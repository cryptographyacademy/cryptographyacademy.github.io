---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/187';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Accelerating ID-based Encryption based on Trapdoor DL using Pre-computation';
const AUTHORS_HTML = 'Hyung Tae Lee, Jung Hee Cheon, Jin Hong';

const CONTENT = `    <p class="text-gray-300">Hyung Tae Lee Jung Hee Cheon Jin Hong</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">The existing identity-based encryption (IBE) schemes based on pairings require pairing computations in encryption or decryption algorithm and it is a burden to each entity which has restricted computing resources in mobile computing environments. An IBE scheme (MY-IBE) based on a trapdoor DL group for RSA setting is one of good alternatives for applying to mobile computing environments. However, it has a drawback for practical use, that the key generation algorithm spends a long time for generating a user’s private key since the key generation center has to solve a discrete logarithm problem.</p>

    <p class="text-gray-300">In this paper, we suggest a method to reduce the key generation time of the MY-IBE scheme, applying modified Pollard rho algorithm using significant pre-computation (mPAP). We also provide a rigorous analysis of the mPAP for more precise estimation of the key generation time and consider the parallelization and applying the tag tracing technique to reduce the wall-clock running time of the key generation algorithm.</p>

    <p class="text-gray-300">Finally, we give a parameter setup method for an efficient key generation algorithm and estimate key generation time for practical parameters from our theoretical analysis and experimental results on small parameters. Our estimation shows that it takes about two minutes using pre-computation for about 50 days with 27 GB storage to generate one user’s private key using the parallelized mPAP enhanced by the tag tracing technique with 100 processors.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">Identity-based Encryption, Trapdoor DL Groups, Discrete Logarithm, Pre-computation.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">In <em>[26]</em>, Shamir suggested the concept of identity-based cryptosystem and proposed identity-based signature schemes. Since then, there have been several proposals <em>[31, 16, 28, 9]</em> to construct an identity-based encryption (IBE) scheme. However, these proposals are not fully satisfactory. Some schemes require the condition that users cannot collude for the security and other schemes spend a long time to generate a user’s private key. Later, the first sufficiently secure and efficient IBE scheme was proposed using pairings by Boneh and Franklin <em>[4]</em>. Since Boneh and Franklin’s construction, many IBE schemes <em>[33, 34, 10, 10]</em> based on pairings have been proposed to enhance the security or efficiency. Also, some IBE schemes <em>[2, 11]</em> based on lattices have been also proposed under the necessary of lattice-based cryptosystems.</p>

    <p class="text-gray-300">However, the existing IBE schemes based on pairings or lattices are not proper on some systems in which each entity has restricted computing resources, such as mobile computing environments. In case of pairing-based IBE schemes, an encryption algorithm or a decryption algorithm requires one or more pairing computations and it spends much computation cost than modular exponentiations over finite fields. Also, although the encryption and decryption</p>

    <p class="text-gray-300">algorithm of lattice-based IBE schemes are more efficient than those of pairing-based IBE schemes, the public key size and private key size of lattice-based IBE schemes are quite large to utilize in mobile entities.</p>

    <p class="text-gray-300">Among previous IBE schemes, Maurer and Yacobi’s suggestion is one of good alternatives for applying to mobile computing environments. In <em>[16]</em>, the authors proposed a non-interactive key distribution (NIKD) algorithm based on a trapdoor DL group which is a maximal cyclic subgroup <span class="math">G</span> of <span class="math">\\mathbf{Z}_{N}^{<em>}</span> where an integer <span class="math">N</span> is hard to factor. Also the authors provided the IBE (MY-IBE) scheme from their NIKD algorithm. The most hard computation in encryption and decryption algorithms of the MY-IBE scheme is a modular exponentiation in <span class="math">\\mathbf{Z}_{N}^{</em>}</span> and the user’s private key consists of one element less than <span class="math">N</span>, hence, they are no burden for a mobile entity.</p>

    <p class="text-gray-300">However, the MY-IBE scheme has some problems for practical use. First, the security proof of the MY-IBE scheme is insufficient to formal security notion of IBE schemes, provided in <em>[4]</em>. Second, there are no secure full domain hash functions into a maximal cyclic subgroup <span class="math">G</span> of <span class="math">\\mathbf{Z}_{N}^{*}</span>. Moreover, the most serious obstacle for practical use of the MY-IBE scheme is that the key generation time is quite long since the key generation center (KGC) has to solve a discrete logarithm problem (DLP) in <span class="math">G</span> for generating a private key of a user.</p>

    <p class="text-gray-300">Later, Paterson and Srinivasan resolved the above three problems. In <em>[20]</em>, they proposed a full domain hash function into <span class="math">G</span> and proved the security of the proposed hash function. Then, they refined the MY-IBE scheme using their hash function and provided the security proof of the refined MY-IBE scheme based on the formal security definition of IBE schemes. Finally, they suggested that the use of the index calculus algorithm with significant pre-computation to reduce the key generation time. However, although KGC utilizes the index calculus algorithm with significant pre-computed data, there are no known concrete methods reducing DLP solving time and we cannot estimate the expected key generation time and required resources such as the amount of memory and the number of processors.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Our Contribution</h3>

    <p class="text-gray-300">The authors in <em>[20]</em> noted that there were no proper variants of the Pollard rho algorithm <em>[23]</em> using pre-computation. However there have been some proposals <em>[12, 14]</em> to reduce DLP solving time, modifying the parallelized Pollard rho algorithm <em>[32]</em> using pre-computation. In this paper, we suggest the method to reduce the key generation time of the MY-IBE scheme applying a modified Pollard rho algorithm using pre-computation (mPAP).</p>

    <p class="text-gray-300">Moreover, although there have been some complexity analyses <em>[12, 14]</em> related to the mPAP, they did not give precise relations between the required memory size, the pre-computation time and the online time. Especially, all previous analyses did not provide concrete required memory size in the mPAP. Hence, one cannot precisely estimate the required memory size of the MY-IBE scheme with respect to DLP solving time in the practical system. In this paper, we provide more rigorous complexity analysis of the mPAP including relations between the amount of pre-computation, online computation and the memory size and give experimental results of the mPAP on small parameters.</p>

    <p class="text-gray-300">Also, we discuss about two extensions for reducing the wall-clock running time of the online phase in the mPAP. First, we consider the possibility of the parallelization of the mPAP and provide the complexity analysis of the parallelized mPAP. According to our analysis, while the pre-computation phase of the mPAP can trivially be parallelized with speedup linear in the number of processors, the online phase of the mPAP can be parallelized with linear increments of storage for speedup linear in the number of processors. Second, we consider applying the tag tracing technique <em>[7]</em> to the mPAP for solving DLPs over a finite field. From experimental results, we confirm that the tag tracing technique works well with the mPAP.</p>

    <p class="text-gray-300">Lastly, we suggest a parameter setup method for reducing key generation time with maintaining security level and estimate the key generation time and the memory size of the MY-IBE scheme in the practical system from our theoretical analysis and implementation results on small parameters. According to our estimation on parameters for <span class="math">2^{80}</span> security, the parallelized mPAP enhanced by the tag tracing technique <em>[7]</em> requires about one minutes and 46 seconds with 100 processors when 100 processors are used for pre-computation for about 50 days with 27 GB storage. Since the key generation process is performed by the key generation center, 100 processors are quite practical.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Organization</h3>

    <p class="text-gray-300">We introduce the MY-IBE scheme and give some related works on DL algorithm using pre-computation in Section 2. Section 3 describes the mPAP and provides more rigorous complexity analysis of the algorithm. We also give experimental results on small parameters and consider the parallelization and applying the tag tracing technique. In Section 4, we suggest a parameter setup method for reducing key generation time and estimate the key generation time of the MY-IBE scheme from our theoretical analysis and experimental results on small parameters.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section, we introduce an identity-based encryption scheme (MY-IBE) based on trapdoor DL groups for RSA setting, proposed by Maurer and Yacobi <em>[16]</em> and refined by Paterson and Srinivasan <em>[20]</em>.</p>

    <p class="text-gray-300">The key generation center has to solve one DLP in the key generation algorithm of the MY-IBE scheme and it takes a long time for practical use. To reduce the key generation time the authors of <em>[20]</em> suggested the re-use of significant pre-computed elements for solving previous DLPs. However, their suggestion was not enough to make the MY-IBE scheme practical for real systems. At the end, we briefly introduce related works on our suggestion to solve DLPs using significant pre-computation, which is a modification of the parallelized Pollard rho algorithm <em>[32]</em>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Identity-based Encryption based on Trapdoor DL</h3>

    <p class="text-gray-300">First, we define trapdoor DL groups and trapdoor DL group generators.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1 ( <em>[8]</em> ).</h6>

    <p class="text-gray-300">We define the two following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TDLGen : a polynomial-time algorithm which takes as input a security parameter <span class="math">\\lambda</span> and outputs a finite cyclic group <span class="math">G</span>, a generator <span class="math">g</span> of <span class="math">G</span> and its trapdoor information <span class="math">\\tau</span>.</li>

      <li>SolveTDL : a polynomial-time algorithm which takes as input a finite cyclic group <span class="math">G</span>, a generator <span class="math">g</span> of <span class="math">G</span>, a trapdoor information <span class="math">\\tau</span> and a target element <span class="math">h</span> of a DLP and outputs the DL of <span class="math">h</span> based on <span class="math">g</span>.</li>

    </ul>

    <p class="text-gray-300">We also define a polynomial-time algorithm Gen which takes as input a security parameter <span class="math">\\lambda</span>, runs TDLGen(<span class="math">\\lambda</span>) algorithm and then outputs <span class="math">(G,g)</span>. If <span class="math">(G,g,\\tau)</span> is an output of TDLGen and a DLP over <span class="math">G</span> is hard for the output of Gen, we call <span class="math">G</span> a trapdoor DL group.</p>

    <p class="text-gray-300">As examples of trapdoor DL groups, one considers a maximal cyclic subgroup <span class="math">G</span> of <span class="math">\\mathbf{Z}_{N}^{<em>}</span> where <span class="math">N</span> is a product of primes and its trapdoor information is the factorization of <span class="math">N</span> </em>[16]<em>. Then one who knows a factorization of <span class="math">N</span> can efficiently solve a DLP over <span class="math">G</span> using Index Calculus algorithm or Pohllig-Hellman algorithm with Pollard rho algorithm. However, if <span class="math">N</span> is a product of more than three primes, there are no secure full domain hash function into <span class="math">G</span>. Also, one may consider trapdoor DL groups over an elliptic curve <span class="math">E(\\mathbf{F}_{2^{161}})</span>, whose trapdoor information are isogenies </em>[30]*. But an elliptic curve <span class="math">E(\\mathbf{F}_{2^{161}})</span> is the only currently known possible parameter and it is not yet known how to generalize construction to higher security level.</p>

    <p class="text-gray-300">In this paper, among these trapdoor DL groups, we will only deal with a maximal cyclic subgroup <span class="math">G</span> of <span class="math">\\mathbf{Z}_{N}^{*}</span> where <span class="math">N</span> is a product of two primes <span class="math">p,q</span> that are roughly the same size and satisfy <span class="math">p\\equiv 3\\pmod{4}</span>, <span class="math">q\\equiv 1\\pmod{4}</span>, and <span class="math">p-1,q-1</span> are <span class="math">B</span>-smooth integers.</p>

    <p class="text-gray-300">Note that TDLGen and SolveTDL are both polynomial-time algorithms in the above definition. To our knowledge, there are no polynomial-time algorithms to solve a DLP in a maximal cyclic subgroup <span class="math">G</span> of <span class="math">\\mathbf{Z}_{N}^{*}</span> although the trapdoor information is given. Hence, the above group <span class="math">G</span> does not satisfy the definition of trapdoor DL groups. However, there are some algorithms to solve DLP over <span class="math">G</span>, whose complexity is sub-exponential or exponential in the security parameter <span class="math">\\lambda</span> but it is quite practical. Hence, we will apply the definition of SolveTDL relaxedly.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Identity-based Encryption based on trapdoor DL groups</h4>

    <p class="text-gray-300">In <em>[16]</em>, Maurer and Yacobi proposed an IBE scheme based on a trapdoor DL group <span class="math">G</span> which is a maximal cyclic subgroup of <span class="math">\\mathbf{Z}_{N}^{<em>}</span> where <span class="math">N</span> is a product of primes and whose trapdoor information is a factorization of <span class="math">N</span>. However, when <span class="math">N</span> is a product of more than three primes, the authors could not give an efficient full domain hash function from a set <span class="math">\\{0,1\\}^{</em>}</span> to <span class="math">G</span>. Also, although they presented two efficient full domain hash functions from <span class="math">\\{0,1\\}^{<em>}</span> to <span class="math">G</span> when <span class="math">N</span> is a product of two primes, it was proved that their suggestions were not secure </em>[15, 17, 18, 19]<em>. In </em>[19]*, the authors presented another full domain hash function into <span class="math">G</span>, however they did not give a security proof of the presented hash function.</p>

    <p class="text-gray-300">Later, Paterson and Srinivasan <em>[20]</em> provided a security proof of a full domain hash function presented in <em>[19]</em>. Based on this full domain hash function, they provided the IND-ID-CPA se</p>

    <p class="text-gray-300">cure IBE scheme based on the security notion in <em>[4]</em>. Here, we present the MY-IBE scheme modified by Paterson and Srinivasan. The scheme consists of four algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(\\lambda)</span>: this algorithm runs <span class="math">\\mathsf{TDLGen}</span> algorithm to obtain <span class="math">(G,g,\\tau)</span> where <span class="math">G</span> is a maximal cyclic subgroup of <span class="math">\\mathbf{Z}_{N}^{<em>}</span>, <span class="math">g</span> is a generator of <span class="math">G</span> and trapdoor information <span class="math">\\tau</span> which is a factorization of <span class="math">N</span>. (We assume that <span class="math">N</span> is a product of two primes that are roughly the same size and satisfy <span class="math">p\\equiv 3\\pmod{4}</span>, <span class="math">q\\equiv 1\\pmod{4}</span> and <span class="math">\\gcd(p-1,q-1)=2</span>.) Let <span class="math">H</span> be a hash function from <span class="math">\\{0,1\\}^{</em>}</span> to <span class="math">\\mathbf{Z}_{N}</span> and define <span class="math">H_{1}:\\{0,1\\}^{*}\\to G</span> by</li>

    </ul>

    <p class="text-gray-300"><span class="math">H_{1}(\\mathsf{ID})=\\left(\\frac{H(\\mathsf{ID})}{N}\\right)H(\\mathsf{ID})</span></p>

    <p class="text-gray-300">where <span class="math">\\left(\\frac{x}{N}\\right)</span> denotes the Jacobi symbol. Let <span class="math">H_{2}:G\\to\\{0,1\\}^{\\ell}</span> be a hash function where <span class="math">\\ell</span> is the bit size of messages. Then this algorithm outputs</p>

    <p class="text-gray-300"><span class="math">\\mathsf{params}=(\\lambda,G,N,g,H,H_{1},H_{2},\\ell)</span> <span class="math">\\mathsf{msk}=\\tau=(p,q).</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KeyGen}(\\mathsf{params},\\mathsf{msk},\\mathsf{ID})</span>: this algorithm computes <span class="math">H_{1}(\\mathsf{ID})</span>. Then it runs <span class="math">\\mathsf{SolveTDL}(G,g,\\tau,H_{1}(\\mathsf{ID}))</span> and obtains the private key <span class="math">\\mathsf{s_{ID}}</span> such that <span class="math">g^{\\mathsf{s_{ID}}}=H_{1}(\\mathsf{ID})</span>. It outputs <span class="math">\\mathsf{s_{ID}}</span>.</li>

      <li><span class="math">\\mathsf{Encrypt}(\\mathsf{params},\\mathsf{ID},M)</span>: this algorithm computes <span class="math">H_{1}(\\mathsf{ID})</span> and chooses <span class="math">r\\in\\mathbf{Z}_{N}</span> uniformly at random. Then it outputs <span class="math">C=(U,V)</span> where <span class="math">U=g^{r}</span> and <span class="math">V=M\\oplus H_{2}(H_{1}(\\mathsf{ID})^{r})</span>.</li>

      <li><span class="math">\\mathsf{Decrypt}(\\mathsf{params},\\mathsf{s_{ID}},C)</span>: for a ciphertext <span class="math">C=(U,V)</span>, this algorithm outputs <span class="math">M^{\\prime}=V\\oplus H_{2}(U^{\\mathsf{s_{ID}}})</span>.</li>

    </ul>

    <p class="text-gray-300">Note that the above scheme is <span class="math">\\mathsf{IND}</span>-<span class="math">\\mathsf{ID}</span>-<span class="math">\\mathsf{CPA}</span> secure under the CDH assumption and one-wayness of the hash function <span class="math">H_{1}</span>. Also the CDH problem in the above group <span class="math">G</span> is at least hard to factor <span class="math">N</span>. Therefore, the above scheme is <span class="math">\\mathsf{IND}</span>-<span class="math">\\mathsf{ID}</span>-<span class="math">\\mathsf{CPA}</span> secure if factoring <span class="math">N</span> is hard.</p>

    <p class="text-gray-300">Although the encryption and decryption algorithms are efficient since those require two and one modular exponentiation, respectively, KGC has to solve one DLP over <span class="math">G</span> to generate the private key for one user. Hence, the weak point of the above scheme is to spend a long time in the key generation algorithm. To overcome this obstacle, the authors in <em>[20]</em> suggested the use of the index calculus algorithm with a large amount of pre-computation.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.2 Discrete Logarithm Algorithm using Pre-computation</h3>

    <p class="text-gray-300">To reduce key generation time in <span class="math">\\mathsf{KeyGen}</span> algorithm of the MY-IBE scheme, the authors in <em>[20]</em> suggested the use of the index calculus algorithm <em>[1]</em> with significant pre-computation over <span class="math">\\mathbf{Z}_{p}</span> and <span class="math">\\mathbf{Z}_{q}</span> for solving a DLP in a maximal cyclic subgroup <span class="math">G</span> of <span class="math">\\mathbf{Z}_{N}^{*}</span> where <span class="math">N=pq</span> and <span class="math">p,q</span> are primes. The index calculus algorithm for solving DLPs divides into two parts, the pre-computation phase and the online phase. In the pre-computation phase, when the cyclic group <span class="math">G</span> and a generator <span class="math">g</span> are given, one computes DLs of all elements in the factor base <span class="math">\\mathcal{B}</span>. Then in the online phase, one finds some relations between the target element of the</p>

    <p class="text-gray-300">DLP and elements in the factor base <span class="math">\\mathcal{B}</span> and then solves the DLP using DLs of elements in the factor base <span class="math">\\mathcal{B}</span>, which are pre-computed in the pre-computation phase.</p>

    <p class="text-gray-300">However, the complexity of the online phase is the same with the complexity of the pre-computation phase in the original index calculus algorithm. Hence, it also requires a large amount of computations for the online phase. For achieving 80-bit security, we assume that the bit size of <span class="math">p</span> and <span class="math">q</span> is 512. Then, according to the analysis of the number field sieve method <em>[6]</em> which is a variant of the index calculus algorithm, it is required about <span class="math">O(2^{78.04})</span> multiplications in <span class="math">\\mathbf{Z}_{p}</span> and <span class="math">\\mathbf{Z}_{q}</span> in the online phase and hence it is impractical to realize in the system.</p>

    <p class="text-gray-300">To make the MY-IBE scheme more practical, we will propose the use of the Pohlig-Hellman algorithm and the modified Pollard rho algorithm with a large amount of pre-computation. In <em>[20]</em>, the authors noted that there were no proper algorithms to solve DLPs using the Pollard rho algorithm with pre-computation. However, there have been some modified Pollard rho algorithms <em>[12, 14]</em> to solve a DLP efficiently using pre-computation. In <em>[14]</em>, the authors provided the algorithm for solving multiple DLPs using elements which were computed for solving previous DLPs, modifying the parallelized Pollard rho algorithm <em>[32]</em>. Then the authors in <em>[12]</em> modified the above multiple DLPs solving algorithm to the DLP solving algorithm with pre-computation, by solving randomly generated DLPs before the target element of the original DLP is given.</p>

    <p class="text-gray-300">In the rest of this section, we introduce some basic concepts, <span class="math">r</span>-adding walk iterating function and distinguished point (DP) collision detection method, which are composing variants of Pollard rho algorithm.</p>

    <p class="text-gray-300">When <span class="math">G</span> is a cyclic group of order <span class="math">q</span> generated by a generator <span class="math">g</span>, if we know the factorization of <span class="math">q=\\prod_{i=1}^{\\ell}p_{i}^{e_{i}}</span> where <span class="math">p_{i}</span>’s are primes, one can reduce the DLP over <span class="math">G</span> to DLPs over a group of order <span class="math">p_{i}</span>’s using the Pohlig-Hellman algorithm. Hence, it is assumed that the group order <span class="math">q</span> is prime from here in this subsection. The group element <span class="math">h</span> denotes the target element of the DLP, in other words, we are looking for the value <span class="math">\\log_{g}h</span>.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6"><span class="math">r</span>-adding walk iteration function</h4>

    <p class="text-gray-300">We briefly look into <span class="math">r</span>-adding walk iterating functions. Partition <span class="math">G</span> into <span class="math">r</span> roughly same sized subsets <span class="math">G_{1},\\cdots,G_{r}</span> so that <span class="math">G=G_{1}\\cup\\cdots\\cup G_{r}</span>. The index function <span class="math">s:G\\to\\{1,2,\\cdots,r\\}</span> is defined to be almost pre-image uniform and efficiently computable. Then choose <span class="math">r</span> pairs <span class="math">(u_{i},v_{i})\\in\\mathbf{Z}_{q}\\times\\mathbf{Z}_{q}</span> and set <span class="math">r</span> multipliers <span class="math">M_{i}</span> to <span class="math">g^{u_{i}}h^{v_{i}}</span>. (In <em>[12]</em>, the authors suggested the use of multipliers which are independent of the target element. Hence we will set multipliers of <span class="math">r</span>-adding walk iterating function in the mPAP to the form <span class="math">g^{u_{i}}h^{0}</span> where <span class="math">u_{i}</span> is a randomly chosen integers in <span class="math">\\mathbf{Z}_{q}</span>.) Define <span class="math">r</span>-adding walk iterating function <span class="math">F_{r}:G\\times\\mathbf{Z}_{q}\\times\\mathbf{Z}_{q}\\to G\\times\\mathbf{Z}_{q}\\times\\mathbf{Z}_{q}</span> by</p>

    <p class="text-gray-300"><span class="math">F_{r}(y,a,b)=(y\\cdot M_{s(y)},a+u_{s(y)},b+v_{s(y)})</span></p>

    <p class="text-gray-300">where <span class="math">y=g^{a}h^{b}</span>. Throughout this paper, <span class="math">F_{r}</span> will denote an <span class="math">r</span>-adding walk iterating function.</p>

    <p class="text-gray-300">It was shown <em>[25]</em> that the expected number of iterations for finding a collision in a walk generated by <span class="math">r</span>-adding walk for <span class="math">r\\geq 8</span> is <span class="math">O(\\sqrt{q})</span>. Experimental results <em>[29]</em> over elliptic curve groups show that the expected number of iterations required to find a collision with 20-adding walk is very close to <span class="math">\\sqrt{\\frac{q}{2}\\pi}</span>, which is that with a random function.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">DP collision detection method</h4>

    <p class="text-gray-300">Let us introduce the DP technique <em>[24]</em>, which was originally used in time memory tradeoff techniques. One sets the distinguishing property that is easy to check and define a DP by a point satisfying the distinguishing property in <span class="math">G</span>. For example, one may define the distinguishing property to be that a certain number of the most significant are all zeros under a fixed encoding of <span class="math">G</span>. One starts with an empty table, and the walk is computed iteratively until the walk encounters a DP. Then one searches for the same point with the occurred DP in the table. If it is not in the table, one stores it and generates another walk. The DP collision detection method is required about <span class="math">t</span> additional iterations for noticing a collision after a collision occurs in a walk when <span class="math">t^{-1}</span> is the proportion of DPs in <span class="math">G</span>. It is straightforward to apply the DP method to multiple walks, so the DP method has an advantage that admits <span class="math">n</span>-times speedup with an <span class="math">n</span>-processor parallelization <em>[32]</em>.</p>

    <h2 id="sec-14" class="text-2xl font-bold">3 Analysis of Discrete Logarithm Algorithm using Pre-computation</h2>

    <p class="text-gray-300">In this section, we describe the mPAP, which is a modification of the parallelized Pollard rho algorithm <em>[32]</em>. Then, we provide more rigorous complexity analysis of the algorithm and give experimental results on small parameters. Finally, we consider two extensions to reduce wall-clock running time of the online phase in the mPAP, the parallelization of the mPAP and applying the tag tracing technique.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.1 Algorithm Description</h3>

    <p class="text-gray-300">Now, we are ready to describe the mPAP, which is a modification of the parallelized Pollard rho algorithm <em>[32]</em>. Our description is modified in three points compared with the algorithm in <em>[12]</em>. First, in the pre-computation phase one generates chains which are started from a random starting point and are ended at a DP, not randomly generating DL instances and solving these DLPs. Second, multipliers of an <span class="math">r</span>-adding walk iterating function are given by a special form. Third, one does not store created DPs in the online phase because its advantage is almost negligible.</p>

    <p class="text-gray-300">Let us describe the mPAP. Choose positive integers <span class="math">m,t</span> such that <span class="math">mt^{2}=\\alpha q</span> where <span class="math">m</span> is the number of generated chains in the pre-computation phase, <span class="math">t^{-1}</span> is the proportion of DPs in the group, and <span class="math">\\alpha</span> is not a large constant. The parameters are assumed not to be extreme, in the sense that <span class="math">1\\ll m,t\\ll q</span> and a typical value is <span class="math">\\alpha\\approx 1</span>. We shall later determine the proper size of parameters <span class="math">m,t,\\alpha</span>. Fix an <span class="math">r</span>-adding walk iterating function <span class="math">F_{r}</span> so that the multipliers have the form <span class="math">g^{u}h^{0}</span> for some random <span class="math">u\\in\\mathbf{Z}_{q}</span>. Since the pre-computation phase starts before a target element is given, the multipliers of the <span class="math">r</span>-adding walk iterating function <span class="math">F_{r}</span> must have the above form. Determine the distinguishing property so that a proportion of distinguished points in <span class="math">G</span> is <span class="math">t^{-1}</span></p>

    <p class="text-gray-300">In the pre-computation phase, one chooses <span class="math">m</span> random starting points <span class="math">\\mathbf{g}_{i,0} = g^{a_{i,0}}h^0\\in G</span> for <span class="math">1\\leq i\\leq m</span> and iteratively computes <span class="math">\\mathbf{g}_{i,j + 1} = F_r(\\mathbf{g}_{i,j})</span>. Each chain is terminated at its first encounter with a DP. We call by a DP chain a chain ended at a DP. Then one stores the occurred DPs and the exponents corresponding to each DP in a DP table DT.</p>

    <p class="text-gray-300">The average number of iterations to generate a DP chain is <span class="math">t</span>, but some of chains may fall into a loop that never reaches a DP. In order to detect a chain falling into an infinite loop, we set a chain length bound <span class="math">\\hat{t}</span>. Any chain longer than this bound is discarded and one can choose to regenerate a chain from a different starting point. Note that the probability for a chain not to reach a DP until its <span class="math">\\hat{t}</span>-th iteration is <span class="math">(1 - \\frac{1}{t})^{\\hat{t} + 1} \\approx \\exp(-\\frac{\\hat{t} + 1}{t})</span>. This shows that setting <span class="math">\\hat{t}</span> to a reasonable multiple of <span class="math">t</span> will suffice in removing the effect of any such discarded chains for any practical purpose.</p>

    <p class="text-gray-300">After the pre-computation phase, one obtains the following matrix.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} _ {1, 0} \\xrightarrow {F _ {r}} \\mathbf {g} _ {1, 1} \\xrightarrow {F _ {r}} \\dots \\dots \\xrightarrow {F _ {r}} \\mathbf {g} _ {1, t _ {1}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} _ {2, 0} \\xrightarrow {F _ {r}} \\mathbf {g} _ {2, 1} \\xrightarrow {F _ {r}} \\dots \\xrightarrow {F _ {r}} \\mathbf {g} _ {2, t _ {2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\vdots \\\\ \\vdots \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} _ {m, 0} \\xrightarrow {F _ {r}} \\mathbf {g} _ {m, 1} \\xrightarrow {F _ {r}} \\dots \\dots \\dots \\xrightarrow {F _ {r}} \\mathbf {g} _ {m, t _ {m}}</span></div>

    <p class="text-gray-300">Such matrix consisting of <span class="math">m</span> DP chains is called the DP matrix.</p>

    <p class="text-gray-300">In the online phase, when a target element <span class="math">h</span> of DLP is given, one starts to generate a DP chain from an element <span class="math">h^r</span> for a random <span class="math">1 \\leq r &amp;lt; q</span>. When a DP occurs in a chain, one compares it with the stored DPs in the table DT. If a collision is not found, one generates another DP chain from a distinct starting point <span class="math">h^{r&#x27;}</span> for a random <span class="math">1 \\leq r&#x27; \\neq r &amp;lt; q</span>. Otherwise, one can get the DL of <span class="math">h</span> from the relation <span class="math">a_i \\equiv x b_j + a_j \\pmod{q}</span> where <span class="math">x</span> is the DL of <span class="math">h</span>, a pair <span class="math">(g_i, a_i, b_i)</span> and <span class="math">(g_j, a_j, b_j)</span> is the collision, <span class="math">(g_i, a_i, b_i)</span> is the stored point in the table DT, and <span class="math">(g_j, a_j, b_j)</span> is the created DP in the online phase.</p>

    <p class="text-gray-300">In the modification of the mPAP described in [12], created DPs in the online phase are also added to the DP table DT. However, unless <span class="math">\\alpha</span> is not extremely small, the number of newly created DPs in the online phase is just one or two. It does not give a big help of accelerating DL computation of a present target element and hence we do not consider saving created DPs in the online phase.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3.2 Complexity Analysis</h2>

    <p class="text-gray-300">The analysis of the mPAP can be inferred from DL algorithm [14] for multiple instances. According to the analysis, the expected number of group operations to solve <span class="math">k</span> DLPs sequentially with their algorithm is about <span class="math">\\sqrt{2kq}</span>. From these results, we simply guess that the expected number of group operations to solve the <span class="math">(k + 1)</span>-th DLP is about <span class="math">\\sqrt{2q} / (\\sqrt{k + 1} + \\sqrt{k}) = \\sqrt{2(k + 1)q} - \\sqrt{2kq}</span> when <span class="math">\\sqrt{2kq}</span> group operations was done in the pre-computation phase since the expected number of group operations to solve <span class="math">k + 1</span> DLPs with their algorithm is about <span class="math">\\sqrt{2(k + 1)q}</span>.</p>

    <p class="text-gray-300">Moreover, Hitchcock et al. <em>[12]</em> provided the expected online time complexity of the mPAP associated with the amount of pre-computation. However, their analysis has two missing points:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Although collisions may occur in the pre-computation phase, it does not consider this fact in their analysis. Hence they regard that the number of distinct elements in a DP matrix is the same with the number of iterations in the pre-computation phase.</li>

      <li>It does not consider the additional iterations to reach a DP for collision detection after a collision occurs in the online phase.</li>

    </ul>

    <p class="text-gray-300">Now, let us correct the complexity of the mPAP. We shall exploit the analysis technique of time-memory tradeoff. Recently, in <em>[13]</em>, the authors gave the expected number of distinct entries in a DP matrix for various <span class="math">\\hat{t}</span>. However, it does not give an error bound of the approximation value. In the following lemma, we present the precise limit value of the expected number of distinct entries in a DP matrix when <span class="math">\\hat{t}</span> is sufficiently large and provide the difference between the limit value and the expected number when we use a specific <span class="math">\\hat{t}</span>. This lemma will make up for the first missing point of the analysis provided by Hitchcock et al.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Consider a DP matrix created with parameters satisfying <span class="math">mt^{2}=\\alpha\\,q</span>. When the iterating function is taken to be the random function and <span class="math">\\hat{t}</span> is sufficiently large, we can expect the DP matrix to contain</p>

    <p class="text-gray-300"><span class="math">\\frac{\\sqrt{1+2\\alpha+O(\\frac{1}{t})}-1}{\\alpha}m(t-1).</span> (1)</p>

    <p class="text-gray-300">distinct entries. Moreover, the difference between the expected number of distinct entries contained in the DP matrix and the above limit value is bounded by <span class="math">m(\\hat{t}+t)\\exp(-\\hat{t}/t)</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We follow the proof of Proposition 10 provided in <em>[13]</em>. Consider a DP matrix generated in the pre-computation phase. Let <span class="math">m_{j}</span> be the number of elements which first appear at <span class="math">j</span>-th column in a DP matrix. Now we assume that chains not reaching a DP until <span class="math">\\hat{t}</span> steps remain on a DP matrix for an analysis and however we will give the error bound considering that these chains are discarded. Then the recurrence relation</p>

    <p class="text-gray-300"><span class="math">\\frac{m_{j}}{q}=\\left(1-\\exp\\left(\\frac{-m_{j-1}}{q}\\right)\\right)\\left(1-\\frac{1}{t}\\right)\\left(1-\\frac{\\sum_{i=0}^{j-1}m_{j}}{q(1-1/t)}\\right)</span></p>

    <p class="text-gray-300">with <span class="math">m_{0}=m</span> is satisfied from Lemma 6 in <em>[13]</em>. Differently from the analysis of <em>[13]</em>, the initial value of the sequence <span class="math">(m_{i})_{i=0}^{\\infty}</span> is <span class="math">m</span> since our DP table are generated from the exact <span class="math">m</span> starting points without making up for the discarded chains to store the exact <span class="math">m</span> DPs in a table.</p>

    <p class="text-gray-300">Let <span class="math">\\mu_{i}=\\frac{m_{i}}{q(1-1/t)}</span> and <span class="math">\\sigma_{j}=\\sum_{i=0}^{j-1}\\mu_{i}</span>. Then the recurrence relation</p>

    <p class="text-gray-300"><span class="math">\\sigma_{j+1}-\\sigma_{j}=\\frac{m_{0}}{q}-\\frac{1}{t}\\sigma_{j}-\\frac{1}{2}\\sigma_{j}^{2}+O\\left(\\frac{1}{t^{3}}\\right)\\ \\ \\text{with}\\ \\ \\sigma_{0}=0</span></p>

    <p class="text-gray-300">is also satisfied from Lemma 7 in [13]. The sequence <span class="math">(\\sigma_j)_{j=0}^{\\infty}</span> is monotone increasing from the definition of the sequence <span class="math">(\\sigma_j)_{j=0}^{\\infty}</span> and all <span class="math">\\sigma_j</span>'s are bounded since the sum <span class="math">\\sum_{i=0}^{\\infty} m_j</span> does not exceed the group order <span class="math">q</span>. Hence the sequence <span class="math">(\\sigma_j)_{j=0}^{\\infty}</span> converges and the limit <span class="math">S</span> of this sequence is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\frac {1}{t} + \\sqrt {\\left(\\frac {1}{t}\\right) ^ {2} + 2 \\left(\\frac {m}{q} + O \\left(\\frac {1}{t ^ {3}}\\right)\\right)}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and all <span class="math">\\sigma_{j}</span>'s are less than <span class="math">S</span>. Therefore, the expected number of distinct entries in a DP table is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {i = 1} ^ {\\infty} m _ {i} = q (1 - 1 / t) \\left(- \\frac {1}{t} + \\sqrt {\\left(\\frac {1}{t}\\right) ^ {2} + 2 \\left(\\frac {m}{q} + O \\left(\\frac {1}{t ^ {3}}\\right)\\right)}\\right) \\quad (2) \\\\ = \\frac {\\sqrt {1 + 2 \\alpha + O \\left(\\frac {1}{t}\\right)} - 1}{\\alpha} m (t - 1). \\quad (3) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">E</span> be the expected number of distinct elements in a DP table that chains whose length exceeds <span class="math">\\hat{t}</span> are discarded. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} E \\leq \\sum_ {i = 1} ^ {\\hat {t}} m _ {j} \\leq q (1 - 1 / t) \\lim _ {j \\to \\infty} \\sigma_ {j} \\\\ = q \\left(1 - 1 / t\\right) S \\leq \\frac {\\sqrt {1 + 2 \\alpha} - 1}{\\alpha} m (t - 1). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Now, we consider the lower bound of <span class="math">E</span>. Note that the probability that a chain reaches a DP at <span class="math">j</span> steps is <span class="math">\\left(1 - \\frac{1}{t}\\right)^{j-1} \\frac{1}{t}</span>. Let <span class="math">E_1</span> be the expected number of entries belonging to the discarded chains. Then the relation <span class="math">E \\geq q(1 - 1/t)S - E_1</span> is satisfied.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} E _ {1} = m \\sum_ {i = \\hat {t}} ^ {\\infty} \\left(1 - \\frac {1}{t}\\right) ^ {i - 1} \\frac {1}{t} i = \\frac {m}{t} \\sum_ {i = \\hat {t}} ^ {\\infty} \\left(1 - \\frac {1}{t}\\right) ^ {i - 1} i \\quad (4) \\\\ = m \\left(\\hat {t} \\left(1 - \\frac {1}{t}\\right) ^ {\\hat {t} - 1} + \\left(1 - \\frac {1}{t}\\right) ^ {\\hat {t}} t\\right) \\quad (5) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">from <span class="math">\\frac{x^{\\hat{t}}}{1 - x} = \\sum_{i = \\hat{t}}^{\\infty}x^{n}</span> and its derivation and</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (5) \\leq \\left(1 - \\frac {1}{t}\\right) ^ {\\hat {t}} \\left(m \\hat {t} - m \\frac {\\hat {t}}{t} + m t\\right) \\\\ \\leq m (\\hat {t} + t) \\exp (- \\hat {t} / t) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">since <span class="math">f(x) = (1 - \\frac{1}{x})^x</span> is an increasing function and <span class="math">\\lim_{x\\to \\infty}f(x) = \\exp (-1)</span>. Hence</p>

    <div class="my-4 text-center"><span class="math-block">E _ {1} \\geq \\frac {\\sqrt {1 + 2 \\alpha} - 1}{\\alpha} m (t - 1) - m (\\hat {t} + t) \\exp (- \\hat {t} / t).</span></div>

    <p class="text-gray-300">Therefore, the difference between the limit value and the number of distinct entries on practical parameters is bounded by <span class="math">m(\\hat{t}+t)\\exp(-\\hat{t}/t)</span>.</p>

    <p class="text-gray-300">Considering the fact that the authors ignored <span class="math">(1-\\frac{1}{t})</span> in the proof of Proposition 10 in <em>[13]</em>, Lemma 1 shows that the exact limit value of the expected number of distinct entries in a DP matrix is the same with the approximation value presented in <em>[13]</em>. Also it shows that the difference between the limit value and the expected number on practical parameters is negligible since <span class="math">m(\\hat{t}+t)\\exp(-\\hat{t}/t)</span> is sufficiently smaller than <span class="math">\\frac{\\sqrt{1+2\\alpha}-1}{\\alpha}\\,m(t-1)</span> when <span class="math">\\hat{t}</span> is sufficiently larger than <span class="math">t</span>.</p>

    <p class="text-gray-300">We are now ready to discuss about the probability for solving a DLP with generating a single DP chain in the online phase.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Fix parameters satisfying <span class="math">mt^{2}=\\alpha\\,q</span> and generate a DP matrix. Then generate another chain from a random starting point, terminating at its first DP occurrence. When the iterating function <span class="math">F</span> is taken to be the random function, we can expect the ending DP of the new chain to be equal to one of the ending DPs for the pre-generated chains with probability</p>

    <p class="text-gray-300"><span class="math">1-\\frac{1}{\\sqrt{1+2\\alpha}},</span></p>

    <p class="text-gray-300">and the error term is bounded by <span class="math">\\frac{7\\alpha}{t}+\\frac{\\alpha}{\\sqrt{1+2\\alpha}}(c+1)\\exp(-c)</span> when <span class="math">\\hat{t}=ct</span> for some constant <span class="math">c</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let us write DP for the set of all DPs in <span class="math">G</span>, DM (DP matrix) for the set of all elements belonging to the pre-generated DP chains, and DT (DP table) for the set of ending points of the pre-generated DP chains.</p>

    <p class="text-gray-300">Once the DP matrix DM is ready, one is told to create a new chain</p>

    <p class="text-gray-300"><span class="math">\\mathbf{h}_{0}\\xrightarrow{F}\\mathbf{h}_{1}\\xrightarrow{F}\\cdots\\xrightarrow{F}\\mathbf{h}_{j}\\xrightarrow{F}\\cdots</span></p>

    <p class="text-gray-300">from a random starting point <span class="math">\\mathbf{h}_{0}</span>. At each iteration, as a new <span class="math">\\mathbf{h}_{j}</span> is created, one of the following three events may occur.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{h}_{j}\\in\\texttt{DM}</span> : The new chain has merged with a pre-generated chain. The rest of the chain will automatically follow the pre-generated chain and terminate with a DP belonging to DT.</li>

      <li><span class="math">\\mathbf{h}_{j}\\in\\texttt{DP}\\setminus\\texttt{DM}=\\texttt{DP}\\setminus\\texttt{DT}</span> : The new chain has terminated with a DP without merging with a pre-generated chain. The chain cannot reach a point belonging to DT.</li>

      <li><span class="math">\\mathbf{h}_{j}\\not\\in\\texttt{DM}\\cup\\texttt{DP}</span> : The new chain has neither merged with one of the pre-generated chains nor reached a DP. One needs to continue onto the next iteration.</li>

    </ol>

    <p class="text-gray-300">Hence the new chain terminates with an element from DT if and only if each iteration of the chain results in event E3, before finally sinking into event E1.</p>

    <p class="text-gray-300">Let <span class="math">\\delta\\ =\\ \\frac{\\sqrt{1+2\\alpha}-1}{\\alpha}\\,m+m(\\hat{t}+t)\\exp(-\\hat{t}/t)+\\frac{mO(1)}{\\alpha(\\sqrt{1+2\\alpha}+\\sqrt{1+2\\alpha+O(\\frac{1}{t})})}</span>. According to Lemma 1, for a random function, we can expect event E1 to happen, at each iteration,</p>

    <p class="text-gray-300">with probability</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathrm{E}1] = \\frac{\\sqrt{1 + 2\\alpha} - 1}{\\alpha} \\frac{mt}{q} + \\frac{\\delta}{q} = \\frac{\\sqrt{1 + 2\\alpha} - 1}{t} + \\frac{\\delta}{q},</span></div>

    <p class="text-gray-300">where the equality follows from a use of <span class="math">mt^2 = \\alpha q</span>. We can also state</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\Pr[\\mathrm{E}3] &amp;amp;= 1 - \\frac{\\#(\\mathrm{DM} \\cup \\mathrm{DP})}{q} = 1 - \\frac{\\#\\mathrm{DM} + \\#\\mathrm{DP} - \\#(\\mathrm{DM} \\cap \\mathrm{DP})}{q} \\\\ &amp;amp;= 1 - \\frac{\\frac{q}{t} + \\frac{\\sqrt{1 + 2\\alpha} - 1}{\\alpha} mt}{q} + \\epsilon \\\\ &amp;amp;= 1 - \\frac{\\sqrt{1 + 2\\alpha}}{t} + \\epsilon \\\\ \\end{aligned}</span></div>

    <p class="text-gray-300">as the probability for event E3's occurrence when <span class="math">\\epsilon</span> is <span class="math">\\frac{\\#(\\mathrm{DM} \\cap \\mathrm{DP})}{q} - \\frac{\\delta}{q^2} \\leq \\frac{m}{q}</span>.</p>

    <p class="text-gray-300">Finally, gathering the above information and argument, we can compute the probability for the new chain to terminate at an element of DT to be</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sum_{k=0}^{\\infty} \\left(1 - \\frac{\\sqrt{1 + 2\\alpha}}{t} + \\epsilon\\right)^k \\left(\\frac{\\sqrt{1 + 2\\alpha} - 1}{t} + \\frac{\\delta}{q}\\right) \\\\ = 1 - \\frac{1 - t\\epsilon}{\\sqrt{1 + 2\\alpha} + t\\epsilon} + \\frac{\\alpha\\sqrt{1 + 2\\alpha} + \\alpha\\delta}{mt(\\sqrt{1 + 2\\alpha} + \\epsilon)} \\\\ \\approx 1 - \\frac{1}{\\sqrt{1 + 2\\alpha}}. \\end{aligned}</span></div>

    <p class="text-gray-300">When <span class="math">\\hat{t} = ct</span> for some constant <span class="math">c</span>, the error term of the last approximation is bounded by <span class="math">2t\\epsilon + \\frac{5\\alpha}{\\hat{t}} + \\frac{\\alpha}{\\sqrt{1 + 2\\alpha}} (c + 1)\\exp(-c) &amp;lt; \\frac{7\\alpha}{\\hat{t}} + \\frac{\\alpha}{\\sqrt{1 + 2\\alpha}} (c + 1)\\exp(-c)</span>.</p>

    <p class="text-gray-300">Those familiar with time-memory tradeoff techniques can interpret this theorem as giving the probability of false alarms occurrence³ during the processing of a single non-perfect DP table. This high probability is an annoyance in the time-memory tradeoff. While every collision of the online DP chain with the pre-computed table will always bring about a solution to the DLP since the <span class="math">r</span>-adding walk does not modify the exponent of <span class="math">h</span>. Hence this high probability is a good thing for DLP solving.</p>

    <p class="text-gray-300">Execution Complexity As given by Theorem 1, the mPAP succeeds using a single online DP chain with probability <span class="math">1 - \\frac{1}{\\sqrt{1 + 2\\alpha}}</span>. Taking the inverse of this value, we can state the expected number of online DP chain creations until successful DL retrieval to be <span class="math">\\frac{\\sqrt{1 + 2\\alpha}}{\\sqrt{1 + 2\\alpha} - 1}</span>. Since</p>

    <p class="text-gray-300">³ One should consider whether allowing the starting point to be the ending point will produce any difference in the final result.</p>

    <p class="text-gray-300">⁴ Although we consider the online time complexity with the error term of probability in Theorem 1, that increases less than <span class="math">\\frac{7(\\sqrt{1 + 2\\alpha} + 1)^3}{4\\alpha} + \\frac{(\\sqrt{1 + 2\\alpha} + 1)^2}{2} (c + 1)\\exp(-c)t</span>, i.e., <span class="math">T &amp;lt; \\frac{\\sqrt{1 + 2\\alpha}}{\\sqrt{1 + 2\\alpha} - 1} t + \\frac{7(\\sqrt{1 + 2\\alpha} + 1)^3}{4\\alpha} + \\frac{(\\sqrt{1 + 2\\alpha} + 1)^2}{2} (c + 1)\\exp(-c)t</span>. This error comes from setting the chain length bound <span class="math">\\hat{t}</span>. However, since <span class="math">t</span> is sufficiently large and <span class="math">(c + 1)\\exp(-c)</span> is sufficiently smaller than <span class="math">t</span>, we ignore this error on our analysis.</p>

    <p class="text-gray-300">the average length of a DP chain is <span class="math">t</span>, we can state the expected online time complexity <span class="math">T</span>, storage complexity <span class="math">M</span>, and the pre-computation time complexity <span class="math">P</span> as</p>

    <p class="text-gray-300"><span class="math">T\\approx\\frac{\\sqrt{1+2\\alpha}}{\\sqrt{1+2\\alpha}-1}\\;t,\\quad M\\approx m,\\quad\\text{and}\\quad P=mt.</span> (6)</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">3.2.2 Tradeoff Curve</h4>

    <p class="text-gray-300">Using the equation <span class="math">mt^{2}=\\alpha\\,q</span>, we obtain</p>

    <p class="text-gray-300"><span class="math">P\\,T\\approx\\frac{\\alpha\\sqrt{1+2\\alpha}}{\\sqrt{1+2\\alpha}-1}\\;q.</span> (7)</p>

    <p class="text-gray-300">This shows that any increase in pre-computation is awarded by a corresponding decrease in online time. Interpretation of the following equations give us more detail.</p>

    <p class="text-gray-300"><span class="math">\\sqrt{M}\\,T\\approx\\frac{\\sqrt{\\alpha}\\sqrt{1+2\\alpha}}{\\sqrt{1+2\\alpha}-1}\\;\\sqrt{q}\\quad\\text{and}\\quad P\\approx\\sqrt{\\alpha}\\,\\sqrt{M}\\sqrt{q}.</span> (8)</p>

    <p class="text-gray-300">With minimal storage, the expected pre-computation and online time are both <span class="math">O(\\sqrt{q})</span>. By utilizing a storage of size <span class="math">M</span>, we can reduce online time by a factor of <span class="math">\\sqrt{M}</span> at the price of a <span class="math">\\sqrt{M}</span> factor increase in pre-computation time.</p>

    <p class="text-gray-300">Note that for any fixed <span class="math">q</span>, the right-side of tradeoff curve between storage and online time is optimal when the constant <span class="math">\\frac{\\sqrt{\\alpha}\\sqrt{1+2\\alpha}}{\\sqrt{1+2\\alpha}-1}</span> is at its minimum. Explicitly, one can show that the minimum value of 2.35480 is attained at <span class="math">\\alpha=\\frac{1+\\sqrt{5}}{4}\\approx 0.809017</span>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.3 Experiments</h3>

    <p class="text-gray-300">We have tested the complexity analysis of the mPAP by running it with small parameters. This was implemented on a dual-core AMD Opteron 2.6 GHz system and the NTL library <em>[27]</em> was used to provide the required finite field arithmetics. Throughout the test, the cyclic group <span class="math">G=\\langle g\\rangle</span> was taken to be a subgroup of <span class="math">\\mathbf{Z}_{p}^{\\ast}</span>, where <span class="math">p</span> was taken to be a random 1024-bit prime. The 20-adding walk served as the iterating function. As is customary in time memory tradeoff tables, sequential points <span class="math">g^{1},g^{2},\\ldots,g^{m}</span> were used in place of the <span class="math">m</span> random points to simplify implementation. Likewise, the first online chain started from DLP target <span class="math">h</span> and sequential powers of <span class="math">h</span> were used thereafter. The chain length bound was set to <span class="math">10t</span> to detect random walks that fell into loops without reaching a DP. Chains were not regenerated to replace the discarded chain.</p>

    <p class="text-gray-300">In Table 1, we compare our theory against experiment results under variations of <span class="math">\\alpha</span>. The success probability entries test the validity of Theorem 1 and the last two rows of the table test the <span class="math">T</span> value as given by (6).</p>

    <p class="text-gray-300">Table 2 shows a similar comparison under a fixed <span class="math">\\alpha</span> and varying <span class="math">m</span> and <span class="math">t</span> parameters. This table gives an indication of how well the relation (8) is observed, i.e., whether the increase in storage results in the predicted reduction of online time complexity.</p>

    <p class="text-gray-300">Table 1. Online phase success probability and complexity for various  <span class="math">\\alpha</span>  (  <span class="math">q</span>  : 42-bit prime,  <span class="math">t = {2}^{14}</span>  )</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.001</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.01</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.81</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">success probability at 1st chain (%)</td>

            <td class="px-3 py-2 border-b border-gray-700">experiment</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10</td>

            <td class="px-3 py-2 border-b border-gray-700">1.30</td>

            <td class="px-3 py-2 border-b border-gray-700">28.10</td>

            <td class="px-3 py-2 border-b border-gray-700">37.50</td>

            <td class="px-3 py-2 border-b border-gray-700">38.10</td>

            <td class="px-3 py-2 border-b border-gray-700">48.10</td>

            <td class="px-3 py-2 border-b border-gray-700">54.10</td>

            <td class="px-3 py-2 border-b border-gray-700">76.90</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">theory</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10</td>

            <td class="px-3 py-2 border-b border-gray-700">0.99</td>

            <td class="px-3 py-2 border-b border-gray-700">29.29</td>

            <td class="px-3 py-2 border-b border-gray-700">38.22</td>

            <td class="px-3 py-2 border-b border-gray-700">42.26</td>

            <td class="px-3 py-2 border-b border-gray-700">50.00</td>

            <td class="px-3 py-2 border-b border-gray-700">55.28</td>

            <td class="px-3 py-2 border-b border-gray-700">78.18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">success probability at 2nd chain (%)</td>

            <td class="px-3 py-2 border-b border-gray-700">experiment</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00</td>

            <td class="px-3 py-2 border-b border-gray-700">0.70</td>

            <td class="px-3 py-2 border-b border-gray-700">21.50</td>

            <td class="px-3 py-2 border-b border-gray-700">24.10</td>

            <td class="px-3 py-2 border-b border-gray-700">25.80</td>

            <td class="px-3 py-2 border-b border-gray-700">24.80</td>

            <td class="px-3 py-2 border-b border-gray-700">23.80</td>

            <td class="px-3 py-2 border-b border-gray-700">17.40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">theory</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10</td>

            <td class="px-3 py-2 border-b border-gray-700">0.98</td>

            <td class="px-3 py-2 border-b border-gray-700">20.71</td>

            <td class="px-3 py-2 border-b border-gray-700">23.61</td>

            <td class="px-3 py-2 border-b border-gray-700">24.40</td>

            <td class="px-3 py-2 border-b border-gray-700">25.00</td>

            <td class="px-3 py-2 border-b border-gray-700">24.72</td>

            <td class="px-3 py-2 border-b border-gray-700">17.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">average iterations until solution (unit:t)</td>

            <td class="px-3 py-2 border-b border-gray-700">experiment</td>

            <td class="px-3 py-2 border-b border-gray-700">1085.7</td>

            <td class="px-3 py-2 border-b border-gray-700">99.37</td>

            <td class="px-3 py-2 border-b border-gray-700">3.46</td>

            <td class="px-3 py-2 border-b border-gray-700">2.62</td>

            <td class="px-3 py-2 border-b border-gray-700">2.51</td>

            <td class="px-3 py-2 border-b border-gray-700">2.00</td>

            <td class="px-3 py-2 border-b border-gray-700">1.87</td>

            <td class="px-3 py-2 border-b border-gray-700">1.33</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">theory</td>

            <td class="px-3 py-2 border-b border-gray-700">1001.5</td>

            <td class="px-3 py-2 border-b border-gray-700">101.50</td>

            <td class="px-3 py-2 border-b border-gray-700">3.41</td>

            <td class="px-3 py-2 border-b border-gray-700">2.62</td>

            <td class="px-3 py-2 border-b border-gray-700">2.37</td>

            <td class="px-3 py-2 border-b border-gray-700">2.00</td>

            <td class="px-3 py-2 border-b border-gray-700">1.81</td>

            <td class="px-3 py-2 border-b border-gray-700">1.28</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Online phase success probability and complexity for various  <span class="math">m</span>  and  <span class="math">t\\left( {q : {42}\\text{ bits prime,}\\alpha  = {0.81}}\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">17</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">theory</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">46121039</td>

            <td class="px-3 py-2 border-b border-gray-700">586463</td>

            <td class="px-3 py-2 border-b border-gray-700">12564</td>

            <td class="px-3 py-2 border-b border-gray-700">207</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">storage size (MB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">11806.986</td>

            <td class="px-3 py-2 border-b border-gray-700">150.135</td>

            <td class="px-3 py-2 border-b border-gray-700">3.216</td>

            <td class="px-3 py-2 border-b border-gray-700">0.053</td>

            <td class="px-3 py-2 border-b border-gray-700">0.001</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">success probability (%)</td>

            <td class="px-3 py-2 border-b border-gray-700">1st chain</td>

            <td class="px-3 py-2 border-b border-gray-700">36.90</td>

            <td class="px-3 py-2 border-b border-gray-700">33.80</td>

            <td class="px-3 py-2 border-b border-gray-700">37.50</td>

            <td class="px-3 py-2 border-b border-gray-700">37.60</td>

            <td class="px-3 py-2 border-b border-gray-700">24.50</td>

            <td class="px-3 py-2 border-b border-gray-700">38.22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2nd chain</td>

            <td class="px-3 py-2 border-b border-gray-700">23.00</td>

            <td class="px-3 py-2 border-b border-gray-700">25.50</td>

            <td class="px-3 py-2 border-b border-gray-700">24.10</td>

            <td class="px-3 py-2 border-b border-gray-700">22.30</td>

            <td class="px-3 py-2 border-b border-gray-700">16.40</td>

            <td class="px-3 py-2 border-b border-gray-700">23.61</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ave. iterations until solution (unit: t)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.70</td>

            <td class="px-3 py-2 border-b border-gray-700">2.65</td>

            <td class="px-3 py-2 border-b border-gray-700">2.62</td>

            <td class="px-3 py-2 border-b border-gray-700">2.78</td>

            <td class="px-3 py-2 border-b border-gray-700">15.30</td>

            <td class="px-3 py-2 border-b border-gray-700">2.62</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Test results given above are average values done over multiple table creations and multiple DLP target solving per created table. Each pre-computation table on experiments was created with a different random multiplier set for the 20-adding walk. All tests used 10 tables and 100 DLPs per table.</p>

    <p class="text-gray-300">The implementation results support our theoretic analysis very well for a wide range of parameters. The only visible exception corresponds to when  <span class="math">m</span>  is extremely small. In this case the expected DP chain length approaches the expected rho length of a random walk and thus too many chains are being discarded. Unlike the small  <span class="math">m</span>  case, the results for large  <span class="math">m</span>  follows the theory closely. This implies that the mPAP will work well even when extremely large storage is employed.</p>

    <p class="text-gray-300">The pre-computation phase of the mPAP can trivially be parallelized. While pre-computation is certainly the computationally intensive part of the mPAP, there may be situations where the parallelization of the online phase is desired, possibly to reduce the wall-clock running time of the online algorithm further. Let us investigate this matter in this subsection.</p>

    <p class="text-gray-300">Readers familiar with time-memory tradeoff techniques will have read the previous material with  <span class="math">\\alpha \\approx 1</span>  in their minds, but one can confirm through a careful re-reading of all proofs that everything we wrote is true for even extremely small  <span class="math">\\alpha</span> .</p>

    <p class="text-gray-300">With Theorem 1 confirmed for small  <span class="math">\\alpha</span> , let us consider the parallel use of  <span class="math">n</span>  processors at the online phase. We take parameters  <span class="math">m</span>  and  <span class="math">t</span>  such that  <span class="math">mt^2 = \\frac{\\alpha}{n} q</span> , where  <span class="math">\\alpha \\approx 1</span> . Then, based on Theorem 1, one can state that the probability of success at the first run of the online phase, i.e., after the  <span class="math">n</span>  DP chains have been produced, is  <span class="math">1 - \\left(\\frac{1}{1 + 2\\alpha / n}\\right)^{n / 2}</span> . Inverting this, we</p>

    <p class="text-gray-300">can state</p>

    <p class="text-gray-300"><span class="math">T_{1/n}\\approx\\Big{\\{}1+\\frac{1}{(1+\\frac{2\\alpha}{n})^{\\frac{n}{2}}-1}\\Big{\\}}\\,t</span></p>

    <p class="text-gray-300">as the average time spent by each processor, until the DLP is solved. As before, we require <span class="math">M\\approx m</span> storage and <span class="math">P=mt</span> pre-computation time.</p>

    <p class="text-gray-300">Applying the equation <span class="math">mt^{2}=\\frac{\\alpha}{n}\\,q</span>, we can write the analogue to equation (7) as follows.</p>

    <p class="text-gray-300"><span class="math">P\\,T_{1/n}\\approx\\frac{\\alpha}{n}\\,\\Big{\\{}1+\\frac{1}{(1+\\frac{2\\alpha}{n})^{\\frac{n}{2}}-1}\\Big{\\}}\\,q.</span> (9)</p>

    <p class="text-gray-300">It is easy to check that <span class="math">1+\\frac{1}{e^{\\alpha}-1}\\leq 1+\\frac{1}{(1+2\\alpha/n)^{n/2}-1}\\leq 1+\\frac{1}{\\sqrt{1+2\\alpha}-1}</span>, so that we can treat the term inclosed between the braces as an insignificant constant. Noting that <span class="math">n\\,T_{1/n}</span> is the total online processing time, one can see that (9) is almost identical to (7). In other words, regardless of parallelization, with the same pre-computation effort, one needs the same total online processor time to solve a given DLP.</p>

    <p class="text-gray-300">Analogue of (8) is as follows.</p>

    <p class="text-gray-300"><span class="math">\\sqrt{M}\\,T_{1/n}\\approx\\sqrt{\\frac{\\alpha}{n}}\\,\\left\\{1+\\frac{1}{(1+\\frac{2\\alpha}{n})^{\\frac{n}{2}}-1}\\right\\}\\sqrt{q}</span> (10)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">P\\approx\\sqrt{\\frac{\\alpha}{n}}\\,\\sqrt{M}\\sqrt{q}.</span> (11)</p>

    <p class="text-gray-300">This says that with <span class="math">n</span>-processor parallelization, one can achieve <span class="math">\\sqrt{n}</span> times online (wall-clock) time reduction and also an <span class="math">\\sqrt{n}</span> factor reduction in pre-computation. A more practical view is to say that, by deciding to invest <span class="math">n</span>-times more on the online processing power, one reduces the required cost of the pre-computation phase. Since the pre-computation is much more resource consuming than the online phase, in most situations, the less-than-linear speedup of the online phase will be justified by the reduction of pre-computation cost. In addition, if the parameters were such that the storage cost outweighed the processor cost, then one can surely justify the cost of additional processors.</p>

    <p class="text-gray-300">This brings us to the subject of what can be done while maintaining the pre-computation cost. In that case, one can read from (9) that we achieve linear speedup of the online phase, but one must be slightly more careful before jumping to this conclusion. The equation (11) shows that the storage must also be increased by a factor of <span class="math">n</span> in addition to the number of processors. In other words, by increasing the storage and processor used during the online phase by a factor of <span class="math">n</span>, one achieves <span class="math">n</span>-times speedup of the online phase. If the parameters were such that the storage cost is much smaller than the processor cost, we may claim linear speedup through parallelization. If otherwise, this may not be what most would call linear speedup, but <span class="math">n</span>-times investment on what is used during the online phase results in an <span class="math">n</span>-times speedup of online phase.</p>

    <p class="text-gray-300">In order to reduce the time for solving DLP over a finite field more, we consider applying tag tracing technique [7] to the mPAP. Since the mPAP consists of  <span class="math">r</span> -adding walk iterating function and DP collision detection method, the tag tracing technique can be applied to the mPAP well. In this subsection, we confirm that the tag tracing technique works well in the mPAP from experimental results.</p>

    <p class="text-gray-300">Test environment and implementation method of the mPAP were the same with Section 3.3. For the tag tracing technique, we stored all possible products of multipliers of 4-adding walk up to 40 steps using pre-computation with  <span class="math">54.9\\mathrm{MB}</span>  and 36.951 seconds on average of all tests. Other parameters were set equal to experiments of Section 4.5 in [7] for fair comparison.</p>

    <p class="text-gray-300">Table 3. Comparison of 20-adding walk and tag tracing  <span class="math">\\left( {\\alpha  = {0.81}}\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">phase</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20-adding walk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">tag tracing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20-add./tag.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">storage</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">42bit (t=214)</td>

            <td class="px-3 py-2 border-b border-gray-700">pre-computation</td>

            <td class="px-3 py-2 border-b border-gray-700">1032.221 s</td>

            <td class="px-3 py-2 border-b border-gray-700">77.995 s</td>

            <td class="px-3 py-2 border-b border-gray-700">13.234</td>

            <td class="px-3 py-2 border-b border-gray-700">5 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">online</td>

            <td class="px-3 py-2 border-b border-gray-700">0.256 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.027 s</td>

            <td class="px-3 py-2 border-b border-gray-700">9.487</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">48bit (t=216)</td>

            <td class="px-3 py-2 border-b border-gray-700">pre-computation</td>

            <td class="px-3 py-2 border-b border-gray-700">17005.030 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1274.148 s</td>

            <td class="px-3 py-2 border-b border-gray-700">13.346</td>

            <td class="px-3 py-2 border-b border-gray-700">17 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">online</td>

            <td class="px-3 py-2 border-b border-gray-700">1.038 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.105 s</td>

            <td class="px-3 py-2 border-b border-gray-700">9.886</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">54bit (t=218)</td>

            <td class="px-3 py-2 border-b border-gray-700">pre-computation</td>

            <td class="px-3 py-2 border-b border-gray-700">210312.400 s</td>

            <td class="px-3 py-2 border-b border-gray-700">15439.350 s</td>

            <td class="px-3 py-2 border-b border-gray-700">13.622</td>

            <td class="px-3 py-2 border-b border-gray-700">68 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">online</td>

            <td class="px-3 py-2 border-b border-gray-700">4.115 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.419 s</td>

            <td class="px-3 py-2 border-b border-gray-700">9.821</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80bit* (t=230)</td>

            <td class="px-3 py-2 border-b border-gray-700">pre-computation</td>

            <td class="px-3 py-2 border-b border-gray-700">137 y 104.360 d</td>

            <td class="px-3 py-2 border-b border-gray-700">10 y 136.282 d</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">268 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">online</td>

            <td class="px-3 py-2 border-b border-gray-700">4 h 39.620 m</td>

            <td class="px-3 py-2 border-b border-gray-700">29 m 29.472 s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80bit† (t=230)</td>

            <td class="px-3 py-2 border-b border-gray-700">pre-computation</td>

            <td class="px-3 py-2 border-b border-gray-700">1 y 136.097 d</td>

            <td class="px-3 py-2 border-b border-gray-700">37 d 20.707 h</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">27 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">online</td>

            <td class="px-3 py-2 border-b border-gray-700">2 m 47.772 s</td>

            <td class="px-3 py-2 border-b border-gray-700">17.695 s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">estimated value (*with 1 processor, †parallel processing with 100 processors)</p>

    <p class="text-gray-300">Table 3 gives experimental results of applying 4-adding walk with tag tracing technique and 20 adding walk to the mPAP. All results are average values done over 10 table creations and 100 DLP targets solving per created table. Each table was produced with a different random multipliers for use of different  <span class="math">r</span> -adding walks.</p>

    <p class="text-gray-300">We know that the use of 4-adding walk with the tag tracing technique is about 12 times faster than the use of 20-adding walk without the tag tracing technique from the result of [7] in our implementation environment. The last row in Table 3 shows that the tag tracing technique makes the mPAP 9.487 - 13.622 times faster. This shows that applying tag tracing technique to the mPAP works well.</p>

    <p class="text-gray-300">Moreover, we also estimate the time to solve a DLP on a group of 80-bit order from experimental results. In Table 3, we confirm that the pre-computation time and the online time are about  <span class="math">2^{2d/3}</span>  and  <span class="math">2^{d/3}</span>  times increased respectively, when  <span class="math">d</span>  is the difference between bit sizes of group orders. From this fact, we give the estimation of solving a DLP on a 80-bit order group using the mPAP with 20-adding walk iterating function and 4-adding walk with the tag tracing technique in the eighth and ninth rows in Table 3. The last two rows in</p>

    <p class="text-gray-300">Table 3 also provide the estimation time to solve a DLP using the parallelized mPAP with 100 processors.</p>

    <h2 id="sec-25" class="text-2xl font-bold">4 Key Generation Time Estimation</h2>

    <p class="text-gray-300">In this section, we propose a parameter setup method of the MY-IBE scheme for achieving <span class="math">2^{80}</span> security and efficiently generating a user’s private key. Then we estimate the key generation time on proposed parameters when applying the mPAP to KeyGen algorithm based on our complexity analysis and experimental results on small parameters.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">4.1 Parameter Setup</h3>

    <p class="text-gray-300">In the MY-IBE scheme, the base group <span class="math">G</span> is taken to be a maximal cyclic subgroup of <span class="math">\\mathbf{Z}_{N}</span> where <span class="math">N</span> is a product of roughly same sized primes <span class="math">p,q</span> such that <span class="math">p\\equiv 3\\pmod{4}</span>, <span class="math">q\\equiv 1\\pmod{4}</span>, and <span class="math">\\gcd(p-1,q-1)=2</span>. In order to obtain a secure MY-IBE scheme, as mentioned before, it is assumed that the CDH assumption in <span class="math">G</span> holds and hence factoring <span class="math">N</span> is to be hard.</p>

    <p class="text-gray-300">Consider required conditions that <span class="math">N</span> is hard to factor using known integer factorization algorithms within <span class="math">2^{80}</span> time complexity. First, <span class="math">N</span> is to be at least 1024-bit integer (and hence both <span class="math">p,q</span> are at least 512-bit primes) to endure against the number field sieve factorization algorithm <em>[6]</em>. Second, there are some factoring algorithms whose time complexity depends on the factorization of <span class="math">p-1</span> and <span class="math">q-1</span>. In case of the Pollard <span class="math">p-1</span> algorithm <em>[22]</em>, it takes <span class="math">O(B\\log N/\\log B)</span> group operations to factor <span class="math">N</span> where <span class="math">p-1</span> and <span class="math">q-1</span> are <span class="math">B</span>-smooth integers. Also, if factors of <span class="math">p-1</span> or <span class="math">q-1</span> consist of one <span class="math">(\\log B)</span>-bit prime and other <span class="math">(\\log B)/2</span>-bit primes, then one can factor <span class="math">N</span> within <span class="math">O(\\sqrt{B})</span> operations using Brent’s method <em>[5]</em>. Hence one has to set <span class="math">p,q</span> to be primes such that both <span class="math">p-1</span> and <span class="math">q-1</span> are at least <span class="math">2^{80}</span>-smooth integers and have at least two prime factors of 80-bit or more.</p>

    <p class="text-gray-300">However, the number of large prime factors of <span class="math">p-1</span> and <span class="math">q-1</span> has a significant effect on the key generation time. Let us look into a process of solving a DLP in KeyGen algorithm of the MY-IBE scheme, which applies Pohlig-Hellman algorithm <em>[21]</em> with the mPAP. When an identity ID is given to KGC, he tries to compute the DL of <span class="math">H_{1}(\\text{ID})</span> to the base <span class="math">g</span>. Since KGC knows the factorization of <span class="math">N</span> as trapdoor information, he can apply the mPAP or the Pollard rho algorithm to obtain <span class="math">H_{1}(\\text{ID})^{c_{i}}</span>’s to the base <span class="math">g^{c_{i}}</span> for all <span class="math">c_{i}</span>’s where <span class="math">c_{i}=p-1/p_{i}</span> or <span class="math">q-1/q_{i}</span>, <span class="math">p-1=\\prod_{i=1}^{\\ell}p_{i}</span>, and <span class="math">q-1=\\prod_{i=1}^{\\ell}q_{i}</span>, i.e., he solves DLPs over subgroups of <span class="math">G</span>, whose order are <span class="math">p_{i}</span>’s and <span class="math">q_{i}</span>’s. Thereafter, he computes the DL of <span class="math">H_{1}(\\text{ID})</span> to the base <span class="math">g</span> using Chinese remainder theorem. In this process, large prime factors of <span class="math">p-1</span> and <span class="math">q-1</span> cause more key generation time or much memory size for the mPAP to reduce key generation time. Hence, we recommend the use of <span class="math">p,q</span> such that both <span class="math">p,q</span> are 512-bit primes and each <span class="math">p-1</span>, <span class="math">q-1</span> has two 80-bit primes and other less than 40-bit primes.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.2 Key Generation Time Estimation from Experimental Results</h3>

    <p class="text-gray-300">We shall give the estimated key generation time with experimental results applying the mPAP. Test environment was the same with Section 3.3. Throughout the test, <span class="math">G</span> was taken to be</p>

    <p class="text-gray-300">a maximal cyclic subgroup of  <span class="math">\\mathbf{Z}_N^*</span>  where  <span class="math">N</span>  was an 1024-bit integer which was a product of 512-bit primes  <span class="math">p, q</span>  and two prime factors of  <span class="math">p - 1</span>  and  <span class="math">q - 1</span>  were  <span class="math">(\\log B)</span> -bit and other prime factors were less than  <span class="math">(\\log B)/2</span> -bit each. We utilized the mPAP enhanced by the tag tracing technique [7] for solving DLPs on groups of four large prime factors and applied Pollard rho algorithm with 20-adding walk and DP collision detection method for solving DLPs on the other groups. Parameters for tag tracing technique were set equal to Section 3.5 and those for the mPAP were set to  <span class="math">t = 2^{(\\log B)/3}</span> ,  <span class="math">\\alpha = 0.81</span> .</p>

    <p class="text-gray-300">Table 4. Key generation time for various  <span class="math">B</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security level</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pre-comp. size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pre-comp. time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">online time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">storage</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">small factors</td>

            <td class="px-3 py-2 border-b border-gray-700">large factors</td>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">229.9</td>

            <td class="px-3 py-2 border-b border-gray-700">3 m 25 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.266 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.079 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.345 s</td>

            <td class="px-3 py-2 border-b border-gray-700">17 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">233.9</td>

            <td class="px-3 py-2 border-b border-gray-700">54 m 45 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.495 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.310 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.805 s</td>

            <td class="px-3 py-2 border-b border-gray-700">68 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80*</td>

            <td class="px-3 py-2 border-b border-gray-700">251</td>

            <td class="px-3 py-2 border-b border-gray-700">13 y 231 d</td>

            <td class="px-3 py-2 border-b border-gray-700">3 m 12.605 s</td>

            <td class="px-3 py-2 border-b border-gray-700">2 h 52.578 m</td>

            <td class="px-3 py-2 border-b border-gray-700">2 h 55.788 m</td>

            <td class="px-3 py-2 border-b border-gray-700">270 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80†</td>

            <td class="px-3 py-2 border-b border-gray-700">251</td>

            <td class="px-3 py-2 border-b border-gray-700">49 d 19 h</td>

            <td class="px-3 py-2 border-b border-gray-700">1.926 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1 m 43.547 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1 m 45.473 s</td>

            <td class="px-3 py-2 border-b border-gray-700">27 GB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">estimated value (*with 1 processor, †parallel processing with 100 processors)</p>

    <p class="text-gray-300">In Table 4, the third and fourth rows provide our experimental results of the key generation time corresponding to  <span class="math">B</span> , which are average values done over 10 table generations and 100 DLP targets solving per a created table. From these, when the difference between log  <span class="math">B</span> 's is  <span class="math">d</span> -bit, we are sure that the pre-computation time and the online-time for large prime factors are about  <span class="math">2^{2d/3}</span> ,  <span class="math">2^{d/3}</span>  times increased respectively and the online time for small prime factors is about  <span class="math">2^{d/4}</span>  times increased.</p>

    <p class="text-gray-300">We estimate the pre-computation time and the online time for  <span class="math">2^{80}</span>  security. Assume that we perform  <span class="math">P = 2^{51}</span>  pre-computation for four large prime factors and store  <span class="math">2^{18}</span>  elements in each table. Then it takes about 13 years and 231 days for pre-computation with 270 MB storage. Since the pre-computation can be parallelized, one can generate the table in 49 days and 19 hours using 100 processors and 270 MB storage, in addition to the factors of  <span class="math">n</span> , as the trapdoor information. When an instance of DLP is given, it can be solved in 2 hours and 56 minutes on one processor.</p>

    <p class="text-gray-300">If, as described in Section 3.4, we decide to parallelize the online phase across 100 processors while keeping the pre-computation at  <span class="math">2^{51}</span> , the online phase reduces to one minute and 46 seconds with the use of 27 GB storage. Since this process is to be done by the key generation center to handle just key extractions, the presented pre-computation and online time may both be quite practical.</p>

    <p class="text-gray-300">In this paper, we provided the method to reduce the key generation time of the MY-IBE scheme for practical use. To achieve this, we suggested the use of the mPAP with significant pre-computation for solving DLPs over a trapdoor DL group in the key generation algo</p>

    <p class="text-gray-300">rithm and gave more rigorous complexity analysis of the mPAP. Also we discussed about the parallelization of the mPAP and applying the tag tracing technique.</p>

    <p class="text-gray-300">Finally, we gave the parameter setup method so that KGC efficiently solves a DLP and we estimated the key generation time on proposed parameter from our theoretical analysis and experimental results on small parameters.</p>

    <h2 id="sec-29" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] L. M. Adleman. A subexponential algorithm for the discrete logarithm problem with applications to cryptography (abstract). In FOCS, pages 55–60. IEEE Computer Society, 1979.</li>

      <li>[2] S. Agrawal, D. Boneh, and X. Boyen. Efficient lattice (h)ibe in the standard model. In Advances in Cryptology - EUROCRYPT 2010, volume 6110 of LNCS, pages 553–572. Springer, 2010.</li>

      <li>[3] D. Boneh and X. Boyen. Efficient selective-id secure identity-based encryption without random oracles. In Advances in Cryptology - EUROCRYPT 2004, volume 3027 of LNCS, pages 223–238. Springer, 2004.</li>

      <li>[4] D. Boneh and M. K. Franklin. Identity-based encryption from the weil pairing. In Advances in Cryptology—CRYPTO 2001, volume 2139 of LNCS, pages 213–229. Springer, 2001.</li>

      <li>[5] R. P. Brent. Some integer factorization algorithms using elliptic curves. CoRR, abs/1004.3366, 2010.</li>

      <li>[6] J. P. Buhler, H. W. Lenstra, and C. Pomerance. Factoring integers with the number field sieve. In The Development of the Number Field Sieve, volume 1554 of LNCS, pages 50–94. Springer, 1993.</li>

      <li>[7] J. H. Cheon, J. Hong, and M. Kim. Speeding up the Pollard rho method on prime fields. In Advances in Cryptology - ASIACRYPT 2008, volume 5350 of LNCS, pages 471–488. Springer, 2008.</li>

      <li>[8] A. W. Dent and S. D. Galbraith. Hidden pairings and trapdoor ddh groups. In ANTS, volume 4076 of LNCS, pages 436–451. Springer, 2006.</li>

      <li>[9] Y. Desmedt and J.-J. Quisquater. Public-key systems based on the difficulty of tampering (is there a difference between des and rsa?). In Advances in Cryptology – CRYPTO 86, volume 263 of LNCS, pages 111–117. Springer, 1987.</li>

      <li>[10] C. Gentry. Practical identity-based encryption without random oracles. In Advances in Cryptology - EUROCRYPT 2006, volume 4004 of LNCS, pages 445–464. Springer, 2006.</li>

      <li>[11] C. Gentry, C. Peikert, and V. Vaikuntanathan. Trapdoors for hard lattices and new cryptographic constructions. In STOC, pages 197–206. ACM, 2008.</li>

      <li>[12] Y. Hitchcock, P. Montague, G. Carter, and E. Dawson. The efficiency of solving multiple discrete logarithm problems and the implications for the security of fixed elliptic curves. International Journal of Information Security, 3:86–98, 2004.</li>

      <li>[13] J. Hong and S. Moon. A comparison of cryptanalytic tradeoff algorithms. Cryptology ePrint Archive, Report 2010/176, ver. 20110705:120703, 2011.</li>

      <li>[14] F. Kuhn and R. Struik. Random walks revisited: extensions of Pollard’s rho algorithm for computing multiple discrete logarithms. In S. Vaudenay and A. M. Youssef, editors, Selected Areas in Cryptography 2001, LNCS 2259, pages 212–229. Springer, 2001.</li>

      <li>[15] C. H. Lim and P. J. Lee. Modified maurer-yacobi’s scheme and its applications. In J. Seberry and Y. Zheng, editors, Advances in Cryptology - AUSCRYPT ’92, LNCS 718, pages 308–323. Springer, 1993.</li>

      <li>[16] U. M. Maurer and Y. Yacobi. Non-interactive public-key cryptography. In D. W. Davies, editor, Advances in Cryptology - EUROCRYPT ’91, LNCS 547, pages 498–507. Springer, 1991.</li>

      <li>[17] U. M. Maurer and Y. Yacobi. A remark on a non-interactive public-key distribution system. In R. A. Rueppel, editor, Advances in Cryptology - EUROCRYPT ’92, LNCS 658, pages 458–460. Springer, 1993.</li>

      <li>[18] U. M. Maurer and Y. Yacobi. A non-interactive public-key distribution system. Designs, Codes and Cryptography, 9:305–316, 1996.</li>

      <li>[19] Y. Murakami and M. Kasahara. Murakami-kasahara id-based key sharing scheme revisited — in comparison with maurer-yacobi schemes—. Cryptology ePrint Archive, Report 2005/306, 2005. http://eprint.iacr.org/.</li>

      <li>[20] K. G. Paterson and S. Srinivasan. On the relations between non-interactive key distribution, identity-based encryption and trapdoor discrete log groups. Designs, Codes and Cryptography, 52(2):219–241, 2009.</li>

    </ul>

    <p class="text-gray-300">21] S. C. Pohlig and M. E. Hellman. An improved algorithm for computing logarithms over <span class="math">\\operatorname{GF}(p)</span> and its cryptographic significance. IEEE Transactions on Information Theory, 24:106–110, 1978.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[22] J. M. Pollard. Theorems of factorization and primality testing. Cambridge Philosophical Society, 76:521–528, 1974.</li>

      <li>[23] J. M. Pollard. A monte carlo methods for index computation mod <span class="math">p</span>. Mathematics of Computation, 32:918–924, 1978.</li>

      <li>[24] J.-J. Quisquater and J.-P. Delescaille. How easy is collision search. New results and applications to DES. In G. Brassard, editor, Advances in Cryptology - CRYPTO, LNCS 435, pages 408–413. Springer, 1989.</li>

      <li>[25] J. Sattler and C.-P. Schnorr. Generating random walks in groups. Ann. Univ. Sci. Budapest. Sect. Comput., 6:65–79, 1985.</li>

      <li>[26] A. Shamir. Identity-based cryptosystems and signature schemes. In Advances in Cryptology—CRYPTO ’84, volume 196 of LNCS, pages 47–53. Springer, 1984.</li>

      <li>[27] V. Shoup. NTL: A library for doing number theory ver. 5.5. http://www.shoup.net/ntl/, 2009.</li>

      <li>[28] H. Tanaka. A realization scheme for the identity-based cryptosystem. In Advances in Cryptology – CRYPTO 87, volume 293 of LNCS, pages 340–349. Springer, 1988.</li>

      <li>[29] E. Teske. On random walks for Pollard’s rho method. Mathematics of Computation, 70(234):809–825, 2001.</li>

      <li>[30] E. Teske. An elliptic curve trapdoor system. Journal of Cryptology, 19(1):115–133, 2006.</li>

      <li>[31] S. Tsujii and T. Itoh. An id-based cryptosystem based on the discrete logarithm problem. Selected Areas in Communications, IEEE Journal on, 7(4):467 – 473, may 1989.</li>

      <li>[32] P. C. van Oorschot and M. J. Wiener. Parallel collision search with cryptanalytic applications. Journal of Cryptology, 12:1–28, 1999.</li>

      <li>[33] B. Waters. Efficient identity-based encryption without random oracles. In Advances in Cryptology - EUROCRYPT 2005, volume 3494 of LNCS, pages 114–127. Springer, 2005.</li>

      <li>[34] B. Waters. Dual system encryption: Realizing fully secure ibe and hibe under simple assumptions. In Advances in Cryptology - CRYPTO 2009, volume 5677 of LNCS, pages 619–636. Springer, 2009.</li>

    </ul>`;
---

<BaseLayout title="Accelerating ID-based Encryption based on Trapdoor DL using ... (2011/187)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/187
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
