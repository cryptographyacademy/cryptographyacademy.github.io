---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1216';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A summary on the FRI low degree test';
const AUTHORS_HTML = 'Ulrich Haböck';

const CONTENT = `    <p class="text-gray-300">Ulrich Hab¨ock<sup>∗</sup></p>

    <p class="text-gray-300">December 17, 2024†</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6"><strong>Abstract</strong></h4>

    <p class="text-gray-300">This document is an informal summary on the FRI low degree test [\\[BBHR18a\\]](#page-20-0), <a href="#page-20-1">\\[BCI</a><sup>+</sup>20], and DEEP algebraic linking from [\\[BGKS20\\]](#page-21-0). Based on its most recent soundness analysis <a href="#page-20-1">\\[BCI</a><sup>+</sup>20], we discuss parameter settings for practical security levels, how FRI is turned into a polynomial commitment scheme, and the soundness of DEEP sampling in the list decoding regime. In particular, we illustrate the DEEP method applied to proving satisfiability of algebraic intermediate representations and prove a soundness error bound which slightly improves the one in [\\[Sta23\\]](#page-21-1).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Notation<br>3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Correlated agreement<br>3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">FRI proof of proximity<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Reduction<br>5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Sampling phase<br>6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Batching<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.4</td>

            <td class="px-3 py-2 border-b border-gray-700">Soundness<br>7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">Example parameters<br><br>8</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                             | 3.5.1<br>66 bits of security<br><br>9 |  |  |  |  |  |</p>

    <p class="text-gray-300">|   |                             | 3.5.2<br>112 bits security<br><br>9   |  |  |  |  |  |</p>

    <p class="text-gray-300">|   |                             | 3.5.3<br>128 bits security<br><br>10  |  |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjectured security<br><br>10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><sup>∗</sup>This work was supported during my employment at Horizenlabs, Inc., and Orbis Labs.</p>

    <p class="text-gray-300"><sup>†</sup>This updated version of the summary corrects Section 3.7 on adding zero-knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{FR}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I as a polynomial commitment scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1</td>

            <td class="px-3 py-2 border-b border-gray-700">In the unique decoding regime</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1.1 A first construction</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1.2 The refined scheme</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1.3 Multi-point queries</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.2</td>

            <td class="px-3 py-2 border-b border-gray-700">List commitments</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">DE</td>

            <td class="px-3 py-2 border-b border-gray-700">EP-ALI</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Algebraic linking and the DEEP method</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.2</td>

            <td class="px-3 py-2 border-b border-gray-700">DEEP-ALI of an AIR</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|              |               | 5.2.1 Extractability                               |    |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Boosting soundness</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|              |               | 5.3.1 Using extension fields                       |    |  |  |  |  |</p>

    <p class="text-gray-300">|              |               | 5.3.2 Increasing the number of protocol challenges |    |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5.4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Beyond the Johnson bound?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Berlekamp-Welch decoder</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|              |               | List decoding                                      |    |  |  |  |  |</p>

    <p class="text-gray-300">|              |               | A.2.1 The Sudan decoder                            |    |  |  |  |  |</p>

    <p class="text-gray-300">|              |               | A.2.2 The Guruswami-Sudan decoder                  |    |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weighted correlated agreement</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FRI, in full length Fast Reed-Solomon Code Interactive Oracle Proof of Proximity, is a low-degree test for functions on an FFT domain, i.e. a smooth multiplicative subgroup D of a finite field F. Given a function</p>

    <div class="my-4 text-center"><span class="math-block">f:D\\longrightarrow F</span></div>

    <p class="text-gray-300">FRI proves that f corresponds to a polynomial of low degree with respect to the size of D.</p>

    <p class="text-gray-300">The oracles provided by the FRI prover are again functions on D, or a subdomain of it, and the verifier queries the values at points from their domain only. Due to the small size of D (compared to the cryptographically large sampling spaces of polynomial IOPs) the key tool for distinguishing one polynomial from another is statistical sampling. However, a statistical test can only assure proximity, which we measure by the fractional Hamming distance</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta(f,g) = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ x \\in D : f(x) \\neq g(x) \\right\\} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In FRI the prover convinces the verifier that a given function  <span class="math">f: D \\longrightarrow F</span>  is  <span class="math">\\theta</span> -close (and not necessarily equal) to a low-degree polynomial, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\delta(f, p) \\le \\theta,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for some polynomial p(X) of specified maximum degree. In words, f agrees with p(X) on a set  <span class="math">A \\subseteq D</span>  of density  $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\ge 1 - \\theta$ . In applications the agreement set is chosen large enough to infer global properties on the low degree polynomial. It is exactly this inference principle which makes FRI applicable to proving algebraic relations between a set of low-degree polynomials, might it be circuit satisfiability or the evaluation identities for building a polynomial commitment scheme.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>We stress that fact that this summary does not present any novelties.</em> Instead it is an outcome of my learnings when reading the papers <a href="#page-20-1">\\[BCI</a>+20], [\\[BGKS20\\]](#page-21-0), [\\[BBHR18a\\]](#page-20-0), [\\[KPV19\\]](#page-21-2) and [\\[Sta23\\]](#page-21-1). The document provides an overview of FRI and its soundness analysis, including some background on decoding Reed-Solomon codes. It discusses the DEEP method and how it is related to polynomial commitment schemes and we sketch the more general notion of list polynomial commitment schemes [\\[KPV19\\]](#page-21-2). Finally we illustrate how soundness error bounds are proven for the DEEP method in the list decoding regime. In the course the latter we clarify two points of [\\[Sta23\\]](#page-21-1), which are the usage of degree correction factors (these are not needed for the DEEP method), and the quadratic occurence of the decoder list size bound in their soundness error formula, which can be replaced by a linear term.</p>

    <p class="text-gray-300">We assume that the reader knows (public-coin) interactive oracle proofs and their security notions [\\[BCS16\\]](#page-20-2), such as soundness, proof of knowledge, and statistical (i.e. perfect) honest verifier zero-knowledge. Any IOP with these security properties can be compiled into a succinct non-interact-ive argument of knowledge in the random oracle model [\\[BCS16\\]](#page-20-2): The prover oracle messages are committed by Merkle roots using the random oracle, and the verifier coins are the answers of the random oracle given the prover messages as its input.</p>

    <h2 id="sec-6" class="text-2xl font-bold"><strong>1.1 Notation</strong></h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout the document we assume that the size of the sampling domain <em>D</em> and the number of coefficients <em>k</em> are both powers of two, and that the multiplicative subgroup <em>F</em> <sup>∗</sup> of the finite field <em>F</em> is smooth enough to contain a subgroup of order <em>k</em> and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>D</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. The absolute Hamming distance between two function <em>f, g</em> ∈ <em>F <sup>D</sup></em> is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Delta(f,g) = \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ x \\in D : f(x) \\neq g(x) \\right\\} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and we shall write</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta(f,g) = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\Delta(f,g)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for its fractional variant. Given any subset <em>V</em> ⊆ <em>F <sup>D</sup></em>, we denote by</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta(f,V) = \\min_{v \\in V} \\Delta(f,v)</span></div>

    <p class="text-gray-300">the minimal distance of <em>f</em> ∈ <em>F <sup>D</sup></em> to <em>V</em> , and likewise we define the minimal fractional Hamming distance. We denote by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{RS}_k[F,D] = \\big\\{ \\; p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in D} : p(X) \\in F[X], \\deg p(X) \\le k-1 \\big\\}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the Reed-Solomon code of rate <em>ρ</em> = <em>k n</em> over the domain of definition <em>D</em> ⊆ <em>F</em> ∗ . (Here, <em>p</em>(<em>x</em>)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>x</em>∈<em><sup>D</sup></em> denotes the domain evaluation, i.e. the functional restriction of <em>p</em>(<em>x</em>) to <em>D</em>.) Whenever we say that a polynomial <em>p</em>(<em>X</em>) belongs to RS<em>k</em>[<em>F, D</em>], we mean that its domain evaluation <em>p</em>(<em>x</em>)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>x</em>∈<em><sup>D</sup></em> is a code word.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the context of oracle proofs, we denote oracles for functions <em>f</em> ∈ <em>F <sup>D</sup></em> by <em>f</em> , and occasionally call them <em>domain evaluation oracles</em> to distinguish from the oracle notion of univariate polynomial IOPs [\\[BFS20\\]](#page-21-3), which models an ideal polynomial commitment scheme. In order to a closer alignment with the compiled protocol in the random oracle model, we prefer to say that a party <em>P</em> (the prover) "sends" [<em>f</em>] to another party <em>V</em> (the verifier), meaning that <em>P</em> sets up the oracle for <em>f</em> and <em>V</em> obtains oracle access for it.</p>

    <p class="text-gray-300">As in polynomial IOPs, building random linear combinations is the core reduction argument in FRI . While the soundness of it is easily proven in the polynomial model, this is not the case for domain evaluations. Even in the most elementary case, proving that if with noticeable probability a random linear combination of two given functions  <span class="math">f_0</span> ,  <span class="math">f_1</span>  is  <span class="math">\\theta</span> -close to a Reed-Solomon codeword, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\delta(f_0 + \\lambda \\cdot f_1, \\mathsf{RS}_k[F, D]) \\le \\theta,</span></div>

    <p class="text-gray-300">then a similar proximity would hold for  <span class="math">f_0</span>  and  <span class="math">f_1</span> , is non-trivial, in particular when targeting only a small increase in the distance bound  <span class="math">\\theta</span> . The most advanced result is the correlated agreement theorem (or proximity gap theorem) of Ben-Sasson, et al. [BCI<sup>+</sup>20]. We state it for the case of algebraic curves, which is typically favored in the context of proof composition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-3-3"></span><strong>Theorem 1.</strong> (Correlated agreement theorem, full version of [BCI<sup>+</sup>20], Theorem 6.1 and 6.2) Let  <span class="math">\\mathsf{RS}_k = \\mathsf{RS}_k[F,D]</span>  be the Reed-Solomon code over a a finite field F with defining set  <span class="math">D \\subseteq F</span>  and rate  $\\rho = \\frac{k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Given a proximity parameter  </span>\\theta \\in (0, 1 - \\sqrt{\\rho})<span class="math">  and words  </span>f_0, f_1, ..., f_{N-1} \\in F^D$  for which</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\lambda \\in F: \\delta\\big(f_0 + \\lambda \\cdot f_1 + \\ldots + \\lambda^{N-1} \\cdot f_{N-1}, \\mathsf{RS}_k\\,\\big) \\leq \\theta\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} > \\varepsilon,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\varepsilon</span>  is as in (1) and (2) below. Then there exist polynomials  <span class="math">p_0(X)</span> ,  <span class="math">p_1(X)</span> ,..., <span class="math">p_{N-1}(X)</span>  belonging to  <span class="math">\\mathsf{RS}_k</span> , and a set  <span class="math">A \\subseteq D</span>  of density  $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\ge 1 - \\theta<span class="math">  on which  </span>f_0, \\ldots, f_{N-1}<span class="math">  jointly coincide with  </span>p_0, \\ldots, p_{N-1}$ , respectively. In particular,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\delta(f_0 + \\lambda \\cdot f_1 + \\ldots + \\lambda^{N-1} \\cdot f_{N-1}, \\mathsf{RS}_k) \\leq \\theta</span></div>

    <p class="text-gray-300">for every  <span class="math">\\lambda \\in F</span> .</p>

    <p class="text-gray-300">The proof of the correlated agreement theorem, including concrete values for the soundness error bound  <span class="math">\\varepsilon</span> , is an algebraic analysis of the Berlekamp-Welch or the Guruswami-Sudan list decoder over the rational function field K = F(Z). It uses the Polichuk-Spielmann lemma to "glue together" the outputs of the decoder for  <span class="math">f_0 + \\lambda \\cdot f_1 + \\ldots + \\lambda^{N-1} \\cdot f_{N-1}</span>  over the "small" field F by means of the decoder result for the word</p>

    <div class="my-4 text-center"><span class="math-block">f_0 + Z \\cdot f_1 + \\ldots + Z^{N-1} \\cdot f_{N-1} \\in K^D</span></div>

    <p class="text-gray-300">over the infinite field K: If for a noticeable fraction of  <span class="math">\\lambda</span> 's the distance to the Reed-Solomon code is  <span class="math">\\leq \\theta</span> , then the same holds over F(Z).</p>

    <p class="text-gray-300">Depending on the decoding regime the following values for  <span class="math">\\varepsilon</span>  are obtained by [BCI<sup>+</sup>20]:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Unique decoding regime. For  <span class="math">\\theta \\in \\left(0, \\frac{1-\\rho}{2}\\right]</span> , Theorem 1 holds with</li>

    </ol>

    <p class="text-gray-300"><span id="page-3-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon = (N-1) \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.\\tag{1}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>List decoding regime. For  <span class="math">\\theta \\in \\left(\\frac{1-\\rho}{2}, 1-\\sqrt{\\rho}\\right)</span>  and setting  <span class="math">\\theta = 1-\\sqrt{\\rho} \\cdot \\left(1+\\frac{1}{2m}\\right)</span> , with  <span class="math">m \\geq 3</span> , Theorem 1 holds with</li>

    </ol>

    <p class="text-gray-300"><span id="page-3-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon = (N-1) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\rho^{\\frac{3}{2}}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> (2)</p>

    <p class="text-gray-300">For linear varieties of the form  <span class="math">f_0 + \\lambda_1 \\cdot f_1 + \\ldots + \\lambda_{N-1} \\cdot f_{N-1}</span>  a similar result holds, with the (N-1)-term in (1) and (2) replaced by 1. See the full version of [BCI<sup>+</sup>20], Theorem 4.1 and 5.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-3-0"></span>Note that in contrast to the unique decoding regime, the sampling domain size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">occurs quadratically in the error bound, and therefore the field needs to be significantly larger to obtain the same magnitude of soundness as in the unique decoding regime. This quadratic occurrence is inherently connected with the Guruswami-Sudan-Johnson list size bound. It is conjectured by [BGKS20] that Reed-Solomon codes over prime fields F are more "nicely" list decodable, even up to capacity bound  <span class="math">1 - \\rho</span> , and that the sampling domain size occurs only linearly in the error bound. We will discuss this conjecture in Section 5.4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a function <em>f</em> ∈ <em>F <sup>D</sup></em> and its domain evaluation oracle [<em>f</em>(<em>x</em>)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>x</em>∈<em>D</em>]<em>,</em> FRI is an interactive oracle proof for <em>f</em> being close to a word from RS<em>k</em>[<em>F, D</em>],</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\delta(f, \\mathsf{RS}_k[F, D]) \\le \\theta,</span></div>

    <p class="text-gray-300">given a <em>proximity parameter θ</em> of at most the Johnson list decoding bound. As most interactive oracle proofs, the FRI protocol is comprised of a <em>commit phase</em> and a <em>query phase</em>. The commit phase consists of one or several rounds, in which the prover sends domain evaluation oracles to the verifier, who then responds with a random challenge. That phase of FRI performs a random reduction similar to the one of an inner product argument <a href="#page-20-3">\\[BCC</a>+16], at least halving the instance size with each step by a linear folding procedure. In the concluding query phase, the verifier asks for openings of the oracles at random points from their domain of definition. These openings are then used to check consistency of each reduction step of the commit phase.</p>

    <p class="text-gray-300">The commit phase of FRI starts with the instance to proven, i.e. the polynomial <em>p</em>0(<em>X</em>) = <em>p</em>(<em>X</em>) and its domain evaluation over <em>D</em><sup>0</sup> = <em>D</em>. This instance is stepwised reduced by means of a random folding procedure, yielding a sequence of polynomials</p>

    <div class="my-4 text-center"><span class="math-block">p_0(X), p_1(X), \\dots, p_r(X) \\in F[X]</span></div>

    <p class="text-gray-300">as words over the domains</p>

    <div class="my-4 text-center"><span class="math-block">D_0 \\supseteq D_1 \\supseteq \\ldots \\supseteq D_r</span></div>

    <p class="text-gray-300">respectively, wheras their degree bounds <em>k<sup>i</sup></em> , deg <em>pi</em>(<em>X</em>) <em>< k<sup>i</sup></em> , decrease with the same ratio as the domains. The quotients</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$a_i = \\frac{k_{i-1}}{k_i} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">are the <em>reduction factors</em>, and we throughout assume that <em>a<sup>i</sup></em> ≥ 2. (By our assumptions on</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>D</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and <em>k</em> the <em>a<sup>i</sup></em> are again powers of two.) The number of rounds <em>r</em> ≥ 1, their reduction factors <em>a</em>1<em>, . . . , a<sup>r</sup></em> and therefore the decreasing sequence of domains <em>D</em>0<em>, . . . , Dr</em>, are parameters of FRI.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Protocol 1</strong> (FRI commit phase)<strong>.</strong> <em>Given the domain evaluation</em> [<em>p</em>0(<em>x</em>)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>x</em>∈<em>D</em><sup>0</sup> ] <em>for the polynomial p</em>0(<em>X</em>) ∈ <em>F</em>[<em>X</em>]<em>,</em> deg <em>p</em>0(<em>X</em>) <em>< k</em>0<em>, the commit phase consists of the following r rounds.</em></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• <em>In each round i,</em> 1 ≤ <em>i</em> ≤ <em>r, the prover decomposes the previous polynomial pi</em>−1(<em>X</em>) <em>of</em> deg <em>pi</em>−1(<em>X</em>) <em>< ki</em>−1<em>, according to</em></p>

    <p class="text-gray-300"><span id="page-4-1"></span> <span class="math-block">p_{i-1}(X) = F_0(X^{a_i}) + X \\cdot F_1(X^{a_i}) + \\dots + X^{a_{i-1}} \\cdot F_{a_i-1}(X^{a_i}), \\tag{3}</span></p>

    <p class="text-gray-300"><em>where each</em></p>

    <div class="my-4 text-center"><span class="math-block">\\deg F_i(Y) &lt; \\frac{k_{i-1}}{a_i} = k_i.</span></div>

    <p class="text-gray-300"><em>(For a<sup>i</sup></em> = 2 <em>this is the decomposition into odd and even parts.) The verifier samples a random challenge λ<sup>i</sup></em> ←\\$ <em>F, sends it to the prover, which in turn responds with the linear combination</em></p>

    <div class="my-4 text-center"><span class="math-block">p_i(Y) = F_0(Y) + \\lambda_i \\cdot F_1(Y) + \\ldots + \\lambda_i^{a_{i-1}} \\cdot F_{a_i-1}(Y)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>as a word on the reduced domain D<sup>i</sup></em> = <em>D ai <sup>i</sup></em>−<sup>1</sup> = {<em>x ai</em> : <em>x</em> ∈ <em>Di</em>−1}<em>. That is, it sends</em> [<em>pi</em>(<em>y</em>)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>y</em>∈<em>D<sup>i</sup></em> ] <em>to the verifier. In the last step however, i</em> = <em>r, the polynomial pr</em>(<em>X</em>) ∈ <em>F</em>[<em>X</em>] <em>is revealed in full length instead.</em></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let us elaborate on the decomposition (3) in terms of the reduction map</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_i: D_{i-1} \\longrightarrow D_i, \\quad x \\mapsto x^{a_i}.</span></div>

    <p class="text-gray-300">Notice that for each y in  <span class="math">D_i</span> ,  <span class="math">y = x^{a_i}</span> , the values of  <span class="math">F_0(y), \\ldots, F_{a_i-1}(y)</span>  are uniquely determined by the values of</p>

    <div class="my-4 text-center"><span class="math-block">F_0(y) + F_1(y) \\cdot X + \\dots + F_{a_i-1}(y) \\cdot X^{a_i-1}</span></div>

    <p class="text-gray-300">on the coset  <span class="math">\\pi_i^{-1}(y) = x \\cdot \\ker(\\pi_i)</span> , and these values are exactly the ones given by  <span class="math">p_{i-1}(X)</span> . Hence if  <span class="math">\\tau</span>  is a generator of  <span class="math">\\ker(\\pi_i) = \\{1, \\tau, \\dots, \\tau^{a_i-1}\\}</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">p_{i}(\\pi_{i}(x)) = L_{0}\\left(p_{i-1}\\left(\\tau^{0} \\cdot x\\right), \\dots, p_{i-1}\\left(\\tau^{a_{i}-1} \\cdot x\\right)\\right) + \\lambda_{i} \\cdot L_{1}\\left(p_{i-1}\\left(\\tau^{0} \\cdot x\\right), \\dots, p_{i-1}\\left(\\tau^{a_{i}-1} \\cdot x\\right)\\right) + \\dots + \\lambda_{i}^{a_{i}-1} \\cdot L_{a_{i}-1}\\left(p_{i-1}\\left(\\tau^{0} \\cdot x\\right), \\dots, p_{i-1}\\left(\\tau^{a_{i}-1} \\cdot x\\right)\\right)</span></div>

    <p class="text-gray-300">where  <span class="math">(L_0, ..., L_{a_i-1})</span>  is the Lagrange interpolation map for the coset  <span class="math">x \\cdot ker(\\pi_i)</span> . In other words,</p>

    <p class="text-gray-300"><span id="page-5-1"></span> <span class="math-block">p_i(\\pi_i(x)) = \\mathsf{FFT}_{\\lambda_i/x} \\left( p_{i-1} \\left( \\tau^0 \\cdot x \\right), \\dots, p_{i-1} \\left( \\tau^{a_i-1} \\cdot x \\right) \\right), \\tag{4}</span></p>

    <p class="text-gray-300">that is the Fourier transform of the vector  <span class="math">(p_{i-1}(\\tau^0 \\cdot x), \\dots, p_{i-1}(\\tau^{a_i-1} \\cdot x))</span> , evaluated at  <span class="math">\\frac{\\lambda_i}{x}</span> . This equation will be used to check consistency between the provided oracles.</p>

    <p class="text-gray-300">In some situations it is more efficient to compute the values of  <span class="math">p_i(y)</span>  over  <span class="math">D_i</span>  directly from the ones of  <span class="math">p_{i-1}(x)</span> ,  <span class="math">x \\in D_{i-1}</span> , using (4). In terms of field additions A, multiplications M, and FFT operations  <span class="math">\\mathsf{FFT}(a_i)</span>  of size  <span class="math">a_i</span> , this can be done<sup>1</sup> in</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot ((a_i + 1 + \\frac{a_i}{2} \\cdot \\log a_i) \\mathsf{M} + (a_i - 1 + a_i \\cdot \\log a_i) \\mathsf{A}) \\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (a_i + 1 + \\frac{a_i}{2} \\cdot \\log a_i) \\mathsf{M},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">compared to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$a_i \\cdot k_i \\; (\\mathsf{M} + \\mathsf{A}) + \\mathsf{FFT}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (a_i + \\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\; \\mathsf{M}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">when computing the domain evaluation of the random linear combination  <span class="math">p_i(X)</span> . Hence using equation (4) is more efficient whenever</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$1 + \\frac{a_i}{2} \\cdot \\log_2(a_i) < \\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\tag{5}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which holds for most reduction steps when  <span class="math">a_i = 2</span> . For  <span class="math">a_i = 2^2</span>  and  <span class="math">a_i = 2^3</span>  we already obtain  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> 2^5<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> 2^{13}$ , respectively. However, it should be noticed that these counts do not take into account that equation (4) is better parallelizable than the FFT approach.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.2 Sampling phase</h3>

    <p class="text-gray-300">In the query phase the verifier samples at random points from the defining domains of the oracles, and use the returned values to check the consistency of all reduction steps.</p>

    <p class="text-gray-300"><strong>Protocol 2</strong> (FRI query phase). The query phase consists of  <span class="math">s \\ge 1</span>  many rounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-5-2"></span><sup>&</sup>lt;sup>1</sup>Using batch inversion to compute  <span class="math">\\frac{\\lambda_i}{x}</span>  over  <span class="math">D_i</span>  costs  $2 \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M<span class="math"> , computing the fiber FFT&#x27;s costs  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\frac{a_i}{2} \\cdot \\log(a_i) \\cdot (M + A)<span class="math"> , and evaluating them another  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (a_i - 1) \\cdot (M + A)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• <em>In each round the verifier samples an x</em><sup>0</sup> ∈ <em>D</em><sup>0</sup> <em>uniformly at random, computes x</em>1<em>, . . . , x<sup>r</sup> recursively via x<sup>i</sup></em> = <em>πi</em>(<em>xi</em>−1)<em>, and checks if</em></p>

    <div class="my-4 text-center"><span class="math-block">p_i(x_i) = \\mathsf{FFT}_{\\lambda_i/x_i} \\, \\big( p_{i-1}(x_{i-1}), p_{i-1}(\\tau \\cdot x_{i-1}), \\dots, p_{i-1}(\\tau^{a_{i-1}} \\cdot x_{i-1}) \\big),</span></div>

    <p class="text-gray-300"><em>for every i</em> = 1<em>, . . . , r, by querying the values of each pi</em>−<sup>1</sup> <em>over the coset xi</em>−<sup>1</sup> · ker <em>πi.</em></p>

    <p class="text-gray-300">Notice that unlike in <a href="#page-20-1">\\[BCI</a>+20] we choose <em>x</em><sup>0</sup> uniformly from <em>D</em>0, and form the <em>x<sup>i</sup></em> by projecting <em>xi</em>−<sup>1</sup> onto <em>D<sup>i</sup></em> . In distribution, this way of sampling is equivalent to the one in the paper, which starts with <em>x<sup>r</sup></em> ←\\$ <em>Dr</em>, and then samples <em>xi</em>−<sup>1</sup> uniformly from the coset <em>π</em> −1 <em>i</em> (<em>xi</em>).</p>

    <h2 id="sec-11" class="text-2xl font-bold"><strong>3.3 Batching</strong></h2>

    <p class="text-gray-300">As for linear polynomial commitment schemes, batching is done via random linear combinations. We will only discuss the algebraic variant, which uses powers of a single random challenge. (Again, this is the one favored in the context of proof composition.)</p>

    <p class="text-gray-300">Given a batch of <em>L</em> low-degree polynomials <em>q</em>0(<em>X</em>), . . . , <em>qL</em>−1(<em>X</em>), the verifier samples a random challenge <em>λ</em> ←\\$ <em>F</em>. The prover computes the linear combination</p>

    <p class="text-gray-300"><span id="page-6-2"></span> <span class="math-block">h(X) = \\sum_{i=0}^{L-1} \\lambda^i \\cdot q_i(X), \\tag{6}</span></p>

    <p class="text-gray-300">sends the oracle of it,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$[h(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x\\in D}],$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">to the verifier. Then both prover and verifier continue with FRI for <em>h</em>. Each <em>x</em><sup>0</sup> ←\\$ <em>D</em><sup>0</sup> = <em>D</em> from the query phase of FRI is used to additionally check consistency between the oracle for <em>h</em>(<em>X</em>) and the ones in the batch, <em>q</em>0(<em>X</em>)<em>, . . . , qL</em>−1(<em>X</em>), using <a href="#page-6-2">\\(6\\)</a>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8"><strong>3.4 Soundness</strong></h3>

    <p class="text-gray-300">The soundness analysis of FRI is based on a strengthening of the correlated agreement theorem, which allows to additionally keep track of the success probability for the FRI query phase by a sub-probability measure <em>µ</em>. We state that <em>weighted correlated agreement theorem</em> in Appendix <a href="#page-25-0">A.3.</a> For proximity parameters close to the Johnson bound, the soundness error of the batched FRI oracle proof is as follows<a href="#page-6-3">2</a> :</p>

    <p class="text-gray-300"><span id="page-6-5"></span><strong>Theorem 2</strong> (Batched FRI soundness error, full version of <a href="#page-20-1">\\[BCI</a>+20], Theorem 8.3)<strong>.</strong> <em>Suppose that q<sup>i</sup></em> ∈ <em>F D, i</em> = 0<em>, . . . , L</em> − 1<em>, is a batch of functions given by their domain evaluation oracles. If an adversary passes batched FRI for</em> RS<em>k</em>[<em>F, D</em>] <em>and proximity parameter θ</em> = 1− <sup>√</sup><em><sup>ρ</sup></em> · 1 + <sup>1</sup> 2<em>m , m</em> ≥ 3<em>, with a probability larger than</em></p>

    <p class="text-gray-300"><span id="page-6-4"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon = \\left(L - \\frac{1}{2}\\right) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\sqrt{\\rho^3}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{(2m+1) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1) \\cdot \\sum_{i=1}^r a_i}{\\sqrt{\\rho} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + (1-\\theta)^s,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(7)</p>

    <p class="text-gray-300"><em>then the functions q<sup>i</sup></em> ∈ <em>F <sup>D</sup>, i</em> = 0<em>, . . . , L</em> − 1<em>, have correlated agreement with RSk</em>[<em>D, F</em>] <em>on a set of density of at least α ></em> 1 + <sup>1</sup> 2<em>m</em> · <sup>√</sup><em>ρ.</em></p>

    <p class="text-gray-300"><span id="page-6-3"></span><sup>2</sup>We would like to thank Paul Gafni for pointing out a typo in formula <a href="#page-6-4">\\(7\\)</a> in a previous version of the document.</p>

    <p class="text-gray-300">Remark 3. The case of linear batching of two functions  <span class="math">q_0</span> ,  <span class="math">q_1</span>  corresponds to the case L=2, in which  <span class="math">L-\\frac{1}{2}=\\frac{3}{2}</span> . The same is true for affine batching of several functions, its soundness error is obtained from (7) by replacing  <span class="math">L-\\frac{1}{2}</span>  by  <span class="math">\\frac{3}{2}</span> , see [BCI<sup>+</sup>20].</p>

    <p class="text-gray-300">The first two terms in (7),</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon_C = \\left(L - \\frac{1}{2}\\right) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\sqrt{\\rho^3}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{(2m+1) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1) \\cdot \\sum_{i=1}^r a_i}{\\sqrt{\\rho} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">correspond to soundness error of the commit phase, reflecting the systematic error estimated by the correlated agreement theorem and collected over the batching step and the reduction rounds. In words, if the oracles in the batch do not share the claimed correlated agreement for  <span class="math">\\alpha = 1 - \\theta</span> , then except with probability  <span class="math">\\varepsilon_C</span> , the oracles produced during the commit phase cannot be "nice". That is, the set where all consistency checks would hold is <em>at most</em> of density  <span class="math">\\alpha</span> . The remaining term,</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_Q = (1 - \\theta)^s,</span></div>

    <p class="text-gray-300">is the soundness error of the query phase with s rounds. This is the probability not to detect such a set of non-"nice" oracles using s independent samples.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3.5 Example parameters</h2>

    <p class="text-gray-300">One way to settle the parameters is as follows. For target security level  <span class="math">2^{-\\lambda}</span> , we assure that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the soundness error for the commit phase is bounded by  <span class="math">\\frac{1}{2} \\cdot 2^{-\\lambda}</span> . For that we choose the maximum Johnson proximity  <span class="math">m \\geq 3</span>  so that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_C \\le \\frac{1}{2} \\cdot 2^{-\\lambda},</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the soundness error of the query phase is bounded by  <span class="math">\\frac{1}{2} \\cdot 2^{-\\lambda}</span> . Using m from the first step, we determine the number s of query rounds via</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_Q = \\sqrt{\\rho}^s \\cdot \\left(1 + \\frac{1}{2m}\\right)^s \\le \\frac{1}{2} \\cdot 2^{-\\lambda}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following examples<sup>3</sup>consider a situation is similar to the one in Plonky2 [?]. We take extensions F of a base field of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{64}<span class="math"> , and sampling domain sizes  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{12} \\cdot \\rho^{-1}<span class="math"> , where we vary the blow-up factors  </span>\\rho^{-1}$  to the maximum possible for the given security level. The number of polynomials is taken as L = 300, and we assume that these are grouped into</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\{100, 100, 100\\}</span></div>

    <p class="text-gray-300">polynomials, each group committed by a single tree using Merkle caps. The height for the Merkle caps is chosen to minimize the proof size. For each blow-up factor we compute the proof size (assuming a hash size of 256 bits), and as a very coarse measure for the prover complexity the number hashes<sup>4</sup>it needs to compute.</p>

    <p class="text-gray-300"><span id="page-7-2"></span><span id="page-7-1"></span><sup>&</sup>lt;sup>3</sup>In a previous version of the document the example parameters where based on linear batching of FRI. The current ones consider algebraic batching.</p>

    <p class="text-gray-300"><span id="page-7-3"></span><sup>&</sup>lt;sup>4</sup>Each call of the hash processes another r = 256 bits.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8"><strong>3.5.1 66 bits of security</strong></h3>

    <p class="text-gray-300">Such a configuration might be still interesting in practice, as its security can be increased by <em>grinding</em> (see [\\[Sta23\\]](#page-21-1)): Another 14 bits proof of work bound to the proof generation, and one obtains overall 80 bits of security.</p>

    <p class="text-gray-300">• With a degree 2 extension of <em>Fb</em>, hence a field size of 128 bits, the best security level one can obtain for <em>ρ</em> = 2−<sup>5</sup> is about 69 bits. The commit phase error is</p>

    <p class="text-gray-300"><span class="math-block">\\varepsilon_C \\approx 2^{-67.21}</span> ,</p>

    <p class="text-gray-300">with Johnson proximity <em>m</em> = 3. To have about the same soundness error in the query phase, we demand <em>s</em> = 29 samples, yielding</p>

    <p class="text-gray-300"><span class="math-block">\\varepsilon_Q \\approx 2^{-68.33}</span> .</p>

    <p class="text-gray-300">With a reduction strategy {<em>a</em>1<em>, a</em>2} = {2 4 <em>,</em> 2 <sup>3</sup>} we obtain proof sizes of about 104 kB.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">−<br>log2<br>(ρ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T<br>in hashes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π <br>in bytes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">17.4 k</td>

            <td class="px-3 py-2 border-b border-gray-700">166.9 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">34.8 k</td>

            <td class="px-3 py-2 border-b border-gray-700">129.5 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">69.6 k</td>

            <td class="px-3 py-2 border-b border-gray-700">107.5 k</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• With a degree 3 extension of <em>Fb</em>, hence a field size of 192 bits, one can choose higher blow-up factors. For <em>ρ</em> = 2−<sup>6</sup> we obtain 67 bits security by</p>

    <p class="text-gray-300"><span class="math-block">\\varepsilon_C \\approx 2^{-67.00}</span> ,</p>

    <p class="text-gray-300">where the Johnson proximity is <em>m</em> = 1<em>,</em> 427. To have about the same soundness error in the query phase, we need only <em>s</em> = 23 samples, yielding</p>

    <p class="text-gray-300"><span class="math-block">\\varepsilon_Q \\approx 2^{-68.99}</span> .</p>

    <p class="text-gray-300">With the same reduction strategy as before, we reduce the proof size down to 89 kB. However, this comes at the cost of about tripling the prover cost.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">−<br>(ρ)<br>log2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T<br>in hashes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π <br>in bytes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">1,<br>427</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">209 k</td>

            <td class="px-3 py-2 border-b border-gray-700">88.9 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">713</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">836 k</td>

            <td class="px-3 py-2 border-b border-gray-700">68.4 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">356</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">3,<br>342 k</td>

            <td class="px-3 py-2 border-b border-gray-700">58.4 k</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h3 id="sec-15" class="text-xl font-semibold mt-8"><strong>3.5.2 112 bits security</strong></h3>

    <p class="text-gray-300">As in the previous setting, we discuss this level of security as it can be improved by grinding, typically up to 128 bits. All configurations use degree 3 extensions of <em>Fb</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">−<br>log2<br>(ρ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T<br>in hashes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π <br>in bytes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">209 k</td>

            <td class="px-3 py-2 border-b border-gray-700">149 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">836 k</td>

            <td class="px-3 py-2 border-b border-gray-700">115 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">3,<br>342 k</td>

            <td class="px-3 py-2 border-b border-gray-700">99 k</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-8-1"></span>For higher blow-up factors, one needs to increase grinding. For example, for − log<sup>2</sup> (<em>ρ</em>) = 11 the best level of security that can be obtained with degree 3 extensions is 109 bits, leaving 19 bits for grinding. The proof size decreases down to 88<em>.</em>2 kB, at the prover cost of 6<em>,</em> 684<em>,</em> 672 hashes.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8"><strong>3.5.3 128 bits security</strong></h3>

    <p class="text-gray-300">These configurations do not use grinding, and hence have quite large proof sizes. Again, we use degree 3 extensions of <em>Fb</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">−<br>log2<br>(ρ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T<br>in hashes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π <br>in bytes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">92</td>

            <td class="px-3 py-2 border-b border-gray-700">26 k</td>

            <td class="px-3 py-2 border-b border-gray-700">326 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">52 k</td>

            <td class="px-3 py-2 border-b border-gray-700">254 k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">104 k</td>

            <td class="px-3 py-2 border-b border-gray-700">211 k</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h2 id="sec-17" class="text-2xl font-bold"><strong>3.6 Conjectured security</strong></h2>

    <p class="text-gray-300">In their line of work on FRI <a href="#page-20-0">\\[BBHR18a,</a> <a href="#page-21-0">BGKS20,</a> <a href="#page-20-1">BCI</a>+20] the authors make several conjectures on the soundness of FRI for proximity parameters above the Johnson bound. In the most recent one, they state the following.</p>

    <p class="text-gray-300"><span id="page-9-2"></span><strong>Conjecture 1</strong> (Full version of <a href="#page-20-1">\\[BCI</a>+20], Conjecture 8.4)<strong>.</strong> <em>There exist constants c</em>1<em>, c</em><sup>2</sup> <em>such that for all θ</em> = 1 − <em>ρ</em> − <em>η, η ></em> 0<em>, the soundness error in the correlated agreement theorem on f</em>0<em>, . . . , fN</em>−<sup>1</sup> <em>is bounded by</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon \\le \\frac{1}{(\\eta \\cdot \\rho)^{c_1}} \\cdot \\frac{(N \\cdot n)^{c_2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Remark</em> 4<em>.</em> For purely linear batching, a similar conjecture is stated.</p>

    <p class="text-gray-300">We point out that the above conjecture (as well as its corresponding one in [\\[BBHR18a\\]](#page-20-0)) is stated isolated from any general conjectured properties on Reed-Solomon codes, such as list decodability up to capacity bound (as done for DEEP method, see Section <a href="#page-19-3">5.4\\)</a>. Instead it is rather justified by "<em>[to the best of our knowledge...] nothing seems to contradict</em>" . The authors consider the choice of <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 2 reasonable, and for fields of characteristic <em>q > n</em> they estimate that <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 1.</p>

    <p class="text-gray-300">The <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 1 assumption is of particular interest for practitioners, as it yields proofs of halve the size as in the <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 2 case. For example, it is used by the ethSTARK [\\[Sta23\\]](#page-21-1) (besides its provably secure parameter setting), as well as by Plonky2 [\\[Pol\\]](#page-21-4).</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8"><strong>3.7 Adding zero-knowledge</strong></h3>

    <p class="text-gray-300">Zero-knowledge for FRI has to be provided on application level. In our use cases, the witnesses of an argument correspond to the values of some polynomial <em>q</em>(<em>X</em>) on a given domain <em>H</em> (the proving domain for Plonk, say). To protect it from being leaked by the queries of the <em>s</em> query rounds (as well as by the final reduction polynomial), one uses a an <em>H</em>-disjoint <em>coset a</em> · <em>D</em> of the FRI domain, and randomizes <em>q</em>(<em>X</em>) outside the domain <em>H</em>. That is, the batching and the entire FRI reduction takes place on</p>

    <div class="my-4 text-center"><span class="math-block">a \\cdot D_0 \\supseteq a \\cdot D_1 \\supseteq \\ldots \\supseteq a \\cdot D_r,</span></div>

    <p class="text-gray-300">instead of <em>D</em><sup>0</sup> ⊇ <em>D</em><sup>1</sup> ⊇ <em>. . .</em> ⊆ <em>Dr</em>, where (<em>a</em> · <em>D</em>0) ∩ <em>H</em> = ∅. This leads to running batched FRI for <em>qi</em>(<em>X</em>), <em>i</em> = 0<em>, . . . , L</em> − 1, over the non-shifted domain <em>D</em><sup>0</sup> on the shifted polynomials</p>

    <div class="my-4 text-center"><span class="math-block">q_i(a\\cdot X),</span></div>

    <p class="text-gray-300"><em>i</em> = 0<em>, . . . , L</em> − 1, instead.</p>

    <p class="text-gray-300">The concrete degree of freedom in the randomization of the polynomials depends on the number of FRI queries and the degree of the extension they are taken from, as well as the the polynomial IOP on top of FRI. Furthermore, and unlike described in a previous version of the survey, it is crucial to add a separate blinding polynomial h(x) to the batch, in order to assure that no information is revealed by the folding oracles of FRI. We refer to [HK24] for a detailed description of the [BCR<sup>+</sup>19] randomization of FRI, plus additional subtleties one has to take care of in the context of the complete IOP of the STARK.</p>

    <p class="text-gray-300">FRI can be turned into a polynomial commitment scheme by means of the evaluation quotients</p>

    <div class="my-4 text-center"><span class="math-block">h(x) = \\frac{f(x) - v}{x - z}</span></div>

    <p class="text-gray-300">of a committed word  <span class="math">f \\in F^D</span> . This approach, called the DEEP method in [BGKS20] corresponds to the algebraic linking of the evaluation identity</p>

    <div class="my-4 text-center"><span class="math-block">f(X) = v + h(x) \\cdot (X - z)</span></div>

    <p class="text-gray-300">with a low-degree problem on the sampling domain D, assuming that  <span class="math">z \\notin D</span> . (For  <span class="math">z \\in D</span>  the oracle can directly answer with the queried value. We will omit this case throughout our discussion.)</p>

    <p class="text-gray-300">For proximity parameters  <span class="math">\\theta</span>  up to the unique decoding radius one obtains a polynomial commitment scheme in the classical sense (when compiling the oracle proof into an argument using a secure partially disclosable vector commitment). In the list decoding regime the situation is a bit more subtle due to the non-uniqueness of  <span class="math">\\theta</span> -close code words. In this case the DEEP method can be viewed as an oracle proof for a more general type of polynomial commitment scheme, called <em>list polynomial commitment scheme</em> in [KPV19]. However, as their notion does not cover the power of correlated agreement, we shall only sketch list polynomial commitment schemes.</p>

    <h2 id="sec-20" class="text-2xl font-bold">4.1 In the unique decoding regime</h2>

    <p class="text-gray-300">For a proximity bound up to the unique decoding radius, i.e.  <span class="math">\\theta &lt; \\frac{1-\\rho}{2}</span> , the situation is quite simple. However, there are several ways to algebraically link the evaluation identity with a low-degree test.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">4.1.1 A first construction</h4>

    <p class="text-gray-300">We first discuss a naive scheme, in which the maximum degree corresponds to the degree proven by FRI.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: The maximum degree d = k 1 is chosen as the maximum degree of polynomials belonging to  <span class="math">\\mathsf{RS}_k[F,D]</span> .</li>

      <li>Commit: Given a polynomial p(X) of degree  <span class="math">\\deg p(X) \\leq d</span> , the prover commits its domain evaluation over D, i.e.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{Com}(p(X)) = [p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in D}].$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• Evaluation proof: Given an opening claim (z, v) with  <span class="math">z \\notin D</span> , the prover engages with the verifier in a batched FRI argument on</p>

    <div class="my-4 text-center"><span class="math-block">f_1(x) = \\frac{p(x) - v}{x - z},</span></div>

    <p class="text-gray-300"> <span class="math">f_2(x) = x \\cdot f_1(x) = x \\cdot \\frac{p(x) - v}{x - z}.</span></p>

    <p class="text-gray-300">with proximity bound  <span class="math">\\theta = \\frac{1-\\rho}{2}</span> . This proof batches the functions into a random linear combination  <span class="math">f_1(x) + \\lambda \\cdot f_2(x) = (1 + \\lambda \\cdot x) \\cdot \\frac{p(x) - v}{x - z}</span> , and then runs FRI on it. The linear term  <span class="math">\\lambda \\cdot x</span>  is called degree correction factor.</p>

    <p class="text-gray-300">We point out that the two functions  <span class="math">f_1</span> ,  <span class="math">f_2</span>  are not needed to be provided by another oracle, as their evaluations on D can be computed from the values of p(x).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us discuss that the evaluation proofs in fact provide a view on a unique polynomial of degree  <span class="math">\\leq d</span> , determined by the values committed in  $[p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x\\in D}]<span class="math"> . First of all, if the prover passes with a probability p greater than the soundness error of batched FRI on  </span>f_1, f_2<span class="math">  as above, then there exist two polynomials  </span>p_1(X), p_2(X)<span class="math">  of degree  </span>\\leq d<span class="math"> , and a correlated agreement set A of density  </span>1 - \\theta \\geq \\frac{1+\\rho}{2}$  such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$f_1(x) = p_1(x)\\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in A},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$x \\cdot f_1(x) = p_2(x)\\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in A},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and hence also  $x \\cdot p_1(x) = p_2(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in A}<span class="math"> . As the density of A is strictly greater than  </span>\\rho<span class="math"> , the polynomial  </span>X \\cdot p_1(X) - p_2(X)<span class="math">  has at least k+1 = d+2 zeroes and hence must be trivial, i.e.  </span>X \\cdot p_1(X) = p_2(X)<span class="math"> . This implies that  </span>\\deg p_1(X) \\leq d-1$ , and hence p(x) coincides on A with the degree d polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">P(X) = v + (X - z) \\cdot p_1(X),</span></div>

    <p class="text-gray-300">which evaluates to v at z. Notice that  <span class="math">\\delta(p(x), P(X)) &lt; \\frac{1-\\rho}{2}</span> , hence a single evaluation proof implies distance to a degree  <span class="math">\\leq d</span>  polynomial of at most the unique decoding radius. As a consequence, any other evaluation proof (on the same or any other query) is consistent with that unique degree  <span class="math">\\leq d</span>  polynomial, showing that we indeed have a polynomial commitment scheme.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">4.1.2 The refined scheme</h4>

    <p class="text-gray-300">By similar reasoning (based on a degree k=d+1 polynomial vanishing on a set of density  <span class="math">&gt; \\rho</span> ) we can remove the degree correction factor in the above naive scheme, running FRI for a proximity parameter  <span class="math">\\theta &lt; \\frac{1-\\rho}{2}</span> , only on the evaluation quotient of the claim: For any two evaluation claims  <span class="math">(z_1, v_1)</span>  and  <span class="math">(z_2, v_2)</span>  we conclude the existence of polynomials  <span class="math">p_1(X)</span> ,  <span class="math">p_2(X)</span>  of degree  <span class="math">\\leq k-1</span>  and sets  <span class="math">A_1</span> ,  <span class="math">A_2</span>  of density  <span class="math">1-\\theta &gt; \\frac{1+\\rho}{2}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">v_1 + (X - z_1) \\cdot p_1(X),</span></div>

    <p class="text-gray-300"> <span class="math">v_2 + (X - z_2) \\cdot p_2(X),</span></p>

    <p class="text-gray-300">agree with p(x) on  <span class="math">A_1</span>  and  <span class="math">A_2</span> , respectively. Since the density of  <span class="math">A_1 \\cap A_2</span>  is at least  <span class="math">1 - 2 \\cdot \\theta &gt; \\rho</span> , it contains at least k + 1 points, and by degree we may conclude the formal identity</p>

    <div class="my-4 text-center"><span class="math-block">v_1 + (X - z_1) \\cdot p_1(X) = v_2 + (X - z_2) \\cdot p_2(X).</span></div>

    <p class="text-gray-300">This leads to the following optimized scheme:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: The maximum degree is  <span class="math">d^+ = k</span> , where k is the absolute rate of  <span class="math">\\mathsf{RS}_k[F,D]</span> .</li>

      <li>Commit: Given a polynomial p(X) of degree  <span class="math">\\deg p(X) \\leq d^+</span> , the prover commits its domain evaluation over D, i.e.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{Com}(p(X)) = [p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in D}].$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• Evaluation proof: Given an opening claim (z, v) with  <span class="math">z \\notin D</span> , the prover engages with the verifier in a batched FRI argument on</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{p(x) - v}{x - z}</span></div>

    <p class="text-gray-300"><span id="page-11-1"></span>with proximity bound  <span class="math">\\theta &lt; \\frac{1-\\rho}{2}</span> .</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">4.1.3 Multi-point queries</h4>

    <p class="text-gray-300">Instead of batching several point evaluation quotients, queries for the values of a polynomial p(X) over a small set  <span class="math">\\Omega = \\{z_1, ..., z_m\\} \\subset F \\setminus D</span>  can be also proven via the multi-evaluation identity</p>

    <p class="text-gray-300"><span class="math-block">\\sum_{i=1}^{m} (p(X) - v_i) \\cdot L(z_i, X) = 0 \\mod v_{\\Omega}(X),</span> (8)</p>

    <p class="text-gray-300">where  <span class="math">v_{\\Omega}(X) = \\prod_{j=1}^{m} (X - z_j)</span>  is the vanishing polynomial of  <span class="math">\\Omega</span>  and  <span class="math">L(z_i, X) = \\prod_{j \\neq i} \\frac{X - z_j}{z_i - z_j}</span>  is the Lagrange polynomial at  <span class="math">z_i</span> . Similar to the single query case, one argues using the quotient</p>

    <p class="text-gray-300"><span class="math-block">h(x) = \\text{Quotient}(p, \\{(z_i, v_i) : i = 1, \\dots, m\\}) = \\frac{p(x) - V(x)}{v_{\\Omega}(x)},</span>  (9)</p>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">V(X) = \\sum_{i=1}^{m} v_i \\cdot L(z_i, X)</span></div>

    <p class="text-gray-300">is the unique degree  <span class="math">\\leq m-1</span>  polynomial that interpolates the claim.</p>

    <p class="text-gray-300">Alternatively, as in the batch evaluation protocol of Boneh, et al. [BDFG21], one can replace the Lagrange kernel with the non-normalized variant  <span class="math">D(z_i, X) = \\prod_{j \\neq i} (X - z_j)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{m} (p(X) - v_i) \\cdot D(z_i, X) = 0 \\mod v_{\\Omega}(X), \\tag{10}</span></div>

    <p class="text-gray-300">and work with the quotient</p>

    <div class="my-4 text-center"><span class="math-block">h&#x27;(x) = \\sum_{i=1}^{m} \\frac{p(x) - v_i}{x - z_i}</span></div>

    <p class="text-gray-300">instead.</p>

    <p class="text-gray-300">In both cases one has to limit the number m of simultaneous queries to some maximum value  <span class="math">m_{max}</span> , satisfying</p>

    <div class="my-4 text-center"><span class="math-block">k + m_{max} &lt; (1 - \\theta) \\cdot n.</span></div>

    <p class="text-gray-300">For this it is sufficient to choose  <span class="math">k + m_{max} \\le (1 - \\theta_0) \\cdot n = \\frac{k+n}{2}</span> , and hence  <span class="math">m_{max} \\le \\frac{n-k}{2}</span> . Even with the lowest blow-up factor we have  <span class="math">n \\ge 2 \\cdot k</span> , it is thus enough to demand</p>

    <div class="my-4 text-center"><span class="math-block">m_{max} \\le \\frac{k}{2}. (11)</span></div>

    <p class="text-gray-300">In our applications the bound on  <span class="math">m_{max}</span>  is trivially met, as only few values are queried in the run of the proof. Furthermore, given a polynomial we use multi-point queries of fixed given size  <span class="math">m \\leq m_{max}</span> . As a consequence the maximum degree in the setup can be enlarged to  <span class="math">d_{max} = k + m - 1</span> .</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">4.2 List commitments</h4>

    <p class="text-gray-300">In the list decoding regime the situation is a bit more subtle. Running FRI for  <span class="math">\\mathsf{RS}_k[F,D]</span>  with a proximity parameter  <span class="math">\\frac{1-\\rho}{2} &lt; \\theta &lt; 1 - \\sqrt{\\rho}</span>  on an evaluation quotient</p>

    <div class="my-4 text-center"><span class="math-block">h(x) = \\frac{p(x) - v}{x - z}</span></div>

    <p class="text-gray-300">only proves agreement of p with an evaluation-claim-consistent polynomial of degree  <span class="math">d^+ = k</span>  on a set of density greater than  <span class="math">\\alpha = 1 - \\theta</span> . This might be not large enough for proving the polynomials of different runs</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">of FRI being equal. In fact, they might differ from claim to claim, unless one runs a joint FRI argument on them. Assuming  <span class="math">\\alpha &gt; \\sqrt{\\rho^+}</span> , where  $\\rho^+ = \\frac{k+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ , the Guruswami-Sudan list decoding bound shows that there might be</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">L \\le \\frac{1}{2 \\cdot \\eta \\cdot \\rho^+}</span></div>

    <p class="text-gray-300">such code words. This leads to the idea of list polynomial commitment schemes as in [KPV19] with the following information-theoretic model: The prover sets up an oracle which contains a list of l,  <span class="math">1 \\le l \\le L</span> , low-degree polynomials, and the oracle is allowed to choose which one to evaluate on a given query. Such extended notion is practical as security proofs in the oracle model are similar to polynomial oracle proofs. However, the notion of list polynomial oracles as given in [KPV19] is not strong enough to capture correlated agreement, and as a consequence soundness error bounds are too coarse. For this reason we do not dive into formal details of that model, and instead directly work with DEEP algebraic linking.</p>

    <p class="text-gray-300">In this section we discuss the <em>DEEP algebraic linking (DEEP-ALI)</em> [BGKS20] and demonstrate its application to proving satisfiability of algebraic intermediate representations (AIR). Other representations such as randomized AIR or Plonk [GWC19] can be treated similarly.</p>

    <h2 id="sec-26" class="text-2xl font-bold">5.1 Algebraic linking and the DEEP method</h2>

    <p class="text-gray-300">Algebraic linking transforms satisfiability of algebraic identities over algebraic subsets of F into proximity problems of low-degree extensions to Reed-Solomon codes over "outside" domains (i.e. disjoint to the algebraic subset). A family of functions  <span class="math">g_1, \\ldots, g_N</span>  on  <span class="math">\\Omega = \\{x_1, ..., x_n\\}</span>  satisfies an algebraic identity</p>

    <div class="my-4 text-center"><span class="math-block">P(x, g_1(x), \\dots, g_N(x)) = 0</span></div>

    <p class="text-gray-300">on  <span class="math">\\Omega</span>  (P is a polynomial), if and only if their low-degree extensions  <span class="math">p_1(X), \\ldots, p_N(X)</span>  satisfy that  <span class="math">P(X, p_1(X), \\ldots, p_N(X))</span>  is divisible by the vanishing polynomial  <span class="math">v_{\\Omega}(X) = \\prod_{i=1}^n (X - x_i)</span>  of  <span class="math">\\Omega</span> , i.e. the quotient</p>

    <div class="my-4 text-center"><span class="math-block">h(X) = \\frac{P(X, p_1(X), ..., p_N(X))}{v_{\\Omega}(X)}</span></div>

    <p class="text-gray-300">is a low-degree polynomial. This divisibility criterion is translated to the proximity of given code words</p>

    <div class="my-4 text-center"><span class="math-block">f_1, ..., f_N, h \\in F^D,</span></div>

    <p class="text-gray-300">(the honest prover chooses the domain evaluations of  <span class="math">p_1(X), \\ldots, p_N(X)</span>  and h(X) over D) to low-degree polynomials, i.e. a Reed-Solomon code words<sup>5</sup>. For this the proximity parameter needs to be chosen so that the agreement sets are large enough to infer from local satisfiability of algebraic identities to their satisfiability over the entire field F. This means that the sampling domain D is such that the notion of low-degree is determined by the degree of  <span class="math">P(X, p_1(X), ..., p_N(X))</span> . DEEP-ALI instead allows for decoupling the sampling domain size from the degree of P.</p>

    <p class="text-gray-300">DEEP-ALI is very much in alignment with a polynomial IOP for proving that</p>

    <p class="text-gray-300"><span id="page-13-3"></span> <span class="math-block">P(X, p_1(X), ..., p_N(X)) = h(X) \\cdot v_{\\Omega}(X).</span> (12)</p>

    <p class="text-gray-300"><span id="page-13-2"></span><sup>&</sup>lt;sup>5</sup>In the case of a single batched FRI proof for the  <span class="math">f_i</span>  together with h, one needs to use degree correction factors as in Section 4.1.1.</p>

    <p class="text-gray-300">Instead of showing proximity of the quotient</p>

    <div class="my-4 text-center"><span class="math-block">h(x) = \\frac{P(x, f_1(x), ..., f_N(x))}{v_{\\Omega}(x)}</span></div>

    <p class="text-gray-300">to a low-degree polynomial, one samples a random point <em>z</em> ←\\$ <em>F</em> outside the domain <em>D</em>, and let the prover provide evaluations claims <em>v<sup>i</sup></em> , <em>i</em> = 1<em>, . . . , w</em> for <em>p<sup>i</sup></em> , and <em>v</em> for <em>h</em>, which are used to check the identity <a href="#page-13-3">\\(12\\)</a> at <em>X</em> = <em>z</em>. The validity of the values are supported by proving proximity of the point evaluation quotients</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{f_i(x) - v_i}{x - z}, \\quad i = 1, \\dots, w,</span></div>

    <p class="text-gray-300">as well as</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{h(x) - v}{x - z}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">to corresponding low-degree polynomials. Furthermore, by decomposing <em>h</em>(<em>X</em>) into into polynomials of degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ω</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">− 1, e.g.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-14-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$h(X) = h_0(X) + X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot h_1(X) + \\dots + X^{(d-1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot h_{d-1}(X), \\tag{13}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">one can even use a sampling domain the size of which is not determined by the degree of <em>h</em>(<em>X</em>). (We use a different decomposition as in <a href="#page-21-0">\\[BGKS20,</a> [Sta23\\]](#page-21-1), which does not imply any further constraints on the sampling space for <em>z</em>.)</p>

    <p class="text-gray-300">In the unique decoding regime, the DEEP-ALI approach is equivalent to a (univariate) polynomial IOP using FRI as a polynomial commitment scheme as described in Chapter <a href="#page-10-0">4.</a> For larger proximity parameters, one can generalize the polynomial oracle model to list polynomial commitment schemes as done in [\\[KPV19\\]](#page-21-2), but their approach does not yield soundness bounds which are as tight as given by the correlated agreement theorem. In order not to introduce yet another oracle model which reflects this specific correlated agreement property of batched FRI, we directly show how to apply the DEEP method to proving satisfiability of an algebraic intermediate representation.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8"><strong>5.2 DEEP-ALI of an AIR</strong></h3>

    <p class="text-gray-300">An <em>algebraic intermediate representation (AIR)</em>, see <a href="#page-20-5">\\[BBHR18b,</a> <a href="#page-21-0">BGKS20,</a> [Sta23\\]](#page-21-1), is defined over an FFT domain <em>H</em> ⊂ <em>F</em> with generator <em>g</em>. Each <em>x</em> in <em>H</em> carries a "row" of <em>w</em> witnesses (or, "columns")</p>

    <div class="my-4 text-center"><span class="math-block">(g_1(x),..,g_w(x)),</span></div>

    <p class="text-gray-300">on which a certain number of algebraic constraints are imposed. For simplicity we restrict ourselves to constraints between neigboring rows only, i.e. polynomials</p>

    <div class="my-4 text-center"><span class="math-block">P_1, \\ldots, P_C \\in F[X_1, ..., X_w, Y_1, ..., Y_w],</span></div>

    <p class="text-gray-300">each <em>P<sup>i</sup></em> being imposed on a specified coset <em>a<sup>i</sup></em> · <em>H<sup>i</sup></em> ⊆ <em>H</em>, where <em>H<sup>i</sup></em> is a subgroup of <em>H</em>. Hence satisfiability of the AIR is defined by</p>

    <p class="text-gray-300"><span id="page-14-2"></span> <span class="math-block">P_i(x, g_1(x), \\dots, g_w(x), g_1(g \\cdot x), \\dots, g_w(g \\cdot x)) = 0 \\quad \\forall x \\in a_i \\cdot H_i,</span></p>

    <div class="my-4 text-center"><span class="math-block">(14)</span></div>

    <p class="text-gray-300">for every <em>i</em> = 1<em>, . . . , C</em>. In terms of polynomials <em>p</em>1(<em>X</em>)<em>, . . . , pw</em>(<em>X</em>) ∈ <em>F</em>[<em>X</em>] extending the witness functions <em>g</em>1<em>, . . . , gw</em>, satisfiability of an AIR constraint <em>P<sup>i</sup></em> on <em>a<sup>i</sup></em> · <em>H<sup>i</sup></em> can be expressed by demanding the quotient</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{P_i(p_1(X),\\ldots,p_w(X),p_1(g\\cdot X),\\ldots,p_1(g\\cdot X))}{v_{a_i\\cdot H_i}(X)}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $v_{a_i \\cdot H_i}(X) = z^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - a_i^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  is the vanishing polynomial of the coset  </span>a_i \\cdot H_i<span class="math"> , being again a polynomial. This is the approach [BBHR18b, BGKS20, Sta23]. However, instead of working with these quotients we prefer using polynomial identities similar to Plonk [GWC19]: Satisfiability of an AIR constraint  </span>P_i<span class="math">  imposed on  </span>a_i \\cdot H_i$  is equvialent to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math-block">s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(g \\cdot X), \\dots, p_1(g \\cdot X)) = 0 \\mod v_H(X),</span>  (15)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span id="page-15-1"></span> <span class="math-block">s_i(X) = \\frac{v_H(X)}{v_{a_i \\cdot H_i}(X)} \\in F[X]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\tag{16}</span></div>

    <p class="text-gray-300">is the selector polynomial<sup>6</sup> for the constraint  <span class="math">P_i</span> . The overall degree of the AIR is defined as</p>

    <div class="my-4 text-center"><span class="math-block">d = \\max_{i} \\deg(P_i),\\tag{17}</span></div>

    <p class="text-gray-300">where  <span class="math">deg(P_i)</span>  is the total degree of  <span class="math">P_i</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The sampling domain D for FRI is chosen so that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\beta \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , with a blow-up factor  </span>\\beta = 1/\\rho<span class="math">  being a power of two, and  </span>\\mathsf{RS}_k[D,F]$  is the Reed-Solomon code of length n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and rate  <span class="math">\\rho = \\frac{k}{n}</span> , with</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$k =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. (18)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, the agreement parameter used for FRI is taken slightly larger than  <span class="math">\\alpha = \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho}, m \\ge 3</span> , namely</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{+} = \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho^{+}}, \\quad m \\ge 3, \\tag{19}</span></div>

    <p class="text-gray-300">where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\rho^{+} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.\\tag{20}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The reason for this slightly larger choice is due to the evaluation quotients of the protocol, which are subject to the FRI proof. Their denominators are at most quadratic and hence the degree of the non-quotients is bounded by</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 + 2. The low-degree extensions  <span class="math">p_i(X) \\in F[X]</span>  of the witness functions  <span class="math">g_i</span>  on H are provided as code words over D, and to use again the same code for a polynomial h(X) of larger degree, we split it into segment polynomials as in (13).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The DEEP-ALI protocol (for simplicity without zero-knowledge) for our AIR is as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-15-2"></span><strong>Protocol 3</strong> (IOP for AIR using DEEP-ALI). Let  <span class="math">p_1(X), \\ldots, p_w(X) \\in F[X]</span>  be polynomials of degree  $\\deg p_i(X) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">  satisfying the AIR constraints (14),  </span>i = 1, \\ldots, C$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The prover sends the domain evaluation oracles  <span class="math">[p_1], \\ldots, [p_w]</span>  for  <span class="math">p_1(X), \\ldots, p_w(X)</span>  to the verifier, who responds with a randomness  <span class="math">\\lambda \\leftarrow F</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2. The prover computes  <span class="math">h_{\\lambda}(X) \\in F[X]</span>  of degree  $\\leq d \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)$  satisfying the identity</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = h_{\\lambda}(X) \\cdot v_H(X),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-15-0"></span><sup>&</sup>lt;sup>6</sup>Notice that, although deg  $s_i(X) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> , the polynomial  </span>s_i(X)$  can be succinctly evaluated outside H using the rational representation from (16). Therefore no evaluation has to be provided by the prover.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>splits it into its segment polynomials hλ,j</em> (<em>X</em>)<em>, j</em> = 0<em>, . . . , d</em> − 1<em>, each of degree</em> ≤</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>H</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">− 1<em>, as in</em> <a href="#page-14-1">\\(13\\)</a><em>, and sends their domain evaluation oracles</em> [<em>hλ,</em>0]<em>, . . . ,</em> [<em>hλ,d</em>−1] <em>to the verifier. The overall identity to be proven is therefore</em></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-16-0"></span> $$\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX))</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= v_H(X) \\cdot \\sum_{j=0}^{d-1} X^{j \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot h_{\\lambda, j}(X).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(21)</p>

    <p class="text-gray-300"><em>The verifier answers with a DEEP query, i.e. a random z</em> ←\\$ <em>F</em> \\ (<em>D</em> ∪ <em>H</em>)<em>.</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>3. Upon receiving the DEEP query z, the prover sends the evaluation claims</em> (<em>z, vi,</em>1)<em>,</em> (<em>g</em> · <em>z, vi,</em>2)<em>, i</em> = 1<em>, ..., w, for the witness polynomials pi</em>(<em>X</em>)<em>, and</em> (<em>z, v<sup>j</sup></em> )<em>, j</em> = 0<em>, ..., d</em> − 1<em>, for the segment polynomials hλ,j</em> (<em>X</em>)<em>, to the verifier.</em></li>

      <li><em>4. Eventually, prover and verifier run batched FRI for proximity of the evaluation quotients</em></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\frac{p_i(x) - V_i(x)}{(x-z) \\cdot (x-gz)},</span></div>

    <p class="text-gray-300"><em>where Vi</em>(<em>x</em>) <em>is determined from the evaluation claims as described in Section <a href="#page-11-1">4.1.3,</a> i</em> = 1<em>, . . . , w, and</em></p>

    <div class="my-4 text-center"><span class="math-block">\\frac{h_{\\lambda,j}(x)-v_j}{x-z},</span></div>

    <p class="text-gray-300"><em>j</em> = 0<em>, .., d</em> − 1<em>, to RSk</em>[<em>F, D</em>]<em>, where the chosen agreement parameter is α</em> <sup>+</sup> <em>as defined above. If FRI passes, and if the evaluation claims satisfy the overall identity</em> <a href="#page-16-0">\\(21\\)</a> <em>at X</em> = <em>z, the verifier accepts. (Otherwise, it rejects.)</em></p>

    <p class="text-gray-300"><em>Remark</em> 5<em>.</em> Notice that the polynomial <em>si</em>(<em>X</em>) can only be succinctly evaluated outside <em>H</em>. For this reason that <em>H</em> is excluded from the sampling space of <em>z</em>.</p>

    <p class="text-gray-300"><em>Remark</em> 6<em>.</em> As discussed above, our definition of AIR is equivalent to the one from <a href="#page-20-5">\\[BBHR18b,</a> <a href="#page-21-0">BGKS20,</a> [Sta23\\]](#page-21-1) (besides that we restricted to constraints between neighboring rows in order to keep the presentation simple). In particular the quotient polynomial <em>hλ</em>(<em>X</em>) in our protocol is the same as</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot \\frac{s_i(X)}{v_H(X)} \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = \\sum_{i=1}^{C} \\lambda^{i-1} \\cdot \\frac{P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX))}{v_{a_i \\cdot H_i}(X)},</span></div>

    <p class="text-gray-300">which is the batched rational function used in their line of work.</p>

    <p class="text-gray-300"><em>Remark</em> 7<em>.</em> Let us point us the difference of Protocol <a href="#page-15-2">3</a> to the IOP given in [\\[Sta23\\]](#page-21-1). Instead of using a purely linear batching strategy, we use the powers of a single randomness <em>λ</em>, which is the favoured choice in the context of proof composition. Secondly, as in [\\[BGKS20\\]](#page-21-0) we use multi-point quotients for the witness polynomials which are queried at <em>z</em> and <em>gz</em>. This reduces the number of polynomials on which FRI is applied, at the cost of only a slight increase in the choice of <em>k</em> <sup>+</sup>. Thirdly, the way we decompose <em>hλ</em>(<em>X</em>) into segment polynomials <a href="#page-14-1">\\(13\\)</a> does not further reduce the sampling space for <em>z</em>, as is needed when using a FRI-like decomposition.</p>

    <p class="text-gray-300">We finally state the soundness error of Protocol 3 in the oracle model.</p>

    <p class="text-gray-300"><span id="page-17-0"></span>Theorem 8 (DEEP-ALI soundness). The above oracle proof for AIR satisfiability has soundness error</p>

    <p class="text-gray-300"><span id="page-17-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon \\le L^+ \\cdot \\left(\\frac{C}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{d \\cdot (k^+ - 1) + (k - 1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\cup H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) + \\varepsilon_{FRI},\\tag{22}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with  <span class="math">k^+ = k + 2</span> ,  <span class="math">L^+ = \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho^+}}</span> ,  <span class="math">\\rho^+ = \\frac{k^+}{n}</span> , and  <span class="math">\\varepsilon_{FRI}</span>  being the soundness error for batched FRI for  <span class="math">\\alpha^+</span> -agreement with  <span class="math">RS_k[F,D]</span> , Theorem 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 9. We point out some differences to the error bound in [Sta23], Theorem 4. In our bound the list size bound  <span class="math">L^+</span>  only occurs linearly instead of quadratically. This due to our more careful analysis of the consequences of the correlated agreement enforced on polynomials produced in different rounds of the protocol. Secondly, as mentioned above, the alternative decomposition of  <span class="math">h_{\\lambda}(X)</span>  into segment polynomials does not reduce the sampling space for z by a factor d larger domain. Less importantly, since we use do algebraic batching using the powers of  <span class="math">\\lambda</span> , the first term incorporates the number of constraints C. A purley linear batching strategy, as used in [Sta23] leads to  $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  instead.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 10. In the soundness error formula in [BGKS20], Theorem 15, the list bound  <span class="math">L^+</span>  occurs quadratically. This is due to the application of two separate FRI arguments, one for the batched quotients of the witness polynomials, and another one for the overall quotient polynomial. (However, the splitting technique for h is outlined in Section 5.5. therein.) For the same reason, the notion of list polynomial commitment schemes from [KPV19] would lead to the w-th power of  <span class="math">L^+</span> , w being the number of witness columns. This might be acceptable for proving soundness of standard Plonk in the list polynomial oracle model, but not for a larger number of witness columns.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Theorem 8. Let us denote  $\\varepsilon_1 = L^+ \\cdot \\frac{C}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ,  </span>\\varepsilon_2 = L^+ \\cdot \\frac{d \\cdot (k^+ - 1) + (k - 1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\cup H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , and  </span>\\varepsilon_3 = \\varepsilon_{FRI}<span class="math"> . Suppose that  </span>P^<em><span class="math">  is an adversary which succeeds the verifier with a probability exceeding  </span>\\varepsilon = \\varepsilon_1 + \\varepsilon_2 + \\varepsilon_3<span class="math"> . Then there exists a first message of  </span>P^</em><span class="math"> , i.e. words  </span>f_1, \\ldots, f_w<span class="math">  on D, on which  </span>P^*<span class="math">  succeeds with probability  </span>> \\varepsilon$ , and hence</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\lambda : \\Pr\\left(P^* \\text{ succeeds }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda\\right) > \\varepsilon_2 + \\varepsilon_3\\right] > \\varepsilon_1.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(Otherwise  <span class="math">\\Pr[P^<em> \\text{ succeeds }] \\leq 1 \\cdot \\varepsilon_1 + (\\varepsilon_2 + \\varepsilon_3) \\cdot (1 - \\varepsilon_1) &lt; \\varepsilon_1 + \\varepsilon_2 + \\varepsilon_3</span> .) Likewise, for every such "good"  <span class="math">\\lambda</span>  (by the definition of  <span class="math">\\varepsilon_1</span> , there are at least  <span class="math">L^+ \\cdot C</span>  many) there exists a second message of  <span class="math">P^</em></span> , i.e. words  <span class="math">h_{\\lambda,0}, \\ldots, h_{\\lambda,d-1}</span>  on D such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[z \\in F \\setminus D : \\Pr(P^* \\text{ succeeds }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z) > \\varepsilon_3\\right] > \\varepsilon_2.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each such "good"  <span class="math">z \\in F \\setminus (D \\cup H)</span>  (by the definition of  <span class="math">\\varepsilon_2</span> , there are more than  <span class="math">L^+ \\cdot (d \\cdot (k^+ - 1) + (k - 1))</span>  many) the evaluation claims pass the verifier checks, and moreover the soundness of FRI enforces the evaluation quotients</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{f_1(x) - V_1(x)}{(x - z) \\cdot (x - g \\cdot z)}, \\dots, \\frac{f_w(x) - V_w(x)}{(x - z) \\cdot (x - g \\cdot z)}, \\frac{h_{\\lambda,0}(x) - v_0}{x - z}, \\dots, \\frac{h_{d-1}(x) - v_{d-1}}{x - z}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">to have correlated agreement with some  <span class="math">q_i(X) \\in F[X]</span> , i = 1, ..., w + d, of degree  $\\deg q_i(X) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">  on a set A of density at least  </span>\\alpha^+ > \\sqrt{\\rho^+}$ . Cancelling out the denominators, we see that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(f_1,\\ldots,f_w,h_{\\lambda,0},\\ldots,h_{\\lambda,d-1})</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">have correlated agreement on a set of density  <span class="math">\\geq \\alpha^+</span>  with some element from  <span class="math">F[X]^{w+d}</span>  where each component polynomial is of degree  $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 + 2 = k^+ - 1$ , and satisfies the evaluation claim.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In what follows we shall call an element  <span class="math">(P_0(X), \\ldots, P_{l-1}(X))</span>  from  <span class="math">F[X]^l</span> , with component polynomials of degree  <span class="math">\\leq k^+ - 1</span> , having correlated agreement with a vector of functions  <span class="math">(\\phi_0(x), \\ldots, \\phi_{l-1}(x))</span>  on a set of density  <span class="math">\\geq \\alpha^+</span> , an  <span class="math">\\alpha^+</span> -configuration for that vector of functions. Another way to express this, is that</p>

    <div class="my-4 text-center"><span class="math-block">P(X) = \\sum_{i=0}^{l-1} P_i(X) \\cdot Z^i,</span></div>

    <p class="text-gray-300">belonging to the Reed-Solomon code  <span class="math">\\mathsf{RS}_{k^+}[K,D]</span>  over the rational function field K=F(Z) is  <span class="math">(1-\\alpha^+)</span> -close to the K-valued function  <span class="math">\\phi(x) = \\sum_{i=0}^{l-1} \\phi_i(X) \\cdot Z^i</span> . Note that since  <span class="math">\\alpha^+ &gt; \\sqrt{\\rho^+}</span> , the Guruswami-Sudan list size bound (over general fields, see Appendix A.2) is applicable to  <span class="math">\\mathsf{RS}_{k^+}[K,D]</span> . In particular, there are at most</p>

    <div class="my-4 text-center"><span class="math-block">L^+ = \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho^+}}</span></div>

    <p class="text-gray-300"> <span class="math">\\alpha^+</span> -configurations for  <span class="math">(\\phi_0(x), \\dots, \\phi_{l-1}(x))</span> .</p>

    <p class="text-gray-300">Let us keep a combination of "good" first and second messages  <span class="math">(f_1, \\ldots, f_w)</span> ,  <span class="math">(h_{\\lambda,0}, \\ldots, h_{\\lambda,d-1})</span>  fixed. We have seen above that the existence of a single "good" z implies the existence of an  <span class="math">\\alpha^+</span> -configuration for  <span class="math">(f_1, \\ldots, f_w, h_{\\lambda,0}, \\ldots, h_{\\lambda,d-1})</span> . By the Guruswami-Sudan list size bound for  <span class="math">\\mathsf{RS}_{k^+}(K,D)</span>  (see Appendix A.2) there are at most  <span class="math">L^+</span>  such  <span class="math">\\alpha^+</span> -configurations. However, since there are more than  <span class="math">L^+</span>  ( <span class="math">d \\cdot (k^+ - 1) + (k - 1)</span> ) many "good" z, and each establishes an  <span class="math">\\alpha^+</span> -configuration which smoreover evaluates to the claimed values, we conclude from the pigeon-hole principle that there is at least one  <span class="math">\\alpha^+</span> -configuration,</p>

    <div class="my-4 text-center"><span class="math-block">(p_1,\\ldots,p_w,q_{\\lambda,0},\\ldots,q_{\\lambda,d-1})\\in F[X]^{w+d},</span></div>

    <p class="text-gray-300">for which the overall identity (21) (taking the  <span class="math">q_{\\lambda,j}</span>  as  <span class="math">h_{\\lambda,j}</span>  therein) holds at more than  <span class="math">d \\cdot (k^+ - 1) + (k - 1)</span>  many z. By the degree of the identity, this configuration is a solution of it, hence  <span class="math">(p_1, \\ldots, p_w) \\in F[X]^w</span>  is an  <span class="math">\\alpha^+</span> -configuration for  <span class="math">(f_1, \\ldots, f_w)</span>  which satisfies</p>

    <p class="text-gray-300"><span id="page-18-1"></span> <span class="math-block">\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = 0 \\mod v_H(X).</span> (23)</p>

    <p class="text-gray-300">Now let us keep a "good" first message  <span class="math">(f_1, \\ldots, f_w)</span>  fixed. We have seen that for each "good"  <span class="math">\\lambda</span>  there exists an  <span class="math">\\alpha^+</span> -configuration for  <span class="math">(f_1, \\ldots, f_w)</span>  which is a solution of (23). Again, by the Guruswami-Sudan list size bound for  <span class="math">\\mathsf{RS}_{k^+}[K,D]</span> , there can be at most  <span class="math">L^+</span>  many w-configurations. Since there are at least  <span class="math">L^+ \\cdot C</span>  many "good"  <span class="math">\\lambda</span> , we conclude again from the pigeon-hole principle that there is at least one  <span class="math">\\alpha^+</span> -configuration, which we again denote by  <span class="math">(p_1,\\ldots,p_w)</span> , for which there are at least C many "good"  <span class="math">\\lambda</span>  for which (23) holds. By linear algebra (the Vandermonde matrix is invertible) we conclude that this configuration satisfies</p>

    <div class="my-4 text-center"><span class="math-block">s_i(X) \\cdot P_i(X, p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = 0 \\mod v_H(X)</span></div>

    <p class="text-gray-300">for every  <span class="math">i=1,\\ldots,C</span> . The values of  <span class="math">(p_1,\\ldots,p_w)</span>  over H satisfy the constraints the AIR. This completes the proof.</p>

    <p class="text-gray-300"><span id="page-18-0"></span>We note that in Equation (22), the term in the brackets is exactly the soundness error bound of the protocol in the (univariate) polynomial IOP model [BFS20]. As soundness in this model is essentially based on the Schwartz-Zippel lemma, we believe that the blow-up by the factor  <span class="math">L^+</span>  holds in general for every (public coin) polynomial IOP when replacing polynomial oracles by domain-evaluation oracles. (At least for the polynomial IOPs we know, such as [GWC19, MBKM19, CHM <span class="math">^+</span> 20] or [HGdB21], this is the case.) Such a general transformation of (univariate) polynomial IOPs into ordinary (i.e. domain-evaluation) IOPs would be of interest, as the polynomial IOP model is widely used by practicioners. The protocol design as well as its security analysis is much easier to understand in the polynomial oracle model, and their soundness error bounds could be easily taken over. We plan to elaborate on this in a separate document.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.2.1 Extractability</h3>

    <p class="text-gray-300">We only provide a brief sketch how to build the extractor in the oracle model, given a prover  <span class="math">P^*</span>  which succeeds with a probability of that exceeds the soundness error bound from Theorem 8:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Sample a "good" first message  <span class="math">[f_1], \\ldots, [f_w]</span>  on which the prover succeeds with a probability greater than the soundness error bound from Theorem 8.</li>

      <li>2. In this step we build a straight-line extractor from the "good" first message  <span class="math">[f_1], \\ldots, [f_w]</span>  pbtained in Step (1): Read  <span class="math">f_1, \\ldots, f_w</span>  from the oracles. By the proof of Theorem 8,  <span class="math">(f_1, \\ldots, f_w)</span>  agrees with an AIR solution  <span class="math">(p_1(X), \\ldots, p_w(X)) \\in F[X]^w</span>  on a set A of density  <span class="math">\\geq \\alpha^+</span> . To obtain this solution, one repeatedly applies the Guruswami-Sudan list decoder<sup>7</sup>and "intersects" their outputs as described in [Sta23], Section 5.5. One of the resulting configurations must be the one that satisfies the AIR.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first step takes expected time  <span class="math">O(1/\\varepsilon)</span> , and the Gurswami-Sudan decoder consumes at most  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{15})<span class="math">  field operations, see Remark 14. To obtain strict polynomial running time, at the cost of having a success probability &lt; 1, one may stop the sampling after an appropriate multiple of  </span>1/\\varepsilon$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.3 Boosting soundness</h3>

    <p class="text-gray-300">In this section we outline standard techniques to lower the DEEP-ALI soundness error for AIRs over small fields F. (See [Sta23], or [?].)</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">5.3.1 Using extension fields</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One simply draws queries (for example the DEEP queries and the FRI challenges) from a suitable large extension field  <span class="math">F_e</span>  of F. The soundness error bound lowers accordingly, replacing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . (Notice that the disadvantage of applying this approach to the entire protocol is that all FRI quotients have to be computed over  </span>F_e$ .)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">5.3.2 Increasing the number of protocol challenges</h4>

    <p class="text-gray-300">Instead of drawing protocol challenges from an extension field, one may repeatedly sample a challenge and run the remaining protocol for them in parallel. For instance, the first verifier challenge  <span class="math">\\lambda</span>  can be sampled  <span class="math">N_1</span>  times,  <span class="math">\\lambda_1, \\ldots, \\lambda_{N_1} \\leftarrow F</span> , and prove the overall polynomial identity (21) for all of these cases. This yields a lowered soundness error bound of the first round,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon_1 = \\left(L^+ \\cdot \\frac{C}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{N_\\lambda},\\,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and increases only the number of  <span class="math">h_{\\lambda,j}</span>  polynomials (by the factor  <span class="math">N_{\\lambda}</span> ) that are subject to the DEEP queries in the second round. Likewise, one may also take several DEEP queries  <span class="math">z_1, \\ldots, z_{N_z}</span>  from  <span class="math">F \\setminus D</span> , and apply FRI to the batch of all resulting quotients, lowering the soundness error bound of the second round to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon_2 = \\left(L^+ \\cdot \\frac{d \\cdot (k^+ - 1) + (k - 1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F \\setminus (D \\cup H)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{N_z}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, this comes at the cost of increasing the entire batch for FRI by the factor  <span class="math">N_z</span>  (which might be acceptable in some applications, though). On the contrary, resampling of FRI challenges would increase the proof size too much. Hence for FRI extension field sampling is preferable.</p>

    <p class="text-gray-300"><span id="page-19-4"></span><span id="page-19-3"></span><sup>&</sup>lt;sup>7</sup>Alternatively one could run the Guruswami-Sudan list decoder over K = F(Z). However, its run-time analysis in the number of operations over F is probably more difficult.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">5.4 Beyond the Johnson bound?</h4>

    <p class="text-gray-300">The conjectured soundness error for FRI alone (Conjecture 1) is not good enough to argue the security of DEEP-ALI beyond the Guruswami-Sudan list decoding bound. For that reason we also cite a general conjecture on the list decodability of Reed-Solomon codes, which is used by Ben-Sasson et al. to conjecture the soundness error of DEEP-FRI up to capacity bound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Conjecture 2.</strong> ([BGKS20], Conjecture 21) Let  <span class="math">RS_k[F,D]</span>  be the Reed-Solomon code over a prime field  <span class="math">F = F_q</span>  with defining domain D and rate  $\\rho = \\frac{k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Then there exists a constant  </span>C_\\rho<span class="math">  such that for every  </span>\\theta = 1 - \\rho - \\eta<span class="math"> , with  </span>\\eta > 0<span class="math"> ,  </span>RS_k[F,D]<span class="math">  is list-decodable from a fraction of  </span>\\theta$  errors with list size</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$L \\le \\left(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\eta}\\right)^{C_{\\rho}}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 11. No concrete assumptions on the constant  <span class="math">C_{\\rho}</span>  are made in [BGKS20].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For quite large fields F (compared to the block length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n) there are linear codes which are list decodable up to capacity bound  <span class="math">1-\\rho</span> , such as the folded Reed-Solomon codes (see [Gur07], e.g.). In the case of a bounded alphabet, Guruswami [Gur07] demonstrates binary linear codes which are list decodable to the Zyablow bound  <span class="math">\\frac{1-\\rho}{H}</span>  (here, H is the entropy of the code) and uses such codes to construct examples that approach capacity bound, having list size  <span class="math">L=O\\left(\\frac{1}{\\eta}\\right)</span> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, practitioners seem to avoid this conjecture. The ethSTARK documentation [Sta23] takes a toy protocol as a representative for the entire DEEP-ALI of AIR, whereas the Plonky2 writeup [?] only sketches soundness in the polynomial oracle model, with no reference to list bounds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-20-0"></span>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast Reed-Solomon interactive oracle proofs of proximity. In <em>ICALP 2018</em>, 2018. Full paper: https://eccc.weizmann.ac.il/report/2017/134/.</li>

      <li><span id="page-20-5"></span>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. In <em>IACR ePrint Archive 2018/046</em>, 2018. https://eprint.iacr.org/2018/046.</li>

      <li><span id="page-20-3"></span>[BCC<sup>+</sup>16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In M. Fischlin and J.S. Coron, editors, <em>EUROCRYPT 2016</em>, volume 9666 of <em>LNCS</em>. Springer, 2016. Full paper: https://eprint.iacr.org/2016/263.</li>

      <li><span id="page-20-1"></span>[BCI<sup>+</sup>20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for Reed-Solomon codes. In <em>FOCS 2020</em>, 2020. Full paper: https://eprint.iacr.org/2020/654.</li>

      <li><span id="page-20-4"></span>[BCR<sup>+</sup>19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Y. Ishai and Vincent Rijmen, editors, <em>EUROCRYPT 2019</em>, volume 11476 of <em>LNCS</em>. Springer, 2019.</li>

      <li><span id="page-20-2"></span>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In <em>TCC</em> 2016, pages 31–60, 2016.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-21-6"></span>[BDFG21] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Halo Infinite: Recursive zk-snarks from additive polynomial commitments. In <em>CRYPTO 2021</em>, volume 12825 of <em>LNCS</em>. Springer, 2021. Full paper: <https://eprint.iacr.org/2020/1536>.</li>

      <li><span id="page-21-3"></span>[BFS20] Benedikt B¨unz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In <em>EUROCRYPT 2020</em>, 2020. Full paper: <https://eprint.iacr.org/2019/1229>.</li>

      <li><span id="page-21-0"></span>[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling outside the box improves soundness. In <em>ITCS 2020</em>, 2020. Full paper: <a href="https://eprint.iacr.org/2019/336">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2019/336">org/2019/336</a>.</li>

      <li><span id="page-21-9"></span>[CHM+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In <em>EUROCRYPT 2020</em>, volume 12105 of <em>LNCS</em>, 2020. Full paper: <https://eprint.iacr.org/2019/1047.pdf>.</li>

      <li><span id="page-21-14"></span>[GS99] Venkatesan Guruswami and Madhu Sudan. Improved decoding of Reed-Solomon and algebraic-geometry codes. In <em>IEEE Trans. on Information Theory</em>, volume 45(6), 1999.</li>

      <li><span id="page-21-11"></span>[Gur07] Venkatesan Guruswami. Algorithmic results in list decoding. In <em>Foundation and Trands in Theoretical Computer Science</em>, volume 2(2), 2007.</li>

      <li><span id="page-21-7"></span>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical non-interactive arguments of knowledge. In <em>IACR ePrint Archive 2019/953</em>, 2019. <https://eprint.iacr.org/2019/953>.</li>

      <li><span id="page-21-10"></span>[HGdB21] Ulrich Hab¨ock, Alberto Garoffolo, and Daniele di Benedetto. Darlin: Recursive proofs based on Marlin. In <em>IACR preprint archive 2021/930</em>, 2021. <https://eprint.iacr.org/2021/930>.</li>

      <li><span id="page-21-5"></span>[HK24] Ulrich Hab¨ock and Al Kindi. A note on adding zero-knowledge to STARKs. In <em>IACR ePrint Archive 2024/1037</em>, 2024. <https://eprint.iacr.org/2024/1037>.</li>

      <li><span id="page-21-2"></span>[KPV19] Assimakis Kattis, Konstantin Panarin, and Alaxander Vlasov. REDSHIFT: Transparent snarks from list polynomial commitment IOPs. In <em>IACR preprint archive 2019/1400</em>, 2019. <https://eprint.iacr.org/2019/1400>.</li>

      <li><span id="page-21-8"></span>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In <em>ACM SIGSAC Conference on Computer and Communication Security</em>, pages 2111–2128, 2019. Full paper: <https://eprint.iacr.org/2019/099>.</li>

      <li><span id="page-21-4"></span>[Pol] Polygon Labs / Polygon Zero. Plonky2: Fast recursive arguments with PLONK and FRI. <https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf>.</li>

      <li><span id="page-21-1"></span>[Sta23] StarkWare Team. ethSTARK documentation – version 1.2. In <em>IACR preprint archive 2021/582</em>, 2023. <https://eprint.iacr.org/2021/582>.</li>

      <li><span id="page-21-13"></span>[Sud97] Madhu Sudan. Decoding of Reed Solomon codes beyond the error-correction bound. In <em>Journal of Complexity</em>, volume 13(1), 1997.</li>

      <li><span id="page-21-12"></span>[WB86] Lloyd R. Welch and Elwyn R. Berlekamp. Error correction for algebraic block codes. US Patent 4633470, 1986. <https://patents.google.com/patent/US4633470A>.</li>

    </ul>

    <p class="text-gray-300">In this section we recap well-known facts on decodability of Reed-Solomon codes<sup>8</sup>, and describe the weighted variant of Theorem 1, which is used by the soundness analysis of FRI.</p>

    <p class="text-gray-300">Unless contrary stated, we assume that K is a <em>general</em> field (finite, or infinite), and as for finite fields we shall call</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{RS}_k[K,D] = \\{ p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in D} \\ : \\ p(X) \\in K[X], \\deg p(X) \\le k - 1 \\}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the Reed-Solomon code with rate  $\\rho = \\frac{k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  and blocklength n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. We say that a family of codes  <span class="math">\\{V(n)\\}</span>  of increasing blocklength n is list decodable up to distance  <span class="math">\\theta \\in (0,1)</span> , if the maximum possible number of  <span class="math">\\theta</span> -close codewords,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$L = \\sup_{f \\in K^D} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B(f, \\theta) \\cap V(n) \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is polynomial in the blocklength n. (Here,  <span class="math">B(f,\\theta) = \\{w \\in \\mathsf{RS}_k[K,D] : \\delta(f,w) &lt; \\theta\\}</span>  is the open -ball around f, and  <span class="math">\\delta</span>  is the fractional Hamming distance.) As in the main part of the document, we throughout assume that both n and k are even.</p>

    <h2 id="sec-35" class="text-2xl font-bold">A.1 Berlekamp-Welch decoder</h2>

    <p class="text-gray-300">Assume that  <span class="math">f \\in K^D</span>  is at most  <span class="math">\\theta_0</span> -close to V, with  <span class="math">\\theta_0 = \\frac{1-\\rho}{2}</span>  being the unique decoding radius, and let p(X) be the unique polynomial of degree  <span class="math">\\leq k-1</span>  such that  <span class="math">\\delta(f,p) \\leq \\theta_0</span> . Then the number of points of disagreement is at most  <span class="math">e = \\frac{n-k}{2}</span> . The Berlekamp-Welch decoder [WB86] is based on the observation that if  <span class="math">\\Omega = \\{x_1, \\ldots, x_e\\}</span>  is the set of errors, and  <span class="math">E(x) = \\prod_{x \\in \\Omega} (X - x)</span>  is its vanishing polynomial, then we have</p>

    <div class="my-4 text-center"><span class="math-block">E(x) \\cdot f(x) = E(x) \\cdot p(x)</span></div>

    <p class="text-gray-300">for all  <span class="math">x \\in D</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-22-4"></span><strong>Protocol 4</strong> (Welch-Berlekamp decoding). Let K be a general field, and  <span class="math">V = \\mathsf{RS}_k[K,D]</span>  be the Reed-Solomon code of length n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and rate  <span class="math">\\rho = \\frac{k}{n}</span> . Assume any word  <span class="math">f \\in K^D</span> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find the coefficients of polynomials E(X), G(X) over K with  <span class="math">\\deg E(X) \\leq e</span> ,  <span class="math">\\deg G(X) \\leq k-1+e</span> , where  <span class="math">e = \\frac{n-k}{2}</span> , such that</li>

    </ol>

    <p class="text-gray-300"><span class="math-block">E(x) \\cdot w(x) = G(x)</span>  for all  <span class="math">x \\in D</span> .</p>

    <p class="text-gray-300">This linear system has at least one non-trivial solution which can be found in at most  <span class="math">O(n^3)</span>  field operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This is a homogeneous linear system of</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n equations in  <span class="math">k + 2 \\cdot e + 1 = n + 1</span>  unknown: The e + 1 coefficients of E(X) and the k + e coefficients of G(X).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Notice that for any such non-trivial solution (E(X), G(X)) the polynomial E(X) must be non-trivial. If E(x) would be identically zero, by the size of D the same is true G(x).</p>

    <p class="text-gray-300"><span id="page-22-3"></span>2. For any such non-trivial solution (E(X), G(X)) obtained in step 1, check if G(X) is divisible by E(X). If yes, then output  <span class="math">p(X) = \\frac{G(X)}{E(X)}</span> . (If not, then abort.)</p>

    <p class="text-gray-300">For a word  <span class="math">f \\in K^D</span>  with fractional Hamming distance of at most  <span class="math">\\theta_0</span> , Step (2) of Protocol 4 always succeeds: Let p(X) be the (unique)  <span class="math">\\theta_0</span> -close code word. This polynomial agrees with f on a set of size  <span class="math">a \\ge \\frac{n+k}{2}</span> . Consider the bivariate polynomial</p>

    <div class="my-4 text-center"><span class="math-block">Q(X,Y) := Y \\cdot E(X) - G(X).</span></div>

    <p class="text-gray-300"><span id="page-22-2"></span><sup>&</sup>lt;sup>8</sup>The survey by Guruswami [Gur07] is a recommended source.</p>

    <p class="text-gray-300">Then Q(X, p(X)) is a univariate polynomial of degree</p>

    <div class="my-4 text-center"><span class="math-block">\\deg Q(X, p(X)) \\le k - 1 + e = \\frac{n+k}{2} - 1,</span></div>

    <p class="text-gray-300">which by the assumption on p(X) has at least a zeroes. Consequently Q(X, p(X)) is trivial and  <span class="math">p(X) \\cdot E(X) = G(X)</span>  holds as a formal identity. Since E(X) is non-trivial, we conclude divisibility.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">A.2 List decoding</h3>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">A.2.1 The Sudan decoder</h4>

    <p class="text-gray-300">The Sudan list decoder [Sud97] generalizes the Berlekamp-Welch procedure by searching for general bivariate polynomials  <span class="math">Q(X,Y) \\in K[X,Y]</span>  which satisfy</p>

    <p class="text-gray-300"><span class="math-block">Q(x, f(x)) = 0</span>  for all  <span class="math">x \\in D</span> .</p>

    <p class="text-gray-300">In order that Y - p(X) is a factor of Q(X, Y) for every polynomial p(X) of degree  <span class="math">\\leq d = k - 1</span>  which has the claimed agreement set size with f, one looks for such bivariate Q so that the degree of Q(X, p(X)) for any such polynomial is smaller than the targeted agreement set size.</p>

    <p class="text-gray-300"><strong>Definition 12.</strong> The (1,d)-weighted degree (in short, (1,d)-degree) of a monomial  <span class="math">X^i \\cdot Y^j</span>  is  <span class="math">i+d \\cdot j</span> . More generally, the (1,d)-weighted degree of a bivariate polynomial Q(X,Y) is the maximum of the weighted degrees of its monomials.</p>

    <p class="text-gray-300">A polynomial Q(X,Y) of (1,d)—weighted degree W is of the form</p>

    <div class="my-4 text-center"><span class="math-block">Q(X,Y) = \\sum_{i+d \\cdot j \\le W, i,j \\ge 0} c_{i,j} \\cdot X^i \\cdot Y^j,</span></div>

    <p class="text-gray-300">and its number of coefficients is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\sum_{j=0}^{\\lfloor W/d \\rfloor} W - d \\cdot j + 1 &amp;= (W+1) \\cdot \\left( \\left\\lfloor \\frac{W}{d} \\right\\rfloor + 1 \\right) - d \\cdot \\frac{\\left\\lfloor \\frac{W}{d} \\right\\rfloor \\cdot \\left( \\left\\lfloor \\frac{W}{d} \\right\\rfloor + 1 \\right)}{2} \\\\ &amp;\\geq \\left( \\left\\lfloor \\frac{W}{d} \\right\\rfloor + 1 \\right) \\cdot \\left( W + 1 - \\frac{W}{2} \\right) \\\\ &amp;\\geq \\frac{(W+1) \\cdot (W+2)}{2 \\cdot d} \\end{split}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a consequence, if this lower bound exceeds the number of linear equations n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, the linear system has a non-trivial solution. In particular this holds for any</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$W \\ge \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{2 \\cdot d \\cdot n} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Protocol 5</strong> (Sudan list decoder). Assume that K is a general field, and  <span class="math">\\mathsf{RS}_k[K,D]</span>  is the Reed-Solomon code of length n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and rate  <span class="math">\\rho = \\frac{k}{n}</span> . Let  <span class="math">f \\in K^D</span> , and choose an agreement parameter  <span class="math">a \\in [0,n]</span> ,  <span class="math">a &gt; \\sqrt{2 \\cdot d \\cdot n}</span> , where d = k - 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Solve the linear system on the coefficients of Q(X,Y) with (1,d)-degree  <span class="math">W = \\lfloor \\sqrt{2 \\cdot d \\cdot n} \\rfloor</span> , given by the interpolation constraints</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q(x, f(x)) = 0, \\quad x \\in D.</span></div>

    <p class="text-gray-300">This system has a non-trivial solution which is found in at most  <span class="math">O(n^3)</span>  field operations. Note that by construction, for any  <span class="math">\\left(1-\\frac{a}{n}\\right)</span> -close code word p(X) the (irreducible) polynomial Y-p(X) divides Q(X,Y) in the polynomial ring K[X,Y]. Since K[X,Y] is a unique factorization domain, this already proves that the list size  <span class="math">L \\leq \\left\\lfloor \\frac{W}{d} \\right\\rfloor \\leq \\frac{\\sqrt{2 \\cdot d \\cdot n}}{d} = \\sqrt{\\frac{2 \\cdot n}{d}}</span> .</p>

    <p class="text-gray-300"><span id="page-24-1"></span>2. Find all factors of Q(X,Y) which are of the form</p>

    <p class="text-gray-300"><span class="math-block">Y - p(X)</span> ,</p>

    <p class="text-gray-300">with p(X) being a polynomial over K of degree at most k-1. There are at most  <span class="math">\\sqrt{\\frac{2 \\cdot n}{d}}</span>  such factors. Filter out those which agree with f on at least a points.</p>

    <p class="text-gray-300">The efficiency of Step (2) depends on the field K. If K is a finite field, then there are polynomial time algorithms (both probabilistic or deterministic) for finding such factors of the form Y - p(X). (They both rely on univariate factorization, see [Gur07], e.g.) If K is infinite, then this might not be true in general.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">A.2.2 The Guruswami-Sudan decoder</h4>

    <p class="text-gray-300">To extend the interpolation technique to the Johnson limit  <span class="math">1-\\sqrt{\\rho}</span> , one takes into account that several close codewords might coincide at some points. One therefore looks for polynomials Q(X,Y) the (1,d)-degree of which is m times as large as the targeted agreement set would suggest, and which have a zero of order m at every interpolating point  <span class="math">(x, f(x)), x \\in D</span> . The parameter  <span class="math">m \\ge 1</span>  is called <em>multiplicity parameter</em>.</p>

    <p class="text-gray-300"><strong>Definition 13.</strong> A polynomial  <span class="math">Q(X,Y) \\in K[X,Y]</span>  is said to have a zero of order m at the point (x,y), if the polynomial Q(X-x,Y-y) has no monomial of absolute degree < m.</p>

    <p class="text-gray-300">Such polynomials Q(X,Y) of (1,d)-weighted degree W have still the property, that if p(X) is a polynomial of  <span class="math">\\deg p(X) \\leq d</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">\\deg Q(X, p(X)) \\le \\frac{W}{m}.</span></div>

    <p class="text-gray-300">Again, counting the number of coefficients and comparing with the number of interpolation constraints yields that whenever</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{(W+1)\\cdot(W+2)}{d\\cdot m\\cdot(m+1)} &gt; n,</span></div>

    <p class="text-gray-300">and hence in particular for  <span class="math">W \\ge \\left\\lfloor \\sqrt{m \\cdot (m+1) \\cdot d \\cdot n} \\right\\rfloor</span>  there always exists such a (non-trivial) polynomial Q(X,Y). (For details, see [Gur07], e.g.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-24-2"></span><strong>Protocol 6</strong> (Guruswami-Sudan list decoder [GS99]). Assume that K is a general field, and  <span class="math">\\mathsf{RS}_k[K,D]</span>  the Reed-Solomon code of length n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and rate  <span class="math">\\rho = \\frac{k}{n}</span> . Let  <span class="math">f \\in K^D</span> , and choose an agreement parameter  <span class="math">a \\in [0,n], \\ a &gt; \\sqrt{\\left(1 + \\frac{1}{m}\\right) \\cdot d \\cdot n}</span> , where m is a positive integer (the multiplicity parameter).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Solve the linear system on the coefficients of Q(X,Y) with (1,d)-degree  <span class="math">W = [\\sqrt{m \\cdot (m+1) \\cdot d \\cdot n}]</span> : For each  <span class="math">x \\in D</span> ,</li>

    </ol>

    <p class="text-gray-300"><span class="math-block">Q(X,Y)</span>  has a zero of order  <span class="math">m</span>  at  <span class="math">(x,f(x))</span> .</p>

    <p class="text-gray-300">Such a solution always exists and can be found in polynomially many field operations.</p>

    <p class="text-gray-300">By construction, again for any  <span class="math">\\left(1-\\frac{a}{n}\\right)</span> -close code word p(X) the irreducible polynomial Y-p(X) divides Q(X,Y). This already proves that the list size  <span class="math">L \\leq \\frac{\\sqrt{m \\cdot (m+1) \\cdot d \\cdot n}}{d} &lt; \\sqrt{\\frac{m \\cdot (m+1)}{\\rho}}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find all factors of Q(X,Y) which are of the form</li>

    </ol>

    <p class="text-gray-300"><span class="math-block">Y - p(X)</span> ,</p>

    <p class="text-gray-300">with p(X) being a polynomial over K of degree at most d = k - 1. There are at most  <span class="math">\\sqrt{\\frac{m \\cdot (m+1)}{\\rho}}</span>  many. Filter out those which agree with f on at least a points.</p>

    <p class="text-gray-300">As before, this step might be efficient or not, depending on the field K.</p>

    <p class="text-gray-300"><span id="page-25-1"></span>Remark 14. Choosing the discriminant method to find factors of the form Y - p(X), the Guruswami-Sudan list decoder taking at most</p>

    <div class="my-4 text-center"><span class="math-block">O\\left(\\max\\left\\{\\frac{d^3 \\cdot n^6 \\cdot a^6}{(a^2 - d \\cdot n)^6}, \\frac{a^6}{k^3}\\right\\}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field operations over K, see [GS99]. This is at most of order  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{15})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that choosing</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha = \\frac{a}{n} \\ge \\sqrt{\\left(1 + \\frac{1}{m}\\right) \\cdot \\rho}</span></div>

    <p class="text-gray-300">implies a large enough agreement parameter for the Protocol 6. In particular the choice  <span class="math">\\alpha = \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho}</span>  used throughout the main part of the document is strong enough, since</p>

    <div class="my-4 text-center"><span class="math-block">\\left(1 + \\frac{1}{2 \\cdot m}\\right)^2 = 1 + \\frac{1}{m} + \\frac{1}{4 \\cdot m^2} \\ge 1 + \\frac{1}{m}.</span></div>

    <p class="text-gray-300">Let us summarize the consequences of Protocol 6.</p>

    <p class="text-gray-300"><strong>Theorem 15</strong> (Guruswami-Sudan). Let K be a general (possibly infinite) field, and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{RS}_k[K,D] = \\{ p(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x \\in D} \\ : \\ p(X) \\in K[X], \\deg(p) <</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the Reed-Solomon code of block length n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and rate  <span class="math">\\rho=\\frac{k}{n}</span> . Choos a proximity parameter  <span class="math">\\theta=1-\\left(1+\\frac{1}{2\\cdot m}\\right)\\cdot\\sqrt{\\rho}</span>  for some integer  <span class="math">m\\geq 1</span> . Then  <span class="math">\\mathsf{RS}_k[K,D]</span>  is list decodable for  <span class="math">\\theta</span>  with list bound</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math-block">L \\le \\sqrt{\\frac{m \\cdot (m+1)}{\\rho}} \\le \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho}}.</span>  (24)</p>

    <p class="text-gray-300">If K is finite, then the Guruswami-Sudan decoder runs in polynomial time.</p>

    <p class="text-gray-300">We say that a function  <span class="math">f \\in F^D</span>  has  <span class="math">\\mu</span> -agreement of at least  <span class="math">\\alpha</span>  with another function  <span class="math">g \\in F^D</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{agree}_{\\mu}(f,g) &gt; \\alpha,</span></div>

    <p class="text-gray-300">if there is a set  <span class="math">A \\subseteq D</span>  of measure  <span class="math">\\mu(A) &gt; \\alpha</span>  on which both functions agree. Likewise we say that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{agree}_{\\mu}(f, \\mathsf{RS}_k) &gt; \\alpha,</span></div>

    <p class="text-gray-300">if there exists a  <span class="math">p \\in \\mathsf{RS}_k[F,D]</span>  for which  <span class="math">agree_\\mu(f,p) &gt; \\alpha</span> .</p>

    <p class="text-gray-300"><strong>Theorem 16.</strong> (Full version of [BCI<sup>+</sup> 20], Theorem 7.1) Let  <span class="math">\\theta \\in \\left(\\frac{1-\\rho}{2}, 1-\\sqrt{\\rho}\\right)</span> , where  <span class="math">\\theta = 1-\\sqrt{\\rho} \\cdot \\left(1+\\frac{1}{2m}\\right)</span> , for some integer  <span class="math">m \\geq 3</span> , and assume that  <span class="math">\\mu</span>  is a sub-probability measure on D with common denominator M, i.e. for all x in D</p>

    <div class="my-4 text-center"><span class="math-block">\\mu(\\{x\\}) = \\frac{a_x}{M},</span></div>

    <p class="text-gray-300">for an integer value  <span class="math">a_x</span> . Suppose that for  <span class="math">f_0, f_1, \\ldots, f_{N-1} \\in F^D</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\lambda: \\mathsf{agree}_{\\mu}(f_0 + \\lambda \\cdot f_1 + \\ldots + \\lambda^{N-1} \\cdot f_{N-1}, \\mathsf{RS}_k) > \\alpha\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$> \\max \\left( \\varepsilon, (N-1) \\cdot \\frac{M \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\frac{2m+1}{\\sqrt{\\rho}} \\right),$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with  <span class="math">\\varepsilon</span>  as in (2). Then there exist polynomials  <span class="math">p_0(X)</span> ,  <span class="math">p_1(X)</span> , ...,  <span class="math">p_{N-1}(X)</span>  from  <span class="math">\\mathsf{RS}_k[F,D]</span> , and a set A of density  <span class="math">\\mu(A) &gt; \\alpha</span>  on which  <span class="math">f_i</span>  coincides with  <span class="math">p_i</span>  for all  <span class="math">i = 0, \\ldots, N-1</span> .</p>`;
---

<BaseLayout title="A summary on the FRI low degree test (2022/1216)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1216
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
