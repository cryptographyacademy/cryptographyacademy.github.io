---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1216';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A summary on the FRI low degree test';
const AUTHORS_HTML = 'Ulrich Hab&ouml;ck';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">This document is an informal summary on the FRI low degree test [BSBHR18a], [BSCI+20], and DEEP algebraic linking from [BSGKS20]. Based on its most recent soundness analysis [BSCI+20], we discuss parameter settings for practical security levels, how FRI is turned into a polynomial commitment scheme, and the soundness of DEEP sampling in the list decoding regime. In particular, we illustrate the DEEP method applied to proving satisfiability of algebraic intermediate representations and prove a soundness error bound which slightly improves the one in [Sta21].</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Interactive Oracle Proofs &middot; STARK &middot; Low Degree Testing &middot; FRI</p>
    </section>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8"><strong>3.3 Batching</strong></h3>

    <p class="text-gray-300">As for linear polynomial commitment schemes, batching is done via random linear combinations. We will only discuss the algebraic variant, which uses powers of a single random challenge. (Again, this is the one favored in the context of proof composition.)</p>

    <p class="text-gray-300">Given a batch of <em>L</em> low-degree polynomials <em>q</em>0(<em>X</em>), . . . , <em>qL</em>&minus;1(<em>X</em>), the verifier samples a random challenge <em>&lambda;</em> &larr;$ <em>F</em>. The prover computes the linear combination</p>

    <p class="text-gray-300">
<span class="math">$h(X) = \\sum_{i=0}^{L-1} \\lambda^i \\cdot q_i(X), \\tag{6}</span>$</p>

    <p class="text-gray-300">sends the oracle of it,</p>

    <p class="text-gray-300"><span class="math">$[h(x)|_{x\\in D}],</span>$</p>

    <p class="text-gray-300">to the verifier. Then both prover and verifier continue with FRI for <em>h</em>. Each <em>x</em><sup>0</sup> &larr;$ <em>D</em><sup>0</sup> = <em>D</em> from the query phase of FRI is used to additionally check consistency between the oracle for <em>h</em>(<em>X</em>) and the ones in the batch, <em>q</em>0(<em>X</em>)<em>, . . . , qL</em>&minus;1(<em>X</em>), using <a href="#page-6-2">(6)</a>.</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8"><strong>3.4 Soundness</strong></h3>

    <p class="text-gray-300">The soundness analysis of FRI is based on a strengthening of the correlated agreement theorem, which allows to additionally keep track of the success probability for the FRI query phase by a sub-probability measure <em>&micro;</em>. We state that <em>weighted correlated agreement theorem</em> in Appendix <a href="#page-25-0">A.3.</a> For proximity parameters close to the Johnson bound, the soundness error of the batched FRI oracle proof is as follows<a href="#page-6-3">2</a> :</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> (Batched FRI soundness error, full version of <a href="#page-20-1">[BCI</a>+20], Theorem 8.3)<strong>.</strong> <em>Suppose that q<sup>i</sup></em> &isin; <em>F D, i</em> = 0<em>, . . . , L</em> &minus; 1<em>, is a batch of functions given by their domain evaluation oracles. If an adversary passes batched FRI for</em> RS<em>k</em>[<em>F, D</em>] <em>and proximity parameter &theta;</em> = 1&minus; <sup>&radic;</sup><em><sup>&rho;</sup></em> &middot; 1 + <sup>1</sup> 2<em>m , m</em> &ge; 3<em>, with a probability larger than</em></p>

    <p class="text-gray-300">
<span class="math">$\\varepsilon = \\left(L - \\frac{1}{2}\\right) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\sqrt{\\rho^3}} \\cdot \\frac{|D_0|^2}{|F|} + \\frac{(2m+1) \\cdot (|D_0| + 1) \\cdot \\sum_{i=1}^r a_i}{\\sqrt{\\rho} \\cdot |F|} + (1-\\theta)^s,</span>$
(7)</p>

    <p class="text-gray-300"><em>then the functions q<sup>i</sup></em> &isin; <em>F <sup>D</sup>, i</em> = 0<em>, . . . , L</em> &minus; 1<em>, have correlated agreement with RSk</em>[<em>D, F</em>] <em>on a set of density of at least &alpha; &gt;</em> 1 + <sup>1</sup> 2<em>m</em> &middot; <sup>&radic;</sup><em>&rho;.</em></p>

    <p class="text-gray-300"><sup>2</sup>We would like to thank Paul Gafni for pointing out a typo in formula <a href="#page-6-4">(7)</a> in a previous version of the document.</p>

    <p class="text-gray-300">Remark 3. The case of linear batching of two functions  <span class="math">q_0</span> ,  <span class="math">q_1</span>  corresponds to the case L=2, in which  <span class="math">L-\\frac{1}{2}=\\frac{3}{2}</span> . The same is true for affine batching of several functions, its soundness error is obtained from (7) by replacing  <span class="math">L-\\frac{1}{2}</span>  by  <span class="math">\\frac{3}{2}</span> , see [BCI<sup>+</sup>20].</p>

    <p class="text-gray-300">The first two terms in (7),</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_C = \\left(L - \\frac{1}{2}\\right) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\sqrt{\\rho^3}} \\cdot \\frac{|D_0|^2}{|F|} + \\frac{(2m+1) \\cdot (|D_0| + 1) \\cdot \\sum_{i=1}^r a_i}{\\sqrt{\\rho} \\cdot |F|},</span>$</p>

    <p class="text-gray-300">correspond to soundness error of the commit phase, reflecting the systematic error estimated by the correlated agreement theorem and collected over the batching step and the reduction rounds. In words, if the oracles in the batch do not share the claimed correlated agreement for  <span class="math">\\alpha = 1 - \\theta</span> , then except with probability  <span class="math">\\varepsilon_C</span> , the oracles produced during the commit phase cannot be &quot;nice&quot;. That is, the set where all consistency checks would hold is <em>at most</em> of density  <span class="math">\\alpha</span> . The remaining term,</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_Q = (1 - \\theta)^s,</span>$</p>

    <p class="text-gray-300">is the soundness error of the query phase with s rounds. This is the probability not to detect such a set of non-&quot;nice&quot; oracles using s independent samples.</p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">3.5 Example parameters</h3>

    <p class="text-gray-300">One way to settle the parameters is as follows. For target security level  <span class="math">2^{-\\lambda}</span> , we assure that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the soundness error for the commit phase is bounded by  <span class="math">\\frac{1}{2} \\cdot 2^{-\\lambda}</span> . For that we choose the maximum Johnson proximity  <span class="math">m \\geq 3</span>  so that</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\varepsilon_C \\le \\frac{1}{2} \\cdot 2^{-\\lambda},</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the soundness error of the query phase is bounded by  <span class="math">\\frac{1}{2} \\cdot 2^{-\\lambda}</span> . Using m from the first step, we determine the number s of query rounds via</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\varepsilon_Q = \\sqrt{\\rho}^s \\cdot \\left(1 + \\frac{1}{2m}\\right)^s \\le \\frac{1}{2} \\cdot 2^{-\\lambda}.</span>$</p>

    <p class="text-gray-300">The following examples<sup>3</sup>consider a situation is similar to the one in Plonky2 [?]. We take extensions F of a base field of size  <span class="math">|F_b| = 2^{64}</span> , and sampling domain sizes  <span class="math">|D_0| = 2^{12} \\cdot \\rho^{-1}</span> , where we vary the blow-up factors  <span class="math">\\rho^{-1}</span>  to the maximum possible for the given security level. The number of polynomials is taken as L = 300, and we assume that these are grouped into</p>

    <p class="text-gray-300"><span class="math">$\\{100, 100, 100\\}</span>$</p>

    <p class="text-gray-300">polynomials, each group committed by a single tree using Merkle caps. The height for the Merkle caps is chosen to minimize the proof size. For each blow-up factor we compute the proof size (assuming a hash size of 256 bits), and as a very coarse measure for the prover complexity the number hashes<sup>4</sup>it needs to compute.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup>In a previous version of the document the example parameters where based on linear batching of FRI. The current ones consider algebraic batching.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>Each call of the hash processes another r = 256 bits.</p>

      <h4 id="sec-3.5.1" class="text-lg font-semibold mt-6"><strong>3.5.1 66 bits of security</strong></h4>

    <p class="text-gray-300">Such a configuration might be still interesting in practice, as its security can be increased by <em>grinding</em> (see <a href="#page-21-1">[Sta23]</a>): Another 14 bits proof of work bound to the proof generation, and one obtains overall 80 bits of security.</p>

    <p class="text-gray-300">&bull; With a degree 2 extension of <em>Fb</em>, hence a field size of 128 bits, the best security level one can obtain for <em>&rho;</em> = 2&minus;<sup>5</sup> is about 69 bits. The commit phase error is</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_C \\approx 2^{-67.21}</span>$
,</p>

    <p class="text-gray-300">with Johnson proximity <em>m</em> = 3. To have about the same soundness error in the query phase, we demand <em>s</em> = 29 samples, yielding</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_Q \\approx 2^{-68.33}</span>$
.</p>

    <p class="text-gray-300">With a reduction strategy {<em>a</em>1<em>, a</em>2} = {2 4 <em>,</em> 2 <sup>3</sup>} we obtain proof sizes of about 104 kB.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&minus;<br>log2<br>(&rho;)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">m</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">s</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">T<br>in hashes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&pi; <br>in bytes</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.4 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">166.9 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34.8 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">129.5 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">69.6 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">107.5 k</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&bull; With a degree 3 extension of <em>Fb</em>, hence a field size of 192 bits, one can choose higher blow-up factors. For <em>&rho;</em> = 2&minus;<sup>6</sup> we obtain 67 bits security by</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_C \\approx 2^{-67.00}</span>$
,</p>

    <p class="text-gray-300">where the Johnson proximity is <em>m</em> = 1<em>,</em> 427. To have about the same soundness error in the query phase, we need only <em>s</em> = 23 samples, yielding</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_Q \\approx 2^{-68.99}</span>$
.</p>

    <p class="text-gray-300">With the same reduction strategy as before, we reduce the proof size down to 89 kB. However, this comes at the cost of about tripling the prover cost.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&minus;<br>(&rho;)<br>log2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">m</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">s</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">T<br>in hashes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&pi; <br>in bytes</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,<br>427</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">209 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">88.9 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">713</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">836 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68.4 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">356</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3,<br>342 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">58.4 k</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h4 id="sec-3.5.2" class="text-lg font-semibold mt-6"><strong>3.5.2 112 bits security</strong></h4>

    <p class="text-gray-300">As in the previous setting, we discuss this level of security as it can be improved by grinding, typically up to 128 bits. All configurations use degree 3 extensions of <em>Fb</em>.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&minus;<br>log2<br>(&rho;)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">m</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">s</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">T<br>in hashes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&pi; <br>in bytes</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">209 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">149 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">836 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3,<br>342 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">99 k</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">For higher blow-up factors, one needs to increase grinding. For example, for &minus; log<sup>2</sup> (<em>&rho;</em>) = 11 the best level of security that can be obtained with degree 3 extensions is 109 bits, leaving 19 bits for grinding. The proof size decreases down to 88<em>.</em>2 kB, at the prover cost of 6<em>,</em> 684<em>,</em> 672 hashes.</p>

      <h4 id="sec-3.5.3" class="text-lg font-semibold mt-6"><strong>3.5.3 128 bits security</strong></h4>

    <p class="text-gray-300">These configurations do not use grinding, and hence have quite large proof sizes. Again, we use degree 3 extensions of <em>Fb</em>.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&minus;<br>log2<br>(&rho;)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">m</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">s</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">T<br>in hashes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&pi; <br>in bytes</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">92</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">326 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">70</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">254 k</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">104 k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">211 k</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-3.6" class="text-xl font-semibold mt-8"><strong>3.6 Conjectured security</strong></h3>

    <p class="text-gray-300">In their line of work on FRI <a href="#page-20-0">[BBHR18a,</a> <a href="#page-21-0">BGKS20,</a> <a href="#page-20-1">BCI</a>+20] the authors make several conjectures on the soundness of FRI for proximity parameters above the Johnson bound. In the most recent one, they state the following.</p>

    <p class="text-gray-300"><strong>Conjecture 1</strong> (Full version of <a href="#page-20-1">[BCI</a>+20], Conjecture 8.4)<strong>.</strong> <em>There exist constants c</em>1<em>, c</em><sup>2</sup> <em>such that for all &theta;</em> = 1 &minus; <em>&rho;</em> &minus; <em>&eta;, &eta; &gt;</em> 0<em>, the soundness error in the correlated agreement theorem on f</em>0<em>, . . . , fN</em>&minus;<sup>1</sup> <em>is bounded by</em></p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\le \\frac{1}{(\\eta \\cdot \\rho)^{c_1}} \\cdot \\frac{(N \\cdot n)^{c_2}}{|F|}.</span>$</p>

    <p class="text-gray-300"><em>Remark</em> 4<em>.</em> For purely linear batching, a similar conjecture is stated.</p>

    <p class="text-gray-300">We point out that the above conjecture (as well as its corresponding one in <a href="#page-20-0">[BBHR18a]</a>) is stated isolated from any general conjectured properties on Reed-Solomon codes, such as list decodability up to capacity bound (as done for DEEP method, see Section <a href="#page-19-3">5.4)</a>. Instead it is rather justified by &quot;<em>[to the best of our knowledge...] nothing seems to contradict</em>&quot; . The authors consider the choice of <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 2 reasonable, and for fields of characteristic <em>q &gt; n</em> they estimate that <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 1.</p>

    <p class="text-gray-300">The <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 1 assumption is of particular interest for practitioners, as it yields proofs of halve the size as in the <em>c</em><sup>1</sup> = <em>c</em><sup>2</sup> = 2 case. For example, it is used by the ethSTARK <a href="#page-21-1">[Sta23]</a> (besides its provably secure parameter setting), as well as by Plonky2 <a href="#page-21-4">[Pol]</a>.</p>

      <h3 id="sec-3.7" class="text-xl font-semibold mt-8"><strong>3.7 Adding zero-knowledge</strong></h3>

    <p class="text-gray-300">Zero-knowledge for FRI has to be provided on application level. In our use cases, the witnesses of an argument correspond to the values of some polynomial <em>q</em>(<em>X</em>) on a given domain <em>H</em> (the proving domain for Plonk, say). To protect it from being leaked by the queries of the <em>s</em> query rounds (as well as by the final reduction polynomial), one uses a an <em>H</em>-disjoint <em>coset a</em> &middot; <em>D</em> of the FRI domain, and randomizes <em>q</em>(<em>X</em>) outside the domain <em>H</em>. That is, the batching and the entire FRI reduction takes place on</p>

    <p class="text-gray-300"><span class="math">$a \\cdot D_0 \\supseteq a \\cdot D_1 \\supseteq \\ldots \\supseteq a \\cdot D_r,</span>$</p>

    <p class="text-gray-300">instead of <em>D</em><sup>0</sup> &supe; <em>D</em><sup>1</sup> &supe; <em>. . .</em> &sube; <em>Dr</em>, where (<em>a</em> &middot; <em>D</em>0) &cap; <em>H</em> = &empty;. This leads to running batched FRI for <em>qi</em>(<em>X</em>), <em>i</em> = 0<em>, . . . , L</em> &minus; 1, over the non-shifted domain <em>D</em><sup>0</sup> on the shifted polynomials</p>

    <p class="text-gray-300"><span class="math">$q_i(a\\cdot X),</span>$</p>

    <p class="text-gray-300"><em>i</em> = 0<em>, . . . , L</em> &minus; 1, instead.</p>

    <p class="text-gray-300">The concrete degree of freedom in the randomization of the polynomials depends on the number of FRI queries and the degree of the extension they are taken from, as well as the the polynomial IOP on top of FRI. Furthermore, and unlike described in a previous version of the survey, it is crucial to add a separate blinding polynomial h(x) to the batch, in order to assure that no information is revealed by the folding oracles of FRI. We refer to [HK24] for a detailed description of the [BCR<sup>+</sup>19] randomization of FRI, plus additional subtleties one has to take care of in the context of the complete IOP of the STARK.</p>

    <p class="text-gray-300">FRI can be turned into a polynomial commitment scheme by means of the evaluation quotients</p>

    <p class="text-gray-300"><span class="math">$h(x) = \\frac{f(x) - v}{x - z}</span>$</p>

    <p class="text-gray-300">of a committed word  <span class="math">f \\in F^D</span> . This approach, called the DEEP method in [BGKS20] corresponds to the algebraic linking of the evaluation identity</p>

    <p class="text-gray-300"><span class="math">$f(X) = v + h(x) \\cdot (X - z)</span>$</p>

    <p class="text-gray-300">with a low-degree problem on the sampling domain D, assuming that  <span class="math">z \\notin D</span> . (For  <span class="math">z \\in D</span>  the oracle can directly answer with the queried value. We will omit this case throughout our discussion.)</p>

    <p class="text-gray-300">For proximity parameters  <span class="math">\\theta</span>  up to the unique decoding radius one obtains a polynomial commitment scheme in the classical sense (when compiling the oracle proof into an argument using a secure partially disclosable vector commitment). In the list decoding regime the situation is a bit more subtle due to the non-uniqueness of  <span class="math">\\theta</span> -close code words. In this case the DEEP method can be viewed as an oracle proof for a more general type of polynomial commitment scheme, called <em>list polynomial commitment scheme</em> in [KPV19]. However, as their notion does not cover the power of correlated agreement, we shall only sketch list polynomial commitment schemes.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 In the unique decoding regime</h3>

    <p class="text-gray-300">For a proximity bound up to the unique decoding radius, i.e.  <span class="math">\\theta &lt; \\frac{1-\\rho}{2}</span> , the situation is quite simple. However, there are several ways to algebraically link the evaluation identity with a low-degree test.</p>

      <h4 id="sec-4.1.1" class="text-lg font-semibold mt-6">4.1.1 A first construction</h4>

    <p class="text-gray-300">We first discuss a naive scheme, in which the maximum degree corresponds to the degree proven by FRI.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup: The maximum degree d = k 1 is chosen as the maximum degree of polynomials belonging to  <span class="math">\\mathsf{RS}_k[F,D]</span> .</li>
      <li>Commit: Given a polynomial p(X) of degree  <span class="math">\\deg p(X) \\leq d</span> , the prover commits its domain evaluation over D, i.e.</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathsf{Com}(p(X)) = [p(x)|_{x \\in D}].</span>$</p>

    <p class="text-gray-300">&bull; Evaluation proof: Given an opening claim (z, v) with  <span class="math">z \\notin D</span> , the prover engages with the verifier in a batched FRI argument on</p>

    <p class="text-gray-300"><span class="math">$f_1(x) = \\frac{p(x) - v}{x - z},</span>$</p>

    <p class="text-gray-300"><span class="math">f_2(x) = x \\cdot f_1(x) = x \\cdot \\frac{p(x) - v}{x - z}.</span></p>

    <p class="text-gray-300">with proximity bound  <span class="math">\\theta = \\frac{1-\\rho}{2}</span> . This proof batches the functions into a random linear combination  <span class="math">f_1(x) + \\lambda \\cdot f_2(x) = (1 + \\lambda \\cdot x) \\cdot \\frac{p(x) - v}{x - z}</span> , and then runs FRI on it. The linear term  <span class="math">\\lambda \\cdot x</span>  is called degree correction factor.</p>

    <p class="text-gray-300">We point out that the two functions  <span class="math">f_1</span> ,  <span class="math">f_2</span>  are not needed to be provided by another oracle, as their evaluations on D can be computed from the values of p(x).</p>

    <p class="text-gray-300">Let us discuss that the evaluation proofs in fact provide a view on a unique polynomial of degree  <span class="math">\\leq d</span> , determined by the values committed in  <span class="math">[p(x)|_{x\\in D}]</span> . First of all, if the prover passes with a probability p greater than the soundness error of batched FRI on  <span class="math">f_1, f_2</span>  as above, then there exist two polynomials  <span class="math">p_1(X), p_2(X)</span>  of degree  <span class="math">\\leq d</span> , and a correlated agreement set A of density  <span class="math">1 - \\theta \\geq \\frac{1+\\rho}{2}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$f_1(x) = p_1(x)\\big|_{x \\in A},</span>$</p>

    <p class="text-gray-300"><span class="math">$x \\cdot f_1(x) = p_2(x)\\big|_{x \\in A},</span>$</p>

    <p class="text-gray-300">and hence also  <span class="math">x \\cdot p_1(x) = p_2(x)|_{x \\in A}</span> . As the density of A is strictly greater than  <span class="math">\\rho</span> , the polynomial  <span class="math">X \\cdot p_1(X) - p_2(X)</span>  has at least k+1 = d+2 zeroes and hence must be trivial, i.e.  <span class="math">X \\cdot p_1(X) = p_2(X)</span> . This implies that  <span class="math">\\deg p_1(X) \\leq d-1</span> , and hence p(x) coincides on A with the degree d polynomial</p>

    <p class="text-gray-300"><span class="math">$P(X) = v + (X - z) \\cdot p_1(X),</span>$</p>

    <p class="text-gray-300">which evaluates to v at z. Notice that  <span class="math">\\delta(p(x), P(X)) &lt; \\frac{1-\\rho}{2}</span> , hence a single evaluation proof implies distance to a degree  <span class="math">\\leq d</span>  polynomial of at most the unique decoding radius. As a consequence, any other evaluation proof (on the same or any other query) is consistent with that unique degree  <span class="math">\\leq d</span>  polynomial, showing that we indeed have a polynomial commitment scheme.</p>

      <h4 id="sec-4.1.2" class="text-lg font-semibold mt-6">4.1.2 The refined scheme</h4>

    <p class="text-gray-300">By similar reasoning (based on a degree k=d+1 polynomial vanishing on a set of density  <span class="math">&gt; \\rho</span> ) we can remove the degree correction factor in the above naive scheme, running FRI for a proximity parameter  <span class="math">\\theta &lt; \\frac{1-\\rho}{2}</span> , only on the evaluation quotient of the claim: For any two evaluation claims  <span class="math">(z_1, v_1)</span>  and  <span class="math">(z_2, v_2)</span>  we conclude the existence of polynomials  <span class="math">p_1(X)</span> ,  <span class="math">p_2(X)</span>  of degree  <span class="math">\\leq k-1</span>  and sets  <span class="math">A_1</span> ,  <span class="math">A_2</span>  of density  <span class="math">1-\\theta &gt; \\frac{1+\\rho}{2}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$v_1 + (X - z_1) \\cdot p_1(X),</span>$</p>

    <p class="text-gray-300"><span class="math">v_2 + (X - z_2) \\cdot p_2(X),</span></p>

    <p class="text-gray-300">agree with p(x) on  <span class="math">A_1</span>  and  <span class="math">A_2</span> , respectively. Since the density of  <span class="math">A_1 \\cap A_2</span>  is at least  <span class="math">1 - 2 \\cdot \\theta &gt; \\rho</span> , it contains at least k + 1 points, and by degree we may conclude the formal identity</p>

    <p class="text-gray-300"><span class="math">$v_1 + (X - z_1) \\cdot p_1(X) = v_2 + (X - z_2) \\cdot p_2(X).</span>$</p>

    <p class="text-gray-300">This leads to the following optimized scheme:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup: The maximum degree is  <span class="math">d^+ = k</span> , where k is the absolute rate of  <span class="math">\\mathsf{RS}_k[F,D]</span> .</li>
      <li>Commit: Given a polynomial p(X) of degree  <span class="math">\\deg p(X) \\leq d^+</span> , the prover commits its domain evaluation over D, i.e.</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathsf{Com}(p(X)) = [p(x)|_{x \\in D}].</span>$</p>

    <p class="text-gray-300">&bull; Evaluation proof: Given an opening claim (z, v) with  <span class="math">z \\notin D</span> , the prover engages with the verifier in a batched FRI argument on</p>

    <p class="text-gray-300"><span class="math">$\\frac{p(x) - v}{x - z}</span>$</p>

    <p class="text-gray-300">with proximity bound  <span class="math">\\theta &lt; \\frac{1-\\rho}{2}</span> .</p>

      <h4 id="sec-4.1.3" class="text-lg font-semibold mt-6">4.1.3 Multi-point queries</h4>

    <p class="text-gray-300">Instead of batching several point evaluation quotients, queries for the values of a polynomial p(X) over a small set  <span class="math">\\Omega = \\{z_1, ..., z_m\\} \\subset F \\setminus D</span>  can be also proven via the multi-evaluation identity</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{m} (p(X) - v_i) \\cdot L(z_i, X) = 0 \\mod v_{\\Omega}(X),</span>$
(8)</p>

    <p class="text-gray-300">where  <span class="math">v_{\\Omega}(X) = \\prod_{j=1}^{m} (X - z_j)</span>  is the vanishing polynomial of  <span class="math">\\Omega</span>  and  <span class="math">L(z_i, X) = \\prod_{j \\neq i} \\frac{X - z_j}{z_i - z_j}</span>  is the Lagrange polynomial at  <span class="math">z_i</span> . Similar to the single query case, one argues using the quotient</p>

    <p class="text-gray-300"><span class="math">$h(x) = \\text{Quotient}(p, \\{(z_i, v_i) : i = 1, \\dots, m\\}) = \\frac{p(x) - V(x)}{v_{\\Omega}(x)},</span>$
(9)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$V(X) = \\sum_{i=1}^{m} v_i \\cdot L(z_i, X)</span>$</p>

    <p class="text-gray-300">is the unique degree  <span class="math">\\leq m-1</span>  polynomial that interpolates the claim.</p>

    <p class="text-gray-300">Alternatively, as in the batch evaluation protocol of Boneh, et al. [BDFG21], one can replace the Lagrange kernel with the non-normalized variant  <span class="math">D(z_i, X) = \\prod_{j \\neq i} (X - z_j)</span></p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{m} (p(X) - v_i) \\cdot D(z_i, X) = 0 \\mod v_{\\Omega}(X), \\tag{10}</span>$</p>

    <p class="text-gray-300">and work with the quotient</p>

    <p class="text-gray-300"><span class="math">$h&#x27;(x) = \\sum_{i=1}^{m} \\frac{p(x) - v_i}{x - z_i}</span>$</p>

    <p class="text-gray-300">instead.</p>

    <p class="text-gray-300">In both cases one has to limit the number m of simultaneous queries to some maximum value  <span class="math">m_{max}</span> , satisfying</p>

    <p class="text-gray-300"><span class="math">$k + m_{max} &lt; (1 - \\theta) \\cdot n.</span>$</p>

    <p class="text-gray-300">For this it is sufficient to choose  <span class="math">k + m_{max} \\le (1 - \\theta_0) \\cdot n = \\frac{k+n}{2}</span> , and hence  <span class="math">m_{max} \\le \\frac{n-k}{2}</span> . Even with the lowest blow-up factor we have  <span class="math">n \\ge 2 \\cdot k</span> , it is thus enough to demand</p>

    <p class="text-gray-300"><span class="math">$m_{max} \\le \\frac{k}{2}. (11)</span>$</p>

    <p class="text-gray-300">In our applications the bound on  <span class="math">m_{max}</span>  is trivially met, as only few values are queried in the run of the proof. Furthermore, given a polynomial we use multi-point queries of fixed given size  <span class="math">m \\leq m_{max}</span> . As a consequence the maximum degree in the setup can be enlarged to  <span class="math">d_{max} = k + m - 1</span> .</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 List commitments</h3>

    <p class="text-gray-300">In the list decoding regime the situation is a bit more subtle. Running FRI for  <span class="math">\\mathsf{RS}_k[F,D]</span>  with a proximity parameter  <span class="math">\\frac{1-\\rho}{2} &lt; \\theta &lt; 1 - \\sqrt{\\rho}</span>  on an evaluation quotient</p>

    <p class="text-gray-300"><span class="math">$h(x) = \\frac{p(x) - v}{x - z}</span>$</p>

    <p class="text-gray-300">only proves agreement of p with an evaluation-claim-consistent polynomial of degree  <span class="math">d^+ = k</span>  on a set of density greater than  <span class="math">\\alpha = 1 - \\theta</span> . This might be not large enough for proving the polynomials of different runs</p>

    <p class="text-gray-300">of FRI being equal. In fact, they might differ from claim to claim, unless one runs a joint FRI argument on them. Assuming  <span class="math">\\alpha &gt; \\sqrt{\\rho^+}</span> , where  <span class="math">\\rho^+ = \\frac{k+1}{|D|}</span> , the Guruswami-Sudan list decoding bound shows that there might be</p>

    <p class="text-gray-300"><span class="math">$L \\le \\frac{1}{2 \\cdot \\eta \\cdot \\rho^+}</span>$</p>

    <p class="text-gray-300">such code words. This leads to the idea of list polynomial commitment schemes as in [KPV19] with the following information-theoretic model: The prover sets up an oracle which contains a list of l,  <span class="math">1 \\le l \\le L</span> , low-degree polynomials, and the oracle is allowed to choose which one to evaluate on a given query. Such extended notion is practical as security proofs in the oracle model are similar to polynomial oracle proofs. However, the notion of list polynomial oracles as given in [KPV19] is not strong enough to capture correlated agreement, and as a consequence soundness error bounds are too coarse. For this reason we do not dive into formal details of that model, and instead directly work with DEEP algebraic linking.</p>

    <p class="text-gray-300">In this section we discuss the <em>DEEP algebraic linking (DEEP-ALI)</em> [BGKS20] and demonstrate its application to proving satisfiability of algebraic intermediate representations (AIR). Other representations such as randomized AIR or Plonk [GWC19] can be treated similarly.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Algebraic linking and the DEEP method</h3>

    <p class="text-gray-300">Algebraic linking transforms satisfiability of algebraic identities over algebraic subsets of F into proximity problems of low-degree extensions to Reed-Solomon codes over &quot;outside&quot; domains (i.e. disjoint to the algebraic subset). A family of functions  <span class="math">g_1, \\ldots, g_N</span>  on  <span class="math">\\Omega = \\{x_1, ..., x_n\\}</span>  satisfies an algebraic identity</p>

    <p class="text-gray-300"><span class="math">$P(x, g_1(x), \\dots, g_N(x)) = 0</span>$</p>

    <p class="text-gray-300">on  <span class="math">\\Omega</span>  (P is a polynomial), if and only if their low-degree extensions  <span class="math">p_1(X), \\ldots, p_N(X)</span>  satisfy that  <span class="math">P(X, p_1(X), \\ldots, p_N(X))</span>  is divisible by the vanishing polynomial  <span class="math">v_{\\Omega}(X) = \\prod_{i=1}^n (X - x_i)</span>  of  <span class="math">\\Omega</span> , i.e. the quotient</p>

    <p class="text-gray-300"><span class="math">$h(X) = \\frac{P(X, p_1(X), ..., p_N(X))}{v_{\\Omega}(X)}</span>$</p>

    <p class="text-gray-300">is a low-degree polynomial. This divisibility criterion is translated to the proximity of given code words</p>

    <p class="text-gray-300"><span class="math">$f_1, ..., f_N, h \\in F^D,</span>$</p>

    <p class="text-gray-300">(the honest prover chooses the domain evaluations of  <span class="math">p_1(X), \\ldots, p_N(X)</span>  and h(X) over D) to low-degree polynomials, i.e. a Reed-Solomon code words<sup>5</sup>. For this the proximity parameter needs to be chosen so that the agreement sets are large enough to infer from local satisfiability of algebraic identities to their satisfiability over the entire field F. This means that the sampling domain D is such that the notion of low-degree is determined by the degree of  <span class="math">P(X, p_1(X), ..., p_N(X))</span> . DEEP-ALI instead allows for decoupling the sampling domain size from the degree of P.</p>

    <p class="text-gray-300">DEEP-ALI is very much in alignment with a polynomial IOP for proving that</p>

    <p class="text-gray-300">
<span class="math">$P(X, p_1(X), ..., p_N(X)) = h(X) \\cdot v_{\\Omega}(X).</span>$
(12)</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>In the case of a single batched FRI proof for the  <span class="math">f_i</span>  together with h, one needs to use degree correction factors as in Section 4.1.1.</p>

    <p class="text-gray-300">Instead of showing proximity of the quotient</p>

    <p class="text-gray-300"><span class="math">$h(x) = \\frac{P(x, f_1(x), ..., f_N(x))}{v_{\\Omega}(x)}</span>$</p>

    <p class="text-gray-300">to a low-degree polynomial, one samples a random point <em>z</em> &larr;$ <em>F</em> outside the domain <em>D</em>, and let the prover provide evaluations claims <em>v<sup>i</sup></em> , <em>i</em> = 1<em>, . . . , w</em> for <em>p<sup>i</sup></em> , and <em>v</em> for <em>h</em>, which are used to check the identity <a href="#page-13-3">(12)</a> at <em>X</em> = <em>z</em>. The validity of the values are supported by proving proximity of the point evaluation quotients</p>

    <p class="text-gray-300"><span class="math">$\\frac{f_i(x) - v_i}{x - z}, \\quad i = 1, \\dots, w,</span>$</p>

    <p class="text-gray-300">as well as</p>

    <p class="text-gray-300"><span class="math">$\\frac{h(x) - v}{x - z}</span>$</p>

    <p class="text-gray-300">to corresponding low-degree polynomials. Furthermore, by decomposing <em>h</em>(<em>X</em>) into into polynomials of degree |&Omega;| &minus; 1, e.g.</p>

    <p class="text-gray-300">
<span class="math">$h(X) = h_0(X) + X^{|\\Omega|} \\cdot h_1(X) + \\dots + X^{(d-1)\\cdot|\\Omega|} \\cdot h_{d-1}(X), \\tag{13}</span>$</p>

    <p class="text-gray-300">one can even use a sampling domain the size of which is not determined by the degree of <em>h</em>(<em>X</em>). (We use a different decomposition as in <a href="#page-21-0">[BGKS20,</a> <a href="#page-21-1">Sta23]</a>, which does not imply any further constraints on the sampling space for <em>z</em>.)</p>

    <p class="text-gray-300">In the unique decoding regime, the DEEP-ALI approach is equivalent to a (univariate) polynomial IOP using FRI as a polynomial commitment scheme as described in Chapter <a href="#page-10-0">4.</a> For larger proximity parameters, one can generalize the polynomial oracle model to list polynomial commitment schemes as done in <a href="#page-21-2">[KPV19]</a>, but their approach does not yield soundness bounds which are as tight as given by the correlated agreement theorem. In order not to introduce yet another oracle model which reflects this specific correlated agreement property of batched FRI, we directly show how to apply the DEEP method to proving satisfiability of an algebraic intermediate representation.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8"><strong>5.2 DEEP-ALI of an AIR</strong></h3>

    <p class="text-gray-300">An <em>algebraic intermediate representation (AIR)</em>, see <a href="#page-20-5">[BBHR18b,</a> <a href="#page-21-0">BGKS20,</a> <a href="#page-21-1">Sta23]</a>, is defined over an FFT domain <em>H</em> &sub; <em>F</em> with generator <em>g</em>. Each <em>x</em> in <em>H</em> carries a &quot;row&quot; of <em>w</em> witnesses (or, &quot;columns&quot;)</p>

    <p class="text-gray-300"><span class="math">$(g_1(x),..,g_w(x)),</span>$</p>

    <p class="text-gray-300">on which a certain number of algebraic constraints are imposed. For simplicity we restrict ourselves to constraints between neigboring rows only, i.e. polynomials</p>

    <p class="text-gray-300"><span class="math">$P_1, \\ldots, P_C \\in F[X_1, ..., X_w, Y_1, ..., Y_w],</span>$</p>

    <p class="text-gray-300">each <em>P<sup>i</sup></em> being imposed on a specified coset <em>a<sup>i</sup></em> &middot; <em>H<sup>i</sup></em> &sube; <em>H</em>, where <em>H<sup>i</sup></em> is a subgroup of <em>H</em>. Hence satisfiability of the AIR is defined by</p>

    <p class="text-gray-300">
<span class="math">$P_i(x, g_1(x), \\dots, g_w(x), g_1(g \\cdot x), \\dots, g_w(g \\cdot x)) = 0 \\quad \\forall x \\in a_i \\cdot H_i,</span>$</p>

    <p class="text-gray-300"><span class="math">$(14)</span>$</p>

    <p class="text-gray-300">for every <em>i</em> = 1<em>, . . . , C</em>. In terms of polynomials <em>p</em>1(<em>X</em>)<em>, . . . , pw</em>(<em>X</em>) &isin; <em>F</em>[<em>X</em>] extending the witness functions <em>g</em>1<em>, . . . , gw</em>, satisfiability of an AIR constraint <em>P<sup>i</sup></em> on <em>a<sup>i</sup></em> &middot; <em>H<sup>i</sup></em> can be expressed by demanding the quotient</p>

    <p class="text-gray-300"><span class="math">$\\frac{P_i(p_1(X),\\ldots,p_w(X),p_1(g\\cdot X),\\ldots,p_1(g\\cdot X))}{v_{a_i\\cdot H_i}(X)}</span>$</p>

    <p class="text-gray-300">where  <span class="math">v_{a_i \\cdot H_i}(X) = z^{|H_i|} - a_i^{|H_i|}</span>  is the vanishing polynomial of the coset  <span class="math">a_i \\cdot H_i</span> , being again a polynomial. This is the approach [BBHR18b, BGKS20, Sta23]. However, instead of working with these quotients we prefer using polynomial identities similar to Plonk [GWC19]: Satisfiability of an AIR constraint  <span class="math">P_i</span>  imposed on  <span class="math">a_i \\cdot H_i</span>  is equvialent to</p>

    <p class="text-gray-300"><span class="math">$s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(g \\cdot X), \\dots, p_1(g \\cdot X)) = 0 \\mod v_H(X),</span>$
(15)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">
<span class="math">$s_i(X) = \\frac{v_H(X)}{v_{a_i \\cdot H_i}(X)} \\in F[X]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\tag{16}</span>$</p>

    <p class="text-gray-300">is the selector polynomial<sup>6</sup> for the constraint  <span class="math">P_i</span> . The overall degree of the AIR is defined as</p>

    <p class="text-gray-300"><span class="math">$d = \\max_{i} \\deg(P_i),\\tag{17}</span>$</p>

    <p class="text-gray-300">where  <span class="math">deg(P_i)</span>  is the total degree of  <span class="math">P_i</span> .</p>

    <p class="text-gray-300">The sampling domain D for FRI is chosen so that  <span class="math">|D| = \\beta \\cdot |H|</span> , with a blow-up factor  <span class="math">\\beta = 1/\\rho</span>  being a power of two, and  <span class="math">\\mathsf{RS}_k[D,F]</span>  is the Reed-Solomon code of length n = |D| and rate  <span class="math">\\rho = \\frac{k}{n}</span> , with</p>

    <p class="text-gray-300"><span class="math">$k = |H|. (18)</span>$</p>

    <p class="text-gray-300">However, the agreement parameter used for FRI is taken slightly larger than  <span class="math">\\alpha = \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho}, m \\ge 3</span> , namely</p>

    <p class="text-gray-300"><span class="math">$\\alpha^{+} = \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho^{+}}, \\quad m \\ge 3, \\tag{19}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\rho^{+} = \\frac{|H| + 2}{|D|}.\\tag{20}</span>$</p>

    <p class="text-gray-300">The reason for this slightly larger choice is due to the evaluation quotients of the protocol, which are subject to the FRI proof. Their denominators are at most quadratic and hence the degree of the non-quotients is bounded by |H| - 1 + 2. The low-degree extensions  <span class="math">p_i(X) \\in F[X]</span>  of the witness functions  <span class="math">g_i</span>  on H are provided as code words over D, and to use again the same code for a polynomial h(X) of larger degree, we split it into segment polynomials as in (13).</p>

    <p class="text-gray-300">The DEEP-ALI protocol (for simplicity without zero-knowledge) for our AIR is as follows:</p>

    <p class="text-gray-300"><strong>Protocol 3</strong> (IOP for AIR using DEEP-ALI). Let  <span class="math">p_1(X), \\ldots, p_w(X) \\in F[X]</span>  be polynomials of degree  <span class="math">\\deg p_i(X) \\leq |H| - 1</span>  satisfying the AIR constraints (14),  <span class="math">i = 1, \\ldots, C</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover sends the domain evaluation oracles  <span class="math">[p_1], \\ldots, [p_w]</span>  for  <span class="math">p_1(X), \\ldots, p_w(X)</span>  to the verifier, who responds with a randomness  <span class="math">\\lambda \\leftarrow F</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover computes  <span class="math">h_{\\lambda}(X) \\in F[X]</span>  of degree  <span class="math">\\leq d \\cdot (|H|-1)</span>  satisfying the identity</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = h_{\\lambda}(X) \\cdot v_H(X),</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>Notice that, although deg  <span class="math">s_i(X) \\leq |H| - 1</span> , the polynomial  <span class="math">s_i(X)</span>  can be succinctly evaluated outside H using the rational representation from (16). Therefore no evaluation has to be provided by the prover.</p>

    <p class="text-gray-300"><em>splits it into its segment polynomials h&lambda;,j</em> (<em>X</em>)<em>, j</em> = 0<em>, . . . , d</em> &minus; 1<em>, each of degree</em> &le; |<em>H</em>| &minus; 1<em>, as in</em> <a href="#page-14-1">(13)</a><em>, and sends their domain evaluation oracles</em> [<em>h&lambda;,</em>0]<em>, . . . ,</em> [<em>h&lambda;,d</em>&minus;1] <em>to the verifier. The overall identity to be proven is therefore</em></p>

    <p class="text-gray-300">
$$\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX))
= v_H(X) \\cdot \\sum_{j=0}^{d-1} X^{j \\cdot |H|} \\cdot h_{\\lambda, j}(X).$$
(21)</p>

    <p class="text-gray-300"><em>The verifier answers with a DEEP query, i.e. a random z</em> &larr;$ <em>F</em> \\ (<em>D</em> &cup; <em>H</em>)<em>.</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>3. Upon receiving the DEEP query z, the prover sends the evaluation claims</em> (<em>z, vi,</em>1)<em>,</em> (<em>g</em> &middot; <em>z, vi,</em>2)<em>, i</em> = 1<em>, ..., w, for the witness polynomials pi</em>(<em>X</em>)<em>, and</em> (<em>z, v<sup>j</sup></em> )<em>, j</em> = 0<em>, ..., d</em> &minus; 1<em>, for the segment polynomials h&lambda;,j</em> (<em>X</em>)<em>, to the verifier.</em></li>
      <li><em>4. Eventually, prover and verifier run batched FRI for proximity of the evaluation quotients</em></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\frac{p_i(x) - V_i(x)}{(x-z) \\cdot (x-gz)},</span>$</p>

    <p class="text-gray-300"><em>where Vi</em>(<em>x</em>) <em>is determined from the evaluation claims as described in Section <a href="#page-11-1">4.1.3,</a> i</em> = 1<em>, . . . , w, and</em></p>

    <p class="text-gray-300"><span class="math">$\\frac{h_{\\lambda,j}(x)-v_j}{x-z},</span>$</p>

    <p class="text-gray-300"><em>j</em> = 0<em>, .., d</em> &minus; 1<em>, to RSk</em>[<em>F, D</em>]<em>, where the chosen agreement parameter is &alpha;</em> <sup>+</sup> <em>as defined above. If FRI passes, and if the evaluation claims satisfy the overall identity</em> <a href="#page-16-0">(21)</a> <em>at X</em> = <em>z, the verifier accepts. (Otherwise, it rejects.)</em></p>

    <p class="text-gray-300"><em>Remark</em> 5<em>.</em> Notice that the polynomial <em>si</em>(<em>X</em>) can only be succinctly evaluated outside <em>H</em>. For this reason that <em>H</em> is excluded from the sampling space of <em>z</em>.</p>

    <p class="text-gray-300"><em>Remark</em> 6<em>.</em> As discussed above, our definition of AIR is equivalent to the one from <a href="#page-20-5">[BBHR18b,</a> <a href="#page-21-0">BGKS20,</a> <a href="#page-21-1">Sta23]</a> (besides that we restricted to constraints between neighboring rows in order to keep the presentation simple). In particular the quotient polynomial <em>h&lambda;</em>(<em>X</em>) in our protocol is the same as</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot \\frac{s_i(X)}{v_H(X)} \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = \\sum_{i=1}^{C} \\lambda^{i-1} \\cdot \\frac{P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX))}{v_{a_i \\cdot H_i}(X)},</span>$</p>

    <p class="text-gray-300">which is the batched rational function used in their line of work.</p>

    <p class="text-gray-300"><em>Remark</em> 7<em>.</em> Let us point us the difference of Protocol <a href="#page-15-2">3</a> to the IOP given in <a href="#page-21-1">[Sta23]</a>. Instead of using a purely linear batching strategy, we use the powers of a single randomness <em>&lambda;</em>, which is the favoured choice in the context of proof composition. Secondly, as in <a href="#page-21-0">[BGKS20]</a> we use multi-point quotients for the witness polynomials which are queried at <em>z</em> and <em>gz</em>. This reduces the number of polynomials on which FRI is applied, at the cost of only a slight increase in the choice of <em>k</em> <sup>+</sup>. Thirdly, the way we decompose <em>h&lambda;</em>(<em>X</em>) into segment polynomials <a href="#page-14-1">(13)</a> does not further reduce the sampling space for <em>z</em>, as is needed when using a FRI-like decomposition.</p>

    <p class="text-gray-300">We finally state the soundness error of Protocol 3 in the oracle model.</p>

    <p class="text-gray-300">Theorem 8 (DEEP-ALI soundness). The above oracle proof for AIR satisfiability has soundness error</p>

    <p class="text-gray-300">
<span class="math">$\\varepsilon \\le L^+ \\cdot \\left(\\frac{C}{|F|} + \\frac{d \\cdot (k^+ - 1) + (k - 1)}{|F| - |D \\cup H|}\\right) + \\varepsilon_{FRI},\\tag{22}</span>$</p>

    <p class="text-gray-300">with  <span class="math">k^+ = k + 2</span> ,  <span class="math">L^+ = \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho^+}}</span> ,  <span class="math">\\rho^+ = \\frac{k^+}{n}</span> , and  <span class="math">\\varepsilon_{FRI}</span>  being the soundness error for batched FRI for  <span class="math">\\alpha^+</span> -agreement with  <span class="math">RS_k[F,D]</span> , Theorem 2.</p>

    <p class="text-gray-300">Remark 9. We point out some differences to the error bound in [Sta23], Theorem 4. In our bound the list size bound  <span class="math">L^+</span>  only occurs linearly instead of quadratically. This due to our more careful analysis of the consequences of the correlated agreement enforced on polynomials produced in different rounds of the protocol. Secondly, as mentioned above, the alternative decomposition of  <span class="math">h_{\\lambda}(X)</span>  into segment polynomials does not reduce the sampling space for z by a factor d larger domain. Less importantly, since we use do algebraic batching using the powers of  <span class="math">\\lambda</span> , the first term incorporates the number of constraints C. A purley linear batching strategy, as used in [Sta23] leads to  <span class="math">\\frac{1}{|F|}</span>  instead.</p>

    <p class="text-gray-300">Remark 10. In the soundness error formula in [BGKS20], Theorem 15, the list bound  <span class="math">L^+</span>  occurs quadratically. This is due to the application of two separate FRI arguments, one for the batched quotients of the witness polynomials, and another one for the overall quotient polynomial. (However, the splitting technique for h is outlined in Section 5.5. therein.) For the same reason, the notion of list polynomial commitment schemes from [KPV19] would lead to the w-th power of  <span class="math">L^+</span> , w being the number of witness columns. This might be acceptable for proving soundness of standard Plonk in the list polynomial oracle model, but not for a larger number of witness columns.</p>

    <p class="text-gray-300">Proof of Theorem 8. Let us denote  <span class="math">\\varepsilon_1 = L^+ \\cdot \\frac{C}{|F|}</span> ,  <span class="math">\\varepsilon_2 = L^+ \\cdot \\frac{d \\cdot (k^+ - 1) + (k - 1)}{|F| - |D \\cup H|}</span> , and  <span class="math">\\varepsilon_3 = \\varepsilon_{FRI}</span> . Suppose that  <span class="math">P^*</span>  is an adversary which succeeds the verifier with a probability exceeding  <span class="math">\\varepsilon = \\varepsilon_1 + \\varepsilon_2 + \\varepsilon_3</span> . Then there exists a first message of  <span class="math">P^*</span> , i.e. words  <span class="math">f_1, \\ldots, f_w</span>  on D, on which  <span class="math">P^*</span>  succeeds with probability  <span class="math">&gt; \\varepsilon</span> , and hence</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\lambda : \\Pr\\left(P^* \\text{ succeeds } | \\lambda\\right) &gt; \\varepsilon_2 + \\varepsilon_3\\right] &gt; \\varepsilon_1.</span>$</p>

    <p class="text-gray-300">(Otherwise  <span class="math">\\Pr[P^* \\text{ succeeds }] \\leq 1 \\cdot \\varepsilon_1 + (\\varepsilon_2 + \\varepsilon_3) \\cdot (1 - \\varepsilon_1) &lt; \\varepsilon_1 + \\varepsilon_2 + \\varepsilon_3</span> .) Likewise, for every such &quot;good&quot;  <span class="math">\\lambda</span>  (by the definition of  <span class="math">\\varepsilon_1</span> , there are at least  <span class="math">L^+ \\cdot C</span>  many) there exists a second message of  <span class="math">P^*</span> , i.e. words  <span class="math">h_{\\lambda,0}, \\ldots, h_{\\lambda,d-1}</span>  on D such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[z \\in F \\setminus D : \\Pr(P^* \\text{ succeeds } |z) &gt; \\varepsilon_3\\right] &gt; \\varepsilon_2.</span>$</p>

    <p class="text-gray-300">For each such &quot;good&quot;  <span class="math">z \\in F \\setminus (D \\cup H)</span>  (by the definition of  <span class="math">\\varepsilon_2</span> , there are more than  <span class="math">L^+ \\cdot (d \\cdot (k^+ - 1) + (k - 1))</span>  many) the evaluation claims pass the verifier checks, and moreover the soundness of FRI enforces the evaluation quotients</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{f_1(x) - V_1(x)}{(x - z) \\cdot (x - g \\cdot z)}, \\dots, \\frac{f_w(x) - V_w(x)}{(x - z) \\cdot (x - g \\cdot z)}, \\frac{h_{\\lambda,0}(x) - v_0}{x - z}, \\dots, \\frac{h_{d-1}(x) - v_{d-1}}{x - z}\\right)</span>$</p>

    <p class="text-gray-300">to have correlated agreement with some  <span class="math">q_i(X) \\in F[X]</span> , i = 1, ..., w + d, of degree  <span class="math">\\deg q_i(X) \\leq |H| - 1</span>  on a set A of density at least  <span class="math">\\alpha^+ &gt; \\sqrt{\\rho^+}</span> . Cancelling out the denominators, we see that</p>

    <p class="text-gray-300"><span class="math">$(f_1,\\ldots,f_w,h_{\\lambda,0},\\ldots,h_{\\lambda,d-1})</span>$</p>

    <p class="text-gray-300">have correlated agreement on a set of density  <span class="math">\\geq \\alpha^+</span>  with some element from  <span class="math">F[X]^{w+d}</span>  where each component polynomial is of degree  <span class="math">\\leq |H| - 1 + 2 = k^+ - 1</span> , and satisfies the evaluation claim.</p>

    <p class="text-gray-300">In what follows we shall call an element  <span class="math">(P_0(X), \\ldots, P_{l-1}(X))</span>  from  <span class="math">F[X]^l</span> , with component polynomials of degree  <span class="math">\\leq k^+ - 1</span> , having correlated agreement with a vector of functions  <span class="math">(\\phi_0(x), \\ldots, \\phi_{l-1}(x))</span>  on a set of density  <span class="math">\\geq \\alpha^+</span> , an  <span class="math">\\alpha^+</span> -configuration for that vector of functions. Another way to express this, is that</p>

    <p class="text-gray-300"><span class="math">$P(X) = \\sum_{i=0}^{l-1} P_i(X) \\cdot Z^i,</span>$</p>

    <p class="text-gray-300">belonging to the Reed-Solomon code  <span class="math">\\mathsf{RS}_{k^+}[K,D]</span>  over the rational function field K=F(Z) is  <span class="math">(1-\\alpha^+)</span> -close to the K-valued function  <span class="math">\\phi(x) = \\sum_{i=0}^{l-1} \\phi_i(X) \\cdot Z^i</span> . Note that since  <span class="math">\\alpha^+ &gt; \\sqrt{\\rho^+}</span> , the Guruswami-Sudan list size bound (over general fields, see Appendix A.2) is applicable to  <span class="math">\\mathsf{RS}_{k^+}[K,D]</span> . In particular, there are at most</p>

    <p class="text-gray-300"><span class="math">$L^+ = \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho^+}}</span>$</p>

    <p class="text-gray-300"><span class="math">\\alpha^+</span> -configurations for  <span class="math">(\\phi_0(x), \\dots, \\phi_{l-1}(x))</span> .</p>

    <p class="text-gray-300">Let us keep a combination of &quot;good&quot; first and second messages  <span class="math">(f_1, \\ldots, f_w)</span> ,  <span class="math">(h_{\\lambda,0}, \\ldots, h_{\\lambda,d-1})</span>  fixed. We have seen above that the existence of a single &quot;good&quot; z implies the existence of an  <span class="math">\\alpha^+</span> -configuration for  <span class="math">(f_1, \\ldots, f_w, h_{\\lambda,0}, \\ldots, h_{\\lambda,d-1})</span> . By the Guruswami-Sudan list size bound for  <span class="math">\\mathsf{RS}_{k^+}(K,D)</span>  (see Appendix A.2) there are at most  <span class="math">L^+</span>  such  <span class="math">\\alpha^+</span> -configurations. However, since there are more than  <span class="math">L^+</span>  ( <span class="math">d \\cdot (k^+ - 1) + (k - 1)</span> ) many &quot;good&quot; z, and each establishes an  <span class="math">\\alpha^+</span> -configuration which smoreover evaluates to the claimed values, we conclude from the pigeon-hole principle that there is at least one  <span class="math">\\alpha^+</span> -configuration,</p>

    <p class="text-gray-300"><span class="math">$(p_1,\\ldots,p_w,q_{\\lambda,0},\\ldots,q_{\\lambda,d-1})\\in F[X]^{w+d},</span>$</p>

    <p class="text-gray-300">for which the overall identity (21) (taking the  <span class="math">q_{\\lambda,j}</span>  as  <span class="math">h_{\\lambda,j}</span>  therein) holds at more than  <span class="math">d \\cdot (k^+ - 1) + (k - 1)</span>  many z. By the degree of the identity, this configuration is a solution of it, hence  <span class="math">(p_1, \\ldots, p_w) \\in F[X]^w</span>  is an  <span class="math">\\alpha^+</span> -configuration for  <span class="math">(f_1, \\ldots, f_w)</span>  which satisfies</p>

    <p class="text-gray-300">
<span class="math">$\\sum_{i=1}^{C} \\lambda^{i-1} \\cdot s_i(X) \\cdot P_i(p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = 0 \\mod v_H(X).</span>$
(23)</p>

    <p class="text-gray-300">Now let us keep a &quot;good&quot; first message  <span class="math">(f_1, \\ldots, f_w)</span>  fixed. We have seen that for each &quot;good&quot;  <span class="math">\\lambda</span>  there exists an  <span class="math">\\alpha^+</span> -configuration for  <span class="math">(f_1, \\ldots, f_w)</span>  which is a solution of (23). Again, by the Guruswami-Sudan list size bound for  <span class="math">\\mathsf{RS}_{k^+}[K,D]</span> , there can be at most  <span class="math">L^+</span>  many w-configurations. Since there are at least  <span class="math">L^+ \\cdot C</span>  many &quot;good&quot;  <span class="math">\\lambda</span> , we conclude again from the pigeon-hole principle that there is at least one  <span class="math">\\alpha^+</span> -configuration, which we again denote by  <span class="math">(p_1,\\ldots,p_w)</span> , for which there are at least C many &quot;good&quot;  <span class="math">\\lambda</span>  for which (23) holds. By linear algebra (the Vandermonde matrix is invertible) we conclude that this configuration satisfies</p>

    <p class="text-gray-300"><span class="math">$s_i(X) \\cdot P_i(X, p_1(X), \\dots, p_w(X), p_1(gX), \\dots, p_w(gX)) = 0 \\mod v_H(X)</span>$</p>

    <p class="text-gray-300">for every  <span class="math">i=1,\\ldots,C</span> . The values of  <span class="math">(p_1,\\ldots,p_w)</span>  over H satisfy the constraints the AIR. This completes the proof.</p>

    <p class="text-gray-300">We note that in Equation (22), the term in the brackets is exactly the soundness error bound of the protocol in the (univariate) polynomial IOP model [BFS20]. As soundness in this model is essentially based on the Schwartz-Zippel lemma, we believe that the blow-up by the factor  <span class="math">L^+</span>  holds in general for every (public coin) polynomial IOP when replacing polynomial oracles by domain-evaluation oracles. (At least for the polynomial IOPs we know, such as [GWC19, MBKM19, CHM <span class="math">^+</span> 20] or [HGdB21], this is the case.) Such a general transformation of (univariate) polynomial IOPs into ordinary (i.e. domain-evaluation) IOPs would be of interest, as the polynomial IOP model is widely used by practicioners. The protocol design as well as its security analysis is much easier to understand in the polynomial oracle model, and their soundness error bounds could be easily taken over. We plan to elaborate on this in a separate document.</p>

      <h4 id="sec-5.2.1" class="text-lg font-semibold mt-6">5.2.1 Extractability</h4>

    <p class="text-gray-300">We only provide a brief sketch how to build the extractor in the oracle model, given a prover  <span class="math">P^*</span>  which succeeds with a probability of that exceeds the soundness error bound from Theorem 8:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample a &quot;good&quot; first message  <span class="math">[f_1], \\ldots, [f_w]</span>  on which the prover succeeds with a probability greater than the soundness error bound from Theorem 8.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In this step we build a straight-line extractor from the &quot;good&quot; first message  <span class="math">[f_1], \\ldots, [f_w]</span>  pbtained in Step (1): Read  <span class="math">f_1, \\ldots, f_w</span>  from the oracles. By the proof of Theorem 8,  <span class="math">(f_1, \\ldots, f_w)</span>  agrees with an AIR solution  <span class="math">(p_1(X), \\ldots, p_w(X)) \\in F[X]^w</span>  on a set A of density  <span class="math">\\geq \\alpha^+</span> . To obtain this solution, one repeatedly applies the Guruswami-Sudan list decoder<sup>7</sup>and &quot;intersects&quot; their outputs as described in [Sta23], Section 5.5. One of the resulting configurations must be the one that satisfies the AIR.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The first step takes expected time  <span class="math">O(1/\\varepsilon)</span> , and the Gurswami-Sudan decoder consumes at most  <span class="math">O(|D|^{15})</span>  field operations, see Remark 14. To obtain strict polynomial running time, at the cost of having a success probability &lt; 1, one may stop the sampling after an appropriate multiple of  <span class="math">1/\\varepsilon</span> .</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Boosting soundness</h3>

    <p class="text-gray-300">In this section we outline standard techniques to lower the DEEP-ALI soundness error for AIRs over small fields F. (See [Sta23], or [?].)</p>

      <h4 id="sec-5.3.1" class="text-lg font-semibold mt-6">5.3.1 Using extension fields</h4>

    <p class="text-gray-300">One simply draws queries (for example the DEEP queries and the FRI challenges) from a suitable large extension field  <span class="math">F_e</span>  of F. The soundness error bound lowers accordingly, replacing |F| with  <span class="math">|F_e|</span> . (Notice that the disadvantage of applying this approach to the entire protocol is that all FRI quotients have to be computed over  <span class="math">F_e</span> .)</p>

      <h4 id="sec-5.3.2" class="text-lg font-semibold mt-6">5.3.2 Increasing the number of protocol challenges</h4>

    <p class="text-gray-300">Instead of drawing protocol challenges from an extension field, one may repeatedly sample a challenge and run the remaining protocol for them in parallel. For instance, the first verifier challenge  <span class="math">\\lambda</span>  can be sampled  <span class="math">N_1</span>  times,  <span class="math">\\lambda_1, \\ldots, \\lambda_{N_1} \\leftarrow F</span> , and prove the overall polynomial identity (21) for all of these cases. This yields a lowered soundness error bound of the first round,</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_1 = \\left(L^+ \\cdot \\frac{C}{|F|}\\right)^{N_\\lambda},\\,</span>$</p>

    <p class="text-gray-300">and increases only the number of  <span class="math">h_{\\lambda,j}</span>  polynomials (by the factor  <span class="math">N_{\\lambda}</span> ) that are subject to the DEEP queries in the second round. Likewise, one may also take several DEEP queries  <span class="math">z_1, \\ldots, z_{N_z}</span>  from  <span class="math">F \\setminus D</span> , and apply FRI to the batch of all resulting quotients, lowering the soundness error bound of the second round to</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_2 = \\left(L^+ \\cdot \\frac{d \\cdot (k^+ - 1) + (k - 1)}{|F \\setminus (D \\cup H)|}\\right)^{N_z}.</span>$</p>

    <p class="text-gray-300">However, this comes at the cost of increasing the entire batch for FRI by the factor  <span class="math">N_z</span>  (which might be acceptable in some applications, though). On the contrary, resampling of FRI challenges would increase the proof size too much. Hence for FRI extension field sampling is preferable.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>Alternatively one could run the Guruswami-Sudan list decoder over K = F(Z). However, its run-time analysis in the number of operations over F is probably more difficult.</p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Beyond the Johnson bound?</h3>

    <p class="text-gray-300">The conjectured soundness error for FRI alone (Conjecture 1) is not good enough to argue the security of DEEP-ALI beyond the Guruswami-Sudan list decoding bound. For that reason we also cite a general conjecture on the list decodability of Reed-Solomon codes, which is used by Ben-Sasson et al. to conjecture the soundness error of DEEP-FRI up to capacity bound.</p>

    <p class="text-gray-300"><strong>Conjecture 2.</strong> ([BGKS20], Conjecture 21) Let  <span class="math">RS_k[F,D]</span>  be the Reed-Solomon code over a prime field  <span class="math">F = F_q</span>  with defining domain D and rate  <span class="math">\\rho = \\frac{k}{|D|}</span> . Then there exists a constant  <span class="math">C_\\rho</span>  such that for every  <span class="math">\\theta = 1 - \\rho - \\eta</span> , with  <span class="math">\\eta &gt; 0</span> ,  <span class="math">RS_k[F,D]</span>  is list-decodable from a fraction of  <span class="math">\\theta</span>  errors with list size</p>

    <p class="text-gray-300"><span class="math">$L \\le \\left(\\frac{|D|}{\\eta}\\right)^{C_{\\rho}}.</span>$</p>

    <p class="text-gray-300">Remark 11. No concrete assumptions on the constant  <span class="math">C_{\\rho}</span>  are made in [BGKS20].</p>

    <p class="text-gray-300">For quite large fields F (compared to the block length |D|=n) there are linear codes which are list decodable up to capacity bound  <span class="math">1-\\rho</span> , such as the folded Reed-Solomon codes (see [Gur07], e.g.). In the case of a bounded alphabet, Guruswami [Gur07] demonstrates binary linear codes which are list decodable to the Zyablow bound  <span class="math">\\frac{1-\\rho}{H}</span>  (here, H is the entropy of the code) and uses such codes to construct examples that approach capacity bound, having list size  <span class="math">L=O\\left(\\frac{1}{\\eta}\\right)</span> .</p>

    <p class="text-gray-300">However, practitioners seem to avoid this conjecture. The ethSTARK documentation [Sta23] takes a toy protocol as a representative for the entire DEEP-ALI of AIR, whereas the Plonky2 writeup [?] only sketches soundness in the polynomial oracle model, with no reference to list bounds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast Reed-Solomon interactive oracle proofs of proximity. In <em>ICALP 2018</em>, 2018. Full paper: https://eccc.weizmann.ac.il/report/2017/134/.</p></li>
      <li><p class="text-gray-300">[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. In <em>IACR ePrint Archive 2018/046</em>, 2018. https://eprint.iacr.org/2018/046.</p></li>
      <li><p class="text-gray-300">[BCC<sup>+</sup>16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In M. Fischlin and J.S. Coron, editors, <em>EUROCRYPT 2016</em>, volume 9666 of <em>LNCS</em>. Springer, 2016. Full paper: https://eprint.iacr.org/2016/263.</p></li>
      <li><p class="text-gray-300">[BCI<sup>+</sup>20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for Reed-Solomon codes. In <em>FOCS 2020</em>, 2020. Full paper: https://eprint.iacr.org/2020/654.</p></li>
      <li><p class="text-gray-300">[BCR<sup>+</sup>19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Y. Ishai and Vincent Rijmen, editors, <em>EUROCRYPT 2019</em>, volume 11476 of <em>LNCS</em>. Springer, 2019.</p></li>
      <li><p class="text-gray-300">[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In <em>TCC</em> 2016, pages 31&ndash;60, 2016.</p></li>
      <li><p class="text-gray-300">[BDFG21] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Halo Infinite: Recursive zk-snarks from additive polynomial commitments. In <em>CRYPTO 2021</em>, volume 12825 of <em>LNCS</em>. Springer, 2021. Full paper: <a href="https://eprint.iacr.org/2020/1536" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2020/1536</a>.</p></li>
      <li><p class="text-gray-300">[BFS20] Benedikt B&uml;unz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In <em>EUROCRYPT 2020</em>, 2020. Full paper: <a href="https://eprint.iacr.org/2019/1229" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/1229</a>.</p></li>
      <li><p class="text-gray-300">[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling outside the box improves soundness. In <em>ITCS 2020</em>, 2020. Full paper: <a href="https://eprint.iacr.org/2019/336" target="_blank" rel="noopener noreferrer">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2019/336" target="_blank" rel="noopener noreferrer">org/2019/336</a>.</p></li>
      <li><p class="text-gray-300">[CHM+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In <em>EUROCRYPT 2020</em>, volume 12105 of <em>LNCS</em>, 2020. Full paper: <a href="https://eprint.iacr.org/2019/1047.pdf" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/1047.pdf</a>.</p></li>
      <li><p class="text-gray-300">[GS99] Venkatesan Guruswami and Madhu Sudan. Improved decoding of Reed-Solomon and algebraic-geometry codes. In <em>IEEE Trans. on Information Theory</em>, volume 45(6), 1999.</p></li>
      <li><p class="text-gray-300">[Gur07] Venkatesan Guruswami. Algorithmic results in list decoding. In <em>Foundation and Trands in Theoretical Computer Science</em>, volume 2(2), 2007.</p></li>
      <li><p class="text-gray-300">[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical non-interactive arguments of knowledge. In <em>IACR ePrint Archive 2019/953</em>, 2019. <a href="https://eprint.iacr.org/2019/953" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/953</a>.</p></li>
      <li><p class="text-gray-300">[HGdB21] Ulrich Hab&uml;ock, Alberto Garoffolo, and Daniele di Benedetto. Darlin: Recursive proofs based on Marlin. In <em>IACR preprint archive 2021/930</em>, 2021. <a href="https://eprint.iacr.org/2021/930" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2021/930</a>.</p></li>
      <li><p class="text-gray-300">[HK24] Ulrich Hab&uml;ock and Al Kindi. A note on adding zero-knowledge to STARKs. In <em>IACR ePrint Archive 2024/1037</em>, 2024. <a href="https://eprint.iacr.org/2024/1037" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2024/1037</a>.</p></li>
      <li><p class="text-gray-300">[KPV19] Assimakis Kattis, Konstantin Panarin, and Alaxander Vlasov. REDSHIFT: Transparent snarks from list polynomial commitment IOPs. In <em>IACR preprint archive 2019/1400</em>, 2019. <a href="https://eprint.iacr.org/2019/1400" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/1400</a>.</p></li>
      <li><p class="text-gray-300">[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In <em>ACM SIGSAC Conference on Computer and Communication Security</em>, pages 2111&ndash;2128, 2019. Full paper: <a href="https://eprint.iacr.org/2019/099" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/099</a>.</p></li>
      <li><p class="text-gray-300">[Pol] Polygon Labs / Polygon Zero. Plonky2: Fast recursive arguments with PLONK and FRI. <a href="https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf" target="_blank" rel="noopener noreferrer">https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf</a>.</p></li>
      <li><p class="text-gray-300">[Sta23] StarkWare Team. ethSTARK documentation &ndash; version 1.2. In <em>IACR preprint archive 2021/582</em>, 2023. <a href="https://eprint.iacr.org/2021/582" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2021/582</a>.</p></li>
      <li><p class="text-gray-300">[Sud97] Madhu Sudan. Decoding of Reed Solomon codes beyond the error-correction bound. In <em>Journal of Complexity</em>, volume 13(1), 1997.</p></li>
      <li><p class="text-gray-300">[WB86] Lloyd R. Welch and Elwyn R. Berlekamp. Error correction for algebraic block codes. US Patent 4633470, 1986. <a href="https://patents.google.com/patent/US4633470A" target="_blank" rel="noopener noreferrer">https://patents.google.com/patent/US4633470A</a>.</p></li>
    </ul>

    <p class="text-gray-300">In this section we recap well-known facts on decodability of Reed-Solomon codes<sup>8</sup>, and describe the weighted variant of Theorem 1, which is used by the soundness analysis of FRI.</p>

    <p class="text-gray-300">Unless contrary stated, we assume that K is a <em>general</em> field (finite, or infinite), and as for finite fields we shall call</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{RS}_k[K,D] = \\{ p(x) |_{x \\in D} \\ : \\ p(X) \\in K[X], \\deg p(X) \\le k - 1 \\}</span>$</p>

    <p class="text-gray-300">the Reed-Solomon code with rate  <span class="math">\\rho = \\frac{k}{|D|}</span>  and blocklength n = |D|. We say that a family of codes  <span class="math">\\{V(n)\\}</span>  of increasing blocklength n is list decodable up to distance  <span class="math">\\theta \\in (0,1)</span> , if the maximum possible number of  <span class="math">\\theta</span> -close codewords,</p>

    <p class="text-gray-300"><span class="math">$L = \\sup_{f \\in K^D} \\big| B(f, \\theta) \\cap V(n) \\big|,</span>$</p>

    <p class="text-gray-300">is polynomial in the blocklength n. (Here,  <span class="math">B(f,\\theta) = \\{w \\in \\mathsf{RS}_k[K,D] : \\delta(f,w) &lt; \\theta\\}</span>  is the open -ball around f, and  <span class="math">\\delta</span>  is the fractional Hamming distance.) As in the main part of the document, we throughout assume that both n and k are even.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Berlekamp-Welch decoder</h3>

    <p class="text-gray-300">Assume that  <span class="math">f \\in K^D</span>  is at most  <span class="math">\\theta_0</span> -close to V, with  <span class="math">\\theta_0 = \\frac{1-\\rho}{2}</span>  being the unique decoding radius, and let p(X) be the unique polynomial of degree  <span class="math">\\leq k-1</span>  such that  <span class="math">\\delta(f,p) \\leq \\theta_0</span> . Then the number of points of disagreement is at most  <span class="math">e = \\frac{n-k}{2}</span> . The Berlekamp-Welch decoder [WB86] is based on the observation that if  <span class="math">\\Omega = \\{x_1, \\ldots, x_e\\}</span>  is the set of errors, and  <span class="math">E(x) = \\prod_{x \\in \\Omega} (X - x)</span>  is its vanishing polynomial, then we have</p>

    <p class="text-gray-300"><span class="math">$E(x) \\cdot f(x) = E(x) \\cdot p(x)</span>$</p>

    <p class="text-gray-300">for all  <span class="math">x \\in D</span> .</p>

    <p class="text-gray-300"><strong>Protocol 4</strong> (Welch-Berlekamp decoding). Let K be a general field, and  <span class="math">V = \\mathsf{RS}_k[K,D]</span>  be the Reed-Solomon code of length n = |D| and rate  <span class="math">\\rho = \\frac{k}{n}</span> . Assume any word  <span class="math">f \\in K^D</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Find the coefficients of polynomials E(X), G(X) over K with  <span class="math">\\deg E(X) \\leq e</span> ,  <span class="math">\\deg G(X) \\leq k-1+e</span> , where  <span class="math">e = \\frac{n-k}{2}</span> , such that</li>
    </ol>

    <p class="text-gray-300"><span class="math">$E(x) \\cdot w(x) = G(x)</span>$
for all  <span class="math">x \\in D</span> .</p>

    <p class="text-gray-300">This linear system has at least one non-trivial solution which can be found in at most  <span class="math">O(n^3)</span>  field operations.</p>

    <p class="text-gray-300">This is a homogeneous linear system of |D| = n equations in  <span class="math">k + 2 \\cdot e + 1 = n + 1</span>  unknown: The e + 1 coefficients of E(X) and the k + e coefficients of G(X).</p>

    <p class="text-gray-300">Notice that for any such non-trivial solution (E(X), G(X)) the polynomial E(X) must be non-trivial. If E(x) would be identically zero, by the size of D the same is true G(x).</p>

    <p class="text-gray-300">2. For any such non-trivial solution (E(X), G(X)) obtained in step 1, check if G(X) is divisible by E(X). If yes, then output  <span class="math">p(X) = \\frac{G(X)}{E(X)}</span> . (If not, then abort.)</p>

    <p class="text-gray-300">For a word  <span class="math">f \\in K^D</span>  with fractional Hamming distance of at most  <span class="math">\\theta_0</span> , Step (2) of Protocol 4 always succeeds: Let p(X) be the (unique)  <span class="math">\\theta_0</span> -close code word. This polynomial agrees with f on a set of size  <span class="math">a \\ge \\frac{n+k}{2}</span> . Consider the bivariate polynomial</p>

    <p class="text-gray-300"><span class="math">$Q(X,Y) := Y \\cdot E(X) - G(X).</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>The survey by Guruswami [Gur07] is a recommended source.</p>

    <p class="text-gray-300">Then Q(X, p(X)) is a univariate polynomial of degree</p>

    <p class="text-gray-300"><span class="math">$\\deg Q(X, p(X)) \\le k - 1 + e = \\frac{n+k}{2} - 1,</span>$</p>

    <p class="text-gray-300">which by the assumption on p(X) has at least a zeroes. Consequently Q(X, p(X)) is trivial and  <span class="math">p(X) \\cdot E(X) = G(X)</span>  holds as a formal identity. Since E(X) is non-trivial, we conclude divisibility.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 List decoding</h3>

      <h4 id="app-a.2.1" class="text-lg font-semibold mt-6">A.2.1 The Sudan decoder</h4>

    <p class="text-gray-300">The Sudan list decoder [Sud97] generalizes the Berlekamp-Welch procedure by searching for general bivariate polynomials  <span class="math">Q(X,Y) \\in K[X,Y]</span>  which satisfy</p>

    <p class="text-gray-300"><span class="math">$Q(x, f(x)) = 0</span>$
for all  <span class="math">x \\in D</span> .</p>

    <p class="text-gray-300">In order that Y - p(X) is a factor of Q(X, Y) for every polynomial p(X) of degree  <span class="math">\\leq d = k - 1</span>  which has the claimed agreement set size with f, one looks for such bivariate Q so that the degree of Q(X, p(X)) for any such polynomial is smaller than the targeted agreement set size.</p>

    <p class="text-gray-300"><strong>Definition 12.</strong> The (1,d)-weighted degree (in short, (1,d)-degree) of a monomial  <span class="math">X^i \\cdot Y^j</span>  is  <span class="math">i+d \\cdot j</span> . More generally, the (1,d)-weighted degree of a bivariate polynomial Q(X,Y) is the maximum of the weighted degrees of its monomials.</p>

    <p class="text-gray-300">A polynomial Q(X,Y) of (1,d)&mdash;weighted degree W is of the form</p>

    <p class="text-gray-300"><span class="math">$Q(X,Y) = \\sum_{i+d \\cdot j \\le W, i,j \\ge 0} c_{i,j} \\cdot X^i \\cdot Y^j,</span>$</p>

    <p class="text-gray-300">and its number of coefficients is</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\sum_{j=0}^{\\lfloor W/d \\rfloor} W - d \\cdot j + 1 &amp;= (W+1) \\cdot \\left( \\left\\lfloor \\frac{W}{d} \\right\\rfloor + 1 \\right) - d \\cdot \\frac{\\left\\lfloor \\frac{W}{d} \\right\\rfloor \\cdot \\left( \\left\\lfloor \\frac{W}{d} \\right\\rfloor + 1 \\right)}{2} \\\\ &amp;\\geq \\left( \\left\\lfloor \\frac{W}{d} \\right\\rfloor + 1 \\right) \\cdot \\left( W + 1 - \\frac{W}{2} \\right) \\\\ &amp;\\geq \\frac{(W+1) \\cdot (W+2)}{2 \\cdot d} \\end{split}</span>$</p>

    <p class="text-gray-300">As a consequence, if this lower bound exceeds the number of linear equations n = |D|, the linear system has a non-trivial solution. In particular this holds for any</p>

    <p class="text-gray-300"><span class="math">$W \\ge \\left| \\sqrt{2 \\cdot d \\cdot n} \\right|.</span>$</p>

    <p class="text-gray-300"><strong>Protocol 5</strong> (Sudan list decoder). Assume that K is a general field, and  <span class="math">\\mathsf{RS}_k[K,D]</span>  is the Reed-Solomon code of length n = |D| and rate  <span class="math">\\rho = \\frac{k}{n}</span> . Let  <span class="math">f \\in K^D</span> , and choose an agreement parameter  <span class="math">a \\in [0,n]</span> ,  <span class="math">a &gt; \\sqrt{2 \\cdot d \\cdot n}</span> , where d = k - 1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Solve the linear system on the coefficients of Q(X,Y) with (1,d)-degree  <span class="math">W = \\lfloor \\sqrt{2 \\cdot d \\cdot n} \\rfloor</span> , given by the interpolation constraints</li>
    </ol>

    <p class="text-gray-300"><span class="math">$Q(x, f(x)) = 0, \\quad x \\in D.</span>$</p>

    <p class="text-gray-300">This system has a non-trivial solution which is found in at most  <span class="math">O(n^3)</span>  field operations. Note that by construction, for any  <span class="math">\\left(1-\\frac{a}{n}\\right)</span> -close code word p(X) the (irreducible) polynomial Y-p(X) divides Q(X,Y) in the polynomial ring K[X,Y]. Since K[X,Y] is a unique factorization domain, this already proves that the list size  <span class="math">L \\leq \\left\\lfloor \\frac{W}{d} \\right\\rfloor \\leq \\frac{\\sqrt{2 \\cdot d \\cdot n}}{d} = \\sqrt{\\frac{2 \\cdot n}{d}}</span> .</p>

    <p class="text-gray-300">2. Find all factors of Q(X,Y) which are of the form</p>

    <p class="text-gray-300"><span class="math">$Y - p(X)</span>$
,</p>

    <p class="text-gray-300">with p(X) being a polynomial over K of degree at most k-1. There are at most  <span class="math">\\sqrt{\\frac{2 \\cdot n}{d}}</span>  such factors. Filter out those which agree with f on at least a points.</p>

    <p class="text-gray-300">The efficiency of Step (2) depends on the field K. If K is a finite field, then there are polynomial time algorithms (both probabilistic or deterministic) for finding such factors of the form Y - p(X). (They both rely on univariate factorization, see [Gur07], e.g.) If K is infinite, then this might not be true in general.</p>

      <h4 id="app-a.2.2" class="text-lg font-semibold mt-6">A.2.2 The Guruswami-Sudan decoder</h4>

    <p class="text-gray-300">To extend the interpolation technique to the Johnson limit  <span class="math">1-\\sqrt{\\rho}</span> , one takes into account that several close codewords might coincide at some points. One therefore looks for polynomials Q(X,Y) the (1,d)-degree of which is m times as large as the targeted agreement set would suggest, and which have a zero of order m at every interpolating point  <span class="math">(x, f(x)), x \\in D</span> . The parameter  <span class="math">m \\ge 1</span>  is called <em>multiplicity parameter</em>.</p>

    <p class="text-gray-300"><strong>Definition 13.</strong> A polynomial  <span class="math">Q(X,Y) \\in K[X,Y]</span>  is said to have a zero of order m at the point (x,y), if the polynomial Q(X-x,Y-y) has no monomial of absolute degree &lt; m.</p>

    <p class="text-gray-300">Such polynomials Q(X,Y) of (1,d)-weighted degree W have still the property, that if p(X) is a polynomial of  <span class="math">\\deg p(X) \\leq d</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\deg Q(X, p(X)) \\le \\frac{W}{m}.</span>$</p>

    <p class="text-gray-300">Again, counting the number of coefficients and comparing with the number of interpolation constraints yields that whenever</p>

    <p class="text-gray-300"><span class="math">$\\frac{(W+1)\\cdot(W+2)}{d\\cdot m\\cdot(m+1)} &gt; n,</span>$</p>

    <p class="text-gray-300">and hence in particular for  <span class="math">W \\ge \\left\\lfloor \\sqrt{m \\cdot (m+1) \\cdot d \\cdot n} \\right\\rfloor</span>  there always exists such a (non-trivial) polynomial Q(X,Y). (For details, see [Gur07], e.g.)</p>

    <p class="text-gray-300"><strong>Protocol 6</strong> (Guruswami-Sudan list decoder [GS99]). Assume that K is a general field, and  <span class="math">\\mathsf{RS}_k[K,D]</span>  the Reed-Solomon code of length n = |D| and rate  <span class="math">\\rho = \\frac{k}{n}</span> . Let  <span class="math">f \\in K^D</span> , and choose an agreement parameter  <span class="math">a \\in [0,n], \\ a &gt; \\sqrt{\\left(1 + \\frac{1}{m}\\right) \\cdot d \\cdot n}</span> , where m is a positive integer (the multiplicity parameter).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Solve the linear system on the coefficients of Q(X,Y) with (1,d)-degree  <span class="math">W = [\\sqrt{m \\cdot (m+1) \\cdot d \\cdot n}]</span> : For each  <span class="math">x \\in D</span> ,</li>
    </ol>

    <p class="text-gray-300"><span class="math">$Q(X,Y)</span>$
has a zero of order  <span class="math">m</span>  at  <span class="math">(x,f(x))</span> .</p>

    <p class="text-gray-300">Such a solution always exists and can be found in polynomially many field operations.</p>

    <p class="text-gray-300">By construction, again for any  <span class="math">\\left(1-\\frac{a}{n}\\right)</span> -close code word p(X) the irreducible polynomial Y-p(X) divides Q(X,Y). This already proves that the list size  <span class="math">L \\leq \\frac{\\sqrt{m \\cdot (m+1) \\cdot d \\cdot n}}{d} &lt; \\sqrt{\\frac{m \\cdot (m+1)}{\\rho}}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Find all factors of Q(X,Y) which are of the form</li>
    </ol>

    <p class="text-gray-300"><span class="math">$Y - p(X)</span>$
,</p>

    <p class="text-gray-300">with p(X) being a polynomial over K of degree at most d = k - 1. There are at most  <span class="math">\\sqrt{\\frac{m \\cdot (m+1)}{\\rho}}</span>  many. Filter out those which agree with f on at least a points.</p>

    <p class="text-gray-300">As before, this step might be efficient or not, depending on the field K.</p>

    <p class="text-gray-300">Remark 14. Choosing the discriminant method to find factors of the form Y - p(X), the Guruswami-Sudan list decoder taking at most</p>

    <p class="text-gray-300"><span class="math">$O\\left(\\max\\left\\{\\frac{d^3 \\cdot n^6 \\cdot a^6}{(a^2 - d \\cdot n)^6}, \\frac{a^6}{k^3}\\right\\}\\right)</span>$</p>

    <p class="text-gray-300">field operations over K, see [GS99]. This is at most of order  <span class="math">O(|D|^{15})</span> .</p>

    <p class="text-gray-300">Note that choosing</p>

    <p class="text-gray-300"><span class="math">$\\alpha = \\frac{a}{n} \\ge \\sqrt{\\left(1 + \\frac{1}{m}\\right) \\cdot \\rho}</span>$</p>

    <p class="text-gray-300">implies a large enough agreement parameter for the Protocol 6. In particular the choice  <span class="math">\\alpha = \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho}</span>  used throughout the main part of the document is strong enough, since</p>

    <p class="text-gray-300"><span class="math">$\\left(1 + \\frac{1}{2 \\cdot m}\\right)^2 = 1 + \\frac{1}{m} + \\frac{1}{4 \\cdot m^2} \\ge 1 + \\frac{1}{m}.</span>$</p>

    <p class="text-gray-300">Let us summarize the consequences of Protocol 6.</p>

    <p class="text-gray-300"><strong>Theorem 15</strong> (Guruswami-Sudan). Let K be a general (possibly infinite) field, and</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{RS}_k[K,D] = \\{ p(x) |_{x \\in D} \\ : \\ p(X) \\in K[X], \\deg(p) &lt; |D| \\}</span>$</p>

    <p class="text-gray-300">the Reed-Solomon code of block length n=|D| and rate  <span class="math">\\rho=\\frac{k}{n}</span> . Choos a proximity parameter  <span class="math">\\theta=1-\\left(1+\\frac{1}{2\\cdot m}\\right)\\cdot\\sqrt{\\rho}</span>  for some integer  <span class="math">m\\geq 1</span> . Then  <span class="math">\\mathsf{RS}_k[K,D]</span>  is list decodable for  <span class="math">\\theta</span>  with list bound</p>

    <p class="text-gray-300"><span class="math">$L \\le \\sqrt{\\frac{m \\cdot (m+1)}{\\rho}} \\le \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho}}.</span>$
(24)</p>

    <p class="text-gray-300">If K is finite, then the Guruswami-Sudan decoder runs in polynomial time.</p>

    <p class="text-gray-300">We say that a function  <span class="math">f \\in F^D</span>  has  <span class="math">\\mu</span> -agreement of at least  <span class="math">\\alpha</span>  with another function  <span class="math">g \\in F^D</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{agree}_{\\mu}(f,g) &gt; \\alpha,</span>$</p>

    <p class="text-gray-300">if there is a set  <span class="math">A \\subseteq D</span>  of measure  <span class="math">\\mu(A) &gt; \\alpha</span>  on which both functions agree. Likewise we say that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{agree}_{\\mu}(f, \\mathsf{RS}_k) &gt; \\alpha,</span>$</p>

    <p class="text-gray-300">if there exists a  <span class="math">p \\in \\mathsf{RS}_k[F,D]</span>  for which  <span class="math">agree_\\mu(f,p) &gt; \\alpha</span> .</p>

    <p class="text-gray-300"><strong>Theorem 16.</strong> (Full version of [BCI<sup>+</sup> 20], Theorem 7.1) Let  <span class="math">\\theta \\in \\left(\\frac{1-\\rho}{2}, 1-\\sqrt{\\rho}\\right)</span> , where  <span class="math">\\theta = 1-\\sqrt{\\rho} \\cdot \\left(1+\\frac{1}{2m}\\right)</span> , for some integer  <span class="math">m \\geq 3</span> , and assume that  <span class="math">\\mu</span>  is a sub-probability measure on D with common denominator M, i.e. for all x in D</p>

    <p class="text-gray-300"><span class="math">$\\mu(\\{x\\}) = \\frac{a_x}{M},</span>$</p>

    <p class="text-gray-300">for an integer value  <span class="math">a_x</span> . Suppose that for  <span class="math">f_0, f_1, \\ldots, f_{N-1} \\in F^D</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\left|\\left\\{\\lambda: \\mathsf{agree}_{\\mu}(f_0 + \\lambda \\cdot f_1 + \\ldots + \\lambda^{N-1} \\cdot f_{N-1}, \\mathsf{RS}_k) &gt; \\alpha\\right\\}\\right|}{|F|}</span>$</p>

    <p class="text-gray-300"><span class="math">$&gt; \\max \\left( \\varepsilon, (N-1) \\cdot \\frac{M \\cdot |D| + 1}{|F|} \\cdot \\frac{2m+1}{\\sqrt{\\rho}} \\right),</span>$</p>

    <p class="text-gray-300">with  <span class="math">\\varepsilon</span>  as in (2). Then there exist polynomials  <span class="math">p_0(X)</span> ,  <span class="math">p_1(X)</span> , ...,  <span class="math">p_{N-1}(X)</span>  from  <span class="math">\\mathsf{RS}_k[F,D]</span> , and a set A of density  <span class="math">\\mu(A) &gt; \\alpha</span>  on which  <span class="math">f_i</span>  coincides with  <span class="math">p_i</span>  for all  <span class="math">i = 0, \\ldots, N-1</span> .</p>

`;
---

<BaseLayout title="A summary on the FRI low degree test (2022/1216)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1216
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Notation</a></li>
          </ol>
        </li>
        <li><a href="#sec-2" class="hover:text-white">Correlated agreement</a></li>
        <li>
          <a href="#sec-3" class="hover:text-white">FRI proof of proximity</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Reduction</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Sampling phase</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Batching</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Soundness</a></li>
            <li><a href="#sec-3.5" class="hover:text-white">Example parameters</a></li>
            <li><a href="#sec-3.5.1" class="hover:text-white">66 bits of security</a></li>
            <li><a href="#sec-3.5.2" class="hover:text-white">112 bits security</a></li>
            <li><a href="#sec-3.5.3" class="hover:text-white">128 bits security</a></li>
            <li><a href="#sec-3.6" class="hover:text-white">Conjectured security</a></li>
            <li><a href="#sec-3.7" class="hover:text-white">Adding zero-knowledge</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">FRI as a polynomial commitment scheme</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">In the unique decoding regime</a></li>
            <li><a href="#sec-4.1.1" class="hover:text-white">A first construction</a></li>
            <li><a href="#sec-4.1.2" class="hover:text-white">The refined scheme</a></li>
            <li><a href="#sec-4.1.3" class="hover:text-white">Multi-point queries</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">List commitments</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">DEEP-ALI</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Algebraic linking and the DEEP method</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">DEEP-ALI of an AIR</a></li>
            <li><a href="#sec-5.2.1" class="hover:text-white">Extractability</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Boosting soundness</a></li>
            <li><a href="#sec-5.3.1" class="hover:text-white">Using extension fields</a></li>
            <li><a href="#sec-5.3.2" class="hover:text-white">Increasing the number of protocol challenges</a></li>
            <li><a href="#sec-5.4" class="hover:text-white">Beyond the Johnson bound?</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Appendix</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Berlekamp-Welch decoder</a></li>
            <li><a href="#app-a.2" class="hover:text-white">List decoding</a></li>
            <li><a href="#app-a.2.1" class="hover:text-white">The Sudan decoder</a></li>
            <li><a href="#app-a.2.2" class="hover:text-white">The Guruswami-Sudan decoder</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Weighted correlated agreement</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-summary-on-the-fri-low-degree-test-2022" />
  </article>
</BaseLayout>
