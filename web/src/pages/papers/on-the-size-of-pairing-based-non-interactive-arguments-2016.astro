---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/260';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On the Size of Pairing-based Non-interactive Arguments';
const AUTHORS_HTML = 'Jens Groth';

const CONTENT = `    <p class="text-gray-300">On the Size of Pairing-based Non-interactive Arguments</p>

    <p class="text-gray-300">Jens Groth**</p>

    <p class="text-gray-300">University College London, UK</p>

    <p class="text-gray-300">j.groth@ucl.ac.uk</p>

    <p class="text-gray-300">Abstract. Non-interactive arguments enable a prover to convince a verifier that a statement is true. Recently there has been a lot of progress both in theory and practice on constructing highly efficient non-interactive arguments with small size and low verification complexity, so-called succinct non-interactive arguments (SNARGs) and succinct non-interactive arguments of knowledge (SNARKs).</p>

    <p class="text-gray-300">Many constructions of SNARGs rely on pairing-based cryptography. In these constructions a proof consists of a number of group elements and the verification consists of checking a number of pairing product equations. The question we address in this article is how efficient pairing-based SNARGs can be.</p>

    <p class="text-gray-300">Our first contribution is a pairing-based (preprocessing) SNARK for arithmetic circuit satisfiability, which is an NP-complete language. In our SNARK we work with asymmetric pairings for higher efficiency, a proof is only 3 group elements, and verification consists of checking a single pairing product equations using 3 pairings in total. Our SNARK is zero-knowledge and does not reveal anything about the witness the prover uses to make the proof.</p>

    <p class="text-gray-300">As our second contribution we answer an open question of Bitansky, Chiesa, Ishai, Ostrovsky and Paneth (TCC 2013) by showing that 2-move linear interactive proofs cannot have a linear decision procedure. It follows from this that SNARGs where the prover and verifier use generic asymmetric bilinear group operations cannot consist of a single group element. This gives the first lower bound for pairing-based SNARGs. It remains an intriguing open problem whether this lower bound can be extended to rule out 2 group element SNARGs, which would prove optimality of our 3 element construction.</p>

    <p class="text-gray-300">Keywords: SNARKs, non-interactive zero-knowledge arguments, linear interactive proofs, quadratic arithmetic programs, bilinear groups.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Goldwasser, Micali and Rackoff [GMR89] introduced zero-knowledge proofs that enable a prover to convince a verifier that a statement is true without revealing anything else. They have three core properties:</p>

    <p class="text-gray-300">Completeness: Given a statement and a witness, the prover can convince the verifier.</p>

    <p class="text-gray-300">Soundness: A malicious prover cannot convince the verifier of a false statement.</p>

    <p class="text-gray-300">Zero-knowledge: The proof does not reveal anything but the truth of the statement, in particular it does not reveal the prover's witness.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>©IACR 2016. This article is a minor revision of the version published by Springer-Verlag at http://dx.doi.org/10.1007/978-3-662-49896-5_11</li>

    </ul>

    <p class="text-gray-300">** The research leading to these results has received funding from the European Research Council under the European Union’s Seventh Framework Programme (FP/2007-2013) / ERC Grant Agreement n. 307937 and the Engineering and Physical Sciences Research Council grant EP/J009520/1. This work was done in part while the author was visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467.</p>

    <p class="text-gray-300">Blum, Feldman and Micali <em>[x1]</em> extended the notion to non-interactive zero-knowledge (NIZK) proofs in the common reference string model. NIZK proofs are useful in the construction of non-interactive cryptographic schemes, e.g., digital signatures and CCA-secure public key encryption.</p>

    <p class="text-gray-300">The amount of communication is an important performance parameter for zero-knowledge proofs. Kilian <em>[x10]</em> gave the first sublinear communication zero-knowledge argument that sends fewer bits than the size of the statement to be proved. Micali <em>[x13]</em> proposed sublinear size arguments by letting the prover in a communication efficient argument compute the verifier’s challenges using a cryptographic function, and as remarked in Kilian <em>[x11]</em> this leads to sublinear size NIZK proofs when the interactive argument is public coin and zero-knowledge.</p>

    <p class="text-gray-300">Groth, Ostrovsky and Sahai <em>[x12, x13, x14, x15]</em> introduced pairing-based NIZK proofs, yielding the first linear size proofs based on standard assumptions. Groth <em>[x12]</em> combined these techniques with ideas from interactive zero-knowledge arguments <em>[x13]</em> to give the first constant size NIZK arguments. Lipmaa <em>[x14]</em> used an alternative construction based on progression-free sets to reduce the size of the common reference string.</p>

    <p class="text-gray-300">Groth’s constant size NIZK argument is based on constructing a set of polynomial equations and using pairings to efficiently verify these equations. Gennaro, Gentry, Parno and Raykova <em>[x10]</em> found an insightful construction of polynomial equations based on Lagrange interpolation polynomials yielding a pairing-based NIZK argument with a common reference string size proportional to the size of the statement and witness. They gave two types of polynomial equations: quadratic span programs for proving boolean circuit satisfiability and quadratic arithmetic programs for proving arithmetic circuit satisfiability. Lipmaa <em>[x14]</em> suggested more efficient quadratic span programs using error correcting codes, and Danezis, Fournet, Groth and Kohlweiss <em>[x6]</em> refined quadratic span programs to square span programs that give NIZK arguments consisting of 4 group elements for boolean circuit satisfiability.</p>

    <p class="text-gray-300">Exciting work on implementation has followed the above theoretical advances <em>[PHGR13, BCG^{+}13, BFR^{+}13, BCTV14b, KPP^{+}14, BBFR15, CTV15, WSR^{+}15, CFH^{+}15, SVdV16]</em>. Most efficient implementations refine the quadratic arithmetic program approach of Gennaro et al. <em>[x10]</em> and combine it with a compiler producing a suitable quadratic arithmetic program that is equivalent to the statement to be proven; libsnark <em>[x2, BSCG^{+}14]</em> also includes an NIZK argument based on <em>[x6]</em>.</p>

    <p class="text-gray-300">One powerful motivation for building efficient non-interactive arguments is verifiable computation. A client can outsource a complicated computational task to a server in the cloud and get back the results. To convince the client that the computation is correct the server may include a non-interactive argument of correctness with the result. However, since the verifier does not have many computational resources this only makes sense if the argument is compact and computationally light to verify, i.e., it is a succinct non-interactive argument (SNARG) or a succinct non-interactive argument of knowledge (SNARK). While pairing-based SNARGs are efficient for the verifier, the computational overhead for the prover is still orders of magnitude too high to warrant use in outsourced computation <em>[x16, x17]</em> and further efficiency improvements are needed. In their current state, SNARKs that are zero-knowledge already have uses when proving statements about private data though. Zero-knowledge SNARKs are for</p>

    <p class="text-gray-300">instance key ingredients in the virtual currency proposals Pinocchio coin <em>[x10]</em> and Zerocash <em>[BCG^{+}14]</em>.</p>

    <p class="text-gray-300">In parallel with developments in pairing-based NIZK arguments there has been interesting work on understanding SNARKs. Gentry and Wichs <em>[x14]</em> showed that SNARGs must necessarily rely on non-falsifiable assumptions, and Bitansky et al. <em>[x3]</em> proved designated verifier SNARKs exist if and only if extractable collision-resistant hash functions exist. Of particular interest in terms of efficiency is a series of works studying how SNARKs compose <em>[x34, x2, x11]</em>. They show among other things that a preprocessing SNARK with a long common reference string can be used to build a fully succinct SNARK with a short common reference string.</p>

    <p class="text-gray-300">Bitansky et al. <em>[BCI^{+}13]</em> give an abstract model of SNARKs that rely on linear encodings of field elements. Their information theoretic framework called linear interactive proofs (LIPs) capture proof systems where the prover is restricted to using linear operations in computing her messages. They give a generic conversion of a 2-move LIP to a publicly verifiable SNARK using pairing-based techniques or to a designated verifier using additively homomorphic encryption techniques.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 Our contribution</h3>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Succinct NIZK.</h4>

    <p class="text-gray-300">We construct a NIZK argument for arithmetic circuit satisfiability where a proof consists of only 3 group elements. In addition to being small, the proof is also easy to verify. The verifier just needs to compute a number of exponentiations proportional to the statement size and check a single pairing product equation, which only has 3 pairings. Our construction can be instantiated with any type of pairings including Type III pairings, which are the most efficient pairings.</p>

    <p class="text-gray-300">The argument has perfect completeness and perfect zero-knowledge. For soundness we take an aggressive stance and rely on a security proof in the generic bilinear group model <em>[x37, x30]</em> in order to get optimal performance. This stance is partly justified by Gentry and Wichs <em>[x14]</em> that rule out SNARGs based on standard falsifiable assumptions. However, following Abe, Groth, Ohkubo and Tibouchi <em>[x1]</em> we do provide a hedge against cryptanalysis by proving our construction secure in the symmetric pairing setting. For optimal efficiency it makes sense to use our NIZK argument in the asymmetric setting, however, by providing a security proof in the symmetric setting we get additional security: even if cryptanalytic advances yield a hitherto unknown efficiently computable isomorphism between the source groups this does not necessarily lead to a break of our scheme. We therefore have a unified NIZK argument that can be instantiated with any type of pairing, yielding both optimal efficiency and optimal generic bilinear group resilience.</p>

    <p class="text-gray-300">We give a performance comparison for boolean circuit satisfiability in Table 1 and for arithmetic circuit satisfiability in Table 2 of the size of the common reference string (CRS), the size of the proof, the prover’s computation, the verifier’s computation, and the number of pairing product equations used to verify a proof. We perform better than the state of the art on all efficiency parameters.</p>

    <p class="text-gray-300">In both comparisons the number of wires exceeds the number of gates, <span class="math">m\\geq n</span>, since each gate has an output wire. We expect for typical cases that the statement size <span class="math">\\ell</span> will be small compared to <span class="math">m</span> and <span class="math">n</span>. In both tables, we have excluded the size of representing</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover comp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier comp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PPE</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[DFGK14]</td>

            <td class="px-3 py-2 border-b border-gray-700">2m+n-2ℓ G1, m+n-ℓ G2</td>

            <td class="px-3 py-2 border-b border-gray-700">3 G1, 1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">m+n-ℓ E1</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ M1, 6 P</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">3m+n G1, m G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G1, 1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">n E1</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ M1, 3 P</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Comparison for boolean circuit satisfiability with  <span class="math">\\ell</span> -bit statement,  <span class="math">m</span>  wires and  <span class="math">n</span>  fan-in 2 logic gates. Notation:  <span class="math">\\mathbb{G}</span>  means group elements,  <span class="math">M</span>  means multiplications,  <span class="math">E</span>  means exponentiations and  <span class="math">P</span>  means pairings with subscripts indicating the relevant group. It is possible to get a CRS size of  <span class="math">m + 2n</span>  elements in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">n</span>  elements in  <span class="math">\\mathbb{G}_2</span>  but we have chosen to include some precomputed values in the CRS to reduce the prover's computation, see Sect. 3.2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover comp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier comp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PPE</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[PHGR13]</td>

            <td class="px-3 py-2 border-b border-gray-700">7m+n-2ℓ G</td>

            <td class="px-3 py-2 border-b border-gray-700">8 G</td>

            <td class="px-3 py-2 border-b border-gray-700">7m+n-2ℓ E</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ E, 11 P</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">m+2n G</td>

            <td class="px-3 py-2 border-b border-gray-700">3 G</td>

            <td class="px-3 py-2 border-b border-gray-700">m+3n-ℓ E</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ E, 3 P</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCTV14a]</td>

            <td class="px-3 py-2 border-b border-gray-700">6m+n+ℓ G1, m G2</td>

            <td class="px-3 py-2 border-b border-gray-700">7 G1, 1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">6m+n-ℓ E1, m E2</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ E1, 12 P</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">m+2n G1, n G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G1, 1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">m+3n-ℓ E1, n E2</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ E1, 3 P</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Comparison for arithmetic circuit satisfiability with  <span class="math">\\ell</span> -element statement,  <span class="math">m</span>  wires,  <span class="math">n</span>  multiplication gates. Notation:  <span class="math">\\mathbb{G}</span>  means group elements,  <span class="math">E</span>  means exponentiations and  <span class="math">P</span>  means pairings. We compare symmetric pairings in the first two rows and asymmetric pairings in the last two rows.</p>

    <p class="text-gray-300">the relation for which we give proofs. In the boolean circuit satisfiability case, we are considering arbitrary fan-in 2 logic gates. In the arithmetic circuit satisfiability case we work with fan-in 2 multiplication gates where each input factor can be a weighed sum of other wires. We assume each multiplication gate input depends on a constant number of wires; otherwise the cost of evaluating the relation itself may exceed the cost of the subsequent proof generation.</p>

    <p class="text-gray-300">We note that [PHGR13] uses symmetric bilinear groups where  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span>  and we are therefore comparing with a symmetric bilinear group instantiation of our scheme, which saves  <span class="math">n</span>  elements in the common reference string. However, in the implementation of their system, called Pinocchio, asymmetric pairings are used for better efficiency. The switch to asymmetric pairings only requires minor modifications, see e.g. [BCTV14a] for a specification of such a SNARK, which has been implemented in the libsnark library.</p>

    <p class="text-gray-300">SIZE MATTERS. While the reduction in proof size to 3 group elements and the reduction in verification time is nice in itself, we would like to highlight that it is particularly important when composing SNARKs. [BCCT13,BCTV14a] show that preprocessing SNARKs with a long CRS can be composed to yield fully succinct SNARKs with a short CRS. <span class="math">^{1}</span>  The transformations split the statement into smaller pieces, prove each piece is correct by itself, and recursively construct proofs of knowledge of other proofs that jointly show the pieces are correct and fit together. In the recursive construction of proofs, it is extra beneficial when the proofs are small and easy to verify since the resulting statements "there exists a proof satisfying the verification equation..." become small themselves. So we gain both from the prover's lower computation and from the</p>

    <p class="text-gray-300">fact that the statements in the recursive composition are smaller since we have a more efficient verification procedure for our SNARK. Chiesa and Virza <em>[x10]</em> report a factor 4-5 speedup from using our SNARKs in the implementation of <em>[x3]</em>.</p>

    <p class="text-gray-300">Technique. All pairing-based SNARKs in the literature follow a common paradigm where the prover computes a number of group elements using generic group operations and the verifier checks the proof using a number of pairing product equations. Bitansky et al. <em>[BCI^{+}13]</em> formalize this paradigm through the definition of linear interactive proofs (LIPs). A linear interactive proof works over a finite field and the prover’s and verifier’s messages consist of vectors of field elements. It furthermore requires that the prover computes her messages using only linear operations. Once we have an approriate 2-move LIP, it can be compiled into a SNARK by executing the equations “in the exponent” using pairing-based cryptography. One source of our efficiency gain is that we design a LIP system for arithmetic circuits where the prover only sends 3 field elements. In comparison, the quadratic arithmetic programs by <em>[x14, x22]</em> correspond to LIPs where the prover sends 4 field elements.</p>

    <p class="text-gray-300">A second source of efficiency gain compared to previous work is a more aggressive compilation of the LIP. Bitansky et al. <em>[BCI^{+}13]</em> propose a transformation in the symmetric bilinear group setting, where each field element gets compiled into two group elements. They then use a knowledge of exponent assumption to argue that the prover knows the relevant field elements. A less conservative choice would be to compile each field element into a single group element. Compiling with a single group element per field element improves efficiency but we only prove security generic group model <em>[x31, x5]</em> since we can no longer use the knowledge of exponent assumption. It is also possible to make a choice between these two extremes, Parno et al. <em>[x22]</em> for instance have a LIP with 4 field elements, which gets compiled into 7 group elements. To summarize, in this paper we have opted for maximal efficiency and compile each field element in the LIP into a single group element and argue security in the generic group model.</p>

    <p class="text-gray-300">We prefer to work with asymmetric bilinear groups for their higher efficiency than symmetric bilinear groups. This means that there is more to the story than the number of field elements the prover sends in the LIP and the choice of how aggressive a compilation we use. When working with asymmetric bilinear groups, a field element can appear as an exponent in the first source group, the second source group, or both. Our LIP is carefully designed such that each field element gets compiled into a single source group element in order to minimize the proof size to 3 group elements in total.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Lower bounds.</h4>

    <p class="text-gray-300">Working towards ever more efficient non-interactive arguments, it is natural to ask what the minimal proof size is. We will show that pairing-based SNARGs with a single group element proof cannot exist. This result relates to an open question raised by Bitansky et al. <em>[BCI^{+}13]</em>, whether there are LIPs with a linear decision procedure for the verifier. Such a linear decision procedure would be quite useful; it could for instance enable the construction of SNARGs based on ElGamal encryption.</p>

    <p class="text-gray-300">We answer this open problem negatively by proving that LIPs with a linear decision procedure do not exist. A consequence of this is that any pairing-based SNARG must pair group elements from the proof together to make the decision procedure quadratic</p>

    <p class="text-gray-300">instead of linear. Working over asymmetric bilinear groups we must therefore have elements in both source groups in order to do such a pairing. This rules out the existence of 1 group element SNARGs, regardless of whether it is zero-knowledge or not, and shows our NIZK argument has close to optimal proof size. It remains an intriguing open problem to completely close the gap by either constructing a SNARG with exactly one element from each source group <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>, or alternatively rule out the existence of such a SNARG.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given two functions <span class="math">f,g:\\mathbb{N}\\to[0,1]</span> we write <span class="math">f(\\lambda)\\approx g(\\lambda)</span> when $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\lambda)-g(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lambda^{-\\omega(1)}<span class="math">. We say that </span>f<span class="math"> is negligible when </span>f(\\lambda)\\approx 0<span class="math"> and that </span>f<span class="math"> is overwhelming when </span>f(\\lambda)\\approx 1<span class="math">. We will use </span>\\lambda<span class="math"> to denote a security parameter, with the intuition that as </span>\\lambda$ grows we expect stronger security.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We write <span class="math">y=A(x;r)</span> when algorithm <span class="math">A</span> on input <span class="math">x</span> and randomness <span class="math">r</span>, outputs <span class="math">y</span>. We write <span class="math">y\\leftarrow A(x)</span> for the process of picking randomness <span class="math">r</span> at random and setting <span class="math">y=A(x;r)</span>. We also write <span class="math">y\\leftarrow S</span> for sampling <span class="math">y</span> uniformly at random from the set <span class="math">S</span>. We will assume it is possible to sample uniformly at random from sets such as <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <p class="text-gray-300">Following Abe and Fehr <em>[x1]</em> we write <span class="math">(y;z)\\leftarrow(\\mathcal{A}\\parallel\\mathcal{X}_{\\mathcal{A}})(x)</span> when <span class="math">\\mathcal{A}</span> on input <span class="math">x</span> outputs <span class="math">y</span>, and <span class="math">\\mathcal{X}_{\\mathcal{A}}</span> on the same input (including random coins) outputs <span class="math">z</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 Bilinear groups</h3>

    <p class="text-gray-300">We will work over bilinear groups <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g,h)</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span> are groups of prime order <span class="math">p</span></li>

      <li>The pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is a bilinear map</li>

      <li><span class="math">g</span> is a generator for <span class="math">\\mathbb{G}_{1}</span>, <span class="math">h</span> is a generator for <span class="math">\\mathbb{G}_{2}</span>, and <span class="math">e(g,h)</span> is a generator for <span class="math">\\mathbb{G}_{T}</span></li>

      <li>There are efficient algorithms for computing group operations, evaluating the bilinear map, deciding membership of the groups, deciding equality of group elements and sampling generators of the groups. We refer to these as the generic group operations.</li>

    </ul>

    <p class="text-gray-300">There are many ways to set up bilinear groups both as symmetric bilinear groups where <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span> and as asymmetric bilinear groups where <span class="math">\\mathbb{G}_{1}\\neq\\mathbb{G}_{2}</span>. Galbraith, Paterson and Smart <em>[x10]</em> classify bilinear groups as Type I where <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span>, Type II where there is an efficiently computable non-trivial homomorphism <span class="math">\\Psi:\\mathbb{G}_{2}\\to\\mathbb{G}_{1}</span>, and Type III where no such efficiently computable homomorphism exists in either direction between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. Type III bilinear groups are the most efficient type of bilinear groups and hence the most relevant for practical applications. We give lower bound for pairing-based SNARGs in Type III bilinear groups. Our constructions on the other hand can be instantiated in all 3 types of bilinear groups.</p>

    <p class="text-gray-300">It will be useful to use a notation that represents group elements by their discrete logarithms. We stress the discrete logarithms are hard to compute, this notation is just convenient for representational purposes. We write <span class="math">[a]_{1}</span> for <span class="math">g^{a}</span>, <span class="math">[b]_{2}</span> for <span class="math">h^{b}</span>, and <span class="math">[c]_{T}</span> for <span class="math">e(g,h)^{c}</span>. With this notation <span class="math">g=[1]_{1}</span>, <span class="math">h=[1]_{2}</span> and <span class="math">e(g,h)=[1]_{T}</span>, while the neutral elements are <span class="math">[0]_{1},[0]_{2}</span> and <span class="math">[0]_{T}</span>. Working with the discrete logarithm representation of group it is natural to use additive notation in all groups, so for instance <span class="math">[a]_{T}+[b]_{T}=[1]_{T}</span></p>

    <p class="text-gray-300"><span class="math">[a+b]_{T}</span>. A vector of group elements will be represented as <span class="math">[\\bm{a}]_{i}</span>. Our notation allows us to define natural operations using standard linear algebra notation, so <span class="math">[\\bm{a}]_{i}+[\\bm{b}]_{i}=[\\bm{a}+\\bm{b}]_{i}</span> assuming <span class="math">\\bm{a}</span> and <span class="math">\\bm{b}</span> have the same dimension, and also assuming appropriate dimension we define <span class="math">A[\\bm{b}]_{i}=[A\\bm{b}]_{i}</span>. Given two vectors of <span class="math">n</span> group elements <span class="math">[\\bm{a}]_{1}</span> and <span class="math">[\\bm{b}]_{2}</span>, we define their dot product as <span class="math">[\\bm{a}]_{1}\\cdot[\\bm{b}]_{2}=[\\bm{a}\\cdot\\bm{b}]_{T}</span>, which can be efficiently computed using the pairing <span class="math">e</span>.</p>

    <p class="text-gray-300">We say an algorithm is generic if it only uses generic group operations to create and manipulate group elements. Shoup <em>[x18]</em> formalized the generic group model by considering random injective encodings <span class="math">[\\cdot]_{i}</span> instead of real group elements. Generic group operations are then handled through an oracle the algorithm has access to, e.g., it can for instance on <span class="math">(\\text{add},[a]_{i},[b]_{i})</span> return <span class="math">[a+b]_{i}</span>. Due to the randomness of the encoding, the generic algorithm can only do meaningful operations through the generic group oracle. One implication of this is that if it has input <span class="math">[\\bm{a}]_{1}</span> and return elements <span class="math">[\\bm{b}]</span>, we can by checking the addition queries it has made in <span class="math">\\mathbb{G}_{1}</span> efficiently deduce a matrix <span class="math">M</span> such that <span class="math">\\bm{b}=M\\bm{a}</span>. The same holds in <span class="math">\\mathbb{G}_{2}</span>, while in <span class="math">\\mathbb{G}_{T}</span> there may also be elements computed from the pairing operation, but we can still write any output element as an explicit quadratic polynomial in the inputs.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Non-interactive zero-knowledge arguments of knowledge</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a relation generator that given a security parameter <span class="math">\\lambda</span> in unary returns a polynomial time decidable binary relation <span class="math">R</span>. For pairs <span class="math">(\\phi,w)\\in R</span> we call <span class="math">\\phi</span> the statement and <span class="math">w</span> the witness. We define <span class="math">\\mathcal{R}_{\\lambda}</span> to be the set of possible relations <span class="math">R</span> the relation generator may output given <span class="math">1^{\\lambda}</span>. We will in the following for notational simplicity assume <span class="math">\\lambda</span> can be deduced from the description of <span class="math">R</span>. The relation generator may also output some side information, an auxiliary input <span class="math">z</span>, which will be given to the adversary. An efficient prover publicly verifiable non-interactive argument for <span class="math">\\mathcal{R}</span> is a quadruple of probabilistic polynomial algorithms (Setup, Prove, Vfy, Sim) such that</p>

    <p class="text-gray-300"><span class="math">(\\sigma,\\tau)\\leftarrow\\texttt{Setup}(R)</span>: The setup produces a common reference string <span class="math">\\sigma</span> and a simulation trapdoor <span class="math">\\tau</span> for the relation <span class="math">R</span>. <span class="math">\\pi\\leftarrow\\texttt{Prove}(R,\\sigma,\\phi,w)</span>: The prover algorithm takes as input a common reference string <span class="math">\\sigma</span> and <span class="math">(\\phi,w)\\in R</span> and returns an argument <span class="math">\\pi</span>. <span class="math">0/1\\leftarrow\\texttt{Vfy}(R,\\sigma,\\phi,\\pi)</span>: The verification algorithm takes as input a common reference string <span class="math">\\sigma</span>, a statement <span class="math">\\phi</span> and an argument <span class="math">\\pi</span> and returns <span class="math">0</span> (reject) or <span class="math">1</span> (accept). <span class="math">\\pi\\leftarrow\\texttt{Sim}(R,\\tau,\\phi)</span>: The simulator takes as input a simulation trapdoor and statement <span class="math">\\phi</span> and returns an argument <span class="math">\\pi</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">We say <span class="math">(\\textsf{Setup},\\textsf{Prove},\\textsf{Vfy})</span> is a non-interactive argument for <span class="math">\\mathcal{R}</span> if it has perfect completeness and computational soundness as defined below.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">We say <span class="math">(\\textsf{Setup},\\textsf{Prove},\\textsf{Vfy},\\textsf{Sim})</span> is a perfect non-interactive zero-knowledge argument of knowledge for <span class="math">\\mathcal{R}</span> if it has perfect completeness, perfect zero-knowledge and computational knowledge soundness as defined below.</p>

    <p class="text-gray-300">Perfect completeness. Completeness says that, given any true statement, an honest prover should be able to convince an honest verifier. For all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>, <span class="math">(\\phi,w)\\in R</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(\\sigma,\\tau)\\leftarrow\\texttt{Setup}(R);\\pi\\leftarrow\\texttt{Prove}(R,\\sigma,\\phi,w):\\textsf{Vfy}(R,\\sigma,\\phi,\\pi)=1\\right]=1.</span></p>

    <p class="text-gray-300">Perfect zero-knowledge. An argument is zero-knowledge if it does not leak any information besides the truth of the statement. We say <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Vfy},\\mathsf{Sim})</span> is perfect zero-knowledge if for all <span class="math">\\lambda\\in\\mathbb{N},(R,z)\\leftarrow\\mathcal{R}(1^{\\lambda}),(\\phi,w)\\in R</span> and all adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(\\sigma,\\tau)\\leftarrow\\mathsf{Setup}(R);\\pi\\leftarrow\\mathsf{Prove}(R,\\sigma,\\phi,w):\\mathcal{A}(R,z,\\sigma,\\tau,\\pi)=1\\right]</span> <span class="math">=\\Pr\\left[(\\sigma,\\tau)\\leftarrow\\mathsf{Setup}(R);\\pi\\leftarrow\\mathsf{Sim}(R,\\tau,\\phi):\\mathcal{A}(R,z,\\sigma,\\tau,\\pi)=1\\right].</span></p>

    <p class="text-gray-300">Computational soundness. We say <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Vfy},\\mathsf{Sim})</span> is sound if it is not possible to prove a false statement, i.e., convince the verifier if no witness exists. Let <span class="math">L_{R}</span> be the language consisting of statements for which there exist matching witnesses in <span class="math">R</span>. Formally, we require that for all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(R,z)\\leftarrow\\mathcal{R}(1^{\\lambda});(\\sigma,\\tau)\\leftarrow\\mathsf{Setup}(R);(\\phi,\\pi)\\leftarrow\\mathcal{A}(R,z,\\sigma):\\\\ \\phi\\notin L_{R}\\text{ and }\\mathsf{Vfy}(R,\\sigma,\\phi,\\pi)=1\\end{matrix}\\right]\\approx 0. \\]</p>

    <p class="text-gray-300">Computational knowledge soundness. Strengthening the notion of soundness, we call <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Vfy},\\mathsf{Sim})</span> an argument of knowledge if there is an extractor that can compute a witness whenever the adversary produces a valid argument. The extractor gets full access to the adversary’s state, including any random coins. Formally, we require that for all non-uniform polynomial time adversaries <span class="math">\\mathcal{A}</span> there exists a non-uniform polynomial time extractor <span class="math">\\mathcal{X}_{\\mathcal{A}}</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(R,z)\\leftarrow\\mathcal{R}(1^{\\lambda});(\\sigma,\\tau)\\leftarrow\\mathsf{Setup}(R);((\\phi,\\pi);w)\\leftarrow(\\mathcal{A}\\parallel\\mathcal{X}_{\\mathcal{A}})(R,z,\\sigma):\\\\ (\\phi,w)\\notin R\\text{ and }\\mathsf{Vfy}(R,\\sigma,\\phi,\\pi)=1\\end{matrix}\\right]\\approx 0. \\]</p>

    <p class="text-gray-300">Public verifiability and designated verifier proofs. We can naturally generalize the definition of a non-interactive argument by splitting <span class="math">\\sigma</span> into two parts <span class="math">\\sigma_{P}</span> and <span class="math">\\sigma_{V}</span> used by the prover and verifier respectively. We say the non-interactive argument is publicly verifiable when <span class="math">\\sigma_{V}</span> can be deduced from <span class="math">\\sigma_{P}</span>. Otherwise we refer to it as a designated verifier argument. For designated verifier arguments it is possible to relax soundness and knowledge soundness such that the adversary only sees <span class="math">\\sigma_{P}</span> but not <span class="math">\\sigma_{V}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SNARGs and SNARKs. A non-interactive argument where the verifier runs in polynomial time in $\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the proof size is polynomial in </span>\\lambda<span class="math"> is called a preprocessing succinct non-interactive argument (SNARG) if it sound, and a preprocessing succinct argument of knowledge (SNARK) if it is knowledge sound. If we also restrict the common reference string to be polynomial in </span>\\lambda$ we say the non-interactive argument is a fully succinct SNARG or SNARK. Bitansky et al. <em>[x1]</em> show that preprocessing SNARKs can be composed to yield fully succinct SNARKs. The focus of this paper is on preprocessing SNARKs, where the common reference string may be long.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Benign relation generators. Bitansky et al. <em>[x2]</em> show that indistinguishability obfuscation implies that for every candidate SNARK there are auxiliary output distributions that enable the adversary to create a valid proof without it being possible to extract the witness. Assuming also public coin differing input obfuscation and other cryptographic assumptions, Boyle and Pass <em>[x4]</em> strengthen this impossibility to show that there is an auxiliary output distribution that defeats witness extraction</p>

    <p class="text-gray-300">for all candidate SNARKs. These counter examples, however, rely on specific auxiliary input distributions. We will therefore in the following assume the relationship generator is benign in the sense that the relation and the auxiliary input are distributed in such a way that the SNARKs we construct can be knowledge sound.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.3 Quadratic arithmetic programs</h3>

    <p class="text-gray-300">Consider an arithmetic circuit consisting of addition and multiplication gates over a finite field <span class="math">\\mathbb{F}</span>. We may designate some of the input/output wires as specifying a statement and use the rest of the wires in the circuit to define a witness. This gives us a binary relation <span class="math">R</span> consisting of statement wires and witness wires that satisfy the arithmetic circuit, i.e., make it consistent with the designated input/output wires.</p>

    <p class="text-gray-300">Generalizing arithmetic circuits, we may be interested in relations described by equations over a set of variables. Some of the variables correspond to the statement; the remaining variables correspond to the witness. The relation consists of statements and witnesses that satisfy all the equations. The equations will be over <span class="math">a_{0}=1</span> and variables <span class="math">a_{1},\\ldots,a_{m}\\in\\mathbb{F}</span> and be of the form</p>

    <p class="text-gray-300"><span class="math">\\sum a_{i}u_{i,q}\\cdot\\sum a_{i}v_{i,q}=\\sum a_{i}w_{i,q},</span></p>

    <p class="text-gray-300">where <span class="math">u_{i,q},v_{i,q},w_{i,q}</span> are constants in <span class="math">\\mathbb{F}</span> specifying the <span class="math">q</span>th equation.</p>

    <p class="text-gray-300">We observe that addition and multiplication gates are special cases of such equations so such systems of arithmetic constraints do indeed generalize arithmetic circuits. A multiplication gate can for instance be described as <span class="math">a_{i}\\cdot a_{j}=a_{k}</span> (using <span class="math">u_{i}=1,v_{j}=1</span> and <span class="math">w_{k}=1</span> and setting the remaining constants for this gate to <span class="math">0</span>). Addition gates are handled for free in the sums defining the equations, i.e., if <span class="math">a_{i}+a_{j}=a_{k}</span> and <span class="math">a_{k}</span> is multiplied by <span class="math">a_{\\ell}</span>, we may simply write <span class="math">(a_{i}+a_{j})\\cdot a_{\\ell}</span> and skip the calculation of <span class="math">a_{k}</span>.</p>

    <p class="text-gray-300">Following Gennaro, Gentry, Parno and Raykova <em>[x1]</em> we can reformulate the set of arithmetic constraints as a quadratic arithmetic program assuming <span class="math">\\mathbb{F}</span> is large enough. Given <span class="math">n</span> equations we pick arbitrary distinct <span class="math">r_{1},\\ldots,r_{n}\\in\\mathbb{F}</span> and define <span class="math">t(x)=\\prod_{q=1}^{n}(x-r_{q})</span>. Furthermore, let <span class="math">u_{i}(x),v_{i}(x),w_{i}(x)</span> be degree <span class="math">n-1</span> polynomials such that</p>

    <p class="text-gray-300"><span class="math">u_{i}(r_{q})=u_{i,q}\\qquad v_{i}(r_{q})=v_{i,q}\\qquad w_{i}(r_{q})=w_{i,q}\\qquad\\text{for}\\quad i=0,\\ldots,m,q=1,\\ldots,n.</span></p>

    <p class="text-gray-300">We now have that <span class="math">a_{0}=1</span> and the variables <span class="math">a_{1},\\ldots,a_{m}\\in\\mathbb{F}</span> satisfy the <span class="math">n</span> equations if and only if in each point <span class="math">r_{1},\\ldots,r_{q}</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m}a_{i}u_{i}(r_{q})\\cdot\\sum_{i=0}^{m}a_{i}v_{i}(r_{q})=\\sum_{i=0}^{m}a_{i}w_{i}(r_{q}).</span></p>

    <p class="text-gray-300">Since <span class="math">t(X)</span> is the lowest degree monomial with <span class="math">t(r_{q})=0</span> in each point, we can reformulate this condition as</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m}a_{i}u_{i}(X)\\cdot\\sum_{i=0}^{m}a_{i}v_{i}(X)\\equiv\\sum_{i=0}^{m}a_{i}w_{i}(X)\\ \\ \\text{mod}\\ t(X).</span></p>

    <p class="text-gray-300">Formally, we will be working with quadratic arithmetic programs <span class="math">R</span> that have the following description</p>

    <p class="text-gray-300"><span class="math">R=(\\mathbb{F},\\text{aux},\\ell,\\{u_{i}(X),v_{i}(X),w_{i}(X)\\}_{i=0}^{m},t(X))\\,,</span></p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}</span> describes a finite field, aux is some auxiliary information, <span class="math">1\\leq\\ell\\leq m</span>, <span class="math">u_{i}(X),v_{i}(X),w_{i}(X),t(X)\\in\\mathbb{F}[X]</span> and <span class="math">u_{i}(X),v_{i}(X),w_{i}(X)</span> have strictly lower degree than <span class="math">n</span>, the degree of <span class="math">t(X)</span>. A quadratic arithmetic program with such a description defines the following binary relation, where we define <span class="math">a_{0}=1</span>,</p>

    <p class="text-gray-300">\\[ R=\\left\\{(\\phi,w)\\begin{array}[]{l}\\phi=(a_{1},\\ldots,a_{\\ell})\\in\\mathbb{F}^{\\ell}\\\\ w=(a_{\\ell+1},\\ldots,a_{m})\\in\\mathbb{F}^{m-\\ell}\\\\ \\sum_{i=0}^{m}a_{i}u_{i}(X)\\cdot\\sum_{i=0}^{m}a_{i}v_{i}(X)\\equiv\\sum_{i=0}^{m}a_{i}w_{i}(X)\\ \\bmod t(X)\\end{array}\\right\\}. \\]</p>

    <p class="text-gray-300">We say <span class="math">\\mathcal{R}</span> is a quadratic arithmetic program generator if it generates relations of the form given above with fields of size larger than <span class="math">2^{\\lambda-1}</span>.</p>

    <p class="text-gray-300">Relations can arise in many different ways in practice. It may be that the relationship generator is deterministic or it may be that it is randomized. It may be that first the field <span class="math">\\mathbb{F}</span> is generated and then the rest of the relation is built on top of the field. Or it may be that the polynomials are specified first and then a random field is chosen. To get maximal flexibility we have chosen our definitions to be agnostic with respect to the exact way the field and the relation is generated, the different options can all be modelled by appropriate choices of relation generators.</p>

    <p class="text-gray-300">Looking ahead, we will in our pairing-based NIZK arguments let the auxiliary information aux specify a bilinear group. It may seem a bit surprising to make the choice of bilinear group part of the relation generator but this provides a better model of settings where the relation is built on top of an already existing bilinear group. Again, there is no loss of generality in this choice, one can think of a traditional setting where the relation is chosen first and then the bilinear group is chosen at random as the special case where the relation generator works in two steps, first choosing the relation and then picking a random bilinear group. Of course letting the relation generator pick the bilinear group is another good reason that we need to assume it is benign; an appropriate choice of bilinear group is essential for security.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.4 Linear non-interactive proofs</h3>

    <p class="text-gray-300">Bitansky et al. <em>[BCI^{+}13]</em> give a useful characterization of the information theoretic underpinning of recent SNARK constructions that they call 2-move algebraic input-oblivious linear interactive proofs. To clarify the connection to non-interactive arguments that we defined in Section 2.2, we will rename this notion as non-interactive linear proofs (NILP). NILPs are defined relative to a relation generator <span class="math">\\mathcal{R}</span>, where we assume the relations specify a finite field <span class="math">\\mathbb{F}</span>, and work as follows.</p>

    <p class="text-gray-300">The setup is a probabilistic polynomial time algorithm that returns vectors <span class="math">\\bm{\\sigma}\\in\\mathbb{F}^{m}</span> and <span class="math">\\bm{\\tau}\\in\\mathbb{F}^{n}</span>. We will for notational simplicity assume that <span class="math">\\bm{\\sigma}</span> always contains 1 as an entry such that there is no distinction between affine and linear functions of <span class="math">\\bm{\\sigma}</span>. The prover operates in two stages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First it runs <span class="math">\\Pi\\ \\leftarrow\\ \\mathsf{ProofMatrix}(R,\\phi,w)</span>, where <span class="math">\\mathsf{ProofMatrix}</span> is a probabilistic polynomial time algorithm that generates a matrix <span class="math">\\Pi\\in\\mathbb{F}^{k\\times m}</span>.</li>

      <li>Then it computes the proof as <span class="math">\\bm{\\pi}=\\Pi\\bm{\\sigma}</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">0/1\\leftarrow\\mathsf{Vfy}(R,\\boldsymbol{\\sigma},\\phi,\\boldsymbol{\\pi})\\colon</span> The verifier runs in two stages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First it runs a deterministic polynomial time algorithm <span class="math">\\boldsymbol{t}\\leftarrow\\mathsf{Test}(R,\\phi)</span> to get an arithmetic circuit <span class="math">\\boldsymbol{t}:\\mathbb{F}^{m+k}\\rightarrow\\mathbb{F}^{\\eta}</span> corresponding to the evaluation of a vector of multi-variate polynomials of total degree <span class="math">d</span>.</li>

      <li>It then accepts the proof if and only if <span class="math">\\boldsymbol{t}(\\boldsymbol{\\sigma},\\boldsymbol{\\pi})=\\boldsymbol{0}</span>.</li>

    </ul>

    <p class="text-gray-300">The degree <span class="math">d</span> and the dimensions <span class="math">\\mu,m,n,k,\\eta</span> may be constants or polynomials in the security parameter <span class="math">\\lambda</span>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 3 (Linear non-interactive proof)</h6>

    <p class="text-gray-300">The tuple <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Vfy})</span> is a linear non-interactive proof for <span class="math">\\mathcal{R}</span> if it has perfect completeness and statistical knowledge soundness against affine prover strategies as defined below.</p>

    <p class="text-gray-300">Statistical knowledge soundness against affine prover strategies. A NILP has knowledge soundness against affine prover strategies if a witness can be extracted from a successful proof matrix <span class="math">\\Pi</span>. More precisely, there is a polynomial time extractor <span class="math">\\mathcal{X}</span> such that for all adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(R,z)\\leftarrow\\mathcal{R}(1^{\\lambda});(\\boldsymbol{\\sigma},\\boldsymbol{\\tau})\\leftarrow\\mathsf{Setup}(R);(\\phi,\\Pi)\\leftarrow\\mathcal{A}(R,z);w\\leftarrow\\mathcal{X}(R,\\phi,\\Pi):\\\\ \\Pi\\in\\mathbb{F}^{m\\times k}\\ \\wedge\\ \\mathsf{Vfy}(R,\\boldsymbol{\\sigma},\\phi,\\Pi\\boldsymbol{\\sigma})=\\boldsymbol{0}\\ \\wedge\\ (\\phi,w)\\notin R\\end{matrix}\\right]\\approx 0. \\]</p>

    <p class="text-gray-300">The notion of zero-knowledge from Section 2.2 also applies to NILPs and corresponds to honest-verifier zero-knowledge for a 2-move LIP. Another potential extension is to designated-verifier NILPs where the common reference string <span class="math">\\boldsymbol{\\sigma}</span> is split into two parts <span class="math">\\boldsymbol{\\sigma}_{P}</span> used by the prover and <span class="math">\\boldsymbol{\\sigma}_{V}</span> used by the verifier.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.5 Non-interactive arguments from linear non-interactive proofs.</h3>

    <p class="text-gray-300">NILPs are useful because they can be compiled into publicly verifiable non-interactive arguments using pairings and designated verifier non-interactive arguments using a variant of Paillier encryption <em>[BCI^{+}13]</em>. If we work in the pairing setting, the intuition is that a NILP with verifier degree <span class="math">d=2</span> can be executed “in the discrete logarithms”. The common reference string contains encodings of field elements in <span class="math">\\boldsymbol{\\sigma}</span>. The prover computes the proof as linear combinations of group elements in the common reference string. The verifier checks the argument by verifying a number of pairing product equations (equations formed by multiplying together the results of pairings), which corresponds to checking quadratic equations in the encoded field elements. We will now formalize this methodology.</p>

    <p class="text-gray-300">When working with Type III pairings, executing the NILP in the discrete logarithms requires that we specify for each element in which group the operations should take place. We will therefore define a split NILP, which is a NILP where the common reference string can be split into two parts <span class="math">\\boldsymbol{\\sigma}=(\\boldsymbol{\\sigma}_{1},\\boldsymbol{\\sigma}_{2})</span> and the prover’s proof can be split into two parts <span class="math">\\boldsymbol{\\pi}=(\\boldsymbol{\\pi}_{1},\\boldsymbol{\\pi}_{2})</span>. Each part of the proof is computed from the corresponding part of the common reference string. Finally, when verifying the proof, we want the verifier’s test to be a quadratic equation where each variable has degree 1. Writing it out, a split NILP is a NILP of the following form:</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300"><span class="math">(\\pmb{\\sigma}, \\pmb{\\tau}) \\gets \\mathsf{Setup}(R)</span>: The setup algorithm generates vectors <span class="math">\\pmb{\\sigma} = (\\pmb{\\sigma}_1, \\pmb{\\sigma}_2) \\in \\mathbb{F}^{m_1} \\times \\mathbb{F}^{m_2}</span> and <span class="math">\\pmb{\\tau} \\in \\mathbb{F}^n</span>. We will for notational simplicity assume <span class="math">\\pmb{\\sigma}_1</span> and <span class="math">\\pmb{\\sigma}_2</span> both contain 1 as an entry such that there is no distinction between affine and linear functions of <span class="math">\\pmb{\\sigma}</span>.</p>

    <p class="text-gray-300"><span class="math">\\pmb{\\pi} \\gets \\operatorname{Prove}(R, \\pmb{\\sigma}, \\phi, w)</span>: The prover operates in two stages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First it runs <span class="math">\\varPi \\gets \\mathsf{ProofMatrix}(R,\\phi,w)</span>, where we require ProofMatrix generates a matrix of the form <span class="math">\\varPi=\\left(\\begin{array}{cc}\\varPi_1 &amp;amp; 0\\\\ 0 &amp;amp; \\varPi_2\\end{array}\\right)</span>, where <span class="math">\\varPi_1 \\in \\mathbb{F}^{k_1 \\times m_1}</span> and <span class="math">\\varPi_2 \\in \\mathbb{F}^{k_2 \\times m_2}</span>.</li>

      <li>Then it computes <span class="math">\\pmb{\\pi}_1 = \\varPi_1\\pmb{\\sigma}_1</span> and <span class="math">\\pmb{\\pi}_2 = \\varPi_2\\pmb{\\sigma}_2</span> and returns <span class="math">\\pmb{\\pi} = (\\pmb{\\pi}_1, \\pmb{\\pi}_2)</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">0/1 \\gets \\mathsf{Vfy}(R, \\pmb{\\sigma}, \\phi, \\pmb{\\pi})</span>: The verifier runs in two stages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First it runs <span class="math">\\pmb{t} \\gets \\operatorname{Test}(R, \\phi)</span> to get an arithmetic circuit <span class="math">\\pmb{t}: \\mathbb{F}^{m_1 + k_1 + m_2 + k_2} \\to \\mathbb{F}^\\eta</span> corresponding to matrices <span class="math">T_1, \\ldots, T_\\eta \\in \\mathbb{F}^{(m_1 + k_1) \\times (m_2 + k_2)}</span>.</li>

      <li>It then accepts the proof if and only if for all matrices <span class="math">T_{1}, \\ldots, T_{\\eta}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c} \\boldsymbol {\\sigma} _ {1} \\\\ \\boldsymbol {\\pi} _ {2} \\end{array} \\right) \\cdot T _ {i} \\left( \\begin{array}{c} \\boldsymbol {\\sigma} _ {2} \\\\ \\boldsymbol {\\pi} _ {2} \\end{array} \\right) = 0.</span></div>

    <p class="text-gray-300">Intuitively, after compiling the split NILP we want to argue soundness by saying a cheating prover that uses generic group operations cannot deviate from the NILP. However, when the prover sees the common reference string, she may learn useful information from it and choose her matrix <span class="math">\\varPi</span> in a way that depends on it. To counter this type of adversary, we will define a disclosure-free common reference string as one where the prover does not gain useful information that can help her choose a special matrix <span class="math">\\varPi</span>.</p>

    <p class="text-gray-300"><strong>Definition 4 (Disclosure-free NILP).</strong> We say a split NILP is disclosure-free if for all adversaries <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (R, z) \\leftarrow \\mathcal {R} (1 ^ {\\lambda}); T \\leftarrow \\mathcal {A} (R, z); (\\pmb {\\sigma} _ {1}, \\pmb {\\sigma} _ {2}, \\pmb {\\tau}), (\\pmb {\\sigma} _ {1} ^ {\\prime}, \\pmb {\\sigma} _ {2} ^ {\\prime}, \\pmb {\\tau} ^ {\\prime}) \\leftarrow \\mathsf {S e t u p} (R): \\\\ \\pmb {\\sigma} _ {1} \\cdot T \\pmb {\\sigma} _ {2} = 0 \\text{ if and only if } \\pmb {\\sigma} _ {1} ^ {\\prime} \\cdot T \\pmb {\\sigma} _ {2} ^ {\\prime} = 0 \\end{array} \\right] \\approx 1.</span></div>

    <p class="text-gray-300">The way to interpret the definition of a disclosure-free common reference string is that the outcome of any test the adversary can run on <span class="math">\\sigma_{1},\\sigma_{2}</span> can be predicted by running it on an independently generated <span class="math">\\sigma_1^{\\prime},\\sigma_2^{\\prime}</span>.</p>

    <p class="text-gray-300">We are now ready to describe a compiler that uses a split NILP (Setup, Prove, Vf, Sim) with disclosure-free common reference strings to give us a pairing-based non-interactive argument <span class="math">(\\mathsf{Setup}&#x27;,\\mathsf{Prove}&#x27;,\\mathsf{Vfy}&#x27;,\\mathsf{Sim}&#x27;)</span>.</p>

    <p class="text-gray-300"><span class="math">(\\sigma, \\tau) \\gets \\mathsf{Setup}&#x27;(R)</span>: Run <span class="math">(\\pmb{\\sigma}_1, \\pmb{\\sigma}_2, \\pmb{\\tau}) \\gets \\mathsf{Setup}(R)</span>. Return <span class="math">\\sigma = ([\\pmb{\\sigma}_1]_1, [\\pmb{\\sigma}_2]_2)</span> and <span class="math">\\tau = \\pmb{\\tau}</span>.</p>

    <p class="text-gray-300"><span class="math">\\pi \\gets \\mathsf{Prove}&#x27;(R,\\sigma ,\\phi ,w)</span>: Generate <span class="math">(\\varPi_1,\\varPi_2)\\gets \\mathsf{ProofMatrix}(R,x,w)</span> and return <span class="math">\\pi = ([\\pmb {\\pi}_1]_1,[\\pmb {\\pi}_2]_2)</span> computed as</p>

    <div class="my-4 text-center"><span class="math-block">[ \\boldsymbol {\\pi} _ {1} ] _ {1} = \\Pi_ {1} [ \\boldsymbol {\\sigma} _ {1} ] _ {1} \\quad [ \\boldsymbol {\\pi} _ {2} ] _ {2} = \\Pi_ {2} [ \\boldsymbol {\\sigma} _ {2} ] _ {2}.</span></div>

    <p class="text-gray-300"><span class="math">0 / 1 \\gets \\mathsf{Vfy}&#x27;(R, \\sigma, \\phi, \\pi)</span>: Generate <span class="math">(T_1, \\ldots, T_\\eta) \\gets \\mathsf{Test}(R, \\phi)</span>. Parse <span class="math">\\pi = ([\\pmb{\\pi}_1]_1, [\\pmb{\\pi}_2)]_2 \\in \\mathbb{G}_1^{k_1} \\times \\mathbb{G}_2^{k_2}</span>. Accept the proof if and only if for all <span class="math">T_1, \\ldots, T_\\eta</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} \\boldsymbol {\\sigma} _ {1} \\\\ \\boldsymbol {\\pi} _ {1} \\end{array} \\right] _ {1} \\cdot T _ {i} \\left[ \\begin{array}{c} \\boldsymbol {\\sigma} _ {2} \\\\ \\boldsymbol {\\pi} _ {2} \\end{array} \\right] _ {2} = [ 0 ] _ {T}.</span></div>

    <p class="text-gray-300"><span class="math">\\pi \\gets \\mathsf{Sim}&#x27;(R,\\tau ,\\phi)</span>: Simulate <span class="math">(\\pmb{\\pi}_1,\\pmb{\\pi}_2) \\gets \\mathsf{Sim}(R,\\pmb{\\tau},\\phi)</span> and return <span class="math">\\pi = ([\\pmb{\\pi}_1]_1, [\\pmb{\\pi}_2]_2)</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">The protocol given above is a non-interactive argument with perfect completeness and statistical knowledge soundness against generic adversaries that only do a polynomial number of generic group operations. It is perfect zero-knowledge if the underlying split NILP is perfect zero-knowledge.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Perfect completeness follows from the perfect completeness of the NILP and the fact it is a split NILP, which allows the adversary to compute the two parts of the proof <span class="math">[\\bm{\\pi}_{1}]_{1},[\\bm{\\pi}_{2}]_{2}</span> using generic group operations in the relevant groups <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">Perfect zero-knowledge follows from the perfect zero-knowledge property of the NILP.</p>

    <p class="text-gray-300">It remains to argue statistical soundness against generic adversaries. A generic adversary can use the generic group operations to multiply elements in <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span>, test membership of the groups, evaluate the pairing, and test whether elements are equal.</p>

    <p class="text-gray-300">We first argue that the disclosure-freeness implies that the adversary has negligible probability of learning non-trivial information about the common reference string. Whenever an adversary tests whether an element computed using generic group operations is <span class="math">0</span>, it can be written out as a pairing product equality test of the form <span class="math">[\\bm{\\sigma}_{1}]_{1}\\cdot T[\\bm{\\sigma}_{2}]_{2}=[0]_{T}</span>, where the matrix <span class="math">T</span> can be deduced from the generic group operation queries the adversary has made. Instead of making these queries, we could instead run a modified adversary that picks an alternative common reference string <span class="math">(\\bm{\\sigma}^{\\prime}_{1},\\bm{\\sigma}^{\\prime}_{2},\\bm{\\tau}^{\\prime})</span> and answers the queries herself by testing whether <span class="math">\\bm{\\sigma}^{\\prime}_{1}\\cdot T\\bm{\\sigma}^{\\prime}_{2}=0</span>. By the disclosure-freeness, the answers made this way are with overwhelming probability identical to what the adversary would see on the real common reference string, so we can from now on assume the generic adversary does not make any zero tests on elements involving the common reference string.</p>

    <p class="text-gray-300">An adversary that does not make any zero-tests on the common reference string and only uses generic group operations, is equivalent to an adversary that picks matrices <span class="math">\\Pi_{1},\\Pi_{2}</span> independently of <span class="math">[\\bm{\\sigma}_{1}]_{1},[\\bm{\\sigma}_{2}]_{2}</span> and then computes the proofs as <span class="math">[\\pi_{1}]_{1}=\\Pi_{1}[\\bm{\\sigma}_{1}]</span> and <span class="math">[\\pi_{2}]_{2}=\\Pi_{2}[\\bm{\\sigma}_{2}]_{2}</span>. Taking discrete logarithms, this corresponds exactly to running a split NILP knowledge soundness adversary to get matrices <span class="math">\\Pi_{1},\\Pi_{2}</span> and proofs <span class="math">\\bm{\\pi}_{1}=\\Pi_{1}\\bm{\\sigma}_{1},\\bm{\\pi}_{2}=\\Pi_{1}\\bm{\\sigma}_{2}</span>.</p>

    <p class="text-gray-300">Taking discrete logarithms of the verification equations, we see that if the adversary is successful in finding <span class="math">\\phi</span> and a valid proof <span class="math">\\bm{\\pi}_{1},\\bm{\\pi}_{2}</span>, this corresponds to finding <span class="math">\\phi</span> and <span class="math">\\Pi_{1},\\Pi_{2}</span> such that for the test matrices <span class="math">T_{1},\\ldots,T_{\\eta}\\leftarrow\\mathsf{Test}(R,\\phi)</span></p>

    <p class="text-gray-300">\\[ \\left(\\begin{matrix}\\bm{\\sigma}_{1}\\\\ \\Pi_{1}\\bm{\\sigma}_{1}\\end{matrix}\\right)\\cdot T_{i}\\left(\\begin{matrix}\\bm{\\sigma}_{2}\\\\ \\Pi_{2}\\bm{\\sigma}_{2}\\end{matrix}\\right)=0. \\]</p>

    <p class="text-gray-300">By the statistical soundness of the split NILP this has negligible probability of happening unless knowledge of <span class="math">\\Pi_{1},\\Pi_{2}</span> enables the extraction of a witness <span class="math">w</span> such that <span class="math">(\\phi,w)\\in R</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">The proof for Lemma 1 also holds if we use a split NILP that only has soundness against split affine adversaries that are restricted to outputting a matrix <span class="math">\\Pi=\\left(\\begin{matrix}\\Pi_{1}&amp;0\\\\ 0&amp;\\Pi_{2}\\end{matrix}\\right)</span>. However, the split NILP we construct later will actually be secure against any choice of</p>

    <p class="text-gray-300"><span class="math">\\Pi</span>. The advantage of this is a hedge against cryptanalysis, even if the adversary finds an efficiently computable isomorphism between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> and even if it maps <span class="math">g</span> to <span class="math">h</span>, we will still have security in the generic group model. Another advantage is that the construction also works for symmetric bilinear groups with very minor changes.</p>

    <h2 id="sec-15" class="text-2xl font-bold">3 Constructions of non-interactive arguments</h2>

    <p class="text-gray-300">We will construct a pairing-based NIZK argument for quadratic arithmetic programs where proofs consist of only 3 group elements. We give the construction in two steps, first we construct a NILP for quadratic arithmetic programs, and then we observe it is also a split NILP and convert it to pairing-based NIZK argument using the compilation technique we presented earlier.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.1 Non-interactive linear proofs for quadratic arithmetic programs</h3>

    <p class="text-gray-300">We will now construct a NILP for quadratic arithmetic program generators that outputs relations of the form</p>

    <p class="text-gray-300"><span class="math">R=(\\mathbb{F},\\text{aux},\\ell,\\{u_{i}(X),v_{i}(X),w_{i}(X)\\}_{i=0}^{m},t(X))\\,.</span></p>

    <p class="text-gray-300">The relation defines a language of statements <span class="math">(a_{1},\\ldots,a_{\\ell})\\in\\mathbb{F}^{\\ell}</span> and witnesses <span class="math">(a_{\\ell+1},\\ldots,a_{m})\\in\\mathbb{F}^{m-\\ell}</span> such that with <span class="math">a_{0}=1</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m}a_{i}u_{i}(X)\\cdot\\sum_{i=0}^{m}a_{i}v_{i}(X)=\\sum_{i=0}^{m}a_{i}w_{i}(X)+h(X)t(X),</span></p>

    <p class="text-gray-300">for some degree <span class="math">n-2</span> quotient polynomial <span class="math">h(X)</span>, where <span class="math">n</span> is the degree of <span class="math">t(X)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bm{\\sigma},\\bm{\\tau})\\leftarrow\\mathsf{Setup}(R)</span>: Pick <span class="math">\\alpha,\\beta,\\gamma,\\delta,x\\leftarrow\\mathbb{F}^{*}</span>. Set <span class="math">\\bm{\\tau}=(\\alpha,\\beta,\\gamma,\\delta,x)</span> and</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bm{\\sigma}=\\bigg{(}\\alpha,\\beta,\\gamma,\\delta,\\big{\\{}x^{i}\\}_{i=0}^{n-1},\\Big{\\{}\\tfrac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\gamma}\\Big{\\}}_{i=0}^{\\ell},\\Big{\\{}\\tfrac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\delta}\\Big{\\}}_{i=\\ell+1}^{m},\\Big{\\{}\\tfrac{x^{i}t(x)}{\\delta}\\Big{\\}}_{i=0}^{n-2}\\bigg{)}\\,.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bm{\\pi}\\leftarrow\\mathsf{Prove}(R,\\bm{\\sigma},a_{1},\\ldots,a_{m})</span>: Pick <span class="math">r,s\\leftarrow\\mathbb{F}</span> and compute a <span class="math">3\\times(m+2n+4)</span> matrix <span class="math">\\Pi</span> such that <span class="math">\\bm{\\pi}=\\Pi\\bm{\\sigma}=(A,B,C)</span> where</li>

    </ul>

    <p class="text-gray-300"><span class="math">A=\\alpha+\\sum_{i=0}^{m}a_{i}u_{i}(x)+r\\delta\\qquad\\qquad B=\\beta+\\sum_{i=0}^{m}a_{i}v_{i}(x)+s\\delta</span> <span class="math">C=\\frac{\\sum_{i=\\ell+1}^{m}a_{i}\\left(\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)\\right)+h(x)t(x)}{\\delta}+As+rB-rs\\delta.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">0/1\\leftarrow\\mathsf{Vfy}(R,\\bm{\\sigma},a_{1},\\ldots,a_{\\ell})</span>: Compute a quadratic multi-variate polynomial <span class="math">\\bm{t}</span> such that <span class="math">\\bm{t}(\\bm{\\sigma},\\bm{\\pi})=0</span> corresponds to the test</li>

    </ul>

    <p class="text-gray-300"><span class="math">A\\cdot B=\\alpha\\cdot\\beta+\\frac{\\sum_{i=0}^{\\ell}a_{i}\\left(\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)\\right)}{\\gamma}\\cdot\\gamma+C\\cdot\\delta.</span></p>

    <p class="text-gray-300">Accept the proof if the test passes.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{\\pi}\\leftarrow\\mathsf{Sim}(R,\\mathbf{\\tau},a_{1},\\ldots,a_{\\ell})</span>: Pick <span class="math">A,B\\leftarrow\\mathbb{F}</span> and compute <span class="math">C=\\frac{AB-\\alpha\\beta-\\sum_{i=0}^{\\ell}a_{i}(\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x))}{\\delta}</span>.</p>

    <p class="text-gray-300">Return <span class="math">\\mathbf{\\pi}=(A,B,C)</span>.</p>

    <p class="text-gray-300">Before formally proving this is a NILP, let us give a little intuition behind the different components. The role of <span class="math">\\alpha</span> and <span class="math">\\beta</span> is to ensure <span class="math">A,B</span> and <span class="math">C</span> are consistent with each other in the choice of <span class="math">a_{0},\\ldots,a_{m}</span>. The product <span class="math">\\alpha\\cdot\\beta</span> in the verification equation guarantees that <span class="math">A</span> and <span class="math">B</span> involve non-trivial <span class="math">\\alpha</span> and <span class="math">\\beta</span> components. This means the product <span class="math">A\\cdot B</span> involves a linear dependence on <span class="math">\\alpha</span> and <span class="math">\\beta</span>, and we will later prove that this linear dependence can only be balanced out by <span class="math">C</span> with a consistent choice of <span class="math">a_{0},\\ldots,a_{m}</span> in all three of <span class="math">A,B</span> and <span class="math">C</span>. The role of <span class="math">\\gamma</span> and <span class="math">\\delta</span> is to make the two latter products of the verification equation independent from the first product, by dividing the left factors with <span class="math">\\gamma</span> and <span class="math">\\delta</span> respectively. This prevents mixing and matching of elements intended for different products in the verification equation. Finally, we use <span class="math">r</span> and <span class="math">s</span> to randomize the proof to get zero-knowledge.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">The construction above yields a NILP with perfect completeness, perfect zero-knowledge and statistical knowledge soundness against affine prover strategies.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Perfect completeness is straightforward to verify. Perfect zero-knowledge follows from both real proofs and simulated proofs having uniformly random field elements <span class="math">A,B</span>. These elements uniquely determine <span class="math">C</span> through the verification equation, so real proofs and simulated proofs have identical probability distributions.</p>

    <p class="text-gray-300">What remains is to demonstrate that for any affine prover strategy with non-negligible success probability we can extract a witness. When using an affine prover strategy we have</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=A_{\\alpha}\\alpha+A_{\\beta}\\beta+A_{\\gamma}\\gamma+A_{\\delta}\\delta+A(x)+\\sum_{i=0}^{\\ell}A_{i}\\frac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\gamma}</span> <span class="math">\\quad+\\sum_{i=\\ell+1}^{m}A_{i}\\frac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\delta}+A_{h}(x)\\frac{t(x)}{\\delta},</span></p>

    <p class="text-gray-300">for known field elements <span class="math">A_{\\alpha},A_{\\beta},A_{\\gamma},A_{\\delta},A_{i}</span> and polynomials <span class="math">A(x),A_{h}(x)</span> of degrees <span class="math">n-1</span> and <span class="math">n-2</span>, respectively that correspond to the first row of the matrix <span class="math">\\Pi</span>. We can write out <span class="math">B</span> and <span class="math">C</span> in a similar fashion from the second and third rows of <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">We now view the verification equation as an equality of multi-variate Laurent polynomials. By the Schwartz-Zippel lemma the prover has negligible success probability unless the verification equation holds when viewing <span class="math">A,B</span> and <span class="math">C</span> as formal polynomials in indeterminates <span class="math">\\alpha,\\beta,\\gamma,\\delta,x</span>.</p>

    <p class="text-gray-300">The terms with indeterminate <span class="math">\\alpha^{2}</span> are <span class="math">A_{\\alpha}B_{\\alpha}\\alpha^{2}=0</span>, which means <span class="math">A_{\\alpha}=0</span> or <span class="math">B_{\\alpha}=0</span>. Since <span class="math">AB=BA</span> we can without loss of generality assume <span class="math">B_{\\alpha}=0</span>. The terms with indeterminate <span class="math">\\alpha\\beta</span> give us <span class="math">A_{\\alpha}B_{\\beta}+A_{\\beta}B_{\\alpha}=A_{\\alpha}B_{\\beta}=1</span>. This means <span class="math">AB=(AB_{\\beta})(A_{\\alpha}B)</span> so we can without loss of generality after rescaling assume <span class="math">A_{\\alpha}=B_{\\beta}=1</span>. The terms with indeterminate <span class="math">\\beta^{2}</span> now give us <span class="math">A_{\\beta}B_{\\beta}=A_{\\beta}=0</span>. We have now simplified <span class="math">A</span> and <span class="math">B</span> constructed by the adversary to be of the form</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=\\alpha+A_{\\gamma}\\gamma+A_{\\delta}\\delta+A(x)+\\cdots</span> <span class="math">B</span> <span class="math">=\\beta+B_{\\gamma}\\gamma+B_{\\delta}\\delta+B(x)+\\cdots.</span></p>

    <p class="text-gray-300">Next, let us consider the terms involving <span class="math">\\frac{1}{\\delta^2}</span>. We have</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{i = \\ell + 1}^{m} A_i \\left(\\beta u_i(x) + \\alpha v_i(x) + w_i(x)\\right) + A_h(x) t(x)\\right) $$ $$ \\cdot \\left(\\sum_{i = \\ell + 1}^{m} B_i \\left(\\beta u_i(x) + \\alpha v_i(x) + w_i(x)\\right) + B_h(x) t(x)\\right) = 0,</span></div>

    <p class="text-gray-300">showing either the left factor is 0 or the right factor is 0. By symmetry, let us without loss of generality assume <span class="math">\\sum_{i = \\ell +1}^{m}A_{i}\\left(\\beta u_{i}(x) + \\alpha v_{i}(x) + w_{i}(x)\\right) + t(x)A_{t}(x) = 0</span>. The terms in <span class="math">\\alpha \\frac{\\sum_{i = \\ell + 1}^{m}B_{i}(\\beta u_{i}(x) + \\alpha v_{i}(x) + w_{i}(x)) + B_{h}(x)t(x)}{\\delta} = 0</span> now show us that also <span class="math">\\sum_{i = \\ell +1}^{m}B_{i}\\left(\\beta u_{i}(x) + \\alpha v_{i}(x) + w_{i}(x)\\right) + B_{h}(x)t(x) = 0</span>.</p>

    <p class="text-gray-300">The terms involving <span class="math">\\frac{1}{\\gamma^2}</span> give us</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i = 0}^{\\ell} A_i \\left(\\beta u_i(x) + \\alpha v_i(x) + w_i(x)\\right) \\cdot \\sum_{i = 0}^{\\ell} B_i \\left(\\beta u_i(x) + \\alpha v_i(x) + w_i(x)\\right) = 0,</span></div>

    <p class="text-gray-300">showing either the left factor is 0 or the right factor is 0. By symmetry, let us without loss of generality assume <span class="math">\\sum_{i = 0}^{\\ell}A_{i}\\left(\\beta u_{i}(x) + \\alpha v_{i}(x) + w_{i}(x)\\right) = 0</span>. The terms in <span class="math">\\alpha \\frac{\\sum_{i = 0}^{m}B_{i}(\\beta u_{i}(x) + \\alpha v_{i}(x) + w_{i}(x))}{\\gamma} = 0</span> now show us <span class="math">\\sum_{i = 0}^{\\ell}B_{i}\\left(\\beta u_{i}(x) + \\alpha v_{i}(x) + w_{i}(x)\\right) = 0</span> as well.</p>

    <p class="text-gray-300">The terms <span class="math">A_{\\gamma}\\beta \\gamma = 0</span> and <span class="math">B_{\\gamma}\\alpha \\gamma = 0</span> show us that <span class="math">A_{\\gamma} = 0</span> and <span class="math">B_{\\gamma} = 0</span>. We now have</p>

    <div class="my-4 text-center"><span class="math-block">A = \\alpha + A(x) + A_{\\delta} \\delta \\quad B = \\beta + B(x) + B_{\\delta} \\delta.</span></div>

    <p class="text-gray-300">The remaining terms in the verification equation that involve <span class="math">\\alpha</span> give us <span class="math">\\alpha B(x) = \\sum_{i=0}^{\\ell} a_i \\alpha v_i(x) + \\sum_{i=\\ell+1}^{m} C_i \\alpha v_i(x)</span>. The terms involving <span class="math">\\beta</span> give us <span class="math">\\beta A(x) = \\sum_{i=0}^{\\ell} a_i \\beta u_i(x) + \\sum_{i=\\ell+1}^{m} C_i \\beta u_i(x)</span>. Defining <span class="math">a_i = C_i</span> for <span class="math">i = \\ell+1, \\ldots, m</span> we now have</p>

    <div class="my-4 text-center"><span class="math-block">A(x) = \\sum_{i = 0}^{m} a_i u_i(x) \\quad B(x) = \\sum_{i = 0}^{m} a_i v_i(x).</span></div>

    <p class="text-gray-300">Finally, we look at the terms involving powers of <span class="math">x</span> to get</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i = 0}^{m} a_i u_i(x) \\cdot \\sum_{i = 0}^{m} a_i v_i(x) = \\sum_{i = 0}^{m} a_i w_i(x) + C_h(x) t(x).</span></div>

    <p class="text-gray-300">This shows that <span class="math">(a_{\\ell + 1}, \\ldots, a_m) = (C_{\\ell + 1}, \\ldots, C_m)</span> is a witness for the statement <span class="math">(a_1, \\ldots, a_\\ell)</span>.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">2 FIELD ELEMENT NILPs. It is natural to ask whether the number of field elements the prover sends in the NILP can be reduced further. The square span programs of Danezis et al. [DFGK14] give rise to 2 field element NILPs for boolean circuit satisfiability. It is also possible to get a 2-element NILP for arithmetic circuit satisfiability by rewriting the circuit into one that only uses squaring gates, since each multiplication gate <span class="math">a \\cdot b = c</span> can be rewritten as a <span class="math">(a + b)^2 - (a - b)^2 = 4c</span>. When an arithmetic circuit only has squaring</p>

    <p class="text-gray-300">gates we get <span class="math">u_{i}(x)=v_{i}(x)</span> for all <span class="math">i</span>. By choosing <span class="math">r=s</span> in the NILP, we now have that <span class="math">B=A+\\beta-\\alpha</span>, so the prover only needs to send two elements <span class="math">A</span> and <span class="math">C</span> to make a convincing proof. Rewriting the arithmetic circuit to only use squaring gates may double the number of gates and also requires some additional wires for the subtraction of the squares, so the reduction of the size of the NILP comes at a significant computational cost though.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.2 NIZK arguments for quadratic arithmetic programs</h3>

    <p class="text-gray-300">We will now give a pairing-based NIZK argument for quadratic arithmetic programs. We consider relation generators <span class="math">\\mathcal{R}</span> that return relations of the form</p>

    <p class="text-gray-300"><span class="math">R=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g,h,\\ell,\\{u_{i}(X),v_{i}(X),w_{i}(X)\\}_{i=0}^{m},t(X))\\,,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lambda<span class="math">. The relation defines a field </span>\\mathbb{Z}_{p}<span class="math"> and a language of statements </span>(a_{1},\\ldots,a_{\\ell})\\in\\mathbb{Z}_{p}^{\\ell}<span class="math"> and witnesses </span>(a_{\\ell+1},\\ldots,a_{m})\\in\\mathbb{Z}_{p}^{m-\\ell}<span class="math"> such that with </span>a_{0}=1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m}a_{i}u_{i}(X)\\cdot\\sum_{i=0}^{m}a_{i}v_{i}(X)=\\sum_{i=0}^{m}a_{i}w_{i}(X)+h(X)t(X),</span></p>

    <p class="text-gray-300">for some degree <span class="math">n-2</span> quotient polynomial <span class="math">h(X)</span>.</p>

    <p class="text-gray-300">An important design feature of the NILP we gave above is that it is easily to make it a split NILP. The proof elements <span class="math">A,B</span> and <span class="math">C</span> are only used once in the verification equation and therefore it is easy to assign them to different sides of the bilinear test. By splitting the common reference string in two parts that enable the computation of each side of the proof we then get a split NILP. The resulting split NILP is also disclosure-free and can therefore be compiled into a NIZK argument in the generic group model as we did in Section 2.5. Since pairing-friendly elliptic curves usually have that the group element representations are smaller in <span class="math">\\mathbb{G}_{1}</span> than in <span class="math">\\mathbb{G}_{2}</span> <em>[x10]</em> we choose to assign <span class="math">A</span> and <span class="math">C</span> to the first source group and <span class="math">B</span> to the second source group for maximal efficiency. This gives us the following NIZK argument.</p>

    <p class="text-gray-300"><span class="math">(\\sigma,\\tau)\\leftarrow\\mathsf{Setup}(R)</span>: Pick <span class="math">\\alpha,\\beta,\\gamma,\\delta,x\\leftarrow\\mathbb{Z}_{p}^{*}</span>. Define <span class="math">\\tau=(\\alpha,\\beta,\\gamma,\\delta,x)</span> and compute <span class="math">\\sigma=([\\boldsymbol{\\sigma}_{1}]_{1},[\\boldsymbol{\\sigma}_{2}]_{2})</span>, where</p>

    <p class="text-gray-300">\\[ \\boldsymbol{\\sigma}_{1}=\\begin{pmatrix}\\alpha,\\beta,\\delta,\\{x^{i}\\}_{i=0}^{n-1},\\left\\{\\frac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\gamma}\\right\\}_{i=0}^{\\ell}\\\\ \\left\\{\\frac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\delta}\\right\\}_{i=\\ell+1}^{m},\\left\\{\\frac{x^{i}t(x)}{\\delta}\\right\\}_{i=0}^{n-2}\\end{pmatrix}\\qquad\\boldsymbol{\\sigma}_{2}=\\left(\\,\\beta,\\gamma,\\delta,\\{x^{i}\\}_{i=0}^{n-1}\\,\\right). \\]</p>

    <p class="text-gray-300"><span class="math">\\pi\\leftarrow\\mathsf{Prove}(R,\\sigma,a_{1},\\ldots,a_{m})</span>: Pick <span class="math">r,s\\leftarrow\\mathbb{Z}_{p}</span> and compute <span class="math">\\pi=([A]_{1},[C]_{1},[B]_{2})</span>, where</p>

    <p class="text-gray-300"><span class="math">A=\\alpha+\\sum_{i=0}^{m}a_{i}u_{i}(x)+r\\delta\\qquad\\qquad B=\\beta+\\sum_{i=0}^{m}a_{i}v_{i}(x)+s\\delta</span> <span class="math">C=\\frac{\\sum_{i=\\ell+1}^{m}a_{i}(\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x))+h(x)t(x)}{\\delta}+As+Br-rs\\delta.</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{0}/1\\leftarrow\\mathsf{Vfy}(R,\\sigma,a_{1},\\ldots,a_{\\ell},\\pi)</span>: Parse <span class="math">\\pi=([A]_{1},[C]_{1},[B]_{2})\\in\\mathbb{G}_{1}^{2}\\times\\mathbb{G}_{2}</span>. Accept the proof if and only if</p>

    <p class="text-gray-300"><span class="math">[A]_{1}\\cdot[B]_{2}=[\\alpha]_{1}\\cdot[\\beta]_{2}+\\sum_{i=0}^{\\ell}a_{i}\\left[\\frac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\gamma}\\right]_{1}\\cdot[\\gamma]_{2}+[C]_{1}\\cdot[\\delta]_{2}.</span></p>

    <p class="text-gray-300"><span class="math">\\pi\\leftarrow\\mathsf{Sim}(R,\\tau,a_{1},\\ldots,a_{\\ell})</span>: Pick <span class="math">A,B\\leftarrow\\mathbb{Z}_{p}</span> and compute a simulated proof <span class="math">\\pi=([A]_{1},[C]_{1},[B]_{2})</span> with</p>

    <p class="text-gray-300"><span class="math">C=\\frac{AB-\\alpha\\beta-\\sum_{i=0}^{\\ell}a_{i}\\left(\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)\\right)}{\\delta}.</span></p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">The protocol given above is a non-interactive zero-knowledge argument with perfect completeness and perfect zero-knowledge. It has statistical knowledge soundness against adversaries that only use a polynomial number of generic bilinear group operations.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It is easy to see that the non-interactive argument encodes a split NILP. The only thing that remains in order to apply Lemma 1 is to prove that the common reference string is disclosure-free. We observe that the common reference strings <span class="math">\\boldsymbol{\\sigma}_{1}</span> and <span class="math">\\boldsymbol{\\sigma}_{2}</span> contain multi-variate Laurent polynomials evaluated in elements in <span class="math">\\mathbb{Z}_{p}^{*}</span>. A test of the form <span class="math">\\boldsymbol{\\sigma}_{1}\\cdot T\\boldsymbol{\\sigma}_{2}</span> can evaluate to <span class="math">0</span> because the corresponding formal multi-variate Laurent polynomial is zero, or because it is a non-zero Laurent polynomial that happens to evaluate to <span class="math">0</span> in the concrete choice of input variables. It follows from a straightforward extension of the Schwartz-Zippel lemma that the latter case only occurs with negligible probability since the negative and poitive total degrees are polynomially bounded in <span class="math">\\lambda</span>. The remaining possibility is that the test corresponds to the zero polynomial formally speaking, but in that case any other common reference string <span class="math">\\boldsymbol{\\sigma}^{\\prime}_{1},\\boldsymbol{\\sigma}^{\\prime}_{2}</span> would also have <span class="math">\\boldsymbol{\\sigma}^{\\prime}_{1}\\cdot T\\boldsymbol{\\sigma}^{\\prime}_{2}=0</span>. ∎</p>

    <p class="text-gray-300">Symmetric bilinear groups. The non-interactive argument system also works in symmetric bilinear groups where <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span> and <span class="math">g=h</span>. In this case, the common reference string contains the union of the elements in <span class="math">[\\boldsymbol{\\sigma}_{1}]_{1}</span> and <span class="math">[\\boldsymbol{\\sigma}_{2}]_{2}</span> and the proof and verification equation is computed the same way as described above.</p>

    <p class="text-gray-300">Efficiency. The proof size is <span class="math">2</span> elements in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">1</span> element in <span class="math">\\mathbb{G}_{2}</span>. The common reference string contains a description of the relation <span class="math">R</span>, <span class="math">n</span> elements in <span class="math">\\mathbb{Z}_{p}</span>, <span class="math">m+2n+3</span> elements in <span class="math">\\mathbb{G}_{1}</span>, and <span class="math">n+3</span> elements in <span class="math">\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">The verifier does not need to know the entire common reference string, it suffices to know</p>

    <p class="text-gray-300"><span class="math">\\sigma_{V}=\\left(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,[1]_{1},\\left\\{\\left[\\frac{\\beta u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{\\gamma}\\right]_{1}\\right\\}_{i=0}^{\\ell},[1]_{2},[\\gamma]_{2},[\\delta]_{2},[\\alpha\\beta]_{T}\\right).</span></p>

    <p class="text-gray-300">The verifier’s reference string only contains <span class="math">\\ell+2</span> elements in <span class="math">\\mathbb{G}_{1}</span>, <span class="math">3</span> elements in <span class="math">\\mathbb{G}_{2}</span>, and <span class="math">1</span> element in <span class="math">\\mathbb{G}_{T}</span>.</p>

    <p class="text-gray-300">The verification consists of checking that the proof consists of three appropriate group elements and checking a single pairing product equation. The verifier computes <span class="math">\\ell</span></p>

    <p class="text-gray-300">exponentiations in <span class="math">\\mathbb{G}_1</span>, a small number of group multiplications, and 3 pairings (assuming <span class="math">[\\alpha \\beta]_T = [\\alpha]_1 \\cdot [\\beta]_2</span> is precomputed in the verifier's reference string).</p>

    <p class="text-gray-300">The prover has to compute the polynomial <span class="math">h(X)</span>. The prover can compute the polynomial evaluations</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{m} a_i u_i(r_q) = \\sum_{i=0}^{m} a_i u_{i,q} \\qquad \\sum_{i=0}^{m} a_i v_i(r_q) = \\sum_{i=0}^{m} a_i v_{i,q} \\qquad \\sum_{i=0}^{m} a_i w_i(r_q) = \\sum_{i=0}^{m} a_i w_{i,q}</span></div>

    <p class="text-gray-300">for <span class="math">q = 1, \\ldots, n</span>. It depends on the relation how long time this computation takes; if it arises from an arithmetic circuit where each multiplication gate connects to a constant number of wires, the relation will be sparse and the computation will be linear in <span class="math">n</span>. Since the polynomials have degree <span class="math">n - 1</span> they are completely determined by these evaluation points. If <span class="math">r_1, \\ldots, r_n</span> are roots of unity for a suitable prime <span class="math">p</span> she can compute <span class="math">h(X)</span> using standard Fast Fourier Transform techniques in <span class="math">O(n \\log n)</span> operations in <span class="math">\\mathbb{Z}_p</span>. The prover can also compute the coefficients of <span class="math">\\sum_{i=0}^{m} a_i u_i(X)</span> and <span class="math">\\sum_{i=0}^{m} a_i v_i(X)</span> using FFT techniques. Having all the coefficients, the prover does <span class="math">m + 3n - \\ell + 3</span> exponentiations in <span class="math">\\mathbb{G}_1</span> and <span class="math">n + 1</span> exponentiations in <span class="math">\\mathbb{G}_2</span>.</p>

    <p class="text-gray-300">Asymptotically the exponentiations are the dominant cost as the security parameter grows. However, in practice the multiplications that go into the FFT computations may be more costly for moderate security parameters and large statements. In that case, it may be worth to use a larger common reference string that contains precomputed <span class="math">[u_i(x)]_1, [v_i(x)]_1, [v_i(x)]_2</span> elements for <span class="math">i = 0, \\ldots, m</span> such that <span class="math">A</span> and <span class="math">B</span> can be constructed directly instead of the prover having to compute the coefficients of <span class="math">\\sum_{i=0}^{m} a_i u_i(X)</span> and <span class="math">\\sum_{i=0}^{m} a_i v_i(X)</span> and then do the exponentiations. In the case of boolean circuits we have <span class="math">a_i \\in \\{0,1\\}</span> and the prover can with such precomputed elements just do <span class="math">m</span> group multiplications for each when computing <span class="math">A</span> and <span class="math">B</span>. We have for this reason let the CRS be longer in Table 1 to get a low computational cost for the prover.²</p>

    <h2 id="sec-22" class="text-2xl font-bold">4 Lower bounds for non-interactive arguments</h2>

    <p class="text-gray-300">It is an intriguing question how efficient non-interactive arguments can be. We will now give a lower bound showing that pairing-based non-interactive arguments must have at least 2 group elements in the proofs. More precisely, we look at pairing-based arguments where the common reference string contains a description of a bilinear group and a number of group elements, the proof consists of a number of group elements computed by the prover using generic group operations, and the verifier checks the proof using generic bilinear group operations. We will show that for such pairing-based argument systems, the proof needs to have elements from both <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> if the language includes hard decisional problems as defined below.</p>

    <p class="text-gray-300">Consider sampleable problems for a relation <span class="math">R</span>, where there are two sampling algorithms Yes and No. Yes samples statements and witnesses in the relation. No samples</p>

    <p class="text-gray-300">² Since the modified common reference string that gives faster prover computation can be computed from the original common reference string, the security proof still applies and we get knowledge soundness against generic adversaries. We note that if the non-interactive argument has knowledge soundness in the standard model then the modified common reference string also gives knowledge soundness in the standard model assuming we still give the original common reference string to the extractor.</p>

    <p class="text-gray-300">t statements outside the language <span class="math">L_{R}</span> defined by the relation. We are interested in relations where it is hard to tell whether a statement <span class="math">\\phi</span> has been sampled by <span class="math">\\mathsf{Yes}</span> or <span class="math">\\mathsf{No}</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 5</h6>

    <p class="text-gray-300">We say the relation generator <span class="math">\\mathcal{R}</span> has hard decisional problems if there are two polynomial time algorithms <span class="math">\\mathsf{Yes}</span> and <span class="math">\\mathsf{No}</span> such that for <span class="math">(R,z)\\leftarrow\\mathcal{R}(1^{\\lambda})</span> we have <span class="math">\\mathsf{Yes}(R)\\to(\\phi,w)\\in R</span> and <span class="math">\\mathsf{No}(R)\\to\\phi\\notin L_{R}</span> with overwhelming probability, and for all non-uniform polynomial time distinguishers <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(R,z)\\leftarrow\\mathcal{R}(1^{\\lambda});\\phi_{0}\\leftarrow\\mathsf{No}(R);(\\phi_{1},w_{1})\\leftarrow\\mathsf{Yes}(R);b\\leftarrow\\{0,1\\}:\\mathcal{A}(R,z,\\phi_{b})=b\\right]\\approx\\frac{1}{2}.</span></p>

    <p class="text-gray-300">If one-way functions exist, we can construct pseudorandom generators. A pseudorandom generator can be used to generate a pseudorandom string, a <span class="math">\\mathsf{Yes}</span>-instance, with the seed being the witness. To get a <span class="math">\\mathsf{No}</span>-instance we sample a uniform random string, which with overwhelming probability is not pseudorandom. If the relation <span class="math">R</span> is NP-complete, or just expressive enough to capture pseudorandom generators, then it has a hard decisional problem. In particular, when we are working with pairing-based arguments we must assume at the very least that the discrete logarithm problem is hard and then relation generators with hard decisional problems exist.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">4.1 Linear interactive proofs cannot have linear decision procedures</h3>

    <p class="text-gray-300">We will now prove that NILPs cannot have a degree 1 verifier. This answers an open question raised by Bitansky et al. <em>[BCI^{+}13]</em>. The result holds even if we consider designated verifier NILPs that get input <span class="math">\\boldsymbol{\\sigma}_{V}</span> not available to the prover, and instead of knowledge soundness we only consider the weaker notion of soundness that we now define.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 6 (Statistical soundness against affine prover strategies)</h6>

    <p class="text-gray-300">We say a LIP is sound against affine prover strategies if for all adversaries <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(R,z)\\leftarrow\\mathcal{R}(1^{\\lambda});(\\boldsymbol{\\sigma}_{P},\\boldsymbol{\\sigma}_{V},\\boldsymbol{\\tau})\\leftarrow\\mathsf{Setup}(R);(\\phi,\\Pi)\\leftarrow\\mathcal{A}(R,z)\\\\ \\boldsymbol{\\pi}=\\Pi\\boldsymbol{\\sigma}_{P};\\boldsymbol{t}\\leftarrow\\mathsf{Test}(R,\\phi,\\sigma_{V}):\\phi\\notin L_{R}\\ \\wedge\\ \\boldsymbol{t}(\\boldsymbol{\\pi})=\\boldsymbol{0}\\end{matrix}\\right]\\approx 0. \\]</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 4.1</h6>

    <p class="text-gray-300">There are no NILPs with verifier degree 1 for relation generators with hard decisional problems.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">NILPs of degree 1 by definition have a decision procedure producing an arithmetic circuit <span class="math">\\boldsymbol{t}:\\mathbb{F}^{k}\\to\\mathbb{F}^{\\eta}</span> evaluating polynomials of degree 1 and testing whether <span class="math">\\boldsymbol{t}(\\boldsymbol{\\pi})=\\boldsymbol{0}</span>. Since the polynomials have degree 1 it is possible to efficiently compute a matrix <span class="math">A\\in\\mathbb{F}^{\\eta\\times k}</span> and a vector <span class="math">\\boldsymbol{b}\\in\\mathbb{F}^{\\eta}</span> such that the test corresponds to checking <span class="math">A\\boldsymbol{\\pi}=\\boldsymbol{b}</span>.</p>

    <p class="text-gray-300">Let us now construct an algorithm <span class="math">\\mathcal{A}</span> that given <span class="math">R</span> and <span class="math">\\phi</span> has a good chance of determining whether <span class="math">\\phi\\in L_{R}</span> or <span class="math">\\phi\\notin L_{R}</span>. It is crucial here that in our definition of NILPs the prover and soundness adversary choose the proof matrix <span class="math">\\Pi</span> independently of the setup <span class="math">\\boldsymbol{\\sigma}_{P}</span> and <span class="math">\\boldsymbol{\\sigma}_{V}</span>. The idea is to run an honest verifier repeatedly to create many common reference strings and verifications. When <span class="math">\\phi\\in L_{R}</span> the same proof matrix <span class="math">\\Pi</span> will give valid proofs for all honest runs of the verifier. On the other hand, when <span class="math">\\phi\\notin L_{R}</span> soundness makes it unlikely that the same <span class="math">\\Pi</span> can pass many tests.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now give the details. First, <span class="math">\\mathcal{A}(R,\\phi)</span> runs the setup $N=mk\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times to get </span>(\\bm{\\sigma}_{1,P},\\bm{\\sigma}_{1,V}),\\ldots,(\\bm{\\sigma}_{N,P},\\bm{\\sigma}_{N,V})<span class="math">. Then for each of them it creates the verifier’s tests </span>A_{i}\\in\\mathbb{F}^{\\eta\\times k}<span class="math"> and </span>\\bm{b}_{i}\\in\\mathbb{F}^{\\eta}<span class="math"> for the statement </span>\\phi<span class="math">. By completeness, if we had a witness for </span>\\phi<span class="math"> we could compute a proof matrix </span>\\Pi<span class="math"> such that for all </span>N<span class="math"> tests </span>A_{i}\\Pi\\bm{\\sigma}_{i,P}=\\bm{b}_{i}<span class="math">. The algorithm </span>\\mathcal{A}<span class="math"> does not know a witness for </span>\\phi\\in L_{R}<span class="math">, but it can solve the set of linear equations to see whether such a </span>\\Pi<span class="math"> exists. If it does, it outputs </span>1<span class="math"> to indicate </span>\\phi\\in L_{R}<span class="math"> and otherwise it outputs </span>0<span class="math"> to indicate </span>\\phi\\notin L_{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us now analyze the success probability of the decision algorithm <span class="math">\\mathcal{A}</span>. On input <span class="math">\\phi\\in L_{R}</span> the completeness of the NILP means that such a <span class="math">\\Pi</span> exists and since the system of equations is linear it can be efficiently solved. The decision algorithm will therefore output <span class="math">1</span> when <span class="math">\\phi\\in L_{R}</span>. On input <span class="math">\\phi\\notin L_{R}</span> the soundness of the NILP means that any choice of <span class="math">\\Pi</span> has low probability of passing the verification. The chance that it passes all $N=mk\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> verifications is therefore upper bounded by </span>\\text{negl}(\\lambda)^{mk\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. There are </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{mk}<span class="math"> possible choices of </span>\\Pi<span class="math">, so there is negligible probability that any </span>\\Pi<span class="math"> exists that will pass all tests. The decision algorithm therefore outputs </span>0<span class="math"> with overwhelming probability when </span>\\phi\\notin L_{R}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of the Theorem 3 also holds for split NILPs and if we restrict the soundness adversary to produce split matrices <span class="math">\\Pi_{1},\\Pi_{2}</span>; this is just an extra restriction on the proof matrices the prover and adversary can produce. In Sect. 2.5 we constructed a pairing-based SNARK from disclosure-free split NILPs. The disclosure-freeness captured that a generic soundness adversary cannot learn interesting information about the common reference string in a pairing setting. All it can do is therefore to choose a statement <span class="math">\\phi\\notin L_{R}</span> and a proof matrix <span class="math">\\Pi</span> independently of <span class="math">\\bm{\\sigma}</span> and hope they pass the verification. Since a single element proof would correspond to a linear decision procedure in the Type III pairing setting, we get the following corollary:</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Corollary 1</h6>

    <p class="text-gray-300">A relation generator with pairing-based SNARKs in the Type III setting constructed from disclosure-free split NILPs as described in Sect. 2.5 must have at least two elements in the proofs for the languages to be non-trivial.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">4.2 Lower bound for the size of generic pairing-based non-interactive arguments</h3>

    <p class="text-gray-300">We will now generalize the statement that a pairing-based non-interactive argument over Type III groups must have elements in both <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> by not requiring the common reference string to be disclosure-free. The intuition behind the argument is still the same though: if we have a unilateral argument with only elements in <span class="math">\\mathbb{G}_{1}</span> or only elements in <span class="math">\\mathbb{G}_{2}</span>, then the verification equations become linear and it becomes possible to violate soundness. For generality, we show this holds even if the common reference string and proof contain elements in <span class="math">\\mathbb{G}_{T}</span>. This results implies a lower bound of at least <span class="math">2</span> group elements in a pairing-based non-interactive argument.</p>

    <p class="text-gray-300">We will consider pairing-based argument systems (Setup, Prove, Vfy), where the common reference string and proofs consist of group elements computed using generic group operations and the verifier uses generic bilinear group operations to test the proof. We restrict the verifier to test the validity of the proof by creating a number of pairing product equations and accepting when they all holds. All known pairing-based SNARKs</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">satisfy this restriction. The restriction rules out violations of the intention behind saying the argument is “pairing based”. For instance, if the common reference string and the proof can be expressed as group elements raised to bits, <span class="math">(G^0,G^1,\\ldots ,G^1,G^0)</span>, then we could imagine the prover would read of the bit-string in the common reference string, use this to create a non-pairing based SNARK, encode it as bits sent to the verifier, and the verifier would decode the bits in the proof and check it. Clearly this is just a very cumbersome way to encode a different type of SNARK and cannot be sadi to be pairing-based.</p>

    <p class="text-gray-300">Let us be explicit about what we mean by a pairing-based non-interactive argument as described above and the consequences of using generic group operations.</p>

    <p class="text-gray-300"><span class="math">(\\sigma, \\tau) \\gets \\mathsf{Setup}(R)</span>: The relation contains a bilinear group <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, G, H)</span> and the common reference string contains group elements in <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> and <span class="math">\\mathbb{G}_T</span>, i.e., <span class="math">\\sigma = ([\\pmb{\\sigma}_1]_1, [\\pmb{\\sigma}_2]_2, [\\pmb{\\sigma}_T]_T)</span>.</p>

    <p class="text-gray-300">oup elements <span class="math">G, G^b</span>, where <span class="math">b</span> is a bit. The prover can easily recover the bit <span class="math">b</span> by guessing it and verifying the guess with generic group operations.</p>

    <p class="text-gray-300"><span class="math">\\pi \\gets \\mathsf{Prove}(R, \\sigma, \\phi, w)</span>: The prover uses generic group operations to construct the proof. This means that she picks matrices <span class="math">\\Pi_1, \\Pi_2</span> and <span class="math">\\Pi_T</span> and computes the proof by setting</p>

    <div class="my-4 text-center"><span class="math-block">\\pi = (\\Pi_ {1} [ \\boldsymbol {\\sigma} _ {1} ] _ {1}, \\Pi_ {2} [ \\boldsymbol {\\sigma} _ {2} ] _ {2}, \\Pi_ {T} [ \\boldsymbol {\\sigma} _ {T} ] _ {T}).</span></div>

    <p class="text-gray-300">Note that we do not assume the common reference string is disclosure-free, so it is possible the matrices <span class="math">\\Pi_1, \\Pi_2, \\Pi_T</span> are related to <span class="math">\\sigma_1, \\sigma_2, \\sigma_T</span>.</p>

    <p class="text-gray-300"><span class="math">0/1 \\gets \\mathsf{Vfy}(R, \\sigma, \\phi, \\pi)</span>: The verifier works in two steps. First, it generates matrices and vectors <span class="math">\\{T_i, \\pmb{t}_i\\}_{i=1}^{\\eta}</span>. It chooses these matrices and vectors independently of the proof, but may use knowledge of the statement and the common reference string. Then it accepts if and only if all pairing product equations of the form</p>

    <div class="my-4 text-center"><span class="math-block">[ \\pmb {\\sigma} _ {1} ^ {\\top}, \\pmb {\\pi} _ {1} ^ {\\top} ] _ {1} \\cdot T _ {i} \\left[ \\begin{array}{l} \\pmb {\\sigma} _ {2} \\\\ \\pmb {\\pi} _ {2} \\end{array} \\right] = \\pmb {t} \\cdot \\left[ \\begin{array}{l} \\pmb {\\sigma} _ {T} \\\\ \\pmb {\\pi} _ {T} \\end{array} \\right] _ {T}</span></div>

    <p class="text-gray-300">hold.</p>

    <p class="text-gray-300">Theorem 4. A pairing-based non-interactive argument with generic group algorithms as described above cannot exist for relation generators with hard decisional problems unless the proofs have elements both in <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span>.</p>

    <p class="text-gray-300">Proof. Let us for contradiction assume we have a pairing-based non-interactive argument of the form described above where the proofs have no elements in <span class="math">\\mathbb{G}_1</span>. The case where the proof has no elements in <span class="math">\\mathbb{G}_2</span> is similar. This means the proofs are of the form <span class="math">[\\varPi_2\\sigma_2]_2, [\\varPi_T\\sigma_T]_T</span>, where <span class="math">\\varPi_2, \\varPi_T</span> are matrices chosen by the generic prover. The matrices and vectors for the test of a proof can then be rewritten as <span class="math">(A_1, B_1, c_1, d_1, \\ldots, A_\\eta, B_\\eta, c_\\eta, d_\\eta)</span>, for which the verifier checks</p>

    <div class="my-4 text-center"><span class="math-block">[ \\pmb {\\sigma} _ {1} ] _ {1} \\cdot A _ {i} [ \\pmb {\\sigma} _ {2} ] _ {2} + [ \\pmb {\\sigma} _ {1} ] _ {1} \\cdot B _ {i} \\varPi_ {2} [ \\pmb {\\sigma} _ {2} ] _ {2} = \\pmb {c} _ {i} \\cdot [ \\pmb {\\sigma} _ {T} ] _ {T} + \\pmb {d} _ {i} \\cdot \\varPi_ {T} [ \\pmb {\\sigma} _ {T} ] _ {T}.</span></div>

    <p class="text-gray-300">³ The prover can also include pairings of elements in <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_T</span> in the proof but we can without loss of generality assume all possible pairwise pairings of elements in <span class="math">[\\sigma_1]_1</span> and <span class="math">[\\sigma_2]_2</span> are included in <span class="math">[\\sigma_T]_T</span>.</p>

    <p class="text-gray-300">We observe that the verification equations correspond to a system of linear equations in <span class="math">\\Pi_{2}</span> and <span class="math">\\Pi_{T}</span>.</p>

    <p class="text-gray-300">We will use such a pairing-based argument system to design an algorithm <span class="math">\\mathcal{A}(R,\\phi)</span> that gets a statement <span class="math">\\phi</span> as input that is either generated as a Yes-instance or a No-instance and decides which case it is. The algorithm works in two stages: first it generates a lot of honest proofs for Yes-instances chosen by itself, and then it checks exloits the linearity of the verification equations to check if the current instance <span class="math">\\phi</span> can have a proof similar to the other Yes-instances. If <span class="math">\\phi</span> is a Yes-instance it can have such a structure, but if <span class="math">\\phi</span> is a No-instance soundness says it cannot.</p>

    <p class="text-gray-300">For the first stage, the algorithm samples many Yes-instances <span class="math">(\\phi_{j},w_{j})\\leftarrow\\textsf{Yes}(R)</span>. It then generates a common reference string <span class="math">[\\bm{\\sigma}_{1}]_{1},[\\bm{\\sigma}_{2}]_{2},[\\bm{\\sigma}_{T}]_{T}</span> and creates proof matrices <span class="math">\\Pi_{j,2},\\Pi_{j,T}</span> and verification tests <span class="math">(A_{j,1},B_{j,1},\\bm{c}_{j,1},\\bm{d}_{j,1},\\ldots,A_{j,\\eta},B_{j,\\eta},\\bm{c}_{j,\\eta},\\bm{d}_{j,\\eta})</span> for all statements. Let <span class="math">V</span> be the vector space generated by <span class="math">(A_{j,1},B_{j,1}\\Pi_{j,2},\\bm{c}_{j,1},\\bm{d}_{j,1}^{\\top}\\Pi_{T},\\ldots,A_{j,\\eta},B_{j,\\eta}\\Pi_{j,2},\\bm{c}_{j,\\eta},\\bm{d}_{j,\\eta}^{\\top}\\Pi_{j,T})</span>.</p>

    <p class="text-gray-300">The algorithm keeps sampling until <span class="math">\\lambda</span> Yes-instances <span class="math">\\phi_{j}</span> in a row give vectors already in <span class="math">V</span>. The vector space has polynomial dimension, so this process terminates in polynomial time. Chernoff-bounds then tell us that with at least <span class="math">50\\%</span> probability the Yes-instance <span class="math">\\phi</span> also gives rise to a vector in <span class="math">V</span>. Of course, even if <span class="math">\\phi</span> is a Yes-instance, the algorithm does not know the corresponding witness though.</p>

    <p class="text-gray-300">The algorithm now proceeds to the second phase. Given <span class="math">\\phi</span> it creates the test <span class="math">(A_{1},B_{1},\\bm{c}_{1},\\bm{d}_{1},\\ldots,A_{\\eta},B_{\\eta},\\bm{d}_{1},\\ldots,A_{\\eta},B_{\\eta},\\bm{d}_{1},\\ldots,A_{\\eta},B_{\\eta},\\bm{d}_{1},\\ldots,A_{\\eta},B_{\\eta},\\bm{d}_{1},\\ldots,A_{\\eta},\\bm{d}_{1},\\ldots,\\bm{d}_{N})</span>. Then it tries to solve for <span class="math">\\Pi_{2},\\Pi_{T}</span> such that <span class="math">(A_{1},B_{1}\\Pi_{2},\\bm{c}_{1},\\bm{d}_{1}^{\\top}\\Pi_{T},\\ldots,A_{\\eta},B_{\\eta}\\Pi_{2},\\bm{c}_{\\eta},\\bm{d}_{\\eta}^{\\top}\\Pi_{T})</span> belongs to the vector space <span class="math">V</span>. This is a system of linear equations, so it can be efficiently solved. If the algorithm manages to solve for <span class="math">\\Pi_{2},\\Pi_{T}</span> it returns <span class="math">1</span>, otherwise it returns <span class="math">0</span>.</p>

    <p class="text-gray-300">Let us now analyze the success probability of the algorithm. If <span class="math">\\phi</span> is sampled as a Yes-instance the algorithm has least <span class="math">50\\%</span> chance of finding <span class="math">\\Pi_{2},\\Pi_{T}</span> giving rise to a vector in <span class="math">V</span>. On the other hand, if <span class="math">\\phi</span> is sampled as a No-instance, soundness implies that there is negligible probability of finding such a <span class="math">\\Pi_{2},\\Pi_{T}</span>. We note that soundness holds because the algorithm after generating the setup <span class="math">[\\bm{\\sigma}_{1}]_{1},[\\bm{\\sigma}_{2}]_{2},[\\bm{\\sigma}_{T}]_{T}</span> honestly runs the generic prover and verifier several times, but never uses special knowledge about the underlying discrete logarithms <span class="math">\\bm{\\sigma}_{1},\\bm{\\sigma}_{2},\\bm{\\sigma}_{T}</span> except what an honest prover and verifier might learn with generic algorithms. ∎</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">A pairing-based non-interactive argument with generic group algorithms as described must have at least two group elements in the proof.</p>

    <h2 id="sec-31" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We are grateful to Alessandro Chiesa and Madars Virza for extensive comments on an earlier version of this paper and for their implementation and analysis of the SNARK in the libsnark library <em>[x10]</em>. We also thank Eran Tromer and Michael Walfish for interesting discussions about the performance of SNARK implementations and the anonymous reviewers for their comments.</p>

    <h2 id="sec-32" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AF07] Masayuki Abe and Serge Fehr. Perfect NIZK with adaptive soundness. In TCC, volume 4392 of Lecture Notes in Computer Science, pages 118–136, 2007.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[AGOT14] Masayuki Abe, Jens Groth, Miyako Ohkubo, and Mehdi Tibouchi. Unified, minimal and selectively randomizable structure-preserving signatures. In TCC, volume 8349 of Lecture Notes in Computer Science, pages 688–712, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBFR15] Michael Backes, Manuel Barbosa, Dario Fiore, and Raphael M. Reischuk. ADSNARK: nearly practical and privacy-preserving proofs on authenticated data. In IEEE Symposium on Security and Privacy, pages 271–286, 2015.</li>

      <li>[BBG05] Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based encryption with constant size ciphertext. Cryptology ePrint Archive, Report 2005/015, 2005.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Innovations in Theoretical Computer Science, pages 326–349, 2012.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In STOC, pages 111–120, 2013.</li>

      <li>[BCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. Snarks for C: verifying program executions succinctly and in zero knowledge. In CRYPTO, volume 8043 of Lecture Notes in Computer Science, pages 90–108, 2013.</li>

      <li>[BCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In IEEE Symposium on Security and Privacy, pages 459–474, 2014.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In TCC, volume 7785 of Lecture Notes in Computer Science, pages 315–333, 2013.</li>

      <li>[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In STOC, pages 505–514, 2014.</li>

      <li>[BCTV14a] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable zero knowledge via cycles of elliptic curves. In CRYPTO, volume 8617 of Lecture Notes in Computer Science, pages 276–294, 2014.</li>

      <li>[BCTV14b] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In USENIX, pages 781–796, 2014.</li>

      <li>[BFM88] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications. In STOC, pages 103–112, 1988.</li>

      <li>[BFR^{+}13] Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath T. V. Setty, Andrew J. Blumberg, and Michael Walfish. Verifying computations with state. In SOSP, pages 341–357, 2013.</li>

      <li>[BP15] Elette Boyle and Rafael Pass. Limits of extractability assumptions with distributional auxiliary input. In ASIACRYPT, volume 9453 of Lecture Notes in Computer Science, pages 236–261, 2015.</li>

      <li>[BSCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Shaul Kfir, Eran Tromer, and Madars Virza. libsnark, 2014. Available at https://github.com/scipr-lab/libsnark.</li>

      <li>[CFH^{+}15] Craig Costello, Cédric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter, Michael Naehrig, Bryan Parno, and Samee Zahur. Geppetto: Versatile verifiable computation. In IEEE Symposium on Security and Privacy, pages 253–270, 2015.</li>

      <li>[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. Cluster computing in zero knowledge. In EUROCRYPT, volume 9057 of Lecture Notes in Computer Science, pages 371–403, 2015.</li>

      <li>[CV16] Alessandro Chiesa and Madars Virza. Personal communication, 2016.</li>

      <li>[DFGK14] George Danezis, Cédric Fournet, Jens Groth, and Markulf Kohlweiss. Square span programs with applications to succinct NIZK arguments. In ASIACRYPT, volume 8873 of Lecture Notes in Computer Science, pages 532–550, 2014.</li>

      <li>[DFKP13] George Danezis, Cédric Fournet, Markulf Kohlweiss, and Bryan Parno. Pinocchio coin: building zerocoin from a succinct pairing-based proof system. In PETShopCCS, 2013.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In EUROCRYPT, volume 7881 of Lecture Notes in Computer Science, pages 626–645, 2013.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proofs. SIAM Journal on Computing, 18(1):186–208, 1989.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GOS06] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive zaps and new techniques for NIZK. In CRYPTO, volume 4117 of Lecture Notes in Computer Science, pages 97–111, 2006.</li>

      <li>[GOS12] Jens Groth, Rafail Ostrovsky, and Amit Sahai. New techniques for noninteractive zero-knowledge. Journal of the ACM, 59(3):11:1–11:35, 2012.</li>

      <li>[GPS08] Steven D. Galbraith, Kenneth G. Paterson, and Nigel P. Smart. Pairings for cryptographers. Discrete Applied Mathematics, 156(16):3113–3121, 2008.</li>

      <li>[Gro06] Jens Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In ASIACRYPT, volume 4248 of Lecture Notes in Computer Science, pages 444–459, 2006.</li>

      <li>[Gro09] Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In CRYPTO, volume 5677 of Lecture Notes in Computer Science, pages 192–208, 2009.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT, volume 6477 of Lecture Notes in Computer Science, pages 321–340, 2010.</li>

      <li>[GS12] Jens Groth and Amit Sahai. Efficient noninteractive proof systems for bilinear groups. SIAM Journal on Computing, 41(5):1193–1232, 2012.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In STOC, pages 99–108, 2011.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In STOC, pages 723–732, 1992.</li>

      <li>[Kil95] Joe Kilian. Improved efficient arguments (preliminary version). In CRYPTO, volume 963 of Lecture Notes in Computer Science, pages 311–324, 1995.</li>

      <li>[KPP^{+}14] Ahmed E. Kosba, Dimitrios Papadopoulos, Charalampos Papamanthou, Mahmoud F. Sayed, Elaine Shi, and Nikos Triandopoulos. TRUESET: faster verifiable set computations. In USENIX, pages 765–780, 2014.</li>

      <li>[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In TCC, volume 7194 of Lecture Notes in Computer Science, pages 169–189, 2012.</li>

      <li>[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. In ASIACRYPT, volume 8269 of Lecture Notes in Computer Science, pages 41–60, 2013.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000.</li>

      <li>[Nec94] Vasilii I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. Mat. Zametki, 55(2):91–101, 1994.</li>

      <li>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE Symposium on Security and Privacy, pages 238–252, 2013.</li>

      <li>[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In EUROCRYPT, volume 1233 of Lecture Notes in Computer Science, pages 256–266, 1997.</li>

      <li>[SVdV16] Berry Schoenmakers, Meilof Veeningen, and Niels de Vreede. Trinocchio: Privacy-friendly outsourcing by distributed verifiable computation. In ACNS, volume ???? of Lecture Notes in Computer Science, pages ???–???, 2016.</li>

      <li>[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In TCC, volume 4948 of Lecture Notes in Computer Science, pages 1–18, 2008.</li>

      <li>[Wal15] Michael Walfish. A wishlist for verifiable computation: An applied cs perspective, 2015.</li>

      <li>[WB15] Michael Walfish and Andrew J. Blumberg. Verifying computations without reexecuting them. Communications of the ACM, 58(2):74–84, 2015.</li>

      <li>[WSR^{+}15] Riad S. Wahby, Srinath T. V. Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walfish. Efficient RAM and control flow in verifiable outsourced computation. In NDSS, 2015.</li>

    </ul>`;
---

<BaseLayout title="On the Size of Pairing-based Non-interactive Arguments (2016/260)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/260
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
