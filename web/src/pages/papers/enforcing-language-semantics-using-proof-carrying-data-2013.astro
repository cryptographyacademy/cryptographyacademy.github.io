---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/513';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Enforcing Language Semantics Using Proof-Carrying Data';
const AUTHORS_HTML = 'Stephen Chong, Eran Tromer, Jeffrey A.  Vaughan';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Sound reasoning about the behavior of programs relies on program execution adhering to the language semantics. However, in a distributed computation, when a value is sent from one party to another, the receiver faces the question of whether the value is well-traced: could it have been produced by a computation that respects the language semantics?  If not, then accepting the non-well-traced value may invalidate the receiver&#x27;s reasoning, leading to bugs or vulnerabilities.

Proof-Carrying Data (PCD) is a recently-introduced cryptographic mechanism that allows messages in a distributed computation to be accompanied by proof that the message, and the history leading to it, complies with a specified predicate. Using PCD, a verifier can be convinced that the predicate held throughout the distributed computation, even in the presence of malicious parties, and at a verification cost that is independent of the size of the computation producing the value. Unfortunately, previous approaches to using PCD required tailoring a specialized predicate for each application, using  an inconvenient formalism and with little methodological support.

We connect these two threads by introducing a novel, PCD-based approach to enforcing language semantics in distributed computations.  We show how to construct an object-oriented language runtime that ensures that objects received from potentially untrusted parties are well-traced with respect to a set of class definitions. Programmers can then soundly reason about program behavior, despite values received from untrusted parties, without needing to be aware of the underlying cryptographic techniques.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> computationally-sound proofs &middot; programming language security</p>
    </section>

    <h2 id="sec-misc-1" class="text-2xl font-bold">Syntax</h2>

    <p class="text-gray-300">    <img src="_page_9_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2. Syntax of Coco</p>

    <p class="text-gray-300">and term this with  <span class="math">\\{\\overline{g} = s\\}</span>  creates a new object identical to the object denoted by this, except each  <span class="math">g_i</span>  is mapped to the result of evaluating  <span class="math">s_i</span> .</p>

    <p class="text-gray-300">Term  <span class="math">s \\parallel t</span>  concurrently evaluates both s and t; if either evaluates to some value v,  <span class="math">s \\parallel t</span>  may evaluate to v. We use term  <span class="math">s \\parallel t</span>  to provide a limited model of both concurrency and nondeterministic choice.</p>

    <p class="text-gray-300">We provide a simple mechanism to model how values can escape the context where they are created (e.g., through imperative state, communication, exceptions or coroutines&mdash;none of which exist in COCO). This explicit modeling allows code in a class to temporarily violate object invariants, so long as it can ensure that all objects that may escape satisfy object invariants. We use <strong>escape</strong> and <strong>capture</strong> to mark where objects escape and where escaped objects may be used, thus allowing us to avoid defining semantics for object invariants, or defining an escape analysis. Term <strong>escape</strong> t evaluates t to a value v, marks v as &quot;escaping&quot; by appending it to a list t of escaped values, and evaluates to t or Term <strong>capture</strong> nondeterministically evaluates to any value in t (i.e., that previously escaped). If a class does not contain any <strong>escape</strong> terms, then a value owned by that class can escape only if it is passed as an argument to a method (of another class) that may apply <strong>escape</strong> to it, or if it is returned from a method.</p>

    <p class="text-gray-300">Judgment  <span class="math">CT, \\rho \\vdash \\langle t, S \\rangle \\rightarrow \\langle t&#x27;, S&#x27; \\rangle</span>  indicates that, under class table CT, and environment  <span class="math">\\rho</span> , term t takes one small step to t', with the list of escaped values growing from S to S'. Figure 3 defines inference rules for this judgment. When a small step evaluation of t evaluates an <strong>escape</strong> v term then</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold">Evaluation Contexts</h2>

    <p class="text-gray-300"><span class="math">$E ::= [\\cdot] \\mid \\text{isnull } E \\mid E \\oplus t \\mid v \\oplus E \\mid \\text{if } E \\text{ then } s \\text{ else } t \\mid E \\text{ int } t \\text{ escape } E</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mid \\text{this with}(\\overline{g} = \\overline{v}, f = E, \\overline{g&#x27;} = \\overline{t}) \\mid E \\mid t \\mid t \\mid E \\mid \\text{let } x = E \\text{ in } t \\mid \\text{ escape } E</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle s, S \\rangle \\rightarrow \\langle t, S&#x27; \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle s, S \\rangle \\rightarrow \\langle t, S&#x27; \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t \\mid s, S \\rangle \\rightarrow \\langle t, S \\rangle</span>$</p>

    <p class="text-gray-300">Figure 3. Operational semantics of COCO</p>

    <pre><code class="language-text">Terms
s, t ::= ...
      | mcall(t, &rho;) Partially-evaluated method call
Environments
 &rho; &isin; Var &cup; {this} * Val
</code></pre>

    <p class="text-gray-300">Figure 4. Deep syntax of COCO</p>

    <p class="text-gray-300">S <sup>0</sup> = S &bull; [v] (where &bull; denotes list concatenation); otherwise S <sup>0</sup> = S. We write CT <code>ht, Si &rarr; ht 0 , S&lt;sup&gt;0&lt;/sup&gt; i when environment &rho; is empty and CT</code> hs, Si &rarr;<sup>&lowast;</sup> ht, S<sup>0</sup> i for zero or more sequential small steps. We write &empty; for the empty list of escaped values.</p>

    <p class="text-gray-300">Environments &rho; &isin; Var &cup; {this} * Val map variables and this to values. We write &empty; for the empty environment. Environments are modified by let terms and by method invocations. For instance, let x = v in t steps to let x = v in t <sup>0</sup> by evaluating t in an environment where &rho; has been extended to &rho;[x 7&rarr; v].</p>

    <p class="text-gray-300">To define the operational semantics of method calls, we extend the surface syntax (Figure <a href="#page-9-0">2)</a> with a new syntactic form, mcall(t, &rho;), which is used to indicate a partially evaluated method call. The extended syntax is shown in Figure <a href="#page-11-1">4.</a>In the remainder of the paper, we use &quot;<em>program</em>&quot; to mean a COCO term that uses just surface syntax, and does not contain a term of the form mcall(t, &rho;).</p>

    <p class="text-gray-300">Intuitively, term v.m(u) invokes method m on object v, passing value u as an argument. If the class declaration of v's class contains method declaration m(x) {return t; }, then v.m(u) steps to mcall(t, [this 7&rarr; v, x 7&rarr; u]). More generally, term mcall(t, &rho;) represents a method invocation that is currently executing, where t is the rest of the method body to execute, and &rho; is the environment for the callee. Note that unlike let terms, evaluation of mcall replaces the current environment instead of extending it; this models the fact that all variables are local to a method.</p>

    <p class="text-gray-300">As mentioned previously, term escape v adds v to the list S of escaped values, and capture evaluates nondeterministically to a previously escaped value. Note that the list of escaped values only increases during execution.</p>

    <p class="text-gray-300">A small-step evaluation of <sup>s</sup>8<sup>t</sup> may take a step for either <sup>s</sup> or <sup>t</sup> (using appropriate evaluation contexts), or, if either s or t is a value, then it may step to that value.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Well-traced values</h3>

    <p class="text-gray-300">We say that a value v is <em>well-traced in class table</em> CT if there is some COCO program that can evaluate to v using a class table that is consistent with CT.</p>

    <p class="text-gray-300">The property of well-tracedness is central to our goal of enforcing language semantics in distributed computation. Intuitively, if value v is well-traced in class table CT, then v could have been produced by a program execution that adhered to the language semantics, using class definitions that are compatible with class table CT, but possibly including additional classes.</p>

    <p class="text-gray-300">To formally define well-tracedness, we first introduce some notation, and define what it means for a value to be well-formed in a class table, and for one class table to extend another.</p>

    <p class="text-gray-300">We must first present some preliminary definitions. Judgment CT \`wf v, defined in Figure <a href="#page-12-1">5,</a> indicates that v is <em>well-formed in class table</em> CT. Intuitively, well-formedness requires that objects are syntactically consistent with their class definitions. That is, object o = {C | f = v } is well-formed if C appears in CT, the fields f bound by object o are exactly the fields that the class C has according to CT, and, recursively, the values v that o binds to fields are also well formed in CT. Well-formedness (unlike well-tracedness) is</p>

    <p class="text-gray-300"><span class="math">$\\frac{CT \\vdash_{\\mathsf{wf}} v}{CT(C) = \\mathsf{class}\\{\\mathsf{fields}\\, f_1, \\dots, f_n; \\, \\mathsf{meths}\\, \\overline{M}\\,\\} \\qquad CT \\vdash_{\\mathsf{wf}} v_i \\, \\mathsf{for}\\, i \\in 1..n \\qquad names(CT) \\subseteq \\mathsf{dom}(CT)}{CT \\vdash_{\\mathsf{wf}} \\{C \\mid f_1 = v_1, \\dots, f_n = v_n\\,\\}}</span>$</p>

    <p class="text-gray-300"><span class="math">$names(CT) \\subseteq \\mathsf{dom}(CT) \\qquad names(CT) \\subseteq \\mathsf{dom}(CT)</span>$</p>

    <p class="text-gray-300">Figure 5. Inference rules for well-formedness</p>

    <p class="text-gray-300">CT \`wf i</p>

    <p class="text-gray-300">directly and efficiently checkable. If an object o is not well formed, then o is inconsistent with class table CT, and use of o may result in stuck computation.</p>

    <p class="text-gray-300">Class table CT extends class table CT<sup>0</sup> when CT contains all of the class declarations of CT<sup>0</sup> , and possibly some additional class declarations.</p>

    <p class="text-gray-300">Definition 1 (Class table extension). <em>Class table</em> CT extends <em>class table</em> CT<sup>0</sup> <em>(written</em> CT &supe; CT<sup>0</sup> <em>) if</em> dom(CT<sup>0</sup> ) &sube; dom(CT) <em>and for all</em> C &isin; dom(CT<sup>0</sup> )<em>,</em> CT(C) = CT<sup>0</sup> (C)<em>.</em></p>

    <p class="text-gray-300">We can now formally define well-tracedness:</p>

    <p class="text-gray-300">CT \`wf null</p>

    <p class="text-gray-300">Definition 2 (Well-traced values). <em>Value</em> v <em>is</em> well-traced in CT <em>if</em> CT \`wf v <em>and there exist a class table</em> CT<sup>0</sup> <em>and a program</em> t <em>such that</em></p>

    <p class="text-gray-300"><span class="math">$CT&#x27; \\supseteq CT</span>$
and  <span class="math">CT&#x27; \\vdash \\langle t, S \\rangle \\rightarrow^* \\langle v, S&#x27; \\rangle</span> .</p>

    <p class="text-gray-300">Well-tracedness distinguishes syntactically well-formed values from values that can be produced by a COCO program. For integers, these notions coincide. However, for objects, well-tracedness plus encapsulation can ensure that fields satisfy nontrivial predicates (e.g., &quot;this chess puzzle is solvable&quot;, &quot;this is a valid RSA modulus, i.e., an integer which is the product of two large primes&quot;). It is encapsulation that makes well-tracedness a useful property: in a calculus without encapsulation, the set of well-formed values and well-traced values typically coincide.</p>

    <p class="text-gray-300">Note that well-tracedness of a value does not imply that we know the computation that produced it. Class table CT represents class definitions that are well-known and agreed upon by all parties, such as standard libraries and common application-specific classes (e.g., Puzzle, Board, and Move for the chess puzzle example). The computation that produced the value may use additional classes beyond those in CT. For example, the computation may use classes that are defined by another party in the distributed system, and represent proprietary algorithms or private data-structures of the other party.</p>

    <p class="text-gray-300">The inclusion in COCO of non-deterministic concurrent evaluation and terms escape and capture means that any object that escapes the dynamic scope of the owning class is well-traced. This permits a simple and intuitive definition of well-tracedness that includes such escaping objects, since if program t allows value <sup>v</sup> to escape, then program <sup>t</sup>8capture can evaluate to <sup>v</sup>, and thus <sup>v</sup> is well-traced. For example, even if the classes in CT do not include any escape terms, if their code passes a value v to a method of an arbitrary class, then that could be a class in some CT<sup>0</sup> (extending CT) which invokes escape on v, which means we could write a COCO program that escapes v; hence v is well-traced in CT.</p>

    <p class="text-gray-300">COCO deliberately models only local computation without communication. This is so that we can define well-tracedness independently of communication with untrusted parties, which greatly simplifies</p>

    <h2 id="sec-misc-3" class="text-2xl font-bold">Metavariable convention for names</h2>

    <p class="text-gray-300">ch ranges over channel names</p>

    <pre><code class="language-text">Syntax
Terms
s, t ::= . . .
     | send t on ch Send
     | recv on ch Receive
</code></pre>

    <p class="text-gray-300">Figure 6. Syntax of COCOCOMM (extending COCO)</p>

    <p class="text-gray-300">reasoning about well-traced values. In this section, we extend COCO to the calculus COCOCOMM by adding communication primitives. A COCOCOMM program represents the local computation of one party of a distributed computation; communication with other parties occurs by sending and receiving values on channels. COCOCOMM semantics ensure that all values received are well-traced in a common class table.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Syntax and semantics</h3>

    <p class="text-gray-300">COCOCOMM extends COCO with terms for sending and receiving values over channels. The syntax extension is given in Figure <a href="#page-13-1">6.</a> Term send t on ch evaluates term t to a value, which is sent over channel ch, and the term evaluates to the value sent. Term recv on ch receives a value on channel ch. We require that values sent and received are well-formed in a <em>common class table</em>: a set of class names and definitions that all parties in a distributed computation have agreed upon in advance. The common class table ensures that a value received will be well-formed in the receiver's local class table, even though the local class tables of the sender and receiver may differ. This is analogous to restricting class serialization in Java to only classes from well-known and agreed-upon libraries.<a href="#page-13-2">2</a></p>

    <p class="text-gray-300">Importantly, COCOCOMM semantics also require that any value received is well-traced in the common class table. Intuitively, this allows the recipient to use local reasoning to establish invariants about the received value. That is, the recipient can examine the code of the relevant classes in the common class table in order to reason about the received value. The recipient does <em>not</em> need to trust the sender of the value, or be concerned about how the value was produced. The challenge is to enforce the semantics of COCOCOMM, that is, to ensure that all values received are well-traced. We address this in Sections <a href="#page-15-0">5</a> and <a href="#page-21-0">6.</a></p>

    <p class="text-gray-300">Judgment CT, CTcmn, &rho; <code>comm ht, Si &rarr; ht 0 , S&lt;sup&gt;0&lt;/sup&gt; i indicates that COCOCOMM term t takes one small step to term t 0 , using class table CT and environment &rho;, using common class table CTcmn for communication, with the list of escaped values growing from S to S 0 . Class table CT must extend the common class table CTcmn, i.e., CT &supe; CTcmn. Note that CTcmn is a COCO class table: the definitions of the classes of CTcmn do not contain any send or recv terms; CT may, however, contain classes with send or recv terms. We write CT, CTcmn </code>comm ht, Si &rarr;<sup>&lowast;</sup> ht 0 , S<sup>0</sup> i to indicate that term t can take zero or more steps to evaluate to term t 0 (with an empty environment).</p>

    <p class="text-gray-300">Semantics for COCOCOMM are similar to that of COCO: for each inference rule in the operational semantics of COCO (Figure <a href="#page-10-0">3)</a> there is a corresponding inference rule for COCOCOMM. In addition, we have inference rules for the terms send t on ch and recv on ch, given in Figure <a href="#page-14-2">7.</a> The rule for send t on ch evaluates t to a value, ensures that the value is well-formed in CTcmn, and adds v to the list of escaped values. The rule for recv on ch nondeterministically receives some value v that is well-traced in CTcmn.</p>

    <p class="text-gray-300"><sup>2</sup> We could extend our model to allow mobile code, that is, class definitions sent over channels. For simplicity, we refrain from doing so.</p>

    <p class="text-gray-300"><span class="math">$CT, CT_{\\mathsf{cmn}}, \\rho \\vdash_{\\mathsf{comm}} \\langle t, S \\rangle \\to \\langle t&#x27;, S&#x27; \\rangle</span>$</p>

    <p class="text-gray-300"><span class="math">$E ::= \\dots \\mid \\mathsf{send} \\ E \\ \\mathsf{on} \\ ch</span>$</p>

    <p class="text-gray-300"><span class="math">$\\frac{CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{wf}} v}{CT, CT_{\\mathsf{cmn}}, \\rho \\vdash_{\\mathsf{comm}} \\langle \\mathsf{send} \\ v \\ \\mathsf{on} \\ ch, S \\rangle \\to \\langle v, S \\bullet [v] \\rangle}</span>$</p>

    <p class="text-gray-300"><span class="math">$v \\ \\mathsf{is} \\ \\mathsf{well-traced} \\ \\mathsf{in} \\ CT_{\\mathsf{cmn}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\frac{v \\ \\mathsf{is} \\ \\mathsf{well-traced} \\ \\mathsf{in} \\ CT_{\\mathsf{cmn}}}{CT, CT_{\\mathsf{cmn}}, \\rho \\vdash_{\\mathsf{comm}} \\langle \\mathsf{recv} \\ \\mathsf{on} \\ ch, S \\rangle \\to \\langle v, S \\rangle}</span>$</p>

    <p class="text-gray-300">Figure 7. Semantics of COCOCOMM (extending COCO)</p>

    <p class="text-gray-300"><em>Example</em> Consider the chess puzzle example from the Introduction. (The pseudo-code in Figure <a href="#page-3-0">1</a> is close to, but not exactly, COCO syntax.) Suppose class table CTcmn contains definitions for common classes, including Puzzle, Board, and Move. When object {Puzzle | remainingMoves = n, board = v } is received, the fact that it is well-traced, combined with the class definitions in CTcmn, allows the recipient to reason that the puzzle must have a solution within n moves. This holds, even though the recipient may not trust the sender, and has no idea how the sender produced the object. Indeed, the sender may have used proprietary code (in classes not in CTcmn) to compute the puzzle, or may have manufactured the puzzle without executing any COCO program.</p>

    <p class="text-gray-300">COCOCOMM is a strict extension of COCO: if t is a COCO program that evaluates to value v, then it is also a COCOCOMM program that evaluates to v. The converse does not necessarily hold.</p>

    <p class="text-gray-300"><em>Communication model</em> We do not explicitly model the operation of COCOCOMM communication channels. In Section <a href="#page-15-2">5.2</a> we define a model for composing concurrently executing programs so that send and recv operations are matched up appropriately, but this model is deliberately underspecified with respect to whether communication is point-to-point, broadcast, in-order, reliable, etc. These details are not important for the purposes of this paper.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Well-tracedness</h3>

    <p class="text-gray-300">COCOCOMM preserves well-tracedness, in that if a COCOCOMM program allows value v to escape and v is well-formed in CTcmn then v is well-traced in CTcmn.</p>

    <p class="text-gray-300">Theorem 1. <em>Let</em> CT <em>be a</em> COCOCOMM <em>class table and let</em> CTcmn <em>be a common class table such that</em> CT &supe; CTcmn<em>. Let</em> t <em>be a</em> COCOCOMM <em>program,</em> t <sup>0</sup> <em>a term,</em> S <em>a sequence of escaped values, and</em> v <em>a value such that</em> v &isin; S<em>. If</em></p>

    <p class="text-gray-300"><span class="math">$CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t, \\emptyset \\rangle \\to^* \\langle t&#x27;, S \\rangle</span>$</p>

    <p class="text-gray-300"><em>and</em> CTcmn \`wf v <em>then</em> v <em>is well-traced in</em> CTcmn<em>.</em></p>

    <p class="text-gray-300">The proof of this theorem is in Appendix <a href="#page-36-0">B.</a></p>

    <p class="text-gray-300">Theorem <a href="#page-14-1">1</a> has two key implications. First, a party using COCOCOMM to carry out its part of a distributed computation can be sure that values produced by its computation could also have been produced by a plain COCO program. The party does not need to be concerned that values received over channels can somehow violate properties that can be established by reasoning about only COCO programs. Despite communication with untrusted parties, it is as easy to reason about COCOCOMM programs as it is to reason about COCO programs.</p>

    <p class="text-gray-300">
<span class="math">$\\overline{CT,CT_{\\mathrm{cmn}},\\rho \\vdash_{\\mathsf{Trust}} \\langle \\mathsf{recv} \\; \\mathsf{on} \\; ch,S \\rangle \\to \\langle v,S \\rangle}</span>$</p>

    <p class="text-gray-300"><strong>Figure 8.</strong> Receive rule for COCOTRUST (modifying COCOCOMM.)</p>

    <p class="text-gray-300">Second, honest parties can indeed use COCOCOMM to perform a distributed computation, since any value that an honest party sends over a channel will be well-traced in  <span class="math">CT_{\\rm cmn}</span> , and can thus be accepted by the receiver. In other words, computation by honest parties will not get stuck due to sending non-well-traced values. Later, we will show that this is preserved when the assumption of honesty is replaced by cryptographic proofs.</p>

    <h2 id="sec-misc-4" class="text-2xl font-bold">5. Modeling Distributed Executions</h2>

    <p class="text-gray-300">The COCOCOMM language enables a party in a distributed computation to reason locally about values received during computation, without trusting the senders. To enforce COCOCOMM semantics, we must ensure that only well-traced values are received. In this and the following section, we show how to enforce COCOCOMM semantics using Proof-Carrying Data (PCD) [8, 12], as follows.</p>

    <p class="text-gray-300">We introduce COCOTRUST, which is similar to COCOCOMM except that the evaluation of <strong>recv</strong> does not check that received values are well-traced (Section 5.1). We show that if we have a distributed computation where all parties are executing COCOTRUST programs, then received values are, nevertheless, well-traced (Section 5.2 and Theorem 2). Thus, to enforce COCOCOMM semantics, it suffices to ensure that all parties adhere to COCOTRUST semantics.</p>

    <p class="text-gray-300">We provide an overview of PCD (Section 6.1), and develop a PCD compliance predicate that states that a computation adheres to CocoTrust semantics (Section 6.2). By instantiating PCD on this compliance predicate, a party can prove that its computation adhered to CocoTrust semantics, and, transitively, all values it received were also produced by CocoTrust semantics.</p>

    <p class="text-gray-300">We show that this yields a sound and complete proof system for well-tracedness of values (Section 6.3 and Theorems 3 and 4, using Theorem 2), and, moreover, a sound and complete proof system for COCO-COMM semantics (Section 6.4 and Theorems 5 and 6).</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 COCOTRUST</h3>

    <p class="text-gray-300">COCOTRUST shares its syntax of terms and evaluation contexts with COCOCOMM, and has a single (but crucial) relaxation in semantics. Judgment  <span class="math">CT, CT_{cmn}, \\rho \\models_{trust} \\langle t, S \\rangle \\rightarrow \\langle t&#x27;, S&#x27; \\rangle</span>  indicates that COCOCOMM term t takes one small step to term t', using class table CT and environment  <span class="math">\\rho</span> , using common class table  <span class="math">CT_{cmn}</span>  for communication, with the list of escaped values growing from S to S'. As before, we write  <span class="math">CT, CT_{cmn} \\models_{trust} \\langle t, S \\rangle \\rightarrow^* \\langle t&#x27;, S&#x27; \\rangle</span>  to indicate that term t can take zero or more steps, using COCOTRUST semantics, to evaluate to term t' (with an empty environment).</p>

    <p class="text-gray-300">Inference rules for the COCOTRUST operational semantics are identical to those for COCOCOMM, with the exception of the rule for receiving values. Whereas COCOCOMM requires received values to be well-traced in the common class table  <span class="math">CT_{\\rm cmn}</span> , COCOTRUST merely &quot;trusts&quot; that received values will be suitable. The COCOTRUST rule for <strong>recv</strong> is shown in Figure 8; note that there is no premise for the rule, and thus no requirements on the received value v. Intuitively, the simplified rule for <strong>recv</strong> makes it easy to efficiently implement COCOTRUST evaluation.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Distributed execution graphs</h3>

    <p class="text-gray-300">Suppose that we have multiple parties, each of which is executing its own COCOTRUST program, with common class table  <span class="math">CT_{cmn}</span> , and recv operations are matched up with appropriate send operations. As long</p>

    <p class="text-gray-300">as all parties are honest, i.e., adhere to COCOTRUST semantics and  <span class="math">CT_{cmn}</span> , all values received by parties will in fact be well-traced and thus COCOCOMM semantics are achieved.</p>

    <p class="text-gray-300">To model this, we define distributed execution graphs, which represent the parallel composition of COCOTRUST programs with the sends and receives matched up appropriately. The nodes of a distributed execution graph represent zero or more computational steps taken by one of the parties. Directed edges between nodes indicate either local sequential evaluation for a single party (who first performs the computation represented by the source node, and then the computation represented by the target node), or communication between two parties (i.e., the last computational step of the source node is a <strong>send</strong> v <strong>on</strong> ch term, and v is received by the first step of the target node).</p>

    <p class="text-gray-300">We first informally describe distributed execution graphs, and then present a formal definition, stated in a way that simplifies the subsequent use of PCD. The key observation is that in a distributed execution graph (where all parties are following COCOTRUST semantics), all values received are well-traced, and thus COCOCOMM semantics are achieved.</p>

    <p class="text-gray-300"><strong>Nodes of a distributed execution graph</strong> Each node in a distributed execution graph has a label of the form  <span class="math">(CT, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W)</span>  where CT is a class table, t and t' are terms, and  <span class="math">CT, CT_{cmn} \\vdash_{trust} \\langle t, S \\rangle \\rightarrow^* \\langle t&#x27;, S&#x27; \\rangle</span> . Trace-witness W allows us to efficiently check that  <span class="math">CT, CT_{cmn} \\vdash_{trust} \\langle t, S \\rangle \\rightarrow^* \\langle t&#x27;, S&#x27; \\rangle</span> . This will be useful when we instantiate PCD to help enforce COCOCOMM semantics. Trace-witnesses indicate how nondeterministic choices in the program were resolved. Formally, a trace-witness W is a sequence defined by the grammar below, which indicates, for each step, whether the step was deterministic, or, if it was a nondeterministic choice  <span class="math">s \\mid t</span> , whether the left or right term was chosen (and how the nondeterministic choices of the subterm were evaluated), or, if it was a <strong>capture</strong> term, the index i of the escaped value to which the term evaluated.</p>

    <p class="text-gray-300"><span class="math">$U ::= Det \\mid Left \\cdot U \\mid Right \\cdot U \\mid i</span>$</p>

    <p class="text-gray-300"><span class="math">$W ::= (U)^*</span>$</p>

    <p class="text-gray-300">We denote the set of possible trace-witnesses as W.</p>

    <p class="text-gray-300"><strong>Edges of a distributed execution graph</strong> Edges between nodes of a distributed execution graph indicate either the continuation of the local <em>sequence</em> of evaluation or <em>communication</em>, and are labeled to indicate which. The labels also convey the information required for checking consistency between its source and destination nodes.<sup>3</sup></p>

    <p class="text-gray-300">A sequence edge between two nodes has label seq[CT, t', S'], indicating that the source node computation used class table CT and the last term in the source node's computation was t' with escaped values S'. The target node represents the continuation of the computation by the same party, so the target node's computation will also use class table CT, and the first term in the target node's computation will be t' with escaped values S'.</p>

    <p class="text-gray-300">A communication edge between two nodes has label msg[v, ch], indicating that the source node sent value v over channel ch, and value v was received by the target node. Thus, the last term of the source node must have the form  <span class="math">F[\\mathbf{send}\\ v\\ \\mathbf{on}\\ ch]</span>  for some context F; and the first term of the target node must have the form  <span class="math">F&#x27;[\\mathbf{recv}\\ \\mathbf{on}\\ ch]</span>  for some context F' and then step to F'[v], indicating that the value v was received. Here, contexts F are used to identify  <span class="math">\\mathbf{send}</span>  and  <span class="math">\\mathbf{recv}</span>  terms that will be reduced in the next evaluation step.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup> Thus, Definition 3 speaks of requirements within a node, and on node vs. its incident edges, but never on node vs. another node. This is essential to the subsequent instantiation of PCD to enforce COCOCOMM semantics, since no node can observe another except by the messages sent.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} F ::= [\\cdot] \\mid &amp; \\text{isnull } F \\mid F \\oplus t \\mid v \\oplus F \\mid \\text{if } F \\text{ then } s \\text{ else } t \\\\ \\mid F \\text{ instanceof } C \\mid F.m(t) \\mid v.m(F) \\\\ \\mid &amp; \\text{send } F \\text{ on } ch \\mid \\text{this with} \\{ \\overline{g = v}, f = F, \\overline{g&#x27; = t} \\} \\\\ \\mid &amp; F \\llbracket t \\mid t \\rrbracket F \\mid \\text{escape } F \\\\ \\mid &amp; \\text{let } x = F \\text{ in } t \\mid \\text{let } x = v \\text{ in } F \\mid \\text{mcall}(F, \\rho) \\end{split}</span>$</p>

    <p class="text-gray-300">Figure 9. Contexts. Compared to COCOCOMM evaluation contexts, this adds let x=v in F and  <span class="math">\\operatorname{mcall}(F,\\rho)</span> .</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 10.</strong> Cases for incoming edges of distributed execution graph nodes. Dashed nodes and edges indicate a typical (but not required) neighborhood. Here,  <span class="math">\\langle t, S \\rangle \\underset{CT}{\\rightarrow^*} \\langle t&#x27;, S&#x27; \\rangle</span>  is shorthand for  <span class="math">CT, CT_{\\mathsf{cmn}} \\mid_{\\mathsf{trust}} \\langle t, S \\rangle \\rightarrow^* \\langle t&#x27;, S&#x27; \\rangle</span> .</p>

    <p class="text-gray-300">Contexts F include the evaluation contexts of Figures 3 and 7 and also contexts for method calls <strong>mcall</strong> and let x = v in t expressions. Syntax for these contexts is given in Figure 9.<sup>4</sup></p>

    <p class="text-gray-300">We restrict the incoming and outgoing edges of nodes to ensure that the graph represents valid computation and communication between parties. For example, we ensure that no node has multiple incoming sequence edges. More precisely, we ensure that for each node  <span class="math">(CT, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W)</span> , there are only three possible cases for the incoming edges, enumerated here. (Diagrams illustrating the cases are given in Figure 10.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(0) No incoming edges. This node represents the start of a computation by a party, where t is the program the party is executing. Escaped values S should be empty.</li>
      <li>(1) One incoming sequence edge. This node represents the continuation of a local evaluation process: the parent node indicates that the party has evaluated the program up to term t (and escaped values S), and this node continues execution from t (and using the same class table, and escaped values S).</li>
    </ul>

    <p class="text-gray-300">The COCOCOMM operational semantics do not include <strong>let</strong> and <strong>mcall</strong> in evaluation contexts E, since these require specialized inference rules and would not be correctly handled by the generic rule for evaluation contexts (first rule in Figure 3). For example, let x = v in send x on ch is equivalent to F[send x on ch] where F = let x = v in  <span class="math">[\\cdot]</span> , but there is no evaluation context E such that it is equivalent to E[send x on ch].</p>

    <p class="text-gray-300">(2) Two incoming edges, consisting of one sequence edge and one communication edge. This node represents the continuation of an evaluation process (via a seq edge) after receiving a value via a msg edge from a sender. Note that the sender will typically continue its execution via another seq edge.</p>

    <p class="text-gray-300">We require that distributed execution graphs are acyclic to ensure that communication is causally ordered: messages aren't received before they are sent. We also require that evaluation of a recv term receives exactly one value that was previously sent by a send term. We do not otherwise make assumptions about the operations of channels. For example, our model is agnostic as to whether message delivery is in-order or out-of-order, and is agnostic as to whether a sent value should be received at most once (i.e., point-to-point communication), or whether a sent value may be received multiple times along multiple communication edges (e.g., broadcast communication).</p>

    <p class="text-gray-300"><em>Definition of distributed execution graphs</em> Before we formally define distributed execution graphs, we first introduce a helper function, check, that given class table CT, configurations ht, Si and ht 0 , S<sup>0</sup> i, and trace-witness W, efficiently checks whether CT \` ht, Si &rarr;<sup>&lowast;</sup> ht 0 , S<sup>0</sup> i. Note that although terms t and t <sup>0</sup> may contain send and recv operations, the semantics are COCO, not COCOTRUST. This means that t evaluates to t <sup>0</sup> without performing any send or receive operations.</p>

    <p class="text-gray-300">Proposition 1 (Existence of check). <em>There exists a polynomial-time algorithm</em></p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{check} : \\mathcal{CT} \\times \\big( \\mathbf{Term} \\times \\mathbf{List}(\\mathbf{Val}) \\big) \\times \\\\ &amp; \\big( \\mathbf{Term} \\times \\mathbf{List}(\\mathbf{Val}) \\big) \\times \\mathcal{W} \\to \\{0,1\\} \\end{split}</span>$</p>

    <p class="text-gray-300"><em>such that whenever</em></p>

    <p class="text-gray-300"><span class="math">$\\operatorname{check}(CT,\\langle t,S\\rangle,\\langle t&#x27;,S&#x27;\\rangle,W)=1</span>$</p>

    <p class="text-gray-300"><em>it holds that</em> CT \` ht, Si &rarr;<sup>&lowast;</sup> ht 0 , S<sup>0</sup> i<em>.</em></p>

    <p class="text-gray-300"><em>Define also a version that takes the common class table and skips any initial</em> send <em>if the value sent is well-formed in the common class table:</em></p>

    <p class="text-gray-300"><span class="math">$\\mathsf{check}&#x27;(CT, CT_{\\mathsf{cmn}}, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W) = \\\\ \\begin{cases} \\mathsf{check}(CT, \\langle F[v], S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W) &amp; \\textit{if } t = F[\\mathsf{send} \\ v \\ \\mathsf{on} \\ ch] \\ \\textit{and} \\ CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{wf}} v \\\\ \\mathsf{check}(CT, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W) &amp; \\textit{otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">Implementation of check and check<sup>0</sup> is straightforward: using the trace witness, we can efficiently find a derivation of CT \` ht, Si &rarr;<sup>&lowast;</sup> ht 0 , S<sup>0</sup> i. Moreover, trace-witnesses can be produced efficiently (which is needed to satisfy the PCD instantiation requirements).</p>

    <p class="text-gray-300">Proposition 2 (Efficient trace-witness production). <em>There exists a polynomial-time algorithm that, given a derivation of</em> CT \` ht, Si &rarr;<sup>&lowast;</sup> ht 0 , S<sup>0</sup> i <em>yields trace-witness</em> W <em>where</em> check(CT,ht, Si,ht 0 , S<sup>0</sup> i, W) = 1<em>.</em></p>

    <p class="text-gray-300">Note that the running time of check is polynomial in all of its inputs, including W, which in turn is polynomial in the size of the derivation. However, it independent of the derivation of received messages (indeed, check verifies only plain COCO derivations).</p>

    <p class="text-gray-300">Distributed execution graphs are defined as follows.</p>

    <p class="text-gray-300">Definition 3 (Distributed execution graph). <em>Given a class table</em> CTcmn<em>, a</em> distributed execution graph using CTcmn <em>is a labeled directed acyclic graph fulfilling the following.</em></p>

    <p class="text-gray-300"><em>a. Each node's label is of the form</em> (CT,ht, Si,ht 0 , S<sup>0</sup> i, W) <em>where</em> CT <em>is a class table,</em> t <em>and</em> t <sup>0</sup> <em>are terms,</em> S <em>and</em> S <sup>0</sup> <em>are lists of values, and</em> W &isin; W <em>is a trace-witness.</em></p>

    <p class="text-gray-300"><em>b. For each node</em> (CT,ht, Si,ht 0 , S<sup>0</sup> i, W) <em>and edge with label</em> zout <em>exiting it, exactly one of the following holds:</em></p>

    <pre><code class="language-text">i. zout = seq[CT, t0
                       , S0
                           ]
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>ii.</em> zout = msg[v, ch] <em>for some value</em> v <em>and channel</em> ch<em>, such that</em> t <sup>0</sup> = F[send v on ch] <em>for some context</em> F<em>, and</em> CTcmn \`wf v</li>
      <li><em>c. For each node</em> (CT,ht, Si,ht 0 , S<sup>0</sup> i, W) <em>and its list</em> ~zin <em>of incoming edges, exactly one of the following holds:</em>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>(0)</em> ~zin <em>is empty and:</em>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>i.</em> CT <em>extends</em> CTcmn</li>
      <li><em>ii.</em> check<sup>0</sup> (CT, CTcmn,ht, Si,ht 0 , S<sup>0</sup> i, W) = 1</li>
      <li><em>iii.</em> t <em>is a program (i.e., it contains only surface syntax)</em></li>
      <li><em>iv.</em> S <em>is the empty list</em> &empty;<em>.</em></li>
    </ul></li>
    </ul></li>
      <li><em>(1)</em> ~zin = (seq[CT <sup>E</sup>, tE, SE] ) <em>such that:</em>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>i.</em> CT <sup>E</sup> = CT <em>and</em> t<sup>E</sup> = t <em>and</em> S<sup>E</sup> = S</li>
      <li><em>ii.</em> check<sup>0</sup> (CT, CTcmn,ht, Si,ht 0 , S<sup>0</sup> i, W) = 1</li>
    </ul></li>
      <li><em>(2)</em> ~zin = (seq[CT <sup>E</sup>, tE, SE], msg[v, ch] ) <em>such that:</em>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>i.</em> CT <sup>E</sup> = CT <em>and</em> t<sup>E</sup> = t <em>and</em> S<sup>E</sup> = S</li>
      <li><em>ii.</em> t = F[recv on ch] <em>for some context</em> F</li>
      <li><em>iii.</em> check(CT,hF[v], Si,ht 0 , S<sup>0</sup> i, W) = 1</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Distributed execution graphs represent the execution of communicating COCOTRUST (rather than COCOCOMM) programs. Recall, however, that COCOCOMM semantics differ from COCOTRUST semantics only in requiring received values to be well-traced. Since the distributed execution graph explicitly shows the &quot;pedigree&quot; of each received value, it implies that all received values <em>are</em> in fact well-traced, and thus, COCOCOMM semantics hold for all nodes in the graph:</p>

    <p class="text-gray-300">Theorem 2. <em>In a distributed execution graph, for every node labeled</em> (CT,ht, Si,ht 0 , S<sup>0</sup> i, W)<em>, it holds that</em></p>

    <p class="text-gray-300"><span class="math">$CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t, S \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle \\ .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> By induction on the structure of the graph. Since the graph is acyclic, the induction is well founded. The induction hypothesis is that for any node (CT,ht, Si,ht 0 , S<sup>0</sup> i, W), there exists a program t<sup>0</sup> such that CT, CTcmn <code>comm ht0, &empty;i &rarr;&lt;sup&gt;&lowast;&lt;/sup&gt; ht 0 , S&lt;sup&gt;0&lt;/sup&gt; i and moreover, if t &lt;sup&gt;0&lt;/sup&gt; = F[send v on ch] and CTcmn </code>wf v then v is well-traced in CTcmn.</p>

    <p class="text-gray-300">We will use the following lemma, which is straightforward from the definitions:</p>

    <p class="text-gray-300">Lemma 1. <em>For any program</em> t0<em>, terms</em> t<em>,</em>t 0 <em>, class tables</em> CT<em>,</em>CTcmn<em>, lists</em> S<em>,</em>S <sup>0</sup> <em>and trace witness</em> W<em>: if</em></p>

    <p class="text-gray-300"><span class="math">$CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t_0, \\emptyset \\rangle \\to^* \\langle t, S&#x27; \\rangle \\quad \\textit{and} \\quad \\mathsf{check&#x27;}(CT, CT_{\\mathsf{cmn}}, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W) = 1</span>$</p>

    <p class="text-gray-300"><em>then</em></p>

    <p class="text-gray-300"><span class="math">$CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t_0, \\emptyset \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span>$
.</p>

    <p class="text-gray-300">Consider node n, labeled (CT,ht, Si,ht 0 , S<sup>0</sup> i, W). Assume the inductive hypothesis holds for all nodes that can reach n. To show that there exists a program t<sup>0</sup> such that CT, CTcmn \`comm ht0, &empty;i &rarr;<sup>&lowast;</sup> ht 0 , S<sup>0</sup> i, consider the cases of the incoming edges to n.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(0) The cases of no incoming edges is straightforward, letting  <span class="math">t_0 = t</span>  and noting condition c(0) in Definition 3 and the definition of check'.</li>
      <li>(1) In the case of a single incoming edge (seq[ <span class="math">CT_{\\mathsf{E}}, t_{\\mathsf{E}}, S_{\\mathsf{E}}</span> ]), we know by condition c(1)i of Definition 3 that  <span class="math">CT_{\\mathsf{E}} = CT</span>  and  <span class="math">t_{\\mathsf{E}} = t</span>  and  <span class="math">S_{\\mathsf{E}} = S</span> , and then by condition b(i) of Definition 3 that this edge exited some parent node of the form  <span class="math">(CT, \\langle \\cdot, \\cdot \\rangle, \\langle t, S \\rangle, \\cdot)</span> . By the induction hypothesis applied to the parent, there exists a program  <span class="math">t_0</span>  such that  <span class="math">CT, CT_{\\mathsf{cmn}} \\models_{\\mathsf{comm}} \\langle t_0, \\emptyset \\rangle \\to^* \\langle t, S \\rangle</span> . By condition c(1)ii of Definition 3, check' <span class="math">(CT, CT_{\\mathsf{cmn}}, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W) = 1</span>  and thus by Lemma 1,  <span class="math">CT, CT_{\\mathsf{cmn}} \\models_{\\mathsf{comm}} \\langle t_0, \\emptyset \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span>  as required.</li>
    </ul>

    <p class="text-gray-300">(2) In the case of two incoming edges, these are  <span class="math">seq[CT_E, t_E S_E]</span>  and msg[u, ch]. Similarly to the above,</p>

    <p class="text-gray-300">we deduce from conditions c(2)i and b(i) of Definition 3 that there exists a program  <span class="math">t_0</span>  such that  <span class="math">CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t_0, \\emptyset \\rangle \\to^* \\langle t, S \\rangle</span> . Moreover, by condition c(2)ii,  <span class="math">t = F[\\mathsf{recv} \\ \\mathsf{on} \\ ch]</span>  for some context F.</p>

    <p class="text-gray-300">By condition b(ii), the parent of the edge  <span class="math">\\mathsf{msg}[u, ch]</span>  is node of the form  <span class="math">(\\cdot, \\cdot, \\langle F_2[\\mathsf{send} \\ u \\ \\mathsf{on} \\ ch], \\cdot \\rangle, \\cdot)</span>  for some context  <span class="math">F_2</span> , and  <span class="math">CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{wf}} u</span> . Thus, by the induction hypothesis, u is well-traced in  <span class="math">CT_{\\mathsf{cmn}}</span> , and thus by COCOCOMM semantics,  <span class="math">CT, CT_{\\mathsf{cmn}} \\vdash \\langle F[\\mathsf{recv} \\ \\mathsf{on} \\ ch], S \\rangle \\to \\langle F[u], S \\rangle</span> . Concatenating these derivations, we get:  <span class="math">CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t_0, \\emptyset \\rangle \\to^* \\langle F[u], S \\rangle</span> . Also, by condition c(2)iii,  <span class="math">\\mathsf{check}(CT, \\langle F[u], S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W) = 1</span>  and thus by Lemma 1,  <span class="math">CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t_0, \\emptyset \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span>  as required.</p>

    <p class="text-gray-300">There remains to show that if  <span class="math">t&#x27; = F[\\mathbf{send}\\ v\\ \\mathbf{on}\\ ch]</span>  for some v, and  <span class="math">CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{wf}} v</span> , then v is well-traced. Indeed, since  <span class="math">\\mathbf{send}\\ v\\ \\mathbf{on}\\ ch</span>  adds v to the list of escaped values, we have  <span class="math">CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t_0 \\| \\mathsf{capture}, \\emptyset \\rangle \\to^* \\langle v, S&#x27; \\rangle</span> , and so by Theorem 1, v is well-traced.</p>

    <p class="text-gray-300">The key implication of this theorem is that to show that a received value is well-traced, it suffices to show that the computation that sent the value (and, transitively, any computation on which the sender depended) adhered to COCOTRUST semantics. We can achieve this by instantiating PCD appropriately, which we do in the following subsections.</p>

    <p class="text-gray-300">A corollary of this theorem is that in a distributed execution graph, any value sent or received is well-traced.</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> In a distributed execution graph, for every edge labeled msg[v, ch], v is well-traced in class table  <span class="math">CT_{cmn}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Consider the source node of an edge  <span class="math">\\operatorname{msg}[v,ch]</span> , and suppose it is  <span class="math">(CT,\\langle t,S\\rangle,\\langle t&#x27;,S&#x27;\\rangle,W)</span> . Term t' must be of the form  <span class="math">F[\\operatorname{send} v \\text{ on } ch]</span>  for some F. By the structure of the graph, and by Theorem 2 there is a program  <span class="math">t_0</span>  such that  <span class="math">CT,CT_{\\operatorname{cmn}} \\vdash_{\\operatorname{comm}} \\langle t_0,\\emptyset\\rangle \\to^* \\langle F[v],S&#x27;\\bullet[v]\\rangle</span> . By Theorem 1 we have that v is well-traced, as required.</p>

    <p class="text-gray-300"><strong>Modeling computation with distributed execution graphs</strong> In this paper distributed execution graphs define a model of concurrently executing, communicating COCOTRUST programs. Below, we argue informally that this is indeed a reasonable model of distributed computation.</p>

    <p class="text-gray-300">First, distributed execution graphs are &quot;intuitively sound,&quot; in the sense that every distributed execution graph maps to a scenario of parties executing COCOTRUST programs on distinct hardware and sending messages via a network. Second, they are &quot;intuitively complete,&quot; in the sense that given a pool of communicating COCOTRUST interpreters, we can construct a distributed execution graph representing this. Note that while formal soundness and completeness results could be proved with respect to a (for instance) CSP-style model of COCOTRUST, we would still need an informal argument to show that the CSP-style model itself is reasonable.</p>

    <p class="text-gray-300">Third, a distributed execution graph can be incrementally constructed as a system of COCOTRUST programs executes using the following process. As the programs execute they may nondeterministically perform the following actions on the distributed execution graph:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Add an unlabeled node (representing a prospective derivation)</li>
    </ol></li>
      <li>2. Add an edge labeled seq[CT, t, S] from a labeled node n to an unlabeled node n 0 (representing n 0 continuing evaluation from configuration ht, Si)</li>
      <li>3. Add an edge labeled msg[v, ch] from a labeled node n to an unlabeled node n 0 (representing n sending the value v to n <sup>0</sup> on channel ch)</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Label an unlabeled node (representing the actual derivation and nondeterministic choices)</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">This process can be more fully specified to ensure that the resulting distributed execution graph satisfies the appropriate constraints and accurately reflects the execution of the COCOTRUST programs.</p>

    <p class="text-gray-300">Proof Carrying Data (PCD), introduced by Chiesa and Tromer <a href="#page-32-4">[12,</a> <a href="#page-32-5">13]</a> and developed by Bitansky et al. <a href="#page-32-9">[7,</a> <a href="#page-32-3">8]</a>, is a cryptographic mechanism for ensuring that a given property is maintained at every step of a distributed computation among mutually-untrusting parties. The designated property is specified as a <em>compliance predicate</em>, and all messages between parties are accompanied by a proof that the message's data, along with all of the distributed computation leading to that message, satisfies the compliance predicate.</p>

    <p class="text-gray-300">We first recall the key definitions of PCD, which capture the notion of a distributed computation that is compliant with a designated property, and define a PCD system that proves and verifies such compliance. See Bitansky et al. <a href="#page-32-9">[7]</a> for formal definitions.<a href="#page-21-2">5</a></p>

    <p class="text-gray-300"><em>Distributed computation transcripts</em> Distributed computations are viewed as directed acyclic multigraphs with vertex labels and edge labels.<a href="#page-21-3">6</a> Vertices represent the computation of programs, and edges represent messages sent between these programs. Such graphs are called <em>distributed computation transcripts</em>.</p>

    <p class="text-gray-300">In our case, an &quot;honest&quot; distributed computation transcript will be a distributed execution graph. Thus, node labels should be of the form (CT,ht, Si,ht 0 , S<sup>0</sup> i, W), edge labels should be of the form seq[CT, t, S] or msg[v, ch], and the conditions in Definition <a href="#page-18-0">3</a> should hold. But <em>verifying</em> these conditions is up to the PCD system.</p>

    <p class="text-gray-300">In a <em>proof-carrying distributed computation transcript</em>, every edge label z<sup>i</sup> is augmented with another <em>proof string</em> label &pi;<sup>i</sup> . Figure <a href="#page-22-0">11</a> shows an example.</p>

    <p class="text-gray-300"><em>Compliance</em> A <em>compliance predicate</em> C is a polynomial-time computable predicate for a node in a distributed computation transcript. Intuitively, a compliance predicate is a locally verifiable property: the predicate can be checked using just information that is available at a node. By choosing an appropriate compliance predicate, global properties may hold if all nodes in a distributed transaction graph satisfy the compliance predicate.</p>

    <p class="text-gray-300">More precisely, C(zout; linp, ~zin) observes the local environment of a node in a distributed computation transcript: the list of received inputs ~zin; an (alleged) output zout; and the node's label, or <em>local input</em>,</p>

    <p class="text-gray-300"><sup>5</sup> We use the definitions of &quot;publicly-verifiable PCD system&quot; of Bitansky et al. <a href="#page-32-9">[7,</a> <a href="#page-32-3">8]</a> which, compared to Chiesa and Tromer <a href="#page-32-4">[12]</a>, do not assume a secure oracle/token; directly allow arbitrary node in-degree and out-degrees; and simplify the security quantification. We also make some simplifications, mentioned in subsequent footnotes where pertinent.</p>

    <p class="text-gray-300"><sup>6</sup> The definition of Bitansky et al. <a href="#page-32-9">[7]</a> requires source and sink nodes to be labeled &perp;. The restriction is inessential and we remove it here for convenience. Also, we identify &perp; with &empty;.</p>

    <p class="text-gray-300">    <img src="_page_22_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 11.</strong> Example of a proof-carrying distributed computation transcript. Node labels (&quot;local inputs&quot;) are denoted  <span class="math">\\operatorname{linp}_i</span> , edge labels  <span class="math">z_i</span> , and proof strings  <span class="math">\\pi_i</span> . Omitting proof strings gives the corresponding (non-proof-carrying) distributed computation transcript. When checking compliance of node  <span class="math">\\operatorname{linp}_H</span> ,  <span class="math">\\mathbb C</span>  checks the values marked by solid boxes. When <em>proving</em> compliance,  <span class="math">\\mathbb P_{\\mathbb C}</span>  additionally gets the incoming proofs, marked by dashed boxes, and outputs  <span class="math">\\pi_{11}</span> .</p>

    <p class="text-gray-300">denoted linp. The label linp contains the executed program and any associated local data (in our case, it will be the local class table CT, configurations  <span class="math">\\langle t, S \\rangle</span>  and  <span class="math">\\langle t&#x27;, S&#x27; \\rangle</span> , and trace-witness W). Given a distributed computation transcript DCT, we say that node n in DCT, with inputs  <span class="math">\\vec{z}_{in}</span>  and local input linp, is  <span class="math">\\mathbb{C}</span> -compliant if  <span class="math">\\mathbb{C}(z_{out}, \\mathsf{linp}, \\vec{z}_{in})</span>  holds for every output  <span class="math">z_{out}</span>  of n (see Figure 11). We say that DCT is  <span class="math">\\mathbb{C}</span> -compliant if every node in the graph is  <span class="math">\\mathbb{C}</span> -compliant. We say that a string z is  <span class="math">\\mathbb{C}</span> -compliant if there exists a  <span class="math">\\mathbb{C}</span> -compliant distributed computation transcript containing an edge labeled z.</p>

    <p class="text-gray-300"><strong>PCD</strong> syntax and operation A PCD system for a compliance predicate  <span class="math">\\mathbb{C}</span>  is a triple of algorithms  <span class="math">(\\mathbb{G}, \\mathbb{P}_{\\mathbb{C}}, \\mathbb{V}_{\\mathbb{C}})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>PCD generator</em>  <span class="math">\\mathbb{G}</span> , given an integer  <span class="math">\\kappa</span>  as a key size, outputs a key k which will be used by  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span>  to generate proofs and by  <span class="math">\\mathbb{V}_{\\mathbb{C}}</span>  to verify them.<sup>8</sup></li>
      <li><em>PCD prover</em>  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span> : Let k be a key, let  <span class="math">\\vec{z}_{\\mathsf{in}}</span>  be a list of inputs and  <span class="math">\\vec{\\pi}_{\\mathsf{in}}</span>  be corresponding proof strings, let linp be a local input string, and let  <span class="math">z_{\\mathsf{out}}</span>  be an output string. Then  <span class="math">\\mathbb{P}_{\\mathbb{C}}(k, \\vec{z}_{\\mathsf{in}}, \\vec{\\pi}_{\\mathsf{in}}, \\mathsf{linp}, z_{\\mathsf{out}})</span>  outputs a proof string  <span class="math">\\pi_{\\mathsf{out}}</span>  for the claim that  <span class="math">z_{\\mathsf{out}}</span>  is  <span class="math">\\mathbb{C}</span> -compliant.</li>
      <li><em>PCD verifier</em>  <span class="math">\\mathbb{V}_{\\mathbb{C}}</span> : Let k be a key, let  <span class="math">z_{\\mathsf{out}}</span>  be an output string and  <span class="math">\\pi_{\\mathsf{out}}</span>  a corresponding proof string. Then  <span class="math">\\mathbb{V}_{\\mathbb{C}}(k, z_{\\mathsf{out}}, \\pi_{\\mathsf{out}})</span>  is meant to accept only if convinced that  <span class="math">z_{\\mathsf{out}}</span>  is  <span class="math">\\mathbb{C}</span> -compliant.</li>
    </ul>

    <p class="text-gray-300">Using these algorithms, a distributed computation transcript is dynamically compiled into a <em>proof-carrying</em> distributed computation transcript by generating and adding &quot;on the fly&quot; a proof string to each edge (see Figure 11). The process of generating proof strings is defined inductively, starting from the source nodes in the transcript graph. Consider a node n in the transcript, with local input linp, received inputs  <span class="math">\\vec{z}_{\\text{in}}</span>  and corresponding proofs  <span class="math">\\vec{\\pi}_{\\text{in}}</span> , and an output  <span class="math">z_{\\text{out}}</span> . Use prover  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span>  to produce a new proof string  <span class="math">\\pi_{\\text{out}}</span>  for its output  <span class="math">z_{\\text{out}}</span>  (given the inputs of n, their corresponding generated proof strings, the program of n, and its output). Proof strings generated in this way form the additional label on the edges in the resulting proof-carrying transcript.</p>

    <p class="text-gray-300">The triple  <span class="math">(\\mathbb{G}, \\mathbb{P}_{\\mathbb{C}}, \\mathbb{V}_{\\mathbb{C}})</span>  must satisfy three properties. The first two bound the complexity of proving and verifying, and the third is computational soundness, discussed next.</p>

    <p class="text-gray-300">Completeness and asymptotically-efficient proving The PCD prover can prove true statements, and do so efficiently. Whenever it is indeed the case that a given distributed computation transcript is  <span class="math">\\mathbb{C}</span> -compliant,</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{\\phantom{a}}</span>  In Bitansky et al. [7], the edge labeled z should be the first one entering a sink, but this is inessential since one can consider the subgraph leading to this edge.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup> For simplicity, we merge the &quot;reference string&quot;  <span class="math">\\sigma</span>  and &quot;verification state&quot;  <span class="math">\\tau</span>  of Bitansky et al. [7] into a single key k.</p>

    <p class="text-gray-300">one can use the PCD prover  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span>  to generate proof strings for each message, and all of these proof strings will be accepted by the PCD verifier. The generation of these proofs runs in time that is polynomial in the key size  <span class="math">\\kappa</span>  and the time it took to run  <span class="math">\\mathbb{C}</span>  at every node in the distributed computation transcript.</p>

    <p class="text-gray-300"><strong>Efficient verification</strong> Proof strings generated by the PCD prover have length polynomial in the key size  <span class="math">\\kappa</span> , and are <em>efficiently verifiable</em> by the PCD verifier:  <span class="math">\\mathbb{V}_{\\mathbb{C}}(k, z_{\\text{out}}, \\pi_{\\text{out}})</span>  runs in time polynomial in  <span class="math">\\kappa</span>  and the length of the string  <span class="math">z_{\\text{out}}</span> . In particular, the proof length and verification time are independent of how long it took to evaluate  <span class="math">\\mathbb{C}</span>  and run  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span> .</p>

    <p class="text-gray-300"><strong>Soundness notion</strong> <sup>11</sup> It is computationally infeasible to prove false statements. This is expressed as follows. Let  <span class="math">\\tilde{\\mathbb{P}}</span>  be any efficient cheating prover, i.e., a deterministic algorithm running in time polynomial in the key size  <span class="math">\\kappa</span> . <sup>12</sup> After a key  <span class="math">k \\leftarrow \\mathbb{G}(1^{\\kappa})</span>  is randomly generated,  <span class="math">\\tilde{\\mathbb{P}}(k)</span>  outputs some non-compliant string z along with a proof string  <span class="math">\\pi</span> , and tries to use  <span class="math">\\pi</span>  to falsely convince  <span class="math">\\mathbb{V}_{\\mathbb{C}}</span>  that z is compliant. Then, we are guaranteed that  <span class="math">\\mathbb{V}_{\\mathbb{C}}(k,z,\\pi)</span>  will accept this false claim with negligible probability  <span class="math">\\kappa^{-\\omega(1)}</span>  (i.e., smaller than  <span class="math">1/p(\\kappa)</span>  for any polynomial p). Formally:</p>

    <p class="text-gray-300"><strong>Definition 4</strong> (PCD soundness).  <span class="math">(\\mathbb{G}, \\mathbb{P}_{\\mathbb{C}}, \\mathbb{V}_{\\mathbb{C}})</span>  is sound if for every efficient cheating-prover algorithm  <span class="math">\\tilde{\\mathbb{P}}</span>  and key size  <span class="math">\\kappa \\in \\mathbb{N}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{k \\leftarrow \\mathbb{G}(1^{\\kappa})} \\left[ \\begin{array}{c} (z, \\pi) \\leftarrow \\tilde{\\mathbb{P}}(k) \\\\ \\wedge \\quad \\mathbb{V}_{\\mathbb{C}}(k, z, \\pi) = 1 \\\\ \\wedge \\quad z \\text{ is not } \\mathbb{C}\\text{-compliant} \\end{array} \\right] \\leq \\kappa^{-\\omega(1)}</span>$</p>

    <p class="text-gray-300">Construction of PCD There are two known approaches to constructing PCD systems. The first, sketched in Section 2, is based on probabilistically-checkable proofs (PCPs). It relies on standard cryptographic assumptions (collision-resistant hashing and signatures), and requires parties to have access to a trusted oracle (e.g., a secure hardware token or trusted network service) that signs its inputs and produces fresh randomness. An asymptotically-efficient construction is known [12], and there has been recent progress towards the requisite concretely-efficient PCPs [2].</p>

    <p class="text-gray-300">An alternative approach starts with the special case of PCD for a single message, called <em>computationally-sound proofs of knowledge</em> [33] or <em>Succinct Non-interactive ARguments of Knowledge (SNARKs)</em> which can be constructed without any trusted oracles, under a large class of assumptions [6]. SNARKs have been recently implemented for C programs [3, 4] and a restricted subset thereof [40], using approaches based on knowledge-of-exponent assumptions [26][31][23][9], in the relaxed &quot;preprocessing&quot; sense, where  <span class="math">\\mathbb G</span>  is allowed to run for time polynomial in that of  <span class="math">\\mathbb C</span> . These are practical for very small programs, and research efforts are underway to improve efficiency. Using bootstrapping [8], such SNARKs (in principle) suffice to construct PCD systems without oracles, for a restricted but large set of distributed execution graph structures.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup> The formal definition of completeness requires a precise description of the inductive process of proof generation, and is thus straightforward but long; see Bitansky et al. [7, &sect;5.2].</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;10</sup> For simplicity of presentation, we assume here that the potential adversary's power is greater than all &quot;honest&quot; computations that will be proven, and the key size  <span class="math">\\kappa</span>  is chosen large enough to be secure against such adversaries. Since the adversary's power is at most  <span class="math">\\operatorname{poly}(\\kappa)</span> , the length of honest computation can be upper-bounded by  <span class="math">B = \\kappa^{\\log \\kappa}</span>  (or any other superpolynomial subexponential function), and thus the  <span class="math">\\log B</span>  terms in the proof length and verifier complexity expressions of Bitansky et al. [7] are dominated by  <span class="math">\\kappa</span>  and can be omitted.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup> Soundness is implied by the stronger &quot;proof of knowledge&quot; proved in Bitansky et al. [7, 8], Chiesa and Tromer [12]. For simplicity, in the following we discuss mere soundness, but our construction also offers proof of knowledge (see Section 7).</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{12}&lt;/sup&gt;</span>  Or more, generally, a family of circuits, one for each  <span class="math">\\kappa</span> , whose size is polynomial in  <span class="math">\\kappa</span> .</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8"><strong>6.2</strong> A compliance predicate for well-tracedness</h3>

    <p class="text-gray-300">We shall use PCD to prove well-tracedness of values sent by a system of communicating COCOCOMM programs. A common class table  <span class="math">CT_{\\mathsf{cmn}}</span>  will be fixed in advance, and every value v sent during an (honest) execution will accompanied by a proof that v is well-traced in  <span class="math">CT_{\\mathsf{cmn}}</span> .</p>

    <p class="text-gray-300">Consider a system of communicating COCOCOMM programs using common class table  <span class="math">CT_{\\rm cmn}</span> , that sends value v from one party to another on channel ch. If this computation is honest, then by the completeness of distributed execution graphs, there is a distributed execution graph DEG with an edge labeled  <span class="math">{\\rm msg}[v,ch]</span> . We shall define a PCD compliance predicate  <span class="math">{\\mathbb C}_{\\rm cmn}</span>  that enables efficiently proving the existence of such a DEG.</p>

    <p class="text-gray-300">The compliance predicate  <span class="math">\\mathbb{C}_{cmn}</span>  will be applied to the nodes of a distributed computation transcript that is <em>allegedly</em> a distributed execution graph. The role of  <span class="math">\\mathbb{C}_{cmn}</span>  is to check that the nodes in the transcript indeed fulfill the constraints defined in Definition 3, i.e., that each node's label describes a correct Coco-TRUST derivation that is consistent with the incoming and outgoing edges' labels.</p>

    <p class="text-gray-300"><strong>Definition 5</strong> (Compliance predicate enforcing  <span class="math">CT_{cmn}</span> ). For a COCO class table  <span class="math">CT_{cmn}</span> , the compliance predicate enforcing  <span class="math">CT_{cmn}</span>  is denoted  <span class="math">\\mathbb{C}_{cmn}</span> . Given local input linp, inputs  <span class="math">\\vec{z}_{in}</span>  and (alleged) output  <span class="math">z_{out}</span> ,  <span class="math">\\mathbb{C}_{cmn}(z_{out}, \\text{linp}, \\vec{z}_{in})</span>  accepts if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>linp is the form  <span class="math">(CT, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W)</span>  where CT is a class table, t and t' are terms, S and S' are lists of values, and  <span class="math">W \\in W</span>  is a trace-witness, and for these:</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Condition b(i) or b(ii) from Definition 3 holds, and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Condition c(0), c(1), or c(2) from Definition 3 holds.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">CT_{cmn}</span>  be a COCO class table. Then every  <span class="math">\\mathbb{C}_{cmn}</span> -compliant distributed computation transcript is also a distributed execution graph using  <span class="math">CT_{cmn}</span> , and vice versa.</p>

    <p class="text-gray-300">The above is obvious from the definitions. Thus:</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let  <span class="math">CT_{\\mathsf{cmn}}</span>  be a Coco class table, let v be a value, and ch a channel. If  <span class="math">z = \\mathsf{msg}[v, ch]</span>  is  <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span> -compliant then v is well-traced in  <span class="math">CT_{\\mathsf{cmn}}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> As z is  <span class="math">\\mathbb{C}_{cmn}</span> -compliant, there exists a  <span class="math">\\mathbb{C}_{cmn}</span> -compliant distributed computation transcript DCT containing an edge labeled z. By Lemma 2, DCT is a distributed execution graph using  <span class="math">CT_{cmn}</span> , and thus by Corollary 1, v is well-traced in  <span class="math">CT_{cmn}</span> .</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Verifying well-tracedness</h3>

    <p class="text-gray-300">By plugging compliance predicate  <span class="math">\\mathbb{C}_{cmn}</span>  into a PCD construction, we obtain a PCD system ( <span class="math">\\mathbb{G}, \\mathbb{P}_{\\mathbb{C}_{cmn}}, \\mathbb{V}_{\\mathbb{C}_{cmn}}</span> ). This PCD system is both sound and complete for efficiently verifying well-tracedness of values. This means that given a well-traced value v, it is possible to construct a proof that v is well-traced, and if we accept a proof that v is well-traced, then it is indeed well-traced (up to a negligible probability of error). This is key to enforcing COCOCOMM semantics, which we will see in Section 6.4.</p>

    <p class="text-gray-300"><strong>Soundness for well-tracedness</strong> To verify well-tracedness of a value v with a proof  <span class="math">\\pi</span> , we run  <span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(k, \\mathsf{msg}[v, ch], \\pi)</span> , where k is the key generated by  <span class="math">\\mathbb{G}</span>  (the channel ch does not matter, but is syntactically necessary since  <span class="math">\\mathbb{V}_{\\mathbb{C}}</span>  expects to verify edge labels of a distributed execution graph). Soundness of the PCD system means that if an efficient cheating-prover algorithm generates a string  <span class="math">z = \\mathsf{msg}[v, ch]</span>  claiming that v is well-traced, along with an alleged proof  <span class="math">\\pi</span>  for this (as before ch does not matter), but v is actually not well-traced, then  <span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(z,\\pi)</span>  will accept only with negligible probability (smaller than any  <span class="math">1/\\mathsf{poly}(\\kappa)</span> ). Formally:</p>

    <p class="text-gray-300"><strong>Theorem 3</strong> (Soundness of PCD for well-tracedness). For any COCO class table  <span class="math">CT_{cmn}</span> , any efficient cheating-prover algorithm  <span class="math">\\tilde{\\mathbb{P}}</span> , and every key size  <span class="math">\\kappa</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{k \\leftarrow \\mathbb{G}(1^{\\kappa})} \\left[ \\begin{array}{c} (z,\\pi) \\leftarrow \\tilde{\\mathbb{P}}(k) \\\\ \\wedge \\ \\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(k,z,\\pi) = 1 \\\\ \\wedge \\ \\exists v, ch : z = (\\mathsf{msg}[v,ch]) \\\\ \\wedge \\ v \\ \\textit{is not well-traced in } CT_{\\mathsf{cmn}} \\end{array} \\right] \\leq \\kappa^{-\\omega(1)}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The soundness of the PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}_{\\mathbb{C}}, \\mathbb{V}_{\\mathbb{C}})</span> , according to Definition 4, means that whenever the verifier accepts  <span class="math">(z, \\pi)</span> , it's true that z is  <span class="math">\\mathbb{C}_{cmn}</span> -compliant (up to negligible probability). By Lemma 3, if  <span class="math">z = \\mathsf{msg}[v, ch]</span>  then v is well-traced in  <span class="math">CT_{cmn}</span>  (up to negligible probability).</p>

    <p class="text-gray-300"><strong>Completeness for well-tracedness</strong> The PCD system is complete in that if we have a well-traced value with a known derivation, then we can efficiently produce a proof for its well-tracedness:</p>

    <p class="text-gray-300"><strong>Theorem 4</strong> (Completeness of PCD for well-tracedness). Let  <span class="math">CT_{cmn}</span>  be a COCO class table, and let v be a well-traced value in  <span class="math">CT_{cmn}</span> , witnessed by  <span class="math">CT&#x27; \\vdash \\langle t, \\emptyset \\rangle \\to^* \\langle v, S \\rangle</span>  where CT' is a COCO class table such that  <span class="math">CT&#x27; \\supseteq CT_{cmn}</span> . Consider the COCOTRUST execution</p>

    <p class="text-gray-300"><span class="math">$CT&#x27;, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{trust}} \\langle \\mathsf{send}\\ t\\ \\mathsf{on}\\ ch, \\emptyset \\rangle \\to^* \\langle v, S \\bullet [v] \\rangle</span>$</p>

    <p class="text-gray-300">Let W be the trace-witness corresponding to the above derivation (by Proposition 2) and let linp =  <span class="math">(CT, \\langle send \\ t \\ on \\ ch, \\emptyset \\rangle, \\langle v, S \\bullet [v] \\rangle, W)</span> .</p>

    <p class="text-gray-300">Then for any key size  <span class="math">\\kappa</span>  and key  <span class="math">k \\leftarrow \\mathbb{G}(1^{\\kappa})</span> , the proof  <span class="math">\\pi = \\mathbb{P}_{\\mathbb{C}_{\\mathsf{cmn}}}(k,\\emptyset,\\emptyset,\\mathsf{linp},\\mathsf{msg}[v,ch])</span>  is always accepted:</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{V}_{\\mathbb{C}_{\\mathrm{cmn}}}(k, \\mathrm{msg}[v, ch], \\pi) = 1.</span>$</p>

    <p class="text-gray-300">Moreover,  <span class="math">\\pi</span>  is computed in time polynomial in the size of the derivation  <span class="math">CT \\vdash \\langle t, \\emptyset \\rangle \\rightarrow^* \\langle v, S \\rangle</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Consider the graph DEG consisting of a node labeled linp, with no input edges, and single outgoing edge labeled z going to another node labeled  <span class="math">(CT_{\\mathsf{cmn}}, \\langle \\mathsf{recv} \\ \\mathsf{on} \\ ch, \\emptyset \\rangle, \\langle v, \\emptyset \\rangle, \\emptyset)</span> . It is readily verified to be a distributed execution graph using  <span class="math">CT_{\\mathsf{cmn}}</span> , and thus by Lemma 2, DEG is also a  <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span> -compliant distributed computation transcript. The claim then follows from the completeness of the PCD system. Efficiency follows from  <span class="math">\\mathbb{P}_{\\mathbb{C}_{\\mathsf{cmn}}}</span>  being polynomial-time in its inputs, and the size of W being polynomial in the size of the derivation.</p>

      <h3 id="sec-6.4" class="text-xl font-semibold mt-8">6.4 Verifying correctness of COCOCOMM executions</h3>

    <p class="text-gray-300">The PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}_{\\mathbb{C}_{cmn}}, \\mathbb{V}_{\\mathbb{C}_{cmn}})</span>  can be used to verify the correct execution of a number of parties, each of which is executing its own CocoComm program. That is, we can use the PCD system to build a runtime system for CocoComm that correctly enforces semantics even when non-well-traced values are received from rogue parties.</p>

    <p class="text-gray-300"><strong>Soundness for CocoComm executions</strong> A party who performs a CocoTrust evaluation, and uses  <span class="math">\\mathbb{V}_{\\mathbb{C}_{cmn}}</span>  to verify every received value, can rest assured that (except with negligible probability) the evaluation follows the stricter CocoComm semantics: the probability that  <span class="math">\\mathbb{V}_{\\mathbb{C}_{cmn}}</span>  accepts all received values, and yet the evaluation violates CocoComm semantics, is negligible (smaller than any  <span class="math">1/\\text{poly}(\\kappa)</span> ). Formally:</p>

    <p class="text-gray-300"><strong>Theorem 5</strong> (Soundness of verifying COCOCOMM). Consider a COCOTRUST derivation:</p>

    <p class="text-gray-300"><span class="math">$CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{trust}} \\langle t, S \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span>$</p>

    <p class="text-gray-300">Let  <span class="math">(v_i, ch_i)_{i=1}^{\\ell}</span>  be the list of values, and corresponding channels, received in this derivation. Then for any efficient cheating-prover algorithm  <span class="math">\\tilde{\\mathbb{P}}&#x27;</span> , and every key size  <span class="math">\\kappa</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{k \\leftarrow \\mathbb{G}(1^\\kappa)} \\left[ \\begin{array}{c} \\pi_i \\leftarrow \\tilde{\\mathbb{P}}&#x27;(k,i) \\text{ for } 1..\\ell \\\\ \\wedge \\ \\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}} \\big( k, \\ \\mathsf{msg}[v_i, ch_i] \\, \\pi_i \\big) = 1 \\text{ for } 1..\\ell \\\\ \\wedge \\ \\neg \\ CT, CT_{\\mathsf{cmn}} \\mid_{\\mathsf{comm}} \\langle t, S \\rangle \\rightarrow^* \\langle t&#x27;, S&#x27; \\rangle \\end{array} \\right] \\leq \\kappa^{-\\omega(1)}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The only difference between the semantics of COCOCOMM and COCOTRUST is the premise of the <strong>recv</strong> rule, so the above probability is bounded by:</p>

    <p class="text-gray-300"><span class="math">$\\leq \\Pr_{k \\leftarrow \\mathbb{G}(1^{\\kappa})} \\left[ \\begin{array}{c} \\pi_{i} \\leftarrow \\tilde{\\mathbb{P}}&#x27;(k,i) \\text{ for } 1..\\ell \\\\ \\wedge \\ \\exists i \\in 1..\\ell : \\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}} \\big(k, \\, \\mathsf{msg}[v_{i}, ch_{i}] \\, \\pi_{i} \\big) = 1 \\\\ \\wedge \\ v_{i} \\text{ is not well-traced in } CT_{\\mathsf{cmn}} \\end{array} \\right]</span>$</p>

    <p class="text-gray-300">Invoking the union bound on the events for separate i:</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sum_{i=1}^{\\ell} \\Pr_{k \\leftarrow \\mathbb{G}(1^{\\kappa})} \\left[ \\begin{array}{c} \\pi_{i} \\leftarrow \\tilde{\\mathbb{P}}&#x27;(k,i) \\\\ \\wedge \\ \\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(k, \\, \\mathsf{msg}[v_{i}, \\, ch_{i}] \\, \\pi_{i}) = 1 \\\\ \\wedge \\ v_{i} \\ \\mathsf{is \\ not \\ well-traced \\ in} \\ CT_{\\mathsf{cmn}} \\end{array} \\right]</span>$</p>

    <p class="text-gray-300">and invoking Theorem 3 (with  <span class="math">\\tilde{\\mathbb{P}}</span>  derived from  <span class="math">\\tilde{\\mathbb{P}}&#x27;</span>  by hardcoding i and  <span class="math">z = \\text{msg}[v_i, ch_i]</span> ):</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sum_{i=1}^{\\ell} \\kappa^{-\\omega(1)} \\leq \\kappa^{-\\omega(1)}</span>$</p>

    <p class="text-gray-300"><strong>Proof generation</strong> Generating the above proof requires an inductive process accompanying the whole computation. Every time a party in the computation sends a message (msg edge) or pauses its derivation to receive a message (seq edge), it will run the PCD prover  <span class="math">\\mathbb{P}_{\\mathbb{C}_{cmn}}</span>  to produce a proof that the computation was correct so far. Thus, we modify the process for incremental generation of a distributed execution graph (Section 5.2) to ensure that each edge also has a proof associated with it.<sup>13</sup> Initially, we run the PCD generator  <span class="math">\\mathbb{G}</span>  with a sufficiently large key size  <span class="math">\\kappa</span>  to obtain a key  <span class="math">k \\leftarrow \\mathbb{G}(1^{\\kappa})</span> . Then we run the following <em>proof generation</em> process: every time a new edge is added (Operations 2 and 3), with edge label  <span class="math">z_{out}</span> , exiting a node labeled linp =  <span class="math">(CT, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W)</span>  whose incoming edges are labeled  <span class="math">\\vec{z}_{in}</span>  with associated proofs  <span class="math">\\vec{\\pi}_{in}</span> , we generate the proof  <span class="math">\\pi = \\mathbb{P}_{\\mathbb{C}_{cmn}}(k, \\vec{z}_{in}, \\vec{\\pi}_{in}, \\lim, z_{out})</span>  and associate  <span class="math">\\pi</span>  with the edge. (See Section 2 for a more concrete but less precise account.)</p>

    <p class="text-gray-300"><strong>Completeness for CocoComm executions</strong> The proofs constructed as above are indeed accepted by the PCD verifier (which follows easily from PCD completeness):</p>

    <p class="text-gray-300"><strong>Theorem 6</strong> (Completeness of verifying COCOCOMM). Let DEG be a distributed execution graph using COCO class table  <span class="math">CT_{cmn}</span> . Consider an edge e in DEG, labeled z, from node n to node n'. Consider any key size  <span class="math">\\kappa</span>  and key  <span class="math">k \\leftarrow \\mathbb{G}(1^{\\kappa})</span> . Let  <span class="math">\\pi</span>  be a proof associated with e by the above proof generation process. Then  <span class="math">\\pi</span>  is accepted:  <span class="math">\\mathbb{V}_{\\mathbb{C}_{cmn}}(k, z, \\pi) = 1</span> .</p>

    <p class="text-gray-300">Moreover, the running time of the proof generation process for edge e is polynomial in the size of the derivation associated with node n.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;13</sup> For a general formal treatment, see the ProofGen process in Bitansky et al. [7].</p>

    <p class="text-gray-300"><em>Proof.</em> Consider DEG<sup>0</sup> , the subgraph of DEG consisting of n 0 , and all nodes that can reach n 0 (which of course includes n). DEG<sup>0</sup> is also a distributed execution graph using CTcmn, and is thus a Ccmn-compliant distributed computation transcript. Acceptance of &pi; thus follows from the completeness property of PCD (observing that the aforementioned proof generation process is essentially identical to the ProofGen process of Bitansky et al. <a href="#page-32-9">[7]</a>).</p>

    <p class="text-gray-300">Let the label of n be (CT,ht, Si,ht 0 , S<sup>0</sup> i, W); then efficiency follows from PCcmn being polynomialtime in its inputs, and the size of W being polynomial in the size of the derivationto which it attests.</p>

    <p class="text-gray-300"><em>Remarks</em> In the above soundness definitions, the received values are independent of the PCD key k. The stronger property of adaptive soundness, where v<sup>i</sup> and ch<sup>i</sup> (and thus the resulting derivation) are allowed to depend on k, holds as well (due to the adaptive soundness of the underlying PCD system).</p>

    <p class="text-gray-300">A natural optimization is the case where, in a distributed computation, there exists a clique of trusted parties Q that trust each other, but not others. The parties in Q can then verify messages received from outside Q, but omit verification of messages within Q, and still deduce that their (various) derivations follow COCOCOMM semantics.</p>

    <p class="text-gray-300">COCO is an intentionally minimal calculus, intended to capture essential language features and match them to the PCD formalism, while maintaining simplicity. However, our techniques can be extended to handle more expressive language features, and to provide stronger guarantees for consumers of verified values.</p>

    <p class="text-gray-300">Imperative state, including a heap, can be added in a straightforward manner. State is threaded through the operational semantics of the language (as with the list of escaped values), and sent values are accompanied by a heap, which includes all locations that are transitively reachable from the value. When a value and heap are received, locations in the received heap are renamed to ensure disjointness from the current heap, and then the received heap is unioned with the current heap. The definition of distributed execution graphs is extended to enforce state consistency.</p>

    <p class="text-gray-300">With the addition of state, we would no longer require the use of escape and capture terms to help define well-tracedness, since the language would now contain another, more standard, mechanism by which values may escape the dynamic scope of an owning class.</p>

    <p class="text-gray-300">Concurrency is already modeled by the nondeterministic choice operator <sup>s</sup>8t, although threads are not guaranteed to run to completion. This can be remedied by adding a concurrent composition operator. Additional mechanisms for synchronization and communication between threads could also be added.</p>

    <p class="text-gray-300">Evolution of values from known past ones (e.g., showing that the computation to produce value v <sup>0</sup> used value v) is a stronger property than well-tracedness (which allows an arbitrary semanticallyallowed history). For example, consider a protocol for a <em>chess game</em> (as opposed to the aforementioned <em>chess puzzle</em>), where White sends value v describing a board, subsequently receives value v 0 supposedly representing the board after Black's move, and wishes to ensure that v 0 is actually the result of a computation that starts with v and legally moves a single Black piece to produce v 0 .</p>

    <p class="text-gray-300">Such properties can be enforced using mechanisms within the programming language, and do not require modifications to the language, or to the runtime mechanism for enforcing well-tracedness. One approach is to ensure that classes in CTcmn contain a field that is an append-only log of past states (or a cryptographic compression thereof, using hash functions), and the field is updated appropriately by methods of the class. For example, an object representing a chess board may contain a log of all previous chess boards that led up to it. This ensures that the object itself is recording its evolution, and welltracedness suffices to allow reasoning about the evolution of the value.</p>

    <p class="text-gray-300">Another approach is to add a field id to a class, and the value of this field is only modified by method setId(r) { return (this with {id = owf(r)}); } where owf is a cryptographic one-way hash function. Given an object v with a particular value n for the field id, v was produced either by evolution from another object v <sup>0</sup> with id equal to n, or by a computation that knows a value i such that owf(i)= n. For example, White sets the id field of a board v by calling setId(r) with a large random integer r, and upon receiving v 0 , verifies that v 0 .getId()=v.getId(). Either v 0 evolved from v, or Black found a preimage of owf, which is by definition infeasible.</p>

    <p class="text-gray-300">Enforcing encapsulation by the language semantics, along with enforcing of those semantics, enable local language-level reasoning about received values. However, in Java, it is difficult to enforce encapsulation, due to reflection. In order for our technique to be useful, we anticipate that it will be necessary to restrict the use of reflection and any other mechanisms that may violate encapsulation, or otherwise prevent local reasoning. Indeed, many sophisticated Java language analyses are sound only in the absence of reflection.</p>

    <p class="text-gray-300">Note that in our setting we use encapsulation to enforce integrity: ensuring that values of fields of objects are consistent with using the public interface of the object. We are not able to use encapsulation to enforce confidentiality, since a malicious party receiving an object could always violate language semantics to <em>examine</em> the values of fields of that object (e.g., by peeking into the interpreter's in-memory representation of values). PCD will only detect violation of language semantics if the malicious party attempts to send a non-well-traced value.</p>

    <p class="text-gray-300">Interaction with the external environment can be modeled in COCO by treating inputs as nondeterministic choices. However, this does not <em>enforce</em> that choice resolution is &quot;truly external.&quot; To do so we could add input operators to COCO, and make the PCD compliance predicate verify inputs are cryptographically signed by suitable input devices, parties in the environment, etc.</p>

    <p class="text-gray-300">Proof of knowledge is a security property of computational proof systems that is stronger than mere soundness. At times, there is a difference between proving that value v is well-traced and proving that one <em>knows</em> a program that (efficiently) produces v. This is especially true in programs that use cryptography. For example, consider the class BobPayment which sets its field amount to an integer i only when a method BobPayment.check is called with arguments i and u, where u is a digital signature on i that verifies under Bob's (hard-coded) signature verification key. Suppose Alice sends Bob the value v = {BobPayment | amount=1000000 } and a proof that v is well-traced. Should Bob be convinced that he owes her $1M? Clearly a valid signature on &quot;1000000&quot; <em>exists</em>, so v is trivially well-traced regardless of whether Alice actually received the signature. However Alice cannot <em>efficiently compute</em> the signature by herself, so if she <em>efficiently</em> produced v following COCO semantics, then Bob should indeed be convinced. Our proof system indeed (nontrivially) supports reasoning about the computational complexity of producing values. PCD systems offer, beyond mere soundness, the guarantee of <em>proof of knowledge</em> <a href="#page-32-9">[7]</a>, which implies essentially the following: whenever the verifier accepts, VCcmn (k, msg[v, ch], &pi;) = 1, the (possibly cheating) prover that produced &pi; actually &quot;knows&quot; the full derivation of the value v and &quot;could have&quot; written it down with similar complexity.</p>

    <p class="text-gray-300">Zero-knowledge is another useful property of proof systems, meaning essentially that when the verifier accepts, all it learns is that the value is well-traced, and nothing else about its derivation. In particular, if the sender had secrets, they are not revealed by the proof he produces, a desirable property in any other application where a party has proprietary algorithms or private data (such as the chess puzzle example of the Introduction). Our approach provides zero knowledge when invoked using suitable PCD systems <a href="#page-32-9">[7]</a> or SNARKs <a href="#page-32-6">[3,</a> <a href="#page-32-7">4,</a> <a href="#page-33-3">40]</a>.</p>

    <p class="text-gray-300"><em>Verifiable computing</em> The Proof-Carrying Data mechanism lies in the broad area of verifiable computing, which has been extensively studied from a cryptographic perspective. Verifying general, distributed interaction requires the full power of PCD systems whose construction was discussed in Section <a href="#page-23-0">6.1.</a></p>

    <p class="text-gray-300">An important special case is Succinct Noninteractive Arguments of Knowledge (SNARKs) which, beside being an ingredient for PCDs as discussed in Section <a href="#page-23-0">6.1,</a> are also of direct use for proving correct execution of stand-alone programs (e.g., outsourcing a computational task to a cloud server, and requiring a proof of the results' correctness). Recently, concrete SNARK systems were implemented for proving correct execution of C programs. One is restricted to constant memory access and control flow <a href="#page-33-3">[40]</a>, and another supports arbitrary control flow and memory accesses (by implementing a simulated random-access machine) <a href="#page-32-7">[4]</a> and even self-modifying code <a href="#page-32-6">[3]</a>. Those works focus on the cryptographic and algorithmic implementations and are complementary to the present paper. In particular, they consider only the case of stand-alone programs (rather than distributed computation), and do not address issues of enforcing well-tracedness and invariants of values, for which the C language is unsuitable due to lack of strong encapsulation. Our work can thus be construed as looking ahead to potential uses and a program analysis approach for exploiting the &quot;raw power&quot; of the cryptographic implementations, once they achieve full PCD and sufficient efficiency.</p>

    <p class="text-gray-300">If one relaxes the requirements to allow the verifier to send queries back to the prover (instead of proofs piggy-backing on existing messages), then <em>interactive proof systems</em> are relevant, including recent highly-optimized implementations (see Vu et al. <a href="#page-34-2">[49]</a> and references therein). If one further relaxes the verifier efficiency requirement, then many <em>secure multiparty computation</em> and <em>secure function evaluation</em> techniques become relevant. When simultaneously verifying many claims, one can use efficient <em>batching arguments</em> (see Setty et al. <a href="#page-34-3">[44]</a> and references therein). Some restricted classes of computation, such as those expressible as low-depth circuits, have especially efficient proof systems <a href="#page-33-11">[24]</a> which were recently implemented (see Thaler <a href="#page-34-4">[46]</a> and references therein).</p>

    <p class="text-gray-300"><em>Automatic program partitioning</em> Jif/Split <a href="#page-34-5">[51,</a> <a href="#page-34-6">52]</a> automatically partitions single-threaded programs annotated with security types <a href="#page-34-7">[42]</a> into a program distributed across potentially mutually distrusting host machines. The partitioning ensures that if computation of a value is declared to be independent of a given host, then that host is unable to corrupt or influence the computation of the value. This enables sound reasoning at the language-level of abstraction about the distributed computation: the value computed by the distributed system will be the same as the value computed by the single-threaded program unless one or more of the hosts upon which the computation depends (as indicated by the security-type annotations) is malicious. In Jif/Split, if a host is corrupted, then no computation they perform can be trusted. By contrast, our system allows trust to be gained in computation performed by a corrupted or malicious host: values received from hosts are checked to ensure they are well-traced, which enables sound reasoning about properties that the value must satisfy. However, our system is not suitable for restricting the flow of information in a distributed system, and is thus, is not suitable for enforcing confidentiality requirements.</p>

    <p class="text-gray-300"><em>Enforcing language semantics</em> Our work ensures that values received over a network were produced according to COCOCOMM semantics, thus enabling sound reasoning about such values at the level of language abstractions, even in the presence of malicious parties. We do not know of existing work exploring this problem.</p>

    <p class="text-gray-300">Much previous work seeks to enforce language-level semantics in different settings, typically on a single execution platform, or against different classes of faults.</p>

    <p class="text-gray-300">Safe deserialization of objects, as discussed in Section <a href="#page-2-0">1,</a> is extensively discussed in Bloch's book on practical Java programming <a href="#page-32-1">[10,</a> Chapter 11]. Pointing out that &quot;serialization is an extralinguistic mechanism for creating objects&quot;, Bloch presents several attacks that cause objects to be deserialized into a state that cannot be reached through their public interfaces (i.e., attacks that create non-welltraced objects). Although Bloch describes methods for defensive programming to avoid these attacks, the solutions are manual and error-prone. Similar concerns are raised in CERT's Secure Coding Standard for Java entries SER06-J and SER07-J <a href="#page-32-2">[11]</a>, in Common Weakness Enumeration entry CWE-502 <a href="#page-33-0">[34]</a>, and the references therein.</p>

    <p class="text-gray-300">Numerous works seek to enforce memory safety in C and C-like programs, including CCured <a href="#page-33-12">[37]</a>, Cyclone <a href="#page-33-13">[25,</a> <a href="#page-33-14">28]</a>, and SAFECode <a href="#page-32-13">[18,</a> <a href="#page-32-14">19]</a>. SAFECode in particular states that their mechanism enables certain analyses to be sound (points-to graph, call graph, and a subset of type information).</p>

    <p class="text-gray-300">Perry et al. <a href="#page-34-8">[41]</a> present a type system that can detect transient hardware faults (a single local corruption) in assembly programs, by maintaining redundant copies of the computations and enforcing their consistency.</p>

    <p class="text-gray-300">Work on certified compilation (e.g., <a href="#page-32-15">[5,</a> <a href="#page-32-16">14,</a> <a href="#page-32-17">15,</a> <a href="#page-33-15">30]</a>) seeks to ensure that program semantics is preserved as the program is compiled.</p>

    <p class="text-gray-300"><em>Ensuring integrity</em> Various language-based techniques have attempted to ensure the <em>integrity</em> of computation or the values they create. For example, automated program partitioning <a href="#page-34-6">[52]</a> allows a distributed computation to be written as a single program with security types, and is compiled so that only sufficiently trusted hosts may handle high-integrity data and computation. Likewise, evidence-based audit <a href="#page-34-0">[48]</a> allows programs to automatically verify that incoming values are endorsed by trusted principals. Techniques including proof-carrying code (PCC) <a href="#page-33-16">[36]</a> and dependently typed programming <a href="#page-32-18">[17]</a> combine values (representing data or code) with machine-checkable proof objects that demonstrate the validity of propositions about the values, independent of their provenance.</p>

    <p class="text-gray-300">These techniques require a programmer to reason about a level of security types, propositions, or proofs, as well as the main computation language. By contrast, PCD allows a programmer to reason entirely at the level of COCOCOMM, and without making implicit or explicit trust assumptions about remote parties. Such systems are complementary to our approach. Similar to proof-carrying access control systems (discussed in the Introduction) our approach can enable compression, constant-time verification, and zero-knowledge privacy for PCC and dependent-type proofs.</p>

    <p class="text-gray-300"><em>Foreign function interfaces</em> Foreign function interfaces (FFI) allow programs written in a high-level language to call code written in another language (typically C or native machine code). It is available in many popular languages, for performance and interoperability reasons. Typically, the callee can return arbitrary values to the caller, potentially violating the semantics and invariants of the high-level language (i.e., producing values that are not well-traced). Furr and Foster <a href="#page-33-17">[22]</a> describe a static analysis approach to this problem, based on cross-language type-inference. Google Native Client <a href="#page-33-18">[35,</a> <a href="#page-34-9">50]</a> restricts the nativecode callee, using software fault isolation, to a certain memory region and set of instructions; however, it does not reason about the values output by the callee.</p>

    <p class="text-gray-300">Our approach to proving well-tracedness offers an alternative, in principle: the high-level language can require values produced by FFI calls to be accompanied by proofs of well-tracedness. However, this incurs runtime overhead, which seems unattractive for performance-motivated uses of FFI.</p>

    <p class="text-gray-300"><em>Remote attestation</em> Remote attestation <a href="#page-32-19">[16,</a> <a href="#page-33-19">39]</a> uses a hardware root of trust, typically based on a Trusted Platform Module (TPM), along with cryptography, to let a target machine convince an appraiser/verifier machine that the target machine's state fulfills some properties (e.g., that it is presently running a specific, unmodified and suitably-configured software stack).</p>

    <p class="text-gray-300">Remote attestation can be used to claim well-tracedness of values by attesting that they were produced by executing a given program on top of a given operating system. This attestation is convincing if the appraiser trusts the TPM hardware root of trust,<a href="#page-31-2">14</a> the correctness of the hardware platform (e.g., CPU and memory), and the correctness of (requisite properties of) the operating system. Our PCD-based approach removes all of these assumptions.</p>

    <p class="text-gray-300">Similarly to our approach, BIND <a href="#page-34-10">[45]</a> and Flicker <a href="#page-33-20">[32]</a> aim to provide <em>fine-grained attestation</em>, attesting only to code directly relevant to producing an output. They remove the trust in the operating system, using CPU support for secure execution and late launch. However, trust in the hardware remains inherent. Notably, BIND supports transitive proofs, similarly to PCD.</p>

    <p class="text-gray-300">Unlike most prior works, which focus on low-level properties such as enforcing execution of specific or signed software, we focus on enforcing language semantics, requiring that values produced by a target machine are well-traced.</p>

    <p class="text-gray-300">PCD can be an alternative to hardware-based remote attestation, in scenarios where the latter is used to enforce <em>integrity</em> or <em>correctness</em> of a value computed by an untrusted target machine. However, PCD cannot express or enforce properties of the target machine as a whole, and thus cannot enforce <em>secrecy</em> properties, such as preventing data copying in Digital Rights Management applications.</p>

    <p class="text-gray-300">This paper presents a novel mechanism to enforce language semantics in a distributed computation with potentially malicious participants. Using the cryptographic mechanism of Proof-Carrying Data (PCD) <a href="#page-32-3">[8,</a> <a href="#page-32-4">12]</a>, we ensure that values received must be <em>well-traced</em>: they could have been produced by a program execution consistent with the language semantics. Thus, developers can reason about properties and invariants of received values, without trusting the parties that provide the values and without being aware of the underlying cryptographic mechanism.</p>

    <p class="text-gray-300">We thank are indebted to Alessandro Chiesa, Christos Dimoulas, Daniel Genkin, Greg Morrisett and Noam Rinetzky for their insightful comments.</p>

    <p class="text-gray-300">This work was supported by the Air Force Office of Scientific Research under Award No. FA95501210262; by the Check Point Institute for Information Security; by the Israeli Ministry of Science and Technology; by the Israeli Centers of Research Excellence I-CORE program (center 4/11); by the National Science Foundation under Grant No. 1054172; and by NATO's Public Diplomacy Division in the Framework of &quot;Science for Peace&quot;.</p>

    <p class="text-gray-300"><sup>14</sup> The Pioneer system <a href="#page-34-11">[43]</a> aims to remove the explicit hardware root of trust, but depends on extensive knowledge of the precise hardware, can be verified only locally, and is subject to some attacks <a href="#page-32-19">[16]</a>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy. Checking computations in polylogarithmic time. In <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>, STOC '91, pages 21&ndash;32, 1991.</p></li>
      <li><p class="text-gray-300">[2] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. On the concrete efficiency of probabilistically-checkable proofs. In <em>Proceedings of ACM symposium on Symposium on theory of computing</em>, pages 585&ndash;594. ACM, 2013.</p></li>
      <li><p class="text-gray-300">[3] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive arguments for a von Neumann architecture. Cryptology ePrint Archive, Report 2013/879, 2013. <a href="http://eprint.iacr.org/2013/879" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2013/879</a>.</p></li>
      <li><p class="text-gray-300">[4] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In <em>Proceedings of CRYPTO 2013</em>, LNCS. Springer, to appear.</p></li>
      <li><p class="text-gray-300">[5] N. Benton and C.-K. Hur. Biorthogonality, step-indexing and compiler correctness. In <em>Proceeding of the 14th ACM SIGPLAN international conference on Functional programming</em>, pages 97&ndash;108, 2009.</p></li>
      <li><p class="text-gray-300">[6] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct noninteractive arguments of knowledge, and back again. In <em>Proceedings of Innovations in Theoretical Computer Science 2012</em>, pages 326&ndash;349. ACM, 2012.</p></li>
      <li><p class="text-gray-300">[7] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. Cryptology ePrint Archive, Report 2012/095, 2012. <a href="http://eprint.iacr.org/2012/095" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2012/</a> <a href="http://eprint.iacr.org/2012/095" target="_blank" rel="noopener noreferrer">095</a>.</p></li>
      <li><p class="text-gray-300">[8] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In <em>Proceedings of ACM symposium on Symposium on theory of computing</em>, STOC '13, pages 111&ndash;120. ACM, 2013. ISBN 978-1-4503-2029-0.</p></li>
      <li><p class="text-gray-300">[9] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In <em>Proceedings of the 10th Theory of Cryptography Conference</em>, TCC '13, pages 315&ndash;333, 2013.</p></li>
      <li><p class="text-gray-300">[10] J. Bloch. <em>Effective Java, Second Edition</em>. Addison-Wesley, Boston, 2nd edition, 2008.</p></li>
      <li><p class="text-gray-300">[11] CERT. The CERT Oracle secure coding standard for Java, entries SER06-J and SER07- J. <a href="https://www.securecoding.cert.org/confluence/display/java/The+CERT+Oracle+Secure+Coding+Standard+for+Java" target="_blank" rel="noopener noreferrer">https://www.securecoding.cert.org/confluence/display/java/The+CERT+Oracle+Secure+</a> <a href="https://www.securecoding.cert.org/confluence/display/java/The+CERT+Oracle+Secure+Coding+Standard+for+Java" target="_blank" rel="noopener noreferrer">Coding+Standard+for+Java</a>, 2013. Accessed 2013-06-04.</p></li>
      <li><p class="text-gray-300">[12] A. Chiesa and E. Tromer. Proof-carrying data and hearsay arguments from signature cards. In A. C.-C. Yao, editor, <em>ICS</em>, pages 310&ndash;331. Tsinghua University Press, 2010. ISBN 978-7-302-21752-7.</p></li>
      <li><p class="text-gray-300">[13] A. Chiesa and E. Tromer. Proof-carrying data: Secure computation on untrusted platforms. <em>The Next Wave: the NSA's review of emerging technologies</em>, 19(2):40&ndash;46, 2012. URL <a href="http://www.nsa.gov/research/_files/publications/next_wave/TNW_19_2_ProofCarryingData_Chiesa_Tromer.pdf" target="_blank" rel="noopener noreferrer">http://www.nsa.gov/research/</a> <a href="http://www.nsa.gov/research/_files/publications/next_wave/TNW_19_2_ProofCarryingData_Chiesa_Tromer.pdf" target="_blank" rel="noopener noreferrer">\\_files/publications/next\\_wave/TNW\\_19\\_2\\_ProofCarryingData\\_Chiesa\\_Tromer.pdf</a>.</p></li>
      <li><p class="text-gray-300">[14] A. Chlipala. A certified type-preserving compiler from lambda calculus to assembly language. In <em>Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation</em>, PLDI '07, pages 54&ndash;65, New York, NY, USA, 2007. ACM.</p></li>
      <li><p class="text-gray-300">[15] A. Chlipala. A verified compiler for an impure functional language. In <em>Proceedings of the 37th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages</em>, POPL '10, pages 93&ndash;106, New York, NY, USA, 2010. ACM.</p></li>
      <li><p class="text-gray-300">[16] G. Coker, J. Guttman, P. Loscocco, A. Herzog, J. Millen, B. O'Hanlon, J. Ramsdell, A. Segall, J. Sheehy, and B. Sniffen. Principles of remote attestation. <em>International Journal of Information Security</em>, 10(2):63&ndash;81, June 2011.</p></li>
      <li><p class="text-gray-300">[17] T. Coquand and G. Huet. The calculus of constructions. <em>Information and Computation</em>, 76, 1988.</p></li>
      <li><p class="text-gray-300">[18] J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve. Secure virtual architecture: A safe execution environment for commodity operating systems. In <em>Proceedings of the Twenty First ACM Symposium on Operating Systems Principles (SOSP)</em>, 2007.</p></li>
      <li><p class="text-gray-300">[19] D. Dhurjati, S. Kowshik, and V. Adve. SAFECode: Enforcing alias analysis for weakly typed languages. In <em>Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, 2006.</p></li>
      <li><p class="text-gray-300">[20] C. Dimoulas, R. B. Findler, C. Flanagan, and M. Felleisen. Correct blame for contracts: No more scapegoating. In <em>POPL</em>, pages 215 &ndash; 226, 2011.</p></li>
      <li><p class="text-gray-300">[21] R. B. Findler and M. Felleisen. Contracts for higher-order functions. In <em>ICFP</em>, pages 48&ndash;59, 2002.</p></li>
      <li><p class="text-gray-300">[22] M. Furr and J. S. Foster. Checking type safety of foreign function calls. <em>ACM Trans. Program. Lang. Syst.</em>, 30 (4):18:1&ndash;18:63, Aug. 2008. ISSN 0164-0925. . URL <a href="http://doi.acm.org/10.1145/1377492.1377493" target="_blank" rel="noopener noreferrer">http://doi.acm.org/10.1145/1377492.1377493</a>.</p></li>
      <li><p class="text-gray-300">[23] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '13, pages 626&ndash;645, 2013.</p></li>
      <li><p class="text-gray-300">[24] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. Delegating computation: Interactive proofs for Muggles. In <em>Proceedings of the 40th Annual ACM Symposium on Theory of Computing</em>, STOC '08, pages 113&ndash;122, 2008.</p></li>
      <li><p class="text-gray-300">[25] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-based memory management in Cyclone. In <em>Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pages 282&ndash;293, New York, NY, USA, 2002. ACM Press.</p></li>
      <li><p class="text-gray-300">[26] J. Groth. Short non-interactive zero-knowledge proofs. In <em>Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '10, pages 341&ndash;358, 2010.</p></li>
      <li><p class="text-gray-300">[27] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A minimal core calculus for Java and GJ. <em>ACM Transactions on Programming Languages and Systems</em>, 23(3):396&ndash;450, 2001.</p></li>
      <li><p class="text-gray-300">[28] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and Y. Wang. Cyclone: A safe dialect of C. In <em>ATEC '02: Proceedings of the General Track of the annual conference on USENIX Annual Technical Conference</em>, pages 275&ndash;288, Berkeley, CA, USA, 2002. USENIX Association.</p></li>
      <li><p class="text-gray-300">[29] J. Kilian. A note on efficient zero-knowledge proofs and arguments. In <em>Proceedings of the 24th Annual ACM Symposium on Theory of Computing</em>, STOC '92, pages 723&ndash;732, 1992.</p></li>
      <li><p class="text-gray-300">[30] X. Leroy. A formally verified compiler back-end. <em>Journal of Automated Reasoning</em>, 43(4):363&ndash;446, 2009.</p></li>
      <li><p class="text-gray-300">[31] H. Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In <em>Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography</em>, TCC '12, pages 169&ndash; 189, 2012.</p></li>
      <li><p class="text-gray-300">[32] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and H. Isozaki. Flicker: an execution infrastructure for TCB minimization. In <em>Proceedings of the 3rd ACM SIGOPS/EuroSys European Conference on Computer Systems 2008</em>, Eurosys '08, pages 315&ndash;328, New York, NY, USA, 2008. ACM.</p></li>
      <li><p class="text-gray-300">[33] S. Micali. Computationally sound proofs. <em>SIAM Journal on Computing</em>, 30(4):1253&ndash;1298, 2000. Preliminary version appeared in FOCS '94.</p></li>
      <li><p class="text-gray-300">[34] MITRE Corporation. Common weakness enumeration, CWE-502, 2013. URL <a href="http://cwe.mitre.org/data/definitions/502.html" target="_blank" rel="noopener noreferrer">http://cwe.mitre.org/</a> <a href="http://cwe.mitre.org/data/definitions/502.html" target="_blank" rel="noopener noreferrer">data/definitions/502.html</a>.</p></li>
      <li><p class="text-gray-300">[35] G. Morrisett, G. Tan, J. Tassarotti, J.-B. Tristan, and E. Gan. RockSalt: better, faster, stronger SFI for the x86. In <em>Proceedings of the 33rd ACM SIGPLAN conference on Programming Language Design and Implementation</em>, PLDI '12, pages 395&ndash;404, New York, NY, USA, 2012. ACM.</p></li>
      <li><p class="text-gray-300">[36] G. C. Necula. Proof-carrying code. In <em>Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, pages 106&ndash;119, New York, NY, USA, 1997. ACM.</p></li>
      <li><p class="text-gray-300">[37] G. C. Necula, S. McPeak, and W. Weimer. CCured: type-safe retrofitting of legacy code. In <em>Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, pages 128&ndash;139, 2002.</p></li>
      <li><p class="text-gray-300">[38] Y. G. Park and B. Goldberg. Escape analysis on lists. In <em>Proceedings of the ACM SIGPLAN 1992 Conference on Programming Language Design and Implementation</em>, pages 116&ndash;127, New York, NY, USA, 1992. ACM.</p></li>
      <li><p class="text-gray-300">[39] B. Parno, J. McCune, and A. Perrig. <em>Bootstrapping Trust in Modern Computers</em>. Springer, 2011. ISBN 9781461414605.</p></li>
      <li><p class="text-gray-300">[40] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In <em>Proceedings of the IEEE Symposium on Security and Privacy</em>, 2013.</p></li>
      <li><p class="text-gray-300">[41] F. Perry, L. Mackey, G. A. Reis, J. Ligatti, D. I. August, and D. Walker. Fault-tolerant typed assembly language. In <em>Proceedings of the 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pages 42&ndash;53, New York, NY, USA, 2007. ACM Press.</p></li>
      <li><p class="text-gray-300">[42] A. Sabelfeld and A. C. Myers. Language-based information-flow security. <em>IEEE Journal on Selected Areas in Communications</em>, 21(1):5&ndash;19, Jan. 2003.</p></li>
      <li><p class="text-gray-300">[43] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. van Doorn, and P. Khosla. Pioneer: Verifying integrity and guaranteeing execution of code on legacy platforms. In <em>Proceedings of ACM Symposium on Operating Systems Principles (SOSP)</em>, pages 1&ndash;16, Oct. 2005.</p></li>
      <li><p class="text-gray-300">[44] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In <em>EuroSys</em>, 2013.</p></li>
      <li><p class="text-gray-300">[45] E. Shi, A. Perrig, and L. V. Doorn. BIND: A fine-grained attestation service for secure distributed systems. In <em>Proceedings of the 2005 IEEE Symposium on Security and Privacy</em>, pages 154&ndash;168, Washington, DC, USA, 2005. IEEE Computer Society.</p></li>
      <li><p class="text-gray-300">[46] J. Thaler. Time-optimal interactive proofs for circuit evaluation. <em>CoRR</em>, abs/1304.3812, 2013.</p></li>
      <li><p class="text-gray-300">[47] P. Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In <em>TCC</em>, 2008.</p></li>
      <li><p class="text-gray-300">[48] J. A. Vaughan, L. Jia, K. Mazurak, and S. Zdancewic. Evidence-based audit. In <em>CSF</em>, pages 177&ndash;191, 2008. Extended version available as U. Pennsylvania Technical Report MS-CIS-08-09.</p></li>
      <li><p class="text-gray-300">[49] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for interactive verifiable computation. In <em>Proceedings of the IEEE Symposium on Security and Privacy</em>, 2013.</p></li>
      <li><p class="text-gray-300">[50] B. Yee, D. Sehr, G. Dardyk, J. Chen, R. Muth, T. Ormandy, S. Okasaka, N. Narula, and N. Fullagar. Native client: A sandbox for portable, untrusted x86 native code. In <em>Security and Privacy, 2009 30th IEEE Symposium on</em>, pages 79&ndash;93, 2009. .</p></li>
      <li><p class="text-gray-300">[51] S. Zdancewic, L. Zheng, N. Nystrom, and A. C. Myers. Untrusted hosts and confidentiality: Secure program partitioning. In <em>Proceedings of the 17th ACM Symposium on Operating System Principles (SOSP)</em>, pages 1&ndash;14, New York, NY, USA, Oct. 2001. ACM Press.</p></li>
      <li><p class="text-gray-300">[52] L. Zheng, S. Chong, A. C. Myers, and S. Zdancewic. Using replication and partitioning to build secure distributed systems. In <em>Proceedings of the IEEE Symposium on Security and Privacy</em>, pages 236&ndash;250, Oakland, California, May 2003. IEEE Computer Society.</p></li>
    </ul>

    <h2 id="sec-misc-5" class="text-2xl font-bold">A. Auxillary Definitions</h2>

    <p class="text-gray-300">We write names(CT) for the set of class names used or defined in CT. Collecting class names mentioned in syntax (via names) is straightforward because there are no binding occurences of class names and no need to avoid capture. We overload names to return the class names used in terms, environments, class declarations, and sets of values.</p>

    <p class="text-gray-300"><strong>Definition 6</strong> (names).</p>

    <p class="text-gray-300"><span class="math">$names(\\mathbf{new}\\ C) = \\{C\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$names(t\\ \\mathbf{instanceof}\\ C) = names(t) \\cup \\{C\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\vdots</span>$</p>

    <p class="text-gray-300"><span class="math">$names(i) = \\emptyset</span>$</p>

    <p class="text-gray-300"><span class="math">$names(\\mathbf{null}) = \\emptyset</span>$</p>

    <p class="text-gray-300"><span class="math">$names(\\{C \\mid \\overline{f = v}\\}) = \\{C\\} \\cup \\left(\\bigcup_{(f = v) \\in \\overline{f = v}} names(v)\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$names(\\rho) = \\bigcup_{x \\in \\mathrm{dom}(\\rho)} names(\\rho(x))</span>$</p>

    <p class="text-gray-300"><span class="math">$names(m(x) \\{\\mathbf{return}\\ t;\\}) = names(t)</span>$</p>

    <p class="text-gray-300"><span class="math">$names\\left(\\begin{array}{c} \\mathbf{class}\\{\\ \\mathrm{fields}\\ \\overline{f};\\\\ \\mathrm{meths}\\ \\overline{M}\\} \\end{array}\\right) = \\bigcup_{M \\in \\overline{M}} names(M)</span>$</p>

    <p class="text-gray-300"><span class="math">$names(CT) = \\bigcup_{C \\in \\mathrm{dom}(CT)} \\{C\\} \\cup names(CT(C))</span>$</p>

    <p class="text-gray-300"><span class="math">$names(\\{v_1, \\dots, v_n\\}) = names(v_1) \\cup \\dots \\cup names(v_n)</span>$</p>

    <p class="text-gray-300">We write e[D/C] to denote the replacement of class name C with class name D in expression e. As before, we overload this notation to also define substitution for environments, class declarations, class tables, and sets of values.</p>

    <h2 id="sec-misc-6" class="text-2xl font-bold"><strong>Definition 7</strong> <span class="math">(\\cdot [\\cdot / \\cdot])</span> .</h2>

    <p class="text-gray-300"><span class="math">$C[D/C] = D</span>$</p>

    <p class="text-gray-300"><span class="math">$E[D/C] = E \\ \\ where \\ C \\neq E</span>$</p>

    <p class="text-gray-300"><span class="math">$(\\text{new } E)[D/C] = \\text{new } (E[D/C])</span>$</p>

    <p class="text-gray-300"><span class="math">$(t \\ \\text{instanceof } E)[D/C] = (t[D/C]) \\ \\text{instanceof } (E[D/C])</span>$</p>

    <p class="text-gray-300"><span class="math">$\\vdots</span>$</p>

    <p class="text-gray-300"><span class="math">$i[D/C] = i</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{null}[D/C] = \\text{null}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\{E \\mid \\overline{f = v}\\}[D/C] = \\{E[D/C] \\mid \\overline{f = (v[D/C])}\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\rho[D/C] = \\lambda x.(\\rho(x)[D/C])</span>$</p>

    <p class="text-gray-300"><span class="math">$CT[D/C] = \\lambda E.\\begin{cases} (CT(C))[D/C] &amp; E = D \\\\ (CT(E))[D/C] &amp; E \\in \\text{dom}(CT) \\setminus \\{C, D\\} \\\\ \\text{undefined} &amp; \\text{otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\{v_1, \\dots, v_n\\}[D/C] = \\{v_1[D/C], \\dots, v_n[D/C]\\}</span>$</p>

    <p class="text-gray-300">We define what it means for one environment to extend another.</p>

    <p class="text-gray-300"><strong>Definition 8</strong> (2). We write  <span class="math">\\rho_2 \\supseteq \\rho_1</span>  when for any  <span class="math">x \\in \\text{dom}(\\rho_1)</span>  it is the case that  <span class="math">\\rho_2(x) = \\rho_1(x)</span> .</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">B. Proof of Theorem 1</h4>

    <p class="text-gray-300">Given an evaluation  <span class="math">CT \\vdash \\langle t, S \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span> , it is possible to rename any class C to a new class name D without otherwise modifying the evaluation.</p>

    <p class="text-gray-300">Lemma 4 (Renaming). Suppose</p>

    <p class="text-gray-300"><span class="math">$CT, \\rho \\vdash \\langle t, S \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">D \\notin names(CT) \\cup names(t) \\cup names(\\rho) \\cup names(t&#x27;) \\cup names(S) \\cup names(S&#x27;)</span> .</p>

    <p class="text-gray-300">Then, for any class name C, it is the case that</p>

    <p class="text-gray-300"><span class="math">$CT[D/C], \\rho[D/C] \\vdash \\langle t[D/C], S[D/C] \\rangle \\rightarrow^* \\langle t&#x27;[D/C], S&#x27;[D/C] \\rangle.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> by induction on the reduction relation.</p>

    <p class="text-gray-300">Given an evaluation of a program, it is possible to add additional classes to the class table without changing the evaluation.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Suppose
<span class="math">$CT_2 \\supseteq CT_1</span>$
and  <span class="math">CT_1 \\vdash \\langle t, \\emptyset \\rangle \\to^* \\langle t&#x27;, S \\rangle</span> . Then  <span class="math">CT_2 \\vdash \\langle t, \\emptyset \\rangle \\to^* \\langle t&#x27;, S \\rangle</span></p>

    <p class="text-gray-300"><em>Proof.</em> By a straightforward induction on  <span class="math">CT_1 \\vdash \\langle t, \\emptyset \\rangle \\to^* \\langle t&#x27;, S \\rangle</span> .</p>

    <p class="text-gray-300">We are now ready to prove Theorem 1, which states that if value v esacpes during evaluation of a Coco-Common program and v is well-formed with respect to common class table  <span class="math">CT_{cmn}</span> , then v is well-traced in  <span class="math">CT_{cmn}</span> .</p>

    <p class="text-gray-300">Proof of Theorem 1. Suppose we have a COCOCOMM program t using classtable CT and during an evaluation of t, the value v escapes and values  <span class="math">u_1, \\ldots, u_n</span>  are received. Intuitively, since each value received is well-traced in  <span class="math">CT_{\\mathsf{cmn}}</span> , there are COCO terms  <span class="math">s_1, \\ldots, s_n</span>  and class tables  <span class="math">CT_1, \\ldots, CT_n</span>  such that  <span class="math">CT_i \\supseteq CT_{\\mathsf{cmn}}</span>  and  <span class="math">CT_i \\vdash \\langle s_i, \\emptyset \\rangle \\to^* \\langle s_i&#x27;, S_i \\rangle</span>  such that  <span class="math">u_i \\in S_i</span> .</p>

    <p class="text-gray-300">We will first construct a class table  <span class="math">CT^*</span>  such that for all i we have a program  <span class="math">\\overline{s}_i</span>  such that  <span class="math">CT^* \\vdash \\langle \\overline{s}_i, \\emptyset \\rangle \\to^* \\langle \\overline{s&#x27;}_i, \\overline{S}_i \\rangle</span>  such that  <span class="math">u_i \\in \\overline{S}_i</span> .</p>

    <p class="text-gray-300">For each i, we can rename the classes in  <span class="math">s_i</span>  and  <span class="math">CT_i</span>  using Lemma 4 to acquire terms  <span class="math">\\overline{s}_i</span>  and class tables  <span class="math">CT_i&#x27; \\supseteq CT_{\\mathsf{cmn}}</span>  such that  <span class="math">\\mathrm{dom}(CT_i&#x27;) \\cap (\\mathrm{dom}(CT_j&#x27;) \\cup CT) = \\mathrm{dom}(CT_{\\mathsf{cmn}})</span>  for all  <span class="math">i \\neq j</span> , and  <span class="math">CT_i&#x27; \\vdash \\langle \\overline{s}_i, \\emptyset \\rangle \\to^* \\langle \\overline{s&#x27;}_i, \\overline{S}_i \\rangle</span>  such that  <span class="math">u_i \\in \\overline{S}_i</span> .</p>

    <p class="text-gray-300">Let  <span class="math">CT^* = CT \\cup \\bigcup CT_i&#x27;</span> . Then by Lemma 5 for any i it holds that  <span class="math">CT^* \\vdash \\langle \\overline{s}_i, \\emptyset \\rangle \\to^* \\langle \\overline{s&#x27;}_i, \\overline{S}_i \\rangle</span>  such that  <span class="math">u_i \\in \\overline{S}_i</span> .</p>

    <p class="text-gray-300">Recall that t is a COCOCOMM program such that value v escapes during evaluation, and v is well-formed in  <span class="math">CT_{cmn}</span> . We must show that v is well traced. We now translate COCOCOMM program t to a COCO program that replaces all <strong>recv on</strong> ch terms with term <strong>capture</strong> and replaces any term <strong>send</strong> s <strong>on</strong> ch with <strong>escape</strong> s. Moreover, we compose the translation with terms that will mark values  <span class="math">u_1, \\ldots, u_n</span>  as escaping. More precisely we translate t to the following program, which we denote  <span class="math">t^*</span> .</p>

    <p class="text-gray-300"><span class="math">$t^* \\equiv \\overline{s}_1 \\, \\| \\dots \\| \\, \\overline{s}_n \\, \\| \\, [\\![t]\\!] \\,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\llbracket \\cdot \\rrbracket</span>  is a function such that</p>

    <p class="text-gray-300"><span class="math">$[\\![ \\mathbf{send} \\ s \\ \\mathbf{on} \\ ch]\\!] = \\mathbf{escape} [\\![ s]\\!]</span>$
<span class="math">[\\![ \\mathbf{recv} \\ \\mathbf{on} \\ ch]\\!] = \\mathbf{capture}</span></p>

    <p class="text-gray-300">and is otherwise homomorphic in the struture of terms. Note that  <span class="math">t^*</span>  is a program that uses only COCO terms (i.e., it does not contain any <strong>send</strong> or <strong>recv</strong> operations).</p>

    <p class="text-gray-300">Moreover, we translate the class table  <span class="math">CT^*</span>  in a similar way, denoted  <span class="math">\\llbracket CT^* \\rrbracket</span> . More precisely  <span class="math">\\llbracket CT^* \\rrbracket</span>  is a class table with the same domain as  <span class="math">CT^*</span>  and if for class C,</p>

    <p class="text-gray-300"><span class="math">$CT^*(C) = \\operatorname{class}\\{\\operatorname{fields}\\overline{f}; \\operatorname{meths}\\overline{m(x)}\\{\\operatorname{return}t;\\}\\}</span>$</p>

    <p class="text-gray-300">then</p>

    <p class="text-gray-300"><span class="math">$[\\![CT^*]\\!](C) = \\operatorname{class}\\{\\operatorname{fields}\\overline{f}; \\ \\operatorname{meths} \\ \\overline{m(x)}\\{\\operatorname{return}\\ [\\![t]\\!];\\}\\,\\}.</span>$</p>

    <p class="text-gray-300">First note that  <span class="math">\\llbracket CT^* \\rrbracket \\vdash \\langle t^*, \\emptyset \\rangle \\to^* \\langle \\llbracket t \\rrbracket, S^* \\rangle</span>  such that  <span class="math">\\{u_1, \\dots, u_n\\} \\subseteq S^*</span> .</p>

    <p class="text-gray-300">We now show that evaluation of  <span class="math">\\langle t, \\emptyset \\rangle</span>  with class table CT under COCOCOMM semantics is in lockstep with evaluation of  <span class="math">\\langle [t], S^* \\rangle</span>  with class table  <span class="math">[CT^*]</span>  under COCO semantics. We proceeds by induction on the length of the evaluation, with the inductive hypothesis being that if the current COCOCOMM term is s then the current COCO term is [s]. For each small step, we proceed by induction on the derivation</p>

    <p class="text-gray-300"><span class="math">$CT, CT_{\\mathsf{cmn}}, \\emptyset \\vdash_{\\mathsf{comm}} \\langle s, S \\rangle \\to \\langle s&#x27;, S&#x27; \\rangle,</span>$</p>

    <p class="text-gray-300">to show that if  <span class="math">S&#x27; \\subseteq S&#x27;&#x27;&#x27;</span>  then</p>

    <p class="text-gray-300"><span class="math">$\\llbracket CT^* \\rrbracket, \\emptyset \\vdash \\langle \\llbracket s \\rrbracket, S&#x27;&#x27; \\rangle \\rightarrow \\langle \\llbracket s&#x27; \\rrbracket, S&#x27;&#x27;&#x27; \\rangle</span>$</p>

    <p class="text-gray-300">and S &sube; S <sup>00</sup>. The only interesting case is when the redex is recv on ch, and the received value is u<sup>i</sup> for some u<sup>i</sup> that is well-traced in CTcmn. In the translated version, the redex is capture, and the current set of escaped values contains at least u1, . . . , un. Thus, we can step to u<sup>i</sup> as required.</p>

    <p class="text-gray-300">Finally, since v is a value, we have [[v]] = v, and so we have a program t &lowast; such that</p>

    <p class="text-gray-300"><span class="math">$\\llbracket CT^* \\rrbracket \\vdash \\langle t^*, S \\rangle \\to^* \\langle t&#x27;, S \\rangle</span>$</p>

    <p class="text-gray-300">for some S such that v &isin; S, and thus v is well-traced, as required.</p>

`;
---

<BaseLayout title="Enforcing Language Semantics Using Proof-Carrying Data (2013/513)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/513
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="enforcing-language-semantics-using-proof-carrying-data-2013" />
  </article>
</BaseLayout>
