---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/513';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Enforcing Language Semantics Using Proof-Carrying Data';
const AUTHORS_HTML = 'Stephen Chong, Eran Tromer, Jeffrey A.  Vaughan';

const CONTENT = `    <p class="text-gray-300">(extended version)</p>

    <p class="text-gray-300">September 22, 2024</p>

    <p class="text-gray-300">Stephen Chong</p>

    <p class="text-gray-300">Harvard University</p>

    <p class="text-gray-300">chong@seas.harvard.edu</p>

    <p class="text-gray-300">Eran Tromer</p>

    <p class="text-gray-300">Tel Aviv University</p>

    <p class="text-gray-300">tromer@cs.tau.ac.il</p>

    <p class="text-gray-300">Jeffrey A. Vaughan</p>

    <p class="text-gray-300">LogicBlox Inc.</p>

    <p class="text-gray-300">jeff.vaughan@logicblox.com</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">Sound reasoning about the behavior of programs relies on program execution adhering to the language semantics. However, in a distributed computation, when a value is sent from one party to another, the receiver faces the question of whether the value is well-traced: could it have been produced by a computation that respects the language semantics? If not, then accepting the non-well-traced value may invalidate the receiver's reasoning, leading to bugs or vulnerabilities.</p>

    <p class="text-gray-300">Proof-Carrying Data (PCD) is a recently-introduced cryptographic mechanism that allows messages in a distributed computation to be accompanied by proof that the message and the history leading to it complies with a specified predicate. Using PCD, a verifier can be convinced that the predicate held throughout the distributed computation, even in the presence of malicious parties, and at a verification cost that is independent of the size of the computation producing the value. Unfortunately, previous approaches to using PCD required tailoring a specialized predicate for each application, using an inconvenient formalism and with little methodological support.</p>

    <p class="text-gray-300">We connect these two threads by introducing a novel, PCD-based approach to enforcing language semantics in distributed computations. We show how to construct an object-oriented language runtime that ensures that objects received from potentially untrusted parties are well-traced with respect to a set of class definitions. Programmers can then soundly reason about program behavior, despite values received from untrusted parties, without needing to be aware of the underlying cryptographic techniques.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 2  Overview  6 3  Base Language  9 3.1  Syntax and semantics  9 3.2  Well-traced values  12 4  Communication Language  13 4.1  Syntax and semantics  14 4.2  Well-tracedness  15 5  Modeling Distributed Executions  16 5.1  COCOTRUST  16 5.2  Distributed execution graphs  16 6  Proof Carrying Data  22 6.1  Overview of PCD  22 6.2  A compliance predicate for well-tracedness  25 6.3  Verifying well-tracedness  25 6.4  Verifying correctness of COCOCOMM executions  26 7  Extensions  28 8  Related work  30 9  Conclusion  32 Acknowledgments  32 References  33 A  Auxiliary Definitions  36 B  Proof of Theorem 1  37</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Encapsulation allows programmers to reason locally about expressive and useful properties of programs and values. The soundness of such local reasoning relies on program execution adhering to the language semantics. However, in a distributed computation, when a value is received from an untrusted party, it is potentially difficult to ascertain that the value was computed according to language semantics. Indeed, the received value (say, an object of a specific class) may be one that could never result from any valid computation. This could happen due to a malicious attack by the sender, transient errors, Trojan horses at the software or hardware levels, or (transitively) corruption in values that the sender itself received from others. Accepting values that are not the result of valid computation may belie otherwise sound reasoning, and lead to bugs or vulnerabilities. Such risks are especially a concern with distributed and outsourced cloud computing.</p>

    <p class="text-gray-300">Consider, for example, object deserialization in a class-based type-safe language. A byte stream received from the network could represent a well-formed object value (i.e., one with appropriate fields for its class), but with a state that is impossible to reach by a sequence of calls to the class’s public interface. Such objects may violate invariants that are satisfied by every object of that class produced in accordance with the language semantics, by calls to the public interface. Allowing such objects into a program’s evaluation is potentially harmful, and may render invalid any program reasoning that relies on those invariants. Verifying these invariants is, in general, a hard open problem. Bloch devotes an entire chapter of his book <em>Effective Java</em> <em>[10]</em> to the problem of, and manual methods for, safe deserialization of objects. In practice, similar concerns are raised by a secure coding standard <em>[11]</em> (listing this problem as “probable” and “high remediation cost”), and by a study of common weaknesses <em>[34]</em>.</p>

    <p class="text-gray-300">In this paper we show how to enforce language semantics in a distributed computation, where values are sent between mutually-untrusting and potentially-malicious parties. We do so in the context of a simple class-based object-oriented calculus, Coco, that provides encapsulation, and thus allows local language-level reasoning about rich application-specific properties. We enforce language semantics using a recently introduced cryptographic mechanism, <em>Proof-Carrying Data</em> <em>[8, 12, 13]</em>, to prove (in zero-knowledge) that object values that party <span class="math">A</span> receives from party <span class="math">B</span> were computed in accordance with language semantics, and, transitively, that all values previously received by <span class="math">B</span> and used in its computation were similarly computed in accordance with language semantics.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Proof-Carrying Data</h4>

    <p class="text-gray-300">PCD <em>[8, 12, 13]</em> allows every message in a distributed computation to be accompanied by proof that the message <em>and the history leading to it</em> complies with a specified <em>compliance predicate</em>. Using PCD, a verifier can be convinced that the compliance predicate held throughout the computation, even in the presence of malicious parties, and at a verification cost that is independent of the size of the computation to produce the value.</p>

    <p class="text-gray-300">The PCD compliance predicate can be instantiated with any polynomial-time computable property that is required to hold, locally, at every node of the computation. Once a compliance predicate has been chosen, PCD gives a recipe for generating and verifying proofs of this property during the distributed execution. In this work, we design a PCD compliance predicate that asserts that values were produced in accordance with the semantics of a specific object-oriented programming language, and with respect to any prescribed set of classes in that language.</p>

    <p class="text-gray-300">PCD proofs are <em>probabilistic</em> and <em>computationally sound</em>: convincing proofs for false statements may exist, but no efficient algorithm can find them with more than negligible probability (just as in other cryptographic mechanisms for integrity, such as digital signatures).</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Example</h4>

    <p class="text-gray-300">Consider a distributed application where a sender creates <em>helpmate chess puzzles</em> to be solved by a recipient. A helpmate chess problem is a pair of an integer <span class="math">n</span> and a board position. A solution exists if White and Black can conspire such that White wins in at most <span class="math">n</span> moves. It is easy to construct a solvable</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1. Class definitions for chess puzzles, in the Coco language. Comments indicate the intended types of methods and fields. Fields are implicitly private, initialized to null, and immutable.</p>

    <p class="text-gray-300">puzzle by starting from a White checkmate and "rewinding" valid moves, but it's potentially difficult to decide if a given puzzle has a solution.</p>

    <p class="text-gray-300">Figure 1 sketches class definitions intended to implement this application, in an object-oriented programming language (namely, the Coco language described in Section 3). Class Puzzle encodes helpmate problems following the intuition above: Puzzles are initialized with a Board object where White has won and where remaining Moves = 0, and more interesting puzzles are created via calls to rewindMove. All fields in these classes are implicitly private and immutable. We can reason at the language level to conclude that an invariant holds: every Puzzle object (where board is non-null) represents a solvable helpmate problem.</p>

    <p class="text-gray-300">Now consider the distributed setting, and assume that all parties have agreed on a common class table that includes the definitions of classes in Figure 1. How can a recipient know if a received Puzzle is really solvable in the stated number of moves? An honest sender may have computed the puzzle using its own classes (i.e., classes not in the common class table that, say, implement a proprietary puzzle-making algorithm), executed that code according to language semantics, serialized the result, and sent it to the recipient. However, a malicious sender might simply provide data that deserialization into an unsolvable yet well-formed Puzzle object (i.e., it has two fields of the right name). The receiver might attempt to validate the Puzzle by solving it, but this is, in general, expensive.</p>

    <p class="text-gray-300">In this paper we show how to use PCD to enable the recipient to efficiently verify that the Puzzle was (with overwhelming probability) computed in accordance with language semantics, which suffices to allow the recipient to conclude that the puzzle is solvable. And by using zero-knowledge PCD, the sender may share Puzzle objects without recipients learning any information about solutions, beyond that they exist.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Other Applications</h4>

    <p class="text-gray-300">Enforcing language semantics in distributed computations can enable solutions to many different security problems, including the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider a class with a single private field called key that can be set only by a method keyGen(seed) that uses seed as a source of entropy to generate two large primes, and sets key to the product of these primes. (This models one interesting part of RSA key generation, eliding exponents.) Upon receiving an object of this class, the recipient knows that the field key was generated according to appropriate algorithms, without knowing what the value of seed was. More generally, enforcement of language semantics can be used to provide assurance that correct cryptographic algorithms were followed, without revealing secret information.</li>

      <li>In proof-carrying access control systems <em>[48]</em>, access requests are accompanied by explicit proofs that the access is allowed, and the resource guard must check that the proof is correct. As an alternative, consider a class representing an access request with a private field proofOK that is set only by a method that takes a proof, checks it, and sets proofOK to a non-zero value only if the proof is correct. The resource guard, upon receiving such an object, can simply accept the request if proofOK is non-zero, because the resource guard is confident that language semantics were enforced. Moreover, the guard does not learn any private information that may be present in the explicit proof.</li>

      <li>Higher-order contracts <em>[21]</em> are a run-time mechanism to enforce pre- and post-conditions of functions in higher-order languages. Contract implementations ensure that misbehaving parties are correctly blamed for their misbehavior <em>[20]</em>, a form of accountability. But enforcing correct contract use in a distributed system is a difficult problem, as an attacker may fail to evaluate pre- and post-conditions at appropriate times (and thus contract violations are not detected) and also may alter data structures that represent and track blame labels (possibly causing parties to be blamed inappropriately). Our approach of enforcing language semantics can ensure contracts are evaluated correctly. Thus, rich application-specific assertions can be checked, and blame appropriately assigned when assertions fail.</li>

    </ul>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Practicality</h4>

    <p class="text-gray-300">The fundamental possibility of PCD systems motivates the theoretical question of whether program properties and language semantics can be enforced in distributed systems. Yet, ultimately we are interested in working systems. Our approach can, in principle, be built using known cryptographic machinery, with good asymptotic complexity (the running time overheads of all components are at most polylogarithmic, compared to just blindly trusting received values). However, implementation of our approach for nontrivial programs is not yet practical, since sufficiently-efficient implementations of the underlying PCD systems are not yet available (see Section 6.1). Using current techniques, the concrete overhead for producing proofs will be several orders of magnitude, and would thus be of practical interest mainly for security-critical systems or a small trusted base of larger system (though verifying such proofs is already highly efficient, on the order of milliseconds <em>[3, 4, 40]</em>). However, rapid recent progress in the implementations of special cases of PCD <em>[3, 4, 40]</em> raises favorable prospects for implementation of the general case required by our approach.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Outline</h4>

    <p class="text-gray-300">Section 2 provides intuition about the underlying cryptographic proof system. Section 3 presents Coco, a class-based object-oriented language with encapsulation. An object <span class="math">v</span> is well-traced if there is a Coco program that produces <span class="math">v</span>. Because Coco has encapsulation and class tables, well-tracedness enables local language-level reasoning about objects.</p>

    <p class="text-gray-300">Section 4 presents CocoComm, which extends Coco with communication primitives, and requires that any value received over a channel must be well-traced. This is sufficient to ensure that any value produced by a CocoComm program must itself be well-traced. Thus, a party that uses CocoComm to execute its part of a distributed computation is able to use local language-level reasoning about objects,</p>

    <p class="text-gray-300">despite communication with untrusted parties. The challenge, of course, is to enforce CocoComm semantics.</p>

    <p class="text-gray-300">Sections 5 and 6 show how to use PCD to enforce CocoComm semantics, i.e., to ensure that all values received could have been computed in accordance with language semantics. Section 7 discusses extensions to our approach, including supporting additional language features (imperative state, concurrency, etc.), and achieving stronger proof notions. We discuss related work in Section 8, and conclude in Section 9.</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Contribution</h5>

    <p class="text-gray-300">The key contribution of this work is a novel mechanism to enforce language semantics in distributed computations with potentially malicious or faulty participants. This enables sound program reasoning: because received values are verified to have been computed in accordance with language semantics, developers can reason about properties and invariants of received values without needing to trust the party that computed the value. Key features of our approach include the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We support both verified computation and private intermediate computations and data. For verified computation of known code, the known code may be placed in a mutually-agreed-upon <em>common class table</em>, and enforcement of language semantics ensures that this code is executed correctly. Computation not included in the common class table is deliberately left unspecified, and parties may choose it arbitrarily. For example, a party may use a proprietary algorithm or private data structure to perform a computation (e.g., to generate a chess puzzle); the zero-knowledge property ensures that such algorithms and private data are not unnecessarily revealed.</li>

    </ul>

    <p class="text-gray-300">This is enabled by careful design of the programming language Coco, which is a class-based object-oriented calculus that provides encapsulation. This combination of language features enables local language-level reasoning about programs, which in turn enables local reasoning about application-specific properties, despite communication with potentially malicious parties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Our scheme offers efficient verification with short proofs. That is, one party can prove to another that a value <span class="math">v</span> is well-traced using a proof whose size is independent of the length of the computation to compute <span class="math">v</span> (and the time to produce the proof is polynomial in the length of the computation). Moreover, verification is transitive: a party can prove not just that the value it produced is well-traced, but any value it received was itself well-traced. (These properties arise due to the underlying PCD mechanism.)</li>

    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">2 Overview</h2>

    <p class="text-gray-300">Our approach relies on two key technical mechanisms. The first includes the Coco programming language, its extension to distributed settings (CocoComm), and the implementation using PCD to enforce language semantics in distributed computations. This is the main contribution of our paper and subsequent sections will formally describe our approach and prove its correctness. The second mechanism is PCD itself, which we use as a black box and is <em>not</em> a contribution of this paper.</p>

    <p class="text-gray-300">However, in order to understand (and believe) our results, it is helpful to gain intuition for the PCD mechanism. Thus, in this section we forgo abstraction and provide a brisk, informal walk-through of our system, focusing on the cryptographic machinery that make the approach possible, and sketching reasons for its soundness. This journey will go through several scenarios (highlighted in bold), starting from naive non-solutions that assume too much or are inefficient, and building towards (one instance of) the full approach. Here, we simplify or omit most technical details.</p>

    <p class="text-gray-300">Consider, first, the case of two parties, Alice and Bob. They have agreed upon an object-oriented programming language, in this case Coco, and upon a class table <span class="math">CT_{\\mathsf{cmn}}</span> providing a common vocabulary (e.g., the classes from the chess puzzle example). Each party also has arbitrary additional local classes, and some local program to evaluate. At some point, Bob’s program receives from Alice an object <span class="math">v</span> of a class <span class="math">C</span> in <span class="math">CT_{\\mathsf{cmn}}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">All Bob knows about <span class="math">v</span> is its class <span class="math">C</span>. He does not know what program was used to produce it. However, because the language provides encapsulation, Bob can reason locally, relying on the language semantics and the content of <span class="math">CT_{\\mathsf{cmn}}</span>, and deduce an invariant of <span class="math">C</span> which <span class="math">v</span> must fulfill (e.g., the puzzle is solvable). That Coco supports sound, encapsulation-based reasoning at all is a result of careful decisions in its design (see Sections 3–4). And because <span class="math">C</span> is a Coco class, as opposed to CocoComm, Bob need not think about communication in his analysis of <span class="math">v</span>; he can reason as if <span class="math">v</span> was constructed locally by a trusted runtime.</p>

    <p class="text-gray-300">Suppose Bob ascertained that this invariant of <span class="math">v</span> implies a desirable property of his program (e.g., it eventually solves the puzzle represented by <span class="math">v</span>). If both Alice and Bob’s programs are run in a trusted joint runtime (e.g., a single interpreter running on a trusted platform), which passes <span class="math">v</span> from Alice’s program to Bob’s, then Bob’s property of course holds. It still holds if the programs are separated onto different computers, using separate but trusted runtime systems that correctly execute both programs and, whenever Alice sends a value, faithfully serialize it, transmit it to Bob over a network, and deserialize it there.</p>

    <p class="text-gray-300">Suppose, however, that Alice runs an untrusted runtime that may produce corrupted values (due to malice or faults). When <span class="math">v</span> is received, the deserialization in Bob’s runtime easily ensures that <span class="math">v</span> is well-formed (i.e., it has the right fields). But for Bob’s property to hold, the value should moreover be well-traced (i.e., indeed produced by Alice executing a program, in adherence with the language semantics, and using the common class table). This is not guaranteed, and in general may be infeasible or impossible to check directly (e.g., how would one efficiently check if a chess puzzle is solvable?).</p>

    <p class="text-gray-300">Bob still trusts his own computer (otherwise it is meaningless to discuss his program’s behavior). He replaces his local runtime with a verifying runtime, which requires Alice to provide evidence that <span class="math">v</span> is well-traced. Alice (if she is honest) then installs a proving runtime. Her runtime first executes her program as usual, until the point where her program sends <span class="math">v</span>. This may entail nondeterministic choices resolved in arbitrary ways, such as external inputs, human interaction, or randomness; these choices are recorded in a trace-witness <span class="math">W</span>. Alice’s runtime then packages up everything needed to reproduce <span class="math">v</span>: Alice’s local program <span class="math">t</span>, her local classes <span class="math">CT</span>, and <span class="math">W</span>; call this her local input, <span class="math">\\mathsf{linp}</span>. Alice’s runtime sends her <span class="math">\\mathsf{linp}</span> to Bob’s runtime, which checks it using a fixed program, called the compliance predicate <span class="math">\\mathbb{C}</span>, which operates simply as follows: given value <span class="math">v</span> and local input <span class="math">\\mathsf{linp}</span>, <span class="math">\\mathbb{C}(v,\\mathsf{linp})</span> ensures that <span class="math">CT</span> is compatible with <span class="math">CT_{\\mathsf{cmn}}</span>, and replays the whole computation to confirm that <span class="math">v</span> is the correct result of executing program <span class="math">t</span> with classes <span class="math">CT</span>, using trace-witness <span class="math">W</span> to resolve nondeterministic choices. Bob’s runtime will agree to deserialize <span class="math">v</span> only if <span class="math">\\mathbb{C}(v,\\mathsf{linp})</span> accepts. We have thus restored the soundness of Bob’s reasoning, but using inefficient verification and long proofs.</p>

    <p class="text-gray-300">We would like to move the burden of proving back to Alice. To convince Bob that there exists <span class="math">\\mathsf{linp}</span> that produces <span class="math">v</span> (and thus <span class="math">v</span> is well-traced), Alice should run <span class="math">\\mathbb{C}</span> on her own computer, and convince Bob of the following.</p>

    <p class="text-gray-300">Alice’s Statement: “There exists some <span class="math">\\mathsf{linp}</span> such that <span class="math">\\mathbb{C}(v,\\mathsf{linp})</span> accepts.”</p>

    <p class="text-gray-300">Probabilistically-Checkable Proofs (PCPs) <em>[1]</em> allow us to do just that. Alice’s runtime first records a step-by-step trace <span class="math">T</span> of <span class="math">\\mathbb{C}</span>’s execution (note that <span class="math">\\mathbb{C}</span> is a fixed, known part of the runtime). It then uses a PCP to encode <span class="math">T</span> into proof <span class="math">\\pi_{\\mathsf{PCP}}</span>, which is a string of bits with a special error-detection property: there is an efficient algorithm, the PCP verifier <span class="math">V_{\\mathsf{PCP}}</span>, that gets <span class="math">v</span> as input, samples just a handful of locations in the string <span class="math">\\pi_{\\mathsf{PCP}}</span>, and just by a simple consistency check on these bits (e.g., a few parity checks), decides whether <span class="math">T</span> is a correct trace of an execution of <span class="math">\\mathbb{C}(v,\\mathsf{linp})</span> for the given <span class="math">v</span> and some <span class="math">\\mathsf{linp}</span>. The PCP verifier is probabilistically sound: if there does not exist <span class="math">\\mathsf{linp}</span> such that <span class="math">\\mathbb{C}(v,\\mathsf{linp})</span> accepts, then for any proof string <span class="math">\\pi_{\\mathsf{PCP}}</span>, the PCP verifier will almost always catch an inconsistency in <span class="math">\\pi_{\\mathsf{PCP}}</span> and reject. Alice’s runtime thus</p>

    <p class="text-gray-300">sends <span class="math">v</span> and <span class="math">\\pi_{\\mathsf{PCP}}</span> to Bob’s runtime, which runs <span class="math">V_{\\mathsf{PCP}}</span>. Alas, the string <span class="math">\\pi_{\\mathsf{PCP}}</span> is even longer than the trace <span class="math">T</span> it encodes. We have thus attained a probabilistically-sound efficient verification with long proofs.</p>

    <p class="text-gray-300">The next improvement is to reduce the proof size using cryptographic machinery. Alice’s runtime again produces the PCP proof string <span class="math">\\pi_{\\mathsf{PCP}}</span> as above. It then summarizes <span class="math">\\pi_{\\mathsf{PCP}}</span> and commits to it, by computing its cryptographic (Merkle) hash digest <span class="math">r</span>. Hash digest <span class="math">r</span> determines which locations in <span class="math">\\pi_{\\mathsf{PCP}}</span> to sample. Alice’s runtime creates a new proof string <span class="math">\\pi</span> consisting of hash digest <span class="math">r</span>, the samples, and cryptographic evidence for consistency between these. It then sends <span class="math">v</span> and <span class="math">\\pi</span> to Bob’s runtime, which runs a verifier <span class="math">V_{\\mathsf{CSP}}</span> to check this. <span class="math">V_{\\mathsf{CSP}}(v,\\pi)</span> checks the hash consistency and then invokes <span class="math">V_{\\mathsf{PCP}}</span> to check the samples. Soundness now relies on cryptographic assumptions (e.g., that no efficient algorithm can find colliding inputs to the hash function, or manipulate the hash input to control the choice of samples). We thus attain a <em>computationally-sound proof system</em> <em>[33]</em>, whose soundness holds only if the adversary is an efficient algorithm. The size of <span class="math">\\pi</span> is merely logarithmic in that of <span class="math">\\pi_{\\mathsf{PCP}}</span> (and <span class="math">T</span>). We have thus attained computationally-sound efficient verification with short proofs for Alice’s Statement, and thus for well-tracedness of <span class="math">v</span>. This is the best Bob could hope for.</p>

    <p class="text-gray-300">More generally, similar computationally-sound proofs can generically compress proofs for NP statements (i.e., statements of the form “there exists <span class="math">w</span> such that <span class="math">\\Phi(x,w)</span> accepts” for a polynomial-time <span class="math">\\Phi</span>). We use this later.</p>

    <p class="text-gray-300">Let us now extend the scenario to a chain of untrust. Consider a third party, Carol, who has her own computer and program. She joins the conversation, using the same common class table <span class="math">CT_{\\mathsf{cmn}}</span>. After receiving <span class="math">v</span> from Alice, Bob’s program sends a value <span class="math">v^{\\prime}</span> (derived from <span class="math">v</span>) to Carol. In her turn, Carol runs some Coco program that receives <span class="math">v^{\\prime}</span>, and relies on <span class="math">v^{\\prime}</span> being well-traced in order to ensure some property. Carol does not trust Alice or Bob. She thus installs the same verifying runtime described above, using computationally-sound proofs, and expects Bob to produce a suitable proof <span class="math">\\pi^{\\prime}</span> for <span class="math">v^{\\prime}</span>. Bob can compute his local input <span class="math">\\mathsf{linp}^{\\prime}</span> similarly to Alice, but when he tries to run <span class="math">\\mathbb{C}</span>, it fails because the replayed computation receives a value (from Alice); this mustn’t be allowed, for fear that the value is not well-traced. Indeed, even if Bob correctly evaluated every step of his program, if he (accidentally or maliciously) received values that were not well-traced, then <span class="math">v^{\\prime}</span> may not be well-traced.</p>

    <p class="text-gray-300">We thus require a mechanism for transitive verification: Bob’s proof <span class="math">\\pi^{\\prime}</span> should convince Carol not merely that Bob executed his own program correctly, but also that he verified that every value he received was well-traced. The combination of these ensures that <span class="math">v^{\\prime}</span> is well-traced.</p>

    <p class="text-gray-300">To realize this we make two extensions. First, we extend compliance predicate <span class="math">\\mathbb{C}</span> with an additional parameter <span class="math">\\vec{v}_{\\mathsf{in}}</span>, representing the values received during the computation. Now, <span class="math">\\mathbb{C}(v,\\mathsf{linp},\\vec{v}_{\\mathsf{in}})</span> (where <span class="math">\\mathsf{linp}=(CT,t,W)</span>) ensures that <span class="math">CT</span> is compatible with <span class="math">CT_{\\mathsf{cmn}}</span>, and that <span class="math">v</span> is the correct result of executing program <span class="math">t</span> using classes <span class="math">CT</span>, using trace-witness <span class="math">W</span> to resolve nondeterministic choices, and using <span class="math">\\vec{v}_{\\mathsf{in}}</span> as the list of received values. This takes care of verifying Bob’s Coco evaluation. Second, in order to transitively verify that values <span class="math">\\vec{v}_{\\mathsf{in}}</span> are well-traced, we define the following algorithm <span class="math">\\mathbb{M}_{\\mathbb{C}}</span>. Given value <span class="math">v</span>, local input <span class="math">\\mathsf{linp}</span>, received values <span class="math">\\vec{v}_{\\mathsf{in}}</span> and corresponding proofs <span class="math">\\vec{\\pi}_{\\mathsf{in}}</span>, <span class="math">\\mathbb{M}_{\\mathbb{C}}(v,\\mathsf{linp},\\vec{v}_{\\mathsf{in}},\\vec{\\pi}_{\\mathsf{in}})</span> verifies that <span class="math">\\mathbb{C}(v,\\mathsf{linp},\\vec{v}_{\\mathsf{in}})</span> accepts and, moreover, for every input <span class="math">v_{i}\\in\\vec{v}_{\\mathsf{in}}</span> and corresponding proof <span class="math">\\pi_{i}\\in\\vec{\\pi}_{\\mathsf{in}}</span>, the aforementioned verifier <span class="math">V_{\\mathsf{CSP}}(v_{i},\\pi_{i})</span> accepts. Carol asks Bob to prove the following about <span class="math">v^{\\prime}</span>.</p>

    <p class="text-gray-300">Bob’s Statement: “There exists some <span class="math">\\mathsf{linp}</span>, received values <span class="math">\\vec{v}_{\\mathsf{in}}</span> and corresponding proofs <span class="math">\\vec{\\pi}_{\\mathsf{in}}</span> such that <span class="math">\\mathbb{M}_{\\mathbb{C}}(v^{\\prime},\\mathsf{linp},\\vec{v}_{\\mathsf{in}},\\vec{\\pi}_{\\mathsf{in}})</span> accepts.”</p>

    <p class="text-gray-300">Bob then convinces Carol of this statement, using a computationally-sound proof. Concretely, Bob’s proof is a compression of the execution trace of <span class="math">\\mathbb{M}_{\\mathbb{C}}(v^{\\prime},\\mathsf{linp}^{\\prime},(v),(\\pi))</span>, where <span class="math">v</span> and <span class="math">\\pi</span> are the value and proof he received from Alice. The result is a transitive proof that convinces Carol that <span class="math">v^{\\prime}</span> is well-traced.</p>

    <p class="text-gray-300">Note that, in the above, proofs always “piggybacked” on values: every data value sent was accompanied by a stand-alone proof that attests to its well-tracedness. Carol did not have to talk to Alice; the proof produced by Bob already summarized his history. This idea naturally generalizes to general distributed computation among untrusted parties. Consider a distributed system, consisting of any number of parties, communicating in an arbitrary pattern and mutually-distrusting. We can ensure that, jointly, they are following the prescribed language semantics with respect to common classes <span class="math">CT_{\\mathsf{cmn}}</span>, by having all of them follow a protocol similar to Bob: verify every incoming value, and produce a transitive proof for every sent value, using computationally-sound proofs about (a generalization of) algorithm <span class="math">\\mathbb{M}_{\\mathbb{C}}</span>. The proofs are constant size, regardless of the length of computation or number of parties, and always “summarize” the relevant history back to the dawn of computation. This is a Proof-Carrying Data system for the property of well-tracedness.</p>

    <p class="text-gray-300">Existing constructions of Proof-Carrying Data (of Chiesa and Tromer <em>[12]</em> following Micali <em>[33]</em>, Kilian <em>[29]</em> and Valiant <em>[47]</em>, of which the above is a sketch; and of Bitansky et al. <em>[8]</em>, which takes an alternative approach) already tackle the cryptographic details and soundness analysis, and encapsulate them as a “cryptographic primitive” which lets any compliance predicate (of suitable form) be enforced. In the remainder of this paper, we will take these constructions as granted, and <em>instantiate</em> them for well-tracedness, for a particular, illustrative object-oriented language Coco, by defining a suitable compliance predicate and proving its requisite properties. By instantiating PCD on a compliance predicate that enforces language semantics, we enable local language-level program reasoning. A single instantiation of PCD enables many applications to enforce arbitrary properties through the use of standard programming language mechanisms.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 Base Language</h2>

    <p class="text-gray-300">This section introduces Coco, a Core Calculus for Objects. Coco is a class-based object-oriented calculus broadly based on Featherweight Java <em>[27]</em>, but modified to model encapsulation and to support a clear, robust definition of well-tracedness. Coco allows only functional update of fields (i.e., fields are immutable, but it is possible to create a <em>copy</em> of an object with modified fields), and all fields are private (i.e., fields of objects of class <span class="math">C</span> are accessible only by code of class <span class="math">C</span>). These restrictions provide encapsulation and enable local language-level reasoning about objects, because given a Coco object, the only way it could have been produced is by some sequence of calls to methods of the corresponding class.</p>

    <p class="text-gray-300">Coco contains two operators, escape and capture, that model the essence of values escaping their owner <em>[38]</em> without the need for an explicit escape analysis. A non-deterministic choice operator makes it easy to construct and reason about observers of escaped values, even in the presence of concurrency and non-termination. These features allows us to give an intuitive definition of well-tracedness that includes escaped objects.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1 Syntax and semantics</h3>

    <p class="text-gray-300">Coco is a class-based object-oriented language; a class table <span class="math">CT</span> is a partial map from names to class declarations, which define the classes’ fields and methods. We write <span class="math">\\mathrm{dom}(CT)</span> for the set of class names for which <span class="math">CT</span> provides a definition, and <span class="math">names(CT)</span> for the set of class names used or defined in <span class="math">CT</span>.</p>

    <p class="text-gray-300">Figure 2 presents the syntax of Coco. <span class="math">\\overline{X}</span> indicates a set (without duplicates) of objects in syntactic category <span class="math">X</span>. We use subscripts to refer to individual elements of <span class="math">\\overline{X}</span>, e.g., <span class="math">X_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Objects have form $\\{C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\overline{f=v}\\ \\}<span class="math">, where </span>C<span class="math"> is the class of the object, and the fields </span>f_{i}<span class="math"> of the object map to values </span>v_{i}<span class="math">. Operator new </span>C<span class="math"> creates an object </span>\\{C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\overline{f=\\mathsf{null}}\\ \\}<span class="math">, i.e., all fields initially map to the special value null. Notation </span>s.m(t)<span class="math"> invokes method </span>m<span class="math"> with receiver </span>s<span class="math"> and argument </span>t<span class="math">. All methods take one argument and return a value. Fields are immutable and implicitly private: fields may be read only via term this.</span>f$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Metavariable convention for names</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C, D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">class names (∈ CName)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s, t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">terms (∈ Term)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CT</td>

            <td class="px-3 py-2 border-b border-gray-700">class tables (∈ CT)</td>

            <td class="px-3 py-2 border-b border-gray-700">u, v, o</td>

            <td class="px-3 py-2 border-b border-gray-700">values (∈ Val)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f, g</td>

            <td class="px-3 py-2 border-b border-gray-700">field names</td>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">integers (∈ Z)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m, n</td>

            <td class="px-3 py-2 border-b border-gray-700">method names</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">total integer operations</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x, y, z</td>

            <td class="px-3 py-2 border-b border-gray-700">variable names (∈ Var)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Class Table</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Class Declaration</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CT</td>

            <td class="px-3 py-2 border-b border-gray-700">∈</td>

            <td class="px-3 py-2 border-b border-gray-700">CT = CName → CDecl</td>

            <td class="px-3 py-2 border-b border-gray-700">χ ::= class{fields f; meths M} ∈ CDecl</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  |  |  | Method Declaration |</p>

    <p class="text-gray-300">|  |  |  | M ::= m(x) {return t;} |</p>

    <p class="text-gray-300">| Terms |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s, t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">::= x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Variable</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s.m(t)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method invocation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">this</td>

            <td class="px-3 py-2 border-b border-gray-700">The current object</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">this with{ f = s}</td>

            <td class="px-3 py-2 border-b border-gray-700">Functional field update</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">null</td>

            <td class="px-3 py-2 border-b border-gray-700">Null value</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">if t then s1 else s2</td>

            <td class="px-3 py-2 border-b border-gray-700">If not zero</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">new C</td>

            <td class="px-3 py-2 border-b border-gray-700">Object creation</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">let x = s in t</td>

            <td class="px-3 py-2 border-b border-gray-700">Let</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">t instanceof C</td>

            <td class="px-3 py-2 border-b border-gray-700">Instance-of test</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">escape s</td>

            <td class="px-3 py-2 border-b border-gray-700">Escape</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">isnull t</td>

            <td class="px-3 py-2 border-b border-gray-700">Null test</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">capture</td>

            <td class="px-3 py-2 border-b border-gray-700">Capture</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">s ⊕ t</td>

            <td class="px-3 py-2 border-b border-gray-700">Integer operations</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">Nondeterministic choice</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| Values |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">o, v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">::= {C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f = v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Object</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">null</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Null value</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2. Syntax of COCO</p>

    <p class="text-gray-300">and term this with  <span class="math">\\{g = s\\}</span>  creates a new object identical to the object denoted by this, except each  <span class="math">g_{i}</span>  is mapped to the result of evaluating  <span class="math">s_i</span> .</p>

    <p class="text-gray-300">Term  <span class="math">s \\llbracket t</span>  concurrently evaluates both  <span class="math">s</span>  and  <span class="math">t</span> ; if either evaluates to some value  <span class="math">v</span> ,  <span class="math">s \\llbracket t</span>  may evaluate to  <span class="math">v</span> . We use term  <span class="math">s \\llbracket t</span>  to provide a limited model of both concurrency and nondeterministic choice.</p>

    <p class="text-gray-300">We provide a simple mechanism to model how values can escape the context where they are created (e.g., through imperative state, communication, exceptions or coroutines—none of which exist in COCO). This explicit modeling allows code in a class to temporarily violate object invariants, so long as it can ensure that all objects that may escape satisfy object invariants. We use escape and capture to mark where objects escape and where escaped objects may be used, thus allowing us to avoid defining semantics for object invariants, or defining an escape analysis. Term escape  <span class="math">t</span>  evaluates  <span class="math">t</span>  to a value  <span class="math">v</span> , marks  <span class="math">v</span>  as "escaping" by appending it to a list  <span class="math">S</span>  of escaped values, and evaluates to  <span class="math">v</span> . Term capture nondeterministically evaluates to any value in  <span class="math">S</span>  (i.e., that previously escaped). If a class does not contain any escape terms, then a value owned by that class can escape only if it is passed as an argument to a method (of another class) that may apply escape to it, or if it is returned from a method.</p>

    <p class="text-gray-300">Judgment  <span class="math">CT, \\rho \\vdash \\langle t, S \\rangle \\to \\langle t&#x27;, S&#x27; \\rangle</span>  indicates that, under class table  <span class="math">CT</span> , and environment  <span class="math">\\rho</span> , term  <span class="math">t</span>  takes one small step to  <span class="math">t&#x27;</span> , with the list of escaped values growing from  <span class="math">S</span>  to  <span class="math">S&#x27;</span> . Figure 3 defines inference rules for this judgment. When a small step evaluation of  <span class="math">t</span>  evaluates an escape  <span class="math">v</span>  term then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">E\\coloneqq [\\cdot ]</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">isnull  <span class="math">E\\mid E\\oplus t\\mid v\\oplus E\\mid</span>  if  <span class="math">E</span>  then  <span class="math">s</span>  else  <span class="math">t\\mid E</span>  instanceof  <span class="math">C\\mid E.m(t)\\mid v.m(E)</span>  this with  <span class="math">\\{\\overline{g = v},f = E,\\overline{g^{\\prime} = t}\\} \\mid E\\llbracket t\\mid t\\rrbracket E\\mid</span>  let  <span class="math">x = E</span>  in  <span class="math">t\\mid</span>  escape  <span class="math">E</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle s,S\\rangle \\to \\langle t,S^{\\prime}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle s,S\\rangle \\to \\langle s^{\\prime},S^{\\prime}\\rangle</span> <span class="math">CT,\\rho \\vdash \\langle E[s],S\\rangle \\to \\langle E[s^{\\prime}],S^{\\prime}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\rho (x) = v</span> <span class="math">CT,\\rho \\vdash \\langle x,S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\rho (\\mathbf{this}) = v</span> <span class="math">CT,\\rho \\vdash \\langle \\mathbf{this},S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle i_1\\oplus i_2,S\\rangle \\to \\langle i,S\\rangle</span> <span class="math">i_{1}\\oplus i_{2} = i</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{isnull}\\mathbf{null},S\\rangle \\to \\langle 1,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{isnull}v,S\\rangle \\to \\langle 0,S\\rangle</span> <span class="math">v\\neq \\mathbf{null}</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\text{if } i \\text{ then } s_1 \\text{ else } s_2, S \\rangle \\rightarrow \\langle s_1, S \\rangle</span> <span class="math">i \\neq 0</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\text{if } 0 \\text{ then } s_1 \\text{ else } s_2, S \\rangle \\rightarrow \\langle s_2, S \\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\{C\\mid \\overline{f = u}\\}</span>  instanceof  <span class="math">C,S\\rangle \\to \\langle 1,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle v\\text{instanceof} C,S\\rangle \\to \\langle 0,S\\rangle</span> <span class="math">v\\neq \\{C\\mid \\overline{f = u}\\}</span></p>

    <p class="text-gray-300"><span class="math">\\rho (\\mathbf{this}) = \\{C\\mid \\overline{f = u},g = v\\}</span> <span class="math">CT,\\rho \\vdash \\langle \\mathbf{this}.g,S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT(C) = \\text{class}\\{\\text{fields} \\overline{f}; \\text{meths} \\overline{M}\\}</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{new}C,S\\rangle \\to \\langle \\{C\\mid \\overline{f = \\mathbf{null}}\\} ,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">v_{1} = \\{C\\mid \\overline{f = u}\\}</span> <span class="math">CT(C) = \\mathbf{class}\\{\\mathbf{fields}\\overline{f};\\mathbf{meths}\\overline{M},m(x)\\{\\mathbf{return}t;\\}\\}</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle v_{1}.m(v_{2}),S\\rangle \\to \\langle \\mathbf{mcall}(t,[\\mathbf{this}\\mapsto v_{1},x\\mapsto v_{2}]),S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho^{\\prime}\\vdash \\langle t,S\\rangle \\to \\langle t^{\\prime},S^{\\prime}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{mcall}(t,\\rho^{\\prime}),S\\rangle \\to \\langle \\mathbf{mcall}(t^{\\prime},\\rho^{\\prime}),S^{\\prime}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{mcall}(v,\\rho^{\\prime}),S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\rho (\\mathbf{this}) = \\{C\\mid \\overline{f = u},\\overline{g = v}\\}</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{this}\\mathbf{with}\\{\\overline{g = v^{\\prime}}\\} ,S\\rangle \\to \\langle \\{C\\mid \\overline{f = u},\\overline{g = v^{\\prime}}\\} ,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{let}x = u\\mathbf{in}v,S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho [x\\mapsto v]\\vdash \\langle t,S\\rangle \\to \\langle t^{\\prime},S^{\\prime}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{let}x = v\\mathbf{in}t,S\\rangle \\to \\langle \\mathbf{let}x = v\\mathbf{in}t^{\\prime},S^{\\prime}\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle v\\llbracket t,S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle t\\llbracket v,S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{escape}v,S\\rangle \\to \\langle v,S\\bullet [v]\\rangle</span></p>

    <p class="text-gray-300"><span class="math">v\\in S</span></p>

    <p class="text-gray-300"><span class="math">CT,\\rho \\vdash \\langle \\mathbf{capture},S\\rangle \\to \\langle v,S\\rangle</span></p>

    <p class="text-gray-300">Figure 3. Operational semantics of COCO</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 4. Deep syntax of Coco</p>

    <p class="text-gray-300"><span class="math">S&#x27; = S \\bullet [v]</span>  (where  <span class="math">\\bullet</span>  denotes list concatenation); otherwise  <span class="math">S&#x27; = S</span> . We write  <span class="math">CT \\vdash \\langle t, S \\rangle \\rightarrow \\langle t&#x27;, S&#x27; \\rangle</span>  when environment  <span class="math">\\rho</span>  is empty and  <span class="math">CT \\vdash \\langle s, S \\rangle \\rightarrow^* \\langle t, S&#x27; \\rangle</span>  for zero or more sequential small steps. We write  <span class="math">\\emptyset</span>  for the empty list of escaped values.</p>

    <p class="text-gray-300">Environments  <span class="math">\\rho \\in \\mathbf{Var} \\cup \\{\\mathbf{this}\\} \\rightharpoonup \\mathbf{Val}</span>  map variables and this to values. We write  <span class="math">\\emptyset</span>  for the empty environment. Environments are modified by let terms and by method invocations. For instance, let  <span class="math">x = v</span>  in  <span class="math">t</span>  steps to let  <span class="math">x = v</span>  in  <span class="math">t&#x27;</span>  by evaluating  <span class="math">t</span>  in an environment where  <span class="math">\\rho</span>  has been extended to  <span class="math">\\rho[x \\mapsto v]</span> .</p>

    <p class="text-gray-300">To define the operational semantics of method calls, we extend the surface syntax (Figure 2) with a new syntactic form,  <span class="math">\\mathbf{mcall}(t,\\rho)</span> , which is used to indicate a partially evaluated method call. The extended syntax is shown in Figure 4. In the remainder of the paper, we use "program" to mean a Coco term that uses just surface syntax, and does not contain a term of the form  <span class="math">\\mathbf{mcall}(t,\\rho)</span> .</p>

    <p class="text-gray-300">Intuitively, term  <span class="math">v.m(u)</span>  invokes method  <span class="math">m</span>  on object  <span class="math">v</span> , passing value  <span class="math">u</span>  as an argument. If the class declaration of  <span class="math">v</span> 's class contains method declaration  <span class="math">m(x)\\{\\text{return } t; \\}</span> , then  <span class="math">v.m(u)</span>  steps to  <span class="math">\\mathbf{mcall}(t, [\\text{this} \\mapsto v, x \\mapsto u])</span> . More generally, term  <span class="math">\\mathbf{mcall}(t, \\rho)</span>  represents a method invocation that is currently executing, where  <span class="math">t</span>  is the rest of the method body to execute, and  <span class="math">\\rho</span>  is the environment for the callee. Note that unlike let terms, evaluation of  <span class="math">\\mathbf{mcall}</span>  replaces the current environment instead of extending it; this models the fact that all variables are local to a method.</p>

    <p class="text-gray-300">As mentioned previously, term escape  <span class="math">v</span>  adds  <span class="math">v</span>  to the list  <span class="math">S</span>  of escaped values, and capture evaluates nondeterministically to a previously escaped value. Note that the list of escaped values only increases during execution.</p>

    <p class="text-gray-300">A small-step evaluation of  <span class="math">s \\parallel t</span>  may take a step for either  <span class="math">s</span>  or  <span class="math">t</span>  (using appropriate evaluation contexts), or, if either  <span class="math">s</span>  or  <span class="math">t</span>  is a value, then it may step to that value.</p>

    <p class="text-gray-300">We say that a value  <span class="math">v</span>  is well-traced in class table  <span class="math">CT</span>  if there is some Coco program that can evaluate to  <span class="math">v</span>  using a class table that is consistent with  <span class="math">CT</span> .</p>

    <p class="text-gray-300">The property of well-tracedness is central to our goal of enforcing language semantics in distributed computation. Intuitively, if value  <span class="math">v</span>  is well-traced in class table  <span class="math">CT</span> , then  <span class="math">v</span>  could have been produced by a program execution that adhered to the language semantics, using class definitions that are compatible with class table  <span class="math">CT</span> , but possibly including additional classes.</p>

    <p class="text-gray-300">To formally define well-tracedness, we first introduce some notation, and define what it means for a value to be well-formed in a class table, and for one class table to extend another.</p>

    <p class="text-gray-300">We must first present some preliminary definitions. Judgment  <span class="math">CT \\vdash_{\\mathrm{ref}} v</span> , defined in Figure 5, indicates that  <span class="math">v</span>  is well-formed in class table  <span class="math">CT</span> . Intuitively, well-formedness requires that objects are syntactically consistent with their class definitions. That is, object  <span class="math">o = \\{C \\mid \\overline{f} = \\overline{v}\\}</span>  is well-formed if  <span class="math">C</span>  appears in  <span class="math">CT</span> , the fields  <span class="math">\\overline{f}</span>  bound by object  <span class="math">o</span>  are exactly the fields that the class  <span class="math">C</span>  has according to  <span class="math">CT</span> , and, recursively, the values  <span class="math">\\overline{v}</span>  that  <span class="math">o</span>  binds to fields are also well formed in  <span class="math">CT</span> . Well-formedness (unlike well-tracedness) is</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 5. Inference rules for well-formedness</p>

    <p class="text-gray-300">directly and efficiently checkable. If an object  <span class="math">o</span>  is not well formed, then  <span class="math">o</span>  is inconsistent with class table  <span class="math">CT</span> , and use of  <span class="math">o</span>  may result in stuck computation.</p>

    <p class="text-gray-300">Class table  <span class="math">CT</span>  extends class table  <span class="math">CT&#x27;</span>  when  <span class="math">CT</span>  contains all of the class declarations of  <span class="math">CT&#x27;</span> , and possibly some additional class declarations.</p>

    <p class="text-gray-300">Definition 1 (Class table extension). Class table  <span class="math">CT</span>  extends class table  <span class="math">CT&#x27;</span>  (written  <span class="math">CT \\supseteq CT&#x27;</span> ) if  <span class="math">\\operatorname{dom}(CT&#x27;) \\subseteq \\operatorname{dom}(CT)</span>  and for all  <span class="math">C \\in \\operatorname{dom}(CT&#x27;)</span> ,  <span class="math">CT(C) = CT&#x27;(C)</span> .</p>

    <p class="text-gray-300">We can now formally define well-tracedness:</p>

    <p class="text-gray-300">Definition 2 (Well-traced values). Value  <span class="math">v</span>  is well-traced in  <span class="math">CT</span>  if  <span class="math">CT \\vdash_{\\mathrm{wf}} v</span>  and there exist a class table  <span class="math">CT&#x27;</span>  and a program  <span class="math">t</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">C T ^ {\\prime} \\supseteq C T \\quad a n d \\quad C T ^ {\\prime} \\vdash \\langle t, S \\rangle \\rightarrow^ {*} \\langle v, S ^ {\\prime} \\rangle .</span></div>

    <p class="text-gray-300">Well-tracedness distinguishes syntactically well-formed values from values that can be produced by a Coco program. For integers, these notions coincide. However, for objects, well-tracedness plus encapsulation can ensure that fields satisfy nontrivial predicates (e.g., "this chess puzzle is solvable", "this is a valid RSA modulus, i.e., an integer which is the product of two large primes"). It is encapsulation that makes well-tracedness a useful property: in a calculus without encapsulation, the set of well-formed values and well-traced values typically coincide.</p>

    <p class="text-gray-300">Note that well-tracedness of a value does not imply that we know the computation that produced it. Class table  <span class="math">CT</span>  represents class definitions that are well-known and agreed upon by all parties, such as standard libraries and common application-specific classes (e.g., Puzzle, Board, and Move for the chess puzzle example). The computation that produced the value may use additional classes beyond those in  <span class="math">CT</span> . For example, the computation may use classes that are defined by another party in the distributed system, and represent proprietary algorithms or private data-structures of the other party.</p>

    <p class="text-gray-300">The inclusion in COCO of non-deterministic concurrent evaluation and terms escape and capture means that any object that escapes the dynamic scope of the owning class is well-traced. This permits a simple and intuitive definition of well-tracedness that includes such escaping objects, since if program  <span class="math">t</span>  allows value  <span class="math">v</span>  to escape, then program  <span class="math">t \\nVdash</span>  capture can evaluate to  <span class="math">v</span> , and thus  <span class="math">v</span>  is well-traced. For example, even if the classes in  <span class="math">CT</span>  do not include any escape terms, if their code passes a value  <span class="math">v</span>  to a method of an arbitrary class, then that could be a class in some  <span class="math">CT&#x27;</span>  (extending  <span class="math">CT</span> ) which invokes escape on  <span class="math">v</span> , which means we could write a COCO program that escapes  <span class="math">v</span> ; hence  <span class="math">v</span>  is well-traced in  <span class="math">CT</span> .</p>

    <p class="text-gray-300">COCO deliberately models only local computation without communication. This is so that we can define well-tracedness independently of communication with untrusted parties, which greatly simplifies</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Metavariable convention for names ch ranges over channel names Figure 6. Syntax of COCOCOMM (extending COCO)</p>

    <p class="text-gray-300">reasoning about well-traced values. In this section, we extend COCO to the calculus COCOCOMM by adding communication primitives. A COCOCOMM program represents the local computation of one party of a distributed computation; communication with other parties occurs by sending and receiving values on channels. COCOCOMM semantics ensure that all values received are well-traced in a common class table.</p>

    <p class="text-gray-300">COCOCOMM extends COCO with terms for sending and receiving values over channels. The syntax extension is given in Figure 6. Term send  <span class="math">t</span>  on  <span class="math">ch</span>  evaluates term  <span class="math">t</span>  to a value, which is sent over channel  <span class="math">ch</span> , and the term evaluates to the value sent. Term recv on  <span class="math">ch</span>  receives a value on channel  <span class="math">ch</span> . We require that values sent and received are well-formed in a common class table: a set of class names and definitions that all parties in a distributed computation have agreed upon in advance. The common class table ensures that a value received will be well-formed in the receiver's local class table, even though the local class tables of the sender and receiver may differ. This is analogous to restricting class serialization in Java to only classes from well-known and agreed-upon libraries.[2]</p>

    <p class="text-gray-300">Importantly, COCOCOMM semantics also require that any value received is well-traced in the common class table. Intuitively, this allows the recipient to use local reasoning to establish invariants about the received value. That is, the recipient can examine the code of the relevant classes in the common class table in order to reason about the received value. The recipient does not need to trust the sender of the value, or be concerned about how the value was produced. The challenge is to enforce the semantics of COCOCOMM, that is, to ensure that all values received are well-traced. We address this in Sections 5 and 6.</p>

    <p class="text-gray-300">Judgment  <span class="math">CT, CT_{\\mathsf{cmn}}, \\rho \\vdash_{\\mathsf{comm}} \\langle t, S \\rangle \\to \\langle t&#x27;, S&#x27; \\rangle</span>  indicates that COCOCOMM term  <span class="math">t</span>  takes one small step to term  <span class="math">t&#x27;</span> , using class table  <span class="math">CT</span>  and environment  <span class="math">\\rho</span> , using common class table  <span class="math">CT_{\\mathsf{cmn}}</span>  for communication, with the list of escaped values growing from  <span class="math">S</span>  to  <span class="math">S&#x27;</span> . Class table  <span class="math">CT</span>  must extend the common class table  <span class="math">CT_{\\mathsf{cmn}}</span> , i.e.,  <span class="math">CT \\supseteq CT_{\\mathsf{cmn}}</span> . Note that  <span class="math">CT_{\\mathsf{cmn}}</span>  is a COCO class table: the definitions of the classes of  <span class="math">CT_{\\mathsf{cmn}}</span>  do not contain any send or recv terms;  <span class="math">CT</span>  may, however, contain classes with send or recv terms. We write  <span class="math">CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{comm}} \\langle t, S \\rangle \\to^{*} \\langle t&#x27;, S&#x27; \\rangle</span>  to indicate that term  <span class="math">t</span>  can take zero or more steps to evaluate to term  <span class="math">t&#x27;</span>  (with an empty environment).</p>

    <p class="text-gray-300">Semantics for COCOCOMM are similar to that of COCO: for each inference rule in the operational semantics of COCO (Figure 3) there is a corresponding inference rule for COCOCOMM. In addition, we have inference rules for the terms send  <span class="math">t</span>  on  <span class="math">ch</span>  and recv on  <span class="math">ch</span> , given in Figure 7. The rule for send  <span class="math">t</span>  on  <span class="math">ch</span>  evaluates  <span class="math">t</span>  to a value, ensures that the value is well-formed in  <span class="math">CT_{\\mathrm{cmn}}</span> , and adds  <span class="math">v</span>  to the list of escaped values. The rule for recv on  <span class="math">ch</span>  nondeterministically receives some value  <span class="math">v</span>  that is well-traced in  <span class="math">CT_{\\mathrm{cmn}}</span> .</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 7. Semantics of COCOCOMM (extending COCO)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Example Consider the chess puzzle example from the Introduction. (The pseudo-code in Figure 1 is close to, but not exactly, COCO syntax.) Suppose class table  <span class="math">CT_{\\mathrm{cmn}}</span>  contains definitions for common classes, including Puzzle, Board, and Move. When object  $\\{\\text{Puzzle}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{remainingMoves} = n, \\text{board} = v\\}<span class="math">  is received, the fact that it is well-traced, combined with the class definitions in  </span>CT_{\\mathrm{cmn}}<span class="math"> , allows the recipient to reason that the puzzle must have a solution within  </span>n<span class="math">  moves. This holds, even though the recipient may not trust the sender, and has no idea how the sender produced the object. Indeed, the sender may have used proprietary code (in classes not in  </span>CT_{\\mathrm{cmn}}$ ) to compute the puzzle, or may have manufactured the puzzle without executing any COCO program.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">CocoComm is a strict extension of Coco: if  <span class="math">t</span>  is a Coco program that evaluates to value  <span class="math">v</span> , then it is also a CocoComm program that evaluates to  <span class="math">v</span> . The converse does not necessarily hold.</p>

    <p class="text-gray-300">Communication model We do not explicitly model the operation of CocoComm communication channels. In Section 5.2 we define a model for composing concurrently executing programs so that send and recv operations are matched up appropriately, but this model is deliberately underspecified with respect to whether communication is point-to-point, broadcast, in-order, reliable, etc. These details are not important for the purposes of this paper.</p>

    <p class="text-gray-300">CocoComm preserves well-tracedness, in that if a CocoComm program allows value  <span class="math">v</span>  to escape and  <span class="math">v</span>  is well-formed in  <span class="math">CT_{\\mathrm{cmn}}</span>  then  <span class="math">v</span>  is well-traced in  <span class="math">CT_{\\mathrm{cmn}}</span> .</p>

    <p class="text-gray-300">Theorem 1. Let  <span class="math">CT</span>  be a CocoComm class table and let  <span class="math">CT_{\\mathrm{cmn}}</span>  be a common class table such that  <span class="math">CT \\supseteq CT_{\\mathrm{cmn}}</span> . Let  <span class="math">t</span>  be a CocoComm program,  <span class="math">t&#x27;</span>  a term,  <span class="math">S</span>  a sequence of escaped values, and  <span class="math">v</span>  a value such that  <span class="math">v \\in S</span> . If</p>

    <div class="my-4 text-center"><span class="math-block">C T, C T _ {\\mathrm {c m n}} \\vdash_ {\\mathrm {c o m m}} \\langle t, \\emptyset \\rangle \\rightarrow^ {*} \\langle t ^ {\\prime}, S \\rangle</span></div>

    <p class="text-gray-300">and  <span class="math">CT_{\\mathrm{cmn}} \\vdash_{\\mathrm{wf}} v</span>  then  <span class="math">v</span>  is well-traced in  <span class="math">CT_{\\mathrm{cmn}}</span> .</p>

    <p class="text-gray-300">The proof of this theorem is in Appendix B.</p>

    <p class="text-gray-300">Theorem 1 has two key implications. First, a party using CocoComm to carry out its part of a distributed computation can be sure that values produced by its computation could also have been produced by a plain Coco program. The party does not need to be concerned that values received over channels can somehow violate properties that can be established by reasoning about only Coco programs. Despite communication with untrusted parties, it is as easy to reason about CocoComm programs as it is to reason about Coco programs.</p>

    <p class="text-gray-300">Figure 8. Receive rule for CocoTrust (modifying CocoComm.)</p>

    <p class="text-gray-300">Second, honest parties can indeed use CocoComm to perform a distributed computation, since any value that an honest party sends over a channel will be well-traced in  <span class="math">CT_{\\mathsf{cmn}}</span> , and can thus be accepted by the receiver. In other words, computation by honest parties will not get stuck due to sending non-well-traced values. Later, we will show that this is preserved when the assumption of honesty is replaced by cryptographic proofs.</p>

    <p class="text-gray-300">The CocoComm language enables a party in a distributed computation to reason locally about values received during computation, without trusting the senders. To enforce CocoComm semantics, we must ensure that only well-traced values are received. In this and the following section, we show how to enforce CocoComm semantics using Proof-Carrying Data (PCD) [8, 12], as follows.</p>

    <p class="text-gray-300">We introduce CocoTrust, which is similar to CocoComm except that the evaluation of recv does not check that received values are well-traced (Section 5.1). We show that if we have a distributed computation where all parties are executing CocoTrust programs, then received values are, nevertheless, well-traced (Section 5.2 and Theorem 2). Thus, to enforce CocoComm semantics, it suffices to ensure that all parties adhere to CocoTrust semantics.</p>

    <p class="text-gray-300">We provide an overview of PCD (Section 6.1), and develop a PCD compliance predicate that states that a computation adheres to CocoTrust semantics (Section 6.2). By instantiating PCD on this compliance predicate, a party can prove that its computation adhered to CocoTrust semantics, and, transitively, all values it received were also produced by CocoTrust semantics.</p>

    <p class="text-gray-300">We show that this yields a sound and complete proof system for well-tracedness of values (Section 6.3 and Theorems 3 and 4, using Theorem 2), and, moreover, a sound and complete proof system for CocoComm semantics (Section 6.4 and Theorems 5 and 6).</p>

    <p class="text-gray-300">CocoTrust shares its syntax of terms and evaluation contexts with CocoComm, and has a single (but crucial) relaxation in semantics. Judgment  <span class="math">CT, CT_{\\mathsf{cmn}}, \\rho \\vdash_{\\mathsf{trust}} \\langle t, S \\rangle \\to \\langle t&#x27;, S&#x27; \\rangle</span>  indicates that CocoComm term  <span class="math">t</span>  takes one small step to term  <span class="math">t&#x27;</span> , using class table  <span class="math">CT</span>  and environment  <span class="math">\\rho</span> , using common class table  <span class="math">CT_{\\mathsf{cmn}}</span>  for communication, with the list of escaped values growing from  <span class="math">S</span>  to  <span class="math">S&#x27;</span> . As before, we write  <span class="math">CT, CT_{\\mathsf{cmn}} \\vdash_{\\mathsf{trust}} \\langle t, S \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span>  to indicate that term  <span class="math">t</span>  can take zero or more steps, using CocoTrust semantics, to evaluate to term  <span class="math">t&#x27;</span>  (with an empty environment).</p>

    <p class="text-gray-300">Inference rules for the CocoTrust operational semantics are identical to those for CocoComm, with the exception of the rule for receiving values. Whereas CocoComm requires received values to be well-traced in the common class table  <span class="math">CT_{\\mathsf{cmn}}</span> , CocoTrust merely "trusts" that received values will be suitable. The CocoTrust rule for recv is shown in Figure 8; note that there is no premise for the rule, and thus no requirements on the received value  <span class="math">v</span> . Intuitively, the simplified rule for recv makes it easy to efficiently implement CocoTrust evaluation.</p>

    <p class="text-gray-300">Suppose that we have multiple parties, each of which is executing its own CocoTrust program, with common class table  <span class="math">CT_{\\mathsf{cmn}}</span> , and recv operations are matched up with appropriate send operations. As long</p>

    <p class="text-gray-300">as all parties are honest, i.e., adhere to CocoTrust semantics and <span class="math">CT_{\\mathsf{cmn}}</span>, all values received by parties will in fact be well-traced and thus CocoComm semantics are achieved.</p>

    <p class="text-gray-300">To model this, we define <em>distributed execution graphs</em>, which represent the parallel composition of CocoTrust programs with the sends and receives matched up appropriately. The nodes of a distributed execution graph represent zero or more computational steps taken by one of the parties. Directed edges between nodes indicate either local sequential evaluation for a single party (who first performs the computation represented by the source node, and then the computation represented by the target node), or communication between two parties (i.e., the last computational step of the source node is a send <span class="math">v</span> on <span class="math">ch</span> term, and <span class="math">v</span> is received by the first step of the target node).</p>

    <p class="text-gray-300">We first informally describe distributed execution graphs, and then present a formal definition, stated in a way that simplifies the subsequent use of PCD. The key observation is that in a distributed execution graph (where all parties are following CocoTrust semantics), all values received are well-traced, and thus CocoComm semantics are achieved.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Nodes of a distributed execution graph</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Each node in a distributed execution graph has a label of the form <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span> where <span class="math">CT</span> is a class table, <span class="math">t</span> and <span class="math">t^{\\prime}</span> are terms, and <span class="math">CT,CT_{\\mathsf{cmn}}\\vDash_{\\mathsf{trust}}\\langle t,S\\rangle\\to^{<em>}\\langle t^{\\prime},S^{\\prime}\\rangle</span>. Trace-witness <span class="math">W</span> allows us to efficiently check that <span class="math">CT,CT_{\\mathsf{cmn}}\\vDash_{\\mathsf{trust}}\\langle t,S\\rangle\\to^{</em>}\\langle t^{\\prime},S^{\\prime}\\rangle</span>. This will be useful when we instantiate PCD to help enforce CocoComm semantics. Trace-witnesses indicate how nondeterministic choices in the program were resolved. Formally, a <em>trace-witness</em> <span class="math">W</span> is a sequence defined by the grammar below, which indicates, for each step, whether the step was deterministic, or, if it was a nondeterministic choice $s\\mathbin{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}t<span class="math">, whether the left or right term was chosen (and how the nondeterministic choices of the subterm were evaluated), or, if it was a capture term, the index </span>i$ of the escaped value to which the term evaluated.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">U::=\\mathit{Det}\\mid\\mathit{Left}\\cdot U\\mid\\mathit{Right}\\cdot U\\mid i</span> <span class="math">W::=(U)^{*}</span></p>

    <p class="text-gray-300">We denote the set of possible trace-witnesses as <span class="math">\\mathcal{W}</span>.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Edges of a distributed execution graph</h4>

    <p class="text-gray-300">Edges between nodes of a distributed execution graph indicate either the continuation of the local <em>sequence</em> of evaluation or <em>communication</em>, and are labeled to indicate which. The labels also convey the information required for checking consistency between its source and destination nodes.</p>

    <p class="text-gray-300">A sequence edge between two nodes has label <span class="math">\\mathsf{seq}[CT,t^{\\prime},S^{\\prime}]</span>, indicating that the source node computation used class table <span class="math">CT</span> and the last term in the source node’s computation was <span class="math">t^{\\prime}</span> with escaped values <span class="math">S^{\\prime}</span>. The target node represents the continuation of the computation by the same party, so the target node’s computation will also use class table <span class="math">CT</span>, and the first term in the target node’s computation will be <span class="math">t^{\\prime}</span> with escaped values <span class="math">S^{\\prime}</span>.</p>

    <p class="text-gray-300">A communication edge between two nodes has label <span class="math">\\mathsf{msg}[v,ch]</span>, indicating that the source node sent value <span class="math">v</span> over channel <span class="math">ch</span>, and value <span class="math">v</span> was received by the target node. Thus, the last term of the source node must have the form <span class="math">F[\\textbf{send }v\\textbf{ on }ch]</span> for some context <span class="math">F</span>; and the first term of the target node must have the form <span class="math">F^{\\prime}[\\textbf{recv on }ch]</span> for some context <span class="math">F^{\\prime}</span> and then step to <span class="math">F^{\\prime}[v]</span>, indicating that the value <span class="math">v</span> was received. Here, contexts <span class="math">F</span> are used to identify send and recv terms that will be reduced in the next evaluation step.</p>

    <pre><code class="language-latex">$F\\coloneqq [\\cdot ]$  |isnull  $F$  |  $F\\oplus t$  |  $v\\oplus F$  |if  $F$  then s else t
|  $F$  instanceof  $C$  |  $F.m(t)$  |  $v.m(F)$
| send  $F$  on ch | this with  $\\{\\overline{g = v},f = F,\\overline{g^{\\prime} = t}\\}$
|  $F\\llbracket t|t\\llbracket F|$  escape  $F$
| let  $x = F$  in  $t$  | let  $x = v$  in  $F$  | mcall(F,  $\\rho$  )</code></pre>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 9. Contexts. Compared to COCOCOMM evaluation contexts, this adds let  <span class="math">x = v</span>  in  <span class="math">F</span>  and  <span class="math">\\mathbf{mcall}(F, \\rho)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 10. Cases for incoming edges of distributed execution graph nodes. Dashed nodes and edges indicate a typical (but not required) neighborhood. Here,  <span class="math">\\langle t,S\\rangle \\xrightarrow[CT]{*} \\langle t&#x27;,S&#x27;\\rangle</span>  is shorthand for  $CT,CT_{\\mathrm{cmn}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{trust}}<span class="math"> </span>\\langle t,S\\rangle \\to^{*}\\langle t',S'\\rangle$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Case (0): No incoming edges. Case (1): One incoming edge. Case (2): Two incoming edges.</p>

    <p class="text-gray-300">Contexts  <span class="math">F</span>  include the evaluation contexts of Figures 3 and 7 and also contexts for method calls mcall and let  <span class="math">x = v</span>  in  <span class="math">t</span>  expressions. Syntax for these contexts is given in Figure 9. <span class="math">^4</span></p>

    <p class="text-gray-300">We restrict the incoming and outgoing edges of nodes to ensure that the graph represents valid computation and communication between parties. For example, we ensure that no node has multiple incoming sequence edges. More precisely, we ensure that for each node  <span class="math">(CT, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W)</span> , there are only three possible cases for the incoming edges, enumerated here. (Diagrams illustrating the cases are given in Figure 10.)</p>

    <p class="text-gray-300">(0) No incoming edges. This node represents the start of a computation by a party, where  <span class="math">t</span>  is the program the party is executing. Escaped values  <span class="math">S</span>  should be empty. (1) One incoming sequence edge. This node represents the continuation of a local evaluation process: the parent node indicates that the party has evaluated the program up to term  <span class="math">t</span>  (and escaped values  <span class="math">S</span> ), and this node continues execution from  <span class="math">t</span>  (and using the same class table, and escaped values  <span class="math">S</span> ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Two incoming edges, consisting of one sequence edge and one communication edge. This node represents the continuation of an evaluation process (via a seq edge) after receiving a value via a msg edge from a sender. Note that the sender will typically continue its execution via another seq edge.</li>

    </ol>

    <p class="text-gray-300">We require that distributed execution graphs are acyclic to ensure that communication is causally ordered: messages aren’t received before they are sent. We also require that evaluation of a recv term receives exactly one value that was previously sent by a send term. We do not otherwise make assumptions about the operations of channels. For example, our model is agnostic as to whether message delivery is in-order or out-of-order, and is agnostic as to whether a sent value should be received at most once (i.e., point-to-point communication), or whether a sent value may be received multiple times along multiple communication edges (e.g., broadcast communication).</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Definition of distributed execution graphs</h4>

    <p class="text-gray-300">Before we formally define distributed execution graphs, we first introduce a helper function, check, that given class table <span class="math">CT</span>, configurations <span class="math">\\langle t,S\\rangle</span> and <span class="math">\\langle t^{\\prime},S^{\\prime}\\rangle</span>, and trace-witness <span class="math">W</span>, efficiently checks whether <span class="math">CT\\vdash\\langle t,S\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span>. Note that although terms <span class="math">t</span> and <span class="math">t^{\\prime}</span> may contain send and recv operations, the semantics are Coco, not CocoTrust. This means that <span class="math">t</span> evaluates to <span class="math">t^{\\prime}</span> without performing any send or receive operations.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proposition 1 (Existence of check).</h6>

    <p class="text-gray-300">There exists a polynomial-time algorithm</p>

    <p class="text-gray-300"><span class="math">\\textsf{check}:\\mathcal{CT}\\times\\big{(}\\textsf{Term}\\times\\textbf{List}(\\textsf{Val})\\,\\big{)}\\times</span> <span class="math">\\big{(}\\textsf{Term}\\times\\textbf{List}(\\textsf{Val})\\,\\big{)}\\times\\mathcal{W}\\rightarrow\\{0,1\\}</span></p>

    <p class="text-gray-300">such that whenever</p>

    <p class="text-gray-300"><span class="math">\\textsf{check}(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span></p>

    <p class="text-gray-300">it holds that <span class="math">CT\\vdash\\langle t,S\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span>.</p>

    <p class="text-gray-300">Define also a version that takes the common class table and skips any initial send if the value sent is well-formed in the common class table:</p>

    <p class="text-gray-300"><span class="math">\\textsf{check}^{\\prime}(CT,CT_{\\textsf{cmn}},\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=</span> \\[ \\begin{cases}\\textsf{check}(CT,\\langle F[v],S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)&\\text{if }t=F[\\textsf{send }v\\textbf{ on }ch]\\text{ and }CT_{\\textsf{cmn}}\\vdash_{\\textsf{wf}}v\\\\ \\textsf{check}(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)&\\text{otherwise}\\end{cases} \\]</p>

    <p class="text-gray-300">Implementation of check and check^{′} is straightforward: using the trace witness, we can efficiently find a derivation of <span class="math">CT\\vdash\\langle t,S\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span>. Moreover, trace-witnesses can be produced efficiently (which is needed to satisfy the PCD instantiation requirements).</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proposition 2 (Efficient trace-witness production).</h6>

    <p class="text-gray-300">There exists a polynomial-time algorithm that, given a derivation of <span class="math">CT\\vdash\\langle t,S\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span> yields trace-witness <span class="math">W</span> where <span class="math">\\textsf{check}(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span>.</p>

    <p class="text-gray-300">Note that the running time of check is polynomial in all of its inputs, including <span class="math">W</span>, which in turn is polynomial in the size of the derivation. However, it independent of the derivation of received messages (indeed, check verifies only plain Coco derivations).</p>

    <p class="text-gray-300">Distributed execution graphs are defined as follows.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 3 (Distributed execution graph).</h6>

    <p class="text-gray-300">Given a class table <span class="math">CT_{\\textsf{cmn}}</span>, a <em>distributed execution graph</em> using <span class="math">CT_{\\textsf{cmn}}</span> is a labeled directed acyclic graph fulfilling the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each node’s label is of the form <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span> where <span class="math">CT</span> is a class table, <span class="math">t</span> and <span class="math">t^{\\prime}</span> are terms, <span class="math">S</span> and <span class="math">S^{\\prime}</span> are lists of values, and <span class="math">W\\in\\mathcal{W}</span> is a trace-witness.</li>

    </ol>

    <p class="text-gray-300">. For each node <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span> and edge with label <span class="math">z_{\\text{out}}</span> exiting it, exactly one of the following holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{\\text{out}}=\\text{seq}[CT,t^{\\prime},S^{\\prime}]</span></li>

      <li><span class="math">z_{\\text{out}}=\\text{msg}[v,\\text{ch}]</span> for some value <span class="math">v</span> and channel <span class="math">ch</span>, such that <span class="math">t^{\\prime}=F[\\text{\\bf send }v\\text{\\bf on }ch]</span> for some context <span class="math">F</span>, and <span class="math">CT_{\\text{cmn}}\\vdash_{\\text{wf}}v</span></li>

      <li>For each node <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span> and its list <span class="math">\\vec{z}_{\\text{in}}</span> of incoming edges, exactly one of the following holds:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\vec{z}_{\\text{in}}</span> is empty and:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">CT</span> extends <span class="math">CT_{\\text{cmn}}</span></li>

      <li><span class="math">\\text{check}^{\\prime}(CT,CT_{\\text{cmn}},\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span></li>

      <li><span class="math">t</span> is a program (i.e., it contains only surface syntax)</li>

      <li><span class="math">S</span> is the empty list <span class="math">\\emptyset</span>.</li>

      <li><span class="math">\\vec{z}_{\\text{in}}=(\\text{ seq}[CT_{\\text{E}},t_{\\text{E}},S_{\\text{E}}]\\,)</span> such that:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">CT_{\\text{E}}=CT</span> and <span class="math">t_{\\text{E}}=t</span> and <span class="math">S_{\\text{E}}=S</span></li>

      <li><span class="math">\\text{check}^{\\prime}(CT,CT_{\\text{cmn}},\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span></li>

      <li><span class="math">\\vec{z}_{\\text{in}}=(\\text{ seq}[CT_{\\text{E}},t_{\\text{E}},S_{\\text{E}}],\\text{ msg}[v,\\text{ch}]\\,)</span> such that:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">CT_{\\text{E}}=CT</span> and <span class="math">t_{\\text{E}}=t</span> and <span class="math">S_{\\text{E}}=S</span></li>

      <li><span class="math">t=F[\\text{\\bf recv on }ch]</span> for some context <span class="math">F</span></li>

      <li><span class="math">\\text{check}(CT,\\langle F[v],S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span></li>

    </ol>

    <p class="text-gray-300">Distributed execution graphs represent the execution of communicating CocoTrust (rather than CocoComm) programs. Recall, however, that CocoComm semantics differ from CocoTrust semantics only in requiring received values to be well-traced. Since the distributed execution graph explicitly shows the “pedigree” of each received value, it implies that all received values are in fact well-traced, and thus, CocoComm semantics hold for all nodes in the graph:</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">In a distributed execution graph, for every node labeled <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">CT,CT_{\\text{cmn}}\\vdash_{\\text{comm}}\\langle t,S\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle\\enspace.</span></p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By induction on the structure of the graph. Since the graph is acyclic, the induction is well founded. The induction hypothesis is that for any node <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span>, there exists a program <span class="math">t_{0}</span> such that <span class="math">CT,CT_{\\text{cmn}}\\vdash_{\\text{comm}}\\langle t_{0},\\emptyset\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span> and moreover, if <span class="math">t^{\\prime}=F[\\text{\\bf send }v\\text{\\bf on }ch]</span> and <span class="math">CT_{\\text{cmn}}\\vdash_{\\text{wf}}v</span> then <span class="math">v</span> is well-traced in <span class="math">CT_{\\text{cmn}}</span>.</p>

    <p class="text-gray-300">We will use the following lemma, which is straightforward from the definitions:</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">For any program <span class="math">t_{0}</span>, terms <span class="math">t</span>,<span class="math">t^{\\prime}</span>, class tables <span class="math">CT</span>,<span class="math">CT_{\\text{cmn}}</span>, lists <span class="math">S</span>,<span class="math">S^{\\prime}</span> and trace witness <span class="math">W</span>: if</p>

    <p class="text-gray-300"><span class="math">CT,CT_{\\text{cmn}}\\vdash_{\\text{comm}}\\langle t_{0},\\emptyset\\rangle\\rightarrow^{*}\\langle t,S^{\\prime}\\rangle\\quad\\text{and}\\quad\\text{check}^{\\prime}(CT,CT_{\\text{cmn}},\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span></p>

    <p class="text-gray-300">then</p>

    <p class="text-gray-300"><span class="math">CT,CT_{\\text{cmn}}\\vdash_{\\text{comm}}\\langle t_{0},\\emptyset\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle\\enspace.</span></p>

    <p class="text-gray-300">Consider node <span class="math">n</span>, labeled <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span>. Assume the inductive hypothesis holds for all nodes that can reach <span class="math">n</span>. To show that there exists a program <span class="math">t_{0}</span> such that <span class="math">CT,CT_{\\text{cmn}}\\vdash_{\\text{comm}}\\langle t_{0},\\emptyset\\rangle\\rightarrow^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span>, consider the cases of the incoming edges to <span class="math">n</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The cases of no incoming edges is straightforward, letting <span class="math">t_{0}=t</span> and noting condition c(0) in Definition 3 and the definition of <span class="math">\\mathsf{check}^{\\prime}</span>.</li>

      <li>In the case of a single incoming edge (<span class="math">\\mathsf{seq}[CT_{\\mathsf{E}},t_{\\mathsf{E}},S_{\\mathsf{E}}]</span>), we know by condition c(1)i of Definition 3 that <span class="math">CT_{\\mathsf{E}}=CT</span> and <span class="math">t_{\\mathsf{E}}=t</span> and <span class="math">S_{\\mathsf{E}}=S</span>, and then by condition b(i) of Definition 3 that this edge exited some parent node of the form <span class="math">(CT,\\langle\\cdot,\\cdot\\rangle,\\langle t,S\\rangle,\\cdot)</span>. By the induction hypothesis applied to the parent, there exists a program <span class="math">t_{0}</span> such that $CT,CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny</li>

    </ol>

    <p class="text-gray-300">{čomm}}}\\langle t_{0},\\emptyset\\rangle\\to^{*}\\langle t,S\\rangle$.</p>

    <p class="text-gray-300">By condition c(1)ii of Definition 3, <span class="math">\\mathsf{check}^{\\prime}(CT,CT_{\\mathsf{cmn}},\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span> and thus by Lemma 1, <span class="math">CT,CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny {čomm}}}\\langle t_{0},\\emptyset\\rangle\\to^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span> as required.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the case of two incoming edges, these are <span class="math">\\mathsf{seq}[CT_{\\mathsf{E}},t_{\\mathsf{E}}S_{\\mathsf{E}}]</span> and <span class="math">\\mathsf{msg}[u,ch]</span>. Similarly to the above, we deduce from conditions c(2)i and b(i) of Definition 3 that there exists a program <span class="math">t_{0}</span> such that $CT,CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny</li>

    </ol>

    <p class="text-gray-300">{čomm}}}\\langle t_{0},\\emptyset\\rangle\\to^{*}\\langle t,S\\rangle<span class="math">. Moreover, by condition c(2)ii, </span>t=F[\\mathsf{recv\\ on\\ }ch]<span class="math"> for some context </span>F$.</p>

    <p class="text-gray-300">By condition b(ii), the parent of the edge <span class="math">\\mathsf{msg}[u,ch]</span> is node of the form <span class="math">(\\cdot,\\cdot,\\langle F_{2}[\\mathsf{send\\ }u\\ \\mathsf{on\\ }ch],\\cdot\\rangle,\\cdot)</span> for some context <span class="math">F_{2}</span>, and <span class="math">CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny {čof}}}\\ u</span>. Thus, by the induction hypothesis, <span class="math">u</span> is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span>, and thus by CocoComm semantics, <span class="math">CT,CT_{\\mathsf{cmn}}\\vdash\\langle F[\\mathsf{recv\\ on\\ }ch],S\\rangle\\to\\langle F[u],S\\rangle</span>.</p>

    <p class="text-gray-300">Concatenating these derivations, we get: <span class="math">CT,CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny {čomm}}}\\langle t_{0},\\emptyset\\rangle\\to^{<em>}\\langle F[u],S\\rangle</span>. Also, by condition c(2)iii, <span class="math">\\mathsf{check}(CT,\\langle F[u],S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)=1</span> and thus by Lemma 1, <span class="math">CT,CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny {čomm}}}\\langle t_{0},\\emptyset\\rangle\\to^{</em>}\\langle t^{\\prime},S^{\\prime}\\rangle</span> as required.</p>

    <p class="text-gray-300">There remains to show that if <span class="math">t^{\\prime}=F[\\mathsf{send\\ }v\\ \\mathsf{on\\ }ch]</span> for some <span class="math">v</span>, and <span class="math">CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny {čof}}}\\ v</span>, then <span class="math">v</span> is well-traced. Indeed, since <span class="math">\\mathsf{send\\ }v\\ \\mathsf{on\\ }ch</span> adds <span class="math">v</span> to the list of escaped values, we have <span class="math">CT,CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny {čomm}}}\\langle t_{0}\\llbracket\\mathsf{capture},\\emptyset\\rangle\\to^{*}\\langle v,S^{\\prime}\\rangle</span>, and so by Theorem 1, <span class="math">v</span> is well-traced.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">The key implication of this theorem is that to show that a received value is well-traced, it suffices to show that the computation that sent the value (and, transitively, any computation on which the sender depended) adhered to CocoTrust semantics. We can achieve this by instantiating PCD appropriately, which we do in the following subsections.</p>

    <p class="text-gray-300">A corollary of this theorem is that in a distributed execution graph, any value sent or received is well-traced.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">In a distributed execution graph, for every edge labeled <span class="math">\\mathsf{msg}[v,\\,ch]</span>, <span class="math">v</span> is well-traced in class table <span class="math">CT_{\\mathsf{cmn}}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider the source node of an edge <span class="math">\\mathsf{msg}[v,\\,ch]</span>, and suppose it is <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span>. Term <span class="math">t^{\\prime}</span> must be of the form <span class="math">F[\\mathsf{send\\ }v\\ \\mathsf{on\\ }ch]</span> for some <span class="math">F</span>. By the structure of the graph, and by Theorem 2 there is a program <span class="math">t_{0}</span> such that <span class="math">CT,CT_{\\mathsf{cmn}}\\vbox{\\hbox{\\tiny {čomm}}}\\langle t_{0},\\emptyset\\rangle\\to^{*}\\langle F[v],S^{\\prime}\\bullet[v]\\rangle</span>. By Theorem 1 we have that <span class="math">v</span> is well-traced, as required. ∎</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Modeling computation with distributed execution graphs</h4>

    <p class="text-gray-300">In this paper distributed execution graphs <em>define</em> a model of concurrently executing, communicating CocoTrust programs. Below, we argue informally that this is indeed a reasonable model of distributed computation.</p>

    <p class="text-gray-300">First, distributed execution graphs are “intuitively sound,” in the sense that every distributed execution graph maps to a scenario of parties executing CocoTrust programs on distinct hardware and sending messages via a network. Second, they are “intuitively complete,” in the sense that given a pool of communicating CocoTrust interpreters, we can construct a distributed execution graph representing this. Note that while formal soundness and completeness results could be proved with respect to a (for instance) CSP-style model of CocoTrust, we would still need an informal argument to show that the CSP-style model itself is reasonable.</p>

    <p class="text-gray-300">Third, a distributed execution graph can be incrementally constructed as a system of CocoTrust programs executes using the following process. As the programs execute they may nondeterministically perform the following actions on the distributed execution graph:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Add an unlabeled node (representing a prospective derivation)</li>

      <li>Add an edge labeled <span class="math">\\mathsf{seq}[CT,t,S]</span> from a labeled node <span class="math">n</span> to an unlabeled node <span class="math">n^{\\prime}</span> (representing <span class="math">n^{\\prime}</span> continuing evaluation from configuration <span class="math">\\langle t,S\\rangle</span>)</li>

      <li>Add an edge labeled <span class="math">\\mathsf{msg}[v,ch]</span> from a labeled node <span class="math">n</span> to an unlabeled node <span class="math">n^{\\prime}</span> (representing <span class="math">n</span> sending the value <span class="math">v</span> to <span class="math">n^{\\prime}</span> on channel <span class="math">ch</span>)</li>

      <li>Label an unlabeled node (representing the actual derivation and nondeterministic choices)</li>

    </ol>

    <p class="text-gray-300">This process can be more fully specified to ensure that the resulting distributed execution graph satisfies the appropriate constraints and accurately reflects the execution of the CocoTrust programs.</p>

    <h2 id="sec-34" class="text-2xl font-bold">6 Proof Carrying Data</h2>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">6.1 Overview of PCD</h3>

    <p class="text-gray-300">Proof Carrying Data (PCD), introduced by Chiesa and Tromer <em>[12, 13]</em> and developed by Bitansky et al. <em>[7, 8]</em>, is a cryptographic mechanism for ensuring that a given property is maintained at every step of a distributed computation among mutually-untrusting parties. The designated property is specified as a compliance predicate, and all messages between parties are accompanied by a proof that the message’s data, along with all of the distributed computation leading to that message, satisfies the compliance predicate.</p>

    <p class="text-gray-300">We first recall the key definitions of PCD, which capture the notion of a distributed computation that is compliant with a designated property, and define a PCD system that proves and verifies such compliance. See Bitansky et al. <em>[7]</em> for formal definitions.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Distributed computation transcripts</h4>

    <p class="text-gray-300">Distributed computations are viewed as directed acyclic multi-graphs with vertex labels and edge labels. Vertices represent the computation of programs, and edges represent messages sent between these programs. Such graphs are called distributed computation transcripts.</p>

    <p class="text-gray-300">In our case, an “honest” distributed computation transcript will be a distributed execution graph. Thus, node labels should be of the form <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span>, edge labels should be of the form <span class="math">\\mathsf{seq}[CT,t,S]</span> or <span class="math">\\mathsf{msg}[v,ch]</span>, and the conditions in Definition 3 should hold. But verifying these conditions is up to the PCD system.</p>

    <p class="text-gray-300">In a proof-carrying distributed computation transcript, every edge label <span class="math">z_{i}</span> is augmented with another proof string label <span class="math">\\pi_{i}</span>. Figure 11 shows an example.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Compliance</h4>

    <p class="text-gray-300">A compliance predicate <span class="math">\\mathbb{C}</span> is a polynomial-time computable predicate for a node in a distributed computation transcript. Intuitively, a compliance predicate is a locally verifiable property: the predicate can be checked using just information that is available at a node. By choosing an appropriate compliance predicate, global properties may hold if all nodes in a distributed transaction graph satisfy the compliance predicate.</p>

    <p class="text-gray-300">More precisely, <span class="math">\\mathbb{C}(z_{\\mathsf{out}};\\mathsf{linp},\\vec{z}_{\\mathsf{in}})</span> observes the local environment of a node in a distributed computation transcript: the list of received inputs <span class="math">\\vec{z}_{\\mathsf{in}}</span>; an (alleged) output <span class="math">z_{\\mathsf{out}}</span>; and the node’s label, or local input,</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 11. Example of a proof-carrying distributed computation transcript. Node labels ("local inputs") are denoted  <span class="math">\\mathrm{linp}_i</span> , edge labels  <span class="math">z_i</span> , and proof strings  <span class="math">\\pi_i</span> . Omitting proof strings gives the corresponding (non-proof-carrying) distributed computation transcript. When checking compliance of node  <span class="math">\\mathrm{linp_H}</span> ,  <span class="math">\\mathbb{C}</span>  checks the values marked by solid boxes. When proving compliance,  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span>  additionally gets the incoming proofs, marked by dashed boxes, and outputs  <span class="math">\\pi_{11}</span> .</p>

    <p class="text-gray-300">denoted linp. The label linp contains the executed program and any associated local data (in our case, it will be the local class table  <span class="math">CT</span> , configurations  <span class="math">\\langle t, S \\rangle</span>  and  <span class="math">\\langle t&#x27;, S&#x27; \\rangle</span> , and trace-witness  <span class="math">W</span> ). Given a distributed computation transcript  <span class="math">DCT</span> , we say that node  <span class="math">n</span>  in  <span class="math">DCT</span> , with inputs  <span class="math">\\vec{z}_{\\mathrm{in}}</span>  and local input linp, is  <span class="math">\\mathbb{C}</span> -compliant if  <span class="math">\\mathbb{C}(z_{\\mathrm{out}}, \\mathrm{linp}, \\vec{z}_{\\mathrm{in}})</span>  holds for every output  <span class="math">z_{\\mathrm{out}}</span>  of  <span class="math">n</span>  (see Figure 11). We say that  <span class="math">DCT</span>  is  <span class="math">\\mathbb{C}</span> -compliant if every node in the graph is  <span class="math">\\mathbb{C}</span> -compliant. We say that a string  <span class="math">z</span>  is  <span class="math">\\mathbb{C}</span> -compliant if there exists a  <span class="math">\\mathbb{C}</span> -compliant distributed computation transcript containing an edge labeled  <span class="math">z</span> .</p>

    <p class="text-gray-300">PCD syntax and operation A PCD system for a compliance predicate  <span class="math">\\mathbb{C}</span>  is a triple of algorithms  <span class="math">(\\mathbb{G},\\mathbb{P}_{\\mathbb{C}},\\mathbb{V}_{\\mathbb{C}})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PCD generator  <span class="math">\\mathbb{G}</span> , given an integer  <span class="math">\\kappa</span>  as a key size, outputs a key  <span class="math">k</span>  which will be used by  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span>  to generate proofs and by  <span class="math">\\mathbb{V}_{\\mathbb{C}}</span>  to verify them.</li>

      <li>PCD prover  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span> : Let  <span class="math">k</span>  be a key, let  <span class="math">\\vec{z}_{\\mathrm{in}}</span>  be a list of inputs and  <span class="math">\\vec{\\pi}_{\\mathrm{in}}</span>  be corresponding proof strings, let  <span class="math">\\mathrm{linp}</span>  be a local input string, and let  <span class="math">z_{\\mathrm{out}}</span>  be an output string. Then  <span class="math">\\mathbb{P}_{\\mathbb{C}}(k,\\vec{z}_{\\mathrm{in}},\\vec{\\pi}_{\\mathrm{in}},\\mathrm{linp},z_{\\mathrm{out}})</span>  outputs a proof string  <span class="math">\\pi_{\\mathrm{out}}</span>  for the claim that  <span class="math">z_{\\mathrm{out}}</span>  is  <span class="math">\\mathbb{C}</span> -compliant.</li>

      <li>PCD verifier  <span class="math">\\mathbb{V}_{\\mathbb{C}}</span> : Let  <span class="math">k</span>  be a key, let  <span class="math">z_{\\mathrm{out}}</span>  be an output string and  <span class="math">\\pi_{\\mathrm{out}}</span>  a corresponding proof string. Then  <span class="math">\\mathbb{V}_{\\mathbb{C}}(k,z_{\\mathrm{out}},\\pi_{\\mathrm{out}})</span>  is meant to accept only if convinced that  <span class="math">z_{\\mathrm{out}}</span>  is  <span class="math">\\mathbb{C}</span> -compliant.</li>

    </ul>

    <p class="text-gray-300">Using these algorithms, a distributed computation transcript is dynamically compiled into a proof-carrying distributed computation transcript by generating and adding "on the fly" a proof string to each edge (see Figure 11). The process of generating proof strings is defined inductively, starting from the source nodes in the transcript graph. Consider a node  <span class="math">n</span>  in the transcript, with local input  <span class="math">\\mathrm{linp}</span> , received inputs  <span class="math">\\vec{z}_{\\mathrm{in}}</span>  and corresponding proofs  <span class="math">\\vec{\\pi}_{\\mathrm{in}}</span> , and an output  <span class="math">z_{\\mathrm{out}}</span> . Use prover  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span>  to produce a new proof string  <span class="math">\\pi_{\\mathrm{out}}</span>  for its output  <span class="math">z_{\\mathrm{out}}</span>  (given the inputs of  <span class="math">n</span> , their corresponding generated proof strings, the program of  <span class="math">n</span> , and its output). Proof strings generated in this way form the additional label on the edges in the resulting proof-carrying transcript.</p>

    <p class="text-gray-300">The triple  <span class="math">(\\mathbb{G},\\mathbb{P}_{\\mathbb{C}},\\mathbb{V}_{\\mathbb{C}})</span>  must satisfy three properties. The first two bound the complexity of proving and verifying, and the third is computational soundness, discussed next.</p>

    <p class="text-gray-300">Completeness and asymptotically-efficient proving The PCD prover can prove true statements, and do so efficiently. Whenever it is indeed the case that a given distributed computation transcript is  <span class="math">\\mathbb{C}</span> -compliant,</p>

    <p class="text-gray-300">one can use the PCD prover  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span>  to generate proof strings for each message, and all of these proof strings will be accepted by the PCD verifier. The generation of these proofs runs in time that is polynomial in the key size  <span class="math">\\kappa</span>  and the time it took to run  <span class="math">\\mathbb{C}</span>  at every node in the distributed computation transcript. <span class="math">^9</span></p>

    <p class="text-gray-300">Efficient verification Proof strings generated by the PCD prover have length polynomial in the key size  <span class="math">\\kappa</span> , and are efficiently verifiable by the PCD verifier:  <span class="math">\\mathbb{V}_{\\mathbb{C}}(k, z_{\\mathrm{out}}, \\pi_{\\mathrm{out}})</span>  runs in time polynomial in  <span class="math">\\kappa</span>  and the length of the string  <span class="math">z_{\\mathrm{out}}</span> . In particular, the proof length and verification time are independent of how long it took to evaluate  <span class="math">\\mathbb{C}</span>  and run  <span class="math">\\mathbb{P}_{\\mathbb{C}}</span> .</p>

    <p class="text-gray-300">Soundness notion 11 It is computationally infeasible to prove false statements. This is expressed as follows. Let  <span class="math">\\tilde{\\mathbb{P}}</span>  be any efficient cheating prover, i.e., a deterministic algorithm running in time polynomial in the key size  <span class="math">\\kappa</span> . After a key  <span class="math">k \\gets \\mathbb{G}(1^{\\kappa})</span>  is randomly generated,  <span class="math">\\tilde{\\mathbb{P}}(k)</span>  outputs some non-compliant string  <span class="math">z</span>  along with a proof string  <span class="math">\\pi</span> , and tries to use  <span class="math">\\pi</span>  to falsely convince  <span class="math">\\mathbb{V}_{\\mathbb{C}}</span>  that  <span class="math">z</span>  is compliant. Then, we are guaranteed that  <span class="math">\\mathbb{V}_{\\mathbb{C}}(k, z, \\pi)</span>  will accept this false claim with negligible probability  <span class="math">\\kappa^{-\\omega(1)}</span>  (i.e., smaller than  <span class="math">1/p(\\kappa)</span>  for any polynomial  <span class="math">p</span> ). Formally:</p>

    <p class="text-gray-300">Definition 4 (PCD soundness).  <span class="math">(\\mathbb{G},\\mathbb{P}_{\\mathbb{C}},\\mathbb{V}_{\\mathbb{C}})</span>  is sound if for every efficient cheating-prover algorithm  <span class="math">\\tilde{\\mathbb{P}}</span>  and key size  <span class="math">\\kappa \\in \\mathbb{N}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {k \\leftarrow \\mathbb {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c c} &amp;amp; (z, \\pi) \\leftarrow \\tilde {\\mathbb {P}} (k) \\\\ \\wedge &amp;amp; \\mathbb {V} _ {\\mathbb {C}} (k, z, \\pi) = 1 \\\\ \\wedge &amp;amp; z \\text {i s n o t} \\mathbb {C} - c o m p l i a n t \\end{array} \\right] \\leq \\kappa^ {- \\omega (1)}</span></div>

    <p class="text-gray-300">Construction of PCD There are two known approaches to constructing PCD systems. The first, sketched in Section 2, is based on probabilistically-checkable proofs (PCPs). It relies on standard cryptographic assumptions (collision-resistant hashing and signatures), and requires parties to have access to a trusted oracle (e.g., a secure hardware token or trusted network service) that signs its inputs and produces fresh randomness. An asymptotically-efficient construction is known [12], and there has been recent progress towards the requisite concretely-efficient PCPs [2].</p>

    <p class="text-gray-300">An alternative approach starts with the special case of PCD for a single message, called computationally-sound proofs of knowledge [33] or Succinct Non-interactive ARguments of Knowledge (SNARKs) which can be constructed without any trusted oracles, under a large class of assumptions [6]. SNARKs have been recently implemented for C programs [3, 4] and a restricted subset thereof [40], using approaches based on knowledge-of-exponent assumptions [26][31][23][9], in the relaxed "preprocessing" sense, where  <span class="math">\\mathbb{G}</span>  is allowed to run for time polynomial in that of  <span class="math">\\mathbb{C}</span> . These are practical for very small programs, and research efforts are underway to improve efficiency. Using bootstrapping [8], such SNARKs (in principle) suffice to construct PCD systems without oracles, for a restricted but large set of distributed execution graph structures.</p>

    <p class="text-gray-300">6.2 A compliance predicate for well-tracedness</p>

    <p class="text-gray-300">We shall use PCD to prove well-tracedness of values sent by a system of communicating CocoComm programs. A common class table <span class="math">CT_{\\mathsf{cmn}}</span> will be fixed in advance, and every value <span class="math">v</span> sent during an (honest) execution will accompanied by a proof that <span class="math">v</span> is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span>.</p>

    <p class="text-gray-300">Consider a system of communicating CocoComm programs using common class table <span class="math">CT_{\\mathsf{cmn}}</span>, that sends value <span class="math">v</span> from one party to another on channel <span class="math">ch</span>. If this computation is honest, then by the completeness of distributed execution graphs, there is a distributed execution graph <span class="math">DEG</span> with an edge labeled <span class="math">\\mathsf{msg}[v,ch]</span>. We shall define a PCD compliance predicate <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span> that enables efficiently proving the existence of such a <span class="math">DEG</span>.</p>

    <p class="text-gray-300">The compliance predicate <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span> will be applied to the nodes of a distributed computation transcript that is <em>allegedly</em> a distributed execution graph. The role of <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span> is to check that the nodes in the transcript indeed fulfill the constraints defined in Definition 3, i.e., that each node’s label describes a correct CocoTrust derivation that is consistent with the incoming and outgoing edges’ labels.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 5 (Compliance predicate enforcing <span class="math">CT_{\\mathsf{cmn}}</span>).</h6>

    <p class="text-gray-300">For a Coco class table <span class="math">CT_{\\mathsf{cmn}}</span>, the compliance predicate enforcing <span class="math">CT_{\\mathsf{cmn}}</span> is denoted <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>. Given local input <span class="math">\\mathsf{linp}</span>, inputs <span class="math">\\vec{z}_{\\mathsf{in}}</span> and (alleged) output <span class="math">z_{\\mathsf{out}}</span>, <span class="math">\\mathbb{C}_{\\mathsf{cmn}}(z_{\\mathsf{out}},\\mathsf{linp},\\vec{z}_{\\mathsf{in}})</span> accepts if:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{linp}</span> is the form <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span> where <span class="math">CT</span> is a class table, <span class="math">t</span> and <span class="math">t^{\\prime}</span> are terms, <span class="math">S</span> and <span class="math">S^{\\prime}</span> are lists of values, and <span class="math">W\\in\\mathcal{W}</span> is a trace-witness, and for these:</li>

      <li>Condition b(i) or b(ii) from Definition 3 holds, and</li>

      <li>Condition c(0), c(1), or c(2) from Definition 3 holds.</li>

    </ol>

    <h6 id="sec-39" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">CT_{\\mathsf{cmn}}</span> be a Coco class table. Then every <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>-compliant distributed computation transcript is also a distributed execution graph using <span class="math">CT_{\\mathsf{cmn}}</span>, and vice versa.</p>

    <p class="text-gray-300">The above is obvious from the definitions. Thus:</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">CT_{\\mathsf{cmn}}</span> be a Coco class table, let <span class="math">v</span> be a value, and <span class="math">ch</span> a channel. If <span class="math">z=\\mathsf{msg}[v,ch]</span> is <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>-compliant then <span class="math">v</span> is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">As <span class="math">z</span> is <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>-compliant, there exists a <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>-compliant distributed computation transcript <span class="math">DCT</span> containing an edge labeled <span class="math">z</span>. By Lemma 2, <span class="math">DCT</span> is a distributed execution graph using <span class="math">CT_{\\mathsf{cmn}}</span>, and thus by Corollary 1, <span class="math">v</span> is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span>. ∎</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">6.3 Verifying well-tracedness</h3>

    <p class="text-gray-300">By plugging compliance predicate <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span> into a PCD construction, we obtain a PCD system <span class="math">(\\mathbb{G},\\mathbb{P}_{\\mathbb{C}_{\\mathsf{cmn}}},\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}})</span>. This PCD system is both sound and complete for efficiently verifying well-tracedness of values. This means that given a well-traced value <span class="math">v</span>, it is possible to construct a proof that <span class="math">v</span> is well-traced, and if we accept a proof that <span class="math">v</span> is well-traced, then it is indeed well-traced (up to a negligible probability of error). This is key to enforcing CocoComm semantics, which we will see in Section 6.4.</p>

    <h5 id="sec-43" class="text-base font-semibold mt-4">Soundness for well-tracedness</h5>

    <p class="text-gray-300">To verify well-tracedness of a value <span class="math">v</span> with a proof <span class="math">\\pi</span>, we run <span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(k,\\mathsf{msg}[v,ch],\\pi)</span>, where <span class="math">k</span> is the key generated by <span class="math">\\mathbb{G}</span> (the channel <span class="math">ch</span> does not matter, but is syntactically necessary since <span class="math">\\mathbb{V}_{\\mathbb{C}}</span> expects to verify edge labels of a distributed execution graph). Soundness of the PCD system means that if an efficient cheating-prover algorithm generates a string <span class="math">z=\\mathsf{msg}[v,ch]</span> claiming that <span class="math">v</span> is well-traced, along with an alleged proof <span class="math">\\pi</span> for this (as before <span class="math">ch</span> does not matter), but <span class="math">v</span> is actually not well-traced, then <span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(z,\\pi)</span> will accept only with negligible probability (smaller than any <span class="math">1/\\mathrm{poly}(\\kappa)</span>). Formally:</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Theorem 3 (Soundness of PCD for well-tracedness).</h6>

    <p class="text-gray-300">For any Coco class table <span class="math">CT_{\\mathsf{cmn}}</span>, any efficient cheating-prover algorithm <span class="math">\\tilde{\\mathbb{P}}</span>, and every key size <span class="math">\\kappa</span>:</p>

    <p class="text-gray-300">\\[ \\Pr_{k\\leftarrow\\mathbb{G}(1^{\\kappa})}\\left[\\begin{array}[]{c}(z,\\pi)\\leftarrow\\tilde{\\mathbb{P}}(k)\\\\ \\wedge\\ \\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(k,z,\\pi)=1\\\\ \\wedge\\ \\exists v,ch:z=(\\mathsf{msg}[v,ch])\\\\ \\ \\ \\ \\ \\ \\ \\ \\wedge\\ v\\ \\text{is not well-traced in}\\ CT_{\\mathsf{cmn}}\\end{array}\\right]\\leq\\kappa^{-\\omega(1)} \\]</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The soundness of the PCD system <span class="math">(\\mathbb{G},\\mathbb{P}_{\\mathbb{C}},\\mathbb{V}_{\\mathbb{C}})</span>, according to Definition 4, means that whenever the verifier accepts <span class="math">(z,\\pi)</span>, it’s true that <span class="math">z</span> is <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>-compliant (up to negligible probability). By Lemma 3, if <span class="math">z=\\mathsf{msg}[v,ch]</span> then <span class="math">v</span> is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span> (up to negligible probability). ∎</p>

    <h5 id="sec-46" class="text-base font-semibold mt-4">Completeness for well-tracedness</h5>

    <p class="text-gray-300">The PCD system is complete in that if we have a well-traced value with a known derivation, then we can efficiently produce a proof for its well-tracedness:</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 4 (Completeness of PCD for well-tracedness).</h6>

    <p class="text-gray-300">Let <span class="math">CT_{\\mathsf{cmn}}</span> be a Coco class table, and let <span class="math">v</span> be a well-traced value in <span class="math">CT_{\\mathsf{cmn}}</span>, witnessed by <span class="math">CT^{\\prime}\\vdash\\langle t,\\emptyset\\rangle\\to^{*}\\langle v,S\\rangle</span> where <span class="math">CT^{\\prime}</span> is a Coco class table such that <span class="math">CT^{\\prime}\\supseteq CT_{\\mathsf{cmn}}</span>. Consider the CocoTrust execution</p>

    <p class="text-gray-300"><span class="math">CT^{\\prime},CT_{\\mathsf{cmn}}\\vdash_{\\mathsf{trust}}\\langle\\textbf{send}\\ t\\ \\textbf{on}\\ ch,\\emptyset\\rangle\\to^{*}\\langle v,S\\bullet[v]\\rangle</span></p>

    <p class="text-gray-300">Let <span class="math">W</span> be the trace-witness corresponding to the above derivation (by Proposition 2) and let <span class="math">\\limp=(CT,\\langle\\textbf{send}\\ t\\ \\textbf{on}\\ ch,\\emptyset\\rangle,\\langle v,S\\bullet[v]\\rangle,W)</span>.</p>

    <p class="text-gray-300">Then for any key size <span class="math">\\kappa</span> and key <span class="math">k\\leftarrow\\mathbb{G}(1^{\\kappa})</span>, the proof <span class="math">\\pi=\\mathbb{P}_{\\mathbb{C}_{\\mathsf{cmn}}}(k,\\emptyset,\\emptyset,\\limp,\\mathsf{msg}[v,ch])</span> is always accepted:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}(k,\\mathsf{msg}[v,ch],\\pi)=1.</span></p>

    <p class="text-gray-300">Moreover, <span class="math">\\pi</span> is computed in time polynomial in the size of the derivation <span class="math">CT\\vdash\\langle t,\\emptyset\\rangle\\to^{*}\\langle v,S\\rangle</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider the graph <span class="math">DEG</span> consisting of a node labeled <span class="math">\\limp</span>, with no input edges, and single outgoing edge labeled <span class="math">z</span> going to another node labeled <span class="math">(CT_{\\mathsf{cmn}},\\langle\\textbf{recv}\\ \\textbf{on}\\ ch,\\emptyset\\rangle,\\langle v,\\emptyset\\rangle,\\emptyset)</span>. It is readily verified to be a distributed execution graph using <span class="math">CT_{\\mathsf{cmn}}</span>, and thus by Lemma 2, <span class="math">DEG</span> is also a <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>-compliant distributed computation transcript. The claim then follows from the completeness of the PCD system. Efficiency follows from <span class="math">\\mathbb{P}_{\\mathbb{C}_{\\mathsf{cmn}}}</span> being polynomial-time in its inputs, and the size of <span class="math">W</span> being polynomial in the size of the derivation. ∎</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">6.4 Verifying correctness of CocoComm executions</h3>

    <p class="text-gray-300">The PCD system <span class="math">(\\mathbb{G},\\mathbb{P}_{\\mathbb{C}_{\\mathsf{cmn}}},\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}})</span> can be used to verify the correct execution of a number of parties, each of which is executing its own CocoComm program. That is, we can use the PCD system to build a runtime system for CocoComm that correctly enforces semantics even when non-well-traced values are received from rogue parties.</p>

    <h5 id="sec-50" class="text-base font-semibold mt-4">Soundness for CocoComm executions</h5>

    <p class="text-gray-300">A party who performs a CocoTrust evaluation, and uses <span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}</span> to verify every received value, can rest assured that (except with negligible probability) the evaluation follows the stricter CocoComm semantics: the probability that <span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathsf{cmn}}}</span> accepts all received values, and yet the evaluation violates CocoComm semantics, is negligible (smaller than any <span class="math">1/\\mathrm{poly}(\\kappa)</span>). Formally:</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 5 (Soundness of verifying CocoComm).</h6>

    <p class="text-gray-300">Consider a CocoTrust derivation:</p>

    <p class="text-gray-300"><span class="math">CT,CT_{\\mathsf{cmn}}\\vdash_{\\mathsf{trust}}\\langle t,S\\rangle\\to^{*}\\langle t^{\\prime},S^{\\prime}\\rangle</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Let <span class="math">(v_{i},ch_{i})_{i = 1}^{\\ell}</span> be the list of values, and corresponding channels, received in this derivation. Then for any efficient cheating-prover algorithm  <span class="math">\\tilde{\\mathbb{P}}^{\\prime}</span> , and every key size  <span class="math">\\kappa</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {k \\leftarrow \\mathbb {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c} \\pi_ {i} \\leftarrow \\tilde {\\mathbb {P}} ^ {\\prime} (k, i) \\text { for } 1.. \\ell \\\\ \\wedge \\mathbb {V} _ {\\mathbb {C} _ {\\mathrm {c m n}}} \\big (k, \\mathsf {m s g} [ v _ {i}, c h _ {i} ] \\pi_ {i} \\big) = 1 \\text { for } 1.. \\ell \\\\ \\wedge \\neg C T, C T _ {\\mathrm {c m n}} \\vdash_ {\\mathrm {c o m m}} \\langle t, S \\rangle \\to^ {*} \\langle t ^ {\\prime}, S ^ {\\prime} \\rangle \\end{array} \\right] \\leq \\kappa^ {- \\omega (1)}</span></div>

    <p class="text-gray-300">Proof. The only difference between the semantics of CocoComm and CocoTrust is the premise of the recv rule, so the above probability is bounded by:</p>

    <div class="my-4 text-center"><span class="math-block">\\leq \\Pr_ {k \\leftarrow \\mathbb {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c} \\pi_ {i} \\leftarrow \\tilde {\\mathbb {P}} ^ {\\prime} (k, i) \\text { for } 1.. \\ell \\\\ \\wedge \\exists i \\in 1.. \\ell : \\mathbb {V} _ {\\mathbb {C} _ {\\mathrm {c m n}}} \\big (k, \\mathsf {m s g} [ v _ {i}, c h _ {i} ] \\pi_ {i} \\big) = 1 \\\\ \\wedge v _ {i} \\text { is not well-traced in } C T _ {\\mathrm {c m n}} \\end{array} \\right]</span></div>

    <p class="text-gray-300">Invoking the union bound on the events for separate  <span class="math">i</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\leq \\sum_ {i = 1} ^ {\\ell} \\Pr_ {k \\leftarrow \\mathbb {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c} \\pi_ {i} \\leftarrow \\tilde {\\mathbb {P}} ^ {\\prime} (k, i) \\\\ \\wedge \\mathbb {V} _ {\\mathbb {C} _ {\\mathrm {c m n}}} \\big (k, \\mathsf {m s g} [ v _ {i}, c h _ {i} ] \\pi_ {i} \\big) = 1 \\\\ \\wedge v _ {i} \\text { is not well-traced in } C T _ {\\mathrm {c m n}} \\end{array} \\right]</span></div>

    <p class="text-gray-300">and invoking Theorem 3 (with  <span class="math">\\tilde{\\mathbb{P}}</span>  derived from  <span class="math">\\tilde{\\mathbb{P}}^{\\prime}</span>  by hardcoding  <span class="math">i</span>  and  <span class="math">z = \\mathsf{msg}[v_i, ch_i]</span> ):</p>

    <div class="my-4 text-center"><span class="math-block">\\leq \\sum_ {i = 1} ^ {\\ell} \\kappa^ {- \\omega (1)} \\leq \\kappa^ {- \\omega (1)}</span></div>

    <p class="text-gray-300">Proof generation Generating the above proof requires an inductive process accompanying the whole computation. Every time a party in the computation sends a message (msg edge) or pauses its derivation to receive a message (seq edge), it will run the PCD prover  <span class="math">\\mathbb{P}_{\\mathbb{C}_{\\mathrm{cmn}}}</span>  to produce a proof that the computation was correct so far. Thus, we modify the process for incremental generation of a distributed execution graph (Section 5.2) to ensure that each edge also has a proof associated with it. <span class="math">^{13}</span>  Initially, we run the PCD generator  <span class="math">\\mathbb{G}</span>  with a sufficiently large key size  <span class="math">\\kappa</span>  to obtain a key  <span class="math">k \\gets \\mathbb{G}(1^{\\kappa})</span> . Then we run the following proof generation process: every time a new edge is added (Operations 2 and 3), with edge label  <span class="math">z_{\\mathrm{out}}</span> , exiting a node labeled  <span class="math">\\mathrm{linp} = (CT, \\langle t, S \\rangle, \\langle t&#x27;, S&#x27; \\rangle, W)</span>  whose incoming edges are labeled  <span class="math">\\vec{z}_{\\mathrm{in}}</span>  with associated proofs  <span class="math">\\vec{\\pi}_{\\mathrm{in}}</span> , we generate the proof  <span class="math">\\pi = \\mathbb{P}_{\\mathbb{C}_{\\mathrm{cmn}}} (k, \\vec{z}_{\\mathrm{in}}, \\vec{\\pi}_{\\mathrm{in}}, \\mathrm{linp}, z_{\\mathrm{out}})</span>  and associate  <span class="math">\\pi</span>  with the edge. (See Section 2 for a more concrete but less precise account.)</p>

    <p class="text-gray-300">Completeness for CocoComm executions The proofs constructed as above are indeed accepted by the PCD verifier (which follows easily from PCD completeness):</p>

    <p class="text-gray-300">Theorem 6 (Completeness of verifying CocoComm). Let  <span class="math">DEG</span>  be a distributed execution graph using Coco class table  <span class="math">CT_{\\mathrm{cmn}}</span> . Consider an edge  <span class="math">e</span>  in  <span class="math">DEG</span> , labeled  <span class="math">z</span> , from node  <span class="math">n</span>  to node  <span class="math">n&#x27;</span> . Consider any key size  <span class="math">\\kappa</span>  and key  <span class="math">k \\gets \\mathbb{G}(1^{\\kappa})</span> . Let  <span class="math">\\pi</span>  be a proof associated with  <span class="math">e</span>  by the above proof generation process. Then  <span class="math">\\pi</span>  is accepted:  <span class="math">\\mathbb{V}_{\\mathbb{C}_{\\mathrm{cmn}}} (k, z, \\pi) = 1</span> .</p>

    <p class="text-gray-300">Moreover, the running time of the proof generation process for edge  <span class="math">e</span>  is polynomial in the size of the derivation associated with node  <span class="math">n</span> .</p>

    <p class="text-gray-300">27</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider <span class="math">DEG^{\\prime}</span>, the subgraph of <span class="math">DEG</span> consisting of <span class="math">n^{\\prime}</span>, and all nodes that can reach <span class="math">n^{\\prime}</span> (which of course includes <span class="math">n</span>). <span class="math">DEG^{\\prime}</span> is also a distributed execution graph using <span class="math">CT_{\\mathsf{cmn}}</span>, and is thus a <span class="math">\\mathbb{C}_{\\mathsf{cmn}}</span>-compliant distributed computation transcript. Acceptance of <span class="math">\\pi</span> thus follows from the completeness property of PCD (observing that the aforementioned proof generation process is essentially identical to the ProofGen process of <em>Bitansky et al. [7]</em>).</p>

    <p class="text-gray-300">Let the label of <span class="math">n</span> be <span class="math">(CT,\\langle t,S\\rangle,\\langle t^{\\prime},S^{\\prime}\\rangle,W)</span>; then efficiency follows from <span class="math">\\mathbb{P}_{\\mathbb{C}_{\\mathsf{cmn}}}</span> being polynomial-time in its inputs, and the size of <span class="math">W</span> being polynomial in the size of the derivationto which it attests. ∎</p>

    <h5 id="sec-53" class="text-base font-semibold mt-4">Remarks</h5>

    <p class="text-gray-300">In the above soundness definitions, the received values are independent of the PCD key <span class="math">k</span>. The stronger property of adaptive soundness, where <span class="math">v_{i}</span> and <span class="math">ch_{i}</span> (and thus the resulting derivation) are allowed to depend on <span class="math">k</span>, holds as well (due to the adaptive soundness of the underlying PCD system).</p>

    <p class="text-gray-300">A natural optimization is the case where, in a distributed computation, there exists a clique of trusted parties <span class="math">Q</span> that trust each other, but not others. The parties in <span class="math">Q</span> can then verify messages received from outside <span class="math">Q</span>, but omit verification of messages within <span class="math">Q</span>, and still deduce that their (various) derivations follow CocoComm semantics.</p>

    <h2 id="sec-54" class="text-2xl font-bold">7 Extensions</h2>

    <p class="text-gray-300">Coco is an intentionally minimal calculus, intended to capture essential language features and match them to the PCD formalism, while maintaining simplicity. However, our techniques can be extended to handle more expressive language features, and to provide stronger guarantees for consumers of verified values.</p>

    <p class="text-gray-300">Imperative state, including a heap, can be added in a straightforward manner. State is threaded through the operational semantics of the language (as with the list of escaped values), and sent values are accompanied by a heap, which includes all locations that are transitively reachable from the value. When a value and heap are received, locations in the received heap are renamed to ensure disjointness from the current heap, and then the received heap is unioned with the current heap. The definition of distributed execution graphs is extended to enforce state consistency.</p>

    <p class="text-gray-300">With the addition of state, we would no longer require the use of escape and capture terms to help define well-tracedness, since the language would now contain another, more standard, mechanism by which values may escape the dynamic scope of an owning class.</p>

    <p class="text-gray-300">Concurrency is already modeled by the nondeterministic choice operator <span class="math">s\\mathbin{\\rVert}t</span>, although threads are not guaranteed to run to completion. This can be remedied by adding a concurrent composition operator. Additional mechanisms for synchronization and communication between threads could also be added.</p>

    <p class="text-gray-300">Evolution of values from known past ones (e.g., showing that the computation to produce value <span class="math">v^{\\prime}</span> used value <span class="math">v</span>) is a stronger property than well-tracedness (which allows an arbitrary semantically-allowed history). For example, consider a protocol for a <em>chess game</em> (as opposed to the aforementioned <em>chess puzzle</em>), where White sends value <span class="math">v</span> describing a board, subsequently receives value <span class="math">v^{\\prime}</span> supposedly representing the board after Black’s move, and wishes to ensure that <span class="math">v^{\\prime}</span> is actually the result of a computation that starts with <span class="math">v</span> and legally moves a single Black piece to produce <span class="math">v^{\\prime}</span>.</p>

    <p class="text-gray-300">Such properties can be enforced using mechanisms within the programming language, and do not require modifications to the language, or to the runtime mechanism for enforcing well-tracedness. One approach is to ensure that classes in <span class="math">CT_{\\mathsf{cmn}}</span> contain a field that is an append-only log of past states (or a cryptographic compression thereof, using hash functions), and the field is updated appropriately by methods of the class. For example, an object representing a chess board may contain a log of all previous chess boards that led up to it. This ensures that the object itself is recording its evolution, and well-tracedness suffices to allow reasoning about the evolution of the value.</p>

    <p class="text-gray-300">Another approach is to add a field id to a class, and the value of this field is only modified by method setId(r) { return (this with {id = owf(r)}); } where owf is a cryptographic one-way hash function. Given an object <span class="math">v</span> with a particular value <span class="math">n</span> for the field id, <span class="math">v</span> was produced either by evolution from another object <span class="math">v^{\\prime}</span> with id equal to <span class="math">n</span>, or by a computation that knows a value <span class="math">i</span> such that owf(<span class="math">i</span>)<span class="math">=n</span>. For example, White sets the id field of a board <span class="math">v</span> by calling setId(r) with a large random integer r, and upon receiving <span class="math">v^{\\prime}</span>, verifies that <span class="math">v^{\\prime}.\\texttt{getId}()</span>=<span class="math">v.\\texttt{getId}()</span>. Either <span class="math">v^{\\prime}</span> evolved from <span class="math">v</span>, or Black found a preimage of owf, which is by definition infeasible.</p>

    <p class="text-gray-300">Enforcing encapsulation by the language semantics, along with enforcing of those semantics, enable local language-level reasoning about received values. However, in Java, it is difficult to enforce encapsulation, due to reflection. In order for our technique to be useful, we anticipate that it will be necessary to restrict the use of reflection and any other mechanisms that may violate encapsulation, or otherwise prevent local reasoning. Indeed, many sophisticated Java language analyses are sound only in the absence of reflection.</p>

    <p class="text-gray-300">Note that in our setting we use encapsulation to enforce integrity: ensuring that values of fields of objects are consistent with using the public interface of the object. We are not able to use encapsulation to enforce confidentiality, since a malicious party receiving an object could always violate language semantics to <em>examine</em> the values of fields of that object (e.g., by peeking into the interpreter’s in-memory representation of values). PCD will only detect violation of language semantics if the malicious party attempts to send a non-well-traced value.</p>

    <p class="text-gray-300">Interaction with the external environment can be modeled in Coco by treating inputs as nondeterministic choices. However, this does not <em>enforce</em> that choice resolution is “truly external.” To do so we could add input operators to Coco, and make the PCD compliance predicate verify inputs are cryptographically signed by suitable input devices, parties in the environment, etc.</p>

    <p class="text-gray-300">Proof of knowledge is a security property of computational proof systems that is stronger than mere soundness. At times, there is a difference between proving that value <span class="math">v</span> is well-traced and proving that one <em>knows</em> a program that (efficiently) produces <span class="math">v</span>. This is especially true in programs that use cryptography. For example, consider the class BobPayment which sets its field amount to an integer <span class="math">i</span> only when a method BobPayment.check is called with arguments <span class="math">i</span> and <span class="math">u</span>, where <span class="math">u</span> is a digital signature on <span class="math">i</span> that verifies under Bob’s (hard-coded) signature verification key. Suppose Alice sends Bob the value <span class="math">v=\\{\\texttt{BobPayment}\\mid\\texttt{amount}</span>=<span class="math">1000000\\}</span> and a proof that <span class="math">v</span> is well-traced. Should Bob be convinced that he owes her <span class="math">1M? Clearly a valid signature on “1000000” <em>exists</em>, so </span>v<span class="math"> is trivially well-traced regardless of whether Alice actually received the signature. However Alice cannot <em>efficiently compute</em> the signature by herself, so if she <em>efficiently</em> produced </span>v<span class="math"> following Coco semantics, then Bob should indeed be convinced. Our proof system indeed (nontrivially) supports reasoning about the computational complexity of producing values. PCD systems offer, beyond mere soundness, the guarantee of <em>proof of knowledge</em> <em>[7]</em>, which implies essentially the following: whenever the verifier accepts, </span>\\mathbb{V}_{\\mathbb{C}_{\\texttt{cmn}}}(k,\\texttt{msg}[v,ch],\\pi)=1<span class="math">, the (possibly cheating) prover that produced </span>\\pi<span class="math"> actually “knows” the full derivation of the value </span>v$ and “could have” written it down with similar complexity.</p>

    <p class="text-gray-300">Zero-knowledge is another useful property of proof systems, meaning essentially that when the verifier accepts, all it learns is that the value is well-traced, and nothing else about its derivation. In particular, if the sender had secrets, they are not revealed by the proof he produces, a desirable property in any other application where a party has proprietary algorithms or private data (such as the chess puzzle example of the Introduction). Our approach provides zero knowledge when invoked using suitable PCD systems <em>[7]</em> or SNARKs <em>[3, 4, 40]</em>.</p>

    <p class="text-gray-300">##</p>

    <h2 id="sec-55" class="text-2xl font-bold">8 Related work</h2>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Verifiable computing</h4>

    <p class="text-gray-300">The Proof-Carrying Data mechanism lies in the broad area of verifiable computing, which has been extensively studied from a cryptographic perspective. Verifying general, distributed interaction requires the full power of PCD systems whose construction was discussed in Section 6.1.</p>

    <p class="text-gray-300">An important special case is Succinct Noninteractive Arguments of Knowledge (SNARKs) which, beside being an ingredient for PCDs as discussed in Section 6.1, are also of direct use for proving correct execution of stand-alone programs (e.g., outsourcing a computational task to a cloud server, and requiring a proof of the results’ correctness). Recently, concrete SNARK systems were implemented for proving correct execution of C programs. One is restricted to constant memory access and control flow <em>[40]</em>, and another supports arbitrary control flow and memory accesses (by implementing a simulated random-access machine) <em>[4]</em> and even self-modifying code <em>[3]</em>. Those works focus on the cryptographic and algorithmic implementations and are complementary to the present paper. In particular, they consider only the case of stand-alone programs (rather than distributed computation), and do not address issues of enforcing well-tracedness and invariants of values, for which the C language is unsuitable due to lack of strong encapsulation. Our work can thus be construed as looking ahead to potential uses and a program analysis approach for exploiting the “raw power” of the cryptographic implementations, once they achieve full PCD and sufficient efficiency.</p>

    <p class="text-gray-300">If one relaxes the requirements to allow the verifier to send queries back to the prover (instead of proofs piggy-backing on existing messages), then <em>interactive proof systems</em> are relevant, including recent highly-optimized implementations (see Vu et al. <em>[49]</em> and references therein). If one further relaxes the verifier efficiency requirement, then many <em>secure multiparty computation</em> and <em>secure function evaluation</em> techniques become relevant. When simultaneously verifying many claims, one can use efficient <em>batching arguments</em> (see Setty et al. <em>[44]</em> and references therein). Some restricted classes of computation, such as those expressible as low-depth circuits, have especially efficient proof systems <em>[24]</em> which were recently implemented (see Thaler <em>[46]</em> and references therein).</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Automatic program partitioning</h4>

    <p class="text-gray-300">Jif/Split <em>[51, 52]</em> automatically partitions single-threaded programs annotated with security types <em>[42]</em> into a program distributed across potentially mutually distrusting host machines. The partitioning ensures that if computation of a value is declared to be independent of a given host, then that host is unable to corrupt or influence the computation of the value. This enables sound reasoning at the language-level of abstraction about the distributed computation: the value computed by the distributed system will be the same as the value computed by the single-threaded program unless one or more of the hosts upon which the computation depends (as indicated by the security-type annotations) is malicious. In Jif/Split, if a host is corrupted, then no computation they perform can be trusted. By contrast, our system allows trust to be gained in computation performed by a corrupted or malicious host: values received from hosts are checked to ensure they are well-traced, which enables sound reasoning about properties that the value must satisfy. However, our system is not suitable for restricting the flow of information in a distributed system, and is thus, is not suitable for enforcing confidentiality requirements.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Enforcing language semantics</h4>

    <p class="text-gray-300">Our work ensures that values received over a network were produced according to CocoComm semantics, thus enabling sound reasoning about such values at the level of language abstractions, even in the presence of malicious parties. We do not know of existing work exploring this problem.</p>

    <p class="text-gray-300">Much previous work seeks to enforce language-level semantics in different settings, typically on a single execution platform, or against different classes of faults.</p>

    <p class="text-gray-300">Safe deserialization of objects, as discussed in Section 1, is extensively discussed in Bloch’s book on practical Java programming <em>[10, Chapter 11]</em>. Pointing out that “serialization is an extralinguistic mechanism for creating objects”, Bloch presents several attacks that cause objects to be deserialized</p>

    <p class="text-gray-300">into a state that cannot be reached through their public interfaces (i.e., attacks that create non-well-traced objects). Although Bloch describes methods for defensive programming to avoid these attacks, the solutions are manual and error-prone. Similar concerns are raised in CERT’s Secure Coding Standard for Java entries SER06-J and SER07-J <em>[11]</em>, in Common Weakness Enumeration entry CWE-502 <em>[34]</em>, and the references therein.</p>

    <p class="text-gray-300">Numerous works seek to enforce memory safety in C and C-like programs, including CCured <em>[37]</em>, Cyclone <em>[25, 28]</em>, and SAFECode <em>[18, 19]</em>. SAFECode in particular states that their mechanism enables certain analyses to be sound (points-to graph, call graph, and a subset of type information).</p>

    <p class="text-gray-300">Perry et al. <em>[41]</em> present a type system that can detect transient hardware faults (a single local corruption) in assembly programs, by maintaining redundant copies of the computations and enforcing their consistency.</p>

    <p class="text-gray-300">Work on certified compilation (e.g., <em>[5, 14, 15, 30]</em>) seeks to ensure that program semantics is preserved as the program is compiled.</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Ensuring integrity</h4>

    <p class="text-gray-300">Various language-based techniques have attempted to ensure the <em>integrity</em> of computation or the values they create. For example, automated program partitioning <em>[52]</em> allows a distributed computation to be written as a single program with security types, and is compiled so that only sufficiently trusted hosts may handle high-integrity data and computation. Likewise, evidence-based audit <em>[48]</em> allows programs to automatically verify that incoming values are endorsed by trusted principals. Techniques including proof-carrying code (PCC) <em>[36]</em> and dependently typed programming <em>[17]</em> combine values (representing data or code) with machine-checkable proof objects that demonstrate the validity of propositions about the values, independent of their provenance.</p>

    <p class="text-gray-300">These techniques require a programmer to reason about a level of security types, propositions, or proofs, as well as the main computation language. By contrast, PCD allows a programmer to reason entirely at the level of CocoComm, and without making implicit or explicit trust assumptions about remote parties. Such systems are complementary to our approach. Similar to proof-carrying access control systems (discussed in the Introduction) our approach can enable compression, constant-time verification, and zero-knowledge privacy for PCC and dependent-type proofs.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Foreign function interfaces</h4>

    <p class="text-gray-300">Foreign function interfaces (FFI) allow programs written in a high-level language to call code written in another language (typically C or native machine code). It is available in many popular languages, for performance and interoperability reasons. Typically, the callee can return arbitrary values to the caller, potentially violating the semantics and invariants of the high-level language (i.e., producing values that are not well-traced). Furr and Foster <em>[22]</em> describe a static analysis approach to this problem, based on cross-language type-inference. Google Native Client <em>[35, 50]</em> restricts the native-code callee, using software fault isolation, to a certain memory region and set of instructions; however, it does not reason about the values output by the callee.</p>

    <p class="text-gray-300">Our approach to proving well-tracedness offers an alternative, in principle: the high-level language can require values produced by FFI calls to be accompanied by proofs of well-tracedness. However, this incurs runtime overhead, which seems unattractive for performance-motivated uses of FFI.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Remote attestation</h4>

    <p class="text-gray-300">Remote attestation <em>[16, 39]</em> uses a hardware root of trust, typically based on a Trusted Platform Module (TPM), along with cryptography, to let a target machine convince an appraiser/verifier machine that the target machine’s state fulfills some properties (e.g., that it is presently running a specific, unmodified and suitably-configured software stack).</p>

    <p class="text-gray-300">Remote attestation can be used to claim well-tracedness of values by attesting that they were produced by executing a given program on top of a given operating system. This attestation is convincing if the</p>

    <p class="text-gray-300">appraiser trusts the TPM hardware root of trust, the correctness of the hardware platform (e.g., CPU and memory), and the correctness of (requisite properties of) the operating system. Our PCD-based approach removes all of these assumptions.</p>

    <p class="text-gray-300">Similarly to our approach, BIND <em>[45]</em> and Flicker <em>[32]</em> aim to provide <em>fine-grained attestation</em>, attesting only to code directly relevant to producing an output. They remove the trust in the operating system, using CPU support for secure execution and late launch. However, trust in the hardware remains inherent. Notably, BIND supports transitive proofs, similarly to PCD.</p>

    <p class="text-gray-300">Unlike most prior works, which focus on low-level properties such as enforcing execution of specific or signed software, we focus on enforcing language semantics, requiring that values produced by a target machine are well-traced.</p>

    <p class="text-gray-300">PCD can be an alternative to hardware-based remote attestation, in scenarios where the latter is used to enforce <em>integrity</em> or <em>correctness</em> of a value computed by an untrusted target machine. However, PCD cannot express or enforce properties of the target machine as a whole, and thus cannot enforce <em>secrecy</em> properties, such as preventing data copying in Digital Rights Management applications.</p>

    <h2 id="sec-62" class="text-2xl font-bold">9 Conclusion</h2>

    <p class="text-gray-300">This paper presents a novel mechanism to enforce language semantics in a distributed computation with potentially malicious participants. Using the cryptographic mechanism of Proof-Carrying Data (PCD) <em>[8, 12]</em>, we ensure that values received must be <em>well-traced</em>: they could have been produced by a program execution consistent with the language semantics. Thus, developers can reason about properties and invariants of received values, without trusting the parties that provide the values and without being aware of the underlying cryptographic mechanism.</p>

    <h2 id="sec-63" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank are indebted to Alessandro Chiesa, Christos Dimoulas, Daniel Genkin, Greg Morrisett and Noam Rinetzky for their insightful comments.</p>

    <p class="text-gray-300">This work was supported by the Air Force Office of Scientific Research under Award No. FA95501210262; by the Check Point Institute for Information Security; by the Israeli Ministry of Science and Technology; by the Israeli Centers of Research Excellence I-CORE program (center 4/11); by the National Science Foundation under Grant No. 1054172; and by NATO’s Public Diplomacy Division in the Framework of ”Science for Peace”.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy. Checking computations in polylogarithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, STOC ’91, pages 21–32, 1991.</li>

      <li>[2] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. On the concrete efficiency of probabilistically-checkable proofs. In Proceedings of ACM symposium on Symposium on theory of computing, pages 585–594. ACM, 2013.</li>

      <li>[3] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive arguments for a von Neumann architecture. Cryptology ePrint Archive, Report 2013/879, 2013. http://eprint.iacr.org/2013/879.</li>

      <li>[4] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Proceedings of CRYPTO 2013, LNCS. Springer, to appear.</li>

      <li>[5] N. Benton and C.-K. Hur. Biorthogonality, step-indexing and compiler correctness. In Proceeding of the 14th ACM SIGPLAN international conference on Functional programming, pages 97–108, 2009.</li>

      <li>[6] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of Innovations in Theoretical Computer Science 2012, pages 326–349. ACM, 2012.</li>

      <li>[7] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. Cryptology ePrint Archive, Report 2012/095, 2012. http://eprint.iacr.org/2012/095.</li>

      <li>[8] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In Proceedings of ACM symposium on Symposium on theory of computing, STOC ’13, pages 111–120. ACM, 2013. ISBN 978-1-4503-2029-0.</li>

      <li>[9] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In Proceedings of the 10th Theory of Cryptography Conference, TCC ’13, pages 315–333, 2013.</li>

      <li>[10] J. Bloch. Effective Java, Second Edition. Addison-Wesley, Boston, 2nd edition, 2008.</li>

      <li>[11] CERT. The CERT Oracle secure coding standard for Java, entries SER06-J and SER07-J. https://www.securecoding.cert.org/confluence/display/java/The+CERT+Oracle+Secure+Coding+Standard+for+Java, 2013. Accessed 2013-06-04.</li>

      <li>[12] A. Chiesa and E. Tromer. Proof-carrying data and hearsay arguments from signature cards. In A. C.-C. Yao, editor, ICS, pages 310–331. Tsinghua University Press, 2010. ISBN 978-7-302-21752-7.</li>

      <li>[13] A. Chiesa and E. Tromer. Proof-carrying data: Secure computation on untrusted platforms. The Next Wave: the NSA’s review of emerging technologies, 19(2):40–46, 2012. URL http://www.nsa.gov/research/_files/publications/next_wave/TNW_19_2_ProofCarryingData_Chiesa_Tromer.pdf.</li>

      <li>[14] A. Chlipala. A certified type-preserving compiler from lambda calculus to assembly language. In Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation, PLDI ’07, pages 54–65, New York, NY, USA, 2007. ACM.</li>

      <li>[15] A. Chlipala. A verified compiler for an impure functional language. In Proceedings of the 37th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages, POPL ’10, pages 93–106, New York, NY, USA, 2010. ACM.</li>

      <li>[16] G. Coker, J. Guttman, P. Loscocco, A. Herzog, J. Millen, B. O’Hanlon, J. Ramsdell, A. Segall, J. Sheehy, and B. Sniffen. Principles of remote attestation. International Journal of Information Security, 10(2):63–81, June 2011.</li>

      <li>[17] T. Coquand and G. Huet. The calculus of constructions. Information and Computation, 76, 1988.</li>

      <li>[18] J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve. Secure virtual architecture: A safe execution environment for commodity operating systems. In Proceedings of the Twenty First ACM Symposium on Operating Systems Principles (SOSP), 2007.</li>

      <li>[19] D. Dhurjati, S. Kowshik, and V. Adve. SAFECode: Enforcing alias analysis for weakly typed languages. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, 2006.</li>

    </ul>

    <p class="text-gray-300">[20] C. Dimoulas, R. B. Findler, C. Flanagan, and M. Felleisen. Correct blame for contracts: No more scapegoating. In POPL, pages 215 – 226, 2011.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[21] R. B. Findler and M. Felleisen. Contracts for higher-order functions. In ICFP, pages 48–59, 2002.</li>

      <li>[22] M. Furr and J. S. Foster. Checking type safety of foreign function calls. ACM Trans. Program. Lang. Syst., 30 (4):18:1–18:63, Aug. 2008. ISSN 0164-0925. . URL http://doi.acm.org/10.1145/1377492.1377493.</li>

      <li>[23] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT ’13, pages 626–645, 2013.</li>

      <li>[24] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. Delegating computation: Interactive proofs for Muggles. In Proceedings of the 40th Annual ACM Symposium on Theory of Computing, STOC ’08, pages 113–122, 2008.</li>

      <li>[25] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-based memory management in Cyclone. In Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 282–293, New York, NY, USA, 2002. ACM Press.</li>

      <li>[26] J. Groth. Short non-interactive zero-knowledge proofs. In Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT ’10, pages 341–358, 2010.</li>

      <li>[27] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A minimal core calculus for Java and GJ. ACM Transactions on Programming Languages and Systems, 23(3):396–450, 2001.</li>

      <li>[28] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and Y. Wang. Cyclone: A safe dialect of C. In ATEC ’02: Proceedings of the General Track of the annual conference on USENIX Annual Technical Conference, pages 275–288, Berkeley, CA, USA, 2002. USENIX Association.</li>

      <li>[29] J. Kilian. A note on efficient zero-knowledge proofs and arguments. In Proceedings of the 24th Annual ACM Symposium on Theory of Computing, STOC ’92, pages 723–732, 1992.</li>

      <li>[30] X. Leroy. A formally verified compiler back-end. Journal of Automated Reasoning, 43(4):363–446, 2009.</li>

      <li>[31] H. Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography, TCC ’12, pages 169–189, 2012.</li>

      <li>[32] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and H. Isozaki. Flicker: an execution infrastructure for TCB minimization. In Proceedings of the 3rd ACM SIGOPS/EuroSys European Conference on Computer Systems 2008, Eurosys ’08, pages 315–328, New York, NY, USA, 2008. ACM.</li>

      <li>[33] S. Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000. Preliminary version appeared in FOCS ’94.</li>

      <li>[34] MITRE Corporation. Common weakness enumeration, CWE-502, 2013. URL http://cwe.mitre.org/data/definitions/502.html.</li>

      <li>[35] G. Morrisett, G. Tan, J. Tassarotti, J.-B. Tristan, and E. Gan. RockSalt: better, faster, stronger SFI for the x86. In Proceedings of the 33rd ACM SIGPLAN conference on Programming Language Design and Implementation, PLDI ’12, pages 395–404, New York, NY, USA, 2012. ACM.</li>

      <li>[36] G. C. Necula. Proof-carrying code. In Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 106–119, New York, NY, USA, 1997. ACM.</li>

      <li>[37] G. C. Necula, S. McPeak, and W. Weimer. CCured: type-safe retrofitting of legacy code. In Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 128–139, 2002.</li>

      <li>[38] Y. G. Park and B. Goldberg. Escape analysis on lists. In Proceedings of the ACM SIGPLAN 1992 Conference on Programming Language Design and Implementation, pages 116–127, New York, NY, USA, 1992. ACM.</li>

      <li>[39] B. Parno, J. McCune, and A. Perrig. Bootstrapping Trust in Modern Computers. Springer, 2011. ISBN 9781461414605.</li>

      <li>[40] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In Proceedings of the IEEE Symposium on Security and Privacy, 2013.</li>

    </ul>

    <p class="text-gray-300">[41] F. Perry, L. Mackey, G. A. Reis, J. Ligatti, D. I. August, and D. Walker. Fault-tolerant typed assembly language. In Proceedings of the 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 42–53, New York, NY, USA, 2007. ACM Press.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[42] A. Sabelfeld and A. C. Myers. Language-based information-flow security. IEEE Journal on Selected Areas in Communications, 21(1):5–19, Jan. 2003.</li>

      <li>[43] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. van Doorn, and P. Khosla. Pioneer: Verifying integrity and guaranteeing execution of code on legacy platforms. In Proceedings of ACM Symposium on Operating Systems Principles (SOSP), pages 1–16, Oct. 2005.</li>

      <li>[44] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In EuroSys, 2013.</li>

      <li>[45] E. Shi, A. Perrig, and L. V. Doorn. BIND: A fine-grained attestation service for secure distributed systems. In Proceedings of the 2005 IEEE Symposium on Security and Privacy, pages 154–168, Washington, DC, USA, 2005. IEEE Computer Society.</li>

      <li>[46] J. Thaler. Time-optimal interactive proofs for circuit evaluation. CoRR, abs/1304.3812, 2013.</li>

      <li>[47] P. Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In TCC, 2008.</li>

      <li>[48] J. A. Vaughan, L. Jia, K. Mazurak, and S. Zdancewic. Evidence-based audit. In CSF, pages 177–191, 2008. Extended version available as U. Pennsylvania Technical Report MS-CIS-08-09.</li>

      <li>[49] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for interactive verifiable computation. In Proceedings of the IEEE Symposium on Security and Privacy, 2013.</li>

      <li>[50] B. Yee, D. Sehr, G. Dardyk, J. Chen, R. Muth, T. Ormandy, S. Okasaka, N. Narula, and N. Fullagar. Native client: A sandbox for portable, untrusted x86 native code. In Security and Privacy, 2009 30th IEEE Symposium on, pages 79–93, 2009. .</li>

      <li>[51] S. Zdancewic, L. Zheng, N. Nystrom, and A. C. Myers. Untrusted hosts and confidentiality: Secure program partitioning. In Proceedings of the 17th ACM Symposium on Operating System Principles (SOSP), pages 1–14, New York, NY, USA, Oct. 2001. ACM Press.</li>

      <li>[52] L. Zheng, S. Chong, A. C. Myers, and S. Zdancewic. Using replication and partitioning to build secure distributed systems. In Proceedings of the IEEE Symposium on Security and Privacy, pages 236–250, Oakland, California, May 2003. IEEE Computer Society.</li>

    </ul>

    <p class="text-gray-300">A Auxiliary Definitions</p>

    <p class="text-gray-300">We write <span class="math">names(CT)</span> for the set of class names used or defined in <span class="math">CT</span>. Collecting class names mentioned in syntax (via <span class="math">names</span>) is straightforward because there are no binding occurences of class names and no need to avoid capture. We overload <span class="math">names</span> to return the class names used in terms, environments, class declarations, and sets of values.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Definition 6 (<span class="math">names</span>).</h6>

    <p class="text-gray-300"><span class="math">names(\\textbf{new}\\,C)</span> <span class="math">=\\{C\\}</span> <span class="math">names(t\\texttt{ instanceof }C)</span> <span class="math">=names(t)\\cup\\{C\\}</span> <span class="math">\\vdots</span> <span class="math">names(i)</span> <span class="math">=\\emptyset</span> <span class="math">names(\\textbf{null})</span> <span class="math">=\\emptyset</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$names(\\{C\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\overline{f=v}\\,\\})<span class="math"> </span>=\\{C\\}\\cup\\left(\\bigcup_{(f=v)\\in\\overline{f=v}}\\,names(v)\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">names(\\rho)</span> <span class="math">=\\bigcup_{x\\in\\text{dom}(\\rho)}names(\\rho(x))</span> <span class="math">names(m(x)\\,\\{\\textbf{return}\\,t;\\})</span> <span class="math">=names(t)</span> <span class="math">names\\pmatrix{\\textbf{class}\\{\\,\\text{fields}\\,\\,\\overline{f};\\\\ \\text{meths}\\,\\overline{M}\\}}</span> <span class="math">=\\bigcup_{M\\in\\overline{M}}names(M)</span> <span class="math">names(CT)</span> <span class="math">=\\bigcup_{C\\in\\text{dom}(CT)}\\{C\\}\\cup names(CT(C))</span> <span class="math">names(\\{v_{1},\\ldots,v_{n}\\})</span> <span class="math">=names(v_{1})\\cup\\cdots\\cup names(v_{n})</span></p>

    <p class="text-gray-300">We write <span class="math">e[D/C]</span> to denote the replacement of class name <span class="math">C</span> with class name <span class="math">D</span> in expression <span class="math">e</span>. As before, we overload this notation to also define substitution for environments, class declarations, class tables, and sets of values.</p>

    <p class="text-gray-300">Definition 7 (<span class="math">\\cdot[\\cdot/\\cdot]</span>).</p>

    <div class="my-4 text-center"><span class="math-block">C[D/C] = D</span></div>

    <div class="my-4 text-center"><span class="math-block">E[D/C] = E \\text{ where } C \\neq E</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\text{new } E)[D/C] = \\text{new } (E[D/C])</span></div>

    <div class="my-4 text-center"><span class="math-block">(t \\text{ instanceof } E)[D/C] = (t[D/C]) \\text{ instanceof } (E[D/C])</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vdots</span></div>

    <div class="my-4 text-center"><span class="math-block">i[D/C] = i</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{null}[D/C] = \\text{null}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\{E \\mid \\overline{f = v}\\} [D/C] = \\{E[D/C] \\mid \\overline{f = (v[D/C])}\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho[D/C] = \\lambda x. (\\rho(x)[D/C])</span></div>

    <div class="my-4 text-center"><span class="math-block">CT[D/C] = \\lambda E. \\begin{cases} (CT(C))[D/C] &amp;amp; E = D \\\\ (CT(E))[D/C] &amp;amp; E \\in \\operatorname{dom}(CT) \\setminus \\{C, D\\} \\\\ \\text{undefined} &amp;amp; \\text{otherwise} \\end{cases}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\{v_1, \\dots, v_n\\}[D/C] = \\{v_1[D/C], \\dots, v_n[D/C]\\}</span></div>

    <p class="text-gray-300">We define what it means for one environment to extend another.</p>

    <p class="text-gray-300">Definition 8 ( <span class="math">\\supseteq</span> ). We write  <span class="math">\\rho_2 \\supseteq \\rho_1</span>  when for any  <span class="math">x \\in \\operatorname{dom}(\\rho_1)</span>  it is the case that  <span class="math">\\rho_2(x) = \\rho_1(x)</span> .</p>

    <p class="text-gray-300">B. Proof of Theorem 1</p>

    <p class="text-gray-300">Given an evaluation  <span class="math">CT \\vdash \\langle t, S \\rangle \\to^* \\langle t&#x27;, S&#x27; \\rangle</span> , it is possible to rename any class  <span class="math">C</span>  to a new class name  <span class="math">D</span>  without otherwise modifying the evaluation.</p>

    <p class="text-gray-300">Lemma 4 (Renaming). Suppose</p>

    <div class="my-4 text-center"><span class="math-block">CT, \\rho \\vdash \\langle t, S \\rangle \\rightarrow^* \\langle t&#x27;, S&#x27; \\rangle</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">D \\notin \\text{names}(CT) \\cup \\text{names}(t) \\cup \\text{names}(\\rho) \\cup \\text{names}(t&#x27;) \\cup \\text{names}(S) \\cup \\text{names}(S&#x27;)</span></div>

    <p class="text-gray-300">Then, for any class name  <span class="math">C</span> , it is the case that</p>

    <div class="my-4 text-center"><span class="math-block">CT[D/C], \\rho[D/C] \\vdash \\langle t[D/C], S[D/C] \\rangle \\rightarrow^* \\langle t&#x27;[D/C], S&#x27;[D/C] \\rangle.</span></div>

    <p class="text-gray-300">Proof. by induction on the reduction relation.</p>

    <p class="text-gray-300">Given an evaluation of a program, it is possible to add additional classes to the class table without changing the evaluation.</p>

    <p class="text-gray-300">Lemma 5. Suppose  <span class="math">CT_2 \\supseteq CT_1</span>  and  <span class="math">CT_1 \\vdash \\langle t, \\emptyset \\rangle \\to^<em> \\langle t&#x27;, S \\rangle</span> . Then  <span class="math">CT_2 \\vdash \\langle t, \\emptyset \\rangle \\to^</em> \\langle t&#x27;, S \\rangle</span></p>

    <p class="text-gray-300">Proof. By a straightforward induction on  <span class="math">CT_1 \\vdash \\langle t, \\emptyset \\rangle \\to^* \\langle t&#x27;, S \\rangle</span> .</p>

    <p class="text-gray-300">We are now ready to prove Theorem 1, which states that if value <span class="math">v</span> esacpes during evaluation of a CocoComm program and <span class="math">v</span> is well-formed with respect to common class table <span class="math">CT_{\\mathsf{cmn}}</span>, then <span class="math">v</span> is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span>.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof of Theorem 1.</h6>

    <p class="text-gray-300">Suppose we have a CocoComm program <span class="math">t</span> using classtable <span class="math">CT</span> and during an evaluation of <span class="math">t</span>, the value <span class="math">v</span> escapes and values <span class="math">u_{1},\\ldots,u_{n}</span> are received. Intuitively, since each value received is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span>, there are Coco terms <span class="math">s_{1},\\ldots,s_{n}</span> and class tables <span class="math">CT_{1},\\ldots,CT_{n}</span> such that <span class="math">CT_{i}\\supseteq CT_{\\mathsf{cmn}}</span> and <span class="math">CT_{i}\\vdash\\langle s_{i},\\emptyset\\rangle\\to^{*}\\langle s^{\\prime}_{i},S_{i}\\rangle</span> such that <span class="math">u_{i}\\in S_{i}</span>.</p>

    <p class="text-gray-300">We will first construct a class table <span class="math">CT^{<em>}</span> such that for all <span class="math">i</span> we have a program <span class="math">\\overline{s}_{i}</span> such that <span class="math">CT^{</em>}\\vdash\\langle\\overline{s}_{i},\\emptyset\\rangle\\to^{*}\\langle\\overline{s^{\\prime}}_{i},\\overline{S}_{i}\\rangle</span> such that <span class="math">u_{i}\\in\\overline{S}_{i}</span>.</p>

    <p class="text-gray-300">For each <span class="math">i</span>, we can rename the classes in <span class="math">s_{i}</span> and <span class="math">CT_{i}</span> using Lemma 4 to acquire terms <span class="math">\\overline{s}_{i}</span> and class tables <span class="math">CT^{\\prime}_{i}\\supseteq CT_{\\mathsf{cmn}}</span> such that <span class="math">\\mathrm{dom}(CT^{\\prime}_{i})\\cap(\\mathrm{dom}(CT^{\\prime}_{j})\\cup CT)=\\mathrm{dom}(CT_{\\mathsf{cmn}})</span> for all <span class="math">i\\neq j</span>, and <span class="math">CT^{\\prime}_{i}\\vdash\\langle\\overline{s}_{i},\\emptyset\\rangle\\to^{*}\\langle\\overline{s^{\\prime}}_{i},\\overline{S}_{i}\\rangle</span> such that <span class="math">u_{i}\\in\\overline{S}_{i}</span>.</p>

    <p class="text-gray-300">Let <span class="math">CT^{<em>}=CT\\cup\\bigcup CT^{\\prime}_{i}</span>. Then by Lemma 5 for any <span class="math">i</span> it holds that <span class="math">CT^{</em>}\\vdash\\langle\\overline{s}_{i},\\emptyset\\rangle\\to^{*}\\langle\\overline{s^{\\prime}}_{i},\\overline{S}_{i}\\rangle</span> such that <span class="math">u_{i}\\in\\overline{S}_{i}</span>.</p>

    <p class="text-gray-300">Recall that <span class="math">t</span> is a CocoComm program such that value <span class="math">v</span> escapes during evaluation, and <span class="math">v</span> is well-formed in <span class="math">CT_{\\mathsf{cmn}}</span>. We must show that <span class="math">v</span> is well traced. We now translate CocoComm program <span class="math">t</span> to a Coco program that replaces all <span class="math">\\mathsf{recv}</span> <span class="math">\\mathsf{on}</span> <span class="math">ch</span> terms with term <span class="math">\\mathsf{capture}</span> and replaces any term <span class="math">\\mathsf{send}</span> <span class="math">s</span> <span class="math">\\mathsf{on}</span> <span class="math">ch</span> with <span class="math">\\mathsf{escape}</span> <span class="math">s</span>. Moreover, we compose the translation with terms that will mark values <span class="math">u_{1},\\ldots,u_{n}</span> as escaping. More precisely we translate <span class="math">t</span> to the following program, which we denote <span class="math">t^{*}</span>.</p>

    <p class="text-gray-300"><span class="math">t^{*}\\equiv\\overline{s}_{1}\\llbracket\\ldots\\llbracket\\overline{s}_{n}\\llbracket\\llbracket t\\rrbracket</span></p>

    <p class="text-gray-300">where <span class="math">\\llbracket\\cdot\\rrbracket</span> is a function such that</p>

    <p class="text-gray-300"><span class="math">\\llbracket\\mathsf{send}</span> <span class="math">s</span> <span class="math">\\mathsf{on}</span> <span class="math">ch\\rrbracket</span> <span class="math">=\\mathsf{escape}\\llbracket s\\rrbracket</span> <span class="math">\\llbracket\\mathsf{recv}</span> <span class="math">\\mathsf{on}</span> <span class="math">ch\\rrbracket</span> <span class="math">=\\mathsf{capture}</span></p>

    <p class="text-gray-300">and is otherwise homomorphic in the struture of terms. Note that <span class="math">t^{*}</span> is a program that uses only Coco terms (i.e., it does not contain any <span class="math">\\mathsf{send}</span> or <span class="math">\\mathsf{recv}</span> operations).</p>

    <p class="text-gray-300">Moreover, we translate the class table <span class="math">CT^{<em>}</span> in a similar way, denoted <span class="math">\\llbracket CT^{</em>}\\rrbracket</span>. More precisely <span class="math">\\llbracket CT^{<em>}\\rrbracket</span> is a class table with the same domain as <span class="math">CT^{</em>}</span> and if for class <span class="math">C</span>,</p>

    <p class="text-gray-300"><span class="math">CT^{*}(C)=\\mathsf{class}\\{\\mathsf{fields}\\;\\overline{f};\\;\\mathsf{meths}\\;\\overline{m(x)\\left\\{\\mathsf{return}\\;t;\\right\\}}\\}</span></p>

    <p class="text-gray-300">then</p>

    <p class="text-gray-300"><span class="math">\\llbracket CT^{*}\\rrbracket(C)=\\mathsf{class}\\{\\mathsf{fields}\\;\\overline{f};\\;\\mathsf{meths}\\;\\overline{m(x)\\left\\{\\mathsf{return}\\;\\llbracket t\\rrbracket;\\right\\}}\\}.</span></p>

    <p class="text-gray-300">First note that <span class="math">\\llbracket CT^{<em>}\\rrbracket\\vdash\\langle t^{</em>},\\emptyset\\rangle\\to^{<em>}\\langle\\llbracket t\\rrbracket,S^{</em>}\\rangle</span> such that <span class="math">\\{u_{1},\\ldots,u_{n}\\}\\subseteq S^{*}</span>.</p>

    <p class="text-gray-300">We now show that evaluation of <span class="math">\\langle t,\\emptyset\\rangle</span> with class table <span class="math">CT</span> under CocoComm semantics is in lockstep with evaluation of <span class="math">\\langle\\llbracket t\\rrbracket,S^{<em>}\\rangle</span> with class table <span class="math">\\llbracket CT^{</em>}\\rrbracket</span> under Coco semantics. We proceeds by induction on the length of the evaluation, with the inductive hypothesis being that if the current CocoComm term is <span class="math">s</span> then the current Coco term is <span class="math">\\llbracket s\\rrbracket</span>. For each small step, we proceed by induction on the derivation</p>

    <p class="text-gray-300"><span class="math">CT,CT_{\\mathsf{cmn}},\\emptyset\\vdash_{\\mathsf{comm}}\\langle s,S\\rangle\\to\\langle s^{\\prime},S^{\\prime}\\rangle,</span></p>

    <p class="text-gray-300">to show that if <span class="math">S^{\\prime}\\subseteq S^{\\prime\\prime\\prime}</span> then</p>

    <p class="text-gray-300"><span class="math">\\llbracket CT^{*}\\rrbracket,\\emptyset\\vdash\\langle\\llbracket s\\rrbracket,S^{\\prime\\prime}\\rangle\\to\\langle\\llbracket s^{\\prime}\\rrbracket,S^{\\prime\\prime\\prime}\\rangle</span></p>

    <p class="text-gray-300">for</p>

    <p class="text-gray-300">and <span class="math">S \\subseteq S&#x27;&#x27;</span>. The only interesting case is when the redex is <span class="math">\\mathbf{recv}</span> on <span class="math">ch</span>, and the received value is <span class="math">u_i</span> for some <span class="math">u_i</span> that is well-traced in <span class="math">CT_{\\mathsf{cmn}}</span>. In the translated version, the redex is <span class="math">\\mathbf{capture}</span>, and the current set of escaped values contains at least <span class="math">u_1, \\ldots, u_n</span>. Thus, we can step to <span class="math">u_i</span> as required.</p>

    <p class="text-gray-300">Finally, since <span class="math">v</span> is a value, we have <span class="math">\\llbracket v\\rrbracket = v</span>, and so we have a program <span class="math">t^*</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\llbracket CT^* \\rrbracket \\vdash \\langle t^*, S \\rangle \\rightarrow^* \\langle t&#x27;, S \\rangle</span></div>

    <p class="text-gray-300">for some <span class="math">S</span> such that <span class="math">v \\in S</span>, and thus <span class="math">v</span> is well-traced, as required.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">39</p>`;
---

<BaseLayout title="Enforcing Language Semantics Using Proof-Carrying Data (2013/513)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/513
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
