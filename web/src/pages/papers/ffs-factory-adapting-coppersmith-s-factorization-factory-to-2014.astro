---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/419';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'FFS Factory: Adapting Coppersmith&#x27;s &quot;Factorization Factory&quot; to the Function Field Sieve';
const AUTHORS_HTML = 'Jérémie Detrey';

const CONTENT = `    <p class="text-gray-300">Jérémie Detrey</p>

    <p class="text-gray-300">CARAMEL project-team, LORIA, INRIA / CNRS / Université de Lorraine, Campus Scientifique, BP 239, 54506 Vandœuvre-lès-Nancy Cedex, France Jeremie.Detrey@loria.fr</p>

    <p class="text-gray-300">Abstract. In 1993, Coppersmith introduced the "factorization factory" approach as a means to speed up the Number Field Sieve algorithm (NFS) when factoring batches of integers of similar size: at the expense of a large precomputation whose cost is amortized when considering sufficiently many integers to factor, the complexity of each individual factorization can then be lowered.</p>

    <p class="text-gray-300">We suggest here to extend this idea to the computation of discrete logarithms in finite fields of small characteristic using the Function Field Sieve (FFS), thus referring to this approach as the "FFS factory". In this paper, the benefits of the proposed technique are established thanks to both a theoretical complexity analysis along with a practical experiment in which we solved the discrete logarithm problem in fifty different binary fields of sizes ranging from 601 to 699 bits.</p>

    <p class="text-gray-300">Keywords: Discrete logarithm, Function field sieve, Cryptanalysis</p>

    <p class="text-gray-300">Initially introduced in 1994 by Adleman [2], the Function Field Sieve (FFS) has been for almost twenty years the most efficient algorithm known for computing discrete logarithms in the multiplicative subgroup of finite fields <span class="math">\\mathbb{F}_{q^k}</span>, with a subexponential asymptotic complexity of <span class="math">L_{q^k}(1/3, \\sqrt[3]{32/9})^{1 + o(1)}</span>, where the notation <span class="math">L_{q^k}</span> designates the usual function</p>

    <div class="my-4 text-center"><span class="math-block">L_N(\\alpha, c) = \\exp \\left(c (\\log N)^\\alpha (\\log \\log N)^{1 - \\alpha}\\right), \\quad \\text{with } 0 \\leq \\alpha \\leq 1 \\text{ and } c &amp;gt; 0.</span></div>

    <p class="text-gray-300">However, the year 2013 was marked by several successive major theoretical improvements on this algorithm by Göloğlu et al. [14], Joux [23], and finally Barbulescu et al. [8], which eventually brought the asymptotic complexity of solving the discrete logarithm problem over fields of small characteristic down to quasi-polynomial time. These breakthroughs were accompanied by many computations of discrete logarithms in record-sized binary and ternary</p>

    <p class="text-gray-300">fields <em>[20, 14, 21, 15, 22, 16, 1]</em>. Nevertheless, finding the exact crossing point between FFS and these recent algorithms, especially when it comes to fields of prime extension degrees, is still an active research topic <em>[5]</em>.</p>

    <p class="text-gray-300">Furthermore, software implementations of FFS (or at least of the descent step) are now publicly available, either as standalone software packages such as in the cado-nfs distribution <em>[4]</em>, or as part of computer algebra systems such as Magma <em>[10]</em>. Therefore, providing such software with the precomputed discrete logarithms of factor bases for various finite fields should definitely make their job easier when computing individual logarithms in these fields. For instance, the release notes of Magma V2.20 state that “The database of logarithms is continually being extended and now includes data for larger fields. In particular, the fields <span class="math">\\mathrm{GF}(2^{d})</span> are now covered for all prime degree <span class="math">d\\leq 509</span> and most degrees up to <span class="math">500</span>” <em>[9]</em>.</p>

    <p class="text-gray-300">Bearing in mind this motivation of computing discrete logarithms in several finite fields, we propose in this paper the so-called “FFS factory”, whose key idea is to share as much of the computation as possible amongst the considered finite fields in order to decrease the overall computation cost when compared to running as many independent instances of FFS.</p>

    <p class="text-gray-300">This approach is directly inspired from Coppersmith’s “factorization factory” <em>[12]</em>, which can be used to accelerate the factorization of many integers of the same size using the Number Field Sieve (NFS), thus bringing the original complexity of NFS from <span class="math">L_{N}(1/3,1.923)^{1+o(1)}</span> down to <span class="math">L_{N}(1/3,1.639)^{1+o(1)}</span> for each integer <span class="math">N</span> to be factored. A similar modification of NFS, known as the “discrete logarithm factory”, was later presented by Barbulescu in order to batch discrete logarithm computations over finite fields of large characteristic <em>[6, Section 7.2]</em>.</p>

    <p class="text-gray-300">However, since both of the above cases are based on NFS, they can only share the computations on the so-called rational side of the algorithm. What we propose here is to leverage the fact that the polynomial selection is far less constrained in the FFS setting in order to share the computations on the algebraic side instead. It is to be noted that this idea was first suggested by Kleinjung in the context of factoring using the Special Number Field Sieve (SNFS) <em>[24]</em>, which is in many ways quite similar to FFS.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">1.0.1 Roadmap.</h4>

    <p class="text-gray-300">This paper is organized as follows. After a presentation on the Function Field Sieve in Section 2, with a special emphasis on its complexity analysis, Section 3 details the algorithmic and complexity aspects of the proposed FFS factory approach before discussing its applicability. A practical experiment, involving the computation of discrete logarithms in 50 binary finite fields of size between 601 and 699 bits, is then presented in Section 4, before some concluding remarks in Section 5.</p>

    <p class="text-gray-300">2 Remainder on the Function Field Sieve</p>

    <p class="text-gray-300">In the following, we let <span class="math">q</span> be a prime power and <span class="math">k</span> a positive integer, and assume that we want to compute discrete logarithms in the multiplicative subgroup of the finite field <span class="math">\\mathbb{F}_{q^{k}}</span>. In other words, for any two elements <span class="math">g</span> and <span class="math">h\\in\\mathbb{F}_{q^{k}}^{\\times}</span>, with <span class="math">g</span> primitive, we want to find the integer <span class="math">\\lambda\\in\\mathbb{Z}/(q^{k}-1)\\mathbb{Z}</span> such that <span class="math">h=g^{\\lambda}</span>.</p>

    <p class="text-gray-300">Note that, in order to fall into the domain of applicability of FFS, we further require that <span class="math">q=L_{q^{k}}(\\alpha,c)</span> with <span class="math">0\\leq\\alpha&lt;1/3</span> and <span class="math">c&gt;0</span>. In practice, <span class="math">q</span> will usually be a small prime (such as <span class="math">2</span>) or a small power thereof.</p>

    <p class="text-gray-300">As the Function Field Sieve belongs to the family of <em>index calculus</em> algorithms for computing discrete logarithms, it follows the same basic three steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <em>relation collection</em> step, whose goal is to find many multiplicative equalities, or <em>relations</em>, involving only elements from a predefined subset of <span class="math">\\mathbb{F}_{q^{k}}</span>, called the <em>factor base</em>. Taking the logarithm, each such relation becomes a linear equation modulo <span class="math">q^{k}-1</span>, whose unknowns are the discrete logarithms of the factor base elements.</li>

      <li>The <em>linear algebra</em> step, which solves the linear system once enough such relations have been found, and therefore recovers the value of the discrete logarithms of the factor base elements.</li>

      <li>The <em>individual logarithm</em> step, which computes the discrete logarithm of an arbitrary element <span class="math">h\\in\\mathbb{F}_{q^{k}}^{\\times}</span> by finding a multiplicative relation involving only <span class="math">h</span> and factor base elements.</li>

    </ul>

    <p class="text-gray-300">Further details on how these three tasks are achieved in FFS are given in the following paragraphs, before a careful complexity analysis in Section 2.4. However, we do not claim here to give an exhaustive nor comprehensive description of FFS, but rather to focus on a few key points which will prove useful in the rest of this paper. For more information on this topic, we refer the interested reader to the original theoretical foundations of FFS by Adleman and Adleman & Huang <em>[2, 3]</em> along with the later improvements by Matsumoto and Joux & Lercier <em>[26, 19]</em>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Relation collection</h3>

    <p class="text-gray-300">Let <span class="math">d&gt;1</span> be an integer, and let <span class="math">f(x,t)\\in\\mathbb{F}_{q}[t][x]</span> be a monic, bivariate polynomial of degree <span class="math">d</span> in <span class="math">x</span>. Note that, for our purposes, the degree in <span class="math">t</span> of <span class="math">f</span> can be made as small as possible. Let now <span class="math">g(x,t)\\in\\mathbb{F}_{q}[t][x]</span> be a linear polynomial such that its resultant in <span class="math">x</span> with <span class="math">f</span> has an irreducible factor <span class="math">\\varphi(t)</span> of degree <span class="math">k</span>. Since, by construction, <span class="math">f</span> has coefficients of small degree in <span class="math">t</span>, this implies that <span class="math">\\deg_{t}g\\approx k/d</span>.</p>

    <p class="text-gray-300">In the following, we denote by <span class="math">F(X,Y,t)=Y^{d}\\cdot f(X/Y,t)</span> and <span class="math">G(X,Y,t)=Y\\cdot g(X/Y,t)</span> the homogenizations in <span class="math">x</span> of the polynomials <span class="math">f</span> and <span class="math">g</span>, respectively.</p>

    <p class="text-gray-300">Given the above choice of polynomials, the target finite field <span class="math">\\mathbb{F}_{q^{k}}</span> is therefore isomorphic to the extension field <span class="math">\\mathbb{F}_{q}[t]/(\\varphi(t))</span>, and the following diagram is commutative:</p>

    <p class="text-gray-300">J. Detrey</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">The core idea behind the relation collection step in FFS, also known as the sieving step, is to consider elements of  <span class="math">\\mathbb{F}_q[t][x]</span>  and to map them down to  <span class="math">\\mathbb{F}_{q^k}</span>  through both sides of the diagram, factoring the corresponding principal ideals in the ring of integers of the function fields  <span class="math">\\mathbb{F}_q(t)[x] / (f(x,t))</span>  and  <span class="math">\\mathbb{F}_q(t)[x] / (g(x,t))</span>  along the way.</p>

    <p class="text-gray-300">In this sieving step, we then consider all the pairs of polynomials  <span class="math">(r(t), s(t)) \\in (\\mathbb{F}_q[t])^2</span>  where  <span class="math">r</span>  is monic and both are of degree at most  <span class="math">e</span> , where  <span class="math">e</span>  is a parameter called the sieving bound. Given a second parameter  <span class="math">b</span> , referred to as the smoothness bound, we then push each polynomial  <span class="math">r(t) - s(t)x \\in \\mathbb{F}_q[t][x]</span>  through the above diagram, and try to factor the corresponding principal ideals in the ring of integers of the function fields  <span class="math">\\mathbb{F}_q(t)[x] / (f(x,t))</span>  and  <span class="math">\\mathbb{F}_q(t)[x] / (g(x,t))</span>  as products of prime ideals whose norms are of degree at most  <span class="math">b</span> . If such a factorization succeeds on both sides, then the pair  <span class="math">(r,s)</span>  is called doubly- <span class="math">b</span> -smooth. Mapping both factorizations to  <span class="math">\\mathbb{F}_{q^k}</span>  thanks to the two lower maps of the diagram then yields a relation, that is a multiplicative equality between elements of the factor base, which is defined as the set of those elements of  <span class="math">\\mathbb{F}_{q^k}</span>  that correspond to prime ideals whose norms have degree at most  <span class="math">b</span>  in the function fields above.</p>

    <p class="text-gray-300">On the left-hand side of the diagram (also known as the algebraic side), the principal ideal corresponding to an element  <span class="math">r(t) - s(t)x</span>  factors as a product of prime ideals whose norms have degree at most  <span class="math">b</span>  in the ring of integers of the function field  <span class="math">\\mathbb{F}_q(t)[x] / (f(x,t))</span>  if and only if the norm of this principal ideal itself factors as a product of irreducible polynomials of degree at most  <span class="math">b</span> . The same obviously holds for the right-hand side as well (also known as the rational side). Therefore, checking if a pair  <span class="math">(r,s)</span>  from the sieving domain if doubly-  <span class="math">b</span> -smooth is tantamount to checking if the norms of the corresponding principal ideals, namely the polynomials  <span class="math">F(r,s,t)</span>  and  <span class="math">G(r,s,t) \\in \\mathbb{F}_q[t]</span> , both factor as products of irreducible polynomials of degree at most  <span class="math">b</span> .</p>

    <p class="text-gray-300">Therefore, collecting relations in FFS is just a matter of enumerating all pairs  <span class="math">(r,s)</span>  in the sieving domain, computing their norms  <span class="math">F(r,s,t)</span>  and  <span class="math">G(r,s,t)</span> , and marking each of them as a valid relation if both norms are indeed  <span class="math">b</span> -smooth. Of course, the parameters  <span class="math">d</span> ,  <span class="math">e</span>  and  <span class="math">b</span>  should be carefully chosen so that this step finds enough relations in order to solve the corresponding linear system.</p>

    <p class="text-gray-300">All the relations collected in the previous step form a large linear system modulo  <span class="math">q^k - 1</span> , the order of the multiplicative subgroup of  <span class="math">\\mathbb{F}_{q^k}</span> . However, this linear system is very sparse, thus allowing for efficient methods such as Lanczos' or</p>

    <p class="text-gray-300">Wiedemann’s algorithms <em>[25]</em>: given a sparse matrix of <span class="math">N</span> rows and columns, with an average of <span class="math">\\omega</span> non-zero coefficients per row, such algorithms can indeed solve the corresponding linear system in time <span class="math">O(\\omega N^{2})</span>, which is more efficient than classical Gaussian elimination algorithms running in <span class="math">O(N^{3})</span>.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.3 Individual logarithms</h3>

    <p class="text-gray-300">Let <span class="math">h</span> be an arbitrary element of <span class="math">\\mathbb{F}_{q^{k}}^{\\times}</span>. Since <span class="math">\\mathbb{F}_{q^{k}}\\cong\\mathbb{F}_{q}[t]/(\\varphi(t))</span>, <span class="math">h</span> can be seen as a polynomial in <span class="math">t</span> of degree less than <span class="math">k</span>. The discrete logarithm of <span class="math">h</span> then can be computed in two main steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <em>smoothing</em> step, in which one tries to find an element of the factor base, whose norm we denote as <span class="math">\\theta(t)</span>, along with an exponent <span class="math">m</span> such that the polynomial <span class="math">\\theta(t)^{m}h(t)\\bmod\\varphi(t)</span> is <span class="math">b_{0}</span>-smooth, with <span class="math">b_{0}=\\sqrt{kb}</span>.</li>

      <li>The <em>special</em>-<span class="math">\\mathfrak{q}</span> <em>descent</em>: given a prime ideal <span class="math">\\mathfrak{q}</span> (on either the algebraic or the rational side of the diagram) whose norm is of degree <span class="math">d_{\\mathfrak{q}}</span>, with <span class="math">b&lt;d_{\\mathfrak{q}}\\leq b_{0}</span>, we denote by <span class="math">\\Lambda_{\\mathfrak{q}}</span> the set of <span class="math">(r,s)</span> pairs in <span class="math">(\\mathbb{F}_{q}[t])^{2}</span> such that the principal ideal corresponding to <span class="math">r(t)-s(t)x</span> (on the same side of the diagram) is divisible by <span class="math">\\mathfrak{q}</span>. It can be remarked that <span class="math">\\Lambda_{\\mathfrak{q}}</span> forms an <span class="math">\\mathbb{F}_{q}[t]</span>-lattice of dimension <span class="math">2</span>. A basis of <span class="math">\\Lambda_{\\mathfrak{q}}</span> is then obtained thanks to Gaussian lattice reduction, which yields two vectors <span class="math">(r_{1}(t),s_{1}(t))</span> and <span class="math">(r_{2}(t),s_{2}(t))</span>, the degree of whose coefficients <span class="math">r_{1}</span>, <span class="math">s_{1}</span>, <span class="math">r_{2}</span> and <span class="math">s_{2}</span> is approximately <span class="math">d_{\\mathfrak{q}}/2</span>.</li>

    </ul>

    <p class="text-gray-300">Similarly to the sieving phase, we fix a parameter <span class="math">e^{\\prime}</span> and enumerate all pairs of polynomials <span class="math">(i(t),j(t))\\in(\\mathbb{F}_{q}[t])^{2}</span> where <span class="math">i</span> is monic and both are of degree at most <span class="math">e^{\\prime}</span>. For each such pair, we then consider the element <span class="math">(ir_{1}+jr_{2},is_{1}+js_{2})\\in\\Lambda_{\\mathfrak{q}}</span> and try to factor the corresponding norms <span class="math">F(ir_{1}+jr_{2},is_{1}+js_{2},t)</span> and <span class="math">G(ir_{1}+jr_{2},is_{1}+js_{2},t)</span> as products of irreducible polynomials of degree at most <span class="math">b^{\\prime}</span>, with the smoothness bound <span class="math">b^{\\prime}=\\lambda d_{\\mathfrak{q}}</span> and the <em>descent parameter</em> <span class="math">\\lambda&lt;1</span>. One such doubly-<span class="math">b^{\\prime}</span>-smooth pair will then give us a linear relation between the discrete logarithm of <span class="math">\\mathfrak{q}</span> and that of several prime ideals whose norms have degree at most <span class="math">b^{\\prime}</span>.</p>

    <p class="text-gray-300">We finally iterate the process recursively until we end up considering only prime ideals whose norms have degree at most <span class="math">b</span>, that is, elements of the factor base, whose discrete logarithms were already computed in the linear algebra step.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.4 Complexity analysis</h3>

    <p class="text-gray-300">In order to lay the groundwork for the study of the proposed FFS factory algorithm in Section 3.2, we recall here the complexity analysis of the Function Field Sieve presented in the previous subsections, following the notations of Barbulescu <em>[6, Section 7.5]</em>, which are also that of Coppersmith <em>[12]</em> in the case of the Number Field Sieve.</p>

    <p class="text-gray-300">To that intent, let us first introduce the positive constants <span class="math">\\delta</span>, <span class="math">\\varepsilon</span>, and <span class="math">\\beta</span> so as to define the degree <span class="math">d</span> of <span class="math">f(x,t)</span>, the sieving bound <span class="math">e</span>, and the smoothness bound</p>

    <p class="text-gray-300"><span class="math">b</span> as follows:</p>

    <p class="text-gray-300"><span class="math">d=\\delta\\left(\\frac{k\\log q}{\\log k}\\right)^{1/3},\\quad e=\\varepsilon\\frac{k^{1/3}(\\log k)^{2/3}}{(\\log q)^{2/3}},\\quad\\text{and}\\quad b=\\beta\\frac{k^{1/3}(\\log k)^{2/3}}{(\\log q)^{2/3}}.</span></p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Sieving and linear algebra.</h5>

    <p class="text-gray-300">Given a pair <span class="math">(r,s)</span> of polynomials in the sieving range (i.e., both of degree at most <span class="math">e</span> and <span class="math">r</span> monic), we then denote by <span class="math">P_{f}</span> and <span class="math">P_{g}</span> the probabilities that the corresponding norms <span class="math">F(r,s,t)</span> and <span class="math">G(r,s,t)</span> are <span class="math">b</span>-smooth, respectively. The degrees of these norms can be bounded by</p>

    <p class="text-gray-300"><span class="math">\\deg F(r,s,t)</span> <span class="math">\\leq\\deg_{t}f+de\\approx de=\\;\\delta\\varepsilon\\frac{k^{2/3}(\\log k)^{1/3}}{(\\log q)^{1/3}}</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\mbox{(since </span>f<span class="math"> has small coefficients) and}</span> <span class="math">\\deg G(r,s,t)</span> <span class="math">\\leq\\deg_{t}g+e\\approx k/d=\\;\\frac{1}{\\delta}\\frac{k^{2/3}(\\log k)^{1/3}}{(\\log q)^{1/3}}</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\mbox{(since </span>\\deg_{t}g\\approx k/d<span class="math"> dominates </span>e<span class="math">)}.</span></p>

    <p class="text-gray-300">Assuming that these norms behave like random polynomials of the same degree, following <em>[27]</em>, we then estimate the probabilities that they are <span class="math">b</span>-smooth as</p>

    <p class="text-gray-300"><span class="math">P_{f}</span> <span class="math">=u^{-u(1+o(1))}\\quad\\text{where </span>u=\\frac{\\deg F(r,s,t)}{b}\\approx de/b=\\frac{\\delta\\varepsilon}{\\beta}\\left(\\frac{k\\log q}{\\log k}\\right)^{1/3}<span class="math"> and}</span> <span class="math">P_{g}</span> <span class="math">=v^{-v(1+o(1))}\\quad\\text{where </span>v=\\frac{\\deg G(r,s,t)}{b}\\approx k/db=\\frac{1}{\\delta\\beta}\\left(\\frac{k\\log q}{\\log k}\\right)^{1/3}<span class="math">},</span></p>

    <p class="text-gray-300">which we rewrite as <span class="math">P_{f}=L_{q^{k}}(1/3,\\frac{\\delta\\varepsilon}{3\\beta})^{-1+o(1)}</span> and <span class="math">P_{g}=L_{q^{k}}(1/3,\\frac{1}{3\\delta\\beta})^{-1+o(1)}</span>.</p>

    <p class="text-gray-300">Since the sieving domain comprises <span class="math">q^{2e+1}=L_{q^{k}}(1/3,2\\varepsilon)^{1+o(1)}</span> such pairs <span class="math">(r,s)</span>, the expected total number of relations collected by the sieving step is therefore <span class="math">q^{2e+1}P_{f}P_{g}</span>. However, in order to be able to solve the corresponding linear system, we require at least as many relations as there are elements in the factor base, whose cardinality is less than <span class="math">2q^{b}=L_{q^{k}}(1/3,\\beta)^{1+o(1)}</span>. Consequently, we impose that</p>

    <p class="text-gray-300"><span class="math">q^{2e+1}P_{f}P_{g}\\geq(2q^{b})^{1+o(1)}\\quad\\text{or, equivalently, that}\\quad 2\\varepsilon-\\frac{\\delta\\varepsilon}{3\\beta}-\\frac{1}{3\\delta\\beta}=\\beta.</span></p>

    <p class="text-gray-300">Solving in <span class="math">\\varepsilon</span>, and additionally requiring that <span class="math">\\delta&lt;6\\beta</span>, we finally obtain the following constraint on the sieving bound:</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\geq\\frac{3\\delta\\beta^{2}+1}{\\delta(6\\beta-\\delta)}.</span> (1)</p>

    <p class="text-gray-300">Furthermore, since the degrees of the norms <span class="math">F(r,s,t)</span> and <span class="math">G(r,s,t)</span> are polynomial in <span class="math">\\log(q^{k})</span>, checking if they are <span class="math">b</span>-smooth can be done in polynomial time, and the number of non-zero coefficients in the corresponding row of the matrix in the linear algebra step will also be polynomial in <span class="math">\\log(q^{k})</span>. Therefore, as FFS falls into the <span class="math">L_{q^{k}}(1/3,\\cdot)</span> sub-exponential complexity range, we can ignore these polynomial terms and obtain the following time complexities:</p>

    <p class="text-gray-300"><span class="math">T_{\\text{sieving}}</span> <span class="math">=(q^{2e+1})^{1+o(1)}=L_{q^{k}}(1/3,2\\varepsilon)^{1+o(1)}\\quad\\text{and}</span> <span class="math">T_{\\text{lin.algebra}}</span> <span class="math">=(2q^{b})^{2+o(1)}\\quad=L_{q^{k}}(1/3,2\\beta)^{1+o(1)}.</span></p>

    <p class="text-gray-300">These two steps being the most expensive ones in FFS, balancing their computational cost is key to minimize the overall complexity of the algorithm. We therefore impose the further constraint that <span class="math">e=b</span> or, equivalently, that <span class="math">\\varepsilon=\\beta</span>. Under that condition, (1) can be rewritten as a quadratic inequation in <span class="math">\\delta</span>, namely <span class="math">\\varepsilon\\delta^{2}-3\\varepsilon^{2}\\delta+1\\leq 0</span>, which admits a positive solution <span class="math">\\delta</span> if and only if <span class="math">\\varepsilon\\geq\\sqrt[3]{4/9}</span>.</p>

    <p class="text-gray-300">Consequently, setting the constants <span class="math">\\varepsilon=\\beta=\\sqrt[3]{4/9}</span>, we obtain <span class="math">\\delta=\\sqrt[3]{3/2}</span> and, finally, the overall complexity of FFS as</p>

    <p class="text-gray-300"><span class="math">T_{\\text{FFS}}=L_{q^{k}}(1/3,2\\varepsilon)^{1+o(1)}=L_{q^{k}}(1/3,\\sqrt[3]{32/9})^{1+o(1)}.</span></p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">4.2.2 Individual logarithms.</h4>

    <p class="text-gray-300">We follow here the reasoning of <em>[6, Section 7.3]</em> and adapt it to the FFS setting. It can be shown that the most expensive step in the computation of individual logarithms is the special-<span class="math">\\mathfrak{q}</span> descent when the degree <span class="math">d_{\\mathfrak{q}}</span> of the norm of the prime ideal <span class="math">\\mathfrak{q}</span> is closest to <span class="math">b</span>. In order to evaluate the complexity of this step, we consider here an ideal <span class="math">\\mathfrak{q}</span> whose norm has degree <span class="math">d_{\\mathfrak{q}}</span> of the form</p>

    <p class="text-gray-300"><span class="math">d_{\\mathfrak{q}}=\\gamma\\frac{k^{1/3}(\\log k)^{2/3}}{(\\log q)^{2/3}},\\quad\\text{with }\\gamma&gt;\\beta.</span></p>

    <p class="text-gray-300">Recall that, in that case, we consider the norms corresponding to pairs of polynomials of the form <span class="math">(ir_{1}+jr_{2},is_{1}+js_{2})\\in\\Lambda_{\\mathfrak{q}}\\subset(\\mathbb{F}_{q}[t])^{2}</span>, with the polynomials <span class="math">i</span> and <span class="math">j</span> of degree at most <span class="math">e^{\\prime}</span>, <span class="math">i</span> monic, and where the coefficients <span class="math">r_{1}</span>, <span class="math">r_{2}</span>, <span class="math">s_{1}</span>, and <span class="math">s_{2}</span> of the basis vectors all have degree around <span class="math">d_{\\mathfrak{q}}/2</span>. The degrees of these norms can therefore be bounded by</p>

    <p class="text-gray-300">\\[ \\begin{split}&\\deg F(ir_{1}+jr_{2},is_{1}+js_{2},t)\\lesssim\\deg_{t}f+d(e^{\\prime}+d_{\\mathfrak{q}}/2)\\approx d(e^{\\prime}+d_{\\mathfrak{q}}/2)\\quad\\text{and}\\\\ &\\deg G(ir_{1}+jr_{2},is_{1}+js_{2},t)\\lesssim\\deg_{t}g+(e^{\\prime}+d_{\\mathfrak{q}}/2)\\approx k/d.\\end{split} \\]</p>

    <p class="text-gray-300">Denoting by <span class="math">\\varepsilon^{\\prime}</span> the positive parameter such that <span class="math">e^{\\prime}=\\varepsilon^{\\prime}\\frac{k^{1/3}(\\log k)^{2/3}}{(\\log q)^{2/3}}</span>, the probabilities that these two norms are <span class="math">b^{\\prime}</span>-smooth, for <span class="math">b^{\\prime}=\\lambda d_{\\mathfrak{q}}</span>, are then given by <span class="math">P^{\\prime}_{f}=L_{q^{k}}(1/3,\\frac{\\delta\\varepsilon^{\\prime}}{3\\lambda\\gamma}+\\frac{\\delta}{6\\lambda})^{-1+o(1)}</span> and <span class="math">P^{\\prime}_{g}=L_{q^{k}}(1/3,\\frac{1}{3\\delta\\lambda\\gamma})^{-1+o(1)}</span>, respectively. Furthermore, since there is no point in taking a smoothness bound <span class="math">b^{\\prime}</span> for the descent lower than the sieving smoothness bound <span class="math">b</span>, we can assume that <span class="math">b^{\\prime}=\\lambda d_{\\mathfrak{q}}\\geq b</span>, whence <span class="math">\\lambda\\gamma\\geq\\beta</span>.</p>

    <p class="text-gray-300">Consequently, the overall probability to find one doubly-<span class="math">b^{\\prime}</span>-smooth relation in this descent step when considering all <span class="math">(i,j)</span> pairs can be bounded by</p>

    <p class="text-gray-300"><span class="math">q^{2e^{\\prime}+1}P^{\\prime}_{f}P^{\\prime}_{g}\\geq L_{q^{k}}\\left(1/3,2\\varepsilon^{\\prime}-\\frac{\\delta\\varepsilon^{\\prime}}{3\\beta}-\\frac{\\delta}{6\\lambda}-\\frac{1}{3\\delta\\beta}\\right)^{1+o(1)}.</span></p>

    <p class="text-gray-300">Since we require this probability to be non-negligible so that at least one such relation can actually be found, we end up with the following condition on <span class="math">\\varepsilon^{\\prime}</span>:</p>

    <p class="text-gray-300"><span class="math">\\varepsilon^{\\prime}\\geq\\frac{\\delta^{2}\\beta/(2\\lambda)+1}{\\delta(6\\beta-\\delta)}.</span> (2)</p>

    <p class="text-gray-300">Plugging in the values for <span class="math">\\beta</span> and <span class="math">\\delta</span> found previously and, following <em>[6]</em>, taking for <span class="math">\\lambda</span> a constant close but not equal to 1, such as 0.999, allows us to choose <span class="math">\\varepsilon^{\\prime}=\\sqrt[3]{1/18}</span>. The cost for this special-<span class="math">\\mathfrak{q}</span> descent step is then</p>

    <p class="text-gray-300"><span class="math">(q^{2e^{\\prime}+1})^{1+o(1)}=L_{q^{k}}(1/3,2\\varepsilon^{\\prime})^{1+o(1)}=L_{q^{k}}(1/3,\\sqrt[3]{4/9})^{1+o(1)}.</span></p>

    <p class="text-gray-300">Finally, considering the tree formed by the recursive calls in the descent process, one can check that the arity of each node is less than <span class="math">2k</span> (since special-<span class="math">\\mathfrak{q}</span> descent will produce less than <span class="math">2k</span> new prime ideals), while the total depth of the tree is given by <span class="math">w=\\log_{\\lambda}(b/b_{0})=O(\\log k)</span>. Therefore, the total number of nodes in the tree is in <span class="math">O(\\exp((\\log k)^{2})</span>, which is polynomial in <span class="math">\\log(q^{k})</span>. Consequently, ignoring the polynomial terms, the overall time complexity for computing an individual logarithm is the same as the complexity of a single special-<span class="math">\\mathfrak{q}</span> descent step, namely</p>

    <p class="text-gray-300"><span class="math">T_{\\mathrm{indiv.log.}}=L_{q^{k}}(1/3,\\sqrt[3]{4/9})^{1+o(1)}.</span></p>

    <h2 id="sec-10" class="text-2xl font-bold">3 The FFS factory</h2>

    <p class="text-gray-300">The main contribution of this paper is based on the observation that, in the Function Field Sieve, a same polynomial <span class="math">f(x,t)\\in\\mathbb{F}_{q}[t][x]</span> can be used to compute discrete logarithms in several finite fields of approximately the same size. Therefore, in a setting where one wants to compute discrete logarithms in many different finite fields of close enough sizes, it is possible to use a single polynomial <span class="math">f</span> for all these fields and share the computations on the algebraic side of the FFS algorithm.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 Batching FFS computations</h3>

    <p class="text-gray-300">Let us now assume that we want to compute discrete logarithms in several finite fields <span class="math">\\mathbb{F}_{q^{k^{\\prime}}}</span>, with <span class="math">k^{\\prime}\\leq k</span> and <span class="math">q</span> a prime power such that <span class="math">q=L_{q^{k}}(\\alpha,c)</span> with <span class="math">0\\leq\\alpha&lt;1/3</span> and <span class="math">c&gt;0</span>.</p>

    <p class="text-gray-300">The idea here is to split the relation collection step into two parts:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An <em>precomputation</em> step, which is performed only once, and which exclusively focuses on the algebraic (<em>i.e.</em>, left-hand) side of the FFS commutative diagram. In this step, we select a good polynomial <span class="math">f(x,t)\\in\\mathbb{F}_{q}[t][x]</span> of degree <span class="math">d</span>, and find all pairs <span class="math">(r,s)</span> in the sieving domain which are <span class="math">b</span>-smooth on the algebraic side. These pairs are then stored into a large file, where they can be reused later.</li>

      <li>An <em>individual sieving</em> step, which is performed for each target field <span class="math">\\mathbb{F}_{q^{k^{\\prime}}}</span>. Here, a linear polynomial <span class="math">g(x,t)</span> is first chosen so that its resultant in <span class="math">x</span> with <span class="math">f</span> has an irreducible factor of degree <span class="math">k^{\\prime}</span>. The previously computed file is then read, and each pair <span class="math">(r,s)</span> in this file is checked for <span class="math">b</span>-smoothness on the rational (<em>i.e.</em> right-hand) side.</li>

    </ul>

    <p class="text-gray-300">Once the individual sieving step is completed for a given finite field <span class="math">\\mathbb{F}_{q^{k^{\\prime}}}</span>, the remaining linear algebra and individual logarithm steps can be performed for this field just as in the original FFS algorithm.</p>

    <p class="text-gray-300">3.2 Complexity analysis</p>

    <p class="text-gray-300">Since the first part of the relation collection step is now shared between several discrete logarithm computations, the optimal values for the parameters <span class="math">b</span>, <span class="math">d</span>, and <span class="math">e</span> will differ from the ones in the original FFS. In order to find these new values, we build upon the complexity analysis of FFS detailed in Section 2.4.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">3.2.1 Relation collection and linear algebra.</h4>

    <p class="text-gray-300">First of all, one has to remark that, with respect to the parameters <span class="math">b</span>, <span class="math">d</span>, and <span class="math">e</span>, the degrees of the polynomials <span class="math">f</span> and <span class="math">g</span>, the sieving domain and the factor base are the same as in the original FFS. In other words, the sieving domain still comprises <span class="math">q^{2e+1}=L_{q^{k}}(1/3,2\\varepsilon)^{1+o(1)}</span> pairs of polynomials <span class="math">(r,s)</span>, the cardinality of the factor base is still less that <span class="math">2q^{b}=L_{q^{k}}(1/3,\\beta)^{1+o(1)}</span>, and the degrees of the norms <span class="math">F(r,s,t)</span> and <span class="math">G(r,s,t)</span> are still bounded by <span class="math">de</span> and <span class="math">k/d</span>, respectively.</p>

    <p class="text-gray-300">Consequently, the condition <span class="math">q^{2e+1}P_{f}P_{g}=(2q^{b})^{1+o(1)}</span> which ensures that enough relations are collected in order to solve the corresponding linear system imposes the exact same constraint on <span class="math">\\varepsilon</span>:</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\geq\\frac{3\\delta\\beta^{2}+1}{\\delta(6\\beta-\\delta)},\\;\\;\\;\\text{with}\\;\\delta&lt;6\\beta.</span> (1)</p>

    <p class="text-gray-300">We now consider the costs of the various steps involved in the FFS factory. Note however that the actual values of the constants <span class="math">\\beta</span>, <span class="math">\\delta</span>, and <span class="math">\\varepsilon</span> will be determined later.</p>

    <p class="text-gray-300">First of all, as the precomputation step requires to enumerate all pairs <span class="math">(r,s)</span> of the sieving domain, its complexity is</p>

    <p class="text-gray-300"><span class="math">T_{\\text{precomp.}}=(q^{2e+1})^{1+o(1)}=L_{q^{k}}(1/3,2\\varepsilon)^{1+o(1)}.</span></p>

    <p class="text-gray-300">Furthermore, since each pair <span class="math">(r,s)</span> has probability <span class="math">P_{f}</span> to be <span class="math">b</span>-smooth on the algebraic side, the number of such <span class="math">b</span>-smooth pairs written to the file in this precomputation step is then</p>

    <p class="text-gray-300"><span class="math">N_{\\text{precomp.}}=q^{2e+1}P_{f}=L_{q^{k}}\\left(1/3,2\\varepsilon-\\frac{\\delta\\varepsilon}{3\\beta}\\right)^{1+o(1)}.</span></p>

    <p class="text-gray-300">Then, for each target field, we need to perform the corresponding individual sieving step, which entails going through all the precomputed pair <span class="math">(r,s)</span> and checking whether each of them is <span class="math">b</span>-smooth on the rational side. Since this check can be done in polynomial time, the actual complexity of this step is then <span class="math">T_{\\text{indiv.sieving}}=N_{\\text{precomp.}}</span>.</p>

    <p class="text-gray-300">The linear algebra step, which also has to be performed for each target field, still has complexity quadratic in the size of the factor base, as in the original FFS:</p>

    <p class="text-gray-300"><span class="math">T_{\\text{lin.algebra}}=(2q^{b})^{2+o(1)}=L_{q^{k}}(1/3,2\\beta)^{1+o(1)}.</span></p>

    <p class="text-gray-300">Finally, we denote by <span class="math">T_{\\text{indiv.FFS}}=T_{\\text{indiv.sieving}}+T_{\\text{lin.algebra}}</span> the overall time complexity of the specific computations required for each target field.</p>

    <p class="text-gray-300">Individual logarithms. In a similar way as for the sieving constraint on <span class="math">\\varepsilon</span>, one can easily see that computing a special-<span class="math">\\mathfrak{q}</span> descent step in a target field <span class="math">\\mathbb{F}_{q^{k^{\\prime}}}</span> entails exactly the same constraint on the parameter <span class="math">\\varepsilon^{\\prime}</span> of the sieving region as in the case of the original FFS:</p>

    <p class="text-gray-300"><span class="math">\\varepsilon^{\\prime}\\geq\\frac{\\delta^{2}\\beta/(2\\lambda)+1}{\\delta(6\\beta-\\delta)}.</span> (2)</p>

    <p class="text-gray-300">Furthermore, the cost of an individual logarithm in this field will also be</p>

    <p class="text-gray-300"><span class="math">T_{\\mathrm{indiv.log.}}=L_{q^{k}}(1/3,2\\varepsilon^{\\prime})^{1+o(1)}.</span></p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Balancing the complexities.</h4>

    <p class="text-gray-300">Assuming that the precomputation step is done once and for all, we only need to balance the cost of the individual sieving and linear algebra steps for each target field. Setting <span class="math">q^{2e+1}P_{f}=(2q^{b})^{2+o(1)}</span> and using the constraint (1) on <span class="math">\\varepsilon</span>, we obtain the condition <span class="math">\\delta\\geq 1/(3\\beta^{2})</span>, which in turn imposes that <span class="math">\\beta&gt;\\sqrt[3]{1/18}</span>, since (1) also requires that <span class="math">\\delta&lt;6\\beta</span>.</p>

    <p class="text-gray-300">In fact, it can be shown that, for any <span class="math">\\lambda&lt;1</span>, the quantity</p>

    <p class="text-gray-300"><span class="math">\\varepsilon^{\\prime}-\\beta\\geq\\frac{\\delta^{2}\\beta/(2\\lambda)+1}{\\delta(6\\beta-\\delta)}-\\beta\\geq\\frac{3\\beta\\delta^{2}-12\\beta^{2}\\delta+2}{2\\delta(6\\beta-\\delta)}</span></p>

    <p class="text-gray-300">is always positive when <span class="math">\\sqrt[3]{1/18}&lt;\\beta&lt;\\sqrt[3]{1/6}</span>. Consequently, if one takes <span class="math">\\beta</span> in that interval, then the cost of computing an individual logarithm in a target field <span class="math">\\mathbb{F}_{q^{k^{\\prime}}}</span> will dominate that of the linear algebra step in the same field. The intuitive explanation is that, in such a case, the factor base is too small and the descent is thus much harder. It is therefore useless to consider values of <span class="math">\\beta</span> below <span class="math">\\sqrt[3]{1/6}</span>. Similarly, considering values of <span class="math">\\beta</span> larger that <span class="math">\\sqrt[3]{4/9}</span> is also useless, as such values will yield complexities larger than that of the original FFS algorithm, thus defeating the purpose of the FFS factory approach.</p>

    <p class="text-gray-300">In the following, we denote by <span class="math">\\varepsilon_{0}</span> the lower bound on <span class="math">\\varepsilon</span> given by (1):</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{0}(\\beta,\\delta)=\\frac{3\\delta\\beta^{2}+1}{\\delta(6\\beta-\\delta)}.</span></p>

    <p class="text-gray-300">We first study the behavior of <span class="math">\\varepsilon_{0}</span> with respect to <span class="math">\\delta</span>, in the range <span class="math">1/(3\\beta^{2})\\leq\\delta&lt;6\\beta</span>, for a fixed value of <span class="math">\\sqrt[3]{1/6}&lt;\\beta\\leq\\sqrt[3]{4/9}</span>. Taking the partial derivative of <span class="math">\\varepsilon_{0}</span> with respect to <span class="math">\\delta</span> then gives</p>

    <p class="text-gray-300"><span class="math">\\frac{\\partial\\varepsilon_{0}}{\\partial\\delta}(\\beta,\\delta)=\\frac{3\\beta^{2}\\delta^{2}+2\\delta-6\\beta}{\\delta^{2}(6\\beta-\\delta)^{2}},</span></p>

    <p class="text-gray-300">which is negative when <span class="math">1/(3\\beta^{2})\\leq\\delta&lt;\\delta_{0}(\\beta)</span> and positive when <span class="math">\\delta_{0}(\\beta)&lt;\\delta&lt;6\\beta</span>, with <span class="math">\\delta_{0}(\\beta)=(\\xi(\\beta)-1)/(3\\beta^{2})</span> and <span class="math">\\xi(\\beta)=\\sqrt{18\\beta^{3}+1}</span>. Hence, in order to minimize <span class="math">\\varepsilon_{0}</span>, we define <span class="math">\\tilde{\\varepsilon}_{0}(\\beta)=\\varepsilon_{0}(\\beta,\\delta_{0}(\\beta))</span>. This function and its derivative with respect to <span class="math">\\beta</span> are then given by</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\varepsilon}_{0}(\\beta)=\\varepsilon_{0}(\\beta,\\delta_{0}(\\beta))=\\left(\\frac{3\\beta^{2}}{\\xi(\\beta)-1}\\right)^{2}\\quad\\text{and}\\quad\\frac{d\\tilde{\\varepsilon}_{0}}{d\\beta}(\\beta)=\\frac{9\\beta^{3}\\left(\\xi(\\beta)^{2}-4\\xi(\\beta)+3\\right)}{\\xi(\\beta)(\\xi(\\beta)-1)^{3}},</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">FFS Factory</p>

    <p class="text-gray-300">respectively. The latter shows that  <span class="math">\\tilde{\\varepsilon}_0</span>  is a strictly decreasing function of  <span class="math">\\beta</span>  on the whole interval  <span class="math">\\sqrt[3]{1/6} &amp;lt; \\beta &amp;lt; \\sqrt[3]{4/9}</span> , its derivative vanishing at  <span class="math">\\beta = \\sqrt[3]{4/9}</span> .</p>

    <p class="text-gray-300">Similarly, fixing  <span class="math">\\delta = \\delta_0(\\beta)</span>  in constraint (2) for individual logarithms gives the following lower bound on the parameter  <span class="math">\\varepsilon&#x27;</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon^ {\\prime} \\geq \\frac {\\beta}{2 \\xi (\\beta)} \\left(\\frac {1}{\\lambda} + \\frac {\\xi (\\beta) + 1}{\\xi (\\beta) - 1}\\right),</span></div>

    <p class="text-gray-300">which becomes  <span class="math">\\varepsilon&#x27; \\geq \\beta / (\\xi(\\beta) - 1)</span>  when  <span class="math">\\lambda</span>  is chosen to be almost equal to 1.</p>

    <p class="text-gray-300">One can remark that, when taking  <span class="math">\\beta = \\sqrt[3]{4/9}</span> , we end up with the exact same complexity as the original FFS algorithm:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T _ {\\text {p r e c o m p .}} = T _ {\\text {i n d i v . F F S}} = L _ {q ^ {k}} \\left(1 / 3, \\sqrt [ 3 ]{3 2 / 9}\\right) ^ {1 + o (1)} \\quad \\text {a n d} \\\\ T _ {\\text {i n d i v . l o g .}} = L _ {q ^ {k}} \\left(1 / 3, \\sqrt [ 3 ]{4 / 9}\\right) ^ {1 + o (1)}. \\\\ \\end{array}</span></div>

    <h2 id="sec-14" class="text-2xl font-bold">3.3 Discussion</h2>

    <p class="text-gray-300">From the previous analysis, taking the parameters  <span class="math">\\varepsilon = \\tilde{\\varepsilon}_0(\\beta)</span>  and  <span class="math">\\varepsilon&#x27; = \\beta / (\\xi(\\beta) - 1)</span> , one can use  <span class="math">\\beta</span>  in order to adjust the tradeoff between the cost of the precomputation step and that of the individual sieving/linear algebra steps, depending on how many target fields  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span>  are considered.</p>

    <p class="text-gray-300">Indeed, if one wants to compute discrete logarithms in many different finite fields, taking a lower value for  <span class="math">\\beta</span>  will increase the precomputation time, while decreasing the individual cost for each target field. This can be seen in Figure 1, in which the costs  <span class="math">T_{\\mathrm{precomp.}}</span> ,  <span class="math">T_{\\mathrm{indiv.FFS}}</span> , and  <span class="math">T_{\\mathrm{indiv.log.}}</span>  are given as functions of  <span class="math">\\beta</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 1. Costs of the various steps in the FFS factory, as functions of  <span class="math">\\beta</span> , and expressed as the parameter  <span class="math">c</span>  which appears in their complexity when written as  <span class="math">L_{q^k}(1/3, c)</span> .</p>

    <p class="text-gray-300">Of course, mitigating the extra cost of the precomputation step requires that enough target fields are considered. In fact, the number <span class="math">N</span> of distinct finite fields in which to compute discrete logarithms should be of the form <span class="math">N=L_{q^{k}}(1/3,\\nu)^{1+o(1)}</span>, with <span class="math">\\nu&gt;0</span>, in order to be able to amortize the precomputation cost. For instance, while <span class="math">\\beta=\\sqrt[3]{4/9}</span> corresponds to the original FFS algorithm and can therefore be used even for a single target field, on the other hand, setting <span class="math">\\beta=\\sqrt[3]{1/6}</span> requires that <span class="math">N\\geq T_{\\text{FFS}}/T_{\\text{precomp.}}</span> or, in other words, that <span class="math">\\nu\\geq\\sqrt[3]{9/2}-\\sqrt[3]{32/9}\\approx 0.125</span>. In that case, we have the following complexity estimates:</p>

    <p class="text-gray-300"><span class="math">T_{\\text{precomp.}}</span> <span class="math">=L_{q^{k}}(1/3,\\sqrt[3]{9/2})^{1+o(1)}\\quad\\text{and}</span> <span class="math">T_{\\text{indiv.FFS}}</span> <span class="math">=T_{\\text{indiv.log}}</span> <span class="math">=L_{q^{k}}(1/3,\\sqrt[3]{4/3})^{1+o(1)}.</span></p>

    <p class="text-gray-300">However, since the finite fields of a given size <span class="math">q^{k^{\\prime}}</span> are all isomorphic, and that this isomorphism is computable in polynomial time, there is absolutely no point in applying the FFS factory to more than one field of each size. As there are only a polynomial number of distinct finite fields <span class="math">\\mathbb{F}_{q^{k^{\\prime}}}</span> with <span class="math">k^{\\prime}\\leq k</span>, there is no way for <span class="math">N</span> to be in the <span class="math">L_{q^{k}}(1/3,\\cdot)</span> complexity range as <span class="math">k</span> grows. On first sight, this renders the whole FFS factory approach useless, at least asymptotically.</p>

    <p class="text-gray-300">However, this criticism might be mitigated as, since 2013, it is known that FFS, asymptotically speaking, is no longer the most efficient algorithm known for computing discrete logarithms in finite fields of small characteristic <em>[23, 14, 8]</em>. Even though the exact crossing point between FFS and these asymptotically faster algorithms is not known yet, recent experiments show that computing discrete logarithms using FFS still makes sense for finite fields <span class="math">\\mathbb{F}_{q^{k}}</span> of size <span class="math">\\log_{2}(q^{k})</span> up to around 1000 bits <em>[5]</em>. It turns out that, for fields of that size, the quantity <span class="math">L_{q^{k}}(1/3,\\nu)</span> amounts to at most a few dozens when <span class="math">\\nu\\leq\\sqrt[3]{9/2}-\\sqrt[3]{32/9}</span>. Therefore, in this case, the number <span class="math">N</span> of finite fields to consider for the FFS factory to be better than <span class="math">N</span> independent instances of the original FFS is roughly of the same order of magnitude and is thus totally manageable in practice, as shown by the experiment presented in Section 4.</p>

    <h2 id="sec-15" class="text-2xl font-bold">4 Practical experiment</h2>

    <p class="text-gray-300">In order to assess the applicability and the impact of the proposed FFS factory approach, we have implemented this algorithm and used it to compute discrete logarithms in the 50 binary finite fields <span class="math">\\mathbb{F}_{2^{k^{\\prime}}}</span> for all odd values of <span class="math">k^{\\prime}</span> between 601 and 699 (inclusive), which fall slightly below the current size records for FFS <em>[17, 5]</em>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.0.1 Software implementation.</h3>

    <p class="text-gray-300">Our implementation of the FFS factory is based on the C implementation of FFS which is freely available as part of the cado-nfs software suite <em>[4]</em>. Since some of the steps in the FFS factory are identical to those of the original FFS, we were able to directly reuse various part of cado-nfs for our computation, such as the polynomial selection <em>[7]</em>, the filtering utilities</p>

    <p class="text-gray-300">(which prepare the matrix before the linear algebra) <em>[11]</em>, or the GPU-based linear algebra implementation <em>[18]</em>.</p>

    <p class="text-gray-300">However, the relation collection step had to be modified so as to match the FFS factory algorithm. In the cado-nfs implementation of FFS, this step is directly based on the implementation described by Detrey et al. in <em>[13]</em> which, among other techniques, uses</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>special-q sieving, which ensure that large prime ideals q (on either the algebraic or the rational side) appear in the relations, thus increasing the smoothness probabilities; and</li>

      <li>lattice sieving, which, in a somewhat similar way to the sieve of Eratosthenes, allows one to quickly find all pairs <span class="math">(r,s)</span> which are divisible by small prime ideals (on both sides), and to actually check for smoothness only those pairs which are divisible by sufficiently many of these small prime ideals, since they will then have higher chances of being <span class="math">b</span>-smooth.</li>

    </ul>

    <p class="text-gray-300">In order for this program to follow the FFS factory approach, we have modified it to support several polynomials (and therefore several target fields) on the rational side at the same time, thus sharing the (pre)computations for the algebraic side amongst all target fields. We have also disabled both the special-q sieving and the lattice sieving on the rational side, but kept these techniques for the algebraic side so as to maintain the running time of the precomputation step as low as possible.</p>

    <p class="text-gray-300">All in all, adding support for the FFS factory mostly entailed minute changes in the cado-nfs software. It is therefore planned that these changes eventually make their way into the official code base of cado-nfs, and that the FFS factory becomes available in future releases.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">3.2.2 Experimental setup and results.</h4>

    <p class="text-gray-300">In order to compute discrete logarithms in all finite fields <span class="math">\\mathbb{F}_{2^{k^{\\prime}}}</span>, with <span class="math">k^{\\prime}</span> odd and between 601 and 699, using the proposed FFS factory, we used the same degree-6 polynomial <span class="math">f(x,t)</span> for the algebraic side that was used for the discrete logarithm computation in <span class="math">\\mathbb{F}_{2^{809}}^{\\times}</span> <em>[5]</em>:</p>

    <p class="text-gray-300"><span class="math">f(x,t)=x^{6}+0\\textsf{x}7x^{5}+0\\textsf{x}6\\textsf{b}x^{3}+0\\textsf{x}1\\textsf{a}\\textsf{b}x^{2}+0\\textsf{x}326x+0\\textsf{x}19\\textsf{b}3.</span></p>

    <p class="text-gray-300">Note that we also considered using a degree-5 polynomial, but none were found in the polynomial selection step that were as good as the one above for the considered finite fields.</p>

    <p class="text-gray-300">Sieving was performed using the implementation described above on Intel Xeon E5-2650 CPUs running at 2.0 GHz. The smoothness bound was fixed to <span class="math">b=26</span>, and we lattice-sieved on the algebraic side all prime ideals whose norm had degree at most 20. We sieved for special-q’s of norm starting at degree 21 and increasing until enough relations were found. As soon as sufficiently many relations were collected for a given target field, we stopped sieving for this field. Sieving timings and the number of collected relations for each target field are reported in Figure 2 (left).</p>

    <p class="text-gray-300">J. Detrey</p>

    <p class="text-gray-300">It is to be noted that the precomputation step required 38.2 core-days, and that the 50 individual sieving steps took a total of 1788.6 core-days. If we had used the original FFS instead, we estimate that this computation would have required about 2991.3 core-days to produce a similar set of relations. Therefore, the FFS factory induced a speedup of  <span class="math">39\\%</span>  on the overall computation time, that is, a saving of almost 3.2 core-years on an 8.2-core-year computation.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. Timings for the relation collection step on each target field  <span class="math">\\mathbb{F}_{2^{k&#x27;}}</span> , for both the original FFS (estimated) and the FFS factory, along with the number of collected relations (left). Timings for the linear algebra step on each target field, along with the number of rows and columns of the corresponding matrix (right).</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">As mentioned previously, we used Jeljeli's GPU implementation of the block Wiedemann algorithm for the linear algebra step [18]. Timings on Nvidia GTX 680 graphics cards, along with the dimension of the corresponding matrices (whose density was set to an average of 100 non-zero coefficients per row), are given in Figure 2 (right). This computation represents a total running time of 83.8 GPU-days.</p>

    <p class="text-gray-300">In this paper, we have presented an adaptation of Coppersmith's "factorization factory" idea to the case of the Function Field Sieve for batching discrete logarithm computations in several finite fields of small characteristic. Along with a careful complexity analysis showing that this approach can be leveraged in practice to decrease the total computation time when enough target fields are considered, we also presented a working implementation of this algorithm based on the FFS implementation of cado-nfs. This implementation was used in a full-scale experiment in order to validate our analysis, thus solving the discrete logarithm problem in all the binary finite fields  <span class="math">\\mathbb{F}_{2^{k&#x27;}}</span>  of odd extension degree  <span class="math">k&#x27;</span>  and of size from 601 to 699 bits. For this experiment, the observed speedup against the original FFS algorithm was  <span class="math">39\\%</span> .</p>

    <p class="text-gray-300">FFS Factory</p>

    <p class="text-gray-300">Even though the days of FFS are now numbered, it is far from obsolete yet, especially for finite fields of (almost) prime extension degrees and of size around or below 1000 bits. Future works include polishing the FFS factory implementation so that it can be published as part of the cado-nfs suite and, more importantly, using this approach to (pre)compute discrete logarithms in as many binary (or ternary) finite fields as possible so as to complete the database of factor bases in computer algebra systems such as Magma or Sage. Even though such computations need to be done only once, they still represent a huge endeavor when large field sizes are targeted.</p>

    <h2 id="sec-19" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Adj, G., Menezes, A., Oliveira, T., Rodríguez-Henríquez, F.: Computing discrete logarithms in <span class="math">\\mathbb{F}_{2^{6}\\cdot 137}</span> and <span class="math">\\mathbb{F}_{2^{6}\\cdot 163}</span> using Magma (2014), Cryptology ePrint Archive, report 2014/057</li>

      <li>[2] Adleman, L.M.: The function field sieve. In: Adleman, L.M., Huang, M.D.A. (eds.) Algorithmic Number Theory – ANTS-I. Lecture Notes in Computer Science, vol. 877, pp. 108–121. Springer–Verlag (1994)</li>

      <li>[3] Adleman, L.M., Huang, M.D.A.: Function field sieve method for discrete logarithms over finite fields. Information and Computation 151(1–2), 5–16 (1999)</li>

      <li>[4] Bai, S., Bouvier, C., Filbois, A., Gaudry, P., Imbert, L., Kruppa, A., Morain, F., Thomé, E., Zimmermann, P.: cado-nfs, an implementation of the Number Field Sieve algorithm, release 2.0, available from http://cado-nfs.gforge.inria.fr/</li>

      <li>[5] Barbulescu, R., Bouvier, C., Detrey, J., Gaudry, P., Jeljeli, H., Thomé, E., Videau, M., Zimmermann, P.: Discrete logarithm in GF(2^{809}) with FFS. In: Krawczyk, H. (ed.) Public-Key Cryptography – PKC 2014. Lecture Notes in Computer Science, vol. 8383, pp. 221–238. Springer–Verlag (2014)</li>

      <li>[6] Barbulescu, R.: Algorithms of discrete logarithm in finite fields. Ph.D. thesis, Université de Lorraine (2013), available at http://tel.archives-ouvertes.fr/tel-00925228</li>

      <li>[7] Barbulescu, R.: Selecting polynomials for the Function Field Sieve (2013), preprint, 23 pages, available at http://hal.inria.fr/hal-00798386</li>

      <li>[8] Barbulescu, R., Gaudry, P., Joux, A., Thomé, E.: A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In: Nguyen, P.Q., Oswald, E. (eds.) Advances in Cryptology – EUROCRYPT 2014. Lecture Notes in Computer Science, vol. 8441, pp. 1–16. Springer–Verlag (2014)</li>

      <li>[9] Bosma, W., Cannon, J.J., Fieker, C., Steel, A.: Summary of new features in Magma V2.20. Available at http://magma.maths.usyd.edu.au/magma/releasenotes/2/20/ (Dec 2013)</li>

      <li>[10] Bosma, W., Cannon, J.J., Playoust, C.: The Magma algebra system. I. The user language. Journal of Symbolic Computation 24(3-4), 235–265 (1997)</li>

      <li>[11] Bouvier, C.: The filtering step of discrete logarithm and integer factorization algorithms (2013), preprint, 22 pages, available at http://hal.inria.fr/hal-00734654</li>

      <li>[12] Coppersmith, D.: Modifications to the Number Field Sieve. Journal of Cryptology 6(3), 169–180 (1993)</li>

      <li>[13] Detrey, J., Gaudry, P., Videau, M.: Relation collection for the Function Field Sieve. In: Nannarelli, A., Seidel, P.M., Tang, P.T.P. (eds.) IEEE Symposium on Computer Arithmetic – ARITH-21. pp. 201–210. IEEE (2013)</li>

    </ul>

    <p class="text-gray-300">14] Göloğlu, F., Granger, R., McGuire, G., Zumbrägel, J.: On the function field sieve and the impact of higher splitting probabilities. In: Canetti, R., Garay, J.A. (eds.) Advances in Cryptology – CRYPTO 2013. Lecture Notes in Computer Science, vol. 8043, pp. 109–128. Springer–Verlag (2013)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] Göloğlu, F., Granger, R., McGuire, G., Zumbrägel, J.: Solving a 6120-bit DLP on a desktop computer. In: Lange, T., Lauter, K., Lisoněk, P. (eds.) Selected Areas in Cryptography – SAC 2013. Lecture Notes in Computer Science, vol. 8282, pp. 136–152. Springer–Verlag (2014)</li>

      <li>[16] Granger, R., Kleinjung, T., Zumbrägel, J.: Discrete logarithms in GF(2^{9234}). E-mail to the NMBRTHRY mailing list, http://listserv.nodak.edu/archives/nmbrthry.html (Jan 2014)</li>

      <li>[17] Hayashi, T., Shimoyama, T., Shinohara, N., Takagi, T.: Breaking pairing-based cryptosystems using <span class="math">\\eta_{T}</span> pairing over <span class="math">GF(3^{97})</span>. In: Wang, X., Sako, K. (eds.) Advances in Cryptology – ASIACRYPT 2012. Lecture Notes in Computer Science, vol. 7658, pp. 43–60. Springer–Verlag (2012)</li>

      <li>[18] Jeljeli, H.: Accelerating iterative SpMV for Discrete Logarithm Problem using GPUs (2013), preprint, 11 pages, available at http://hal.inria.fr/hal-00734975</li>

      <li>[19] Joux, A., Lercier, R.: The function field sieve is quite special. In: Fieker, C., Kohel, D.R. (eds.) Algorithmic Number Theory – ANTS-V. Lecture Notes in Computer Science, vol. 2369, pp. 431–445. Springer–Verlag (2002)</li>

      <li>[20] Joux, A.: Discrete logarithms in GF(2^{1778}). E-mail to the NMBRTHRY mailing list, http://listserv.nodak.edu/archives/nmbrthry.html (Feb 2013)</li>

      <li>[21] Joux, A.: Discrete logarithms in GF(2^{4080}). E-mail to the NMBRTHRY mailing list, http://listserv.nodak.edu/archives/nmbrthry.html (Mar 2013)</li>

      <li>[22] Joux, A.: Discrete logarithms in GF(2^{6168}) [= GF((2^{257})^{24})]. E-mail to the NMBRTHRY mailing list, http://listserv.nodak.edu/archives/nmbrthry.html (May 2013)</li>

      <li>[23] Joux, A.: A new index calculus algorithm with complexity <span class="math">L(1/4+o(1))</span> in very small characteristic. In: Lange, T., Lauter, K., Lisoněk, P. (eds.) Selected Areas in Cryptography – SAC 2013. Lecture Notes in Computer Science, vol. 8282, pp. 355–379. Springer–Verlag (2014)</li>

      <li>[24] Kleinjung, T.: private communication (2012)</li>

      <li>[25] LaMacchia, B.A., Odlyzko, A.M.: Solving large sparse linear systems over finite fields. In: Menezes, A.J., Vanstone, S.A. (eds.) Advances in Cryptology – CRYPTO ’90. Lecture Notes in Computer Science, vol. 537, pp. 109–133. Springer–Verlag (1990)</li>

      <li>[26] Matsumoto, R.: Using <span class="math">C_{ab}</span> curves in the function field sieve. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences E82-A(3), 551–552 (1999)</li>

      <li>[27] Panario, D., Gourdon, X., Flajolet, P.: An analytic approach to smooth polynomials over finite fields. In: Buhler, J.P. (ed.) Algorithmic Number Theory – ANTS-III. Lecture Notes in Computer Science, vol. 1423, pp. 226–236. Springer–Verlag (1998)</li>

    </ul>`;
---

<BaseLayout title="FFS Factory: Adapting Coppersmith&#x27;s &quot;Factorization Factory&quot; ... (2014/419)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/419
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
