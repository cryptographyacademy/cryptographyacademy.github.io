---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1351';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proximity Gaps in Interleaved Codes';
const AUTHORS_HTML = 'Benjamin E. Diamond, Angus Gruen';

const CONTENT = `    <p class="text-gray-300">Benjamin E. DIAMOND Irreducible bdiamond@irreducible.com Angus GRUEN Polygon agruen@polygon.technology</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">A linear error-correcting code exhibits <em>proximity gaps</em> if each affine line of words either consists entirely of words which are close to the code or else contains almost no such words. In this short note, we prove that for each linear code which exhibits proximity gaps within the unique decoding radius, that code’s interleaved code also does. Combining our result with a recent argument of Angeris, Evans and Roh (’24), we extend those authors’ sharpening of the tensor-based proximity gap of Diamond and Posen (Commun. Cryptol. ’24) up to the unique decoding radius, at least in the Reed–Solomon setting.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Proximity gaps for linear codes reside at the heart of modern hash-based SNARKs <em>[x1]</em> <em>[x12]</em>. That a code features <em>proximity gaps</em> ensures that for each list which fails to consist <em>entirely</em> of words which are close to the code, most linear combinations of that list’s words themselves fail to be close to the code. This condition implies that, with high probability, the closeness of a random combination of a list’s elements faithfully proxies the closeness of that list itself. This guarantee undergirds the soundness of many popular SNARKs, including FRI-based <em>[x1, § 8.2]</em> and Ligero-style <em>[x1]</em> <em>[x15]</em> <em>[x16]</em> ones. In these SNARKs, the prover commits the list at issue; the verifier uses its combination of that list to test the prover.</p>

    <p class="text-gray-300">The most fundamental manifestation of the <em>proximity gaps</em> phenomenon pertains to affine lines. We fix a field <span class="math">\\mathbb{F}_{q}</span> and an <span class="math">[n,k,d]</span>-code <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> over <span class="math">\\mathbb{F}_{q}</span>, as well as a <em>proximity parameter</em> <span class="math">e</span> and a <em>false witness bound</em> <span class="math">\\varepsilon</span>. The code <span class="math">C</span> is said to feature <em>proximity gaps for affine lines</em> with respect to the parameters <span class="math">e</span> and <span class="math">\\varepsilon</span> if, roughly, for each affine line <span class="math">U\\subset\\mathbb{F}_{q}^{n}</span>, <em>either</em> fewer than or equal to <span class="math">\\varepsilon</span> among <span class="math">U</span>’s elements fall within distance <span class="math">e</span> from <span class="math">C</span> or else all of <span class="math">U</span>’s elements do. In this latter case, we in fact obtain a certain stronger condition, called <em>correlated agreement</em>. This condition entails that, for some set consisting of <span class="math">e</span> or fewer among the coordinate axes <span class="math">\\{0,\\ldots,n-1\\}</span>, the projection which collapses these axes maps the line <span class="math">U\\subset\\mathbb{F}_{q}^{n}</span> identically into the image of <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> (i.e., the image of <span class="math">U</span> under this projection consists entirely of punctured codewords).</p>

    <p class="text-gray-300">We explain this phenomenon intuitively. Upon puncturing <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> arbitrarily at <span class="math">e</span> positions, choosing an affine line consisting entirely of <em>punctured</em> codewords, and finally lifting that line back to <span class="math">\\mathbb{F}_{q}^{n}</span> itself, we obtain a further affine line <span class="math">U\\subset\\mathbb{F}_{q}^{n}</span> which “trivially” consists exclusively of <span class="math">e</span>-close points. The proximity gap phenomenon entails that each affine line <span class="math">U</span> which contains sufficiently many close points—that is, more than <span class="math">\\varepsilon</span> of them—must in fact consist <em>identically</em> of <span class="math">e</span>-close points (and in this most trivial of ways, no less).</p>

    <p class="text-gray-300">The <em>interleaved code</em> abstraction captures this phenomenon concisely. For each <span class="math">m\\geq 1</span>, <span class="math">C</span>’s <span class="math">m</span>-fold <em>interleaving</em> <span class="math">C^{m}\\subset\\mathbb{F}_{q}^{m\\times n}</span> is the set of <span class="math">m\\times n</span> matrices all of whose rows are codewords. The <em>distance</em> between two words in <span class="math">\\mathbb{F}_{q}^{m\\times n}</span> is the number of columns at which those words fail to agree identically. Each affine line yields a word <span class="math">U</span> in the two-fold interleaving <span class="math">\\mathbb{F}_{q}^{2\\times n}</span>. By definition, <span class="math">C</span> exhibits proximity gaps for affine lines if each word <span class="math">U</span> in <span class="math">\\mathbb{F}_{q}^{2\\times n}</span> more than <span class="math">\\varepsilon</span> of whose affine row-combinations are <span class="math">e</span>-close to <span class="math">C</span> is itself <span class="math">e</span>-close to <span class="math">C^{2}</span>.</p>

    <p class="text-gray-300">As Ben-Sasson et al. <em>[x1]</em> show, each code <span class="math">C</span> which features proximity gaps for affine lines <em>also</em> features proximity gaps of various further sorts. For example, <em>[x1, Thm. 1.6]</em> shows each code <span class="math">C</span> which features proximity gaps over lines also features proximity gaps over <em>higher-dimensional affine subspaces</em>. That is, if <span class="math">C</span> features proximity gaps for lines, then, for each <span class="math">m&gt;1</span>, each <span class="math">m</span>-fold interleaved word <span class="math">U</span> a proportion of more than <span class="math">\\frac{\\varepsilon}{q}</span> among whose affine row-combinations are <span class="math">e</span>-close to <span class="math">C</span> is itself <span class="math">e</span>-close to <span class="math">C^{m}</span>. The result <em>[x1, Thm. 1.5]</em> shows something analogous for <em>low-degree parameterized curves</em>, albeit with the linearly worse false witness probability <span class="math">(m-1)\\cdot\\frac{\\varepsilon}{q}</span>.</p>

    <p class="text-gray-300">1.1 Proximity Gaps for Tensor Combinations</p>

    <p class="text-gray-300">Diamond and Posen <em>[x10]</em> study a further sort of proximity gap. Their main result <em>[x10, Thm. 2]</em> shows that each code <span class="math">C</span> which exhibits proximity gaps for affine lines also exhibits proximity gaps for <em>tensor combinations</em>. That is, if <span class="math">C</span> features proximity gaps for lines—with respect to the parameters <span class="math">e</span> and <span class="math">\\varepsilon</span> say, where moreover <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right\\}</span>—then, for each <span class="math">\\vartheta&gt;1</span>, the tensor-combinations of the rows of each interleaved word <span class="math">U\\in\\mathbb{F}_{q}^{2^{\\vartheta}\\times n}</span> witness that word’s interleaved distance from <span class="math">C^{2^{\\vartheta}}</span>. More precisely, if the probability, taken over <span class="math">(r_{0},\\ldots,r_{\\vartheta-1})\\leftarrow\\mathbb{F}_{q}^{\\vartheta}</span>, that</p>

    <p class="text-gray-300">\\[ d\\Bigg{(}\\Big{[}\\quad\\bigotimes_{i=0}^{\\vartheta-1}(1-r_{i},r_{i})\\quad\\Big{]}\\cdot\\begin{bmatrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}u_{0}&\\end{matrix}\\end{matrix}\\end{bmatrix},C\\\\ \\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{0}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{}\\end{\\mbox{}} \\]</p>

    <p class="text-gray-300">holds is sufficiently high, then <span class="math">d^{2^{\\vartheta}}\\left((u_{i})_{i=0}^{2^{\\vartheta}-1},C^{2^{\\vartheta}}\\right)\\leq e</span>. Here, <span class="math">\\bigotimes_{i=0}^{\\vartheta-1}(1-r_{i},r_{i})</span> is a <em>tensor product</em>, a vector which arises naturally in the context of multilinear evaluation (we refer to Section 2 below for further background). Specifically, <em>[x10, Thm. 2]</em> achieves the false witness probability <span class="math">2\\cdot\\vartheta\\cdot\\frac{\\varepsilon}{q}</span>, a bound which surpasses by <span class="math">2\\cdot\\vartheta</span>-fold the underlying bound for lines. In <em>[x10, Rem. 3]</em>, Diamond and Posen suggest, as a problem for future work, the elimination of that bound’s factor of <span class="math">2</span>.</p>

    <p class="text-gray-300">In recent work, Angeris, Evans and Roh <em>[x2]</em> eliminate that factor of <span class="math">2</span>, albeit using an argument which works only in the restricted range <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{3}\\right\\rfloor\\right\\}</span>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Our Contribution</h3>

    <p class="text-gray-300">In this work, we extend Angeris, Evans and Roh’s <em>[x2]</em> result to the range <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right\\}</span>. We explain this paper’s contribution slightly more precisely. Angeris, Evans and Roh’s result proceeds in two steps. In the first step, those authors argue directly that, for each code <span class="math">C</span>, each proximity parameter <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{3}\\right\\rfloor\\right\\}</span>, and each interleaving factor <span class="math">m\\geq 1</span>, the interleaved code <span class="math">C^{m}</span> features proximity gaps for affine lines with respect to <span class="math">e</span> and the false witness bound <span class="math">\\varepsilon\\coloneqq e+1</span>. Their proof of that result works only in the range <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{3}\\right\\rfloor\\right\\}</span>, and follows essentially exactly the argument of <em>[x10, Thm. 1]</em> (that result proves that, in the range <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{3}\\right\\rfloor\\right\\}</span>, each standard, <em>noninterleaved</em> code <span class="math">C</span> features proximity gaps for lines with respect to <span class="math">e</span> and <span class="math">\\varepsilon\\coloneqq e+1</span>). In their argument’s second step, those authors show that each code <span class="math">C</span> whose interleavings feature proximity gaps over lines <em>also</em> features tensor-style proximity gaps.</p>

    <p class="text-gray-300">To extend Angeris, Evans and Roh’s result, we must achieve their argument’s first step in the larger range <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right\\}</span>. To do this, we show that <em>if</em> <span class="math">C</span> exhibits proximity gaps for affine lines with respect to the parameters <span class="math">e</span> and <span class="math">\\varepsilon</span>—where, again, we allow arbitrary <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right\\}</span>—then, for each <span class="math">m&gt;1</span>, <span class="math">C</span>’s interleaving <span class="math">C^{m}</span> also does. We prove that result as our main Theorem 3.1 below. The second step of our proof proceeds exactly as Angeris, Evans and Roh’s does; we reproduce that step as our Theorem 3.6 below.</p>

    <p class="text-gray-300">Combining Theorems 3.1 and 3.6, we conclude that if <span class="math">C</span> exhibits proximity gaps for affine lines with respect to <span class="math">e</span> and <span class="math">\\varepsilon</span>—where, again, <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right\\}</span> may vary arbitrarily—then <span class="math">C</span> also exhibits <span class="math">\\vartheta</span>-ary tensor-style proximity gaps for each <span class="math">\\vartheta\\geq 1</span>, with the sharpened false witness probability <span class="math">\\vartheta\\cdot\\frac{\\varepsilon}{q}</span> no less.</p>

    <p class="text-gray-300">We note finally that, by Ben-Sasson et al. <em>[Ben+23, Thm. 4.1]</em>, Reed–Solomon codes exhibit proximity gaps for affine lines up to the unique decoding radius. Our Theorems 3.1 and Theorem 3.6 thus apply to those codes, at the very least. (Whether <em>general</em> linear codes in fact exhibit proximity gaps for affine lines up to the unique decoding radius remains an important open problem; we note our Conjecture 4.3 below.)</p>

    <p class="text-gray-300">In the important Reed–Solomon special case, therefore, we improve <em>[x10, Thm. 2]</em>’s false witness probability by a factor of <span class="math">2</span> over the entire unique decoding range.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 The Conjecture for General Codes</h3>

    <p class="text-gray-300">As a miscellaneous further contribution, we show that the conjecture <em>[x10, Conj. 1]</em> is false as written, by exhibiting a code <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> and an affine line <span class="math">U\\subset\\mathbb{F}_{q}^{n}</span> which, though it lacks correlated agreement with <span class="math">C</span>, contains <span class="math">n</span> close points (see Example 4.1 below). Since our code <span class="math">C</span> is Reed–Solomon, our example moreover shows that <em>[Ben+23, Thm. 4.1]</em> is sharp (i.e., its false witness probability cannot be decreased). We amend <em>[x10, Conj. 1]</em>, by increasing that conjecture’s false witness bound from <span class="math">e+1</span> to <span class="math">n</span> (see Conjecture 4.3).</p>

    <p class="text-gray-300">1.4 Impact of our Result</p>

    <p class="text-gray-300">The <em>use</em> within modern SNARKs of proximity gaps is complicated; we note the rigorous treatments carried out in <em>[x10]</em> and <em>[x11]</em>. For now, we sketch the impact informally.</p>

    <p class="text-gray-300">Roughly, in applications, one wants the false witness probability <span class="math">\\varepsilon</span> to be as small as possible and the proximity parameter <span class="math">e</span> to be as large as possible. (As soon as <span class="math">e</span> becomes <em>greater</em> then the unique decoding radius <span class="math">\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor</span>, things become complicated, and new proof techniques become required. On the other hand, increasing <span class="math">e</span> from <span class="math">\\left\\lfloor\\frac{d-1}{3}\\right\\rfloor</span> to <span class="math">\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor</span> amounts to a “free win”.) Why? Coding-based SNARKs face two main sorts of soundness error.</p>

    <p class="text-gray-300">In those SNARKs, one shows that a <em>cheating</em> prover must, during the course of the protocol, commit to an interleaved word which is far from the interleaved code. The first sort of error entails “bad batching”; in this situation, upon row-combining the cheating prover’s <em>far</em> interleaved word, the verifier nonetheless obtains a <em>close</em> combination. This sort of error is a “fixed error”, which happens—or doesn’t happen—exactly once (i.e., when the verifier samples its combination coefficients). The second sort of error entails “unlucky querying”; it results when the verifier, though faced with a combined word which is <em>far</em> from the code, nonetheless tests exclusively positions of that word which spuriously agree with a codeword. This latter sort of error is a “variable error”, in that the verifier may always drive down it to zero—at least, eventually—by performing more queries.</p>

    <p class="text-gray-300">Thus, these protocols have total soundness error roughly given by:</p>

    <p class="text-gray-300"><span class="math">\\vartheta\\cdot\\frac{\\varepsilon}{q}+\\Big{(}1-\\frac{e}{n}\\Big{)}^{\\gamma}.</span> (1)</p>

    <p class="text-gray-300">Here, <span class="math">\\varepsilon</span> and <span class="math">e</span> respectively represent the test’s false witness probability and proximity parameter; <span class="math">\\gamma</span> represents the number of queries the verifier makes.</p>

    <p class="text-gray-300">We explain the expression (1) above. The probability with which the verifier samples <em>bad batching</em> coefficients—i.e., (1)’s first term—is controlled by proximity test’s false witness probability <span class="math">\\varepsilon</span> (bad batching coefficients <em>falsely witness</em> the closeness to the code of an interleaved codeword which actually isn’t close). The expression (1)’s second term represents the probability that the verifier evades the bad batching event, and yet, during <em>each</em> of its subsequent queries, nonetheless manages to miss the combination’s disagreeing positions. The proximity gap’s proximity parameter <span class="math">e</span> controls the <em>per-query</em> probability with which the verifier fails to catch the cheating prover. In other words, the proximity parameter controls the exponential decay <em>rate</em> with which the protocol’s total soundness error approaches its batching error (i.e., as the verifier’s number of queries grows). In practice, it is <span class="math">\\gamma</span>, the number of queries, that <em>directly</em> mediates proof size, and which we’d like to keep small.</p>

    <p class="text-gray-300">We fix a <em>desired</em> number <span class="math">\\Xi</span> of bits of security (for example, we can take <span class="math">\\Xi\\coloneqq 100</span>). In each SNARK, we must choose <span class="math">\\gamma</span> so large that the error expression (1) above drops beneath or equal to <span class="math">2^{-\\Xi}</span>. Of course, we can choose <span class="math">\\gamma</span> this way <em>in the first place</em> only when the limiting soundness error <span class="math">\\vartheta\\cdot\\frac{\\varepsilon}{q}</span> is itself less than the security threshold <span class="math">2^{-\\Xi}</span>. When <span class="math">\\vartheta\\cdot\\frac{\\varepsilon}{q}</span> is <em>much</em> smaller than the desired security level <span class="math">2^{-\\Xi}</span>, the decay rate <span class="math">1-\\frac{e}{n}</span> dominates the determination of this minimal, satisfactory <span class="math">\\gamma</span>. On the other hand, as this the limiting soundness error <span class="math">\\vartheta\\cdot\\frac{\\varepsilon}{q}</span> begins to approach <span class="math">2^{-\\Xi}</span> from below, the minimum adequate <span class="math">\\gamma</span> is liable to soar.</p>

    <p class="text-gray-300">In this work, we achieve a first term of just <span class="math">\\vartheta\\cdot\\frac{\\varepsilon}{q}</span> (compare the batching error <span class="math">2\\cdot\\vartheta\\cdot\\frac{\\varepsilon}{q}</span> achieved by <em>[x10, Thm. 2]</em>) <em>and</em> a proximity parameter upper limit <span class="math">e\\leq\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor</span> (compare that of <span class="math">\\left\\lfloor\\frac{d-1}{3}\\right\\rfloor</span> achieved by <em>[x2]</em>). Each of these previous works achieves exactly one of these conditions; we attain both simultaneously. The concrete impact of our work depends on the various parameters at hand (as well as on to which among the works <em>[x10]</em> and <em>[x2]</em> the comparison is made).</p>

    <p class="text-gray-300">In the limit of a <em>small</em> batching error <span class="math">\\vartheta\\cdot\\frac{\\varepsilon}{q}</span> approaching zero and a <em>large</em> distance <span class="math">d</span> approaching <span class="math">n</span>—an important, representative special case—our work improves upon <em>[x2]</em> by a factor of <span class="math">\\frac{1}{\\log_{2}(3)-1}\\approx 1.710</span>, which is significant. Indeed, in this case, one has</p>

    <p class="text-gray-300"><span class="math">\\gamma\\approx\\log_{1-\\frac{e}{n}}\\big{(}2^{-\\Xi}\\big{)}=\\Xi\\cdot\\frac{-1}{\\log_{2}(1-\\frac{e}{n})}.</span></p>

    <p class="text-gray-300">We improve the argument <span class="math">1-\\frac{e}{n}</span> above from just under <span class="math">\\frac{2}{3}</span> to just under <span class="math">\\frac{1}{2}</span> (again, for <span class="math">d</span> near <span class="math">n</span>). That is, we improve the scaling factor <span class="math">\\frac{1}{\\log_{2}(1-\\frac{e}{n})}</span> attached to <span class="math">\\Xi</span> from just over <span class="math">\\frac{-1}{\\log_{2}(^{2}/3)}\\approx 1.710</span> to just over <span class="math">\\frac{-1}{\\log_{2}(^{1}/3)}=1</span>.</p>

    <p class="text-gray-300">In the opposite direction, our work, in comparison to <em>[x10]</em>, improves by 1 bit the <em>limiting</em> soundness error to which the protocol tends, in the limit of a large number of queries <span class="math">\\gamma</span>. The impact of this phenomenon is seen most clearly in the case of a batching error <span class="math">2\\cdot\\vartheta\\cdot\\frac{c}{q}</span> which closely approaches <span class="math">2^{-\\Xi}</span> from below. Amid this sort of phenomenon, <em>[x10]</em> would begin to demand ballooning values <span class="math">\\gamma</span>; our work would not. Indeed, by creating space between the limiting batching error and the desired security level, our improvement creates a sort of “breathing room” in precisely this sort of situation, liable to significantly reduce <span class="math">\\gamma</span>. As a more extreme sort of case, we fix a scenario in which <span class="math">2\\cdot\\vartheta\\cdot\\frac{c}{q}\\geq 2^{-\\Xi}</span> holds, and yet <span class="math">\\vartheta\\cdot\\frac{c}{q}&lt;2^{-\\Xi}</span>. In this latter sort of case, <em>[x10]</em> would fail altogether even to instantiate the protocol (i.e., it would be unable to achieve <span class="math">\\Xi</span> bits of security, regardless of how high it set <span class="math">\\gamma</span>). Our work allows <span class="math">\\Xi</span> bits of security to be attained after all even in cases of this sort.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.5 Application to FRI</h3>

    <p class="text-gray-300">We have already mentioned the essential role played by tensor-style proximity gaps in Ligero-like succinct proof protocols <em>[x2]</em> <em>[x10]</em>. As it happens, the same phenomenon appears also in FRI-based protocols, as concurrent work of Diamond and Posen <em>[x11]</em> makes clear.</p>

    <p class="text-gray-300">We recall the <em>FRI</em> interactive oracle proof of proximity for Reed–Solomon codes, due to Ben-Sasson, Bentov, Horesh and Riabzev <em>[x4]</em>. As is discussed in <em>[BBHR18, § 3.2]</em> and again in subsequent work of Ben-Sasson et al. <em>[Ben+23, Claim. 8.1]</em>, FRI supports certain <em>higher-arity</em> folding schemata, in which each word is collapsed in a <span class="math">2^{\\eta}</span>-to-1 manner (i.e., for <span class="math">\\eta\\geq 1</span>, in general). The folding arity parameter <span class="math">\\eta</span> mediates an efficiency tradeoff. As <span class="math">\\eta</span> increases, the total number of oracles committed to, as well as the total number of Merkle paths sent, decreases; on the other hand, the respective sizes of the various cosets sent increase. The “sweet spot” in practical applications appears to occur around <span class="math">\\eta=4</span> <em>[x11]</em>.</p>

    <p class="text-gray-300">Both <em>[BBHR18]</em> and <em>[Ben+23, § 8.2]</em> achieve higher-arity folding by <em>univariate interpolation</em>. To explain this, we briefly fix notation. We fix a field <span class="math">\\mathbb{F}_{q}</span>, subsets <span class="math">S^{(i)}</span> and <span class="math">S^{(i+1)}</span> of <span class="math">\\mathbb{F}_{q}</span>, and a <span class="math">2^{\\eta}</span>-to-1 map <span class="math">q^{(i)}:S^{(i)}\\to S^{(i+1)}</span>; we finally fix a function <span class="math">f^{(i)}</span> on <span class="math">S^{(i)}</span>. To fold the word <span class="math">f^{(i)}</span> with respect to the random challenge <span class="math">r\\in\\mathbb{F}_{q}</span>, say, the prover and verifier both define <span class="math">f^{(i+1)}:S^{(i+1)}\\to\\mathbb{F}_{q}</span> pointwise according to the recipe</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f^{(i+1)}:y\\mapsto\\textsf{Interpolant}\\bigg{(}f^{(i)}\\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{q^{(i)-1}(\\{y\\})}\\bigg{)}(r).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, for each <span class="math">y\\in S^{(i+1)}</span> given, the fiber <span class="math">q^{(i)^{-1}}(\\{y\\})\\subset S^{(i)}</span> is of size <span class="math">2^{\\eta}</span>. The restriction of <span class="math">f^{(i)}</span> to this fiber defines a unique <em>polynomial</em> of degree less than <span class="math">2^{\\eta}</span>, namely $\\textsf{Interpolant}\\bigg{(}f^{(i)}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{q^{(i)-1}(\\{y\\})}\\bigg{)}<span class="math">. The value of </span>f^{(i+1)}<span class="math"> at </span>y<span class="math"> is <em>defined</em> to be the value of this latter interpolant at the out-of-domain point </span>r\\in\\mathbb{F}_{q}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As is explained in <em>[Ben+23, § 8.2]</em>, FRI’s security proof uses—at a key juncture—the fact whereby Reed–Solomon codes exhibit proximity gaps. Which type? In the standard 2-to-1 folding setting (i.e., in the case <span class="math">\\eta=1</span>), the relevant proximity gap is that for affine lines (i.e., Definition 2.1). As is made clear in <em>[Ben+23, § 8.2.1]</em>, the security of <em>univariate</em> higher-arity FRI folding depends on the proximity gap for <em>low-degree parameterized curves</em> <em>[Ben+23, Thm. 1.5]</em>. This latter proximity gap’s false witness probability exceeds that for affine lines’ by a factor <em>linear</em> in the length of the list (i.e., by <span class="math">2^{\\eta}-1</span>). That proximity gap thus contributes a linear factor in <span class="math">2^{\\eta}</span> to that protocol’s soundness error.</p>

    <p class="text-gray-300">Diamond and Posen <em>[x11]</em> introduce a new type of higher-arity FRI-folding, as we now explain. We fix a folding arity constant <span class="math">\\vartheta\\geq 1</span> (we use a new symbol, to avoid confusion with <span class="math">\\eta</span>). The work <em>[x11, § 3.2]</em> stipulates that the prover and verifier simply fold <span class="math">f^{(i)}</span> in a 2-to-1 way <em>repeatedly</em>. That is, the prover folds <span class="math">f^{(i)}</span> <span class="math">\\vartheta</span> times in succession, “skipping” all intermediate oracles, and consuming <span class="math">\\vartheta</span> random challenges in the process (as opposed to just one). The prover commits only to the final result. This strategy achieves a proof size profile identical to that achieved by univariate higher-arity folding. Its security depends exactly on the fact whereby Reed–Solomon codes exhibit <em>tensor-style</em> proximity gaps (i.e., see Corollary 3.7). This security reduction—i.e., from repeated 2-ary FRI folding to tensor-style proximity gaps—is carried out in detail in <em>[x11, Thm. 3.16]</em> (see in particular <em>[x11, Prop. 3.20]</em>). Its soundness error, finally, improves upon that of univariate folding, precisely because the false witness premium of tensor-folding grows only like <span class="math">\\vartheta</span>, and not like <span class="math">2^{\\vartheta}</span>. We thus suggest oracle-skipping as a new, and more natural, FRI-folding mechanism, provably secure in light of <em>[x11, Thm. 2]</em> and this work.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Acknowledgements. We would like to sincerely thank Ulrich Haböck and Daniel Lubarov for various helpful discussions.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Background</h2>

    <p class="text-gray-300">We recall background notation, following Guruswami <em>[x10]</em> and Diamond and Posen <em>[x12]</em>. For each <span class="math">\\vartheta\\geq 1</span>, the <em>boolean cube</em> <span class="math">\\mathcal{B}_{\\vartheta}</span> is <span class="math">\\{0,1\\}^{\\vartheta}</span>. We fix a finite field <span class="math">\\mathbb{F}_{q}</span>. For each <span class="math">\\vartheta\\geq 1</span> and each pair of lists <span class="math">(a_{0,0},\\ldots,a_{0,\\vartheta-1})</span> and <span class="math">(a_{1,0},\\ldots,a_{1,\\vartheta-1})</span> of <span class="math">\\mathbb{F}_{q}</span>-elements, the <em>tensor product</em> <span class="math">\\bigotimes_{i=0}^{\\vartheta-1}(a_{0,i},a_{1,i})</span> is defined to be the vector <span class="math">\\left(\\prod_{i=0}^{\\vartheta-1}a_{v_{i},i}\\right)_{v\\in\\mathcal{B}_{\\vartheta}}</span>. Using the little-endian convention, we understand each vector of this latter form as a flat, length-<span class="math">2^{\\vartheta}</span> array.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each pair of elements <span class="math">v_{0}</span> and <span class="math">v_{1}</span> of <span class="math">\\mathbb{F}_{q}</span>, we define the <em>disagreement set</em> between <span class="math">v_{0}</span> and <span class="math">v_{1}</span> as $\\Delta(v_{0},v_{1})\\coloneqq\\{i\\in\\{0,\\ldots,n-1\\}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,v_{0,i}\\neq v_{1,i}\\}<span class="math">. The Hamming <em>distance</em> between </span>v_{0}<span class="math"> and </span>v_{1}<span class="math"> is </span>d(v_{0},v_{1})\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(v_{0},v_{1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. A linear </span>[n,k,d]<span class="math">-<em>code</em> over </span>\\mathbb{F}_{q}<span class="math"> is a </span>k<span class="math">-dimensional linear subspace </span>C\\subset\\mathbb{F}_{q}^{n}<span class="math"> for which, for each pair of distinct elements </span>v_{0}<span class="math"> and </span>v_{1}<span class="math"> of </span>C<span class="math">, </span>d(v_{0},v_{1})\\geq d<span class="math">. The <em>unique decoding radius</em> of the </span>[n,k,d]<span class="math">-code </span>C\\subset\\mathbb{F}_{q}^{n}<span class="math"> is </span>\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor<span class="math">; indeed, we note that, for each word </span>u\\in\\mathbb{F}_{q}^{n}<span class="math">, at most one codeword </span>v\\in C<span class="math"> satisfies </span>d(u,v)<\\frac{d}{2}<span class="math"> (this fact is a direct consequence of the triangle inequality). For </span>u\\in\\mathbb{F}_{q}^{n}<span class="math"> arbitrary, we write </span>d(u,C)\\coloneqq\\min_{v\\in C}d(u,v)<span class="math"> for the <em>distance</em> between </span>u<span class="math"> and the code </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each linear code <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> and each integer <span class="math">m\\geq 1</span>, we define <span class="math">C</span>’s <em><span class="math">m</span>-fold interleaved code</em> as <span class="math">C^{m}\\subset\\left(\\mathbb{F}_{q}^{n}\\right)^{m}\\cong\\left(\\mathbb{F}_{q}^{m}\\right)^{n}</span>. We understand this latter set as a length-<span class="math">n</span> block code over the alphabet <span class="math">\\mathbb{F}_{q}^{m}</span>. In particular, its elements are matrices in <span class="math">\\mathbb{F}_{q}^{m\\times n}</span> each of whose rows is a <span class="math">C</span>-element. We often write matrices as lists of <em>rows</em>—i.e., by writing <span class="math">(u_{i})_{i=0}^{m-1}\\in\\mathbb{F}_{q}^{m\\times n}</span>. By definition of <span class="math">C^{m}</span>, two matrices in <span class="math">\\mathbb{F}_{q}^{m\\times n}</span> <em>differ</em> at a column if they differ at <em>any</em> of that column’s components. That a matrix <span class="math">(u_{i})_{i=0}^{m-1}\\in\\mathbb{F}_{q}^{m\\times n}</span> is within distance <span class="math">e</span> to the code <span class="math">C^{m}</span> thus entails that there exists a matrix <span class="math">(v_{i})_{i=0}^{m-1}</span> whose <em>rows are all codewords</em> and a subset <span class="math">D\\coloneqq\\Delta^{m}\\Big{(}(u_{i})_{i=0}^{m-1},C^{m}\\Big{)}</span> of <span class="math">\\{0,\\ldots,n-1\\}</span>, of size at most <span class="math">e</span>, for which, for each <span class="math">j\\in\\{0,\\ldots,n-1\\}</span>, the columns <span class="math">(u_{i,j})_{i=0}^{m-1}</span> and <span class="math">(v_{i,j})_{i=0}^{m-1}</span> are identical.</p>

    <p class="text-gray-300">The following key definition is implicit in <em>[x2]</em> and <em>[x13]</em>. Below, we fix a field <span class="math">\\mathbb{F}_{q}</span> and an arbitrary linear <span class="math">[n,k,d]</span>-code <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.1.</h6>

    <p class="text-gray-300">We say that <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> features <em>proximity gaps for affine lines</em> with respect to the proximity parameter <span class="math">e</span> and the false witness bound <span class="math">\\varepsilon</span> if, for each pair of words <span class="math">u_{0}</span> and <span class="math">u_{1}</span> in <span class="math">\\mathbb{F}_{q}^{n}</span>, if</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r\\in\\mathbb{F}_{q}}\\left[d((1-r)\\cdot u_{0}+r\\cdot u_{1},C)\\leq e\\right]&gt;\\frac{\\varepsilon}{q}</span></p>

    <p class="text-gray-300">holds, then <span class="math">d^{2}\\Big{(}(u_{i})_{i=0}^{1},C^{2}\\Big{)}\\leq e</span> also does.</p>

    <p class="text-gray-300">We note that for each <span class="math">r\\in\\mathbb{F}_{q}</span>,</p>

    <p class="text-gray-300"><span class="math">d((1-r)\\cdot u_{0}+r\\cdot u_{1},C)\\leq d^{2}\\Big{(}(u_{i})_{i=0}^{1},C^{2}\\Big{)}.</span></p>

    <p class="text-gray-300">Hence, if <span class="math">C</span> features proximity gaps for affine lines, then, for each pair of words <span class="math">u_{0}</span> and <span class="math">u_{1}</span> in <span class="math">\\mathbb{F}_{q}^{n}</span>, exactly one of the following conditions must hold:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r\\in\\mathbb{F}_{q}}\\left[d((1-r)\\cdot u_{0}+r\\cdot u_{1},C)\\leq e\\right]\\leq\\frac{\\varepsilon}{q}\\quad\\text{or}\\quad\\Pr_{r\\in\\mathbb{F}_{q}}\\left[d((1-r)\\cdot u_{0}+r\\cdot u_{1},C)\\leq e\\right]=1.</span></p>

    <p class="text-gray-300">We fix an interleaved word <span class="math">(u_{i})_{i=0}^{1}</span> for which the second condition above holds, and write <span class="math">(v_{i})_{i=0}^{1}</span> for an interleaved codeword in <span class="math">C^{2}</span> for which <span class="math">d^{2}((u_{i})_{i=0}^{1},(v_{i})_{i=0}^{1})\\leq e</span>. So long as <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right\\}</span> is in the unique decoding radius, for each <span class="math">r\\in\\mathbb{F}_{q}</span>, the codeword closest to <span class="math">u_{r}\\coloneqq(1-r)\\cdot u_{0}+r\\cdot u_{1}</span> can be none other than <span class="math">v_{r}\\coloneqq(1-r)\\cdot v_{0}+r\\cdot v_{1}</span>. Indeed, for each <span class="math">j\\not\\in\\Delta^{2}((u_{i})_{i=0}^{1},(v_{i})_{i=0}^{1})</span>, <span class="math">u_{0,j}=v_{0,j}</span> and <span class="math">u_{1,j}=v_{1,j}</span> both hold, so that <span class="math">u_{r,j}=v_{r,j}</span> also does, and <span class="math">j\\not\\in\\Delta(u_{r},v_{r})</span>. We conclude that <span class="math">\\Delta(u_{r},v_{r})\\subset\\Delta^{2}((u_{i})_{i=0}^{1},(v_{i})_{i=0}^{1})</span>.</p>

    <p class="text-gray-300">We recall Reed–Solomon codes (see e.g. <em>[x10, Def. 2.3]</em>). We fix nonnegative <em>message length</em> and <em>block length</em> length parameters <span class="math">k</span> and <span class="math">n</span>, as well as a subset <span class="math">S\\subset\\mathbb{F}_{q}</span> of size <span class="math">n</span>. We write <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> for the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{RS}_{\\mathbb{F}_{q},S}[k,n]\\coloneqq \\left\\{(P(x))_{x\\in S}\\bigm{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P(X)\\in \\mathbb{F}_{q}[X]^{\\prec k}\\right\\}<span class="math">. That is, </span>\\mathsf{RS}_{\\mathbb{F}_{q},S}[k,n]<span class="math"> is the set of those </span>n<span class="math">-tuples which arise as the evaluations of some polynomial </span>P(X)<span class="math"> of degree less than </span>k<span class="math"> on the set </span>S<span class="math">. The distance of </span>\\mathsf{RS}_{\\mathbb{F}_{q},S}[k,n]<span class="math"> is </span>d = n - k + 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following important result of Ben-Sasson et al. [Ben+23] shows that Reed-Solomon codes exhibit proximity gaps up to the unique decoding radius (with the false witness bound <span class="math">\\varepsilon = n</span>). Below, we fix a field <span class="math">\\mathbb{F}_q</span>, a domain <span class="math">S\\subset \\mathbb{F}_q</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math">, and a message length </span>k\\leq n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Theorem 2.2</strong> (Ben-Sasson, et al. [Ben+23, Thm. 4.1]). For each <span class="math">e \\in \\{0, \\dots, \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor \\}</span>, <span class="math">\\mathsf{RS}_{\\mathbb{F}_q, S}[k, n]</span> exhibits proximity gaps for affine lines with respect to the proximity parameter <span class="math">e</span> and the false witness bound <span class="math">\\varepsilon \\coloneqq n</span>.</p>

    <p class="text-gray-300">The following definition is implicit in [DP24b, Thm. 2], though it sharpens by a factor of two that result's false witness probability.</p>

    <p class="text-gray-300"><strong>Definition 2.3.</strong> We say that <span class="math">C \\subset \\mathbb{F}_q^n</span> features tensor-style proximity gaps with respect to the proximity parameter <span class="math">e</span> and the false witness bound <span class="math">\\varepsilon</span> if, for each <span class="math">\\vartheta \\geq 1</span> and each list of words <span class="math">u_0, \\ldots, u_{2^\\vartheta - 1}</span> in <span class="math">\\mathbb{F}_q^n</span>, if</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{(r_0,\\ldots ,r_{\\vartheta -1})\\in \\mathbb{F}_q^\\vartheta}\\left[d\\left(\\left[ \\begin{array}{cccc}\\bigotimes_{i = 0}^{\\vartheta -1}(1 - r_i,r_i) &amp;amp; \\bigcirc \\end{array} \\right]\\cdot \\left[ \\begin{array}{ccc}\\text{—}&amp;amp;u_0&amp;amp; \\text{—}\\\\ &amp;amp; \\vdots &amp;amp; \\\\ \\text{—}&amp;amp;u_{2^\\vartheta -1}&amp;amp; \\text{—} \\end{array} \\right],C\\right)\\leq e\\right] &amp;gt; \\vartheta \\cdot \\frac{\\varepsilon}{q}</span></div>

    <p class="text-gray-300">holds, then <span class="math">d^{2^{\\vartheta}}\\left((u_i)_{i = 0}^{2^{\\vartheta} - 1},C^{2^{\\vartheta}}\\right)\\leq e</span> also does.</p>

    <p class="text-gray-300">The extensive role of tensor-style proximity gaps in succinct proofs is developed at length in [DP24b].</p>

    <p class="text-gray-300">We now present our main theorem. We fix a field <span class="math">\\mathbb{F}_q</span> and an arbitrary <span class="math">[n,k,d]</span>-code <span class="math">C\\subset \\mathbb{F}_q^n</span>.</p>

    <p class="text-gray-300"><strong>Theorem 3.1.</strong> If <span class="math">C</span> features proximity gaps for affine lines with respect to the proximity parameter <span class="math">e \\in \\{0, \\ldots, \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor \\}</span> and the false witness bound <span class="math">\\varepsilon \\geq e + 1</span>, then, for each <span class="math">m &amp;gt; 1</span>, <span class="math">C</span>'s interleaving <span class="math">C^m</span> also does.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We fix a code <span class="math">C</span> which satisfies the hypothesis of the theorem, as well as interleaved words <span class="math">U_0</span> and <span class="math">U_1</span> in <span class="math">\\mathbb{F}_q^{m \\times n}</span>. For each <span class="math">r \\in \\mathbb{F}_q</span>, we write <span class="math">U_r \\coloneqq (1 - r) \\cdot U_0 + r \\cdot U_1</span> for the corresponding point on the affine line spanned by <span class="math">U_0</span> and <span class="math">U_1</span>. For each row <span class="math">i \\in \\{0, \\ldots, m-1\\}</span> and each column <span class="math">j \\in \\{0, \\ldots, n-1\\}</span>, we write <span class="math">(U_r)_i</span> and <span class="math">(U_r)^j</span>, respectively, for <span class="math">U_r</span>'s <span class="math">i^{\\text{th}}</span> row and <span class="math">j^{\\text{th}}</span> column. Finally, we write <span class="math">R^*</span> for the set of parameters <span class="math">r \\in \\mathbb{F}_q</span> for which the combination <span class="math">U_r</span> is <span class="math">e</span>-close to the interleaved code <span class="math">C^m</span>; in other words:</p>

    <div class="my-4 text-center"><span class="math-block">R^* := \\{r \\in \\mathbb{F}_q \\mid d^m(U_r, C^m) \\leq e\\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To prove the theorem, we must show that if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\varepsilon<span class="math">, then </span>U_0<span class="math"> and </span>U_1<span class="math"> feature correlated agreement with </span>C^m<span class="math">. In other words, we must show that exist interleaved codewords </span>V_0<span class="math"> and </span>V_1<span class="math"> in </span>C^m<span class="math"> and a subset </span>D \\subset \\{0, \\ldots, n-1\\}<span class="math"> of cardinality </span>e<span class="math"> or less such that, for each </span>j \\in \\{0, \\ldots, n-1\\} \\setminus D<span class="math"> and each </span>b \\in \\{0, 1\\}<span class="math">, the columns </span>(U_b)^j = (V_b)^j$ are identical.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We start by producing the codewords <span class="math">V_0</span> and <span class="math">V_1</span>. We fix an individual row-index <span class="math">i \\in \\{0, \\dots, m-1\\}</span>. We note first that, for each <span class="math">r \\in \\mathbb{F}_q</span>,</p>

    <div class="my-4 text-center"><span class="math-block">d((U_r)_i, C) \\leq d^m(U_r, C^m).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In particular, if <span class="math">r \\in R^*</span>, then <span class="math">d((U_r)_i, C) \\leq e</span>. Using our hypothesis $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\varepsilon<span class="math"> and our assumption whereby </span>C<span class="math"> itself features proximity gaps for affine lines, we conclude that there exist codewords </span>(V_0)_i<span class="math"> and </span>(V_1)_i<span class="math"> in </span>C<span class="math"> and a subset </span>D_i \\subset \\{0, \\dots, n-1\\}<span class="math"> such that, for each </span>j \\in \\{0, \\dots, n-1\\} \\setminus D_i<span class="math"> and each </span>b \\in \\{0, 1\\}<span class="math">, </span>((U_b)_i)_j = ((V_b)_i)_j<span class="math"> holds. Assembling the resulting such codewords </span>(V_0)_i<span class="math"> and </span>(V_1)_i<span class="math"> into matrices, we obtain interleaved codewords </span>V_0<span class="math"> and </span>V_1<span class="math"> in </span>C^m<span class="math">. For each </span>r \\in \\mathbb{F}_q<span class="math">, we define the affine line element </span>V_r<span class="math"> as we did </span>U_r<span class="math">; that is, we set </span>V_r := (1-r) \\cdot V_0 + r \\cdot V_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Concatenating the matrices <span class="math">U_{0}</span> and <span class="math">U_{1}</span>, as well as <span class="math">V_{0}</span> and <span class="math">V_{1}</span>, vertically, we define:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\qquad U \\qquad \\right] := \\left[ \\begin{array}{c} U _ {0} \\\\ \\hline U _ {1} \\end{array} \\right] \\text{ and } \\left[ \\qquad V \\qquad \\right] := \\left[ \\begin{array}{c} V _ {0} \\\\ \\hline V _ {1} \\end{array} \\right].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our task amounts to proving that <span class="math">D \\coloneqq \\Delta^{2 \\cdot m}(U, V)</span> satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e$. To do this, we engage in a counting argument. We define:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">R ^ {* *} := \\left\\{(r, j) \\in R ^ {*} \\times \\{0, \\dots , n - 1 \\} \\mid (U _ {r}) ^ {j} = (V _ {r}) ^ {j} \\right\\}.</span></div>

    <p class="text-gray-300">In other words, <span class="math">R^{**}</span> is the set of pairs, consisting of an affine line parameter <span class="math">r \\in R^*</span> and a column index <span class="math">j \\in \\{0, \\dots, n - 1\\}</span>, for which <span class="math">U_r</span>'s and <span class="math">V_r</span>'s respective <span class="math">j^{\\text{th}}</span> columns agree identically.</p>

    <p class="text-gray-300">We bound <span class="math">R^{**}</span> from both above and below. We prepare the way with the following basic lemma, which shows that <span class="math">U_r</span> can become close to <span class="math">C^m</span> only by becoming close to <span class="math">V_r</span>.</p>

    <p class="text-gray-300"><strong>Lemma 3.2.</strong> For each <span class="math">r \\in R^*</span>, <span class="math">d^{m}(U_{r}, V_{r}) \\leq e</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> This lemma follows almost immediately from the remarks made after Definition 2.1 above. By construction of the interleaved codewords <span class="math">V_{0}</span> and <span class="math">V_{1}</span>, for each individual row <span class="math">i \\in \\{0, \\dots, m - 1\\}</span>, <span class="math">d^{2}\\left((U_{b})_{i})_{b = 0}^{1}, ((V_{b})_{i})_{b = 0}^{1}\\right) \\leq e</span>. On the other hand, for each <span class="math">r \\in R^{<em>}</span>, by definition, some interleaved codeword <span class="math">V_{r}^{</em>}</span> satisfies <span class="math">d^{m}(U_{r}, V_{r}^{<em>}) \\leq e</span>, and in particular, for each <span class="math">i \\in \\{0, \\dots, m - 1\\}</span>, <span class="math">d((U_{r})_{i}, (V_{r}^{</em>})_{i}) \\leq e</span>. By the remarks made after Definition 2.1 (essentially by the triangle inequality and unique decoding), we conclude that, again for each <span class="math">i \\in \\{0, \\dots, m - 1\\}</span>, <span class="math">(V_{r})_{i} = (V_{r}^{<em>})_{i}</span>. We see finally that <span class="math">V_{r} = V_{r}^{</em>}</span> itself holds.</p>

    <p class="text-gray-300">We now establish two bounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.3.</strong> $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{**}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> For each <span class="math">j \\in D</span>, by definition of <span class="math">D</span>, either <span class="math">(U_0)^j \\neq (V_0)^j</span> holds or <span class="math">(U_1)^j \\neq (V_1)^j</span> holds (or both). It follows that at most one <span class="math">r \\in \\mathbb{F}_q</span>—and so a fortiori at most one <span class="math">r \\in R^<em></span>—can possibly cause <span class="math">(U_r)^j = (V_r)^j</span> to hold. Each <span class="math">j \\in D</span> thus contributes at most one element to <span class="math">R^{**}</span>. On the other hand, for each <span class="math">j \\in \\{0, \\dots, n-1\\} \\setminus D</span>, <span class="math">(U_0)^j = (V_0)^j</span> and <span class="math">(U_1)^j = (V_1)^j</span> both hold. We conclude that <span class="math">(U_r)^j = (V_r)^j</span> holds for each <span class="math">r</span> in <span class="math">R^</em> \\subset \\mathbb{F}_q</span>. Summing these conclusions over all <span class="math">j \\in \\{0, \\dots, n-1\\}</span>, we obtain the desired bound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.4.</strong> $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{**}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq (n - e) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> For each fixed <span class="math">r \\in R^<em></span>, applying Lemma 3.2, we obtain the inequality <span class="math">d^{m}(U_{r}, V_{r}) \\leq e</span>, which itself entails (by definition) that at least <span class="math">n - e</span> column indices <span class="math">j \\in \\{0, \\dots, n - 1\\}</span> satisfy <span class="math">(U_{r})^{j} = (V_{r})^{j}</span>. Adding up this bound over all parameters <span class="math">r \\in R^</em></span>, we obtain the desired bound $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{**}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (n - e)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Lemmas 3.3 and 3.4, we conclude that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(n - e) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (n -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">so that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">in turn holds, and finally that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e \\cdot \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} &lt; e + 1,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">so that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e<span class="math">. If </span>e = 0<span class="math">, the strict inequality above holds trivially. Otherwise, since </span>X \\mapsto \\frac{X}{X - 1}<span class="math"> is strictly decreasing for </span>X &gt; 1<span class="math">, and since by our hypothesis </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\varepsilon \\geq e + 1<span class="math">, we have </span>e \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} &lt; e \\cdot \\frac{e + 1}{e} = e + 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We depict the proof strategy of Theorem 3.1 in Figure 1 below.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A graphical depiction of the set  <span class="math">R^{**}</span>  of the proof of Theorem 3.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Figure 1, the shaded cells correspond to the set  <span class="math">R^{**}</span> . The proof of Lemma 3.3 shows that each column  <span class="math">j \\in D</span>  contains at most one shaded cell. The proof of Lemma 3.4 shows that each row  <span class="math">r \\in R^<em></span>  contains at least  <span class="math">n - e</span>  shaded cells. This latter guarantee implies that, for each  <span class="math">r \\in R^</em></span> , at least  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- e<span class="math">  of the cells within the index range  </span>j \\in D<span class="math">  are shaded. Multiplying this quantity by the number of rows  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , we obtain a total of at least  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- e)<span class="math">  shaded cells within the column band  </span>j \\in D<span class="math"> . If  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; e<span class="math">  held, then so too would  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- e) &gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (here, we use  </span>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- e} \\leq e + 1 &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ). Applying the pigeonhole principle, we would conclude that at least one column  </span>j \\in D$  featured at least two shaded cells, contradicting Lemma 3.3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 3.5. The restriction  <span class="math">\\varepsilon \\geq e + 1</span>  of Theorem 3.1's hypothesis appears essentially vacuous, with a caveat which we presently explain. Indeed, [DP24b, Rem. 2] shows that no code  <span class="math">C \\subset \\mathbb{F}_q^n</span>  can possibly exhibit proximity gaps with respect to  <span class="math">e</span>  and any false witness bound  <span class="math">\\varepsilon &amp;lt; e + 1</span> , at least provided that  <span class="math">e \\in \\{0, \\dots, \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor\\}</span> . In fact, that example goes through identically so long as  <span class="math">2 \\cdot e + 1 &amp;lt; d</span> , or in other words  <span class="math">e \\in \\{0, \\dots, \\left\\lfloor \\frac{d - 2}{2} \\right\\rfloor\\}</span> . The case in which  <span class="math">e = \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor</span>  and in which  <span class="math">\\left\\lfloor \\frac{d - 2}{2} \\right\\rfloor \\neq \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor</span> , which itself holds if and only if  <span class="math">d</span>  is odd—thus appears to be exceptional. (This setting reappears in Remark 4.2 below.) Indeed, we are not able to rule out the existence of an odd-distance code  <span class="math">C \\subset \\mathbb{F}_q^n</span>  which exhibits proximity gaps with respect to  <span class="math">e = \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor</span>  and some false witness bound  <span class="math">\\varepsilon &amp;lt; e + 1</span> , though we doubt strongly that such a code exists. In fact, as we argue in Remark 4.2 below, the special, high proximity parameter  <span class="math">e = \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor</span>  makes high-false-witness counterexamples easier to construct, and not harder (at least when  <span class="math">C \\subset \\mathbb{F}_q^n</span>  is MDS).</p>

    <p class="text-gray-300">The following result, due to Angeris, Evans and Roh [AER24], establishes that each code  <span class="math">C</span>  for which the conclusion of Theorem 3.1 holds also features tensor-style proximity gaps in the sense of Definition 2.3. The below result, taken jointly with our Theorem 3.1 above, serves to prove a statement almost identical to that of [DP24b, Thm. 2]; it differs from that theorem's statement solely in its elimination of that statement's false witness probability's factor of 2. The elimination of that factor was posed as an open problem in [DP24b, Rem. 3]. For self-containedness, we record their proof in full. We fix an  <span class="math">[n,k,d]</span> -code  <span class="math">C \\subset \\mathbb{F}_q^n</span>  over  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">Theorem 3.6 (Angeris-Evans-Roh [AER24]). If, for each  <span class="math">m \\geq 1</span> ,  <span class="math">C^m</span>  features proximity gaps for affine lines with respect to  <span class="math">e</span>  and  <span class="math">\\varepsilon</span> , then  <span class="math">C</span>  moreover features tensor-style proximity gaps with respect to  <span class="math">e</span>  and  <span class="math">\\varepsilon</span> .</p>

    <p class="text-gray-300">Proof. We prove the result by induction on  <span class="math">\\vartheta</span> . In the base case  <span class="math">\\vartheta = 1</span> , the theorem's statement is exactly that whereby  <span class="math">C</span>  features proximity gaps for affine lines with respect to  <span class="math">e</span>  and  <span class="math">\\varepsilon</span> . We turn to the case  <span class="math">\\vartheta &amp;gt; 1</span> .</p>

    <p class="text-gray-300">We fix a list of words  <span class="math">u_0, \\ldots, u_{2^{\\vartheta} - 1}</span>  in  <span class="math">\\mathbb{F}_q^n</span>  as in the hypothesis of Definition 2.3, and suppose that they fulfill the hypothesis of that definition. We write  <span class="math">U_0</span>  and  <span class="math">U_1</span>  for  <span class="math">(u_i)_{i=0}^{2^{\\vartheta} - 1}</span> 's lower and upper halves. We first note a variant of the recursive substructure given in [DP24b, Thm. 2]:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\vartheta - 1} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - - &amp;amp; u _ {0} &amp;amp; - - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - - &amp;amp; u _ {2 ^ {\\vartheta} - 1} &amp;amp; - - \\end{array} \\right] = \\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\vartheta - 2} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left(\\left[ (1 - r _ {\\vartheta - 1}) \\cdot U _ {0} \\right] + \\left[ r _ {\\vartheta - 1} \\cdot U _ {1} \\right]\\right).</span></div>

    <p class="text-gray-300">For each  <span class="math">r_{\\vartheta -1}\\in \\mathbb{F}_q</span>  , we abbreviate:</p>

    <div class="my-4 text-center"><span class="math-block">p (r _ {\\vartheta - 1}) := \\Pr_ {(r _ {0}, \\dots , r _ {\\vartheta - 2}) \\in \\mathbb {F} _ {q} ^ {\\vartheta - 1}} \\left[ d \\left(\\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\vartheta - 2} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ (1 - r _ {\\vartheta - 1}) \\cdot U _ {0} + r _ {\\vartheta - 1} \\cdot U _ {1} \\right], C\\right) \\leq e \\right].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we define  $R^{*} \\coloneqq \\left\\{r_{\\vartheta - 1} \\in \\mathbb{F}_{q} \\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p(r_{\\vartheta - 1}) &gt; (\\vartheta - 1) \\cdot \\frac{\\varepsilon}{q}\\right\\}<span class="math"> . We note that  </span>R^{<em>}<span class="math">  is precisely the set of parameters  </span>r_{\\vartheta - 1} \\in \\mathbb{F}_{q}<span class="math">  for which the half-length matrix  </span>(1 - r_{\\vartheta - 1}) \\cdot U_{0} + r_{\\vartheta - 1} \\cdot U_{1}<span class="math">  fulfills the inductive hypothesis (that is, the hypothesis of Definition 2.3, with respect to the smaller list size parameter  </span>\\vartheta - 1<span class="math"> ). Applying this theorem inductively to each such matrix, we conclude that, for each  </span>r_{\\vartheta - 1} \\in R^{</em>}$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">d ^ {2 ^ {\\vartheta - 1}} \\left(\\left(1 - r _ {\\vartheta - 1}\\right) \\cdot U _ {0} + r _ {\\vartheta - 1} \\cdot U _ {1}, C ^ {2 ^ {\\vartheta - 1}}\\right) \\leq e.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the other hand, the interleaved words of the form  <span class="math">(1 - r_{\\vartheta - 1}) \\cdot U_0 + r_{\\vartheta - 1} \\cdot U_1</span>  collectively yield an affine line in  <span class="math">\\mathbb{F}_q^{2^{\\vartheta - 1} \\times n}</span> . To prove this theorem, it's enough to show that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\varepsilon<span class="math"> ; indeed, that inequality would make our hypothesis on  </span>C<span class="math"> —i.e., whereby  </span>C^{2^{\\vartheta - 1}}<span class="math">  features proximity gaps for affine lines with respect to  </span>e<span class="math">  and  </span>\\varepsilon<span class="math"> —applicable to the line  </span>(1 - r_{\\vartheta - 1}) \\cdot U_0 + r_{\\vartheta - 1} \\cdot U_1<span class="math"> , implying our desired conclusion  </span>d^{2^{\\vartheta}}\\left((u_i)_{i=0}^{2^{\\vartheta} - 1}, C^{2^{\\vartheta}}\\right) \\leq e$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We invoke the following probability decomposition, which evokes [DP24b, Lem. 2] (though it proceeds in the "opposite direction"):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\vartheta \\cdot \\frac {\\varepsilon}{q} &amp;lt;   \\operatorname * {P r} _ {(r _ {0}, \\dots , r _ {\\vartheta - 1}) \\in \\mathbb {F} _ {q} ^ {\\vartheta}} \\left[ d \\left(\\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\vartheta - 1} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - - &amp;amp; u _ {0} &amp;amp; - - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - - &amp;amp; u _ {2 ^ {\\vartheta} - 1} &amp;amp; - - \\end{array} \\right], C\\right) \\leq e \\right] \\\\ = \\operatorname * {P r} _ {(r _ {0}, \\dots , r _ {\\vartheta - 1}) \\in \\mathbb {F} _ {q} ^ {\\vartheta}} \\left[ d \\left(\\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\vartheta - 2} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ (1 - r _ {\\vartheta - 1}) \\cdot U _ {0} + r _ {\\vartheta - 1} \\cdot U _ {1} \\right], C\\right) \\leq e \\right] \\\\ \\leq (\\vartheta - 1) \\cdot \\frac {\\varepsilon}{q} + \\Pr_ {r _ {\\vartheta - 1} \\in \\mathbb {F} _ {q}} [ r _ {\\vartheta - 1} \\in R ^ {*} ]. \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first step above is simply the hypothesis of the theorem. The second amounts to the recursive substructure already described above. To achieve the final step, we slice the space  <span class="math">\\mathbb{F}_q^\\vartheta</span>  along its last coordinate  <span class="math">r_{\\vartheta -1}</span> . For each slice  <span class="math">r_{\\vartheta -1} \\in \\mathbb{F}_q</span> , we upper-bound the proportion of elements  <span class="math">(r_0,\\ldots ,r_{\\vartheta -2}) \\in \\mathbb{F}_q^{\\vartheta -1}</span>  for which  <span class="math">d\\Big(\\bigotimes_{i = 0}^{\\vartheta -2}(1 - r_i,r_i)\\cdot \\big[(1 - r_{\\vartheta -1})\\cdot U_0 + r_{\\vartheta -1}\\cdot U_1\\big],C\\Big) \\leq e</span>  holds, either trivially by 1 (if  <span class="math">r_{\\vartheta -1} \\in R^{<em>}</span> ) or else by  <span class="math">(\\vartheta -1) \\cdot \\frac{\\varepsilon}{q}</span>  (if  <span class="math">r_{\\vartheta -1} \\notin R^{</em>}</span> ). By subtraction, this calculation implies that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\varepsilon$ , and finishes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Corollary 3.7. For each  <span class="math">e \\in \\{0, \\dots, \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor\\}</span> ,  <span class="math">\\mathsf{RS}_{\\mathbb{F}_q, S}[k, n]</span>  features tensor-style proximity gaps with respect to  <span class="math">e</span>  and  <span class="math">\\varepsilon \\coloneqq n</span> .</p>

    <p class="text-gray-300">Proof. This corollary is a combination of Theorems 2.2, 3.1 and 3.6; we note that  <span class="math">n \\geq e + 1</span> .</p>

    <p class="text-gray-300">Remark 3.8. Before [DP24b, Thm. 2] and this work, the only known proximity gaps were those for affine subspaces [Ben+23, Thm. 1.6] and for low-degree curves [Ben+23, Thm. 1.5]. All known interpolations between these results were "linear". For example, to combine the length- <span class="math">2^{\\vartheta}</span>  list  <span class="math">(u_i)_{i=0}^{2^{\\vartheta}-1}</span>  using two random challenges  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> , say, one would have taken the combination</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c c c c} 1 &amp;amp; \\alpha &amp;amp; \\dots &amp;amp; \\alpha^ {2 ^ {\\vartheta - 1}} &amp;amp; \\beta &amp;amp; \\dots &amp;amp; \\beta^ {2 ^ {\\vartheta - 1} - 1} \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; u _ {0} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; u _ {2 ^ {\\vartheta} - 1} &amp;amp; - \\end{array} \\right],</span></div>

    <p class="text-gray-300">attaining thereby the false witness probability  <span class="math">2^{\\vartheta - 1} \\cdot \\frac{\\varepsilon}{q}</span> . Theorem 3.6 suggests that this common wisdom is mistaken. To combine  <span class="math">(u_i)_{i=0}^{2^{\\vartheta} - 1}</span>  using  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> , one should rather take the combination:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} (1, \\alpha , \\ldots , \\alpha^ {2 ^ {\\vartheta / 2} - 1}) \\otimes (1, \\beta , \\ldots , \\beta^ {2 ^ {\\vartheta / 2} - 1}) \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; u _ {0} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; u _ {2 ^ {\\vartheta} - 1} &amp;amp; - \\end{array} \\right],</span></div>

    <p class="text-gray-300">obtaining thereby the far-better false witness probability  <span class="math">2 \\cdot (2^{\\vartheta / 2} - 1) \\cdot \\frac{\\varepsilon}{q}</span>  (here, we assume that  <span class="math">\\vartheta</span>  is even). More generally, by sampling  <span class="math">k</span>  random values, one can attain a false witness probability proportional not to  <span class="math">\\left(\\frac{2^{\\vartheta}}{k} - 1\\right) \\cdot \\frac{\\varepsilon}{q}</span>  but rather to  <span class="math">k \\cdot (2^{\\vartheta / k} - 1) \\cdot \\frac{\\varepsilon}{q}</span> , which is much better. We see that the best possible false witness bound shrinks not linearly, but rather like a power law, in the number of challenges available. We note, on the other hand, that this work's tensor-style proximity gap result (like that of [DP24b, Thm. 2]) is presently known only to hold within the unique decoding radius; appropriate variants of [Ben+23, Thm. 1.5] and [Ben+23, Thm. 1.6] hold even in the list-decoding regime.</p>

    <p class="text-gray-300">In this section, we amend the conjecture [DP24b, Conj. 1], which is false as written. That conjecture claims that for each linear  <span class="math">[n,k,d]</span> -code  <span class="math">C\\subset \\mathbb{F}_q^n</span>  and each proximity parameter  <span class="math">e\\in \\{0,\\ldots ,\\left\\lfloor \\frac{d - 1}{2}\\right\\rfloor \\}</span> ,  <span class="math">C</span>  features proximity gaps for affine lines with respect to  <span class="math">e</span>  and  <span class="math">\\varepsilon \\coloneqq e + 1</span> . In Example 4.1 below, we disprove [DP24b, Conj. 1], by exhibiting a field  <span class="math">\\mathbb{F}_q</span> , an  <span class="math">[n,k,d]</span> -code  <span class="math">C\\subset \\mathbb{F}_q^n</span>  (in fact,  <span class="math">C</span>  is Reed-Solomon), and words  <span class="math">u_{0}</span>  and  <span class="math">u_{1}</span>  in  <span class="math">\\mathbb{F}_q^n</span>  for which, for  <span class="math">e\\coloneqq \\left\\lfloor \\frac{d - 1}{2}\\right\\rfloor</span> , though  <span class="math">d^{2}\\Big((u_{i})_{i = 0}^{1},C^{2}\\Big) &amp;gt; e</span> ,  <span class="math">\\operatorname*{Pr}_{r\\in \\mathbb{F}_q}[d((1 - r)\\cdot u_0 + r\\cdot u_1,C)\\leq e] = \\frac{n}{q}</span>  nonetheless holds. Example 4.1 shows that—if [DP24b, Conj. 1] is to have any hope of being true—that conjecture's false witness bound must be increased from  <span class="math">e + 1</span>  to  <span class="math">n</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Example 4.1. We fix an even integer  <span class="math">n \\geq 2</span> , a prime power  <span class="math">q \\geq n</span> , and a subset  <span class="math">S \\subset \\mathbb{F}_q</span>  of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math"> . We set  </span>k \\coloneqq 2<span class="math"> , and fix the Reed-Solomon code  </span>C \\coloneqq \\mathsf{RS}_{\\mathbb{F}_q, S}[2, n]<span class="math">  consisting of the evaluations of polynomials of degree at most 1 on  </span>S \\subset \\mathbb{F}_q<span class="math"> . The distance of  </span>C<span class="math">  is  </span>d = n - 2 + 1 = n - 1<span class="math"> ; we fix  </span>e \\coloneqq \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor = \\frac{n}{2} - 1<span class="math"> . We slightly abuse notation by identifying  </span>S = \\{0, \\dots, n - 1\\}<span class="math">  with a set of integers (really, we should write  </span>S = \\{s_0, \\dots, s_{n-1}\\}<span class="math"> ). We define words  </span>u_0<span class="math">  and  </span>u_1<span class="math">  in  </span>\\mathbb{F}_q^n<span class="math">  as in Figure 2 below. We see immediately that  </span>d(u_0, 0) \\leq e<span class="math">  and  </span>d(u_1, 0) \\leq e<span class="math"> ; moreover,  </span>\\Delta(u_0, 0)<span class="math">  and  </span>\\Delta(u_1, 0)<span class="math">  are disjoint. In particular, we note that  </span>d^2((u_i)_{i=0}^1, C^2) &gt; e<span class="math">  holds. (Indeed, if  </span>d^2((u_i)_{i=0}^1, (v_i)_{i=0}^1) \\leq e<span class="math">  held, then  </span>v_0 = 0<span class="math">  and  </span>v_1 = 0<span class="math">  too would; we would conclude that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_0, 0) \\cup \\Delta(u_1, 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e<span class="math"> , an absurdity.) On the other hand, we claim that  </span>R^* := \\{r \\in \\mathbb{F}_q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d((1 - r) \\cdot u_0 + r \\cdot u_1, C) \\leq e\\}<span class="math">  is such that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math"> . We have already seen that  </span>\\{0, 1\\} \\subset R^<em><span class="math"> . We write  </span>v_0^</em><span class="math">  for the encoding of the degree-1 polynomial  </span>X \\mapsto X<span class="math">  and  </span>v_1^*<span class="math">  for the encoding of  </span>X \\mapsto 1 - X$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: A depiction of the affine line of Example 4.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each <span class="math">j\\in\\{2,\\ldots,n-1\\}</span>, we note that, by setting <span class="math">r\\coloneqq j</span>, we obtain <span class="math">(1-r)\\cdot j=r\\cdot(1-j)</span>. In particular, for each <span class="math">j\\in\\{2,\\ldots,e+1\\}</span>, we have <span class="math">d(u_{j},j\\cdot v_{1}^{<em>})=e</span> (indeed, <span class="math">\\Delta(u_{j},j\\cdot v_{1}^{</em>})=\\{0,2,\\ldots,j-1,j+1,\\ldots,e+1\\}</span>). We see that <span class="math">\\{2,\\ldots,e+1\\}\\subset R^{<em>}</span>. On the other hand, for each <span class="math">j\\in\\{e+2,\\ldots,n-1\\}</span>, <span class="math">d(u_{j},(1-j)\\cdot v_{0}^{</em>})=e</span> (indeed, <span class="math">\\Delta(u_{j},(1-j)\\cdot v_{0}^{<em>})=\\{1,e+2,\\ldots,j-1,j+1,\\ldots,n-1\\}</span>). We see similarly that <span class="math">\\{e+2,\\ldots,n-1\\}\\subset R^{</em>}</span>. We conclude finally that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{0,\\ldots,n-1\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Example 4.1 shows that the false witness bound <span class="math">\\varepsilon=n</span> of <em>[x1, Thm. 4.1]</em> is the best possible (i.e., it cannot be decreased). Indeed, it is observed in Ben-Sasson et al. <em>[x1, Rem. 1.1]</em> that the equality $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=e+1<span class="math"> is attainable (we refer also to <em>[x11, Rem. 2]</em> for a further treatment of that example). The theorem <em>[x1, Thm. 4.1]</em> and the example <em>[x1, Rem. 1.1]</em>, taken together, thus show merely that the best possible false witness bound for Reed–Solomon codes lies <em>somewhere</em> in the range </span>\\{e+1,\\ldots,n\\}<span class="math">. Our Example 4.1 “improves” the example <em>[x1, Rem. 1.1]</em>, by producing a line whose false witness count is </span>n<span class="math">. We see that the best possible bound is </span>n$ itself.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 4.2.</h6>

    <p class="text-gray-300">We note that a construction analogous to that of Example 4.1 serves moreover to show that for each MDS code <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> of odd distance, and for <span class="math">e=\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor</span>, there exist words <span class="math">u_{0}</span> and <span class="math">u_{1}</span> in <span class="math">\\mathbb{F}_{q}^{n}</span> for which, though <span class="math">d^{2}\\big{(}(u_{i})_{i=0}^{1},C^{2}\\big{)}&gt;e</span>, <span class="math">\\Pr_{r\\in\\mathbb{F}_{q}}[d((1-r)\\cdot u_{0}+r\\cdot u_{1},C)\\leq e]=\\frac{2\\cdot e+2}{q}</span> nonetheless holds, at least heuristically (that is, assuming that certain columns <span class="math">j\\in\\{0,\\ldots,n-1\\}</span> contribute <em>distinct</em> points to <span class="math">R^{*}</span>).</p>

    <p class="text-gray-300">Below, we amend the conjecture <em>[x10, Conj. 1]</em>. We fix an <em>arbitrary</em> linear <span class="math">[n,k,d]</span>-code <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Conjecture 4.3.</h6>

    <p class="text-gray-300">We wonder whether, for each proximity parameter <span class="math">e\\in\\left\\{0,\\ldots,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right\\}</span>, <span class="math">C</span> features proximity gaps for affine lines with respect to <span class="math">e</span> and the false witness bound <span class="math">\\varepsilon\\coloneqq n</span>.</p>

    <p class="text-gray-300">As far as we are aware, Conjecture 4.3 remains wide-open.</p>

    <h2 id="sec-13" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AER24] Guillermo Angeris, Alex Evans, and Gyumin Roh. <em>A Note on Ligero and Logarithmic Randomness</em>. Cryptology ePrint Archive, Paper 2024/1399. 2024. url: https://eprint.iacr.org/2024/1399.</li>

      <li>[AHIV23] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: lightweight sublinear arguments without a trusted setup”. In: <em>Designs, Codes and Cryptography</em> (2023). doi: 10.1007/s10623-023-01222-8.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Fast Reed–Solomon Interactive Oracle Proofs of Proximity”. In: <em>International Colloquium on Automata, Languages, and Programming</em>. Ed. by Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella. Vol. 107. Leibniz International Proceedings in Informatics. Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2018, 14:1–14:17. doi: 10.4230/LIPIcs.ICALP.2018.14.</li>

      <li>[Ben+23] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. “Proximity Gaps for Reed–Solomon Codes”. In: <em>Journal of the ACM</em> 70.5 (Oct. 2023). doi: 10.1145/3614423.</li>

      <li>[DP24a] Benjamin E. Diamond and Jim Posen. <em>Polylogarithmic Proofs for Multilinears over Binary Towers</em>. Cryptology ePrint Archive, Paper 2024/504. 2024. url: https://eprint.iacr.org/2024/504.</li>

      <li>[DP24b] Benjamin E. Diamond and Jim Posen. “Proximity Testing with Logarithmic Randomness”. In: <em>IACR Communications in Cryptology</em> 1.1 (2024). issn: 3006-5496. doi: 10.62056/aksdkp10.</li>

      <li>[Gol+23] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad S. Wahby. “Brakedown: Linear-Time and Field-Agnostic SNARKs for R1CS”. In: <em>Advances in Cryptology – CRYPTO 2023</em>. Ed. by Helena Handschuh and Anna Lysyanskaya. Cham: Springer Nature Switzerland, 2023, pp. 193–226. doi: 10.1007/978-3-031-38545-2_7.</li>

      <li>[Gur06] Venkatesan Guruswami. <em>Algorithmic Results in List Decoding</em>. Vol. 2. Foundations and Trends in Theoretical Computer Science 2. now publishers, 2006. doi: 10.1561/0400000007.</li>

    </ul>

    <p class="text-gray-300">-</p>`;
---

<BaseLayout title="Proximity Gaps in Interleaved Codes (2024/1351)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1351
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
