---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/705';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Linear-map Vector Commitments and their Practical Applications';
const AUTHORS_HTML = 'Matteo Campanelli, Anca Nitulescu, Carla Ràfols, Alexandros Zacharakis, Arantxa Zapico';

const CONTENT = `    <p class="text-gray-300">Matteo Campanelli¹, Anca Nitulescu¹, Carla Ràfols², Alexandros Zacharakis², and Arantxa Zapico²*.</p>

    <p class="text-gray-300">¹ Protocol Labs {matteo, anca}@protocol.ai ² Universitat Pompeu Fabra {carla.rafols, alexandros.zacharakis, arantxa.zapico}@upf.edu</p>

    <p class="text-gray-300">Abstract. Vector commitments (VC) are a cryptographic primitive that allows one to commit to a vector and then "open" some of its positions efficiently. Vector commitments are increasingly recognized as a central tool to scale highly decentralized networks of large size and whose content is dynamic. In this work, we examine the demands on the properties that a vector commitment should satisfy in the light of the emerging plethora of practical applications and propose new constructions that improve the state-of-the-art in several dimensions and offer new tradeoffs. We also propose a unifying framework that captures several constructions and we show how to generically achieve some properties from more basic ones. On the practical side, we focus on building efficient schemes that do not require a new trusted setup (we can reuse existing ceremonies for other pairing-based schemes, such as "powers of tau" run by real-world systems such as Zcash or Filecoin). Our implementation demonstrates that our work overperforms in efficiency prior schemes with the same properties.</p>

    <p class="text-gray-300">Our contributions can be summarized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Theoretical Formalisation: We formally define the notion of Linear Map Vector Commitments (LVC) inspired by the work of Lai and Malavolta [CRYPTO19]. Our definition aims at recovering all previous notions of VC and include properties such as updatability, aggregation and homomorphism. We introduce a stronger new unbounded aggregation concept that allows to aggregate multiple times without a disaggregation procedure. This relaxes incremental aggregation which is hard to achieve in general.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Black-box Frameworks for LVC: We show how to lift the homomorphic properties of a simple LVC in order to obtain an LVC with unbounded aggregation and/or updatability. We also show that we can construct generic LVC (i.e. for any <span class="math">f: \\mathbb{F}^m \\to \\mathbb{F}^n</span>) from homomorphic LVC for a more restricted class of openings, inner-products IP (for <span class="math">n = 1</span>).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VC Constructions: We show two pairing-based LVC constructions for inner products IP based on the properties of monomial and Lagrange polynomial basis. We prove that the two satisfy all the relevant homomorphic properties to obtain unbounded aggregation and transformation to LVC. We also extend such schemes to support subvector openings SVC in a native way for special subsets or via aggregation for generic subsets.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adding Maintainability: We present two novel maintainable VC constructions that can be instantiated from any underlying VC scheme with homomorphic proofs. We show how to achieve a stronger, more flexible form of maintainability: our schemes allow to arbitrary tune the memory used to save on the opening time to obtain the desired trade-off. Both constructions are based on the tensor structure of multivariate and univariate polynomials:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The multivariate case is a generalisation of a recent work, Hyperproofs that uses binary trees: we allow for any arity for the trees, so proofs are shorter and the leaves can be commitments for any LVC scheme, to allow more expressivity.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The univariate construction generalizes in a similar way a previous construction of Tomescu et al. and it has the additional feature that the setup is independent of the trade-off, so the memory used can be decided by the prover on the fly.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Arantxa Zapico has been funded by a Protocol Labs PhD Fellowship PL-RGP1-2021-062. Alexandros Zacharakis has been partially funded by Protocol Labs Research Grant PL-RGP1-2021-048</li>

    </ul>

    <p class="text-gray-300">Linear-map Vector Commitments and their Practical Applications 1 Matteo Campanelli¹, Anca Nitulescu¹, Carla Ràfols², Alexandros Zacharakis², and Arantxa Zapico²³. 1 Introduction 2 1.1 Motivation for Better Vector Commitments 3 1.2 Desired Properties and Limitations 4 1.3 Our Contributions 4 1.4 Related Work 6 2 Preliminaries 7 3 Definitions: Linear-map Vector Commitments 8 3.1 Homomorphic Properties for LVC 9 4 Generic Constructions from Homomorphic Proofs 9 4.1 New Notion: Unbounded Aggregation 9 4.2 Unbounded Aggregation for LVC 11 4.3 From Inner-Products to Arbitrary Linear-Maps 12 4.4 Updability for LVC 13 5 Constructions for Inner-Pairing VC 14 5.1 Monomial Basis 14 5.2 Lagrange Basis 16 6 Subvector Openings 18 6.1 Native SV Openings for the Monomial Basis 18 6.2 Non-native SV Openings for the Monomial Basis 19 6.3 Lagrange Basis 19 7 Implementation and Experimental Evaluation for LVC 20 7.1 Comparison with SNARKs over Merkle Trees 20 7.2 Proving time for Range Queries 21 7.3 Verification for Special Subsets 21 8 Maintainable Vector Commitment Schemes 22 8.1 Multivariate Case 22 8.2 Univariate Maintainable Vector Commitments 29 A Vector Commitment Definitions 34 B Vector Commitment Applications 35 B.1 Verifiable Databases 35 B.2 Stateless Cryptocurrency 36 B.3 Proof of Space 36 B.4 Compiling SNARKs from Vector Commitments 37 B.5 Applications of Range Openings 38 C Native SVC in [33] 38 D Lagrange basis IP for Cosets of Roots of Unity 38 D.1 Proof of Theorem 9 38</p>

    <p class="text-gray-300">Vector commitment schemes [26, 10] (or VC) allow a party to commit to a vector <span class="math">\\mathbf{v}</span> through a short digest and then open some of its elements guaranteeing position binding⁴ (one should not be able to open a commitment at position <span class="math">i</span> to two different values <span class="math">v_i \\neq v_i&#x27;</span>). For this primitive to be interesting the proof of opening—or just "opening"—should be of size sublinear in <span class="math">m</span>, the size of the committed vector. A vector commitment with subvector opening also supports a short opening for arbitrary subsets of positions <span class="math">I</span></p>

    <p class="text-gray-300">⁴ For the applications considered in this work, hiding properties are not necessary. In particular, our commitments are deterministic.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(rather than individual ones only). More specifically this opening should be of size independent, not only of <span class="math">m</span>, but of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. We denote commitment schemes with such property as SVC <em>[24]</em>(also called VC with batch opening in <em>[5]</em>).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Functional Vector Commitments, first introduced by Libert, Ramanna and Yung in <em>[25]</em>, capture the ability to compute commitments to vectors and later perform openings of linear functions (inner-products) <span class="math">f:\\mathbb{F}^{m}\\rightarrow\\mathbb{F}^{n}</span> of these vectors, for some field <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Both vector commitments with subvector openings and functional commitments for inner-products can be captured as vector commitments with openings for a more general class of function families, linear maps. Lai and Malavolta <em>[24]</em> were the first to introduce Linear Map Commitments (LMC). In such a scheme, the prover is able to open the commitment to some vector <span class="math">\\mathbf{v}</span> to the output of multiple linear functions or, equivalently, to the output of one linear-map <span class="math">f:\\mathbb{F}^{m}\\rightarrow\\mathbb{F}^{n}</span>, by producing a single short proof. In this work, we revisit Lai and Malavolta <em>[24]</em> LMC notion and augment it to a full-featured vector commitment generic definition that recovers all previously-defined schemes and more. We call our primitive Linear Map Vector Commitment and use LVC for short.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Motivation for Better Vector Commitments</h3>

    <p class="text-gray-300">Vector commitments are very useful to scale highly decentralized networks of large size and whose content is dynamic <em>[11, 5, 8, 18]</em>(such dynamic content can be the state of a blockchain, amount stored on a wallet, the value of a file in a decentralized storage network, etc.). Beyond the basic requirement that openings should be efficient, in this work we also discuss how to achieve some additional properties of LVC. We discuss some of the most prominent applications of LVC to motivate and justify the importance of these properties in practice.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Verifiable Databases.</h4>

    <p class="text-gray-300">One of the applications that can be significantly improved by Vector Commitments is Verifiable Databases (VDB). In this setting, a client outsources the storage of a database to a server while keeping the ability to access and change some of its records, i.e. query functions of the data and update some of the data and ensure the server does not tamper with the data. Solutions using (binding) commitment schemes provide security but not efficiency in such a setting. A popular instantiation that achieves both of them is a Merkle tree <em>[27]</em>, but this is not expressive enough to allow for functional openings.</p>

    <p class="text-gray-300">For a VC scheme to be the ideal solution for VDB application, we require it to additionally support efficient updates and expressive openings. For example, an LVC scheme that allows the client to update records of the database in sublinear time and to verify linear-map queries at almost the same cost as simple position openings is a great improvement over current solutions.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Stateless Cryptocurrency.</h4>

    <p class="text-gray-300">A recent application that motivated more efficient constructions of VC schemes is <em>stateless cryptocurrency</em>, i.e. a payment system based on a distributed ledger where neither validators of transactions nor system users need to store the full ledger state. The ideal vector commitment scheme that provides the best trade-off between storage, bandwidth, and computation in this setting should have all of the following properties: it must have a small commitment size, short proofs, efficient computation for openings and it should allow for proof updates and for aggregation to minimise communication in the transactions and <em>maintainability</em> for the proofs, that allows updating all pre-stored proofs in sublinear time.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Proof of Space.</h4>

    <p class="text-gray-300">Proof of Space (PoS) is a protocol that allows miners (storage providers) to convince the network that they are dedicating physical storage over time in an efficient way. In a nutshell, a miner commits to a file (data) that uses a specified amount of disk space and then the miner proves that it continues to store the data by answering to recurring audits that consist of random spot-checks. A PoS construction based on vector commitments, as described in <em>[15]</em>, requires short opening proofs for subvectors to be stored in a blockchain, cross-commitments aggregation techniques and the possibility to implement space-time tradeoffs to reduce the proving time for the miner (ideally sublinear in the size of the vector).</p>

    <p class="text-gray-300">“Caching” Optimizations. In some applications, e.g. when performing HTTP queries, clients use the so-called prefetching and receive from a server not only the values of interest but other related values that could potentially be queried in the near future (e.g., values in a neighboring range of the queried values). Vector commitments with efficient proofs for special (“caching”) subset openings allow to add verifiability to such queries in a way that does not affect the speed of the server since the proving procedure for a bigger subset is close or the same as for individual positions.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.2 Desired Properties and Limitations</h3>

    <p class="text-gray-300">At the very least a basic LVC should be efficient (small proof size and low opening/verifying computational needs). Obviously, the same design goals as with other cryptographic protocols apply, i.e. ideally one would like to prove security under as standard assumptions as possible.</p>

    <p class="text-gray-300">Reusable setup refers to the common reference string that many pairing-based schemes use as public parameters. Ideally, one would like to have a transparent setup (consisting of uniformly distributed elements) that does not rely on any trusted parameter generation. It is common to sacrifice this goal for efficiency and settle for a trusted setup (producing a SRS, or structured reference string) that can be generated in a ceremony. But such ceremonies are complicated to implement, so it is interesting to design LVC that do not have special SRS distributions and can reuse existing setups for other primitives.</p>

    <p class="text-gray-300">Expressivity refers to the opening possibilities. One would like VC to be as expressive as possible, meaning that it should be possible to open to functions of the vector as general as possible (subvector openings, linear or arbitrary functions).</p>

    <p class="text-gray-300">Proof Aggregation captures the ability to “pack” two or more proofs together obtaining a new proof for their combined claims (e.g. <span class="math">\\mathbf{f}(\\mathbf{v})=y</span> and <span class="math">\\mathbf{f}^{\\prime}(\\mathbf{v})=y^{\\prime}</span>). This should be done without knowledge of the opening of the vector and aggregation cost should be sublinear in the vector length. Importantly, the resulting proof should not significantly grow each time we perform an aggregation. One-hop aggregation allows only to aggregate fresh proofs. Ideally, one would also want to aggregate already aggregated proofs.</p>

    <p class="text-gray-300">Updatability allows to efficiently update opening proofs: if <span class="math">\\mathsf{C}</span> is a commitment to <span class="math">\\mathbf{v}</span> and a position needs to be updated resulting in a new commitment <span class="math">\\mathsf{C}^{\\prime}</span>, an updatable VC must provide a method to update an opening <span class="math">\\pi_{f}</span> for a function <span class="math">f</span> that is valid for <span class="math">\\mathsf{C}</span> into a new opening for the same function that is valid for the new commitment <span class="math">\\mathsf{C}^{\\prime}</span>. The new opening should be computed by only knowing the portion of the vector that is supposed to change and in time faster than recomputing the opening from scratch.</p>

    <p class="text-gray-300">Maintainability aims at amortizing the proving costs in systems where committed values have a long life span and evolve over time. This is achieved by means of dedicated memory to reduce the computation time needed to open proofs. Concretely, the property requires that (1) one can efficiently store some values to reduce the cost of computing any individual openings (2) after updating a single position of the committed vector, it should be possible to update all proofs in time sublinear in the size of the vector (less than computing a single proof from scratch in some cases).</p>

    <p class="text-gray-300">Homomorphic properties apply to commitments as well as to proofs. An LVC has homomorphic commitments if it is possible to meaningfully combine commitments without knowing their openings: that is, from commitments <span class="math">\\mathsf{C}_{1}</span> and <span class="math">\\mathsf{C}_{2}</span> to <span class="math">\\mathbf{v}_{1}</span> and <span class="math">\\mathbf{v}_{2}</span>, any party must be able to compute a commitment to <span class="math">\\alpha\\mathbf{v}_{1}+\\beta\\mathbf{v}_{2}</span> for any <span class="math">\\alpha,\\beta\\in\\mathbb{F}</span>. The scheme has homomorphic openings if it is possible to derive a proof that <span class="math">f(\\mathbf{v}_{1}+\\mathbf{v}_{2})=\\mathbf{y}_{1}+\\mathbf{y}_{2}</span> from proofs for the claims <span class="math">f(\\mathbf{v}_{1})=\\mathbf{y}_{1}</span> and <span class="math">f(\\mathbf{v}_{2})=\\mathbf{y}_{2}</span>. Finally, a vector commitment scheme has homomorphic proofs when it is possible to combine proofs of statements for different functions but same vector. As we will see, this property is interesting for its implications.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.3 Our Contributions</h3>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Theoretical Advances.</h4>

    <p class="text-gray-300">On the theoretical frontier, we unify previous definitions and augment them with additional properties. The basic notion we use is Linear Map Vector Commitments (LVC) and is inspired by the work of Lai and Malavolta <em>[24]</em>. We then define additional properties on top of this definition and explore their relations. Specifically, we augment this notion with updatability and aggregation properties,</p>

    <p class="text-gray-300">VC Scheme Setup Aggregation Updates Assumption Functional Special Sets Opening (size  <span class="math">n</span> )</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoS aggSVC [8]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Trusted*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Incremental Same-Com*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hint*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SVC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(n)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pointproofs [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">Trusted</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop Cross-Com</td>

            <td class="px-3 py-2 border-b border-gray-700">key</td>

            <td class="px-3 py-2 border-b border-gray-700">pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Stateless aggSVC [33]</td>

            <td class="px-3 py-2 border-b border-gray-700">Trusted</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop Same-Com</td>

            <td class="px-3 py-2 border-b border-gray-700">key</td>

            <td class="px-3 py-2 border-b border-gray-700">pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">SVC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our Lagrange LVC</td>

            <td class="px-3 py-2 border-b border-gray-700">Reusable</td>

            <td class="px-3 py-2 border-b border-gray-700">UnboundedCross-Com</td>

            <td class="px-3 py-2 border-b border-gray-700">key</td>

            <td class="px-3 py-2 border-b border-gray-700">AGM</td>

            <td class="px-3 py-2 border-b border-gray-700">LVC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our Monomial LVC</td>

            <td class="px-3 py-2 border-b border-gray-700">Reusable</td>

            <td class="px-3 py-2 border-b border-gray-700">UnboundedCross-Com</td>

            <td class="px-3 py-2 border-b border-gray-700">key</td>

            <td class="px-3 py-2 border-b border-gray-700">AGM</td>

            <td class="px-3 py-2 border-b border-gray-700">LVC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of our LVCs with other aggregatable VC schemes (aggSVC) designed for Stateless Cryptocurrencies and Proof of Space applications. All schemes have  <span class="math">O(1)</span> -sized proofs that verify in  <span class="math">O(1)</span>  time and can update commitments in  <span class="math">O(1)</span>  time.</p>

    <p class="text-gray-300"><span class="math">(^{*})</span> : additional notes on [8]: their construction can be instantiated transparently (but less efficiently) replacing RSA-like assumptions with class groups; hint-based updates in their second construction are to maintain a constant-size  <span class="math">O(1)</span>  CRS; key-based updates are possible with a larger CRS; the work in [?] shows how to cross-commitment aggregate in [8].</p>

    <p class="text-gray-300">including a novel notion -unbounded aggregation- capturing the ability to aggregate already aggregated proofs but relaxing incremental aggregation [8] in the sense that the verifier is allowed to do work linear in the number of aggregation hops (i.e. aggregation is "history" dependent), also, disaggregation is not possible. We show that having additional homomorphic properties is highly desirable, by arguing that any LVC that satisfies them: (1) can be augmented with unbounded aggregation as well as updatability; (2) can support general linear map openings (i.e. for any  <span class="math">f: \\mathbb{F}^m \\to \\mathbb{F}^n</span> ) as long as it supports inner product openings (i.e. for  <span class="math">f&#x27;: \\mathbb{F}^m \\to \\mathbb{F}</span> ). This allows us to focus on efficient constructions for inner products with homomorphic properties.</p>

    <p class="text-gray-300">VC Constructions. First, we present two pairing-based LVC constructions for inner products based on the properties of monomial and Lagrange polynomial basis and prove that they satisfy all the relevant homomorphic properties to obtain unbounded aggregation and support general linear maps. In terms of expressivity, these constructions generalize previous work [32, 33] by supporting linear functions instead of only position or subvector openings. VC for this class of functions are core components of important primitives such as arguments of knowledge for Inner Product (IP) relations or aggregation arguments [12].</p>

    <p class="text-gray-300">Second, we present two novel maintainable constructions by exploiting the tensor structure of multivariate and univariate polynomials. These constructions allow a stronger, more flexible form of maintainability: they support an arbitrary memory/time trade-off for openings, meaning that one can decide how much memory it wants to use to reduce the opening time.</p>

    <p class="text-gray-300">The multivariate case is a generalization of Hyperproofs [32] in several dimensions. Roughly speaking maintainability is achieved in Hyperproofs by constructing a binary tree of proofs where at the leaves there are the values of individual positions. We present a single construction that can be instantiated in several ways (recovering Hyperproofs as a special case) with these features: (i) the tree can be of any arity, so proofs are shorter; (ii) the leaves can be commitments for any LVC and not only individual openings, to achieve a fully flexible trade-off. As a result of (ii), the scheme is more expressive (as it can support openings to linear functions/subvector openings at leaf level if the underlying commitment supports it).</p>

    <p class="text-gray-300">The univariate construction presents a similar generalization of previous work by [34] but it has the additional feature that the setup is independent of the trade-off, and can be decided by the prover on the fly.</p>

    <p class="text-gray-300">Practical Improvements. As in some applications like Proof of Space, the subset of opened positions is not very meaningful and its distribution is expected to be known in advance, we study how to improve verification efficiency for certain special subsets  <span class="math">I</span>  openings in our inner-product constructions. For some structured sets  <span class="math">I</span> , we achieve a verifier that performs half of the work it does for arbitrary sets  <span class="math">J</span>  of the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Homomorphic</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggregation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">OpenAll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UpdateAll</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Merkle Trees</td>

            <td class="px-3 py-2 border-b border-gray-700">Transparent</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">SNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">log m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k + log m')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyperproofs [32]</td>

            <td class="px-3 py-2 border-b border-gray-700">Trusted</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">IPP</td>

            <td class="px-3 py-2 border-b border-gray-700">log m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m')</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log m')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our Multivariate LVC</td>

            <td class="px-3 py-2 border-b border-gray-700">Trusted</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">IPP</td>

            <td class="px-3 py-2 border-b border-gray-700">logℓ m'</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m')</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log m')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our Univariate LVC</td>

            <td class="px-3 py-2 border-b border-gray-700">Reusable</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">IPP</td>

            <td class="px-3 py-2 border-b border-gray-700">log m'</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m')</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log m')</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Comparison of our schemes with other maintainable VC. We consider vectors of dimension  <span class="math">m = k \\cdot m&#x27;</span>  where  <span class="math">m&#x27;</span>  is the amount of memory dedicated for storing proofs. All schemes are aggregatable using generic techniques, SNARKs or Inner Pairing Products [7]. All times/sizes omit the dependence on the security parameter  <span class="math">\\lambda</span> . We omit constant additive terms from proof sizes. In the multivariate construction,  <span class="math">\\ell</span>  refers to a constant parameter.</p>

    <p class="text-gray-300">same size in the Lagrange construction, and only a constant number of group operations in the one that uses the monomial basis.</p>

    <p class="text-gray-300">Second, we mitigate the challenges of deploying these constructions due to their need of a trusted setup. With the exception of the multivariate variant of the maintainable construction, all our constructions can reuse trusted setups such as "powers of tau" that were run for pairing-based SNARK schemes used in real-world applications, as opposed to for example [18], in which a certain middle power of  <span class="math">\\tau</span>  needs to be missing in the SRS.</p>

    <p class="text-gray-300">In Appendix 7 we demonstrate the practical benefits of our special subset construction by providing an implementation and comparisons with current solutions.</p>

    <p class="text-gray-300">Vector commitments were fully formalized in [10] and two first constructions were proposed under standard, constant-size, assumptions: CDH in bilinear groups and RSA respectively. Many follow-up works built on these constructions to obtain better efficiency and more properties such as subvector openings, functional openings, aggregation, updates and variants of these. A number of constructions [8, 5] use the properties of hidden order groups to achieve constructions with attractive features such as constant size parameters or incremental aggregation but are concretely less efficient than pairing-based constructions.</p>

    <p class="text-gray-300">Merkle trees are quite efficient and only need a transparent setup. They also offer natural time-memory tradeoffs due to their tree structure. Nevertheless, VC schemes based on bilinear groups are more expressive in terms of openings, have homomorphic properties, allow for efficient updates for the proofs and aggregation mechanisms, so they are becoming an interesting alternative.</p>

    <p class="text-gray-300">Expressivity. VC were generalized by Libert et al. [25], who formalize the notion of functional commitments (FC). They construct vector commitments with openings to linear-forms of the vector based on the Diffie-Hellman exponent assumption over pairing groups. Later, Lai and Malavolta [24] introduce subvector openings and show applications to building succinct-arguments of knowledge (similar applications were shown by [5]) in the bilinear group setting. They also generalize the notion of SVCs to allow the prover to reveal arbitrary linear maps computed over the committed vector. Previously, only Functional VC for single-output linear functions were proposed which did not account for provers that want to reveal multiple locations or function outputs of the committed vector in a concise way.</p>

    <p class="text-gray-300">Updatability. Vector commitments that allow for updates are useful in applications such as stateless cryptocurrencies. A weak variant of updatability requires the algorithms that update the commitment and the opening to take as input an opening for the position in which the vector update occurs called hints. Recent RSA-based constructions are hint-updatable [5, 8]. Compared to hint updates, key-updates only need fixed update keys corresponding to the updated positions. Schemes based on bilinear groups require such fixed keys, and no extra information about the change made in the vector in order to update.</p>

    <p class="text-gray-300">Aggregation. Vector Commitments with an additional aggregation property are very appealing for blockchain applications for their even shorter proofs of opening. Campanelli et al. [8] showed two constructions of incrementally aggregatable SVCs, that have constant-size parameters and work over groups</p>

    <p class="text-gray-300">of unknown order. Unfortunately, the practical efficiency of these constructions is still not suffiecient for their deployment in real-world systems.</p>

    <p class="text-gray-300">Gorbunov et al. <em>[18]</em> show how to extend the VC scheme of <em>[26]</em> to allow for cross-commitment aggregation. Like our constructions, they assume the Algebraic Group Model (AGM) <em>[17]</em> in bilinear groups and a random oracle. Their final SVC requires public parameters whose size is linear in the size of the committed vector, while cross-commitment aggregation allow for splitting up a long vector into shorter ones and simply aggregate the proofs. However, this approach allows only for one-hop aggregation, meaning that already aggregated proofs cannot be reused in further aggregations by external nodes.</p>

    <p class="text-gray-300">Tomescu et al.<em>[33]</em> showed how to realize an <em>updatable</em> SVC with one-hop aggregation from bilinear groups. Their scheme has linear-sized public parameters, and it supports commitment updates, proof updates from a static linear-sized update key tied only to the updated position, in contrast with the dynamic update <em>hints</em> required by related works.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Maintainability</h4>

    <p class="text-gray-300">Apart from Merkle tree based Vector Commitments which are known to be maintainable, Srinivasan et. al. <em>[32]</em> show that the multilinear PST polynomial commitment <em>[29]</em> can be turned to a maintainable VC construction. Pre-computing all (single-position) opening proofs is done in quasilinear time (contrary to the trivial quadratic time) and updating all proofs after a (single position) vector update needs only logarithmic time. Contrary to Merkle tree based approaches, the scheme has <em>homomorphic</em> properties. Furthermore, due to its algebraic structure, it supports one-hop aggregation through generic means, namely, Inner Pairing Product Arguments <em>[7]</em>, albeit with a concretely expensive proving computation. Tomescu et al. <em>[34]</em> add the same attribute to KZG polynomial commitment schemes, resulting in an univariate construction with the same properties.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We denote the set of natural numbers by <span class="math">\\mathbb{N}</span> and let <span class="math">\\lambda\\in\\mathbb{N}</span> be the computational security parameter. We denote the list of integer numbers between <span class="math">1</span> and <span class="math">n</span> as <span class="math">[n]</span>. All the algorithms defined throughout this work are assumed to be probabilistic Turing machines that run in polynomial time (abbreviated as PPT). We say that a function is <em>negligible</em> (in <span class="math">\\lambda</span>), and we denote it by <span class="math">\\mathsf{negl}(\\lambda)</span>, if <span class="math">\\mathsf{negl}(\\lambda)=\\Omega(\\lambda^{-c})</span> for any fixed constant <span class="math">c&gt;1</span>.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Vectors</h4>

    <p class="text-gray-300">For <span class="math">m</span>-dimensional vectors <span class="math">\\mathbf{a}\\in\\mathbb{F}^{m}</span>, we denote the <span class="math">i</span>-th entry by <span class="math">a_{i}\\in\\mathbb{F}</span>. We use <span class="math">\\mathbf{e}_{i}\\in\\mathbb{F}^{m}</span> to denote the vectors of the canonical basis, more concretely <span class="math">\\mathbf{e}_{i}</span> is the vector with a <span class="math">1</span> in the <span class="math">i</span>-th coordinate and <span class="math">0</span>’s elsewhere. For vectors <span class="math">\\mathbf{a}\\in\\mathbb{F}^{m},\\mathbf{b}\\in\\mathbb{F}^{n}</span>, we denote <span class="math">\\mathbf{a}\\otimes\\mathbf{b}\\in\\mathbb{F}^{m\\cdot n}=(a_{1}\\mathbf{b},\\ldots,a_{n}\\mathbf{b})</span> the tensor product of the vectors.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Lagrange basis</h4>

    <p class="text-gray-300">Let <span class="math">\\mathbb{H}=\\{\\mathsf{h}_{1},\\ldots,\\mathsf{h}_{m}\\}</span> be a multiplicative group of size <span class="math">m</span> in <span class="math">\\mathbb{F}</span>. We consider the set of Lagrange interpolation polynomials <span class="math">\\{\\lambda_{j}(X)\\}_{j=1}^{m}</span> associated with <span class="math">\\mathbb{H}</span>, namely,</p>

    <p class="text-gray-300"><span class="math">\\lambda_{j}(X)=\\prod_{i\\neq j}\\frac{X-\\mathsf{h}_{i}}{\\mathsf{h}_{j}-\\mathsf{h}_{i}}.</span></p>

    <p class="text-gray-300">Recall that <span class="math">\\sum_{j=1}^{m}\\lambda_{j}(X)=1</span>. Moreover, we define <span class="math">t(X)=\\prod_{j=1}^{m}(X-\\mathsf{h}_{j})</span> the vanishing polynomial. We will also consider <span class="math">t_{k}(X)=\\prod_{j\\in J_{k}}(X-\\mathsf{h}_{j})</span>, the vanishing polynomial of a subset <span class="math">\\{\\mathsf{h}_{j}\\}_{j\\in J_{k}}\\subset\\mathbb{H}</span> and <span class="math">t_{k^{c}}(X)=\\prod_{j\\notin J_{k}}(X-\\mathsf{h}_{j})</span>.</p>

    <p class="text-gray-300">For the multivariate case, recall that <span class="math">\\lambda_{\\bm{\\sigma}}(X_{\\nu},\\ldots,X_{1})=\\prod_{j=1}^{\\nu}\\lambda_{\\sigma_{j}}(X_{j})</span>. Using these, we can write the vector of multivariate Lagrange as the tensor product <span class="math">\\bm{\\lambda}(X_{\\nu})\\otimes\\cdots\\otimes\\bm{\\lambda}(X_{1})</span>, where <span class="math">\\bm{\\lambda}(X)</span> is the univariate Lagrange basis.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Bilinear Groups</h4>

    <p class="text-gray-300">A bilinear group is given by a description <span class="math">\\,\\mathsf{gk}=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)</span> with additive notation such that <span class="math">p</span> is prime, so <span class="math">\\mathbb{F}=\\mathbb{F}_{p}</span> is a field. <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> are cyclic (additive) groups of prime order <span class="math">p</span>. We use the notation <span class="math">[a]_{1},[b]_{2},[c]_{t}</span> for elements in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> respectively. <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is a bilinear asymmetric map (pairing), which means that <span class="math">\\forall a,b\\in\\mathbb{Z}_{p}</span>, <span class="math">e([a]_{1},[b]_{2})\\coloneqq[ab]_{t}</span>. We implicitly have that <span class="math">[1]_{t}\\coloneqq e([1]_{1},[1]_{2})</span> generates <span class="math">\\mathbb{G}_{T}</span>. We use <span class="math">[a]_{1,2}</span> to refer to <span class="math">2</span> group elements <span class="math">[a]_{1}\\in\\mathbb{G}_{1},[a]_{2}\\in\\mathbb{G}_{2}</span>. In our constructions, we denote by <span class="math">\\mathcal{G}(p)</span> the algorithm that, given as input the prime value <span class="math">p</span>, outputs a description <span class="math">\\,\\mathsf{gk}=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">Algebraic Group Model (AGM). The algebraic group model <em>[17]</em> lies between the standard model and the stronger generic group model. In AGM, we consider only so-called algebraic adversaries. Such adversaries have direct access to group elements and, in particular, can use their bit representation, like in the standard model. However, these adversaries are assumed to output new group elements only by applying the group operation to received group elements (like in the generic group model). This requirement is formalized as follows: Suppose an adversary <span class="math">\\mathcal{A}</span> is given some group elements <span class="math">[x_{1}]_{1}\\ldots[x_{m}]_{1}\\in\\mathbb{G}_{1}</span>. Then, for every new group element <span class="math">[z]_{1}\\in\\mathbb{G}_{1}</span> that the adversary outputs, it must also output <span class="math">z_{1}\\ldots z_{m}\\in\\mathbb{F}</span> such that <span class="math">[z]_{1}=\\sum_{i=1}^{m}[z_{i}x_{i}]_{1}</span>.</p>

    <p class="text-gray-300">Assumptions. We state the computational assumptions used in this work.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">The <span class="math">(q_{1},q_{2})</span>-DLOG assumption holds relative to <span class="math">\\mathcal{G}(1^{\\lambda})</span> if for all PPT adversaries <span class="math">\\mathcal{A}</span>, the following probability is negligible in <span class="math">\\lambda</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\tau\\leftarrow\\mathcal{A}(\\mathsf{gk},\\left\\{[\\tau^{i}]_{1}\\right\\}_{i=0}^{q_{1}},\\left\\{[\\tau^{i}]_{2}\\right\\}_{i=0}^{q_{2}})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathsf{gk}\\leftarrow\\mathcal{G}(1^{\\lambda});\\;\\tau\\leftarrow\\mathbb{F}\\right.\\right].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the tree-based construction we rely on a <span class="math">q</span>-type assumption, the Bilinear Strong Diffie Hellman assumption (<span class="math">(q_{1},q_{2})</span>-<span class="math">\\mathsf{BSDH}</span>) <em>[4]</em>. When <span class="math">q_{1}=q_{2}</span>, we simply call it <span class="math">q</span>-<span class="math">\\mathsf{BSDH}</span> Assumption. We present it next.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">The <span class="math">(q_{1},q_{2})</span>-<span class="math">\\mathsf{BSDH}</span> assumption holds relative to <span class="math">\\mathcal{G}(1^{\\lambda})</span> if for all PPT adversaries <span class="math">\\mathcal{A}</span>, the following probability is negligible in <span class="math">\\lambda</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[(c,\\tfrac{1}{(\\tau-c)}e([1]_{1},[1]_{2}))\\leftarrow\\mathcal{A}(\\mathsf{gk},\\left\\{[\\tau^{i}]_{1}\\right\\}_{i=0}^{q_{1}},\\left\\{[\\tau^{i}]_{2}\\right\\}_{i=0}^{q_{2}})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathsf{gk}\\leftarrow\\mathcal{G}(1^{\\lambda});\\;\\tau\\leftarrow\\mathbb{F}\\right.\\right].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-19" class="text-2xl font-bold">3 Definitions: Linear-map Vector Commitments</h2>

    <p class="text-gray-300">We introduce preliminaries in App. 2.n the following, we define what we call Linear-map Vector Commitments (LVC) schemes. Notably, this definition has been introduced by Lai and Malavolta in <em>[24]</em> (except that there the name is <em>Linear Map Commitments</em>) to capture further functionalities of vector commitments, whose definition before only account for proofs of <em>position openings</em> (Vector Commitments) or more generally <em>subvector openings</em> (Sub-vector commitments) (See Appendix A for the formal definitions).e introduce the definition and security properties of LVC. Importantly, we do not consider the hiding property as for our applications all vectors are public.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">Linear-map Vector Commitment</h3>

    <p class="text-gray-300">A linear-map vector commitment scheme for function families <span class="math">\\mathcal{F}\\subset\\{f:\\mathcal{M}^{m}\\rightarrow\\mathcal{M}^{n}\\}</span> is a tuple of PPT algorithms <span class="math">\\big{(}\\mathsf{LVC.KeyGen},\\mathsf{LVC.Commit},\\mathsf{LVC.Open},\\mathsf{LVC},\\mathsf{Vf}\\big{)}</span> that work as follows: <span class="math">\\mathsf{LVC.KeyGen}(1^{\\lambda},\\mathcal{F})\\rightarrow(\\mathsf{prk},\\mathsf{vrk})\\text{:}</span> The setup algorithm takes the security parameter <span class="math">\\lambda</span>, a family of functions <span class="math">\\mathcal{F}</span> implicitly defining the message space <span class="math">\\mathcal{M}</span>, and the maximum vector length <span class="math">m=\\mathsf{poly}(\\lambda)</span>, and outputs a pair of keys <span class="math">(\\mathsf{prk},\\mathsf{vrk})</span>. <span class="math">\\mathsf{LVC.Commit}(\\mathsf{prk},\\mathbf{v})\\rightarrow(\\mathsf{C},\\mathsf{aux})\\text{:}</span> On input the proving key <span class="math">\\mathsf{prk}</span>, and a vector <span class="math">\\mathbf{v}=(v_{1},v_{2}\\ldots,v_{m})\\in\\mathcal{M}^{m}</span>, returns a commitment <span class="math">\\mathsf{C}</span> and auxiliary information <span class="math">\\mathsf{aux}</span>. This algorithm is <em>deterministic</em>. <span class="math">\\mathsf{LVC.Open}(\\mathsf{prk},\\mathsf{aux},f,\\mathbf{y})\\rightarrow\\pi_{f}:</span> Takes as input <span class="math">\\mathsf{prk}</span>, the auxiliary information <span class="math">\\mathsf{aux}</span>, a function <span class="math">f\\in\\mathcal{F}</span>, and a claimed result <span class="math">\\mathbf{y}\\in\\mathcal{M}^{n}</span>. It outputs a proof <span class="math">\\pi_{f}</span> that <span class="math">f(\\mathbf{v})=\\mathbf{y}</span>. <span class="math">\\mathsf{LVC.Vf}(\\mathsf{vrk},\\mathsf{C},f,\\mathbf{y},\\pi_{f})\\rightarrow 0/1:</span> Takes as input the verification key <span class="math">\\mathsf{vrk}</span>, <span class="math">\\mathsf{C}</span>, function <span class="math">f</span>, <span class="math">\\mathbf{y}\\in\\mathcal{M}^{n}</span>, and proof <span class="math">\\pi_{f}</span>. It accepts or rejects. A LVC scheme must satisfy the following properties:</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 3 (LVC correctness).</h6>

    <p class="text-gray-300">An <span class="math">\\mathsf{LVC}</span> scheme is <em>perfectly correct</em> if for all <span class="math">\\lambda\\in\\mathbb{N}</span>, for any family of functions <span class="math">\\mathcal{F}\\subset\\{f:\\mathcal{M}^{m}\\rightarrow\\mathcal{M}^{n}\\}</span> and any <span class="math">\\mathbf{v}\\in\\mathcal{M}^{m}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathsf{LVC.Vf}(\\mathsf{vrk},\\mathsf{C},f,\\mathbf{y},\\pi_{f})=1\\begin{vmatrix}(\\mathsf{prk},\\mathsf{vrk})\\leftarrow\\mathsf{LVC.KeyGen}(1^{\\lambda},\\mathcal{F})\\\\ (C,\\mathsf{aux})\\leftarrow\\mathsf{LVC.Commit}(\\mathsf{prk},\\mathbf{v})\\\\ \\pi_{f}\\leftarrow\\mathsf{LVC.Open}(\\mathsf{prk},\\mathsf{aux},f,\\mathbf{y})\\end{vmatrix}\\right]=1. \\]</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 4 (LVC (strong) function binding.).</h6>

    <p class="text-gray-300">A linear map commitment <span class="math">\\mathsf{LVC}</span> satisfies strong function binding if, for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, for all <span class="math">\\lambda\\in\\mathbb{N}</span>, for all integers <span class="math">K\\in\\mathsf{poly}(\\lambda)</span>, and for any family of functions <span class="math">\\mathcal{F}</span>, the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\forall k\\in[K]:\\\\ \\mathsf{LVC.Vf}(\\mathsf{vrk},\\mathsf{C},f_{k},\\mathbf{y}_{k},\\pi_{f_{k}})=1\\\\ \\wedge\\ \\beta\\ \\mathbf{v}\\in\\mathcal{M}^{m}\\ s.\\ t.\\\\ \\forall k\\in[K]:\\ f_{k}(\\mathbf{v})=\\mathbf{y}_{k}\\end{array}\\right]\\begin{array}[]{c}(\\mathsf{prk},\\mathsf{vrk})\\leftarrow\\mathsf{LVC.KeyGen}(1^{\\lambda},\\mathcal{F})\\\\ \\Big{(}\\mathsf{C},\\{f_{k},\\mathbf{y}_{k},\\pi_{f_{k}}\\}_{k\\in[K]}\\Big{)}\\leftarrow\\mathcal{A}(\\mathsf{prk},\\mathsf{vrk})\\end{array} \\]</p>

    <p class="text-gray-300">The definition above can be relaxed to hold only for <em>honestly-generated</em> commitments <span class="math">\\mathsf{C}</span>, raising to the <em>weak function binding</em> notion. In the weak definition, the adversary <span class="math">\\mathcal{A}</span> returns a vector <span class="math">\\mathbf{v}</span> while the commitment <span class="math">\\mathsf{C}</span> is computed via <span class="math">\\mathsf{LVC.Commit}</span>. In this work, constructions are proven strong function binding.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.1 Homomorphic Properties for LVC</h3>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Homomorphic Commitments.</h5>

    <p class="text-gray-300">Linear-map vector commitment schemes that satisfy homomorphic commitments allow to combine commitments of two vectors into a single one of their sum (or any linear combination). Namely, for all <span class="math">\\lambda</span>, and <span class="math">(\\mathsf{vrk},\\mathsf{prk})\\leftarrow\\mathsf{LVC.KeyGen}(1^{\\lambda},\\mathcal{F})</span>, if <span class="math">(\\mathsf{C}_{1},\\mathsf{aux}_{1})\\leftarrow\\mathsf{LVC.Commit}(\\mathsf{prk},\\mathbf{v}_{1})</span> and <span class="math">(\\mathsf{C}_{2},\\mathsf{aux}_{2})\\leftarrow\\mathsf{LVC.Commit}(\\mathsf{prk},\\mathbf{v}_{2})</span>, then <span class="math">\\tilde{\\mathsf{C}}=(\\alpha\\mathsf{C}_{1}+\\beta\\mathsf{C}_{2})</span> is a valid commitment to <span class="math">\\tilde{\\mathbf{v}}=(\\alpha\\mathbf{v}_{1}+\\beta\\mathbf{v}_{2})</span> for any <span class="math">\\alpha,\\beta\\in\\mathcal{M}</span>.</p>

    <p class="text-gray-300">In this work, we are particularly interested in LVC that also have <em>homomorphic proofs</em> for different functions applied to a committed vector and <em>homomorphic openings</em> for the same function applied to different initial vectors.</p>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Homomorphic Proofs.</h5>

    <p class="text-gray-300">An LVC scheme has <em>homomorphic proofs</em> if it allows recombine two proofs <span class="math">\\pi_{1}</span>, <span class="math">\\pi_{2}</span> corresponding to linear maps <span class="math">f_{1}</span>, <span class="math">f_{2}</span> into a new proof <span class="math">\\tilde{\\pi}</span> that opens to a linear combination of <span class="math">f_{1}</span> and <span class="math">f_{2}</span> applied to the same committed vector. Namely, for all <span class="math">\\lambda</span>, <span class="math">\\mathcal{F}\\subset\\{f:\\mathcal{M}^{m}\\rightarrow\\mathcal{M}^{n}\\}</span> and all vectors <span class="math">\\mathbf{v}\\in\\mathcal{M}^{m}</span>, and <span class="math">(\\mathsf{vrk},\\mathsf{prk})\\leftarrow\\mathsf{LVC.KeyGen}(1^{\\lambda},\\mathcal{F})</span>, <span class="math">(\\mathsf{C},\\mathsf{aux})\\leftarrow\\mathsf{LVC.Commit}(\\mathsf{prk},\\mathbf{v})</span>, if <span class="math">\\pi_{1}\\leftarrow\\mathsf{LVC.Open}(\\mathsf{prk},\\mathsf{aux},f_{1},\\mathbf{y}_{1})</span> and <span class="math">\\pi_{2}\\leftarrow\\mathsf{LVC.Open}(\\mathsf{prk},\\mathsf{aux},f_{2},\\mathbf{y}_{2})</span>, then for all <span class="math">\\alpha,\\beta\\in\\mathcal{M}</span>:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\pi}=(\\alpha\\pi_{1}+\\beta\\pi_{2})\\ \\text{verifies}\\ \\mathsf{LVC.Vf}(\\mathsf{vrk},\\mathsf{C},\\tilde{f}=(\\alpha f_{1}+\\beta f_{2}),\\tilde{\\mathbf{y}}=(\\alpha\\mathbf{y}_{1}+\\beta\\mathbf{y}_{2}),\\tilde{\\pi}\\big{)}=1.</span></p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Homomorphic Openings.</h5>

    <p class="text-gray-300">An LVC scheme has <em>homomorphic openings</em> if we can combine opening proofs for the same linear-map <span class="math">f</span> applied to two different vectors <span class="math">\\mathbf{v}_{1}</span> and <span class="math">\\mathbf{v}_{2}</span> to obtain a new proof of opening <span class="math">\\tilde{\\pi}</span> that verifies with respect to the linear combination <span class="math">\\tilde{\\mathsf{C}}</span> of the two initial commitments <span class="math">\\mathsf{C}_{1},\\mathsf{C}_{2}</span> and show the result of <span class="math">\\mathbf{f}</span> applied to the linear combination of the vectors <span class="math">\\mathbf{v}_{1}</span> and <span class="math">\\mathbf{v}_{2}</span>.</p>

    <p class="text-gray-300">More formally, for all <span class="math">\\lambda,\\mathcal{F}\\subset\\{f:\\mathcal{M}^{m}\\rightarrow\\mathcal{M}^{n}\\}</span>, vectors <span class="math">\\mathbf{v}_{1},\\mathbf{v}_{2}\\in\\mathcal{M}^{m}</span>, and <span class="math">(\\mathsf{vrk},\\mathsf{prk})\\leftarrow\\mathsf{LVC.KeyGen}(1^{\\lambda},\\mathcal{F})</span>, if <span class="math">\\pi_{1}\\leftarrow\\mathsf{LVC.Open}(\\mathsf{prk},\\mathsf{aux}_{1},f,\\mathbf{y}_{1})</span> and <span class="math">\\pi_{2}\\leftarrow\\mathsf{LVC.Open}(\\mathsf{prk},\\mathsf{aux}_{2},f,\\mathbf{y}_{2})</span>, where <span class="math">(\\mathsf{C}_{1},\\mathsf{aux}_{2})\\leftarrow\\mathsf{LVC.Commit}(\\mathsf{prk},\\mathbf{v}_{1})</span> and <span class="math">(\\mathsf{C}_{2},\\mathsf{aux}_{2})\\leftarrow\\mathsf{LVC.Commit}(\\mathsf{prk},\\mathbf{v}_{2})</span>, then for all <span class="math">\\alpha,\\beta\\in\\mathcal{M}</span>:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\pi}=(\\alpha\\pi_{1}+\\beta\\pi_{2})\\ \\text{verifies}\\ \\mathsf{LVC.Vf}(\\mathsf{vrk},\\tilde{\\mathsf{C}}=(\\alpha\\mathsf{C}_{1}+\\beta\\mathsf{C}_{2}),f,\\tilde{\\mathbf{y}}=(\\alpha\\mathbf{y}_{1}+\\beta\\mathbf{y}_{2}),\\tilde{\\pi}\\big{)}=1.</span></p>

    <h2 id="sec-27" class="text-2xl font-bold">4 Generic Constructions from Homomorphic Proofs</h2>

    <p class="text-gray-300">Many natural schemes (such as <em>[33, 18]</em>, PST commitments or our constructions in Section 5) have homomorphic proofs or openings. This motivates us to consider generic constructions that enhance any LVC scheme with homomorphic properties. We start by defining the notions of unbounded aggregation for same and cross-commitments and then we show how to add such properties to LVC schemes that have homomorphic proofs for the former and, additionally, homomorphic commitments for the latter.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">4.1 New Notion: Unbounded Aggregation</h3>

    <p class="text-gray-300">The intuition for our definition is that, given <span class="math">t</span> proofs, commitments or openings, we can aggregate them by performing a linear combination with random coefficients. Importantly, these coefficients have to</p>

    <p class="text-gray-300">be chosen after the claims are fixed and for that we rely on the RO model, as it is often the case for aggregation in the literature.</p>

    <p class="text-gray-300">In our work, we go a step further and show how this procedure can be done over already aggregated proofs. Actually, aggregating <em>already aggregated</em> proofs consists off just sampling new coefficients and using them for fresh linear combinations. Importantly, the verifier needs to have access to the aggregation history: it has to recompute the coefficient corresponding to each initial proof <span class="math">\\pi</span>, which is the product of all the coefficients used in the aggregations it was involved in. Note that this also adds a small overhead to the verifier: it makes a linear (in the number of aggregation “hops”) number of hash computations.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Example for same-commitment aggregation</h6>

    <p class="text-gray-300">Consider vector <span class="math">\\mathbf{v}</span> committed in <span class="math">\\mathsf{C}</span>, functions <span class="math">f_{1},f_{2}</span> and <span class="math">f_{3}</span>; let <span class="math">\\pi_{1},\\pi_{2}</span> and <span class="math">\\pi_{3}</span> be proofs that <span class="math">f_{1}(\\mathbf{v})=\\mathbf{y}_{1}</span>, <span class="math">f_{2}(\\mathbf{v})=\\mathbf{y}_{2}</span> and <span class="math">f_{3}(\\mathbf{v})=\\mathbf{y}_{3}</span>. An aggregated proof for <span class="math">f_{2}(\\mathbf{v})=\\mathbf{y}_{2}</span>, <span class="math">f_{3}(\\mathbf{v})=\\mathbf{y}_{3}</span>, would be <span class="math">\\pi_{1}^{<em>}=\\pi_{2}+\\gamma_{1}\\pi_{3}</span>, for <span class="math">\\gamma_{1}=\\mathsf{H}(\\mathsf{C},\\{(f_{2},\\mathbf{y}_{2}),(f_{3},\\mathbf{y}_{3})\\})</span>. In a second step, we can aggregate a proof that <span class="math">f_{1}(\\mathbf{v})=\\mathbf{y}_{1}</span>, by performing <span class="math">\\pi_{2}^{</em>}=\\pi_{1}+\\gamma_{2}\\pi_{1}^{<em>}</span>, for <span class="math">\\gamma_{2}=\\mathsf{H}(\\mathsf{C},(f_{1},\\mathbf{y}_{1}),\\gamma_{1})</span>. At the verification step, the verifier would reconstruct the coefficients of each initial proof in <span class="math">\\pi_{2}^{</em>}</span>. For instance, <span class="math">\\delta_{1}=1</span>, <span class="math">\\delta_{2}=\\gamma_{1}\\gamma_{2}</span>, <span class="math">\\delta_{3}=\\gamma_{2}</span>. Then, the verifier can run the LVC.Vf algorithm to check whether <span class="math">\\pi_{2}^{<em>}=\\pi_{1}+\\gamma_{2}\\pi_{1}^{</em>}=\\pi_{1}+\\gamma_{1}\\gamma_{2}\\pi_{2}+\\gamma_{2}\\pi_{3}</span> is a valid proof that function <span class="math">f=f_{1}+\\gamma_{1}\\gamma_{2}f_{2}+\\gamma_{2}f_{3}</span> evaluated at the vector committed in <span class="math">\\mathsf{C}</span> opens to <span class="math">y=y_{1}+\\gamma_{1}\\gamma_{2}y_{2}+\\gamma_{2}y_{3}</span>. For this last step to work we need the homomorphic proof property and the verifier to have access to the aggregation “history”.</p>

    <p class="text-gray-300">To describe our history of claims we move to <em>trees</em> of statements <span class="math">\\{f_{j},\\mathbf{y}_{j}\\}_{j=1}^{t}</span>. In these trees, leaves are pairs of function–output <span class="math">(f,\\mathbf{y})</span>. As in the usual case internal nodes are defined as an ordered list of subtrees. An empty history/tree is referred to as null. We denote trees using the syntax <span class="math">T_{f,\\mathbf{y}}</span> and the operation that “merges” two subtrees in order adding a new root as “<span class="math">\\therefore</span>”. The following definition formalizes the above and will be useful in our construction. We remark that we include the commitment in each of the leaves of the trees <span class="math">T_{f,\\mathbf{y}}</span>. This does not increase the input size for cross-commitment aggregation where this information is necessary (for same-commitment aggregation the commitment is not necessary). This also allows to model more closely the “claims” for the cross-commitment case where each proof is for a statement <span class="math">(\\mathsf{C},f,\\mathbf{y})</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">Given a tree <span class="math">T</span> we associate to each of its internal nodes a hash label <span class="math">h</span> defined so that <span class="math">h(L\\therefore R):=\\mathsf{H}(C,L,R)</span>. We then associate to each of the leaves in the tree a label</p>

    <p class="text-gray-300"><span class="math">\\delta(\\mathsf{leaf}):=\\prod_{i=1,\\ldots,t}h(x_{i})^{r(x_{i},\\mathsf{leaf})}</span></p>

    <p class="text-gray-300">where the <span class="math">x_{i}</span>-s are the internal nodes along the path from <span class="math">\\mathsf{leaf}</span> to the root (root included and starting from the bottom), the predicate <span class="math">r(x,\\mathsf{leaf})</span> is 1 if <span class="math">\\mathsf{leaf}</span> is a right child of <span class="math">x</span> and 0 otherwise.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Remark 1 (Unbounded vs One-hop vs Incremental).</h6>

    <p class="text-gray-300">Previous works have defined other types of aggregation. In one-hop aggregation (or batching) <em>[5]</em> aggregated proofs cannot be aggregated further. Incremental aggregation <em>[8]</em> does not have this limitation. The difference between the latter and our notion is that incremental aggregation does not require to keep track of the order in which the aggregation has been applied (for verification or further aggregation). On the other hand, we do require to track order, but we argue that this is not an overhead in many settings. In particular, even incremental aggregators and verifiers need to know the claims related to the proofs being aggregated, albeit in no order. Adding a structure to the claims roughly adds a number of bits linear in the length of the opening for additional separators (see also examples on tree histories above).</p>

    <p class="text-gray-300">When we consider unbounded-aggregatable LVC, we assume KeyGen outputs additional parameters for aggregations in <span class="math">\\mathsf{pp}</span>. The aggregation algorithm will follow this syntax:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{LVC.Agg}(\\mathsf{pp},T_{f,\\mathbf{y}},\\pi,T_{f^{\\prime},\\mathbf{y}^{\\prime}},\\pi^{\\prime})\\to\\pi^{*}</span></p>

    <p class="text-gray-300">We subsequently modify the syntax for the verification algorithm in an (unbounded) aggregatable LVC as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{LVC.Vf}(\\mathsf{vrk},\\mathsf{C},T_{f,\\mathbf{y}}\\therefore T^{\\prime}_{f,\\mathbf{y}},\\pi^{*})\\to b\\in\\{0,1\\}</span></p>

    <p class="text-gray-300">with <span class="math">T_{f,\\mathbf{y}}</span> replacing <span class="math">f,\\mathbf{y}</span>.</p>

    <p class="text-gray-300">We require the following correctness property and that function binding still holds.</p>

    <p class="text-gray-300">Definition 6 (Unbounded Aggregation Correctness). For any <span class="math">T_{f,\\mathbf{y}}, T_{f&#x27;,\\mathbf{y}&#x27;}</span> and any <span class="math">\\pi, \\pi&#x27;</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} (\\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, T_{f,\\mathbf{y}}, \\pi) = 1 \\wedge \\\\ \\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, T_{f,\\mathbf{y}}&#x27;, \\pi&#x27;) = 1) \\Rightarrow \\\\ \\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, T_{f,\\mathbf{y}} \\therefore T_{f,\\mathbf{y}}&#x27;, \\pi^*) = 1 \\end{array} \\right] \\begin{array}{l} (\\mathsf{prk}, \\mathsf{vrk}, \\mathsf{pp}) \\leftarrow \\mathsf{LVC.KeyGen}(1^{\\lambda}, \\mathcal{F}) \\\\ (\\mathsf{C}, \\mathsf{aux}) \\leftarrow \\mathsf{LVC.Commit}(\\mathsf{prk}, \\mathbf{v}) \\\\ \\pi^* \\leftarrow \\mathsf{LVC.Agg}(\\mathsf{pp}, T_{f,\\mathbf{y}}, \\pi, T_{f&#x27;,\\mathbf{y}&#x27;}, \\pi&#x27;) \\end{array} \\tag{1}</span></div>

    <p class="text-gray-300">Definition 7 (Unbounded Aggregation Function Binding). For any <span class="math">T_{f,\\mathbf{y}}, T_{f&#x27;,\\mathbf{y}&#x27;}</span> the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} \\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, T_{f,\\mathbf{y}} \\therefore T_{f,\\mathbf{y}}&#x27;, \\pi^*) = 1 \\\\ \\wedge \\nexists \\mathbf{a} \\text{ s.t. } f(\\mathbf{a}) = \\mathbf{y} \\wedge f&#x27;(\\mathbf{a}) = \\mathbf{y}&#x27; \\end{array} \\right] \\begin{array}{l} (\\mathsf{prk}, \\mathsf{vrk}, \\mathsf{pp}) \\leftarrow \\mathsf{LVC.KeyGen}(1^{\\lambda}, \\mathcal{F}) \\\\ (\\mathsf{C}, \\pi^*, T_{f,\\mathbf{y}}, T_{f,\\mathbf{y}}&#x27;) \\leftarrow \\mathcal{A}(\\mathsf{pp}, \\mathsf{prk}, \\mathsf{vrk}) \\end{array}</span></div>

    <p class="text-gray-300">Definition: Cross-Commitment Aggregation. Unbounded aggregation can be performed across different commitments as well. This property is called Cross-commitment Aggregation and makes sense when we have a set of commitments <span class="math">\\mathsf{C}_1&#x27;, \\ldots, \\mathsf{C}_t&#x27;</span> that we want to open at one or more maps <span class="math">f</span>, as it allows to compute a succinct proof of opening for linear-maps from different vectors committed separately. Below we show our syntax which directly expands on our same-commitment aggregation described above. Function binding and correctness are also straightforward to expand. We let <span class="math">T_{f,\\mathbf{y}}</span> include our commitments in the leaves (see also next section).</p>

    <p class="text-gray-300">Cross-commitment aggregation: LVC.CrossAgg(pp, <span class="math">T_{f,\\mathbf{y}}, \\pi, T_{f&#x27;,\\mathbf{y}&#x27;}, \\pi&#x27;) \\to \\pi^*</span></p>

    <p class="text-gray-300">Cross-commitment verification: LVC.CrossVfy(vrk, <span class="math">\\left(\\mathsf{C}_j&#x27;\\right)_j, T_{f,\\mathbf{y}}, \\pi^*) \\to 0/1</span></p>

    <h2 id="sec-32" class="text-2xl font-bold">4.2 Unbounded Aggregation for LVC</h2>

    <p class="text-gray-300">We now describe unbounded aggregation algorithms for any LVC scheme that satisfies the homomorphic properties of Section 3.1.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{LVC.KeyGen}(1^{\\lambda}, \\mathcal{F}) \\to (\\mathsf{prk}, \\mathsf{vrk}, \\mathsf{pp}, \\{\\mathsf{upk}_j\\}_{j=1}^m)</span>: Additionally generate the description of a hash function <span class="math">\\mathsf{H}(\\cdot)</span> and set it as <span class="math">\\mathsf{pp}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{LVC.Agg}(\\mathsf{pp}, T_{f,\\mathbf{y}}, \\pi, T_{f&#x27;,\\mathbf{y}&#x27;}, \\pi&#x27;) \\to \\pi^*</span>:</p>

    <p class="text-gray-300">Compute <span class="math">\\gamma = \\mathsf{H}(\\mathsf{C}, T_{f,\\mathbf{y}}, T_{f&#x27;,\\mathbf{y}&#x27;})</span></p>

    <p class="text-gray-300">Output <span class="math">\\pi^{*} = \\pi + \\gamma \\pi&#x27;</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, T_{f,\\mathbf{y}} \\therefore T_{f&#x27;,\\mathbf{y}&#x27;}, \\pi^*) \\to b</span></p>

    <p class="text-gray-300">Return <span class="math">b \\leftarrow \\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, f^<em>, y^</em>, \\pi^*)</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\{\\mathsf{leaf}_i = (\\mathsf{C}, f_i, \\mathbf{y}_i)\\}_{i=1}^t</span> be all the leaves in <span class="math">T_{f,\\mathbf{y}} \\therefore T_{f&#x27;,\\mathbf{y}&#x27;}</span>.</li>

      <li>For each <span class="math">i</span> let <span class="math">\\delta_i := \\delta(\\mathsf{leaf}_i)</span> be the value defined as in Definition 5.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f^* := \\sum_i \\delta_i f_i \\quad y^* := \\sum_i \\delta_i \\mathbf{y}_i</span></div>

    <p class="text-gray-300">Theorem 1. When applied to a function binding LVC scheme with homomorphic proofs, (LVC.Agg, LVC.Vf) satisfies Unbounded Aggregation Correctness (as in Def. 6) and Function Binding (Def. 7) in the ROM.</p>

    <p class="text-gray-300">Proof. Correctness follows by inspection, using the fact that the LVC satisfies homomorphic proof, so we omit it.</p>

    <p class="text-gray-300">For function binding, let <span class="math">\\mathcal{A}</span> be an adversary against it and <span class="math">(\\mathsf{C}, \\pi^<em>, T_{f,\\mathbf{y}}, T_{f&#x27;,\\mathbf{y}&#x27;})</span> an output of them such that <span class="math">\\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, T_{f,\\mathbf{y}} \\therefore T_{f&#x27;,\\mathbf{y}&#x27;}, \\pi^</em>) = 1</span>. By construction this implies <span class="math">\\mathsf{LVC.Vf}(\\mathsf{vrk}, \\mathsf{C}, \\sum_i \\delta_i f_i, \\sum_i \\delta_i \\mathbf{y}_i, \\pi^*) = 1</span>. Because LVC is function binding, except with negligible probability, there exists a vector <span class="math">\\mathbf{a}</span> such that <span class="math">f(\\mathbf{a}) = \\mathbf{y}</span>, for <span class="math">\\mathbf{y} = \\sum_i \\delta_i \\mathbf{y}_i</span>, <span class="math">f(\\mathbf{X}) = \\sum_i \\delta_i f_i(\\mathbf{X})</span> then there exists <span class="math">\\mathbf{a}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^t \\delta_i f_i(\\mathbf{a}) = \\sum_{i=1}^t \\delta_i \\mathbf{y}_i.</span></div>

    <p class="text-gray-300">Since <span class="math">\\mathsf{H}</span> is a random oracle, the coefficients <span class="math">\\delta_i</span> do not depend on <span class="math">\\mathbf{y}_i, f_i</span>. And by the Schwartz-Zippel lemma, except with probability <span class="math">m / \\mathbb{F}</span>, where <span class="math">m</span> is the degree of <span class="math">f</span>, <span class="math">f_i(\\mathbf{a}) = \\mathbf{y}_i</span> for all <span class="math">i</span>, which concludes the proof.</p>

    <p class="text-gray-300">Cross-Commitment Aggregation for LVC. For the case of cross-commitment aggregation, we proceed similarly but we also need to homomorphically operate on the commitments (recall that hashing on trees implicitly hashes the commitments too since we include them there).</p>

    <p class="text-gray-300">LVC.CrossAgg(pp, <span class="math">T_{f,\\mathbf{y}}</span>, <span class="math">\\pi</span>, <span class="math">T_{f&#x27;,\\mathbf{y}&#x27;}</span>, <span class="math">\\pi&#x27;</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi^*</span> :</p>

    <p class="text-gray-300">Compute <span class="math">\\gamma = \\mathsf{H}(T_{f,\\mathbf{y}}, T_{f&#x27;,\\mathbf{y}&#x27;})</span></p>

    <p class="text-gray-300">Output <span class="math">\\pi^{*} = \\pi + \\gamma \\pi&#x27;</span></p>

    <p class="text-gray-300">LVC.CrossVfy(vrk, (C, C', Tf,y, Tf',y', π*) <span class="math">\\rightarrow</span> b</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\mathsf{leaf}_1, \\ldots, \\mathsf{leaf}_\\ell</span> be all the leaves in <span class="math">T_{f,\\mathbf{y}} \\therefore T_{f&#x27;,\\mathbf{y}&#x27;}</span>. We add to each leaf <span class="math">\\mathsf{leaf}_i</span> and additional subindex <span class="math">j</span> that refers to which commitment the proof in <span class="math">\\mathsf{leaf}_{ij}</span> corresponds to. Note that we still consider <span class="math">\\ell</span> leaves.</li>

      <li>each <span class="math">\\mathsf{leaf}_{ij}</span> is of the form <span class="math">(C_j, f_i, \\mathbf{y}_i)</span></li>

      <li>For each <span class="math">i</span> let <span class="math">\\delta_{ij} := \\delta(\\mathsf{leaf}_{ij})</span> be the value defined as in Definition 5.</li>

      <li>Compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f _ {j} ^ {*} := \\sum_ {i} \\delta_ {i j} f _ {i} \\quad y _ {j} ^ {*} := \\sum_ {i} \\delta_ {i j} \\mathbf {y} _ {i}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return 1 iff <span class="math">b_{j} = 1</span> for all <span class="math">b_{j}\\gets \\mathsf{LVC.Vf}\\big(\\mathsf{vrk},\\mathsf{C}_{j},f_{j}^{<em>},y_{j}^{</em>},\\pi^{*}\\big)</span>.</li>

    </ul>

    <p class="text-gray-300">Efficiency. For our constructions, the verification equations for computing <span class="math">b_{i} = \\mathsf{IP.Vf}\\big(\\mathsf{vrk}, C^{<em>}, f^{</em>}, y^{<em>}, \\pi^{</em>}\\big)</span> are two pairing equations where the elements in the right side can be aggregated, and thus the verifier performs only <span class="math">\\ell + 1</span> pairings.</p>

    <p class="text-gray-300">Security. The security of this augmented construction follows analogously to that for same-commitment aggregation, with the additional requirement for the LVC scheme to have homomorphic commitments and openings.</p>

    <h2 id="sec-33" class="text-2xl font-bold">4.3 From Inner-Products to Arbitrary Linear-Maps</h2>

    <p class="text-gray-300">In this section we show we can obtain LVC schemes for any family of functions <span class="math">\\mathcal{F} \\subset \\{f : \\mathbb{F}^m \\to \\mathbb{F}^n\\}</span> starting from simpler constructions that have homomorphic proofs and openings. Our starting point are LVC schemes for <span class="math">\\mathcal{F}_{\\mathrm{IP}} = \\{f : \\mathbb{F}^m \\to \\mathbb{F}\\}</span>, or inner-product VC schemes, that we will denote as <span class="math">\\mathsf{IP} = (\\mathsf{IP.KeyGen}, \\mathsf{IP.Commit}, \\mathsf{IP.Open}, \\mathsf{IP.Vf})</span>. All this algorithms work as the ones for LVC, except that instead of <span class="math">f \\in \\mathcal{F}_{\\mathsf{IP}_{m,p}}</span>, they use the vector <span class="math">\\mathbf{f} \\in \\mathbb{F}^m</span> so that <span class="math">f(\\mathbf{v}) = \\mathbf{f} \\cdot \\mathbf{v}</span>.</p>

    <p class="text-gray-300">We can write the linear-map <span class="math">f: \\mathbb{F}^m \\to \\mathbb{F}^n</span> as <span class="math">f = (f_1, f_2, \\ldots, f_n)</span>, where each <span class="math">f_i</span> is an inner product function. If the IP scheme has homomorphic proofs, and we set <span class="math">\\pi_i</span> to be the proof that <span class="math">f_i(\\mathbf{v}) = \\mathbf{f}_i \\cdot \\mathbf{v} = y_i</span>, an aggregation of <span class="math">\\{\\pi_i\\}_{i=1}^n</span> is a proof of the statement <span class="math">f(\\mathbf{v}) = \\mathbf{y}</span>. Later, in the following section, we show two possible constructions of IP vector commitments schemes that can be used to instantiate the framework in this section. An IP aggregation algorithm for one-hop aggregation<span class="math">^{11}</span> of proofs works as follows:</p>

    <p class="text-gray-300">IP.Agg(pp, <span class="math">\\{\\mathbf{f}_i, y_i\\}_{i=1}^n</span>, <span class="math">\\pi = (\\pi_i)_{i=1}^n</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi&#x27;</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{pp} = \\mathsf{H}</span>, where <span class="math">\\mathsf{H}</span> is a hash function, compute <span class="math">\\gamma = \\mathsf{H}(\\mathsf{C}, \\{\\mathbf{f}_i, y_i\\}_{i=1}^n)</span></li>

      <li>Output <span class="math">\\pi&#x27; = \\sum_{i=1}^{n} \\gamma^{i-1} \\pi_i</span></li>

    </ul>

    <p class="text-gray-300">IP.VfAgg(vrk, C, <span class="math">\\{\\mathbf{f}_i, y_i\\}_{i=1}^n</span>, <span class="math">\\pi&#x27;</span>) <span class="math">\\rightarrow</span> b:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\gamma = \\mathsf{H}(\\mathsf{C}, \\{\\mathbf{f}_i, y_i\\}_{i=1}^n)</span>, <span class="math">\\mathbf{f}&#x27; = \\sum_{i=1}^{n} \\gamma^{i-1} \\mathbf{f}_i</span>, <span class="math">y&#x27; = \\sum_{i=1}^{n} \\gamma^{i-1} y_i</span></li>

      <li>Output <span class="math">b \\gets \\mathsf{IP.Vf}(\\mathsf{vrk}, \\mathsf{C}, \\mathbf{f}&#x27;, y&#x27;, \\pi&#x27;)</span>.</li>

    </ul>

    <p class="text-gray-300">Using IP.Agg, we present an alternative way of computing concise proofs of LVC for more general functions <span class="math">f: \\mathbb{F}^m \\to \\mathbb{F}^n</span>, based on aggregation.</p>

    <p class="text-gray-300">LVC.KeyGen(1^λ, F) <span class="math">\\rightarrow</span> (prk, vrk, pp):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">(\\mathsf{prk},\\mathsf{vrk}) \\gets \\mathsf{IP.KeyGen}(1^{\\lambda},\\mathcal{F}_{\\mathsf{IP}})</span></li>

      <li>Generate aggregation parameters <span class="math">\\mathsf{pp} = \\mathsf{H}</span> (a hash function).</li>

      <li>Output <span class="math">(\\mathsf{prk},\\mathsf{vrk},\\mathsf{pp})</span>.</li>

    </ol>

    <p class="text-gray-300">LVC.Commit(prk, v) <span class="math">\\rightarrow</span> (C, aux):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run (C, aux) <span class="math">\\leftarrow</span> IP.Commit(prk, v)</li>

      <li>Output (C, aux).</li>

    </ol>

    <p class="text-gray-300">LVC.Open(prk, pp, aux, f, y) <span class="math">\\rightarrow</span> <span class="math">\\pi</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">f = (f_1, f_2, \\ldots, f_n)</span> and <span class="math">\\mathbf{y} = (y_1, \\ldots, y_n)</span>. Consider <span class="math">\\mathbf{f}_i</span> as the vector representing inner-product function <span class="math">f_i</span>.</li>

      <li>Run <span class="math">\\pi_i \\leftarrow \\text{IP.Open}(\\text{prk}, \\text{aux}, \\mathbf{f}_i, y_i)</span> for <span class="math">i \\in [n]</span></li>

      <li>Output <span class="math">\\pi \\leftarrow \\text{IP.Agg}(\\text{pp}, \\{\\mathbf{f}_i, y_i\\}_{i=1}^n, (\\pi_i)_{i=1}^n)</span>.</li>

    </ol>

    <p class="text-gray-300">LVC.VfAgg(vrk, pp, C, f, y, <span class="math">\\pi</span>) <span class="math">\\rightarrow</span> <span class="math">b</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">f = (f_1, f_2, \\ldots, f_n)</span> and <span class="math">\\mathbf{y} = (y_1, \\ldots, y_n)</span>. Consider <span class="math">\\mathbf{f}_i</span> as the vector representing function <span class="math">f_i</span>.</li>

      <li>Output <span class="math">b \\leftarrow \\text{IP.VfAgg}(\\text{vrk}, \\mathsf{C}, \\{\\mathbf{f}_i, y_i\\}_{i=1}^n, \\pi)</span></li>

    </ol>

    <h2 id="sec-34" class="text-2xl font-bold">4.4 Updability for LVC</h2>

    <p class="text-gray-300">We consider updatability as an extra property of the LVC scheme. The KeyGen algorithm additionally computes the update keys, while two extra algorithms are defined as follows:</p>

    <p class="text-gray-300">LVC.UpdCom(upk, C, j, δ) <span class="math">\\rightarrow</span> C': takes as input C, a position <span class="math">j \\in [m]</span>, update key upk, and a constant <span class="math">\\delta \\in \\mathcal{M}</span>. It outputs C' as a commitment for <span class="math">\\mathbf{v}&#x27; = \\mathbf{v} + \\delta \\mathbf{e}_j</span>¹².</p>

    <p class="text-gray-300">LVC.UpdOpen(upk, j, δ, f, y, <span class="math">\\pi</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi&#x27;</span> : Takes as input upk, j, δ, a function f, a valid opening pair (y, π) for f and outputs a proof <span class="math">\\pi&#x27;</span> for the new opening <span class="math">\\mathbf{y}&#x27; = f(\\mathbf{v} + \\delta \\mathbf{e}_j)</span>,</p>

    <p class="text-gray-300">and satisfy Update Correctness, as defined below:</p>

    <p class="text-gray-300">Update Correctness. Let <span class="math">(\\text{prk}, \\text{vrk}, \\text{upk}) \\leftarrow \\text{LVC.KeyGen}(1^{\\lambda}, \\mathcal{F})</span>, and let <span class="math">(\\mathsf{C}, j, f, \\mathbf{y}, \\pi)</span> be a tuple such that <span class="math">\\text{LVC.Vf}(\\text{vrk}, \\mathsf{C}, f, \\mathbf{y}, \\pi) = 1</span>. Then LVC satisfies update correctness if for any <span class="math">\\delta \\in \\mathcal{M}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text{LVC.Vf}(\\text{vrk}, \\mathsf{C}&#x27;, f, \\mathbf{y}&#x27;, \\pi&#x27;) = 1 &amp;amp; \\mathsf{C}&#x27; \\leftarrow \\text{LVC.UpdCom}(\\text{upk}_j, \\mathsf{C}, j, \\delta) \\\\ \\wedge \\mathbf{y}&#x27; = \\mathbf{y} + \\delta f(\\mathbf{e}_j) &amp;amp; \\pi&#x27; \\leftarrow \\text{LVC.UpdOpen}(\\text{upk}_j, j, \\delta, f, \\mathbf{y}, \\pi) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Updates for IP. We present a generic construction of the updatability algorithms for inner-product schemes. We state that even though algorithms can be generalized to LVC for arbitrary functions, for ease of exposition we only present it for inner-product openings, rather than generic linear-maps.</p>

    <p class="text-gray-300">It is easy to see that commitments can be updated when one value of the vector changes by simply applying the linear-homomorphic property of the underlying IP scheme. Given <span class="math">\\mathsf{C}</span> such that <span class="math">(\\mathsf{C}, \\mathsf{aux}) \\leftarrow \\text{LVC.Commit}(\\text{prk}, \\mathbf{v})</span>, when position <span class="math">t</span> of the vector changes, i.e. <span class="math">\\mathbf{v}&#x27; = \\mathbf{v} + \\delta \\mathbf{e}_t</span> we can compute a commitment to the new vector <span class="math">\\mathbf{v}&#x27;</span> as <span class="math">\\mathsf{C}&#x27; = (\\mathsf{C} + \\tilde{\\mathsf{C}})</span> where <span class="math">(\\tilde{\\mathsf{C}}, \\tilde{\\mathsf{aux}}) \\leftarrow \\text{LVC.Commit}(\\text{prk}, \\mathbf{e}_t)</span> is given as an update key.</p>

    <p class="text-gray-300">Moreover, it is possible to update existing proofs using the homomorphic openings property of the IP scheme: when position <span class="math">t</span> of the vector changes as above, to update a prior proof we simply add to <span class="math">\\pi</span> a proof <span class="math">\\hat{\\pi}</span> corresponding to the opening of <span class="math">f(\\delta \\mathbf{e}_t)</span>. The resulting <span class="math">\\pi&#x27; = \\pi + \\hat{\\pi}</span> corresponds to the opening of the sum <span class="math">f(\\mathbf{v}&#x27;) = f(\\mathbf{v}) + \\delta f(\\mathbf{e}_t)</span> with respect to the updated commitment <span class="math">\\mathsf{C}&#x27; = \\mathsf{C} + \\tilde{\\mathsf{C}}</span>.</p>

    <p class="text-gray-300">We extend IP arguments to satisfy updatability by asking the IP.KeyGen algorithm to additionally generate updatable keys and introduce IP.UpdCom and IP.UpdOpen that work the following way;</p>

    <p class="text-gray-300">IP.KeyGen(1^λ, FIP) <span class="math">\\rightarrow</span> (prk, vrk, {upk_j}j=1^m):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Additionally generate public update keys upk:</li>

      <li>Set <span class="math">\\pi_{u_{ij}} \\leftarrow \\text{IP.Open}(\\text{prk}, \\text{aux}_j, \\mathbf{e}_i, u_{ij} = \\mathbf{e}_i \\cdot \\mathbf{e}_j)</span>, <span class="math">\\forall i, j \\in [m]</span>.</li>

      <li>Define <span class="math">\\text{upk}_j = \\{\\pi_{u_{ij}}\\}_{i=1}^m</span> for all <span class="math">j \\in [m]</span></li>

      <li>Output <span class="math">(\\text{prk}, \\text{vrk}, \\{\\text{upk}_i\\}_{i=1}^m)</span>.</li>

    </ol>

    <p class="text-gray-300">IP.UpdCom(prk, C, t, δ) <span class="math">\\rightarrow</span> C':</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\tilde{\\mathsf{C}} \\leftarrow \\text{IP.Commit}(\\text{prk}, \\mathbf{e}_t)</span>.</li>

      <li>Output <span class="math">\\mathsf{C}&#x27; = \\mathsf{C} + \\delta \\tilde{\\mathsf{C}}</span>.</li>

    </ol>

    <p class="text-gray-300">IP.UpdOpen(upk_t, t, δ, C, f, y, π) <span class="math">\\rightarrow</span> π':</p>

    <p class="text-gray-300">¹² This notion can be generalized to more than one position.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{upk}_t = \\{\\pi_{u_{it}}\\}_{i=1}^m</span></li>

      <li>Compute <span class="math">\\hat{\\pi} = \\sum_{i=1}^{m} f_i \\pi_{u_{it}}</span>.</li>

      <li>Set <span class="math">\\pi&#x27; = \\pi + \\delta \\hat{\\pi}</span> as proof for <span class="math">y&#x27; = y + \\mathbf{f} \\cdot \\delta \\mathbf{e}_t</span></li>

      <li>Output <span class="math">\\pi&#x27;</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Theorem 2.</strong> If <span class="math">\\mathsf{IP}</span> satisfies function binding and has homomorphic commitments and openings, the extension above satisfies update correctness.</p>

    <p class="text-gray-300">The proof follows directly by the definition of homomorphic proof and <span class="math">\\mathsf{IP.UpdCom}, \\mathsf{IP.UpdOpen}</span>.</p>

    <p class="text-gray-300">In this section, we present two constructions of LVC for inner products, that is, for functions <span class="math">f \\subset \\mathcal{F}_{\\mathrm{IP}} = \\{f : \\mathbb{F}^m \\to \\mathbb{F}\\}</span>. We denote as <span class="math">\\mathsf{IP} = (\\mathsf{IP.KeyGen}, \\mathsf{IP.Commit}, \\mathsf{IP.Open}, \\mathsf{IP.Vf})</span> a vector commitment scheme with inner product openings. All the algorithms work as the ones for LVC, except that they take as inputs the vector of coefficients of the linear function <span class="math">f \\in \\mathcal{F}_{\\mathrm{IP}}</span>, <span class="math">f(\\mathbf{v}) = \\mathbf{f} \\cdot \\mathbf{v}</span>, i.e. use the vector <span class="math">\\mathbf{f} \\in \\mathbb{F}_p^m</span>.</p>

    <p class="text-gray-300">The first one is in the monomial basis and the other based on the univariate sumcheck of [3, 30] that considers vectors encoded as polynomials in the Lagrange basis. We prove they are indeed linear vector commitment arguments with homomorphic proofs and openings. Therefore, they can be used as a starting point to obtain further aggregation properties as shown in Section 4.1 and, in particular, lead to two different more generic linear-map vector commitment schemes.</p>

    <p class="text-gray-300">For the first scheme, we consider vectors <span class="math">\\mathbf{a} \\in \\mathbb{F}^m</span> encoded as a polynomial in the monomial basis, that is as <span class="math">a(X) = \\sum_{i=1}^{m} a_i X^{i-1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.KeyGen}(1^{\\lambda}, \\mathcal{F}_{\\mathsf{IP}}) \\to (\\mathsf{prk}, \\mathsf{vrk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate group description <span class="math">\\mathsf{gk} = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e) \\gets \\mathcal{G}(p)</span></li>

      <li>Sample <span class="math">\\tau \\gets \\mathbb{F}</span></li>

      <li>Output <span class="math">\\mathsf{prk} = \\left(\\left\\{\\left[\\tau^{i}\\right]_{1,2}\\right\\}_{i=0}^{m}\\right)</span>, <span class="math">\\mathsf{vrk} = \\left(\\left[\\tau^{m-1}\\right]_{1}, \\left\\{\\left[\\tau^{i}\\right]_{2}\\right\\}_{i=0}^{m}\\right)</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.Commit}(\\mathsf{prk}, \\mathbf{a}) \\to (\\mathsf{C}_a, \\mathsf{aux})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\mathsf{C}_a = \\sum_{i=1}^{m} a_i [\\tau^{i-1}]_1</span> and output <span class="math">(\\mathsf{C}_a, \\mathbf{a})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.Open}(\\mathsf{prk}, \\mathsf{aux}, \\mathbf{b}, y) \\to \\pi</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find <span class="math">R(X), H(X)</span> such that <span class="math">\\deg(R) &amp;lt; m - 1</span> and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{i=1}^{m} a_i X^{i-1}\\right) \\left(\\sum_{i=1}^{m} b_i X^{m-i}\\right) - y X^{m-1} = R(X) + X^m H(X).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\hat{R}(X) = X^2 R(X)</span></li>

      <li>Output <span class="math">\\pi = ([R(\\tau)]_1, [H(\\tau)]_1, [\\hat{R}(\\tau)]_1)</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.Vf}(\\mathsf{vrk}, \\mathsf{C}_a, \\mathbf{b}, y, \\pi) \\to 0/1</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\mathsf{C}_b = \\sum_{i=1}^{m} b_i [\\tau^{m-i}]_1</span>, parse <span class="math">\\pi = ([R]_1, [H]_1, [\\hat{R}]_1)</span> and output 1 if and only if</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e\\big(\\mathsf{C}_a, \\mathsf{C}_b\\big) - e\\big(y[\\tau^{m-1}]_1, [1]_2\\big) = e\\big([R]_1, [1]_2\\big) + e\\big([H]_1, [\\tau^m]_2\\big) \\text{ and}</span></div>

    <div class="my-4 text-center"><span class="math-block">e([R]_1, [\\tau^2]_2) = e([\\hat{R}]_1, [1]_2).</span></div>

    <p class="text-gray-300">We implement this construction for single positions and compare it with individual position openings in Merkle tree-based vector commitments in Appendix 7.1.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> The construction above satisfies Completeness, Homomorphic Proofs and Homomorphic Openings.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness follows from simple inspection.</p>

    <p class="text-gray-300"><strong>Homomorphic Proofs.</strong> Let <span class="math">y_{b} = \\mathbf{a} \\cdot \\mathbf{b}</span>, <span class="math">y_{c} = \\mathbf{a} \\cdot \\mathbf{c}</span>, <span class="math">\\pi_{b} \\gets \\mathsf{IP.Prove}(\\mathsf{srs}, \\mathbf{a}, \\mathbf{b}, y_{b})</span> and <span class="math">\\pi_{c} \\gets \\mathsf{IP.Prove}(\\mathsf{srs}, \\mathbf{a}, \\mathbf{c}, y_{c})</span>, where <span class="math">\\pi_{b} = ([R_{b}(\\tau)]_{1}, [H_{b}(\\tau)]_{1}, [\\hat{R}_{b}(\\tau)]_{1})</span>, <span class="math">\\pi_{c} = ([R_{c}(\\tau)]_{1}, [H_{c}(\\tau)]_{1}, [\\hat{R}_{c}(\\tau)]_{1})</span> are such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{i=1}^{m} a_{i} X^{i-1}\\right) \\left(\\sum_{i=1}^{m} b_{i} X^{m-i}\\right) - y_{b} X^{m-1} = R_{b}(X) + X^{m} H_{b}(X),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{i=1}^{m} a_{i} X^{i-1}\\right) \\left(\\sum_{i=1}^{m} c_{i} X^{m-i}\\right) - y_{c} X^{m-1} = R_{c}(X) + X^{m} H_{c}(X),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{and} \\hat{R}_{b}(X) = X^{2} R_{b}(X), \\hat{R}_{c}(X) = X^{2} R_{c}(X).</span></div>

    <p class="text-gray-300">In order to compute a proof that <span class="math">\\mathbf{a} \\cdot (\\alpha \\mathbf{b} + \\beta \\mathbf{c}) = \\alpha y_{b} + \\beta y_{c}</span>, the prover proceeds as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\left(\\sum_{i=1}^{m} a_{i} X^{i-1}\\right) \\left(\\alpha \\sum_{i=1}^{m} b_{i} X^{m-i} + \\beta \\sum_{i=1}^{m} c_{i} X^{m-i}\\right) = \\\\ = \\alpha \\left(\\sum_{i=1}^{m} a_{i} X^{i-1}\\right) \\left(\\sum_{i=1}^{m} b_{i} X^{m-i}\\right) + \\beta \\left(\\sum_{i=1}^{m} a_{i} X^{i-1}\\right) \\left(\\sum_{i=1}^{m} c_{i} X^{m-i}\\right) \\\\ = \\alpha \\left(y_{b} X^{m-1} + R_{b}(X) + X^{m} H_{b}(X)\\right) + \\beta \\left(y_{c} X^{m-1} + R_{c}(X) + X^{m} H_{c}(X)\\right) \\\\ = (\\alpha y_{b} + \\beta y_{c}) X^{m-1} + (\\alpha R_{b}(X) + \\beta R_{c}(X)) + X^{m} (\\alpha H_{b}(X) + \\beta H_{c}(X)), \\end{aligned}</span></div>

    <p class="text-gray-300">and therefore for <span class="math">y = \\alpha y_{b} + \\beta y_{c}</span> it outputs <span class="math">\\pi = ([R(\\tau)]_{1}, [H(\\tau)]_{1}, [\\hat{R}(\\tau)]_{1})</span> where <span class="math">R(X) = \\alpha R_{b}(X) + \\beta R_{c}(X)</span>, <span class="math">H(X) = \\alpha H_{b}(X) + \\beta H_{c}(X)</span> and <span class="math">\\hat{R}(X) = X^{2} R(X) = \\alpha X^{2} R_{b}(X) + \\beta X^{2} R_{c}(X) = \\alpha \\hat{R}_{b}(X) + \\beta \\hat{R}_{c}(X)</span>, i.e., <span class="math">\\pi = \\alpha \\pi_{b} + \\beta \\pi_{c}</span>.</p>

    <p class="text-gray-300"><strong>Homomorphic Openings.</strong> The proof for homomorphic openings work analogous as the previous case. Indeed, for <span class="math">y_{a} = \\mathbf{a} \\cdot \\mathbf{c}</span>, <span class="math">y_{b} = \\mathbf{b} \\cdot \\mathbf{c}</span> and <span class="math">\\pi_{a} \\leftarrow \\text{IP.Prove}(\\mathbf{srs}, \\mathbf{a}, \\mathbf{b}, y_{a})</span>, <span class="math">\\pi_{c} \\leftarrow \\text{IP.Prove}(\\mathbf{srs}, \\mathbf{c}, \\mathbf{b}, y_{c})</span>, <span class="math">\\pi_{a} = ([R_{a}(\\tau)]_{1}, [H_{a}(\\tau)]_{1}, [\\hat{R}_{a}(\\tau)]_{1})</span>, <span class="math">\\pi_{c} = ([R_{c}(\\tau)]_{1}, [H_{c}(\\tau)]_{1}, [\\hat{R}_{c}(\\tau)]_{1})</span>, it is enough to see that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\left(\\alpha \\sum_{i=1}^{m} a_{i} X^{i-1} + \\beta \\sum_{i=1}^{m} c_{i} X^{i-1}\\right) \\left(\\sum_{i=1}^{m} b_{i} X^{m-i}\\right) \\\\ = \\alpha \\left(y_{a} X^{m-1} + R_{a}(X) + X^{m} H_{a}(X)\\right) + \\beta \\left(y_{c} X^{m-1} + R_{c}(X) + X^{m} H_{c}(X)\\right) \\\\ = (\\alpha y_{a} + \\beta y_{c}) X^{m-1} + (\\alpha R_{a}(X) + \\beta R_{c}(X)) + X^{m} (\\alpha H_{a}(X) + \\beta H_{c}(X)), \\end{aligned}</span></div>

    <p class="text-gray-300">and the rest of the proof is the same as the one for homomorphic openings.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> The construction above satisfies Strong Function Binding in the AGM under the dlog Assumption.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We will proceed through a series of games, and we set <span class="math">\\mathsf{Game}_0</span> to be the strong binding game of Definition 3. Let <span class="math">\\mathcal{A}</span> be an adversary against it, whose advantage is <span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{s},\\mathsf{binding}}</span>. We define <span class="math">\\mathsf{Game}_1</span> and specify a reduction <span class="math">\\mathcal{B}_1</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{s},\\mathsf{binding}} \\leq \\mathsf{Adv}_{\\mathcal{B}_1}^{\\mathsf{qDHE}} + \\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_1}.</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Game}_1</span> be the game that goes exactly as <span class="math">\\mathsf{Game}_0</span> except that, upon receiving <span class="math">[R]_1, [\\hat{R}]_1</span> from <span class="math">\\mathcal{A}</span>, it checks whether <span class="math">\\deg(R) \\leq m - 2</span>, where <span class="math">R(X)</span> is the algebraic representation of <span class="math">[R]_1</span> and aborts if it is not. If <span class="math">\\mathcal{A}</span> wins <span class="math">\\mathsf{Game}_0</span> but not <span class="math">\\mathsf{Game}_1</span>, then we construct <span class="math">\\mathcal{B}_1</span> that extracts <span class="math">R(X) = \\sum_{s=0}^{m} r_s X^s</span> as the algebraic representation of <span class="math">[R]_1</span> where <span class="math">\\hat{r}_s \\neq 0</span> for <span class="math">s = m - 1</span> or <span class="math">s = m</span>. Then, <span class="math">\\mathcal{B}_1</span> sets <span class="math">\\hat{R}&#x27;(X) = X^2 R(X) = \\sum_{s=0}^{m} \\hat{r}_s X^{2+s}</span>. Note that, from the second verification equation <span class="math">[\\hat{R}&#x27;(\\tau)]_1 = [\\hat{R}]_1</span>.</p>

    <p class="text-gray-300">Now, <span class="math">\\mathcal{B}_1</span> outputs <span class="math">\\left([\\hat{R}]_1 - [R&#x27;(\\tau)]_1\\right) \\frac{1}{r_s} = [\\tau^{2+s}]_1</span>, winning <span class="math">q</span> DHE as <span class="math">2 + s &amp;gt; m</span>, the highest available power of <span class="math">\\tau</span> in <span class="math">\\mathbb{G}_1</span>. Thus,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{s},\\mathsf{binding}} = \\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{Game}_1} + \\mathsf{Adv}_{\\mathcal{B}_1}^{\\mathsf{qDHE}}.</span></div>

    <p class="text-gray-300">Now, we prove that the advantage of <span class="math">\\mathcal{A}</span> in <span class="math">\\mathsf{Game}_1</span> is negligible. We define <span class="math">C_a(X) = \\sum_{j=1}^{m+1} a_j X^{j-1}</span> the algebraic representation of <span class="math">\\mathsf{C}_a</span> and set <span class="math">P(X) = C_a(X) C_b(X) - y X^{m-1} - R(X) - Q(X) z_H(X)</span> and the first verification equation says that, either <span class="math">\\tau</span> is a root of <span class="math">P(X)</span>, or <span class="math">P(X) \\equiv 0</span>. If the latter is the case, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{j=1}^{m+1} a_{j} X^{j-1}\\right) \\left(\\sum_{j=1}^{m} b_{j} X^{m-j}\\right) - y X^{m-1} = R(X) + X^{m} Q(X).</span></div>

    <p class="text-gray-300">The left side equals <span class="math">\\sum_{j=1}^{m}\\sum_{j=1}^{m}a_{j}b_{j}X^{i-1+m-j}-yX^{m-1}+a_{m+1}X^{m}\\sum_{j=1}^{m}b_{j}X^{m-j}</span>. Because <span class="math">\\deg(R)&lt;m-1</span> and <span class="math">\\deg(X^{m}Q(X))&gt;m-1</span>, we have that the right side of the equation has coefficient zero for <span class="math">X^{m-1}</span> and so does the left side then. Thus, <span class="math">\\sum_{j=1}^{m}a_{j}b_{j}X^{m-1}-yX^{m-1}=0</span>, which happens if and only if <span class="math">\\sum_{j=1}^{m}a_{j}b_{j}-y=0</span>. Namely, there exists <span class="math">\\mathbf{a}=(a_{j})_{j=1}^{m}</span> such that <span class="math">\\mathbf{a}\\cdot\\mathbf{b}=y</span>, and <span class="math">\\mathcal{A}</span> looses <span class="math">\\mathsf{Game}_{1}</span>.</p>

    <p class="text-gray-300">Then, it must be the case that <span class="math">P(X)\\neq 0</span> and <span class="math">P(\\tau)=0</span>. As in the proof of the previous theorem, we construct an adversary <span class="math">\\mathcal{B}_{2}</span> against the <span class="math">dlog</span> assumption. On input <span class="math">[\\tau]_{1}</span>, <span class="math">\\mathcal{B}_{2}</span> calculates all the roots of <span class="math">P(X)</span> and checks, in polynomial time, which is the one that encoded in <span class="math">\\mathbb{G}_{1}</span> equals <span class="math">[\\tau]_{1}</span>. Thus,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{x},\\mathsf{binding}}\\leq\\mathsf{Adv}_{\\mathcal{B}_{1}}^{\\mathsf{qDHE}}+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{\\mathit{dlog}}.</span></p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Updates Without Hints.</h4>

    <p class="text-gray-300">We remark that we do not need any additional update keys added to the setup. Indeed, the update key is made by proofs of inner products between cannonic vectors <span class="math">\\mathbf{e}_{i}\\cdot\\mathbf{e}_{i}=1</span> or <span class="math">\\mathbf{e}_{i}\\cdot\\mathbf{e}_{j}=0</span>. In our construction for encodings in the monomial basis, a proof that <span class="math">\\mathbf{e}_{i}\\cdot\\mathbf{e}_{i}=1</span> consists on <span class="math">R(X)=H(X)=0</span>. On the other hand, to prove that <span class="math">\\mathbf{e}_{i}\\cdot\\mathbf{e}_{j}=0</span> for <span class="math">i\\neq j</span> the proof is (the evaluation in the group of) either <span class="math">R(X)=X^{m+i-j}</span> if <span class="math">j&gt;i</span>, or <span class="math">H(X)=X^{i-j}</span> if <span class="math">i&gt;j</span>. As such powers of <span class="math">\\tau</span> are already included in <span class="math">\\mathsf{prk}</span>, <span class="math">\\mathsf{upk}\\subseteq\\mathsf{prk}</span>.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">5.2 Lagrange Basis</h3>

    <p class="text-gray-300">In this second scheme, for a Lagrange basis <span class="math">\\{\\lambda_{i}(X)\\}_{i=1}^{m}</span> over a multiplicative group <span class="math">\\mathbb{H}=\\{\\mathsf{h}_{1},\\ldots,\\mathsf{h}_{m}\\}</span> of size <span class="math">m</span> in <span class="math">\\mathbb{F}</span> we encode a vector <span class="math">\\mathbf{a}\\in\\mathbb{F}^{m}</span> as a polynomial <span class="math">a(X)=\\sum_{i=1}^{m}a_{i}\\lambda_{i}(X)</span>. The construction uses few properties of Lagrange basis over multiplicative groups that we would like to remind before formally presenting our scheme. When <span class="math">\\mathbb{H}</span> is a multiplicative subgroup, <span class="math">\\lambda_{i}(0)=m^{-1}</span> for all <span class="math">i\\in[m]</span>. Moreover, if <span class="math">\\mathbb{H}=\\{\\mathsf{h}_{i}\\}_{i=1}^{m}</span> consists oof the roots of unity of order <span class="math">m</span>, then <span class="math">\\lambda_{i}(\\mathsf{h}_{i})=1</span> and <span class="math">\\lambda_{i}(\\mathsf{h}_{j})=0</span> for <span class="math">i\\neq j</span> and for the vanishing polynomial <span class="math">t(X)=\\prod_{i=1}^{m}(X-\\mathsf{h}_{i})</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\lambda_{i}(X)\\lambda_{j}(X)\\equiv 0\\mod t(X),\\qquad\\lambda_{i}(X)^{2}\\equiv\\lambda_{i}(X)\\mod t(X).</span></p>

    <p class="text-gray-300">The construction below, presented in <em>[30]</em>, exploits these properties in the proof of openings for inner-products:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.KeyGen}(1^{\\lambda},\\mathcal{F}_{\\mathsf{IP}_{m}})\\to(\\mathsf{prk},\\mathsf{vrk})</span>:</p>

    <p class="text-gray-300">Generate group description <span class="math">\\mathsf{gk}=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)\\leftarrow\\mathcal{G}(p)</span></p>

    <p class="text-gray-300">Define multiplicative group <span class="math">\\mathbb{H}=\\{\\mathsf{h}_{1},\\ldots,\\mathsf{h}_{m}\\}</span> in <span class="math">\\mathbb{F}</span></p>

    <p class="text-gray-300">Compute Lagrange polynomials <span class="math">\\{\\lambda_{j}(X)\\}_{j=1}^{m}</span> over <span class="math">\\mathbb{H}</span>.</p>

    <p class="text-gray-300">Sample <span class="math">\\tau\\leftarrow\\mathbb{F}</span></p>

    <p class="text-gray-300">Output <span class="math">\\mathsf{prk}=\\big{(}\\{[\\tau^{i}]_{1,2},[\\lambda_{i}(\\tau)]_{1}\\}_{i=1}^{m}\\big{)}</span> and <span class="math">\\mathsf{vrk}=\\big{(}[1]_{1,2},\\big{\\{}[\\tau^{i}]_{2},[\\lambda_{i}(\\tau)]_{2}\\big{\\}}_{i=1}^{m}\\big{\\}}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.Commit}(\\mathsf{prk},\\mathbf{a})\\to(\\mathsf{C}_{a},\\mathsf{aux})</span>: Compute <span class="math">\\mathsf{C}_{a}=\\sum_{i=1}^{m}a_{i}[\\lambda_{i}(\\tau)]_{1}</span> and output <span class="math">(\\mathsf{C}_{a},\\mathbf{a})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.Open}(\\mathsf{prk},\\mathsf{aux},\\mathbf{b},y)\\to\\pi</span> :</p>

    <p class="text-gray-300">Find <span class="math">R(X),H(X)</span> such that <span class="math">\\deg(R)&lt;m-1</span> and</p>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i=1}^{m}a_{i}\\lambda_{i}(X)\\right)\\left(\\sum_{i=1}^{m}b_{i}\\lambda_{i}(X)\\right)-m^{-1}y=XR(X)+t(X)H(X)</span></p>

    <p class="text-gray-300">Define <span class="math">\\hat{R}(X)=X^{2}R(X)</span> and output <span class="math">\\pi=([R(\\tau)]_{1},[H(\\tau)]_{1},[\\hat{R}(\\tau)]_{1})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{IP.Vf}(\\mathsf{vrk},\\mathsf{C}_{a},\\mathbf{b},y,\\pi)\\to 0/1</span> : Calculate <span class="math">\\mathsf{C}_{b}=\\sum_{i=1}^{m}b_{i}[\\lambda_{i}(\\tau)]_{2}</span></p>

    <p class="text-gray-300">Parse <span class="math">\\pi=([R]_{1},[H]_{1},[\\hat{R}]_{1})</span> and output <span class="math">1</span> if and only if</p>

    <p class="text-gray-300"><span class="math">e\\big{(}\\mathsf{C}_{a},\\mathsf{C}_{b}\\big{)}-e\\big{(}m^{-1}y[1]_{1},[1]_{2}\\big{)}=e\\big{(}[R]_{1},[1]_{2}\\big{)}+e\\big{(}[H]_{1},[t(\\tau)]_{2}\\big{)},\\text{ and }</span> <span class="math">e\\big{(}[R]_{1},[\\tau^{2}]_{2}\\big{)}=e\\big{(}[\\hat{R}]_{1},[1]_{2}\\big{)}.</span></p>

    <p class="text-gray-300">We omit the proof of completeness as it can be found in <em>[30]</em>. Still, since there it is presented as an NIZK argument for inner-product relations as opposite to LVC scheme as considered in this paper, we prove Strong Function Binding and homomorphic proofs and openings below.</p>

    <p class="text-gray-300">Theorem 5. The construction above has Homomorphic Proofs and Openings.</p>

    <p class="text-gray-300">Proof. Completeness follows from simple inspection.</p>

    <p class="text-gray-300">Homomorphic Proofs. Let  <span class="math">y_{b} = \\mathbf{a} \\cdot \\mathbf{b}</span> ,  <span class="math">y_{c} = \\mathbf{a} \\cdot \\mathbf{c}</span> ,  <span class="math">\\pi_{b} \\gets \\mathsf{IP.Prove}(\\mathsf{srs}, \\mathbf{a}, \\mathbf{b}, y_{b})</span>  and  <span class="math">\\pi_{c} \\gets \\mathsf{IP.Prove}(\\mathsf{srs}, \\mathbf{a}, \\mathbf{c}, y_{c})</span> , where  <span class="math">\\pi_{b} = ([R_{b}(\\tau)]_{1}, [H_{b}(\\tau)]_{1}, [\\hat{R}_{b}(\\tau)]_{1})</span> ,  <span class="math">\\pi_{c} = ([R_{c}(\\tau)]_{1}, [H_{c}(\\tau)]_{1}, [\\hat{R}_{c}(\\tau)]_{1})</span>  are such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\sum_ {i = 1} ^ {m} a _ {i} \\lambda_ {i} (X)\\right) \\left(\\sum_ {i = 1} ^ {m} b _ {i} \\lambda_ {i} (X)\\right) - m ^ {- 1} y _ {b} = X R _ {b} (X) + t (X) H _ {b} (X), \\\\ \\left(\\sum_ {i = 1} ^ {m} a _ {i} \\lambda_ {i} (X)\\right) \\left(\\sum_ {i = 1} ^ {m} c _ {i} \\lambda_ {i} (X)\\right) - m ^ {- 1} y _ {c} = X R _ {c} (X) + t (X) H _ {c} (X), \\\\ \\text {a n d} \\hat {R} _ {b} (X) = X ^ {2} R _ {b} (X), \\hat {R} _ {c} (X) = X ^ {2} R _ {c} (X). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In order to compute a proof that  <span class="math">\\mathbf{a} \\cdot (\\alpha \\mathbf{b} + \\beta \\mathbf{c}) = \\alpha y_{b} + \\beta y_{c}</span> , the prover proceeds as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\sum_ {i = 1} ^ {m} a _ {i} \\lambda_ {i} (X)\\right) \\left(\\alpha \\sum_ {i = 1} ^ {m} b _ {i} \\lambda_ {i} (X) + \\beta \\sum_ {i = 1} ^ {m} c _ {i} \\lambda_ {i} (X)\\right) \\\\ = \\alpha \\left(\\sum_ {i = 1} ^ {m} a _ {i} \\lambda_ {i} (X)\\right) \\left(\\sum_ {i = 1} ^ {m} b _ {i} \\lambda_ {i} (X)\\right) + \\beta \\left(\\sum_ {i = 1} ^ {m} a _ {i} \\lambda_ {i} (X)\\right) \\left(\\sum_ {i = 1} ^ {m} c _ {i} \\lambda_ {i} (X)\\right) \\\\ = \\alpha \\left(m ^ {- 1} y _ {b} + X R _ {b} (X) + t (X) H _ {b} (X)\\right) + \\beta \\left(m ^ {- 1} y _ {c} + X R _ {c} (X) + t (X) H _ {c} (X)\\right) \\\\ = m ^ {- 1} \\left(\\alpha y _ {b} + \\beta y _ {c}\\right) + X \\left(\\alpha R _ {b} (X) + \\beta R _ {c} (X)\\right) + t (X) \\left(\\alpha H _ {b} (X) + \\beta H _ {c} (X)\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and therefore for  <span class="math">y = \\alpha y_{b} + \\beta y_{c}</span>  it outputs  <span class="math">\\pi = ([R(\\tau)]_1, [H(\\tau)]_1, [\\hat{R}(\\tau)]_1)</span>  where  <span class="math">R(X) = \\alpha R_{b}(X) + \\beta R_{c}(X)</span> ,  <span class="math">H(X) = \\alpha H_{b}(X) + \\beta H_{c}(X)</span>  and  <span class="math">\\hat{R}(X) = X^2 R(X) = \\alpha X^2 R_{b}(X) + \\beta X^2 R_{c}(X) = \\alpha \\hat{R}_{b}(X) + \\beta \\hat{R}_{c}(X)</span> , i.e.,  <span class="math">\\pi = \\alpha \\pi_{b} + \\beta \\pi_{c}</span> .</p>

    <p class="text-gray-300">Homomorphic Openings. The proof for homomorphic openings work analogous as the previous case. Indeed, for  <span class="math">y_{a} = \\mathbf{a} \\cdot \\mathbf{c}</span> ,  <span class="math">y_{b} = \\mathbf{b} \\cdot \\mathbf{c}</span>  and  <span class="math">\\pi_{a} \\gets \\mathsf{IP.Prove}(\\mathsf{srs}, \\mathbf{a}, \\mathbf{b}, y_{a})</span> ,  <span class="math">\\pi_{c} \\gets \\mathsf{IP.Prove}(\\mathsf{srs}, \\mathbf{c}, \\mathbf{b}, y_{c})</span> , it is enough to see that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\alpha \\sum_ {i = 1} ^ {m} a _ {i} \\lambda_ {i} (X) + \\beta \\sum_ {i = 1} ^ {m} c _ {i} \\lambda_ {i} (X)\\right) \\left(\\sum_ {i = 1} ^ {m} b _ {i} \\lambda_ {i} (X)\\right) \\\\ = \\alpha \\left(\\sum_ {i = 1} ^ {m} a _ {i} \\lambda_ {i} (X)\\right) \\left(\\sum_ {i = 1} ^ {m} b _ {i} \\lambda_ {i} (X)\\right) + \\beta \\left(\\sum_ {i = 1} ^ {m} c _ {i} \\lambda_ {i} (X)\\right) \\left(\\sum_ {i = 1} ^ {m} b _ {i} \\lambda_ {i} (X)\\right) \\\\ = \\alpha \\left(m ^ {- 1} y _ {a} + X R _ {a} (X) + t (X) H _ {a} (X)\\right) + \\beta \\left(m ^ {- 1} y _ {c} + X R _ {c} (X) + t (X) H _ {c} (X)\\right) \\\\ = m ^ {- 1} \\left(\\alpha y _ {a} + \\beta y _ {c}\\right) + X \\left(\\alpha R _ {a} (X) + \\beta R _ {c} (X)\\right) + t (X) \\left(\\alpha H _ {a} (X) + \\beta H _ {c} (X)\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and the rest of the proof is the same as the one for homomorphic openings.</p>

    <p class="text-gray-300">Theorem 6. The construction above satisfies Strong Function Binding in the AGM under the dlog Assumption.</p>

    <p class="text-gray-300">Proof. We will proceed through a series of games, and we set  <span class="math">\\mathsf{Game}_0</span>  to be the strong binding game of Definition 3. Let  <span class="math">\\mathcal{A}</span>  be an adversary against it in our scheme, whose advantage is  <span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{x},\\mathsf{binding}}</span> . Note that the second verification equation in our scheme is the same as in the scheme using the monomial basis, so we define  <span class="math">\\mathsf{Game}_1</span>  and the reduction  <span class="math">\\mathcal{B}_1</span>  as in the proof of Theorem 4, and have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathcal {A}} ^ {\\mathrm {x}, \\text {b i n d i n g}} \\leq \\operatorname {A d v} _ {\\mathcal {B} _ {1}} ^ {\\mathrm {d l o g}} + \\operatorname {A d v} _ {\\mathcal {A}} ^ {\\mathrm {G a m e} _ {1}}.</span></div>

    <p class="text-gray-300">Now, we prove that the advantage of  <span class="math">\\mathcal{A}</span>  in  <span class="math">\\mathsf{Game}_1</span>  is negligible. Indeed, let  <span class="math">C_a(X) = \\sum_{j=1}^{m} a_j \\lambda_j(X) + X^m \\hat{a}</span> ,  <span class="math">R(X)</span>  and  <span class="math">Q(X)</span>  be the algebraic representations of  <span class="math">\\mathsf{C}_a</span> ,  <span class="math">[R]_1</span>  and  <span class="math">[Q]_1</span> , and recall  <span class="math">\\deg(R) \\leq m - 2</span>  while  <span class="math">\\deg(C_a)</span> ,  <span class="math">\\deg(Q) \\leq m</span> .</p>

    <p class="text-gray-300">We set  <span class="math">P(X) = C_a(X)C_b(X) - m^{-1}y - XR(X) - Q(X)z_H(X)</span> , the first verification equation says that  <span class="math">P(\\tau) = 0</span> , which means either that (i)  <span class="math">P(X)</span>  is the zero polynomial, or (ii)  <span class="math">\\tau</span>  is a root of it. Assume for now that  <span class="math">P(X) \\equiv 0</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {j = 1} ^ {m} a _ {j} \\lambda_ {j} (X) + X ^ {m} \\hat {a}\\right) \\left(\\sum_ {j = 1} ^ {m} b _ {j} \\lambda_ {j} (X)\\right) = m ^ {- 1} y + X R (X) + z _ {H} (X) Q (X)</span></div>

    <p class="text-gray-300">Because <span class="math">deg(R)\\leq m-2</span>, we know <span class="math">z_{H}(X)</span> does not divide <span class="math">XR(X)</span> and since for all <span class="math">i\\neq j</span> <span class="math">\\lambda_{i}(X)\\lambda_{j}(X)\\equiv 0\\mod z_{H}(X)</span> and <span class="math">\\lambda_{i}^{2}(X)\\equiv\\lambda_{i}(X)\\mod z_{H}(X)</span>, we have that <span class="math">\\left(\\sum_{j=1}^{m}a_{j}\\lambda_{j}(X)\\right)\\left(\\sum_{j=1}^{m}b_{j}\\lambda_{j}(X)\\right)=\\sum_{j=1}^{m}a_{j}b_{j}\\lambda_{j}(X)\\mod z_{H}(X)</span>. Then,</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=1}^{m}a_{j}b_{j}\\lambda_{j}(X)+X^{m}\\hat{a}\\sum_{j=1}^{m}b_{j}\\lambda_{j}(X)=m^{-1}y+XR(X)</span></p>

    <p class="text-gray-300">and thus <span class="math">m^{-1}y=\\sum_{j=1}^{m}a_{j}b_{j}\\lambda_{j}(0)</span>. As <span class="math">\\mathbb{H}</span> is a multiplicative subgroup, <span class="math">\\lambda_{j}(0)=m^{-1}</span> for all <span class="math">j\\in[m]</span> and thus <span class="math">\\sum_{j=1}^{m}a_{j}b_{j}=y</span>. Namely, there exists <span class="math">\\mathbf{a}=(a_{j})_{j=1}^{m}</span> such that <span class="math">\\mathbf{a}\\cdot\\mathbf{b}=y</span>, and <span class="math">\\mathcal{A}</span> looses <span class="math">\\mathsf{Game}_{1}</span>.</p>

    <p class="text-gray-300">Then, it must be the case that <span class="math">P(X)\\neq 0</span> and <span class="math">P(\\tau)=0</span>. We construct an adversary <span class="math">\\mathcal{B}_{2}</span> against the <em>dlog</em> assumption. On input <span class="math">[\\tau]_{1}</span>, <span class="math">\\mathcal{B}_{2}</span> calculates all the roots of <span class="math">P(X)</span> and checks, in polynomial time, which is the one that encoded in <span class="math">\\mathbb{G}_{1}</span> equals <span class="math">[\\tau]_{1}</span>. Thus,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathcal{A}}^{\\mathsf{v},\\mathsf{binding}}\\leq\\mathsf{Adv}_{\\mathcal{B}_{1}}^{2^{\\text{DHE}}}+\\mathsf{Adv}_{\\mathcal{B}_{2}}^{dlog}.</span></p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Updatability with Short Keys</h4>

    <p class="text-gray-300">In this construction, a proof that <span class="math">\\mathbf{e}_{i}\\cdot\\mathbf{e}_{i}=1</span> is the encoding in a group of the polynomial <span class="math">R_{i}(\\tau)</span>, for <span class="math">R_{i}(X)=(\\lambda_{i}(X)-1)/X</span>. On the other hand, the proof that <span class="math">\\mathbf{e}_{i}\\cdot\\mathbf{e}_{j}=0</span> for <span class="math">i\\neq j</span> is <span class="math">[H(\\tau)]_{1}</span>, for <span class="math">H(X)=((\\lambda_{i}(X)\\lambda_{j}(X))/t(X)</span>. Including the evaluation of all these polynomials in <span class="math">\\mathsf{upk}</span> would require a <span class="math">\\mathsf{srs}</span> of quadratic size. Still, as noted in <em>[33]</em>,</p>

    <p class="text-gray-300"><span class="math">\\frac{\\lambda_{i}(X)\\lambda_{j}(X)}{t(X)}=\\frac{t(X)}{(X-\\mathsf{h}_{i})(X-\\mathsf{h}_{j})},</span></p>

    <p class="text-gray-300">and can be computed as</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{\\mathsf{h}_{i}-\\mathsf{h}_{j}}\\left(\\frac{t(X)}{X-\\mathsf{h}_{i}}+\\frac{t(X)}{X-\\mathsf{h}_{j}}\\right).</span></p>

    <p class="text-gray-300">Therefore, it is enough to include in <span class="math">\\mathsf{upk}</span> the evaluations of <span class="math">(\\lambda_{i}(X)-1)/X</span> for the proofs of same position and then the evaluations of <span class="math">\\{t(X)/(X-\\mathsf{h}_{i})\\}_{i=1}^{m}</span>, so the verifier can reconstruct the one of <span class="math">\\lambda_{i}(X)\\lambda_{j}(X)/t(X)</span> from there, requiring only <span class="math">2m</span> elements instead of <span class="math">m^{2}</span>.</p>

    <h2 id="sec-40" class="text-2xl font-bold">6 Subvector Openings</h2>

    <p class="text-gray-300">In this section, we present schemes for VC with Subvector Openings (SVC), starting from the constructions of Section 5. Instead of using Def. 9, we will consider SVC as a special case of LVC. The class of functions that open a set of positions <span class="math">I=\\{i_{1},\\ldots,i_{n}\\}</span> of a committed vector <span class="math">\\mathbf{v}\\in\\mathbb{F}^{m}</span> is given by the linear-map <span class="math">f_{I}</span> with</p>

    <p class="text-gray-300"><span class="math">f_{I}:\\mathbb{F}^{m}\\to\\mathbb{F}^{n},\\qquad f_{I}(\\mathbf{v})=(\\mathbf{e}_{i_{1}}\\cdot\\mathbf{v},\\ldots\\mathbf{e}_{i_{n}}\\cdot\\mathbf{v})</span></p>

    <p class="text-gray-300">where for each <span class="math">k\\in[n]</span>, <span class="math">e_{i_{k}}</span> is the <span class="math">i_{k}</span>th vector of the canonical basis <span class="math">\\mathbb{F}^{m}</span>.</p>

    <p class="text-gray-300">Naturally, for a vector <span class="math">\\mathbf{v}\\in\\mathbb{F}^{m}</span>, we can construct proofs of openings of subvectors <span class="math">\\mathbf{v}_{I}=(v_{i})_{i\\in I}</span> by aggregating different inner product proofs for vectors <span class="math">\\mathbf{e}_{i_{k}}</span> for <span class="math">i_{k}\\in I</span> using the techniques in Section 4.1. We refer to these aggregated proofs as <em>non-native</em> subvector openings, given that they require a random oracle and in particular, are no longer algebraic and homomorphic. As opposed to them, we call <em>native</em> subvector opening, a scheme that is algebraic and homomorphic.</p>

    <p class="text-gray-300">In what follows, we improve on Subvector Openings in some special scenarios, achieving native aggregation for new schemes and reducing the verifier complexity in existing ones.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">6.1 Native SV Openings for the Monomial Basis</h3>

    <p class="text-gray-300">For the construction of Section 5.1, we introduce native subvector openings for subsets with consecutive position <span class="math">I=\\{i,i+1,\\ldots,i+k\\}</span>. That is, for <span class="math">\\mathbf{\\tilde{c}}=(c_{i})_{i\\in I}</span> such that there exist <span class="math">\\mathbf{u}_{1},\\mathbf{u}_{2}</span> with <span class="math">\\mathbf{c}=(\\mathbf{u}_{1},\\mathbf{\\tilde{c}},\\mathbf{u}_{2})</span>. To prove an opening of <span class="math">\\mathbf{\\tilde{c}}</span>, we only need commitments to <span class="math">R(X)=\\sum_{s=1}^{i-1}c_{i}X^{m-i+s-1}</span> and <span class="math">H(X)=\\sum_{s=1}^{i-1}\\mathbf{u}_{s}(x)\\mathbf{u}_{s+1}</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{i=i+k+1}^{m}c_{m-i+s+1}X^{s-1}</span>, which are shifted-encodings of <span class="math">\\mathbf{u}_{1}</span>, <span class="math">\\mathbf{u}_{2}</span>. The verifier checks that <span class="math">\\deg(R)&lt;m-1</span>, computes <span class="math">\\tilde{C}(X)=\\sum_{s=i}^{i+k}\\tilde{c}_{s}X^{s-i}</span> and <span class="math">\\tilde{\\mathsf{C}}=[\\tilde{C}(\\tau)]_{1}</span> and checks whether</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{C}-\\tilde{\\mathsf{C}},[\\tau^{m-i}]_{1})=e([R]_{1},[1]_{2})+e([H]_{1},[\\tau^{m+k}]_{2}).</span></p>

    <p class="text-gray-300">Note that, given individual proofs of openings as in Section 5.1, that is, <span class="math">[R_{s}(\\tau)]_{1},[H_{s}(\\tau)]_{1}</span> such that <span class="math">C(X)X^{m-s}-c_{s}X^{m-1}=R_{s}(X)+X^{m}H_{s}(X)</span> and <span class="math">\\deg(R_{s})&lt;m-1</span>, for the commitments defined above we have <span class="math">[R]_{1}=[R_{i}(\\tau)]_{1}</span> and <span class="math">[H]_{1}=[H_{i+k}(\\tau)]_{1}</span>, that is, proofs can be aggregated at no cost for the prover.</p>

    <p class="text-gray-300">We implement this scheme and compare it with opening consecutive positions, or ranges, using Merkle trees in Appendix 7.2.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">6.2 Non-native SV Openings for the Monomial Basis</h3>

    <p class="text-gray-300">For the LVC scheme of Section 5.1, the techniques of Section 4.1 allow us to redefine the Open and Vf algorithms to work for an arbitrary subset of positions <span class="math">I\\subset[m]</span>. More specifically, the prover will simply run IP.Open(prk, aux, <span class="math">\\mathbf{e}_{i_{k}},\\mathbf{v}</span>) for <span class="math">k=1,\\ldots,n</span> to obtain <span class="math">(v_{i_{k}},\\pi_{i_{k}})</span> and <span class="math">\\pi_{i_{k}}</span> a proof of correct computation of <span class="math">v_{i_{k}}</span>. Then, use the random oracle to sample a randomness <span class="math">\\gamma\\in\\mathbb{F}</span> and output <span class="math">\\pi_{I}=\\sum_{k=1}^{n}\\gamma^{k-1}\\pi_{i_{k}}</span>.</p>

    <p class="text-gray-300">The verifier will receive <span class="math">\\pi_{I}=([R]_{1},[H]_{1},[\\hat{R}]_{1})</span>, compute <span class="math">y=\\sum_{k=1}^{n}\\gamma^{k-1}v_{i_{k}}</span>, and check as before <span class="math">e([R]_{1},[\\tau]_{2})=e([\\hat{R}]_{1},[1]_{2})</span> and</p>

    <p class="text-gray-300"><span class="math">e\\left(\\mathsf{C},\\sum_{k=1}^{n}\\gamma^{k-1}[\\tau^{m-i_{k}}]_{2}\\right)-e\\left(y[\\tau^{m-1}]_{1},[1]_{2}\\right)=e\\left([R]_{1},[1]_{2}\\right)+e\\left([H]_{1},[\\tau^{m}]_{2}\\right).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that verifier’s work is dominated by the computation of <span class="math">\\sum_{k=1}^{n}\\gamma^{k-1}[\\tau^{m-i_{k}}]_{2}</span>, so we analyze for which sets <span class="math">I\\subset[m]</span> this computation can be cheaper than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\mathbb{G}_{2}<span class="math">-exponentiations. Without loss of generality, we can re-assign </span>\\gamma^{k-1}\\to\\gamma^{m-i_{k}}<span class="math">, and thus our verifier now needs to compute </span>\\sum_{k=1}^{n}[(\\gamma X)^{m-i_{k}}]_{2}=\\sum_{i\\in I}[(\\gamma X)^{m-i}]_{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, note that if <span class="math">I_{k,s,n}\\subset[m]</span> is an arithmetic progression, i.e. it is such that for a given ratio <span class="math">s</span>, a starting power <span class="math">k</span> and a number <span class="math">n</span> of desired elements, <span class="math">I_{k,s,n}=\\{k,s+k,\\ldots,(n-1)s+k\\}</span>, then</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in I_{k,s,n}}(\\gamma X)^{m-i}=(\\gamma X)^{k}\\frac{1-(\\gamma X)^{n}}{1-(\\gamma X)^{s}}.</span></p>

    <p class="text-gray-300">This reduces the work of the verifier to compute <span class="math">\\sum_{i\\in I_{k,s,n}}(\\gamma X)^{m-i}</span> to constant. Note that the verifier cannot compute <span class="math">(1-(\\gamma X)^{s})^{-1}</span>, so we multiply all the terms of the equation by <span class="math">1-(\\gamma X)^{s}</span>. I.e, the verifier computes <span class="math">y=\\sum_{i\\in I_{k,s,n}}\\gamma^{m-i}y_{i}</span> and checks whether</p>

    <p class="text-gray-300">\\[ e\\bigl{(}[C]_{1},\\gamma^{k}[\\tau^{k}]_{2}-\\gamma^{k+n}[\\tau^{k+n}]_{2}\\bigr{)}-e\\bigl{(}[\\tau^{m-1}]_{1}y-[\\tau^{n+s-1}]_{1}\\gamma^{s}y,[1]_{2}\\bigr{)}\\\\ =e\\bigl{(}[R]_{1},1-\\gamma^{s}[\\tau^{s}]_{2}\\bigr{)})+e\\bigl{(}[H]_{1},[\\tau^{n}]_{2}-\\gamma^{s}[\\tau^{n+s}]_{2}\\bigr{)}. \\]</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">6.3 Lagrange Basis</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Native. In the Lagrange Basis, one can use the native subset openings of <em>[33]</em>. There, the verifier needs to compute computation the vanishing polynomial <span class="math">t_{I}(X)=\\prod_{i\\in I}(X-\\mathsf{h}_{i})</span>(we recall SVC.Open and SVC.Vf algorithms in Appendix C). To reduce verifer’s work we focus on those subsets <span class="math">I\\subset[m]</span> such that <span class="math">t_{I}(X)</span> can be calculated in less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> computations. One answer to this question comes from cosets. That is, given </span>\\mathbb{H}=\\{1,\\omega,\\omega^{2},\\ldots,\\omega^{m-1}\\}<span class="math"> group of roots of unity where </span>m=2^{n}<span class="math">, let </span>\\mathbb{H}_{k}<span class="math"> be the subgroup of order </span>2^{k}<span class="math"> of </span>\\mathbb{H}<span class="math">, where </span>k<span class="math"> goes from </span>0<span class="math"> to </span>n<span class="math">. Then, for each </span>0\\leq s<2^{n/k}<span class="math"> we can construct the coset </span>I=\\omega^{s}\\mathbb{H}_{k}<span class="math">, whose vanishing polynomial is </span>t_{I}(X)=X^{2^{k}}-(\\omega^{s})^{2^{k}}$. Verifier accepts if and only if</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">e\\bigl{(}\\mathsf{C}-\\tilde{\\mathsf{C}},[1]_{2}\\bigr{)}=e\\bigl{(}[H]_{1},[x^{2^{k}}]_{2}-\\omega^{s2^{k}}\\bigr{)}.</span></p>

    <p class="text-gray-300">Non-native. Given that the native subvector opening procedure above works for arbitrary subsets  <span class="math">I \\subset [m]</span> , we don't consider aggregation of individual positions. The latter makes sense only when applying a linear function to the new subset. That is, when the verifier is given  <span class="math">\\mathsf{C}_{f,I}</span> , claimed to be a commitment to  <span class="math">\\mathbf{f} \\cdot \\mathbf{c}_I</span> , for some linear function  <span class="math">\\mathbf{f}</span>  applied to the vector  <span class="math">\\mathbf{c}_I = (c_i)_{i \\in I}</span> .</p>

    <p class="text-gray-300">We implement our monomial basis construction in Rust on top of the paired library <span class="math">^{13}</span>  and is available on  <span class="math">\\mathrm{Github}^{14}</span> . In this section we experimentally evaluate different features of our monomial-basis construction. In particular we investigate and provide estimates for the following questions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For which set sizes can we expect proving time in our construction to be more efficient than that in SNARKs over Merkle Trees?</li>

      <li>How beneficial is for proving time our range opening?</li>

      <li>How much can verification time benefit from special subset opening?</li>

    </ul>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Proving time in our scheme with monomial basis vs SNARKs for Merkle trees opening. Plot is in log-scale.</p>

    <p class="text-gray-300">We show our comparison in Fig. 1. We compare to Merkle trees instantiated with both Poseidon hash [19] and with SHA256. The underlying proof system used here is Groth16 [20] in its libsnark implementation <span class="math">^{15}</span> .</p>

    <p class="text-gray-300">We estimate our construction to have more efficient proving time for vectors up to approximately  <span class="math">2^{18}</span> , where SNARKs over Poseidon are of similar efficiency. Our construction is more efficient than SNARKs for SHA-based Merkle trees for larger vectors. We point out that while Poseidon is a highly SNARK-friendly hash function it is slower than SHA when executed "natively" and it has received little cryptanalytic scrutiny so far.</p>

    <p class="text-gray-300">Our proving time has a steeper growth than that of the SNARKs. This is a direct consequence of the following: our proving consists of multiexponentiations roughly linear in the size of the vector; SNARKs over Merkle trees, on the other hand, are still Merkle tree openings and thus logarithmic in the vector size despite their larger hidden constants.</p>

    <p class="text-gray-300">The diagram shows proving time for a single opening only. Our scheme performs better than  <span class="math">\\mathrm{MT} + \\mathrm{Poseidon}</span>  hashes for vectors of size up to  <span class="math">2^{18}</span> , while we do better than Merkle Trees with SHA256 for vector of size up to  <span class="math">2^{25}</span> .</p>

    <p class="text-gray-300">The results of this comparison are in Fig. 2. We compare the proving time of our range subvector opening of Section 6.1 to range opening through a SNARK (again Groth16) over Merkle trees with the Poseidon hash function. For the latter, we make use of the fact that a range opening in a Merkle tree can often be significantly optimized by opening an "upper path" only once and then opening a whole subtree stemming from that upper path and corresponding to the whole range <span class="math">^{16}</span> .</p>

    <p class="text-gray-300">Except for very small ranges, Merkle trees perform worse. The savings are of a few order of magnitudes even for moderately sized ranges. The reason for this is the virtually constant proving time in our range subset compared to the one for SNARKs which roughly grows linearly with it (our proving time actually decreases with the range size, but in the diagram we just consider the proving time for the most expensive case). We performed similar evaluations for different set sizes and find little difference in the patterns.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: Proving time for range queries in our scheme with monomial basis vs SNARKs for Merkle trees with Poseidon in a vector of size  <span class="math">2^{20}</span> . Plot is in log-scale.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The results of this comparison are summarized in Fig. 3. We compare our verifier in Section 6.2 with that in Pointproofs [18]. Our estimates indicate that our verifier can be twice as fast as that in Pointproofs for appropriately large opening subsets. See Fig. 3. We describe the costs of these verifier reducing all other operations to their corresponding costs in  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . For this we use the thorough conversions documented in [2, Table 2]. All our costs refer to an instantiation with BLS12-381.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost of the Pointproofs verifier opening a subset  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {M L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {F E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} _ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + c (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} _ {T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Cost of our verifier in Section 6.2:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {M L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {F E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ c ^ {\\prime} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} _ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Above ML and FE correspond respectively to Miller Loop and Final Exponentiation for the pairing. Field operations refer to multiplications. The constants  <span class="math">c, c&#x27;</span>  are small enough to be ignored in our figure. We estimate the cost of a field operation as approximately  <span class="math">\\frac{1}{8}</span>  of a  <span class="math">\\mathbb{G}_1</span>  operation <span class="math">^{17}</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3: Verification cost for subset opening. Costs are independent of original vector size. Plot is in log-scale.</p>

    <p class="text-gray-300">Our construction has an initially higher cost which is soon compensated as the subset size increases. This is due to the more expensive  <span class="math">\\mathbb{G}_2</span>  operation that dominate in Pointproofs. Our verification achieves a speedup of approximately  <span class="math">16\\times</span>  in this cost model. The maximum subset size we show in the plot is also roughly the parameter at which the ratio between the two verification times converges, i.e., the multiplicative speedup of our construction does not increase for larger subsets.</p>

    <p class="text-gray-300">We stress that our goal here is to give an indication of the fact that our approach can be useful. Concrete speedups would be highly dependent on the implementation of algebraic primitives and on the curve as well as other optimizations we have not considered in the analysis above.</p>

    <p class="text-gray-300">All the curve operations are instantiated over curve BLS12-381 [6]. Our timings for SNARKs over Merkle trees are (generous) lower bounds extrapolated from[9, Figure 5]. All our benchmarks refer to executions run single-threaded on Amazon EC2 using r5.8xlarge instances (248GB of memory).</p>

    <p class="text-gray-300">One of the key points of vector commitment schemes that allow to speedup subvector openings is the ability to pre-compute and store individual openings and later aggregate them to create subvector openings without incurring linear amount of computations each time. This is the case for the construction in [33], presented in Section C, and also for the maintainable scheme of [34].</p>

    <p class="text-gray-300">In constructions such as the ones presented in Section 5, the proof of opening of one position involves all other elements in the vector. That is, the polynomials committed to create the proof have coefficients that involve all the values of the committed vector  <span class="math">\\mathbf{v} \\in \\mathbb{F}^m</span> . As a consequence, prover work is linear in the size of  <span class="math">\\mathbf{v}</span>  (as it has to evaluate polynomials of degree  <span class="math">m</span> ). To alleviate this, Shrinivasan et. al. [32] utilize a tree-like structure for computing/communicating proofs which allows pre-computation in quasi-linear (instead of quadratic) time and efficient updates at the cost of a proof of size  <span class="math">\\log m</span> .</p>

    <p class="text-gray-300">In this section, we extend the techniques of [32] to achieve trade-offs and efficiency improvements. Roughly speaking, we present a way to "compose" the tree-based commitments of [32] with constant size ones. We achieve this by considering trees that themselves have commitments for leaves instead of openings. The intuition is the following: we divide the vector  <span class="math">\\mathbf{v}</span>  in small chunks  <span class="math">\\{\\mathbf{v}_j\\} \\in \\mathbb{F}^k</span> . We then arrange these chunks in a tree as follows: each chunk corresponds to a leaf of the tree and each node is a succinct representation of its children. The root of the tree is the commitment to the vector. An opening proof only involves the elements in the path of the root to the leaf containing the position to be opened. That is, if we want to open value  <span class="math">a</span>  in position  <span class="math">i</span>  of  <span class="math">\\mathbf{v} \\in \\mathbb{F}^{k \\cdot m&#x27;}</span> , we prove that (1)  <span class="math">c_j</span>  is the leaf that contains the commitment to the  <span class="math">j</span>  chunk containing  <span class="math">i</span>  and (2)  <span class="math">c_j</span>  opens to  <span class="math">a</span>  in the position corresponding to  <span class="math">i</span> . The former part can be pre-computed and efficiently maintained while the latter is computed on the fly.</p>

    <p class="text-gray-300">This results in a construction with the following memory/time trade-off: for any <span class="math">k,m^{\\prime}\\in\\mathbb{N}</span> with <span class="math">m=k\\cdot m^{\\prime}</span>, any opening can be computed in time <em>independent of <span class="math">m^{\\prime}</span></em> after pre-computing and storing <span class="math">O_{\\lambda}(m^{\\prime})</span> values (independent of <span class="math">k</span>). Furthermore, a relaxed <em>maintainability</em> notion is satisfied: all stored values can be pre-computed efficiently in <span class="math">O_{\\lambda}(m\\cdot\\log m^{\\prime})</span> time and updated in <span class="math">O(\\log m^{\\prime})</span> time.</p>

    <p class="text-gray-300">Additionally, we show how to use a higher arity tree (any constant <span class="math">\\ell</span> contrary to the binary ones used in <em>[32]</em>) to further reduce the proof size by a constant factor, namely <span class="math">O_{\\lambda}(\\log_{\\ell}m^{\\prime})</span> (assuming a constant size commitment for the leaf part), at the expense of a slightly worse prover time. We note that –apart from the evident advantage of shorter proofs– this results in smaller aggregation time for the prover and verifier when using inner pairing products.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">PST polynomial commitment as a maintainable vector commitment</h4>

    <p class="text-gray-300">Our starting point is the PST polynomial commitment <em>[29]</em>, a n natural generalization of the KGZ polynomial commitment <em>[22]</em> for multivariate polynomials. The PST polynomial commitment allows to commit to <span class="math">\\nu</span>-variate polynomials of individual degrees less than <span class="math">\\ell</span>. The core idea of the construction lies in the fact that for every <span class="math">p(\\mathbf{X})\\in\\mathbb{F}[X_{\\nu},\\ldots,X_{1}]</span> and <span class="math">\\mathbf{x}=(x_{\\nu},\\ldots,x_{1})\\in\\mathbb{F}^{\\nu}</span>, <span class="math">p(\\mathbf{x})=y</span> if and only if there exist polynomials <span class="math">H_{\\nu}(\\mathbf{X}),\\ldots</span>, <span class="math">H_{1}(\\mathbf{X})</span> such that</p>

    <p class="text-gray-300"><span class="math">p(\\mathbf{X})-y=\\sum_{j=1}^{\\nu}H_{j}(\\mathbf{X})\\cdot(X_{j}-x_{j})</span></p>

    <p class="text-gray-300">where the proof polynomials <span class="math">H_{j}(\\mathbf{X})</span> are efficiently computable.</p>

    <p class="text-gray-300">Using standard techniques to encode polynomials in a cryptographically secure bilinear group (publishing some monomial basis evaluated at a secret point <span class="math">\\tau</span> and encoding polynomials by evaluating them at the secret point “in the exponent” via linear combinations of the public elements) results in a polynomial commitment with proof of size roughly <span class="math">\\nu</span> group elements.</p>

    <p class="text-gray-300">Srinivasan et. al. <em>[32]</em> observe that computing all polynomial evaluations and proofs for a committed <span class="math">\\nu</span>-variate multilinear polynomial in the hypercube <span class="math">\\{0,1\\}^{\\nu}</span> can be done in quasi-linear time in the dimension of the vector, instead of the trivial quadratic time. By encoding a vector as the corresponding interpolating polynomial in <span class="math">\\{0,1\\}^{\\nu}</span>, we get a vector commitment with quasi-linear time for pre-computing all proofs. Furthermore, the homomorphic properties along with the tensor structure of multivariate polynomials allow to efficiently (in logarithmic time) update all proofs after a position update. Thus, the resulting construction is a <em>maintainable</em> vector commitment scheme.</p>

    <p class="text-gray-300">We extend these techniques to construct a multi-variate vector commitment scheme with the same properties while reducing proof size. Specifically, we observe that evaluating all openings in any set of the form <span class="math">\\Sigma^{\\nu}</span> for small <span class="math">\\nu</span> has lower amortized cost than computing the evaluations individually. Using <span class="math">\\Sigma</span> of size <span class="math">\\ell</span> instead of <span class="math">2</span> -or equivalently using a low degree instead of a multilinear encoding- results in smaller proof size. Concretely, the proof size depends on the dimension of the hypercube. Setting <span class="math">\\ell=O(1)</span> to avoid a blowup in the prover’s computation results in proof size roughly <span class="math">\\log_{\\ell}m</span> instead of <span class="math">\\log_{2}m</span>, reducing the proof size by a constant factor.</p>

    <p class="text-gray-300">We next describe the high level idea of the construction. First, fix an alphabet <span class="math">\\Sigma\\subseteq\\mathbb{F}</span> of size <span class="math">\\ell</span> and consider the hypercube <span class="math">\\Sigma^{\\nu}</span>. Assume (w.l.o.g.) <span class="math">\\Sigma=\\{0,\\ldots,\\ell-1\\}</span> so that we can encode indices of vectors in <span class="math">\\ell</span>-ary.</p>

    <p class="text-gray-300">Now, we can encode a vector <span class="math">\\mathbf{v}\\in\\mathbb{F}^{\\ell^{\\nu}}</span> by considering the (unique) low degree interpolating polynomial <span class="math">p(\\mathbf{X})</span> of <span class="math">\\mathbf{v}</span>, that is, the <span class="math">\\nu</span>-variate polynomial of individual degree less than <span class="math">\\ell</span> such that for all <span class="math">\\boldsymbol{\\sigma}\\in\\Sigma^{\\nu}</span>, <span class="math">p(\\boldsymbol{\\sigma})=v_{\\boldsymbol{\\sigma}}</span>. This corresponds to position <span class="math">i</span> with <span class="math">\\ell</span>-ary representation <span class="math">(\\boldsymbol{\\sigma})_{\\ell}</span>. Computing all opening proofs corresponds to evaluating and proving evaluations of <span class="math">p(\\mathbf{X})</span> in the hypercube <span class="math">\\Sigma^{\\nu}</span>. To compute these evaluations in quasi-linear (instead of quadratic) time we rely on the following lemma which is implicit in the computation of the <span class="math">H_{j}(\\mathbf{X})</span> polynomials of PST.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\Sigma\\subseteq\\mathbb{F}</span> be a subset of <span class="math">\\mathbb{F}</span>. Also, let <span class="math">p(X_{\\nu},\\ldots,X_{1})\\in\\mathbb{F}[X_{\\nu},\\ldots,X_{1}]</span> be a polynomial in <span class="math">\\nu</span> variables and <span class="math">p_{\\sigma}(X_{\\nu-1},\\ldots,X_{1})\\in\\mathbb{F}[X_{\\nu-1},\\ldots,X_{1}]</span> be a polynomial in <span class="math">\\nu-1</span> variables. Then, for all <span class="math">\\sigma\\in\\Sigma</span>, <span class="math">p(\\sigma,X_{\\nu-1}\\ldots,X_{1})=p_{\\sigma}(X_{\\nu-1}\\ldots,X_{1})</span> iff there exist a polynomial <span class="math">H(X_{\\nu},\\ldots,X_{1})</span> such that</p>

    <p class="text-gray-300"><span class="math">p(X_{\\nu},\\ldots,X_{1})-p_{\\sigma}(X_{\\nu-1},\\ldots,X_{1})=H(X_{\\nu},\\ldots,X_{1})(X_{\\nu}-\\sigma)</span> (1)</p>

    <p class="text-gray-300">To open the polynomial at <span class="math">\\boldsymbol{\\sigma}=(\\sigma_{\\nu},\\ldots,\\sigma_{1})\\in\\Sigma^{\\nu}</span>, the prover can compute the polynomials <span class="math">p(\\sigma_{\\nu},X_{\\nu-1},\\ldots,X_{1}),\\ldots,p(\\sigma_{\\nu},\\ldots,\\sigma_{1})</span> and compute “proof” polynomials <span class="math">H_{\\nu}(\\mathbf{X}),\\ldots,H_{1}(\\mathbf{X})</span>. That is, for <span class="math">1\\leq j\\leq\\nu</span></p>

    <p class="text-gray-300">the following equations hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p(\\boldsymbol{\\sigma}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j+1},X_{j},\\ldots,X_{1})-p(\\boldsymbol{\\sigma}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j+1},\\sigma_{j},X_{j-1},\\ldots,X_{1})=H_{j}(\\mathbf{X})(X_{j}-\\sigma_{j})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Summing all the <span class="math">\\nu</span> claims, we derive the PST verification equation. Note that the polynomial <span class="math">H_{j}(\\mathbf{X})</span> is <em>independent</em> of the variables <span class="math">X_{\\nu},\\ldots,X_{j+1}</span>. Hence, each iteration is cheaper than the previous one.</p>

    <p class="text-gray-300">The interesting part is that proofs for different positions <em>share elements</em>. Consider a polynomial <span class="math">H(\\mathbf{X})</span> asserting <span class="math">p(\\sigma,X_{\\nu},\\ldots,X_{1})-p_{\\sigma}(X_{\\nu-1},\\ldots,X_{1})</span>. This element will be part of the proof for all elements <span class="math">\\boldsymbol{\\sigma}\\in\\Sigma^{\\nu}</span> whose first component is <span class="math">\\sigma_{\\nu}=\\sigma</span>. We utilize this fact to get a smaller amortized cost for evaluating all “proof” polynomials in the hypercube.</p>

    <p class="text-gray-300">The tensor structure of the multivariate polynomial allows to express the openings in the hypercube as a tree. Each node of the tree corresponds to a partial evaluation of <span class="math">p</span>. A proof polynomial <span class="math">H</span> is associated with each of them. We demonstrate this in Fig. 4.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Tree structure for polynomials in 3 variables with individual degree at most 3. The dimension of the committed vectors with these parameters is <span class="math">4^{3}=64</span>. We follow the path until we reach the leafs prefixed with <span class="math">(1,2)</span>. Note that each polynomial is an encoding of the leafs of the sub-tree it defines.</p>

    <p class="text-gray-300">Finally, when using the Lagrange basis to encode polynomials, the interpolating polynomial <span class="math">p(\\mathbf{X})</span> corresponding to <span class="math">\\mathbf{v}</span> becomes <span class="math">\\boldsymbol{\\lambda}(X_{\\nu},\\ldots,X_{1})\\cdot\\mathbf{v}</span>. Furthermore, each node of the tree is of the form <span class="math">\\boldsymbol{\\lambda}(X_{i},\\ldots,X_{1})\\cdot\\mathbf{v}^{\\prime}</span> where <span class="math">\\mathbf{v}^{\\prime}</span> is the subvector of <span class="math">\\mathbf{v}</span> corresponding to the leaf descendants of the node.</p>

    <h5 id="sec-52" class="text-base font-semibold mt-4">Tree structure</h5>

    <p class="text-gray-300">To achieve the flexible memory/time trade-off, instead of having the vector values in the leaves of the tree, we replace them with elements <span class="math">[\\mathbf{r}]_{1}\\cdot\\mathbf{v}_{j}</span> where <span class="math">[\\mathbf{r}]\\in\\mathbb{G}_{1}^{k}</span> is the commitment key of an arbitrary algebraic vector commitment scheme LVC. To open a position of <span class="math">\\mathbf{v}</span>, we use the PST approach to reach corresponding leaf <span class="math">j</span>, and then the opening algorithm of LVC on <span class="math">\\mathbf{v}_{j}</span>. We illustrate this structure in Fig. 5.</p>

    <p class="text-gray-300">One subtlety of replacing leaves with commitments is that a standalone PST proof is no longer binding, that is, the prover can undetectably claim arbitrary values that supposedly correspond to a leaf. We overcome this by using a low degree test to ensure that the claimed value for the leaf is uniquely defined.</p>

    <p class="text-gray-300">Note that the root of the tree depends on the elements <span class="math">\\boldsymbol{\\tau},\\mathbf{r}</span>. Viewing both <span class="math">\\boldsymbol{\\tau}=(\\tau_{\\nu},\\ldots,\\tau_{1})</span> and <span class="math">\\mathbf{r}=(r_{k},\\ldots,r_{1})</span> as formal variables <span class="math">\\mathbf{X},\\mathbf{R}</span>, we can treat the root node (the commitment) as an evaluation of a polynomial. Now, note that this polynomial corresponds to the interpolation of the elements of the leaves in <span class="math">\\Sigma^{\\nu}</span>. Thus, the aforementioned polynomial is</p>

    <p class="text-gray-300"><span class="math">p(\\mathbf{X},\\mathbf{R})=\\boldsymbol{\\lambda}(\\mathbf{X})\\cdot(\\mathbf{R}\\cdot\\mathbf{v}_{1},\\ldots,\\mathbf{R}\\cdot\\mathbf{v}_{\\ell^{\\nu}})=(\\boldsymbol{\\lambda}(\\mathbf{X})\\otimes\\mathbf{R})\\cdot\\mathbf{v}</span></p>

    <p class="text-gray-300">The prover can still evaluate one by one the variables <span class="math">X_{\\nu},\\ldots,X_{1}</span> at <span class="math">\\sigma_{\\nu},\\ldots,\\sigma_{1}</span> -as it would do in the simple PST case- and end up with a polynomial <span class="math">q(\\mathbf{R})=p(\\boldsymbol{\\sigma},\\mathbf{R})=\\mathbf{R}\\cdot\\mathbf{v}_{j}</span>. To ensure that <span class="math">q</span> does not contain any <span class="math">X_{j}</span> variable, we also include a low degree test in the proof. The evaluation of the latter polynomial at <span class="math">[\\mathbf{r}]_{1}</span> corresponds to the leaf commitment at position <span class="math">\\boldsymbol{\\sigma}</span> and can be opened by employing the Open algorithm of the leaf commitment scheme with key <span class="math">[\\mathbf{r}]_{1}</span>.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5: Demonstration of the tree structure of a commitment. Leaf nodes are commitments to  <span class="math">k</span> -dimensional vectors for an arbitrary vector commitment scheme. Each node is a commitment to its children under a Lagrange based key. The message space of the scheme is  <span class="math">k \\cdot 2^3</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction. First, we introduce some notation. Let  <span class="math">\\Sigma \\subseteq \\mathbb{F}</span>  denote an interpolating set of size  <span class="math">\\ell</span> . Given  <span class="math">\\sigma = (\\sigma_{\\nu},\\ldots ,\\sigma_{1})\\in \\Sigma^{\\nu}</span> , we denote  $\\sigma_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i} = (\\sigma_{\\nu},\\dots,\\sigma_{i})\\in \\Sigma^{\\nu -i + 1}<span class="math"> . For  </span>\\mathbf{v} = (\\mathbf{v}_{\\sigma})_{\\sigma \\in \\Sigma^{\\nu}}<span class="math">  with  </span>\\mathbf{v}_{\\sigma}\\in \\mathbb{F}^{k}<span class="math">  and  </span>\\sigma_{1}\\in \\Sigma^{i}<span class="math">  we denote with  </span>\\mathbf{v}_{k,\\sigma_1}<span class="math">  the vector  </span>(\\mathbf{v}_{\\sigma_1,\\sigma_2})_{\\sigma_2\\in \\Sigma^{\\nu -i}}<span class="math"> , that is, the concatenation of vectors  </span>\\mathbf{v}_j<span class="math">  whose  </span>\\ell<span class="math"> -ary representation of the index  </span>j<span class="math">  is prefixed with  </span>\\sigma_{1}<span class="math"> . Finally, we denote with  </span>\\tau_{\\nu ,\\ell}<span class="math">  the  </span>\\nu<span class="math"> -variate monomial basis of individual degree less than  </span>\\ell<span class="math">  evaluated at  </span>\\tau_{\\nu},\\ldots ,\\tau_{1}$ . In all cases, we omit the subscript when it is clear from the context.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We present the construction next. While our aim is individual position openings, the construction supports a bigger family of functions: linear forms <span class="math">^{18}</span>  applied to one of the  <span class="math">k</span> -sized chunks of the vector. Concretely, let  <span class="math">\\mathcal{F}_{p,k} \\subseteq \\{f : \\mathbb{F}^k \\to \\mathbb{F}\\}</span>  be the family of linear forms supported by the leaf commitment scheme. We define the  <span class="math">\\ell, \\nu</span> -extended family as</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Ext}_{\\ell, \\nu} \\mathcal{F}_{p,k} = \\{f : \\mathbb{F}^{k \\cdot \\ell^{\\nu}} \\to \\mathbb{F} \\mid \\exists f&#x27; \\in \\mathcal{F}_{p,k}, i \\in \\{1, \\dots, \\ell^{\\nu}\\} \\text{ s.t.}</span></p>

    <p class="text-gray-300"><span class="math">\\forall \\mathbf{v}_1,\\ldots ,\\mathbf{v}_{\\ell^{\\nu}}\\in \\mathbb{F}^k:f(\\mathbf{v}_1,\\ldots ,\\mathbf{v}_{\\ell^{\\nu}}) = f&#x27;(\\mathbf{v}_i)\\}</span></p>

    <p class="text-gray-300">Our construction is a linear vector commitment MVTree for the family  <span class="math">\\mathsf{Ext}_{\\ell^{\\nu}}\\mathcal{F}_{p,k}</span> , that uses as a black box an algebraic linear vector commitment scheme  <span class="math">\\mathsf{LVC}&#x27;</span>  for the family  <span class="math">\\mathcal{F}_{p,k}</span> .</p>

    <p class="text-gray-300">MVTree.KeyGen(1 <span class="math">\\lambda</span> ,  <span class="math">\\mathsf{Ext}_{\\ell^{\\nu}} - \\mathcal{F}_{p,k}) \\to (\\mathsf{prk}, \\mathsf{vrk})</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{prk}^{\\prime} = [\\mathbf{r}]_{1},\\mathsf{vrk}^{\\prime})\\gets \\mathsf{LVC}^{\\prime}.</span>  KeyGen(1,  <span class="math">\\mathcal{F}_{p,k}</span></li>

      <li>Let  <span class="math">\\lambda(X)</span>  be the vector of Lagrange polynomials associated to  <span class="math">\\Sigma</span> .</li>

      <li>Sample  <span class="math">\\tau_{\\nu},\\ldots ,\\tau_{1}\\gets \\mathbb{F}</span></li>

      <li>Output  <span class="math">\\mathsf{prk} = (\\mathsf{prk}&#x27;,[\\lambda ]_1 = [\\lambda (\\tau_\\nu)\\otimes \\dots \\otimes \\lambda (\\tau_1)\\otimes \\mathbf{r}]_1,[\\tau \\otimes \\mathbf{r}]_1),</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{vrk} = (\\mathsf{vrk}&#x27;,[\\tau_{\\nu}]_{2},\\ldots ,[\\tau_{1}]_{2},[\\tau_{\\nu}^{\\ell -1}\\dots \\tau_{1}^{\\ell -1}]_{2})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{upk} = (\\{[\\pmb {\\lambda}(\\tau_j)\\otimes \\dots \\otimes \\pmb {\\lambda}(\\tau_1)\\otimes \\mathbf{r}]_1\\}_{j = \\nu -1}^1)</span></p>

    <p class="text-gray-300">MVTree.Commit(prk, v)  <span class="math">\\rightarrow</span>  (C, aux):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all  <span class="math">\\sigma \\in \\Sigma^{\\nu}</span> : compute  <span class="math">(C_{\\sigma}, \\mathsf{aux}_{\\sigma}) \\gets \\mathsf{LVC}&#x27;</span> . Commit  <span class="math">(\\mathsf{prk}&#x27;, \\mathbf{v}_{\\sigma})</span> .</li>

      <li>Compute  <span class="math">\\mathsf{C} = [p(\\pmb {\\tau},\\mathbf{r})]_1 = [\\lambda ]_1\\cdot \\mathbf{v}</span></li>

      <li>Output  <span class="math">\\mathsf{C},\\mathsf{aux} = \\left(\\{\\mathsf{aux}_{\\sigma}\\}_{\\sigma \\in \\Sigma^{\\nu}},\\mathbf{v}\\right)</span></li>

    </ol>

    <p class="text-gray-300">MVTree.Open(prk, aux,  <span class="math">f, \\mathbf{y}) \\to \\pi</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">f(\\mathbf{v}_1, \\ldots, \\mathbf{v}_{\\ell^\\nu}) = f&#x27;(\\mathbf{v}_i)</span>  for  <span class="math">f&#x27; \\in \\mathcal{F}_{p,k}</span>  and  <span class="math">i = (\\sigma)_\\ell</span>  in  <span class="math">\\ell</span> -ary.</li>

      <li>Consider  <span class="math">\\pmb{\\tau},\\mathbf{r}</span>  as formal variables  <span class="math">\\mathbf{X} = (X_{\\nu},\\dots ,X_{1}),\\mathbf{R} = (R_{k},\\dots ,R_{1})</span></li>

      <li>Denote  <span class="math">p_{\\nu +1}(\\mathbf{X},\\mathbf{R}) = p(\\mathbf{X},\\mathbf{R}) = (\\lambda (\\mathbf{X})\\otimes \\mathbf{R})\\cdot \\mathbf{v}</span></li>

      <li>For all  <span class="math">\\nu \\geq j\\geq 1</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Compute  $p_j(X_{j-1}, \\ldots, X_1, \\mathbf{R}) = \\lambda(X_{j-1}, \\ldots, X_1, \\mathbf{R}) \\cdot \\mathbf{v}_{\\sigma_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Compute  <span class="math">H_{j}(X_{j},\\ldots ,X_{1},\\mathbf{R})</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">H _ {j} \\left(X _ {j}, \\dots , X _ {1}, \\mathbf {R}\\right) = \\frac {p _ {j + 1} \\left(X _ {j} , \\dots , X _ {1} , \\mathbf {R}\\right) - p _ {j} \\left(X _ {j - 1} , \\dots , X _ {1} , \\mathbf {R}\\right)}{\\left(X _ {j} - \\sigma_ {j}\\right)}</span></div>

    <p class="text-gray-300">Compute group element  <span class="math">[H_j]_1 = [H_j(\\tau_j,\\dots ,\\tau_1,\\mathbf{r})]_1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\hat{\\mathsf{C}}_{\\bm{\\sigma}}=[\\tau_{\\nu}^{\\ell-1}\\cdots\\tau_{1}^{\\ell-1}\\cdot\\mathbf{r}]_{1}\\cdot\\mathbf{v}_{\\bm{\\sigma}}</span></li>

      <li>Compute <span class="math">\\pi^{\\prime}\\leftarrow\\mathsf{LVC}^{\\prime}.\\mathsf{Open}(\\mathsf{prk}^{\\prime},\\mathsf{aux}_{\\bm{\\sigma}},f^{\\prime},\\mathbf{y})</span></li>

      <li>Output <span class="math">\\pi=([H_{\\nu}]_{1},\\ldots,[H_{1}]_{1},\\mathsf{C}_{\\bm{\\sigma}},\\hat{\\mathsf{C}}_{\\bm{\\sigma}},\\pi^{\\prime})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">f(\\mathbf{v}_{1},\\ldots,\\mathbf{v}_{\\ell^{\\nu}})=f^{\\prime}(\\mathbf{v}_{i})</span> for <span class="math">f^{\\prime}\\in\\mathcal{F}_{p,k}</span> and <span class="math">i=(\\bm{\\sigma})_{\\ell}</span> in <span class="math">\\ell</span>-ary.</li>

      <li><span class="math">b_{\\mathsf{Path}}\\leftarrow e(\\mathsf{C}-\\mathsf{C}_{\\bm{\\sigma}},[1]_{2})=\\sum_{j=1}^{\\nu}e([H_{j}]_{1},[\\tau_{j}-\\sigma_{j}]_{2})</span></li>

      <li><span class="math">b_{\\mathsf{LD}\\text{-}\\mathsf{Test}}\\leftarrow e(\\mathsf{C}_{\\bm{\\sigma}},[\\tau_{\\nu}^{\\ell-1}\\cdots\\tau_{1}^{\\ell-1}]_{2})=e(\\hat{\\mathsf{C}}_{\\bm{\\sigma}},[1]_{2})</span></li>

      <li><span class="math">b_{\\mathsf{Leaf}}\\leftarrow\\mathsf{LVC}^{\\prime}.\\mathsf{Vf}(\\mathsf{vrk}^{\\prime},\\mathsf{C}_{\\bm{\\sigma}},f^{\\prime},\\mathbf{y},\\pi^{\\prime})</span></li>

      <li>Output <span class="math">b_{\\mathsf{Path}}\\wedge b_{\\mathsf{LD}\\text{-}\\mathsf{Test}}\\wedge b_{\\mathsf{Leaf}}</span></li>

    </ol>

    <p class="text-gray-300">We omit explicitly describing the update algorithm. Instead, we demonstrate in Thm. 8 how to efficiently update all proofs after modifying a position in the committed vector.</p>

    <p class="text-gray-300">We summarize the properties of the construction in the following theorems.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{LVC}^{\\prime}</span> be an algebraic vector commitment scheme that satisfies completeness, homomorphic openings and weak function binding for a function family <span class="math">\\mathcal{F}_{p,k}</span>. Then, MVTree satisfies (1) completeness, (2) Homomorphic Openings and (3) strong function binding for <span class="math">\\mathsf{Ext}_{\\ell^{\\nu}}</span>-<span class="math">\\mathcal{F}_{p,k}</span> in the AGM under the <span class="math">(\\ell-1)\\cdot\\nu</span>-<span class="math">\\mathsf{BSDH}</span> assumption.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness. Consider an honest execution of MVTree.Open. Let <span class="math">y=f(\\mathbf{v})=f^{\\prime}(\\mathbf{v}_{i})</span> for some <span class="math">i=(\\bm{\\sigma})_{\\ell}</span>. Also, by construction, the low degree test always succeeds. It remains to show that the first test outputs <span class="math">1</span>.</p>

    <p class="text-gray-300">Let <span class="math">p_{\\nu+1}(X_{\\nu},\\ldots,X_{1},\\mathbf{R})=p(X_{\\nu},\\ldots,X_{1},\\mathbf{R})</span> be the polynomial <span class="math">(\\lambda(\\mathbf{X})\\otimes\\mathbf{R})^{\\top}\\mathbf{v}</span>. Next, consider the polynomial equations that the polynomials <span class="math">H_{j}</span> are constructed to satisfy:</p>

    <p class="text-gray-300"><span class="math">p_{j+1}(X_{j},\\ldots,X_{1},\\mathbf{R})-p_{j}(X_{j-1},\\ldots,X_{1},\\mathbf{R})=H_{j}(X_{j},\\ldots,X_{1},\\mathbf{R})(X_{j}-h_{j})</span></p>

    <p class="text-gray-300">Summing all these equation for <span class="math">1\\leq j\\leq\\nu</span> gives</p>

    <p class="text-gray-300"><span class="math">p_{\\nu+1}(X_{\\nu},\\ldots,X_{1},\\mathbf{R})-p_{1}=\\sum_{j=1}^{\\nu}H_{j}(X_{j},\\ldots,X_{1},\\mathbf{R})(X_{j}-h_{j})</span></p>

    <p class="text-gray-300">and note that this corresponds to the verification equation. Thus, the first test passes. Finally, note that all the monomials involved these polynomials are included in the commitment key <span class="math">\\bm{\\lambda}(\\tau_{\\nu},\\ldots,\\tau_{1})\\otimes\\mathbf{r}</span>, so the prover can encode these in <span class="math">\\mathbb{G}_{1}</span>.</p>

    <p class="text-gray-300">Function Binding. First, we prove a claim stating that we can extract an opening of a leaf commitment in the AGM.</p>

    <p class="text-gray-300">Claim. Let <span class="math">\\pi=([H_{\\nu}]_{1},\\ldots,[H_{1}]_{1},\\mathsf{C}_{\\bm{\\sigma}},\\hat{\\mathsf{C}}_{\\bm{\\sigma}},\\pi^{\\prime})</span> be an accepting proof. Then, for all algebraic adversaries <span class="math">\\mathcal{A}</span> outputting accepting proofs, there exists an extractor that outputs opening of <span class="math">\\mathsf{C}_{\\bm{\\sigma}}</span> w.r.t. key <span class="math">\\mathbf{r}</span> in the AGM.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since we work in the AGM, we can extract coefficients <span class="math">\\hat{\\mathbf{a}},\\mathbf{a}</span> of polynomials <span class="math">\\hat{C}(\\mathbf{X},\\mathbf{R}),C(\\mathbf{X},\\mathbf{R})</span> with degree less that <span class="math">\\ell-1</span> in <span class="math">X_{\\nu},\\ldots,X_{1}</span> such that <span class="math">[\\hat{C}(\\bm{\\tau},\\mathbf{r})]_{1}=\\hat{\\mathsf{C}}</span> and <span class="math">[C(\\bm{\\tau},\\mathbf{r})]_{1}=\\mathsf{C}</span>. By the low degree test, either <span class="math">\\hat{C}(\\mathbf{X},\\mathbf{R})=C(\\mathbf{X},\\mathbf{R})\\cdot X_{\\nu}^{\\ell-1}\\cdots X_{1}^{\\ell-1}</span> holds or <span class="math">\\hat{\\mathbf{a}}\\cdot(\\bm{\\tau},\\mathbf{r})=\\mathbf{a}(\\bm{\\tau},\\mathbf{r})\\cdot\\tau_{\\nu}^{\\ell-1}\\cdots\\tau_{1}^{\\ell-1}</span> holds and we find a non-trivial discrete logarithm relations of the elements of the commitment key. Assume the latter event did not happen. For this polynomial relation to hold with polynomial of degree less that <span class="math">\\ell-1</span> in <span class="math">X_{\\nu},\\ldots,X_{1}</span>, only the coefficients involving <span class="math">\\mathbf{R}</span> are non-zero, in which case we extract a leaf commitment opening. Now, either this holds or the adversary successfully computed a non-zero polynomial <span class="math">p(\\mathbf{R},\\mathbf{X})=\\hat{C}(\\mathbf{X},\\mathbf{R})-C(\\mathbf{X},\\mathbf{R})\\cdot X_{\\nu}^{\\ell-1}\\cdots X_{1}^{\\ell-1}</span> that has a root in <span class="math">(\\bm{\\tau},\\mathbf{r})</span> which happens with negligible probability.</p>

    <p class="text-gray-300">Now, consider two opening/proof pairs <span class="math">\\mathsf{C}_{\\bm{\\sigma}}\\;,f_{d},\\mathbf{y}_{d},\\pi_{d}</span> for <span class="math">d\\in\\{1,2\\}</span>. Note the only way that the functions are inconsistent is if <span class="math">f_{1}(\\mathbf{v})=f_{1}^{\\prime}(\\mathbf{v}_{i})</span> and <span class="math">f^{2}(\\mathbf{v})=f_{2}^{\\prime}(\\mathbf{v}_{i})</span> for the same index <span class="math">i</span>.</p>

    <p class="text-gray-300">Let <span class="math">f_{1}(\\mathbf{v})=f_{1}^{\\prime}(\\mathbf{v}_{i})</span> and <span class="math">f_{2}(\\mathbf{v})=f_{2}^{\\prime}(\\mathbf{v}_{i})</span> for the same <span class="math">i=(\\bm{\\sigma})_{\\ell}</span>. We consider two cases. First, assume that <span class="math">C_{1,\\bm{\\sigma}}=C_{2,\\bm{\\sigma}}=C_{\\bm{\\sigma}}</span>. By the fact that the low-degree test passes, we can extract an opening <span class="math">\\mathbf{v}_{\\bm{\\sigma}}</span> for this commitment except with negligible probability. Then, by the last verification test we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{LVC}^{\\prime}.\\mathsf{Vf}(\\mathsf{vk}^{\\prime},C_{\\bm{\\sigma}},f^{\\prime}{}_{1},\\mathbf{y}_{1},\\pi^{\\prime}_{1})=\\mathsf{LVC}^{\\prime}.\\mathsf{Vf}(\\mathsf{vk}^{\\prime},C_{\\bm{\\sigma}},f^{\\prime}{}_{2},\\mathbf{y}_{2},\\pi^{\\prime}_{2})=1</span></p>

    <p class="text-gray-300">Noting that the openings for <span class="math">f_1&#x27;, f_2&#x27;</span> are inconsistent if the openings for <span class="math">f_1, f_2</span> are inconsistent, we conclude that we have solved a strong function binding challenge for <span class="math">\\mathsf{LVC}&#x27;</span> Indeed, we have a commitment <span class="math">C_{\\sigma}</span> with a valid opening <span class="math">\\mathbf{v}_{\\sigma}</span> that <span class="math">f&#x27;^{1}</span>-opens to <span class="math">\\mathbf{y}^1</span> and <span class="math">f&#x27;^{2}</span>-opens to <span class="math">\\mathbf{y}^2</span> for some inconsistent values since <span class="math">f^1, \\mathbf{y}_1</span> and <span class="math">f^2, \\mathbf{y}_2</span> are inconsistent.</p>

    <p class="text-gray-300">Next, consider the case where <span class="math">C_{1,\\sigma} \\neq C_{2,\\sigma}</span>. We show that, in this case, an winning adversary can be used to break BSDH assumption. The reduction works as follows: on input <span class="math">[1]_{1,2}, [\\tau]_{1,2}, \\ldots, [\\tau^{(\\ell-1)\\cdot\\nu}]_{1,2}</span>, sample a key for MVTree in the following way:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guess index <span class="math">i = (\\pmb{\\sigma})_{\\ell}</span>.</li>

      <li>Sample <span class="math">(\\mathsf{pk}^{\\prime} = [\\mathbf{r}]_{1},\\mathsf{vk}^{\\prime})\\gets \\mathsf{LVC}^{\\prime}.\\mathsf{KeyGen}(1^{\\lambda},\\mathcal{F}_{p,k})</span> along with the discrete logarithms of <span class="math">[\\mathbf{r}]_1^{19}</span></li>

      <li>for all <span class="math">1 \\leq j \\leq \\nu</span> set <span class="math">[\\tau_j]_1 = [\\rho_j\\tau + \\sigma_j]_1</span> for random <span class="math">\\rho_j</span>.</li>

      <li>Compute the encodings of the multivariate Lagrange and monomial polynomials <span class="math">[\\lambda(\\tau_{\\nu}, \\dots, \\tau_{1})]_{1}, [\\tau]_{1}</span> and <span class="math">[\\tau_{\\nu}]_{2}, \\ldots, [\\tau_{1}]_{2}, [\\tau_{\\nu}^{\\ell-1} \\cdot \\tau_{\\nu}^{\\ell-1}]_{2}</span>. Note that this step is efficient since any element <span class="math">\\lambda_{\\sigma}(\\tau_{1}, \\dots, \\tau_{\\nu})</span> and in <span class="math">\\pmb{\\tau}</span> is a polynomial of total degree at most <span class="math">(\\ell - 1) \\cdot \\nu</span> on variables <span class="math">\\tau_{j} = \\rho_{j}\\tau</span> so it can be computed using the <span class="math">\\nu</span> powers of <span class="math">\\tau</span>.</li>

      <li>Compute the proving commitment key by computing <span class="math">\\mathbf{r} \\otimes [\\lambda(\\tau_{\\nu}, \\dots, \\tau_{1})]_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">First, we argue that the commitment key is correctly distributed. Indeed, we evaluate the multivariate Lagrange and monomial polynomials on a random point since <span class="math">\\tau, \\rho_{\\nu}, \\ldots, \\rho_{1}</span> are uniformly distributed, and we compute <span class="math">\\mathbf{r}</span> honestly.</p>

    <p class="text-gray-300">Next, assume that the guess of index <span class="math">i</span> was correct (which happens with <span class="math">1 / \\ell^{\\nu} = m / k</span> probability) and that the verifying proofs contain <span class="math">C_{1,\\sigma} \\neq C_{2,\\sigma}</span>. By the fact that the low-degree test passes, we get two valid openings <span class="math">\\mathbf{v}_{1,\\sigma}, \\mathbf{v}_{2,\\sigma}</span> for these commitments w.r.t. the key <span class="math">[\\mathbf{r}]_1</span>. Since we know <span class="math">\\mathbf{r}</span> in the field, we can compute the discrete logarithms of these elements: specifically,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(C _ {1, \\sigma}, C _ {2, \\sigma}\\right) = \\left(\\mathbf {r} ^ {\\top} \\mathbf {v} _ {1, \\sigma}, \\mathbf {r} ^ {\\top} \\mathbf {v} _ {2, \\sigma}\\right)</span></div>

    <p class="text-gray-300">To simplify notation, denote these values <span class="math">v, v&#x27; \\in \\mathbb{F}</span> respectively and note that <span class="math">v \\neq v&#x27;</span>.</p>

    <p class="text-gray-300">By the first verificatioon test, the following equations hold:</p>

    <div class="my-4 text-center"><span class="math-block">e ([ C - v ] _ {1}, [ 1 ] _ {2}) = \\sum_ {j = 1} ^ {\\nu} e ([ H _ {j} ] _ {1}, [ \\tau_ {j} - \\sigma_ {j} ] _ {2}), e ([ C - v ^ {\\prime} ] _ {1}, [ 1 ] _ {2}) = \\sum_ {j = 1} ^ {\\nu} e ([ H _ {j} ^ {\\prime} ] _ {1}, [ \\tau_ {j} - \\sigma_ {j} ] _ {2})</span></div>

    <p class="text-gray-300">Subtracting and setting <span class="math">z_{j} = H_{i} - H_{i}^{\\prime}</span> gives</p>

    <div class="my-4 text-center"><span class="math-block">e ([ v ^ {\\prime} - v ] _ {1}, [ 1 ] _ {2}) = \\sum_ {j = 1} ^ {\\nu} e ([ z _ {j} ] _ {1}, [ \\tau_ {j} - \\sigma_ {j} ] _ {2}) \\Leftrightarrow e ([ v ^ {\\prime} - v ] _ {1}, [ 1 ] _ {2}) = \\sum_ {j = 1} ^ {\\nu} e ([ z _ {j} ] _ {1}, \\rho_ {j} [ \\tau ] _ {2}) \\Leftrightarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">(v ^ {\\prime} - v) \\cdot e ([ 1 ] _ {1}, [ 1 ] _ {2}) = \\tau \\cdot e \\left(\\sum_ {j = 1} ^ {\\nu} \\rho_ {j} [ z _ {j} ] _ {1}, [ 1 ] _ {2}\\right) \\Leftrightarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tau^ {- 1} \\cdot e ([ 1 ] _ {1}, [ 1 ] _ {2}) = (v ^ {\\prime} - v) ^ {- 1} \\cdot e \\left(\\sum_ {j = 1} ^ {\\nu} \\rho_ {j} [ z _ {j} ] _ {1}, [ 1 ] _ {2}\\right) \\Leftrightarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">e ([ \\tau^ {- 1} ] _ {1}, [ 1 ] _ {2}) = \\cdot e \\left((v ^ {\\prime} - v) ^ {- 1} \\sum_ {j = 1} ^ {\\nu} \\rho_ {j} [ z _ {j} ] _ {1}, [ 1 ] _ {2}\\right)</span></div>

    <p class="text-gray-300">so by the final equation</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {1}{\\tau^ {- 1}} e ([ 1 ] _ {1}, [ 1 ] _ {1}) = (v ^ {\\prime} - v) ^ {- 1} \\sum_ {j = 1} ^ {\\nu} \\rho_ {j} [ z _ {j} ] _ {1}</span></div>

    <p class="text-gray-300">Therefore, <span class="math">\\left(0,(v&#x27; - v)^{-1}e(\\sum_{j = 1}^{\\nu}\\rho_j[z_j]_1,[1]_2)\\right)</span> is a solution to the BSDH challenge.</p>

    <p class="text-gray-300">19 We implicitly assume here that the distribution of the key generation algorithm is witness sampleable. This is always the case for all distribution of interest.</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-56" class="text-base font-semibold mt-4">Homomorphic Proofs</h5>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{C}_{1},f,\\mathbf{y}_{1},\\pi_{1})</span>, <span class="math">(\\mathsf{C}_{2},f,\\mathbf{y}_{2},\\pi_{2})</span> be accepting statement-proof pairs with respect to some key vk. We show that for all <span class="math">\\alpha,\\beta\\in\\mathbb{F}</span>, the statement-proof pair <span class="math">(\\mathsf{C},f,\\mathbf{y},\\pi)=(\\alpha\\mathsf{C}_{1}+\\beta\\mathsf{C}_{2},f,\\alpha\\mathbf{y}_{1}+\\beta\\mathbf{y}_{2},\\alpha\\pi_{1}+\\beta\\pi_{2})</span> is also accepting. Let</p>

    <p class="text-gray-300"><span class="math">\\pi=(\\alpha[H_{\\nu,1}]_{1}+\\beta[H_{\\nu,2}]_{1},\\ldots,\\alpha[H_{1,1}]_{1}+\\beta[H_{1,2}]_{1},</span> <span class="math">\\alpha\\mathsf{C}_{1,\\bm{\\sigma}}+\\beta\\mathsf{C}_{2,\\bm{\\sigma}},\\alpha\\hat{\\mathsf{C}}_{1,\\bm{\\sigma}}+\\beta\\hat{\\mathsf{C}}_{2,\\bm{\\sigma}},\\alpha\\pi^{\\prime}_{1}+\\beta\\pi^{\\prime}_{2})</span></p>

    <p class="text-gray-300">be the combined proof. First, note that for the function <span class="math">f^{\\prime}</span> and <span class="math">\\bm{\\sigma}\\in\\Sigma^{\\nu}</span> corresponding to <span class="math">f</span>, the second verification test <span class="math">\\mathsf{LVC}^{\\prime}.\\mathsf{Vf}(\\mathsf{vk}^{\\prime},\\alpha\\mathsf{C}_{1,\\bm{\\sigma}}+\\beta\\mathsf{C}_{2,\\bm{\\sigma}},f^{\\prime},\\alpha\\mathbf{y}_{1}+\\beta\\mathbf{y}_{2},\\alpha\\pi^{\\prime}_{1}+\\beta\\pi^{\\prime}_{2})</span> outputs <span class="math">1</span> by the homomorphic openings property of <span class="math">\\mathsf{LVC}^{\\prime}</span>. For the first test, we have</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{C}-\\mathsf{C}_{\\bm{\\sigma}},[1]_{2})</span> <span class="math">=e(\\alpha\\mathsf{C}_{1}+\\beta\\mathsf{C}_{2}-\\alpha\\mathsf{C}_{1,\\bm{\\sigma}}-\\beta\\mathsf{C}_{2,\\bm{\\sigma}},[1]_{2})</span> <span class="math">=\\alpha\\cdot e(\\mathsf{C}_{1}-\\mathsf{C}_{1,\\bm{\\sigma}},[1]_{2})+\\beta\\cdot e(\\mathsf{C}_{2}-\\mathsf{C}_{2,\\bm{\\sigma}},[1]_{2})</span> <span class="math">=\\alpha\\sum_{j=1}^{\\nu}e([H_{j,1}]_{1},[\\tau_{j}-\\sigma_{j}]_{2})+\\beta\\sum_{j=1}^{\\nu}e([H_{j,2}]_{1},[\\tau_{j}-\\sigma_{j}]_{2})</span> <span class="math">=\\sum_{j=1}^{\\nu}e(\\alpha[H_{j,1}]_{1}+\\beta[H_{j,2}]_{1},[\\tau_{j}-\\sigma_{j}]_{2})=\\sum_{j=1}^{\\nu}e([H_{j}]_{1},[\\tau_{j}-\\sigma_{j}]_{2})</span></p>

    <p class="text-gray-300">Similarly, for the low degree test we have</p>

    <p class="text-gray-300"><span class="math">e(\\hat{\\mathsf{C}}_{\\bm{\\sigma}},[1]_{2})</span> <span class="math">=e(\\alpha\\hat{\\mathsf{C}}_{1,\\bm{\\sigma}}+\\beta\\hat{\\mathsf{C}}_{2,\\bm{\\sigma}},[1]_{2})=\\alpha\\cdot e(\\hat{\\mathsf{C}}_{1,\\bm{\\sigma}},[1]_{2})+\\beta\\cdot e(\\hat{\\mathsf{C}}_{2,\\bm{\\sigma}},[1]_{2})</span> <span class="math">=\\alpha\\cdot e(\\mathsf{C}_{1,\\bm{\\sigma}},[\\tau_{\\nu}^{\\ell-1}\\cdots\\tau_{1}^{\\ell-1}]_{2})+\\beta\\cdot e(\\mathsf{C}_{2,\\bm{\\sigma}},[\\tau_{\\nu}^{\\ell-1}\\cdots\\tau_{1}^{\\ell-1}]_{2})</span> <span class="math">=e(\\alpha\\mathsf{C}_{1,\\bm{\\sigma}}+\\beta\\mathsf{C}_{2,\\bm{\\sigma}},[\\tau_{\\nu}^{\\ell-1}\\cdots\\tau_{1}^{\\ell-1}]_{2})=e(\\mathsf{C}_{\\bm{\\sigma}},[\\tau_{\\nu}^{\\ell-1}\\cdots\\tau_{1}^{\\ell-1}]_{2})</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Thus, the new statement/proof pair passes all verification tests.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Note that in the function binding proof, we only use the AGM to extract openings for the leaf commitments but not for the tree part of the construction. The latter is sound under falsifiable assumptions.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">Consider construction MVTree and let <span class="math">\\pi^{\\bm{\\sigma}}=([H_{\\nu}^{\\bm{\\sigma}}]_{1},\\ldots,[H_{1}^{\\bm{\\sigma}}]_{1},\\mathsf{C}_{\\bm{\\sigma}},\\hat{\\mathsf{C}}_{\\bm{\\sigma}},\\pi^{\\prime}_{\\bm{\\sigma}})</span> be some proof of opening for a leaf commitment in position <span class="math">\\bm{\\sigma}</span> written in <span class="math">\\ell</span>-ary. Then, computing all partial proofs <span class="math">\\left\\{([H_{\\nu}^{\\bm{\\sigma}}]_{2},\\ldots,[H_{1}^{\\bm{\\sigma}}]_{1},\\mathsf{C}_{\\bm{\\sigma}},\\hat{\\mathsf{C}}_{\\bm{\\sigma}})\\right\\}_{\\bm{\\sigma}\\in\\Sigma^{\\nu}}</span> can be done in <span class="math">O_{\\lambda}(k\\cdot\\nu\\cdot\\ell^{\\nu})=O_{\\lambda}(\\nu\\cdot m)</span> time and storing them needs <span class="math">O_{\\lambda}(\\ell^{\\nu})=O_{\\lambda}(m/k)</span> space. Furthermore, if we update <span class="math">C</span> by adding <span class="math">\\delta</span> in some position <span class="math">i^{*}</span>, we can update all partial proofs in time <span class="math">O_{\\lambda}(\\nu)</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Pre-computing partial proofs. Let <span class="math">p(X_{\\nu},\\ldots,X_{1},\\mathbf{R})</span> be the polynomial encoding of <span class="math">\\mathbf{v}</span> w.r.t. <span class="math">\\Sigma^{\\nu}</span> and consider the evaluation of polynomials <span class="math">p_{\\bm{\\sigma}_{1}}(\\mathbf{X},\\mathbf{R})=p(\\bm{\\sigma}_{1},\\mathbf{X},\\mathbf{R})</span> arranged in a tree: the root is the polynomial <span class="math">p(X_{\\nu},\\ldots,X_{1},\\mathbf{R})</span> and the children of a node in level <span class="math">j</span> are <span class="math">\\left\\{p_{\\sigma_{\\nu},\\ldots,\\sigma_{j}}(\\sigma,X_{j-2},\\ldots,X_{1},\\mathbf{R})\\right\\}_{\\sigma\\in\\Sigma}</span>. Computing all proofs corresponds to computing a divisor polynomial for each node that asserts that the node is consistent with its parent node, plus some constant work for computing each leaf commitment along with its low degree proof. Assuming <span class="math">\\ell=O(1)</span>, each divisor polynomial proof can be computed in time linear in the total degree of <span class="math">p_{\\sigma_{\\nu},\\ldots,\\sigma_{j}}</span>. A simple counting argument is enough to conclude the proof. In level <span class="math">j</span> of the tree, we need to compute <span class="math">\\ell^{j}</span> proofs, each for a polynomial of total degree <span class="math">k\\cdot\\ell^{\\nu-j}</span>. Thus, for each level of the tree, we need time linear in <span class="math">k\\cdot\\ell^{\\nu}=m</span>. Having <span class="math">\\nu</span> levels, the total time is <span class="math">O_{\\lambda}(m\\cdot\\nu)</span>. For the space requirements, it is enough to note that the tree is has <span class="math">O(m)</span> nodes, and we associate one group element to each.</p>

    <h5 id="sec-60" class="text-base font-semibold mt-4">Updating all partial proofs.</h5>

    <p class="text-gray-300">The updatability property follows directly by the homomorphic opening property of the construction. We focus on the computation needed for updating all stored proofs. The strategy is to consider the new commitment as <span class="math">\\mathsf{C}^{\\prime}=\\mathsf{C}+\\hat{\\mathsf{C}}</span> where <span class="math">\\hat{\\mathsf{C}}</span> is a commitment to the vector <span class="math">\\delta\\cdot\\mathbf{e}_{i^{<em>}}</span>, where <span class="math">\\bm{\\sigma}</span> denotes leaf corresponding to <span class="math">i^{</em>}</span>. We claim that (1) we can compute all proofs for <span class="math">\\hat{\\mathsf{C}}</span> in</p>

    <p class="text-gray-300">logarithmic time and (2) all but <span class="math">O(\\nu)</span> proof elements are 0. By this two facts the claim follows since we can combine all the non-zero proof elements of <span class="math">\\hat{\\mathbb{C}}</span> with the corresponding elements of <span class="math">\\mathbb{C}</span>.</p>

    <p class="text-gray-300">The commitment <span class="math">\\hat{\\mathbb{C}}</span> corresponds to a polynomial of the form <span class="math">p(\\mathbf{X},\\mathbf{R})=\\delta\\cdot\\lambda_{\\boldsymbol{\\sigma}}(\\mathbf{X})\\cdot R_{j}</span>. All polynomials labeling nodes in the tree are 0 apart from the ones being in the path from the root to the leaf containing <span class="math">i^{*}</span>. Such a node always has the zero polynomial nodes as descendants, and the proof corresponding to each is 0 since <span class="math">0=0\\cdot(X_{j}-\\sigma_{j})</span>. The proof polynomials for the rest <span class="math">\\ell\\cdot\\nu</span> nodes can be computed in constant time each and each can be encoded to the group in constant time since each involves a unique commitment key element. ∎</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Efficiency of the Multivariate Construction.</h4>

    <p class="text-gray-300">We only consider the case where <span class="math">\\ell=O(1)</span>. First, let’s focus on the time needed to compute <span class="math">[H_{j}]_{1}</span>. One can simply write the polynomial <span class="math">p_{j}-p_{j-1}</span> as a polynomial in <span class="math">1,X_{j},\\ldots,X_{j}^{\\ell-1}</span> with polynomial coefficients in the other variables. Then, we can use standard (univariate) polynomial division to divide each term with <span class="math">X_{j}-\\sigma_{j}</span> in constant time. To encode it in the group, it is enough to note that the total degree of each term is <span class="math">k\\cdot\\ell^{j-1}</span>, so we need to perform <span class="math">\\ell</span> multi-exponentiations of this size totaling in <span class="math">O(k\\cdot\\ell^{j})</span> operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That said, we demonstrate the efficiency of the construction. The commitment key consists of linear in <span class="math">m</span> group elements. Opening needs <span class="math">O(k\\cdot\\ell^{j})</span> operations for each iteration, totaling in <span class="math">O(k\\cdot\\ell^{\\nu})</span> time. By inspection of the construction, proofs size is $\\log_{\\ell}(m/k)+2+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\pi^{\\prime}<span class="math"> is the size of an opening of the leaf commitment. Finally, verification consists of (1) a </span>\\log_{\\ell}(m/k)$-size pairing product equation, (2) a low degree test involving constant operations and (3) a verification of an opening of a leaf commitment.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-62" class="text-base font-medium mt-4">Remark 3 (On aggregation)</h6>

    <p class="text-gray-300">The first two verification tests are pairing product equations. Assuming the leaf commitment verification is also a pairing product equation, one can use inner pairing products <em>[7]</em> to aggregate many such equations as done in <em>[32]</em> and, thus, achieve one-hop cross commitment aggregation. While the aggregated proof size decreases exponentially, this comes at the cost of a significant overhead for the prover due to the need to work in the target group. Reducing the proof size from <span class="math">\\log_{2}m</span> to roughly <span class="math">\\log_{\\ell}(m/k)</span> (assuming constant size/verification for leaf commitment opening) can make aggregation significantly cheaper for the prover.</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">8.2 Univariate Maintainable Vector Commitments</h3>

    <p class="text-gray-300">In this section, we give an optimized construction that achieves the same memory-time tradeoffs for the prover that the scheme in Section 8.1, but for univariate polynomials. For that, we rely on the <span class="math">q</span>-BSDH assumption for <span class="math">q=m</span> (<em>[4]</em>), while we only needed <span class="math">q=\\log m</span> plus the assumption that the leaf commitment is sound in the multivariate case. Our work generalizes a previous univariate construction of <em>[34]</em> in a similar way as the previous schemes generalizes Hyperproofs. Namely, our construction truncates the tree at some level so that leaves are commitments and not individual positions.</p>

    <p class="text-gray-300">For vectors of size <span class="math">m</span>, we offer the following trade-off: for any <span class="math">\\nu,\\kappa</span>, such that <span class="math">m=2^{\\nu+\\kappa+1}</span>, one can derive openings of size <span class="math">\\nu+6</span> group elements. The prover can pre-compute and store <span class="math">2^{\\nu}-1</span> proofs, and then realize functional openings by performing <span class="math">O(\\kappa 2^{\\kappa})</span> group operations. We show also how to compute all proofs with <span class="math">O(\\nu m)</span> group operations (plus <span class="math">O(m(\\nu+\\kappa))</span> field operations). The scheme is maintainable, as an update in a position requires recomputing <span class="math">O(\\nu)</span> proofs. One interesting feature is that the trusted setup depends only on <span class="math">m</span> (the powers of <span class="math">\\tau</span>) and not on <span class="math">\\nu,\\kappa</span>, so the right tradeoff can be decided on the fly.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">Overview.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our construction builds a tree of commitments to a vector <span class="math">\\mathbf{v}\\in\\mathbb{F}^{m}</span> build as follows. The root of the tree is a commitment <span class="math">\\mathsf{C}=[\\boldsymbol{\\lambda}]_{1}\\mathbf{v}</span>, where <span class="math">\\boldsymbol{\\lambda}=([\\lambda_{1}(\\tau)]_{1},\\ldots,[\\lambda_{m}(\\tau)]_{1})</span>, for <span class="math">\\{\\lambda_{j}(X)\\}</span> the Lagrange interpolation polynomials for <span class="math">\\mathbb{H}</span>. The two children will be <span class="math">\\mathsf{C}_{0}=[\\boldsymbol{\\lambda}_{0}]_{1}\\mathbf{v}_{0}</span> and <span class="math">\\mathsf{C}_{1}=[\\boldsymbol{\\lambda}_{1}]_{1}\\mathbf{v}_{1}</span>, which are commitments to <span class="math">\\mathbf{v}_{0}</span> and <span class="math">\\mathbf{v}_{1}</span> with keys <span class="math">\\boldsymbol{\\lambda}_{0}</span> and <span class="math">\\boldsymbol{\\lambda}_{1}</span> of half the size to be specified next. The two children of <span class="math">\\mathsf{C}_{0}</span> will be <span class="math">\\mathsf{C}_{00}=[\\boldsymbol{\\lambda}_{10}]_{1}\\mathbf{v}_{10},\\mathsf{C}_{10}=[\\boldsymbol{\\lambda}_{10}]_{1}\\mathbf{v}_{10}</span> and so on. The leaves are commitments <span class="math">\\mathsf{C}_{\\mathbf{b}}</span>, <span class="math">\\mathbf{b}=(b_{\\nu},\\ldots,b_{0})\\in\\{0,1\\}^{\\nu+1}</span> to vectors of size <span class="math">2^{\\kappa}</span>. For any leaf index <span class="math">\\mathbf{b}=(b_{\\nu},\\ldots,b_{0})</span>, we denote $\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}=(b_{j}\\ldots b_{0})<span class="math"> the suffix of size </span>j<span class="math">. Note that </span>\\mathsf{C}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> for </span>j=0,\\ldots,\\nu-1<span class="math"> denotes all the commitments from the root to the leaf </span>\\mathsf{C}_{\\mathbf{b}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">The division into vectors of half the size is done in bit reverse order according to the least significant bit of the binary representation of the index, <span class="math">b_{0}</span>. At the first level, there will be two vectors <span class="math">\\mathbf{v}_{0}, \\mathbf{v}_{1}</span> of size <span class="math">m/2</span> containing all positions of <span class="math">\\mathbf{v}</span> with suffix <span class="math">b_{0} = 0</span> and <span class="math">b_{0} = 1</span>, respectively. At the next level, there will be four vectors <span class="math">\\mathbf{v}_{00}, \\mathbf{v}_{01}, \\mathbf{v}_{10}, \\mathbf{v}_{11}</span> of size <span class="math">m/4</span>, and <span class="math">\\mathbf{v}_{b_{1}b_{0}}</span> indicates all the positions of <span class="math">\\mathbf{v}</span> (in the natural order) that have as suffix <span class="math">b_{1}b_{0}</span> and so on.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The division into commitment keys of half the size will follow a similar pattern. At level 1, the group of roots of unity <span class="math">\\mathbb{H}</span> will be split into <span class="math">\\mathbb{H}^0</span> and <span class="math">\\mathbb{H}^1</span>, according to the least significant bit of the binary representation of the index of the root, i.e. <span class="math">\\mathbb{H}^0</span> consists of all even and <span class="math">\\mathbb{H}^1</span> all odd powers of <span class="math">\\omega</span>. In particular, <span class="math">\\mathbb{H}^0</span> consists of the roots of unity of size <span class="math">m/2</span>, and <span class="math">\\mathbb{H}^1 = \\omega \\mathbb{H}^0</span> is a coset. At level 2, the commitment keys will be associated to <span class="math">\\mathbb{H}^{00}</span>, <span class="math">\\mathbb{H}^{01}</span>, <span class="math">\\mathbb{H}^{10}</span>, <span class="math">\\mathbb{H}^{11}</span> and by the same reasoning, <span class="math">\\mathbb{H}^{00}</span> are the roots of unity of size <span class="math">m/4</span>, <span class="math">\\mathbb{H}^{10} = \\omega^2 \\mathbb{H}^{00}</span>, <span class="math">\\mathbb{H}^{01} = \\omega \\mathbb{H}^{00}</span> and <span class="math">\\mathbb{H}^{11} = \\omega^3 \\mathbb{H}^{00}</span>. More generally, we note that for any <span class="math">0 \\leq j \\leq \\nu</span> and any string <span class="math">(b_j, \\ldots, b_0) \\in \\{0, 1\\}^{j+1}</span>, $\\mathbb{H}^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = \\omega^s \\mathbb{H}_r<span class="math">, for </span>s = \\sum_{i=0}^{j} b_i 2^i<span class="math"> and </span>r = \\frac{m}{2^{j+1}}<span class="math">. The vanishing polynomial associated to </span>\\mathbb{H}^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> will be denoted </span>t^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X) = X^r - (\\omega^s)^r = X^{\\frac{m}{2^{j+1}}} - \\omega^{\\frac{m \\sum_{i=0}^{j} b_i 2^i}{2^{j+1}}}<span class="math">. The Lagrange polynomials associated to the interpolation set </span>\\mathbb{H}^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> with the natural order will be written as </span>\\lambda^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X) = (\\lambda_1^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X), \\ldots, \\lambda_r^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X))<span class="math"> and the commitment key for node </span>\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}<span class="math"> is </span>\\lambda^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = [\\lambda^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(\\tau)]_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As in the multivariate case, to open the commitment to some function <span class="math">f</span> that is a linear function of some chunk <span class="math">\\mathbf{v}_i</span> the prover has to (1) open the root commitment to the leaf and (2) open the commitment to the leaf using the IP argument for the Lagrange basis of Section 5 or the construction of Tomescu et al. [33]. For (2), since at the leaf level the commitment is w.r.t to the key <span class="math">\\lambda^{\\mathbf{b}}</span> for some <span class="math">\\mathbf{b} = (b_{\\nu},\\dots ,b_{0})</span>, we use the following theorem, proven in Appendix D.1, that shows that the construction for inner products of Section 5 works for any coset of roots of unity.</p>

    <p class="text-gray-300"><strong>Theorem 9.</strong> Let <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> be a subset of roots of unity of size <span class="math">m = 2^{\\nu + \\kappa + 1}</span>, for some <span class="math">\\kappa, \\nu \\geq 0</span>. Given some <span class="math">\\mathbf{b} \\in \\{0, 1\\}^{\\nu + 1}</span>, define <span class="math">s = \\sum_{i=0}^{\\nu} b_i 2^i</span>, <span class="math">r = \\frac{m}{2^{\\nu + 1}} = 2^\\kappa</span>, <span class="math">\\mathbb{H}_r \\subset \\mathbb{H}</span> the subgroup of roots of unity of size <span class="math">r</span>, and <span class="math">\\mathbb{H}^{\\mathbf{b}} = \\omega^s \\mathbb{H}_r</span>. Let <span class="math">t^{\\mathbf{b}}(X)</span> be the vanishing polynomial at <span class="math">\\mathbb{H}^{\\mathbf{b}}</span> and <span class="math">\\lambda^{\\mathbf{b}}(X)</span> the associated Lagrange basis polynomials. Then, if <span class="math">A(X) = \\lambda^{\\mathbf{b}}(X) \\cdot \\mathbf{a}</span> and <span class="math">B(X) = \\lambda^{\\mathbf{b}}(X) \\cdot \\mathbf{b}</span>, it holds that <span class="math">\\mathbf{a} \\cdot \\mathbf{b} = y</span> if and only if there exist polynomials <span class="math">H(X), R(X)</span> with <span class="math">\\deg(R) &amp;lt; r - 2</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">A (X) B (X) - r ^ {- 1} y = X R (X) + t ^ {\\mathbf {b}} (X) H (X).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, at any leaf <span class="math">\\mathbf{b}</span> we can open the commitment to any linear relation and verify with the same equation. To open <span class="math">\\mathbb{C}</span> to a certain leaf commitment <span class="math">\\mathbb{C}_i</span>, the idea is to implicitly show from root to leaf that $\\mathsf{C}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}, \\mathsf{C}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j+1}}<span class="math"> agree in </span>\\mathbb{H}^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j+1}}<span class="math">. This is proven by showing that their difference is divisible by </span>t^{(1 - b_{j+1})\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)$. More specifically, we prove the following lemma, that shows how the parent and the children nodes at each level relate through a simple equation:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.</strong> Let <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> be a subgroup of roots of unity of size <span class="math">m = 2^{\\nu + \\kappa + 1}</span>, for some <span class="math">\\kappa, \\nu \\geq 0</span>. Denote <span class="math">\\mathbb{H}_{\\ell} \\subset \\mathbb{H}</span> as the subgroup of size <span class="math">\\ell</span> and define $\\mathbb{H}^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = \\omega^{s} \\mathbb{H}_{r}<span class="math">, and </span>\\mathbb{H}^{0\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = w^{s} \\mathbb{H}_{\\frac{r}{2}}<span class="math"> and </span>\\mathbb{H}^{1\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = w^{s + 2^{j + 1}} \\mathbb{H}_{\\frac{r}{2}}<span class="math">. Let </span>C_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)<span class="math"> be an encoding of vector </span>\\mathbf{v}^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> with respect to key </span>\\lambda^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> as defined above and </span>C_{0\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)<span class="math">, </span>C_{1\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)<span class="math"> those of vectors </span>\\mathbf{v}^{0\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> and </span>\\mathbf{v}^{1\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> with, respectively, keys </span>\\lambda^{\\mathbf{b}_{0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> and </span>\\lambda^{\\mathbf{b}_{1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}$. Then, the following equality holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C _ {\\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X) = t ^ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X) \\frac {C _ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X) - C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X)}{2 \\omega^ {s r}} + C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C _ {\\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X) = t ^ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X) \\frac {C _ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X) - C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X)}{2 \\omega^ {s r}} + C _ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (X)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> We start with the equality $C_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X) = t^{1\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)(C_{0\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X) - C_{1\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X))(2\\omega^{sr})^{-1} + C_{1\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)<span class="math"> and evaluate it in any </span>\\mathsf{h} \\in \\mathbb{H}^{0\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}<span class="math"> and </span>\\mathsf{h}' \\in \\mathbb{H}^{1\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}$, using the result of Lemma 4 in Appendix D.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C _ {\\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf {h}) = t ^ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf {h}) \\frac {C _ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf {h}) - C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf {h})}{2 \\omega^ {s r}} + C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf {h}), \\mathrm {i . e . ,} \\mathbf {v} _ {\\mathsf {h}} ^ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = 2 \\omega^ {s r} \\frac {\\mathbf {v} _ {\\mathsf {h}} ^ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} - C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf {h})}{2 \\omega^ {s r}} + C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf {h}) = \\mathbf {v} _ {\\mathsf {h}} ^ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text {Also, } C _ {\\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} \\left(\\mathrm {h} ^ {\\prime}\\right) = t ^ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} \\left(\\mathrm {h} ^ {\\prime}\\right) \\frac {C _ {0 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} \\left(\\mathrm {h} ^ {\\prime}\\right) - C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} \\left(\\mathrm {h} ^ {\\prime}\\right)}{2 \\omega^ {s r}} + C _ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} \\left(\\mathrm {h} ^ {\\prime}\\right). \\text {Simplifying, } \\mathbf {v} _ {\\mathrm {h} ^ {\\prime}} ^ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = \\mathbf {v} _ {\\mathrm {h} ^ {\\prime}} ^ {1 \\mathbf {b} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Therefore, the left and right side of the equation are polynomials of degree <span class="math">2^r - 1</span> that agree at <span class="math">2^r</span> points, so we conclude they are equal.</p>

    <p class="text-gray-300">For the other case, note that</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf{h}) = t^{0 \\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf{h}) \\frac{C_{0 \\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf{h}) - C_{1 \\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf{h})}{2 \\omega^{s r}} + C_{0 \\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} (\\mathsf{h}) \\text{ and } \\mathbf{v}_{\\mathsf{h}}^{0 \\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = \\mathbf{v}_{\\mathsf{h}}^{0 \\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}. \\text{ Also}, \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\text{ so } \\mathbf{v}_{\\mathbf{h}^{\\prime}}^{1 \\mathbf{b}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">j}} = - 2 \\omega^{s r} \\frac{C_{0 \\mathbf{b}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">j}} (\\mathsf{h}^{\\prime}) - \\mathbf{v}_{\\mathbf{h}^{\\prime}}^{1 \\mathbf{b}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">j}}}{2 \\omega^{s r}} + C_{0 \\mathbf{b}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">j}} (\\mathsf{h}^{\\prime}) = \\mathbf{v}_{\\mathbf{h}^{\\prime}}^{1 \\mathbf{b}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">j}}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Scheme Description. Formally, we present an LVC commitment scheme that works for the function family:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{Ext}_{\\nu} \\mathcal{F}_{p, 2^{\\kappa}} = \\left\\{f: \\mathbb{F}^{m} \\rightarrow \\mathbb{F}, m = 2^{\\kappa + \\nu + 1} \\mid \\exists \\mathbf{f} \\in \\mathbb{F}^{2^{\\kappa}}, i \\in 2^{\\nu} \\text{ s.t. } \\right. \\\\ \\left. \\forall \\mathbf{v}_{1}, \\dots, \\mathbf{v}_{2^{\\nu}} \\in \\mathbb{F}^{2^{\\kappa}}: f(\\mathbf{v}_{1}, \\dots, \\mathbf{v}_{2^{\\nu}}) = \\mathbf{v}_{i} \\cdot \\mathbf{f}\\right) \\end{array}</span></div>

    <p class="text-gray-300">Algorithms LVC.KeyGen and LVC.Commit are the same as the Lagrange basis construction of Section 5 and are omitted. The commitment to <span class="math">\\mathbf{v}</span> is <span class="math">\\mathsf{C} = [\\lambda^{\\top}]_{1}\\mathbf{v}</span> together with the auxiliary input information aux. Note that step 4. of the open algorithm is IP.Open from Section 5.2.</p>

    <p class="text-gray-300">UVTree.Open(pk, b, aux, f, y) → π: 1. Let <span class="math">f(\\mathbf{v}_{0\\dots 0}, \\dots, \\mathbf{v}_{1\\dots 1}) = \\mathbf{v}_{\\mathbf{b}} \\cdot \\mathbf{f}</span> for <span class="math">\\mathbf{f} \\in \\mathbb{F}^{2^{\\kappa}}</span> and some <span class="math">\\mathbf{b} = (b_{\\nu}, \\dots, b_0)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For any <span class="math">0 \\leq j \\leq \\nu</span>, compute $\\mathsf{C}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = [\\lambda^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}]_1 \\mathbf{v}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Compute <span class="math">[H]_1 = (\\mathsf{C}_0 - \\mathsf{C}_1)/2</span>, and for any <span class="math">0 \\leq j \\leq \\nu - 1</span>, compute $K_{b_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}} = (2\\omega^{sr})^{-1}<span class="math"> for </span>s = \\sum_{i=0}^{j} b_i 2^i<span class="math"> and </span>r = \\frac{m}{2^{\\nu+1}}<span class="math">. Then define </span>[H_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}]_1 = K_{b_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(\\mathsf{C}_{0b_j \\dots b_0} - \\mathsf{C}_{1b_j \\dots b_0})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find <span class="math">R(X), H_{\\mathbf{b}}(X)</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\boldsymbol{\\lambda}^{\\mathbf{b}}(X) \\mathbf{v}_{\\mathbf{b}}\\right) \\left(\\sum_{i=1}^{2^{\\kappa}} f_{i} \\lambda_{i}^{\\mathbf{b}}(X)\\right) - y 2^{-\\kappa} = X R(X) + H_{\\mathbf{b}}(X) t^{\\mathbf{b}}(X).</span></div>

    <p class="text-gray-300">Define <span class="math">\\hat{R}(X) = X^{m+2-2^{\\kappa}} R(X)</span>.21 and <span class="math">\\hat{\\mathbf{C}}_{\\mathbf{b}} = [\\hat{C}_{\\mathbf{b}}(\\tau)]_1</span> where <span class="math">\\hat{C}_{\\mathbf{b}} = X^{m-2^{\\kappa}} C_{\\mathbf{b}}(X)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Output $\\pi = ([H]_1, [H_{b_0}]_1, \\ldots, [H_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\nu - 1}}]_1, [H_{\\mathbf{b}}(\\tau)]_1, [R(\\tau)]_1, [\\hat{R}(\\tau)]_1, \\mathsf{C}_{\\mathbf{b}}, \\hat{\\mathsf{C}}_{\\mathbf{b}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">UVTree.Vf(vk, C, f, y, π) → 0/1:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the vector representation <span class="math">\\mathbf{f}</span> of <span class="math">f</span> and compute <span class="math">\\mathsf{C}_f = \\sum_{i=1}^{2^{\\kappa}} f_i [\\lambda_i^{\\mathbf{b}}(\\tau)]_2</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e \\left(\\mathrm{C} - \\mathrm{C}_{\\mathbf{b}}, 1\\right) = e \\left([H]_1, [t^{b_0}(\\tau)]_2\\right) + \\sum_{j=0}^{\\nu-1} e \\left([H_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}]_1, [t^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j+1}}(\\tau)]_2\\right) \\tag{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\mathrm{C}_{\\mathbf{b}}, \\mathrm{C}_f\\right) - e \\left(2^{-\\kappa} y [1]_1, [1]_2\\right) = e \\left([R]_1, [1]_2\\right) + e \\left([H_{\\mathbf{b}}]_1, [t^{\\mathbf{b}}(\\tau)]_2\\right) \\tag{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left([R]_1, [\\tau^{m+2-2^{\\kappa}}]_2\\right) = e \\left([\\hat{R}]_1, [1]_2\\right) \\tag{4}</span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\mathrm{C}_{\\mathbf{b}}, [\\tau^{m-2^{\\kappa} + 1}]_2\\right) = e \\left(\\hat{\\mathrm{C}}_{\\mathbf{b}}, [1]_2\\right) \\tag{5}</span></div>

    <p class="text-gray-300">Maintainability. The cost of computing all proofs is <span class="math">O(\\nu m)</span>. For each piece <span class="math">\\mathbf{v}_i</span> with <span class="math">O(\\kappa 2^{\\kappa})</span> operations one can compute the coefficients in the monomial basis. Following Lemma 2, the parent node can be computed in cost dominated by <span class="math">2^{\\kappa} = \\frac{m}{2^{\\nu + 1}}</span> exponentiations from the expression of children nodes, and since there are <span class="math">2^{\\nu}</span> parent nodes the cost is dominated by <span class="math">\\frac{m}{2}</span> exponentiations. Going one level up, the vector size doubles but the number of nodes is halved. We conclude that to compute all proofs one needs <span class="math">O(\\kappa 2^{\\kappa} + \\nu \\frac{m}{2})</span>. The number of proofs to store (including leaf commitments) is <span class="math">2^{\\nu + 1} - 1</span>.</p>

    <p class="text-gray-300">Theorem 10. When instantiated with a function binding argument for inner product relations <span class="math">\\mathsf{IP}</span>, the scheme above is a function binding LVC argument under the AGM if the <span class="math">(m, m)</span>-DLOG assumption holds.</p>

    <p class="text-gray-300">21 We assume as most <span class="math">m</span> powers of <span class="math">\\tau</span> are in the SRS in group <span class="math">\\mathbb{G}_1</span>. The degree check is meant to ensure that <span class="math">R(X)</span> is of degree at most <span class="math">2^{\\kappa} - 2</span>.</p>

    <p class="text-gray-300">31</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adversary against the function binding game as in Definition 3. We will see, through game reductions, that the advantage of <span class="math">\\mathcal{A}</span> in strong function binding is negligible even for <span class="math">k=2</span>, that is, for two non-compatible functions <span class="math">f_{1},f_{2}</span>. Note that for two functions to be non compatible they must be defined on the same block <span class="math">\\mathbf{b}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{A}</span> plays <span class="math">\\mathsf{Game}_{0}</span>, the strong function binding game as in Definition 3, and outputs <span class="math">(\\mathsf{C},\\{f_{k},y_{k},\\bm{\\pi}_{k}\\}_{k=1,2})</span>, where $\\bm{\\pi}_{1}=([H]_{1},\\{[H_{\\mathbf{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{j}}]_{1},\\}_{j=0}^{\\nu-1},[H_{\\mathbf{b}}]_{1},[R]_{1},[\\hat{R}]_{1},\\mathsf{C}_{\\mathbf{b}},\\hat{\\mathsf{C}}_{\\mathbf{b}}),\\bm{\\pi}_{2}=([H^{\\prime}]_{1},\\{[H^{\\prime}_{\\mathbf{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{j}}]_{1}\\}_{j=0}^{\\nu-1},[H^{\\prime}_{\\mathbf{b}}]_{1},[R^{\\prime}]_{1},[\\hat{R}^{\\prime}]_{1},\\mathsf{C}^{\\prime}_{\\mathbf{b}},\\hat{\\mathsf{C}}^{\\prime}_{\\mathbf{b}})<span class="math">, s.t. </span>\\mathsf{LVC.Verify}(\\mathsf{vk},\\mathsf{C},f_{1},y_{1},\\bm{\\pi}_{1})=1<span class="math">, </span>\\mathsf{LVC.Verify}(\\mathsf{vk},\\mathsf{C},f_{2},y_{2},\\bm{\\pi}_{2})=1<span class="math">, and wins if there exists no </span>\\mathbf{v}\\in\\mathbb{F}^{m}<span class="math"> such that </span>f_{1}(\\mathbf{v})=y_{1}<span class="math"> and </span>f_{2}(\\mathbf{v})=y_{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall <span class="math">\\mathcal{A}</span> is algebraic and thus we assume one can extract polynomials <span class="math">C_{\\mathbf{b}}(X),C^{\\prime}_{\\mathbf{b}}(X),\\hat{C}_{\\mathbf{b}}(X),\\hat{C}^{\\prime}_{\\mathbf{b}}(X)</span> which are, algebraic representations of <span class="math">\\mathsf{C}_{\\mathbf{b}},\\mathsf{C}^{\\prime}_{\\mathbf{b}}</span> and <span class="math">H(X),H^{\\prime}(X),H_{\\mathbf{b}}(X),H^{\\prime}_{\\mathbf{b}}(X)</span>, $\\{H_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X),H^{\\prime}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)\\}_{j=0}^{\\nu-1}<span class="math"> the ones for </span>[H]_{1},[H^{\\prime}]_{1},[H_{\\mathbf{b}}]_{1},[H^{\\prime}_{\\mathbf{b}}]_{1}<span class="math">, </span>\\{[H_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}]_{1},[H^{\\prime}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}]_{1}\\}_{j=0}^{\\nu-1}$, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Game}_{1}</span> be exactly as <span class="math">\\mathsf{Game}_{0}</span> but the game aborts if <span class="math">C_{\\mathbf{b}}(X)</span> or <span class="math">C^{\\prime}_{\\mathbf{b}}(X)</span> are polynomials of degree more than <span class="math">2^{\\kappa}-1</span>. If this is not the case, it is easy to find <span class="math">\\tau</span> by observing that in this case either <span class="math">C_{\\mathbf{b}}(X)X^{m-2^{\\kappa}+1}-\\hat{C}(X)</span> or <span class="math">C^{\\prime}_{\\mathbf{b}}(X)X^{m-2^{\\kappa}+1}-\\hat{C}^{\\prime}(X)</span> is a non-zero polynomial with a root in <span class="math">\\tau</span> so the difference between both games is bounded by the advantage of any adversary against the <span class="math">(m-1,m)</span>-DLOG problem.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Game}_{2}</span> be exactly as <span class="math">\\mathsf{Game}_{1}</span> but upon receiving <span class="math">\\bm{\\pi}_{1},\\bm{\\pi}_{2}</span>, it checks if <span class="math">\\mathsf{C}_{\\mathbf{b}}</span> and <span class="math">\\mathsf{C}^{\\prime}_{\\mathbf{b}}</span> are equal and aborts otherwise. We next bound the probability of abort.</p>

    <p class="text-gray-300">Define the polynomial</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p(X)=C_{\\mathbf{b}}(X)-C^{\\prime}_{\\mathbf{b}}(X)-(H(X)-H^{\\prime}(X))t^{b_{0}}(X)+\\sum_{j=0}^{\\nu-1}(H_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)-H^{\\prime}_{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X))t^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j+1}}(X),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is the difference of verification equation (2) for each commitment. If <span class="math">p(X)\\neq 0</span>, the output of the adversary can be used to construct an adversary against the <span class="math">(m-1,m)</span>-DLOG assumption, since <span class="math">\\tau</span> is a root of <span class="math">p(X)</span>. On the other hand, if <span class="math">p(X)=0</span>, <span class="math">C_{\\mathbf{b}}(X)-C^{\\prime}_{\\mathbf{b}}(X)</span> can be written as a sum of terms that are multiples of $t^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)<span class="math"> for </span>j=0,\\ldots,\\nu<span class="math">. But all of these vanishing polynomials evaluate to </span>0<span class="math"> in </span>\\mathsf{h}\\in\\mathbb{H}^{\\mathbf{b}}<span class="math">, since </span>t^{\\mathbf{b}}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j}}(X)<span class="math"> for </span>j=0,\\ldots,\\nu<span class="math">. Therefore, </span>C_{\\mathbf{b}}(X)-C^{\\prime}_{\\mathbf{b}}(X)<span class="math"> is also </span>0<span class="math"> when evaluated at the coset. But since this polynomial is of degree at most </span>2^{k}<span class="math">, </span>C_{\\mathbf{b}}(X)=C^{\\prime}_{\\mathbf{b}}(X)<span class="math"> which implies that necessarily </span>\\mathsf{C}_{\\mathbf{b}}=\\mathsf{C}^{\\prime}_{\\mathbf{b}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, in <span class="math">\\mathsf{Game}_{2}</span>, except with negligible probability the leaf commitment is the same and the probability that the adversary wins is the same as in the strong function binding game of the inner product commitment. ∎</p>

    <h2 id="sec-66" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] H. Abusalah, J. Alwen, B. Cohen, D. Khilko, K. Pietrzak, and L. Reyzin. Beyond hellman’s time-memory trade-offs with applications to proofs of space. In T. Takagi and T. Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 357–379. Springer, Heidelberg, Dec. 2017.</li>

      <li>[2] D. F. Aranha, E. Pagnin, and F. Rodríguez-Henríquez. Love a pairing. In International Conference on Cryptology and Information Security in Latin America, pages 320–340. Springer, 2021.</li>

      <li>[3] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019.</li>

      <li>[4] D. Boneh and X. Boyen. Efficient selective identity-based encryption without random oracles. Journal of Cryptology, 24(4):659–693, Oct. 2011.</li>

      <li>[5] D. Boneh, B. Bünz, and B. Fisch. Batching techniques for accumulators with applications to IOPs and stateless blockchains. In A. Boldyreva and D. Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 561–586. Springer, Heidelberg, Aug. 2019.</li>

      <li>[6] S. Bowe. Bls12-381: New zk-snark elliptic curve construction. Zcash Company blog, URL: https://z.cash/blog/new-snark-curve, 2017.</li>

      <li>[7] B. Bünz, M. Maller, P. Mishra, N. Tyagi, and P. Vesely. Proofs for inner pairing products and applications. In M. Tibouchi and H. Wang, editors, Advances in Cryptology - ASIACRYPT 2021 - 27th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 6-10, 2021, Proceedings, Part III, volume 13092 of Lecture Notes in Computer Science, pages 65–97. Springer, 2021.</li>

      <li>[</li>

    </ul>

    <p class="text-gray-300">8] M. Campanelli, D. Fiore, N. Greco, D. Kolonelos, and L. Nizzardo. Incrementally aggregatable vector commitments and applications to verifiable decentralized storage. In S. Moriai and H. Wang, editors, ASIACRYPT 2020, Part II, volume 12492 of LNCS, pages 3–35. Springer, Heidelberg, Dec. 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[9] M. Campanelli, D. Fiore, S. Han, J. Kim, D. Kolonelos, and H. Oh. Succinct zero-knowledge batch proofs for set accumulators. Cryptology ePrint Archive, 2021.</li>

      <li>[10] D. Catalano and D. Fiore. Vector commitments and their applications. In K. Kurosawa and G. Hanaoka, editors, PKC 2013, volume 7778 of LNCS, pages 55–72. Springer, Heidelberg, Feb. / Mar. 2013.</li>

      <li>[11] A. Chepurnoy, C. Papamanthou, and Y. Zhang. Edrax: A cryptocurrency with stateless transaction validation. Cryptology ePrint Archive, Report 2018/968, 2018. https://eprint.iacr.org/2018/968.</li>

      <li>[12] V. Daza, C. Ràfols, and A. Zacharakis. Updateable inner product argument with logarithmic verifier and applications. In A. Kiayias, M. Kohlweiss, P. Wallden, and V. Zikas, editors, PKC 2020, Part I, volume 12110 of LNCS, pages 527–557. Springer, Heidelberg, May 2020.</li>

      <li>[13] S. Dziembowski, S. Faust, V. Kolmogorov, and K. Pietrzak. Proofs of space. In R. Gennaro and M. J. B. Robshaw, editors, CRYPTO 2015, Part II, volume 9216 of LNCS, pages 585–605. Springer, Heidelberg, Aug. 2015.</li>

      <li>[14] Filecoin. Filecoin powers of tau ceremony attestations, 2020. https://github.com/arielgabizon/perpetualpowersoftau.</li>

      <li>[15] B. Fisch. PoReps: Proofs of space on useful data. Cryptology ePrint Archive, Report 2018/678, 2018. https://eprint.iacr.org/2018/678.</li>

      <li>[16] B. Fisch. Tight proofs of space and replication. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019, Part II, volume 11477 of LNCS, pages 324–348. Springer, Heidelberg, May 2019.</li>

      <li>[17] G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applications. In H. Shacham and A. Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 33–62. Springer, Heidelberg, Aug. 2018.</li>

      <li>[18] S. Gorbunov, L. Reyzin, H. Wee, and Z. Zhang. Pointproofs: Aggregating proofs for multiple vector commitments. In J. Ligatti, X. Ou, J. Katz, and G. Vigna, editors, ACM CCS 2020, pages 2007–2023. ACM Press, Nov. 2020.</li>

      <li>[19] L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. Poseidon: A new hash function for {Zero-Knowledge} proof systems. In 30th USENIX Security Symposium (USENIX Security 21), pages 519–535, 2021.</li>

      <li>[20] J. Groth. On the size of pairing-based non-interactive arguments. In M. Fischlin and J.-S. Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</li>

      <li>[21] J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. Updatable and universal common reference strings with applications to zk-SNARKs. In H. Shacham and A. Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 698–728. Springer, Heidelberg, Aug. 2018.</li>

      <li>[22] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In M. Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, Dec. 2010.</li>

      <li>[23] J. Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

      <li>[24] R. W. F. Lai and G. Malavolta. Subvector commitments with application to succinct arguments. In A. Boldyreva and D. Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 530–560. Springer, Heidelberg, Aug. 2019.</li>

      <li>[25] B. Libert, S. C. Ramanna, and M. Yung. Functional commitment schemes: From polynomial commitments to pairing-based accumulators from simple assumptions. In I. Chatzigiannakis, M. Mitzenmacher, Y. Rabani, and D. Sangiorgi, editors, ICALP 2016, volume 55 of LIPIcs, pages 30:1–30:14. Schloss Dagstuhl, July 2016.</li>

      <li>[26] B. Libert and M. Yung. Concise mercurial vector commitments and independent zero-knowledge sets with short proofs. In D. Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 499–517. Springer, Heidelberg, Feb. 2010.</li>

      <li>[27] R. C. Merkle. A digital signature based on a conventional encryption function. In C. Pomerance, editor, CRYPTO’87, volume 293 of LNCS, pages 369–378. Springer, Heidelberg, Aug. 1988.</li>

      <li>[28] S. Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, Nov. 1994.</li>

      <li>[29] C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct computation. In A. Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 222–242. Springer, Heidelberg, Mar. 2013.</li>

      <li>[30] C. Ràfols and A. Zapico. An algebraic framework for universal and updatable SNARKs. In T. Malkin and C. Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 774–804, Virtual Event, Aug. 2021. Springer, Heidelberg.</li>

      <li>[31] L. Ren and S. Devadas. Proof of space from stacked expanders. In M. Hirt and A. D. Smith, editors, TCC 2016-B, Part I, volume 9985 of LNCS, pages 262–285. Springer, Heidelberg, Oct. / Nov. 2016.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S. Srinivasan, A. Chepurnoy, C. Papamanthou, A. Tomescu, and Y. Zhang. Hyperproofs: Aggregating and maintaining proofs in vector commitments. In 31st USENIX Security Symposium (USENIX Security 22), Boston, MA, Aug. 2022. USENIX Association. 5, 6, 7, 22, 23, 29</li>

      <li>A. Tomescu, I. Abraham, V. Buterin, J. Drake, D. Feist, and D. Khovratovich. Aggregatable subvector commitments for stateless cryptocurrencies. In C. Galdi and V. Kolesnikov, editors, SCN 20, volume 12238 of LNCS, pages 45-64. Springer, Heidelberg, Sept. 2020. 2, 5, 7, 9, 18, 19, 22, 30, 38</li>

      <li>A. Tomescu, R. Chen, Y. Zheng, I. Abraham, B. Pinkas, G. Golan-Gueta, and S. Devadas. Towards scalable threshold cryptosystems. In 2020 IEEE Symposium on Security and Privacy, pages 877-893. IEEE Computer Society Press, May 2020. 5, 7, 22, 29</li>

    </ol>

    <p class="text-gray-300">In this section we provide the classical definitions of vector commitments (VC), introduced by Catalano and Fiore [10], and subvector commitments (SVC), as in [5, 24], that are particular cases of Linear-map Vector Commitments (LVC).</p>

    <p class="text-gray-300">Definition 8 (Vector Commitment). A vector commitment for vectors from the message space  <span class="math">\\mathcal{M}</span>  is a tuple of PPT algorithms (KeyGen, Commit, Open, Vf) that work as follows:</p>

    <p class="text-gray-300">VC.KeyGen(1 <span class="math">\\lambda</span> ,  <span class="math">\\mathcal{M}</span> ,  <span class="math">m</span> ) → prk, vrk: On input the security parameter  <span class="math">\\lambda</span> , the message space  <span class="math">\\mathcal{M}</span>  for the vectors and the maximum vector length  <span class="math">m^{22}</span> . It returns  <span class="math">s</span>  proving key prk that includes  <span class="math">\\mathcal{M}</span> , and a verification key vrk.</p>

    <p class="text-gray-300">VC.Commit(prk, v)  <span class="math">\\rightarrow</span>  (C, aux): Takes prk and a vector  <span class="math">\\mathbf{v} = (v_{1}, v_{2}, \\ldots, v_{m}) \\in \\mathcal{M}^{m}</span> , and returns a commitment C and auxiliary information aux.</p>

    <p class="text-gray-300">VC.Open(prk, aux, i,  <span class="math">v_{i}</span> ) →  <span class="math">\\pi_{i}</span> : On input prk, aux, an index  <span class="math">i \\in [n]</span> , and a value  <span class="math">v_{i}</span> , it outputs a proof  <span class="math">\\pi_{i}</span>  that the value  <span class="math">v_{i}</span>  is at position  <span class="math">i</span> .</p>

    <p class="text-gray-300">VC.Vf(vrk, C, i, v, πi) → b ∈ {0, 1}: On input vrk, C, i ∈ [m], a value v ∈ M and πi, it outputs 1 if the proof verifies and 0 otherwise.</p>

    <p class="text-gray-300">Perfect Correctness A VC scheme is perfectly correct if, for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , any vector length  <span class="math">m = \\mathrm{poly}(\\lambda)</span>  any index  <span class="math">i\\in [n]</span> , and any  <span class="math">\\mathbf{v}\\in \\mathcal{M}^m</span> , we have:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathsf {V C . V f} (\\mathsf {v r k}, \\mathsf {C}, i, v _ {i}, \\pi_ {i}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {p r k}, \\mathsf {v r k}) \\leftarrow \\mathsf {V C . K e y G e n} (1 ^ {\\lambda}, \\mathcal {M}, m) \\\\ (\\mathsf {C}, \\mathsf {a u x}) \\leftarrow \\mathsf {V C . C o m m i t} (\\mathsf {p r k}, \\mathbf {v}) \\\\ \\pi_ {i} \\leftarrow \\mathsf {V C . O p e n} (\\mathsf {p r k}, \\mathsf {a u x}, i, v _ {i}) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Strong Position Binding A VC scheme satisfies strong position binding if, for all PPT adversaries  <span class="math">\\mathcal{A}</span> , for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , any vector length  <span class="math">m = \\mathrm{poly}(\\lambda)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathsf {V C . V f} (\\mathsf {v r k}, \\mathsf {C}, i, v, \\pi) = 1 \\\\ \\wedge \\mathsf {V C . V f} (\\mathsf {v r k}, \\mathsf {C}, i, v ^ {\\prime}, \\pi^ {\\prime}) = 1 \\\\ \\wedge v \\neq v ^ {\\prime} \\end{array} \\right] \\left( \\begin{array}{c} (\\mathsf {p r k}, \\mathsf {v r k}) \\leftarrow \\mathsf {V C . K e y G e n} (1 ^ {\\lambda}, \\mathcal {M}, m) \\\\ (\\mathsf {C}, i, (v, \\pi), (v ^ {\\prime}, \\pi^ {\\prime})) \\leftarrow \\mathcal {A} (\\mathsf {p r k}, \\mathsf {v r k}) \\end{array} \\right) = \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Weak Position Binding If we relax the definition above to hold only for honestly-generated commitments  <span class="math">\\mathsf{C}</span> , we obtain a weak position binding notion. In other words, for all PPT adversaries  <span class="math">\\mathcal{A}</span> , for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , any vector length  <span class="math">m = \\mathrm{poly}(\\lambda)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathsf {V C . V f} (\\mathsf {v r k}, \\mathsf {C}, i, v, \\pi) = 1 \\\\ \\wedge \\mathsf {V C . V f} (\\mathsf {v r k}, \\mathsf {C}, i, v ^ {\\prime}, \\pi^ {\\prime}) = 1 \\\\ \\wedge y \\neq y ^ {\\prime} \\end{array} \\right] \\left( \\begin{array}{c} (\\mathsf {p r k}, \\mathsf {v r k}) \\leftarrow \\mathsf {V C . K e y G e n} (1 ^ {\\lambda}, \\mathcal {M}) \\\\ (\\mathsf {v}, i, v, \\pi , v ^ {\\prime}, \\pi^ {\\prime}) \\leftarrow \\mathcal {A} (\\mathsf {p r k}, \\mathsf {v r k}) \\\\ (\\mathsf {C}, \\mathsf {a u x}) \\leftarrow \\mathsf {V C . C o m m i t} (\\mathsf {p r k}, \\mathbf {v}) \\end{array} \\right] = \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Definition 9 (Sub-Vector Commitment). A Sub-Vector Commitment scheme is a VC scheme that opens subsets rather than positions. It consists on algorithms (SVC.KeyGen, SVC.Commit, SVC.Open, SVC.Vf) that work as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SVC.KeyGen}(1^{\\lambda},\\mathcal{M},m)\\to\\mathsf{prk},\\mathsf{vrk}</span>: <em>Takes the security parameter <span class="math">\\lambda</span>, the message space <span class="math">\\mathcal{M}</span> for the vectors elements and the maximum vector length <span class="math">m</span>. It outputs a proving key <span class="math">\\mathsf{prk}</span> and verification key <span class="math">\\mathsf{vrk}</span>.</em></p>

    <p class="text-gray-300"><span class="math">\\mathsf{SVC.Commit}(\\mathsf{prk},\\mathbf{v})\\to(\\mathsf{C},\\mathsf{aux})</span>: <em>On <span class="math">\\mathsf{prk}</span> and a vector <span class="math">\\mathbf{v}=(v_{1},v_{2}\\ldots,v_{m})\\in\\mathcal{M}^{m}</span>, returns a commitment <span class="math">\\mathsf{C}</span> and auxiliary information <span class="math">\\mathsf{aux}</span>.</em></p>

    <p class="text-gray-300"><span class="math">\\mathsf{SVC.Open}(\\mathsf{prk},\\mathsf{aux},I,\\mathbf{v}_{I})\\to\\pi_{I}</span> : <em>Takes as input <span class="math">\\mathsf{prk}</span>, <span class="math">\\mathsf{aux}</span>, a set of index <span class="math">I\\subset[m]</span> and values <span class="math">\\mathbf{v}_{I}=\\{v_{i}\\}_{i\\in I}</span> and outputs a proof <span class="math">\\pi_{I}</span> that <span class="math">v_{i}</span> is the value in position <span class="math">i</span>, for all <span class="math">i\\in I</span>.</em></p>

    <p class="text-gray-300"><span class="math">\\mathsf{SVC.Vf}(\\mathsf{vrk},\\mathsf{C},I,\\mathbf{y},\\pi_{I})\\to b\\in\\{0,1\\}</span> : <em>Takes as input <span class="math">\\mathsf{vrk}</span>, <span class="math">\\mathsf{C}</span>, <span class="math">I</span>, a vector <span class="math">\\mathbf{y}=\\{y_{i}\\}_{i\\in I}</span> and <span class="math">\\pi_{I}</span>. It outputs 1 for accept or 0 for reject.</em></p>

    <h4 id="sec-68" class="text-lg font-semibold mt-6">SVC correctness</h4>

    <p class="text-gray-300">An SVC scheme is <em>perfectly correct</em> if, for all <span class="math">\\lambda\\in\\mathbb{N}</span>, any vector length <span class="math">m=\\mathsf{poly}(\\lambda)</span>, any index set <span class="math">I\\subset[m]</span>, and any <span class="math">\\mathbf{v}\\in\\mathcal{M}^{m}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{SVC.Vf}(\\mathsf{vrk},C,I,\\mathbf{v}_{I},\\pi_{I})=1\\begin{vmatrix}(\\mathsf{prk},\\mathsf{vrk})\\leftarrow\\mathsf{VC.KeyGen}(1^{\\lambda},\\mathcal{M},m)\\cr(\\mathsf{C},\\mathsf{aux})\\leftarrow\\mathsf{VC.Commit}(\\mathsf{prk},\\mathbf{v})\\\\ \\pi_{I}\\leftarrow\\mathsf{SVC.Open}(\\mathsf{prk},\\mathsf{aux},I,\\mathbf{v}_{I})\\end{vmatrix}\\right]=1.</span></p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">SVC binding.</h4>

    <p class="text-gray-300">Binding captures the impossibility of creating inconsistent openings for subvectors. An SVC scheme satisfies <em>strong position binding</em> if, for all <span class="math">\\mathsf{PPT}</span> adversaries <span class="math">\\mathcal{A}</span>, for all <span class="math">\\lambda\\in\\mathbb{N}</span>, any vector length <span class="math">m=\\mathsf{poly}(\\lambda)</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{SVC.Vf}(\\mathsf{vrk},\\mathsf{C},I,\\mathbf{y},\\pi_{I})=1\\ \\wedge\\ \\mathsf{SVC.Vf}(\\mathsf{vrk},\\mathsf{C},J,\\mathbf{y}^{\\prime},\\pi_{J})=1\\ \\right.\\left.\\ \\big{\\langle}\\begin{array}[]{c}\\mathsf{SVC.Vf}(\\mathsf{vrk},\\mathsf{C},J,\\mathbf{y}^{\\prime},\\pi_{J})=1\\\\ \\wedge\\exists i\\in I\\cap J\\text{ s.t. }y_{i}\\neq y_{i}^{\\prime}\\end{array}\\right\\vert\\begin{array}[]{c}\\mathsf{(prk},\\mathsf{vrk})\\leftarrow\\mathsf{VC.KeyGen}(1^{\\lambda},\\mathcal{M},m)\\cr\\binom{\\mathsf{C},I,J,\\cr\\mathbf{y},\\pi_{I},\\mathbf{y}^{\\prime},\\pi_{J}}{\\mathbf{y},\\pi_{I},\\mathbf{y}^{\\prime},\\pi_{J}}\\end{array}\\right\\}=\\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">Weak Position Binding is considering the definition above to hold only for <em>honestly-generated</em> commitments <span class="math">C</span> computed via <span class="math">\\mathsf{SVC.Commit}</span>.</p>

    <h2 id="sec-70" class="text-2xl font-bold">Appendix B Vector Commitment Applications</h2>

    <p class="text-gray-300">Here we describe in more detail some of the applications of our work and their specific requirements.</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">B.1 Verifiable Databases</h3>

    <p class="text-gray-300">Vector commitments are a solution for the problem of outsourcing storage to untrusted parties. In the verifiable database (VDB) setting, a client owns a database <span class="math">\\mathsf{D}</span> and wishes to outsource the storage of <span class="math">\\mathsf{D}</span> to a server while keeping the ability to query and update the database. The security goal is to prevent an untrusted server from tampering with the database and cheat on the query outcomes that it provides to the client. A good solution should enable the client to run efficiently once the outsourcing has been performed. Furthermore, the communication and running time of the query and update protocols should not depend on the total size of the database.</p>

    <p class="text-gray-300">The basic problem of integrity of outsourced data can be easily solved by using the celebrated Merkle tree construction <em>[27]</em>. It consists in hashing the data using a tree structure in which the leaves are the blocks of <span class="math">\\mathsf{D}</span> and every internal node is the hash of its two child nodes; the root of this tree is the so-called Merkle hash (digest) of <span class="math">\\mathsf{D}</span>. To use Merkle trees to solve the outsourced storage problem, the client can compute the Merkle tree and store only the root. When the client wants to retrieve the <span class="math">k</span>-th record <span class="math">\\mathsf{D}_{k}</span>, the server responds with the data and a logarithmic-size path consisting of the nodes from <span class="math">\\mathsf{D}_{k}</span> until the root, and the client can then verify the authenticity of <span class="math">\\mathsf{D}_{k}</span> in logarithmic time by recomputing a hashed value using the path and check it against the stored digest (Merkle root). The security of this construction can be reduced to the collision resistance of the hash function <em>[27]</em>. In terms of efficiency, the communication complexity of this protocol is <span class="math">O(\\log n)</span>.</p>

    <p class="text-gray-300">While Merkle trees solution is asymptotically better than resending the entire database, Vector Commitments allow to improve the communication complexity beyond logarithmic and to add important properties such as updatability or functional openings.</p>

    <p class="text-gray-300">B.2 Stateless Cryptocurrency</p>

    <p class="text-gray-300">One of an important decentralised applications of vector commitments is in distributed ledger-based payment systems, known as cryptocurrencies. The best-known examples of cryptocurrency largely used today are Bitcoin, Ethereum, or Zcash to name a few. Such a system, utilises a blockchain in order to post and record peer-to-peer payment transactions. This translates into an ordered log of transactions, in other words an append-only public ledger, that is replicated across nodes in the network. We will call such nodes that store and check the transactions log <em>validators</em>, as opposed to simple cryptocurrency users who only store their account balances. The validators are essential to reach consensus on what is the current state of the public ledger.</p>

    <p class="text-gray-300">Unfortunately, there is a bottleneck: verifying the validity of a transaction requires querying the entire ledger to obtain the latest state of the account balances. However, maintaining the entire ledger increases the memory requirements and reduces the number of possible validators.</p>

    <p class="text-gray-300">To reduce the amount of storage required of validators, there have been solutions <em>[5, 11]</em> based on vector commitments. Instead of storing the entire ledger state, the validators can keep commitments to vectors representing the state. Using vector commitments properties, validators with a commitment to the ledger state can still validate transactions sent by users by checking opening proofs against the commitment. More concretely, the users will send their account balance values and a proof that this is consistent with respect to the commitments stored by the validators. After the transaction is accepted, the validators should be able to update the commitment to the old state to a commitment to the new state that includes the changes made by the transaction. If the vector commitment scheme has small commitment sizes, short proofs, efficient opening computation and allow for updates, then such a solution provides the best trade-off between storage, bandwidth, and computation.</p>

    <p class="text-gray-300">We call such a solution a <em>stateless cryptocurrency</em>, i.e. a system where neither validators nor cryptocurrency users need to store the full ledger state. While the stateless cryptocurrencies overcome the storage overhead when performing transaction validation, they increase network communication because of extra opening proofs added to each transaction payload. To minimise communication in the transactions, an important feature of vector commitments is aggregation. Using aggregation to ”pack” together multiple opening proofs for a batch of transactions into a single constant-size proof allows a significant improvement in the communication.</p>

    <p class="text-gray-300">Another important property for applications to stateless cryptocurrencies is <em>maintainability</em>. This guarantees that re-proving an opening about the new state requires less time than computing it from scratch, which would make all previous computations useless. Instead, the individual proofs are initially computed and <em>stored</em> and <em>efficiently updated</em> after each state transition. Collective updates or maintainability saves computational resources since computing a single proof needs linear time while updating <em>all proofs</em> needs sublinear (e.g. logarithmic time).</p>

    <p class="text-gray-300">To summarize, in order to provide the best trade-off between storage, bandwidth, and computation in stateless cryptocurrency application, the following properties are required from a VC scheme:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>validators store only a commitment to the ledger state.</li>

      <li>to submit a transaction, users will send their account balance values and a proof that this is consistent with respect to the commitments stored by the validators.</li>

      <li>to validate transactions, validators check opening proofs against the commitment.</li>

      <li>after the transaction is accepted, the validators should be able to update the commitment to the old state to a commitment to the new state that includes the changes made by the transaction.</li>

      <li>to minimise communication in the transactions, some nodes can ”pack” together multiple opening proofs for a batch of transactions into a single small proof.</li>

      <li>to save proving time at each update, maintaining all the proofs up to date should be possible in sublinear time each time the state changes.</li>

    </ul>

    <h3 id="sec-72" class="text-xl font-semibold mt-8">B.3 Proof of Space</h3>

    <p class="text-gray-300">Proof-of-Space (PoS) is an eco-friendly alternative to proof-of-work (PoW) in blockchain-based consensus mechanisms that does not consume its resource (space vs. energy), but rather reuses it. A PoS, was introduced in <em>[13]</em> and further studied in <em>[31, 1, 16]</em>. It is an interactive protocol between a prover and a verifier that allows to check if the prover is storing intactly a file (data) that uses a specified amount of</p>

    <p class="text-gray-300">disk space. The protocol must have compact communication relative to the prover’s space requirements and efficient verification. A PoS is persistent if repeated audits force the prover to permanently store the file over a period of time.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof of Space.</h6>

    <p class="text-gray-300">protocols consist of two main steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization (Setup phase): On public input <span class="math">\\mathbf{v}</span>, an <em>advice</em> <span class="math">\\mathbf{a}</span> (e.g., vector of random data) of size <span class="math">m</span> is created and committed to in <span class="math">\\mathsf{C}</span>. The advice is stored by the prover, while the verifier knows only the commitment <span class="math">\\mathsf{C}</span> to the advice.</li>

      <li>Execution (Audit phase): The verifier sends a challenge, for example asking the prover to open some positions in the advice and the prover responds. The verifier outputs accept if they are convinced that the prover stores the advice. This phase can be repeated many times.</li>

    </ul>

    <p class="text-gray-300">We require that the verifier is highly efficient in both phases, whereas the prover is highly efficient in the execution phase if they are honest and had stored the data as expected. Otherwise, if the prover deleted parts of the file, regenerating the advice in order to pass the audit phase should be more costly (in time or computation cost) than just storing the file. A PoS can be run non-interactively using a public blockchain to perform the Setup and the Audit phase of the protocol described above. Provers and verifiers will post their challenge-response in the blockchain and this should be publicly verifiable.</p>

    <h4 id="sec-74" class="text-lg font-semibold mt-6">Publicly Verifiable Proof of Space.</h4>

    <p class="text-gray-300">A classical publicly verifiable PoS is based on Merkle trees and random spot-checks. A drawback of this construction is that proofs grow with the number of spotchecks (and the size of the tree) and become undesirably large to be stored in a blockchain. While these checks can be compressed through a SNARK (Succinct Non-interactive Argument of Knowledge) <em>[20]</em>, this still require hundreds of GB of RAM and tens of minutes compared to our vector commitment solution.</p>

    <p class="text-gray-300">For a construction of PoS based on vector commitments, the prover (miner) uses a VC to commit to a file (seen as a vector of blocks); then at every audit the verifier chooses a challenge by picking a set of many randomly chosen positions, and the prover responds by sending the subvector and an opening proof. The soundness property of a PoS scheme requires that for any prover that convinces the verifier that it is storing the file, there exists an algorithm called the extractor that interacts with the prover and extracts the file.</p>

    <p class="text-gray-300">A vector commitment construction with openings for subvectors immediately implies a publicly-verifiable proof of storage.</p>

    <p class="text-gray-300">Finally, our tree-based constructions allows reduced proving costs in the audit phase of PoS by instead using some extra memory to store proofs. A prover can efficiently pre-compute and store proofs and simply serve them on demand. Since memory is expensive, however, it is not optimal to store all the proofs. Our construction is flexible: a prover only stores <em>partial proofs</em> to reduce computation. Importantly, the part of the proof that is computed on the fly has constant size and therefore the proof size only depends on the amount of memory dedicated by the prover. Finally, our proofs can be aggregated using standard techniques <em>[7]</em>. The smaller proof size translates to a cheaper aggregation cost.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">B.4 Compiling SNARKs from Vector Commitments</h3>

    <p class="text-gray-300">Our LVC schemes can be used to construct new efficient Succinct Non-interactive Arguments of Knowledge (SNARKs) with constant-size opening. Following up on the approach pioneered by Kilian <em>[23]</em> and Micali <em>[28]</em>, recent works <em>[5, 24]</em> show that we can construct SNARKs based on probabilistically checkable proofs (PCPs) or interactive oracle proofs (IOPs) by plugging in vector commitments with subvector openings.</p>

    <p class="text-gray-300">In an IOP the prover sends multiple proof oracles to a verifier. The verifier uses these oracles to query a small subsets of the proof in order to decide acceptance or rejection. Recent practical instantiations of proof systems from IOPs use Merkle trees as a vector commitment. While Merkle trees do not require a trusted setup, these schemes have two significant drawbacks for the two above applications: first, position openings are not constant size, and second, the openings of several positions cannot be compressed into a single constant size proof (i.e. it does not support aggregation or subvector openings). LVC with subvector openings are a perfect candidate to instantiate IOP-based SNARKs.</p>

    <p class="text-gray-300">Replacing Merkle trees with a vector commitment, Lai and Malavolta <em>[24]</em> obtain a SNARK where the proof consists of 3 field elements and 2 group elements. Using the same blueprint, we can use LVC to match the same proof size as theirs and improve the trusted setup by making it compatible with other</p>

    <p class="text-gray-300">widely deployed proof systems. On the other hand, the construction in <em>[24]</em> (last row in their Table 2) requires a trusted setup with a “gap” in the powers of exponent.</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">B.5 Applications of Range Openings</h3>

    <p class="text-gray-300">One of the features of our monomial-basis construction is to have efficient range openings. These arguably have several natural applications.</p>

    <p class="text-gray-300">In several protocols involving queries, it is common to perform some type of “caching” optimizations. For example, an HTTP client can perform <em>prefetching</em> and receive from a server not only the values of interest but other related values that could potentially be queried in the near future (e.g., values in a neighboring range of the queried values). Our range-based queries can be used in similar setting whenever we need to query a resource whose digest consists of a vector commitment.</p>

    <h2 id="sec-77" class="text-2xl font-bold">Appendix C Native SVC in <em>[33]</em></h2>

    <p class="text-gray-300">For a vector <span class="math">\\mathbf{v}\\in\\mathbb{F}^{m}</span> and a subset <span class="math">I\\subset[m]</span>, the subvector opening scheme of Tomescu et. al. (<em>[33]</em>) consists on algorithms (SVC.KeyGen, SVC.Commit, SVC.Open, SVC.Vf) such that SVC.KeyGen, SVC.Commit behave as IP.KeyGen, IP.Commit in the construction of Section 5.2 and the other two as follows:</p>

    <p class="text-gray-300">SVC.Open(prk, aux, <span class="math">I,\\mathbf{\\tilde{c}}</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi_{I}</span> : Compute <span class="math">\\tilde{C}(X)=\\sum_{i\\in I}\\tilde{c}_{i}\\mu_{i}(X)</span>, where <span class="math">\\{\\mu_{i}(X)\\}</span> are the Lagrange interpolation polynomials of the set <span class="math">\\{\\mathsf{h}_{i}\\}_{i\\in I}</span>, and find <span class="math">H(X)</span> such that for <span class="math">t_{I}(X)=\\prod_{i\\in I}(X-\\mathsf{h}_{i})</span>,</p>

    <p class="text-gray-300"><span class="math">C(X)-\\tilde{C}(X)=t_{I}(X)H(X).</span></p>

    <p class="text-gray-300">Output <span class="math">\\pi_{I}=\\big{(}\\tilde{\\mathsf{C}}=[\\tilde{C}(\\tau)]_{1},[H]_{1}=[H(\\tau)]_{1}\\big{)}</span>.</p>

    <p class="text-gray-300">SVC.Vf(vrk, <span class="math">\\mathsf{C},I,\\mathbf{\\tilde{c}},\\pi_{I}</span>) <span class="math">\\rightarrow</span> <span class="math">b\\in\\{0,1\\}</span> : Compute <span class="math">[t_{I}]_{2}=[t_{I}(\\tau)]_{2}</span> and output <span class="math">1</span> if and only if</p>

    <p class="text-gray-300"><span class="math">e\\big{(}\\mathsf{C}-\\tilde{\\mathsf{C}},[1]_{2}\\big{)}=e\\big{(}[H]_{1},[t_{I}]_{2}\\big{)}.</span></p>

    <h2 id="sec-78" class="text-2xl font-bold">Appendix D Lagrange basis IP for Cosets of Roots of Unity</h2>

    <p class="text-gray-300">In this section, we prove some facts about the Lagrange and vanishing polynomials corresponding to cosets of subgroups of roots of unity, that are used in the scheme of Section 8.2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We argue that the IP vector commitments construction in Section 5.2 can be implemented when we set <span class="math">\\mathbb{H}</span> to be a set of roots of unity of size <span class="math">m</span> where <span class="math">m</span> is a power of two, and use as interpolation set a coset of size <span class="math">r</span>(that is a smaller power of 2) instead of <span class="math">\\mathbb{H}</span>. We denote these cosets as $\\mathbb{H}^{\\mathbf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J}}<span class="math"> and </span>\\{\\lambda_{i}^{\\mathbf{b}}(X)\\}_{i=1}^{r}<span class="math">, </span>t^{\\mathbf{b}}(X)<span class="math"> its Lagrange and vanishing polynomials, and set </span>\\boldsymbol{\\lambda}^{\\mathbf{b}}(X)=(\\lambda_{i}^{\\mathbf{b}}(X),\\ldots,\\lambda_{r}^{\\mathbf{b}}(X))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-79" class="text-xl font-semibold mt-8">D.1 Proof of Theorem 9</h3>

    <h6 id="sec-80" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First, note that</p>

    <p class="text-gray-300"><span class="math">A(X)B(X)=\\big{(}\\boldsymbol{\\lambda}^{\\mathbf{b}}(X)\\cdot\\mathbf{a}\\big{)}\\left(\\boldsymbol{\\lambda}^{\\mathbf{b}}(X)\\cdot\\mathbf{b}\\right)=\\boldsymbol{\\lambda}^{\\mathbf{b}}(X)(\\mathbf{a}\\circ\\mathbf{b})\\mod t^{\\mathbf{b}}(X)</span></p>

    <p class="text-gray-300">Then, there exists <span class="math">Q^{\\prime}(X)</span> s.t. <span class="math">A(X)B(X)=\\boldsymbol{\\lambda}^{\\mathbf{b}}(X)(\\mathbf{a}\\circ\\mathbf{b})+t^{\\mathbf{b}}(X)Q^{\\prime}(X)</span>.</p>

    <p class="text-gray-300">Remember that <span class="math">r=\\frac{m}{2^{r+1}}=2^{n}</span>.</p>

    <p class="text-gray-300">For the first implication, note that if <span class="math">\\mathbf{a}\\cdot\\mathbf{b}=y</span>, because <span class="math">\\lambda_{i}^{\\mathbf{b}}(0)=r^{-1}</span> for all <span class="math">i=1,\\ldots,r</span> (See Lemma 3 below), <span class="math">\\sum_{i=1}^{r}a_{i}b_{i}\\lambda_{i}^{\\mathbf{b}}(0)=r^{-1}\\sum_{i=1}^{r}a_{i}b_{i}=r^{-1}y</span>, which implies that <span class="math">\\sum_{i=1}^{r}a_{i}b_{i}\\lambda_{i}^{\\mathbf{b}}(X)-r^{-1}y</span> vanishes at <span class="math">X=0</span> and thus there exists <span class="math">R(X)</span> such that <span class="math">\\sum_{i=1}^{r}a_{i}b_{i}\\lambda_{i}^{\\mathbf{b}}(X)=XR(X)</span>.</p>

    <p class="text-gray-300">On the other hand, if we have that <span class="math">A(X)B(X)=\\sum_{i=1}^{r}a_{i}b_{i}\\boldsymbol{\\lambda}_{i}^{\\mathbf{b}}(X)+t^{\\mathbf{b}}(X)Q^{\\prime}(X)</span> and <span class="math">A(X)B(X)-r^{-1}y=XR(X)+t^{\\mathbf{b}}(X)Q(X)</span>, because <span class="math">\\deg(XR(X))&lt;r</span>, <span class="math">Q(X)=Q^{\\prime}(X)</span> and <span class="math">\\sum_{i=1}^{r}a_{i}b_{i}\\lambda_{i}^{\\mathbf{b}}(X)-yr^{-1}=XR(X)</span>. Set <span class="math">X=0</span> in the equation and we have <span class="math">r^{-1}\\sum_{i=1}^{r}a_{i}b_{i}=r^{-1}m</span>, i.e, <span class="math">\\mathbf{a}\\cdot\\mathbf{b}=y</span>. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Lemma 3. Consider <span class="math">\\mathbb{H}</span> a group of roots of unity of size <span class="math">m</span>, where <span class="math">m</span> is a power of 2 and a coset <span class="math">\\mathbb{H}^{\\mathbf{b}} = \\{\\mathsf{h}_1^{\\mathbf{b}},\\ldots ,\\mathsf{h}_{2^{\\kappa}}^{\\mathbf{b}}\\}</span> of size <span class="math">2^{\\kappa} = \\frac{m}{2^{\\kappa + 1}}</span>. Then, <span class="math">\\lambda_i^{\\mathbf{b}}(0) = -r</span>, where <span class="math">\\lambda_i^{\\mathbf{b}}(X)</span> is the <span class="math">i</span>th Lagrange interpolation polynomial associated to <span class="math">\\mathbb{H}^{\\mathbf{b}}</span>.</p>

    <p class="text-gray-300">Proof. First, we note that <span class="math">t^{\\mathbf{b}}(X) = X^{2^{\\kappa}} - \\omega^{s2^{\\kappa}}</span> is the vanishing polynomial of <span class="math">\\mathbb{H}^{\\mathbf{b}}</span>. Indeed, it has degree <span class="math">2^{\\kappa}</span> and for every <span class="math">\\mathsf{h}_i^{\\mathbf{b}} = \\omega^{s + (i - 1)2^{\\kappa + 1}} \\in \\mathbb{H}^{\\mathbf{b}}</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathrm {h} _ {i} ^ {\\mathbf {b}}\\right) ^ {2 ^ {\\kappa}} - \\omega^ {s 2 ^ {\\kappa}} = \\left(\\omega^ {s + (i - 1) 2 ^ {\\kappa + 1}}\\right) ^ {2 ^ {\\kappa}} - \\omega^ {s 2 ^ {\\kappa}} = \\omega^ {s 2 ^ {\\kappa}} - \\omega^ {s 2 ^ {\\kappa}} = 0.</span></div>

    <p class="text-gray-300">Thus,</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {2 ^ {\\kappa}} - \\omega^ {s 2 ^ {\\kappa}} = \\prod_ {i = 1} ^ {2 ^ {\\kappa}} (X - \\mathsf {h} _ {i} ^ {\\mathbf {b}}) \\mathrm {a n d} \\frac {X ^ {2 ^ {\\kappa}} - \\omega^ {s 2 ^ {\\kappa}}}{X - \\mathsf {h} _ {i} ^ {\\mathbf {b}}} = \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (X - \\mathsf {h} _ {j} ^ {\\mathbf {b}}).</span></div>

    <p class="text-gray-300">Now, we claim that if we denote <span class="math">\\lambda_i^{\\mathbf{b}}(X)</span> as the <span class="math">i</span>th Lagrange interpolation polynomial of <span class="math">\\mathbb{H}^{\\mathbf{b}}</span> and <span class="math">\\mathsf{h}_i^{\\mathbf{0}}</span> as the <span class="math">i</span>th element of the set of roots of unity <span class="math">\\mathbb{H}^{\\mathbf{0}}</span> of size <span class="math">2^{\\kappa}</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda_ {i} ^ {\\mathbf {b}} (X) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa} \\omega^ {s (2 ^ {\\kappa} - 1)}} \\frac {X ^ {2 ^ {\\kappa}} - \\omega^ {s 2 ^ {\\kappa}}}{X - \\mathsf {h} _ {i} ^ {\\mathbf {b}}}.</span></div>

    <p class="text-gray-300">To prove our claim, first note</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda_ {i} ^ {\\mathbf {b}} (X) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa} \\omega^ {s (2 ^ {\\kappa} - 1)}} \\frac {X ^ {2 ^ {\\kappa}} - \\omega^ {s 2 ^ {\\kappa}}}{X - \\mathsf {h} _ {i} ^ {\\mathbf {b}}} = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa} \\omega^ {s (2 ^ {\\kappa} - 1)}} \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (X - \\mathsf {h} _ {j} ^ {\\mathbf {b}}).</span></div>

    <p class="text-gray-300">It is clear from the above that <span class="math">\\lambda_i^{\\mathbf{b}}(\\mathsf{h}_j^{\\mathbf{b}}) = 0</span> for all <span class="math">j\\neq i</span>, now</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda_ {i} ^ {\\mathbf {b}} (\\mathsf {h} _ {i} ^ {\\mathbf {b}}) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa} \\omega^ {s (2 ^ {\\kappa} - 1)}} \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (\\mathsf {h} _ {i} ^ {\\mathbf {b}} - \\mathsf {h} _ {j} ^ {\\mathbf {b}}) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa} \\omega^ {s (2 ^ {\\kappa} - 1)}} \\omega^ {s (2 ^ {\\kappa} - 1)} \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (\\mathsf {h} _ {i} ^ {\\mathbf {0}} - \\mathsf {h} _ {j} ^ {\\mathbf {0}}) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa}} \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (\\mathsf {h} _ {i} ^ {\\mathbf {0}} - \\mathsf {h} _ {j} ^ {\\mathbf {0}})</span></div>

    <p class="text-gray-300">Since <span class="math">\\mathbb{H}^{\\mathbf{0}}</span> is a group of roots of unity of size <span class="math">2^{\\kappa}</span>, we know that <span class="math">\\frac{\\mathsf{h}_i^{\\mathbf{0}}}{2^{\\kappa}}\\prod_{j\\neq i}^{r}(\\mathsf{h}_i^{\\mathbf{0}} - \\mathsf{h}_j^{\\mathbf{0}})</span> is its <span class="math">i</span>th Lagrange polynomial evaluated at <span class="math">\\mathsf{h}_i^{\\mathbf{0}}</span>, which is its <span class="math">i</span>th interpolation point. Thus the equation above equals 1.</p>

    <p class="text-gray-300">Then, <span class="math">\\lambda_i^{\\mathbf{b}}(X)</span> is a polynomial of degree <span class="math">2^{\\kappa} - 1</span> such that vanishes at all elements in <span class="math">\\mathbb{H}^{\\mathbf{b}}</span> except for <span class="math">\\mathsf{h}_i^{\\mathbf{b}}</span> where takes value 1 and so we conclude it is the <span class="math">i</span>th Lagrange polynomial of <span class="math">\\mathbb{H}^{\\mathbf{b}}</span>.</p>

    <p class="text-gray-300">Finally, recall that as <span class="math">\\mathbb{H}_{\\mathbf{0}}</span> is a set of roots of unity of size <span class="math">2^{\\kappa}</span>, all its Lagrange polynomials take value <span class="math">(2^{\\kappa})^{-1}</span> when evaluated in 0. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda_ {i} ^ {\\mathbf {b}} (0) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa} \\omega^ {s (2 ^ {\\kappa} - 1)}} \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (0 - \\mathsf {h} _ {j} ^ {\\mathbf {b}}) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{r \\omega^ {s (2 ^ {\\kappa} - 1)}} \\omega^ {s (2 ^ {\\kappa} - 1)} \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (0 - \\mathsf {h} _ {j} ^ {\\mathbf {0}}) = \\frac {\\mathsf {h} _ {i} ^ {\\mathbf {0}}}{2 ^ {\\kappa}} \\prod_ {j \\neq i} ^ {2 ^ {\\kappa}} (0 - \\mathsf {h} _ {j} ^ {\\mathbf {0}})</span></div>

    <p class="text-gray-300">equals the <span class="math">i</span>th Lagrange polynomial of <span class="math">\\mathbb{H}^{\\mathbf{0}}</span> evaluated in zero, that is, <span class="math">(2^{\\kappa})^{-1}</span>.</p>

    <p class="text-gray-300">The following lemma relates the vanishing polynomial and elements of two different cosets of size <span class="math">r = \\frac{m}{2^k}</span> whose elements belong to the same coset of size <span class="math">\\frac{m}{2^{k-1}}</span>. Recall that this is the case for cosets <span class="math">\\mathbb{H}^{0\\mathbf{b}_{!j}}</span>, <span class="math">\\mathbb{H}^{s&#x27;,r}</span> if and only if <span class="math">s \\equiv s&#x27; \\mod 2^{k-1}</span>. The lemma will be used in the next section to prove what constitutes, along with the result on arguments for inner products using cosets, the core of our maintainable construction.</p>

    <p class="text-gray-300">Lemma 4. Consider <span class="math">\\mathbb{H}_r\\subset \\mathbb{H}</span> the subgroup of roots of unity of size <span class="math">r</span>, and <span class="math">\\mathbb{H}^{\\mathbf{b}} = \\omega^{s}\\mathbb{H}_{r}</span>. Let <span class="math">\\mathbb{H}^{0\\mathbf{b}_{!j}}</span>, <span class="math">\\mathbb{H}^{1\\mathbf{b}_{!j}}</span> be two cosets of <span class="math">\\mathbb{H}^{\\mathbf{b}}</span> and <span class="math">t^{0\\mathbf{b}_{!j}}(X)</span> and <span class="math">t^{1\\mathbf{b}_{!j}}(X)</span> its vanishing polynomials. Then, for every <span class="math">\\mathsf{h}\\in \\mathbb{H}^{0\\mathbf{b}_{!j}}</span> and <span class="math">\\mathsf{h}&#x27;\\in \\mathbb{H}^{1\\mathbf{b}_{!j}}</span>, <span class="math">s_0 = \\sum_{i = 0}^j b_i2^i</span>, <span class="math">s_1 = \\sum_{i = 0}^j b_i2^i +2^{j + 1}</span> and <span class="math">r = \\frac{m}{2^{j + 2}}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">t ^ {0 \\mathbf {b} _ {! j}} (\\mathsf {h} ^ {\\prime}) = - 2 \\omega^ {s r}, \\qquad \\qquad t ^ {1 \\mathbf {b} _ {! j}} (\\mathsf {h}) = 2 \\omega^ {s r}.</span></div>

    <p class="text-gray-300">Proof. First, note that <span class="math">s_1 = s_0 + 2^{j+1}</span>, <span class="math">h = \\omega^{s + (i-1)2^{j+2}}</span> for some <span class="math">i = 1, \\ldots, r</span> and <span class="math">h&#x27; = \\omega^{s + 2^{j+1} + (i-1)2^{j+2}}</span>. Also, remark that <span class="math">\\omega^{\\frac{m}{2}} = -1</span>, <span class="math">t^{0\\mathbf{b}_{ij}}(X) = X^r - \\omega^{sr}</span> and <span class="math">t^{1\\mathbf{b}_{ij}}(X) = X^r - \\omega^{s_1r} = X^r - \\omega^{(s_0 + 2^{j+1})r}</span>. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} t^{0\\mathbf{b}_{ij}}(\\mathbf{h}&#x27;) = \\left(\\omega^{s + 2^{j+1} + (i-1)2^{j+2}}\\right)^r - \\omega^{sr} = \\left(\\omega^{s + 2^{j+1}}\\right)^r - \\omega^{sr} \\\\ = \\omega^{sr} \\left((\\omega^{2^j + 1})^r - 1\\right) = \\omega^{sr} \\left(\\omega^{\\frac{m}{2}} - 1\\right) = \\omega^{sr} (-1 - 1) \\\\ = -2\\omega^{sr}. \\end{array}</span></div>

    <p class="text-gray-300">Analogously,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} t^{1\\mathbf{b}_{ij}}(\\mathbf{h}) = \\mathbf{h}^r - \\omega^{(s + 2^{j+1})r} = \\left(\\omega^{s + (i-1)2^{j+2}}\\right)^r - \\omega^{(s + 2^{j+1})r} \\\\ = \\left(\\omega^s\\right)^r \\left(1 - \\omega^{2^{j+1}}\\right) = \\omega^{sr} \\left(1 - \\omega^{\\frac{m}{2}}\\right) = \\omega^{sr} (1 - (-1)) \\\\ = 2\\omega^{sr}. \\end{array}</span></div>

    <p class="text-gray-300">□</p>`;
---

<BaseLayout title="Linear-map Vector Commitments and their Practical Applicatio... (2022/705)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/705
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
