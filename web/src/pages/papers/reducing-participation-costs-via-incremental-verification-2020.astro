---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1522';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Reducing Participation Costs via Incremental Verification for Ledger Systems';
const AUTHORS_HTML = 'Weikeng Chen, Alessandro Chiesa, Emma Dauterman, Nicholas P.  Ward';

const CONTENT = `    <p class="text-gray-300">Weikeng Chen weikengchen@berkeley.edu UC Berkeley &Alessandro Chiesa alexch@berkeley.edu UC Berkeley Emma Dauterman edauterman@berkeley.edu UC Berkeley Nicholas P. Ward npward@berkeley.edu UC Berkeley</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Ledger systems are applications run on peer-to-peer networks that provide strong integrity guarantees. However, these systems often have high participation costs. For a server to join this network, the bandwidth and computation costs grow linearly with the number of state transitions processed; for a client to interact with a ledger system, it must either maintain the entire ledger system state like a server or trust a server to correctly provide such information. In practice, these substantial costs centralize trust in the hands of the relatively few parties with the resources to maintain the entire ledger system state.</p>

    <p class="text-gray-300">The notion of <em>incrementally verifiable computation</em>, introduced by Valiant (TCC ’08), has the potential to significantly reduce such participation costs. While prior works have studied incremental verification for basic payment systems, the study of incremental verification for a general class of ledger systems remains in its infancy.</p>

    <p class="text-gray-300">In this paper we initiate a systematic study of incremental verification for ledger systems, including its foundations, implementation, and empirical evaluation. We formulate a cryptographic primitive providing the functionality and security for this setting and then demonstrate how it captures applications with privacy and user-defined computations. We build a system that enables incremental verification for applications such as privacy-preserving payments with universal (application-independent) setup. Finally, we show that incremental verification can reduce participation costs by orders of magnitude for a bare-bones version of Bitcoin.</p>

    <p class="text-gray-300">Keywords: incrementally verifiable computation; succinct arguments; ledger systems</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Our theoretical contributions  4 1.2  Our systems contributions  5 1.3  Related work  6</p>

    <p class="text-gray-300">2  Participation costs in ledger systems  8</p>

    <p class="text-gray-300">3  Definition of IVLS  10 3.1  Properties of MakeSF  11 3.2  Properties of MakeC  13 3.3  Properties of History  13</p>

    <p class="text-gray-300">4  System architecture  15</p>

    <p class="text-gray-300">5  Applications  17</p>

    <p class="text-gray-300">6  Construction and implementation  19</p>

    <p class="text-gray-300">7  Evaluation  22 7.1  Constraints for SNARK verification  22 7.2  Incremental verification  23 7.3  Privacy-preserving payments  24 7.4  Synchronization costs  24 7.5  Limitation: producing proofs is costly  26</p>

    <p class="text-gray-300">8  Other related work  27</p>

    <p class="text-gray-300">A  Formalizing applications  28 A.1  Account-based payments  28 A.2  UTXO-based payments  28 A.3  Privacy-preserving payments  29 A.4  Privacy-preserving computation  30 A.5  Key transparency  30</p>

    <p class="text-gray-300">B  Further considerations  32 B.1  Integration with consensus protocols  32 B.2  Privacy considerations  33</p>

    <p class="text-gray-300">C  Construction of an IVLS compiler  34 C.1  Building blocks  34 C.2  Auxiliary state  35 C.3  Construction of Setup  36 C.4  Construction of MakeSF  36 C.5  Construction of MakeC  37 C.6  Construction of History  38</p>

    <p class="text-gray-300">D  Security  39 D.1  Security of vS  39 D.2  Security of vF  39 D.3  Security of vC  41 D.4  Security of History  42 D.5  Merkle tree properties  43</p>

    <p class="text-gray-300">Acknowledgments  45</p>

    <p class="text-gray-300">References  45</p>

    <p class="text-gray-300">3</p>

    <p class="text-gray-300">Ledger systems are applications running across many servers in peer-to-peer networks that offer strong integrity guarantees. Cryptocurrencies, ranging from basic payments to rich smart contracts, are notable examples. The strong integrity guarantees, however, come with high participation costs. In this paper we study how to reduce participation costs in ledger systems.</p>

    <p class="text-gray-300"><strong>Participation costs.</strong> Servers (“full nodes”) in a ledger system maintain the entire application state by performing a new state transition with each new transaction (or batch of transactions in a block), according to some consensus protocol. New servers that join the network must download every transaction and perform each state transition executed since the start of the system. The bandwidth and computation costs increase linearly in the number of transactions and soon become substantial. For example, the Bitcoin ledger is over 300GB; downloading and executing each transaction to reach the latest state can take days, depending on the machine.</p>

    <p class="text-gray-300">Moreover, clients wishing to interact with the application must either keep the entire application state like a server or ask a server to answer queries about the current state (or even past transactions). The first option requires clients to perform computations not relevant to them (e.g., process all payments in the system) and also excludes clients running on weak devices (e.g., smartphones). The second option requires clients to trust that servers answer queries correctly.¹ Both options are undesirable.</p>

    <p class="text-gray-300">Consequently, while in theory ledger systems enable peer-to-peer applications, in practice high participation costs centralize the trust in the hands of a few parties with the resources to maintain the entire application state.</p>

    <p class="text-gray-300"><strong>Avoiding re-execution via cryptographic proofs.</strong> Several works (reviewed in Section 8) have studied systems that leverage cryptographic proofs to avoid re-executing transactions when checking state transitions. Informally, cryptographic proofs enable anyone to produce a short string attesting to the correctness of a computation, which can be verified exponentially faster than the proved computation itself. Using this tool, for each state transition, one can generate a proof of the transition’s correctness by referring to two short commitments that summarize the application state before and after the transition. Now, validating the latest state only requires downloading all state commitments and transition proofs (much less data than all transactions) and checking all transition proofs (much less work than re-executing all transactions).</p>

    <p class="text-gray-300">Transition proofs reduce participation costs for both servers and clients, but servers and clients still have to process every transition proof. The costs to catch up with the latest state still grow linearly with the number of state transitions that have occurred since the last “synchronization” (or since the start of the system for a new participant). In particular, this is expensive for clients who have spent long periods of time offline.²</p>

    <p class="text-gray-300">This idea naturally extends to considering an untrusted operator that produces transition proofs for batches of transactions gathered by the operator. This is a popular “layer-2 scaling solution” that has been used in practice with concrete efficiency benefits (see Section 8). But the basic idea, as well as the asymptotic complexity, remains essentially the same because batches cannot be too large.</p>

    <p class="text-gray-300">Can one reduce the participation costs further?</p>

    <p class="text-gray-300"><strong>Incremental verification.</strong> Valiant [Val08] introduced incrementally verifiable computation (IVC) to cap-</p>

    <p class="text-gray-300">¹ Simplified Payment Verification (SPV) [Nak08], FlyClient [BKLZ20], and other light client schemes offer the client some security guarantees without storing the entire application state, but the client still has to trust that the current state is a result of applying transactions correctly.</p>

    <p class="text-gray-300">² Additionally using a light client protocol can reduce synchronization costs, but this is at the cost of qualitatively weaker security guarantees, because the client would have to trust that all transition proofs have been verified.</p>

    <p class="text-gray-300">ture an everlasting computation whose every intermediate state is accompanied by an easy-to-verify proof attesting to its correctness relative to the <em>initial</em> state (not the previous state). This capability is achievable via recursive composition of cryptographic proofs, i.e., by producing proofs that (informally) certify both a state transition and the correctness of the prior proof. The exponential speedup of verification relative to execution ensures that the cost of producing each proof from the previous proof does <em>not</em> depend on the number of past state transitions.</p>

    <p class="text-gray-300">Incremental verification can dramatically reduce participation costs in ledger systems. Now, validating the latest state requires downloading only the current state (or a short commitment to it) and a <em>short proof that attests to its correctness relative to the initial state</em>.</p>

    <p class="text-gray-300">Towards fulfilling the potential. The blockchain community has recognized the potential of incremental verification and has studied it for payment systems built on Nakamoto consensus <em>[x11]</em> and on proof-of-stake <em>[x16, x3]</em>; the latter has been deployed as a cryptocurrency <em>[x12]</em>.</p>

    <p class="text-gray-300">However, incremental verification for ledger systems remains in its infancy. First, applications studied so far include simple user-to-user money transfers but not richer applications (e.g., with privacy or smart contracts). Second, advances in cryptographic proofs <em>[x4, x7, x2, x5, x6, x7]</em> imply that incremental verification can be based on proof systems that are better suited for deployment than those used in <em>[x11, x3]</em>, namely, proof systems with a <em>simple and universal</em> setup. Both directions are suggested as future work in <em>[x11, x3]</em> and are being explored by practitioners <em>[x13]</em>.</p>

    <p class="text-gray-300">Even more fundamentally, as we elaborate in Section 1.3, while definitions and constructions of IVC have been studied in detail <em>[x5, x4, x3]</em>, prior work has only informally discussed the specific needs beyond IVC that arise in ledger systems, and prior work also did not empirically evaluate the benefits and drawbacks of incremental verification with respect to participation costs.</p>

    <p class="text-gray-300">This paper. This paper aims to initiate a systematic study of incremental verification for ledger systems and of its effectiveness in reducing participation costs. We now describe our theoretical contributions (Section 1.1) and systems contributions (Section 1.2).</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Our theoretical contributions</h3>

    <p class="text-gray-300">We introduce a cryptographic primitive that captures incremental verification for ledger systems and express several applications within the formalism of this primitive. We elaborate on these two items below.</p>

    <p class="text-gray-300">(i) Incrementally verifiable ledger systems. Valiant’s notion of IVC is useful but insufficient for the setting of incremental verification for ledger systems. First, IVC refers to automata computations (arbitrary transitions of a small application state), while applications on ledger systems involve transition functions that, with each transaction, make <em>few</em> accesses to a <em>large</em> application state. Second, IVC is envisioned for one powerful entity performing state transitions for a long time and then passing its responsibility to another powerful entity (Valiant calls this a “multi-generational computation” <em>[x17]</em>); in ledger systems, however, many parties performing state transitions may go offline for periods of time and then, when back online, need to efficiently “catch up” from when they left to the latest state. Third, ledger systems include clients who do not wish to store the entire application state; rather, they wish to learn select information by querying servers that store the entire state, with integrity guarantees.</p>

    <p class="text-gray-300">Moreover, definitions proposed by prior work on incremental verification for ledger systems <em>[x1, x11]</em> have several limitations, which we discuss in Section 3.</p>

    <p class="text-gray-300">3Moreover, incremental verification can be viewed as orthogonal to the "layer-2 scaling solutions" based on batch proofs, and could be used in a hybrid architecture that inherits benefits from both batch proofs and incremental verification.</p>

    <p class="text-gray-300">To fill these gaps, we introduce a cryptographic primitive for transforming a ledger system specified in a certain formalism into a corresponding incrementally verifiable ledger system (IVLS); we call this an IVLS compiler and discuss it in Section 3. Then in Section 4 we explain how the specific interfaces and security properties of our definition let us build peer-to-peer systems that, via incremental verification, achieve low participation costs. An IVLS compiler can be obtained, in a straightforward way, from IVC and collision-resistant hash functions.</p>

    <p class="text-gray-300">(ii) Incrementally verifiable applications. We validate our modeling by showing how to make several applications incrementally verifiable. By carefully designing the applications’ states, transactions, and transition functions, we obtain IVLS for five applications: (i) UTXO-based payments (“bare-bones” Bitcoin); (ii) account-based payments, the ledger application studied in prior works on incremental verification <em>[x1, x13]</em>; (iii) privacy-preserving payments, á la Zerocash <em>[x2]</em>; (iv) privacy-preserving decentralized computation, á la Zexe <em>[x3]</em>; and (v) key transparency <em>[x16]</em>, a popular approach to public-key infrastructure. Our work shows how applications that involve privacy and rich computations are compatible with incremental verification (see Section 5 and Appendix A). This provides solid theoretical foundations that can be used to study the security of new architectures based on recursive proofs that are being explored for Zcash <em>[x12]</em>. Subsequent work on key transparency also falls within our IVLS model <em>[x20]</em>.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Our systems contributions</h3>

    <p class="text-gray-300">We build a system prototype in Rust that realizes our IVLS primitive, contributing the following: (1) incremental verification with a universal (application-independent) setup, based on pairings; (2) an incrementally verifiable analogue of Zerocash; and (3) an empirical evaluation that validates the reduction in participation costs via measurements for a ten-year “bare-bones” Bitcoin.</p>

    <p class="text-gray-300">Before elaborating on each of these contributions, we first describe our system at high level. In our Rust library, the programmer specifies the desired application via a transition function represented as a constraint system with read/write memory gates (which our implementation realizes for the application). Our implementation then produces an incrementally verifiable version of that application, creating functionality for producing proofs with each state transition from the prior state and proof, for validating proofs, and so on.</p>

    <p class="text-gray-300">(1) Recursing a universal SNARK based on pairings. Incremental verification is obtained via a recursive use of cryptographic proofs called succinct non-interactive arguments of knowledge (SNARKs) <em>[x24, x7, x2]</em>. The predominant approach to achieve good efficiency in this setting is based on SNARKs that support “preprocessing” <em>[x2, x4]</em>. Informally, this means that the SNARK verifier can check the satisfiability of a given circuit in time that is exponentially fast by using a short verifying key that was produced in an offline (preprocessing) phase. Prior work on incremental verification <em>[x1, x13]</em> uses SNARKs whose preprocessing is part of the SNARK’s setup: the circuit to be proved/verified must be fixed once and for all when the public parameters for the SNARK are sampled via a cryptographic ceremony <em>[x2, x3, x4]</em>. This circuit-specific setup is ill-suited for many applications where the circuits to be proved/verified are determined later on by users once the ledger system is already running (e.g., as in Zexe <em>[x2]</em>), or where circuits need to be updated.</p>

    <p class="text-gray-300">We give the first demonstration of efficient recursive proofs based on a pairing-based preprocessing SNARK with universal setup. Here “universal setup” denotes the desirable property that the SNARK’s public parameters do not depend on circuits to be proved/verified (but only on an upper bound on their size).</p>

    <p class="text-gray-300">As we discuss shortly, this is helpful, or even necessary, for many applications.</p>

    <p class="text-gray-300">Our contribution is to implement and evaluate a (rank-1) constraint system for the verifier of Marlin <em>[x10]</em>, a state-of-the-art preprocessing SNARK with universal setup and a simple setup ceremony. Our constraint system is less than ten times larger than a constraint system for the state of the art with circuit-specific setup <em>[x23]</em>, which suffices for building incrementally verifiable ledger systems. We discuss our implementation of the Marlin verifier’s constraint system in Section 6 and its evaluation in Section 7.1.</p>

    <p class="text-gray-300">Other recent works study recursion of preprocessing SNARKs with a universal setup based on other cryptographic tools (cyclic groups <em>[x6]</em> or hash functions <em>[x12]</em>), but their proof sizes are markedly larger.</p>

    <p class="text-gray-300">(2) Incremental verification for private payments. We provide the first realization of private payments (á la Zerocash <em>[x3]</em>) with incremental verification, and evaluate its concrete efficiency. Prior works on incremental verification only considered basic public payments, while we show that incremental verification for more complex applications is not only possible but also practical. Our system prototype makes realizing private payments particularly simple: we only need to program the compliance predicate outlined in Section 5 and Appendix A. We describe our implementation in Section 6 and evaluation in Section 7.3.</p>

    <p class="text-gray-300">(3) Incremental verification reduces participation costs. We provide an evaluation that quantifies how incremental verification reduces participation costs. Prior work on incremental verification <em>[x1, x25]</em> provided only microbenchmarks or network data about the Mina blockchain, without studying how recursive proofs reduce network and computation costs for participants.</p>

    <p class="text-gray-300">We evaluate the effect of IVLS on the participation costs of a ten-year simplified version of Bitcoin (e.g., no scripts): recursive proofs reduce synchronization costs by orders of magnitude when compared with not using proofs (that is, naive synchronization) or using per-block transition proofs. Since our code facilitates swapping in different SNARKs over different curves, we evaluate multiple configurations: (a) SNARKs with circuit-specific setup and with universal setup; and (b) different MNT cycles (low-security and high-security levels).</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.3 Related work</h3>

    <p class="text-gray-300">We summarize prior work on incremental verification for ledger systems; its focus is complementary to ours. We discuss other, less relevant prior work in Section 8.</p>

    <p class="text-gray-300">Bonneau et al. <em>[x1]</em> (expanding on a prior whitepaper <em>[x29]</em>) design an incrementally verifiable payment system based on a proof-of-stake consensus protocol. They show how to modify the Ouroboros Genesis protocol <em>[x5]</em> so that its chain selection rule can be realized via a small-space algorithm, thereby obtaining a consensus protocol amenable to incremental state updates.</p>

    <p class="text-gray-300">Kattis and Bonneau <em>[x25]</em> design an incrementally verifiable payment system whose consensus protocol requires miners to solve a cryptographic puzzle that updates the prior state’s proof to the next state’s proof; they call this paradigm a Proof of Necessary Work. They show how to modify the Nakamoto consensus protocol to incorporate the proof-computation process to ensure that solving puzzles is “amortization resistant” across solution attempts (a desirable fairness property for mining).</p>

    <p class="text-gray-300">These works focus on basic payments (and no privacy guarantees) and on tackling challenges that arise in making consensus protocols compatible with incremental updates. In contrast, our focus is to formulate and realize a cryptographic primitive with concrete capabilities and security properties and show how it can express a range of applications (including with privacy goals). We believe that this will facilitate further work in incremental verification, which can make black-box use of our primitive. We discuss other limitations of the definitions in <em>[x1, x25]</em> in Section 3. Further, our implementation achieves incre</p>

    <p class="text-gray-300">mental verifiability based on recent advances in SNARKs with a simple and universal setup, which are better suited to real-world deployment and not studied previously. We also empirically validate how incremental verification reduces participation costs.</p>

    <p class="text-gray-300">Both <em>[x1]</em> and <em>[x12]</em> suggest for future work: (1) to explore richer (e.g. privacy-preserving) applications; and (2) SNARKs with universal setup. We address both.</p>

    <p class="text-gray-300">In this section we elucidate what we mean by "participation costs" in a ledger system and discuss how they are qualitatively affected by no proofs, transition proofs, and recursive proofs. This discussion will motivate the cryptographic primitive in Section 3 and its usage in Section 4.</p>

    <p class="text-gray-300">A ledger system involves heavyweight servers responsible for maintaining the application state and lightweight clients that perform queries to the current state (or to consult past transactions). Within this paper, participation costs consist of the following two types of costs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Synchronization costs: Both servers and clients may go offline and later "catch up" to the current state of the system. (When servers or clients join, they start from the initial state.) Servers and clients verify the current state's integrity by checking that it is the correct result of a sequence of transactions.</li>

      <li>Query costs: Clients only store a short state commitment and want to ensure that servers answer their queries correctly relative to the corresponding state. Clients may also make queries to prior application states, as the application may "forget" information that the client still cares about (e.g., a transaction that is already spent in a UTXO-based payment system). If the client only holds a commitment to the current state, it needs assurance that the prior state used to answer that query is in the history of the current application state.</li>

    </ul>

    <p class="text-gray-300">Below we discuss participation costs in ledger systems with: no proofs, transition proofs, and recursive proofs (which underlie incremental verification). Figure 1 summarizes how these different options affect the computations required to synchronize; our experiments in Section 7.4 confirm this qualitative behavior in practice.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Synchronization costs in ledger systems with different proof types (see Section 4 for discussion of the proof maker). Proving that one state extends another  <span class="math">(\\pi_{i\\rightarrow t})</span>  can be made lightweight enough that it can be done by peer-to-peer networks without the proof maker. The server synchronization includes the client synchronization.</p>

    <p class="text-gray-300">No proofs. Without proofs, servers or clients who want to be confident in an application state have no choice but to derive the application state themselves by downloading and executing each transaction since they were last online, leading to high synchronization costs. This essentially removes the distinction between clients and servers, as clients must hold a copy of the current application state to check its validity. The query cost is thus the cost for the client to execute its query over this local copy.</p>

    <p class="text-gray-300">Transition proofs. Instead of executing every state transition, servers or clients can download, for each state transition, a proof and a commitment to the next state. Servers also download the current application state and check that the final commitment commits to the current state. As clients no longer have the entire application state, query costs are different: clients now only use a commitment to the state to verify query responses. Transition proofs are a significant improvement over no proofs (Section 7.4), and batching can reduce costs even further <em>[x11, x14]</em>. However, synchronization costs remain linear in the number of state transitions and remain substantial for servers and clients that were offline for a long time.</p>

    <p class="text-gray-300">Recursive proofs. Recursive proofs further reduce synchronization costs for servers and clients by removing costs linear in the number of state transitions. Servers and clients only have to verify one proof that the current state is correct and possibly another lightweight proof that the current state extends the prior state held by them. The prover can recursively compose prior proofs to reduce proving cost. Query costs with recursive proofs match those of transition proofs; clients must check that their queries were correctly executed using a commitment to the state.</p>

    <p class="text-gray-300">This informal paradigm is the starting point of our work. In Section 3 we formulate a cryptographic primitive that captures these capabilities, and in Section 4 we explain how to use the primitive in a system.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">We capture the capabilities of recursive proofs with a cryptographic primitive called an incrementally verifiable ledger system (IVLS). An IVLS compiler transforms any ledger system into a corresponding IVLS.</p>

    <p class="text-gray-300">We first discuss limitations of prior definitions related to incremental verification for ledgers and then present our set of definitions.</p>

    <p class="text-gray-300"><strong>Limitations of prior definitions.</strong> Bonneau et al. [BMRS20] define the notion of a succinct blockchain to capture incremental verification of a blockchain application over a compatible consensus algorithm.⁶ While [BMRS20] takes a first step in formulating definitions about IVC for ledgers, we revisit these definitions for two reasons.</p>

    <p class="text-gray-300">First, the definitions in [BMRS20] do not differentiate between participants that maintain the entire state (full nodes) and participants that maintain only a short commitment to it (light clients). Light clients need to query full nodes for information about the state (as they only have a summary), and may also go offline for a period of time and need to synchronize their old summary with a summary of the current state. Our definitions distinguish between these, ensuring that clients can interact with the system in a meaningful way with only a summary of the state.</p>

    <p class="text-gray-300">Second, the definitions in [BMRS20] separate the application and the consensus protocol, which complicates interfaces and introduces properties that only relate to consensus (e.g., chain growth). More importantly, this is unnecessary: any consensus protocol compatible with incremental verification can be “folded” without loss of generality into the application itself. Designing consensus protocols compatible with incremental verification is, of course, important but seems better left to the details of the application. For example, our definitions can capture incremental verification not only for traditional blockchain applications (e.g., simple payments and privacy-preserving payments) but also for applications like key transparency that maintain state via a different centralized consensus (see Section 5). And, indeed, a subsequent work on verifiable key transparency [TFBT21] specifically points out that their work falls under the general framework of IVLS.</p>

    <p class="text-gray-300">Kattis and Bonneau [KB20] also describe a distributed payment system with incremental verification. They discuss the benefits of incremental verification at a high level, but do not provide interfaces and associated security properties that the system needs to fulfill.</p>

    <p class="text-gray-300"><strong>Our definitions.</strong> We present our definitions for IVLS; later in Section 4 we explain how these abstract definitions apply to real systems and how our properties provide meaningful guarantees to participants, and in Section 5 we exercise our definitions to show how to capture several applications of interest, including privacy-preserving payments, privacy-preserving computation, and key transparency (a direction left as future work by [BMRS20; KB20]).⁷</p>

    <p class="text-gray-300">A ledger system is a pair <span class="math">\\mathsf{LS} = (F, C)</span> where <span class="math">F</span> is a read-write program called the transition function and <span class="math">C</span> is a read-only program called the client function.</p>

    <p class="text-gray-300">The transition function <span class="math">F</span> specifies how transactions modify the state. That is, given as input a transaction <span class="math">\\mathsf{tx}</span> and query access to the current state <span class="math">S</span>, <span class="math">F</span> produces an output <span class="math">y</span> and a state update <span class="math">\\Delta</span> (denoted by <span class="math">(y, \\Delta) := F^S(\\mathsf{tx})</span>); the new state <span class="math">S&#x27;</span> is obtained by applying the update <span class="math">\\Delta</span> to the old state <span class="math">S</span> (denoted by</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300"><span class="math">S^{\\prime}\\coloneqq S + \\Delta)</span></p>

    <p class="text-gray-300">The client function  <span class="math">C</span>  specifies the supported types of client queries over a state: given an input query  <span class="math">x</span>  and query access to a state  <span class="math">S</span> ,  <span class="math">C</span>  produces a query answer  <span class="math">y</span>  (denoted by  <span class="math">y \\coloneqq C^S(x)</span> ).</p>

    <p class="text-gray-300">For example, in a simple UTXO-based payment system, the application state contains the pool of all unspent transactions, an incoming transaction consumes the outputs of prior transactions to generate new outputs, and the state transition function accepts a new transaction if it consumes unspent outputs. The client function searches for unspent transactions that can be spent by a public key. (See Section 5 for more examples.)</p>

    <p class="text-gray-300">We wish to transform any ledger system into a ledger system that has the same functionality and is incrementally verifiable. For this, we define an IVLS compiler: a tuple (Setup, MakeSF, MakeC, History) that we require to fulfill certain syntax and properties. First, Setup is used to sample public parameters pp; this is a one-time setup that can be used to transform any number of ledger systems. Next, we separately discuss each of MakeSF, MakeC, History in the next three subsections.</p>

    <p class="text-gray-300">Remark 3.1 (extensions). Our definition of a ledger system assumes for simplicity that the initial state is empty and that the transition function applies one transaction at a time. All discussions in this paper extend, in a straightforward way, to the case of non-empty initial states and to the case of transition functions that apply blocks of transactions. Moreover, we do not consider an algorithm for validating transactions before they are processed by the transition function since the transition function can check validity itself (and if not, return an error in its output and an empty state update). In a real system, validating transactions separately is likely to be more convenient.</p>

    <p class="text-gray-300">Remark 3.2 (deterministic vs. probabilistic). In the definitions of this section we assume that MakeSF and MakeC are deterministic algorithms. This is the case in our construction (in Appendix C) and also simplifies many definitions because an adversary can compute  <span class="math">(\\mathsf{vS},\\mathsf{vF})</span>  and  <span class="math">\\mathsf{vC}</span>  from  <span class="math">F</span>  and  <span class="math">C</span> , respectively, by itself. All of our definitions naturally extend to the case where MakeSF and MakeC can toss coins: the adversary needs to be given  <span class="math">(\\mathsf{vS},\\mathsf{vF})</span>  and  <span class="math">\\mathsf{vC}</span>  as an input at the right place in the definitions.</p>

    <p class="text-gray-300">Given public parameters pp and a transition function  <span class="math">F</span> , MakeSF outputs (vS, vF) where vF is an incrementally verifiable version of  <span class="math">F</span>  and vS are functions that manages vF's state. We describe each below.</p>

    <p class="text-gray-300">vS. The tuple  <span class="math">\\mathsf{vS} = (\\mathsf{Info},\\mathsf{VerifyCM},\\mathsf{VerifyAll})</span>  consists of efficient deterministic algorithms working as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{vS}.\\mathsf{Info}^{S,A}() \\to (t, \\mathsf{cm}, \\pi_{\\mathsf{F}})</span> . Given oracle access to a state  <span class="math">S</span>  and auxiliary state  <span class="math">A</span> , Info outputs the state's current index  <span class="math">t</span> , commitment  <span class="math">\\mathsf{cm}</span> , and proof  <span class="math">\\pi_{\\mathsf{F}}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>vS.VerifyCM(S, cm) → b. On input a state S and commitment cm, VerifyCM determines if cm is a valid commitment to S. We use the convention vS.VerifyCM(⊥, ⊥) = 1 (i.e., the empty commitment is a valid commitment for the empty state).</li>

      <li>vS.VerifyAll(S, A) → b. On input a state S and auxiliary state A, VerifyAll checks if the states are valid. We use the convention vS.VerifyAll(⊥, ⊥) = 1.</li>

    </ul>

    <p class="text-gray-300">For now, the only property that we explicitly require is that it is infeasible to find distinct states with the same valid commitment (Definition 3.3). Definitions later in this section imply other properties of vS.</p>

    <p class="text-gray-300"><strong>Definition 3.3 (binding of vS).</strong> For every polynomial-size adversary <span class="math">\\mathcal{A}</span> and sufficiently large security parameter <span class="math">\\lambda</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf{vS.VerifyCM}(S_1, \\mathsf{cm}) = 1 &amp;amp; \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^\\lambda) \\\\ \\mathsf{vS.VerifyCM}(S_2, \\mathsf{cm}) = 1 &amp;amp; (F, S_1, S_2, \\mathsf{cm}) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ \\downarrow &amp;amp; (\\mathsf{vS}, \\mathsf{vF}) \\leftarrow \\mathsf{MakeSF}(\\mathsf{pp}, F) \\end{array} \\right] \\geq 1 - \\mathrm{negl}(\\lambda)  .</span></div>

    <p class="text-gray-300"><strong>vF.</strong> The tuple <span class="math">\\mathsf{vF} = (\\mathsf{Run}, \\mathsf{Verify})</span> consists of efficient algorithms working as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>vF.Run<span class="math">^{S,A}</span>(tx) → (y, Δ). Given oracle access to a state S and auxiliary state A, and given as input a transaction tx, Run outputs a result y and a state update Δ = (Δ_S, Δ_A) to modify S and A. The result y and state update Δ_S equal the output of the original transition function F (on input tx and state S).</li>

      <li>vF.Verify(t, cm, π_F) → b. On input a state's index t, commitment cm, and proof π_F, Verify decides if the commitment is consistent with a state resulting from applying the transition function F on t transactions. We will assume vF.Verify(0, ⊥, ⊥) = 1.</li>

    </ul>

    <p class="text-gray-300">We require two properties. <strong>Completeness</strong> (Definition 3.4) states that using vF.Run to apply a transaction to a valid state yields a new valid state that is consistent with the original transition function F and a new auxiliary state that contains information passing all the relevant checks. <strong>Knowledge soundness</strong> (Definition 3.5) states that if an efficient adversary outputs a state commitment and proof that are valid according to vF.Verify, then an efficient extractor can output a sequence of transactions that, via transition function F, lead to a state with the claimed commitment.</p>

    <p class="text-gray-300"><strong>Definition 3.4 (completeness of vF).</strong> For every polynomial-size adversary <span class="math">\\mathcal{A}</span> and security parameter <span class="math">\\lambda</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf{vS.VerifyAll}(S, A) = 1 &amp;amp; \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^\\lambda) \\\\ \\downarrow &amp;amp; (F, S, A, \\mathsf{tx}) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ \\mathsf{vF.Verify}(t, \\mathsf{cm}, \\pi_{\\mathsf{F}}) = 1 &amp;amp; (\\mathsf{vS}, \\mathsf{vF}) \\leftarrow \\mathsf{MakeSF}(\\mathsf{pp}, F) \\\\ (y, \\Delta_S) = F^S(\\mathsf{tx}) &amp;amp; (t, \\mathsf{cm}, \\pi_{\\mathsf{F}}) \\leftarrow \\mathsf{vS.Info}^{S, A}() \\\\ t&#x27; = t + 1 &amp;amp; (y, (\\Delta_S, \\Delta_A)) \\leftarrow \\mathsf{vF.Run}^{S, A}(\\mathsf{tx}) \\\\ \\mathsf{vS.VerifyAll}(S&#x27;, A&#x27;) = 1 &amp;amp; S&#x27; := S + \\Delta_S, A&#x27; := A + \\Delta_A \\\\ &amp;amp; (t&#x27;, \\mathsf{cm}&#x27;, \\pi_{\\mathsf{F}}&#x27;) \\leftarrow \\mathsf{vS.Info}^{S&#x27;, A&#x27;}(\\mathsf{tx}) \\end{array} \\right] = 1  .</span></div>

    <p class="text-gray-300"><strong>Definition 3.5 (knowledge soundness of vF).</strong> For every polynomial-size adversary <span class="math">\\mathcal{A}</span> there exists a polynomial-size extractor <span class="math">\\mathcal{E}</span> such that for every sufficiently large security parameter <span class="math">\\lambda</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf{vF.Verify}(t, \\mathsf{cm}, \\pi_{\\mathsf{F}}) = 1 &amp;amp; \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^\\lambda) \\\\ \\downarrow &amp;amp; (F, t, \\mathsf{cm}, \\pi_{\\mathsf{F}}) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ S = F(\\mathsf{tx}_1, \\ldots, \\mathsf{tx}_t) &amp;amp; (\\mathsf{tx}_1, \\ldots, \\mathsf{tx}_t) \\leftarrow \\mathcal{E}(\\mathsf{pp}) \\\\ \\mathsf{vS.VerifyCM}(S, \\mathsf{cm}) = 1 &amp;amp; (\\mathsf{vS}, \\mathsf{vF}) \\leftarrow \\mathsf{MakeSF}(\\mathsf{pp}, F) \\end{array} \\right] \\geq 1 - \\mathrm{negl}(\\lambda)  .</span></div>

    <p class="text-gray-300">Given public parameters  <span class="math">\\mathsf{pp}</span>  and a client function  <span class="math">C</span> , MakeC outputs a tuple  <span class="math">\\mathsf{vC} = (\\mathsf{Run}, \\mathsf{Verify})</span> , the verifiable version of  <span class="math">C</span> , that enables proving/verifying that, given a commitment to the current state, the client function was executed correctly. In more detail, these work as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{vC.Run}^{S,A}(x) \\to (y, \\pi_{\\mathbb{C}})</span> . Given oracle access to a state  <span class="math">S</span>  and auxiliary state  <span class="math">A</span>  and input  <span class="math">x</span> , Run produces an output  <span class="math">y</span>  and a proof  <span class="math">\\pi_{\\mathbb{C}}</span>  attesting that  <span class="math">y = C^S(x)</span> .</li>

      <li><span class="math">\\mathbf{vC.Verify}(\\mathsf{cm},x,y,\\pi_{\\mathbb{C}})\\to b</span> . On input a state's commitment cm, input  <span class="math">x</span> , claimed output  <span class="math">y</span> , and proof  <span class="math">\\pi_{\\mathbb{C}}</span> , Verify determines if cm is consistent with a state  <span class="math">S</span>  such that  <span class="math">y = C^{S}(x)</span> .</li>

    </ul>

    <p class="text-gray-300">We require two properties. Completeness (Definition 3.6) states that outputs of vC.Run are accepted by vC.Verify and are consistent with executions of the given client function  <span class="math">C</span> . Soundness (Definition 3.7) states that if an efficient adversary outputs (a valid state and auxiliary state and) a proof that is accepted by vC.Verify for a given input and claimed output, then the claimed output equals  <span class="math">C</span> 's output.</p>

    <p class="text-gray-300">Definition 3.6 (completeness of vC). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {v S . V e r i f y A l l} (S, A) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\downarrow &amp;amp; (F, C, S, A, x) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ y = C ^ {S} (x) &amp;amp; (\\mathsf {v S}, \\mathsf {v F}) \\leftarrow \\mathsf {M a k e S F} (\\mathsf {p p}, F) \\\\ \\mathsf {v C} \\leftarrow \\mathsf {M a k e C} (\\mathsf {p p}, C) &amp;amp; \\\\ \\mathsf {v C . V e r i f y} (\\mathsf {c m}, x, y, \\pi_ {\\mathsf {C}}) = 1 &amp;amp; (y, \\pi_ {\\mathsf {C}}) \\leftarrow \\mathsf {v C . R u n} ^ {S, A} (x) \\\\ &amp;amp; (\\cdot , \\mathsf {c m}, \\cdot) \\leftarrow \\mathsf {v S . I n f o} ^ {S, A} () \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition 3.7 (soundness of vC). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and sufficiently large security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {v S . V e r i f y A l l} (S, A) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathsf {v C . V e r i f y} (\\mathsf {c m}, x, y, \\pi_ {\\mathsf {C}}) = 1 &amp;amp; (F, C, S, A, x, y, \\pi_ {\\mathsf {C}}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\downarrow &amp;amp; (\\mathsf {v S}, \\mathsf {v F}) \\leftarrow \\mathsf {M a k e S F} (\\mathsf {p p}, F) \\\\ y = C ^ {S} (x) &amp;amp; \\mathsf {v C} \\leftarrow \\mathsf {M a k e C} (\\mathsf {p p}, C) \\\\ &amp;amp; (\\cdot , \\mathsf {c m}, \\cdot) \\leftarrow \\mathsf {v S . I n f o} ^ {S, A} () \\end{array} \\right] \\geq 1 - \\mathrm {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">History = (Prove, Verify) enables proving/verifying that a prior state commitment is on the same timeline as another (later) state commitment. History.Prove produces a proof that the current (committed) state can be reached from an earlier (committed) state. History.Verify checks the proof. In more detail, the algorithms work as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>History.Prove <span class="math">^{S,A}</span> (pp, t) → πH. Given oracle access to a state S and auxiliary state A, and given as input public parameters pp and a previous state's index t, Prove outputs a proof πH attesting to the relationship between the t-th state commitment in the history and the current state commitment. (If the current state has an index less than or equal to t, Prove outputs ⊥.)</li>

      <li>History.Verify(pp, cm, t, cm_t, π_H) → b. On input public parameters pp, the current state's commitment cm, previous state's index t and commitment cm_t, and a proof π_H, Verify determines if cm_t was the valid t-th state commitment in the history leading to cm.</li>

    </ul>

    <p class="text-gray-300">We require two properties. Completeness (Definition 3.8) states that valid proofs can be generated for any past prior state commitment, relative to the state's index. Binding (Definition 3.9) states that it is infeasible to find, for the same state commitment cm, two distinct commitments that are valid for the same prior index  <span class="math">t</span> .</p>

    <p class="text-gray-300">Definition 3.8 (completeness of History). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\mathrm {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathrm {v S . V e r i f y A l l} (S, A) = 1 &amp;amp; (F, S, A, (\\mathsf {t x} _ {1}, \\ldots , \\mathsf {t x} _ {n})) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\downarrow &amp;amp; (\\mathsf {v S}, \\mathsf {v F}) \\leftarrow \\mathsf {M a k e S F} (\\mathsf {p p}, F) \\\\ t ^ {\\prime} = t + n &amp;amp; (t, \\mathsf {c m}, \\cdot) \\leftarrow \\mathsf {v S . I n f o} ^ {S, A} () \\\\ \\mathrm {H i s t o r y . V e r i f y} (\\mathsf {p p}, \\mathsf {c m} ^ {\\prime}, t, \\mathsf {c m}, \\pi_ {\\mathsf {H}}) = 1 &amp;amp; (S ^ {\\prime}, A ^ {\\prime}) \\xleftarrow {\\mathsf {v F . R u n} (\\mathsf {t x} _ {1}, \\ldots , \\mathsf {t x} _ {n})} (S, A) \\\\ &amp;amp; (t ^ {\\prime}, \\mathsf {c m} ^ {\\prime}, \\cdot) \\leftarrow \\mathsf {v S . I n f o} ^ {S ^ {\\prime}, A ^ {\\prime}} () \\\\ &amp;amp; \\pi_ {\\mathsf {H}} \\leftarrow \\mathsf {H i s t o r y . P r o v e} ^ {S ^ {\\prime}, A ^ {\\prime}} (\\mathsf {p p}, t) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Above we use a shorthand for going from state  <span class="math">(S,A)</span>  to state  <span class="math">(S^{\\prime},A^{\\prime})</span>  via the transactions  <span class="math">(\\mathsf{tx}_1,\\ldots ,\\mathsf{tx}_n)</span> .</p>

    <p class="text-gray-300">Definition 3.9 (binding of History). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and sufficiently large security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\mathrm {H i s t o r y . V e r i f y} (\\mathsf {p p}, \\mathsf {c m}, t, \\mathsf {c m} _ {t}, \\pi_ {\\mathsf {H}}) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathrm {H i s t o r y . V e r i f y} (\\mathsf {p p}, \\mathsf {c m}, t, \\mathsf {c m} _ {t} ^ {\\prime}, \\pi_ {\\mathsf {H}} ^ {\\prime}) = 1 &amp;amp; \\left(\\mathsf {c m}, t, \\begin{array}{c} \\mathsf {c m} _ {t}, \\pi_ {\\mathsf {H}} \\\\ \\mathsf {c m} _ {t} ^ {\\prime}, \\pi_ {\\mathsf {H}} ^ {\\prime} \\end{array} \\right) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\end{array} \\right] \\geq 1 - \\mathrm {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">4 System architecture</p>

    <p class="text-gray-300">We described how an IVLS compiler transforms a given ledger system <span class="math">\\mathsf{LS}=(F,C)</span> into a new ledger system <span class="math">\\mathsf{IVLS}=(\\mathsf{vF},\\mathsf{vC})</span> that (a) has the same functionality and similar efficiency and (b) is incrementally verifiable in a precise sense. Next we describe how IVLS gives rise to a peer-to-peer architecture with (much) smaller participation costs. In Appendix B.1 we explain how consensus protocols integrate with this system architecture, and in Appendix B.2 we discuss how privacy fits into this system architecture. Recall from Section 2 that synchronization costs are incurred by servers and clients who want to verify that the current state is derived from a past state correctly, and query costs are incurred by clients who want to verify query responses.</p>

    <p class="text-gray-300">The new system. Informally, servers use the new transition function <span class="math">\\mathsf{vF}</span> instead of the original <span class="math">F</span>, and clients use the new client function <span class="math">\\mathsf{vC}</span> instead of the original <span class="math">C</span>. We now discuss the different operations.</p>

    <p class="text-gray-300"><em>State updates.</em> Besides the application state <span class="math">S</span>, each server maintains an auxiliary state <span class="math">A</span> that stores cryptographic information. A server processes a new transaction <span class="math">\\mathsf{tx}</span> by computing <span class="math">(y,\\Delta):=\\mathsf{vF.Run}^{S,A}(\\mathsf{tx})</span> and applying the state update <span class="math">\\Delta</span> to the augmented state <span class="math">(S,A)</span>. (For comparison, in the original application, each server would compute <span class="math">(y,\\Delta_{S})=F^{S}(\\mathsf{tx})</span> and apply the state update <span class="math">\\Delta_{S}</span> to <span class="math">S</span>.) Any server can run <span class="math">\\mathsf{vS.Info}^{S,A}</span> to obtain the number <span class="math">t</span> of transactions that have been applied since the start of the system, a commitment <span class="math">\\mathsf{cm}</span> to the current application state, and a proof <span class="math">\\pi_{\\mathsf{F}}</span> of correctness.</p>

    <p class="text-gray-300"><em>State validity.</em> A server joining the system can simply download and verify the state and auxiliary information <span class="math">(S,A)</span> by checking the state proof <span class="math">\\pi_{\\mathsf{F}}</span> and checking the consistency between <span class="math">S</span> and <span class="math">A</span> using <span class="math">\\mathsf{vS.VerifyAll}(S,A)</span>. The new server does not need to itself apply the transition function <span class="math">\\mathsf{vF.Run}</span> for each prior transaction.</p>

    <p class="text-gray-300"><em>Client queries.</em> <span class="math">\\mathsf{vC}</span> enables a server to convince a client that it answered the client’s query correctly. The client sends a query <span class="math">x</span> to a server, the server computes and returns the answer and proof <span class="math">(y,\\pi_{\\mathsf{C}})\\leftarrow\\mathsf{vC.Run}^{S,A}(x)</span>, and the client checks the answer by running <span class="math">\\mathsf{vC.Verify}(\\mathsf{cm},x,y,\\pi_{\\mathsf{C}})</span>, where <span class="math">\\mathsf{cm}</span> is the commitment to <span class="math">S</span>.</p>

    <p class="text-gray-300"><em>Relation between states.</em> A server or client may be offline for a period of time and need a way to establish that an old state commitment <span class="math">\\mathsf{cm}^{\\mathsf{old}}</span> and a new state commitment <span class="math">\\mathsf{cm}^{\\mathsf{new}}</span> are not just individually valid (as established via <span class="math">\\mathsf{vF.Verify}</span>) but also belong to the same “timeline”. Moreover, a client that has a current state commitment and wants to make a query about an old state needs to be able to check that the current state was derived from the old state. Both tasks can be accomplished via functionality offered by <span class="math">\\mathsf{History}</span>, which enables skipping along this “timeline” of states using only commitments. The server can prove that the state committed to by <span class="math">\\mathsf{cm}^{\\mathsf{new}}</span> is reachable from a state committed to by <span class="math">\\mathsf{cm}^{\\mathsf{old}}</span> by computing a history proof <span class="math">\\pi_{\\mathsf{H}}:=\\mathsf{History.Prove}^{S,A}(\\mathsf{pp},t^{\\mathsf{old}})</span> where <span class="math">t^{\\mathsf{old}}</span> is the old state’s index. The client checks this proof by running <span class="math">\\mathsf{History.Verify}(\\mathsf{pp},\\mathsf{cm}^{\\mathsf{new}},t^{\\mathsf{old}},\\mathsf{cm}^{\\mathsf{old}},\\pi_{\\mathsf{H}})</span>.</p>

    <p class="text-gray-300">Motivation for security properties. We discuss how the security properties presented in Section 3 translate to the informal security desiderata we have discussed for synchronizing state and executing queries.</p>

    <p class="text-gray-300"><em>Synchronization.</em> <span class="math">\\mathsf{vF}</span>’s knowledge soundness (Definition 3.5) states that every state commitment accepted by <span class="math">\\mathsf{vF.Verify}</span> implies a sequence of transactions that, via the transition function <span class="math">F</span>, lead to the committed state. The binding property of <span class="math">\\mathsf{History}</span> (Definition 3.9) states that one cannot find prior state commitments that contradict each other but are both accepted by <span class="math">\\mathsf{History.Verify}</span> for the current state commitment. Together these imply that the state committed to by prior state commitments is valid.</p>

    <p class="text-gray-300"><em>Query execution.</em> <span class="math">\\mathsf{vC}</span>’s soundness (Definition 3.7) ensures that every query result over a valid state accepted by <span class="math">\\mathsf{vC.Verify}</span> implies that the result <span class="math">y</span> is the output of running the client function <span class="math">C</span> over the state with the</p>

    <p class="text-gray-300">input <span class="math">x</span>.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Reducing participation costs.</h4>

    <p class="text-gray-300">The new system reduces synchronization costs and query costs.</p>

    <p class="text-gray-300">Synchronization now only requires servers and clients to verify the latest state proof <span class="math">\\pi_{\\mathsf{F}}</span> produced by vF.Run along with, if they have a past commitment, a history proof <span class="math">\\pi_{\\mathsf{H}}</span> produced by History.Prove. To verify the consistency between the state and the auxiliary state, the server additionally runs vS.VerifyAll. These are efficient checks, and our evaluation of synchronization costs shows their practical benefits (see Section 7.4).</p>

    <p class="text-gray-300">Query costs are simply the time for the client to verify the query proof <span class="math">\\pi_{\\mathsf{C}}</span> produced by vC.Run, which is much faster than executing the query itself on the state.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Integration with consensus protocols.</h4>

    <p class="text-gray-300">For consensus-based ledger systems, the application’s transition function <span class="math">F</span> should be tasked with maintaining consensus information; in particular, the consensus protocol should be compatible with incremental verification. (Otherwise, the overall system would not be incrementally verifiable.) Prior works <em>[x11, x2]</em> have designed consensus protocols for incremental verification, which can be used here.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Who produces the proofs?</h4>

    <p class="text-gray-300">Introducing cryptographic proofs into a real-world system raises the question of who is responsible for producing these proofs. We briefly summarize two approaches described in prior work, which can be used in IVLS. Mina <em>[x2]</em> introduces a new party that makes proofs (a “snarker”) and is monetarily incentivized to produce proofs: block producers ask snarkers to produce proofs for generated blocks, and the two parties agree on a fee in what is essentially a lowest-price auction. Another approach is to directly embed producing proofs into the cryptographic PoW puzzle, known as Proof of Necessary Work <em>[x11]</em>, which requires the proof-computing process to satisfy amortization resistance (a property plausibly satisfied by known pairing-based SNARKs on NP statements, incorporating nonces). We discuss and evaluate proving costs in Section 7.5.</p>

    <p class="text-gray-300">5 Applications</p>

    <p class="text-gray-300">We describe how the formalism of ledger systems (see Section 3) can capture several applications of interest. By applying an IVLS compiler to these applications, one can make the application incrementally verifiable, and hence significantly reduce participation costs for it. Overall, we show that IVLS supports not only basic payment systems (the only ones studied in prior works on incremental verifiability) but also systems with strong privacy or rich user-defined applications (e.g., smart contracts).</p>

    <p class="text-gray-300">We outline how to “program” ledger systems to express each application, with a focus on transition functions; for completeness, we provide formal details (and a discussion of client functions) in Appendix A. We adopt two design principles for efficiency: (a) each transaction results in a small number of reads/writes to the application state; (b) the application state contains the minimum information necessary for ensuring the application’s integrity. (Users are responsible for storing any information specific to them.)</p>

    <p class="text-gray-300">Basic payments. As a warmup, we first discuss basic payments (user-to-user transfers without privacy guarantees), in the account-based and UTXO-based models.</p>

    <p class="text-gray-300">In the account-based model (studied in <em>[x10, x23]</em>), the application state is a map from public keys to balances. The transition function takes as input a signed message, under the sender’s public key, specifying the amount to be paid and the receiver’s public key. To prevent replaying a prior transaction, the application state maintains a counter for each public key, which increases with each payment; the signed message includes this counter. The application state’s size is linear in the number of public keys.</p>

    <p class="text-gray-300">In the UTXO-based model (think bare-bones Bitcoin with no scripts), the state maps public keys to identifier-value pairs each representing a coin. The transition function takes as input a sender public key; a list of existing coin identifiers all owned by the sender; and information for receivers in the form of their public keys, new coin identifiers, and their values (whose total equals that of the sender’s coins). All of this is signed under the sender’s public key. The identifiers of the spent coins are removed from the application state.</p>

    <p class="text-gray-300">Privacy-preserving payments. We discuss how to express payments with user privacy, as in Zerocash <em>[x11]</em>: user-to-user payments that reveal no information about the sender, receiver, or transferred amount. While superficially such a system looks very different from other payment systems, modeling it as a ledger system is not difficult, as explained below. Recall that each Zerocash transaction contains the serial numbers of old (spent) coins and the commitments to new (created) coins along with a zero-knowledge proof attesting that the old coins were created at some point in the past and now have been spent by someone who knows their private keys, and that the new coins were committed correctly and preserve the monetary value of the old coins.</p>

    <p class="text-gray-300">The application state includes a list of all serial numbers and a list of all coin commitments. (More precisely, the serial numbers are stored in a search tree and the coin commitments in a Merkle tree.) The transition function validates a transaction by checking its zero-knowledge proof and checking that its serial numbers do not already appear in the list of all serial numbers. If so, the transition function adds the transaction’s serial numbers and coin commitments to the application state. Crucially, the transition function here only makes a few accesses to the application state.</p>

    <p class="text-gray-300">Clients must identify transactions where they are recipients. Naively, this requires a linear scan over all transactions. This linear cost can be avoided via viewing keys, which allow the server to identify transactions</p>

    <p class="text-gray-300">relevant to the client without the server being able to spend the client’s funds. Viewing keys protect the clients’ funds but not privacy. To achieve privacy from the server, light clients can leverage prior work using secure hardware <em>[WMSMKČ, MWSKKC, LHAMLK20]</em> and/or private information retrieval (PIR) <em>[QHGR]</em>, which can be directly applied to our setting.</p>

    <p class="text-gray-300">We discuss the implementation and evaluation of incrementally verifiable privacy-preserving payments in Section 6 and Section 7.3 respectively.</p>

    <p class="text-gray-300">Privacy-preserving computation. Zexe <em>[BCGMMW20]</em> extends Zerocash to support privacy-preserving general computation, as captured via a computation model that involves data units called <em>records</em>, which contain scripts for how they can be created or consumed. Analogously, we extend the previous design to privacy-preserving computation, by setting the application state to be a list of all serial numbers and a list of all record commitments. Each transaction contains the serial numbers of old (consumed) records and the commitments to new (created) records along with a zero-knowledge proof attesting that scripts contained in all the records were correctly executed. The transition function validates a transaction by checking its proof and by checking that its serial numbers do not already appear in the list of all serial numbers; if so, it adds the serial numbers and record commitments in the transaction to the application state.</p>

    <p class="text-gray-300">Key transparency. We conclude with an application beyond cryptocurrencies: key transparency <em>[MBBFF, TBPPTD]</em>, a public directory mapping usernames to public keys. Unlike previous applications, in key transparency, a central server maintains the application state, and other parties verify that it does so correctly. Users can publish their own public keys to a directory maintained by the central server, query other users’ public keys, and check that the directory maintains this mapping correctly.</p>

    <p class="text-gray-300">The application state is pairs of usernames and public keys. The transition function processes two types of transactions: in the first type, a user can register a key by sending a new username and public key; in the second type, a user can update an existing public key with a signature of the new public key and the username under the old public key. While server participation costs are not a concern (application state is maintained by a single central server), incremental verifiability does reduce client participation costs. In the original design, a user must regularly query the central server to check that it continuously maintains the mapping between their username and public key. In our incrementally verifiable design, users only need to check a single proof that the <em>entire</em> application state has been maintained correctly.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We implement the IVLS compiler in Rust. The main components are summarized below and are illustrated in Figure 2. Several components are of independent interest, as they simplify the use of recursive SNARKs in many settings. For example, we provide a generic implementation of proof-carrying data and a constraint system encoding the correct execution of the verifier of a state-of-the-art pairing-based SNARK with universal setup. We used and contributed to the constraint-writing framework of the arkworks [arkworks] library (formerly libzexe) and its algebra libraries for finite fields and elliptic curves.</p>

    <p class="text-gray-300">Our implementation is open-sourced under the Apache v2 license or the MIT license and is available online. Our code base has been extended in subsequent work to support new types of recursion [BGH19; BCMS20; BCLMS21].</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 2: Diagram illustrating the relation between different components of our system. The gray boxes denote components that exist in prior libraries, while the white boxes denote components contributed in this work.</p>

    <p class="text-gray-300">IVLS. The top-level interface is a collection of traits that closely follow the interface of an IVLS compiler in Section 3. Its construction combines IVC and a Merkle tree via ideas that require some care but are primarily standard; for reference, we provide the construction in Appendix C and its security proof in Appendix D. The user specifies the transition function for the ledger system by providing code for the native execution and also a (rank-1) constraint system for it. The latter representation, known as R1CS, is a standard representation for NP statements that can be viewed as a generalization of arithmetic circuits. We discuss the IVC scheme below. As for the Merkle tree, like prior works in the SNARK literature [HBHW18; BCGMMW20], we base it on a Pedersen hash function over a suitable elliptic curve (a twisted Edwards curve), whose base field matches the field over which the IVC scheme's constraint system is defined, or</p>

    <p class="text-gray-300">on the Poseidon hash function <em>[x10]</em>. This is for efficiency, as traditional hash functions such as SHA-256 are expensive in constraint systems.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">PCD.</h5>

    <p class="text-gray-300">We provide a generic trait for a PCD scheme, which enables the user to specify transitions whose incremental verification is desired, by giving an R1CS constraint system that checks their validity. We provide a generic implementation of this trait from any pairing-based SNARK for R1CS that comes equipped with a constraint system for its own verifier, by using the technique of MNT cycles in <em>[x2]</em>. Our implementation works with both MNT cycles in arkworks (the lower-security 298-bit cycle and the higher-security 753-bit cycle). In particular, we can base the PCD scheme on pairing-based SNARKs for R1CS with a circuit-specific setup, already part of arkworks (such as <em>[x13]</em>), or with a universal setup that we contribute in this work (<em>[x11]</em>, as described below). Though not part of this work, we anticipate it to be rather straightforward to also implement the PCD scheme trait via hash-based (post-quantum) SNARKs for R1CS such as <em>[x12]</em>. Lastly, to support the Pedersen-based Merkle tree, we contribute twisted Edwards curves suitable for the MNT cycles in arkworks that underlie PCD.</p>

    <p class="text-gray-300">The IVC scheme that we use for IVLS is a special case of the PCD scheme above. We built PCD because PCD can used to distribute proving work via proof trees (e.g., see “parallel scan states” in <em>[x6]</em>), and PCD is useful in security applications beyond IVLS <em>[x24, x15, x16, x1]</em>.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Recursing a universal SNARK.</h5>

    <p class="text-gray-300">We provide the first implementation of a constraint system for a pairing-based SNARK for R1CS with universal setup <em>[x11]</em>. Recall that this means that the trusted generation of system parameters for the SNARK does not depend on the R1CS instance whose satisfiability is proved (but only on some upper bound to it). This enables realizing PCD/IVC based on the SNARK in <em>[x11]</em> (and implemented in marlin <em>[x20]</em>), so that the trusted generation of the system parameters for the PCD/IVC scheme does not depend on the user’s choice of automaton. Our constraint system is a useful addition to existing constraint systems for other types of SNARKs, such as pairing-based SNARKs with circuit-specific setup (starting with <em>[x2]</em>) and post-quantum SNARKs <em>[x12]</em>.</p>

    <p class="text-gray-300">The universal SNARK in <em>[x11]</em> is constructed via a general paradigm combining three ingredients: a polynomial commitment scheme (PC scheme), an algebraic holographic proof (AHP), and a cryptographic hash function for the Fiat–Shamir heuristic <em>[x14]</em>. The SNARK verifier is assembled from these ingredients, and our SNARK verifier constraint system reflects this structure, which should facilitate the implementation of similar universal SNARKs in the future.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PC scheme. We write a constraint system for the checks in the polynomial commitment scheme of Kate et al. <em>[x18]</em>, which ensures that a sender has correctly opened a committed polynomial at a desired point. Our constraint system supports degree enforcement and batching as described in <em>[x11]</em> and is implemented in poly-commit <em>[x21]</em>. This is the part of the verifier that checks a pairing-product equation on a pairing-friendly curve.</li>

    </ul>

    <p class="text-gray-300">Our implementation includes optimizations to reduce the number of constraints. For example, to batch multiple polynomial commitments and pairing checks into one, we replace the linear combination <span class="math">r,r^{2},r^{3},\\ldots</span> used in <em>[x11]</em> with the linear combination <span class="math">r_{1},r_{2},r_{3},\\ldots</span> as it is cheaper to derive multiple challenges from the Poseidon sponge (for the Fiat–Shamir transformation) instead of computing one challenge’s powers via non-native arithmetic.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AHP. We write a constraint system for the AHP verifier described in <em>[x11]</em>. This involves checking polynomial equations, using values in the proof and values derived from the Poseidon sponge. These operations are over the field exposed by the PC scheme above. As the latter is different from the field of the constraint system (due to properties of pairing-friendly curves), we use constraints for</li>

    </ul>

    <p class="text-gray-300">non-native field arithmetic (see below).</p>

    <p class="text-gray-300">In <em>[x10]</em>, the verifier evaluates a few vanishing polynomials, which is expensive due to non-native field arithmetic. To reduce the cost, we modify Marlin to have the prover convince the verifier of the correct evaluation of the vanishing polynomials. This change also reduces the number of verifier constraints from <span class="math">O(\\log N)</span> to <span class="math">O(1)</span>, where <span class="math">N</span> is the number of constraints of the circuit being verified in the constraint system.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Hashing.</em> For the cryptographic hash function we use an algebraic sponge (implemented in <em>[x13]</em> based on the Poseidon hash function). We set the field of the algebraic sponge to equal the field of the constraint system. For our setting we wrote “adapters” to absorb into and squeeze out of the algebraic sponge different types of inputs that arise in our SNARK verifier (commitments from the PC scheme and non-native field elements).</li>

    </ul>

    <p class="text-gray-300">Our modular design facilitates obtaining constraint systems for other SNARKs built via the same paradigm in <em>[x10]</em>. For example, by modifying the equations checked by the AHP, it would be relatively straightforward to obtain a constraint system for the SNARK for arithmetic circuits in <em>[x16]</em>.</p>

    <p class="text-gray-300">Non-native field arithmetic. The constraint system of the verifier requires checking arithmetic over a field <span class="math">\\mathbb{F}_{q}</span> that is different from the field <span class="math">\\mathbb{F}_{r}</span> of the constraint system. We provide a generic implementation in arkworks that hides the differences between native and non-native from the developers: one can program a constraint system with non-native field arithmetic as easily as if it were native. Our implementation is based on <em>[x14, x20, x26]</em>, but we optimize it for lower constraint weight (see below), which requires different parameter selection and multiplication.</p>

    <p class="text-gray-300">Optimizing constraint weight. While the main efficiency metric of a constraint system is the number of constraints, a secondary efficiency metric is its <em>weight</em>, i.e., the number of non-zero entries in the coefficient matrices. While for SNARKs with circuit-specific setup (such as <em>[x15]</em>) weight does not matter much, for all known SNARKs with universal setup (including <em>[x10]</em>) efficiency also depends on weight. To address this additional consideration, we extended the constraint-writing framework arkworks [arkworks] to enable weight-reducing optimizations. For example, we implement an automatic procedure that builds a dependency graph over all the linear combinations of constraint system variables and rewrites the constraint system to avoid re-using the same the linear combinations too many times (which greatly penalizes weight while saving few constraints). More generally, throughout all of our constraint writing, we balance the two (sometimes competing) goals of reducing number of constraints and reducing weight.</p>

    <p class="text-gray-300">Privacy-preserving payments. Using our IVLS interface, implementing privacy-preserving payments is straightforward. We simply assembled the compliance predicate described in Section 5, and our library produced an incrementally verifiable version for this application. To optimize application memory for performance, we chose a Merkle tree layout that is suitable for coin commitments and serial numbers. We evaluate our implementation in Section 7.3.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We measure the size of our constraint system for the verifier of Marlin [CHMMVW20], the costs of IVC with universal setup vs. circuit-specific setup, and how incremental verification reduces participation costs. We establish that incremental verification based on preprocessing SNARKs with a universal setup incurs modest overheads compared with the case of circuit-specific setup. Moreover, incremental verification significantly reduces participation costs compared with systems with no proofs or with transition proofs. While servers and clients greatly benefit from incremental verification, proof makers pay a high cost to produce proofs; we discuss these costs as well as techniques for reducing them in Section 7.5.</p>

    <p class="text-gray-300">Our measurements are taken on a machine with an Intel Xeon 6136 CPU with a base frequency of  <span class="math">3.00\\mathrm{GHz}</span>  and 252 GB of memory using a single thread. All reported proving times can be significantly reduced by using multiple threads (a capability that is already part of the codebase).</p>

    <p class="text-gray-300">Below, we frequently refer to two state-of-the-art proof systems: (a) Groth16 [Gro16], a preprocessing SNARK with a circuit-specific setup; and (b) Marlin [CHMMVW20], a preprocessing SNARK with a universal setup (the SNARK whose verifier we expressed as a constraint system).</p>

    <p class="text-gray-300">We measure the size of our constraint system for the verifier of Marlin [CHMMVW20]. We discuss the MNT-298 cycle with the SNARK verifier built on the MNT6-298 curve, which verifies a proof over the MNT4-298 curve. (Costs when the curves are swapped are similar.)</p>

    <p class="text-gray-300">The Marlin verifier that checks an R1CS instance with  <span class="math">K</span> -element public input has roughly  <span class="math">328825 + 4794K</span>  constraints, compared with  <span class="math">43186 + 7754K</span>  in the case of Groth16. This larger cost is to be expected because the (desirable) property of having a universal setup is harder to achieve and often leads to more expensive verifiers.</p>

    <p class="text-gray-300">The size of our constraint system remains modest and is within a factor of ten of the size for a circuit-specific setup. Our constraint system for the Marlin verifier establishes the feasibility of recursive proofs via pairing-based SNARKs with universal setup. We show a breakdown of the constraint system of the Marlin verifier in Table 1. The polynomial commitment (PC) check, particularly group exponentiation, is responsible for much of the cost. In the future, this cost could be reduced via incomplete group arithmetic [Zca].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Marlin Verifier Component</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weight</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prepare verification key</td>

            <td class="px-3 py-2 border-b border-gray-700">61,506</td>

            <td class="px-3 py-2 border-b border-gray-700">294,603</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AHP</td>

            <td class="px-3 py-2 border-b border-gray-700">62,807</td>

            <td class="px-3 py-2 border-b border-gray-700">339,043</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Non-native arithmetic</td>

            <td class="px-3 py-2 border-b border-gray-700">33,143</td>

            <td class="px-3 py-2 border-b border-gray-700">216,106</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PC check</td>

            <td class="px-3 py-2 border-b border-gray-700">186,493</td>

            <td class="px-3 py-2 border-b border-gray-700">994,080</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Group exponentiations</td>

            <td class="px-3 py-2 border-b border-gray-700">161,862</td>

            <td class="px-3 py-2 border-b border-gray-700">821,769</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">9,376</td>

            <td class="px-3 py-2 border-b border-gray-700">65,804</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fiat-Shamir</td>

            <td class="px-3 py-2 border-b border-gray-700">29,664</td>

            <td class="px-3 py-2 border-b border-gray-700">122,937</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Other</td>

            <td class="px-3 py-2 border-b border-gray-700">2,036</td>

            <td class="px-3 py-2 border-b border-gray-700">96,078</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">332,828</td>

            <td class="px-3 py-2 border-b border-gray-700">1,723,804</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Cost of the Marlin verifier and its main sub-components, including both the number and weight of constraints with  <span class="math">K = 10</span>  elements for public input.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve bit security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving time (μs/constraint)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification time (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size (byte)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin</td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin</td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12-381</td>

            <td class="px-3 py-2 border-b border-gray-700">~ 128</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">485</td>

            <td class="px-3 py-2 border-b border-gray-700">4.69</td>

            <td class="px-3 py-2 border-b border-gray-700">8.31</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MNT4-298</td>

            <td class="px-3 py-2 border-b border-gray-700">~ 80</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">456</td>

            <td class="px-3 py-2 border-b border-gray-700">4.97</td>

            <td class="px-3 py-2 border-b border-gray-700">7.64</td>

            <td class="px-3 py-2 border-b border-gray-700">152</td>

            <td class="px-3 py-2 border-b border-gray-700">950</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MNT6-298</td>

            <td class="px-3 py-2 border-b border-gray-700">~ 80</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">479</td>

            <td class="px-3 py-2 border-b border-gray-700">9.41</td>

            <td class="px-3 py-2 border-b border-gray-700">8.67</td>

            <td class="px-3 py-2 border-b border-gray-700">190</td>

            <td class="px-3 py-2 border-b border-gray-700">950</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MNT4-753</td>

            <td class="px-3 py-2 border-b border-gray-700">~ 128</td>

            <td class="px-3 py-2 border-b border-gray-700">395</td>

            <td class="px-3 py-2 border-b border-gray-700">4426</td>

            <td class="px-3 py-2 border-b border-gray-700">51.25</td>

            <td class="px-3 py-2 border-b border-gray-700">72.18</td>

            <td class="px-3 py-2 border-b border-gray-700">380</td>

            <td class="px-3 py-2 border-b border-gray-700">2375</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MNT6-753</td>

            <td class="px-3 py-2 border-b border-gray-700">~ 128</td>

            <td class="px-3 py-2 border-b border-gray-700">266</td>

            <td class="px-3 py-2 border-b border-gray-700">5540</td>

            <td class="px-3 py-2 border-b border-gray-700">92.98</td>

            <td class="px-3 py-2 border-b border-gray-700">81.26</td>

            <td class="px-3 py-2 border-b border-gray-700">475</td>

            <td class="px-3 py-2 border-b border-gray-700">2375</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Proving time per constraint, verification time, and proof size across preprocessing SNARKs and curves.</p>

    <p class="text-gray-300">We compare the overhead of recursive proofs with that of transition proofs for the case of pairing-based SNARKs. The overhead originates from two sources: (1) the additional constraints used to verify the prior proof (beyond the constraints to prove the desired statement); and (2) the use of an MNT cycle to realize recursion, instead of using more efficient pairing-friendly curves, e.g., BLS12-381. Our measurements (Table 2) show that the recursion overhead is modest with Groth16 and Marlin.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1) Additional constraints. Suppose that one wishes to recursively prove the correct execution of a transition function whose constraint system has  <span class="math">M</span>  constraints. (I.e., the compliance predicate in IVC has size  <span class="math">M</span> .) Following the MNT-cycle paradigm of [BCTV14], we need to: (a) prove, over the MNT4 curve, the satisfiability of a constraint system of size  $M +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT6}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , where  </span>V_{\\mathrm{MNT6}}<span class="math">  denotes (a constraint system for) the MNT6 verifier; and (b) prove, over the MNT6 curve, the satisfiability of a constraint system of size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT4}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , where  </span>V_{\\mathrm{MNT4}}<span class="math">  denotes (a constraint system for) the MNT4 verifier. Proving times over the two curves are essentially the same, so each recursion amounts to proving  </span>M +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT6}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT4}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  constraints (rather than  </span>M<span class="math">  without recursion). For MNT-298: (1) in Groth16,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT4}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT6}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is  </span>1.3 \\times 10^5<span class="math">  constraints; (2) in Marlin,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT4}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{\\mathrm{MNT6}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is  </span>5.9 \\times 10^5$  constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, the number of constraints to prove for recursion is  <span class="math">M</span>  plus a term that grows much slower than  <span class="math">M</span>  as  <span class="math">M</span>  grows, the number of additional constraints is a smaller and smaller fraction of the number of proved constraints. For example, if  <span class="math">M</span>  is two million constraints, recursion requires proving less than 2.6 million constraints.</p>

    <p class="text-gray-300">(2) MNT cycles vs. BLS. We measured the main costs of a preprocessing SNARK (proving time, verification time, and proof size) on the BLS12-381 curve, the MNT-298 cycle, and the MNT-753 cycle, for both Groth16 and Marlin, shown in Table 2. MNT-298 has similar efficiency to BLS12-381 but only 80-bit security; MNT-753 has greater security at an increased cost.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proving time. The proving times in both proof systems are quasilinear in the number of constraints. But, for a large range of parameters, proving times approximately grow linearly, as prior works show, and so we report proving time per constraint. Compared with Groth16, Marlin is  <span class="math">10 \\times</span>  slower. Compared with BLS12-381, MNT-298 has a similar proving time, but MNT-753 is  <span class="math">10 \\times</span>  slower.</li>

      <li>Verification time. Pairing-based preprocessing SNARKs typically have short verification times. We measured the verification times for a constraint system with  <span class="math">N = 2^{16}</span>  constraints and  <span class="math">K = 10</span>  public inputs. All measurements are less than  <span class="math">100 \\, \\mathrm{ms}</span> . Compared with Groth16, Marlin is  <span class="math">2 \\times</span>  slower. Compared with BLS12-381, MNT-298 is  <span class="math">2 \\times</span>  slower or less, and MNT-753 is  <span class="math">10 \\times</span>  to  <span class="math">20 \\times</span>  slower.</li>

      <li>Proof size. All proof sizes are less than three kilobytes. Compared with Groth16's, Marlin's proof is about  <span class="math">5 \\times</span>  larger. Proof sizes over BLS12-381 and MNT-298 are similar, while proof sizes over MNT-753 are  <span class="math">2.5 \\times</span>  larger.</li>

    </ul>

    <p class="text-gray-300">We measure the cost of incremental verification for privacy-preserving payments as described in Section 5 in Table 3. The compliance predicate requires checking four Merkle proofs (two for the set of coin commitments and two for the set of serial numbers) and verifying a zero-knowledge proof attesting the validity of the transaction. (Our compliance predicate does not incorporate a consensus protocol, which would be necessary in practice.) Therefore, the cost of incremental verification largely depends on the choice of hash function and the choice of proof system (Table 3). As expected, a universal SNARK incurs some overhead compared with a circuit-specific one. The choice of hash function also makes a difference: the constraint-optimized Poseidon hash function, compared with Pedersen, is  <span class="math">5 \\times</span>  faster in Groth16, and  <span class="math">3.5 \\times</span>  faster in Marlin.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hash function</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof system</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pedersen</td>

            <td class="px-3 py-2 border-b border-gray-700">1,230,478</td>

            <td class="px-3 py-2 border-b border-gray-700">1,377,884</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">218,088</td>

            <td class="px-3 py-2 border-b border-gray-700">365,494</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Number of constraints for incrementally verifiable privacy-preserving payments using different hash functions and different proof systems on the MNT-298 cycle.</p>

    <p class="text-gray-300">We now consider the synchronization costs, which dominate the participation costs for servers and clients. To demonstrate the benefits of IVLS (recursive proofs), we consider a simplified version of Bitcoin with no scripts. We base the parameters in Table 4 on statistics from Bitcoin over the last ten years.</p>

    <p class="text-gray-300">In Table 4, we show how no proofs, transition proofs, and recursive proofs affect synchronization costs. As expected, the system with no proofs imposes the highest synchronization costs, as it requires both servers and clients to download and re-execute every transaction. Transition proofs reduce the overhead of both clients and servers by orders of magnitude, and recursive proofs decrease the overhead for clients by orders of magnitude again, reducing the sync time to milliseconds and network cost to kilobytes for the clients. The server sync time and network cost are not as affected by the switch from transition proofs to recursive proofs because for both the network cost is dominated by the state size and the sync time is dominated by the time to hash the state. We show recursive proofs for both the MNT-298 curves ( <span class="math">\\sim</span> 80-bit security) and the MNT-753 curves ( <span class="math">\\sim</span> 128-bit security), as the BLS12-381 curve offers  <span class="math">\\sim</span> 128-bit security. <span class="math">^{12}</span></p>

    <p class="text-gray-300">In terms of network cost, the most expensive recursive proofs (Marlin over MNT-753) are still  <span class="math">46\\mathrm{M} \\times</span>  lighter than no proofs and  <span class="math">57\\mathrm{K} \\times</span>  lighter than transition proofs. In terms of synchronization time, the foregoing recursive proofs are  <span class="math">382\\mathrm{K} \\times</span>  faster than no proofs and  <span class="math">3\\mathrm{K} \\times</span>  faster than transition proofs.</p>

    <p class="text-gray-300">Comparison with other light client systems. Recursive proofs (from IVLS) make it possible to construct a client that is extremely light, both in network cost and in synchronization time. In Table 4, we show the differences in network cost and synchronization time between recursive proofs and the following: (1) Bitcoin's</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Network</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sync time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total blocks:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">25K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">50K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">100K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">250K</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">Client</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">Client</td>

            <td class="px-3 py-2 border-b border-gray-700">Bitcoin SPV</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.8 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">7.6 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">19 MB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">No proofs</td>

            <td class="px-3 py-2 border-b border-gray-700">172.3 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">172.3 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">16.9 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">16.9 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">FlyClient</td>

            <td class="px-3 py-2 border-b border-gray-700">109 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">135 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">163 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">204 KB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Transition proofs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Plumo</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 (BLS12-381)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">53.4 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">19 min</td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16</td>

            <td class="px-3 py-2 border-b border-gray-700">6.1 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">7.4 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">10 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">18 KB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Marlin (BLS12-381)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">217.4 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">35 min</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin</td>

            <td class="px-3 py-2 border-b border-gray-700">9.7 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">15 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">25 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">54 KB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Recursive proofs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Recursive proofs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 (MNT-298)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">4.8 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 (MNT-298)</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Marlin (MNT-298)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">16.3 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin (MNT-298)</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 (MNT-753)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">50.8 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 (MNT-753)</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Marlin (MNT-753)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 hrs</td>

            <td class="px-3 py-2 border-b border-gray-700">159.0 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">Marlin (MNT-753)</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">——</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Transaction size:</td>

            <td class="px-3 py-2 border-b border-gray-700">370 B</td>

            <td class="px-3 py-2 border-b border-gray-700">Transactions per block:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2,000</td>

            <td class="px-3 py-2 border-b border-gray-700">Total transactions:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">500M</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Transaction verification time:</td>

            <td class="px-3 py-2 border-b border-gray-700">122 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">State size:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.2 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">Hash time for 1 MB:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.059 s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: On the left are estimated synchronization costs and on the right are network cost for different light client schemes, for a ledger system modeled after a 10-year "bare-bones" Bitcoin (no scripts). Sync time does not include the time to download data. We use the time to verify two ECDSA signatures over the secp256k1 curve as a lower bound for the time to verify a transaction. We assume that transition proofs and recursive proofs use a Pedersen hash function to summarize the current state, and transition proofs are generated for each block. Plumo uses the CP6 curve from Zexe [BCGMMW20]. <span class="math">^{11}</span></p>

    <p class="text-gray-300">simplified payment verification (SPV), (2) FlyClient's proof of consensus [BKLZ20], and (3) Plumo's proof of consensus [Ves+22].</p>

    <p class="text-gray-300">Compared with these prior schemes for light clients, recursive proofs (via IVLS) reduce client network cost and synchronization time, at the cost of relying on sufficiently powerful proof makers, as we discuss in Section 7.5. Moreover, recursive proofs provide a stronger security guarantee by verifying the correctness of the application transitions as well as consensus transitions (as described in Appendix B.1). For more details and a discussion of qualitative differences, see ??</p>

    <p class="text-gray-300">Bitcoin's simple payment verification (SPV), estimated with the parameters in Table 4, would require downloading all the block headers of the blockchain—about  <span class="math">20\\mathrm{MB}</span> —which is at least  <span class="math">5,000\\times</span>  larger than recursive proofs. Synchronization time is small since it mainly involves checking the proof of work for every block. However, SPV provides only limited security and functionality: (1) Though SPV enables the client to check the consensus (proof of work), the client does not check the correctness of the transitions. (2) With SPV, the client can check if a transaction is present, but the client cannot check if the transaction is unspent; light clients of the same account need to synchronize with one another.</p>

    <p class="text-gray-300">FlyClient enables a client to efficiently check the consensus in proof-of-work protocols; rather than downloading every block header as in SPV, FlyClient downloads a logarithmic number of headers. Estimated with a flat proof-of-work difficulty and parameters in Table 4, a client needs to download proofs of  <span class="math">204\\mathrm{KB}</span> , using the simulator in [Wei20]. (We report a smaller proof size than the FlyClient paper because we are measuring over our bare-bones Bitcoin rather than Ethereum, which has larger block headers.) While both network cost and synchronization time are much better than SPV, the network cost is still  <span class="math">50\\times</span>  larger than that of recursive proofs. Moreover, FlyClient does not check the correctness of the transitions and cannot check if a transaction is unspent (as in SPV).</p>

    <p class="text-gray-300">Plumo provides efficient checking for changes in the consensus committee. If a proof is generated every six months (as suggested in [Ves+22]), the client needs to download at least 18 KB with Groth16 or 54 KB with Marlin. In Table 4, we show that the network cost grows linearly with the number of blocks, assuming a constant block rate. Synchronization time remains small due to efficient verification. Similar to SPV and FlyClient, Plumo does not check the transitions. Moreover, Plumo does not fully verify the consensus, such</p>

    <p class="text-gray-300">as whether committee members are indeed winners of the proof of stake. Plumo is also inefficient when a proof for recent transactions is unavailable (a common case, as proofs are generated infrequently); in this case, the client needs to download and verify these transactions. Making proof generation more frequent, or for a larger period of time, would increase the cost for either proving or verification.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">7.5 Limitation: producing proofs is costly</h3>

    <p class="text-gray-300">Recursive proofs (or even transition proofs) are generally advantageous for servers and clients compared with no proofs. The main limitation of this approach, which needs to be balanced against the advantages, is the cost incurred by proof makers to produce proofs. While asymptotically producing proofs is not much more expensive than executing transactions, concrete costs make proving orders of magnitude slower than execution. For example, generating a proof for the correct execution of <span class="math">20</span> two-input two-output transactions in our privacy-preserving payments system takes <span class="math">\\sim 33</span> s using <span class="math">8</span> threads with Groth16 over the MNT-298 cycle with the Poseidon hash. This latency limits a system’s throughput.</p>

    <p class="text-gray-300">That said, proving times for proof makers can be significantly reduced via existing techniques such as proof trees (or “parallel scan state” <em>[x1]</em>), parallelism across many machines <em>[x29]</em>, or specialized proving hardware <em>[x13]</em>. These techniques can increase the system’s transaction throughput: Using proof trees, <span class="math">100</span> machines (with the same setup above) can together produce proofs for one million privacy-preserving transactions in nine hours. (The Mina cryptocurrency <em>[x17]</em> uses proof trees for this reason.) We leave a detailed study to future work (and real-world deployments), and here only mention that proof trees should be straightforward to build given our PCD module. We conclude by noting that recursive proofs are not much harder to produce than transition proofs, as proving the state transition, not recursive verification, dominates the costs. This suggests that moving from transition proofs to recursive proofs is generally a good choice.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">8 Other related work</p>

    <p class="text-gray-300">Less related to our goals, several works have studied how to reduce participation costs via methods other than incremental verification, for either servers or clients.</p>

    <p class="text-gray-300">Servers. Transition proofs, which avoid having every server re-execute every transaction, have been studied by researchers, open-source developers, and industry. Transition proofs for batches of transactions have been studied as a “layer-2 scaling solution” on Ethereum for concrete applications like payments or self-custodial trading, such as StarkDEX [sdex], StarkPay [spay], and “rollups” [Whi18; zkr]. Ozdemir et al. [OWWB20] study more efficient transition proofs for large batches of transactions using RSA accumulators for local updates to the application’s state. Lee et al. [LNS20] study liveness for applications that use transition proofs and show efficiency gains for modest-size batches of ERC-20 transactions compared with naive re-execution. Gabizon et al. [Ves+22] propose Plumo, which uses transition proofs to prove correct evolution of consensus over large periods of time (several months), leading to fewer proofs required for client synchronization; focusing on the consensus rather than application updates allows proving many transitions at once. All of these approaches based on transition proofs incur participation costs that grow linearly in the number of state transitions; incremental verification (our focus) avoids such costs.</p>

    <p class="text-gray-300">Leung et al. [LSGZ19] design bootstrapping techniques for the Algorand proof-of-stake protocol [GHMVZ17] that provide guarantees about the validity of past transactions, without relying on a long-standing committee to store and certify state in order to protect against adaptive corruption. They do this by minimizing the amount of state that needs to be tracked, sharding this state across servers, and generating checkpoints to prevent new servers joining the system from having to check all transitions from the initial state.</p>

    <p class="text-gray-300">Clients. A rich line of work has explored techniques for reducing client participation costs, starting with Nakamoto’s Simplified Payment Verification (SPV) [Nak08]. A recurring theme is to use lightweight approaches while settling for weaker, yet meaningful, security. For example, SPV enables a server to convince a client that a transaction belongs to some past block, though the client cannot check if the current state is the result of applying transactions correctly. Analogous protocols, known as “light clients”, have been developed for other cryptocurrencies, including ones with privacy guarantees [TG18; Lee19; WMSMKČ19]. Some light clients hide the queries themselves using trusted hardware [WMSMKČ19; MWSKKC19; LHAMLK20] or private information retrieval [QHGR19].</p>

    <p class="text-gray-300">Some works have further improved the efficiency of light clients. Bünz et al. [BKLZ20] propose FlyClient, which builds on previous work on “non-interactive proofs of proof-of-work” (NIPoPoWs) [KLS16; KMZ17], allowing light clients to validate the cumulative work put into a chain by looking at only a logarithmic number of block headers.</p>

    <p class="text-gray-300">Combining transition proofs with a light client protocol can reduce synchronization costs at the server (via transition proofs) and client (via the light client protocol). Although such a solution may have comparable or even better concrete efficiency compared to IVLS, it does not provide the same security guarantees: the client does not verify transition proofs and so must trust that the server state was reached by applying transactions correctly.</p>

    <p class="text-gray-300">A Formalizing applications</p>

    <p class="text-gray-300">We describe how to express several applications in the formalism of ledger systems (Section 3), so that, by using our transformation, one can obtain incrementally verifiable versions of these applications. In Appendix A.1 we discuss account-based payments, in Appendix A.2 UTXO-based payments, in Appendix A.3 privacy-preserving payments, in Appendix A.4 privacy-preserving computation, and in Appendix A.5 key transparency. For each application, we discuss the main efficiency features of the incrementally verifiable version of the application.</p>

    <p class="text-gray-300">In this section we let SIG = (KeyGen, Sign, Verify) be a signature scheme. Public parameters required by SIG (e.g., the description of a cyclic group) can be viewed as hardcoded in a ledger system’s programs.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">A.1 Account-based payments</h3>

    <p class="text-gray-300">We describe a ledger system that captures the functionality of a simple account-based currency.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> State. The state <span class="math">S</span> of the ledger system is a search tree that contains all accounts. Each account is a tuple <span class="math">(\\mathsf{pk},\\mathsf{bal},\\mathsf{ctr})</span> where pk is a signature public key of SIG, bal is its corresponding balance, and ctr is a counter of the number of transactions that this user initiates.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Transition function. The transition function <span class="math">F</span> processes three types of transactions tx:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A create transaction of the form (create, pk). If the state <span class="math">S</span> already contains a tuple of the form <span class="math">(\\mathsf{pk},\\mathsf{bal},\\mathsf{ctr})</span>, the transition function <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that inserts the tuple <span class="math">(\\mathsf{pk},0,0)</span> into <span class="math">S</span>.</li>

      <li>A deposit transaction of the form (deposit, pk, amt). If the state <span class="math">S</span> does not contain a tuple of the form <span class="math">(\\mathsf{pk},\\mathsf{bal},\\mathsf{ctr})</span>, the transition function <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that replaces <span class="math">(\\mathsf{pk},\\mathsf{bal},\\mathsf{ctr})</span> with <span class="math">(\\mathsf{pk},\\mathsf{bal}+\\mathsf{amt},\\mathsf{ctr})</span>.</li>

      <li>A transfer transaction of the form (transfer, pkfrom, pkto, amt, sig). The transition function <span class="math">F</span> checks that the state <span class="math">S</span> contains tuples of the form <span class="math">(\\mathsf{pk}_{\\mathsf{from}},\\mathsf{bal}_{\\mathsf{from}},\\mathsf{ctr}_{\\mathsf{from}})</span> and <span class="math">(\\mathsf{pk}_{\\mathsf{to}},\\mathsf{bal}_{\\mathsf{to}},\\mathsf{ctr}_{\\mathsf{to}})</span>, that amt <span class="math">\\leq</span> balfrom, and that SIG.Verify(<span class="math">\\mathsf{pk}_{\\mathsf{from}},(\\mathsf{pk}_{\\mathsf{from}},\\mathsf{pk}_{\\mathsf{to}},\\mathsf{amt},\\mathsf{ctr}_{\\mathsf{from}}),\\mathsf{sig})=1</span>. If any of these checks fails, <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that replaces <span class="math">(\\mathsf{pk}_{\\mathsf{from}},\\mathsf{bal}_{\\mathsf{from}},\\mathsf{ctr}_{\\mathsf{from}}),(\\mathsf{pk}_{\\mathsf{to}},\\mathsf{bal}_{\\mathsf{to}},\\mathsf{ctr}_{\\mathsf{to}})</span> with <span class="math">(\\mathsf{pk}_{\\mathsf{from}},\\mathsf{bal}_{\\mathsf{from}}-\\mathsf{amt},\\mathsf{ctr}_{\\mathsf{from}}+1),(\\mathsf{pk}_{\\mathsf{to}},\\mathsf{bal}_{\\mathsf{to}}+\\mathsf{amt},\\mathsf{ctr}_{\\mathsf{to}})</span>. The counter is used to prevent replaying a previous transaction.</li>

      <li>Client function. The client function <span class="math">C</span> processes two types of queries:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A balance query of the form (balance, pk) that returns the output <span class="math">y:=\\mathsf{bal}</span> if the state <span class="math">S</span> contains a tuple of the form <span class="math">(\\mathsf{pk},\\mathsf{bal},\\mathsf{ctr})</span>. Otherwise, <span class="math">C</span> returns the output <span class="math">y:=\\mathsf{error}</span>.</li>

      <li>A counter query of the form (ctr, pk) that returns the output <span class="math">y:=\\mathsf{ctr}</span> if the state <span class="math">S</span> contains a tuple of the form <span class="math">(\\mathsf{pk},\\mathsf{bal},\\mathsf{ctr})</span>. Otherwise, <span class="math">C</span> returns the output <span class="math">y:=\\mathsf{error}</span>.</li>

    </ul>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">A.2 UTXO-based payments</h3>

    <p class="text-gray-300">We describe a ledger system that captures the functionality of a simple UTXO-based currency, modeling a bare-bones version of Bitcoin.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> State. The state <span class="math">S</span> is a search tree containing key-value pairs where each key is a signature public key pk of SIG and the corresponding value is a search tree of pairs (cid, amt) where cid is a coin identifier and amt is the corresponding amount of this coin; these pairs represent the coins owned by the public key pk.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Transition function. The transition function <span class="math">F</span> processes transactions of the form:</p>

    <p class="text-gray-300"><span class="math">\\texttt{tx}=\\big{(}[{\\texttt{cid}}_{i}^{{\\texttt{in}}}]_{1}^{m},[{\\texttt{cid}}_{j}^{{\\texttt{out}}}]_{1}^{n},[{\\texttt{amt}}_{j}^{{\\texttt{out}}}]_{1}^{n},[{\\texttt{pk}}_{j}^{{\\texttt{out}}}]_{1}^{n},{\\texttt{pk}}^{{\\texttt{in}}},\\texttt{sig}\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">[{\\texttt{cid}}_{i}^{{\\texttt{in}}}]_{1}^{m}</span> are coin identifiers of the inputs to tx and <span class="math">[{\\texttt{cid}}_{j}^{{\\texttt{out}}}]_{1}^{n}</span> are coin identifiers of the outputs of tx. For each <span class="math">j\\in[n]</span>, the value <span class="math">{\\texttt{amt}}_{j}^{{\\texttt{out}}}</span> is the amount being sent to <span class="math">{\\texttt{pk}}_{j}^{{\\texttt{out}}}</span>. The value sig is a signature over the transaction with respect to the public key <span class="math">{\\texttt{pk}}^{{\\texttt{in}}}</span>.</p>

    <p class="text-gray-300">The transition function <span class="math">F</span> looks up <span class="math">{\\texttt{pk}}^{{\\texttt{in}}}</span> in <span class="math">S</span> in order to find tuples of the form <span class="math">\\{({\\texttt{cid}}_{i}^{{\\texttt{in}}},{\\texttt{amt}}_{i}^{{\\texttt{in}}})\\}_{i\\in[m]}</span> belonging to <span class="math">{\\texttt{pk}}^{{\\texttt{in}}}</span>. Then it checks that <span class="math">\\sum_{i=1}^{m}{\\texttt{amt}}_{i}^{{\\texttt{in}}}=\\sum_{j=1}^{n}{\\texttt{amt}}_{j}^{{\\texttt{out}}}</span> and that <span class="math">S</span> does not contain any tuple of the form <span class="math">({\\texttt{cid}}_{j}^{{\\texttt{out}}},\\cdot)</span> for <span class="math">{\\texttt{pk}}_{j}^{{\\texttt{out}}}</span> for any <span class="math">j\\in[n]</span>. Moreover, <span class="math">F</span> verifies that the signature for this transaction is valid by checking</p>

    <p class="text-gray-300"><span class="math">\\texttt{SIG.Verify}\\left({\\texttt{pk}}^{{\\texttt{in}}},([{\\texttt{cid}}_{i}^{{\\texttt{in}}}]_{1}^{m},[{\\texttt{cid}}_{j}^{{\\texttt{out}}}]_{1}^{n},[{\\texttt{amt}}_{j}^{{\\texttt{out}}}]_{1}^{n},[{\\texttt{pk}}_{j}^{{\\texttt{out}}}]_{1}^{n}),\\texttt{sig}\\right)\\stackrel{{\\scriptstyle?}}{{=}}1\\enspace.</span></p>

    <p class="text-gray-300">If any lookup or check fails, <span class="math">F</span> outputs the result <span class="math">y:=\\texttt{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\texttt{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that: (a) for every <span class="math">i\\in[m]</span> removes <span class="math">({\\texttt{cid}}_{i}^{{\\texttt{in}}},{\\texttt{amt}}_{i}^{{\\texttt{in}}})</span> from the search tree of <span class="math">{\\texttt{pk}}^{{\\texttt{in}}}</span>; and (b) for every <span class="math">j\\in[n]</span> adds <span class="math">({\\texttt{cid}}_{j}^{{\\texttt{out}}},{\\texttt{amt}}_{j}^{{\\texttt{out}}})</span> to the search tree of <span class="math">{\\texttt{pk}}_{j}^{{\\texttt{out}}}</span>.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Client function. The client function <span class="math">C</span> processes two types of queries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <em>balance query</em> of the form <span class="math">(\\texttt{balance},\\texttt{pk})</span> that returns the total assets held by the public key pk. Namely, <span class="math">C</span> outputs <span class="math">y:=\\sum_{i=1}^{k}{\\texttt{amt}}_{i}</span> for the <span class="math">k</span> pairs <span class="math">(\\cdot,{\\texttt{amt}}_{i})</span> associated with pk in <span class="math">S</span>.</li>

      <li>A <em>coin query</em> of the form <span class="math">(\\texttt{coin},\\texttt{pk})</span> that returns all the coin identifiers and amounts owned by the public key pk. Namely, <span class="math">C</span> outputs <span class="math">y</span> containing all pairs of the form <span class="math">(\\texttt{cid},\\texttt{amt})</span> for pk in <span class="math">S</span>.</li>

    </ul>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">A.3 Privacy-preserving payments</h3>

    <p class="text-gray-300">We describe a ledger system that captures the functionality of a simple privacy-preserving currency, modeling the basic functionality of Zerocash <em>[x1]</em>. We assume basic familiarity with Zerocash and only discuss the aspects relevant for the formalism of ledger systems. We denote by VerifyZKP the algorithm that validates the zero-knowledge proof contained in a Zerocash transaction (after suitably parsing the transaction).</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> State. The state <span class="math">S</span> contains a Merkle tree of coin commitments, a Merkle tree of serial numbers, and a list of encrypted coins of all the transactions so far.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Transition function. The transition function <span class="math">F</span> processes two types of transactions tx:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <em>mint transaction</em> of the form <span class="math">\\texttt{tx}=(\\texttt{mint},\\texttt{cm},v,\\pi_{\\texttt{MINT}})</span>, which creates a coin of value <span class="math">v</span> with commitment cm. If <span class="math">\\texttt{VerifyZKP}(\\texttt{tx})=1</span>, <span class="math">F</span> outputs the result <span class="math">y:=\\texttt{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that adds cm to the Merkle tree of commitments. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\texttt{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>.</li>

      <li>A <em>pour transaction</em> of the form <span class="math">\\texttt{tx}=(\\texttt{pour},\\texttt{sn}_{1}^{{\\texttt{in}}},\\texttt{sn}_{2}^{{\\texttt{in}}},\\texttt{cm}_{1}^{{\\texttt{out}}},\\texttt{cm}_{2}^{{\\texttt{out}}},\\texttt{e}_{1},\\texttt{e}_{2},\\pi_{\\texttt{POUR}})</span>. The values <span class="math">\\texttt{sn}_{1}^{{\\texttt{in}}},\\texttt{sn}_{2}^{{\\texttt{in}}}</span> are the serial numbers of the old (spent) coins, while the values <span class="math">\\texttt{cm}_{1}^{{\\texttt{out}}},\\texttt{cm}_{2}^{{\\texttt{out}}}</span> are the commitments of the new (created) coins. The values <span class="math">\\texttt{e}_{1},\\texttt{e}_{2}</span> are encryptions of the new coins under public keys of the (unknown) receivers. The value <span class="math">\\pi_{\\texttt{POUR}}</span> is a proof used to attest to the validity of this transaction.</li>

    </ul>

    <p class="text-gray-300">The transition function <span class="math">F</span> checks that <span class="math">\\texttt{VerifyZKP}(\\texttt{tx})=1</span> and that the serial numbers <span class="math">\\texttt{sn}_{1}^{{\\texttt{in}}}</span> and <span class="math">\\texttt{sn}_{2}^{{\\texttt{in}}}</span> do not appear in the list of serial numbers. If both checks pass, <span class="math">F</span> outputs the result <span class="math">y:=\\texttt{ok}</span> and the state update</p>

    <p class="text-gray-300"><span class="math">\\Delta_{S}</span> that adds <span class="math">\\mathsf{cm}_{1}^{\\mathsf{out}}</span> and <span class="math">\\mathsf{cm}_{2}^{\\mathsf{out}}</span> to the Merkle tree of commitments, adds <span class="math">\\mathsf{sn}_{1}^{\\mathsf{in}}</span> and <span class="math">\\mathsf{sn}_{2}^{\\mathsf{in}}</span> to the Merkle tree of serial numbers, and appends encrypted coins <span class="math">\\mathbf{e}_{1}</span> and <span class="math">\\mathbf{e}_{2}</span> to the list of encrypted coins. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Client function. The client function <span class="math">C</span> enables a user’s client to find payments sent to the user. The client function <span class="math">C</span> takes as input a viewing key <span class="math">\\mathsf{sk}_{\\mathsf{view}}</span> and checks which of the encrypted coins in the state <span class="math">S</span> belong to this user. This check can be done by scanning through all encrypted coins and trying to decrypt each using <span class="math">\\mathsf{sk}_{\\mathsf{view}}</span>. We can, by careful designs, further constrain <span class="math">\\mathsf{sk}_{\\mathsf{view}}</span> to only capable of testing whether the encrypted coins belong to the user but incapable of seeing the underlying information.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">A.4 Privacy-preserving computation</h3>

    <p class="text-gray-300">We can also express privacy-preserving computation in a ledger system, which models the basic functionality in Zexe <em>[x1]</em>. This is similar to the case of privacy-preserving payment, so we will focus on the differences as follows. We assume basic familiarity with Zexe and only discuss the aspects relevant for the formalism of ledger system. In Zexe, computation is expressed in terms of operations over <em>records</em>. A computation step consumes some previous records (takes old data as input) and creates some new records (outputs new data).</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> State. The state <span class="math">S</span> comprises a Merkle tree of all record commitments appearing in all transactions and a Merkle tree of serial numbers so far.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Transition function. The transition function processes a transaction <span class="math">\\mathsf{tx}</span> of the form <span class="math">([\\mathsf{sn}_{i}^{\\mathsf{in}}]^{N}_{1},[\\mathsf{cm}_{i}^{\\mathsf{out}}]^{M}_{1},</span> <span class="math">\\pi)</span>, which consumes records associated with serial numbers in <span class="math">[\\mathsf{sn}_{i}^{\\mathsf{in}}]^{N}_{1}</span> and generates records associated with commitments in <span class="math">[\\mathsf{cm}_{i}^{\\mathsf{out}}]^{M}</span>. The value <span class="math">\\pi</span> is a cryptographic proof that the computation is executed correctly. The transition function <span class="math">F</span> checks that <span class="math">\\mathsf{VerifyZKP}(\\mathsf{tx})=1</span> and that all the serial numbers <span class="math">[\\mathsf{sn}_{i}^{\\mathsf{in}}]^{N}_{1}</span> do not appear in the list of serial numbers in <span class="math">S</span>. If the checks pass, <span class="math">F</span> outputs the result <span class="math">y:=\\mathsf{ok}</span> and the state update <span class="math">\\Delta</span> that adds <span class="math">[\\mathsf{cm}_{i}^{\\mathsf{out}}]^{M}_{1}</span> to the Merkle tree of commitments and adds <span class="math">[\\mathsf{sn}_{i}^{\\mathsf{in}}]^{N}_{1}</span> to the search tree of serial numbers. Otherwise, <span class="math">F</span> outputs <span class="math">y:=\\mathsf{error}</span> and empty state update <span class="math">\\Delta:=\\bot</span>.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Client function. The client function <span class="math">C</span> checks if a record has been committed and if a record has been consumed in the state <span class="math">S</span>. The client function <span class="math">C</span> processes two types of queries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <em>commitment query</em> of the form <span class="math">(\\mathsf{commitment},\\mathsf{cm})</span> that returns <span class="math">1</span> if <span class="math">\\mathsf{cm}</span> is in the Merkle tree of commitments in <span class="math">S</span> and <span class="math">0</span> otherwise.</li>

      <li>A <em>consumption query</em> of the form <span class="math">(\\mathsf{consumption},\\mathsf{sn})</span> that returns <span class="math">1</span> if <span class="math">\\mathsf{sn}</span> is in the search tree of revealed serial numbers in <span class="math">S</span> and <span class="math">0</span> otherwise.</li>

    </ul>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">A.5 Key transparency</h3>

    <p class="text-gray-300">An application of ledger systems outside of cryptocurrencies is key transparency <em>[x15, x16]</em>, a public directory that maps usernames to public keys. Users can publish their own public keys on this directory, query other users’ public keys, and monitor that the directory behaves correctly. We consider two variants of key transparency, which differ in how they handle the case when a user wants to change their public key in the directory (e.g., due to secret key loss or due to routine key update).</p>

    <p class="text-gray-300">Variant 1: key update with authorization. A user, to update their own public key, must provide a signature under their previous public key or under a trusted authority’s public key (to account for secret key loss).</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> State. The state <span class="math">S</span> consists of a Merkle tree that maps usernames to public keys. The state <span class="math">S</span> also stores the trusted authority’s public key, denoted by <span class="math">\\mathsf{pk}_{\\mathbbm{R}}</span>.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Transition function. The transition function <span class="math">F</span> processes two types of transactions <span class="math">\\mathsf{tx}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A registration transaction of the form <span class="math">(\\mathtt{new},u,\\mathsf{pk}_{u})</span>. If the tree in <span class="math">S</span> already has a node for the username <span class="math">u</span>, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that adds <span class="math">(u,\\mathsf{pk}_{u})</span> into the tree.</li>

      <li>An update transaction of the form <span class="math">(\\mathtt{update},u,\\mathsf{pk}_{u}^{\\mathtt{new}},\\mathtt{sig})</span>. If the tree in <span class="math">S</span> does not contain a node with username <span class="math">u</span>, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, letting <span class="math">(u,\\mathsf{pk}_{u}^{\\mathtt{old}})</span> be the node for for <span class="math">u</span>, <span class="math">F</span> checks that <span class="math">\\mathsf{Verify}(\\mathsf{pk}_{u}^{\\mathtt{old}},(u,\\mathsf{pk}_{u}^{\\mathtt{new}}),\\mathtt{sig})=1</span> or <span class="math">\\mathsf{Verify}(\\mathsf{pk}_{\\mathbbm{R}},(u,\\mathsf{pk}_{u}^{\\mathtt{old}},\\mathsf{pk}_{u}^{\\mathtt{new}}),\\mathtt{sig})=1</span>. If so, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that changes the node to <span class="math">(u,\\mathsf{pk}_{u}^{\\mathtt{new}})</span>; else if the signature is invalid, <span class="math">F</span> outputs <span class="math">y:=\\mathtt{error}</span> and empty state update <span class="math">\\Delta_{S}=\\bot</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bullet</span> Client function. The client function <span class="math">C</span> takes as input a username <span class="math">x:=u</span> and searches for its public key in the tree in <span class="math">S</span>. If <span class="math">C</span> finds a public key, it outputs <span class="math">y:=\\mathsf{pk}_{u}</span>; otherwise, it outputs <span class="math">y:=\\bot</span>.</p>

    <p class="text-gray-300">Variant 2: Append-only key transparency. A user monitors all changes to their public key, which requires the history of all public keys to be stored in the state. When the directory server adds some unauthorized keys, the identity owner can detect the discrepancy. Compared with Variant 1, this variant no longer requires a signature for key updates, and each username is now associated with a chronologically ordered list of public keys (current and the past) instead of only the current key.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> State. The state <span class="math">S</span> consists of a Merkle tree that maps a username <span class="math">u</span> to a list of public keys <span class="math">\\mathsf{list}_{u}</span>.</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Transition function. The transition function <span class="math">F</span> processes two types of transactions <span class="math">\\mathsf{tx}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A registration transaction of the form <span class="math">(\\mathtt{new},u,\\mathsf{pk}_{u})</span>. If the tree in <span class="math">S</span> already has a node for the username <span class="math">u</span>, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that adds <span class="math">(u,\\mathsf{list}_{u})</span> into the tree where <span class="math">\\mathsf{list}_{u}:=(\\mathsf{pk}_{u})</span>.</li>

      <li>An update transaction of the form <span class="math">(\\mathtt{update},u,\\mathsf{pk}_{u}^{\\mathtt{new}})</span>. If the tree in <span class="math">S</span> does not contain a node with <span class="math">u</span>, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{error}</span> and empty state update <span class="math">\\Delta_{S}:=\\bot</span>. Otherwise, letting <span class="math">(u,\\mathsf{list}_{u}^{\\mathtt{old}})</span> be the node for <span class="math">u</span>, <span class="math">F</span> outputs the result <span class="math">y:=\\mathtt{ok}</span> and the state update <span class="math">\\Delta_{S}</span> that changes the node to <span class="math">(u,\\mathsf{list}_{u}^{\\mathtt{new}})</span> in which <span class="math">\\mathsf{list}_{u}^{\\mathtt{new}}</span> is the result of appending <span class="math">\\mathsf{pk}_{u}^{\\mathtt{new}}</span> to <span class="math">\\mathsf{list}_{u}^{\\mathtt{old}}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bullet</span> Client function. The client function <span class="math">C</span> takes as input a username <span class="math">x:=u</span> and searches for its list of public keys in the tree in <span class="math">S</span>. If <span class="math">C</span> finds the list, it outputs <span class="math">y:=\\mathsf{list}_{u}</span>; otherwise, it outputs <span class="math">y:=\\bot</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">B Further considerations</p>

    <p class="text-gray-300">We discuss further considerations for applications that are beyond the scope of this paper, but may be useful for real-world deployments.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">B.1 Integration with consensus protocols</h3>

    <p class="text-gray-300">While in describing applications (in Section 5) we do not mention a consensus protocol, in the real world one may need to take consensus into account because it <em>must</em> be incrementally verifiable if the system as a whole is to be incrementally verifiable. We view a consensus protocol as an algorithm that can be folded into the application, by suitably augmenting the application state and transition function, so that its incremental evolution will then be proved together with the application. Consensus protocols need not be compatible with incremental verification “off-the-shelf”, and prior work has studied how to make specific consensus protocols incrementally verifiable <em>[x1, x10]</em>; a systematic treatment of this remains an exciting research direction.</p>

    <p class="text-gray-300">Here, we give a brief overview of how this can be achieved. Consider peer-to-peer systems with multiple servers running an application. The servers must somehow agree on the next transaction (or block of transactions) to process. This is typically achieved by way of a consensus protocol, which leverages paradigms such as proof of work (PoW), proof of stake (PoS), or others.</p>

    <p class="text-gray-300">We summarize how to integrate consensus protocols with IVLS. To make ledger systems incrementally verifiable, one must augment the application’s transition function <span class="math">F</span> to add an algorithm that maintains consensus information. Otherwise, even if the application is incrementally verifiable, the consensus would not be, and the overall system would not be incrementally verifiable. (Participation costs would remain high due to the need to “catch up” on consensus information from the initial state of the system.) However, not all consensus protocols are amenable to incremental verification: some protocols require servers to store large amounts of consensus information (e.g., going back arbitrarily far in history).</p>

    <p class="text-gray-300">Different consensus paradigms have been studied (see recent surveys <em>[x2, x11]</em>), and their suitability for incremental verification varies. Prior work has focused on adapting specific consensus protocols for incremental verification <em>[x10, x2]</em>, so we explain how they fit within IVLS.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Nakamoto consensus.</h5>

    <p class="text-gray-300">The canonical consensus protocol based on proof of work is the Nakamoto consensus protocol <em>[x24]</em>, which instructs servers to follow the “longest chain rule”, meaning that the correct chain is the one with the highest amount of cumulative work. In more detail, each transaction contains a proof of work with a specific difficulty, and the cumulative work of a chain is the sum of the difficulties across all transactions in the chain. To maintain this information, the IVLS application state is augmented with a field that stores the cumulative work; when processing a transaction, the transition function adds the difficulty of the transaction’s proof of work to the cumulative work stored in the application state. Therefore, the cumulative work is incrementally updated, and anyone can correctly choose between different application states by selecting the one with the highest cumulative work.</p>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Ouroboros.</h5>

    <p class="text-gray-300">As noted in <em>[x1]</em>, many proof-of-stake protocols are not incrementally updatable “off the shelf” because their chain selection rules require reasoning about information arbitrarily in the past to protect against long-range fork attacks. Bonneau et al. <em>[x1]</em> construct a proof-of-stake protocol called Ouroboros Samasika (based on Ouroboros Genesis <em>[x3]</em>) whose chain selection rule is <em>incrementally updatable</em>. Because chain selection is incrementally updatable, the IVLS transition function can be augmented to support it efficiently.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Consensus with incremental updates.</h5>

    <p class="text-gray-300">Given the value of incremental verifiability, we believe that it would</p>

    <p class="text-gray-300">be valuable to see more research into consensus protocols that are suitable for incremental verification. An informative first step would be to conduct a systematic study of which known protocols based on proof of work (e.g., Bitcoin-NG <em>[x11]</em>, GHOST <em>[x37]</em>, Spectre <em>[x36]</em>, and others) can be implemented via incremental updates to a small state; a similar study for proof-of-stake protocols would be valuable. Moreover, future research in consensus protocols may want to consider incremental updates to be one of the “standard” desiderata.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">B.2 Privacy considerations</h3>

    <p class="text-gray-300">Some ledger systems provide privacy guarantees (e.g., <em>[x4, x1]</em> as discussed in Section 5). Applying an IVLS compiler to such ledger systems does <em>not</em> affect those privacy guarantees.</p>

    <p class="text-gray-300">However, the queries that a client makes to the (public) application state may involve private information, and so a client may wish to have some privacy guarantees against servers that answer its queries. We consider this problem beyond the scope of this paper (our focus is on reducing participation costs). In particular, the notion of an IVLS does not make any attempts to ensure that clients in <span class="math">(\\mathsf{vF},\\mathsf{vC})</span> have any more privacy guarantees against servers than in the original ledger system <span class="math">\\mathsf{LS}=(F,C)</span>.</p>

    <p class="text-gray-300">It remains an interesting direction to investigate how to achieve private queries in practice, possibly while also reducing participation costs (as achieved by incremental verifiability). Here we only briefly recall two generic techniques that in principle could be used to protect the client’s query privacy against servers.</p>

    <p class="text-gray-300">Secure multi-party computation. One approach is for the client and server to engage in a two-party protocol to securely compute <span class="math">y\\leftarrow C^{S}(x)</span>. The client would provide the query <span class="math">x</span> as input to the protocol, and receive the answer <span class="math">y</span> as output; the server would provide the application state <span class="math">S</span> as input to the protocol, and receive no output. The two-party protocol can leverage private information retrieval (PIR) <em>[x10]</em> to hide client function <span class="math">C</span>’s access to the state. Alternatively, for efficiency reasons, the client could instead choose to engage in a <em>multi</em>-party protocol <em>[x39, x16, x12, x13]</em>, enlisting the help of multiple servers that are assumed to not collude (up to some threshold). In either case, privacy would require hiding access patterns to the state, which may be expensive. (Alternatively one could aim to trade more efficiency for less privacy by deliberately leaking specific information about <span class="math">x</span>.)</p>

    <p class="text-gray-300">Secure hardware. Another approach is for the client to communicate with a piece of secure hardware (e.g., using hardware enclaves <em>[x27, x14]</em> ) on the server’s machine, which will execute the client’s query within certain secure boundaries. The privacy of the client would then depend upon the threat model and security guarantees of the secure hardware used.</p>

    <p class="text-gray-300">C Construction of an IVLS compiler</p>

    <p class="text-gray-300">We construct an incrementally verifiable ledger compiler (Setup, MakeSF, MakeC, History). In Appendix C.1 we describe the building blocks that we use. In Appendix C.2 we describe the auxiliary state. In Appendices C.3 to C.6 we describe each of the components. We discuss the security proof in Appendix D, where we also specify in more detail the security properties that we assume hold for the building blocks.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">C.1 Building blocks</h3>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Non-interactive argument of knowledge.</h5>

    <p class="text-gray-300">A non-interactive argument of knowledge (ARK) is a tuple of polynomial-time algorithms <span class="math">\\mathsf{ARK}=(\\mathsf{Setup},\\mathsf{KeyGen},\\mathsf{Prove},\\mathsf{Verify})</span> with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda})\\to\\mathsf{pp}_{\\mathsf{ARK}}</span>: on input a security parameter <span class="math">1^{\\lambda}</span>, <span class="math">\\mathsf{Setup}</span> samples ARK public parameters <span class="math">\\mathsf{pp}_{\\mathsf{ARK}}</span>.</li>

      <li><span class="math">\\mathsf{KeyGen}(\\mathsf{pp}_{\\mathsf{ARK}},R)\\to(\\mathsf{pk}_{R},\\mathsf{vk}_{R})</span>: on input public parameters <span class="math">\\mathsf{pp}_{\\mathsf{ARK}}</span> and a specification of an NP relation <span class="math">R</span>, <span class="math">\\mathsf{KeyGen}</span> deterministically derives a proving key <span class="math">\\mathsf{pk}_{R}</span> and a verification key <span class="math">\\mathsf{vk}_{R}</span> for the NP relation <span class="math">R</span>.</li>

      <li><span class="math">\\mathsf{Prove}(\\mathsf{pk}_{R},\\mathtt{x},\\mathtt{w})\\to\\pi</span>: on input a proving key <span class="math">\\mathsf{pk}_{R}</span>, instance <span class="math">\\mathtt{x}</span>, and witness <span class="math">\\mathtt{w}</span>, <span class="math">\\mathsf{Prove}</span> outputs a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{Verify}(\\mathsf{vk}_{R},\\mathtt{x},\\pi)\\to b</span>: on input a verification key <span class="math">\\mathsf{vk}_{R}</span>, instance <span class="math">\\mathtt{x}</span>, and proof <span class="math">\\pi</span>, <span class="math">\\mathsf{Verify}</span> determines if <span class="math">\\pi</span> is a convincing proof (of knowledge) for the statement “there exists <span class="math">\\mathtt{w}</span> such that <span class="math">(\\mathtt{x},\\mathtt{w})\\in R</span>”.</li>

    </ul>

    <p class="text-gray-300">The completeness and knowledge soundness properties that we will assume for ARK are stated in Appendix D.3.</p>

    <h5 id="sec-37" class="text-base font-semibold mt-4">Incrementally verifiable computation.</h5>

    <p class="text-gray-300">Incrementally verifiable computation (IVC) <em>[x18]</em> is a cryptographic primitive that augments multi-step automata computations with proofs attesting to the correctness of the computation so far. There is an efficient procedure to move from a state of the automaton and its proof to the new state of the automaton and a corresponding new proof. The formalism for IVC that we use is drawn from the literature on proof-carrying data <em>[x5, x1, x2]</em>, which extends IVC to more general settings of incrementally verifiable distributed computations. In particular, the automata computations that we consider are non-deterministic: each transition takes an old state <em>and an auxiliary input</em> to a new state.</p>

    <p class="text-gray-300">An IVC scheme is a tuple of polynomial-time algorithms <span class="math">\\mathsf{IVC}=(\\mathsf{Setup},\\mathsf{KeyGen},\\mathsf{Prove},\\mathsf{Verify})</span> with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda})\\to\\mathsf{pp}_{\\mathsf{IVC}}</span>: on input a security parameter <span class="math">1^{\\lambda}</span>, <span class="math">\\mathsf{Setup}</span> samples IVC public parameters <span class="math">\\mathsf{pp}_{\\mathsf{IVC}}</span>.</li>

      <li><span class="math">\\mathsf{KeyGen}(\\mathsf{pp}_{\\mathsf{IVC}},\\Pi)\\to(\\mathsf{pk}_{\\Pi},\\mathsf{vk}_{\\Pi})</span>: on input IVC public parameters <span class="math">\\mathsf{pp}_{\\mathsf{IVC}}</span> and a specification of an IVC compliance predicate <span class="math">\\Pi</span>, <span class="math">\\mathsf{KeyGen}</span> outputs a proving key <span class="math">\\mathsf{pk}_{\\Pi}</span> and a verification key <span class="math">\\mathsf{vk}_{\\Pi}</span> for the predicate <span class="math">\\Pi</span>. A compliance predicate <span class="math">\\Pi</span> determines which transitions are valid: it receives input a new message <span class="math">z^{\\mathsf{new}}</span> (a new “state”), local data <span class="math">w</span> (an “auxiliary input”), and old message <span class="math">z^{\\mathsf{old}}</span> (an old “state”), and outputs a bit indicating whether the transition from <span class="math">z^{\\mathsf{old}}</span> to <span class="math">z^{\\mathsf{new}}</span> is valid.</li>

      <li><span class="math">\\mathsf{Prove}(\\mathsf{pk}_{\\Pi},z^{\\mathsf{new}},w,z^{\\mathsf{old}},\\pi^{\\mathsf{old}})\\to\\pi^{\\mathsf{new}}</span>: on input a proving key <span class="math">\\mathsf{pk}_{\\Pi}</span>, new message <span class="math">z^{\\mathsf{new}}</span>, local data <span class="math">w</span>, and previous message <span class="math">z^{\\mathsf{old}}</span> with proof <span class="math">\\pi^{\\mathsf{old}}</span>, <span class="math">\\mathsf{Prove}</span> outputs a proof <span class="math">\\pi^{\\mathsf{new}}</span> attesting that this message transition is in compliance with the predicate <span class="math">\\Pi</span>. In the base case, one takes <span class="math">z^{\\mathsf{old}}=\\pi^{\\mathsf{old}}=\\bot</span>.</li>

      <li><span class="math">\\mathsf{Verify}(\\mathsf{vk}_{\\Pi},z,\\pi)\\to b</span>: on input a verification key <span class="math">\\mathsf{vk}_{\\Pi}</span>, message <span class="math">z</span>, and proof <span class="math">\\pi</span>, <span class="math">\\mathsf{Verify}</span> determines if <span class="math">\\pi</span> is a valid proof attesting that <span class="math">z</span> is the output of a <span class="math">\\Pi</span>-compliant transcript of computation.</li>

    </ul>

    <p class="text-gray-300">The completeness and knowledge soundness properties that we will assume for IVC are stated in Appendix D.2.¹³</p>

    <p class="text-gray-300"><strong>Merkle tree.</strong> A Merkle tree (MT) is an authenticated data structure with efficient lookups and updates. We view it as a tuple of algorithms MT = (Setup, New, Root, Validate, Lookup, VerifyLookup, Modify, VerifyModify) with the syntax specified below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup(1ᴬ) → pp_MT: on input a security parameter 1ᴬ, Setup samples MT public parameters pp_MT.</li>

      <li>New(pp_MT) → T: on input MT public parameters pp_MT, New outputs an empty tree T.</li>

      <li>Root⁻ᵀ(pp_MT) → rh: on input MT public parameters pp_MT, with oracle access to the tree T, Root outputs the root hash value of the tree rh.</li>

      <li>Validate(pp_MT, T) → b: on input MT public parameters pp_MT and the tree T, Validate determines if the Merkle tree is constructed correctly (e.g., the hashes of internal nodes correspond to their children).</li>

      <li>Lookup⁻ᵀ(pp_MT, [addr_i]ᵀᵀ) → π_lookup: on input MT public parameters pp_MT and locations [addr_i]ᵀᵀ, with oracle access to the tree T, Lookup outputs a proof π_lookup certifying the values at those locations.</li>

      <li>VerifyLookup(pp_MT, rh, [addr_i]ᵀᵀ, [data_i]ᵀᵀ, π_lookup) → b: on input MT public parameters pp_MT, the tree's root hash rh, the queried locations [addr_i]ᵀᵀ, the data at those locations [data_i]ᵀᵀ, and the proof π_lookup, VerifyLookup determines if the lookup result is valid.</li>

      <li>Modify⁻ᵀ(pp_MT, [addr_i]ᵀᵀ, [data_i]ᵀᵀ) → (rh, Δ_T, π_modify): on input MT public parameters pp_MT, the locations to be modified [addr_i]ᵀᵀ, and the new data [data_i]ᵀᵀ, with oracle access to the tree T, Modify outputs the new root hash rh, the update to the tree Δ_T, and a proof π_modify.</li>

      <li>VerifyModify(pp_MT, rh^old, rh^new, [addr_i]ᵀᵀ, [data_i]ᵀᵀ, π_modify) → b: on input MT public parameters pp_MT, the old tree's root hash rh^old, the new tree's root hash rh^new, the modified locations [addr_i]ᵀᵀ, the new data [data_i]ᵀᵀ, and the proof π_modify, VerifyModify determines if the modification is valid.</li>

    </ul>

    <p class="text-gray-300">The completeness and security properties that we will assume for MT are stated in Appendix D.5.</p>

    <h2 id="sec-38" class="text-2xl font-bold">C.2 Auxiliary state</h2>

    <p class="text-gray-300">In addition to the state S of the original transition function F, the incrementally verifiable transition function vF will maintain an auxiliary state A of the following form</p>

    <div class="my-4 text-center"><span class="math-block">A = (t, \\mathsf{cm}, \\pi_{\\mathsf{F}}, T_{\\text{state}}, T_{\\text{history}}) \\ ,</span></div>

    <p class="text-gray-300">where: t records the current time (the number of transactions applied so far); T_state is a Merkle tree over S; T_history is a Merkle tree over all state commitments so far, ordered chronologically; cm is the current state commitment, and is defined as cm := (rh_state, rh_history) where rh_state is the root hash of T_state and rh_history is the root hash of T_history; π_F is a proof attesting that “cm commits to a state obtained with t transactions”.</p>

    <p class="text-gray-300">¹³These definitions can be straightforwardly extended to oracle-based models in those cases where security must hold in the presence of application-specific oracles (e.g., a signing oracle for a signature scheme), by following the analogous case for argument systems in [FN16].</p>

    <p class="text-gray-300">C.3 Construction of Setup</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathsf{Setup}(1^{\\lambda})}\\to \\mathsf{pp}</span>. Run the setup algorithms of the building blocks: <span class="math">\\mathsf{pp}_{\\mathsf{MT}}\\gets \\mathsf{MT.Setup}(1^{\\lambda})</span>; <span class="math">\\mathsf{pp}_{\\mathsf{IVC}}\\gets \\mathsf{IVC.Setup}(1^{\\lambda})</span>; <span class="math">\\mathsf{pp}_{\\mathsf{ARK}}\\gets \\mathsf{ARK.Setup}(1^{\\lambda})</span>. Output the public parameters <span class="math">\\mathsf{pp} := (\\mathsf{pp}_{\\mathsf{MT}},\\mathsf{pp}_{\\mathsf{IVC}},\\mathsf{pp}_{\\mathsf{ARK}})</span>.</p>

    <p class="text-gray-300">C.4 Construction of MakeSF</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathsf{MakeSF}(\\mathsf{pp},F)\\to(\\mathsf{vS},\\mathsf{vF})}</span>. Parse <span class="math">\\mathsf{pp}</span> as <span class="math">(\\mathsf{pp}_{\\mathsf{MT}},\\mathsf{pp}_{\\mathsf{IVC}},\\mathsf{pp}_{\\mathsf{ARK}})</span>. Create the IVC predicate <span class="math">\\Pi</span> as defined below, which hardcodes <span class="math">(\\mathsf{pp}_{\\mathsf{MT}},F)</span>.</p>

    <p class="text-gray-300"><span class="math">\\Pi (z^{\\mathrm{new}},w,z^{\\mathrm{old}})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the new message <span class="math">z^{\\mathrm{new}}</span> as <span class="math">(t^{\\mathrm{new}},\\mathsf{cm}^{\\mathrm{new}})</span>. Parse the commitment <span class="math">\\mathsf{cm}^{\\mathrm{new}}</span> as <span class="math">(\\mathsf{rh}_{\\mathrm{state}}^{\\mathrm{new}},\\mathsf{rh}_{\\mathrm{history}}^{\\mathrm{new}})</span>.</li>

      <li>Parse the local data <span class="math">w</span> as <span class="math">(\\mathsf{trans},[\\mathsf{raddr}_i]_1^N,[\\mathsf{rdata}_i]_1^N,\\pi_{\\mathsf{read}},\\mathsf{tx},[\\mathsf{waddr}_i]_1^M,[\\mathsf{wdata}_i]_1^M,\\pi_{\\mathsf{write}},\\pi_{\\mathsf{insert}})</span>.</li>

      <li>Check that <span class="math">\\mathsf{trans}</span> is a valid execution transcript of the transition function <span class="math">F</span> on input tx, read queries <span class="math">[\\mathsf{raddr}_i]_1^N</span>, corresponding read answers <span class="math">[\\mathsf{rdata}_i]_1^N</span>, and output state update <span class="math">\\Delta_S = ([\\mathsf{waddr}_i]_1^M, [\\mathsf{wdata}_i]_1^M)</span>.</li>

      <li>For the base case <span class="math">(z^{\\mathrm{old}} = \\bot)</span>, check the following:</li>

      <li>(index is initialized correctly) <span class="math">t^{\\mathrm{new}} = 1</span>;</li>

      <li>(reads return no data because the initial state is empty) <span class="math">[rdata_i]_1^N = \\bot</span>;</li>

      <li>(writes are performed) MT.VerifyModify <span class="math">(pp_{MT}, rh_{state}^{empty}, rh_{state}^{new}, [waddr_i]_1^M, [wdata_i]_1^M, \\pi_{write}) = 1</span>, where <span class="math">rh_{state}^{empty}</span> is the root hash of an empty Merkle tree (a tree created by MT.New <span class="math">(pp_{MT})</span>).</li>

      <li>Otherwise <span class="math">(z^{\\mathrm{old}} \\neq \\bot)</span>, parsing the old message <span class="math">z^{\\mathrm{old}}</span> as <span class="math">(t^{\\mathrm{old}}, \\mathsf{cm}^{\\mathrm{old}})</span> and parsing <span class="math">\\mathsf{cm}^{\\mathrm{old}}</span> as <span class="math">(\\mathsf{rh}_{\\mathrm{state}}^{\\mathrm{old}}, \\mathsf{rh}_{\\mathrm{history}}^{\\mathrm{old}})</span>, check the following:</li>

      <li>(index grows correctly) <span class="math">t^{\\mathrm{new}} = t^{\\mathrm{old}} + 1</span>.</li>

      <li>(reads are correct) MT.VerifyLookup <span class="math">(pp_{MT}, rh_{state}^{old}, [\\mathsf{raddr}_i]_1^N, [\\mathsf{rdata}_i]_1^N, \\pi_{\\mathsf{read}}) = 1</span>.</li>

      <li>(writes are performed) MT.VerifyModify <span class="math">(pp_{MT}, rh_{state}^{old}, rh_{state}^{new}, [\\mathsf{waddr}_i]_1^M, [\\mathsf{wdata}_i]_1^M, \\pi_{\\mathsf{write}}) = 1</span>.</li>

      <li>(commitment is added to history) MT.VerifyModify <span class="math">(pp_{MT}, rh_{history}^{old}, rh_{history}^{new}, t^{old}, cm^{old}, \\pi_{insert}) = 1</span>.</li>

    </ul>

    <p class="text-gray-300">Derive the IVC key pair <span class="math">(\\mathsf{pk}_{\\Pi},\\mathsf{vk}_{\\Pi})\\gets \\mathsf{IVC.KeyGen}(\\mathsf{pp}_{\\mathsf{IVC}},\\Pi)</span>. Construct and output the tuple <span class="math">\\mathsf{vS} = (\\mathsf{Info},\\mathsf{VerifyCM},\\mathsf{VerifyAll})</span> as defined below. Note that VerifyCM hardcodes <span class="math">\\mathsf{pp}_{\\mathsf{MT}}</span> and VerifyAll hardcodes <span class="math">(\\mathsf{pp}_{\\mathsf{MT}},\\mathsf{vk}_{\\Pi})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{vS.Info}^{S,A}() \\to (t, \\mathsf{cm}, \\pi_{\\mathsf{F}})</span>. Retrieve <span class="math">(t, \\mathsf{cm}, \\pi_{\\mathsf{F}})</span> from the auxiliary state <span class="math">A</span>, and output it.</li>

      <li><span class="math">\\mathsf{vS.VerifyCM}(S, \\mathsf{cm}) \\to b</span>. If <span class="math">S = \\bot</span> and <span class="math">\\mathsf{cm} = \\bot</span>, output 1. Otherwise, parse <span class="math">\\mathsf{cm}</span> as <span class="math">(\\mathsf{rh}_{\\mathsf{state}}, \\mathsf{rh}_{\\mathsf{history}})</span>, and check that <span class="math">\\mathsf{rh}_{\\mathsf{state}}</span> is the root of a Merkle tree built on the state <span class="math">S</span>.</li>

      <li><span class="math">\\mathsf{vS.VerifyAll}(S, A) \\to b</span>. For the base case <span class="math">(A = \\bot)</span>, check that <span class="math">S = \\bot</span>. Otherwise <span class="math">(A \\neq \\bot)</span>, parse <span class="math">A</span> as <span class="math">(t, \\mathsf{cm}, \\pi_{\\mathsf{F}}, T_{\\mathsf{state}}, T_{\\mathsf{history}})</span> and <span class="math">\\mathsf{cm}</span> as <span class="math">(\\mathsf{rh}_{\\mathsf{state}}, \\mathsf{rh}_{\\mathsf{history}})</span>. Check that:</li>

      <li><span class="math">\\mathsf{vS.VerifyCM}(S, \\mathsf{cm}) = 1</span>;</li>

      <li><span class="math">\\mathsf{IVC.Verify}(\\mathsf{vk}_{\\Pi}, (t, \\mathsf{cm}), \\pi_{\\mathsf{F}}) = 1</span>;</li>

      <li>the state tree <span class="math">T_{\\mathrm{state}}</span> is well-formed (MT.Validate <span class="math">(pp_{MT}, T_{\\mathrm{state}}) = 1</span>);</li>

      <li>the state tree <span class="math">T_{\\mathrm{state}}</span> has root <span class="math">\\mathsf{rh}_{\\mathrm{state}}</span> (<span class="math">\\mathsf{rh}_{\\mathrm{state}} = \\mathsf{MT.Root}^{T_{\\mathrm{state}}}(\\mathsf{pp}_{\\mathsf{MT}})</span>);</li>

      <li>the history tree <span class="math">T_{\\mathrm{history}}</span> is well-formed (MT.Validate <span class="math">(pp_{MT}, T_{\\mathrm{history}}) = 1</span>);</li>

      <li>the history tree <span class="math">T_{\\mathrm{history}}</span> has root <span class="math">\\mathsf{rh}_{\\mathrm{history}}</span> (<span class="math">\\mathsf{rh}_{\\mathrm{history}} = \\mathsf{MT.Root}^{T_{\\mathrm{history}}}(\\mathsf{pp}_{\\mathsf{MT}})</span>).</li>

    </ul>

    <p class="text-gray-300">Construct and output the tuple <span class="math">\\mathsf{vF} = (\\mathsf{Run},\\mathsf{Verify})</span> as defined below. Note that <span class="math">\\mathsf{vF.Run}</span> hardcodes <span class="math">(\\mathsf{pk}_{\\Pi}, \\mathsf{pp}_{\\mathsf{MT}}, F)</span>, and <span class="math">\\mathsf{vF.Verify}</span> hardcodes <span class="math">\\mathsf{vk}_{\\Pi}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{vF.Run}^{S,A}(\\mathsf{tx}) \\to (y, \\Delta)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate <span class="math">(y, \\Delta_S) = F^S(\\mathrm{tx})</span>, obtaining read queries <span class="math">[raddr_i]_1^N</span> to <span class="math">S</span> and the corresponding read answers <span class="math">[rdata_i]_1^N</span>; let <span class="math">\\mathrm{trans}</span> denote the execution transcript of <span class="math">F</span>. Parse <span class="math">\\Delta_S</span> as <span class="math">([\\mathsf{waddr}_i]_1^M, [\\mathsf{wdata}_i]_1^M)</span>.</li>

    </ul>

    <p class="text-gray-300">36</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize the update to the auxiliary state <span class="math">\\Delta_A := \\bot</span>.</li>

      <li>For the base case (<span class="math">A = \\bot</span>):</li>

      <li>set <span class="math">t^{\\mathrm{old}} := 0</span>, <span class="math">\\mathsf{cm}^{\\mathrm{old}} := \\bot</span>, <span class="math">z^{\\mathrm{old}} := \\bot</span>, <span class="math">\\pi_{\\mathsf{F}}^{\\mathrm{old}} := \\bot</span>, <span class="math">\\pi_{\\mathrm{read}} := \\bot</span>, and <span class="math">\\pi_{\\mathrm{insert}} := \\bot</span>;</li>

      <li>add to <span class="math">\\Delta_A</span> the creation of an empty state tree <span class="math">T_{\\mathrm{state}} := \\mathsf{MT.New}(\\mathsf{pp}_{\\mathsf{MT}})</span>;</li>

      <li>add to <span class="math">\\Delta_A</span> the creation of an empty history tree <span class="math">T_{\\mathrm{history}} := \\mathsf{MT.New}(\\mathsf{pp}_{\\mathsf{MT}})</span>, and set <span class="math">\\mathsf{rh}_{\\mathrm{history}}^{\\mathrm{new}} := \\mathsf{MT.Root}^{T_{\\mathrm{history}}}(\\mathsf{pp}_{\\mathsf{MT}})</span>.</li>

      <li>Otherwise (<span class="math">A \\neq \\bot</span>):</li>

      <li>retrieve <span class="math">(t^{\\mathrm{old}}, \\mathsf{cm}^{\\mathrm{old}}, \\pi_{\\mathsf{F}}^{\\mathrm{old}})</span> from the auxiliary state <span class="math">A</span>;</li>

      <li>compute <span class="math">\\pi_{\\mathrm{read}} := \\mathsf{MT.Lookup}^{T_{\\mathrm{state}}}(\\mathsf{pp}_{\\mathsf{MT}}, [\\mathsf{raddr}_i]_1^N)</span>;</li>

      <li>compute <span class="math">(\\mathsf{rh}_{\\mathrm{history}}^{\\mathrm{new}}, \\Delta_T^{\\mathrm{history}}, \\pi_{\\mathrm{insert}}) := \\mathsf{MT.Modify}^{T_{\\mathrm{history}}}(\\mathsf{pp}_{\\mathsf{MT}}, t^{\\mathrm{old}}, \\mathsf{cm}^{\\mathrm{old}})</span>, and add <span class="math">\\Delta_T^{\\mathrm{history}}</span> to <span class="math">\\Delta_A</span>;</li>

      <li>set <span class="math">z^{\\mathrm{old}} := (t^{\\mathrm{old}}, \\mathsf{cm}^{\\mathrm{old}})</span>.</li>

      <li>Compute <span class="math">(\\mathsf{rh}_{\\mathrm{state}}^{\\mathrm{new}}, \\Delta_T^{\\mathrm{state}}, \\pi_{\\mathrm{write}}) := \\mathsf{MT.Modify}^{T_{\\mathrm{state}}}(\\mathsf{pp}_{\\mathsf{MT}}, [\\mathsf{waddr}_i]_1^M, [\\mathsf{wdata}_i]_1^M)</span>, and add <span class="math">\\Delta_T^{\\mathrm{state}}</span> to <span class="math">\\Delta_A</span>.</li>

      <li>Set the new state index <span class="math">t^{\\mathrm{new}} := t^{\\mathrm{old}} + 1</span> and new state commitment <span class="math">\\mathsf{cm}^{\\mathrm{new}} := (\\mathsf{rh}_{\\mathrm{state}}^{\\mathrm{new}}, \\mathsf{rh}_{\\mathrm{history}}^{\\mathrm{new}})</span>.</li>

      <li>Set the new message <span class="math">z^{\\mathrm{new}} := (t^{\\mathrm{new}}, \\mathsf{cm}^{\\mathrm{new}})</span>.</li>

      <li>Set the local data <span class="math">w := (\\text{trans}, [\\text{raddr}_i]_1^N, [\\text{rdata}_i]_1^N, \\pi_{\\text{read}}, \\text{tx}, [\\text{waddr}_i]_1^M, [\\text{wdata}_i]_1^M, \\pi_{\\text{write}}, \\pi_{\\text{insert}})</span>.</li>

      <li>Compute the IVC proof <span class="math">\\pi_{\\mathsf{F}}^{\\mathrm{new}} := \\mathsf{IVC.Prove}(\\mathsf{pk}_{\\mathsf{II}}, z^{\\mathrm{new}}, w, z^{\\mathrm{old}}, \\pi_{\\mathsf{F}}^{\\mathrm{old}})</span>.</li>

      <li>Add to <span class="math">\\Delta_A</span> the change of the metadata to <span class="math">(t^{\\mathrm{new}}, \\mathsf{cm}^{\\mathrm{new}}, \\pi_{\\mathsf{F}}^{\\mathrm{new}})</span>.</li>

      <li>Output <span class="math">(y, \\Delta)</span> where <span class="math">\\Delta := (\\Delta_S, \\Delta_A)</span> is the state update to <span class="math">(S, A)</span>.</li>

      <li><span class="math">\\mathsf{vF.Verify}(t, \\mathsf{cm}, \\pi_{\\mathsf{F}}) \\to b</span>. If <span class="math">t = 0</span>, <span class="math">\\mathsf{cm} = \\bot</span>, <span class="math">\\pi_{\\mathsf{F}} = \\bot</span>, output 1. Else output <span class="math">\\mathsf{IVC.Verify}(\\mathsf{vk}_{\\mathsf{II}},(t, \\mathsf{cm}), \\pi_{\\mathsf{F}})</span>.</li>

    </ul>

    <h2 id="sec-39" class="text-2xl font-bold">C.5 Construction of MakeC</h2>

    <p class="text-gray-300">MakeC(pp, C) → vC. Parse pp as <span class="math">(\\mathsf{pp}_{\\mathsf{MT}}, \\mathsf{pp}_{\\mathsf{IVC}}, \\mathsf{pp}_{\\mathsf{ARK}})</span>. Create the NP relation <span class="math">R</span> as defined below.</p>

    <p class="text-gray-300">The NP relation <span class="math">R</span>, which depends on <span class="math">(\\mathsf{pp}_{\\mathsf{MT}}, C)</span>, considers instances of the form <span class="math">\\mathbf{x} = (\\mathsf{cm}, x, y)</span> and witnesses of the form <span class="math">\\mathbf{w} = (\\text{trans}, [\\text{raddr}_i]_1^N, [\\text{rdata}_i]_1^N, \\pi_{\\text{read}})</span>. A pair <span class="math">(\\mathbf{x}, \\mathbf{w})</span> is in the relation <span class="math">R</span> if the following conditions hold: (a) trans is a valid execution transcript of <span class="math">C</span> with input <span class="math">x</span>, read queries <span class="math">[\\text{raddr}_i]_1^N</span>, read answers <span class="math">[\\text{rdata}_i]_1^N</span>, and output <span class="math">y</span>; (b) if <span class="math">\\mathsf{cm} = \\bot</span>, check that <span class="math">\\mathsf{rdata} = \\bot</span>; (c) if <span class="math">\\mathsf{cm} \\neq \\bot</span>, parse <span class="math">\\mathsf{cm}</span> as <span class="math">(\\mathsf{rh}_{\\text{state}}, \\mathsf{rh}_{\\text{history}})</span> and check that MT.VerifyLookup(ppMT, rhstate, [raddr_i]_1^N, [rdata_i]_1^N, πread) = 1.</p>

    <p class="text-gray-300">Derive the ARK key pair <span class="math">(\\mathsf{pk}_R, \\mathsf{vk}_R) \\gets \\mathsf{ARK.KeyGen}(\\mathsf{pp}_{\\mathsf{ARK}}, R)</span>. Construct and output the tuple <span class="math">\\mathsf{vC} = (\\mathsf{Run}, \\mathsf{Verify})</span> as defined below. Note that vC.Run hardcodes <span class="math">(\\mathsf{pp}_{\\mathsf{MT}}, C, \\mathsf{pk}_R)</span> and vC.Verify hardcodes <span class="math">\\mathsf{vk}_R</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>vC.Run<span class="math">^{S,A}(x) \\to (y, \\pi_C)</span>.</li>

      <li>Simulate the client function as <span class="math">y = C^S(x)</span>, obtaining the list of read queries <span class="math">[\\mathsf{raddr}_i]_1^N</span> to the state <span class="math">S</span> and the corresponding read answers <span class="math">[\\mathsf{rdata}_i]_1^N</span>. Also, denote by <span class="math">\\mathsf{trans}</span> the execution transcript of <span class="math">C</span>.</li>

      <li>Retrieve the information <span class="math">(t, \\mathsf{cm}, \\pi_{\\mathsf{F}})</span> from the auxiliary state <span class="math">A</span>, and parse <span class="math">\\mathsf{cm}</span> as <span class="math">(\\mathsf{rh}_{\\mathrm{state}}, \\mathsf{rh}_{\\mathrm{history}})</span>.</li>

      <li>If <span class="math">t = 0</span>, set <span class="math">\\pi_{\\mathrm{read}} := \\bot</span>.</li>

      <li>Otherwise, compute <span class="math">\\pi_{\\mathrm{read}} := \\mathsf{MT.Lookup}^{T_{\\mathrm{state}}}(\\mathsf{pp}_{\\mathsf{MT}}, [\\mathsf{raddr}_i]_1^N)</span> where <span class="math">T_{\\mathrm{state}}</span> is the state tree in <span class="math">A</span>.</li>

      <li>Set the NP instance <span class="math">\\mathbf{x} := (\\mathsf{cm}, x, y)</span> and the NP witness <span class="math">\\mathbf{w} := (\\text{trans}, [\\text{raddr}_i]_1^N, [\\text{rdata}_i]_1^N, \\pi_{\\text{read}})</span>.</li>

      <li>Output <span class="math">(y, \\pi_C)</span> where the ARK proof is <span class="math">\\pi_C := \\mathsf{ARK.Prove}(\\mathsf{pk}_R, \\mathbf{x}, \\mathbf{w})</span>.</li>

      <li>vC.Verify(cm, x, y, <span class="math">\\pi_C</span>): <span class="math">= \\mathsf{ARK.Verify}(\\mathsf{vk}_R, (\\mathsf{cm}, x, y), \\pi_C)</span>.</li>

    </ul>

    <p class="text-gray-300">C.6 Construction of History</p>

    <p class="text-gray-300">History. Prove <span class="math">S, A</span> (pp, t) → πH. If t = 0, output πH := ⊥. Otherwise, parse pp as (ppMT, ppIVC, ppARK) and retrieve the state commitment cm = (rh_state, rh_history) from the auxiliary state A. Compute the proof for location t as πH := MT. Lookup <span class="math">T_{\\text{history}}</span> (ppMT, t) where T_history is the history tree in A. Output πH.</p>

    <p class="text-gray-300">History. Verify (pp, cm, t, cm_t, π_H) → b. If t = 0, cm_t = ⊥, π_H = ⊥, return 1. Otherwise, parse pp as (ppMT, ppIVC, ppARK), parse cm as (rh_state, rh_history), and check that MT. Verify Lookup (ppMT, rh_history, t, cm_t, π_H) = 1.</p>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300">D Security</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem D.1.</h6>

    <p class="text-gray-300">Our construction of an IVLS scheme in Appendix C satisfies the correctness and security properties described in Section 3 (assuming that the building blocks IVC, ARK, and MT that we use in our construction meet standard notions of correctness and security).</p>

    <p class="text-gray-300">This section is dedicated to proving the above theorem, and is organized to mirror the desired correctness and security properties in Section 3. For convenience we include, in the relevant places, formal statements of the properties of IVC and ARK that we use. We separately provide in Appendix D.5 the (tedious but precise) list of properties of MT that we use.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">D.1 Security of vS</h3>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma D.2.</h6>

    <p class="text-gray-300">The construction of VerifyCM in Appendix C.4 satisfies the binding property (Definition 3.3).</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\mathcal{A}</span> is an adversary that, given as input <span class="math">\\mathsf{pp}=(\\mathsf{pp}_{\\mathsf{MT}},\\mathsf{pp}_{\\mathsf{IVC}},\\mathsf{pp}_{\\mathsf{ARK}})\\in\\mathsf{Setup}(1^{\\lambda})</span>, outputs a transition function <span class="math">F</span>, state commitment <span class="math">\\mathsf{cm}</span>, and two states <span class="math">S_{1}</span> and <span class="math">S_{2}</span> such that <span class="math">\\mathsf{vS.VerifyCM}(S_{1},\\mathsf{cm})=1</span> and <span class="math">\\mathsf{vS.VerifyCM}(S_{2},\\mathsf{cm})=1</span> where <span class="math">\\mathsf{vS}</span> is produced by <span class="math">\\mathsf{MakeSF}(\\mathsf{pp},F)</span>. We argue that <span class="math">S_{1}=S_{2}</span> except with negligible probability. We assume that <span class="math">\\mathsf{cm}\\neq\\bot</span>; otherwise we are done.</p>

    <p class="text-gray-300">We use <span class="math">\\mathcal{A}</span> to construct an adversary <span class="math">\\mathcal{A}^{\\prime}</span> that breaks the binding property of root hashes (Definition D.18). On input <span class="math">\\mathsf{pp}_{\\mathsf{MT}}\\in\\mathsf{MT.Setup}(1^{\\lambda})</span>, <span class="math">\\mathcal{A}^{\\prime}</span> works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\mathsf{pp}_{\\mathsf{IVC}}\\leftarrow\\mathsf{IVC.Setup}(1^{\\lambda})</span> and <span class="math">\\mathsf{pp}_{\\mathsf{ARK}}\\leftarrow\\mathsf{ARK.Setup}(1^{\\lambda})</span>.</li>

      <li>Assemble <span class="math">\\mathsf{pp}:=(\\mathsf{pp}_{\\mathsf{MT}},\\mathsf{pp}_{\\mathsf{IVC}},\\mathsf{pp}_{\\mathsf{ARK}})</span>.</li>

      <li>Compute <span class="math">(F,S_{1},S_{2},\\mathsf{cm}):=\\mathcal{A}(\\mathsf{pp})</span>.</li>

      <li>Construct Merkle trees <span class="math">T_{1}</span> from <span class="math">S_{1}</span> and <span class="math">T_{2}</span> from <span class="math">S_{2}</span>.</li>

      <li>Compute <span class="math">\\mathsf{rh}\\leftarrow\\mathsf{MT.Root}^{T_{1}}(\\mathsf{pp}_{\\mathsf{MT}})</span>.</li>

      <li>Output <span class="math">(T_{1},T_{2},\\mathsf{rh})</span>.</li>

    </ul>

    <p class="text-gray-300">Note that if the two states <span class="math">S_{1}</span> and <span class="math">S_{2}</span> are distinct, then so are the corresponding (valid) Merkle trees <span class="math">T_{1}</span> and <span class="math">T_{2}</span>. Recall that <span class="math">\\mathsf{cm}</span> is a pair of root hashes <span class="math">(\\mathsf{rh}_{\\mathsf{state}},\\mathsf{rh}_{\\mathsf{history}})</span>. Note that <span class="math">\\mathsf{vS.VerifyCM}(S_{1},\\mathsf{cm})=1</span> implies that the Merkle tree on <span class="math">S_{1}</span> has root hash <span class="math">\\mathsf{rh}_{\\mathsf{state}}</span>, and similarly the Merkle tree on <span class="math">S_{2}</span> has the same root hash <span class="math">\\mathsf{rh}_{\\mathsf{state}}</span>. This means that whenever <span class="math">\\mathcal{A}</span> outputs distinct states with the same commitment, <span class="math">\\mathcal{A}^{\\prime}</span> outputs distinct Merkle trees with the same root hash, which can happen with at most negligible probability. ∎</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">D.2 Security of vF</h3>

    <p class="text-gray-300">The construction of vF appears in Appendix C.4, and its two main subroutines are MT (a Merkle tree) and IVC (incrementally verifiable computation). We state the properties of IVC that we use (omitting the tuple prefix IVC), and then prove the security properties of vF. We remark that the formalization of IVC that we use follows as a straightforward special case of definitions of proof-carrying data <em>[x10, x1]</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An IVC predicate <span class="math">\\Pi</span> is an algorithm that takes as input the new step’s output <span class="math">z^{\\mathsf{new}}</span>, the new step’s auxiliary input <span class="math">w</span>, and the previous step’s output <span class="math">z^{\\mathsf{old}}</span> (<span class="math">\\bot</span> if the new step is the first step) as input, and outputs <span class="math">1</span> or <span class="math">0</span>.</li>

      <li>An IVC transcript is a tuple <span class="math">\\mathsf{T}=([w_{i}]_{1}^{n},[z_{i}]_{1}^{n})</span> where <span class="math">w_{i}</span> is the auxiliary input to the <span class="math">i</span>-th step and <span class="math">z_{i}</span> is the output after the <span class="math">i</span>-th step. The output of <span class="math">\\mathsf{T}</span>, denoted by <span class="math">\\mathsf{out}(\\mathsf{T})</span>, is <span class="math">z_{n}</span>. We say that <span class="math">\\mathsf{T}=([w_{i}]_{1}^{n},[z_{i}]_{1}^{n})</span> is <span class="math">\\Pi</span>-compliant, denoted by <span class="math">\\Pi(\\mathsf{T})=1</span>, if <span class="math">\\Pi(z_{i},w_{i},z_{i-1})=1</span> for every <span class="math">i\\in[n]</span> with <span class="math">z_{0}:=\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">Definition D.3 (completeness of IVC). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (z ^ {\\mathrm {o l d}} = \\bot \\lor \\mathsf {V e r i f y} (\\mathsf {v k} _ {\\Pi}, z ^ {\\mathrm {o l d}}, \\pi^ {\\mathrm {o l d}}) = 1) &amp;amp; \\mathsf {p p} _ {\\mathsf {I V C}} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\Pi (z ^ {\\mathsf {n e w}}, w, z ^ {\\mathsf {o l d}}) = 1 &amp;amp; (\\Pi , z ^ {\\mathsf {n e w}}, w, z ^ {\\mathsf {o l d}}, \\pi^ {\\mathsf {o l d}}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {I V C}}) \\\\ \\downarrow &amp;amp; (\\mathsf {p k} _ {\\Pi}, \\mathsf {v k} _ {\\Pi}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {p p} _ {\\mathsf {I V C}}, \\Pi) \\\\ \\mathsf {V e r i f y} (\\mathsf {v k} _ {\\Pi}, z ^ {\\mathsf {n e w}}, \\pi^ {\\mathsf {n e w}}) = 1 &amp;amp; \\pi^ {\\mathsf {n e w}} \\leftarrow \\mathsf {P r o v e} (\\mathsf {p k} _ {\\Pi}, z ^ {\\mathsf {n e w}}, w, z ^ {\\mathsf {o l d}}, \\pi^ {\\mathsf {o l d}}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition D.4 (knowledge soundness of IVC). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span> , there exists a polynomial-size extractor  <span class="math">\\mathcal{E}</span>  such that for every sufficiently large security parameter  <span class="math">\\lambda</span>  and every auxiliary input  <span class="math">\\mathrm{aux} \\in \\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} (\\mathsf {v k} _ {\\Pi}, z, \\pi) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {I V C}} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}) \\\\ \\downarrow &amp;amp; (\\Pi , z, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {I V C}}, \\mathsf {a u x}) \\\\ \\operatorname {o u t} (\\mathsf {T}) = z &amp;amp; \\mathsf {T} \\leftarrow \\mathcal {E} (\\mathsf {p p} _ {\\mathsf {I V C}}, \\mathsf {a u x}) \\\\ \\Pi (\\mathsf {T}) = 1 &amp;amp; (\\mathsf {p k} _ {\\Pi}, \\mathsf {v k} _ {\\Pi}) \\leftarrow \\operatorname {K e y G e n} (\\mathsf {p p} _ {\\mathsf {I V C}}, \\Pi) \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">Lemma D.5. The construction of vF in Appendix C.4 satisfies the completeness property (Definition 3.4).</p>

    <p class="text-gray-300">Proof. Our construction of vF.Run straightforwardly ensures that  <span class="math">(y, \\Delta_S) = F^S(\\mathrm{tx})</span>  and  <span class="math">t&#x27; = t + 1</span> . We are then only left to argue that vS.VerifyAll  <span class="math">(S, A) = 1</span>  implies vS.VerifyAll  <span class="math">(S&#x27;, A&#x27;) = 1</span> , where  <span class="math">(S&#x27;, A&#x27;)</span>  are the updated states. The discussion below assumes familiarity with our construction of vS.VerifyAll. It suffices to argue the following points: (a) the IVC proof in  <span class="math">A&#x27;</span>  is valid; (b) the Merkle trees in  <span class="math">A&#x27;</span>  are well-formed; (c) the commitment in  <span class="math">A&#x27;</span>  contains root hashes of the Merkle trees; (d) the state Merkle tree is over  <span class="math">S&#x27;</span> .</p>

    <p class="text-gray-300">(a) IVC proof is valid. We argue that IVC.Verify(vkII, (t new, cm new), π new) = 1 where (t new, cm new, π new) are in the new auxiliary state  <span class="math">A&#x27;</span> . Observe that the condition vS.VerifyAll(S, A) = 1 implies that  <span class="math">S = A = \\bot</span>  or IVC.Verify(vkII, (t old, cm old), π old) = 1 where (t old, cm old, π old) are in  <span class="math">A</span> . Therefore, by the completeness property of IVC (Definition D.3), we are left to argue that  <span class="math">\\Pi((t \\text{ new}, cm \\text{ new}), w, z^{\\text{old}}) = 1</span>  where  <span class="math">z^{\\text{old}} = \\bot</span>  if  <span class="math">A = \\bot</span>  or  <span class="math">z^{\\text{old}} = (t \\text{ old}, cm \\text{ old})</span>  if  <span class="math">A \\neq \\bot</span> , for the local data  <span class="math">w = (\\text{trans}, [\\text{raddr}_i]_1^N, [\\text{rdata}_i]_1^N, \\pi_{\\text{read}}, tx, [\\text{waddr}_i]_1^M, [\\text{wdata}_i]_1^M, \\pi_{\\text{write}}, \\pi_{\\text{insert}})</span>  supplied by vF.Run. We discuss these two cases separately.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the base case  <span class="math">(z^{\\mathrm{old}} = \\bot)</span> ,  <span class="math">\\Pi</span>  is satisfied because vF.Run ensures the following conditions:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(index is correct)  <span class="math">t^{\\mathrm{new}} = 1</span> .</li>

      <li>(execution is correct) trans is a valid transcript of  <span class="math">F</span>  over an empty state.</li>

      <li>(reads are correct)  <span class="math">\\left[\\mathrm{rdata}_i\\right]_1^N = \\bot</span> .</li>

      <li>(writes are performed)  <span class="math">\\pi_{\\mathrm{write}}</span>  proves that  <span class="math">T_{\\mathrm{state}}</span>  is updated according to trans.</li>

      <li>(commitment is correct)  <span class="math">\\mathsf{cm}^{\\mathrm{new}}</span>  matches the new Merkle trees.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise  <span class="math">(z^{\\mathrm{old}} \\neq \\bot)</span> ,  <span class="math">\\Pi</span>  is satisfied because vF.Run ensures the following conditions:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(index is correct)  <span class="math">t^{\\mathrm{new}} = t^{\\mathrm{old}} + 1</span> .</li>

      <li>(execution is correct) trans is a valid transcript of  <span class="math">F</span>  over  <span class="math">([\\mathrm{raddr}_i]_1^N, [\\mathrm{rdata}_i]_1^N)</span> .</li>

      <li>(reads are correct)  <span class="math">\\pi_{\\mathrm{read}}</span>  proves that  <span class="math">([\\mathrm{raddr}_i]_1^N, [\\mathrm{rdata}_i]_1^N)</span>  matches the state committed by  <span class="math">\\mathsf{cm}^{\\mathrm{old}}</span> .</li>

      <li>(writes are performed)  <span class="math">\\pi_{\\mathrm{write}}</span>  proves that  <span class="math">T_{\\mathrm{state}}</span>  is updated according to trans.</li>

      <li>(commitment is added to history)  <span class="math">\\pi_{\\mathrm{insert}}</span>  proves that  <span class="math">T_{\\mathrm{history}}</span>  now has  <span class="math">\\mathsf{cm}^{\\mathrm{old}}</span>  at position  <span class="math">t^{\\mathrm{old}}</span> .</li>

      <li>(commitment is correct)  <span class="math">\\mathsf{cm}^{\\mathrm{new}}</span>  matches the updated Merkle trees.</li>

    </ul>

    <p class="text-gray-300">(b) Merkle trees are well-formed. Completeness properties of Merkle trees (Definitions D.13 and D.15) ensure that changes from the old state  <span class="math">S</span>  to the new state  <span class="math">S&#x27;</span>  have been applied correctly to the state tree</p>

    <p class="text-gray-300">in <span class="math">T_{\\text{state}}</span> in <span class="math">A</span>, and also that the insertion of the commitment to the history tree <span class="math">T_{\\text{history}}</span> has been applied correctly.</p>

    <p class="text-gray-300">(c) State commitment contains correct root hashes. Our construction of vF.Run stores the new commitment <span class="math">\\mathsf{cm}^{\\text{new}}</span> in the new auxiliary state <span class="math">A&#x27;</span>, so this condition holds.</p>

    <p class="text-gray-300">(d) New state Merkle tree is over new state. The changes to the state <span class="math">S</span>, <span class="math">([\\mathsf{waddr}_i]_1^M, [\\mathsf{wdata}_i]_1^M)</span>, are converted into Merkle tree update <span class="math">\\Delta_T^{\\mathrm{state}}</span> applied to <span class="math">A</span>, so the new state Merkle tree is over the new state.</p>

    <p class="text-gray-300">Lemma D.6. The construction of vF in Appendix C.4 satisfies the knowledge soundness property (Definition 3.5).</p>

    <p class="text-gray-300">Proof. Let <span class="math">\\mathcal{A}</span> be an adversary against the knowledge soundness of vF (Definition 3.5). This means that on input public parameters <span class="math">\\mathsf{pp} \\in \\mathsf{Setup}(1^{\\lambda})</span>, <span class="math">\\mathcal{A}</span> outputs a tuple <span class="math">(F, t, \\mathsf{cm}, \\pi_{\\mathsf{F}})</span>. We assume that <span class="math">t &amp;gt; 0</span>; otherwise there is nothing to prove.</p>

    <p class="text-gray-300">We construct an adversary <span class="math">\\mathcal{A}&#x27;</span> against the knowledge soundness of IVC (Definition D.4), using an auxiliary input aux that is interpreted as <span class="math">(\\mathsf{pp}_{\\mathsf{MT}}, \\mathsf{pp}_{\\mathsf{ARK}})</span>, as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}&#x27;</span> receives as input public parameters <span class="math">\\mathsf{pp}_{\\mathsf{IVC}} \\in \\mathsf{IVC.Setup}(1^{\\lambda})</span> and the auxiliary input aux, then it works as follows: (1) parse aux as <span class="math">(\\mathsf{pp}_{\\mathsf{MT}}, \\mathsf{pp}_{\\mathsf{ARK}})</span> and assemble <span class="math">\\mathsf{pp} = (\\mathsf{pp}_{\\mathsf{MT}}, \\mathsf{pp}_{\\mathsf{IVC}}, \\mathsf{pp}_{\\mathsf{ARK}})</span>; (2) compute <span class="math">(F, t, \\mathsf{cm}, \\pi_{\\mathsf{F}}) := \\mathcal{A}(\\mathsf{pp})</span>; (3) use <span class="math">(\\mathsf{pp}_{\\mathsf{MT}}, F)</span> to create the IVC predicate <span class="math">\\Pi</span> as in Appendix C.4; (4) create the IVC message <span class="math">z := (t, \\mathsf{cm})</span>; (5) create the IVC proof <span class="math">\\pi := \\pi_{\\mathsf{F}}</span>; (6) output <span class="math">(\\Pi, z, \\pi)</span>.</p>

    <p class="text-gray-300">Recall that, for <span class="math">t &amp;gt; 0</span>, vF.Verify <span class="math">(t,\\mathsf{cm},\\pi_{\\mathsf{F}}) = \\mathsf{IVC.Verify}(\\mathsf{vk}_{\\Pi},(t,\\mathsf{cm}),\\pi_{\\mathsf{F}})</span> where <span class="math">\\mathsf{vk}_{\\Pi}</span> is hardcoded in vF. This means that <span class="math">\\mathcal{A}&#x27;</span> produces an accepting output whenever <span class="math">\\mathcal{A}</span> does.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}&#x27;</span> be the extractor for <span class="math">\\mathcal{A}&#x27;</span> guaranteed by the knowledge soundness property of IVC (Definition D.4). We construct an extractor <span class="math">\\mathcal{E}</span> for <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span> receives as input public parameters <span class="math">\\mathsf{pp} \\in \\mathsf{Setup}(1^{\\lambda})</span> and then works as follows: (1) parse <span class="math">\\mathsf{pp} = (\\mathsf{pp}_{\\mathsf{MT}}, \\mathsf{pp}_{\\mathsf{IVC}}, \\mathsf{pp}_{\\mathsf{ARK}})</span>; (2) set the auxiliary input <span class="math">\\mathsf{aux} := (\\mathsf{pp}_{\\mathsf{MT}}, \\mathsf{pp}_{\\mathsf{ARK}})</span>; (3) compute the IVC transcript <span class="math">\\mathsf{T} = ([w_i]_1^n, [z_i]_1^n) := \\mathcal{E}&#x27;(\\mathsf{pp}_{\\mathsf{IVC}}, \\mathsf{aux})</span>; (4) for each <span class="math">i</span>, find in the local data <span class="math">w_i</span> a transaction <span class="math">\\mathsf{tx}_i</span> (in the execution transcript of <span class="math">F</span> contained in <span class="math">w_i</span>); (5) output all transactions <span class="math">[\\mathsf{tx}_i]_1^n</span>.</p>

    <p class="text-gray-300">We are left to argue that the extractor <span class="math">\\mathcal{E}</span> works for <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">The knowledge soundness property of IVC tells us that the IVC transcript output by <span class="math">\\mathcal{E}&#x27;</span> is <span class="math">\\Pi</span>-compliant and ends in the message <span class="math">z</span>, whenever the output <span class="math">(\\Pi, z, \\pi)</span> of <span class="math">\\mathcal{A}&#x27;</span> is accepting. This, together with the binding properties of Merkle trees, tells us that the state <span class="math">S := F(\\mathsf{tx}_1, \\ldots, \\mathsf{tx}_n)</span> is such that <span class="math">\\mathsf{vS.VerifyCM}(S, \\mathsf{cm}) = 1</span>, whenever the output <span class="math">(F, t, \\mathsf{cm}, \\pi_{\\mathsf{F}})</span> of <span class="math">\\mathcal{A}</span> is accepting.</p>

    <p class="text-gray-300">D.3 Security of vC</p>

    <p class="text-gray-300">The construction of vC appears in Appendix C.5, and its two main subroutines are MT (a Merkle tree) and ARK (a non-interactive argument of knowledge). We state the properties of ARK that we use (omitting the tuple prefix ARK), and then prove the security properties of vC.</p>

    <p class="text-gray-300">Definition D.7 (completeness of ARK). For every polynomial-size adversary <span class="math">\\mathcal{A}</span> and security parameter <span class="math">\\lambda</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c} (\\Xi , \\mathbb {w}) \\in R \\\\ \\downarrow \\\\ \\text {V e r i f y} (\\mathsf {v k} _ {R}, \\Xi , \\pi) = 1 \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {p p} _ {\\mathsf {A R K}} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ (R, \\Xi , \\mathbb {w}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {A R K}}) \\\\ (\\mathsf {p k} _ {R}, \\mathsf {v k} _ {R}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {p p} _ {\\mathsf {A R K}}, R) \\\\ \\pi \\leftarrow \\mathsf {P r o v e} (\\mathsf {p k} _ {R}, \\Xi , \\mathbb {w}) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition D.8 (knowledge soundness of ARK). For every polynomial-size adversary <span class="math">\\mathcal{A}</span> there exists a polynomial-size extractor <span class="math">\\mathcal{E}</span> such that for every sufficiently large security parameter <span class="math">\\lambda</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {V e r i f y} (\\mathsf {v k} _ {R}, \\Xi , \\pi) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {A R K}} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\downarrow &amp;amp; (R, \\Xi , \\pi) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {A R K}}) \\\\ (\\Xi , \\mathbb {w}) \\in R &amp;amp; \\mathbb {w} \\leftarrow \\mathcal {E} (\\mathsf {p p} _ {\\mathsf {A R K}}) \\\\ &amp;amp; (\\mathsf {p k} _ {R}, \\mathsf {v k} _ {R}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {p p} _ {\\mathsf {A R K}}, R) \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Lemma D.9. The construction of vC in Appendix C.5 satisfies the completeness property (Definition 3.6).</p>

    <p class="text-gray-300">Proof. First note that vC.Run produces the output <span class="math">y</span> by running <span class="math">C</span> on input <span class="math">x</span> with state <span class="math">S</span>, and so clearly the condition <span class="math">y = C^{S}(x)</span> holds. Next we argue that, if the auxiliary state <span class="math">A</span> is such that vS.VerifyAll <span class="math">(S, A) = 1</span>, then the proof <span class="math">\\pi_{\\mathbb{C}}</span> produced by vC.Run will be accepted by vC.Verify. Since the proof <span class="math">\\pi_{\\mathbb{C}}</span> is produced and validated using the prover and verifier of ARK, by the completeness of ARK (Definition D.7), it suffices to argue that the instance-witness pair constructed by vC.Run is in the NP relation <span class="math">R</span>.</p>

    <p class="text-gray-300">To see this, recall that <span class="math">R</span> checks that the witness <span class="math">\\mathbb{W}</span> for an instance <span class="math">\\Xi = (\\mathsf{cm}, x, y)</span> contains a valid execution transcript of a computation of <span class="math">C</span> on input <span class="math">x</span> leading to output <span class="math">y</span>, with read queries and read answers authenticated against the state root hash contained in the state commitment <span class="math">\\mathsf{cm} = (\\mathsf{rh}_{\\mathsf{state}}, \\mathsf{rh}_{\\mathsf{history}})</span> (if any). The condition vS.VerifyAll <span class="math">(S, A) = 1</span> in the completeness property ensures that <span class="math">T_{\\mathsf{state}}</span> in <span class="math">A</span> is a Merkle tree over the state <span class="math">S</span>, and <span class="math">\\mathsf{cm} = (\\mathsf{rh}_{\\mathsf{state}}, \\mathsf{rh}_{\\mathsf{history}})</span> in <span class="math">A</span> is such that <span class="math">\\mathsf{rh}_{\\mathsf{state}}</span> is the root of this Merkle tree. This means that the read queries and read answers are consistent with the state <span class="math">S</span>, and the Merkle tree lookup proof placed in the witness <span class="math">\\mathbb{W}</span> by vC.Run is valid (by the completeness of Merkle tree lookups, Definition D.14).</p>

    <p class="text-gray-300">Lemma D.10. The construction of vC in Appendix C.5 satisfies the soundness property (Definition 3.7).</p>

    <p class="text-gray-300">Proof. Suppose that an adversary outputs <span class="math">(S, A)</span> such that <span class="math">\\mathsf{vS.VerifyAll}(S, A) = 1</span> and also <span class="math">(x, y, \\pi_{\\mathbb{C}})</span> such that, for the state commitment <span class="math">\\mathsf{cm}</span> in <span class="math">A</span>, it holds that <span class="math">\\mathsf{vC.Verify}(\\mathsf{cm}, x, y, \\pi_{\\mathbb{C}}) = 1</span>. By construction, we know that the verifier of ARK accepts the instance <span class="math">\\Xi = (\\mathsf{cm}, x, y)</span> for the NP relation <span class="math">R</span>.</p>

    <p class="text-gray-300">By the knowledge soundness of ARK (Definition D.8), there exists a corresponding extractor that outputs a valid witness <span class="math">\\mathbb{W}</span> for <span class="math">\\Xi</span>, which contains a valid execution transcript of a computation of <span class="math">C</span> on input <span class="math">x</span> leading to output <span class="math">y</span>, with read queries and read answers authenticated against the state root hash contained in the state commitment <span class="math">\\mathsf{cm} = (\\mathsf{rh}_{\\mathsf{state}}, \\mathsf{rh}_{\\mathsf{history}})</span> (if any). But we know from VerifyAll <span class="math">(S, A)</span> that <span class="math">\\mathsf{rh}_{\\mathsf{state}}</span> is the root of a Merkle tree over the state <span class="math">S</span> and so, by the soundness of Merkle tree lookup proofs (Definition D.19), we know that the read queries and read answers are consistent with <span class="math">S</span>, and conclude that <span class="math">y = C^S(x)</span>.</p>

    <h2 id="sec-45" class="text-2xl font-bold">D.4 Security of History</h2>

    <p class="text-gray-300">Lemma D.11. The construction of History in Appendix C.6 satisfies the completeness property (Definition 3.8).</p>

    <p class="text-gray-300">Proof. Suppose that an adversary outputs <span class="math">(S, A)</span> such that <span class="math">\\mathsf{vS.VerifyAll}(S, A) = 1</span> and also transactions <span class="math">(\\mathsf{tx}_1, \\ldots, \\mathsf{tx}_n)</span>. Let <span class="math">t</span> be the state index and <span class="math">\\mathsf{cm}_t</span> the state commitment contained in the auxiliary state <span class="math">A</span>. The condition <span class="math">\\mathsf{vS.VerifyAll}(S, A) = 1</span> implies that the history Merkle tree <span class="math">T_{\\text{history}}</span> in <span class="math">A</span> is well-formed, and its root is stored in <span class="math">\\mathsf{cm}_t</span>.</p>

    <p class="text-gray-300">When <span class="math">\\mathsf{vF.Run}</span> is invoked to apply the first of these transactions, <span class="math">\\mathsf{cm}_t</span> will be placed at location <span class="math">t</span> in the history Merkle tree. When <span class="math">\\mathsf{vF.Run}</span> is invoked to apply each of the other transactions, the <span class="math">t</span>-th location in the</p>

    <p class="text-gray-300">history Merkle tree continues to store  <span class="math">\\mathsf{cm}_t</span>  (while subsequent locations in the history Merkle tree are allocated to store the subsequent commitments). This is due to the completeness of Merkle tree modifications (Definitions D.16 and D.17).</p>

    <p class="text-gray-300">This means that History.Verify will accept the history proof. Indeed, History.Prove produces a history proof  <span class="math">\\pi_{\\mathsf{H}}</span>  for a state index  <span class="math">t</span>  by authenticating  <span class="math">\\mathsf{cm}_t</span>  as being at location  <span class="math">t</span>  in the current history Merkle tree, and History.Verify validates a history proof by checking this authentication against the history root hash in the current state commitment. The completeness property of Merkle tree lookups (Definition D.14) implies that History.Verify accepts.</p>

    <p class="text-gray-300">Lemma D.12. The construction of History in Appendix C.6 satisfies the soundness property (Definition 3.9).</p>

    <p class="text-gray-300">Proof. Suppose that an adversary outputs a state commitment  <span class="math">\\mathsf{cm}</span> , state index  <span class="math">t</span> , two state commitments  <span class="math">\\mathsf{cm}_t</span>  and  <span class="math">\\mathsf{cm}_t&#x27;</span> , and two history proofs  <span class="math">\\pi_{\\mathsf{H}}</span>  and  <span class="math">\\pi_{\\mathsf{H}}&#x27;</span>  such that History.Verify  <span class="math">(\\mathsf{pp}, \\mathsf{cm}, t, \\mathsf{cm}_t, \\pi_{\\mathsf{H}}) = 1</span>  and History.Verify  <span class="math">(\\mathsf{pp}, \\mathsf{cm}, t, \\mathsf{cm}_t&#x27;, \\pi_{\\mathsf{H}}&#x27;) = 1</span> . We argue that, except with negligible probability,  <span class="math">\\mathsf{cm}_t = \\mathsf{cm}_t&#x27;</span> .</p>

    <p class="text-gray-300">If  <span class="math">t = 0</span> , then we know by construction of History. Verify that it is always the case that  <span class="math">\\mathsf{cm}_t = \\mathsf{cm}_t&#x27; = \\bot</span> .</p>

    <p class="text-gray-300">If  <span class="math">t &amp;gt; 0</span> , History. Verify parses cm as a tuple (rh_state, rh_history) and checks that the history proof authenticates the past state commitment as being at location  <span class="math">t</span>  of a Merkle tree with root rh_history. This means that the adversary has output proofs  <span class="math">\\pi_{\\mathsf{H}}</span>  and  <span class="math">\\pi_{\\mathsf{H}}&#x27;</span>  that respectively authenticate  <span class="math">\\mathsf{cm}_t</span>  and  <span class="math">\\mathsf{cm}_t&#x27;</span>  for the same location  <span class="math">t</span>  of a Merkle tree with the same root rh_history. By the binding property (Definition D.18) and soundness of lookups (Definition D.19) of Merkle trees, we know that  <span class="math">\\mathsf{cm}_t = \\mathsf{cm}_t&#x27;</span>  except with negligible probability.</p>

    <p class="text-gray-300">We formally state the properties of a Merkle tree that we use. We omit the tuple prefix MT in the text below.</p>

    <p class="text-gray-300">Definition D.13 (completeness for an empty tree). For every security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T) = 1 &amp;amp; \\begin{array}{c} \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\text {S e t u p} (1 ^ {\\lambda}) \\\\ T \\leftarrow \\text {N e w} (\\mathsf {p p} _ {\\mathsf {M T}}) \\end{array} \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition D.14 (completeness for a lookup). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\text {S e t u p} (1 ^ {\\lambda}) \\\\ (\\mathsf {a d d r} _ {i}, \\mathsf {d a t a} _ {i}) \\in T \\text {f o r} i \\in [ n ] &amp;amp; (T, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ \\downarrow &amp;amp; \\pi \\leftarrow \\mathsf {L o o k u p} ^ {T} (\\mathsf {p p} _ {\\mathsf {M T}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}) \\\\ b = 1 &amp;amp; \\mathsf {r h} \\leftarrow \\mathsf {R o o t} ^ {T} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ &amp;amp; b \\leftarrow \\mathsf {V e r i f y L o o k u p} (\\mathsf {p p} _ {\\mathsf {M T}}, \\mathsf {r h}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\pi) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition D.15 (completeness for a modification). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T ^ {\\text {o l d}}) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\text {S e t u p} (1 ^ {\\lambda}) \\\\ \\downarrow &amp;amp; (T ^ {\\text {o l d}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T ^ {\\text {n e w}}) = 1 &amp;amp; \\mathsf {r h} ^ {\\text {o l d}} \\leftarrow \\text {R o o t} ^ {T ^ {\\text {o l d}}} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ \\text {r h} ^ {\\text {n e w}} = \\text {R o o t} ^ {T ^ {\\text {n e w}}} (\\mathsf {p p} _ {\\mathsf {M T}}) &amp;amp; (\\mathsf {r h} ^ {\\text {n e w}}, \\Delta_ {T}, \\pi) \\leftarrow \\text {M o d i f y} ^ {T ^ {\\text {o l d}}} (\\mathsf {p p} _ {\\mathsf {M T}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}) \\\\ b = 1 &amp;amp; T ^ {\\text {n e w}} := T ^ {\\text {o l d}} + \\Delta_ {T} \\\\ &amp;amp; b \\leftarrow \\text {V e r i f y M o d i f y} (\\mathsf {p p} _ {\\mathsf {M T}}, \\mathsf {r h} ^ {\\text {o l d}}, \\mathsf {r h} ^ {\\text {n e w}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\pi) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition D.16 (completeness for a modification on the modified location). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T ^ {\\mathsf {o l d}}) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathsf {a d d r} _ {q} \\in [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n} &amp;amp; (T ^ {\\mathsf {o l d}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\mathsf {a d d r} _ {q}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ \\downarrow &amp;amp; (\\cdot , \\Delta_ {T}, \\cdot) \\leftarrow \\mathsf {M o d i f y} ^ {T ^ {\\mathsf {o l d}}} (\\mathsf {p p} _ {\\mathsf {M T}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}) \\\\ \\mathsf {a d d r} _ {q} \\text {i s u p - t o - d a t e i n} T ^ {\\mathsf {n e w}} &amp;amp; T ^ {\\mathsf {n e w}} := T ^ {\\mathsf {o l d}} + \\Delta_ {T} \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">where "addr <span class="math">_q</span>  is up-to-date" means that the highest index  <span class="math">1 \\leq j \\leq N</span>  such that  <span class="math">\\mathsf{addr}_j = \\mathsf{addr}_q</span>  in  <span class="math">[\\mathsf{addr}_i]_1^n</span>  satisfies that  <span class="math">\\mathsf{data}_j</span>  in  <span class="math">[\\mathsf{data}_i]_1^n</span>  matches the value at  <span class="math">\\mathsf{addr}_q</span>  in  <span class="math">T^{\\mathsf{new}}</span> .</p>

    <p class="text-gray-300">Definition D.17 (completeness for a modification on an unmodified location). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T ^ {\\mathsf {o l d}}) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathsf {a d d r} _ {q} \\notin [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n} &amp;amp; (T ^ {\\mathsf {o l d}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\mathsf {a d d r} _ {q}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ \\downarrow &amp;amp; (\\cdot , \\Delta_ {T}, \\cdot) \\leftarrow \\mathsf {M o d i f y} ^ {T ^ {\\mathsf {o l d}}} (\\mathsf {p p} _ {\\mathsf {M T}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}) \\\\ T ^ {\\mathsf {o l d}} \\text {a n d} T ^ {\\mathsf {n e w}} \\text {i s t h e s a m e a t a d d r} _ {q} &amp;amp; T ^ {\\mathsf {n e w}} := T ^ {\\mathsf {o l d}} + \\Delta_ {T} \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition D.18 (binding of root hash). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and sufficiently large security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T _ {1}) = 1 &amp;amp; \\\\ \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T _ {2}) = 1 &amp;amp; \\\\ \\text {R o o t} ^ {T _ {1}} (\\mathsf {p p} _ {\\mathsf {M T}}) = \\mathsf {r h} &amp;amp; \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\text {S e t u p} (1 ^ {\\lambda}) \\\\ \\text {R o o t} ^ {T _ {2}} (\\mathsf {p p} _ {\\mathsf {M T}}) = \\mathsf {r h} &amp;amp; (T _ {1}, T _ {2}, \\mathsf {r h}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ \\downarrow &amp;amp; \\\\ T _ {1} = T _ {2} &amp;amp; \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">Definition D.19 (soundness of a lookup). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and sufficiently large security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ b = 1 &amp;amp; (T, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ \\downarrow &amp;amp; \\mathsf {r h} \\leftarrow \\mathsf {R o o t} ^ {T} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ (\\mathsf {a d d r} _ {i}, \\mathsf {d a t a} _ {i}) \\in T \\text {f o r} i \\in [ n ] &amp;amp; b \\leftarrow \\mathsf {V e r i f y L o o k u p} (\\mathsf {p p} _ {\\mathsf {M T}}, \\mathsf {r h}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\pi) \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">Definition D.20 (soundness of a modification). For every polynomial-size adversary  <span class="math">\\mathcal{A}</span>  and sufficiently large security parameter  <span class="math">\\lambda</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T ^ {\\mathsf {o l d}}) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {M T}} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\text {V a l i d a t e} (\\mathsf {p p} _ {\\mathsf {M T}}, T ^ {\\mathsf {n e w}}) = 1 &amp;amp; (T ^ {\\mathsf {o l d}}, T ^ {\\mathsf {n e w}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ b = 1 &amp;amp; (\\mathsf {r h} ^ {\\mathsf {n e w}}, \\Delta_ {T}, \\cdot) \\leftarrow \\mathsf {M o d i f y} ^ {T ^ {\\mathsf {o l d}}} (\\mathsf {p p} _ {\\mathsf {M T}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}) \\\\ \\downarrow &amp;amp; \\mathsf {r h} ^ {\\mathsf {o l d}} \\leftarrow \\mathsf {R o o t} ^ {T ^ {\\mathsf {o l d}}} (\\mathsf {p p} _ {\\mathsf {M T}}) \\\\ T ^ {\\mathsf {n e w}} := T ^ {\\mathsf {o l d}} + \\Delta_ {T} &amp;amp; b \\leftarrow \\mathsf {V e r i f y M o d i f y} (\\mathsf {p p} _ {\\mathsf {M T}}, \\mathsf {r h} ^ {\\mathsf {o l d}}, \\mathsf {r h} ^ {\\mathsf {n e w}}, [ \\mathsf {a d d r} _ {i} ] _ {1} ^ {n}, [ \\mathsf {d a t a} _ {i} ] _ {1} ^ {n}, \\pi_ {\\mathsf {m o d i f y}}) \\end{array} \\right] \\\\ \\geq 1 - \\operatorname {n e g l} (\\lambda) . \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">This research was supported in part by a Google Faculty Research Award, the Ethereum Foundation, an NSF Graduate Research Fellowship, the NSF CISE Expeditions Award CCF-1730628, and gifts from Amazon Web Services, Ant Financial, Ericsson, Facebook, Futurewei, Google, Intel, Microsoft, Nvidia, Scotiabank, Splunk, and VMware.</p>

    <h2 id="sec-47" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. “Recursive composition and bootstrapping for SNARKs and proof-carrying data”. In: <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>. STOC ’13. 2013, pp. 111–120.</li>

      <li>[BCG21] Elette Boyle, Ran Cohen, and Aarushi Goel. “Breaking the <span class="math">O(\\sqrt{n})</span>-bits barrier: Balanced Byzantine agreement with polylog bits per-party”. In: <em>Proceedings of the 40th ACM Symposium on Principles of Distributed Computing</em>. PODC ’21. 2021, TBD.</li>

      <li>[BCGMMW20] Sean Bowe, Alessandro Chiesa, Matthew Green, Ian Miers, Pratyush Mishra, and Howard Wu. “Zexe: Enabling decentralized private computation”. In: <em>Proceedings of the 41st Symposium on Security and Privacy</em>. S&P ’20. 2020.</li>

      <li>[BCGTV15] Eli Ben-Sasson, Alessandro Chiesa, Matthew Green, Eran Tromer, and Madars Virza. “Secure sampling of public parameters for succinct zero knowledge proofs”. In: <em>Proceedings of the 36th IEEE Symposium on Security and Privacy</em>. S&P ’15. 2015, pp. 287–304.</li>

      <li>[BCLMS21] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. “Proof-carrying data without succinct arguments”. In: <em>Proceedings of the 41st Annual International Cryptology Conference</em>. CRYPTO ’21. 2021, TBD.</li>

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. “Proof-Carrying Data from Accumulation Schemes”. In: <em>Proceedings of the 18th Theory of Cryptography Conference</em>. TCC ’20. 2020, pp. 1–18.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable zero knowledge via cycles of elliptic curves”. In: <em>Proceedings of the 34th Annual International Cryptology Conference</em>. CRYPTO ’14. 2014, pp. 276–294.</li>

      <li>[BGG17] Sean Bowe, Ariel Gabizon, and Matthew Green. <em>A multi-party protocol for constructing the public parameters of the Pinocchio zk-SNARK</em>. Cryptology ePrint Archive, Report 2017/602. 2017.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. <em>Halo: Recursive proof composition without a trusted setup</em>. Cryptology ePrint Archive, Report 2019/1021. 2019.</li>

      <li>[BGKRZ18] Christian Badertscher, Peter Gaži, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas. “Ouroboros Genesis: Composable proof-of-stake blockchains with dynamic availability”. In: <em>Proceedings of the 25th Conference on Computer and Communications Security</em>. CCS ’18. 2018, pp. 913–930.</li>

      <li>[BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers. <em>Scalable multi-party computation for zk-SNARK parameters in the random beacon model</em>. Cryptology ePrint Archive, Report 2017/1050. 2017.</li>

      <li>[BKLZ20] Benedikt Bünz, Lucianna Kiffer, Loi Luu, and Mahdi Zamani. “FlyClient: Super-light clients for cryptocurrencies”. In: <em>Proceedings of the 41st IEEE Symposium on Security and Privacy</em>. S&P ’20. 2020.</li>

      <li>[BMRS20] Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. <em>Coda: Decentralized cryptocurrency at scale</em>. Cryptology ePrint Archive, Report 2020/352. 2020.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BOGW88] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. “Completeness theorems for non-cryptographic fault-tolerant distributed computation”. In: Proceedings of the 20th ACM Symposium on Theory of Computing. STOC ’88. 1988, pp. 1–10.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Ban+19] Shehar Bano, Alberto Sonnino, Mustafa Al-Bassam, Sarah Azouvi, Patrick McCorry, Sarah Meiklejohn, and George Danezis. “SoK: Consensus in the Age of Blockchains”. In: Proceedings of the 1st Conference on Advances in Financial Technologies. AFT ’19. 2019, pp. 183–198.</li>

      <li>[Ben+14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. “Zerocash: Decentralized anonymous payments from Bitcoin”. In: Proceedings of the 35th Symposium on Security and Privacy. S&P ’14. 2014, pp. 459–474.</li>

      <li>[CCD88] David Chaum, Claude Crépeau, and Ivan Damgård. “Multiparty unconditionally secure protocols”. In: Proceedings of the 20th ACM Symposium on Theory of Computing. STOC ’88. 1988, pp. 11–19.</li>

      <li>[CGKS95] Benny Chor, Oded Goldreich, Eyal Kushilevitz, and Madhu Sudan. “Private information retrieval”. In: Proceedings of the 36th Symposium on Foundations of Computer Science. FOCS ’95. 1995, pp. 41–50.</li>

      <li>[CHMMVW20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. “Marlin: Preprocessing zkSNARKs with universal and updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 738–768.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. “Fractal: Post-quantum and transparent recursive proofs from holography”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 769–793.</li>

      <li>[CT10] Alessandro Chiesa and Eran Tromer. “Proof-Carrying data and hearsay arguments from signature cards”. In: Proceedings of the 1st Symposium on Innovations in Theoreticak Computer Science. ITCS ’10. 2010, pp. 310–331.</li>

      <li>[CTV13] Stephen Chong, Eran Tromer, and Jeffrey A. Vaughan. Enforcing language semantics using proof-carrying data. Cryptology ePrint Archive, 2013/513. 2013.</li>

      <li>[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. “Cluster computing in zero knowledge”. In: Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’15. 2015, pp. 371–403.</li>

      <li>[Can01] Ran Canetti. “Universally Composable Security: A New Paradigm for Cryptographic Protocols”. In: Proceedings of the 42nd Symposium on Foundations of Computer Science. FOCS ’01. 2001, pp. 136–145.</li>

      <li>[Che06] Jung Hee Cheon. “Security analysis of the strong Diffie–Hellman problem”. In: Proceedings of the 25th International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’06. 2006, pp. 1–11.</li>

      <li>[DFKP16] Antoine Delignat-Lavaud, Cédric Fournet, Markulf Kohlweiss, and Bryan Parno. “Cinderella: Turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation”. In: Proceedings of the 37th IEEE Symposium on Security and Privacy. S&P ’16. 2016, pp. 235–254.</li>

      <li>[EGSR16] Ittay Eyal, Adem Efe Gencer, Emin Gün Sirer, and Robbert van Renesse. “Bitcoin-NG: A Scalable Blockchain Protocol”. In: Proceedings of the 13th USENIX Symposium on Networked Systems Design and Implementation. NSDI ’16. 2016, pp. 45–59.</li>

      <li>[FN16] Dario Fiore and Anca Nitulescu. “On the (In)Security of SNARKs in the Presence of Oracles”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 108–138.</li>

    </ul>

    <p class="text-gray-300">[FS86] Amos Fiat and Adi Shamir. “How to prove yourself: Practical solutions to identification and signature problems”. In: Proceedings of the 6th Annual International Cryptology Conference. CRYPTO ’86. 1986, pp. 186–194.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GHMVZ17] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich. “Algorand: Scaling Byzantine agreements for cryptocurrencies”. In: Proceedings of the 26th Symposium on Operating Systems Principles. SOSP ’17. 2017, pp. 51–68.</li>

      <li>[GK20] Juan A. Garay and Aggelos Kiayias. “SoK: A Consensus Taxonomy in the Blockchain Era”. In: Proceedings of the Cryptographers’ Track at the 2020 RSA Conference. CT-RSA ’20. 2020, pp. 284–318.</li>

      <li>[GKRRS21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. “Poseidon: A new hash function for zero-knowledge proof systems”. In: Proceedings of the 30th USENIX Security Symposium. Security ’21. 2021.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. “How to play any mental game: A completeness theorem for protocols with honest majority”. In: Proceedings of the 19th ACM Symposium on Theory of Computing. STOC ’87. 1987, pp. 218–229.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953. 2019.</li>

      <li>[Glu20] Alex Gluchowski. World’s first practical hardware for zero-knowledge proofs acceleration. https://medium.com/matter-labs/worlds-first-practical-hardware-for-zero-knowledge-proofs-acceleration-72bf974f8d6e. 2020.</li>

      <li>[Gro16] Jens Groth. “On the size of pairing-based non-interactive arguments”. In: Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[HBHW18] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. Zcash Protocol Specification. 2018. URL: https://github.com/zcash/zips/blob/master/protocol/protocol.pdf.</li>

      <li>[HLPRPd13] Matthew Hoekstra, Reshma Lal, Pradeep Pappachan, Carlos Rozas, Vinay Phegade, and Juan del Cuvillo. “Using innovative instructions to create trustworthy software solutions”. In: Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy. HASP ’13. 2013.</li>

      <li>[Hop19] Daira Hopwood. Scalable Privacy. https://www.youtube.com/watch?v=HNSf2Bw_YmM. Zcon. 2019.</li>

      <li>[JT20] Joseph Jaeger and Stefano Tessaro. “Expected-time cryptography: Generic techniques and applications to concrete soundness”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC ’20. 2020, pp. 414–443.</li>

      <li>[KB20] Assimakis Kattis and Joseph Bonneau. Proof of necessary work: Succinct state verification with fairness guarantees. Cryptology ePrint Archive, Report 2020/190. 2020.</li>

      <li>[KLS16] Aggelos Kiayias, Nikolaos Lamprou, and Aikaterini-Panagiota Stouka. “Proofs of proofs of work with sublinear complexity”. In: Proceedings of the 20th International Conference on Financial Cryptography and Data Security. FC ’16. 2016, pp. 61–78.</li>

      <li>[KMZ17] Aggelos Kiayias, Andrew Miller, and Dionysis Zindros. Non-interactive proofs of proof-of-work. Cryptology ePrint Archive, Report 2017/963. 2017.</li>

      <li>[KPS18] Ahmed E. Kosba, Charalampos Papamanthou, and Elaine Shi. “xJsnark: A framework for efficient verifiable computation”. In: Proceedings of the 39th Symposium on Security and Privacy. S&P ’18. 2018, pp. 944–961.</li>

    </ul>

    <p class="text-gray-300">[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. “Constant-size commitments to polynomials and their applications”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’10. 2010, pp. 177–194.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LHAMLK20] Duc V Le, Lizzy Tengana Hurtado, Adil Ahmad, Mohsen Minaei, Byoungyoung Lee, and Aniket Kate. “A tale of two trees: one writes, and other reads: Optimized oblivious accesses to Bitcoin and other UTXO-based blockchains”. In: Proceedings on Privacy Enhancing Technologies. PETS’20. 2020, pp. 519–536.</li>

      <li>[LNS20] Jonathan Lee, Kirill Nikitin, and Srinath Setty. “Replicated state machines without replicated execution”. In: Proceedings of the 41st IEEE Symposium on Security and Privacy. S&P ’20. 2020.</li>

      <li>[LSGZ19] Derek Leung, Adam Suhl, Yossi Gilad, and Nickolai Zeldovich. “Vault: Fast bootstrapping for the Algorand cryptocurrency”. In: Proceedings of the 25th Network and Distributed System Security Symposium. NDSS ’19. 2019.</li>

      <li>[Lee19] Linda Naeun Lee. Zcash reference wallet light client protocol. https://www.electriccoin.co/blog/zcash-reference-wallet-light-client-protocol/. 2019.</li>

      <li>[MBBFF15] Marcela S. Melara, Aaron Blankstein, Joseph Bonneau, Edward W. Felten, and Michael J. Freedman. “CONIKS: Bringing key transparency to end users”. In: Proceedings of the 24th USENIX Security Symposium. Security ’15. 2015, pp. 383–398.</li>

      <li>[MS18] Izaak Meckler and Evan Shapiro. Coda: Decentralized cryptocurrency at scale. https://cdn.codaprotocol.com/v2/static/coda-whitepaper-05-10-2018-0.pdf. 2018.</li>

      <li>[MWSKKC19] Sinisa Matetic, Karl Wüst, Moritz Schneider, Kari Kostiainen, Ghassan Karame, and Srdjan Capkun. “BITE: Bitcoin lightweight client privacy using trusted execution”. In: Proceedings of the 28th USENIX Security Symposium. Security ’19. 2019, pp. 783–800.</li>

      <li>[McK+13] Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos Rozas, Hisham Shafi, Vedvyas Shanbhogue, and Uday Savagaonkar. “Innovative instructions and software model for isolated execution”. In: Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy. HASP ’13. 2013.</li>

      <li>[Mec20] Izaak Meckler. Meet Pickles SNARK. https://medium.com/minaprotocol/meet-pickles-snark-enabling-smart-contract-on-coda-protocol-7ede3b54c250. 2020.</li>

      <li>[Mina] O(1) Labs. Mina Cryptocurrency. https://minaprotocol.com/.</li>

      <li>[NT16] Assa Naveh and Eran Tromer. “PhotoProof: Cryptographic image authentication for any set of permissible transformations”. In: Proceedings of the 37th IEEE Symposium on Security and Privacy. S&P ’16. 2016, pp. 255–271.</li>

      <li>[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf. 2008.</li>

      <li>[OWWB20] Alex Ozdemir, Riad S. Wahby, Barry Whitehat, and Dan Boneh. “Scaling verifiable computation using efficient set accumulators”. In: Proceedings of the 29th USENIX Security Symposium. Security ’20. 2020.</li>

      <li>[QHGR19] Kaihua Qin, Henryk Hadass, Arthur Gervais, and Joel Reardon. “Applying private information retrieval to lightweight Bitcoin clients”. In: Proceedings of the Crypto Valley Conference on Blockchain Technology. CVCBT ’19. 2019, pp. 60–72.</li>

      <li>[SLZ16] Yonatan Sompolinsky, Yoad Lewenberg, and Aviv Zohar. SPECTRE: A Fast and Scalable Cryptocurrency Protocol. Cryptology ePrint Archive, Report 2016/1159. 2016.</li>

      <li>[SZ13] Yonatan Sompolinsky and Aviv Zohar. Accelerating Bitcoin’s Transaction Processing: Fast Money Grows on Trees, Not Chains. Cryptology ePrint Archive, Report 2013/881. 2013.</li>

    </ul>

    <p class="text-gray-300">[TBPPTD19] Alin Tomescu, Vivek Bhupatiraju, Dimitrios Papadopoulos, Charalampos Papamanthou, Nikos Triandopoulos, and Srinivas Devadas. "Transparency logs via append-only authenticated dictionaries". In: Proceedings of the 26th Conference on Computer and Communications Security. CCS '19. 2019, pp. 1299-1316.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[TFBT21] Nirvan Tyagi, Ben Fisch, Joseph Bonneau, and Stefano Tessaro. Client-auditable verifiable registries. Cryptology ePrint Archive, Report 2021/627. 2021.</li>

      <li>[TG18] George Tankersley and Jack Grigg. Light client protocol for payment detection. https://github.com/gtank/zips/blob/light_payment_detection/zip-XXX-light-payment-detection.rst. 2018.</li>

      <li>[Val08] Paul Valiant. “Incrementally verifiable computation or proofs of knowledge imply time/space efficiency”. In: Proceedings of the 5th Theory of Cryptography Conference. TCC ’08. 2008, pp. 1–18.</li>

      <li>[Ves+22] Psi Vesely, Kobi Gurkan, Michael Straka, Ariel Gabizon, Philipp Jovanovic, Georgios Konstantopoulos, Asa Oines, Marek Olszewski, and Eran Tromer. “Plumo: An ultralight blockchain client”. In: Proceedings of the 26th International Conference on Financial Cryptography and Data Security. FC ’22. 2022, pp. 597–614.</li>

      <li>[WMSMKČ19] Karl Wüst, Sinisa Matetic, Moritz Schneider, Ian Miers, Kari Kostiainen, and Srdjan Čapkun. “ZLiTE: Lightweight clients for shielded Zcash transactions using trusted execution”. In: Proceedings of the 23rd International Conference on Financial Cryptography and Data Security. FC ’19. 2019, pp. 179–198.</li>

      <li>[WZCPS18] Howard Wu, Wenting Zheng, Alessandro Chiesa, Raluca Ada Popa, and Ion Stoica. “DIZK: A distributed zero knowledge proof system”. In: Proceedings of the 27th USENIX Security Symposium. Security ’18. 2018, pp. 675–692.</li>

      <li>[Wei20] Patrick Weißkirchner. Evaluation and improvement of Ethereum light clients. Technische Universität Wien, Diplomarbeit. http://repositum.tuwien.ac.at/obvutwhs/content/titleinfo/4671631. 2020.</li>

      <li>[Whi18] Barry Whitehat. Roll_up: Scale Ethereum with SNARKs. https://github.com/barryWhiteHat/roll_up. 2018.</li>

      <li>[Yao86] Andrew Chi-Chih Yao. “How to generate and exchange secrets”. In: Proceedings of the 27th Symposium on Foundations of Computer Science. FOCS’86. 1986, pp. 162–167.</li>

      <li>[Zca] Faster variable-base scalar multiplication in zk-SNARK circuits. https://github.com/zcash/zcash/issues/3924.</li>

      <li>[arkworks] arkworks. A Rust ecosystem for developing and programming with zkSNARKs. 2020. URL: https://arkworks.rs.</li>

      <li>[mar19] marlin. A Rust library for the Marlin preprocessing zkSNARK. 2019. URL: https://github.com/arkworks-rs/marlin.</li>

      <li>[pc19] poly-commit. A Rust library for Polynomial Commitments. 2019. URL: https://github.com/arkworks-rs/poly-commit.</li>

      <li>[sdex] StarkWare. Brining STARKs to Ethereum. https://www.starkdex.io/.</li>

      <li>[spay] StarkWare. When Lightning STARKs. https://medium.com/starkware/when-lightning-starks-a90819be37ba.</li>

      <li>[zkr] Ethereum. ZK-Rollups. https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/.</li>

    </ul>`;
---

<BaseLayout title="Reducing Participation Costs via Incremental Verification fo... (2020/1522)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1522
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
