---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/381';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Security Reductions of the Second Round SHA-3 Candidates';
const AUTHORS_HTML = 'Elena Andreeva, Bart Mennink, Bart Preneel';

const CONTENT = `    <p class="text-gray-300">Elena Andreeva Bart Mennink Bart Preneel</p>

    <p class="text-gray-300">Dept. Electrical Engineering, ESAT/COSIC and IBBT Katholieke Universiteit Leuven, Belgium {elena.andreeva, bart.mennink}@esat.kuleuven.be</p>

    <p class="text-gray-300">Abstract. In 2007, the US National Institute for Standards and Technology announced a call for the design of a new cryptographic hash algorithm in response to vulnerabilities identified in existing hash functions, such as MD5 and SHA-1. NIST received many submissions, 51 of which got accepted to the first round. At present, 14 candidates are left in the second round. An important criterion in the selection process is the SHA-3 hash function security and more concretely, the possible security reductions of the hash function to the security of its underlying building blocks. While some of the candidates are supported with firm security reductions, for most of the schemes these results are still incomplete. In this paper, we compare the state of the art provable security reductions of the second round candidates. We discuss all SHA-3 candidates at a high functional level, and analyze and summarize the security reduction results. Surprisingly, we derive some security bounds from the literature, which the hash function designers seem to be unaware of. Additionally, we generalize the well-known proof of collision resistance preservation, such that all SHA-3 candidates with a suffix-free padding are covered.</p>

    <p class="text-gray-300">Hash functions are a building block for numerous cryptographic applications. In 2004 a series of attacks by Wang et al. [66,67] have exposed security vulnerabilities in the design of the most widely adopted and deployed SHA-1 hash function. As a result, the US National Institute for Standards and Technology (NIST) recommended the replacement of SHA-1 by the SHA-2 hash function family and announced a call for the design of a new SHA-3 hashing algorithm. The SHA-3 hash function must allow for message digests of length <span class="math">224,256,384</span> and 512 bits, it should be efficient, and most importantly it should provide an adequate level of security. In the current second round, 14 candidate hash functions are still in the race for the selection of the SHA-3 hash function. These candidates are under active evaluation by the cryptographic community. As a result of the performed comparative analysis, several classifications of the SHA-3 candidates, mostly focussed on hardware performance, appeared in the literature [33,64,32,45]. A classification based on the specified by NIST security criteria is however still due.</p>

    <p class="text-gray-300">NIST Security Requirements. NIST specifies a number of security requirements [55] to be satisfied by the future SHA-3 function: (i) at least one variant of the hash function must securely support HMAC and randomized hashing. Furthermore, for all <span class="math">n</span>-bit digest values, the hash function must provide (ii) preimage resistance of approximately <span class="math">n</span> bits, (iii) second preimage resistance of approximately <span class="math">n - L</span> bits, where the first preimage is of length at most <span class="math">2^{L}</span> blocks, (iv) collision resistance of approximately <span class="math">n/2</span> bits, and (v) all variants must be resistant to the length-extension attack. Finally, (vi) for any <span class="math">m \\leq n</span>, the hash function specified by taking a fixed subset of <span class="math">m</span> bits of the function's output is required to satisfy properties (ii)-(v) with <span class="math">n</span> replaced by <span class="math">m</span>.</p>

    <p class="text-gray-300">Our Contribution. In this work we provide a survey of the 14 remaining SHA-3 candidates, in which we compare their security reductions. More concretely, we consider preimage, second preimage and collision resistance (security requirements (ii)-(iv)) for the <span class="math">n = 256</span> and <span class="math">n = 512</span> variants. Most of our security analysis is realized in the ideal model, where one or more of the underlying</p>

    <p class="text-gray-300">integral building blocks (e.g., the underlying block cipher or permutation(s)) are assumed to be ideal, i.e. random primitives. Additionally, to argue collision resistance we extend the standard proof of Merkle-Damgård collision resistance <em>[27, 53]</em> to cover <em>all</em> SHA-3 candidate hash functions with a suffix-free padding (App. A). Notice that the basic Merkle-Damgård proof does not suffice in the presence of a final transformation and/or a chopping.</p>

    <p class="text-gray-300">Furthermore, we consider the indifferentiability of the candidates. Informally, indifferentiability guarantees that a design has no structural design flaws <em>[26]</em>, and in particular (as formally proven in App. B) an indifferentiability result provides upper bounds on the advantage of finding preimages, second preimages and collisions.</p>

    <p class="text-gray-300">Our main contribution consists in performing a comparative survey of the existing security results on the 14 hash function candidates and results derivable from earlier works on hash functions, and suggesting possible research directions aimed at resolving some of the identified open problems.</p>

    <p class="text-gray-300">Section 2 briefly covers the notation, and the basic principles of hash function design. In Sect. 3, we consider all candidates from a provable security point of view. We give a high level algorithmic description of each hash function, and discuss the existing security results. All results are summarized in Table 1. We conclude the paper with Sect. 4 and give some final remarks on the security comparison.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a positive integer value <span class="math">n\\in\\mathbb{N}</span>, we denote by <span class="math">\\mathbb{Z}_{2}^{n}</span> the set of bit strings of length <span class="math">n</span>, and by <span class="math">(\\mathbb{Z}_{2}^{n})^{<em>}</span> the set of strings of length a positive multiple of <span class="math">n</span> bits. We denote by <span class="math">\\mathbb{Z}_{2}^{</em>}</span> the set of bit strings of arbitrary length. If <span class="math">x,y</span> are two bit strings, their concatenation is denoted by $x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y<span class="math">. By </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> we denote the length of a bit string </span>x<span class="math">, and for </span>m,n\\in\\mathbb{N}<span class="math"> we denote by </span>\\langle m\\rangle_{n}<span class="math"> the encoding of </span>m<span class="math"> as an </span>n<span class="math">-bit string. The function </span>\\mathsf{chop}_{n}(x)<span class="math"> chops off </span>n<span class="math"> bits of a bit string </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Throughout, we use a unified notation for all candidates. The value <span class="math">n</span> denotes the output size of the hash function, <span class="math">l</span> the size of the chaining value, and <span class="math">m</span> the number of message bits compressed in one iteration of the compression function. A padded message is always parsed as a sequence of <span class="math">k\\geq 1</span> message blocks of length <span class="math">m</span> bits: <span class="math">(M_{1},\\ldots,M_{k})</span>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Security Notions</h3>

    <p class="text-gray-300">In this section we investigate the security of the hash functions in the ‘ideal model’ and the more classical ‘generic’ security.</p>

    <p class="text-gray-300">Security in the ideal model. In the ideal model, a <em>compressing</em> function <span class="math">F</span> (either on fixed or arbitrary input lengths) that uses one or more underlying building blocks is viewed insecure if there exists a successful information-theoretic adversary that has only query access to the idealized underlying primitives of <span class="math">F</span>. The complexity of the attack is measured by the number of queries <span class="math">q</span> to the primitive made by the adversary. In this work it is clear from the context which of the underlying primitives is assumed to be ideal. The three main security properties required from the SHA-3 hash function are preimage, second preimage and collision resistance. For each of these three notions, with <span class="math">\\mathbf{Adv}_{F}^{\\text{atk}}</span>, where <span class="math">\\text{atk}\\in\\{\\text{pre},\\text{sec},\\text{col}\\}</span>, we denote the maximum advantage of an adversary to break the function <span class="math">F</span> under the security notion <span class="math">\\text{atk}</span>. The advantage is the probability function taken over all random choices of the underlying primitives, and the maximum is taken over all adversaries that make at most <span class="math">q</span> queries to their oracles.</p>

    <p class="text-gray-300">Additionally, we consider the indifferentiability of the SHA-3 candidates. The indifferentiability</p>

    <p class="text-gray-300">framework introduced by Maurer et al. <em>[52]</em> is an extension of the classical notion of indistinguishability, and ensures that a hash function has no structural defects. We denote the indifferentiability security of a hash function <span class="math">\\mathcal{H}</span> by <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pro}}</span>, maximized over all distinguishers making at most <span class="math">q</span> queries of maximal length <span class="math">K\\geq 0</span> message blocks to their oracles. We refer to <em>[26]</em> for a formal definition. An indifferentiability bound guarantees security of the hash function against specific attacks. In particular, one can obtain a bound on <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{atk}}</span>, for any security notion atk: <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{atk}}\\leq\\mathbf{Pr}_{RO}^{\\mathrm{atk}}+\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pro}}</span>, where <span class="math">\\mathbf{Pr}_{RO}^{\\mathrm{atk}}</span> denotes the success probability of a generic attack against <span class="math">\\mathcal{H}</span> under atk. This bound is proven in Thm. 2 (App. B).</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Generic security.</h4>

    <p class="text-gray-300">The <em>generic collision resistance security</em> in the context of this work deals with analyzing the collision resistance of hash functions in the standard model. A hash function <span class="math">\\mathcal{H}</span> is called generically <span class="math">(t,\\varepsilon)</span> collision resistant if no adversary running in time at most <span class="math">t</span> can find two different messages <span class="math">M,M^{\\prime}</span> such that <span class="math">\\mathcal{H}(M)=\\mathcal{H}(M^{\\prime})</span> with advantage more than <span class="math">\\varepsilon</span>. We denote by <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{gcol}}</span> the generic collision resistance security of the function <span class="math">\\mathcal{H}</span>, maximized over all ‘efficient’ adversaries. We refer the reader to <em>[59, 58, 3]</em> for a more formal discussion.</p>

    <p class="text-gray-300">To argue generic collision resistance security of the hash function <span class="math">\\mathcal{H}</span> (as domain extenders of fixed input length compression functions) we use the composition result of <em>[27, 53]</em> and extend it to a wider class of suffix-free hash functions (App. A). This result concludes the collision resistance of the hash function <span class="math">\\mathcal{H}</span> assuming collision resistance security guarantees from the underlying compression functions. We then translate ideal model collision resistance security results on the compression functions via the latter composition to ideal model collision results on the hash function (expressed by <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}}</span>). A generic collision result, generally speaking, applies to a wider class of schemes for which no bounds on the collision resistance security of the underlying compression functions is known, e.g. for BLAKE and BMW.</p>

    <p class="text-gray-300">If a compressing function <span class="math">F</span> outputs a bit string of length <span class="math">n</span>, one expects to find collisions with high probability after approximately <span class="math">2^{n/2}</span> queries (due to the birthday attack). Similarly, (second) preimages can be found with high probability after approximately <span class="math">2^{n}</span> queries. Moreover, finding second preimages is provably harder than finding collisions, and similar for preimages (depending on the specification of <span class="math">F</span>) <em>[59]</em>. Formally, we have <span class="math">\\Omega(q^{2}/2^{n})=\\mathbf{Adv}_{F}^{\\mathrm{col}}=O(1)</span>, <span class="math">\\Omega(q/2^{n})=\\mathbf{Adv}_{F}^{\\mathrm{sec}}\\leq\\mathbf{Adv}_{F}^{\\mathrm{col}}</span>, and <span class="math">\\Omega(q/2^{n})=\\mathbf{Adv}_{F}^{\\mathrm{pre}}\\leq\\mathbf{Adv}_{F}^{\\mathrm{col}}+\\varepsilon</span>, where <span class="math">\\varepsilon</span> is negligible if <span class="math">F</span> is a variable input length compressing function. In the remainder, we will consider these bounds for granted, and only include security results that improve either of these bounds. A bound is called <em>tight</em> if the lower and upper bound are the same up to a constant factor, and <em>optimal</em> if the bound is tight with respect to the original lower bound.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Compression Function Design Strategies</h3>

    <p class="text-gray-300">A common way to build compression functions is to base it on a block cipher <em>[57, 21, 62]</em>, or on a (limited number of) permutation(s) <em>[20, 60, 61]</em>. Preneel et al. <em>[57]</em> analyzed and categorized 64 block cipher based compression functions. Twelve of them are formally proven secure by Black et al. <em>[21]</em>. These results have been recently generalized by Stam <em>[62]</em>. Interestingly, the latter result implies security bounds for some compression functions that do not fit in the PGV-model, like ECHO, Hamsi and SIMD. Throughout, by ‘PGVx’ we denote the <span class="math">x^{\\mathrm{th}}</span> type compression function</p>

    <p class="text-gray-300">of <em>[57]</em>. We note that PGV1, PGV3 and PGV5 are better known as the Matyas-Meyer-Oseas, the Miyaguchi-Preneel and the Davies-Meyer compression functions, respectively. In the context of permutation based compression functions, Black et al. <em>[20]</em> analyzed <span class="math">2l</span>- to <span class="math">l</span>-bit compression functions based on <em>one</em> <span class="math">l</span>-bit permutation, and proved them insecure. This result has been generalized by Rogaway and Steinberger <em>[60]</em>, Stam <em>[61]</em> and Steinberger <em>[63]</em> to compression functions with arbitrary input and output sizes, and an arbitrary number of underlying permutations. Their bounds indicate the number of queries required to find collisions or preimages for permutation based compression functions.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Hash Function Design Strategies</h3>

    <p class="text-gray-300">In order to allow the hashing of arbitrarily long strings, all SHA-3 candidates employ a specific mode of operation. Central to all designs is the <em>iterated hash function principle</em> <em>[47]</em>: on input of an initialization vector <span class="math">\\mathsf{IV}</span>, the iterated hash function <span class="math">\\mathcal{H}^{f}</span> based on the compression function <span class="math">f</span> proceeds a padded message <span class="math">(M_{1},\\ldots,M_{k})</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}^{f}(\\mathsf{IV};M_{1},\\ldots,M_{k})=h_{k}\\text{, where: }h_{0}=\\mathsf{IV},</span> <span class="math">h_{i}=f(h_{i-1},M_{i})\\text{ for }i=1,\\ldots,k.</span></p>

    <p class="text-gray-300">This principle is also called the plain Merkle-Damgård (MD) design <em>[53, 27]</em>. Each of the 14 remaining candidates is based on this design, possibly followed by a final transformation (FT), and/or a chop-function.</p>

    <p class="text-gray-300">The padding function <span class="math">\\mathsf{pad}:\\mathbb{Z}_{2}^{<em>}\\to(\\mathbb{Z}_{2}^{m})^{</em>}</span> is an injective mapping that transforms a message of arbitrary length to a message of length a multiple of <span class="math">m</span> bits (the number of message bits compressed in one compression function iteration). Most of the candidates employ a sufficiently strong padding rule (cf. App. C). Additionally, in some of the designs the message blocks are compressed along with specific counters or tweaks, which may strengthen the padding rule. We distinguish between ‘prefix-free’ and/or ‘suffix-free’ padding.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A padding rule is called suffix-free, if for any distinct <span class="math">M,M^{\\prime}</span>, there exists no bit string <span class="math">X</span> such that $\\mathsf{pad}(M^{\\prime})=X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pad}(M)$. The plain MD design with any suffix-free padding (also called MD-strengthening <em>[47]</em>) preserves collision resistance <em>[53, 27]</em>. We generalize this result in Thm. 1 (App. A): informally, this preservation result also holds if the iteration is finalized by a distinct compression function and/or the chop-function. Other security properties, like preimage resistance, are however not preserved in the MD design <em>[3]</em>. It is also proven that the MD design with a suffix-free padding need not necessarily be indifferentiable <em>[26]</em>. However, the MD construction <em>is</em> indifferentiable if it ends with a chopping function or a final transformation, both when the underlying compression function is ideal or when the hash function is based on a PGV compression function <em>[26, 39, 51]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">HAIFA design. A concrete design based on the MD principle is the HAIFA construction <em>[18]</em>. In HAIFA the message is padded in a specific way so as to solve some deficiencies of the original MD construction: in the iteration, each message block is accompanied with a fixed (optional) salt of <span class="math">s</span> bits and a (mandatory) counter <span class="math">C_{i}</span> of <span class="math">t</span> bits. The counter <span class="math">C_{i}</span> keeps track of the number of message bits hashed so far, and equals 0 by definition if the <span class="math">i^{\\text{th}}</span> block does not contain any message bits. Partially due to the properties of this counter, the HAIFA padding rule is suffix- and prefix-free. As a consequence, the construction preserves collision resistance (cf. Thm. 1) and the indifferentiability results of <em>[26]</em> carry over. For the HAIFA design, these indifferentiability results are improved in <em>[16]</em>. Furthermore, the HAIFA construction is proven secure against second preimage attacks if the underlying compression function is assumed to behave like an ideal primitive <em>[23]</em>.</p>

    <p class="text-gray-300">Wide-pipe design. In the wide-pipe design <em>[50]</em>, the iterated state size is significantly larger than the final hash output: at the end of the iteration, a fraction of the output of a construction is discarded. As proved in <em>[26]</em>, the MD construction with a distinct final transformation and/or chopping at the end is indifferentiable from a random oracle.</p>

    <p class="text-gray-300">Sponge functions. We do not explicitly consider sponge functions <em>[15]</em> or their generalization <em>[1]</em> as a specific type of construction: all SHA-3 candidates known to be sponge(-like) functions, CubeHash, Fugue, JH, Keccak and Luffa, can be described in terms of the chop-MD construction (possibly with a final transformation before or instead of the chopping).</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 SHA-3 Hash Function Candidates</h2>

    <p class="text-gray-300">In this section, we analyze the security of the 14 remaining SHA-3 candidates in more detail. For simplicity, we only consider the proposals of the SHA-3 candidates that output digests of 256 or 512 bits. Observe that in many candidate SHA-3 hash function families, the algorithms that output 224 or 384 bits are the same as the 256- or 512-bits algorithms, except for an additional chopping at the end. Particularly, the results of <em>[26]</em> and Thm. 1 carry over in most of the cases. The same remark applies to requirement (vi) of NIST.</p>

    <p class="text-gray-300">All designers claim that their proposal can safely be used in HMAC mode <em>[9]</em> or for randomized hashing <em>[41]</em>, and we do not discuss it here; Preimage, second preimage and collision resistance of each hash function are discussed in this section. Additionally, we consider the indifferentiability of the candidates; All hash function candidates are secure against the length extension attack, and thus we do not discuss it further.</p>

    <p class="text-gray-300">Below, we examine the SHA-3 candidate hash functions in more detail. Each paragraph contains an informal discussion for each of the second round SHA-3 candidates and their security reduction results. The mathematical descriptions of the (abstracted) designs are given in Fig. 1, and the candidates’ padding functions are summarized in App. C. The concrete security results for all current candidate hash functions are summarized in Table 1. More precisely, for each candidate and each security notion, this table includes the security bound, as far as it exists, and the underlying assumption.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1</h3>

    <p class="text-gray-300">The BLAKE hash function <em>[6]</em> is a HAIFA construction. The message blocks are accompanied with a HAIFA-counter, and more generally, the function employs a suffix- and prefix-free padding rule. The compression function <span class="math">f</span> is block cipher based. It moreover employs an injective linear</p>

    <p class="text-gray-300">|  BLAKE: (n,l,m,s,t) ∈ {(256,256,512,128,64), (512,512,1024,256,128)}  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  E: Z231× Z2m→ Z231a block cipher  |</p>

    <p class="text-gray-300">|  L: Z21++1→ Z231, L': Z231→ Z22 linear functions  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(h,M,S,C) = L'(EM(L(h,S,C))) ⊕ h ⊕ (S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  BLAKE(M) = hk, where: (M1,...,Mk) ← pad4(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k h ← chop1-n[hk]  |</p>

    <p class="text-gray-300">|  BMW: (n,l,m) ∈ {(256,512,512), (512,1024,1024)}  |</p>

    <p class="text-gray-300">|  E: Z2m× Z2l→ Z2m a block cipher  |</p>

    <p class="text-gray-300">|  L: Z21++1→ Z22 a compressing function  |</p>

    <p class="text-gray-300">|  f(h,M) = L(h,M,Eh(M))  |</p>

    <p class="text-gray-300">|  g(h) = f(IV',h)  |</p>

    <p class="text-gray-300">|  BMW(M) = h, where: (M1,...,Mk) ← pad2(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k h ← chop1-n[hk]  |</p>

    <p class="text-gray-300">|  CubeHash: (n,l,m) ∈ {(256,1024,256), (512,1024,256)}  |</p>

    <p class="text-gray-300">|  P: Z2l→ Z2l a permutation  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(h,M) = P(h ⊕ (M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0l-m))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  CubeHash(M) = h, where: (M1,...,Mk) ← pad2(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k h ← chop1-n[ghk]  |</p>

    <p class="text-gray-300">|  ECHO: (n,l,m,s,t) ∈ {(256,512,1536,128,64/128), (512,1024,1024,256,64/128)}  |</p>

    <p class="text-gray-300">|  E: Z2048× Z2+1→ Z2048 a block cipher  |</p>

    <p class="text-gray-300">|  L: Z2048→ Z2l a linear function  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(h,M,S,C) = L(ES,C(h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M) ⊕ (h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ECHO(M) = h, where: (M1,...,Mk) ← pad4(M); h0 ← IV S ∈ Z2: (Ci)i=1 HAIFA-counter  |</p>

    <p class="text-gray-300">|  h1 ← f(h1-1,M1,S,Ci) for i = 1,...,k  |</p>

    <p class="text-gray-300">|  h ← chop1-n[hk]  |</p>

    <p class="text-gray-300">|  Fugue: (n,l,m) ∈ {(256,960,32), (512,1152,32)}  |</p>

    <p class="text-gray-300">|  P, P: Z2l→ Z2l permutations  |</p>

    <p class="text-gray-300">|  L: Z2l× Z2m→ Z2l a linear function  |</p>

    <p class="text-gray-300">|  f(h,M) = P(h ⊕ M) ⊕ Q(M) ⊕ h  |</p>

    <p class="text-gray-300">|  g(h) = P(h) ⊕ h  |</p>

    <p class="text-gray-300">|  Grostl(M) = h, where: (M1,...,Mk) ← pad5(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k h ← chop1-n[P(hk)]  |</p>

    <p class="text-gray-300">|  Hamsi: (n,l,m) ∈ {(256,256,32), (512,512,64)}  |</p>

    <p class="text-gray-300">|  P, P: Z2m→ Z2m permutations  |</p>

    <p class="text-gray-300">|  Exp: Z2m→ Z2m a linear code  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(h,M) = h ⊕ chop_n[P(Exp(M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h)]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Hamsi(M) = h, where: (M1,...,Mk) ← pad7(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k - 1  |</p>

    <p class="text-gray-300">|  h ← g(hk-1,Mk)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">JH: (n,l,m) ∈ {(256,1024,512), (512,1024,512)} P: Z2l → Z2l a permutation f(h,M) = P(h ⊕ (0l-m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M)) ⊕ (M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0l-m)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  JH(M) = h, where: (M1,...,Mk) ← pad8(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k h ← chop1-n[hk]  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Keccak: (n,l,m) ∈ {(256,1600,1088), (512,1600,576)} P: Z2l → Z2l a permutation f(h,M) = P(h ⊕ (M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0l-m))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Keccak(M) = h, where: (M1,...,Mk) ← pad9(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k h ← chop1-n[hk]  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Luffa: (n,l,m,w) ∈ {(256,768,256,3), (512,1278,256,5)} P1: Z2m → Z2m (i = 1,...,w) permutations L: Z2m+1 → Z2m+1, L': Z2m+1 → Z2m+1 linear functions f(h,M) = (P1(h))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pw(h'w)) where (h1,...,h1') = L(h,M) g(h) = (L'(h)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L'(f(h,0m)))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Luffa(M) = h, where: (M1,...,Mk) ← pad10(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k h ← chop1-n[ghk]  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Shaba: (n,l,m) ∈ {(256,1408,512), (512,1408,512)} E: Z2896 × Z21024 → Z2896 a block cipher f(h,C,M) = (y1,h3-M,y3) where h ∈ Z2l → h = (h1,h2,h3) ∈ Z2384+m+m and (y1,y3) = EM,h3(h1 ⊕ (0320</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C),h2 + M)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Shaba(M) = h, where: (M1,...,Mk) ← pad11(M); h0 ← IV h1 ← f(h1-1,i)64,M1) for i = 1,...,k hk+i ← f(hk+i-1, (k)64,Mk) for i = 1,...,3 h ← chop1-n[hk+3]  |</p>

    <p class="text-gray-300">|  SHAvite-3: (n,l,m,s,t) ∈ {(256,256,512,256,64), (512,512,1024,512,128)} E: Z2l × Z2m++1 → Z2l a block cipher f(h,M,S,C) = EM,S,C(h) ⊕ h  |</p>

    <p class="text-gray-300">|  SHAvite-3(M) = hk, where: (M1,...,Mk) ← pad12(M); h0 ← IV S ∈ Z2: (Ci)i=1 HAIFA-counter h1 ← f(h1-1,M1,S,Ci) for i = 1,...,k  |</p>

    <p class="text-gray-300">|  SIMD: (n,l,m) ∈ {(256,512,512), (512,1024,1024)} E, E: Z2l × Z2m → Z2l block ciphers f(h,M) = L(h,EM(h ⊕ M)) g(h,M) = L(h,EM(h ⊕ M))  |</p>

    <p class="text-gray-300">|  SIMD(M) = h, where: (M1,...,Mk) ← pad13(M); h0 ← IV h1 ← f(h1-1,M1) for i = 1,...,k - 1 hk ← g(hk-1,Mk) h ← chop1-n[hk]  |</p>

    <p class="text-gray-300">|  Skein: (n,l,m) ∈ {(256,512,512), (512,512,512)} E: Z2m × Z2l28 × Z2l → Z2m a tweakable block cipher f(h,T,M) = Eh,T(M) ⊕ M  |</p>

    <p class="text-gray-300">|  Skein(M) = h, where: (M1,...,Mk) ← pad14(M); h0 ← IV (Ti)i=1 round-specific tweaks h1 ← f(h1-1,Ti,M1) for i = 1,...,k h ← chop1-n[hk]  |</p>

    <p class="text-gray-300">Fig. 1. The padding rules employed by the functions are summarized in App. C. In all algorithm descriptions, IV denotes an initialization vector,  <span class="math">h</span>  denotes state values,  <span class="math">M</span>  denotes message blocks,  <span class="math">S</span>  denotes a (fixed) salt,  <span class="math">C</span>  denotes a counter and  <span class="math">T</span>  denotes a tweak. The functions  <span class="math">L, L&#x27;, \\text{Exp}</span>  underlying BLAKE, BMW, ECHO, Fugue, Hamsi and Luffa, are explained in the corresponding section.</p>

    <p class="text-gray-300">function <span class="math">L</span>, and a linear function <span class="math">L&#x27;</span> that XORs the first and second halves of the input.</p>

    <p class="text-gray-300"><strong>Security of BLAKE.</strong> The compression function of BLAKE shows similarities with the PGV5 compression function [21], but no security results are known for this variation. The mode of operation of BLAKE is based on the HAIFA structure, and as a consequence all security properties regarding this type hold [18]. In particular, the design preserves collision resistance, and as a consequence we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}} = \\Theta (q^{2} / 2^{n})</span> (if <span class="math">f</span> is assumed ideal). Also, the design is secure against second preimage attacks. Additionally, a preimage for BLAKE implies a preimage for its last compression function, and we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pre}} = \\Theta (q / 2^{n})</span>. Furthermore, the BLAKE hash function is indifferentiable from a random oracle if the underlying compression function is assumed to be ideal, due to the HAIFA counter [26,16].</p>

    <p class="text-gray-300"><strong>3.2.</strong> The Blue Midnight Wish (BMW) hash function [38] is a chop-MD construction, with a final transformation before chopping. The hash function employs a suffix-free padding rule. The compression function <span class="math">f</span> is block cipher based<span class="math">^4</span>, and the final transformation <span class="math">g</span> consists of the same compression function with the chaining value processed as a message, and with an initial value as chaining input. The compression function employs a function <span class="math">L</span> which consists of two compression functions with specific properties as specified in [38].</p>

    <p class="text-gray-300"><strong>Security of BMW.</strong> The compression function of BMW shows similarities with the PGV3 compression function [21], but no security results are known for this variation. Thm. 1 applies to BMW, where the final transformation has no message block as input, and as a consequence we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}} = \\Theta (q^{2} / 2^{n})</span> (if <span class="math">f</span> is assumed ideal). Additionally, a preimage for BMW implies a preimage for its final transformation, and we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pre}} = \\Theta (q / 2^{n})</span>. Furthermore, albeit no indifferentiability proof for the BMW hash function is known, we note that BMW can be seen as a combination of the HMAC- and the chop-construction, both proven indifferentiable from a random oracle [26]. We remark that a distinguisher for the compression function of BMW is derived in [5].</p>

    <p class="text-gray-300"><strong>3.3.</strong> The CubeHash hash function [12] is a chop-MD construction, with a final transformation before chopping. The compression function <span class="math">f</span> is permutation based, and the final transformation <span class="math">g</span> consists of flipping a certain bit in the state and applying 10 more compression function rounds on zero-messages.</p>

    <p class="text-gray-300"><strong>Security of CubeHash.</strong> The compression function of CubeHash is based on one permutation<span class="math">^5</span>, and collisions and preimages for the compression function can be found in one query to the permutation [20]. The CubeHash hash function is as parazoa design proven indifferentiable from a random oracle if the underlying permutation is assumed to be ideal [1]. Using Thm. 2, this indifferentiability bound additionally renders an optimal collision resistance bound for CubeHash, <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}} = \\Theta (q^{2} / 2^{n})</span>, as well as an improved upper bound <span class="math">O\\left(\\frac{q}{2^n} +\\frac{q^2}{2^{l - n}}\\right)</span> on the preimage and second preimage resistance. Note that these bounds are optimal for the <span class="math">n = 256</span> variant.</p>

    <p class="text-gray-300"><strong>3.4.</strong> The ECHO hash function [11] is a chop-HAIFA construction. The message blocks are accompanied with a HAIFA-counter, and more generally, the function employs a suffix- and prefix-free padding rule. The compression function <span class="math">f</span> is block cipher based<span class="math">^6</span>. It moreover employs a linear function <span class="math">L</span> that chops the state in blocks of length <span class="math">l</span> bits, and XORs these.</p>

    <p class="text-gray-300"><strong>Security of ECHO.</strong> The compression function of ECHO is a 'chopped single call Type-I' com</p>

    <p class="text-gray-300"><span class="math">^4</span> As observed in [38], the compression function can be seen as a generalized PGV3 construction, where the function <span class="math">f_0</span> of [38] defines the block cipher keyed with the chaining value.</p>

    <p class="text-gray-300"><span class="math">^5</span> Effectively, this permutation consists of one simpler permutation executed 16 times iteratively.</p>

    <p class="text-gray-300"><span class="math">^6</span> As observed in [11], the core part of the compression function can be seen as a permutation keyed by the salt and counter, which we view here as a block cipher. This cipher is AES-based.</p>

    <p class="text-gray-300">pression function in the categorization of <em>[62]</em>. Therefore, the results of <em>[62, Thm. 15]</em> carry over, yielding optimal security bounds for the compression function. Observe that these results can easily be adjusted to obtain bound <span class="math">\\mathbf{Adv}_{\\mathsf{chop}\\circ f}^{\\mathrm{col}}=\\Theta(q^{2}/2^{n})</span>. ECHO is a combination of HAIFA and chop-MD, but it is unclear whether all HAIFA security properties hold after chopping. Still, Thm. 1 applies to ECHO, and as a consequence we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}}=\\Theta(q^{2}/2^{n})</span>. Additionally, a preimage for ECHO implies a preimage for its last compression function, and we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pre}}=\\Theta(q/2^{n})</span>. Furthermore, the ECHO hash function would be indifferentiable from a random oracle if the underlying compression function is assumed to be ideal, due to the chopping function at the end <em>[26]</em>. However, the compression function of ECHO is easily differentiable from a random oracle <em>[35]</em>, and we cannot directly apply the results of <em>[26]</em>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.5</h3>

    <p class="text-gray-300">The Fugue hash function <em>[40]</em> is a chop-MD construction, with a final transformation before chopping. The hash function employs a suffix-free padding rule. The compression function <span class="math">f</span> is permutation based, and the final transformation consists of a permutation <span class="math">\\tilde{P}</span> which differs from <span class="math">P</span> in the parametrization. The compression function employs a linear function <span class="math">L</span> for message injection (TIX of <em>[40]</em>).</p>

    <p class="text-gray-300">Security of Fugue. The compression function of Fugue is based on one permutation, and collisions and preimages for the compression function can be found in one query to the permutation <em>[20]</em>. As a consequence, the result of Thm. 1 is irrelevant, even though the padding rule of Fugue is suffix-free. The Fugue hash function is as parazoa design proven indifferentiable from a random oracle if the underlying permutations <span class="math">P</span> and <span class="math">\\tilde{P}</span> are assumed to be ideal <em>[1]</em>. Using Thm. 2, this indifferentiability bound additionally renders an optimal collision resistance bound for Fugue, <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}}=\\Theta(q^{2}/2^{n})</span>, as well as an improved upper bound <span class="math">O\\left(\\frac{q}{2^{n}}+\\frac{q^{2}}{2^{l-m-n}}\\right)</span> on the preimage and second preimage resistance. Note that these bounds are optimal for the <span class="math">n=256</span> variant. We remark that a distinguisher for the final round of Fugue is derived in <em>[8, 36]</em>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.6</h3>

    <p class="text-gray-300">The Grøstl hash function <em>[37]</em> is a chop-MD construction, with a final transformation before chopping. The hash function employs a suffix-free padding rule. The compression function <span class="math">f</span> is permutation based, and the final transformation <span class="math">g</span> is defined as <span class="math">g(h)=P(h)\\oplus h</span>.</p>

    <p class="text-gray-300">Security of Grøstl. The compression function of Grøstl is permutation based, and the results of <em>[60, 61]</em> apply. Furthermore, the preimage resistance of the compression function is analyzed in <em>[34]</em>, and an upper bound for collision resistance can be obtained easily. As a consequence, we obtain tight security bounds on the compression function, <span class="math">\\mathbf{Adv}_{f}^{\\mathrm{pre}}=\\Theta(q^{2}/2^{l})</span> and <span class="math">\\mathbf{Adv}_{f}^{\\mathrm{col}}=\\Theta(q^{4}/2^{l})</span>. Thm. 1 applies to Grøstl, where the final transformation has no message block as input. Observe that we also have <span class="math">\\mathbf{Adv}_{\\mathsf{chop}\\circ g}^{\\mathrm{col}}=\\Theta(q^{2}/2^{n})</span>, and as a consequence we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}}=\\Theta(q^{2}/2^{n})</span>. Additionally, a preimage for Grøstl implies a preimage for its final transformation, and we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pre}}=\\Theta(q/2^{n})</span>. Furthermore, the Grøstl hash function is proven indifferentiable from a random oracle if the underlying permutations are ideal <em>[2]</em>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.7</h3>

    <p class="text-gray-300">The Hamsi hash function <em>[46]</em> is a MD construction, with a final transformation before chopping. The hash function employs a suffix-free padding rule. The compression function <span class="math">f</span> is permutation based, but the last round is executed with a compression function <span class="math">g</span> based on a permutation <span class="math">\\tilde{P}</span> which differs from <span class="math">P</span> in the parametrization. The compression functions employ a linear code Exp for message injection <em>[46]</em>.</p>

    <p class="text-gray-300">Security of Hamsi. The compression function of Hamsi is a ‘chopped single call Type-I’ compression function in the categorization of <em>[62]</em>. Therefore, the results of <em>[62, Thm. 15]</em> carry over, yielding optimal security bounds for the compression function. Observe that these bounds also apply to the</p>

    <p class="text-gray-300">function <span class="math">g</span>. Thm. 1 applies to <span class="math">\\mathsf{Hamsi}</span>, and as a consequence we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}} = \\Theta (q^{2} / 2^{n})</span>. Additionally, a preimage for <span class="math">\\mathsf{Hamsi}</span> implies a preimage for its last compression function, and we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pre}} = \\Theta (q / 2^{n})</span>. Furthermore, albeit no indifferentiability proof for the <span class="math">\\mathsf{Hamsi}</span> hash function is known, we note that <span class="math">\\mathsf{Hamsi}</span> can be seen as a variation of the NMAC-construction, which is proven indifferentiable from a random oracle [26].</p>

    <p class="text-gray-300">3.8. The JH hash function [68] is a chop-MD construction. The hash function employs a suffix-free padding rule. The compression function <span class="math">f</span> is permutation based.</p>

    <p class="text-gray-300">Security of JH. The compression function of JH is based on one permutation, and collisions and preimages for the compression function can be found in one query to the permutation [20]. As a consequence, the result of Thm. 1 is irrelevant, even though the padding rule of JH is suffix-free. The JH hash function is proven optimally collision resistant [48], and proven indifferentiable from a random oracle if the underlying permutation is assumed to be ideal [17]. Using Thm. 2, this indifferentiability bound additionally renders an improved upper bound <span class="math">O\\left(\\frac{q}{2^n} + \\frac{q^3}{2^{l - m}}\\right)</span> on the preimage and second preimage resistance.</p>

    <p class="text-gray-300">3.9. The Keccak hash function [14] is a chop-MD construction. The compression function <span class="math">f</span> is permutation based. The hash function output is obtained by chopping off <span class="math">l - n</span> bits of the state<span class="math">^7</span>. Notice that the parameters of Keccak satisfy <span class="math">l = 2n + m</span>.</p>

    <p class="text-gray-300">Security of Keccak. The compression function of Keccak is based on one permutation, and collisions and preimages for the compression function can be found in one query to the permutation [20]. The Keccak hash function is proven indifferentiable from a random oracle if the underlying permutation is assumed to be ideal [13]. Using Thm. 2, this indifferentiability bound additionally renders an optimal collision resistance bound for Keccak, <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}} = \\Theta (q^{2} / 2^{n})</span>, as well as an optimal preimage second preimage resistance bound <span class="math">\\Theta (q / 2^{n})</span>.</p>

    <p class="text-gray-300">3.10. The Luffa hash function [28] is a chop-MD construction, with a final transformation before chopping. The compression function <span class="math">f</span> is permutation based, and the final transformation <span class="math">g</span> is built on this compression function and a linear function <span class="math">L&#x27;</span> that chops the state in blocks of length <span class="math">m</span> bits, and XORs these. The compression function employs a linear function <span class="math">L</span> for message injection (MI of [28])<span class="math">^8</span>. Notice that the state size of Luffa satisfies <span class="math">l = w \\cdot m</span>.</p>

    <p class="text-gray-300">Security of Luffa. The compression function of Luffa is based on <span class="math">w</span> permutations executed independently. As a consequence, collisions and preimages for the compression function can be found in at most 5 queries to the permutations [20]. The Luffa hash function borrows characteristics from the sponge design and is similar to the parazoa design, if the permutation <span class="math">P</span> consisting of the <span class="math">w</span> permutations <span class="math">P_i</span> is considered ideal, and ideas from the indifferentiability proofs of [1,13] may carry over. However, for the case of <span class="math">w</span> different permutations <span class="math">P_i</span> this is not immediately clear. We remark that a distinguisher for the permutation of Luffa is derived in [43].</p>

    <p class="text-gray-300">3.11. The Shabal hash function [24] is a chop-MD construction. The message blocks are accompanied with a counter, and the last block is iterated three times. In particular, the function employs a suffix- and prefix-free padding rule. The compression function <span class="math">f</span> is block cipher based<span class="math">^9</span>. Notice that the parameters of Shabal satisfy <span class="math">l = 384 + 2m</span>.</p>

    <p class="text-gray-300"><span class="math">^7</span> We notice that sponge functions are designed more general [15], but for Keccak this description suffices.</p>

    <p class="text-gray-300"><span class="math">^8</span> We defined the output transformation in a slightly more complicated but unified way. Essentially, Luffa<span class="math">_{256}</span> simply outputs <span class="math">L&#x27;(h)</span>. Observe that we implicitly captured the extra compression function call in the adjusted padding.</p>

    <p class="text-gray-300"><span class="math">^9</span> Essentially, it is a permutation tweaked by a 1024-bit key, which we view here as a block cipher.</p>

    <p class="text-gray-300">Security of Shabal. A bound on the collision resistance of the compression function of Shabal is derived in <em>[24]</em>. Concretely, it is proven that the Shabal compression function is collision resistant up to <span class="math">q=2^{(l-m)/2}</span> queries. Thm. 1 applies to Shabal. Collision and preimage resistance of Shabal are studied in <em>[24]</em>, yielding optimal bounds <span class="math">\\mathbf{Adv}^{\\mathrm{pre}}_{\\mathcal{H}}=\\Theta(q/2^{n})</span> and <span class="math">\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H}}=\\Theta(q^{2}/2^{n})</span>. Furthermore, the same authors prove the Shabal hash function to be indifferentiable from a random oracle if the underlying block cipher is assumed to be ideal <em>[24]</em>. Using Thm. 2, this indifferentiability bound additionally renders an improved upper bound <span class="math">O\\left(\\frac{q}{2^{n}}+\\frac{q^{2}}{2^{l-m}}\\right)</span> on the second preimage resistance. Note that this bound is optimal for the <span class="math">n=256</span> variant. We remark that a distinguisher for the block cipher of Shabal is derived in <em>[4, 7, 44, 56, 65]</em>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.12</h3>

    <p class="text-gray-300">The SHAvite-3 hash function <em>[19]</em> is a HAIFA construction. The message blocks are accompanied with a HAIFA-counter, and more generally, the function employs a suffix- and prefix-free padding rule. The compression function <span class="math">f</span> is block cipher based.</p>

    <p class="text-gray-300">Security of SHAvite-3. The compression function of SHAvite-3 is the PGV5 compression function, and the security results of <em>[21]</em> carry over. As a consequence, we obtain optimal security bounds on the compression function. The mode of operation of SHAvite-3 is based on the HAIFA structure, and as a consequence all security properties regarding this type hold <em>[18]</em>. In particular, the design preserves collision resistance, and as a consequence we obtain <span class="math">\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H}}=\\Theta(q^{2}/2^{n})</span>. Also, the design is secure against second preimage attacks. Additionally, a preimage for SHAvite-3 implies a preimage for its last compression function, and we obtain <span class="math">\\mathbf{Adv}^{\\mathrm{pre}}_{\\mathcal{H}}=\\Theta(q/2^{n})</span>. Finally, the SHAvite-3 hash function is indifferentiable from a random oracle if the underlying block cipher is assumed to be ideal, due to the prefix-free padding <em>[26]</em>. This result has been improved under the assumption that the underlying compression function is ideal <em>[16]</em>. However, the compression function of SHAvite-3 is easily differentiable from a random oracle due to the presence of fixed-points.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.13</h3>

    <p class="text-gray-300">The SIMD hash function <em>[49]</em> is a chop-MD construction, with a final transformation before chopping. The hash function employs a suffix-free padding rule. The compression function <span class="math">f</span> is block cipher based, but the last round is executed with a compression function <span class="math">g</span> based on a block cipher <span class="math">\\tilde{E}</span> which differs from <span class="math">E</span> in the parametrization. These function employ a quasi-group operation <span class="math">L</span> <em>[49]</em>.</p>

    <p class="text-gray-300">Security of SIMD. The compression function of SIMD is a ‘rate-1 Type-I’ compression function in the categorization of <em>[62]</em>. Therefore, the results of <em>[62, Thm. 6]</em> carry over, yielding optimal security bounds for the compression function. Observe that these bounds also apply to the function <span class="math">g</span>. Observe moreover that these results can easily be adjusted to obtain bound <span class="math">\\mathbf{Adv}^{\\mathrm{col}}_{\\mathsf{chop}\\circ g}=\\Theta(q^{2}/2^{n})</span>. Thm. 1 applies to SIMD, and as a consequence we obtain <span class="math">\\mathbf{Adv}^{\\mathrm{col}}_{\\mathcal{H}}=\\Theta(q^{2}/2^{n})</span>. Additionally, a preimage for SIMD implies a preimage for its last compression function, and we obtain <span class="math">\\mathbf{Adv}^{\\mathrm{pre}}_{\\mathcal{H}}=\\Theta(q/2^{n})</span>. Furthermore, the SIMD hash function would be indifferentiable from a random oracle if the underlying compression functions are assumed to be ideal, due to the chopping function at the end <em>[26]</em>. However, the compression functions of SIMD are easily differentiable from a random oracle <em>[22]</em>, and we cannot directly apply the results of <em>[26]</em>.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.14</h3>

    <p class="text-gray-300">The Skein hash function <em>[31]</em> is a chop-MD construction. The message blocks are accompanied with a round-specific tweak, and more generally, the function employs a suffix- and prefix-free</p>

    <p class="text-gray-300">adding rule. The compression function <span class="math">f</span> is based on a tweakable block cipher.</p>

    <p class="text-gray-300">Security of Skein. The compression function of Skein is the PGV1 compression function, with a difference that a tweak is involved. As claimed in <em>[10]</em>, the results of <em>[21]</em> carry over, which in turn results in optimal security bounds on the compression function. Thm. 1 applies to Skein, and as a consequence we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{col}}=\\Theta(q^{2}/2^{n})</span>. Additionally, a preimage for Skein implies a preimage for its last compression function, and we obtain <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pre}}=\\Theta(q/2^{n})</span>. Furthermore, the Skein hash function is proven indifferentiable from a random oracle if the underlying tweakable block cipher is assumed to be ideal <em>[10]</em>. This proof is based on the preimage-awareness approach <em>[30]</em>. Using Thm. 2, this indifferentiability bound additionally renders an improved upper bound <span class="math">O\\left(\\frac{q}{2^{n}}+\\frac{q^{2}}{2^{l}}\\right)</span> on the second preimage resistance. Note that this bound is optimal for the <span class="math">n=256</span> variant.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4 Summary and Conclusions</h2>

    <p class="text-gray-300">In this survey, we compared the security achieved by the remaining round 2 SHA-3 hash function candidates, when their underlying primitives are assumed to be ideal. The main contribution of this paper is the summary of the security reductions for the hash function candidates in Table 1. Before giving an interpretation of these results, we first make some remarks on the provided classification.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assuming ideality of the underlying primitives (permutations or block ciphers) is not realistic. In particular, none of the candidates’ primitives is ideal, and some even have identified weaknesses. However, assuming ideality of these primitives gives significantly more confidence in the security of the higher level structure and is the only way to get useful (and comparable) security bounds on the candidate hash functions;</li>

      <li>The fact that different hash functions have different bounds, does not directly imply that one of the functions offers a higher level of security: albeit the underlying structure of the basic primitives is abstracted away (see the previous item), still many differences among the schemes remain (chaining size, message input size, etc.). Moreover, not all bounds are tight.</li>

    </ul>

    <p class="text-gray-300">For the sponge(-like) hash functions, CubeHash, Fugue, JH, Keccak and Luffa, collisions and preimages for the compression function can be found in a constant number of queries. This does not have direct implications for the security of the hash function. In fact, the only consequence is that it becomes unreasonable to assume ideality of the compression function in order to prove security at a higher level. Most of the remaining nine candidates are provided with a tight bound for collision and/or preimage resistance of the compression function, merely due to the results of <em>[21, 62]</em>. Single exceptions are BLAKE and BMW, for which the results of <em>[62]</em> are not directly applicable. No security results are known for the second preimage resistance of the nine remaining candidates: albeit collision resistance implies second preimage resistance <em>[59]</em>, the obtained security bounds would be below the requirements of NIST <em>[55]</em>; Nine of the candidates are proven indifferentiable from a random oracle, and six of the candidates have a similar constructions to ones proven indifferentiable. We note that there exist some differences among the bounds. For instance, for the hash function variant outputting <span class="math">n=512</span> bits, the indifferentiability bounds vary between <span class="math">O(Kq^{3}/2^{512})</span> and <span class="math">O((Kq)^{2}/2^{1024})</span>. These differences are mainly caused by the fact that the bounds are parameterized by the internal chaining value size <span class="math">l</span>, rather than the output size <span class="math">n</span> (as is the case for bounds on the collision resistance). As a consequence, a higher state size often</p>

    <p class="text-gray-300">results in a better indifferentiability bound. The indifferentiability results are powerful, as they render bounds on the (second) preimage and collision resistance of the design (Thm. 2); Most of the hash functions are not provided with an optimal security bound on the second preimage resistance. Main cause for this is that the MD design does not preserve second preimage resistance <em>[3]</em>. Additionally, the second preimage bound that can be derived via the indifferentiability (Thm. 2) is not always sufficiently tight. Proving security against these attacks could be attempted either by making a different (possibly weaker) assumption on the compression function or by basing it directly on the ideality of the underlying block cipher or permutation(s). We notice that a fruitful direction might be the graph based approach followed by the designers of Shabal <em>[24]</em>; Except for the sponge(-like) functions, the collision resistance preservation result of Thm. 1 (App. A) applies to all candidates. This theorem results in a bound on the generic collision resistance of the hash function, which, intuitively, means that ‘finding collisions for the hash function is at least as hard as finding collisions for (one of) the underlying function(s)’. Together with the collision resistance bounds on the compression functions in the ideal model, the preservation result allows for obtaining a collision resistance bound on the entire hash function. This leads to optimal bounds on the collision resistance for ECHO, Grøstl, Hamsi, SHAvite-3, SIMD and Skein. For BLAKE, CubeHash, Fugue, JH, Keccak and Shabal, the same optimal bound is obtained differently (e.g. based on the indifferentiability of the hash function). Again, the graph based approach may be suitable to prove collision resistance of the candidates for which no collision resistance bound is yet obtained.</p>

    <p class="text-gray-300">A hash function that is provided with a sound security analysis, is not necessarily a ‘good’ function, nor is it a ‘bad’ function if only little security results are known. The quality of the hash function depends further on other criteria not covered in this classification, such as the strength of the basic underlying primitives and software/hardware performance. Yet, security reductions guarantee that the hash function has no severe structural weaknesses, and in particular that the design does not suffer weaknesses that can be trivially exploited by cryptanalysts. Therefore, we see the provided security analysis as a fair comparison of the SHA-3 candidates and an important contribution to the selection of the finalists. To the best of our knowledge, we included all security results to date. However, we welcome suggestions, remarks or information about provable security results that could improve the quality of this work.</p>

    <h2 id="sec-17" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">This work has been funded in part by the IAP Program P6/26 BCRYPT of the Belgian State (Belgian Science Policy), and in part by the European Commission through the ICT program under contract ICT-2007-216676 ECRYPT II. The first author is supported by a Ph.D. Fellowship from the Flemish Research Foundation (FWO-Vlaanderen). The second author is supported by a Ph.D. Fellowship from the Institute for the Promotion of Innovation through Science and Technology in Flanders (IWT-Vlaanderen). We would like to thank Joan Daemen, Praveen Gauravaram, Charanjit Jutla and Christian Rechberger for the helpful comments.</p>

    <h2 id="sec-18" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Andreeva, E., Mennink, B., Preneel, B.: The parazoa family: Generalizing the sponge hash functions. Cryptology ePrint Archive, Report 2011/028 (2011)</li>

      <li>[2] Andreeva, E., Mennink, B., Preneel, B.: On the indifferentiability of the Grøstl hash function. In: SCN ’10. LNCS, vol. 6280, pp. 88–105. Springer-Verlag, Berlin (2010)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(n,l,m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Advpref</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Advrecf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Advcolf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AdvpreR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AdvrecR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AdvcolR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AdvcolR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AdvproR</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLAKE</td>

            <td class="px-3 py-2 border-b border-gray-700">HAIFA</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 256, 512) or (512, 512, 1024)</td>

            <td class="px-3 py-2 border-b border-gray-700">PGV5-likeE ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PGV5-likeE ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)f ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)f ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolf</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)f ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(Kq2/2n)f ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BMW</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-(MD+FT)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 512, 512) or (512, 1024, 1024)</td>

            <td class="px-3 py-2 border-b border-gray-700">PGV3-likeE ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PGV3-likeE ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)f ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolf+Advgrolchop og</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)f ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">chopHMAC-likef ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CubeHash</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-(MD+FT)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 1024, 256) or (512, 1024, 256)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l-m)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l-m)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">(no preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O((Kq)2/2l-m)P ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECHO</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-HAIFA</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 512, 1536) or (512, 1024, 1024)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2l)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2l)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-HAIFAf ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolchop of</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)E ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">chopMD construction</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fugue</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-(MD+FT)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 960, 32) or (512, 1152, 32)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l-m-n)P, P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l-m-n)P, P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">(no preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)P, P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O((Kq)2/2l-m-n)P, P ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Grostl</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-(MD+FT)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 512, 512) or (512, 1024, 1024)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2l)P, Q ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q4/2l)P, Q ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolf+Advgrolchop og</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)P, Q ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">O((Kq)4/2l)P, Q ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hamsi</td>

            <td class="px-3 py-2 border-b border-gray-700">MD+FT</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 256, 32) or (512, 512, 64)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolf+Advgrolf</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)P, P ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">NMAC-likef, g ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JH</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-MD</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 1024, 512) or (512, 1024, 512)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l-m)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l-m)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">(no preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q3/2l-m+Kq3/2l-n)P ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Keccak</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-MD</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 1600, 1088) or (512, 1600, 576)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">(no preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)P ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ((Kq)2/2l-m)P ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Luffa</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-(MD+FT)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 768, 256) or (512, 1278, 256)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P, ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P, ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(1)P, ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(no preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">sponge-likeP, ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Shabal</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-MD</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 1408, 512) or (512, 1408, 512)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(q2/2l-m)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l-m)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolchop of</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O((Kq)2/2l-m)E ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SHAvite-3</td>

            <td class="px-3 py-2 border-b border-gray-700">HAIFA</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 256, 512) or (512, 512, 1024)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)f ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolf</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)E ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">O((Kq)2/2n)E ideal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMD</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-(MD+FT)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 512, 512) or (512, 1024, 1024)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2l)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2l)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolf+Advgrolchop og</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)E, E ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">chopMD construction</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Skein</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-MD</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">(256, 512, 512) or (512, 512, 512)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2l)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2l)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q/2n)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">O(q/2n+q2/2l)E ideal</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ Advgrolf</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(q2/2n)E ideal (proof by preservation)</td>

            <td class="px-3 py-2 border-b border-gray-700">O((Kq)2/2l)E ideal</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. A schematic summary of all results. The first column describes the hash function construction, and the second and third column show which hash functions have a suffix-free (sf) or prefix-free (pf) padding. The fourth column summarizes the main parameters  <span class="math">n, l, m</span> , which denote the hash function output size, the chaining value size and the message input size, respectively. In the remaining columns, the security bounds are summarized together with the underlying assumptions. A green box indicates the existence of an optimal upper bound, a yellow box indicates the existence of a non-trivial upper bound which is not yet optimal for both the 256 and 512 bits variant. A red box means that an efficient adversary is known for the security notion. We note that for all candidates, a red box does not have any direct consequences for the security of the hash function. All other notions and notations and further explained in Sect. 2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[3] Andreeva, E., Neven, G., Preneel, B., Shrimpton, T.: Seven-property-preserving iterated hashing: ROX. In: ASIACRYPT ’07. LNCS, vol. 4833, pp. 130–146. Springer-Verlag, Berlin (2007)</li>

      <li>[4] Aumasson, J.P.: On the pseudorandomness of Shabal’s keyed permutation (2009)</li>

      <li>[5] Aumasson, J.P.: Practical distinguisher for the compression function of Blue Midnight Wish (2010)</li>

      <li>[6] Aumasson, J.P., Henzen, L., Meier, W., Phan, R.: SHA-3 proposal BLAKE (2009)</li>

      <li>[7] Aumasson, J.P., Mashatan, A., Meier, W.: More on Shabal’s permutation (2009)</li>

      <li>[8] Aumasson, J.P., Phan, R.: On the cryptanalysis of the hash function Fugue: Partitioning and inside-out distinguishers. Inf. Process. Lett. 111(11), 512–515 (2011)</li>

      <li>[9] Bellare, M., Canetti, R., Krawczyk, H.: Keying hash functions for message authentication. In: CRYPTO ’96. LNCS, vol. 1109, pp. 1–15. Springer-Verlag, Berlin (1996)</li>

      <li>[10] Bellare, M., Kohno, T., Lucks, S., Ferguson, N., Schneier, B., Whiting, D., Callas, J., Walker, J.: Provable security support for the skein hash family (2009)</li>

      <li>[11] Benadjila, R., Billet, O., Gilbert, H., Macario-Rat, G., Peyrin, T., Robshaw, M., Seurin, Y.: SHA-3 Proposal: ECHO (2009)</li>

      <li>[12] Bernstein, D.: CubeHash specification (2009)</li>

      <li>[13] Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On the indifferentiability of the sponge construction. In: EUROCRYPT ’08. LNCS, vol. 4965, pp. 181–197. Springer-Verlag, Berlin (2008)</li>

      <li>[14] Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: The KECCAK sponge function family (2009)</li>

      <li>[15] Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Sponge functions (ECRYPT Hash Workshop 2007)</li>

      <li>[16] Bhattacharyya, R., Mandal, A., Nandi, M.: Indifferentiability characterization of hash functions and optimal bounds of popular domain extensions. In: INDOCRYPT ’09. LNCS, vol. 5922, pp. 199–218. Springer-Verlag, Berlin (2009)</li>

      <li>[17] Bhattacharyya, R., Mandal, A., Nandi, M.: Security analysis of the mode of JH hash function. In: FSE ’10. LNCS, vol. 6147, pp. 168–191. Springer-Verlag, Berlin (2010)</li>

      <li>[18] Biham, E., Dunkelman, O.: A framework for iterative hash functions – HAIFA. Cryptology ePrint Archive, Report 2007/278 (2007)</li>

      <li>[19] Biham, E., Dunkelman, O.: The SHAvite-3 Hash Function (2009)</li>

      <li>[20] Black, J., Cochran, M., Shrimpton, T.: On the impossibility of highly-efficient blockcipher-based hash functions. In: EUROCRYPT ’05. LNCS, vol. 3494, pp. 526–541. Springer-Verlag, Berlin (2005)</li>

      <li>[21] Black, J., Rogaway, P., Shrimpton, T.: Black-box analysis of the block-cipher-based hash-function constructions from PGV. In: CRYPTO ’02. LNCS, vol. 2442, pp. 320–335. Springer-Verlag, Berlin (2002)</li>

      <li>[22] Bouillaguet, C., Fouque, P.A., Leurent, G.: Security analysis of SIMD (2010)</li>

      <li>[23] Bouillaguet, C., Fouque, P.A., Shamir, A., Zimmer, S.: Second preimage attacks on dithered hash functions. Cryptology ePrint Archive, Report 2007/395 (2007)</li>

      <li>[24] Bresson, E., Canteaut, A., Chevallier-Mames, B., Clavier, C., Fuhr, T., Gouget, A., Icart, T., Misarsky, J.F., Naya-Plasencia, M., Paillier, P., Pornin, T., Reinhard, J.R., Thuillet, C., Videau, M.: Shabal, a Submission to NIST’s Cryptographic Hash Algorithm Competition (2009)</li>

      <li>[25] Chang, D., Lee, S., Nandi, M., Yung, M.: Indifferentiable security analysis of popular hash functions with prefix-free padding. In: ASIACRYPT ’06. LNCS, vol. 4284, pp. 283–298. Springer-Verlag, Berlin (2006)</li>

      <li>[26] Coron, J.S., Dodis, Y., Malinaud, C., Puniya, P.: Merkle-Damgård revisited: How to construct a hash function. In: CRYPTO ’05. LNCS, vol. 3621, pp. 430–448. Springer-Verlag, Berlin (2005)</li>

      <li>[27] Damgård, I.: A design principle for hash functions. In: CRYPTO ’89. LNCS, vol. 435, pp. 416–427. Springer-Verlag, Berlin (1990)</li>

      <li>[28] De Cannière, C., Sato, H., Watanabe, D.: Hash Function Luffa (2009)</li>

      <li>[29] Dodis, Y., Puniya, P.: Getting the best out of existing hash functions; or what if we are stuck with SHA? In: ACNS ’08. LNCS, vol. 5037, pp. 156–173. Springer-Verlag, Berlin (2008)</li>

      <li>[30] Dodis, Y., Ristenpart, T., Shrimpton, T.: Salvaging merkle-damgård for practical applications. In: EUROCRYPT ’09. LNCS, vol. 5479, pp. 371–388. Springer-Verlag, Berlin (2009)</li>

      <li>[31] Ferguson, N., Lucks, S., Schneier, B., Whiting, D., Bellare, M., Kohno, T., Callas, J., Walker, J.: The Skein Hash Function Family (2009)</li>

      <li>[32] Ferguson, N., Lucks, S., Schneier, B., Whiting, D., Bellare, M., Kohno, T., Callas, J., Walker, J.: Engineering comparison of SHA-3 candidates (2010)</li>

      <li>[33] Fleischmann, E., Forler, C., Gorski, M.: Classification of the SHA-3 candidates. Cryptology ePrint Archive, Report 2008/511 (2008)</li>

      <li>[34] Fouque, P.A., Stern, J., Zimmer, S.: Cryptanalysis of tweaked versions of SMASH and reparation. In: SAC ’08. LNCS, vol. 5381, pp. 136–150. Springer-Verlag, Berlin (2009)</li>

      <li>[35] Gauravaram, P., Bagheri, N.: ECHO compression function is not indifferentiable from a FIL-RO (2010)</li>

      <li>[36] Gauravaram, P., Knudsen, L., Bagheri, N., Wei, L.: Improved security analysis of Fugue-256. In: ACISP 2011. LNCS, vol. 6812, pp. 428–432. Springer-Verlag, Berlin (2011)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[37] Gauravaram, P., Knudsen, L., Matusiewicz, K., Mendel, F., Rechberger, C., Schläffer, M., Thomsen, S.: Grøstl – a SHA-3 candidate (2009)</li>

      <li>[38] Gligoroski, D., Klima, V., Knapskog, S.J., El-Hadedy, M., Amundsen, J., Mjølsnes, S.F.: Cryptographic Hash Function BLUE MIDNIGHT WISH (2009)</li>

      <li>[39] Gong, Z., Lai, X., Chen, K.: A synthetic indifferentiability analysis of some block-cipher-based hash functions. Des. Codes Cryptography 48(3), 293–305 (2008)</li>

      <li>[40] Halevi, S., Hall, W., Jutla, C.: The Hash Function “Fugue” (2009)</li>

      <li>[41] Halevi, S., Krawczyk, H.: Strengthening digital signatures via randomized hashing. In: CRYPTO ’06. LNCS, vol. 4117, pp. 41–59. Springer-Verlag, Berlin (2006)</li>

      <li>[42] Kelsey, J., Schneier, B.: Second preimages on n-bit hash functions for much less than <span class="math">2^{\\rm B}</span> work. In: EUROCRYPT ’05. LNCS, vol. 3494, pp. 474–490. Springer-Verlag, Berlin (2005)</li>

      <li>[43] Khovratovich, D., Naya-Plasencia, M., Röck, A., Schläffer, M.: Cryptanalysis of Luffa v2 components. In: SAC ’10. LNCS, vol. 6544, pp. 388–409. Springer-Verlag, Berlin (2011)</li>

      <li>[44] Knudsen, L., Matusiewicz, K., Thomsen, S.: Observations on the Shabal keyed permutation (2009)</li>

      <li>[45] Kobayashi, K., Ikegami, J., Matsuo, S., Sakiyama, K., Ohta, K.: Evaluation of hardware performance for the SHA-3 candidates using SASEBO-GII. Cryptology ePrint Archive, Report 2010/010 (2010)</li>

      <li>[46] Küçük, Ö.: The Hash Function Hamsi (2009)</li>

      <li>[47] Lai, X., Massey, J.: Hash function based on block ciphers. In: EUROCRYPT ’92. LNCS, vol. 658, pp. 55–70. Springer-Verlag, Berlin (1992)</li>

      <li>[48] Lee, J., Hong, D.: Collision resistance of the JH hash function. Cryptology ePrint Archive, Report 2011/019 (2011)</li>

      <li>[49] Leurent, G., Bouillaguet, C., Fouque, P.A.: SIMD is a Message Digest (2009)</li>

      <li>[50] Lucks, S.: A failure-friendly design principle for hash functions. In: ASIACRYPT ’05. LNCS, vol. 3788, pp. 474–494. Springer-Verlag, Berlin (2005)</li>

      <li>[51] Luo, Y., Gong, Z., Duan, M., Zhu, B., Lai, X.: Revisiting the indifferentiability of PGV hash functions. Cryptology ePrint Archive, Report 2009/265 (2009)</li>

      <li>[52] Maurer, U., Renner, R., Holenstein, C.: Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology. In: TCC ’04. LNCS, vol. 2951, pp. 21–39. Springer-Verlag, Berlin (2004)</li>

      <li>[53] Merkle, R.: One way hash functions and DES. In: CRYPTO ’89. LNCS, vol. 435, pp. 428–446. Springer-Verlag, Berlin (1990)</li>

      <li>[54] Nandi, M.: Characterizing padding rules of MD hash functions preserving collision security. In: ACISP ’09. LNCS, vol. 5594, pp. 171–184. Springer-Verlag, Berlin (2009)</li>

      <li>[55] National Institute for Standards and Technology. Announcing Request for Candidate Algorithm Nominations for a New Cryptographic Hash Algorithm (SHA3) Family (November 2007)</li>

      <li>[56] Novotney, P.: Distinguisher for Shabal’s permutation function. Cryptology ePrint Archive, Report 2010/398 (2010)</li>

      <li>[57] Preneel, B., Govaerts, R., Vandewalle, J.: Hash functions based on block ciphers: A synthetic approach. In: CRYPTO ’93. LNCS, vol. 773, pp. 368–378. Springer-Verlag, Berlin (1993)</li>

      <li>[58] Rogaway, P.: Formalizing human ignorance. In: VIETCRYPT ’06. LNCS, vol. 4341, pp. 211–228. Springer-Verlag, Berlin (2006)</li>

      <li>[59] Rogaway, P., Shrimpton, T.: Cryptographic hash-function basics: Definitions, implications, and separations for preimage resistance, second-preimage resistance, and collision resistance. In: FSE ’04. LNCS, vol. 3017, pp. 371–388. Springer-Verlag, Berlin (2004)</li>

      <li>[60] Rogaway, P., Steinberger, J.: Security/efficiency tradeoffs for permutation-based hashing. In: EUROCRYPT ’08. LNCS, vol. 4965, pp. 220–236. Springer-Verlag, Berlin (2008)</li>

      <li>[61] Stam, M.: Beyond uniformity: Better security/efficiency tradeoffs for compression functions. In: CRYPTO ’08. LNCS, vol. 5157, pp. 397–412. Springer-Verlag, Berlin (2008)</li>

      <li>[62] Stam, M.: Blockcipher-based hashing revisited. In: FSE ’09. LNCS, vol. 5665, pp. 67–83. Springer-Verlag, Berlin (2009)</li>

      <li>[63] Steinberger, J.: Stam’s collision resistance conjecture. In: EUROCRYPT ’10. LNCS, vol. 6110, pp. 597–615. Springer-Verlag, Berlin (2010)</li>

      <li>[64] Tillich, S., Feldhofer, M., Kirschbaum, M., Plos, T., Schmidt, J.M., Szekely, A.: High-speed hardware implementations of BLAKE, Blue Midnight Wish, CubeHash, ECHO, Fugue, Grøstl, Hamsi, JH, Keccak, Luffa, Shabal, SHAvite-3, SIMD, and Skein. Cryptology ePrint Archive, Report 2009/510 (2009)</li>

      <li>[65] Van Assche, G.: A rotational distinguisher on Shabal’s keyed permutation and its impact on the security proofs (2010)</li>

      <li>[66] Wang, X., Yin, Y.L., Yu, H.: Finding collisions in the full SHA-1. In: CRYPTO ’05. LNCS, vol. 3621, pp. 17–36. Springer-Verlag, Berlin (2005)</li>

      <li>[67] Wang, X., Yu, H.: How to break MD5 and other hash functions. In: EUROCRYPT ’05. LNCS, vol. 3494, pp. 19–35. Springer-Verlag, Berlin (2005)</li>

      <li>[68] Wu, H.: The Hash Function JH (2009)</li>

    </ul>

    <p class="text-gray-300">A Preservation of Collision Resistance</p>

    <p class="text-gray-300">For the purpose of the analysis of the SHA-3 candidates, we generalize the well-known result by Merkle and Damgård. The result of Thm. 1 differs in three cases: we consider any suffix-free padding, the proof allows for different compression functions in one hash function evaluation, and it includes an optional chopping at the end. Related work can, a.o., be found in <em>[53, 27, 29, 54]</em>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">l,m,n\\in\\mathbb{N}</span> such that <span class="math">l\\geq n</span>. Let <span class="math">\\mathsf{pad}:\\mathbb{Z}_{2}^{<em>}\\to(\\mathbb{Z}_{2}^{m})^{</em>}</span> be a suffix-free padding and let <span class="math">f,g:\\mathbb{Z}_{2}^{l}\\times\\mathbb{Z}_{2}^{m}\\to\\mathbb{Z}_{2}^{l}</span> be two compression functions. Consider the hash function <span class="math">\\mathcal{H}:\\mathbb{Z}_{2}^{*}\\to\\mathbb{Z}_{2}^{n}</span> defined as follows (cf. Fig. 2), where <span class="math">h_{0}=\\mathsf{IV}</span> is the initialization vector:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}(M)=h</span>, where: <span class="math">(M_{1},\\ldots,M_{k})=\\mathsf{pad}(M),</span> <span class="math">h_{i}=f(h_{i-1},M_{i})\\text{ for }i=1,\\ldots,k-1,</span> <span class="math">h_{k}=g(h_{k-1},M_{k}),</span> <span class="math">h=\\mathsf{chop}_{l-n}(h_{k}).</span></p>

    <p class="text-gray-300">Define the function <span class="math">g^{\\prime}:\\mathbb{Z}_{2}^{l}\\times\\mathbb{Z}_{2}^{m}\\to\\mathbb{Z}_{2}^{n}</span> by <span class="math">g^{\\prime}=\\mathsf{chop}_{l-n}\\circ g</span>. Then, the advantage of finding collisions for <span class="math">\\mathcal{H}</span> is upper bounded by the advantage of finding collisions for <span class="math">f</span> or <span class="math">g^{\\prime}</span>. Formally, if <span class="math">f</span> is <span class="math">(t_{1},\\varepsilon_{1})</span> collision secure, and <span class="math">g^{\\prime}</span> is <span class="math">(t_{2},\\varepsilon_{2})</span> collision secure, then <span class="math">\\mathcal{H}</span> is <span class="math">(t,\\varepsilon)</span> collision secure for <span class="math">\\varepsilon=\\varepsilon_{1}+\\varepsilon_{2}</span>, and <span class="math">t=\\min\\{t_{1},t_{2}\\}-2(K-1)\\tau_{f}</span>, where <span class="math">\\tau_{f}</span> is the time to evaluate <span class="math">f</span> and <span class="math">K</span> is the maximum length of the messages, in blocks.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{A}</span> is a <span class="math">(t,\\varepsilon)</span> collision finding attacker for <span class="math">\\mathcal{H}</span>. We construct collision finding adversaries <span class="math">\\mathcal{B}_{1}</span> and <span class="math">\\mathcal{B}_{2}</span> for <span class="math">f</span> and <span class="math">g</span>, respectively, using the following observation. Let <span class="math">M,M^{\\prime}</span> be two distinct messages such that <span class="math">\\mathcal{H}(M)=\\mathcal{H}(M^{\\prime})</span>. Let <span class="math">(M_{1},\\ldots,M_{k})</span> be the padded message of <span class="math">M</span>, and <span class="math">(M_{1}^{\\prime},\\ldots,M_{k^{\\prime}}^{\\prime})</span> be the padded message of <span class="math">M^{\\prime}</span>. Define the intermediate state values <span class="math">h_{i},h_{i}^{\\prime}</span> similarly. A collision on <span class="math">M,M^{\\prime}</span> means that <span class="math">\\mathsf{chop}_{l-n}\\big{(}g(h_{k-1},M_{k})\\big{)}=\\mathsf{chop}_{l-n}\\big{(}g(h_{k^{\\prime}-1}^{\\prime},M_{k^{\\prime}}^{\\prime})\\big{)}</span>. Now, if <span class="math">(h_{k-1},M_{k})\\neq(h_{k^{\\prime}-1}^{\\prime},M_{k^{\\prime}}^{\\prime})</span> this results in a collision for <span class="math">g^{\\prime}</span>. Assume the contrary, and let <span class="math">j\\in\\{1,\\ldots,\\min\\{k,k^{\\prime}\\}-1\\}</span> be the minimal index such that <span class="math">(h_{k-j-1},M_{k-j})\\neq(h_{k^{\\prime}-j-1}^{\\prime},M_{k^{\\prime}-j}^{\\prime})</span>. We notice that such index <span class="math">j</span> exists: in case <span class="math">k=k^{\\prime}</span> it exists as <span class="math">M\\neq M^{\\prime}</span>, and in case <span class="math">k\\neq k^{\\prime}</span> it exists as the padding rule is suffix-free. By definition of the index <span class="math">j</span>, we have <span class="math">h_{k-j}=h_{k^{\\prime}-j}^{\\prime}</span>, and in particular we obtain a collision for <span class="math">f</span>:</p>

    <p class="text-gray-300"><span class="math">f(h_{k-j-1},M_{k-j})=h_{k-j}=h_{k^{\\prime}-j}^{\\prime}=f(h_{k^{\\prime}-j-1}^{\\prime},M_{k^{\\prime}-j}^{\\prime}).</span></p>

    <p class="text-gray-300">Both <span class="math">\\mathcal{B}_{1},\\mathcal{B}_{2}</span> follow this procedure. If <span class="math">M,M^{\\prime}</span> define a collision for <span class="math">f</span>, <span class="math">\\mathcal{B}_{1}</span> outputs this collision. Similarly for <span class="math">\\mathcal{B}_{2}</span> and <span class="math">g^{\\prime}</span>. Both adversaries work in time at most <span class="math">t+2(K-1)\\tau_{f}</span>, from which we deduce <span class="math">t\\geq\\min\\{t_{1},t_{2}\\}-2(K-1)\\tau_{f}</span>. The messages <span class="math">M,M^{\\prime}</span> define a collision for <span class="math">f</span> or <span class="math">g^{\\prime}</span>. Thus, we obtain <span class="math">\\varepsilon\\leq\\varepsilon_{1}+\\varepsilon_{2}</span>. ∎</p>

    <p class="text-gray-300">In case the design is based on the compression function <span class="math">f</span> only (but it may still include the chopping), the above result can easily be simplified to <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{gcol}}(\\mathcal{A})\\leq\\mathbf{Adv}_{f^{\\prime}}^{\\mathrm{gcol}}(\\mathcal{B}_{1})</span>, where <span class="math">f^{\\prime}</span> is defined by <span class="math">f^{\\prime}=\\mathsf{chop}_{l-n}\\circ f</span>. Observe that this result also holds if <span class="math">l=n</span>, and in particular, the basic theorems of Merkle and Damgård are covered as well. We note that Thm. 1 can be generalized arbitrarily, e.g. to more different compression functions, but for the purpose of this paper, the mentioned generalization of the Merkle-Damgård structure suffices.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 2. A generalized Merkle-Damgård structure.  <span class="math">f, g</span>  are two compression functions, and  <span class="math">\\mathsf{chop}_{l - n}</span>  chops off  <span class="math">l - n</span>  bits of the state.</p>

    <h2 id="sec-21" class="text-2xl font-bold">B Security Implications of Indifferentiability</h2>

    <p class="text-gray-300">Indifferentiability assures that a design is structurally correct, and that it can replace a random oracle without security loss. In particular, it guarantees that, up to a certain degree, the design is secured against any generic attack, like finding preimages, collisions, multicollisions, etc. In Thm. 2, we formally prove a security reduction to derive security against specific attacks from the indifferentability of a hash function. This proof is based on a personal communication with Joan Daemen.</p>

    <p class="text-gray-300">Theorem 2. Let  <span class="math">\\mathcal{H}</span>  be a hash function, built on underlying primitive  <span class="math">\\pi</span> , and  <span class="math">RO</span>  be a random oracle, where  <span class="math">\\mathcal{H}</span>  and  <span class="math">RO</span>  have the same domain and range space. Denote by  <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pro}}(q)</span>  the advantage of distinguishing  <span class="math">(\\mathcal{H}, \\pi)</span>  from  <span class="math">(RO, S)</span> , for some simulator  <span class="math">S</span> , maximized over all distinguishers  <span class="math">\\mathcal{D}</span>  making at most  <span class="math">q</span>  queries. Let atk be a security property of  <span class="math">\\mathcal{H}</span> . Denote by  <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{atk}}(q)</span>  the advantage of breaking  <span class="math">\\mathcal{H}</span>  under atk, maximized over all adversaries  <span class="math">\\mathcal{A}</span>  making at most  <span class="math">q</span>  queries. Then:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {H}} ^ {\\mathrm {a t k}} (q) \\leq \\mathbf {P r} _ {R O} ^ {\\mathrm {a t k}} (q) + \\mathbf {A d v} _ {\\mathcal {H}} ^ {\\mathrm {p r o}} (q), \\tag {1}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{Pr}_{RO}^{\\mathrm{atk}}(q)</span>  denotes the success probability of a generic attack against  <span class="math">\\mathcal{H}</span>  under atk, after at most  <span class="math">q</span>  queries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  <span class="math">\\mathcal{A}</span>  be any  <span class="math">(q,\\varepsilon)</span>  attacker for  <span class="math">\\mathcal{H}</span>  under security notion atk, and assume  <span class="math">\\varepsilon &amp;gt;\\mathbf{Pr}_{RO}^{\\mathrm{atk}}(q)</span> . We define a distinguisher  <span class="math">\\mathcal{D}</span>  for the indifferentability of  <span class="math">\\mathcal{H}</span>  as follows:  <span class="math">\\mathcal{D}</span>  makes the same queries as  <span class="math">\\mathcal{A}</span> , and obtains a query history  <span class="math">Q</span>  (with query answers coming from either  <span class="math">\\mathcal{H}</span>  or  <span class="math">RO</span> ). Next,  <span class="math">\\mathcal{D}</span>  outputs 1 if  <span class="math">Q</span>  violates security notion atk, and 0 otherwise. Denote by  <span class="math">\\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pro}}(\\mathcal{D})</span>  the success probability of  <span class="math">\\mathcal{D}</span> . By definition, we have  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Pr}\\left(\\mathcal{D}^{\\mathcal{H},\\pi} = 1\\right) - \\mathbf{Pr}\\left(\\mathcal{D}^{RO,S} = 1\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pro}}(\\mathcal{D}) \\leq \\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pro}}(q)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By  <span class="math">E_{\\mathcal{H}}</span>  (resp.  <span class="math">E_{RO}</span> ), we denote the event that  <span class="math">Q</span>  defines a set of query pairs that break  <span class="math">\\mathcal{H}</span>  (resp.  <span class="math">RO</span> ) under security notion atk. The distinguisher outputs 1 if and only if  <span class="math">Q</span>  violates security notion atk, and hence we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {P r} \\left(\\mathcal {D} ^ {\\mathcal {H}, \\pi} = 1\\right) = \\mathbf {P r} \\left(\\mathcal {D} ^ {\\mathcal {H}, \\pi} = 1 \\mid E _ {\\mathcal {H}}\\right) \\mathbf {P r} \\left(E _ {\\mathcal {H}}\\right) + \\mathbf {P r} \\left(\\mathcal {D} ^ {\\mathcal {H}, \\pi} = 1 \\mid \\neg E _ {\\mathcal {H}}\\right) \\mathbf {P r} (\\neg E _ {\\mathcal {H}}) \\\\ = 1 \\cdot \\mathbf {P r} \\left(E _ {\\mathcal {H}}\\right) + 0 = \\varepsilon . \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Similarly, we get  <span class="math">\\mathbf{Pr}\\left(\\mathcal{D}^{RO,S} = 1\\right) = \\mathbf{Pr}\\left(E_{RO}\\right) = \\mathbf{Pr}_{RO}^{\\mathrm{atk}}(q)</span> . As  <span class="math">\\varepsilon &amp;gt;\\mathbf{Pr}_{RO}^{\\mathrm{atk}}(q)</span> , we consequently derive  <span class="math">\\varepsilon \\leq \\mathbf{Pr}_{RO}^{\\mathrm{atk}}(q) + \\mathbf{Adv}_{\\mathcal{H}}^{\\mathrm{pro}}(q)</span> . This holds for any  <span class="math">(q,\\varepsilon)</span>  adversary for  <span class="math">\\mathcal{H}</span>  under security notion atk, which completes the proof.</p>

    <h2 id="sec-22" class="text-2xl font-bold">C Padding Rules</h2>

    <p class="text-gray-300">The padding rules of all SHA-3 hash function candidates are summarized. All padding functions output bit strings parsed as sequences of  <span class="math">m</span> -bit blocks, where  <span class="math">m</span>  is the message block length of</p>

    <p class="text-gray-300">the corresponding function. Formally, for each candidate, for  <span class="math">n \\in \\{256, 512\\}</span>  the padding function  <span class="math">\\mathsf{pad} : \\mathbb{Z}_2^<em> \\to (\\mathbb{Z}_2^m)^</em></span>  is defined as follows. For the hash functions BLAKE, ECHO, Shabal, SHAvite-3 and Skein, the complete padding rule of the corresponding hash function is additionally defined by a counter or tweak (as explained in Sect. 3). Particularly, all hash functions employ an injective padding rule.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLAKE:  $\\mathsf{pad}_1(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- t - 2\\bmod m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_t,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BMW:  $\\mathsf{pad}_2(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 65\\bmod m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_{64},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CubeHash:  $\\mathsf{pad}_3(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\bmod m},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ECHO:  $\\mathsf{pad}_4(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{m - 1 - (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 144\\bmod m)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle n\\rangle_{16}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_{128},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fugue:  $\\mathsf{pad}_5(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bmod m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_{64},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Grestl:  $\\mathsf{pad}_6(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 65\\bmod l}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\lceil (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 65) / l\\rceil \\rangle_{64},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hamsi:  $\\mathsf{pad}_7(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\bmod m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_{64},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">JH:  $\\mathsf{pad}_8(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{383 + (-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bmod m)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_{128},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Keccak:  $\\mathsf{pad}_9(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\bmod 8}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle n / 8\\rangle_8\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle m / 8\\rangle_8\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bmod 8)) - 25\\bmod m},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Luffa:  $\\mathsf{pad}_{10}(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{(-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\bmod m) + 256},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Shabal:  $\\mathsf{pad}_{11}(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\bmod m},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SHAvite-3:  $\\mathsf{pad}_{12}(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- t - 17\\bmod m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle n\\rangle_{16},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SIMD:  $\\mathsf{pad}_{13}(M) = M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bmod m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle_m,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Skein <span class="math">^{12}</span> :  $\\mathsf{pad}_{14}(M) = M' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{(-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bmod m) + m}<span class="math"> , where  </span>M' = \\begin{cases} M \\text{ if }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\equiv 0 \\bmod 8, \\\\ M \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 \\bmod 8} \\text{ otherwise.} \\end{cases}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Security Reductions of the Second Round SHA-3 Candidates (2010/381)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/381
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
