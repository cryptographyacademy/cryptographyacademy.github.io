---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/400';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic';
const AUTHORS_HTML = 'Razvan Barbulescu&lt;sup&gt;1&lt;/sup&gt;, Pierrick Gaudry&lt;sup&gt;1&lt;/sup&gt;, Antoine Joux&lt;sup&gt;2,3&lt;/sup&gt;, and Emmanuel Thomé&lt;sup&gt;1&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Razvan Barbulescu&lt;sup&gt;1&lt;/sup&gt;, Pierrick Gaudry&lt;sup&gt;1&lt;/sup&gt;, Antoine Joux&lt;sup&gt;2,3&lt;/sup&gt;, and Emmanuel Thomé&lt;sup&gt;1&lt;/sup&gt;</p>

    <p class="text-gray-300"><span class="math">^{1}</span> Inria, CNRS, University of Lorraine, France <span class="math">^{2}</span> Cryptology Chair, Foundation UPMC – LIP 6, CNRS UMR 7606, Paris, France <span class="math">^{3}</span> Crypto&lt;br/&gt;Experts, Paris, France</p>

    <p class="text-gray-300">Abstract The difficulty of computing discrete logarithms in fields  <span class="math">\\mathbb{F}_{q^k}</span>  depends on the relative sizes of k and q. Until recently all the cases had a sub-exponential complexity of type L(1/3), similar to the factorization problem. In 2013, Joux designed a new algorithm with a complexity of  <span class="math">L(1/4+\\epsilon)</span>  in small characteristic. In the same spirit, we propose in this article another heuristic algorithm that provides a quasi-polynomial complexity when q is of size at most comparable with k. By quasi-polynomial, we mean a runtime of  <span class="math">n^{O(\\log n)}</span>  where n is the bit-size of the input. For larger values of q that stay below the limit  <span class="math">L_{q^k}(1/3)</span> , our algorithm loses its quasi-polynomial nature, but still surpasses the Function Field Sieve.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">1 Introduction</h4>

    <p class="text-gray-300">The discrete logarithm problem (DLP) was first proposed as a hard problem in cryptography in the seminal article of Diffie and Hellman [7]. Since then, together with factorization, it has become one of the two major pillars of public key cryptography. As a consequence, the problem of computing discrete logarithms has attracted a lot of attention. From an exponential algorithm in 1976, the fastest DLP algorithms have been greatly improved during the past 35 years. A first major progress was the realization that the DLP in finite fields can be solved in subexponential time, i.e. L(1/2) where  <span class="math">L_N(\\alpha) = \\exp\\left(O((\\log N)^{\\alpha}(\\log\\log N)^{1-\\alpha})\\right)</span> . The next step further reduced this to a heuristic L(1/3) running time in the full range of finite fields, from fixed characteristic finite fields to prime fields [2,6,11,3,17,18].</p>

    <p class="text-gray-300">Recently, practical and theoretical advances have been made [15,10,16] with an emphasis on small to medium characteristic finite fields and composite degree extensions. The most general and efficient algorithm [16] gives a complexity of L(1/4 + o(1)) when the characteristic is smaller than the square root of the extension degree. Among the ingredients of this approach, we find the use of a very particular representation of the finite field; the use of the so-called <em>systematic</em></p>

    <p class="text-gray-300">equation<a href="#page-1-0">1</a> ; and the use of algebraic resolution of bilinear polynomial systems in the individual logarithm phase.</p>

    <p class="text-gray-300">In this work, we present a new discrete logarithm algorithm, in the same vein as in <a href="#page-15-9">[16]</a> that uses an asymptotically more efficient descent approach. The main result gives a quasi-polynomial heuristic complexity for the DLP in finite fields of small characteristic. By quasi-polynomial, we mean a complexity of type n O(log n) where n is the bit-size of the cardinality of the finite field. Such a complexity is smaller than any L() for &gt; 0. It remains super-polynomial in the size of the input, but offers a major asymptotic improvement compared to L(1/4 + o(1)).</p>

    <p class="text-gray-300">The key features of our algorithm are the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We keep the field representation and the systematic equations of <a href="#page-15-9">[16]</a>.</li>
      <li>The algorithmic building blocks are elementary. In particular, we avoid the use of Gröbner basis algorithms.</li>
      <li>The complexity result relies on three key heuristics: the existence of a polynomial representation of the appropriate form; the fact that the smoothness probabilities of some non-uniformly distributed polynomials are similar to the probabilities for uniformly random polynomials of the same degree; and the linear independence of some finite field elements related to the action of PGL2(Fq).</li>
    </ul>

    <p class="text-gray-300">The heuristics are very close to the ones used in <a href="#page-15-9">[16]</a>. In addition to the arguments in favor of these heuristics already given in <a href="#page-15-9">[16]</a>, we performed some experiments to validate them on practical instances.</p>

    <p class="text-gray-300">Although we insist on the case of finite fields of small characteristic, where quasi-polynomial complexity is obtained, our new algorithm improves the complexity of discrete logarithm computations in a much larger range of finite fields.</p>

    <p class="text-gray-300">More precisely, in finite fields of the form F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; , where q grows as L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (α), the complexity becomes L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (α + o(1)). As a consequence, our algorithm is asymptotically faster than the Function Field Sieve algorithm in almost all the range previously covered by this algorithm. Whenever α &lt; 1/3, our new algorithm offers the smallest complexity. For the limiting case L(1/3, c), the Function Field Sieve remains more efficient for small values of c, and the Number Field Sieve is better for large values of c (see <a href="#page-15-6">[18]</a>).</p>

    <p class="text-gray-300">This article is organized as follows. In Section <a href="#page-2-0">2,</a> we state the main result, and discuss how it can be used to design a complete discrete logarithm algorithm. In Section <a href="#page-3-0">3,</a> we analyze how this result can be interpreted for various types of finite fields, including the important case of fields of small characteristic. Section <a href="#page-5-0">4</a> is devoted to the description of our new algorithm. It relies on heuristics that are discussed in Section <a href="#page-8-0">5,</a> from a theoretical and a practical point of view. Before getting to the conclusion, in Section <a href="#page-13-0">6,</a> we propose a few variants of the algorithm.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt; While the terminology is similar, no parallel is to be made with the systematic equations as defined in early works related to the computation discrete logarithms in F2&lt;sup&gt;n&lt;/sup&gt; , as <a href="#page-15-10">[4]</a>.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;2 Main result</h4>

    <p class="text-gray-300">We start by describing the setting in which our algorithm applies. It is basically the same as in [16]: we need a large enough subfield, and we assume that a sparse representation can be found. This is formalized in the following definition.</p>

    <p class="text-gray-300"><strong>Definition 1</strong> A finite field K admits a sparse medium subfield representation if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>it has a subfield of  <span class="math">q^2</span>  elements for a prime power q, i.e. K is isomorphic to  <span class="math">\\mathbb{F}_{q^{2k}}</span>  with  <span class="math">k \\geq 1</span> ;</li>
      <li>there exist two polynomials  <span class="math">h_0</span>  and  <span class="math">h_1</span>  over  <span class="math">\\mathbb{F}_{q^2}</span>  of small degree, such that  <span class="math">h_1X^q h_0</span>  has a degree k irreducible factor.</li>
    </ul>

    <p class="text-gray-300">In what follows, we will assume that all the fields under consideration admit a sparse medium subfield representation. Furthermore, we assume that the degrees of the polynomials  <span class="math">h_0</span>  and  <span class="math">h_1</span>  are uniformly bounded by a constant  <span class="math">\\delta</span> . Later, we will provide heuristic arguments for the fact that any finite field of the form  <span class="math">\\mathbb{F}_{q^{2k}}</span>  with  <span class="math">k \\leq q+2</span>  admits a sparse medium subfield representation with polynomials  <span class="math">h_0</span>  and  <span class="math">h_1</span>  of degree at most 2. But in fact, for our result to hold, allowing the degrees of  <span class="math">h_0</span>  and  <span class="math">h_1</span>  to be bounded by any constant  <span class="math">\\delta</span>  independent of q and k or even allowing  <span class="math">\\delta</span>  to grow slower than  <span class="math">O(\\log q)</span>  would be sufficient.</p>

    <p class="text-gray-300">In a field in sparse medium subfield representation, elements will always be represented as polynomials of degree less than k with coefficients in  <span class="math">\\mathbb{F}_{q^2}</span> . When we talk about the discrete logarithm of such an element, we implicitly assume that a basis for this discrete logarithm has been chosen, and that we work in a subgroup whose order has no small irreducible factor (we refer to the Pohlig-Hellman algorithm [20] to limit ourselves to this case).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;<strong>Proposition 2</strong> Let  <span class="math">K = \\mathbb{F}_{q^{2k}}</span>  be a finite field that admits a sparse medium subfield representation. Under the heuristics explained below, there exists an algorithm whose complexity is polynomial in q and k and which can be used for the following two tasks.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Given an element of K represented by a polynomial  <span class="math">P \\in \\mathbb{F}_{q^2}[X]</span>  with  <span class="math">2 \\le \\deg P \\le k-1</span> , the algorithm returns an expression of  <span class="math">\\log P(X)</span>  as a linear combination of at most  <span class="math">O(kq^2)</span>  logarithms  <span class="math">\\log P_i(X)</span>  with  <span class="math">\\deg P_i \\le \\lceil \\frac{1}{2} \\deg P \\rceil</span>  and of  <span class="math">\\log h_1(X)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The algorithm returns the logarithm of  <span class="math">h_1(X)</span>  and the logarithms of all the elements of K of the form X + a, for a in  <span class="math">\\mathbb{F}_{q^2}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Before the presentation of the algorithm, which is made in Section 4, we explain how to use it as a building block for a complete discrete logarithm algorithm.</p>

    <p class="text-gray-300">Let P(X) be an element of K for which we want to compute the discrete logarithm. Here P is a polynomial of degree at most k-1 and with coefficients</p>

    <p class="text-gray-300">in F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;2&lt;/sup&gt; . We start by applying the algorithm of Proposition <a href="#page-2-1">2</a> to P. We obtain a relation of the form</p>

    <p class="text-gray-300"><span class="math">$\\log P = e_0 \\log h_1 + \\sum e_i \\log P_i,</span>$</p>

    <p class="text-gray-300">where the sum has at most κq2k terms for a constant κ and the P&lt;sup&gt;i&lt;/sup&gt; 's have degree at most d 2 deg Pe. Then, we apply recursively the algorithm to the P&lt;sup&gt;i&lt;/sup&gt; 's, thus creating a descent procedure where at each step, a given element P is expressed as a product of elements, whose degree is at most half the degree of P (rounded up) and the arity of the descent tree is in O(q &lt;sup&gt;2&lt;/sup&gt;k).</p>

    <p class="text-gray-300">At the end of the process, the logarithm of P is expressed as a linear combination of the logarithms of h&lt;sup&gt;1&lt;/sup&gt; and of the linear polynomials, for which the logarithms are computed with the algorithm in Proposition <a href="#page-2-1">2</a> in its second form.</p>

    <p class="text-gray-300">We are left with the complexity analysis of the descent process. Each internal node of the descent tree corresponds to one application of the algorithm of Proposition <a href="#page-2-1">2,</a> therefore each internal node has a cost which is bounded by a polynomial in q and k. The total cost of the descent is therefore bounded by the number of nodes in the descent tree times a polynomial in q and k. The depth of the descent tree is in O(log k). The number of nodes of the tree is then less than or equal to its arity raised to the power of its depth, which is (q &lt;sup&gt;2&lt;/sup&gt;k) O(log k) . Since any polynomial in q and k is absorbed in the O() notation in the exponent, we obtain the following result.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-1&quot;&gt;&lt;/span&gt;Theorem 3 Let K = F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;k&lt;/sup&gt; be a finite field that admits a sparse medium subfield representation. Assuming the same heuristics as in Proposition <a href="#page-2-1">2,</a> any discrete logarithm in K can be computed in a time bounded by</p>

    <p class="text-gray-300"><span class="math">$\\max(q, k)^{O(\\log k)}</span>$
.</p>

    <h2 id="sec-3" class="text-2xl font-bold">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;3 Consequences for various ranges of parameters</h2>

    <p class="text-gray-300">We now discuss the implications of Theorem <a href="#page-3-1">3</a> depending on the properties of the finite field F&lt;sup&gt;Q&lt;/sup&gt; where we want to compute discrete logarithms in the first place. The complexities will be expressed in terms of log Q, which is the size of the input.</p>

    <p class="text-gray-300">Three cases are considered. In the first one, the finite field admits a sparse medium subfield representation, where q and k are almost equal. This is the optimal case. Then we consider the case where the finite field has small (maybe constant) characteristic. And finally, we consider the case where the characteristic is getting larger so that the only available subfield is a bit too large for the algorithm to have an optimal complexity.</p>

    <p class="text-gray-300">In the following, we always assume that for any field of the form F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;k&lt;/sup&gt; , we can find a sparse medium subfield representation.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">3.1 Case where the field is <span class="math">\\mathbb{F}_{q^{2k}}</span> , with <span class="math">q \\approx k</span></h4>

    <p class="text-gray-300">The finite fields  <span class="math">\\mathbb{F}_Q = \\mathbb{F}_{q^{2k}}</span>  for which q and k are almost equal are tailored for our algorithm. In that case, the complexity of Theorem 3 becomes  <span class="math">q^{O(\\log q)}</span> . Since  <span class="math">Q \\approx q^{2q}</span> , we have  <span class="math">q = (\\log Q)^{O(1)}</span> . This gives an expression of the form  <span class="math">2^{O((\\log \\log Q)^2)}</span> , which is sometimes called quasi-polynomial in complexity theory.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;<strong>Corollary 4</strong> For finite fields of cardinality  <span class="math">Q = q^{2k}</span>  with  <span class="math">q + O(1) \\ge k</span>  and  <span class="math">q = (\\log Q)^{O(1)}</span> , there exists a heuristic algorithm for computing discrete logarithms in quasi-polynomial time</p>

    <p class="text-gray-300"><span class="math">$2^{O((\\log \\log Q)^2)}</span>$</p>

    <p class="text-gray-300">We mention a few cases which are almost directly covered by Corollary 4. First, we consider the case where  <span class="math">Q = p^n</span>  with p a prime bounded by  <span class="math">(\\log Q)^{O(1)}</span> , and yet large enough so that  <span class="math">n \\leq (p + \\delta)</span> . In this case  <span class="math">\\mathbb{F}_Q</span> , or possibly  <span class="math">\\mathbb{F}_{Q^2}</span>  if n is odd, can be represented in such a way that Corollary 4 applies.</p>

    <p class="text-gray-300">Much the same can be said in the case where n is composite and factors nicely, so that  <span class="math">\\mathbb{F}_Q</span>  admits a large enough subfield  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">q = p^m</span> . This can be used to solve certain discrete logarithms in, say,  <span class="math">\\mathbb{F}_{2^n}</span>  for adequately chosen n (much similar to records tackled by [12,8,13,9,14]).</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">3.2 Case where the characteristic is polynomial in the input size</h4>

    <p class="text-gray-300">Let now  <span class="math">\\mathbb{F}_Q</span>  be a finite field whose characteristic p is bounded by  <span class="math">(\\log Q)^{O(1)}</span> , and let  <span class="math">n = \\log Q/\\log p</span> , so that  <span class="math">Q = p^n</span> . While we have seen that Corollary 4 can be used to treat some cases, its applicability might be hindered by the absence of an appropriately sized subfield: p might be as small as 2, and n might not factor adequately. In those cases, we use the same strategy as in [16] and embed the discrete logarithm problem in  <span class="math">\\mathbb{F}_Q</span>  into a discrete logarithm problem in a larger field.</p>

    <p class="text-gray-300">Let k be n if n is odd and n/2 if n is even. Then, we set  <span class="math">q = p^{\\lceil \\log_p k \\rceil}</span> , and we work in the field  <span class="math">\\mathbb{F}_{q^{2k}}</span> . By construction this field contains  <span class="math">\\mathbb{F}_Q</span>  (because p|q and n|2k) and it is in the range of applicability of Theorem 3. Therefore, one can solve a discrete logarithm problem in  <span class="math">\\mathbb{F}_Q</span>  in time  <span class="math">\\max(q,k)^{O(\\log k)}</span> . Rewriting this complexity in terms of Q, we get  <span class="math">\\log_p(Q)^{O(\\log\\log Q)}</span> . And finally, we get a similar complexity result as in the previous case. Of course, since we had to embed in a larger field, the constant hidden in the O() is larger than for Corollary 4.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-1&quot;&gt;&lt;/span&gt;<strong>Corollary 5</strong> For finite fields of cardinality Q and characteristic bounded by  <span class="math">\\log(Q)^{O(1)}</span> , there exists a heuristic algorithm for computing discrete logarithms in quasi-polynomial time</p>

    <p class="text-gray-300"><span class="math">$2^{O((\\log\\log Q)^2)}</span>$
.</p>

    <p class="text-gray-300">We emphasize that the case  <span class="math">\\mathbb{F}_{2^n}</span>  for a prime n corresponds to this case. A direct consequence of Corollary 5 is that discrete logarithms in  <span class="math">\\mathbb{F}_{2^n}</span>  can be computed in quasi-polynomial time  <span class="math">2^{O((\\log n)^2)}</span> .</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">3.3 Case where <span class="math">q = L_{q^{2k}}(\\alpha)</span></h4>

    <p class="text-gray-300">If the characteristic of the base field is not so small compared to the extension degree, the complexity of our algorithm does not keep its nice quasi-polynomial form. However, in almost the whole range of applicability of the Function Field Sieve algorithm, our algorithm is asymptotically better than FFS.</p>

    <p class="text-gray-300">We consider here finite fields that can be put into the form  <span class="math">\\mathbb{F}_Q = \\mathbb{F}_{q^{2k}}</span> , where q grows not faster than an expression of the form  <span class="math">L_Q(\\alpha)</span> . In the following, we assume that there is equality, which is of course the worst case. The condition can then be rewritten as  <span class="math">\\log q = O((\\log Q)^{\\alpha}(\\log \\log Q)^{1-\\alpha})</span>  and therefore  <span class="math">k = \\log Q/\\log q = O((\\log Q/\\log\\log Q)^{1-\\alpha})</span> . In particular we have  <span class="math">k \\leq q + \\delta</span> , so that Theorem 3 can be applied and gives a complexity of  <span class="math">q^{O(\\log k)}</span> . This yields the following result.</p>

    <p class="text-gray-300">Corollary 6 For finite fields of the form  <span class="math">\\mathbb{F}_Q = \\mathbb{F}_{q^{2k}}</span>  where q is bounded by  <span class="math">L_Q(\\alpha)</span> , there exists a heuristic algorithm for computing discrete logarithms in subexponential time</p>

    <p class="text-gray-300"><span class="math">$L_O(\\alpha)^{O(\\log \\log Q)}</span>$
.</p>

    <p class="text-gray-300">This complexity is smaller than  <span class="math">L_Q(\\alpha&#x27;)</span>  for any  <span class="math">\\alpha&#x27; &gt; \\alpha</span> . Hence, for any  <span class="math">\\alpha &lt; 1/3</span> , our algorithm is faster than the best previously known algorithm, namely FFS and its variants.</p>

    <h2 id="sec-7" class="text-2xl font-bold">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;4 Main algorithm: proof of Proposition 2</h2>

    <p class="text-gray-300">The algorithm is essentially the same for proving the two points of Proposition 2. The strategy is to find relations between the given polynomial P(X) and its translates by a constant in  <span class="math">\\mathbb{F}_{q^2}</span> . Let D be the degree of P(X), that we assume to be at least 1 and at most k-1.</p>

    <p class="text-gray-300">The key to find relations is the <em>systematic equation</em>:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-1&quot;&gt;&lt;/span&gt;
<span class="math">$X^{q} - X = \\prod_{a \\in \\mathbb{F}_{q}} (X - a). \\tag{1}</span>$</p>

    <p class="text-gray-300">We like to view Equation (1) as involving the projective line  <span class="math">\\mathbb{P}^1(\\mathbb{F}_q)</span> . Let  <span class="math">\\mathcal{S} = \\{(\\alpha, \\beta)\\}</span>  be a set of representatives of the q+1 points  <span class="math">(\\alpha : \\beta) \\in \\mathbb{P}^1(\\mathbb{F}_q)</span> , chosen adequately so that the following equality holds.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-2&quot;&gt;&lt;/span&gt;
<span class="math">$X^{q}Y - XY^{q} = \\prod_{(\\alpha,\\beta)\\in\\mathcal{S}} (\\beta X - \\alpha Y). \\tag{2}</span>$</p>

    <p class="text-gray-300">To make translates of P(X) appear, we consider the action of homographies. Any matrix  <span class="math">m = \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix}</span>  acts on P(X) with the following formula:</p>

    <p class="text-gray-300"><span class="math">$m \\cdot P = \\frac{aP + b}{cP + d}.</span>$</p>

    <p class="text-gray-300">In the following, this action will become trivial if the matrix m has entries that are defined over  <span class="math">\\mathbb{F}_q</span> . This is also the case if m is non-invertible. Finally, it is clear that multiplying all the entries of m by a non-zero constant does not change its action on P(X). Therefore the matrices of the homographies that we consider are going to be taken in the following set of cosets:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathcal{P}_q = \\operatorname{PGL}(\\mathbb{F}_{q^2})/\\operatorname{PGL}(\\mathbb{F}_q).</span>$</p>

    <p class="text-gray-300">(Note that in general  <span class="math">\\operatorname{PGL}_2(\\mathbb{F}_q)</span>  is not a normal subgroup of  <span class="math">\\operatorname{PGL}_2(\\mathbb{F}_{q^2})</span> , so that  <span class="math">\\mathcal{P}_q</span>  is not a quotient group.)</p>

    <p class="text-gray-300">To each element  <span class="math">m = \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\in \\mathcal{P}_q</span> , we associate the equation  <span class="math">(E_m)</span>  obtained by substituting aP + b and cP + d in place of X and Y in Equation (2).</p>

    <p class="text-gray-300"><span class="math">$(aP+b)^{q}(cP+d) - (aP+b)(cP+d)^{q} = \\prod_{(\\alpha,\\beta)\\in\\mathcal{S}} \\beta(aP+b) - \\alpha(cP+d)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\prod_{(\\alpha,\\beta)\\in\\mathcal{S}} (-c\\alpha + a\\beta)P - (d\\alpha - b\\beta)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\lambda \\prod_{(\\alpha,\\beta)\\in\\mathcal{S}} P - \\mathbf{x}(m^{-1} \\cdot (\\alpha : \\beta)).</span>$</p>

    <p class="text-gray-300">This sequence of formulae calls for a short comment because of an abuse of notation in the last expression. First,  <span class="math">\\lambda</span>  is the constant in  <span class="math">\\mathbb{F}_{q^2}</span>  which makes the leading terms of the two sides match. Then, the term  <span class="math">P - \\mathbf{x}(m^{-1} \\cdot (\\alpha : \\beta))</span>  denotes P - u when  <span class="math">m^{-1} \\cdot (\\alpha : \\beta) = (u : 1)</span>  (whence we have  <span class="math">u = \\frac{d\\alpha - b\\beta}{-c\\alpha + a\\beta}</span> ), or 1 if  <span class="math">m^{-1} \\cdot (\\alpha : \\beta) = \\infty</span> . The latter may occur since when a/c is in  <span class="math">\\mathbb{F}_q</span> , the expression  <span class="math">-c\\alpha + a\\beta</span>  vanishes for a point  <span class="math">(\\alpha : \\beta) \\in \\mathbb{P}^1(\\mathbb{F}_q)</span>  so that one of the factors of the product contains no term in P(X).</p>

    <p class="text-gray-300">Hence the right-hand side of Equation  <span class="math">(E_m)</span>  is, up to a multiplicative constant, a product of q+1 or q translates of the target P(X) by elements of  <span class="math">\\mathbb{F}_{q^2}</span> . The equation obtained is actually related to the set of points  <span class="math">m^{-1} \\cdot \\mathbb{P}^1(\\mathbb{F}_q) \\subset \\mathbb{P}^1(\\mathbb{F}_{q^2})</span> .</p>

    <p class="text-gray-300">The polynomial on the left-hand side of  <span class="math">(E_m)</span>  can be rewritten as a smaller degree equivalent. For this, we use the special form of the defining polynomial: in K we have  <span class="math">X^q \\equiv \\frac{h_0(X)}{h_1(X)}</span> . Let us denote by  <span class="math">\\tilde{a}</span>  the element  <span class="math">a^q</span>  when a is any element of  <span class="math">\\mathbb{F}_{q^2}</span> . Furthermore, we write  <span class="math">\\tilde{P}(X)</span>  the polynomial P(X) with all its coefficients raised to the power q. The left-hand side of  <span class="math">(E_m)</span>  is</p>

    <p class="text-gray-300"><span class="math">$(\\tilde{a}\\tilde{P}(X^q)+\\tilde{b})(cP(X)+d)-(aP(X)+b)(\\tilde{c}\\tilde{P}(X^q)+\\tilde{d})</span>$</p>

    <p class="text-gray-300">and using the defining equation for the field K, it is congruent to</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{L}_m := \\left( \\tilde{a} \\tilde{P} \\left( \\frac{h_0(X)}{h_1(X)} \\right) + \\tilde{b} \\right) (cP(X) + d) - (aP(X) + b) \\left( \\tilde{c} \\tilde{P} \\left( \\frac{h_0(X)}{h_1(X)} \\right) + \\tilde{d} \\right).</span>$</p>

    <p class="text-gray-300">The denominator of  <span class="math">\\mathcal{L}_m</span>  is a power of  <span class="math">h_1</span>  and its numerator has degree at most  <span class="math">(1+\\delta)D</span>  where  <span class="math">\\delta = \\max(\\deg h_0, \\deg h_1)</span> . We say that  <span class="math">m \\in \\mathcal{P}_q</span>  yields a relation if this numerator of  <span class="math">\\mathcal{L}_m</span>  is  <span class="math">\\lceil D/2 \\rceil</span> -smooth.</p>

    <p class="text-gray-300">To any  <span class="math">m \\in \\mathcal{P}_q</span> , we associate a row vector v(m) of dimension  <span class="math">q^2 + 1</span>  in the following way. Coordinates are indexed by  <span class="math">\\mu \\in \\mathbb{P}^1(\\mathbb{F}_{q^2})</span> , and the value associated to  <span class="math">\\mu \\in \\mathbb{F}_{q^2}</span>  is 1 or 0 depending on whether  <span class="math">P - \\mathbf{x}(\\mu)</span>  appears in the right-hand side of Equation  <span class="math">(E_m)</span> . Note that exactly q + 1 coordinates are 1 for each m. Equivalently, we may write</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-2&quot;&gt;&lt;/span&gt;
<span class="math">$v(m)_{\\mu \\in \\mathbb{P}^1(\\mathbb{F}_{q^2})} = \\begin{cases} 1 \\text{ if } \\mu = m^{-1} \\cdot (\\alpha : \\beta) \\text{ with } (\\alpha : \\beta) \\in \\mathbb{P}^1(\\mathbb{F}_q), \\\\ 0 \\text{ otherwise.} \\end{cases}</span>$
(3)</p>

    <p class="text-gray-300">We associate to the polynomial P a matrix H(P) whose rows are the vectors v(m) for which m yields a relation, taking at most one matrix m in each coset of  <span class="math">\\mathcal{P}_q</span> . The validity of Proposition 2 crucially relies on the following heuristic.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-1&quot;&gt;&lt;/span&gt;<strong>Heuristic 7</strong> For any P(X), the set of rows v(m) for cosets  <span class="math">m \\in \\mathcal{P}_q</span>  that yield a relation form a matrix which has full rank  <span class="math">q^2 + 1</span> .</p>

    <p class="text-gray-300">As we will note in Section 5, the matrix H(P) is heuristically expected to have  <span class="math">\\Theta(q^3)</span>  rows, where the implicit constant depends on  <span class="math">\\delta</span> . This means that for our decomposition procedure to work, we rely on the fact that q is large enough (otherwise H(P) may have less than  <span class="math">q^2 + 1</span>  rows, which precludes the possibility that it have rank  <span class="math">q^2 + 1</span> ).</p>

    <p class="text-gray-300">The first point of Proposition 2, where we descend a polynomial P(X) of degree D at least 2, follows by linear algebra on this matrix. Since we assume that the matrix has full rank, then the vector  <span class="math">(\\ldots,0,1,0,\\ldots)</span>  with 1 corresponding to P(X) can be written as a linear combination of the rows. When doing this linear combination on the equations  <span class="math">(E_m)</span>  corresponding to P we write  <span class="math">\\log P(X)</span>  as a linear combination of  <span class="math">\\log P_i</span>  where  <span class="math">P_i(x)</span>  are the elements occurring in the left-hand sides of the equations. Since there are  <span class="math">O(q^2)</span>  columns, the elimination process involves at most  <span class="math">O(q^2)</span>  rows, and since each row corresponds to an equation  <span class="math">(E_m)</span> , it involves at most  <span class="math">\\deg \\mathcal{L}_m \\leq (1+\\delta)D</span>  polynomials in the left-hand-side&lt;sup&gt;2&lt;/sup&gt;. In total, the polynomial D is expressed by a linear combination of at most  <span class="math">O(q^2D)</span>  polynomials of degree less than  <span class="math">\\lceil D/2 \\rceil</span> . The logarithm of  <span class="math">h_1(X)</span>  is also involved, as a denominator of  <span class="math">\\mathcal{L}_m</span> . We have not made precise the constant in  <span class="math">\\mathbb{F}_{q^2}^*</span>  which occurs to take care of the leading coefficients. Since discrete logarithms in  <span class="math">\\mathbb{F}_{q^2}^*</span>  can certainly be computed in polynomial time in q, this is not a problem.</p>

    <p class="text-gray-300">Since the order of  <span class="math">\\operatorname{PGL}_2(\\mathbb{F}_{q^i})</span>  is  <span class="math">q^{3i}-q^i</span> , the set of cosets  <span class="math">\\mathcal{P}_q</span>  has  <span class="math">q^3+q</span>  elements. For each  <span class="math">m \\in \\mathcal{P}_q</span> , testing whether  <span class="math">(E_m)</span>  yields a relation amounts to some polynomial manipulations and a smoothness test. All of them can be done</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;2&lt;/sup&gt; This estimate of the number of irreducible factors is a pessimistic upper bound. In practice, one expects to have only  <span class="math">O(\\log D)</span>  factors on average. Since the crude estimate does not change the overall complexity, we keep it that way to avoid adding another heuristic.</p>

    <p class="text-gray-300">in polynomial time in q and the degree of P(X) which is bounded by k. Finally, the linear algebra step can be done in  <span class="math">O(q^{2\\omega})</span>  using asymptotically fast matrix multiplication algorithms, or alternatively  <span class="math">O(q^5)</span>  operations using sparse matrix techniques. Indeed, we have q+1 non-zero entries per row and a size of  <span class="math">q^2+1</span> . Therefore, the overall cost is polynomial in q and k as claimed.</p>

    <p class="text-gray-300">For the second part of Proposition 2 we replace P by X during the construction of the matrix. In that case, both sides of the equations  <span class="math">(E_m)</span>  involve only linear polynomials. Hence we obtain a linear system whose unknowns are  <span class="math">\\log(X+a)</span>  with  <span class="math">a \\in \\mathbb{F}_{q^2}</span> . Since Heuristic 7 would give us only the full rank of the system corresponding to the right-hand sides of the equations  <span class="math">(E_m)</span> , we have to rely on a specific heuristic for this step:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-2&quot;&gt;&lt;/span&gt;<strong>Heuristic 8</strong> The linear system constructed from all the equations  <span class="math">(E_m)</span>  for P(X) = X has full rank.</p>

    <p class="text-gray-300">Assuming that this heuristic holds, we can solve the linear system and obtain the discrete logarithms of the linear polynomials and of  <span class="math">h_1(X)</span> .</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;5 Supporting the heuristic argument in the proof</h3>

    <p class="text-gray-300">For Heuristic 7, we propose two approaches to support this heuristic. Both allow to gain some confidence in the validity of the heuristic, but of course none affect the heuristic nature of this statement.</p>

    <p class="text-gray-300">For the first line of justification, we denote by  <span class="math">\\mathcal{H}</span>  the matrix of all the  <span class="math">\\#\\mathcal{P}_q = q^3 + q</span>  vectors v(m) defined as in Equation (3). Associated to a polynomial P, Section 4 defines the matrix H(P) formed of the rows v(m) such that the numerator of  <span class="math">\\mathcal{L}_m</span>  is smooth. We will give heuristics that H(P) has  <span class="math">\\Theta(q^3)</span>  rows and then prove that  <span class="math">\\mathcal{H}</span>  has rank  <span class="math">q^2 + 1</span> , which of course does not prove that its submatrix H(P) has full rank.</p>

    <p class="text-gray-300">In order to estimate the number of rows of H(P) we assume that the numerator of  <span class="math">\\mathcal{L}_m</span>  has the same probability to be  <span class="math">\\lceil \\frac{D}{2} \\rceil</span> -smooth as a random polynomial of same degree. In this paragraph, we assume that the degrees of  <span class="math">h_0</span>  and  <span class="math">h_1</span>  are bounded by 2, merely to avoid awkward notations; the result holds for any constant bound  <span class="math">\\delta</span> . The degree of the numerator of  <span class="math">\\mathcal{L}_m</span>  is then bounded by 3D, so we have to estimate the probability that a polynomial in  <span class="math">\\mathbb{F}_{q^2}[X]</span>  of degree 3D is  <span class="math">\\lceil \\frac{D}{2} \\rceil</span> -smooth. For any prime power q and integers  <span class="math">1 \\leq m \\leq n</span> , we denote by  <span class="math">N_q(m,n)</span>  the number of m-smooth monic polynomials of degree n. Using analytic methods, Panario et al. gave a precise estimate of this quantity (Theorem 1 of [19]):</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-1&quot;&gt;&lt;/span&gt;
<span class="math">$N_q(n,m) = q^n \\rho\\left(\\frac{n}{m}\\right) \\left(1 + O\\left(\\frac{\\log n}{m}\\right)\\right),\\tag{4}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\rho</span>  is Dickman's function defined as the unique continuous function such that  <span class="math">\\rho(u) = 1</span>  on [0,1] and  <span class="math">u\\rho&#x27;(u) = \\rho(u-1)</span>  for u &gt; 1. We stress that the constant  <span class="math">\\kappa</span>  hidden in the O() notation is independent of q. In our case, we are interested in the value of  <span class="math">N_{q^2}(3D, \\lceil \\frac{D}{2} \\rceil)</span> . Let us call  <span class="math">D_0</span>  the least integer such</p>

    <p class="text-gray-300">that  <span class="math">1 + \\kappa\\left(\\frac{\\log(3D)}{\\lceil D/2 \\rceil}\\right)</span>  is at least 1/2. For  <span class="math">D &gt; D_0</span> , we will use the formula (4); and for  <span class="math">D \\le D_0</span> , we will use the crude estimate  <span class="math">N_q(n,m) \\ge N_q(n,1) = q^n/n!</span> . Hence the smoothness probability of  <span class="math">\\mathcal{L}_m</span>  is at least min  <span class="math">\\left(\\frac{1}{2}\\rho(6), 1/(3D_0)!\\right)</span> .</p>

    <p class="text-gray-300">More generally, if deg  <span class="math">h_0</span>  and deg  <span class="math">h_1</span>  are bounded by a constant  <span class="math">\\delta</span>  then we have a smoothness probability of  <span class="math">\\rho(2\\delta+2)</span>  times an absolute constant. Since we have  <span class="math">q^3+q</span>  candidates and a constant probability of success, H(P) has  <span class="math">\\Theta(q^3)</span>  rows.</p>

    <p class="text-gray-300">Now, unless some theoretical obstruction occurs, we expect a matrix over  <span class="math">\\mathbb{F}_{\\ell}</span>  to have full rank with probability at least  <span class="math">1-\\frac{1}{\\ell}</span> . The matrix  <span class="math">\\mathcal{H}</span>  is however peculiar, and does enjoy regularity properties which are worth noticing. For instance, we have the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 9</strong> Let  <span class="math">\\ell</span>  be a prime not dividing  <span class="math">q^3 - q</span> . Then the matrix  <span class="math">\\mathcal{H}</span>  over  <span class="math">\\mathbb{F}_{\\ell}</span>  has full rank  <span class="math">q^2 + 1</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We may obtain this result in two ways. First,  <span class="math">\\mathcal{H}</span>  is the incidence matrix of a  <span class="math">3 - (q^2 + 1, q + 1, 1)</span>  combinatorial design called <em>inversive plane</em> (see e.g. [21, Theorem 9.27]). As such we obtain the identity</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathcal{H}^T \\mathcal{H} = (q+1)(J_{q^2+1} - (1-q)I_{q^2+1})</span>$</p>

    <p class="text-gray-300">(see [21, Theorem 1.13 and Corollary 9.6]), where  <span class="math">J_n</span>  is the  <span class="math">n \\times n</span>  matrix with all entries equal to one, and  <span class="math">I_n</span>  is the  <span class="math">n \\times n</span>  identity matrix. This readily gives the result exactly as announced.</p>

    <p class="text-gray-300">We also provide an elementary proof of the Proposition. We have a bijection between rows of  <span class="math">\\mathcal{H}</span>  and the different possible image sets of the projective line  <span class="math">\\mathbb{P}^1(\\mathbb{F}_q)</span>  within  <span class="math">\\mathbb{P}^1(\\mathbb{F}_{q^2})</span> , under injections of the form  <span class="math">(\\alpha : \\beta) \\mapsto m^{-1} \\cdot (\\alpha : \\beta)</span> . All these  <span class="math">q^3 + q</span>  image sets have size q + 1, and by symmetry all points of  <span class="math">\\mathbb{P}^1(\\mathbb{F}_{q^2})</span>  are reached equally often. Therefore, the sum of all rows of  <span class="math">\\mathcal{H}</span>  is the vector whose coordinates are all equal to  <span class="math">\\frac{1}{1+q^2}(q^3+q)(q+1)=q^2+q</span> .</p>

    <p class="text-gray-300">Let us now consider the sum of the rows in  <span class="math">\\mathcal{H}</span>  whose first coordinate is 1 (as we have just shown, we have  <span class="math">q^2+q</span>  such rows). Those correspond to image sets of  <span class="math">\\mathbb{P}^1(\\mathbb{F}_q)</span>  which contain one particular point, say (0:1). The value of the sum for any other coordinate indexed by e.g.  <span class="math">Q\\in\\mathbb{P}^1(\\mathbb{F}_{q^2})</span>  is the number of image sets  <span class="math">m^{-1}\\cdot\\mathbb{P}^1(\\mathbb{F}_q)</span>  which contain both (0:1) and Q, which we prove is equal to q+1 as follows. Without loss of generality, we may assume  <span class="math">Q=\\infty=(1:0)</span> . We need to count the relevant homographies  <span class="math">m^{-1}\\in\\mathrm{PGL}_2(\\mathbb{F}_{q^2})</span> , modulo  <span class="math">\\mathrm{PGL}_2(\\mathbb{F}_q)</span> -equivalence  <span class="math">m\\equiv hm</span> . By  <span class="math">\\mathrm{PGL}_2(\\mathbb{F}_q)</span> -equivalence, we may without loss of generality assume that  <span class="math">m^{-1}</span>  fixes (0:1) and (1:0). Letting  <span class="math">m^{-1}=\\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix}</span> , we obtain (b:d)=(0:1) and (a:c)=(1:0), whence b=c=0, and both  <span class="math">a,d\\neq 0</span> . We may normalize to d=1, and notice that multiplication of a by a scalar in  <span class="math">\\mathbb{F}_q^*</span>  is absorbed in  <span class="math">\\mathrm{PGL}_2(\\mathbb{F}_q)</span> -equivalence. Therefore the number of suitable m is  <span class="math">\\#\\mathbb{F}_{q^2}^*/\\mathbb{F}_q^*=q+1</span> .</p>

    <p class="text-gray-300">These two facts show that the row span of  <span class="math">\\mathcal{H}</span>  contains the vectors  <span class="math">(q^2 + q, \\ldots, q^2 + q)</span>  and  <span class="math">(q^2 + q, q + 1, \\ldots, q + 1)</span> . The vector  <span class="math">(q^3 - q, 0, \\ldots, 0)</span>  is obtained</p>

    <p class="text-gray-300">as a linear combination of these two vectors, which suffices to prove that H has full rank, since the same reasoning holds for any coordinate.</p>

    <p class="text-gray-300">ut</p>

    <p class="text-gray-300">Proposition <a href="#page-9-0">9,</a> while encouraging, is clearly not sufficient. We are, at the moment, unable to provide a proof of a more useful statement. On the experimental side, it is reasonably easy to sample arbitrary subsets of the rows of H and check for their rank. To this end, we propose the following experiment. We have considered small values of q in the range [16, . . . , 64], and made 50 random picks of subsets S&lt;sup&gt;i&lt;/sup&gt; ⊂ Pq, all of size exactly q &lt;sup&gt;2&lt;/sup&gt; + 1. For each we considered the matrix of the corresponding linear system, which is made of selected rows of the matrix H, and computed its determinant δ&lt;sup&gt;i&lt;/sup&gt; . For all values of q considered, we have observed the following facts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First, all square matrices considered had full rank over Z. Furthermore, their determinants had no common factor apart possibly from those appearing in the factorization of q &lt;sup&gt;3&lt;/sup&gt; − q as predicted by Proposition <a href="#page-9-0">9.</a> In fact, experimentally it seems that only the factors of q + 1 are causing problems.</li>
      <li>We also explored the possibility that modulo some primes, the determinant could vanish with non-negligible probability. We thus computed the pairwise GCD of all 50 determinants computed, for each q. Again, the only prime factors appearing in the GCDs were either originating from the factorization of q &lt;sup&gt;3&lt;/sup&gt; − q, or sporadically from the birthday paradox.</li>
    </ul>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">q #trials in gcd({δi}) in gcd(δi, δj</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">q #trials in gcd({δi}) in gcd(δi, δj&lt;br&gt;)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">691</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2879</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">431, 691</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3, 7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1327</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1303, 3209</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3, 11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5, 13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;none above q</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;Table1. Prime factors appearing in determinant of random square submatrices of H (for one given set of random trials)</p>

    <p class="text-gray-300">These results are summarized in table <a href="#page-10-0">1,</a> where the last column omits small prime factors below q 2 . Of course, we remark that considering square submatrices is a more demanding check than what Heuristic <a href="#page-7-1">7</a> suggests, since our algorithm only needs a slightly larger matrix of size Θ(q 3 ) × (q &lt;sup&gt;2&lt;/sup&gt; + 1) to have full rank.</p>

    <p class="text-gray-300">A second line of justification is more direct and natural, as it is possible to implement the algorithm outlined in Section <a href="#page-5-0">4,</a> and verify that it does provide the desired result. A Magma implementation validates this claim, and has been used to implement descent steps for an example field of degree 53 over  <span class="math">\\mathbb{F}_{53^2}</span> . An example step in this context is given for applying our algorithm to a polynomial of degree 10, attempting to reduce it to polynomials of degree 6 or less. Among the 148,930 elements of  <span class="math">\\mathcal{P}_q</span> , it sufficed to consider only 71,944 matrices m, of which about 3.9% led to relations, for a minimum sufficient number of relations equal to  <span class="math">q^2+1=2810</span>  (as more than half of the elements of  <span class="math">\\mathcal{P}_q</span>  had not even been examined at this point, it is clear that getting more relations was easy—we did not have to). As the defining polynomial for the finite field considered was constructed with  <span class="math">\\delta=\\deg h_{0,1}=1</span> , all left-hand sides involved had degree 20. The polynomials appearing in their factorizations had the following degrees (the number in brackets give the number of distinct polynomials found for each degree): 1(2098), 2(2652), 3(2552), 4(2463), 5(2546), 6(2683). Of course this tiny example size uses no optimization, and is only intended to check the validity of Proposition 2.</p>

    <p class="text-gray-300">As for Heuristic 8, it is already present in [16] and [10], so this is not a new heuristic. Just like for Heuristic 7, it is based on the fact that the probability that a left-hand side is 1-smooth and yields a relation is constant. Therefore, we have a system with  <span class="math">\\Theta(q^3)</span>  relations between  <span class="math">O(q^2)</span>  indeterminates, and it seems reasonable to expect that it has full rank. On the other hand, there is not as much algebraic structure in the linear system as in Heuristic 7, so that we see no way to support this heuristic apart from testing it on several inputs. This was already done (including for record computations) in [16] and [10], so we do not elaborate on our own experiments that confirm again that Heuristic 8 seems to be valid except for tiny values of q.</p>

    <p class="text-gray-300">An obstruction to the heuristics. As noted by Cheng, Wan and Zhuang [5], the irreducible factors of  <span class="math">h_1X^q - h_0</span>  other than the degree k factor that is used to define  <span class="math">\\mathbb{F}_{q^{2k}}</span>  are problematic. Let P be such a problematic polynomial. The fact that it divides the defining equation implies that it also divides the  <span class="math">\\mathcal{L}_m</span>  quantity that is involved when trying to build a relation that relates P to other polynomials. Therefore the first part of Proposition 2 can not hold for this P. Similarly, if P is linear, its presence will prevent the second part of Proposition 2 to hold since the logarithm of P can not be found with the technique of Section 4. We present here a technique to deal with the problematic polynomials. (The authors of [5] proposed another solution to keep the quasi-polynomial nature of algorithm.)</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;<strong>Proposition 10</strong> For each problematic polynomial P of degree D, we can find a linear relation between  <span class="math">\\log P</span> ,  <span class="math">\\log h_1</span>  and O(D) logarithms of polynomials of degree at most  <span class="math">(\\delta - 1)D</span>  which are not problematic.</p>

    <p class="text-gray-300"><em>Proof.</em> Let P be an irreducible factor of  <span class="math">h_1X^q - h_0</span>  of degree D. Let us consider  <span class="math">P^q</span> ; by reducing modulo  <span class="math">h_1X^q - h_0</span>  and clearing denominators, there exists a polynomial A(X) such that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;
<span class="math">$h_1^D P^q = h_1^D \\tilde{P}\\left(\\frac{h_0}{h_1}\\right) + (h_1 X^q - h_0) A(X). \\tag{5}</span>$</p>

    <p class="text-gray-300">Since P divides two of the terms of this equality, it must also divide the third one, namely the polynomial  <span class="math">\\mathcal{R} = h_1^D \\tilde{P}(h_0/h_1)</span> . Let  <span class="math">v_P \\geq 1</span>  be the valuation of P in  <span class="math">\\mathcal{R}</span> . In the finite field  <span class="math">\\mathbb{F}_{q^{2k}}</span>  we obtain the following equalities between logarithms:</p>

    <p class="text-gray-300"><span class="math">$(q - v_P)\\log P = -D\\log h_1 + \\sum_i e_i \\log Q_i,</span>$</p>

    <p class="text-gray-300">where  <span class="math">Q_i</span>  are the irreducible factors of  <span class="math">\\mathcal{R}</span>  other than P and  <span class="math">e_i</span>  their valuation in  <span class="math">\\mathcal{R}</span> . A polynomial  <span class="math">Q_i</span>  can not be problematic. Otherwise, it would divide the right-hand side of Equation (5), and therefore, also the left-hand side, which is impossible. Since  <span class="math">v_P \\leq \\frac{\\deg \\mathcal{R}}{\\deg P} \\leq \\delta &lt; q</span> , the quantity  <span class="math">q - v_P</span>  is invertible modulo  <span class="math">\\ell</span>  (we assume, as usual that  <span class="math">\\ell</span>  is larger than q) and we obtain a relation between  <span class="math">\\log P</span> ,  <span class="math">\\log h_1</span>  and the logarithms of the non-problematic polynomials  <span class="math">Q_i</span> . The degree of  <span class="math">\\mathcal{R}/P^{v_P}</span>  is at most  <span class="math">(\\delta - 1)D</span> , which gives the claimed bound on the degrees of the  <span class="math">Q_i</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\delta \\leq 2</span> , this proposition solves the issues raised by [5] about problematic polynomials. Indeed, for each problematic polynomial of degree D&gt;1, it will be possible to rewrite its logarithm in terms of logarithms of non-problematic polynomials of at most the same degree that can be descended in the usual way. Similarly, each problematic polynomial of degree 1 can have its logarithm rewritten in terms of the logarithms of other non-problematic linear polynomials. Adding these relations to the ones obtained in Section 4, we expect to have a full-rank linear system.</p>

    <p class="text-gray-300">If  <span class="math">\\delta &gt; 2</span> , we need to rely on the additional heuristic. Indeed, when descending the  <span class="math">Q_i</span>  that have a degree potentially larger than the degree of D, we could hit again the problematic polynomial we started with, and it could be that the coefficients in front of  <span class="math">\\log P</span>  in the system vanishes. More generally, taking into account all the problematic polynomials, if when we apply Proposition 10 to them we get polynomials  <span class="math">Q_i</span>  of higher degrees, it could be that descending those we creates loops so that the logarithms of some of the problematic polynomials could not be computed. We expect this event to be very unlikely. Since in all our experiments it was always possible to obtain  <span class="math">\\delta = 2</span> , we did not investigate further.</p>

    <p class="text-gray-300">Finding appropriate  <span class="math">h_0</span>  and  <span class="math">h_1</span> . One key fact about the algorithm is the existence of two polynomials  <span class="math">h_0</span>  and  <span class="math">h_1</span>  in  <span class="math">\\mathbb{F}_{q^2}[X]</span>  such that  <span class="math">h_1(X)X^q - h_0(X)</span>  has an irreducible factor of degree k. A partial solution is due to Joux [16] who showed how to construct such polynomials when  <span class="math">k \\in \\{q-1,q,q+1\\}</span> . No such deterministic construction is known in the general case, but experiments show that one can apparently choose  <span class="math">h_0</span>  and  <span class="math">h_1</span>  of degree at most 2. We performed an experiment for every odd prime power q in  <span class="math">[3,\\ldots,1000]</span>  and every  <span class="math">k \\leq q</span>  and found that we could select  <span class="math">a \\in \\mathbb{F}_{q^2}</span>  such that  <span class="math">X^q + X^2 + a</span>  has an irreducible factor of degree k. Finally, note that the result is similar to a commonly made heuristic in discrete logarithm algorithms: for fixed  <span class="math">f \\in \\mathbb{F}_{q^2}[X,Y]</span>  and random  <span class="math">g \\in \\mathbb{F}_{q^2}[X,Y]</span> , the polynomial  <span class="math">\\mathrm{Res}_Y(f,g)</span>  behaves as a random polynomial of same degree with respect to the degrees of its irreducible factors.</p>

    <h2 id="sec-9" class="text-2xl font-bold">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;6 Some directions of improvement</h2>

    <p class="text-gray-300">The algorithm can be modified in several ways. On the one hand one can obtain a better complexity if one proves a stronger result on the smoothness probability. On the other hand, without changing the complexity, one can obtain a version which should behave better in practice.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">6.1 Complexity improvement</h4>

    <p class="text-gray-300">Heuristic 7 tells that a rectangular matrix with  <span class="math">\\Theta(q)</span>  times more rows than columns has full rank. It seems reasonable to expect that only a constant times more rows than columns would be enough to get the full rank properties (as is suggested by the experiments proposed in Section 5). Then, it means that we expect to have a lot of choices to select the best relations, in the sense that their left-hand sides split into irreducible factors of degrees as small as possible.</p>

    <p class="text-gray-300">On average, we expect to be able to try  <span class="math">\\Theta(q)</span>  relations for each row of the matrix. So, assuming that the numerators of  <span class="math">\\mathcal{L}_m</span>  behave like random polynomials of similar degrees, we have to evaluate the expected smoothness that we can hope for after trying  <span class="math">\\Theta(q)</span>  polynomials of degree  <span class="math">(1 + \\delta)D</span>  over  <span class="math">\\mathbb{F}_{q^2}</span> . Set  <span class="math">u = \\log q/\\log\\log q</span> , so that  <span class="math">u^u \\approx q</span> . According to [19] it is then possible to replace  <span class="math">\\lceil D/2 \\rceil</span>  in Proposition 2 by the value  <span class="math">O(D\\log\\log q/\\log q)</span> .</p>

    <p class="text-gray-300">Then, the discussion leading to Theorem 3 can be changed to take this faster descent into account. We keep the same estimate for the arity of each node in the tree, but the depth is now only in  <span class="math">\\log k/\\log\\log q</span> . Since this depth ends up in the exponent, the resulting complexity in Theorem 3 is then</p>

    <p class="text-gray-300"><span class="math">$\\max(q, k)^{O(\\log k / \\log \\log q)}</span>$
.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">6.2 Practical improvements</h4>

    <p class="text-gray-300">Because of the arity of the descent tree, the breadth eventually exceeds the number of polynomials below some degree bound. It makes no sense, therefore, to use the descent procedure beyond this point, as the recovery of discrete logarithms of all these polynomials is better achieved as a pre-computation. Note that this corresponds to the computations of the  <span class="math">L(1/4 + \\epsilon)</span>  algorithm which starts by pre-computing the logarithms of polynomials up to degree 2. In our case, we could in principle go up to degree  <span class="math">O(\\log q)</span>  without changing the complexity.</p>

    <p class="text-gray-300">We propose another practical improvement in the case where we would like to spend more time descending a given polynomial P in order to improve the quality of the descent tree rooted at P. The set of polynomials appearing in the right-hand side of Equation  <span class="math">(E_m)</span>  in Section 4 is  <span class="math">\\{P - \\lambda\\}</span> , because in the factorization of  <span class="math">X^q - X</span> , we substitute X with  <span class="math">m \\cdot P</span>  for homographies m. In fact, we may apply m to  <span class="math">(P : P_1)</span>  for any polynomial  <span class="math">P_1</span>  whose degree does not exceed that of P. In the right-hand sides, we will have only factors of form  <span class="math">P - \\lambda P_1</span>  for  <span class="math">\\lambda</span>  in  <span class="math">\\mathbb{F}_{q^2}</span> . On the left-hand sides, we have polynomials of the same</p>

    <p class="text-gray-300">degree as before, so that the smoothness probability is expected to be the same. Nevertheless, it is possible to test several P&lt;sup&gt;1&lt;/sup&gt; polynomials, and to select the one that leads to the best tree.</p>

    <p class="text-gray-300">This strategy can also be useful in the following context (which will not occur for large enough q): it can happen that for some triples (q, D, D&lt;sup&gt;0&lt;/sup&gt; ) one has N&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;2&lt;/sup&gt; (3D, D&lt;sup&gt;0&lt;/sup&gt; )/q&lt;sup&gt;n&lt;/sup&gt; ≈ 1/q. In this case we have no certainty that we can descend a degree-D polynomial to degree D&lt;sup&gt;0&lt;/sup&gt; , but we can hope that at least one of the P&lt;sup&gt;1&lt;/sup&gt; allows to descend.</p>

    <p class="text-gray-300">Finally, if one decides to use several auxiliary P&lt;sup&gt;1&lt;/sup&gt; polynomials to descend a polynomial P, it might be interesting to take a set of polynomials P&lt;sup&gt;1&lt;/sup&gt; with an arithmetic structure, so that the smoothness tests on the left-hand sides can benefit from a sieving technique.</p>

    <h2 id="sec-12" class="text-2xl font-bold">7 Conclusion</h2>

    <p class="text-gray-300">The algorithm presented in this article achieves a significant improvement of the asymptotic complexity of discrete logarithm in finite fields, in almost the whole range of parameters where the Function Field Sieve was presently the most competitive algorithm. Compared to existing approaches, and in particular to the line of recent works <a href="#page-15-7">[15,</a><a href="#page-15-8">10]</a>, the practical relevance of our algorithm is not clear, and will be explored by further work.</p>

    <p class="text-gray-300">We note that the analysis of the algorithm presented here is heuristic, as discussed in Section <a href="#page-8-0">5.</a> Some of the heuristics we stated, related to the properties of matrices H(P) extracted from the matrix H, seem accessible to more solid justification. It seems plausible to have the validity of algorithm rely on the sole heuristic of the validity of the smoothness estimates.</p>

    <p class="text-gray-300">The crossing point between the L(1/4) algorithm and our quasi-polynomial one is not determined yet. One of the key factors which hinders the practical efficiency of this algorithm is the O(q &lt;sup&gt;2&lt;/sup&gt;D) arity of the descent tree, compared to the O(q) arity achieved by techniques based on Gröbner bases <a href="#page-15-7">[15]</a> at the expense of a L(1/4 + ) complexity. Adj et al. <a href="#page-14-0">[1]</a> proposed to mix the two algorithms and deduced that the new descent technique must be used for cryptographic sizes. Indeed, by estimating the time required to compute discrete logarithms in F3 &lt;sup&gt;6&lt;/sup&gt;·&lt;sup&gt;509&lt;/sup&gt; , they showed the weakness of some pairing-based cryptosystems.</p>

    <h2 id="sec-13" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors would like to thank Daniel J. Bernstein for his comments on an earlier version of this work, and for pointing out to us the possible use of asymptotically fast linear algebra for solving the linear systems encountered.</p>

    <h2 id="sec-14" class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;1. Adj, G., Menezes, A., Oliveira, T., Rodríguez-Henríquez, F.: Weakness of F36·&lt;sup&gt;509&lt;/sup&gt; for discrete logarithm cryptography. Cryptology ePrint Archive, Report 2013/446 (2013), <a href="http://eprint.iacr.org/2013/446/">http://eprint.iacr.org/2013/446/</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;2. Adleman, L.: A subexponential algorithm for the discrete logarithm problem with applications to cryptography. In: Foundations of Computer Science, 1979., 20th Annual Symposium on. pp. 55–60. IEEE (1979)</li>
      <li>&lt;span id=&quot;page-15-4&quot;&gt;&lt;/span&gt;3. Adleman, L.: The function field sieve. In: Algorithmic number theory – ANTS I. Lecture Notes in Comput. Sci., vol. 877, pp. 108–121. Springer (1994)</li>
      <li>&lt;span id=&quot;page-15-10&quot;&gt;&lt;/span&gt;4. Blake, I.F., Fuji-Hara, R., Mullin, R.C., Vanstone, S.A.: Computing logarithms in finite fields of characteristic two. SIAM J. Alg. Disc. Meth. 5(2), 276–285 (Jun 1984)</li>
      <li>&lt;span id=&quot;page-15-19&quot;&gt;&lt;/span&gt;5. Cheng, Q., Wan, D., Zhuang, J.: Traps to the BGJT-algorithm for discrete logarithms. Cryptology ePrint Archive, Report 2013/673 (2013), <a href="http://eprint.iacr.org/2013/673/">http://eprint.iacr.</a> <a href="http://eprint.iacr.org/2013/673/">org/2013/673/</a></li>
      <li>&lt;span id=&quot;page-15-2&quot;&gt;&lt;/span&gt;6. Coppersmith, D.: Fast evaluation of logarithms in fields of characteristic two. IEEE Transactions on Information Theory 30(4), 587–594 (1984)</li>
      <li>&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;7. Diffie, W., Hellman, M.: New directions in cryptography. IEEE Transactions on Information Theory 22(6), 644–654 (1976)</li>
      <li>&lt;span id=&quot;page-15-13&quot;&gt;&lt;/span&gt;8. Göloglu, F., Granger, R., McGuire, G., Zumbrägel, J.: Discrete logarithm in GF(2&lt;sup&gt;1971&lt;/sup&gt;) (Feb 2013), announcement to the NMBRTHRY list</li>
      <li>&lt;span id=&quot;page-15-15&quot;&gt;&lt;/span&gt;9. Göloglu, F., Granger, R., McGuire, G., Zumbrägel, J.: Discrete logarithm in GF(2&lt;sup&gt;6120&lt;/sup&gt;) (Apr 2013), announcement to the NMBRTHRY list</li>
      <li>&lt;span id=&quot;page-15-8&quot;&gt;&lt;/span&gt;10. Göloglu, F., Granger, R., McGuire, G., Zumbrägel, J.: On the Function Field Sieve and the impact of higher splitting probabilities. In: Advances in Cryptology – CRYPTO 2013. Lecture Notes in Comput. Sci., vol. 8043, pp. 109–128. Springer (2013)</li>
      <li>&lt;span id=&quot;page-15-3&quot;&gt;&lt;/span&gt;11. Gordon, D.M.: Discrete logarithms in GF(p) using the number field sieve. SIAM Journal on Discrete Mathematics 6(1), 124–138 (1993)</li>
      <li>&lt;span id=&quot;page-15-12&quot;&gt;&lt;/span&gt;12. Joux, A.: Discrete logarithm in GF(2&lt;sup&gt;1778&lt;/sup&gt;) (Feb 2013), announcement to the NM-BRTHRY list</li>
      <li>&lt;span id=&quot;page-15-14&quot;&gt;&lt;/span&gt;13. Joux, A.: Discrete logarithm in GF(2&lt;sup&gt;4080&lt;/sup&gt;) (Mar 2013), announcement to the NM-BRTHRY list</li>
      <li>&lt;span id=&quot;page-15-16&quot;&gt;&lt;/span&gt;14. Joux, A.: Discrete logarithm in GF(2&lt;sup&gt;6168&lt;/sup&gt;) (May 2013), announcement to the NM-BRTHRY list</li>
      <li>&lt;span id=&quot;page-15-7&quot;&gt;&lt;/span&gt;15. Joux, A.: Faster index calculus for the medium prime case. Application to 1175 bit and 1425-bit finite fields. In: Advances in Cryptology – EUROCRYPT 2013, Lecture Notes in Comput. Sci., vol. 7881, pp. 177–193. Springer (2013)</li>
      <li>&lt;span id=&quot;page-15-9&quot;&gt;&lt;/span&gt;16. Joux, A.: A new index calculus algorithm with complexity L(1/4 + o(1)) in very small characteristic. Cryptology ePrint Archive, Report 2013/095 (2013)</li>
      <li>&lt;span id=&quot;page-15-5&quot;&gt;&lt;/span&gt;17. Joux, A., Lercier, R.: The function field sieve in the medium prime case. In: Advances in Cryptology – EUROCRYPT 2006. Lecture Notes in Comput. Sci., vol. 4005, pp. 254–270. Springer (2006)</li>
      <li>&lt;span id=&quot;page-15-6&quot;&gt;&lt;/span&gt;18. Joux, A., Lercier, R., Smart, N., Vercauteren, F.: The number field sieve in the medium prime case. In: Advances in Cryptology – CRYPTO 2006, Lecture Notes in Comput. Sci., vol. 4117, pp. 326–344. Springer (2006)</li>
      <li>&lt;span id=&quot;page-15-17&quot;&gt;&lt;/span&gt;19. Panario, D., Gourdon, X., Flajolet, P.: An analytic approach to smooth polynomials over finite fields. In: Algorithmic number theory – ANTS III, Lecture Notes in Comput. Sci., vol. 1423, pp. 226–236. Springer (1998)</li>
      <li>&lt;span id=&quot;page-15-11&quot;&gt;&lt;/span&gt;20. Pohlig, S., Hellman, M.: An improved algorithm for computing logarithms over GF(p) and its cryptographic signifiance. IEEE Transactions on Information Theory 24(1), 106–110 (1978)</li>
      <li>&lt;span id=&quot;page-15-18&quot;&gt;&lt;/span&gt;21. Stinson, D.R.: Combinatorial designs : constructions and analysis. Springer (2003)</li>
    </ul>

`;
---

<BaseLayout title="A quasi-polynomial algorithm for discrete logarithm in finit... (2013/400)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/400
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-quasi-polynomial-algorithm-for-discrete-logarithm-in-2013" />
  </article>
</BaseLayout>
