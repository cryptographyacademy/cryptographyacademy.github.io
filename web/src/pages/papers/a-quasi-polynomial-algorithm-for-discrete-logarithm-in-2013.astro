---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/400';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic';
const AUTHORS_HTML = 'Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, Emmanuel Thomé';

const CONTENT = `    <p class="text-gray-300">Razvan Barbulescu<span class="math">^{1}</span>, Pierrick Gaudry<span class="math">^{1}</span>, Antoine Joux<span class="math">^{2,3}</span>, and Emmanuel Thomé<span class="math">^{1}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Inria, CNRS, University of Lorraine, France <span class="math">^{2}</span> Cryptology Chair, Foundation UPMC – LIP 6, CNRS UMR 7606, Paris, France <span class="math">^{3}</span> CryptoExperts, Paris, France</p>

    <p class="text-gray-300">Abstract The difficulty of computing discrete logarithms in fields <span class="math">\\mathbb{F}_{q^k}</span> depends on the relative sizes of <span class="math">k</span> and <span class="math">q</span>. Until recently all the cases had a sub-exponential complexity of type <span class="math">L(1/3)</span>, similar to the factorization problem. In 2013, Joux designed a new algorithm with a complexity of <span class="math">L(1/4 + \\epsilon)</span> in small characteristic. In the same spirit, we propose in this article another heuristic algorithm that provides a quasi-polynomial complexity when <span class="math">q</span> is of size at most comparable with <span class="math">k</span>. By quasi-polynomial, we mean a runtime of <span class="math">n^{O(\\log n)}</span> where <span class="math">n</span> is the bit-size of the input. For larger values of <span class="math">q</span> that stay below the limit <span class="math">L_{q^k}(1/3)</span>, our algorithm loses its quasi-polynomial nature, but still surpasses the Function Field Sieve.</p>

    <p class="text-gray-300">The discrete logarithm problem (DLP) was first proposed as a hard problem in cryptography in the seminal article of Diffie and Hellman [7]. Since then, together with factorization, it has become one of the two major pillars of public key cryptography. As a consequence, the problem of computing discrete logarithms has attracted a lot of attention. From an exponential algorithm in 1976, the fastest DLP algorithms have been greatly improved during the past 35 years. A first major progress was the realization that the DLP in finite fields can be solved in subexponential time, i.e. <span class="math">L(1/2)</span> where <span class="math">L_N(\\alpha) = \\exp \\left(O((\\log N)^{\\alpha}(\\log \\log N)^{1 - \\alpha})\\right)</span>. The next step further reduced this to a heuristic <span class="math">L(1/3)</span> running time in the full range of finite fields, from fixed characteristic finite fields to prime fields [2,6,11,3,17,18].</p>

    <p class="text-gray-300">Recently, practical and theoretical advances have been made [15,10,16] with an emphasis on small to medium characteristic finite fields and composite degree extensions. The most general and efficient algorithm [16] gives a complexity of <span class="math">L(1/4 + o(1))</span> when the characteristic is smaller than the square root of the extension degree. Among the ingredients of this approach, we find the use of a very particular representation of the finite field; the use of the so-called systematic</p>

    <p class="text-gray-300">equation; and the use of algebraic resolution of bilinear polynomial systems in the individual logarithm phase.</p>

    <p class="text-gray-300">In this work, we present a new discrete logarithm algorithm, in the same vein as in <em>[16]</em> that uses an asymptotically more efficient descent approach. The main result gives a quasi-polynomial heuristic complexity for the DLP in finite fields of small characteristic. By quasi-polynomial, we mean a complexity of type <span class="math">n^{O(\\log n)}</span> where <span class="math">n</span> is the bit-size of the cardinality of the finite field. Such a complexity is smaller than any <span class="math">L(\\epsilon)</span> for <span class="math">\\epsilon&gt;0</span>. It remains super-polynomial in the size of the input, but offers a major asymptotic improvement compared to <span class="math">L(1/4+o(1))</span>.</p>

    <p class="text-gray-300">The key features of our algorithm are the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We keep the field representation and the systematic equations of <em>[16]</em>.</li>

      <li>The algorithmic building blocks are elementary. In particular, we avoid the use of Gröbner basis algorithms.</li>

      <li>The complexity result relies on three key heuristics: the existence of a polynomial representation of the appropriate form; the fact that the smoothness probabilities of some non-uniformly distributed polynomials are similar to the probabilities for uniformly random polynomials of the same degree; and the linear independence of some finite field elements related to the action of <span class="math">\\mathrm{PGL}_{2}(\\mathbb{F}_{q})</span>.</li>

    </ul>

    <p class="text-gray-300">The heuristics are very close to the ones used in <em>[16]</em>. In addition to the arguments in favor of these heuristics already given in <em>[16]</em>, we performed some experiments to validate them on practical instances.</p>

    <p class="text-gray-300">Although we insist on the case of finite fields of small characteristic, where quasi-polynomial complexity is obtained, our new algorithm improves the complexity of discrete logarithm computations in a much larger range of finite fields.</p>

    <p class="text-gray-300">More precisely, in finite fields of the form <span class="math">\\mathbb{F}_{q^{k}}</span>, where <span class="math">q</span> grows as <span class="math">L_{q^{k}}(\\alpha)</span>, the complexity becomes <span class="math">L_{q^{k}}(\\alpha+o(1))</span>. As a consequence, our algorithm is asymptotically faster than the Function Field Sieve algorithm in almost all the range previously covered by this algorithm. Whenever <span class="math">\\alpha&lt;1/3</span>, our new algorithm offers the smallest complexity. For the limiting case <span class="math">L(1/3,c)</span>, the Function Field Sieve remains more efficient for small values of <span class="math">c</span>, and the Number Field Sieve is better for large values of <span class="math">c</span> (see <em>[18]</em>).</p>

    <p class="text-gray-300">This article is organized as follows. In Section 2, we state the main result, and discuss how it can be used to design a complete discrete logarithm algorithm. In Section 3, we analyze how this result can be interpreted for various types of finite fields, including the important case of fields of small characteristic. Section 4 is devoted to the description of our new algorithm. It relies on heuristics that are discussed in Section 5, from a theoretical and a practical point of view. Before getting to the conclusion, in Section 6, we propose a few variants of the algorithm.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Main result</h2>

    <p class="text-gray-300">We start by describing the setting in which our algorithm applies. It is basically the same as in <em>[16]</em>: we need a large enough subfield, and we assume that a sparse representation can be found. This is formalized in the following definition.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Definition 1</h6>

    <p class="text-gray-300">A finite field <span class="math">K</span> admits a sparse medium subfield representation if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>it has a subfield of <span class="math">q^{2}</span> elements for a prime power <span class="math">q</span>, i.e. <span class="math">K</span> is isomorphic to <span class="math">\\mathbb{F}_{q^{2k}}</span> with <span class="math">k\\geq 1</span>;</li>

      <li>there exist two polynomials <span class="math">h_{0}</span> and <span class="math">h_{1}</span> over <span class="math">\\mathbb{F}_{q^{2}}</span> of small degree, such that <span class="math">h_{1}X^{q}-h_{0}</span> has a degree <span class="math">k</span> irreducible factor.</li>

    </ul>

    <p class="text-gray-300">In what follows, we will assume that all the fields under consideration admit a sparse medium subfield representation. Furthermore, we assume that the degrees of the polynomials <span class="math">h_{0}</span> and <span class="math">h_{1}</span> are uniformly bounded by a constant <span class="math">\\delta</span>. Later, we will provide heuristic arguments for the fact that any finite field of the form <span class="math">\\mathbb{F}_{q^{2k}}</span> with <span class="math">k\\leq q+2</span> admits a sparse medium subfield representation with polynomials <span class="math">h_{0}</span> and <span class="math">h_{1}</span> of degree at most <span class="math">2</span>. But in fact, for our result to hold, allowing the degrees of <span class="math">h_{0}</span> and <span class="math">h_{1}</span> to be bounded by any constant <span class="math">\\delta</span> independent of <span class="math">q</span> and <span class="math">k</span> or even allowing <span class="math">\\delta</span> to grow slower than <span class="math">O(\\log q)</span> would be sufficient.</p>

    <p class="text-gray-300">In a field in sparse medium subfield representation, elements will always be represented as polynomials of degree less than <span class="math">k</span> with coefficients in <span class="math">\\mathbb{F}_{q^{2}}</span>. When we talk about the discrete logarithm of such an element, we implicitly assume that a basis for this discrete logarithm has been chosen, and that we work in a subgroup whose order has no small irreducible factor (we refer to the Pohlig-Hellman algorithm <em>[20]</em> to limit ourselves to this case).</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Proposition 2</h6>

    <p class="text-gray-300">Let <span class="math">K=\\mathbb{F}_{q^{2k}}</span> be a finite field that admits a sparse medium subfield representation. Under the heuristics explained below, there exists an algorithm whose complexity is polynomial in <span class="math">q</span> and <span class="math">k</span> and which can be used for the following two tasks.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given an element of <span class="math">K</span> represented by a polynomial <span class="math">P\\in\\mathbb{F}_{q^{2}}[X]</span> with <span class="math">2\\leq\\deg P\\leq k-1</span>, the algorithm returns an expression of <span class="math">\\log P(X)</span> as a linear combination of at most <span class="math">O(kq^{2})</span> logarithms <span class="math">\\log P_{i}(X)</span> with <span class="math">\\deg P_{i}\\leq\\lceil\\frac{1}{2}\\deg P\\rceil</span> and of <span class="math">\\log h_{1}(X)</span>.</li>

      <li>The algorithm returns the logarithm of <span class="math">h_{1}(X)</span> and the logarithms of all the elements of <span class="math">K</span> of the form <span class="math">X+a</span>, for <span class="math">a</span> in <span class="math">\\mathbb{F}_{q^{2}}</span>.</li>

    </ol>

    <p class="text-gray-300">Before the presentation of the algorithm, which is made in Section 4, we explain how to use it as a building block for a complete discrete logarithm algorithm.</p>

    <p class="text-gray-300">Let <span class="math">P(X)</span> be an element of <span class="math">K</span> for which we want to compute the discrete logarithm. Here <span class="math">P</span> is a polynomial of degree at most <span class="math">k-1</span> and with coefficients</p>

    <p class="text-gray-300">in <span class="math">\\mathbb{F}_{q^{2}}</span>. We start by applying the algorithm of Proposition 2 to <span class="math">P</span>. We obtain a relation of the form</p>

    <p class="text-gray-300"><span class="math">\\log P=e_{0}\\log h_{1}+\\sum e_{i}\\log P_{i},</span></p>

    <p class="text-gray-300">where the sum has at most <span class="math">\\kappa q^{2}k</span> terms for a constant <span class="math">\\kappa</span> and the <span class="math">P_{i}</span>’s have degree at most <span class="math">\\lceil\\frac{1}{2}\\deg P\\rceil</span>. Then, we apply recursively the algorithm to the <span class="math">P_{i}</span>’s, thus creating a descent procedure where at each step, a given element <span class="math">P</span> is expressed as a product of elements, whose degree is at most half the degree of <span class="math">P</span> (rounded up) and the arity of the descent tree is in <span class="math">O(q^{2}k)</span>.</p>

    <p class="text-gray-300">At the end of the process, the logarithm of <span class="math">P</span> is expressed as a linear combination of the logarithms of <span class="math">h_{1}</span> and of the linear polynomials, for which the logarithms are computed with the algorithm in Proposition 2 in its second form.</p>

    <p class="text-gray-300">We are left with the complexity analysis of the descent process. Each internal node of the descent tree corresponds to one application of the algorithm of Proposition 2, therefore each internal node has a cost which is bounded by a polynomial in <span class="math">q</span> and <span class="math">k</span>. The total cost of the descent is therefore bounded by the number of nodes in the descent tree times a polynomial in <span class="math">q</span> and <span class="math">k</span>. The depth of the descent tree is in <span class="math">O(\\log k)</span>. The number of nodes of the tree is then less than or equal to its arity raised to the power of its depth, which is <span class="math">(q^{2}k)^{O(\\log k)}</span>. Since any polynomial in <span class="math">q</span> and <span class="math">k</span> is absorbed in the <span class="math">O()</span> notation in the exponent, we obtain the following result.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 3.1</h6>

    <p class="text-gray-300">Let <span class="math">K=\\mathbb{F}_{q^{2k}}</span> be a finite field that admits a sparse medium subfield representation. Assuming the same heuristics as in Proposition 2, any discrete logarithm in <span class="math">K</span> can be computed in a time bounded by</p>

    <p class="text-gray-300"><span class="math">\\max(q,k)^{O(\\log k)}.</span></p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Consequences for various ranges of parameters</h2>

    <p class="text-gray-300">We now discuss the implications of Theorem 3.1 depending on the properties of the finite field <span class="math">\\mathbb{F}_{Q}</span> where we want to compute discrete logarithms in the first place. The complexities will be expressed in terms of <span class="math">\\log Q</span>, which is the size of the input.</p>

    <p class="text-gray-300">Three cases are considered. In the first one, the finite field admits a sparse medium subfield representation, where <span class="math">q</span> and <span class="math">k</span> are almost equal. This is the optimal case. Then we consider the case where the finite field has small (maybe constant) characteristic. And finally, we consider the case where the characteristic is getting larger so that the only available subfield is a bit too large for the algorithm to have an optimal complexity.</p>

    <p class="text-gray-300">In the following, we always assume that for any field of the form <span class="math">\\mathbb{F}_{q^{2k}}</span>, we can find a sparse medium subfield representation.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 Case where the field is <span class="math">\\mathbb{F}_{q^{2k}}</span>, with <span class="math">q\\approx k</span></h3>

    <p class="text-gray-300">The finite fields <span class="math">\\mathbb{F}_{Q}=\\mathbb{F}_{q^{2k}}</span> for which <span class="math">q</span> and <span class="math">k</span> are almost equal are tailored for our algorithm. In that case, the complexity of Theorem 3 becomes <span class="math">q^{O(\\log q)}</span>. Since <span class="math">Q\\approx q^{2q}</span>, we have <span class="math">q=(\\log Q)^{O(1)}</span>. This gives an expression of the form <span class="math">2^{O\\big{(}(\\log\\log Q)^{2}\\big{)}}</span>, which is sometimes called quasi-polynomial in complexity theory.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Corollary 4</h6>

    <p class="text-gray-300">For finite fields of cardinality <span class="math">Q=q^{2k}</span> with <span class="math">q+O(1)\\geq k</span> and <span class="math">q=(\\log Q)^{O(1)}</span>, there exists a heuristic algorithm for computing discrete logarithms in quasi-polynomial time</p>

    <p class="text-gray-300"><span class="math">2^{O\\big{(}(\\log\\log Q)^{2}\\big{)}}.</span></p>

    <p class="text-gray-300">We mention a few cases which are almost directly covered by Corollary 4. First, we consider the case where <span class="math">Q=p^{n}</span> with <span class="math">p</span> a prime bounded by <span class="math">(\\log Q)^{O(1)}</span>, and yet large enough so that <span class="math">n\\leq(p+\\delta)</span>. In this case <span class="math">\\mathbb{F}_{Q}</span>, or possibly <span class="math">\\mathbb{F}_{Q^{2}}</span> if <span class="math">n</span> is odd, can be represented in such a way that Corollary 4 applies.</p>

    <p class="text-gray-300">Much the same can be said in the case where <span class="math">n</span> is composite and factors nicely, so that <span class="math">\\mathbb{F}_{Q}</span> admits a large enough subfield <span class="math">\\mathbb{F}_{q}</span> with <span class="math">q=p^{m}</span>. This can be used to solve certain discrete logarithms in, say, <span class="math">\\mathbb{F}_{2^{n}}</span> for adequately chosen <span class="math">n</span> (much similar to records tackled by <em>[12, 8, 13, 9, 14]</em>).</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.2 Case where the characteristic is polynomial in the input size</h3>

    <p class="text-gray-300">Let now <span class="math">\\mathbb{F}_{Q}</span> be a finite field whose characteristic <span class="math">p</span> is bounded by <span class="math">(\\log Q)^{O(1)}</span>, and let <span class="math">n=\\log Q/\\log p</span>, so that <span class="math">Q=p^{n}</span>. While we have seen that Corollary 4 can be used to treat some cases, its applicability might be hindered by the absence of an appropriately sized subfield: <span class="math">p</span> might be as small as <span class="math">2</span>, and <span class="math">n</span> might not factor adequately. In those cases, we use the same strategy as in <em>[16]</em> and embed the discrete logarithm problem in <span class="math">\\mathbb{F}_{Q}</span> into a discrete logarithm problem in a larger field.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">k</span> be <span class="math">n</span> if <span class="math">n</span> is odd and <span class="math">n/2</span> if <span class="math">n</span> is even. Then, we set <span class="math">q=p^{\\lceil\\log_{p}k\\rceil}</span>, and we work in the field <span class="math">\\mathbb{F}_{q^{2k}}</span>. By construction this field contains <span class="math">\\mathbb{F}_{Q}</span> (because $p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q<span class="math"> and </span>n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2k<span class="math">) and it is in the range of applicability of Theorem 3. Therefore, one can solve a discrete logarithm problem in </span>\\mathbb{F}_{Q}<span class="math"> in time </span>\\max(q,k)^{O(\\log k)}<span class="math">. Rewriting this complexity in terms of </span>Q<span class="math">, we get </span>\\log_{p}(Q)^{O(\\log\\log Q)}<span class="math">. And finally, we get a similar complexity result as in the previous case. Of course, since we had to embed in a larger field, the constant hidden in the </span>O()$ is larger than for Corollary 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Corollary 5</h6>

    <p class="text-gray-300">For finite fields of cardinality <span class="math">Q</span> and characteristic bounded by <span class="math">\\log(Q)^{O(1)}</span>, there exists a heuristic algorithm for computing discrete logarithms in quasi-polynomial time</p>

    <p class="text-gray-300"><span class="math">2^{O\\big{(}(\\log\\log Q)^{2}\\big{)}}.</span></p>

    <p class="text-gray-300">We emphasize that the case <span class="math">\\mathbb{F}_{2^{n}}</span> for a prime <span class="math">n</span> corresponds to this case. A direct consequence of Corollary 5 is that discrete logarithms in <span class="math">\\mathbb{F}_{2^{n}}</span> can be computed in quasi-polynomial time <span class="math">2^{O((\\log n)^{2})}</span>.</p>

    <p class="text-gray-300">##</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.3 Case where <span class="math">q=L_{q^{2k}}(\\alpha)</span></h3>

    <p class="text-gray-300">If the characteristic of the base field is not so small compared to the extension degree, the complexity of our algorithm does not keep its nice quasi-polynomial form. However, in almost the whole range of applicability of the Function Field Sieve algorithm, our algorithm is asymptotically better than FFS.</p>

    <p class="text-gray-300">We consider here finite fields that can be put into the form <span class="math">\\mathbb{F}_{Q}=\\mathbb{F}_{q^{2k}}</span>, where <span class="math">q</span> grows not faster than an expression of the form <span class="math">L_{Q}(\\alpha)</span>. In the following, we assume that there is equality, which is of course the worst case. The condition can then be rewritten as <span class="math">\\log q=O((\\log Q)^{\\alpha}(\\log\\log Q)^{1-\\alpha})</span> and therefore <span class="math">k=\\log Q/\\log q=O((\\log Q/\\log\\log Q)^{1-\\alpha})</span>. In particular we have <span class="math">k\\leq q+\\delta</span>, so that Theorem 3 can be applied and gives a complexity of <span class="math">q^{O(\\log k)}</span>. This yields the following result.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Corollary 6</h6>

    <p class="text-gray-300">For finite fields of the form <span class="math">\\mathbb{F}_{Q}=\\mathbb{F}_{q^{2k}}</span> where <span class="math">q</span> is bounded by <span class="math">L_{Q}(\\alpha)</span>, there exists a heuristic algorithm for computing discrete logarithms in subexponential time</p>

    <p class="text-gray-300"><span class="math">L_{Q}(\\alpha)^{O(\\log\\log Q)}.</span></p>

    <p class="text-gray-300">This complexity is smaller than <span class="math">L_{Q}(\\alpha^{\\prime})</span> for any <span class="math">\\alpha^{\\prime}&gt;\\alpha</span>. Hence, for any <span class="math">\\alpha&lt;1/3</span>, our algorithm is faster than the best previously known algorithm, namely FFS and its variants.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Main algorithm: proof of Proposition 2</h2>

    <p class="text-gray-300">The algorithm is essentially the same for proving the two points of Proposition 2. The strategy is to find relations between the given polynomial <span class="math">P(X)</span> and its translates by a constant in <span class="math">\\mathbb{F}_{q^{2}}</span>. Let <span class="math">D</span> be the degree of <span class="math">P(X)</span>, that we assume to be at least <span class="math">1</span> and at most <span class="math">k-1</span>.</p>

    <p class="text-gray-300">The key to find relations is the systematic equation:</p>

    <p class="text-gray-300"><span class="math">X^{q}-X=\\prod_{a\\in\\mathbb{F}_{q}}(X-a).</span> (1)</p>

    <p class="text-gray-300">We like to view Equation (1) as involving the projective line <span class="math">\\mathbb{P}^{1}(\\mathbb{F}_{q})</span>. Let <span class="math">\\mathcal{S}=\\{(\\alpha,\\beta)\\}</span> be a set of representatives of the <span class="math">q+1</span> points <span class="math">(\\alpha:\\beta)\\in\\mathbb{P}^{1}(\\mathbb{F}_{q})</span>, chosen adequately so that the following equality holds.</p>

    <p class="text-gray-300"><span class="math">X^{q}Y-XY^{q}=\\prod_{(\\alpha,\\beta)\\in\\mathcal{S}}(\\beta X-\\alpha Y).</span> (2)</p>

    <p class="text-gray-300">To make translates of <span class="math">P(X)</span> appear, we consider the action of homographies. Any matrix \\[ m=\\begin{pmatrix}a&b\\\\ c&d\\end{pmatrix} \\] acts on <span class="math">P(X)</span> with the following formula:</p>

    <p class="text-gray-300"><span class="math">m\\cdot P=\\frac{aP+b}{cP+d}.</span></p>

    <p class="text-gray-300">the following, this action will become trivial if the matrix <span class="math">m</span> has entries that are defined over <span class="math">\\mathbb{F}_{q}</span>. This is also the case if <span class="math">m</span> is non-invertible. Finally, it is clear that multiplying all the entries of <span class="math">m</span> by a non-zero constant does not change its action on <span class="math">P(X)</span>. Therefore the matrices of the homographies that we consider are going to be taken in the following set of cosets:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{q}=\\mathrm{PGL}(\\mathbb{F}_{q^{2}})/\\,\\mathrm{PGL}(\\mathbb{F}_{q}).</span></p>

    <p class="text-gray-300">(Note that in general <span class="math">\\mathrm{PGL}_{2}(\\mathbb{F}_{q})</span> is not a normal subgroup of <span class="math">\\mathrm{PGL}_{2}(\\mathbb{F}_{q^{2}})</span>, so that <span class="math">\\mathcal{P}_{q}</span> is not a quotient group.)</p>

    <p class="text-gray-300">To each element \\[ m=\\begin{pmatrix}a&b\\\\ c&d\\end{pmatrix}\\in\\mathcal{P}_{q}, \\] we associate the equation <span class="math">(E_{m})</span> obtained by substituting <span class="math">aP+b</span> and <span class="math">cP+d</span> in place of <span class="math">X</span> and <span class="math">Y</span> in Equation (2).</p>

    <p class="text-gray-300"><span class="math">(aP+b)^{q}(cP+d)-(aP+b)(cP+d)^{q}</span> <span class="math">=</span> <span class="math">\\prod_{(\\alpha,\\beta)\\in\\mathcal{S}}\\beta(aP+b)-\\alpha(cP+d)</span> <span class="math">(E_{m})</span> <span class="math">=</span> <span class="math">\\prod_{(\\alpha,\\beta)\\in\\mathcal{S}}(-c\\alpha+a\\beta)P-(d\\alpha-b\\beta)</span> <span class="math">=</span> <span class="math">\\lambda\\prod_{(\\alpha,\\beta)\\in\\mathcal{S}}P-\\mathrm{x}(m^{-1}\\cdot(\\alpha:\\beta)).</span></p>

    <p class="text-gray-300">This sequence of formulae calls for a short comment because of an abuse of notation in the last expression. First, <span class="math">\\lambda</span> is the constant in <span class="math">\\mathbb{F}_{q^{2}}</span> which makes the leading terms of the two sides match. Then, the term <span class="math">P-\\mathrm{x}(m^{-1}\\cdot(\\alpha:\\beta))</span> denotes <span class="math">P-u</span> when <span class="math">m^{-1}\\cdot(\\alpha:\\beta)=(u:1)</span> (whence we have <span class="math">u=\\frac{d\\alpha-b\\beta}{-c\\alpha+a\\beta}</span>), or <span class="math">1</span> if <span class="math">m^{-1}\\cdot(\\alpha:\\beta)=\\infty</span>. The latter may occur since when <span class="math">a/c</span> is in <span class="math">\\mathbb{F}_{q}</span>, the expression <span class="math">-c\\alpha+a\\beta</span> vanishes for a point <span class="math">(\\alpha:\\beta)\\in\\mathbb{P}^{1}(\\mathbb{F}_{q})</span> so that one of the factors of the product contains no term in <span class="math">P(X)</span>.</p>

    <p class="text-gray-300">Hence the right-hand side of Equation <span class="math">(E_{m})</span> is, up to a multiplicative constant, a product of <span class="math">q+1</span> or <span class="math">q</span> translates of the target <span class="math">P(X)</span> by elements of <span class="math">\\mathbb{F}_{q^{2}}.</span> The equation obtained is actually related to the set of points <span class="math">m^{-1}\\cdot\\mathbb{P}^{1}(\\mathbb{F}_{q})\\subset\\mathbb{P}^{1}(\\mathbb{F}_{q^{2}})</span>.</p>

    <p class="text-gray-300">The polynomial on the left-hand side of <span class="math">(E_{m})</span> can be rewritten as a smaller degree equivalent. For this, we use the special form of the defining polynomial: in <span class="math">K</span> we have <span class="math">X^{q}\\equiv\\frac{h_{0}(X)}{h_{1}(X)}.</span> Let us denote by <span class="math">\\tilde{a}</span> the element <span class="math">a^{q}</span> when <span class="math">a</span> is any element of <span class="math">\\mathbb{F}_{q^{2}}.</span> Furthermore, we write <span class="math">\\tilde{P}(X)</span> the polynomial <span class="math">P(X)</span> with all its coefficients raised to the power <span class="math">q</span>. The left-hand side of <span class="math">(E_{m})</span> is</p>

    <p class="text-gray-300"><span class="math">(\\tilde{a}\\tilde{P}(X^{q})+\\tilde{b})(cP(X)+d)-(aP(X)+b)(\\tilde{c}\\tilde{P}(X^{q})+\\tilde{d}),</span></p>

    <p class="text-gray-300">and using the defining equation for the field <span class="math">K</span>, it is congruent to</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{m}:=\\left(\\tilde{a}\\tilde{P}\\left(\\frac{h_{0}(X)}{h_{1}(X)}\\right)+\\tilde{b}\\right)(cP(X)+d)-(aP(X)+b)\\left(\\tilde{c}\\tilde{P}\\left(\\frac{h_{0}(X)}{h_{1}(X)}\\right)+\\tilde{d}\\right).</span></p>

    <p class="text-gray-300">Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé</p>

    <p class="text-gray-300">The denominator of <span class="math">\\mathcal{L}_m</span> is a power of <span class="math">h_1</span> and its numerator has degree at most <span class="math">(1 + \\delta)D</span> where <span class="math">\\delta = \\max (\\deg h_0,\\deg h_1)</span>. We say that <span class="math">m\\in \\mathcal{P}_q</span> yields a relation if this numerator of <span class="math">\\mathcal{L}_m</span> is <span class="math">\\lceil D / 2\\rceil</span>-smooth.</p>

    <p class="text-gray-300">To any <span class="math">m \\in \\mathcal{P}_q</span>, we associate a row vector <span class="math">v(m)</span> of dimension <span class="math">q^2 + 1</span> in the following way. Coordinates are indexed by <span class="math">\\mu \\in \\mathbb{P}^1(\\mathbb{F}_{q^2})</span>, and the value associated to <span class="math">\\mu \\in \\mathbb{F}_{q^2}</span> is 1 or 0 depending on whether <span class="math">P - \\mathrm{x}(\\mu)</span> appears in the right-hand side of Equation <span class="math">(E_m)</span>. Note that exactly <span class="math">q + 1</span> coordinates are 1 for each <span class="math">m</span>. Equivalently, we may write</p>

    <div class="my-4 text-center"><span class="math-block">v (m) _ {\\mu \\in \\mathbb {P} ^ {1} \\left(\\mathbb {F} _ {q ^ {2}}\\right)} = \\left\\{ \\begin{array}{l l} 1 &amp;amp; \\text {if} \\mu = m ^ {- 1} \\cdot (\\alpha : \\beta) \\text {with} (\\alpha : \\beta) \\in \\mathbb {P} ^ {1} \\left(\\mathbb {F} _ {q}\\right), \\\\ 0 &amp;amp; \\text {otherwise.} \\end{array} \\right. \\tag {3}</span></div>

    <p class="text-gray-300">We associate to the polynomial <span class="math">P</span> a matrix <span class="math">H(P)</span> whose rows are the vectors <span class="math">v(m)</span> for which <span class="math">m</span> yields a relation, taking at most one matrix <span class="math">m</span> in each coset of <span class="math">\\mathcal{P}_q</span>. The validity of Proposition 2 crucially relies on the following heuristic.</p>

    <p class="text-gray-300"><strong>Heuristic 7</strong> For any <span class="math">P(X)</span>, the set of rows <span class="math">v(m)</span> for cosets <span class="math">m \\in \\mathcal{P}_q</span> that yield a relation form a matrix which has full rank <span class="math">q^2 + 1</span>.</p>

    <p class="text-gray-300">As we will note in Section 5, the matrix <span class="math">H(P)</span> is heuristically expected to have <span class="math">\\Theta(q^3)</span> rows, where the implicit constant depends on <span class="math">\\delta</span>. This means that for our decomposition procedure to work, we rely on the fact that <span class="math">q</span> is large enough (otherwise <span class="math">H(P)</span> may have less than <span class="math">q^2 + 1</span> rows, which precludes the possibility that it have rank <span class="math">q^2 + 1</span>).</p>

    <p class="text-gray-300">The first point of Proposition 2, where we descend a polynomial <span class="math">P(X)</span> of degree <span class="math">D</span> at least 2, follows by linear algebra on this matrix. Since we assume that the matrix has full rank, then the vector <span class="math">(\\ldots, 0, 1, 0, \\ldots)</span> with 1 corresponding to <span class="math">P(X)</span> can be written as a linear combination of the rows. When doing this linear combination on the equations <span class="math">(E_m)</span> corresponding to <span class="math">P</span> we write <span class="math">\\log P(X)</span> as a linear combination of <span class="math">\\log P_i</span> where <span class="math">P_i(x)</span> are the elements occurring in the left-hand sides of the equations. Since there are <span class="math">O(q^2)</span> columns, the elimination process involves at most <span class="math">O(q^2)</span> rows, and since each row corresponds to an equation <span class="math">(E_m)</span>, it involves at most <span class="math">\\deg \\mathcal{L}_m \\leq (1 + \\delta)D</span> polynomials in the left-hand-side². In total, the polynomial <span class="math">D</span> is expressed by a linear combination of at most <span class="math">O(q^2 D)</span> polynomials of degree less than <span class="math">\\lceil D / 2 \\rceil</span>. The logarithm of <span class="math">h_1(X)</span> is also involved, as a denominator of <span class="math">\\mathcal{L}_m</span>. We have not made precise the constant in <span class="math">\\mathbb{F}_{q^2}^<em></span> which occurs to take care of the leading coefficients. Since discrete logarithms in <span class="math">\\mathbb{F}_{q^2}^</em></span> can certainly be computed in polynomial time in <span class="math">q</span>, this is not a problem.</p>

    <p class="text-gray-300">Since the order of <span class="math">\\mathrm{PGL}_2(\\mathbb{F}_{q^i})</span> is <span class="math">q^{3i} - q^i</span>, the set of cosets <span class="math">\\mathcal{P}_q</span> has <span class="math">q^3 + q</span> elements. For each <span class="math">m \\in \\mathcal{P}_q</span>, testing whether <span class="math">(E_m)</span> yields a relation amounts to some polynomial manipulations and a smoothness test. All of them can be done</p>

    <p class="text-gray-300">² This estimate of the number of irreducible factors is a pessimistic upper bound. In practice, one expects to have only <span class="math">O(\\log D)</span> factors on average. Since the crude estimate does not change the overall complexity, we keep it that way to avoid adding another heuristic.</p>

    <p class="text-gray-300">A quasi-polynomial algorithm for DLP in small characteristic finite fields</p>

    <p class="text-gray-300">in polynomial time in <span class="math">q</span> and the degree of <span class="math">P(X)</span> which is bounded by <span class="math">k</span>. Finally, the linear algebra step can be done in <span class="math">O(q^{2\\omega})</span> using asymptotically fast matrix multiplication algorithms, or alternatively <span class="math">O(q^{5})</span> operations using sparse matrix techniques. Indeed, we have <span class="math">q+1</span> non-zero entries per row and a size of <span class="math">q^{2}+1</span>. Therefore, the overall cost is polynomial in <span class="math">q</span> and <span class="math">k</span> as claimed.</p>

    <p class="text-gray-300">For the second part of Proposition 2 we replace <span class="math">P</span> by <span class="math">X</span> during the construction of the matrix. In that case, both sides of the equations <span class="math">(E_{m})</span> involve only linear polynomials. Hence we obtain a linear system whose unknowns are <span class="math">\\log(X+a)</span> with <span class="math">a\\in\\mathbb{F}_{q^{2}}</span>. Since Heuristic 7 would give us only the full rank of the system corresponding to the right-hand sides of the equations <span class="math">(E_{m})</span>, we have to rely on a specific heuristic for this step:</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Heuristic 8</h6>

    <p class="text-gray-300">The linear system constructed from all the equations <span class="math">(E_{m})</span> for <span class="math">P(X)=X</span> has full rank.</p>

    <p class="text-gray-300">Assuming that this heuristic holds, we can solve the linear system and obtain the discrete logarithms of the linear polynomials and of <span class="math">h_{1}(X)</span>.</p>

    <h2 id="sec-16" class="text-2xl font-bold">5 Supporting the heuristic argument in the proof</h2>

    <p class="text-gray-300">For Heuristic 7, we propose two approaches to support this heuristic. Both allow to gain some confidence in the validity of the heuristic, but of course none affect the heuristic nature of this statement.</p>

    <p class="text-gray-300">For the first line of justification, we denote by <span class="math">\\mathcal{H}</span> the matrix of all the <span class="math">\\#\\mathcal{P}_{q}=q^{3}+q</span> vectors <span class="math">v(m)</span> defined as in Equation (3). Associated to a polynomial <span class="math">P</span>, Section 4 defines the matrix <span class="math">H(P)</span> formed of the rows <span class="math">v(m)</span> such that the numerator of <span class="math">\\mathcal{L}_{m}</span> is smooth. We will give heuristics that <span class="math">H(P)</span> has <span class="math">\\Theta(q^{3})</span> rows and then prove that <span class="math">\\mathcal{H}</span> has rank <span class="math">q^{2}+1</span>, which of course does not prove that its submatrix <span class="math">H(P)</span> has full rank.</p>

    <p class="text-gray-300">In order to estimate the number of rows of <span class="math">H(P)</span> we assume that the numerator of <span class="math">\\mathcal{L}_{m}</span> has the same probability to be <span class="math">\\lceil\\frac{D}{2}\\rceil</span>-smooth as a random polynomial of same degree. In this paragraph, we assume that the degrees of <span class="math">h_{0}</span> and <span class="math">h_{1}</span> are bounded by 2, merely to avoid awkward notations; the result holds for any constant bound <span class="math">\\delta</span>. The degree of the numerator of <span class="math">\\mathcal{L}_{m}</span> is then bounded by <span class="math">3D</span>, so we have to estimate the probability that a polynomial in <span class="math">\\mathbb{F}_{q^{2}}[X]</span> of degree <span class="math">3D</span> is <span class="math">\\lceil\\frac{D}{2}\\rceil</span>-smooth. For any prime power <span class="math">q</span> and integers <span class="math">1\\leq m\\leq n</span>, we denote by <span class="math">N_{q}(m,n)</span> the number of <span class="math">m</span>-smooth monic polynomials of degree <span class="math">n</span>. Using analytic methods, Panario et al. gave a precise estimate of this quantity (Theorem 1 of <em>[19]</em>):</p>

    <p class="text-gray-300"><span class="math">N_{q}(n,m)=q^{n}\\rho\\left(\\frac{n}{m}\\right)\\left(1+O\\left(\\frac{\\log n}{m}\\right)\\right),</span> (4)</p>

    <p class="text-gray-300">where <span class="math">\\rho</span> is Dickman’s function defined as the unique continuous function such that <span class="math">\\rho(u)=1</span> on <span class="math">[0,1]</span> and <span class="math">u\\rho^{\\prime}(u)=\\rho(u-1)</span> for <span class="math">u&amp;gt;1</span>. We stress that the constant <span class="math">\\kappa</span> hidden in the <span class="math">O()</span> notation is independent of <span class="math">q</span>. In our case, we are interested in the value of <span class="math">N_{q^{2}}(3D,\\lceil\\frac{D}{2}\\rceil)</span>. Let us call <span class="math">D_{0}</span> the least integer such</p>

    <p class="text-gray-300">that <span class="math">1+\\kappa\\left(\\frac{\\log(3D)}{\\lceil D/2\\rceil}\\right)</span> is at least <span class="math">1/2</span>. For <span class="math">D&gt;D_{0}</span>, we will use the formula (4); and for <span class="math">D\\leq D_{0}</span>, we will use the crude estimate <span class="math">N_{q}(n,m)\\geq N_{q}(n,1)=q^{n}/n!</span>. Hence the smoothness probability of <span class="math">\\mathcal{L}_{m}</span> is at least <span class="math">\\min\\left(\\frac{1}{2}\\rho(6),1/(3D_{0})!\\right)</span>.</p>

    <p class="text-gray-300">More generally, if <span class="math">\\deg h_{0}</span> and <span class="math">\\deg h_{1}</span> are bounded by a constant <span class="math">\\delta</span> then we have a smoothness probability of <span class="math">\\rho(2\\delta+2)</span> times an absolute constant. Since we have <span class="math">q^{3}+q</span> candidates and a constant probability of success, <span class="math">H(P)</span> has <span class="math">\\Theta(q^{3})</span> rows.</p>

    <p class="text-gray-300">Now, unless some theoretical obstruction occurs, we expect a matrix over <span class="math">\\mathbb{F}_{\\ell}</span> to have full rank with probability at least <span class="math">1-\\frac{1}{\\ell}</span>. The matrix <span class="math">\\mathcal{H}</span> is however peculiar, and does enjoy regularity properties which are worth noticing. For instance, we have the following proposition.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proposition 9</h6>

    <p class="text-gray-300">Let <span class="math">\\ell</span> be a prime not dividing <span class="math">q^{3}-q</span>. Then the matrix <span class="math">\\mathcal{H}</span> over <span class="math">\\mathbb{F}_{\\ell}</span> has full rank <span class="math">q^{2}+1</span>.</p>

    <p class="text-gray-300">Proof. We may obtain this result in two ways. First, <span class="math">\\mathcal{H}</span> is the incidence matrix of a <span class="math">3-(q^{2}+1,q+1,1)</span> combinatorial design called <em>inversive plane</em> (see e.g. <em>[21, Theorem 9.27]</em>). As such we obtain the identity</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}^{T}\\mathcal{H}=(q+1)(J_{q^{2}+1}-(1-q)I_{q^{2}+1})</span></p>

    <p class="text-gray-300">(see <em>[21, Theorem 1.13 and Corollary 9.6]</em>), where <span class="math">J_{n}</span> is the <span class="math">n\\times n</span> matrix with all entries equal to one, and <span class="math">I_{n}</span> is the <span class="math">n\\times n</span> identity matrix. This readily gives the result exactly as announced.</p>

    <p class="text-gray-300">We also provide an elementary proof of the Proposition. We have a bijection between rows of <span class="math">\\mathcal{H}</span> and the different possible image sets of the projective line <span class="math">\\mathbb{P}^{1}(\\mathbb{F}_{q})</span> within <span class="math">\\mathbb{P}^{1}(\\mathbb{F}_{q^{2}})</span>, under injections of the form <span class="math">(\\alpha:\\beta)\\mapsto m^{-1}\\cdot(\\alpha:\\beta)</span>. All these <span class="math">q^{3}+q</span> image sets have size <span class="math">q+1</span>, and by symmetry all points of <span class="math">\\mathbb{P}^{1}(\\mathbb{F}_{q^{2}})</span> are reached equally often. Therefore, the sum of all rows of <span class="math">\\mathcal{H}</span> is the vector whose coordinates are all equal to <span class="math">\\frac{1}{1+q^{2}}(q^{3}+q)(q+1)=q^{2}+q</span>.</p>

    <p class="text-gray-300">Let us now consider the sum of the rows in <span class="math">\\mathcal{H}</span> whose first coordinate is <span class="math">1</span> (as we have just shown, we have <span class="math">q^{2}+q</span> such rows). Those correspond to image sets of <span class="math">\\mathbb{P}^{1}(\\mathbb{F}_{q})</span> which contain one particular point, say <span class="math">(0:1)</span>. The value of the sum for any other coordinate indexed by e.g. <span class="math">Q\\in\\mathbb{P}^{1}(\\mathbb{F}_{q^{2}})</span> is the number of image sets <span class="math">m^{-1}\\cdot\\mathbb{P}^{1}(\\mathbb{F}_{q})</span> which contain both <span class="math">(0:1)</span> and <span class="math">Q</span>, which we prove is equal to <span class="math">q+1</span> as follows. Without loss of generality, we may assume <span class="math">Q=\\infty=(1:0)</span>. We need to count the relevant homographies <span class="math">m^{-1}\\in\\mathrm{PGL}_{2}(\\mathbb{F}_{q^{2}})</span>, modulo <span class="math">\\mathrm{PGL}_{2}(\\mathbb{F}_{q})</span>-equivalence <span class="math">m\\equiv hm</span>. By <span class="math">\\mathrm{PGL}_{2}(\\mathbb{F}_{q})</span>-equivalence, we may without loss of generality assume that <span class="math">m^{-1}</span> fixes <span class="math">(0:1)</span> and <span class="math">(1:0)</span>. Letting <span class="math">m^{-1}=\\binom{a\\ b}{c\\ d}</span>, we obtain <span class="math">(b:d)=(0:1)</span> and <span class="math">(a:c)=(1:0)</span>, whence <span class="math">b=c=0</span>, and both <span class="math">a,d\\neq 0</span>. We may normalize to <span class="math">d=1</span>, and notice that multiplication of <span class="math">a</span> by a scalar in <span class="math">\\mathbb{F}_{q}^{<em>}</span> is absorbed in <span class="math">\\mathrm{PGL}_{2}(\\mathbb{F}_{q})</span>-equivalence. Therefore the number of suitable <span class="math">m</span> is <span class="math">\\#\\mathbb{F}_{q^{2}}^{</em>}/\\mathbb{F}_{q}^{*}=q+1</span>.</p>

    <p class="text-gray-300">These two facts show that the row span of <span class="math">\\mathcal{H}</span> contains the vectors <span class="math">(q^{2}+q,\\ldots,q^{2}+q)</span> and <span class="math">(q^{2}+q,q+1,\\ldots,q+1)</span>. The vector <span class="math">(q^{3}-q,0,\\ldots,0)</span> is obtained</p>

    <p class="text-gray-300">A quasi-polynomial algorithm for DLP in small characteristic finite fields</p>

    <p class="text-gray-300">as a linear combination of these two vectors, which suffices to prove that  <span class="math">\\mathcal{H}</span>  has full rank, since the same reasoning holds for any coordinate.</p>

    <p class="text-gray-300">Proposition 9, while encouraging, is clearly not sufficient. We are, at the moment, unable to provide a proof of a more useful statement. On the experimental side, it is reasonably easy to sample arbitrary subsets of the rows of  <span class="math">\\mathcal{H}</span>  and check for their rank. To this end, we propose the following experiment. We have considered small values of  <span class="math">q</span>  in the range [16, ..., 64], and made 50 random picks of subsets  <span class="math">S_{i} \\subset \\mathcal{P}_{q}</span> , all of size exactly  <span class="math">q^{2} + 1</span> . For each we considered the matrix of the corresponding linear system, which is made of selected rows of the matrix  <span class="math">\\mathcal{H}</span> , and computed its determinant  <span class="math">\\delta_{i}</span> . For all values of  <span class="math">q</span>  considered, we have observed the following facts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, all square matrices considered had full rank over  <span class="math">\\mathbb{Z}</span> . Furthermore, their determinants had no common factor apart possibly from those appearing in the factorization of  <span class="math">q^3 - q</span>  as predicted by Proposition 9. In fact, experimentally it seems that only the factors of  <span class="math">q + 1</span>  are causing problems.</li>

      <li>We also explored the possibility that modulo some primes, the determinant could vanish with non-negligible probability. We thus computed the pairwise GCD of all 50 determinants computed, for each  <span class="math">q</span> . Again, the only prime factors appearing in the GCDs were either originating from the factorization of  <span class="math">q^3 - q</span> , or sporadically from the birthday paradox.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#trials</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in gcd(δi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in gcd(δi,δj)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">691</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2,3</td>

            <td class="px-3 py-2 border-b border-gray-700">431,691</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2,5</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2,3</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2,13</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2,7</td>

            <td class="px-3 py-2 border-b border-gray-700">1327</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2,3,5</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1303,3209</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">3,11</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">#trials</td>

            <td class="px-3 py-2 border-b border-gray-700">in gcd(δi)</td>

            <td class="px-3 py-2 border-b border-gray-700">in gcd(δi,δj)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 19</td>

            <td class="px-3 py-2 border-b border-gray-700">2879</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 3, 7</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 11</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 3</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 5</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 3</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 3, 5</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 31</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">5, 13</td>

            <td class="px-3 py-2 border-b border-gray-700">none above q2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table1. Prime factors appearing in determinant of random square submatrices of  <span class="math">\\mathcal{H}</span>  (for one given set of random trials)</p>

    <p class="text-gray-300">These results are summarized in table 1, where the last column omits small prime factors below  <span class="math">q^2</span> . Of course, we remark that considering square submatrices is a more demanding check than what Heuristic 7 suggests, since our algorithm only needs a slightly larger matrix of size  <span class="math">\\Theta(q^3) \\times (q^2 + 1)</span>  to have full rank.</p>

    <p class="text-gray-300">A second line of justification is more direct and natural, as it is possible to implement the algorithm outlined in Section 4, and verify that it does provide the desired result. A MAGMA implementation validates this claim, and has been</p>

    <p class="text-gray-300">used to implement descent steps for an example field of degree 53 over <span class="math">\\mathbb{F}_{53^{2}}</span>. An example step in this context is given for applying our algorithm to a polynomial of degree 10, attempting to reduce it to polynomials of degree 6 or less. Among the 148,930 elements of <span class="math">\\mathcal{P}_{q}</span>, it sufficed to consider only 71,944 matrices <span class="math">m</span>, of which about 3.9% led to relations, for a minimum sufficient number of relations equal to <span class="math">q^{2}+1=2810</span> (as more than half of the elements of <span class="math">\\mathcal{P}_{q}</span> had not even been examined at this point, it is clear that getting more relations was easy—we did not have to). As the defining polynomial for the finite field considered was constructed with <span class="math">\\delta=\\deg h_{0,1}=1</span>, all left-hand sides involved had degree 20. The polynomials appearing in their factorizations had the following degrees (the number in brackets give the number of distinct polynomials found for each degree): 1(2098), 2(2652), 3(2552), 4(2463), 5(2546), 6(2683). Of course this tiny example size uses no optimization, and is only intended to check the validity of Proposition 2.</p>

    <p class="text-gray-300">As for Heuristic 8, it is already present in <em>[16]</em> and <em>[10]</em>, so this is not a new heuristic. Just like for Heuristic 7, it is based on the fact that the probability that a left-hand side is 1-smooth and yields a relation is constant. Therefore, we have a system with <span class="math">\\Theta(q^{3})</span> relations between <span class="math">O(q^{2})</span> indeterminates, and it seems reasonable to expect that it has full rank. On the other hand, there is not as much algebraic structure in the linear system as in Heuristic 7, so that we see no way to support this heuristic apart from testing it on several inputs. This was already done (including for record computations) in <em>[16]</em> and <em>[10]</em>, so we do not elaborate on our own experiments that confirm again that Heuristic 8 seems to be valid except for tiny values of <span class="math">q</span>.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">An obstruction to the heuristics.</h4>

    <p class="text-gray-300">As noted by Cheng, Wan and Zhuang <em>[5]</em>, the irreducible factors of <span class="math">h_{1}X^{q}-h_{0}</span> other than the degree <span class="math">k</span> factor that is used to define <span class="math">\\mathbb{F}_{q^{2k}}</span> are problematic. Let <span class="math">P</span> be such a problematic polynomial. The fact that it divides the defining equation implies that it also divides the <span class="math">\\mathcal{L}_{m}</span> quantity that is involved when trying to build a relation that relates <span class="math">P</span> to other polynomials. Therefore the first part of Proposition 2 can not hold for this <span class="math">P</span>. Similarly, if <span class="math">P</span> is linear, its presence will prevent the second part of Proposition 2 to hold since the logarithm of <span class="math">P</span> can not be found with the technique of Section 4. We present here a technique to deal with the problematic polynomials. (The authors of <em>[5]</em> proposed another solution to keep the quasi-polynomial nature of algorithm.)</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proposition 10</h6>

    <p class="text-gray-300">For each problematic polynomial <span class="math">P</span> of degree <span class="math">D</span>, we can find a linear relation between <span class="math">\\log P,\\;\\log h_{1}</span> and <span class="math">O(D)</span> logarithms of polynomials of degree at most <span class="math">(\\delta-1)D</span> which are not problematic.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Let <span class="math">P</span> be an irreducible factor of <span class="math">h_{1}X^{q}-h_{0}</span> of degree <span class="math">D</span>. Let us consider <span class="math">P^{q}</span>; by reducing modulo <span class="math">h_{1}X^{q}-h_{0}</span> and clearing denominators, there exists a polynomial <span class="math">A(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">h_{1}^{D}P^{q}=h_{1}^{D}\\tilde{P}\\left(\\frac{h_{0}}{h_{1}}\\right)+(h_{1}X^{q}-h_{0})A(X).</span> (5)</p>

    <p class="text-gray-300"><span class="math">P</span> divides two of the terms of this equality, it must also divide the third one, namely the polynomial <span class="math">\\mathcal{R}=h_{1}^{D}\\tilde{P}\\left(h_{0}/h_{1}\\right)</span>. Let <span class="math">v_{P}\\geq 1</span> be the valuation of <span class="math">P</span> in <span class="math">\\mathcal{R}</span>. In the finite field <span class="math">\\mathbb{F}_{q^{2k}}</span> we obtain the following equalities between logarithms:</p>

    <p class="text-gray-300"><span class="math">(q-v_{P})\\log P=-D\\log h_{1}+\\sum_{i}e_{i}\\log Q_{i},</span></p>

    <p class="text-gray-300">where <span class="math">Q_{i}</span> are the irreducible factors of <span class="math">\\mathcal{R}</span> other than <span class="math">P</span> and <span class="math">e_{i}</span> their valuation in <span class="math">\\mathcal{R}</span>. A polynomial <span class="math">Q_{i}</span> can not be problematic. Otherwise, it would divide the right-hand side of Equation (5), and therefore, also the left-hand side, which is impossible. Since <span class="math">v_{P}\\leq\\frac{\\deg\\mathcal{R}}{\\deg P}\\leq\\delta&lt;q</span>, the quantity <span class="math">q-v_{P}</span> is invertible modulo <span class="math">\\ell</span> (we assume, as usual that <span class="math">\\ell</span> is larger than <span class="math">q</span>) and we obtain a relation between <span class="math">\\log P</span>, <span class="math">\\log h_{1}</span> and the logarithms of the non-problematic polynomials <span class="math">Q_{i}</span>. The degree of <span class="math">\\mathcal{R}/P^{v_{P}}</span> is at most <span class="math">(\\delta-1)D</span>, which gives the claimed bound on the degrees of the <span class="math">Q_{i}</span>. ∎</p>

    <p class="text-gray-300">If <span class="math">\\delta\\leq 2</span>, this proposition solves the issues raised by <em>[5]</em> about problematic polynomials. Indeed, for each problematic polynomial of degree <span class="math">D&gt;1</span>, it will be possible to rewrite its logarithm in terms of logarithms of non-problematic polynomials of at most the same degree that can be descended in the usual way. Similarly, each problematic polynomial of degree <span class="math">1</span> can have its logarithm rewritten in terms of the logarithms of other non-problematic linear polynomials. Adding these relations to the ones obtained in Section 4, we expect to have a full-rank linear system.</p>

    <p class="text-gray-300">If <span class="math">\\delta&gt;2</span>, we need to rely on the additional heuristic. Indeed, when descending the <span class="math">Q_{i}</span> that have a degree potentially larger than the degree of <span class="math">D</span>, we could hit again the problematic polynomial we started with, and it could be that the coefficients in front of <span class="math">\\log P</span> in the system vanishes. More generally, taking into account all the problematic polynomials, if when we apply Proposition 10 to them we get polynomials <span class="math">Q_{i}</span> of higher degrees, it could be that descending those we creates loops so that the logarithms of some of the problematic polynomials could not be computed. We expect this event to be very unlikely. Since in all our experiments it was always possible to obtain <span class="math">\\delta=2</span>, we did not investigate further.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Finding appropriate <span class="math">h_{0}</span> and <span class="math">h_{1}</span></h4>

    <p class="text-gray-300">One key fact about the algorithm is the existence of two polynomials <span class="math">h_{0}</span> and <span class="math">h_{1}</span> in <span class="math">\\mathbb{F}_{q^{2}}[X]</span> such that <span class="math">h_{1}(X)X^{q}-h_{0}(X)</span> has an irreducible factor of degree <span class="math">k</span>. A partial solution is due to Joux <em>[16]</em> who showed how to construct such polynomials when <span class="math">k\\in\\{q-1,q,q+1\\}</span>. No such deterministic construction is known in the general case, but experiments show that one can apparently choose <span class="math">h_{0}</span> and <span class="math">h_{1}</span> of degree at most <span class="math">2</span>. We performed an experiment for every odd prime power <span class="math">q</span> in <span class="math">[3,\\ldots,1000]</span> and every <span class="math">k\\leq q</span> and found that we could select <span class="math">a\\in\\mathbb{F}_{q^{2}}</span> such that <span class="math">X^{q}+X^{2}+a</span> has an irreducible factor of degree <span class="math">k</span>. Finally, note that the result is similar to a commonly made heuristic in discrete logarithm algorithms: for fixed <span class="math">f\\in\\mathbb{F}_{q^{2}}[X,Y]</span> and random <span class="math">g\\in\\mathbb{F}_{q^{2}}[X,Y]</span>, the polynomial <span class="math">\\operatorname{Res}_{Y}(f,g)</span> behaves as a random polynomial of same degree with respect to the degrees of its irreducible factors.</p>

    <p class="text-gray-300">6 Some directions of improvement</p>

    <p class="text-gray-300">The algorithm can be modified in several ways. On the one hand one can obtain a better complexity if one proves a stronger result on the smoothness probability. On the other hand, without changing the complexity, one can obtain a version which should behave better in practice.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">6.1 Complexity improvement</h3>

    <p class="text-gray-300">Heuristic 7 tells that a rectangular matrix with <span class="math">\\Theta(q)</span> times more rows than columns has full rank. It seems reasonable to expect that only a constant times more rows than columns would be enough to get the full rank properties (as is suggested by the experiments proposed in Section 5). Then, it means that we expect to have a lot of choices to select the best relations, in the sense that their left-hand sides split into irreducible factors of degrees as small as possible.</p>

    <p class="text-gray-300">On average, we expect to be able to try <span class="math">\\Theta(q)</span> relations for each row of the matrix. So, assuming that the numerators of <span class="math">\\mathcal{L}_{m}</span> behave like random polynomials of similar degrees, we have to evaluate the expected smoothness that we can hope for after trying <span class="math">\\Theta(q)</span> polynomials of degree <span class="math">(1+\\delta)D</span> over <span class="math">\\mathbb{F}_{q^{2}}</span>. Set <span class="math">u=\\log q/\\log\\log q</span>, so that <span class="math">u^{u}\\approx q</span>. According to <em>[19]</em> it is then possible to replace <span class="math">\\lceil D/2\\rceil</span> in Proposition 2 by the value <span class="math">O(D\\log\\log q/\\log q)</span>.</p>

    <p class="text-gray-300">Then, the discussion leading to Theorem 3 can be changed to take this faster descent into account. We keep the same estimate for the arity of each node in the tree, but the depth is now only in <span class="math">\\log k/\\log\\log q</span>. Since this depth ends up in the exponent, the resulting complexity in Theorem 3 is then</p>

    <p class="text-gray-300"><span class="math">\\max(q,k)^{O(\\log k/\\log\\log q)}.</span></p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">6.2 Practical improvements</h3>

    <p class="text-gray-300">Because of the arity of the descent tree, the breadth eventually exceeds the number of polynomials below some degree bound. It makes no sense, therefore, to use the descent procedure beyond this point, as the recovery of discrete logarithms of all these polynomials is better achieved as a pre-computation. Note that this corresponds to the computations of the <span class="math">L(1/4+\\epsilon)</span> algorithm which starts by pre-computing the logarithms of polynomials up to degree 2. In our case, we could in principle go up to degree <span class="math">O(\\log q)</span> without changing the complexity.</p>

    <p class="text-gray-300">We propose another practical improvement in the case where we would like to spend more time descending a given polynomial <span class="math">P</span> in order to improve the quality of the descent tree rooted at <span class="math">P</span>. The set of polynomials appearing in the right-hand side of Equation <span class="math">(E_{m})</span> in Section 4 is <span class="math">\\{P-\\lambda\\}</span>, because in the factorization of <span class="math">X^{q}-X</span>, we substitute <span class="math">X</span> with <span class="math">m\\cdot P</span> for homographies <span class="math">m</span>. In fact, we may apply <span class="math">m</span> to <span class="math">(P:P_{1})</span> for any polynomial <span class="math">P_{1}</span> whose degree does not exceed that of <span class="math">P</span>. In the right-hand sides, we will have only factors of form <span class="math">P-\\lambda P_{1}</span> for <span class="math">\\lambda</span> in <span class="math">\\mathbb{F}_{q^{2}}</span>. On the left-hand sides, we have polynomials of the same</p>

    <p class="text-gray-300">degree as before, so that the smoothness probability is expected to be the same. Nevertheless, it is possible to test several <span class="math">P_{1}</span> polynomials, and to select the one that leads to the best tree.</p>

    <p class="text-gray-300">This strategy can also be useful in the following context (which will not occur for large enough <span class="math">q</span>): it can happen that for some triples <span class="math">(q,D,D^{\\prime})</span> one has <span class="math">N_{q^{2}}(3D,D^{\\prime})/q^{n}\\approx 1/q</span>. In this case we have no certainty that we can descend a degree-<span class="math">D</span> polynomial to degree <span class="math">D^{\\prime}</span>, but we can hope that at least one of the <span class="math">P_{1}</span> allows to descend.</p>

    <p class="text-gray-300">Finally, if one decides to use several auxiliary <span class="math">P_{1}</span> polynomials to descend a polynomial <span class="math">P</span>, it might be interesting to take a set of polynomials <span class="math">P_{1}</span> with an arithmetic structure, so that the smoothness tests on the left-hand sides can benefit from a sieving technique.</p>

    <h2 id="sec-24" class="text-2xl font-bold">7 Conclusion</h2>

    <p class="text-gray-300">The algorithm presented in this article achieves a significant improvement of the asymptotic complexity of discrete logarithm in finite fields, in almost the whole range of parameters where the Function Field Sieve was presently the most competitive algorithm. Compared to existing approaches, and in particular to the line of recent works <em>[15, 10]</em>, the practical relevance of our algorithm is not clear, and will be explored by further work.</p>

    <p class="text-gray-300">We note that the analysis of the algorithm presented here is heuristic, as discussed in Section 5. Some of the heuristics we stated, related to the properties of matrices <span class="math">H(P)</span> extracted from the matrix <span class="math">\\mathcal{H}</span>, seem accessible to more solid justification. It seems plausible to have the validity of algorithm rely on the sole heuristic of the validity of the smoothness estimates.</p>

    <p class="text-gray-300">The crossing point between the <span class="math">L(1/4)</span> algorithm and our quasi-polynomial one is not determined yet. One of the key factors which hinders the practical efficiency of this algorithm is the <span class="math">O(q^{2}D)</span> arity of the descent tree, compared to the <span class="math">O(q)</span> arity achieved by techniques based on Gröbner bases <em>[15]</em> at the expense of a <span class="math">L(1/4+\\epsilon)</span> complexity. Adj et al. <em>[1]</em> proposed to mix the two algorithms and deduced that the new descent technique must be used for cryptographic sizes. Indeed, by estimating the time required to compute discrete logarithms in <span class="math">\\mathbb{F}_{3^{6}\\cdot 509}</span>, they showed the weakness of some pairing-based cryptosystems.</p>

    <h2 id="sec-25" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors would like to thank Daniel J. Bernstein for his comments on an earlier version of this work, and for pointing out to us the possible use of asymptotically fast linear algebra for solving the linear systems encountered.</p>

    <h2 id="sec-26" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Adj, G., Menezes, A., Oliveira, T., Rodríguez-Henríquez, F.: Weakness of <span class="math">\\mathbb{F}_{3^{6}\\cdot 509}</span> for discrete logarithm cryptography. Cryptology ePrint Archive, Report 2013/446 (2013), http://eprint.iacr.org/2013/446/</li>

    </ul>

    <p class="text-gray-300">Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] Adleman, L.: A subexponential algorithm for the discrete logarithm problem with applications to cryptography. In: Foundations of Computer Science, 1979., 20th Annual Symposium on. pp. 55–60. IEEE (1979)</li>

      <li>[3] Adleman, L.: The function field sieve. In: Algorithmic number theory – ANTS I. Lecture Notes in Comput. Sci., vol. 877, pp. 108–121. Springer (1994)</li>

      <li>[4] Blake, I.F., Fuji-Hara, R., Mullin, R.C., Vanstone, S.A.: Computing logarithms in finite fields of characteristic two. SIAM J. Alg. Disc. Meth. 5(2), 276–285 (Jun 1984)</li>

      <li>[5] Cheng, Q., Wan, D., Zhuang, J.: Traps to the BGJT-algorithm for discrete logarithms. Cryptology ePrint Archive, Report 2013/673 (2013), http://eprint.iacr.org/2013/673/</li>

      <li>[6] Coppersmith, D.: Fast evaluation of logarithms in fields of characteristic two. IEEE Transactions on Information Theory 30(4), 587–594 (1984)</li>

      <li>[7] Diffie, W., Hellman, M.: New directions in cryptography. IEEE Transactions on Information Theory 22(6), 644–654 (1976)</li>

      <li>[8] Göloglu, F., Granger, R., McGuire, G., Zumbrägel, J.: Discrete logarithm in GF(2^{1971}) (Feb 2013), announcement to the NMBRTHRY list</li>

      <li>[9] Göloglu, F., Granger, R., McGuire, G., Zumbrägel, J.: Discrete logarithm in GF(2^{6120}) (Apr 2013), announcement to the NMBRTHRY list</li>

      <li>[10] Göloglu, F., Granger, R., McGuire, G., Zumbrägel, J.: On the Function Field Sieve and the impact of higher splitting probabilities. In: Advances in Cryptology – CRYPTO 2013. Lecture Notes in Comput. Sci., vol. 8043, pp. 109–128. Springer (2013)</li>

      <li>[11] Gordon, D.M.: Discrete logarithms in GF(p) using the number field sieve. SIAM Journal on Discrete Mathematics 6(1), 124–138 (1993)</li>

      <li>[12] Joux, A.: Discrete logarithm in GF(2^{1778}) (Feb 2013), announcement to the NMBRTHRY list</li>

      <li>[13] Joux, A.: Discrete logarithm in GF(2^{4080}) (Mar 2013), announcement to the NMBRTHRY list</li>

      <li>[14] Joux, A.: Discrete logarithm in GF(2^{6168}) (May 2013), announcement to the NMBRTHRY list</li>

      <li>[15] Joux, A.: Faster index calculus for the medium prime case. Application to 1175-bit and 1425-bit finite fields. In: Advances in Cryptology – EUROCRYPT 2013, Lecture Notes in Comput. Sci., vol. 7881, pp. 177–193. Springer (2013)</li>

      <li>[16] Joux, A.: A new index calculus algorithm with complexity L(<span class="math">1/4+o(1)</span>) in very small characteristic. Cryptology ePrint Archive, Report 2013/095 (2013)</li>

      <li>[17] Joux, A., Lercier, R.: The function field sieve in the medium prime case. In: Advances in Cryptology – EUROCRYPT 2006. Lecture Notes in Comput. Sci., vol. 4005, pp. 254–270. Springer (2006)</li>

      <li>[18] Joux, A., Lercier, R., Smart, N., Vercauteren, F.: The number field sieve in the medium prime case. In: Advances in Cryptology – CRYPTO 2006, Lecture Notes in Comput. Sci., vol. 4117, pp. 326–344. Springer (2006)</li>

      <li>[19] Panario, D., Gourdon, X., Flajolet, P.: An analytic approach to smooth polynomials over finite fields. In: Algorithmic number theory – ANTS III, Lecture Notes in Comput. Sci., vol. 1423, pp. 226–236. Springer (1998)</li>

      <li>[20] Pohlig, S., Hellman, M.: An improved algorithm for computing logarithms over <span class="math">GF(p)</span> and its cryptographic signifiance. IEEE Transactions on Information Theory 24(1), 106–110 (1978)</li>

      <li>[21] Stinson, D.R.: Combinatorial designs : constructions and analysis. Springer (2003)</li>

    </ul>`;
---

<BaseLayout title="A quasi-polynomial algorithm for discrete logarithm in finit... (2013/400)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/400
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
