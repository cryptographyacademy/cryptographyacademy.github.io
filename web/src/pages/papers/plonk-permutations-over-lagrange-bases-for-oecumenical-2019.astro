---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/953';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge';
const AUTHORS_HTML = 'Ariel Gabizon, Zachary J.  Williamson, Oana Ciobotaru';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">zk-SNARK constructions that utilize an updatable universal structured reference string remove one of the main obstacles in deploying zk-SNARKs [GKMMM, Crypto 2018]. The important work of Maller et al. [MBKM, CCS 2019] presented $\\mathsf{Sonic}$ - the first potentially practical zk-SNARK with fully succinct verification for general arithmetic circuits with such an SRS.
However, the version of $\\mathsf{Sonic}$ enabling fully succinct verification still requires relatively high proof construction overheads. We present a universal SNARK construction with fully succinct verification, and significantly lower prover running time (roughly 7.5-20 less group exponentiations than [MBKM] in the fully succinct verifier mode depending on circuit structure).

Similarly to [MBKM], we rely on a permutation argument based on Bayer and Groth [Eurocrypt 2012]. However, we focus on \`\`Evaluations on a subgroup rather than coefficients of monomials&#x27;&#x27;; which enables simplifying both the permutation argument and the artihmetization step.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> zk-SNARKs</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Due to real-world deployments of zk-SNARKs, it has become of significant interest to have the structured reference string (SRS) be constructible in a &quot;universal and updatable&quot; fashion. Meaning that the same SRS can be used for statements about all circuits of a certain bounded size; and that at any point in time the SRS can be updated by a new party, such that the honesty of only one party from all updaters up to that point is required for soundness. For brevity, let us call a zk-SNARK with such a setup process universal.</p>

    <p class="text-gray-300">For the purpose of this introduction, let us say a zk-SNARK for circuit satisfiability is fully succinct if</p>

    <p class="text-gray-300"><sup>*</sup>Most of this work was done while the first author was working at Protocol Labs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The preprocessing<a href="#page-1-0">1</a> phase/SRS generation run time is quasilinear in circuit size.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover run time is quasilinear in circuit size.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The proof length is logarithmic<a href="#page-1-1">2</a> in circuit size.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier run time is polylogarithmic in circuit size.<a href="#page-1-2">3</a></li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Maller et al. <a href="#page-32-1">[MBKM]</a> constructed for the first time a universal fully succinct zk-SNARK for circuit satisfiability, called Sonic.</p>

    <p class="text-gray-300"><a href="#page-32-1">[MBKM]</a> also give a version of Sonic with dramatically improved prover run time, at the expense of efficient verification only in a certain amortized sense.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Our results</h3>

    <p class="text-gray-300">In this work we give a universal fully-succinct zk-SNARK with significantly improved prover run time compared to fully-succinct Sonic.</p>

    <p class="text-gray-300">At a high level our improvements stem from a more direct arithmetization of a circuit as compared to the <a href="#page-31-1">[BCC</a>+16]-inspired arithmetization of <a href="#page-32-1">[MBKM]</a>. This is combined with a permutation argument over univariate evaluations on a multiplicative subgroup rather than over coefficients of a bivariate polynomial as in <a href="#page-32-1">[MBKM]</a>.</p>

    <p class="text-gray-300">In a nutshell, one reason multiplicative subgroups are useful is that several protocols, including Sonic, use a permutation argument based on Bayer and Groth <a href="#page-31-0">[BG12]</a>. Ultimately, in the &quot;grand product argument&quot;, this reduces to checking relations between coefficients of polynomials at &quot;neighbouring monomials&quot;.</p>

    <p class="text-gray-300">We observe that if we think of the points x, g&middot;x as neighbours, where g is a generator of a multiplicative subgroup of a field F, it is very convenient to check relations between different polynomials at such pairs of points.</p>

    <p class="text-gray-300">A related convenience is that multiplicative subgroups interact well with Lagrange bases. For example, suppose H &sub; F is a multiplicative subgroup of order n, and x &isin; H. The polynomial L<sup>x</sup> of degree n &minus; 1 that vanishes on H \\ {x} and has Lx(x) = 1, has a very sparse representation of the form</p>

    <p class="text-gray-300"><span class="math">$L_x(X) = \\frac{c_x(X^n - 1)}{(X - x)},</span>$</p>

    <p class="text-gray-300">for a constant cx. This is beneficial when constructing an efficiently verifiable <a href="#page-31-0">[BG12]</a> style permutation argument in terms of polynomial identities.</p>

    <p class="text-gray-300"><sup>1</sup>We use the term SNARK in this paper for what is sometimes called a &quot;SNARK with preprocessing&quot;(see e.g. <a href="#page-32-2">[GGPR13]</a>) where one allows a one-time verifier computation that is polynomial rather than polylogarithmic in the circuit size. In return, the SNARK is expected to work for all non-uniform circuits, rather than only statements about uniform computation.</p>

    <p class="text-gray-300"><sup>2</sup>From a theoretical point of view, polylogarithmic proof length is more natural; but logarithmic nicely captures recent constructions with a constant number of group elements, and sometimes is a good indication of the &quot;practicality barrier&quot;.</p>

    <p class="text-gray-300"><sup>3</sup> In many definitions, only proof size is required to be polylogarithmic. For example, in the terminology of <a href="#page-32-2">[GGPR13]</a>, additionally requiring polylogarithmic verifier run time means the SNARK is unsubtle.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Efficiency Analysis</h3>

    <p class="text-gray-300">We compare the performance of this work to the state of the art, both for non-universal SNARKs and universal SNARKs. At the time of publication, the only fully succinct universal SNARK construction is (the fully-succinct version of) the Sonic protocol <a href="#page-32-1">[MBKM]</a>. This protocol requires the prover compute 273n G<sup>1</sup> group exponentiations, where n is the number of multiplication gates. In fully-succinct Sonic, every wire can only be used in three linear relationships, requiring the addition of 'dummy' multiplication gates to accommodate wires used in more than three addition gates. This increase in the multiplication gate count is factored into the prover computation estimate (see <a href="#page-32-1">[MBKM]</a> for full details).</p>

    <p class="text-gray-300">Our universal SNARK requires the prover to compute 5 polynomial commitments, combined with two opening proofs to evaluate the polynomial commitments at a random challenge point. There are two &quot;flavours&quot;of PlonK to suit the tastes of the user. By increasing the proof size by two group elements, the total prover computations can be reduced by &asymp; 10%. The combined degree of the polynomials is either 9(n + a) (larger proofs) or 11(n + a) (smaller proofs, reduced verifier work), where n is the number of multiplication gates and a is the number of addition gates. Currently, the most efficient fully-succinct SNARK construction available is Groth's 2016 construction <a href="#page-32-3">[Gro16]</a>, which requires a unique, non-updateable CRS per circuit. Proof construction times are dominated by 3n + m G<sup>1</sup> and n G<sup>2</sup> group exponentiations, where m is formally the number of R1CS variables, and is typically bounded by n (for the rest of this section, the reader may assume m = n for simplicity). If we assume that one G<sup>2</sup> exponentiation is equivalent to three G<sup>1</sup> exponentiations, this yields 6n + m equivalent G<sup>1</sup> group exponentiations.</p>

    <p class="text-gray-300">Performing a direct comparison between these SNARK arithmetisations requires some admittedly subjective assumptions. When evaluating common circuits, we found that the number of addition gates is 2x the number of multiplication gates, however circuits that are optimized under the assumption that addition gates are 'free' (as is common in R1CS based systems like <a href="#page-32-3">[Gro16]</a>) will give worse estimates.</p>

    <p class="text-gray-300">At one extreme, for a circuit containing no addition gates and only fan-in-2 multiplication gates, our universal SNARK proofs require &asymp; 1.1 times more prover work than <a href="#page-32-3">[Gro16]</a>, and &asymp; 30 times fewer prover work than Sonic. If a = 2n, the ratios change to &asymp; 2.25 times more prover work than <a href="#page-32-3">[Gro16]</a>, and &asymp; 10 times less work than Sonic. If a = 5n, this changes to &asymp; 3 times more work than <a href="#page-32-3">[Gro16]</a>, and &asymp; 5 times less work than Sonic. We should note that these comparisons are only comparing the required number of group exponentiations.</p>

    <p class="text-gray-300">We also note that the degree of PlonK's structured reference string is equal to the number of gates in a circuit (if one uses the &quot;fast&quot; flavour of PlonK). This is a significant reduction in the SRS size compared to the state of the art.</p>

    <p class="text-gray-300">When comparing proof construction, we also include the number of field multiplications for PlonK, as the number of fast-fourier-transforms required to construct proofs is non-trivial. All other succinct universal SNARK constructions also have high FFT</p>

    <p class="text-gray-300">Table 1: Prover comparison. m = number of wires, n = number of multiplication gates, a = number of addition gates</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathbf{size} \\leq d</span> <span class="math">\\mathbf{SRS}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathbf{size} = n</span> <span class="math">\\mathbf{CRS/SRS}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">prover<br>work</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">proof<br>length</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">succinct</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">universal</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Groth'16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3n+m \\ \\mathbb{G}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3n + m - \\ell \\mathbb{G}_1 \\exp,</span><br><span class="math">n \\mathbb{G}_2 \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\mathbb{G}_1, 1 \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&times;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sonic (helped)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">12d \\mathbb{G}_1, 12d \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">12n \\ \\mathbb{G}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">18n  \\mathbb{G}_1  \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 G <sub>1</sub> , 2 F</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#1061;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sonic (succinct)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">4d \\mathbb{G}_1, 4d \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">36n  \\mathbb{G}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">273n \\ \\mathbb{G}_1 \\ \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">20 \\ \\mathbb{G}_1, \\ 16 \\ \\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Auroralight</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2d \\mathbb{G}_1, 2d \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2n \\mathbb{G}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">8n \\ \\mathbb{G}_1 \\ \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6 G <sub>1</sub> , 4 F</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#1061;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work (small)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3d \\mathbb{G}_1, 1 \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3n + 3a \\mathbb{G}_1, 1 \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">11n + 11a \\mathbb{G}_1 \\exp ,</span><br><span class="math">\\approx 54(n+a)\\log(n+a) \\mathbb{F} \\text{ mul}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">7 \\mathbb{G}_1, 6 \\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work (fast prover)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d \\mathbb{G}_1, 1 \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n+a \\mathbb{G}_1, 1 \\mathbb{G}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">9n + 9a \\ \\mathbb{G}_1 \\ \\exp</span> ,<br><span class="math">\\approx 54(n+a)\\log(n+a) \\ \\mathbb{F} \\ \\text{mul}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9 G <sub>1</sub> , 6 F</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">transform costs, however given the difficulty of finding hard numbers, we cannot include them in the above table. Qualitative analysis suggests that the FFTs consume slightly less compute time than the  <span class="math">\\mathbb{G}_1</span>  group exponentiations. More details on the number of field multiplications are given in section 1.3.</p>

    <p class="text-gray-300">Verifier computation per proof is shown in table 2. Only two bilinear pairing operations are required, due to the simple structure of the committed prover polynomials. In addition, the  <span class="math">\\mathbb{G}_2</span>  elements in each pairing are fixed, enabling optimizations that reduce pairing computation time by  <span class="math">\\approx 30\\%</span>  [CS10].</p>

    <p class="text-gray-300">Table 2: Verifier comparison per proof, P=pairing,  <span class="math">\\ell</span> =num of pub inputs. For non-succinct protocols, additional helper work is specified</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">verifier<br>work</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">elem. from<br>helper</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">extra verifier<br>work in<br>helper mode</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Groth'16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3P, \\ell \\mathbb{G}_1 \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sonic (helped)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10P</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3 \\mathbb{G}_1, 2 \\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4P</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sonic (succinct)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13P</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Auroralight</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">5P, 6 \\mathbb{G}_1 \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">8 \\mathbb{G}_1, 10 \\mathbb{F}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12P</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work (small)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2P</span> , <span class="math">16 \\mathbb{G}_1 \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work (fast prover)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2P</span> , <span class="math">18 \\mathbb{G}_1 \\exp</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Performance and Benchmarks</h3>

    <p class="text-gray-300">    <img src="_page_4_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: Benchmarks for test  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  circuits using the BN254 curve. Does not include witness generation. Tests performed on a Surface pro 6 with 16GB RAM and a core i7-8650U CPU, utilizing all 8 logical/4 physical cores.</p>

    <p class="text-gray-300">Figure 1 provides some estimates for the time required to construct and verify  <span class="math">\\mathcal{PlonK}</span>  proofs. The benchmarks in question utilize the BN254 elliptic curve, using the Barretenberg ecc library.</p>

    <p class="text-gray-300">Even for circuits with over a million gates,  <span class="math">\\mathcal{P}lon\\mathcal{K}</span>  proofs are capable of being constructed on consumer-grade hardware in under 23 seconds. This marks a significant advancement in the efficiency of universal SNARKs, which are now practical for a wide range of real-world use-cases.</p>

    <p class="text-gray-300">Circuit preprocessing is a one-off computation, required for each program codified into a  <span class="math">\\mathcal{PlonK}</span>  circuit. This step generates the polynomial commitments to the 'selector' polynomials required to verify proofs.</p>

    <p class="text-gray-300">When constructing proofs, the time taken to perform the required fast fourier transforms is comparable to the time taken for elliptic curve scalar multiplications. The number of field multiplications in table 1 is obtained from 8 FFTs of size 4n, 5 FFTs of size 2n and 12 FFTs of size n.</p>

    <p class="text-gray-300">The number of FFT transforms can be significantly reduced, if a circuit's preprocessed polynomials are provided as evaluations over the 4n'th roots of unity (instead of in Lagrange-base form). However, given this dramatically increases the amount of information required to construct proofs, we omit this optimisation from our benchmarks.</p>

    <p class="text-gray-300">We conclude the introduction with a comparision to relevant concurrent work.</p>

      <h3 id="sec-1.4" class="text-xl font-semibold mt-8">1.4 Comparison with the randomized sumcheck approach, and Fractal/Marlin:</h3>

    <p class="text-gray-300">Roughly speaking, all succinct proving systems work by using randomness to compress many constraint checks into one. The general way to obtain such compression, is by taking a random linear combination of the constraints. In the case of R1CS and similar systems, the more difficult constraints to be compressed are linear relations between the system variables, i.e. constraints of the form  <span class="math">\\langle a_i, x \\rangle = 0</span>  where  <span class="math">x \\in \\mathbb{F}^m</span>  are the system variables, and  <span class="math">a_i \\in \\mathbb{F}^m</span>  represents one of the constraints.</p>

    <p class="text-gray-300">These are analogous to the less general &quot;wiring constraints&quot; in a circuit satisfiability statement, which have the form  <span class="math">x_i = x_j</span>  (e.g. when  <span class="math">x_i</span>  represents the output wire of a gate G, and  <span class="math">x_i</span>  an input wire from G into another gate G').</p>

    <p class="text-gray-300">A random<sup>5</sup> linear combination of linear constraints might have the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i \\in [n]} r^i &lt; a_i, x &gt; = 0</span>$</p>

    <p class="text-gray-300">for a unifrom  <span class="math">r \\in \\mathbb{F}</span></p>

    <p class="text-gray-300">Skipping some details, [MBKM] and the subsequent work of [Gab19] (relying on [BCR<sup>+</sup>19]) reduce such a check to evaluating a degree n bivariate S at a random point; such that the number of non-zero monomials in S corresponds to the number of non-zero entries in the constraint vectors  <span class="math">\\{a_i\\}_{i\\in[n]}</span> . [MBKM] at this point devise a clever strategy to amortize the cost of many evaluations of S across many proofs. This variant of [MBKM] is much more prover efficient, but not fully succinct because of the need for the verifier to compute at least one evaluation of S by themselves.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>We emphasize that the vector  <span class="math">a_i</span>  here does not precisely correspond to one of the r1cs matrix rows, but rather to a &quot;flattening&quot; of it, i.e. it is a constraint of the form  <span class="math">y = \\sum a&#x27;_{i,j}x_j</span>  where  <span class="math">a&#x27;_i</span>  is one the r1cs matrix rows.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>It is a standard derandomization trick to use powers of a single random  <span class="math">r \\in \\mathbb{F}</span>  rather than random independent  <span class="math">r_i</span> .</p>

    <p class="text-gray-300">Thus, the barrier to a fully succinct version of the more prover efficient version of Sonic (and for a fully succinct version of <a href="#page-32-5">[Gab19]</a>), is a method to efficiently verify an evaluation S(z, y) in the case S only contains O(n) non-zero monomials.</p>

    <p class="text-gray-300">A significant technical contribution of the recent<a href="#page-6-0">6</a> concurrent Fractal and Marlin systems <a href="#page-32-6">[CHM</a>+19, <a href="#page-32-7">COS19]</a> is a solution to this problem &quot;in Lagrange Basis&quot;.</p>

    <p class="text-gray-300">Specifically, suppose that H, K are multiplicative subgroups of size O(n) of F such that S has only M non-zero values on H&times;K; then <a href="#page-32-6">[CHM</a>+19, <a href="#page-32-7">COS19]</a> devise a protocol to convince a succinct verifier that S(z, y) = t where the prover's work is linear in M. This is a good point to note that the solution to this problem by the natural generalization of <a href="#page-32-8">[KZG10]</a> to a bi-variate polynomial commitment scheme would have led to O(n 2 ) proving time.</p>

    <p class="text-gray-300">Coming back to PlonK, the reason we don't require this &quot;bi-variate evaluation breakthrough&quot; is that we focus on constant fan-in circuits rather than R1CS/unlimited addition fan-in; and thus our linear constraints are just wiring constraints that can be reduced to a permutation check (as explained in Sections <a href="#page-21-0">5.2,</a> <a href="#page-22-0">6)</a>. One way to interpret the <a href="#page-31-0">[BG12]</a> technique is that &quot;linear constraints that correspond to a permutation can be more simply combined than general linear constraints&quot;. For example, in the above equation each constraint is multiplied by a distinct random coefficient, whereas in the <a href="#page-31-0">[BG12]</a> randomization, it suffices in a sense to add the same random shift to each variable value. (See the permutation protocol in Section <a href="#page-18-0">5</a> for details.)</p>

    <p class="text-gray-300">Concrete comparison to Marlin While Fractal leverages the sparse bi-variate evaluation technique in the context of transparent recursive SNARKs, Marlin focuses on constructing a fully succinct (universal) SNARK as in this paper.</p>

    <p class="text-gray-300">It is not completely straightforward to compare this work and <a href="#page-32-6">[CHM</a>+19], as we are in the realm of concrete constants, and the basic measure both works use is different. While we take our main parameter n to be the number of addition and multiplication gates in a fan-in two circuit; <a href="#page-32-6">[CHM</a>+19] use as their main parameter the maximal number of non-zeroes in one of the three matrices describing an R1CS. For the same value of n PlonK outperforms Marlin, e.g. by roughly a 2x factor in prover group operations and proof size. In the extreme case of a circuit with only multiplication gates, this would indeed represent the performance difference between the two systems.</p>

    <p class="text-gray-300">However, in constraint systems with &quot;frequent large addition fan-in&quot; Marlin may outperform the currently specified variant<a href="#page-6-1">7</a> of PlonK. For example, this happens in the extreme case of one &quot;fully dense&quot; R1CS constraint</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{j\\in[m]} a_j x_j\\right) \\cdot \\left(\\sum_{j\\in[m]} b_j x_j\\right) = \\sum_{j\\in[m]} c_j x_j.</span>$</p>

    <p class="text-gray-300">where a, b, c &isin; F <sup>m</sup> have all non-zero entries.</p>

    <p class="text-gray-300"><sup>6</sup> In hindsight, we realized Spartan<a href="#page-32-9">[Set]</a> gave a similar sparse evaluation scheme for multilinear polynomials prior to <a href="#page-32-6">[CHM</a><sup>+</sup>19, <a href="#page-32-7">COS19]</a>.</p>

    <p class="text-gray-300"><sup>7</sup> It seems that the natural variants of PlonK where the addition fan-in is increased to three or four according to the instance could outperform the current numbers given in Marlin for any R1CS.</p>

    <p class="text-gray-300">Morever, it seems ideas implicit in Fractal, or alternatively a &quot;plug-in&quot; of the mentioned sparse bi-variate evaluation protocol into [Gab19] will lead to improved performance via this route; especially in cases where some of the prover work can be delegated to an outside helper (in  <span class="math">\\mathcal{PlonK}</span>  there is less opportunity for such delegation, as the wiring is checked on the witness itself, whereas in [Gab19, CHM<sup>+</sup>19, COS19] it is in a sense checked on the random coefficients of the verifier).</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Terminology and Conventions</h3>

    <p class="text-gray-300">We assume our field  <span class="math">\\mathbb{F}</span>  is of prime order. We denote by  <span class="math">\\mathbb{F}_{&lt; d}[X]</span>  the set of univariate polynomials over  <span class="math">\\mathbb{F}</span>  of degree smaller than d. We assume all algorithms described receive as an implicit parameter the security parameter  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Whenever we use the term &quot;efficient&quot;, we mean an algorithm running in time  <span class="math">poly(\\lambda)</span> . Furthermore, we assume an &quot;object generator&quot;  <span class="math">\\mathcal{O}</span>  that is run with input  <span class="math">\\lambda</span>  before all protocols, and returns all fields and groups used. Specifically, in our protocol  <span class="math">\\mathcal{O}(\\lambda) = (\\mathbb{F}, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_t, e, g_1, g_2, g_t)</span>  where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{F}</span>  is a prime field of super-polynomial size  <span class="math">r = \\lambda^{\\omega(1)}</span> .</li>
      <li><span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_t</span>  are all groups of size r, and e is an efficiently computable non-degenerate pairing  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_t</span> .</li>
      <li><span class="math">g_1, g_2</span>  are uniformly chosen generators such that  <span class="math">e(g_1, g_2) = g_t</span> .</li>
    </ul>

    <p class="text-gray-300">We usually let the  <span class="math">\\lambda</span>  parameter be implicit, i.e. write  <span class="math">\\mathbb{F}</span>  instead of  <span class="math">\\mathbb{F}(\\lambda)</span> . We write  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  additively. We use the notations  <span class="math">[x]_1 := x \\cdot g_1</span>  and  <span class="math">[x]_2 := x \\cdot g_2</span> .</p>

    <p class="text-gray-300">We often denote by [n] the integers  <span class="math">\\{1,\\ldots,n\\}</span> . We use the acronym e.w.p for &quot;except with probability&quot;; i.e. e.w.p  <span class="math">\\gamma</span>  means with probability at least  <span class="math">1-\\gamma</span> .</p>

    <p class="text-gray-300">universal SRS-based public-coin protocols We describe public-coin (meaning the verifier messages are uniformly chosen) interactive protocols between a prover and verifier; when deriving results for non-interactive protocols, we implicitly assume we can get a proof length equal to the total communication of the prover, using the Fiat-Shamir transform/a random oracle. Using this reduction between interactive and non-interactive protocols, we can refer to the &quot;proof length&quot; of an interactive protocol.</p>

    <p class="text-gray-300">We allow our protocols to have access to a structured reference string (SRS) that can be derived in deterministic  <span class="math">\\operatorname{poly}(\\lambda)</span> -time from an &quot;SRS of monomials&quot; of the form  <span class="math">\\left\\{\\begin{bmatrix}x^i\\end{bmatrix}_1\\right\\}_{a\\leq i\\leq b}, \\left\\{\\begin{bmatrix}x^i\\end{bmatrix}_2\\right\\}_{c\\leq i\\leq d}</span> , for uniform  <span class="math">x\\in\\mathbb{F}</span> , and some integers a,b,c,d with absolute value bounded by  <span class="math">\\operatorname{poly}(\\lambda)</span> . It then follows from Bowe et al. [BGM17] that the required SRS can be derived in a universal and updatable setup requiring only one honest participant; in the sense that an adversary controlling all but one of the participants in the setup does not gain more than a  <span class="math">\\operatorname{negl}(\\lambda)</span>  advantage in its probability of producing a proof of any statement.</p>

    <p class="text-gray-300">For notational simplicity, we sometimes use the SRS srs as an implicit parameter in protocols, and do not explicitly write it.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Analysis in the AGM model</h3>

    <p class="text-gray-300">For security analysis we will use the Algebraic Group Model of Fuchsbauer, Kiltz and Loss[FKL18]. In our protocols, by an algebraic adversary  <span class="math">\\mathcal{A}</span>  in an SRS-based protocol we mean a  <span class="math">\\mathsf{poly}(\\lambda)</span> -time algorithm which satisfies the following.</p>

    <p class="text-gray-300">&bull; For  <span class="math">i \\in \\{1, 2\\}</span> , whenever  <span class="math">\\mathcal{A}</span>  outputs an element  <span class="math">A \\in \\mathbb{G}_i</span> , it also outputs a vector v over  <span class="math">\\mathbb{F}</span>  such that  <span class="math">A = \\langle v, \\mathsf{srs}_i \\rangle</span> .</p>

    <p class="text-gray-300">Idealized verifier checks for algebraic adversaries We introduce some terminology to capture the advantage of analysis in the AGM.</p>

    <p class="text-gray-300">First we say our srs has degree Q if all elements of  <span class="math">\\operatorname{srs}_i</span>  are of the form  <span class="math">[f(x)]_i</span>  for  <span class="math">f \\in \\mathbb{F}_{&lt; Q}[X]</span>  and uniform  <span class="math">x \\in \\mathbb{F}</span> . In the following discussion let us assume we are executing a protocol with a degree Q SRS, and denote by  <span class="math">f_{i,j}</span>  the corresponding polynomial for the j'th element of  <span class="math">\\operatorname{srs}_i</span> .</p>

    <p class="text-gray-300">Denote by a, b the vectors of  <span class="math">\\mathbb{F}</span> -elements whose encodings in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span>  an algebraic adversary  <span class="math">\\mathcal{A}</span>  outputs during a protocol execution; e.g., the j'th  <span class="math">\\mathbb{G}_1</span>  element output by  <span class="math">\\mathcal{A}</span>  is  <span class="math">[a_j]_1</span> .</p>

    <p class="text-gray-300">By a &quot;real pairing check&quot; we mean a check of the form</p>

    <p class="text-gray-300"><span class="math">$(a \\cdot T_1) \\cdot (T_2 \\cdot b) = 0</span>$</p>

    <p class="text-gray-300">for some matrices  <span class="math">T_1, T_2</span>  over  <span class="math">\\mathbb{F}</span> . Note that such a check can indeed be done efficiently given the encoded elements and the pairing function  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_t</span> .</p>

    <p class="text-gray-300">Given such a &quot;real pairing check&quot;, and the adversary  <span class="math">\\mathcal{A}</span>  and protocol execution during which the elements were output, define the corresponding &quot;ideal check&quot; as follows. Since  <span class="math">\\mathcal{A}</span>  is algebraic when he outputs  <span class="math">[a_j]_i</span>  he also outputs a vector v such that, from linearity,  <span class="math">a_j = \\sum v_\\ell f_{i,\\ell}(x) = R_{i,j}(x)</span>  for  <span class="math">R_{i,j}(X) := \\sum v_\\ell f_{i,\\ell}(X)</span> . Denote, for  <span class="math">i \\in \\{1,2\\}</span>  the vector of polynomials  <span class="math">R_i = (R_{i,j})_j</span> . The corresponding ideal check, checks as a polynomial identity whether</p>

    <p class="text-gray-300"><span class="math">$(R_1 \\cdot T_1) \\cdot (T_2 \\cdot R_2) \\equiv 0</span>$</p>

    <p class="text-gray-300">The following lemma is inspired by [FKL18]'s analysis of [Gro16], and tells us that for soundness analysis against algebraic adversaries it suffices to look at ideal checks. Before stating the lemma we define the Q-DLOG assumption similarly to [FKL18].</p>

    <p class="text-gray-300"><strong>Definition 2.1.</strong> Fix integer Q. The Q-DLOG assumption for  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2)</span>  states that given</p>

    <p class="text-gray-300"><span class="math">$[1]_1, [x]_1, \\dots, [x^Q]_1, [1]_2, [x]_2, \\dots, [x^Q]_2</span>$</p>

    <p class="text-gray-300">for uniformly chosen  <span class="math">x \\in \\mathbb{F}</span> , the probability of an efficient A outputting x is  <span class="math">negl(\\lambda)</span> .</p>

    <p class="text-gray-300">Lemma 2.2. Assume the Q-DLOG for (G1, G2). Given an algebraic adversary A participating in a protocol with a degree Q SRS, the probability of any real pairing check passing is larger by at most an additive negl(&lambda;) factor than the probability the corresponding ideal check holds.</p>

    <p class="text-gray-300">Proof. Let &gamma; be the difference between the satisfiability of the real and ideal check. We describe an adversary A<sup>&lowast;</sup> for the Q-DLOG problem that succeeds with probability &gamma;; this implies &gamma; = negl(&lambda;). A<sup>&lowast;</sup> receives the challenge</p>

    <p class="text-gray-300"><span class="math">$\\left[1\\right]_{1},\\left[x\\right]_{1},\\ldots,\\left[x^{Q}\\right]_{1},\\left[1\\right]_{2},\\left[x\\right]_{2},\\ldots,\\left[x^{Q}\\right]_{2}</span>$</p>

    <p class="text-gray-300">and constructs using group operations the correct SRS for the protocol. Now A<sup>&lowast;</sup> runs the protocol with A, simulating the verifier role. Note that as A<sup>&lowast;</sup> receives from A the vectors of coefficients v, he can compute the polynomials {Ri,j} and check if we are in the case that the real check passed but ideal check failed. In case we are in this event, A<sup>&lowast;</sup> computes</p>

    <p class="text-gray-300"><span class="math">$R:=(R_1\\cdot T_1)(T_2\\cdot R_2).</span>$</p>

    <p class="text-gray-300">We have that R &isin; F&lt;2Q[X] is a non-zero polynomial for which R(x) = 0. Thus A<sup>&lowast;</sup> can factor R and find x.</p>

    <p class="text-gray-300">Knowledge soundness in the Algebraic Group Model We say a protocol P between a prover P and verifier V for a relation R has Knowledge Soundness in the Algebraic Group Model if there exists an efficient E such that the probability of any algebraic adversary A winning the following game is negl(&lambda;).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A chooses input x and plays the role of P in P with input x.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E given access to all of A's messages during the protocol (including the coefficients of the linear combinations) outputs &omega;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A wins if</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) V outputs acc at the end of the protocol, and</li>
      <li>(b) (x, &omega;) &isin; R/ .</li>
    </ul></li>
    </ul>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 A batched version of the <a href="#page-32-8">[KZG10]</a> scheme</h2>

    <p class="text-gray-300">Crucial to the efficiency of our protocol is a batched version of the <a href="#page-32-8">[KZG10]</a> polynomial commitment scheme (PCS) similar to Appendix C of <a href="#page-32-1">[MBKM]</a>, allowing to query multiple committed polynomials at multiple points. We begin by defining polynomial commitment schemes in a manner conducive to our protocol. Specifically, we define the open procedure in a batched setting having multiple polynomials and evaluation points.</p>

    <p class="text-gray-300">Definition 3.1. A d-polynomial commitment scheme consists of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet</span>  gen(d) a randomized algorithm that outputs an SRS srs.</li>
      <li>com(f, srs) that given a polynomial  <span class="math">f \\in \\mathbb{F}_{\\leq d}[X]</span>  returns a commitment cm to f.</li>
      <li>A public coin protocol open between parties  <span class="math">P_{PC}</span>  and  <span class="math">V_{PC}</span> .  <span class="math">P_{PC}</span>  is given  <span class="math">f_1, \\ldots, f_t \\in \\mathbb{F}_{\\leq d}[X]</span> .  <span class="math">P_{PC}</span>  and  <span class="math">V_{PC}</span>  are both given integer  <span class="math">t = \\text{poly}(\\lambda)</span> ,  <span class="math">cm_1, \\ldots, cm_t</span>  the alleged commitments to  <span class="math">f_1, \\ldots, f_t, z_1, \\ldots, z_t \\in \\mathbb{F}</span>  and  <span class="math">s_1, \\ldots, s_t \\in \\mathbb{F}</span>  the alleged correct openings  <span class="math">f_1(z_1), \\ldots, f_t(z_t)</span> . At the end of the protocol  <span class="math">V_{PC}</span>  outputs acc or rej.</li>
    </ul>

    <p class="text-gray-300">such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Completeness: Fix integer  <span class="math">t, z_1, \\ldots, z_t \\in \\mathbb{F}, f_1, \\ldots, f_t \\in \\mathbb{F}_{&lt; d}[X]</span> . Suppose that for each  <span class="math">i \\in [t]</span> ,  <span class="math">\\mathsf{cm}_i = \\mathsf{com}(f_i, \\mathsf{srs})</span> . Then if open is run correctly with values  <span class="math">t, \\{\\mathsf{cm}_i, z_i, s_i = f_i(z_i)\\}_{i \\in [t]}</span> ,  <span class="math">\\mathsf{V}_{\\mathsf{PC}}</span>  outputs acc with probability one.</li>
      <li>Knowledge soundness in the algebraic group model: There exists an efficient E such that for any algebraic adversary A the probability of A winning the following game is  <span class="math">negl(\\lambda)</span>  over the randomness of A and gen.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Given srs,  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">t, \\operatorname{cm}_1, \\ldots, \\operatorname{cm}_t</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E, given access to the messages of A during the previous step, outputs  <span class="math">f_1, \\ldots, f_t \\in \\mathbb{F}_{\\leq d}[X]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A outputs  <span class="math">z_1, \\ldots, z_t \\in \\mathbb{F}, s_1, \\ldots, s_t \\in \\mathbb{F}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A takes the part of  <span class="math">P_{PC}</span>  in the protocol open with inputs  <span class="math">cm_1, \\ldots, cm_t, z_1, \\ldots, z_t, s_1, \\ldots, s_t</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A wins if</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V<sub>PC</sub> outputs acc at the end of the protocol.</li>
      <li>For some  <span class="math">i \\in [t]</span> ,  <span class="math">s_i \\neq f_i(z_i)</span> .</li>
    </ul></li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><strong>Remark 3.2.</strong> Note that the above notion of knowledge soundness for a PCS does not coincide with that of knowledge soundness for a relation as defined in Section 2.2. The goal is to capture the notion of  <span class="math">\\mathcal{A}</span>  &quot;knowing&quot; during commitment time the polynomial they later answer queries about. Arguably, this could have been called binding knowledge soundness, but we stick with the shorter term.</p>

    <p class="text-gray-300">It's interesting to note that the algebraic group model is crucial for allowing us to model both binding and knowledge soundness in one clean game - without it we typically cannot require E to return the polynomial immediately after  <span class="math">\\mathcal{A}</span> 's commitment. Rather, E may require rewinding  <span class="math">\\mathcal{A}</span>  during the open procedure for that. This is one reason why papers that deal with generic PCS, e.g. Section 2.3 of [BDFG20], define separate notions of knowledge soundness and binding.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 The PCS</h3>

    <p class="text-gray-300">We describe the following scheme based on [KZG10, MBKM].</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\operatorname{gen}(d)</span>  - choose uniform  <span class="math">x \\in \\mathbb{F}</span> . Output  <span class="math">\\operatorname{srs} = ([1]_1, [x]_1, \\dots, [x^{d-1}]_1, [1]_2, [x]_2)</span> .</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>com(f,srs) := [f(x)]<sup>1</sup> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We first describe the open protocol in the case z<sup>1</sup> = . . . = z<sup>t</sup> = z. open({cmi} , {zi} , {si}):</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) VPC sends random &gamma; &isin; F.</li>
      <li>(b) PPC computes the polynomial</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$h(X) := \\sum_{i=1}^{t} \\gamma^{i-1} \\cdot \\frac{f_i(X) - f_i(z)}{X - z}</span>$</p>

    <p class="text-gray-300">and using srs computes and sends W := [h(x)]<sup>1</sup> .</p>

    <p class="text-gray-300">(c) VPC computes the elements</p>

    <p class="text-gray-300"><span class="math">$F := \\sum_{i \\in [t]} \\gamma^{i-1} \\cdot \\mathsf{cm}_i, v := \\left[ \\sum_{i \\in [t]} \\gamma^{i-1} \\cdot s_i \\right]_1</span>$</p>

    <p class="text-gray-300">(d) VPC outputs acc if and only if</p>

    <p class="text-gray-300"><span class="math">$e(F - v, [1]_2) \\cdot e(-W, [x - z]_2) = 1.</span>$</p>

    <p class="text-gray-300">We argue knowledge soundness for the above protocol. More precisely, we argue the existence of an efficient E such that an algebraic adversary A can only win the KS game w.p. negl(&lambda;) when restricting itself to choosing z = z<sup>1</sup> = . . . = z<sup>t</sup> .</p>

    <p class="text-gray-300">Let A be such an algebraic adversary.</p>

    <p class="text-gray-300">A begins by outputting cm1, . . . , cm<sup>t</sup> . Each cm<sup>i</sup> is a linear combination Pd&minus;<sup>1</sup> <sup>j</sup>=0 ai,j x j 1 . E, who is given the coefficients {ai,j}, simply outputs the polynomials</p>

    <p class="text-gray-300"><span class="math">$f_i(X) := \\sum_{j=0}^{d-1} a_{i,j} \\cdot X^j.</span>$</p>

    <p class="text-gray-300">A now outputs z, s1, . . . , s<sup>t</sup> &isin; F. Assume that for some i &isin; [t], fi(z) &#824;= s<sup>i</sup> . We show that for any strategy of A from this point, Vpoly outputs acc w.p negl(&lambda;).</p>

    <p class="text-gray-300">In the first step of open, Vpoly chooses a random &gamma; &isin; F. Define</p>

    <p class="text-gray-300"><span class="math">$f(X) := \\sum_{i \\in [t]} \\gamma^{i-1} \\cdot f_i(X), s := \\sum_{i \\in [t]} \\gamma^{i-1} \\cdot s_i.</span>$</p>

    <p class="text-gray-300">We have that e.w.p. t/|F|, f(z) &#824;= s. Now A outputs W = H(x) for some H &isin; F&lt;d[X]. According to Lemma <a href="#page-9-0">2.2,</a> it suffices to upper bound the probability that the ideal check corresponding to the real pairing check in the protocol passes. It has the form</p>

    <p class="text-gray-300"><span class="math">$f(X) - s \\equiv H(X)(X - z).</span>$</p>

    <p class="text-gray-300">The check passing implies that f(X) - s is divisible by (X - z), which implies f(z) = s. Thus the ideal check can only pass w.p.  <span class="math">\\operatorname{negl}(\\lambda)</span>  over the randomness of  <span class="math">V_{\\text{poly}}</span> , which implies the same thing for the real check according to Lemma 2.2.</p>

    <p class="text-gray-300">The open protocol for multiple evaluation points simply consists of running in parallel the open protocol for each evaluation point and the polynomials evaluated at that point. And then applying a generic method for batch randomized evaluation of pairing equations. For notational simplicity we describe the open protocol explicitly only in the case of two distinct evaluation points among  <span class="math">z_1, \\ldots, z_t</span>  (this also happens to be our case in the main protocol). For this, let us denote the distinct evaluation points by z, z' and by  <span class="math">t_1, t_2</span>  the number of polynomials and by  <span class="math">\\{f_i\\}_{i \\in [t_1]}, \\{f&#x27;_i\\}_{i \\in [t_2]}</span>  the polynomials to be evaluated at z, z' respectively.</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{open}(\\left\\{cm_i\\right\\}_{i\\in\\left[t_1\\right]},\\left\\{cm_i&#x27;\\right\\}_{i\\in\\left[t_2\\right]},\\left\\{z,z&#x27;\\right\\},\\left\\{s_i,s_i&#x27;\\right\\}):</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">V_{PC}</span>  sends random  <span class="math">\\gamma, \\gamma&#x27; \\in \\mathbb{F}</span> .</li>
      <li>(b)  <span class="math">P_{\\sf PC}</span>  computes the polynomials</li>
    </ul>

    <p class="text-gray-300"><span class="math">$h(X) := \\sum_{i=1}^{t_1} \\gamma^{i-1} \\cdot \\frac{f_i(X) - f_i(z)}{X - z}</span>$</p>

    <p class="text-gray-300"><span class="math">$h&#x27;(X) := \\sum_{i=1}^{t_2} \\gamma&#x27;^{i-1} \\cdot \\frac{f_i&#x27;(X) - f_i&#x27;(z&#x27;)}{X - z&#x27;}</span>$</p>

    <p class="text-gray-300">and using srs computes and sends  <span class="math">W := [h(x)]_1, W&#x27; := [h&#x27;(x)]_1</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(c)  <span class="math">V_{PC}</span>  chooses random  <span class="math">r&#x27; \\in \\mathbb{F}</span> .</li>
      <li>(d) V<sub>PC</sub> computes the element</li>
    </ul>

    <p class="text-gray-300"><span class="math">$F := \\left(\\sum_{i \\in [t_1]} \\gamma^{i-1} \\cdot \\mathsf{cm}_i - \\left[\\sum_{i \\in [t_1]} \\gamma^{i-1} \\cdot s_i\\right]_1\\right) + r&#x27; \\cdot \\left(\\sum_{i \\in [t_2]} \\gamma&#x27;^{i-1} \\cdot \\mathsf{cm}_i&#x27; - \\left[\\sum_{i \\in [t_2]} \\gamma&#x27;^{i-1} \\cdot s_i&#x27;\\right]_1\\right)</span>$</p>

    <p class="text-gray-300">V<sub>PC</sub> computes outputs acc if and only if</p>

    <p class="text-gray-300"><span class="math">$e\\left(F+z\\cdot W+r&#x27;z&#x27;\\cdot W&#x27;,\\left[1\\right]_{2}\\right)\\cdot e(-W-r&#x27;\\cdot W&#x27;,\\left[x\\right]_{2})=1.</span>$</p>

    <p class="text-gray-300">We summarize the efficiency properties of this batched version of the [KZG10] scheme.</p>

    <p class="text-gray-300"><strong>Lemma 3.3.</strong> Fix positive integer d. There is a d-polynomial commitment scheme  <span class="math">\\mathscr{S}</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) For  <span class="math">n \\leq d</span>  and  <span class="math">f \\in \\mathbb{F}_{&lt; n}[X]</span> , computing com(f) requires  <span class="math">n \\ \\mathbb{G}_1</span> -exponentiations.</li>
      <li>(b) Given  <span class="math">\\mathbf{z} := (z_1, \\ldots, z_t) \\in \\mathbb{F}^t, f_1, \\ldots, f_t \\in \\mathbb{F}_{&lt; d}[X]</span> , denote by  <span class="math">t^*</span>  the number of distinct values in  <span class="math">\\mathbf{z}</span> ; and for  <span class="math">i \\in [t^*]</span> ,  <span class="math">d_i := \\max\\{\\deg(f_i)\\}_{i \\in S_i}</span>  where  <span class="math">S_i</span>  is the set of indices j such that  <span class="math">z_j</span>  equals the i'th distinct point in  <span class="math">\\mathbf{z}</span> . Let  <span class="math">\\mathsf{cm}_i = \\mathsf{com}(f_i)</span> . Then open  <span class="math">(\\{cm_i, f_i, z_i, s_i\\})</span>  requires    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i.  <span class="math">\\sum_{i \\in [t^*]} d_i \\mathbb{G}_1</span> -exponentiations of  <span class="math">P_{PC}</span></li>
      <li>ii.  <span class="math">t + 2t^* 2</span>   <span class="math">\\mathbb{G}_1</span> -exponentiations and 2 pairings of  <span class="math">V_{PC}</span></li>
    </ul></li>
    </ul>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Idealised low-degree protocols</h2>

    <p class="text-gray-300">We define a limited type of protocol between a prover and a verifier to cleanly capture and abstract the use of a polynomial commitment scheme such as [KZG10]. In this protocol, the prover sends low-degree polynomials to a third trusted party  <span class="math">\\mathcal{I}</span> . The verifier may then ask  <span class="math">\\mathcal{I}</span>  whether certain identities hold between the prover's polynomials, and additional predefined polynomials known to the verifier.</p>

    <p class="text-gray-300"><strong>Definition 4.1.</strong> Fix positive integers  <span class="math">d, D, t, \\ell</span> . A  <span class="math">(d, D, t, \\ell)</span> -polynomial protocol is a multiround protocol between a prover  <span class="math">P_{\\mathsf{poly}}</span> , verifier  <span class="math">V_{\\mathsf{poly}}</span>  and trusted party  <span class="math">\\mathcal I</span>  that proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The protocol definition includes a set of preprocessed polynomials  <span class="math">g_1, \\ldots, g_\\ell \\in \\mathbb{F}_{\\leq d}[X]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The messages of  <span class="math">P_{poly}</span>  are sent to  <span class="math">\\mathcal{I}</span>  and are of the form f for  <span class="math">f \\in \\mathbb{F}_{&lt; d}[X]</span> . If  <span class="math">P_{poly}</span>  sends a message not of this form, the protocol is aborted.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The messages of  <span class="math">V_{\\mathsf{poly}}</span>  to  <span class="math">P_{\\mathsf{poly}}</span>  are arbitrary (but we will concentrate on public coin protocols where the messages are simply random coins).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the end of the protocol, suppose  <span class="math">f_1, \\ldots, f_t</span>  are the polynomials that were sent from  <span class="math">P_{poly}</span>  to  <span class="math">\\mathcal{I}</span> .  <span class="math">V_{poly}</span>  may ask  <span class="math">\\mathcal{I}</span>  if certain polynomial identities hold between  <span class="math">\\{f_1, \\ldots, f_t, g_1, \\ldots, g_\\ell\\}</span> . Where each identity is of the form</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$F(X) := G(X, h_1(v_1(X)), \\dots, h_M(v_M(X))) \\equiv 0,</span>$</p>

    <p class="text-gray-300">for some  <span class="math">h_i \\in \\{f_1, \\ldots, f_t, g_1, \\ldots, g_\\ell\\}</span> ,  <span class="math">G \\in \\mathbb{F}[X, X_1, \\ldots, X_M]</span> ,  <span class="math">v_1, \\ldots, v_M \\in \\mathbb{F}_{&lt; d}[X]</span>  such that  <span class="math">F \\in \\mathbb{F}_{&lt; D}[X]</span>  for every choice of  <span class="math">f_1, \\ldots, f_t</span>  made by  <span class="math">P_{\\mathsf{poly}}</span>  when following the protocol correctly.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>After receiving the answers from  <span class="math">\\mathcal{I}</span>  regarding the identities,  <span class="math">V_{\\mathsf{poly}}</span>  outputs acc if all identities hold, and outputs rej otherwise.</li>
    </ol>

    <p class="text-gray-300"><strong>Remark 4.2.</strong> A more expressive model would be to have  <span class="math">P_{poly}</span>  send messages (f, n) for  <span class="math">n \\leq d</span>  to  <span class="math">\\mathcal{I}</span>  instead of just f; and have  <span class="math">\\mathcal{I}</span>  enforce  <span class="math">f \\in \\mathbb{F}_{&lt; n}[X]</span> . We avoid doing this as this extra power is not needed for our protocol, and results in reduced efficiency as it translates to needing to use a polynomial commitment scheme with the ability to dynamically enforce a smaller than d degree bound (as the [MBKM]-variant of [KZG10] is able to do).</p>

    <p class="text-gray-300">We define polynomial protocols for relations in the natural way.</p>

    <p class="text-gray-300"><strong>Definition 4.3.</strong> Given a relation  <span class="math">\\mathcal{R}</span> , a polynomial protocol for  <span class="math">\\mathcal{R}</span>  is a polynomial protocol with the following additional properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the beginning of the protocol,  <span class="math">P_{\\mathsf{poly}}</span>  and  <span class="math">V_{\\mathsf{poly}}</span>  are both additionally given an input x. The description of  <span class="math">P_{\\mathsf{poly}}</span>  assumes possession of  <span class="math">\\omega</span>  such that  <span class="math">(x, \\omega) \\in \\mathcal{R}</span> .</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Completeness: If Ppoly follows the protocol correctly using a witness &omega; for x, Vpoly accepts with probability one.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Knowledge Soundness: There exists an efficient E, that given access to the messages of Ppoly to I outputs &omega; such that, for any strategy of Ppoly, the probability of the following event is negl(&lambda;).</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Vpoly outputs acc at the end of the protocol, and</li>
      <li>(b) (x, &omega;) &isin; R/ .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Remark 4.4. We intentionally do not define a zero-knowledge property for idealized protocols, as achieving ZK will depend on how much information on the polynomials sent to I is leaked in the final &quot;compiled&quot; protocol. This in turn depends on specific details of the polynomial commitment scheme used for compilation.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Polynomial protocols on ranges</h3>

    <p class="text-gray-300">In our protocol Vpoly actually needs to check if certain polynomial equations hold on a certain range of input values, rather than as a polynomial identity. Motivated by this, for a subset S &sub; F, we define an S-ranged (d, D, t, &#8467;)-polynomial protocol identically to a (d, D, t, &#8467;)-polynomial protocol, except that the verifier asks if his identities hold on all points of S, rather than identically. We then define ranged polynomial protocols for relations in the exact same way as in Definition <a href="#page-13-0">4.3.</a></p>

    <p class="text-gray-300">We show that converting a ranged protocol to a polynomial protocol only incurs one additional prover polynomial.</p>

    <p class="text-gray-300">Lemma 4.5. Let P be an S-ranged (d, D, t, &#8467;)-polynomial protocol for R. Then we can construct a (max {d, |S|, D &minus; |S|} , D, t + 1, &#8467; + 1)-polynomial protocol P<sup>&lowast;</sup> for R.</p>

    <p class="text-gray-300">For the lemma, we use the following simple claim.</p>

    <p class="text-gray-300">Claim 4.6. Fix F1, . . . , F<sup>k</sup> &isin; F&lt;n[X]. Fix Z &isin; F&lt;n[X]. Suppose that for some i &isin; [k], Z &#8740; Fi. Then</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>e.w.p 1/|F| over uniform a1, . . . , a<sup>k</sup> &isin; F, Z doesn't divide</li>
    </ol>

    <p class="text-gray-300"><span class="math">$F := \\sum_{j=1}^{k} a_j \\cdot F_j.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Assuming Z decomposes to distinct linear factors over F, e.w.p k/|F| over uniform a &isin; F, Z doesn't divide</li>
    </ol>

    <p class="text-gray-300"><span class="math">$G := \\sum_{j=1}^{k} a^{j-1} \\cdot F_j.</span>$</p>

    <p class="text-gray-300">Proof. Z|F is equivalent to F mod Z = 0. Denoting R := F<sup>i</sup> mod Z, we have that R &#824;= 0; i.e. R isn't the zero polynomial. And we have</p>

    <p class="text-gray-300"><span class="math">$F = \\sum_{j=1, j \\neq i}^{k} a_j \\cdot F_j + a_i \\cdot R \\pmod{Z}</span>$</p>

    <p class="text-gray-300">Thus, for any fixing of {aj}j&#824;=<sup>i</sup> there is at most one value a<sup>i</sup> &isin; F such that F mod Z = 0. The first item of the claim follows.</p>

    <p class="text-gray-300">To prove the second, write similarly</p>

    <p class="text-gray-300"><span class="math">$G = \\sum_{j=1, j \\neq i}^{k} a^{j-1} \\cdot F_j + a^{i-1} \\cdot R \\pmod{Z}</span>$</p>

    <p class="text-gray-300">Let x &isin; F be such that Z(x) = 0 but R(x) &#824;= 0. Then G mod Z = 0 implies G(x) = 0, which means a is a root of the non-zero polynomial</p>

    <p class="text-gray-300"><span class="math">$g(Y) := \\sum_{j=1, j \\neq i}^{k} Y^{j-1} \\cdot F_j(x) + Y^{i-1} \\cdot R(x),</span>$</p>

    <p class="text-gray-300">which is the case for at most k values of a.</p>

    <p class="text-gray-300">Proof. (Of Lemma <a href="#page-14-0">4.5)</a> Let P be the S-ranged (d, D, t, &#8467;)-polynomial protocol. We construct the protocol P<sup>&lowast;</sup> . The set of preprocessed polynomials in P<sup>&lowast;</sup> are the same as in P with the addition of ZS(X) := Q a&isin;S (X &minus; a). P<sup>&lowast;</sup> proceeds exactly as P until the point where Vpoly asks about identities on S. Suppose that the k identities the verifier asks about are F1(X), . . . , Fk(X) (where each F<sup>i</sup> is of total degree at most D and of the form described in Definition <a href="#page-13-1">4.1)</a>. P<sup>&lowast;</sup> now proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Vpoly sends uniform a1, . . . , a<sup>k</sup> &isin; F to Ppoly.</li>
      <li>Ppoly computes the polynomial T := P i&isin;[k] ai&middot;F<sup>i</sup> Z<sup>S</sup> .</li>
      <li>Ppoly sends T to I.</li>
      <li>Vpoly queries the identity</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{i \\in [k]} a_i \\cdot F_i(X) \\equiv T \\cdot Z_S</span>$</p>

    <p class="text-gray-300">It follows from Claim <a href="#page-14-1">4.6</a> that e.w.p. 1/|F| over Vpoly's choice of a1, . . . , ak, the existence of an appropriate T &isin; F[X] is equivalent to F1, . . . , F<sup>k</sup> vanishing on S. This in turn is equivalent to Vpoly outputting acc in the analogous execution of P.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 From polynomial protocols to protocols against algebraic adversaries</h3>

    <p class="text-gray-300">We wish to use the polynomial commitment scheme of Section 3 to compile a polynomial protocol into one with knowledge soundness in the algebraic group model (in the sense defined in Section 2.2).</p>

    <p class="text-gray-300">For the purpose of capturing the efficiency of the transformation, we first define somewhat technical measures of the  <span class="math">(d, D, t, \\ell)</span> -polynomial protocol  <span class="math">\\mathscr{P}</span> .</p>

    <p class="text-gray-300">For  <span class="math">i \\in [t]</span> , let  <span class="math">d_i</span>  be the maximal degree of  <span class="math">f_i</span>  sent by an honest prover in  <span class="math">\\mathscr{P}</span> . Assume only one identity  <span class="math">G(X, h_1(v_1(X)), \\ldots, h_M(v_M(X))) \\equiv 0</span>  is checked by  <span class="math">V_{poly}</span>  in  <span class="math">\\mathscr{P}</span> .</p>

    <p class="text-gray-300">For  <span class="math">i \\in [M]</span> , let  <span class="math">d&#x27;_i</span>  be the &quot;matching&quot;  <span class="math">d_j</span> . That is  <span class="math">d&#x27;_i = d_j</span>  if  <span class="math">h_i = f_j</span> , and  <span class="math">d&#x27;_i = \\deg(g_j)</span>  if  <span class="math">h_i = g_j</span> .</p>

    <p class="text-gray-300">Let  <span class="math">t^* = t^*(\\mathscr{P})</span>  be the number of distinct polynomials amongst  <span class="math">v_1, \\ldots, v_M</span> . Let  <span class="math">S_1 \\cup \\ldots \\cup S_{t^*} = [M]</span>  be a partition of [M] according to the distinct values. For  <span class="math">j \\in [t^*]</span> , let  <span class="math">e_j := \\max\\{d_i&#x27;\\}_{i \\in S_i}</span></p>

    <p class="text-gray-300">Finally, define  <span class="math">e(\\mathscr{P}) := \\sum_{i \\in [t]} (d_i + 1) + \\sum_{j \\in [t^*]} e_j</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4.7.</strong> Let  <span class="math">\\mathscr{P}</span>  be a public coin  <span class="math">(d, D, t, \\ell)</span> -polynomial protocol for a relation  <span class="math">\\mathscr{R}</span>  where only one identity is checked by  <span class="math">V_{\\mathsf{poly}}</span> . Then we can construct a protocol  <span class="math">\\mathscr{P}^*</span>  for  <span class="math">\\mathscr{R}</span>  with knowledge soundness in the Algebraic Group Model under 2d-DLOG such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover <strong>P</strong> in  <span class="math">\\mathscr{P}^*</span>  requires  <span class="math">e(\\mathscr{P})</span>   <span class="math">\\mathbb{G}_1</span> -exponentiations.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The total prover communication consists of  <span class="math">t + t^*(\\mathscr{P})</span>   <span class="math">\\mathbb{G}_1</span>  elements and M  <span class="math">\\mathbb{F}</span> -elements.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier V requires  <span class="math">t + t^*(\\mathscr{P})</span>   <span class="math">\\mathbb{G}_1</span> -exponentiations, two pairings and one evaluation of G.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathscr{S}=(\\mathsf{gen},\\mathsf{com},\\mathsf{open})</span>  be the d-polynomial commitment scheme described in Lemma 3.3. The SRS of  <span class="math">\\mathscr{P}^*</span>  includes  <span class="math">\\mathsf{srs}=\\mathsf{gen}(d)</span> , with the addition of  <span class="math">\\{\\mathsf{com}(g_1),\\ldots,\\mathsf{com}(g_\\ell)\\}</span> . Given  <span class="math">\\mathscr{P}</span>  we describe  <span class="math">\\mathscr{P}^*</span> .  <span class="math">\\mathbf{P}</span>  and  <span class="math">\\mathbf{V}</span>  behave identically to  <span class="math">\\mathsf{P}_{\\mathsf{poly}}</span>  and  <span class="math">\\mathsf{V}_{\\mathsf{poly}}</span> , except in the following two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever  <span class="math">P_{\\mathsf{poly}}</span>  sends a polynomial  <span class="math">f_i \\in \\mathbb{F}_{&lt; d}[X]</span>  to  <span class="math">\\mathcal{I}</span>  in  <span class="math">\\mathscr{P}</span> ,  <span class="math">\\mathbf{P}</span>  sends  <span class="math">\\mathsf{cm}_i = \\mathsf{com}(f_i)</span>  to  <span class="math">\\mathbf{V}</span> .</li>
      <li>Let  <span class="math">v_1^*, \\ldots, v_{t^*}^*</span>  be the distinct polynomials amongst  <span class="math">v_1, \\ldots, v_M</span> . When  <span class="math">V_{poly}</span>  asks about the identity</li>
    </ul>

    <p class="text-gray-300"><span class="math">$F(X) := G(X, h_1(v_1(X)), \\dots, h_M(v_M(X))) \\equiv 0,</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V chooses random  <span class="math">x \\in \\mathbb{F}</span> , computes  <span class="math">v_1^*(x), \\ldots, v_{t^*}^*(x)</span> , and sends x to <strong>P</strong>.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> replies with  <span class="math">\\{s_i\\}_{i\\in[M]}</span> , which are the alleged values  <span class="math">h_1(v_1(x)),\\ldots,h_M(v_M(x))</span> .</li>
    </ol></li>
      <li>3. V engages in the protocol open with P to verify the correctness of  <span class="math">\\{s_i\\}</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V outputs acc if and only if</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$G(x, s_1, \\dots, s_M) = 0.</span>$</p>

    <p class="text-gray-300">The efficiency claims about P<sup>&lowast;</sup> follow directly from Lemma <a href="#page-12-0">3.3.</a></p>

    <p class="text-gray-300">To prove the claim about knowledge soundness in the AGM we must describe the extractor E for the protocol P<sup>&lowast;</sup> . For this purpose, let E<sup>P</sup> be the extractor of the protocol P as guaranteed to exist from Definition <a href="#page-13-0">4.3,</a> and E<sup>S</sup> be the extractor for the Knowledge Soundness game of S as in Definition <a href="#page-9-2">3.1.</a></p>

    <p class="text-gray-300">Now assume an algebraic adversary A is taking the role of P in P<sup>&lowast;</sup> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E sends the commitments cm1, . . . , cm<sup>t</sup> to E<sup>S</sup> and receives in return f1, . . . , f<sup>t</sup> &isin; F&lt;d[X].</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E plays the role of I in interaction with EP, sending him the polynomials f1, . . . , f<sup>t</sup> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When E<sup>P</sup> outputs &omega;, E also outputs &omega;.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Now let us define two events (over the randomness of V,A and gen):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We think of an adversary A<sup>P</sup> participating in P, and using the polynomials f1, . . . , f<sup>t</sup> as their messages to I. We define A to be the event that the identity F held, but (x, &omega;) &isin; R/ . By the KS of P, Pr(A) = negl(&lambda;).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We let B be the event that for some i &isin; [M], hi(vi(x)) &#824;= s<sup>i</sup> , and at the same time VPC has output acc when open was run as a subroutine in Step <a href="#page-16-0">3.</a> By the KS of S , Pr(B) = negl(&lambda;).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Now look at the event C that V outputs acc, but E failed in the sense that (x, &omega;) &isin; R/ . We split C into two events.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A or B also happened this has negl(&lambda;) probability.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C happened but not A or B. This means F is not the zero polynomial, but F(x) = 0; which happens w.p. negl(&lambda;).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Reducing the number of field elements We describe an optimization by Mary Maller, to reduce the number of F-elements in the proof from M. We begin with an illustrating example. Suppose V wishes to check the identity h1(X) &middot; h2(X) &minus; h3(X) &equiv; 0. The compilation described above would have P send the values of h1, h2, h<sup>3</sup> at a random x &isin; F; and V would check if h1(x)h2(x)&minus;h3(x) = 0. Thus, P sends three field elements.</p>

    <p class="text-gray-300">Note however, that we could instead have P send only c := h1(x), and then simply verify in the open protocol whether the polynomial L(X) := c &middot; h2(X) &minus; h3(X) is equal to zero at x. (Note that we can compute com(L) = c &middot; com(h2) &minus; com(h3).) We refer to L later as the linearisation polynomial.</p>

    <p class="text-gray-300">To describe the general method, we must define another technical measure of a polynomial protocol. We assume again (mainly for simplicity) that Vpoly checks only one identity F. Now define r(P) to be the minimal size of a subset S &sub; [M] such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">([M] \\setminus S) \\subset S_i</span>  for one of the subsets  <span class="math">S_i</span>  of the partition described before Lemma 4.7.</li>
      <li><span class="math">\\bullet</span>  The polynomial G such that</li>
    </ul>

    <p class="text-gray-300"><span class="math">$F(X) := G(X, h_1(v_1(X)), \\dots, h_M(v_M(X)))</span>$</p>

    <p class="text-gray-300">has degree zero or one as a polynomial in the variables  <span class="math">\\{X_j\\}_{j\\in[M]\\backslash S}</span>  whose coefficients are polynomials in X and  <span class="math">\\{X_j\\}_{j\\in S}</span> .</p>

    <p class="text-gray-300">Assume  <span class="math">\\mathscr{P}</span>  is such that  <span class="math">\\mathsf{r} := \\mathsf{r}(\\mathscr{P}) &lt; M</span> . We claim that the reduction of Lemma 4.7 can be changed so that only  <span class="math">\\mathsf{r}</span>   <span class="math">\\mathbb{F}</span> -elements are sent by  <span class="math">\\mathbf{P}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>P</strong> now sends only  <span class="math">\\{s_i = h_i(v_i(x))\\}_{i \\in S}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Now let L be the restriction  <span class="math">G|_{X=x;X_i=s_i,i\\in S}</span> .  <span class="math">\\mathbf{V}</span>  and  <span class="math">\\mathbf{P}</span>  use  <span class="math">\\{\\mathsf{com}(f_i)\\}_{i\\in S}</span> , and the linearity of  <span class="math">\\mathsf{com}</span> , to compute the commitment to the corresponding restriction  <span class="math">F_L</span>  of F.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Now <strong>P</strong> and <strong>V</strong> engage in the protocol open to verify the correctness of the evaluations  <span class="math">\\{s_i\\}_{i\\in S}</span> , and additionally to verify  <span class="math">F_L(x)=0</span> .</li>
    </ol></li>
    </ul>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Polynomial protocols for identifying permutations</h2>

    <p class="text-gray-300">At the heart of our universal SNARK is a &quot;permutation check&quot; inspired by the permutation argument originally presented by Bayer and Groth [BG12] and its variants in [BCC<sup>+</sup>16, MBKM]. Again, our main advantage over [MBKM] is getting a simpler protocol by working with <em>univariate</em> polynomials and multiplicative subgroups.</p>

    <p class="text-gray-300">Degree bounds: We use two integer parameters  <span class="math">n \\leq d</span> . Intuitively, n is the degree of the honest prover's polynomials, and d is the bound we actually enforce on malicious provers. Accordingly, we assume degree bound n while analyzing prover efficiency and describing &quot;official&quot; protocol inputs; but allow degree bound d while analyzing soundness.</p>

    <p class="text-gray-300">We assume the existence of a multiplicative subgroup  <span class="math">H\\subset \\mathbb{F}</span>  of order n with generator  <span class="math">\\mathbf{g}.</span></p>

    <p class="text-gray-300">For  <span class="math">i \\in [n]</span> , we denote by  <span class="math">L_i(X)</span>  the element of  <span class="math">\\mathbb{F}_{&lt; n}[X]</span>  with  <span class="math">L_i(\\mathbf{g}^i) = 1</span>  and  <span class="math">L_i(a) = 0</span>  for  <span class="math">a \\in H</span>  different from  <span class="math">\\mathbf{g}^i</span> , i.e.  <span class="math">\\{L_i\\}_{i \\in [n]}</span>  is a Lagrange basis for H.</p>

    <p class="text-gray-300">One thing to note is that the  <span class="math">\\{L_i\\}</span>  can &quot;reduce point checks to range checks&quot;. More precisely, the following claim follows directly from the definition of  <span class="math">\\{L_i\\}</span> .</p>

    <p class="text-gray-300">Claim 5.1. Fix  <span class="math">i \\in [n]</span> , and  <span class="math">Z, Z^* \\in \\mathbb{F}[X]</span> . Then  <span class="math">L_i(a)(Z(a) - Z^*(a)) = 0</span>  for each  <span class="math">a \\in H</span>  if and only if  <span class="math">Z(\\mathbf{g}^i) = Z^*(\\mathbf{g}^i)</span> .</p>

    <p class="text-gray-300">For  <span class="math">f, g \\in \\mathbb{F}_{&lt; d}[X]</span>  and a permutation  <span class="math">\\sigma : [n] \\to [n]</span> , we write  <span class="math">g = \\sigma(f)</span>  if for each  <span class="math">i \\in [n], g(\\mathbf{g}^i) = f(\\mathbf{g}^{\\sigma(i)})</span> .<sup>8</sup></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>Note that according to this definition there are multiple g with  <span class="math">g = \\sigma(f)</span> . Intuitively, we think of  <span class="math">\\sigma(f)</span>  as the unique such  <span class="math">g \\in \\mathbb{F}_{\\leq n}[X]</span> , but do not define this formally to avoid needing to enforce this degree bound for efficiency reasons.</p>

    <p class="text-gray-300">We present a ranged polynomial protocol enabling  <span class="math">P_{poly}</span>  to prove that  <span class="math">g = \\sigma(f)</span> .</p>

    <p class="text-gray-300">Preprocessed polynomials: The polynomial  <span class="math">\\mathsf{S}_{\\mathsf{ID}} \\in \\mathbb{F}_{&lt; n}[X]</span>  defined by  <span class="math">\\mathsf{S}_{\\mathsf{ID}}(\\mathbf{g}^i) = i</span>  for each  <span class="math">i \\in [n]</span>  and  <span class="math">\\mathsf{S}_{\\sigma} \\in \\mathbb{F}_{&lt; n}[X]</span>  defined by  <span class="math">\\mathsf{S}_{\\sigma}(\\mathbf{g}^i) = \\sigma(i)</span>  for each  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">Inputs:  <span class="math">f, g \\in \\mathbb{F}_{\\leq n}[X]</span></p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Protocol:</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">V_{poly}</span>  chooses random  <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span>  and sends them to  <span class="math">P_{poly}</span> .</p></li>
      <li><p class="text-gray-300">Let
<span class="math">$f&#x27; := f + \\beta \\cdot \\mathsf{S}_{\\mathsf{ID}} + \\gamma, g&#x27; := g + \\beta \\cdot \\mathsf{S}_{\\sigma} + \\gamma</span>$</p></li>
      <li><p class="text-gray-300">That is, for  <span class="math">i \\in [n]</span></p></li>
    </ol>

    <p class="text-gray-300"><span class="math">$f&#x27;(\\mathbf{g}^i) = f(\\mathbf{g}^i) + \\beta \\cdot i + \\gamma, g&#x27;(\\mathbf{g}^i) = g(\\mathbf{g}^i) + \\beta \\cdot \\sigma(i) + \\gamma</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P<sub>poly</sub> computes  <span class="math">Z \\in \\mathbb{F}_{\\leq n}[X]</span> , such that  <span class="math">Z(\\mathbf{g}) = 1</span> ; and for  <span class="math">i \\in \\{2, \\dots, n\\}</span></li>
    </ol>

    <p class="text-gray-300"><span class="math">$Z(\\mathbf{g}^i) = \\prod_{1 \\le j &lt; i} f&#x27;(\\mathbf{g}^j) / g&#x27;(\\mathbf{g}^j).</span>$</p>

    <p class="text-gray-300">(If one of the product elements is undefined, which happens w.p.  <span class="math">\\mathsf{negl}(\\lambda)</span>  over  <span class="math">\\gamma</span> , the protocol is aborted<sup>9</sup>.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_{poly}</span>  sends Z to  <span class="math">\\mathcal{I}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{poly}</span>  checks if for all  <span class="math">a \\in H</span></li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">L_1(a)(Z(a)-1)=0</span> .</li>
      <li>(b)  <span class="math">Z(a)f&#x27;(a) = g&#x27;(a)Z(a \\cdot \\mathbf{g}).</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">and outputs acc iff all checks hold.</p>

    <p class="text-gray-300"><strong>Lemma 5.2.</strong> Fix  <span class="math">f, g \\in \\mathbb{F}_{\\leq d}[X]</span> . For any strategy of  <span class="math">P_{\\mathsf{poly}}</span> , the probability of  <span class="math">V_{\\mathsf{poly}}</span>  outputting acc in the above protocol when  <span class="math">g \\neq \\sigma(f)</span>  is  <span class="math">\\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that  <span class="math">g \\neq \\sigma(f)</span> . By claim A.1, e.w.p  <span class="math">negl(\\lambda)</span>  over the choice of  <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span> ,</p>

    <p class="text-gray-300"><span class="math">$a := \\prod_{i \\in [n]} f&#x27;(\\mathbf{g}^i) \\neq b := \\prod_{i \\in [n]} g&#x27;(\\mathbf{g}^i).</span>$</p>

    <p class="text-gray-300">Assume  <span class="math">\\beta, \\gamma</span>  were chosen such that the above holds, and also such that  <span class="math">g&#x27;(\\mathbf{g}^i) \\neq 0</span>  for all  <span class="math">i \\in [n]</span> . We show  <span class="math">V_{poly}</span>  rejects; specifically, that assuming both identities  <span class="math">V_{poly}</span>  checks hold leads to contradiction.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup>This abort ruins the perfect completeness of the protocol. If one wishes to preserve perfect completeness, the protocol can be altered such that if for some  <span class="math">i, g&#x27;(\\mathbf{g}^i) = 0</span> ,  <span class="math">P_{\\text{poly}}</span>  proves this to  <span class="math">V_{\\text{poly}}</span> , and  <span class="math">V_{\\text{poly}}</span>  accepts in this case. This adds a  <span class="math">\\text{negl}(\\lambda)</span>  factor to the soundness error.</p>

    <p class="text-gray-300">From the first check we know that  <span class="math">Z(\\mathbf{g}) = 1</span> . From the second check we can show inductively, that for each  <span class="math">i \\in [n]</span></p>

    <p class="text-gray-300"><span class="math">$Z(\\mathbf{g}^{i+1}) = \\prod_{1 \\leq j \\leq i} \\frac{f&#x27;(\\mathbf{g}^j)}{g&#x27;(\\mathbf{g}^j)}.</span>$</p>

    <p class="text-gray-300">In particular,  <span class="math">Z(\\mathbf{g}^{n+1}) = a/b</span> .</p>

    <p class="text-gray-300">As
<span class="math">$\\mathbf{g}^{n+1} = \\mathbf{g}</span>$
,</p>

    <p class="text-gray-300"><span class="math">$1 = Z(\\mathbf{g}) = Z(\\mathbf{g}^{n+1}) = a/b \\neq 1,</span>$</p>

    <p class="text-gray-300">which is a contradiction.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Checking &quot;extended&quot; permutations</h3>

    <p class="text-gray-300">In our protocol, we in fact need to check a permutation &quot;across&quot; the values of several polynomials. Let us define this setting formally. Suppose we now have multiple polynomials  <span class="math">f_1, \\ldots, f_k \\in \\mathbb{F}_{&lt; d}[X]</span>  and a permutation  <span class="math">\\sigma: [kn] \\to [kn]</span> . For  <span class="math">(g_1, \\ldots, g_k) \\in (\\mathbb{F}_{&lt; d}[X])^k</span> , we say that  <span class="math">(g_1, \\ldots, g_k) = \\sigma(f_1, \\ldots, f_k)</span>  if the following holds.</p>

    <p class="text-gray-300">Define the sequences  <span class="math">(f_{(1)}, \\ldots, f_{(kn)}), (g_{(1)}, \\ldots, g_{(kn)}) \\in \\mathbb{F}^{kn}</span>  by</p>

    <p class="text-gray-300"><span class="math">$f_{((j-1)\\cdot n+i)} := f_j(\\mathbf{g}^i), g_{((j-1)\\cdot n+i)} := g_j(\\mathbf{g}^i),</span>$</p>

    <p class="text-gray-300">for each  <span class="math">j \\in [k], i \\in [n]</span> . Then we have  <span class="math">g_{(\\ell)} = f_{(\\sigma(\\ell))}</span>  for each  <span class="math">\\ell \\in [kn]</span> .</p>

    <p class="text-gray-300">Preprocessed polynomials: The polynomials  <span class="math">S_{\\mathsf{ID}1}, \\ldots, S_{\\mathsf{ID}k} \\in \\mathbb{F}_{&lt; n}[X]</span>  defined by  <span class="math">S_{\\mathsf{ID}j}(\\mathbf{g}^i) = (j-1) \\cdot n + i</span>  for each  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">In fact, only  <span class="math">S_{ID} = S_{ID1}</span>  is actually included in the set of preprocessed polynomials, as  <span class="math">S_{IDj}(x)</span>  can be computed as  <span class="math">S_{IDj}(x) = S_{ID}(x) + (j-1) \\cdot n</span> .</p>

    <p class="text-gray-300">For each  <span class="math">j \\in [k]</span> ,  <span class="math">S_{\\sigma j} \\in \\mathbb{F}_{&lt; n}[X]</span> , defined by  <span class="math">S_{\\sigma j}(\\mathbf{g}^i) = \\sigma((j-1) \\cdot n + i)</span>  for each  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">Inputs:  <span class="math">f_1, \\ldots, f_k, g_1, \\ldots, g_k \\in \\mathbb{F}_{\\leq n}[X]</span></p>

    <p class="text-gray-300">Protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{poly}</span>  chooses random  <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span>  and sends them to  <span class="math">P_{poly}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">f&#x27;_j := f_j + \\beta \\cdot \\mathsf{S}_{\\mathsf{ID}j} + \\gamma</span> , and  <span class="math">g&#x27;_j := g_j + \\beta \\cdot \\mathsf{S}_{\\sigma j} + \\gamma</span> . That is, for  <span class="math">j \\in [k], i \\in [n]</span>   <span class="math">f&#x27;_j(\\mathbf{g}^i) = f_j(\\mathbf{g}^i) + \\beta((j-1) \\cdot n + i) + \\gamma, g&#x27;_j(\\mathbf{g}^i) = g_j(\\mathbf{g}^i) + \\beta \\cdot \\sigma((j-1) \\cdot n + i) + \\gamma</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define  <span class="math">f&#x27;, g&#x27; \\in \\mathbb{F}_{\\leq kn}[X]</span>  by</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$f&#x27;(X) := \\prod_{j \\in [k]} f&#x27;_j(X), g&#x27;(X) := \\prod_{j \\in [k]} g&#x27;_j(X).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P<sub>poly</sub> computes  <span class="math">Z \\in \\mathbb{F}_{\\leq n}[X]</span> , such that  <span class="math">Z(\\mathbf{g}) = 1</span> ; and for  <span class="math">i \\in \\{2, \\ldots, n\\}</span></li>
    </ol>

    <p class="text-gray-300"><span class="math">$Z(\\mathbf{g}^i) = \\prod_{1 \\le j &lt; i} f&#x27;(\\mathbf{g}^j) / g&#x27;(\\mathbf{g}^j).</span>$</p>

    <p class="text-gray-300">(The case of one of the products being undefined is handled as in the previous protocol.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_{poly}</span>  sends Z to  <span class="math">\\mathcal{I}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{poly}</span>  checks if for all  <span class="math">a \\in H</span></li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">L_1(a)(Z(a) 1) = 0</span> .</li>
      <li>(b)  <span class="math">Z(a)f&#x27;(a) = g&#x27;(a)Z(a \\cdot \\mathbf{g}).</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">and outputs acc iff all checks hold.</p>

    <p class="text-gray-300"><strong>Lemma 5.3.</strong> Fix any  <span class="math">f_1, \\ldots, f_k, g_1, \\ldots g_k \\in \\mathbb{F}_{&lt; d}[X]</span>  and permutation  <span class="math">\\sigma</span>  on [kn] as inputs to the above protocol  <span class="math">\\mathscr{P}_k</span> . Suppose that  <span class="math">(g_1, \\ldots, g_k) \\neq \\sigma(f_1, \\ldots, f_k)</span> . Then, for any strategy of  <span class="math">P_{\\mathsf{poly}}</span> , the probability of  <span class="math">V_{\\mathsf{poly}}</span>  outputting acc is  <span class="math">\\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Proof.  <span class="math">(g_1, \\ldots, g_k) \\neq \\sigma(f_1, \\ldots, f_k)</span>  implies that with high probability over  <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span>  the product F of the values  <span class="math">\\left\\{f&#x27;_j(\\mathbf{g}^i)\\right\\}_{j \\in [k], i \\in [n]}</span>  is different from the product G of the values  <span class="math">\\left\\{g&#x27;_j(\\mathbf{g}^i)\\right\\}_{j \\in [k], i \\in [n]}</span> . Note now that</p>

    <p class="text-gray-300"><span class="math">$F = \\prod_{i \\in [n]} f&#x27;(\\mathbf{g}^i), G = \\prod_{i \\in [n]} g&#x27;(\\mathbf{g}^i),</span>$</p>

    <p class="text-gray-300">and that the next steps of the protocol are identical to those in the previous protocol, and as analyzed there - exactly check if these products are equal.  <span class="math">\\Box</span></p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Checking &quot;extended copy constraints&quot; using a permutation</h3>

    <p class="text-gray-300">We finally come to the actual primitive that will be used in our main protocol. Let  <span class="math">\\mathcal{T} = \\{T_1, \\ldots, T_s\\}</span>  be a partition of [kn] into disjoint blocks. Fix  <span class="math">f_1, \\ldots, f_k \\in \\mathbb{F}_{\\leq n}[X]</span> . We say that  <span class="math">f_1, \\ldots, f_k</span>  copy-satisfy  <span class="math">\\mathcal{T}</span>  if, when defining  <span class="math">(f_{(1)}, \\ldots, f_{(kn)}) \\in \\mathbb{F}^{kn}</span>  as above, we have  <span class="math">f_{(\\ell)} = f_{(\\ell&#x27;)}</span>  whenever  <span class="math">\\ell, \\ell&#x27;</span>  belong to the same block of  <span class="math">\\mathcal{T}</span> .</p>

    <p class="text-gray-300">We claim that the above protocol for extended permutations can be directly used for checking whether  <span class="math">f_1, \\ldots, f_k</span>  satisfy  <span class="math">\\mathcal{T}</span> : Define a permutation  <span class="math">\\sigma(\\mathcal{T})</span>  on [kn] such that for each block  <span class="math">T_i</span>  of  <span class="math">\\mathcal{T}</span> ,  <span class="math">\\sigma(\\mathcal{T})</span>  contains a cycle going over all elements of  <span class="math">T_i</span> . Then,  <span class="math">(f_1, \\ldots, f_k)</span>  copy-satisfy  <span class="math">\\mathcal{T}</span>  if and only if  <span class="math">(f_1, \\ldots, f_k) = \\sigma(f_1, \\ldots, f_k)</span> .</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Constraint systems</h2>

    <p class="text-gray-300">Fix positive integers m and n. We present a type of constraint system that captures fan-in two arithmetic circuits of unlimited fan-out with n gates and m wires, but is more general.</p>

    <p class="text-gray-300">The constraint system C = (V, Q) is defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V is of the form V = (a, b, c), where a, b, c &isin; [m] n . We think of a, b, c as the left, right and output sequence of C respectively.</li>
      <li>Q = (qL, qR, qO, qM, qC) &isin; (F n ) <sup>5</sup> where we think of qL, qR, qO, qM, q<sup>C</sup> &isin; F <sup>n</sup> as &quot;selector vectors&quot;.</li>
    </ul>

    <p class="text-gray-300">We say x &isin; F <sup>m</sup> satisfies C if for each i &isin; [n],</p>

    <p class="text-gray-300"><span class="math">$(\\mathbf{q_L})_i \\cdot \\mathbf{x_{a_i}} + (\\mathbf{q_R})_i \\cdot \\mathbf{x_{b_i}} + (\\mathbf{q_O})_i \\cdot \\mathbf{x_{c_i}} + (\\mathbf{q_M})_i \\cdot (\\mathbf{x_{a_i} x_{b_i}}) + (\\mathbf{q_C})_i = 0.</span>$</p>

    <p class="text-gray-300">To define a relation based on C , we extend it to include a positive integer &#8467; &le; m, and subset I &sub; [m] of &quot;public inputs&quot;. Assume without loss of generality that I = {1, . . . , &#8467;}.</p>

    <p class="text-gray-300">Now we can define the relation R<sup>C</sup> as the set of pairs (x, &omega;) with x &isin; F &#8467; , &omega; &isin; F m&minus;&#8467; such that x := (x, &omega;) satisfies C .</p>

    <p class="text-gray-300">We proceed to show some useful instantiations of this type of constraints.</p>

    <p class="text-gray-300">Arithmetic circuits: A fan-in 2 circuit of n gates, each being either an addition or multiplication gate, can be captured in such a constraint system as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>m is set to be the number of wires, and each wire is associated with an index i &isin; [m].</li>
    </ol>

    <p class="text-gray-300">For each i &isin; [n],</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set a<sup>i</sup> , b<sup>i</sup> , c<sup>i</sup> to be the index of left/right/output wire of the i'th gate respectively.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set (qL)<sup>i</sup> = 0,(qR)<sup>i</sup> = 0,(qM)<sup>i</sup> = 1,(qO)<sup>i</sup> = &minus;1 when the i'th gate is a multiplication gate.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set (qL)<sup>i</sup> = 1,(qR)<sup>i</sup> = 1,(qM)<sup>i</sup> = 0,(qO)<sup>i</sup> = &minus;1 when the i'th gate is an addition gate. (Note that we can get &quot;linear combination gates&quot; by using other non-zero values for (qL)<sup>i</sup> ,(qR)<sup>i</sup> .)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Always set (qC)<sup>i</sup> = 0.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Booleanity constraints: A common occurrence in proof systems is the need to enforce x<sup>j</sup> &isin; {0, 1} for some j &isin; [m]. This is equivalent in our system to setting, for some i &isin; [n],</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{a}_i = \\mathbf{b}_i = j, (\\mathbf{q}_{\\mathbf{L}})_i = -1, (\\mathbf{q}_{\\mathbf{M}})_i = 1, (\\mathbf{q}_{\\mathbf{R}})_i = (\\mathbf{q}_{\\mathbf{O}})_i = (\\mathbf{q}_{\\mathbf{C}})_i = 0.</span>$</p>

    <p class="text-gray-300">Enforcing constants: It is quite convenient and direct to set constant values: Fix any j &isin; [m], a &isin; F. To enforce the constraint x<sup>j</sup> = a we set for some i &isin; [n]</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{a}_i = j, (\\mathbf{q}_{\\mathbf{L}})_i = 1, (\\mathbf{q}_{\\mathbf{M}})_i = (\\mathbf{q}_{\\mathbf{R}})_i = (\\mathbf{q}_{\\mathbf{O}})_i = 0, (\\mathbf{q}_{\\mathbf{C}})_i = -a.</span>$</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Main protocol</h2>

    <p class="text-gray-300">Let C = (V, Q) be a constraint system of the form described in Section <a href="#page-22-0">6.</a> We present our main protocol for the relation R<sup>C</sup> . It will be convenient to first define the following notion of the partition of C , denoted T<sup>C</sup> , as follows.</p>

    <p class="text-gray-300">Suppose V = (a, b, c); think of V as a vector V in [m] 3n . For i &isin; [m], let T<sup>i</sup> &sub; [3n] be the set of indices j &isin; [3n] such that V<sup>j</sup> = i. Now define</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{T}_{\\mathscr{C}} := \\{T_i\\}_{i \\in [m]}</span>$
.</p>

    <p class="text-gray-300">We make a final definition before presenting the protocol. We say C is prepared for &#8467; public inputs if for i &isin; [&#8467;]</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{a}_i = i, (\\mathbf{q}_{\\mathbf{L}})_i = 1, (\\mathbf{q}_{\\mathbf{M}})_i = (\\mathbf{q}_{\\mathbf{R}})_i = (\\mathbf{q}_{\\mathbf{O}})_i = 0, (\\mathbf{q}_{\\mathbf{C}})_i = 0.</span>$</p>

    <p class="text-gray-300">Recall that H = {g, . . . , g <sup>n</sup>}. We present an H-ranged polynomial protocol for R<sup>C</sup> .</p>

    <p class="text-gray-300">Preprocessing: Let &sigma; = &sigma;(T<sup>C</sup> ).</p>

    <p class="text-gray-300">The polynomials SID<sup>1</sup> , SID<sup>2</sup> , SID<sup>3</sup> , S&sigma;<sup>1</sup> , S&sigma;<sup>2</sup> , S&sigma;<sup>3</sup> &isin; F&lt;n[X] as defined in the protocol of subsection <a href="#page-20-0">5.1</a> .</p>

    <p class="text-gray-300">Overloading notation, the polynomials qL, qR, qO, qM, q<sup>C</sup> &isin; F&lt;n[X] defined for each i &isin; [n] by</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{q_L}(\\mathbf{g}^i) := (\\mathbf{q_L})_i, \\mathbf{q_R}(\\mathbf{g}^i) := (\\mathbf{q_R})_i, \\mathbf{q_O}(\\mathbf{g}^i) := (\\mathbf{q_O})_i, \\mathbf{q_M}(\\mathbf{g}^i) := (\\mathbf{q_M})_i, \\mathbf{q_C}(\\mathbf{g}^i) := (\\mathbf{q_C})_i</span>$</p>

    <p class="text-gray-300">Protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let x &isin; F <sup>m</sup> be Ppoly's assignment consistent with the public input x. Ppoly computes the three polynomials fL, fR, f<sup>O</sup> &isin; F&lt;n[X], where for i &isin; [n]</li>
    </ol>

    <p class="text-gray-300"><span class="math">$f_L(\\mathbf{g}^i) = \\mathbf{x}_{\\mathbf{a}_i}, f_R(\\mathbf{g}^i) = \\mathbf{x}_{\\mathbf{b}_i}, f_O(\\mathbf{g}^i) = \\mathbf{x}_{\\mathbf{c}_i}.</span>$</p>

    <p class="text-gray-300">Ppoly sends fL, fR, f<sup>O</sup> to I.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ppoly and Vpoly run the extended permutation check protocol using the permutation &sigma; between (fL, fR, fO) and itself. As explained in Section <a href="#page-21-0">5.2,</a> this exactly checks whether (fL, fR, fO) copy-satisfies T<sup>C</sup> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Vpoly computes the &quot;Public input polynomial&quot;</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathsf{PI}(X) := \\sum_{i \\in [\\ell]} -\\mathsf{x}_i \\cdot L_i(X)</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V<sub>poly</sub> now checks the identity</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathbf{q_L} \\cdot f_L + \\mathbf{q_R} \\cdot f_R + \\mathbf{q_O} \\cdot f_O + \\mathbf{q_M} \\cdot f_L \\cdot f_R + (\\mathbf{q_C} + \\mathsf{PI}) = 0,</span>$</p>

    <p class="text-gray-300">on H.</p>

    <p class="text-gray-300"><strong>Theorem 7.1.</strong> The above protocol is an H-ranged polynomial protocol for the relation  <span class="math">\\mathcal{R}_{\\mathscr{C}}</span> .</p>

    <p class="text-gray-300">Proof. Our main task is to describe and prove correctness of an extractor E. E simply uses the values of  <span class="math">f_L</span> ,  <span class="math">f_R</span> ,  <span class="math">f_O</span>  to construct an assignment in the natural way - e.g. if  <span class="math">\\mathbf{a}_i = j</span>  for some  <span class="math">i \\in [n]</span> , let  <span class="math">\\mathbf{x}_j = f_L(\\mathbf{g}^i)</span> . Finally, E defines and outputs  <span class="math">\\omega := (\\mathbf{x}_{\\ell+1}, \\ldots, \\mathbf{x}_m)</span> . Now, let us look at the event C where  <span class="math">(\\mathbf{x}, \\omega) \\notin \\mathcal{R}</span>  but  <span class="math">V_{\\text{poly}}</span>  outputs acc. We split C into the two subevents, where  <span class="math">(f_L, f_R, f_O)</span>  doesn't copy-satisfy  <span class="math">\\sigma(\\mathscr{C})</span> , and where it does. The first subevent has probability  <span class="math">\\text{negl}(\\lambda)</span>  according to the correctness of Lemma 5.3 and its use for copy-satisfiability checks as explained in Section 5.2.</p>

    <p class="text-gray-300">On the other hand, if  <span class="math">(f_L, f_R, f_O)</span>  copy-satisfies  <span class="math">\\sigma(\\mathscr{C})</span>  and the identity checked by  <span class="math">V_{poly}</span>  holds, it must be the case that  <span class="math">(x, \\omega) \\in \\mathcal{R}_{\\mathscr{C}}</span> .</p>

    <p class="text-gray-300">Now, using Lemma 4.5 and Lemma 4.7 we get</p>

    <p class="text-gray-300"><strong>Corollary 7.2.</strong> Let  <span class="math">\\mathscr{C}</span>  be a constraint system of the form described in Section 6 with parameter n. There is a protocol for the relation  <span class="math">\\mathcal{R}_{\\mathscr{C}}</span>  with Knowledge Soundness in the Algebraic Group Model such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover <strong>P</strong> requires 11n + 1  <span class="math">\\mathbb{G}_1</span> -exponentiations.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The total prover communication consists of 7  <span class="math">\\mathbb{G}_1</span> -elements and 7  <span class="math">\\mathbb{F}</span> -elements.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> We bound the quantities  <span class="math">e(\\mathscr{P}), t^*(\\mathscr{P}), r(\\mathscr{P})</span>  from Section 4.2; where  <span class="math">\\mathscr{P}</span>  is the polynomial protocol derived from the protocol of Theorem 7.1 using Lemma 4.5. The result then follows from Lemma 4.7 and the discussion after. (For extra clarity, a full self-contained description of the final protocol is given in Section 8.)</p>

    <p class="text-gray-300">We commit to polynomials  <span class="math">f_L, f_R, f_O, Z \\in \\mathbb{F}_{&lt; n}[X]</span>  and a polynomial  <span class="math">T \\in \\mathbb{F}_{&lt; 3n}[X]</span>  resulting from division by  <span class="math">Z_H</span> . This requires  <span class="math">7n \\ \\mathbb{G}_1</span> -exponentiations. Then, we need to open at random  <span class="math">x \\in \\mathbb{F}</span> :  <span class="math">f_L(x), f_R(x), f_O(x), \\mathsf{S}_{\\mathsf{ID}}(x), \\mathsf{S}_{\\sigma_1}(x), \\mathsf{S}_{\\sigma_2}(x)</span></p>

    <p class="text-gray-300">and at
<span class="math">$x \\cdot \\mathbf{g} : Z(x \\cdot \\mathbf{g})</span>$
.</p>

    <p class="text-gray-300">Note that fixing these 7 values, together with the value  <span class="math">Z_H(x)</span>  which the verifier can compute himself in  <span class="math">\\log(n)</span>  operations, our identity becomes a linear polynomial L which is a linear combination of  <span class="math">\\mathbf{q_L}, \\mathbf{q_R}, \\mathbf{q_O}, \\mathbf{q_M}, \\mathbf{q_C}, Z, \\mathsf{S}_{\\sigma 3}, T</span> . This implies  <span class="math">\\mathsf{r}(\\mathscr{P}) \\leq 7</span> .</p>

    <p class="text-gray-300">It follows that</p>

    <p class="text-gray-300">&bull;  <span class="math">e(\\mathscr{P}) = 11n + 1</span>  - as we add to the 7n cost of commitments, the maximal degree among the polynomial evaluated at x which is 3n plus the maximum degree among polynomials evaluated at x/g which is n + 1.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;10</sup>The result stated in introduction with 6 F-elements uses an additional optimization suggested by Vitalik Buterin explained in Section 8.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">t^*(\\mathscr{P}) = 2</span>  as we have two distinct evaluation points.</li>
      <li><span class="math">r(\\mathscr{P}) \\leq 7</span> .</li>
    </ul>

    </section>

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8 The final protocol, rolled out</h2>

    <p class="text-gray-300">For the reader's convenience we present the full final protocol. A few preliminary notes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Adding zero-knowledge was not explicitly discussed so far, but is implemented here. All that is needed is adding random multiples of  <span class="math">Z_H</span>  to the prover polynomials, and requiring the verifier to send challenges in  <span class="math">\\mathbb{F} \\setminus H</span> . This does not ruin satisfiability, and creates a situation where all values are either<sup>11</sup> completely uniform or determined by verifier equations.</li>
      <li>We explicitly define the multiplicative subgroup H as containing the n'th roots of unity in  <span class="math">\\mathbb{F}</span> , where  <span class="math">\\omega</span>  is a primitive n'th root of unity and a generator of H. i.e:  <span class="math">H = \\{1, \\omega, \\dots, \\omega^{n-1}\\}</span> . We assume that the number of gates in a circuit is no more than n.</li>
      <li>We include an optimisation suggested by Vitalik Buterin representing the identity permutation via degree-1 polynomials, so that their evaluations can be directly computed by the verifier. This reduces the size of the proof by one field element, as well as reducing the number of Fast-Fourier-Transforms required by the prover. The representation is described in the next subsection.</li>
      <li>We use $\\mathcal{H}$ to refer to an efficiently computable hash function, $\\mathcal{H}$: {0,1}* &rarr; $\\mathbb{F}$, that takes arbitrary length inputs and returns elements of $\\mathbb{F}$. We use $\\mathcal{H}$ to obtain a non-interactive version of our protocol via the Fiat-Shamir transformation. Thus, $\\mathcal{H}$ should be modelled as a random oracle for a security proof of this non-interactive variant.</li>
    </ul>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8">8.1 Polynomials that define a specific circuit</h3>

    <p class="text-gray-300">The following polynomials, along with integer n, uniquely define our circuit:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">q_M(X), q_L(X), q_R(X), q_O(X), q_C(X)</span> , the 'selector' polynomials that define the circuit's arithmetisation</li>
      <li><span class="math">\\mathsf{S}_{\\mathsf{ID}1}(X) = X, \\mathsf{S}_{\\mathsf{ID}2}(X) = k_1 X, \\mathsf{S}_{\\mathsf{ID}3}(X) = k_2 X</span> : the identity permutation applied to  <span class="math">\\mathbf{a}, \\mathbf{b}, \\mathbf{c}</span> .  <span class="math">k_1, k_2 \\in \\mathbb{F}</span>  are chosen such that  <span class="math">H, k_1 \\cdot H, k_2 \\cdot H</span>  are distinct cosets of H in  <span class="math">\\mathbb{F}^*</span> , and thus consist of 3n distinct elements. (For example, when  <span class="math">\\omega</span>  is a quadratic</li>
    </ul>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{11}&lt;/sup&gt;</span> A small exception noted to us by Sean Bowe, is that the prover aborts caused by denominators being zero in the computation of Z in Section 5 leak information about the witnesses. For this reason a formal analysis would attain statistical rather than perfect zero-knowledge.</p>

    <p class="text-gray-300">residue in  <span class="math">\\mathbb{F}</span> , take  <span class="math">k_1</span>  to be any quadratic non-residue, and  <span class="math">k_2</span>  to be a quadratic non-residue not contained in  <span class="math">k_1 \\cdot H</span> .)</p>

    <p class="text-gray-300">&bull; Let us denote  <span class="math">H&#x27; := H \\cup (k_1 \\cdot H) \\cup (k_2 \\cdot H)</span> . Let  <span class="math">\\sigma : [3n] \\to [3n]</span>  be a permutation. Now, identify [3n] with H' via  <span class="math">i \\to \\omega^i, n+i \\to k_1 \\cdot \\omega^i, 2n+i \\to k_2 \\cdot \\omega^i</span> . Finally, define  <span class="math">\\sigma^*</span>  below to denote the mapping from [3n] to H' derived from applying  <span class="math">\\sigma</span>  and then this injective mapping into H'. We encode  <span class="math">\\sigma^*</span>  by the three permutation polynomials</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{S}_{\\sigma 1}(X) := \\sum_{i=1}^n \\sigma^*(i) \\mathsf{L}_i(X), \\mathsf{S}_{\\sigma 2}(X) := \\sum_{i=1}^n \\sigma^*(n+i) \\mathsf{L}_i(X), \\mathsf{S}_{\\sigma 3}(X) := \\sum_{i=1}^n \\sigma^*(2n+i) \\mathsf{L}_i(X).</span>$</p>

      <h3 id="sec-8.2" class="text-xl font-semibold mt-8">8.2 The SNARK proof relation</h3>

    <p class="text-gray-300">Given  <span class="math">\\ell \\leq n</span>  and fixed values for the above polynomials, we wish to prove statements of knowledge for the relation  <span class="math">\\mathcal{R} \\subset \\mathbb{F}^{\\ell} \\times \\mathbb{F}^{3n-\\ell}</span>  containing all pairs  <span class="math">x = (w_i)_{i \\in [\\ell]}, w = (w_i)_{i=\\ell+1}^{3n}</span>  such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For all  <span class="math">i \\in [n]</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$q_{Mi}w_iw_{n+i} + q_{Li}w_i + q_{Ri}w_{n+i} + q_{Oi}w_{2n+i} + q_{Ci} = 0,</span>$</p>

    <p class="text-gray-300">(where we used above the shorthand  <span class="math">q_i = q(\\omega^i)</span> ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For all  <span class="math">i \\in [3n]</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$w_i = w_{\\sigma(i)}</span>$
.</p>

      <h3 id="sec-8.3" class="text-xl font-semibold mt-8">8.3 The protocol</h3>

    <p class="text-gray-300">We describe the protocol below as a non-interactive protocol using the Fiat-Shamir heuristic. For this purpose we always denote by transcript the concatenation of the common preprocessed input, and public input, and the proof elements written by the prover up to a certain point in time. We use transcript for obtaining random challenges via Fiat-Shamir. One can alternatively, replace all points where we write below &quot;compute challenges&quot;, by the verifier sending random field elements, to obtain the interactive protocol from which we derive the non-interactive one.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Common preprocessed input:</h4>

    <p class="text-gray-300"><span class="math">$\\begin{split} n, &amp;(x \\cdot [1]_1, \\dots, x^{n+5} \\cdot [1]_1), (q_{Mi}, q_{Li}, q_{Ri}, q_{Oi}, q_{Ci})_{i=1}^n, \\sigma^*, \\\\ \\mathsf{q_M}(X) &amp;= \\sum_{i=1}^n q_{Mi} \\mathsf{L}_i(X), \\\\ \\mathsf{q_L}(X) &amp;= \\sum_{i=1}^n q_{Li} \\mathsf{L}_i(X), \\\\ \\mathsf{q_R}(X) &amp;= \\sum_{i=1}^n q_{Ri} \\mathsf{L}_i(X), \\\\ \\mathsf{q_O}(X) &amp;= \\sum_{i=1}^n q_{Oi} \\mathsf{L}_i(X), \\\\ \\mathsf{q_C}(X) &amp;= \\sum_{i=1}^n q_{Ci} \\mathsf{L}_i(X), \\\\ \\mathsf{S}_{\\sigma 1}(X) &amp;= \\sum_{i=1}^n \\sigma^*(i) \\mathsf{L}_i(X), \\\\ \\mathsf{S}_{\\sigma 2}(X) &amp;= \\sum_{i=1}^n \\sigma^*(n+i) \\mathsf{L}_i(X), \\\\ \\mathsf{S}_{\\sigma 3}(X) &amp;= \\sum_{i=1}^n \\sigma^*(2n+i) \\mathsf{L}_i(X) \\end{split}</span>$</p>

    <p class="text-gray-300">Public input: &#8467;,(wi)i&isin;[&#8467;]</p>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">Prover algorithm:</h3>

    <p class="text-gray-300">Prover input: (wi)i&isin;[3n]</p>

    <h3 id="sec-misc-4" class="text-xl font-semibold mt-8">Round 1:</h3>

    <p class="text-gray-300">Generate random blinding scalars (b1, . . . , b9) &isin; F Compute wire polynomials a(X), b(X), c(X) :</p>

    <p class="text-gray-300"><span class="math">$a(X) = (b_1X + b_2)Z_H(X) + \\sum_{i=1}^n w_iL_i(X)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{b}(X) = (b_3 X + b_4) \\mathsf{Z}_{\\mathsf{H}}(X) + \\sum_{i=1}^n w_{n+i} \\mathsf{L}_i(X)</span>$</p>

    <p class="text-gray-300"><span class="math">$c(X) = (b_5X + b_6)Z_H(X) + \\sum_{i=1}^n w_{2n+i}L_i(X)</span>$</p>

    <p class="text-gray-300">Compute [a]<sup>1</sup> := [a(x)]<sup>1</sup> , [b]<sup>1</sup> := [b(x)]<sup>1</sup> , [c]<sup>1</sup> := [c(x)]<sup>1</sup></p>

    <p class="text-gray-300">First output of P is ([a]1, [b]1, [c]1).</p>

    <h3 id="sec-misc-5" class="text-xl font-semibold mt-8">Round 2:</h3>

    <p class="text-gray-300">Compute permutation challenges (&beta;, &gamma;) &isin; F :</p>

    <p class="text-gray-300"><span class="math">$\\beta = \\mathcal{H}(\\mathsf{transcript}, 0), \\gamma = \\mathcal{H}(\\mathsf{transcript}, 1)</span>$</p>

    <p class="text-gray-300">Compute permutation polynomial z(X) :</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{z}(X) = (b_7 X^2 + b_8 X + b_9) \\mathsf{Z}_\\mathsf{H}(X) \\\\ + \\mathsf{L}_1(X) + \\sum_{i=1}^{n-1} \\left( \\mathsf{L}_{i+1}(X) \\prod_{j=1}^{i} \\frac{(w_j + \\beta \\omega^j + \\gamma)(w_{n+j} + \\beta k_1 \\omega^j + \\gamma)(w_{2n+j} + \\beta k_2 \\omega^j + \\gamma)}{(w_j + \\sigma^*(j)\\beta + \\gamma)(w_{n+j} + \\sigma^*(n+j)\\beta + \\gamma)(w_{2n+j} + \\sigma^*(2n+j)\\beta + \\gamma)} \\right)</span>$
Compute  <span class="math">[z]_1 := [\\mathsf{z}(x)]_1</span></p>

    <p class="text-gray-300">Second output of P is ([z]1)</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">Round 3:</h4>

    <p class="text-gray-300">Compute quotient challenge  <span class="math">\\alpha \\in \\mathbb{F}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\alpha = \\mathcal{H}(\\mathsf{transcript})</span>$</p>

    <p class="text-gray-300">Compute quotient polynomial t(X):</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{t}(X) &amp;= \\\\ &amp; (\\mathsf{a}(X)\\mathsf{b}(X)\\mathsf{q}_\\mathsf{M}(X) + \\mathsf{a}(X)\\mathsf{q}_\\mathsf{L}(X) + \\mathsf{b}(X)\\mathsf{q}_\\mathsf{R}(X) + \\mathsf{c}(X)\\mathsf{q}_\\mathsf{O}(X) + \\mathsf{PI}(X) + \\mathsf{q}_\\mathsf{C}(X)) \\, \\frac{1}{\\mathsf{Z}_\\mathsf{H}(X)} \\\\ &amp;+ \\left( (\\mathsf{a}(X) + \\beta X + \\gamma)(\\mathsf{b}(X) + \\beta k_1 X + \\gamma)(\\mathsf{c}(X) + \\beta k_2 X + \\gamma)\\mathsf{z}(X) \\right) \\, \\frac{\\alpha}{\\mathsf{Z}_\\mathsf{H}(X)} \\\\ &amp;- \\left( (\\mathsf{a}(X) + \\beta \\mathsf{S}_{\\sigma_1}(X) + \\gamma)(\\mathsf{b}(X) + \\beta \\mathsf{S}_{\\sigma_2}(X) + \\gamma)(\\mathsf{c}(X) + \\beta \\mathsf{S}_{\\sigma_3}(X) + \\gamma)\\mathsf{z}(X\\omega) \\right) \\, \\frac{\\alpha}{\\mathsf{Z}_\\mathsf{H}(X)} \\\\ &amp;+ (\\mathsf{z}(X) - 1) \\, \\mathsf{L}_1(X) \\frac{\\alpha^2}{\\mathsf{Z}_\\mathsf{H}(X)} \\end{split}</span>$</p>

    <p class="text-gray-300">Split  <span class="math">\\mathsf{t}(X)</span>  into degree &lt; n polynomials  <span class="math">\\mathsf{t}&#x27;_\\mathsf{lo}(X), \\mathsf{t}&#x27;_\\mathsf{mid}(X)</span>  and  <span class="math">\\mathsf{t}&#x27;_\\mathsf{hi}(X)</span>  of degree at most n+5, such that</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{t}(X) = \\mathsf{t}&#x27;_{\\mathsf{lo}}(X) + X^n \\mathsf{t}&#x27;_{\\mathsf{mid}}(X) + X^{2n} \\mathsf{t}&#x27;_{\\mathsf{hi}}(X)</span>$</p>

    <p class="text-gray-300">Now choose random scalars  <span class="math">b_{10}, b_{11} \\in \\mathbb{F}</span>  and define</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{t}_{\\mathsf{lo}}(X) := \\mathsf{t}&#x27;_{\\mathsf{lo}}(X) + b_{10}X^n, \\mathsf{t}_{\\mathsf{mid}}(X) := \\mathsf{t}&#x27;_{\\mathsf{mid}}(X) - b_{10} + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) - b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) := \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^n, \\mathsf{t}_{\\mathsf{hi}}(X) = \\mathsf{t}&#x27;_{\\mathsf{hi}}(X) + b_{11}X^</span>$</p>

    <p class="text-gray-300">Note that we have  <span class="math">t(X) = t_{lo}(X) + X^n t_{mid}(X) + X^{2n} t_{hi}(X)</span> . Compute  <span class="math">[t_{lo}]_1 := [t_{lo}(x)]_1, [t_{mid}]_1 := [t_{mid}(x)]_1, [t_{hi}]_1 := [t_{hi}(x)]_1</span></p>

    <p class="text-gray-300">Third output of <strong>P</strong> is  <span class="math">([t_{lo}]_1, [t_{mid}]_1, [t_{hi}]_1)</span></p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Round 4:</h4>

    <p class="text-gray-300">Compute evaluation challenge  <span class="math">\\mathfrak{z} \\in \\mathbb{F}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{z} = \\mathcal{H}(\\mathsf{transcript})</span>$</p>

    <p class="text-gray-300">Compute opening evaluations:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\bar{a} = \\mathbf{a}(\\mathfrak{z}), \\bar{b} = \\mathbf{b}(\\mathfrak{z}), \\bar{c} = \\mathbf{c}(\\mathfrak{z}), \\bar{\\mathbf{s}}_{\\sigma 1} = \\mathsf{S}_{\\sigma 1}(\\mathfrak{z}), \\bar{\\mathbf{s}}_{\\sigma 2} = \\mathsf{S}_{\\sigma 2}(\\mathfrak{z}), \\\\ \\bar{z}_{\\omega} = \\mathbf{z}(\\mathfrak{z}\\omega) \\end{split}</span>$</p>

    <p class="text-gray-300">Fourth output of <strong>P</strong> is  <span class="math">(\\bar{a}, \\bar{b}, \\bar{c}, \\bar{s}_{\\sigma 1}, \\bar{s}_{\\sigma 2}, \\bar{z}_{\\omega})</span></p>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Round 5:</h4>

    <p class="text-gray-300">Compute opening challenge  <span class="math">v \\in \\mathbb{F}</span> :</p>

    <p class="text-gray-300"><span class="math">$v = \\mathcal{H}(\\mathsf{transcript})</span>$</p>

    <p class="text-gray-300">Compute linearisation polynomial r(X):</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{r}(X) &amp;= \\\\ &amp; \\left[ \\bar{a}\\bar{b} \\cdot \\mathsf{q}_{\\mathsf{M}}(X) + \\bar{a} \\cdot \\mathsf{q}_{\\mathsf{L}}(X) + \\bar{b} \\cdot \\mathsf{q}_{\\mathsf{R}}(X) + \\bar{c} \\cdot \\mathsf{q}_{\\mathsf{O}}(X) + \\mathsf{PI}(\\mathfrak{z}) + \\mathsf{q}_{\\mathsf{C}}(X) \\right] \\\\ &amp;+ \\alpha \\left[ (\\bar{a} + \\beta \\mathfrak{z} + \\gamma)(\\bar{b} + \\beta k_1 \\mathfrak{z} + \\gamma)(\\bar{c} + \\beta k_2 \\mathfrak{z} + \\gamma) \\cdot \\mathbf{z}(X) \\right. \\\\ &amp;- (\\bar{a} + \\beta \\bar{\\mathbf{s}}_{\\sigma 1} + \\gamma)(\\bar{b} + \\beta \\bar{\\mathbf{s}}_{\\sigma 2} + \\gamma)(\\bar{c} + \\beta \\cdot \\mathsf{S}_{\\sigma 3}(X) + \\gamma)\\bar{z}_{\\omega} \\right] \\\\ &amp;+ \\alpha^2 \\left[ (\\mathbf{z}(X) - 1)\\mathsf{L}_1(\\mathfrak{z}) \\right] \\\\ &amp;- Z_H(\\mathfrak{z}) \\cdot (t_{lo}(X) + \\mathfrak{z}^n t_{mid}(X) + \\mathfrak{z}^{2n} t_{hi}(X)) \\end{split}</span>$</p>

    <p class="text-gray-300">Compute opening proof polynomial  <span class="math">W_3(X)</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{W}_{\\mathfrak{z}}(X) = \\frac{1}{X - \\mathfrak{z}} \\begin{pmatrix} \\mathsf{r}(X) \\\\ + v(\\mathsf{a}(X) - \\bar{a}) \\\\ + v^2(\\mathsf{b}(X) - \\bar{b}) \\\\ + v^3(\\mathsf{c}(X) - \\bar{c}) \\\\ + v^4(\\mathsf{S}_{\\sigma 1}(X) - \\bar{\\mathsf{s}}_{\\sigma 1}) \\\\ + v^5(\\mathsf{S}_{\\sigma 2}(X) - \\bar{\\mathsf{s}}_{\\sigma 2}) \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">Compute opening proof polynomial  <span class="math">\\mathsf{W}_{\\mathfrak{z}\\omega}(X)</span>  :</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{W}_{\\mathfrak{z}\\omega}(X) = \\frac{(\\mathsf{z}(X) - \\bar{z}_\\omega)}{X - \\mathfrak{z}\\omega}</span>$</p>

    <p class="text-gray-300">Compute  <span class="math">\\left[W_{\\mathfrak{z}}\\right]_{1}:=\\left[\\mathsf{W}_{\\mathfrak{z}}(x)\\right]_{1},\\left[W_{\\mathfrak{z}\\omega}\\right]_{1}:=\\left[\\mathsf{W}_{\\mathfrak{z}\\omega}(x)\\right]_{1}</span></p>

    <p class="text-gray-300">The fifth output of <strong>P</strong> is  <span class="math">([W_3]_1, [W_{3\\omega}]_1)</span></p>

    <p class="text-gray-300">Return</p>

    <p class="text-gray-300"><span class="math">$\\pi_{\\mathsf{SNARK}} = \\left( \\begin{array}{c} [a]_1, [b]_1, [c]_1, [z]_1, [t_{lo}]_1, [t_{mid}]_1, [t_{hi}]_1, [W_{\\mathfrak{z}}]_1, [W_{\\mathfrak{z}\\omega}]_1, \\\\ \\bar{a}, \\bar{b}, \\bar{c}, \\bar{\\mathbf{s}}_{\\sigma 1}, \\bar{\\mathbf{s}}_{\\sigma 2}, \\bar{z}_{\\omega} \\end{array} \\right)</span>$</p>

    <p class="text-gray-300">Compute multipoint evaluation challenge  <span class="math">u \\in \\mathbb{F}</span> :</p>

    <p class="text-gray-300"><span class="math">$u = \\mathcal{H}(\\mathsf{transcript})</span>$</p>

    <p class="text-gray-300">We now describe the verifier algorithm in a way that minimizes the number of  <span class="math">\\mathbb{G}_1</span>  scalar multiplications.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Verifier algorithm</h4>

    <h3 id="sec-misc-10" class="text-xl font-semibold mt-8">Verifier preprocessed input:</h3>

    <p class="text-gray-300"><span class="math">$\\begin{split} [q_{\\mathsf{M}}]_1 &amp;:= \\mathsf{q}_{\\mathsf{M}}(x) \\cdot [1]_1, [q_{\\mathsf{L}}]_1 := \\mathsf{q}_{\\mathsf{L}}(x) \\cdot [1]_1, [q_{\\mathsf{R}}]_1 := \\mathsf{q}_{\\mathsf{R}}(x) \\cdot [1]_1, [q_{\\mathsf{O}}]_1 := \\mathsf{q}_{\\mathsf{O}}(x) \\cdot [1]_1, \\\\ [q_{\\mathsf{C}}]_1 &amp;:= \\mathsf{q}_{\\mathsf{C}}(x) \\cdot [1]_1, [s_{\\sigma 1}]_1 := \\mathsf{S}_{\\sigma 1}(x) \\cdot [1]_1, [s_{\\sigma 2}]_1 := \\mathsf{S}_{\\sigma 2}(x) \\cdot [1]_1, \\\\ [s_{\\sigma 3}]_1 &amp;:= \\mathsf{S}_{\\sigma 3}(x) \\cdot [1]_1, x \\cdot [1]_2 \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathbf{V}((w_i)_{i\\in[\\ell]},\\pi_{\\mathsf{SNARK}})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Validate  <span class="math">([a]_1,[b]_1,[c]_1,[z]_1,[t_{lo}]_1,[t_{mid}]_1,[t_{hi}]_1,[W_{\\mathfrak{z}}]_1,[W_{\\mathfrak{z}\\omega}]_1)\\in\\mathbb{G}^9_1.</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Validate  <span class="math">(\\bar{a}, \\bar{b}, \\bar{c}, \\bar{s}_{\\sigma 1}, \\bar{s}_{\\sigma 2}, \\bar{z}_{\\omega}) \\in \\mathbb{F}^6</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Validate  <span class="math">(w_i)_{i \\in [\\ell]} \\in \\mathbb{F}^{\\ell}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute challenges  <span class="math">\\beta, \\gamma, \\alpha, \\mathfrak{z}, v, u \\in \\mathbb{F}</span>  as in prover description, from the common inputs, public input, and elements of  <span class="math">\\pi_{\\mathsf{SNARK}}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute zero polynomial evaluation  <span class="math">Z_H(\\mathfrak{z}) = \\mathfrak{z}^n 1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute Lagrange polynomial evaluation  <span class="math">L_1(\\mathfrak{z}) = \\frac{\\omega(\\mathfrak{z}^n 1)}{n(\\mathfrak{z} \\omega)}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute public input polynomial evaluation  <span class="math">\\mathsf{PI}(\\mathfrak{z}) = \\sum_{i \\in [\\ell]} w_i \\mathsf{L}_i(\\mathfrak{z})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>To save a verifier scalar multiplication, we split r into its constant and non-constant terms. Compute r's constant term:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$r_0 := \\mathsf{PI}(\\mathfrak{z}) - \\mathsf{L}_1(\\mathfrak{z})\\alpha^2 - \\alpha(\\bar{a} + \\beta\\bar{\\mathsf{s}}_{\\sigma 1} + \\gamma)(\\bar{b} + \\beta\\bar{\\mathsf{s}}_{\\sigma 2} + \\gamma)(\\bar{c} + \\gamma)\\bar{z}_{\\omega},</span>$
and let  <span class="math">r&#x27;(X) := r(X) - r_0</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute first part of batched polynomial commitment  <span class="math">[D]_1 := [r&#x27;]_1 + u \\cdot [z]_1</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$[D]_1 := \\begin{array}{l} \\bar{a}\\bar{b}\\cdot[q_{\\mathsf{M}}]_1 + \\bar{a}\\cdot[q_{\\mathsf{L}}]_1 + \\bar{b}\\cdot[q_{\\mathsf{R}}]_1 + \\bar{c}\\cdot[q_{\\mathsf{O}}]_1 + [q_{\\mathsf{C}}]_1 \\\\ + \\left((\\bar{a}+\\beta\\mathfrak{z}+\\gamma)(\\bar{b}+\\beta k_1\\mathfrak{z}+\\gamma)(\\bar{c}+\\beta k_2\\mathfrak{z}+\\gamma)\\alpha + \\mathsf{L}_1(\\mathfrak{z})\\alpha^2 + u\\right)\\cdot[z]_1 \\\\ - (\\bar{a}+\\beta\\bar{\\mathsf{s}}_{\\sigma 1}+\\gamma)(\\bar{b}+\\beta\\bar{\\mathsf{s}}_{\\sigma 2}+\\gamma)\\alpha\\beta\\bar{z}_{\\omega}\\cdot[s_{\\sigma 3}]_1 \\\\ - Z_H(\\mathfrak{z})([t_{lo}]_1 + \\mathfrak{z}^n\\cdot[t_{mid}]_1 + \\mathfrak{z}^{2n}\\cdot[t_{hi}]_1) \\end{array}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute full batched polynomial commitment  <span class="math">[F]_1</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$[F]_1 := [D]_1 + v \\cdot [a]_1 + v^2 \\cdot [b]_1 + v^3 \\cdot [c]_1 + v^4 \\cdot [s_{\\sigma 1}]_1 + v^5 \\cdot [s_{\\sigma 2}]_1</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute group-encoded batch evaluation  <span class="math">[E]_1</span></li>
    </ol>

    <p class="text-gray-300"><span class="math">$[E]_1 := \\left( \\begin{array}{c} -r_0 + v\\bar{a} + v^2\\bar{b} + v^3\\bar{c} \\\\ +v^4\\bar{\\mathbf{s}}_{\\sigma 1} + v^5\\bar{\\mathbf{s}}_{\\sigma 2} + u\\bar{z}_{\\omega} \\end{array} \\right) \\cdot [1]_1</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Batch validate all evaluations:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$e([W_{\\mathfrak{z}}]_{1} + u \\cdot [W_{\\mathfrak{z}\\omega}]_{1}, [x]_{2}) \\stackrel{?}{=} e(\\mathfrak{z} \\cdot [W_{\\mathfrak{z}}]_{1} + u\\mathfrak{z}\\omega \\cdot [W_{\\mathfrak{z}\\omega}]_{1} + [F]_{1} - [E]_{1}, [1]_{2})</span>$</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Mary Maller for telling us about the field element reduction method discussed in the end of Section <a href="#page-13-2">4.</a> We thank Vitalik Buterin for suggesting that we define the identity permutation using degree-1 polynomials, which reduces proof construction time, as well as reducing the proof size by 1 field element, and reduces the verification costs by 1 scalar multiplication. We thank Swastik Kopparty for pointing out an error in the permutation argument in a previous version of the paper, whose correction led to improved performance. We thank Justin Drake and Konstantin Panarin for discussions leading to corrections and simplifications of the permutation argument. We thank Sean Bowe for noticing we weren't hashing the public inputs in our original Fiat-Shamir description which can <a href="https://blog.trailofbits.com/2022/04/18/the-frozen-heart-vulnerability-in-plonk/" target="_blank" rel="noopener noreferrer">lead</a> to attacks. We thank Sean Bowe, Jay Butera, Luke Edwards, Cody Gunton, Adrian Hamelink, Marek Sefranek, Amir Taaki, Patrick Towa, Alexander Vlasov, Yongge Wang, Kevaundray Wedderburn, David Wong and Ye Zhang for comments and corrections. We thank the anonymous reviewers of SBC 2020 for their comments. We thank Marek Sefranek for a correction in Section <a href="#page-25-0">8</a> on how to correctly implement zeroknowledge for t in Round 3. We thank Tohru Kohrita for a simplified proof of Claim <a href="#page-33-0">A.1.</a></p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[BCC+16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Efficient zeroknowledge arguments for arithmetic circuits in the discrete log setting. pages 327&ndash;357, 2016.</p></li>
      <li><p class="text-gray-300">[BCR+19] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS. In Advances in Cryptology - EUROCRYPT 2019 - 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Darmstadt, Germany, May 19-23, 2019, Proceedings, Part I, pages 103&ndash;128, 2019.</p></li>
      <li><p class="text-gray-300">[BDFG20] D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Halo infinite: Recursive zksnarks from any additive polynomial commitment scheme. IACR Cryptol. ePrint Arch., page 1536, 2020.</p></li>
      <li><p class="text-gray-300">[BG12] S. Bayer and J. Groth. Efficient zero-knowledge argument for correctness of a shuffle. In Advances in Cryptology - EUROCRYPT 2012 - 31st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cambridge, UK, April 15-19, 2012. Proceedings, pages 263&ndash;280, 2012.</p></li>
      <li><p class="text-gray-300">[BGM17] S. Bowe, A. Gabizon, and I. Miers. Scalable multi-party computation for zksnark parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. <a href="https://eprint.iacr.org/2017/1050" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2017/1050</a>.</p></li>
      <li><p class="text-gray-300">[CHM+19] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. P. Ward. Marlin: Preprocessing zksnarks with universal and updatable SRS. IACR Cryptology ePrint Archive, 2019:1047, 2019.</p></li>
      <li><p class="text-gray-300">[COS19] A. Chiesa, D. Ojha, and N. Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. IACR Cryptology ePrint Archive, 2019:1076, 2019.</p></li>
      <li><p class="text-gray-300">[CS10] C. Costello and D. Stebila. Fixed argument pairings. In International Conference on Cryptology and Information Security in Latin America, pages 92&ndash;108. Springer, 2010.</p></li>
      <li><p class="text-gray-300">[FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applications. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19- 23, 2018, Proceedings, Part II, pages 33&ndash;62, 2018.</p></li>
      <li><p class="text-gray-300">[Gab19] A. Gabizon. Auroralight:improved prover efficiency and SRS size in a soniclike system. IACR Cryptology ePrint Archive, 2019:601, 2019.</p></li>
      <li><p class="text-gray-300">[GGPR13] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct nizks without pcps. In Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, pages 626&ndash;645, 2013.</p></li>
      <li><p class="text-gray-300">[GKM+] J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. Updatable and universal common reference strings with applications to zk-snarks. IACR Cryptology ePrint Archive, 2018.</p></li>
      <li><p class="text-gray-300">[Gro16] J. Groth. On the size of pairing-based non-interactive arguments. In Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, pages 305&ndash;326, 2016.</p></li>
      <li><p class="text-gray-300">[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. pages 177&ndash;194, 2010.</p></li>
      <li><p class="text-gray-300">[MBKM] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updateable structured reference strings. <a href="https://eprint.iacr.org/2019/099" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/099</a>.</p></li>
      <li><p class="text-gray-300">[Set] S. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. <a href="https://eprint.iacr.org/2019/550" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/550</a>.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Claims for permutation argument:</h2>

    <p class="text-gray-300">The following claim is crucial for the correctness of the protocols in Section <a href="#page-18-0">5.</a></p>

    <p class="text-gray-300">Claim A.1. Fix any permutation &sigma; of [n], and any a1, . . . , an, b1, . . . , b<sup>n</sup> &isin; F. If</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i \\in [n]} (a_i + \\beta \\cdot i + \\gamma) = \\prod_{i \\in [n]} (b_i + \\beta \\cdot \\sigma(i) + \\gamma)</span>$</p>

    <p class="text-gray-300">with probability larger than n/|F| over uniform &beta;, &gamma; &isin; F; then b<sup>i</sup> = a&sigma;(i) for all i &isin; [n].</p>

    <p class="text-gray-300">We present the following proof by Tohru Kohrita.</p>

    <p class="text-gray-300">Proof. By Schwartz-Zippel and the assumption of the claim, the following equality of polynomials holds in F[X, Y ].</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i=1}^{n} (a_i + iX + Y) \\equiv \\prod_{i=1}^{n} (b_i + \\sigma(i)X + Y).</span>$</p>

    <p class="text-gray-300">Recall that F[X, Y ] is a unique factorization domain where the invertible elements are exactly F &lowast; . Note also that the linear factors in the above products are irreducible. Thus, there must be a one to one map M &rarr; M&prime; between the factors of each side, such that M = c &middot; M&prime; for some c &isin; F &lowast; . Moreover, since the coefficient of Y in all terms on both sides is one, we must always have c = 1. Thus, this mapping must map a factor on the LHS to one on the RHS with the same coefficient for X. In summary, we have for all i &isin; [n],</p>

    <p class="text-gray-300"><span class="math">$a_{\\sigma(i)} + \\sigma(i)X + Y \\equiv b_i + \\sigma(i)X + Y.</span>$</p>

    <p class="text-gray-300">Thus, we conclude that b<sup>i</sup> = a&sigma;(i) for all i &isin; [n].</p>

    </section>
`;
---

<BaseLayout title="PLONK: Permutations over Lagrange-bases for Oecumenical Noni... (2019/953)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/953
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Our results</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Efficiency Analysis</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Performance and Benchmarks</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Comparison with the randomized sumcheck approach, and Fractal/Marlin:</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Terminology and Conventions</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Analysis in the AGM model</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">A batched version of the [KZG10] scheme</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">The PCS</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Idealised low-degree protocols</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Polynomial protocols on ranges</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">From polynomial protocols to protocols against algebraic adversaries</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Polynomial protocols for identifying permutations</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Checking &quot;extended&quot; permutations</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Checking &quot;extended copy constraints&quot; using a permutation</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Constraint systems</a></li>
        <li><a href="#sec-7" class="hover:text-white">Main protocol</a></li>
        <li>
          <a href="#sec-8" class="hover:text-white">The final protocol, rolled out</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-8.1" class="hover:text-white">Polynomials that define a specific circuit</a></li>
            <li><a href="#sec-8.2" class="hover:text-white">The SNARK proof relation</a></li>
            <li><a href="#sec-8.3" class="hover:text-white">The protocol</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Claims for permutation argument:</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="plonk-permutations-over-lagrange-bases-for-oecumenical-2019" />
  </article>
</BaseLayout>
