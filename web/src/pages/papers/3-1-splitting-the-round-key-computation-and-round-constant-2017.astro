---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1148';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improvements to the Linear Operations of LowMC: A Faster Picnic';
const AUTHORS_HTML = 'Daniel Kales, L&eacute;o Perrin, Angela Promitzer, Sebastian Ramacher, Christian Rechberger';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Picnic is a practical approach to digital signatures where the security is primarily based on the existence of a one-way function, and the signature size strongly depends on the number of multiplications in the circuit describing that one-way function. The highly parameterizable block cipher family LowMC has the most competitive properties with respect to this metric and is hence a standard choice. In this paper, we study various options for efficient implementations of LowMC in-depth.

First, we investigate optimizations of the round key computation of LowMC independently of any implementation optimizations. By decomposing the round key computations based on the keys&#x27; effect on the S-box layer and general optimizations, we reduce runtime costs by up to a factor of 2 and furthermore reduce the size of the LowMC matrices by around 45% compared to the original Picnic implementation (CCS&#x27;17).

Second, we propose two modifications to the remaining matrix multiplication in LowMC&#x27;s linear layer. The first modification decomposes the multiplication into parts depending on the their effect on the S-box layer. While this requires the linear layer matrices to have an invertible submatrix, it reduces the runtime and memory costs significantly, both by up to a factor of 4 for instances used by Picnic and up to a factor of 25 for LowMC instances with only one S-box. The second modification proposes a Feistel structure using smaller matrices completely replacing the remaining large matrix multiplication in LowMC&#x27;s linear layer. With this approach, we achieve an operation count logarithmic in the block size but more importantly, improve over Picnic&#x27;s matrix multiplication by 60% while retaining a constant-time algorithm. Furthermore, this technique also enables us to reduce the memory requirements for storing LowMC matrices by 60%.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> LowMC &middot; efficient implementation &middot; Picnic &middot; post-quantum digital signatures</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Lightweight cryptographic primitives that only require a low number of multiplications have many applications ranging from reducing costs for countermeasures against side-channel attacks [DPVR00, GLSV14], over improving homomorphic encryption schemes [ARS+15, MJSC16, CCF+16, DSES14, NLV11] and multiparty computation [GRR+16, RSS17], to SNARKs [AGR+16]. Additionally, they also turned out to be useful to efficiently implement and reduce signature sizes of post-quantum signature schemes based on &Sigma;-protocols [CDG+17a] without requiring any structured hardness assumptions. The latter in particular builds upon LowMC [ARS+15, ARS+16], a highly parameterizable block cipher with a low number of multiplications. Using LowMC in this context enables further optimizations with respect to the signature size since the LowMC parameters can be chosen to suit scenarios where an adversary can only observe one plaintext-ciphertext pair. Recently, the combination zero-knowledge proofs and instantiations of symmetric-key primitives using LowMC also resulted in the first privacy-preserving signature schemes without requiring structured hardness assumptions. Those constructions include post-quantum ring signature schemes [DRS18] and group signature schemes [BEF18].</p>

    <p class="text-gray-300">We focus on the use of LowMC in the post-quantum digital signature scheme Picnic [CDG+17a, CDG+17b] which is based on zero-knowledge proofs of knowledge of pre-images of one-way functions. There, the one-way functions are instantiated using LowMC. Picnic relies on a proof system called ZKB++, which is based on the &quot;MPC-in-the-head&quot; [IKOS07] paradigm. To compute proofs in ZKB++, the circuit of the one-way function is decomposed into three branches where XOR gates and AND gates involving constants can be computed locally, but AND gates require communication between the branches. Thus the signature size depends on the total number of AND gates required the describe the one-way function as a circuit.</p>

    <p class="text-gray-300">From the use of LowMC in Picnic, diametral constraints emerge: First, the total number of AND gates, which is a multiple of the number of rounds and the number of S-boxes, directly relates to the signature size and is thus desired to be kept small. Second, as one decreases the number of S-boxes, the number of rounds increases which leads to a three-fold increase in the number of linear layer operations, i.e. additional XORs. Thus LowMC instances used in Picnic were selected to provide a trade-off between runtime and signature size. While applications using plain LowMC could save half of the linear operations by simply pre-computing round keys for multiple encryptions and decryptions, in Picnic the key is shared into fresh secret shares before each round of the proof system. Thus simple round key pre-computation cannot be applied to this use case. Any improvements to LowMC that reduces the number of XORs required to evaluate the linear layer thus allows one to target smaller signature sizes without sacrificing performance.</p>

    <p class="text-gray-300">In this work, we thus follow the direction of optimizing the number of XOR gates which influences the overall performance of LowMC. This goal can be achieved by finding a more efficient description of the LowMC encryption algorithm. Asking for an alternative description or finding implementation tricks which allow to improve the overall performance or make the use of the cipher viable under certain constraints in the first place, is a natural question to ask.</p>

    <p class="text-gray-300">This approach follows the line of work during and after the AES and others competitions, where many authors worked on fast software implementations [AL00, BS08], fast hardware implementations [SME16] but also on alternative and more efficient descriptions of the algorithm [BBF<sup>+</sup>02, BB02].</p>

    <p class="text-gray-300">The large number of XOR gates in LowMC arises from the two matrix multiplications involved in each round, where one is applied to compute the round key, and the other is applied to the state. Consequently, any improvement to matrixvector multiplication algorithms directly applies to LowMC. Fast matrix-vector multiplication over binary fields is especially interesting as lightweight cipher designs such as LowMC and Rasta [DEG<sup>+</sup>18] trade multiplicative complexity for large linear layers. Despite various improvements over the na&iuml;ve matrix-vector multiplication algorithm in last decades [ADKF70, Bar06, Ber09], a runtime of  <span class="math">\\mathcal{O}(nm/\\log(m))</span>  for  <span class="math">n \\times m</span>  matrices is currently the asymptotically best possible option. However, with the advent of single instruction, multiple data (SIMD) instruction sets the constant factors can be significantly decreased due the fact that 128, 256 or even 512 bits can be processed simultaneously. As an alternative to directly optimizing matrix-vector multiplication algorithms, we investigate specialized Feistel networks, which behave similarly to a matrix-vector multiplication. The exploration of Feistel Networks is as old as block ciphers itself, e.g., see [NPV17] for a recent overview. Following the line of work of Suzaki and Minematsu [SM10], we present a new Feistel network for an arbitrary number of branches with fast diffusion.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Contribution</h3>

    <p class="text-gray-300">The contributions of this work can be summarized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We propose an alternative description of LowMC with a new structure to compute round keys and apply round constants. The idea here is to split the computation into linear and non-linear parts. This change allows us to replace all round key computations only affecting the linear part by exactly one matrix multiplication. The remaining non-linear parts can then be computed by much smaller round key matrices. The addition of the round constants can also be considered as constants applied to the non-linear parts and linear parts, making it possible to move all constants applied to the linear part to the beginning. This new description of LowMC allows us to greatly reduce the size of the LowMC constants. In the signature scheme use-case, this optimization leads to performance improvements which range from a factor of 1.5 for smaller block sizes to a factor of 2 for larger block sizes. Additionally, this optimization is independent of implementation optimizations of the matrix multiplication.</li>
      <li>We present an optimization to the matrix multiplication in the linear layer of LowMC, where we employ similar techniques to split the computation into linear and non-linear parts<sup>4</sup>. Again, this changes allow us to reduce the</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup> Independently, Dinur proposed and analyzed a similar optimization [Din18].</p>

    <p class="text-gray-300">overall number of multiplications by moving computations involving linear parts of the state to the beginning of the encryption procedure. These optimizations reduce the number of operations for the linear layer computations as well as the memory requirements from  <span class="math">r \\cdot n^2</span>  to  <span class="math">r \\cdot (n^2 - (n-3 \\cdot m)^2) + n^2</span> , for instances for LowMC with r rounds, blocksize n and m S-boxes. This optimization is especially impactful for instances with low numbers of S-boxes. We evaluate these improvements in the signature scheme use-case and report significant performance improvements as the optimizations reduce the runtime to a quarter of the original runtime.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We present Fibonacci Feistel Networks (FFNs), a variant of Generalized Feistel Networks, which provide very fast diffusion. Instantiating the network with regular matrices as permutations we obtain a compact representation of a larger matrix multiplication. The obtained equivalent of a matrix multiplication algorithm with logarithmic complexity can then be used to replace the linear layer of LowMC. This technique reduces the size of the LowMC matrices again by up to 60 %.</li>
    </ul>

    <p class="text-gray-300">Albeit we focus on the Picnic use-case in the practical part of the work, both contributions will also positively affect other use-cases of LowMC. The alternative description is likely to be useful for cryptanalysis purposes as well.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we briefly recall the core components of Picnic: LowMC and the (2,3)-decomposition of cuircuits.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 LowMC</h3>

    <p class="text-gray-300">LowMC [ARS+15, ARS+16] is a very parameterizable symmetric encryption scheme design enabling instantiation with low AND depth and low multiplicative complexity. Given any block size, a choice for the number of S-boxes per round, and security expectations in terms of time and data complexity, instantiations can be found minimizing the AND depth, the number of ANDs, or the number of ANDs per encrypted bit. Now let n be the block size, m be the number of S-boxes, k the key size, and r the number of rounds, we choose round constants  <span class="math">C_i \\stackrel{R}{\\leftarrow} \\mathbb{F}_2^n</span>  for  <span class="math">i \\in [1, r]</span> , full rank matrices  <span class="math">K_i \\stackrel{R}{\\leftarrow} \\mathbb{F}_2^{n \\times k}</span>  and regular matrices  <span class="math">L_i \\stackrel{R}{\\leftarrow} \\mathbb{F}_2^{n \\times n}</span>  independently during the instance generation and keep them fixed. Keys for LowMC are generated by sampling from  <span class="math">\\mathbb{F}_2^k</span>  uniformly at random. LowMC consists of key whitening in the beginning and multiple rounds composed of an S-box layer, a linear layer, addition with constants and addition of the round key. Algorithm 1 gives a full description of the encryption algorithm.</p>

    <p class="text-gray-300">To reduce the multiplicative complexity, the number of S-boxes applied in parallel can be reduced, leaving part of the substitution layer as the identity <strong>Algorithm 1</strong> LOWMC encryption for key matrices  <span class="math">K_i \\in \\mathbb{F}_2^{n \\times k}</span>  for  <span class="math">i \\in [0, r]</span> , linear layer matrices  <span class="math">L_i \\in \\mathbb{F}_2^{n \\times n}</span>  and round constants  <span class="math">C_i \\in \\mathbb{F}_2^n</span>  for  <span class="math">i \\in [1, r]</span> .</p>

    <pre><code class="language-text">Require: plaintext p \\in \\mathbb{F}_2^n and key y \\in \\mathbb{F}_2^k
s \\leftarrow K_0 \\cdot y + p
for i \\in [1, r] do
s \\leftarrow \\operatorname{SBOX}(s)
s \\leftarrow L_i \\cdot s
s \\leftarrow s + C_i + K_i \\cdot y\\nend for
return s
</code></pre>

    <p class="text-gray-300">mapping. We also note that this choice has little to no influence on the efficiency of the S-box layer since a bit-sliced implementation can process all at once<sup>5</sup>.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 (2,3)-Decomposition of Circuits in Picnic</h3>

    <p class="text-gray-300">Circuit decomposition is a protocol for jointly computing a circuit, similar to an MPC protocol but with higher efficiency. In a (2, 3)-decomposition there are three players and the protocol has 2-privacy, i.e., it remains secure even if two of the three players are corrupted. We discuss some definitions from [GMO16] and the instantiation in PICNIC [CDG<sup>+</sup>17a].</p>

    <p class="text-gray-300"><strong>Definition 1 ((2,3)-decomposition).</strong> Let f be a function that is computed by an n-gate circuit  <span class="math">\\phi</span>  such that  <span class="math">f(x) = \\phi(x) = y</span> . Let  <span class="math">k_1, k_2</span> , and  <span class="math">k_3</span>  be tapes of length  <span class="math">\\kappa</span>  chosen uniformly at random from  <span class="math">\\{0,1\\}^{\\kappa}</span>  corresponding to players  <span class="math">P_1, P_2</span>  and  <span class="math">P_3</span> , respectively. The tuple of algorithms (Share, Update, Output, Reconstruct) are defined as follows:</p>

    <p class="text-gray-300">Share <span class="math">(x, k_1, k_2, k_3)</span> : On input of the secret value x, outputs the initial views for each player containing the secret share  <span class="math">x_i</span>  of x.</p>

    <p class="text-gray-300">Update(view<sub>i</sub><sup>(j)</sup>, view<sub>i+1</sub><sup>(j)</sup>,  <span class="math">k_i</span> ,  <span class="math">k_{i+1}</span> ): On input of the views view<sub>i</sub><sup>(j)</sup>, view<sub>i+1</sub><sup>(j)</sup> and random tapes  <span class="math">k_i</span> ,  <span class="math">k_{i+1}</span> , compute wire values for the next gate and returns the updated view view<sub>i</sub><sup>(j+1)</sup>.</p>

    <p class="text-gray-300">Output(view<sub>i</sub><sup>(n)</sup>): On input of the final view view<sub>i</sub><sup>(n)</sup>, returns the output share  <span class="math">y_i</span> . Reconstruct( <span class="math">y_1, y_2, y_3</span> ): On input of output shares  <span class="math">y_i</span> , reconstructs and returns y.</p>

    <p class="text-gray-300">Correctness requires that reconstructing a (2,3)-decomposed evaluation of a circuit  <span class="math">\\phi</span>  yields the same value as directly evaluating  <span class="math">\\phi</span>  on the input value. The 2-privacy property requires that revealing the values from two shares reveals nothing about the input value.</p>

    <p class="text-gray-300">The  <span class="math">\\Sigma</span> -protocol ZKB++ constructs the (2, 3)-decomposition of a circuit as follows: Let R be an arbitrary finite ring and  <span class="math">\\phi</span>  a function such that  <span class="math">\\phi: R^m \\to R^\\ell</span></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup> Given m S-boxes, the bit-sliced implementation can be implemented using  <span class="math">3 \\cdot m</span>  bit ANDs, ORs and shifts. Thus, as long as  <span class="math">3 \\cdot m</span>  bit fit into a platform's registers, the m-fold S-box can be implemented apart from 4 masking values without any overhead compared to a single S-box.</p>

    <p class="text-gray-300">can be expressed by an n-gate arithmetic circuit over the ring using addition (respectively multiplications) by constants, and binary addition and binary multiplication gates. A (2,3)-decomposition of  <span class="math">\\phi</span>  is then given by:</p>

    <p class="text-gray-300">Share <span class="math">(x, k_1, k_2, k_3)</span> : Samples random  <span class="math">x_1, x_2 \\in \\mathbb{R}^m</span>  from  <span class="math">k_1</span>  and  <span class="math">k_2</span>  and computes  <span class="math">x_3</span>  such that  <span class="math">x_1 + x_2 + x_3 = x</span> . Returns views containing  <span class="math">x_1, x_2, x_3</span> .</p>

    <p class="text-gray-300">Update<sub>i</sub><sup>(j)</sup>(view<sub>i</sub><sup>(j)</sup>, view<sub>i+1</sub><sup>(j)</sup>,  <span class="math">k_i</span> ,  <span class="math">k_i</span> ,  <span class="math">k_i</span> ): Computes  <span class="math">P_i</span> 's view of the output wire of gate  <span class="math">g_j</span>  and appends it to the view. For the k-th wire  <span class="math">w_k</span>  where  <span class="math">w_k^{(i)}</span>  denotes  <span class="math">P_i</span> 's view, the update operation is defined as follows:</p>

    <p class="text-gray-300">Addition by constant  <span class="math">(w_b = w_a + c)</span> :  <span class="math">w_b^{(i)} = w_a^{(i)} + c</span>  if i = 1 and  <span class="math">w_b^{(i)} = w_a^{(i)}</span>  otherwise.</p>

    <p class="text-gray-300">Multiplication by constant  <span class="math">(w_b = c \\cdot w_a)</span> :  <span class="math">w_b^{(i)} = c \\cdot w_a^{(i)}</span></p>

    <p class="text-gray-300">Binary addition  <span class="math">(w_c = w_a + w_b)</span> :  <span class="math">w_c^{(i)} = w_a^{(i)} + w_b^{(i)}</span></p>

    <p class="text-gray-300">Binary multiplication  <span class="math">(w_c = w_a \\cdot w_b)</span> :  <span class="math">w_c^{(i)} = w_a^{(i)} \\cdot w_b^{(i)} + w_a^{(i+1)} \\cdot w_b^{(i)} + w_a^{(i)} \\cdot w_b^{(i+1)} + R_i(c) - R_{i+1}(c)</span>  where  <span class="math">R_i(c)</span>  is the c-th output of a pseudorandom generator seeded with  <span class="math">k_i</span> .</p>

    <p class="text-gray-300">Output<sub>i</sub>(view<sub>i</sub><sup>(n)</sup>): Return the  <span class="math">\\ell</span>  output wires stored in the view view<sub>i</sub><sup>(n)</sup>. Reconstruct <span class="math">(y_1, y_2, y_3)</span> : Computes  <span class="math">y = y_1 + y_2 + y_3</span>  and returns y.</p>

    <p class="text-gray-300">Note that  <span class="math">P_i</span>  can compute all gate types with the exception of binary multiplication gates locally as the latter requires inputs from  <span class="math">P_{i+1}</span> . In other words, only outputs of binary multiplication gates need to be serialized, and thus the view size and consequentially the signature size of PICNIC depend on the size of the ring R and the number of multiplication gates.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Optimizing Linear Operations</h2>

    <p class="text-gray-300">From the use of LOWMC in PICNIC, we obtain some constraints on the optimizations we are allowed to perform. The S-box serves as a synchronization point on the first  <span class="math">3 \\cdot m</span>  bits, i.e., the bits that are actually touched by the S-box. On the other  <span class="math">n-3 \\cdot m</span>  bits the S-box is simply the identity map, and their actual values do not matter for S-box evaluations. Thus we have to ensure that the evaluation of all AND gates stays invariant under all our optimizations. Secondly, we have to assume that the secret key &ndash; or more precisely the shares representing it &ndash; changes on every encryption.</p>

    <p class="text-gray-300">We start with the round key computation. Since the secret key is freshly shared for each LOWMC evaluation in PICNIC, the round keys cannot be pre-computed once during initialization. However, we can observe that due to the structure of the S-box layer for  <span class="math">n-3\\cdot m</span>  bits of the round key, which coincide with the part of the state where the S-box acts as identity map, it does not matter whether</p>

    <p class="text-gray-300">those bits are added to the state before or after the application of the S-box. Due to the linear nature of all operations involved in the computation after the S-box, we can simply change the order of adding the round key and multiplying the state with  <span class="math">L_i</span> . We modify each round as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Modify  <span class="math">s \\leftarrow L_i \\cdot s + K_i \\cdot y + C_i</span>  to  <span class="math">s \\leftarrow L_i \\cdot (L_i^{-1} \\cdot K_i \\cdot y + s) + C_i</span> . Now split  <span class="math">L_i^{-1} \\cdot K_i \\cdot y</span>  into the lower  <span class="math">3 \\cdot m</span>  bits (the &quot;non-linear part&quot;) and the upper  <span class="math">n-3 \\cdot m</span>  bits (the &quot;linear part&quot;) and move the addition of the upper  <span class="math">n-3 \\cdot m</span>  bits before the S-box layer.</li>
    </ul>

    <p class="text-gray-300">In the following we denote by  <span class="math">\\rho_i^j: \\mathbb{F}_2^n \\to \\mathbb{F}_2^{j-i+1}</span>  the map sending <em>n</em>-dimensional vectors to a vector consisting of the <em>i</em> to <em>j</em>-th coordinates, i.e.  <span class="math">\\rho_i^j(v_1,\\ldots,v_n) \\mapsto</span>  <span class="math">(v_i, \\ldots, v_j)</span> , to simplify some notation when referring to the linear and non-linear part. In particular, we use  <span class="math">\\rho_L = \\rho_{3\\cdot m+1}^n</span>  to identify the linear part and  <span class="math">\\rho_N = \\rho_1^{3\\cdot m}</span> for the non-linear part, respectively.</p>

    <p class="text-gray-300">Fig. 1 now demonstrates one round of LowMC with the above modifications. Observe that this modification does not change the output of LowMC. Additionally, we can continue moving the addition of the linear part to the previous round until all those additions have been moved at the start of the algorithm.</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1: One round of LowMC before (left) and after (right) the splitting of the round key addition.</p>

    <p class="text-gray-300">After iterating this procedure to move all linear parts of the round key before the round, we end up with all additions of the linear parts of the round key before the first round and are left with a reduced round key of  <span class="math">3 \\cdot m</span>  bits per round. For the computation of the linear and non-linear part, the matrix  <span class="math">\\overline{L_i^{-1}}</span>  has to be computed for each LowMC round i. By  <span class="math">\\overline{L_i^{-1}}</span>  we denote the inverse of the linear layer matrix  <span class="math">L_i</span>  with the first  <span class="math">3 \\cdot m</span>  rows of this inverse set to 0.</p>

    <p class="text-gray-300">The linear part can be computed by calculating the matrix  <span class="math">P_L</span>  defined as</p>

    <p class="text-gray-300"><span class="math">$P_L = \\overline{L_1^{-1}} \\cdot K_1 + \\sum_{j=2}^r \\left( \\prod_{k=1}^j \\overline{L_k^{-1}} \\right) \\cdot K_j</span>$</p>

    <p class="text-gray-300">and then multiplying it with the secret key y and adding the result to the initial state  <span class="math">s_0</span> . The matrix  <span class="math">P_L</span>  can be precomputed from the LowMC matrices before any encryption and thus only the matrix multiplication with the secret key y and the addition to the initial state  <span class="math">s_0</span>  is required at the beginning of the encryption. For the non-linear part we can define a similar matrix</p>

    <p class="text-gray-300"><span class="math">$P_{N,i} = \\overline{L_i^{-1}} \\cdot K_i + \\sum_{j=i+1}^r \\left( \\prod_{k=i}^j \\overline{L_k^{-1}} \\right) \\cdot K_j</span>$</p>

    <p class="text-gray-300">for round i. This matrix  <span class="math">P_{N,i}</span>  of dimension  <span class="math">(n \\times k)</span>  is then multiplied with the secret key y and the first  <span class="math">3 \\cdot m</span>  bits of this result are added to the state in the corresponding LowMC round after applying the S-box function to the state. However, this still implies that this multiplication  <span class="math">P_{N,i} \\cdot y</span>  is done in every LowMC round, which can be avoided by using the following structure. As only  <span class="math">3 \\cdot m</span>  bits of  <span class="math">P_{N,i} \\cdot y</span>  are used, we can combine the first  <span class="math">3 \\cdot m</span>  rows of the matrix  <span class="math">P_{N,i}</span> , denoted as  <span class="math">\\overline{P_{N,i}}^{3 \\cdot m}</span> , of all rounds i to one matrix  <span class="math">P_N</span>  of dimension  <span class="math">(3 \\cdot m \\cdot r \\times k)</span>  given by</p>

    <p class="text-gray-300"><span class="math">$P_{N} = \\underbrace{\\begin{bmatrix} \\overline{P_{N,i}}^{3 \\cdot m} \\\\ \\vdots \\\\ \\overline{P_{N,r}}^{3 \\cdot m} \\end{bmatrix}}_{k \\text{ cols}} \\} 3 \\cdot m \\text{ rows}</span>$</p>

    <p class="text-gray-300">This matrix is then multiplied with the secret key y before the first round, which results in a  <span class="math">3 \\cdot m \\cdot r</span>  dimensional vector v. Now, the  <span class="math">3 \\cdot m</span>  bits starting from bit  <span class="math">1+3 \\cdot m \\cdot (i-1)</span>  of the vector v are added to the non-linear part of the state in round i. So, although the non-linear part remains in each LowMC round, the computation effort is reduced from a  <span class="math">(n \\times k)</span>  matrix-vector multiplication and a n-bit XOR to a  <span class="math">3 \\cdot m</span> -bit XOR in each round. The pre-computation of  <span class="math">P_L</span>  and  <span class="math">P_{N,i}</span>  can be done independently of the secret key y during the LowMC instance generation. The multiplications  <span class="math">P_L \\cdot y</span>  and  <span class="math">P_N \\cdot y</span>  have to be done once at the start of the encryption algorithm with the specific shares of y for this encryption. The same procedure can also be applied to the constants, leading to constant vectoris  <span class="math">C_L</span>  and  <span class="math">C_N</span>  computed in the same way as  <span class="math">P_L</span>  and  <span class="math">P_N</span>  with  <span class="math">K_i</span>  replaced by  <span class="math">C_i</span> . Algorithm 2 depicts LowMC encryption with split round key and constants.</p>

    <p class="text-gray-300"><strong>Algorithm 2</strong> LOWMC encryption with the split round key for key matrix  <span class="math">K_0 \\in \\mathbb{F}_2^{n \\times k}</span> , linear layer matrices  <span class="math">L_i \\in \\mathbb{F}_2^{n \\times n}</span>  for  <span class="math">i \\in [1, r]</span> , and precomputed matrices  <span class="math">P_L</span>  and  <span class="math">P_N</span>  and vectors  <span class="math">C_L</span>  and  <span class="math">C_N</span> .</p>

    <pre><code class="language-text">Require: plaintext p \\in \\mathbb{F}_2^n and key y \\in \\mathbb{F}_2^k
v \\leftarrow P_N \\cdot y + C_N
s \\leftarrow (K_0 + P_L) \\cdot y + p + C_L
for i \\in [1, r] do
s \\leftarrow \\text{SBOX}(s)
s \\leftarrow \\rho_{1+3 \\cdot m \\cdot (i-1)}^{3 \\cdot m \\cdot i}(v) + s
s \\leftarrow L_i \\cdot s\\nend for
return s
</code></pre>

    <p class="text-gray-300">The sizes of matrices for the unmodified LowMC algorithm and LowMC with the reduced round key computation and constant addition (RRKC) are presented in Table 1. From the memory required to store the matrices, it can be seen that LowMC with RRKC reduces the memory consumption for the round keys from r+1 ( <span class="math">n \\times k</span> ) matrices to a ( <span class="math">n \\times k</span> ) and a ( <span class="math">3 \\cdot m \\cdot r \\times k</span> ) matrix. Additionally, the r n dimensional vectors used as round constants are now stored as a n and a  <span class="math">3 \\cdot m \\cdot r</span>  dimensional vectors. These memory savings come at the cost of computing an additional  <span class="math">3 \\cdot m \\cdot r</span>  dimensional vector to store the non-linear part for each specific encryption.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">LowMC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">LowMC with RRKC $ \\begin{array}{ c c c c c c c c c c c c c c c c c c c$</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Linear layer</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r</span> <span class="math">(n \\times n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r (n \\times n)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Round key matrices</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r+1 (n \\times k)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (n \\times k)</span> (linear part)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (3 \\cdot m \\cdot r \\times k)</span> (non-linear part)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Round constants</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (3 \\cdot m \\cdot r)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 (n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Additional memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{vmatrix} 1 &amp; (n) \\\\ 1 &amp; (3 \\cdot m \\cdot r) \\text{ (vector } v \\end{aligned}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Matrices for general LowMC and LowMC with RRKC.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Reducing Linear Layer Computation</h3>

    <p class="text-gray-300">A similar modification can be applied to the linear layer matrices, where a substantial part of the linear layer computation can be moved to the first round. We take the linear layer matrix  <span class="math">L_i</span>  and split it into 4 submatrices depending on the number of S-boxes in the linear layer:</p>

    <p class="text-gray-300"><span class="math">3 \\cdot m</span>  columns  <span class="math">n-3 \\cdot m</span>  columns</p>

    <p class="text-gray-300"><span class="math">$L_i = \\left| \\begin{array}{c|c} \\mathcal{N}_i &amp; \\mathcal{A}_i \\\\ \\mathcal{N}_i &amp; \\mathcal{A}_i \\\\ \\mathcal{B}_i &amp; \\mathcal{L}_i \\end{array} \\right| \\left. \\begin{array}{c} 3 \\cdot m \\text{ rows} \\\\ n - 3 \\cdot m \\text{ rows} \\end{array} \\right|</span>$</p>

    <p class="text-gray-300">We also split the state into the non-linear part  <span class="math">s_N</span>   <span class="math">(3 \\cdot m</span>  bits) and the linear part  <span class="math">s_L</span>   <span class="math">(n-3 \\cdot m</span>  bits). We rewrite the standard linear layer multiplication  <span class="math">s^{i+1} = L_i \\cdot s^i</span>  into this submatrix form:</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} s_N^{i+1} \\\\ s_L^{i+1} \\end{bmatrix} = \\begin{bmatrix} \\mathcal{N}_i &amp; \\mathcal{A}_i \\\\ \\mathcal{B}_i &amp; \\mathcal{L}_i \\end{bmatrix} \\cdot \\begin{bmatrix} s_N^i \\\\ s_L^i \\end{bmatrix} = \\begin{bmatrix} \\mathcal{N}_i \\cdot s_N^i + \\mathcal{A}_i \\cdot s_L^i \\\\ \\mathcal{B}_i \\cdot s_N^i + \\mathcal{L}_i \\cdot s_L^i \\end{bmatrix} \\,.</span>$</p>

    <p class="text-gray-300">With the precondition that the submatrix  <span class="math">\\mathcal{L}_i</span>  is invertible, we can now move the multiplication by  <span class="math">\\mathcal{L}_i</span>  before the other multiplications as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} s_N^{i+1} \\\\ s_L^{i+1} \\end{bmatrix} = \\begin{bmatrix} \\mathcal{N}_i &amp; \\mathcal{A}_i \\cdot \\mathcal{L}_i^{-1} \\\\ \\mathcal{B}_i &amp; \\mathbf{I} \\end{bmatrix} \\cdot \\begin{bmatrix} s_N^i \\\\ \\mathcal{L}_i \\cdot s_L^i \\end{bmatrix} = \\begin{bmatrix} \\mathcal{N}_i \\cdot s_N^i + \\mathcal{A}_i \\cdot s_L^i \\\\ \\mathcal{B}_i \\cdot s_N^i + \\mathcal{L}_i \\cdot s_L^i \\end{bmatrix} \\,.</span>$</p>

    <p class="text-gray-300">This process is depicted in Fig. 2. While this does not reduce the overall multiplications for a single round of LOWMC, we use the same technique as in the splitting of the round keys and move the multiplication by  <span class="math">\\mathcal{L}_i</span>  even futher back to the beginning of the previous round. We can repeat this process for multiple rounds, allowing us to group all multiplications by  <span class="math">\\mathcal{L}_i</span>  together in a single matrix  <span class="math">Z_0</span> , which is precomputed and multiplied with the linear part of the state before the first round. However, we need to take care to correct the introduced differences that are a result of moving the matrices  <span class="math">\\mathcal{L}_i</span>  by modifying the submatrices  <span class="math">\\mathcal{A}_i</span>  and  <span class="math">\\mathcal{B}_i</span>  accordingly. We create the new, modified linear-layer matrices  <span class="math">Z_i</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$Z_i = \\begin{bmatrix} \\mathcal{N}_i &amp; \\mathcal{A}_i \\cdot \\prod_{k=i}^r \\mathcal{L}_k^{-1} \\\\ \\left(\\prod_{k=0}^{r-(i+1)} \\mathcal{L}_{r-k}\\right) \\cdot \\mathcal{B}_i &amp; I \\end{bmatrix},</span>$</p>

    <p class="text-gray-300">and combine all multiplications by  <span class="math">\\mathcal{L}_i</span>  into a new matrix  <span class="math">Z_0</span> :</p>

    <p class="text-gray-300"><span class="math">$Z_0 = \\begin{bmatrix} I &amp; 0 \\\\ 0 &amp; \\prod_{k=0}^{r-1} \\mathcal{L}_{r-k} \\end{bmatrix}.</span>$</p>

    <p class="text-gray-300">This reduced linear layer matrices  <span class="math">Z_i</span>  allow us to decrease the size of the matrix multiplications in the algorithm, since the  <span class="math">n-3 \\cdot m \\times n-3 \\cdot m</span>  submatrix</p>

    <p class="text-gray-300">    <img src="_page_10_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2: One round of LowMC before (left) and after (right) the splitting of the linear layer computation.</p>

    <p class="text-gray-300">of  <span class="math">Z_i</span>  is now the identity matrix. To be precise, we reduce the multiplications from a  <span class="math">n \\times n \\cdot n \\times 1</span>  matrix-vector multiplication to a  <span class="math">n \\times 3 \\cdot m \\cdot 3 \\cdot m \\times 1</span>  and a  <span class="math">3 \\cdot m \\times (n-3 \\cdot m) \\cdot (n-3 \\cdot m) \\times 1</span>  matrix-vector multiplication. These improvements are especially noticable when m is very small, meaning we have a small amount of S-boxes per round. These instances are also the ones with the lowest number of AND gates, and therefore the preferred instances for many use-cases. Algorithm 3 depicts LowMC encryption with reduced linear-layer matrices.</p>

    <p class="text-gray-300">One downside to this approach is that it is not compatible with standard LowMC, as the generation of the random matrices does not ensure that the submatrix  <span class="math">\\mathcal{L}_i</span>  is indeed invertible. We can still try to apply this approach to standard LowMC, using the standard  <span class="math">L_i</span>  matricies if  <span class="math">\\mathcal{L}_i</span>  is not invertible, and use this optimization for any consecutive rounds where  <span class="math">\\mathcal{L}_i</span>  is invertible. However, since the chance of a random  <span class="math">\\mathcal{L}_i</span>  being invertible is  <span class="math">\\approx \\frac{1}{3}</span> , the potential for optimization is pretty small. We therefore propose a new variant of LowMC, called LowMC-I, with the only difference being that for a given instance with statesize n, keysize k, number of S-boxes m and rounds r, we ensure while generating the matrices  <span class="math">L_i</span>  that the submatrix  <span class="math">\\mathcal{L}_i</span>  of size  <span class="math">(n-3 \\cdot m) \\times (n-3 \\cdot m)</span>  is invertible. We however note that the matrices are still sampled at random where the sampling algorithm gains an additional rejection condition in addition to the matrices being invertible. Thus the modification is still compatible with exsting LowMC</p>

    <p class="text-gray-300"><strong>Algorithm 3</strong> LOWMC encryption with the split round key for key matrix  <span class="math">K_0 \\in \\mathbb{F}_2^{n \\times k}</span> , reduced linear layer matrices  <span class="math">Z_i \\in \\mathbb{F}_2^{n \\times n}</span>   <span class="math">i \\in [1, r]</span> , precomputed matrices  <span class="math">P_L, Z_0</span>  and  <span class="math">P_N</span> , and precomputed vectors  <span class="math">C_L</span>  and  <span class="math">C_N</span> .</p>

    <pre><code class="language-text">Require: plaintext p \\in \\mathbb{F}_2^n and key y \\in \\mathbb{F}_2^k
v \\leftarrow P_N \\cdot y + C_N
s \\leftarrow (K_0 + P_L) \\cdot y + p + C_L
s \\leftarrow Z_0 \\cdot s
for i \\in [1, r] do
s \\leftarrow \\text{SBOX}(s)
s \\leftarrow \\rho_{1+3 \\cdot m \\cdot (i-1)}^{3 \\cdot m \\cdot i}(v) + s
s \\leftarrow Z_i \\cdot s\\nend for
return s
</code></pre>

    <p class="text-gray-300">security analysis. The additional rejection condition increases the complexity of the sampling algorithm at most by a constant factor of about 3.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">LowMC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\big \\operatorname{LowMC}</span> with RRKC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">LowMC with RLL</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Linear layer</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r (n \\times n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r</span> <span class="math">(n \\times n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{vmatrix} r &amp; (n \\times 3 \\cdot m) \\ r &amp; (3 \\cdot m \\times (n - 3 \\cdot m)) \\ 1 &amp; ((n - 3 \\cdot m) \\times (n - 3 \\cdot m)) \\end{vmatrix} $</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r (3 \\cdot m \\times (n - 3 \\cdot m))</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 ((n-3\\cdot m)\\times (n-3\\cdot m))</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Round key matrices</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r+1 (n \\times k)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ 1 (n \\times k) $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (n \\times k)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (3 \\cdot m \\cdot r \\times k)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (3 \\cdot m \\cdot r \\times k)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Round constants</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r (1 \\times n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{vmatrix} 1 &amp; (3 \\cdot m \\cdot r \\times k) \\ 1 &amp; (3 \\cdot m \\cdot r) \\end{vmatrix} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (3 \\cdot m \\cdot r)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1(n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Additional memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (3 \\cdot m \\cdot r \\times 1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 (3 \\cdot m \\cdot r \\times 1)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Matrices for general LowMC, LowMC with RRKC and LowMC with RRKC and RLL.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Fibonacci Feistel Network</h3>

    <p class="text-gray-300">Given that the cost of storing a binary matrix operating on n bits is proportional to  <span class="math">n^2</span> , it is possible to decrease the cost of a  <span class="math">n \\times n</span>  matrix when it can be implemented using several  <span class="math">m \\times m</span>  matrices with m &lt; n. In this section, we describe a method for building large binary matrices using several smaller ones while still ensuring that every output bit may depend on every input bit.</p>

    <p class="text-gray-300">Our main idea is to borrow techniques from block cipher design, in particular from Generalized Feistel Networks (GFN). In fact, we propose a new variant of this structure, called <em>Fibonacci Feistel Network (FFN)</em>, which provides very fast diffusion. As its name indicates, this structure uses the Fibonaci sequence</p>

    <p class="text-gray-300"><span class="math">\\{\\phi_i\\}_{i&gt;0}</span>  defined by the well-known induction formula:</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} \\phi_0 = 0, \\, \\phi_1 = 1 \\\\ \\phi_{i+1} = \\phi_i + \\phi_{i-1}, \\end{cases}</span>$</p>

    <p class="text-gray-300">so that  <span class="math">\\phi_0, \\phi_1, \\phi_2, \\phi_3, \\phi_4, \\phi_5 = 0, 1, 1, 2, 3, 5</span> . The smallest integer i such that  <span class="math">\\phi_i &gt; b</span>  is denoted  <span class="math">i = \\Lambda_{\\phi}(b)</span> . For example,  <span class="math">\\phi_8 = 21</span>  and  <span class="math">\\phi_9 = 34</span> , so  <span class="math">\\Lambda_{\\phi}(32) = 9</span> .</p>

    <p class="text-gray-300">The Fibonacci-Feistel Structure. A FFN operates on  <span class="math">2 \\times b \\times w</span>  bits, where  <span class="math">w \\geq 4</span>  and  <span class="math">b \\geq 2</span> , using R rounds. The round functions are different in each round although they always use the same overall structure: each round is a classical 2-branched Feistel round where the Feistel functions maps  <span class="math">b \\times w</span>  bits to  <span class="math">b \\times w</span>  bits. The Feistel function used in round i, denoted  <span class="math">F_i</span> , works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the state is divided into b branches of w bits denotes as  <span class="math">B_0, \\ldots, B_{b-1}</span> ,</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>each branch goes through a w-bit L-Box, that is, a linear function mapping w bits to w bits, and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the branches are rotated by  <span class="math">\\phi_i</span> , so that  <span class="math">B_j \\leftarrow B_{j-\\phi_i \\pmod{b}}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Alternatively, let us denote the  <span class="math">2 \\times b \\times w</span> -bit internal state at round i as  <span class="math">X^i</span>  and its w-bit branch with index j as  <span class="math">X^i_j</span> . The full round function works as follows, for j &lt; b:</p>

    <p class="text-gray-300"><span class="math">$X_{j+b}^{i+1} = X_{j}^{i}, \\ X_{j}^{i+1} = X_{j+b}^{i} \\oplus L_{j-\\phi_{i}}^{i} \\left( X_{j-\\phi_{i}}^{i} \\right),</span>$</p>

    <p class="text-gray-300">where  <span class="math">j - \\phi_i</span>  is taken modulo b and where  <span class="math">L_j^i</span>  is a w-bit L-Box. An example is given in Fig. 4 in Appendix A.</p>

    <p class="text-gray-300"><strong>Diffusion in a FFN.</strong> Diffusion is very fast in such a structure. The idea of using something more sophisticated than a constant rotation for mixing the branches is not new. In [SM10], Minematsu and Suzaki proposed using complex permutations which significantly improve diffusion: for a structure operating on k branches, only  <span class="math">2\\log_2(k)</span>  rounds are needed to achieve full diffusion while a na&iuml;ve constant rotation would need k rounds. Furthermore, the gain increases as the number of rounds increases, making such methods even more appealing on larger blocks. It was for example used to design the lightweight block cipher TWINE [SMMK12].</p>

    <p class="text-gray-300">Unlike such GFN, the FFN needs a different permutation in each round. However, it works for any even number of branches, we are not restricted to powers of two. The permutations used are also much simpler and, as we explain later, they can lend themselves well to constant-time software implementations using only ANDs, XORs and rotations.</p>

    <p class="text-gray-300">In what follows, we present two lemmas which quantify diffusion inside a FFN more formally. Lemma 1 describes how a single word diffuses through several rounds of FFN, while Lemma 2 highlights some invariant properties of such a network. These two are put together in Corollary 1 to quantify how many rounds are needed to have some form of full diffusion.</p>

    <p class="text-gray-300">In the remainder of this section, we denote with  <span class="math">X_j^i</span>  the word with index j at the input of round i and we say that x influences y if the expression of y involves the variable x. Our definition of diffusion is borrowed from [SM10]. In particular, we consider that we have achieved &quot;full diffusion&quot; when any output word is influenced by all input words.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Consider a FFN with i rounds, where  <span class="math">\\phi_{i+1} \\leq b</span> . Then the word  <span class="math">X_0^0</span>  influences all words  <span class="math">X_j^i</span>  with indices  <span class="math">0 \\leq j &lt; \\phi_{i+1}</span>  or  <span class="math">b \\leq j &lt; b + \\phi_i</span> .</p>

    <p class="text-gray-300">The process behind Lemma 1 is illustrated in Fig. 3. A formal proof based on this intuition is provided below.</p>

    <p class="text-gray-300"><em>Proof.</em> We proceed by induction. Before round 0, i.e. at the beginning of the application of the FFN, only  <span class="math">X_0^0</span>  depends on  <span class="math">X_0^0</span> . After round 0 (where the Feistel function contains a rotation by  <span class="math">\\phi_0 = 0</span> ), only  <span class="math">X_0^1</span>  and  <span class="math">X_b^1</span>  depend on  <span class="math">X_0^0</span> , so that  <span class="math">X_j^1</span>  depends on  <span class="math">X_0^0</span>  if and only if  <span class="math">0 \\le j &lt; \\phi_2</span>  or  <span class="math">b \\le j &lt; b + \\phi_1</span> .</p>

    <p class="text-gray-300">Suppose now that  <span class="math">X_j^i</span>  depends on  <span class="math">X_0^0</span>  if and only if  <span class="math">0 \\le j &lt; \\phi_i</span>  or  <span class="math">b \\le j &lt; b + \\phi_{i-1}</span> . The round function with index i maps  <span class="math">X^i</span>  to  <span class="math">X^{i+1}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} X_{j}^{i+1} = X_{j+b}^{i} \\oplus L_{j-\\phi_{i}}^{i} \\left( X_{j-\\phi_{i}}^{i} \\right) &amp; \\text{if } j &lt; b, \\\\ X_{j}^{i+1} = X_{j-b}^{i} &amp; \\text{if } j \\geq b. \\end{cases}</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\mathbf{j} \\geq \\mathbf{b}</span> , then  <span class="math">X_j^{i+1} = X_{j-b}^i</span>  which, by the induction hypothesis, depends on  <span class="math">X_0^0</span>  if and only if  <span class="math">0 \\leq j-b &lt; \\phi_i</span> , which is equivalent to  <span class="math">b \\leq j &lt; b + \\phi_i</span> . Thus, the lemma holds in this case.</p>

    <p class="text-gray-300">If  <span class="math">\\mathbf{j} &lt; \\mathbf{b}</span> , then  <span class="math">X_j^{i+1}</span>  depends on both  <span class="math">X_{b+j}^i</span>  and  <span class="math">X_{j-\\phi_i}^i</span> . By the induction hypothesis, the first depends on  <span class="math">X_0^0</span>  if and only if  <span class="math">b \\le b+j &lt; b+\\phi_i</span> , which is equivalent to  <span class="math">0 \\le j &lt; \\phi_i</span> . The second depends on  <span class="math">X_0^0</span>  if and only if  <span class="math">0 \\le j - \\phi_i &lt; \\phi_{i+1}</span>  or, equivalently,  <span class="math">\\phi_i \\le j &lt; \\phi_i + \\phi_{i+1} = \\phi_{i+2}</span> . Thus, for any j such that  <span class="math">0 \\le j &lt; \\phi_{i+2}, X_j^{i+1}</span>  depends on  <span class="math">X_0^0</span> . This dependence occurs via  <span class="math">X_{b+j}^i</span>  for  <span class="math">j &lt; \\phi_i</span>  and via  <span class="math">X_{j-\\phi_i}^i</span>  for  <span class="math">\\phi_i \\le j &lt; \\phi_{i+2}</span> . We deduce that the lemma also holds in this case.</p>

    <p class="text-gray-300">The propagation of a word across several rounds is illustrated in Fig. 4 in Appendix A. If we leave the details of the L-Boxes aside, a FFN is invariant under rotation of the halves of the state. This is formalized by the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">R_k</span>  be a permutation of  <span class="math">\\{0,...,2b-1\\}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$R_k(j) = \\begin{cases} (j+k) \\mod b &amp; \\text{if } j &lt; b, \\\\ b + ((j-b+k) \\mod b) &amp; \\text{if } j \\ge b, \\end{cases}</span>$</p>

    <p class="text-gray-300">meaning that applying  <span class="math">R_k</span>  to the index of the branches of FFN rotates separately the left and right branches by k. Let P be one round of FFN where all L-Boxes are the same and let  <span class="math">(y_0, ..., y_{2b-1}) = P(x_0, ..., x_{2b-1})</span> . Then the following always holds:</p>

    <p class="text-gray-300"><span class="math">$P(x_{R_k(0)},...x_{R_k(2b-1)}) = (y_{R_k(0)},...y_{R_k(2b-1)}).</span>$</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3: Influence of  <span class="math">X_0^0</span>  on  <span class="math">X_j^i</span>  for increasing <em>i</em>. The parts of the internal state which depend on  <span class="math">X_0^0</span>  are colored; those which do not are white.</p>

    <p class="text-gray-300"><em>Proof.</em> If the L-boxes are identical, then all operations in a FFN are invariant under a word rotations applied to both halves of the internal state.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">We deduce the following corollary which quantifies the speed of diffusion.</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> Consider a FFN with i rounds, where  <span class="math">\\phi_i \\geq b</span> . Then each left input word  <span class="math">X_j^0</span> , where  <span class="math">0 \\leq j &lt; b</span> , influences all output words  <span class="math">X_j^i</span> , where  <span class="math">0 \\leq j &lt; 2b</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">k \\leq i+1</span>  be such that  <span class="math">\\phi_{k-1} \\leq b &lt; \\phi_k</span> . By Lemma 1, we know that after k-2 rounds,  <span class="math">X_0^0</span>  influences all words with indices j if  <span class="math">0 \\leq j &lt; \\phi_{k-1}</span>  or  <span class="math">b \\leq j &lt; b + \\phi_{k-2}</span> . After round k-1, the words on the left all depend on  <span class="math">X_0^0</span>  and thus, after round  <span class="math">k \\leq i+1</span> , all output words depend on  <span class="math">X_0^0</span> . By Lemma 2, we can generalize this dependency to all input words from the left side. We conclude that, after round k all output words depend on  <span class="math">X_i^0</span>  for all  <span class="math">0 \\leq j &lt; b</span> .</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Consider a FFN with  <span class="math">\\Lambda_{\\phi}(b)+1</span>  rounds labelled  <span class="math">-1,0,1,\\ldots,\\Lambda_{\\phi}(b)-1</span>  and where we set  <span class="math">\\phi_{-1}=0</span> . Then each input words  <span class="math">X_k^{-1}</span> , where  <span class="math">0 \\leq k &lt; 2b</span> , influences all output words  <span class="math">X_j^{\\Lambda_{\\phi}(b)}</span> , where  <span class="math">0 \\leq j &lt; 2b</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> After the initial round, each input word  <span class="math">X_k^{-1}</span>   <span class="math">(0 \\le k &lt; 2b)</span>  influences one left word  <span class="math">X_k^0</span>  (mod b) which in turn (see Corollary 1) influences all output words  <span class="math">X_i^{\\Lambda_{\\phi}(b)}</span> ,  <span class="math">0 \\le j &lt; 2b</span> .</p>

    <p class="text-gray-300"><strong>Efficient Implementation.</strong> In this section, we describe how we can build a linear layer which can be evaluated using  <span class="math">\\mathcal{O}(\\Lambda_{\\phi}(b) \\cdot w)</span>  operations on a modern processor, where  <span class="math">2 \\times b \\times w = n</span> . This linear layer provides full diffusion. Of course, it uses a FFN with 2b branches of w bits each. The core trick is in the definition and implementation of the L-Box layer composed with the rotation by  <span class="math">\\phi_i</span> .</p>

    <p class="text-gray-300">Instead of using table lookups to implement the linear layer, we can use some sort of in-place bit-sliced strategy for small branch sizes<sup>6</sup>, as follows. Let x be the</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup> For larger branch sizes, e.g.  <span class="math">w \\geq 32</span>  we can fall back on optimized matrix-vector multiplication algorithms and the branch rotation can simply be performed by index arithmetic in arrays storing the state.</p>

    <p class="text-gray-300">bw-bit input of F<sup>i</sup> where F<sup>i</sup> consists in a layer of w-bit L-Boxes and a rotation by &phi;<sup>i</sup> . Then we can write</p>

    <p class="text-gray-300"><span class="math">$F_i = M^{-1} \\circ \\mathrm{ROT}_{\\phi_i} \\circ \\mathcal{L}_i \\circ M</span>$
, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M maps the w-bit word with index j to the bits with indices congruent to j modulo b. More formally, M is a bit permutation which maps x0, ...xbw&minus;<sup>1</sup> to x0, xb, x2b, ...x(w&minus;1)<sup>b</sup> , x1, xb+1..., xbw&minus;1, i.e. each bit of the first w-bit word end up at positions k &equiv; 0 (mod b), the bits of the second w-bit word at positions k &equiv; 1 (mod b), etc.</li>
      <li>L<sup>i</sup> is parametrized by w words of size bw denoted \` i j . It maps a bw-bit word y to a value equal to</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathcal{L}_i(y) = \\bigoplus_{j=0}^{w-1} \\ell_j^i \\wedge (y \\lll (j \\cdot b)).</span>$</p>

    <p class="text-gray-300">Thus, the output bit of L<sup>i</sup> with index k is a linear combination of w variables yk, yb+k, y2b+k, ..., y(w&minus;1)b+k. The w output variables with indices k &equiv; a (mod b) depend only on the w input variables with indices k &equiv; a (mod b): Li is effectively an L-Box layer except that it operates on slices of the state defined by k (mod b) rather than bk/bc.</p>

    <p class="text-gray-300">Basically, M changes the representation of the words and L<sup>i</sup> evaluates the L-Box layer on this alternative representation. In fact, we can simplify the functions M in each round by applying M to each half of the input of the whole FFN and M<sup>&minus;</sup><sup>1</sup> to each half of its output. If the only aim is full diffusion, we can simply remove them.</p>

    <p class="text-gray-300">In the end, evaluating a linear FFN with full diffusion on 2b branches with w-bit words requires &Lambda;&phi;(b) + 1 rounds, each of which requires</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>w rotations by &phi;<sup>i</sup> + b &middot; k for all k &isin; {0, ..., w &minus; 1} applied word-wide on a bw-bit word,</li>
      <li>w ANDs applied word-wide on a bw-bit word, and</li>
      <li>w XORs applied word-wide on a bw-bit word to combine the \` i <sup>j</sup> &and; (x &#8810; bk + &phi;i) with the other branch.</li>
    </ul>

    <p class="text-gray-300">Now let us consider a 256-bit linear layer of LowMC. For n = 256 = 2 &times; 32 &times; 4, we can implement a bijective linear layer with full diffusion using 1+&Lambda;&phi;(32) = 10 rounds by composing a 9-round FFN with another round before it. The role of this first round is to ensure that the left input of the FFN depends on both the left and right words of the input of the structure. In this way, at the end of the FFN, all output words depend on all input words. The rotation used in this first round can be chosen freely. Evaluating such a linear layer requires 10 rounds during which we perform:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">4 copies of the left 128-bit half into 4 different 128-bit words;</p></li>
      <li><p class="text-gray-300">a rotation of each of these four 128-bit words by the following number of bits: &phi;i&minus;1, 32 + &phi;i&minus;1, 64 + &phi;i&minus;1, 96 + &phi;i&minus;1; where we set &phi;<sup>&minus;</sup><sup>1</sup> = 16 and where &phi;<sup>i</sup> for i &ge; 0 is the usual Fibonacci sequence;</p></li>
      <li><p class="text-gray-300">a AND of each of these four 128-bit words by 128-bit values derived from the expression of  <span class="math">L_i^i</span> ;</p></li>
      <li><p class="text-gray-300">a XOR of each of these four 128-bit words into the right half of the internal state; and</p></li>
      <li><p class="text-gray-300">a swap of the left and right words.</p></li>
    </ul>

    <p class="text-gray-300">In total, we need 40 copies, 40 rotations, 40 XORs, 40 ANDs, and 10 swaps where all operations are on 128-bit words. An example of  <span class="math">256 \\times 256</span>  binary matrix which can be implemented in this fashion is provided in Appendix B.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Performance and Memory Evaluation</h2>

    <p class="text-gray-300">To verify the expected performance and memory improvements, both suggested optimizations were implemented and evaluated. Both optimizations were compared against the Picnic implementation available on GitHub<sup>7</sup>.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Reduced Round Key Computation and Constant Addition</h3>

    <p class="text-gray-300">We start with the evaluation of the reduced round key computation and constant addition introduced in Section 3.1. The matrix and vector pre-computations were implemented on top of the LowMC reference implementation<sup>8</sup>. We performed the benchmarks on an Intel Core i7-4790 running Ubuntu 17.04 and Raspberry Pi 3 Model B running openSUSE Leap 42.2. All measurements were repeated 1000 times and then averaged, and are presented both as milliseconds and number of cycles. We only benchmarked the Fiat-Shamir transformed variant of PICNIC, since the Unruh transformed variant does not perform any additional rounds of the proof system. Hence improvements to LowMC encryption apply to PICNIC-FS and PICNIC-UR in the same way. For the benchmarks we use the instances listed in Table 3 and denote as PICNIC-n the instance for block size n benchmarked for PICNIC-FS.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Blocksize (n)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-boxes <span class="math">(m)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Keysize <span class="math">(k)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds <span class="math">(r)</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: LowMC parameters (data complexity d = 1) in Picnic [CDG<sup>+</sup>17b].</p>

    <p class="text-gray-300">From the benchmarking results presented in Table 4, we can observe small improvements with a factor of 1.1x for the 128-bit case and up to a factor of 1.8x for larger instances. The results on the Raspberry Pi 3 are presented in</p>

    <p class="text-gray-300"><sup>7</sup> https://github.com/IAIK/Picnic</p>

    <p class="text-gray-300"><sup>8</sup> https://github.com/LowMC/lowmc</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">w/o</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">opt.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">with 1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">RRKC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Improv.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(old / new)<br>Verify</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Parameters</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sign</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sign</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sign</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PICNIC-128<br>PICNIC-192<br>PICNIC-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.95</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.11x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.09x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Picnic-192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.84</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.78</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.54x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.56x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Picnic-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.71</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.79x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.80x</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Benchmarks without and with RRKC on Intel Core i7 (in ms).</p>

    <p class="text-gray-300">Table 5 and show an even larger improvement of factors 1.6 to 2 for signing and verifying with all instances. We also note that the numbers without the split round key also show improvements over the numbers published in [CDG<sup>+</sup>17a]. Those improvements are obtained via general memory usage optimizations and a more specialized optimization focusing only on the case with 10 S-boxes.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">w/o</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">opt.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">with</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">RRKC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Improv. (old / new)<br>  Sign Verify</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Parameters</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sign</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sign</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sign</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verify</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PICNIC-128<br>PICNIC-192<br>PICNIC-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.08</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.65x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.63x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Picnic-192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72.05</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48.06</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39.94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.89</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.80x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.79x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Picnic-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">172.86</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115.42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84.27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56.45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.05x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.04x</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5: Benchmarks without and with RRKC on Raspberry Pi 3 (in ms).</p>

    <p class="text-gray-300">To give one concrete example for the memory savings discussed in Section 3.1, we calculate the memory requirements for parameter set PICNIC-256. For the round key calculations the general LowMC algorithm requires 38+1 matrices of dimension  <span class="math">256\\times256</span> , which correspond to 312 KB. LowMC with the split round key computation only uses one  <span class="math">256\\times256</span> , and one  <span class="math">1140\\times256</span>  matrix. The 38 256-bit round contstants, which consume 1.2 KB, are replaced with one 256-bit vector and one 1140-bit vector, which consume 0.17 KB. Hence, in the parameter set PICNIC-256 we achieve a reduction of the memory cost from 313.19 KB for the round key matrices and round constants to 43.8 KB. Thus RRKC reduced the storage requirements for rounds matrices and constants by more than 85 %. Taking the linear layer into account as well, we still save 43 % of the memory. Therefore, we can conclude that our alternative description provides both a significant performance boost and also saves a large amount of memory required to represent LowMC.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Reduced Linear Layer</h3>

    <p class="text-gray-300">Next we implemented the reduced linear layer introduced in Section 3.2. In Table 6 we present the numbers obtained from benchmarking all variants without any hardware specific optimizations. When comparing an implementation without any of the optimizations to an implementation with RLL, performance is</p>

    <p class="text-gray-300">improved by up to a factor of 4 with the instances used in Picnic. Also compared to RRKC, RLL improves the runtime performance significantly (up to a factor of 3).</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Parameters</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">w/o<br>Sign</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">opt.<br>Verify</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">with Sign</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">RRKC<br>Verify</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">with<br>Sign</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">RLL<br>Verify</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Improv<br>Sign</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">. (old / new)<br>Verify</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PICNIC-128<br>PICNIC-192<br>PICNIC-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&middot;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&middot;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&middot;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.26x<br>3.41x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PICNIC-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94.43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">67.48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">71.07</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38.97</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22.70</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.16x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.91x</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6: Benchmarks without optimizations, with RRKC, and RLL on Intel Core i7 (in ms).</p>

    <p class="text-gray-300">Even better results can be obtained when selecting LowMC instances with m=1. In Table 7 we present benchmarking results for encryption of LowMC instances selected for the signature scheme use-case, i.e. with data complexity 1, and m=1, as well as the instances used in Picnic with m=10. While RRKC already reduces runtime of a single encryption to a half, which we would also obtain by pre-computing the round keys, RLL further reduces the runtime for m=1 to  <span class="math">\\frac{1}{12}</span>  and  <span class="math">\\frac{1}{25}</span> , respectively, of the original runtime. With these performance improvements, choosing instances enabling the smallest possible signature sizes no longer comes with a significant performance penalty as conclued in [CDG+17a]. When viewed relative to RRKC and round key pre-computation, RLL reduces the runtime to around  <span class="math">\\frac{1}{6}</span>  and  <span class="math">\\frac{1}{13}</span> , respectively. The performance improvements for m=10 are mostly consistent with those in Table 6.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">w/o opt.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">with RRKC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">with RLL</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Improv. (old / new)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-128-128-1-182</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48.95</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.58x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-128-128-10-20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.97</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.16x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-192-192-1-284<br>LowMC-192-192-10-30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">194.73<br>21.61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.46<br>8.23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.62x<br>4.55x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-256-256-1-363</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">216.98</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.31x</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-256-256-10-38</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.02x</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 7: Benchmarks of LowMC-n-k-m-r instances without optimization, with RRKC, and RLL on Intel Core i7 (in  <span class="math">\\mu</span> s).</p>

    <p class="text-gray-300">Memory-wise we observe the same memory savings for RLL as for RRKC. For example, for Picnic-256 the liner layer shrinks from 304 KB to 37.69 KB by 87 %. For instances with m=1 the savings are even better. For the 256-bit instance from Table 7 the size of the linear layer is reduced from 2904 KB to 41.45 KB, so the matrices of the linear layer can be presented using only 2 % of their</p>

    <p class="text-gray-300">original size. In practice, the effect of this optimization has some diminishing returns when we have to perform operations that are not optimized for register sizes in modern CPUs, so we do not achieve the full theoretical speedup.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Fibonacci Feistel Network</h3>

    <p class="text-gray-300">We also implemented the proposed Feistel network from Section <a href="#page-11-1">3.3</a> and benchmarked it against an implementation of a constant-time matrix multiplication available used by Picnic. All measurements were repeated 1000000 times and averaged. Performance and memory consumption of a 256-bit block size Feistel network and different branch sizes are shown in Table <a href="#page-19-0">8.</a> The constant-time implementation requires 2302 cycles for a 256 &times; 256 matrix-vector multiplication. As Table <a href="#page-19-0">8</a> shows, the Feistel network performs 10 % better than the constanttime implementation if 64 bit branches are used. The constant-time algorithm consumes of 8192 bytes because to store the whole 256 &times; 256 matrix, while the FFN with 64 bit branches only uses 37 % less memory because the 256 &times; 256 matrix is represented by the 64 &times; 64 matrices. It is also possible to reduce the memory requirements even further if a weaker performance is acceptable.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Instance</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Performance</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">w bits Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Cycles Memory (bytes)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times; 32&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4463</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">640</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times; 16&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3224</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1152</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8&times; 16 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2430</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4&times; 32 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3231</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3072</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times; 64 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2047</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 8: FFN instances for n = 256 bits benchmarked on Intel Core i7.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Discussion</h2>

    <p class="text-gray-300">The results we presented in Section <a href="#page-16-3">4</a> let us presume that all three optimizations yield even better results for larger block sizes, e.g. larger instances as used by LowMCHash-256 <a href="#page-21-2">[AGR</a><sup>+</sup>16], which find its application in post-quantum ring signature schemes <a href="#page-22-7">[DRS18]</a>. We note that for RRKC and RLL the number of S-boxes is essential for the performance gain. If the number of S-boxes remains constant, but the block size is increased, removing the multiplication of the round key matrix by the secret key and reducing the cost of the linear layer has a higher impact than if the number of S-boxes increased proportionally. The smaller the number of S-boxes is relative to the block size, the higher the expected performance gains are. If 3 &middot; m is almost as large as n, then we expect no performance gain, because the modified matrices are almost as big as the original round key and linear layer matrices and therefore the multiplication is not much faster than implemetning an unmodified LowMC encryption.</p>

    <p class="text-gray-300">Also, the proposed Feistel network will result in even higher performance gains if the block size is increased. Table <a href="#page-20-0">9</a> shows the number of XOR operations in the Feistel network and in a constant-time multiplication for increasing block sizes. While the cost for the constant-time multiplication quadruples if the block size doubles, the Feistel network less than triples the cost for doubled block sizes. Additionally, the larger the block size the slower the cost grows with the Fibonacci structure.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Instance</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># XORs</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = 2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">w bits Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FFN ct. mul.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256 = 2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&times; 64 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">640</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,024</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512 = 2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4&times; 64 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4,096</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024 = 2&times;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8&times; 64 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4,096</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16,384</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048 = 2&times; 16&times; 64 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9,216</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65,536</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4096 = 2&times; 32&times; 64 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20,480</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">262,144</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 9: Number of XOR operations using FFN with 64-bit branches and constant-time multiplication for different block sizes.</p>

    <p class="text-gray-300">From an implementation point of view the branch size for very large block sizes, e.g. 1024 bit or more, can be extended to 128-bit, 256-bit or even 512 bit using the SSE2 and NEON, AVX2 and AVX512, respectively, instruction sets. This can be an interesting approach for very large block sizes, because the number of branches and rounds can be reduced, which in turn allows to reduce the number of rounds in the FFN. Additionally, the implementation of the FFN is inherently constant-time without any dependencies on possibly secret state.</p>

    <p class="text-gray-300">While LowMC is currently specified to use uniformly randomly sampled matrices, the cryptanalysis suggests that the involved matrices need to provide full diffusion <a href="#page-21-0">[ARS</a>+15, <a href="#page-21-4">ARS</a>+16]. By replacing these matrices with a FFN providing full diffusion, we can significantly reduce the costs to store the matrices in memory and can also reduce the number of XORs. The analysis of FFNs presented in Section <a href="#page-11-1">3.3</a> first of all gives a lower bound on the required number of rounds to achieve full diffusion and secondly, the performance evaluation shows that there is room for additional rounds if necessary.</p>

    <p class="text-gray-300">Both our main contributions (improved implementation of random linear layers and investigation of potential uses of structured replacements like FFN) will likely also be useful for other cipher designs which heavily rely on large linear layers such as the very recently proposed Rasta <a href="#page-22-10">[DEG</a><sup>+</sup>18].</p>

    <p class="text-gray-300">Acknowledgments. We thank Tyge Tiessen for interesting ideas and discussions on optimizing LowMC's round key computation. We also thank Christoph Dobraunig, Maria Eichlseder and Eik List for comments on earlier version. S. Ramacher, and C. Rechberger have been supported by H2020 project Prismacloud, grant agreement n&#9702;644962. C. Rechberger has additionally been supported by EU H2020 project PQCRYPTO, grant agreement n&#9702;645622.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">ADKF70. V. Arlazarov, E. Dinic, M. Kronrod, and I. Faradzev. On economical construction of the transitive closure of a directed graph. Soviet Math Dokl., 1970.</p></li>
      <li><p class="text-gray-300">AGR<sup>+</sup>16. Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In ASIACRYPT (1), volume 10031 of Lecture Notes in Computer Science, pages 191&ndash;219, 2016.</p></li>
      <li><p class="text-gray-300">AL00. Kazumaro Aoki and Helger Lipmaa. Fast implementations of AES candidates. In AES Candidate Conference, pages 106&ndash;120, 2000.</p></li>
      <li><p class="text-gray-300">ARS<sup>+</sup>15. Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In EURO-CRYPT (1), volume 9056 of Lecture Notes in Computer Science, pages 430&ndash;454. Springer, 2015.</p></li>
      <li><p class="text-gray-300">ARS<sup>+</sup>16. Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. IACR Cryptology ePrint Archive, 2016:687, 2016.</p></li>
      <li><p class="text-gray-300">Bar06. Gregory V. Bard. Accelerating cryptanalysis with the method of four russians. IACR Cryptology ePrint Archive, 2006:251, 2006.</p></li>
      <li><p class="text-gray-300">BB02. Elad Barkan and Eli Biham. In how many ways can you write rijndael? In ASIACRYPT, volume 2501 of Lecture Notes in Computer Science, pages 160&ndash;175. Springer, 2002.</p></li>
      <li><p class="text-gray-300">BBF<sup>+</sup>02. Guido Bertoni, Luca Breveglieri, Pasqualina Fragneto, Marco Macchetti, and Stefano Marchesin. Efficient software implementation of AES on 32-bit platforms. In CHES, volume 2523 of Lecture Notes in Computer Science, pages 159&ndash;171. Springer, 2002.</p></li>
      <li><p class="text-gray-300">BEF18. Dan Boneh, Saba Eskandarian, and Ben Fisch. Post-quantum group signatures from symmetric primitives. IACR Cryptology ePrint Archive, 2018:261, 2018.</p></li>
      <li><p class="text-gray-300">Ber09. Daniel J. Bernstein. Optimizing linear maps modulo 2. 2009. <a href="https://binary.cr.yp.to/linearmod2.html" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://binary.cr.yp.to/linearmod2.html" target="_blank" rel="noopener noreferrer">//binary.cr.yp.to/linearmod2.html</a>.</p></li>
      <li><p class="text-gray-300">BS08. Daniel J. Bernstein and Peter Schwabe. New AES software speed records. In INDOCRYPT, volume 5365 of Lecture Notes in Computer Science, pages 322&ndash;336. Springer, 2008.</p></li>
      <li><p class="text-gray-300">CCF<sup>+</sup>16. Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancr\`ede Lepoint, Mar&acute;&#305;a Naya-Plasencia, Pascal Paillier, and Renaud Sirdey. Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression. In FSE, volume 9783 of Lecture Notes in Computer Science, pages 313&ndash;333. Springer, 2016.</p></li>
      <li><p class="text-gray-300">CDG<sup>+</sup>17a. Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In CCS, pages 1825&ndash;1842. ACM, 2017.</p></li>
      <li><p class="text-gray-300">CDG<sup>+</sup>17b. Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. The Picnic Signature Algorithm Specification, 2017. <a href="https://github.com/Microsoft/Picnic/blob/master/spec.pdf" target="_blank" rel="noopener noreferrer">https://github.com/</a> <a href="https://github.com/Microsoft/Picnic/blob/master/spec.pdf" target="_blank" rel="noopener noreferrer">Microsoft/Picnic/blob/master/spec.pdf</a>.</p></li>
      <li><p class="text-gray-300">DEG<sup>+</sup>18. Christoph Dobraunig, Maria Eichlseder, Lorenzo Grassi, Virginie Lallemand, Gregor Leander, Eik List, Florian Mendel, and Christian Rechberger. Rasta: A cipher with low anddepth and few ands per bit. In CRYPTO (1), volume 10991 of Lecture Notes in Computer Science, pages 662&ndash;692. Springer, 2018.</p></li>
      <li><p class="text-gray-300">Din18. Itai Dinur. Linear equivalence of block ciphers with partial non-linear layers: Application to lowmc. Cryptology ePrint Archive, Report 2018/772, 2018. <a href="https://eprint.iacr.org/2018/772" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2018/772</a>.</p></li>
      <li><p class="text-gray-300">DPVR00. Joan Daemen, Micha&uml;el Peeters, Gilles Van Assche, and Vincent Rijmen. Nessie Proposal: NOEKEON, 2000. <a href="http://gro.noekeon.org/Noekeon-spec.pdf" target="_blank" rel="noopener noreferrer">http://gro.noekeon.org/</a> <a href="http://gro.noekeon.org/Noekeon-spec.pdf" target="_blank" rel="noopener noreferrer">Noekeon-spec.pdf</a>.</p></li>
      <li><p class="text-gray-300">DRS18. David Derler, Sebastian Ramacher, and Daniel Slamanig. Post-quantum zero-knowledge proofs for accumulators with applications to ring signatures from symmetric-key primitives. In PQCrypto, volume 10786 of Lecture Notes in Computer Science, pages 419&ndash;440. Springer, 2018.</p></li>
      <li><p class="text-gray-300">DSES14. Yarkin Dor&uml;oz, Aria Shahverdi, Thomas Eisenbarth, and Berk Sunar. Toward practical homomorphic evaluation of block ciphers using prince. In Financial Cryptography Workshops, volume 8438 of Lecture Notes in Computer Science, pages 208&ndash;220. Springer, 2014.</p></li>
      <li><p class="text-gray-300">GLSV14. Vincent Grosso, Ga&uml;etan Leurent, Fran&cedil;cois-Xavier Standaert, and Kerem Varici. Ls-designs: Bitslice encryption for efficient masked software implementations. In FSE, volume 8540 of Lecture Notes in Computer Science, pages 18&ndash;37. Springer, 2014.</p></li>
      <li><p class="text-gray-300">GMO16. Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster zeroknowledge for boolean circuits. In USENIX Security Symposium, pages 1069&ndash;1083. USENIX Association, 2016.</p></li>
      <li><p class="text-gray-300">GRR<sup>+</sup>16. Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, and Nigel P. Smart. Mpc-friendly symmetric key primitives. In ACM Conference on Computer and Communications Security, pages 430&ndash;443. ACM, 2016.</p></li>
      <li><p class="text-gray-300">IKOS07. Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zeroknowledge from secure multiparty computation. In STOC, pages 21&ndash;30. ACM, 2007.</p></li>
      <li><p class="text-gray-300">MJSC16. Pierrick M&acute;eaux, Anthony Journault, Fran&cedil;cois-Xavier Standaert, and Claude Carlet. Towards stream ciphers for efficient FHE with low-noise ciphertexts. In EUROCRYPT (1), volume 9665 of Lecture Notes in Computer Science, pages 311&ndash;343. Springer, 2016.</p></li>
      <li><p class="text-gray-300">NLV11. Michael Naehrig, Kristin E. Lauter, and Vinod Vaikuntanathan. Can homomorphic encryption be practical? In CCSW, pages 113&ndash;124. ACM, 2011.</p></li>
      <li><p class="text-gray-300">NPV17. Val&acute;erie Nachef, Jacques Patarin, and Emmanuel Volte. Feistel Ciphers - Security Proofs and Cryptanalysis. Springer, 2017.</p></li>
      <li><p class="text-gray-300">RSS17. Dragos Rotaru, Nigel P. Smart, and Martijn Stam. Modes of operation suitable for computing on encrypted data. IACR Trans. Symmetric Cryptol., 2017(3):294&ndash;324, 2017.</p></li>
      <li><p class="text-gray-300">SM10. Tomoyasu Suzaki and Kazuhiko Minematsu. Improving the generalized feistel. In FSE, volume 6147 of Lecture Notes in Computer Science, pages 19&ndash;39. Springer, 2010.</p></li>
      <li><p class="text-gray-300">SME16. Shady Mohamed Soliman, Baher Magdy, and Mohamed A. Abd El-Ghany. Efficient implementation of the AES algorithm for security applications. In SoCC, pages 206&ndash;210. IEEE, 2016.</p></li>
      <li><p class="text-gray-300">SMMK12. Tomoyasu Suzaki, Kazuhiko Minematsu, Sumio Morioka, and Eita Kobayashi. twine: A lightweight block cipher for multiple platforms. In Selected Areas in Cryptography, volume 7707 of Lecture Notes in Computer Science, pages 339&ndash;354. Springer, 2012.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A An Example of Fibonacci-Feistel Network</h2>

    <p class="text-gray-300">Fig. <a href="#page-24-0">4</a> depicts the propagation of the left-most bit through a 6 round FFN structure.</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Example of Binary Matrices Corresponding to a FFN</h2>

    <p class="text-gray-300">The matrix presented in Fig. <a href="#page-25-0">5</a> has the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>It has full rank.</li>
      <li>33585 &asymp; 0.51 &times; 2 <sup>16</sup> of its coefficients are equal to 1.</li>
      <li>It can be evaluated using a 10-round FFN with 32 independent and random 4-bit linear permutations used as L-boxes in each round. A new L-box layer is used for each round.</li>
    </ul>

    <p class="text-gray-300">Its inverse has similar properties and is also depicted in Fig. <a href="#page-25-0">5.</a></p>

    <p class="text-gray-300">    <img src="_page_24_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4: 6 rounds of the FFN structure for b = 8. The rectangles correspond to distinct L-Box calls. A branch is red if its value depends on the left-most word of the input.</p>

    <p class="text-gray-300">    <img src="_page_25_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5: A matrix M and its inverse M<sup>&minus;</sup><sup>1</sup> corresponding to a 10-round 256-bit FFN with b = 32, w = 4. Black means 1, white means 0.</p>

    </section>
`;
---

<BaseLayout title="Improvements to the Linear Operations of LowMC: A Faster Pic... (2017/1148)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/1148
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Contribution</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">LowMC</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">(2,3)-Decomposition of Circuits in Picnic</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Optimizing Linear Operations</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Splitting the Round Key Computation and Round Constant Addition</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Reducing Linear Layer Computation</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Fibonacci Feistel Network</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Performance and Memory Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Reduced Round Key Computation and Constant Addition</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Reduced Linear Layer</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Fibonacci Feistel Network</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Discussion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">An Example of Fibonacci-Feistel Network</a></li>
        <li><a href="#app-b" class="hover:text-white">Example of Binary Matrices Corresponding to a FFN</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="3-1-splitting-the-round-key-computation-and-round-constant-2017" />
  </article>
</BaseLayout>
