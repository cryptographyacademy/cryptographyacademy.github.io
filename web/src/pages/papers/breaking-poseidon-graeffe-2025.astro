---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/950';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="Breaking Poseidon Challenges with Graeffe Transforms (2025/950)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Breaking Poseidon Challenges with Graeffe Transforms and
        Complexity Analysis by FFT Lower Bounds
      </h1>
      <p class="text-gray-400 mb-2">
        Ziyu Zhao, Jintai Ding
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; Full Version &middot; eprint 2025/950
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">Notations</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                The Poseidon Permutation and the CICO Problem</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                Skip First Rounds Trick</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            Root Finding for Univariate Polynomials</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">GCD-Based Methods</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Root Finding via Graeffe Transform</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Implementation and Security Estimation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Implementation Details</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">Security Estimation</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            Memory Access Lower Bounds for FFT</a>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Conclusions</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        Poseidon and Poseidon2 are cryptographic hash functions designed
        for efficient zero-knowledge proof protocols and have been widely
        adopted in Ethereum applications. To encourage security research,
        the Ethereum Foundation announced a bounty program in November
        2024 for breaking the Poseidon challenges, i.e. solving the CICO
        (Constrained Input, Constrained Output) problems for
        round-reduced Poseidon constructions. In this paper, we explain
        how to apply the Graeffe transform to univariate polynomial
        solving, enabling efficient interpolation attacks against
        Poseidon. We will provide an open-source code and details our
        approach for solving several challenges valued at $20000 in
        total. Compared to existing attacks, we improve
        <span class="math">2^&#123;13&#125;</span> and
        <span class="math">2^&#123;4.5&#125;</span> times in wall time
        and memory usage, respectively. For all challenges we solved, the
        cost of memory access turns out to be an essential barrier, which
        makes the security margin much larger than expected. We actually
        prove that the memory access cost for FFT grows as the
        <span class="math">4/3</span>-power of the input size, up to a
        logarithmic factor. This indicates the commonly used pseudolinear
        estimate may be overly conservative. This is very different from
        multivariate equation solving whose main bottleneck is linear
        algebra over finite fields. Thus, it might be preferable to
        choose parameters such that the best known attack is
        interpolation, as it presents more inherent hardness.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> Poseidon, Graeffe transform,
        interpolation attack, root finding, FFT lower bounds,
        zero-knowledge proofs
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>

      <p class="text-gray-300">
        Cryptographic hash functions are fundamental to modern
        cryptography. With the rise of advanced applications such as
        zero-knowledge proofs, especially STARK protocols [BBHR19], there is a
        growing demand for hash functions that are efficient not only on
        conventional hardware but also when represented as arithmetic
        circuits over large prime fields. While general designs like
        SHA-2 and SHA-3 are highly optimized for modern CPUs, they cannot
        be represented as small arithmetic circuits, which essentially
        becomes a bottleneck for the performance of proof systems. As a
        result, several new so-called STARK-friendly or
        arithmetization-oriented constructions have been proposed,
        including Rescue-Prime [SAD20,AKM+22], Feistel-MiMC [AGR+16], Poseidon [GKR+21],
        and Reinforced Concrete [GKL+22]. Among these, Poseidon and its
        successor Poseidon2 [GKS23] have emerged as top performers in recent
        STARK benchmarks by StarkNet, making them promising candidates
        for use in Ethereum and other applications that require efficient
        and verifiable computation.
      </p>

      <p class="text-gray-300">
        However, unlike classic hash functions such as SHA-2 and SHA-3,
        which have been thoroughly analyzed over decades, these
        STARK-friendly constructions are relatively recent and lack
        extensive cryptanalysis. Their security cannot be directly
        inferred from traditional designs. The best known attacks are
        also quite different: instead of relying on differential path
        search, they often exploit the algebraic structure of these hash
        functions.
      </p>

      <p class="text-gray-300">
        The participants in the Ethereum Foundation&rsquo;s bounty
        program are required to solve the CICO (Constrained Input,
        Constrained Output) problems for the inner sponge permutation
        (denoted by Perm) under different Poseidon parameterizations. The
        CICO problem asks for input and output pairs such that the last
        several elements in both are zero. For example, Poseidon-64 asks
        for
        <span class="math">X_0, \ldots, X_6, Y_0, \ldots, Y_6</span>
        such that
        <span class="math">\mathsf&#123;Perm&#125;(X_0, \ldots, X_6, 0) = (Y_0, \ldots, Y_6, 0)</span>.
      </p>

      <p class="text-gray-300">
        Currently, the most effective attack against Poseidon is the
        interpolation attack [JK97]. The interpolation attack first fixes
        <span class="math">X_1, \ldots, X_6</span> to random values.
        Then, the mapping from
        <span class="math">X_0</span> to the last coordinate of
        <span class="math">\mathsf&#123;Perm&#125;(X_0, \ldots, X_6, 0)</span>
        becomes a univariate polynomial. In practice, these univariate
        polynomials typically have roots with high probability, so
        solutions to the CICO problem can be found by univariate
        polynomial root finding.
      </p>

      <p class="text-gray-300">
        <strong>The Graeffe Transform.</strong> Historically, the Graeffe
        transform dates back to the 1820s&ndash;1830s, with independent
        contributions from Dandelin, Lobachevsky, and Gr&auml;ffe [Hou59].
        It was originally designed for finding roots of real polynomials
        by mapping each root to its square, effectively spreading the
        roots apart and making them easier to find numerically.
      </p>

      <p class="text-gray-300">
        Suppose <span class="math">f(x)</span> is a degree-<span
        class="math">d</span> polynomial with roots
        <span class="math">r_1, \ldots, r_d \in \mathbb&#123;R&#125;</span>,
        ordered so that
        <span class="math">|r_0| &gt; |r_1| &gt; \cdots &gt; |r_&#123;d-1&#125;|</span>.
        The Graeffe transform of <span class="math">f(x)</span>,
        denoted by
        <span class="math">\mathsf&#123;GT&#125;_2(f)</span>, is
        defined such that
      </p>
      <div class="math-block">
        (\mathsf&#123;GT&#125;_2(f))(x^2) = f(x)f(-x).
      </div>

      <p class="text-gray-300">
        This construction yields a new polynomial whose roots are exactly
        <span class="math">r_0^2, r_1^2, \ldots, r_&#123;d-1&#125;^2</span>.
        By applying the Graeffe transform
        <span class="math">v</span> times, one obtains a polynomial
        whose roots are
        <span class="math">r_0^&#123;2^v&#125; \gg r_1^&#123;2^v&#125; \gg \cdots \gg r_&#123;d-1&#125;^&#123;2^v&#125;</span>.
        By Vieta&rsquo;s formulas, the coefficients approximately yield
        the original roots.
      </p>

      <p class="text-gray-300">
        <strong>Contribution.</strong> This work improves the most
        time-consuming root finding step of the interpolation attack by
        using the Graeffe transform. Suppose
        <span class="math">\omega_\ell</span> is a primitive
        <span class="math">\ell</span>-th root of unity in the
        underlying field. Given a polynomial
        <span class="math">f</span>, the Graeffe transform
        <span class="math">\mathsf&#123;GT&#125;_\ell</span> computes a
        new polynomial
        <span class="math">g = \mathsf&#123;GT&#125;_\ell(f)</span>
        such that
        <span class="math">g(x^\ell) = f(x)f(x\omega_\ell^1) \cdots f(x\omega_\ell^&#123;\ell-1&#125;)</span>.
        If <span class="math">f</span> has a root
        <span class="math">x_0 \in \mathbb&#123;F&#125;_p</span> and
        <span class="math">\ell</span> divides
        <span class="math">|\mathbb&#123;F&#125;_p^\times|</span>,
        then <span class="math">x_0^\ell</span> will be a root of
        <span class="math">g</span> which lies in a subgroup of
        <span class="math">\mathbb&#123;F&#125;_p^\times</span> of size
        <span class="math">(p-1)/\ell</span>. By taking a large enough
        <span class="math">\ell</span>,
        <span class="math">x_0^\ell</span> can be found easily by
        enumeration, from which we can recover
        <span class="math">x_0</span>.
      </p>

      <p class="text-gray-300">
        Compared to the previous record in [BBLP22], the implementation is
        about <span class="math">2^&#123;13&#125;</span> times faster in
        wall time and uses
        <span class="math">2^&#123;4.5&#125;</span> times less memory.
        With this, the authors were able to solve the previously unsolved
        24-bit, 28-bit, and 32-bit Poseidon-64 challenges, corresponding
        to polynomials of degree
        <span class="math">7^&#123;12&#125;</span>,
        <span class="math">7^&#123;13&#125;</span>, and
        <span class="math">7^&#123;15&#125;</span>, respectively.
      </p>

      <p class="text-gray-300">
        <strong>Roadmap.</strong> Section 2 reviews background on the
        Poseidon permutation and introduces the Skip First Rounds Trick.
        Section 3 details the Graeffe transform and its application to
        univariate polynomial root finding. Section 4 describes the
        implementation and presents performance results, including a
        discussion on security. Section 5 proves an asymptotic lower
        bound for the memory access cost during FFT. Section 6 concludes.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Notations
      </h3>
      <p class="text-gray-300">
        All indices start from 0. Bold uppercase letters denote matrices,
        while bold lowercase letters denote vectors. The
        <span class="math">i</span>-th entry of a vector
        <span class="math">\mathbf&#123;v&#125;</span> is written as
        <span class="math">v_i</span>, and the
        <span class="math">(i, j)</span>-th position of a matrix
        <span class="math">\mathbf&#123;M&#125;</span> is
        <span class="math">\mathbf&#123;M&#125;_&#123;i,j&#125;</span>.
        We denote by
        <span class="math">\mathbb&#123;F&#125;_p</span> the prime
        field with <span class="math">p</span> elements, and by
        <span class="math">\mathbb&#123;F&#125;_p^\times</span> its
        multiplicative group. When the underlying field is clear, we
        denote the cost of multiplying two degree-<span
        class="math">d</span> polynomials by
        <span class="math">\mathsf&#123;M&#125;(d)</span>.
      </p>

      <p class="text-gray-300">
        Throughout the paper, the following primes are used:
      </p>
      <div class="math-block">
        p_&#123;64&#125; = \texttt&#123;0xffffffff00000001&#125;
      </div>
      <div class="math-block">
        p_&#123;255&#125; = \texttt&#123;0x73eda753299d7d483339d80809a1d80553bda402fffe5bfefffffff00000001&#125;
      </div>
      <p class="text-gray-300">
        to denote the Goldilocks prime and BLS12-381, respectively.
      </p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 The Poseidon Permutation and the CICO Problem
      </h3>
      <p class="text-gray-300">
        The Poseidon2 sponge permutation is based on the HADES [GLR+20]
        design strategy. After the input
        <span class="math">(x_0, \ldots, x_&#123;t-1&#125;) \in \mathbb&#123;F&#125;_p^t</span>
        is transformed by the matrix
        <span class="math">\mathbf&#123;M&#125;_&#123;\mathcal&#123;E&#125;&#125;</span>,
        the permutation proceeds by applying
        <span class="math">R_F/2</span> full rounds,
        <span class="math">R_P</span> partial rounds, and then another
        <span class="math">R_F/2</span> full rounds. Each RC gate
        represents the addition of a round constant. The S-box
        <span class="math">S</span> is the power map
        <span class="math">x \mapsto x^\alpha</span>, where
        <span class="math">\alpha</span> is chosen as the smallest
        integer greater than 1 such that the S-box is invertible.
        During the partial rounds, the S-box and RC gates only apply to
        the first state.
      </p>

      <p class="text-gray-300">
        For the Poseidon-64 challenges, the linear transformations are
        taken to be specific matrices
        <span class="math">\mathbf&#123;M&#125;_&#123;\mathcal&#123;E&#125;&#125;</span>
        and
        <span class="math">\mathbf&#123;M&#125;_&#123;\mathcal&#123;I&#125;&#125;</span>,
        where
        <span class="math">(\mathbf&#123;M&#125;_&#123;\mathcal&#123;I&#125;&#125;)_&#123;i,j&#125; = 1 + \mu_i</span>
        if <span class="math">i = j</span> and 1 otherwise.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 (CICO Problem)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Given a function
            <span class="math">F : \mathbb&#123;F&#125;_p^t \to \mathbb&#123;F&#125;_p^t</span>
            and an integer
            <span class="math">u &lt; t</span>, the CICO problem asks
            for
            <span class="math">X_0, \ldots, X_&#123;t-1-u&#125;, Y_0, \ldots, Y_&#123;t-1-u&#125; \in \mathbb&#123;F&#125;_p</span>
            such that
          </p>
          <div class="math-block">
            F(X_0, \ldots, X_&#123;t-1-u&#125;, 0, \ldots, 0) = (Y_0, \ldots, Y_&#123;t-1-u&#125;, 0, \ldots, 0).
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        The Poseidon-64 and Poseidon-256 challenge instances have
        <span class="math">u = 1</span>, which means we only require the
        last coordinate of both the input and output to be zero.
      </p>

      <p class="text-gray-300">
        The differences between Poseidon and Poseidon2 are: (a) Poseidon
        does not apply the initial linear transform before the first
        round; (b) Poseidon uses the same MDS matrix for all rounds;
        (c) for the partial rounds, Poseidon also applies the RC gates
        to all states.
      </p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Skip First Rounds Trick
      </h3>
      <p class="text-gray-300">
        This subsection provides a brief review of the Skip First Rounds
        Trick from [BBLP22], which was also used in the challenges. For
        simplicity, the focus is on the case of Poseidon-64. This
        technique reduces the polynomial degree by a factor of
        <span class="math">\alpha</span> for Poseidon2 and by
        <span class="math">\alpha^2</span> for Poseidon, respectively.
        The impact is less significant for Poseidon2, owing to the
        presence of the initial linear transformation&mdash;this is
        precisely why [GKS23] introduced the initial linear transform in
        the first place.
      </p>

      <p class="text-gray-300">
        Let the last row of
        <span class="math">(\mathbf&#123;M&#125;_&#123;\mathcal&#123;E&#125;&#125;)^&#123;-1&#125;</span>
        be
        <span class="math">(\lambda_0, \ldots, \lambda_&#123;t-1&#125;)</span>.
        Then,
        <span class="math">(y_0, \ldots, y_&#123;t-1&#125;)</span>
        corresponds to an input whose last coordinate is zero if and
        only if
      </p>
      <div class="math-block">
        \sum_&#123;i=0&#125;^&#123;t-1&#125; \lambda_i y_i^&#123;1/7&#125; = \sum_&#123;i=0&#125;^&#123;t-1&#125; \lambda_i \cdot RC_i.
      </div>

      <p class="text-gray-300">
        Under appropriate choices of the variables, the permutation
        becomes a univariate polynomial in
        <span class="math">y_0</span> of degree
        <span class="math">\alpha^&#123;R_F + R_P - 1&#125;</span>.
        Finding the roots of this polynomial gives a solution to the
        CICO problem, so the polynomial degree can be reduced by a
        factor of <span class="math">\alpha</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. ROOT FINDING FOR UNIVARIATE POLYNOMIALS                   -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Root Finding for Univariate Polynomials
      </h2>

      <p class="text-gray-300">
        This section first reviews current polynomial solving methods for
        practical attacks on STARK-friendly hash functions, then presents
        the Graeffe transform-based algorithm in detail, with a focus on
        the Goldilocks field.
      </p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 GCD-Based Methods
      </h3>
      <p class="text-gray-300">
        The polynomials that appear in interpolation attacks usually have
        only a few roots in the underlying field, much like random
        polynomials. This allows the use of the following GCD-based root
        finding approach, which was used to set the Poseidon
        interpolation record [BBLP22].
      </p>

      <p class="text-gray-300">
        If <span class="math">f(x)</span> is a polynomial of degree
        <span class="math">d</span> over
        <span class="math">\mathbb&#123;F&#125;_p</span>, the GCD-based
        approach first replaces <span class="math">f(x)</span> with its
        GCD with the Frobenius polynomial
        <span class="math">x^p - x</span>, reducing the problem to the
        case where <span class="math">f(x)</span> is split over
        <span class="math">\mathbb&#123;F&#125;_p</span>, then finds
        the roots by the Berlekamp algorithm [Ber71] or the
        Cantor&ndash;Zassenhaus algorithm [CZ81].
      </p>

      <p class="text-gray-300">
        Before the GCD computation, since
        <span class="math">f(x)</span> usually has degree much less than
        <span class="math">x^p - x</span>, it will be helpful to
        compute
        <span class="math">g(x) = x^p - x \mod f(x)</span> using the
        square-and-multiply method, requiring
        <span class="math">O(\log p)</span> modular polynomial
        multiplications for a total cost of
        <span class="math">O(\log(p) \mathsf&#123;M&#125;(d))</span>.
        The GCD itself can be computed by the Half-GCD algorithm in
        <span class="math">O(\log(n) \mathsf&#123;M&#125;(d))</span>,
        but this step is the most troublesome part of the root finding
        process.
      </p>

      <p class="text-gray-300">
        The GCD computation is unattractive for several reasons: (a) the
        Half-GCD algorithm is highly sequential, making it notoriously
        difficult to parallelize; (b) the constant factor is quite large
        (bounded by
        <span class="math">22 \log(n) \mathsf&#123;M&#125;(d)</span> in
        the original paper [Moe73]); and (c) the recursive form is
        extremely painful to implement, especially with large memory or
        GPU parallelism.
      </p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Root Finding via Graeffe Transform
      </h3>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2 (Graeffe Transform)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">f(x) \in \mathbb&#123;F&#125;_p[x]</span>
            be a polynomial. For any positive integer
            <span class="math">\ell</span> coprime to
            <span class="math">p</span>, the Graeffe transform of
            <span class="math">f(x)</span> of order
            <span class="math">\ell</span>, denoted
            <span class="math">\mathsf&#123;GT&#125;_\ell(f)</span>, is
            defined as the unique polynomial
            <span class="math">g</span> such that
          </p>
          <div class="math-block">
            g(x^\ell) = f(x)f(x\omega_\ell^1) \cdots f(x\omega_\ell^&#123;\ell-1&#125;),
          </div>
          <p class="text-gray-300">
            where <span class="math">\omega_\ell</span> is a primitive
            <span class="math">\ell</span>-th root of unity, possibly in
            an extension field of
            <span class="math">\mathbb&#123;F&#125;_p</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            If
            <span class="math">f(x) \in \mathbb&#123;F&#125;_p[x]</span>
            is a polynomial of degree <span class="math">d</span>,
            <span class="math">\ell</span> is coprime to
            <span class="math">p</span>, then the Graeffe transform
            <span class="math">\mathsf&#123;GT&#125;_\ell(f)</span> is
            also a well-defined polynomial in
            <span class="math">\mathbb&#123;F&#125;_p[x]</span> of
            degree <span class="math">d</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Let
        <span class="math">h(x) = f(x)f(x\omega_\ell^1) \cdots f(x\omega_\ell^&#123;\ell-1&#125;)</span>.
        By construction, <span class="math">h(x)</span> is invariant
        under the substitution
        <span class="math">x \mapsto x\omega_\ell</span>, which
        multiplies the coefficient of
        <span class="math">x^i</span> by
        <span class="math">\omega_\ell^i</span>. Thus, the coefficients
        of <span class="math">x^i</span> in
        <span class="math">h(x)</span> can be nonzero only if
        <span class="math">\omega_\ell^i = 1</span>, i.e.,
        <span class="math">i</span> is a multiple of
        <span class="math">\ell</span>. Therefore, the existence of
        <span class="math">g(x)</span> is guaranteed, and the degree of
        <span class="math">g(x)</span> is
        <span class="math">\deg(h(x))/\ell = d</span>. The coefficients
        lie in
        <span class="math">\mathbb&#123;F&#125;_p</span> because each
        coefficient of <span class="math">h(x)</span> is fixed under
        any Galois conjugation.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 2</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            If
            <span class="math">f(x) \in \mathbb&#123;F&#125;_p[x]</span>
            is a polynomial of degree <span class="math">d</span>,
            <span class="math">\ell_0, \ell_1</span> are coprime to
            <span class="math">p</span>, then
            <span class="math">\mathsf&#123;GT&#125;_&#123;\ell_0&#125;(\mathsf&#123;GT&#125;_&#123;\ell_1&#125;(f)) = \mathsf&#123;GT&#125;_&#123;\ell_0 \cdot \ell_1&#125;(f)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Suppose <span class="math">\omega</span> is a
        primitive
        <span class="math">\ell_0 \ell_1</span>-th root of unity. Then
        <span class="math">\omega^&#123;\ell_1&#125;</span> is a
        primitive <span class="math">\ell_0</span>-th root of unity,
        and <span class="math">\omega^&#123;\ell_0&#125;</span> is a
        primitive <span class="math">\ell_1</span>-th root of unity. By
        the definition of the Graeffe transform:
      </p>
      <div class="math-block">
        \begin&#123;aligned&#125;
        \mathsf&#123;GT&#125;_&#123;\ell_0&#125;(\mathsf&#123;GT&#125;_&#123;\ell_1&#125;(f))(x^&#123;\ell_0 \ell_1&#125;)
        &amp;= \mathsf&#123;GT&#125;_&#123;\ell_1&#125;(f)(x^&#123;\ell_1&#125;) \mathsf&#123;GT&#125;_&#123;\ell_1&#125;(f)(x^&#123;\ell_1&#125; \omega^&#123;\ell_1&#125;) \cdots \mathsf&#123;GT&#125;_&#123;\ell_1&#125;(f)(x^&#123;\ell_1&#125; \omega^&#123;(\ell_0-1)\ell_1&#125;) \\
        &amp;= \prod_&#123;j=0&#125;^&#123;\ell_0-1&#125; f(x\omega^j)f(x\omega^&#123;j+\ell_0&#125;) \cdots f(x\omega^&#123;j+(\ell_1-1)\ell_0&#125;) \\
        &amp;= \mathsf&#123;GT&#125;_&#123;\ell_0 \cdot \ell_1&#125;(f)(x^&#123;\ell_0 \ell_1&#125;).
        \end&#123;aligned&#125;
      </div>

      <p class="text-gray-300">
        Lemma 2 allows the Graeffe transform of large order
        <span class="math">\ell</span> to be computed by successively
        applying Graeffe transforms of smaller orders. This can be done
        effectively when <span class="math">\ell</span> is smooth, which
        is exactly the case for the challenges solved.
      </p>

      <p class="text-gray-300">
        For <span class="math">\ell = 2</span>, if
        <span class="math">f(x) = f_0(x^2) + x f_1(x^2)</span>, then
      </p>
      <div class="math-block">
        f(x)f(-x) = (f_0(x^2) + xf_1(x^2))(f_0(x^2) - xf_1(x^2)) = f_0(x^2)^2 - x^2 f_1(x^2)^2.
      </div>
      <p class="text-gray-300">
        Therefore, the Graeffe transform of order 2 is given by
        <span class="math">\mathsf&#123;GT&#125;_2(f) = f_0(x)^2 - x f_1(x)^2</span>.
        This can be computed using two FFTs and one invFFT with FFT group
        size at least <span class="math">d</span>, costing only
        <span class="math">\mathsf&#123;M&#125;(d/2)</span>.
      </p>

      <p class="text-gray-300">
        For <span class="math">\ell \geqslant 3</span>, the recursive
        method from [GHL15] is used. If
        <span class="math">P_h(x)</span> is the product
        <span class="math">P_h(x) = f(x)f(x\omega_\ell^1) \cdots f(x\omega_\ell^&#123;h-1&#125;)</span>,
        then it suffices to compute
        <span class="math">P_\ell(x)</span> recursively:
      </p>
      <div class="math-block">
        P_h(x) = \begin&#123;cases&#125; f(x) &amp; \text&#123;if &#125; h = 1 \\ P_&#123;h/2&#125;(x) P_&#123;h/2&#125;(x\omega_\ell^&#123;h/2&#125;) &amp; \text&#123;if &#125; h \text&#123; even&#125; \\ f(x) P_&#123;(h-1)/2&#125;(x\omega_\ell) P_&#123;(h-1)/2&#125;(x\omega_\ell^&#123;(h+1)/2&#125;) &amp; \text&#123;otherwise.&#125; \end&#123;cases&#125;
      </div>

      <p class="text-gray-300">
        The paper presents Algorithm 2 for root finding over the
        Goldilocks field. The algorithm successively applies Graeffe
        transforms of orders matching the factorization
        <span class="math">p_&#123;64&#125; - 1 = 2^&#123;32&#125; \cdot 3 \cdot 5 \cdot 17 \cdot 257 \cdot 65537</span>.
        First, repeated
        <span class="math">\mathsf&#123;GT&#125;_2</span> operations
        are applied while
        <span class="math">\beta</span> is even, then
        <span class="math">\mathsf&#123;GT&#125;_3</span>,
        <span class="math">\mathsf&#123;GT&#125;_5</span>,
        <span class="math">\mathsf&#123;GT&#125;_&#123;17&#125;</span>,
        and
        <span class="math">\mathsf&#123;GT&#125;_&#123;257&#125;</span>
        are applied in sequence. Once the polynomial degree is small
        enough, roots are found by enumeration, and then the original
        root is recovered by backtracking through each Graeffe step.
      </p>

      <p class="text-gray-300">
        The overall cost of the algorithm is estimated to be
        approximately
        <span class="math">(\log_2(p_&#123;64&#125;) - \log_2(d) + 1) \mathsf&#123;M&#125;(d/2)</span>.
        The constant factor is much smaller than that of GCD-based
        methods, which is part of the reason for the speedup.
      </p>

      <p class="text-gray-300">
        The numbers 2, 3, 5, 17, 257 in Algorithm 2 exactly correspond
        to the factorization of
        <span class="math">p_&#123;64&#125; - 1</span>. The algorithm
        can be adapted to other prime fields, as long as the
        multiplicative group size of the field is smooth enough. For
        instance:
      </p>
      <div class="math-block">
        p_&#123;255&#125; - 1 = 2^&#123;32&#125; \cdot 3 \cdot 11 \cdot 19 \cdot 10177 \cdot 125527 \cdot 859267 \cdot 906349^2 \cdot 2508409 \cdot 2529403 \cdot 52437899 \cdot 254760293^2.
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 4. IMPLEMENTATION AND SECURITY ESTIMATION                    -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Implementation and Security Estimation
      </h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Implementation Details
      </h3>
      <p class="text-gray-300">
        The Graeffe transform-based algorithm was implemented in C++ with
        CUDA, with about 4k&ndash;5k lines in total. The code uses a
        modular design which decouples memory management, polynomial
        algorithms, and field arithmetic. It can be adapted to other
        64-bit prime fields by changing the FFT group choice and field
        arithmetic code as long as the multiplicative group size is
        smooth enough. With this implementation, the 24-, 28-, and
        32-bit Poseidon-64 challenges were solved, corresponding to
        polynomial degrees
        <span class="math">7^&#123;12&#125;</span>,
        <span class="math">7^&#123;13&#125;</span>, and
        <span class="math">7^&#123;15&#125;</span>, respectively.
      </p>

      <p class="text-gray-300">
        <strong>Architecture.</strong> The code was developed on a
        dual-socket Intel Xeon Platinum 8474C server equipped with
        several Nvidia RTX 4090 graphics cards. Each card is connected
        to the system&rsquo;s 2TB RAM via a PCIe 4.0 interface,
        providing a unidirectional bandwidth of roughly 200 GiB/s in
        total under real-world conditions. Almost no low-level
        optimization of finite field arithmetic or FFT routines was
        performed for GPU or CPU architectures; the performance is mainly
        determined by memory bandwidth rather than compute throughput.
      </p>

      <p class="text-gray-300">
        <strong>Memory Issue.</strong> Even after significant
        improvements to the root finding algorithm, the &ldquo;32-bit&rdquo;
        challenge still takes several days. For other well-known hard
        problems (lattice problems, multivariate polynomial system
        solving, or decoding [ALM19]), it is typically feasible to solve
        instances up to 60 or even 70 &ldquo;bits.&rdquo; This suggests
        that the Poseidon interpolation attack has some inherent
        hardness, and that previous security estimates might have been
        somewhat too conservative.
      </p>

      <p class="text-gray-300">
        <strong>Performance.</strong> Compared with previous GCD-based
        results in [BBLP22], for degrees
        <span class="math">7^&#123;12&#125;</span> and
        <span class="math">7^&#123;13&#125;</span>, the new result is
        about 10,000 times faster and uses only 4% to 5% of the memory.
        For <span class="math">7^&#123;15&#125;</span>, although
        swapping data to disk causes some slowdown, the method is still
        about 6,000 times faster than the previous result.
      </p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Security Estimation
      </h3>
      <p class="text-gray-300">
        Based on the implementation results, a security estimation for
        the interpolation attack is provided. The focus is on the
        &ldquo;128-bit&rdquo; instance of Poseidon, where the prime
        field size is
        <span class="math">p_&#123;255&#125;</span>. The central
        question is how to quantify the impact of memory access on the
        attack.
      </p>

      <p class="text-gray-300">
        Using the physical fact that the cost of moving information is at
        least proportional to the distance it travels, the paper proves
        in Theorem 1 that the memory access cost for executing FFT is at
        least proportional to the
        <span class="math">4/3</span>-power of the input size. Based on
        this, the root finding cost is modeled as scaling with the
        <span class="math">4/3</span>-power of the polynomial degree.
      </p>

      <p class="text-gray-300">
        For 128-bit security, the estimation script gives round numbers
        <span class="math">R_F = 8, R_P = 56</span>, corresponding to a
        polynomial degree of
        <span class="math">5^&#123;63&#125;</span> using the Skip First
        Rounds Trick. The attack cost is estimated as:
      </p>
      <div class="math-block">
        \left(\frac&#123;5^&#123;63&#125;&#125;&#123;7^&#123;15&#125;&#125;\right)^&#123;4/3&#125; \times 2^&#123;59&#125; \approx 2^&#123;198&#125;
      </div>
      <p class="text-gray-300">
        SHA-256 permutations. So the current parameter choice looks
        somewhat conservative, and it may be tempting to reduce the
        number of rounds for better efficiency.
      </p>

      <p class="text-gray-300">
        It is crucial to remark that this estimation applies only when a
        single zero is required in both the input and output of the
        sponge permutation. Otherwise, the best known attack would
        involve multivariate polynomial solving, where the main
        bottleneck is linear algebra over finite fields and memory cost
        is less relevant.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. MEMORY ACCESS LOWER BOUNDS FOR FFT                        -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. Memory Access Lower Bounds for FFT
      </h2>

      <p class="text-gray-300">
        This section proves a lower bound for the data movement cost of
        the fast Fourier transform. Specifically, it shows that any
        arithmetic circuit corresponding to the FFT algorithm, regardless
        of how it is realized in three-dimensional space, will require
        information to travel a total distance roughly proportional to
        the <span class="math">4/3</span>-power of the input size. The
        proof makes use of two physical facts.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">Fact 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The cost of memory movement is proportional to the physical
            distance over which it is transferred (and, of course, the
            amount of data moved).
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">Fact 2</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Each bit of data must be stored in a physical volume bounded
            below by a positive constant (i.e., information density is
            finite).
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3 (Cost of Data Movement)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For two positions
            <span class="math">\mathbf&#123;x&#125;</span> and
            <span class="math">\mathbf&#123;y&#125;</span> in
            <span class="math">\mathbb&#123;R&#125;^3</span>, we define
            the cost of moving a field element from position
            <span class="math">\mathbf&#123;x&#125;</span> to position
            <span class="math">\mathbf&#123;y&#125;</span> as the
            Euclidean distance
            <span class="math">\|\mathbf&#123;x&#125; - \mathbf&#123;y&#125;\|</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">Theorem 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The arithmetic circuit of FFT over a finite field with input
            size <span class="math">n = 2^&#123;e_2&#125;</span>,
            regardless of how it is realized in our three-dimensional
            world, will incur a memory movement cost of at least
            <span class="math">\tilde&#123;\mathcal&#123;O&#125;&#125;(n^&#123;4/3&#125;)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        To prove the theorem, the paper first introduces the Directed
        Acyclic Graph (DAG) for the FFT circuit. The DAG consists of
        <span class="math">n</span> input nodes and
        <span class="math">n</span> output nodes. A directed edge
        <span class="math">v_i \to v_j</span> indicates that the value
        at node <span class="math">v_j</span> (linearly) depends on the
        value at node <span class="math">v_i</span>.
      </p>

      <p class="text-gray-300">
        The nodes are labeled
        <span class="math">v_&#123;i,0&#125;, v_&#123;i,1&#125;, \ldots, v_&#123;i,e_2&#125;</span>
        for <span class="math">i = 0, \ldots, n-1</span>. From each
        node <span class="math">v_&#123;i,s&#125;</span> with
        <span class="math">0 \leqslant s &lt; e_2</span>, there are two
        directed edges: one to
        <span class="math">v_&#123;i,s+1&#125;</span> and one to
        <span class="math">v_&#123;i \oplus 2^&#123;e_2-1-s&#125;, s+1&#125;</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 3</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Suppose that, when a particular realization of the FFT
            circuit in Theorem 1 halts, the
            <span class="math">i</span>-th output node is stored at
            position
            <span class="math">\mathbf&#123;p&#125;(i) \in \mathbb&#123;R&#125;^3</span>.
            Then the memory movement cost during the execution is at
            least
          </p>
          <div class="math-block">
            \sum_&#123;i \in \&#123;0,\ldots,n-1\&#125;,\, i &lt; i \oplus 2^r&#125; \|\mathbf&#123;p&#125;(i) - \mathbf&#123;p&#125;(i \oplus 2^r)\|
          </div>
          <p class="text-gray-300">
            for any
            <span class="math">r = 0, 1, \ldots, e_2 - 1</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> For each
        <span class="math">i_0 \in \&#123;0, \ldots, n-1\&#125;</span>
        with
        <span class="math">i_0 &lt; i_0 \oplus 2^r</span>, a subgraph
        <span class="math">G_&#123;i_0&#125; = (V_&#123;i_0&#125;, E_&#123;i_0&#125;)</span>
        of the DAG is constructed:
      </p>
      <div class="math-block">
        V_&#123;i_0&#125; = \&#123;v_&#123;i_0 \oplus 2^r, \ell&#125; : e_2 - 1 - r \leqslant \ell \leqslant e_2\&#125; \cup \&#123;v_&#123;i_0, \ell&#125; : e_2 - r \leqslant \ell \leqslant e_2\&#125;
      </div>
      <div class="math-block">
        E_&#123;i_0&#125; = \&#123;v_&#123;i_0 \oplus 2^r, e_2 - 1 - r&#125; \to v_&#123;i_0, e_2 - r&#125;\&#125; \cup \&#123;v_&#123;i,s&#125; \to v_&#123;i,s+1&#125; : v_&#123;i,s&#125; \in V_&#123;i_0&#125;, s &lt; e_2\&#125;
      </div>

      <p class="text-gray-300">
        By construction, the images for different
        <span class="math">i_0</span> are pairwise disjoint. The memory
        movement cost within
        <span class="math">G_&#123;i_0&#125;</span> is at least
        <span class="math">\|\mathbf&#123;p&#125;(i_0) - \mathbf&#123;p&#125;(i_0 \oplus 2^r)\|</span>
        by the triangle inequality, since both output nodes are
        endpoints of directed paths starting from the same node.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 4</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The summation of pairwise distances of the output nodes is
          </p>
          <div class="math-block">
            \sum_&#123;i,j \in \&#123;0, \ldots, n-1\&#125;&#125; \|\mathbf&#123;p&#125;(i) - \mathbf&#123;p&#125;(j)\| = \mathcal&#123;O&#125;(n^&#123;7/3&#125;).
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> By Fact 2, there exists a constant
        <span class="math">C_0</span> such that there are at most
        <span class="math">C_0 R^3</span> field elements stored within
        any ball of radius <span class="math">R</span>. For each
        <span class="math">i</span>:
      </p>
      <div class="math-block">
        \sum_&#123;0 \leqslant j \leqslant n-1&#125; \|\mathbf&#123;p&#125;(i) - \mathbf&#123;p&#125;(j)\| \geqslant (16C_0)^&#123;-1/3&#125; \cdot n^&#123;4/3&#125;.
      </div>
      <p class="text-gray-300">
        The proof concludes by taking the sum over all
        <span class="math">0 \leqslant i \leqslant n - 1</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 5</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            There must exist an
            <span class="math">r \in \&#123;0, 1, \ldots, e_2 - 1\&#125;</span>
            such that
          </p>
          <div class="math-block">
            \sum_&#123;i \in \&#123;0, \ldots, n-1\&#125;,\, i &lt; i \oplus 2^r&#125; \|\mathbf&#123;p&#125;(i) - \mathbf&#123;p&#125;(i \oplus 2^r)\| \geqslant \frac&#123;1&#125;&#123;n e_2&#125; \sum_&#123;i,j \in \&#123;0, \ldots, n-1\&#125;&#125; \|\mathbf&#123;p&#125;(i) - \mathbf&#123;p&#125;(j)\|.
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Let
        <span class="math">S(r) = \sum_&#123;i \in \&#123;0,\ldots,n-1\&#125;, i &lt; i \oplus 2^r&#125; \|\mathbf&#123;p&#125;(i) - \mathbf&#123;p&#125;(i \oplus 2^r)\|</span>.
        Let <span class="math">r_0</span> be such that
        <span class="math">S(r_0)</span> is the largest among
        <span class="math">S(0), \ldots, S(e_2 - 1)</span>. Using the
        triangle inequality and the binary representation of
        <span class="math">j</span>:
      </p>
      <div class="math-block">
        \begin&#123;aligned&#125;
        \sum_&#123;0 \leqslant i,j &lt; n&#125; \|\mathbf&#123;p&#125;(i) - \mathbf&#123;p&#125;(i \oplus j)\|
        &amp;\leqslant 2 \cdot \sum_&#123;j&#125; (S(r_0) + \cdots + S(r_\ell)) \\
        &amp;= n \cdot (S(0) + \cdots + S(e_2 - 1)) \\
        &amp;\leqslant n e_2 \cdot S(r_0)
        \end&#123;aligned&#125;
      </div>
      <p class="text-gray-300">
        as desired.
      </p>

      <p class="text-gray-300">
        <strong>Proof of Theorem 1.</strong> Combining Lemma 3, Lemma 4,
        and Lemma 5: there exists an
        <span class="math">r</span> such that the memory movement cost
        is at least
        <span class="math">S(r) \geqslant \frac&#123;1&#125;&#123;n e_2&#125; \cdot \mathcal&#123;O&#125;(n^&#123;7/3&#125;) = \tilde&#123;\mathcal&#123;O&#125;&#125;(n^&#123;4/3&#125;)</span>,
        since
        <span class="math">e_2 = \log_2 n</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. CONCLUSIONS                                               -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6. Conclusions</h2>
      <p class="text-gray-300">
        The paper presents a Graeffe transform-based algorithm for root
        finding over finite fields, used to solve several Poseidon
        challenges from the Ethereum Foundation. The results show a
        speedup of several orders of magnitude over previous methods,
        while using only about 4&ndash;5% of the memory. Based on these
        results, a security estimate for interpolation attacks with the
        current proposed parameters is provided. In particular, it is
        proven that the FFT algorithm incurs a memory access cost
        proportional to the <span class="math">4/3</span>-power of the
        input size, up to logarithmic factors, which differs from
        previous analyses using hierarchical memory models.
      </p>
      <p class="text-gray-300">
        A few points are worth highlighting. First, these results apply
        only to the classical setting; the quantum resistance of root
        finding in interpolation attacks, or other potential attacks,
        remains unclear compared to the well-established hardness of
        problems used in post-quantum cryptography.
      </p>
      <p class="text-gray-300">
        Moreover, FFTs are also used in other cryptanalytic contexts. For
        example, certain dual lattice attacks on LWE [MAT22] use FFTs to
        accelerate the distinguishing step. The lower bound for FFTs
        derived here may be relevant in those settings as well,
        indicating that some attack complexity estimates in the
        literature may be overly optimistic.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        The authors would like to thank the Ethereum Foundation for
        launching the Poseidon bounty program, which is the initial
        motivation and starting point for this research. On May 22nd,
        about one month after submitting the first bounty instance, the
        report and code were sent to the Ethereum Foundation and later
        the authors were informed about ongoing parallel work by Antonio
        Sanso (Ethereum Foundation Poseidon Group) and Giuseppe Vitto
        [SV25], who independently studied a similar idea. While their work
        places more emphasis on the tangent Graeffe Transform, this
        paper provides a complexity analysis based on FFT lower bounds.
        In the case of Poseidon-64, the results are roughly two orders
        of magnitude faster.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-2 text-gray-400 text-sm list-none">
        <li>
          <span class="text-gray-500">[ACG+19]</span>
          Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D.,
          L&uuml;ftenegger, R., Rechberger, C., Schofnegger, M.:
          &ldquo;Algebraic cryptanalysis of STARK-friendly designs:
          Application to MARVELlous and MiMC.&rdquo; In:
          <em>ASIACRYPT 2019</em>, pp. 371&ndash;397. Springer (2019).
          doi:
          <a
            href="https://doi.org/10.1007/978-3-030-34618-8_13"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1007/978-3-030-34618-8_13</a>.
        </li>
        <li>
          <span class="text-gray-500">[AGR+16]</span>
          Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A.,
          Tiessen, T.: &ldquo;MiMC: Efficient encryption and
          cryptographic hashing with minimal multiplicative
          complexity.&rdquo; In: <em>ASIACRYPT 2016, Part I</em>.
          Vol. 10031. LNCS. Springer (2016), pp. 191&ndash;219. doi:
          <a
            href="https://doi.org/10.1007/978-3-662-53887-6_7"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1007/978-3-662-53887-6_7</a>.
        </li>
        <li>
          <span class="text-gray-500">[ALM19]</span>
          Aragon, N., Lavauzelle, J., Lequesne, M.:
          decodingchallenge.org (2019).
          <a
            href="http://decodingchallenge.org"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >decodingchallenge.org</a>.
        </li>
        <li>
          <span class="text-gray-500">[AD18]</span>
          Ashur, T., Dhooghe, S.: &ldquo;MARVELlous: a
          STARK-friendly family of cryptographic primitives.&rdquo;
          Cryptology ePrint Archive, Paper 2018/1098 (2018).
          <a
            href="https://eprint.iacr.org/2018/1098"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2018/1098</a>.
        </li>
        <li>
          <span class="text-gray-500">[AKM+22]</span>
          Ashur, T., Kindi, A., Meier, W., Szepieniec, A.,
          Threadbare, B.: &ldquo;Rescue-Prime Optimized.&rdquo;
          Cryptology ePrint Archive, Paper 2022/1577 (2022).
          <a
            href="https://eprint.iacr.org/2022/1577"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/1577</a>.
          <a href="/papers/rescue-prime-optimized-2022"
            class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[BBO+24]</span>
          Bariant, A., Boeuf, A., Lemoine, A., Manterola Ayala, I.,
          &Oslash;ygarden, M., Perrin, L., Raddum, H.: &ldquo;The
          algebraic freelunch: Efficient Gr&ouml;bner basis attacks
          against arithmetization-oriented primitives.&rdquo; In:
          <em>CRYPTO 2024</em>, pp. 139&ndash;173. Springer (2024).
          doi:
          <a
            href="https://doi.org/10.1007/978-3-031-68385-5_5"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1007/978-3-031-68385-5_5</a>.
        </li>
        <li>
          <span class="text-gray-500">[BBLP22]</span>
          Bariant, A., Bouvier, C., Leurent, G., Perrin, L.:
          &ldquo;Algebraic attacks against some arithmetization-oriented
          primitives.&rdquo; <em>IACR Trans. Symmetric Cryptol.</em>
          2022(3), 73&ndash;101 (2022). doi:
          <a
            href="https://doi.org/10.46586/tosc.v2022.i3.73-101"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.46586/tosc.v2022.i3.73-101</a>.
        </li>
        <li>
          <span class="text-gray-500">[BBHR19]</span>
          Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.:
          &ldquo;Scalable zero knowledge with no trusted setup.&rdquo;
          In: <em>CRYPTO 2019, Part III</em>, pp. 701&ndash;732.
          Springer (2019). doi:
          <a
            href="https://doi.org/10.1007/978-3-030-26954-8_23"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1007/978-3-030-26954-8_23</a>.
        </li>
        <li>
          <span class="text-gray-500">[BCKL]</span>
          Ben-Sasson, E., Carmon, D., Kopparty, S., Levit, D.:
          &ldquo;Elliptic Curve Fast Fourier Transform (ECFFT) Part I:
          Low-degree Extension in Time
          <span class="math">O(n \log n)</span> over all Finite
          Fields.&rdquo;
          <a
            href="https://epubs.siam.org/doi/abs/10.1137/1.9781611977554.ch30"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >SIAM</a>.
        </li>
        <li>
          <span class="text-gray-500">[Ber71]</span>
          Berlekamp, E.R.: &ldquo;Factoring polynomials over large
          finite fields.&rdquo; In: <em>SYMSAC &rsquo;71</em>. ACM
          (1971). doi:
          <a
            href="https://doi.org/10.1145/800204.806290"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1145/800204.806290</a>.
        </li>
        <li>
          <span class="text-gray-500">[Bes49]</span>
          Best, G.C.: &ldquo;Notes on the Graeffe method of root
          squaring.&rdquo; <em>The American Mathematical Monthly</em>
          56(2), 91&ndash;94 (1949).
        </li>
        <li>
          <span class="text-gray-500">[BS24]</span>
          Brodetsky, S., Smeal, G.: &ldquo;On Graeffe&rsquo;s
          method for complex roots of algebraic equations.&rdquo;
          <em>Math. Proc. Cambridge Phil. Soc.</em> 22(2), 83&ndash;87
          (1924). doi:
          <a
            href="https://doi.org/10.1017/S0305004100002802"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1017/S0305004100002802</a>.
        </li>
        <li>
          <span class="text-gray-500">[Buc06]</span>
          Buchberger, B.: &ldquo;Bruno Buchberger&rsquo;s PhD
          thesis 1965: An algorithm for finding the basis elements of the
          residue class ring of a zero dimensional polynomial
          ideal.&rdquo; <em>J. Symbolic Comput.</em> 41(3), 475&ndash;511
          (2006). doi:
          <a
            href="https://doi.org/10.1016/j.jsc.2005.09.007"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1016/j.jsc.2005.09.007</a>.
        </li>
        <li>
          <span class="text-gray-500">[BDMM09]</span>
          Buchmann, J.A., Ding, J., Mohamed, M.S.E., Mohamed,
          W.S.A.E.: &ldquo;MutantXL: Solving multivariate polynomial
          equations for cryptanalysis.&rdquo; In: <em>Symmetric
          Cryptography</em> (2009).
        </li>
        <li>
          <span class="text-gray-500">[CZ81]</span>
          Cantor, D.G., Zassenhaus, H.: &ldquo;A new algorithm for
          factoring polynomials over finite fields.&rdquo; <em>Math.
          Comp.</em> 36, 587&ndash;592 (1981).
        </li>
        <li>
          <span class="text-gray-500">[EF24]</span>
          Ethereum Foundation: &ldquo;Poseidon cryptanalysis
          initiative 2024&ndash;2026.&rdquo;
          <a
            href="https://www.poseidon-initiative.info/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >poseidon-initiative.info</a> (2024).
        </li>
        <li>
          <span class="text-gray-500">[FGLM93]</span>
          Faug&egrave;re, J., Gianni, P., Lazard, D., Mora, T.:
          &ldquo;Efficient computation of zero-dimensional Gr&ouml;bner
          bases by change of ordering.&rdquo; <em>J. Symbolic Comput.</em>
          16(4), 329&ndash;344 (1993). doi:
          <a
            href="https://doi.org/10.1006/jsco.1993.1051"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1006/jsco.1993.1051</a>.
        </li>
        <li>
          <span class="text-gray-500">[Fau99]</span>
          Faug&egrave;re, J.C.: &ldquo;A new efficient algorithm
          for computing Gr&ouml;bner bases (F4).&rdquo; <em>J. Pure
          Appl. Algebra</em> 139(1), 61&ndash;88 (1999). doi:
          <a
            href="https://doi.org/10.1016/S0022-4049(99)00005-5"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1016/S0022-4049(99)00005-5</a>.
        </li>
        <li>
          <span class="text-gray-500">[GKL+22]</span>
          Grassi, L., Khovratovich, D., L&uuml;ftenegger, R.,
          Rechberger, C., Schofnegger, M., Walch, R.: &ldquo;Reinforced
          Concrete: A fast hash function for verifiable
          computation.&rdquo; In: <em>CCS &rsquo;22</em>. ACM (2022),
          pp. 1323&ndash;1335. doi:
          <a
            href="https://doi.org/10.1145/3548606.3560686"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1145/3548606.3560686</a>.
          <a href="/papers/reinforced-concrete-2021"
            class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKR+21]</span>
          Grassi, L., Khovratovich, D., Rechberger, C., Roy, A.,
          Schofnegger, M.: &ldquo;Poseidon: A new hash function for
          Zero-Knowledge proof systems.&rdquo; In: <em>30th USENIX
          Security Symposium</em>. USENIX Association (Aug 2021),
          pp. 519&ndash;535.
          <a
            href="https://www.usenix.org/conference/usenixsecurity21/presentation/grassi"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >usenix.org</a>.
          <a href="/papers/poseidon-2019"
            class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKS23]</span>
          Grassi, L., Khovratovich, D., Schofnegger, M.:
          &ldquo;Poseidon2: A faster version of the Poseidon hash
          function.&rdquo; Cryptology ePrint Archive, Paper 2023/323
          (2023).
          <a
            href="https://eprint.iacr.org/2023/323"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2023/323</a>.
          <a href="/papers/poseidon2-2023"
            class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GLR+20]</span>
          Grassi, L., L&uuml;ftenegger, R., Rechberger, C.,
          Rotaru, D., Schofnegger, M.: &ldquo;On a generalization of
          substitution-permutation networks: The HADES design
          strategy.&rdquo; In: <em>EUROCRYPT 2020, Part II</em>.
          Springer (2020), pp. 674&ndash;704. doi:
          <a
            href="https://doi.org/10.1007/978-3-030-45724-2_23"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1007/978-3-030-45724-2_23</a>.
          <a href="/papers/hades-2019"
            class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GHL15]</span>
          Grenet, B., van der Hoeven, J., Lecerf, G.:
          &ldquo;Randomized root finding over finite FFT-fields using
          tangent Graeffe transforms.&rdquo; In: <em>ISSAC &rsquo;15</em>.
          ACM (2015), pp. 197&ndash;204. doi:
          <a
            href="https://doi.org/10.1145/2755996.2756647"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1145/2755996.2756647</a>.
        </li>
        <li>
          <span class="text-gray-500">[GHL16]</span>
          Grenet, B., Hoeven, J., Lecerf, G.: &ldquo;Deterministic
          root finding over finite fields using Graeffe transforms.&rdquo;
          <em>Appl. Algebra Eng. Commun. Comput.</em> 27(3), 237&ndash;257
          (Jun 2016). doi:
          <a
            href="https://doi.org/10.1007/s00200-015-0280-5"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1007/s00200-015-0280-5</a>.
        </li>
        <li>
          <span class="text-gray-500">[Hoe22]</span>
          van der Hoeven, J.: &ldquo;Optimizing the Half-GCD
          algorithm.&rdquo; <em>ArXiv</em> abs/2212.12389 (2022).
          <a
            href="https://arxiv.org/abs/2212.12389"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >arxiv.org/abs/2212.12389</a>.
        </li>
        <li>
          <span class="text-gray-500">[HM20]</span>
          van der Hoeven, J., Monagan, M.: &ldquo;Implementing the
          tangent Graeffe root finding method.&rdquo; In:
          <em>ICMS 2020</em>. Springer (2020), pp. 482&ndash;492.
        </li>
        <li>
          <span class="text-gray-500">[Hou59]</span>
          Householder, A.S.: &ldquo;Dandelin, Lobachevsky, or
          Graeffe.&rdquo; <em>The American Mathematical Monthly</em>
          66(6), 464&ndash;466 (1959).
        </li>
        <li>
          <span class="text-gray-500">[JK97]</span>
          Jakobsen, T., Knudsen, L.R.: &ldquo;The interpolation
          attack on block ciphers.&rdquo; In: <em>Fast Software
          Encryption</em>. Springer (1997), pp. 28&ndash;40.
        </li>
        <li>
          <span class="text-gray-500">[JK81]</span>
          Jia-Wei, H., Kung, H.T.: &ldquo;I/O complexity: The
          red-blue pebble game.&rdquo; In: <em>STOC &rsquo;81</em>.
          ACM (1981), pp. 326&ndash;333. doi:
          <a
            href="https://doi.org/10.1145/800076.802486"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1145/800076.802486</a>.
        </li>
        <li>
          <span class="text-gray-500">[MAT22]</span>
          MATZOV: &ldquo;Report on the security of LWE: Improved
          dual lattice attack.&rdquo; (Apr 2022). doi:
          <a
            href="https://doi.org/10.5281/zenodo.6412487"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.5281/zenodo.6412487</a>.
        </li>
        <li>
          <span class="text-gray-500">[Moe73]</span>
          Moenck, R.T.: &ldquo;Fast computation of GCDs.&rdquo;
          In: <em>STOC &rsquo;73</em>. ACM (1973), pp. 142&ndash;151.
          doi:
          <a
            href="https://doi.org/10.1145/800125.804045"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1145/800125.804045</a>.
        </li>
        <li>
          <span class="text-gray-500">[MCB+10]</span>
          Mohamed, M.S.E., Cabarcas, D., Ding, J., Buchmann, J.,
          Bulygin, S.: &ldquo;MXL3: An efficient algorithm for computing
          Gr&ouml;bner bases of zero-dimensional ideals.&rdquo; In:
          <em>ICISC 2009</em>. Springer (2010), pp. 87&ndash;100.
        </li>
        <li>
          <span class="text-gray-500">[NIST23]</span>
          NIST: &ldquo;FAQ on Kyber512.&rdquo;
          <a
            href="https://csrc.nist.gov/csrc/media/Projects/post-quantum-cryptography/documents/faq/Kyber-512-FAQ.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >NIST PQC FAQ</a> (December 2023).
        </li>
        <li>
          <span class="text-gray-500">[Pan96]</span>
          Pan, V.Y.: &ldquo;Parallel computation of polynomial GCD
          and some related parallel computations over abstract
          fields.&rdquo; <em>Theoretical Computer Science</em> 162(2),
          173&ndash;223 (1996). doi:
          <a
            href="https://doi.org/10.1016/0304-3975(96)00030-8"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1016/0304-3975(96)00030-8</a>.
        </li>
        <li>
          <span class="text-gray-500">[RSZ11]</span>
          Ranjan, D., Savage, J., Zubair, M.: &ldquo;Strong I/O
          lower bounds for binomial and FFT computation graphs.&rdquo;
          In: <em>COCOON 2011</em>. Springer (2011), pp. 134&ndash;145.
        </li>
        <li>
          <span class="text-gray-500">[SV25]</span>
          Sanso, A., Vitto, G.: &ldquo;Attacking Poseidon via
          Graeffe-based root-finding over NTT-friendly fields.&rdquo;
          Cryptology ePrint Archive, Paper 2025/937 (2025).
          <a
            href="https://eprint.iacr.org/2025/937"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2025/937</a>.
          <a href="/papers/attacking-poseidon-graeffe-2025"
            class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[SS71]</span>
          Sch&ouml;nhage, A., Strassen, V.: &ldquo;Schnelle
          Multiplikation gro&szlig;er Zahlen.&rdquo; <em>Computing</em>
          7(3&ndash;4), 281&ndash;292 (1971). doi:
          <a
            href="https://doi.org/10.1007/BF02242355"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >10.1007/BF02242355</a>.
        </li>
        <li>
          <span class="text-gray-500">[SS13]</span>
          Scquizzato, M., Silvestri, F.: &ldquo;Communication lower
          bounds for distributed-memory computations.&rdquo; <em>CoRR</em>
          abs/1307.1805 (2013).
          <a
            href="http://arxiv.org/abs/1307.1805"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >arxiv.org/abs/1307.1805</a>.
        </li>
        <li>
          <span class="text-gray-500">[SAD20]</span>
          Szepieniec, A., Ashur, T., Dhooghe, S.:
          &ldquo;Rescue-Prime: a standard specification (SoK).&rdquo;
          Cryptology ePrint Archive, Paper 2020/1143 (2020).
          <a
            href="https://eprint.iacr.org/2020/1143"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2020/1143</a>.
          <a href="/papers/rescue-prime-2020"
            class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
      </ul>
    </section>

  </article>
</BaseLayout>
