---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/630';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proximity Testing with Logarithmic Randomness';
const AUTHORS_HTML = 'Benjamin E. Diamond, Jim Posen';

const CONTENT = `    <p class="text-gray-300">Benjamin E. Diamond Ulvetanna bdiamond@ulvetanna.io Jim Posen Ulvetanna jposen@ulvetanna.io</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">A fundamental result dating to <em>Ligero</em> (Des. Codes Cryptogr. ’23) establishes that each fixed linear block code exhibits <em>proximity gaps</em> with respect to the collection of affine subspaces, in the sense that each given subspace either resides entirely close to the code, or else contains only a small portion which resides close to the code. In particular, any given subspace’s <em>failure</em> to reside entirely close to the code is necessarily witnessed, with high probability, by a uniformly randomly sampled element of that subspace. We investigate a variant of this phenomenon in which the witness is not sampled uniformly from the subspace, but rather from a much smaller subset of it. We show that a <em>logarithmic</em> number of random field elements (in the dimension of the subspace) suffice to effect an analogous proximity test, with moreover only a <em>logarithmic</em> (multiplicative) loss in the possible prevalence of false witnesses. We discuss applications to recent noninteractive proofs based on linear codes, including <em>Brakedown</em> (CRYPTO ’23).</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300"><em>Proximity testing of linear block codes</em> is an important target of many reductions, for example throughout the literature on succinct noninteractive proofs. In the basic version of this problem, a <em>claimed</em> codeword is tested for proximity to some given fixed linear block code, by means of an interactive protocol (or more generally, an <em>interactive oracle proof</em>). The resulting protocol should accept genuine codewords with probability one; conversely, it should reject non-codewords with a probability closely related to the initial vector’s distance from the code. It should also feature efficiency—say, measured in the number of oracle queries, or rounds of interaction—which grows favorably as a function of the code’s block length (say, logarithmically).</p>

    <p class="text-gray-300">In many applications, it is necessary to test whether a list of vectors consists entirely of words which are close to the code. This task is made precise as a proximity test for the code’s <em>interleaved code</em>, defined as the set of matrices whose rows are all codewords, where the <em>distance</em> between two matrices is defined to be the number of columns at which the two matrices don’t entirely agree. Indeed, proximity tests for interleaved linear codes reside at the heart of many recent zero-knowledge proof protocols, including Ames, Hazay, Ishai and Venkitasubramaniam’s <em>Ligero</em> <em>[x1]</em> and Golovnev et al.’s <em>Brakedown</em> <em>[x11]</em>.</p>

    <p class="text-gray-300">Interleaved proximity tests are typically effected by random linear combinations. In this paradigm, the verifier samples a uniformly random coefficient vector as long as the list is, requests the corresponding combination of the list elements, and finally subjects the <em>combination</em> to a standard proximity test. (Other tests use powers of a single element, as we discuss below.) In order for this reduction to be sound, it should hold that the linear subspace generated by the list feature related <em>maximal</em> and <em>average</em> distances from the code. More precisely, it should hold that the failure of the subspace’s <em>farthest</em> element to be close to the code implies in turn that of the <em>vast majority</em> of the subspace’s elements. This property is established for general linear codes by Ligero <em>[x1]</em>. In this setting, the notion of “closeness” is given meaning by means of a so-called <em>proximity parameter</em> (whose value, as we explain below, cannot be completely arbitrary).</p>

    <p class="text-gray-300">A drawback of this approach stems from its communication and randomness complexity. Indeed, it requires that the verifier sample and send as many coefficients as there are elements in the list. Even in the random oracle model, this requirement can induce practical consequences, as it does, for example, in the setting of <em>proof composition</em>, in which the verifier’s check must necessarily be encoded into a circuit. In fact, below, we explain how this issue impacts the zero-knowledge proof protocol <em>Orion</em> of Xie, Zhang and Song <em>[x27, Fig. 4]</em>, and invalidates that protocol’s stated polylogarithmic verifier complexity.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.1 Our Contribution</p>

    <p class="text-gray-300">We introduce a batching process for proximity tests of general linear codes—that is, a reduction from the interleaved code’s proximity testing problem to the standard proximity testing problem—which consumes only logarithmically many random coefficients in the size <span class="math">m</span> of the initial list of vectors. Moreover, our procedure’s error parameter—which, by definition, upper-bounds the probability with which the verifier selects a <em>proximal</em> element despite testing a <em>non-proximal</em> subspace—exceeds by only a logarithmic multiplicative factor the “base” error parameter applicable to the standard affine parameter test (this latter parameter is given by the proximity-gap result of <em>[x1, Lem. A.1]</em>).</p>

    <p class="text-gray-300">In the particular setting of Reed–Solomon codes, a result of Ben-Sasson et al. <em>[x2, Thm. 1.5]</em> achieves a proximity test with sublinear randomness; indeed, that result uses just a <em>single</em> random parameter to test an <span class="math">m</span>-generator subspace for proximity. Its error parameter, however, exceeds by a multiplicative factor of <span class="math">m-1</span> that of the affine case. In the setting of <em>general</em> linear codes, Ben-Sasson, Kopparty, and Saraf <em>[x3, Thm. 12]</em> describe a single-parameter proximity test, which, on the other hand, incurs exponential soundness loss in the list size <span class="math">m</span>. In view of these previous results, our protocol achieves a favorable randomness–soundness tradeoff; it requires only logarithmically many parameters, and incurs only logarithmic multiplicative soundness loss. Our test is the first that we know of which achieves a practical soundness error bound, and consumes sublinear randomness, in the setting of general linear codes.</p>

    <p class="text-gray-300">An interleaved test’s <em>proximity parameter</em>, by definition, captures the degree of proximity the test detects (i.e., the closeness to the code which either all of the space or else almost none of it attains). Our result works only for proximity parameters smaller than a third of the code’s distance. We inherit this range restriction from the state-of-the-art for <em>standard</em> (i.e., linear-complexity) proximity testing. This state-of-the-art—whose proof, attributed to Roth and Zémor, appears in a recent update to Ligero <em>[x1, § A]</em> (see also Theorem 2.1 below)—establishes proximity gaps for <em>affine lines</em> for those proximity parameters smaller than a third of the code’s distance. (Various strengthenings of this result in the Reed–Solomon setting have been attained by <em>[x2]</em>.) We note that the analogue of this latter result for more general proximity parameters—say, smaller than half of the code’s distance (i.e., up to its unique decoding radius)—remains an important open problem; our work would immediately profit upon its hypothetical future resolution.</p>

    <p class="text-gray-300">Our construction entails, roughly, that the verifier, given the initial list <span class="math">u_{0},\\ldots,u_{m-1}</span> of vectors, sample logarithmically many random scalars <span class="math">r_{0},\\ldots,r_{\\log m-1}</span>, send these to the prover, and finally request the combination of the vectors <span class="math">u_{0},\\ldots,u_{m-1}</span> whose coefficient vector is given by the <em>tensor product</em> (or <em>Kronecker product</em>) expansion <span class="math">(1-r_{0},r_{0})\\otimes\\cdots\\otimes(1-r_{\\log m-1},r_{\\log m-1})</span>. The verifier then subjects this latter combination to a standard proximity test. As above, in order for this maneuver to be sound, it should hold that, for each initial list for which the subspace <span class="math">\\langle u_{0},\\ldots,u_{m-1}\\rangle</span> does <em>not</em> consist entirely of elements which are close to the code, <em>most</em> tuples <span class="math">(r_{0},\\ldots,r_{\\log m-1})\\in\\mathbb{F}_{q}^{\\log m}</span> yield tensor-products whose corresponding combinations are themselves far from the code. This is essentially what we prove in our main result, given in Section 3.</p>

    <p class="text-gray-300">Besides its attractive asymptotic profile and its simplicity, our construction is moreover strongly motivated by its applications to polynomial commitment schemes, as we now explain. Indeed, a certain approach to the problem of <em>multilinear polynomial commitment</em>—which appears to date to Ligero <em>[x1]</em>, and is explicitly isolated in the subsequent work <em>Brakedown</em> <em>[x10]</em>—makes use of a suitable error-correcting code. This scheme, which we call the <em>Brakedown multilinear polynomial commitment scheme</em>, proceeds by collating the coefficients of a given multilinear polynomial into the rows of a matrix, and then encoding this matrix row-wise (under the particular linear block code chosen for use). Crucially, if the resulting matrix is close to an <em>interleaved</em> codeword, then the committed polynomial is well-defined, and may be extracted. The Brakedown scheme thus subjects the encoded matrix to an interleaved proximity test (the “testing” phase), before finally requesting its underlying polynomial’s evaluation (the “evaluation” phase). The observation underlying our work is that if <em>our</em> batching procedure is used for the interleaved proximity test—and if the verifier’s evaluation point is <em>random</em> (a minor condition which holds in all applications we’re aware of)—then the testing and evaluation phases of the Brakedown scheme become identical, and can be consolidated. The resulting gains in simplicity and efficiency are substantial. For example, we reduce the proof size of the Brakedown scheme—<em>regardless</em> of the code used—by a factor of <span class="math">\\sqrt{2}</span>. In the special case that a linear-time-encodable code is used (as it is in Brakedown <em>[x10]</em> and Orion <em>[x27]</em>), we moreover improve both the prover’s and verifier’s respective runtimes by a factor of 2, up to lower-order terms. We provide further details in Section 4 and thorough concrete benchmarks in Section 5.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We briefly sketch our proof (see also Theorem 3.1 below). Our proof makes blackbox use of the proximity gaps result for <em>affine lines</em> due to Roth and Zémor (see Theorem 2.1 below, in which we present a thorough, and somewhat simpler, proof of this result). Essentially, we observe that the tensor product exhibits a recursive substructure, whereby, when a <span class="math">\\ell</span>-variable tensor product is used as a combination vector, the resulting combination is <em>itself</em> an interpolation, over an affine line, of two <span class="math">\\ell-1</span>-variable tensor combinations. Under the hypothesis whereby many among the initial <span class="math">\\ell</span>-tensor combinations are close to the code, we manage to deduce that many <span class="math">\\ell-1</span>-tensor combinations yield <em>lines</em> which contain large close-to-the-code subsets. Applying Theorem 2.1 to <em>these</em> lines, we conclude that both <span class="math">\\ell-1</span>-combinations themselves frequently reside close to the code, thereby “pushing down” the initial hypothesis to two half-sized instances of the problem. Inducting, we reach the base case, which is once again simply Theorem 2.1. Finally, we show that two half-dimensional subspaces which individually exhibit correlated agreement may be “reconciled”, so as to yield correlated agreement on their sum. We isolate a condition under which this reconciliation can be performed, whereby <em>both</em> <span class="math">\\ell-1</span>-tensors are <em>simultaneously</em> as <em>far</em> as is possible from the code (in that they disagree with the code everywhere outside of the correlated agreement set of the subspace in which they reside). The difficult part is to produce an appropriate such <span class="math">\\ell-1</span>-tensor (i.e., for which both combinations are far from the code). To achieve this, we bound the sizes of the “bad” sets within which the relevant <span class="math">\\ell-1</span>-tensors become spuriously close to the code; this in turn entails a union bound over the vanishing loci of <span class="math">\\ell-1</span>-variate polynomials, each bounded in size by the Schwartz–Zippel lemma. This latter technique can be viewed as a multivariate generalization of an idea which, in univariate form, appears throughout several prior works (see e.g. Roth and Zémor <em>[x1, § A]</em> and Ben-Sasson, Kopparty, and Saraf <em>[x5, Lem. 8]</em>). The idea whereby a <em>maximally far</em> element of a subspace can, in a sense, “force agreement” between words appears, implicitly, in a proof of Ben-Sasson et al. <em>[x2, § 6.3]</em>.</p>

    <p class="text-gray-300">Section 4—in which, applying our new proximity test, we describe a certain improved scheme for multilinear polynomial commitment—also presents technical difficulties. The difficult part is to show that our polynomial commitment scheme features <em>witness-extended emulation</em>. We note that emulation is trivial for codes which admit efficient <em>decoders</em>, like the Reed–Solomon codes used by Ligero <em>[x1, § A]</em>; we, however, treat general codes. When efficient decoding is not assumed, emulation becomes much more difficult (and requires rewinding). Indeed, our scheme imposes somewhat sophisticated demands on the emulator, which must collect a sequence of passing proximity tests with <em>linearly independent</em> combination vectors. We introduce a new emulation strategy, departing significantly from Brakedown’s. Our emulator is actually quite simple, and is inspired by that of Bootle et al.’s classic <em>forking lemma</em> <em>[Boo+16, Lem. 1]</em>. Its analysis, however, is challenging, and introduces a handful of new ideas. The main technical issue is that a malicious prover could, in principle, act in such a way as to thwart the emulator, by, say, outputting successful proofs with vastly higher probability when the verifier’s challenge vector yields a tensor belonging to some proper subspace. In particular, its <em>conditional</em> distribution of proofs—that is, these proofs’ distribution, conditioned on success—may depart radically from uniform, and may tend towards certain events which cause the emulator to fail. Our idea is to show that if the prover’s success probability is sufficiently high—specifically, higher than the <em>square root</em> of that of the failure events, a quantity which, though likewise negligible, decays much more slowly—then this conditional distribution necessarily concentrates away from the failure events. The idea is to “split the difference” in the exponent (the square root operation has precisely the effect of <em>halving</em> the superlogarithmic decay function implicit in the failure probability’s exponent). This square root is overwhelmingly higher than the failure probability itself; on the other hand, it’s still negligible. We compare our proof strategy to Brakedown’s <em>[Gol+23, Lem. 3]</em> at the end of Subsection 4.2 below. We identify a handful of issues in that proof. While we suggest possible remediation strategies for certain among these issues, we contend that our approach represents a compelling alternative to Brakedown’s. Indeed, our emulator admits a much simpler <em>description</em> than Brakedown’s does. While the analysis of its success probability is, on the other hand, undeniably involved, we believe that it is nonetheless more natural and checkable than is that demanded by Brakedown’s emulator.</p>

    <p class="text-gray-300">In Subsection 4.3 below, we describe how our technique improves the efficiency of the Ligero-style scheme. Indeed, we exhibit a <span class="math">\\sqrt{2}</span>-factor improvement to that protocol’s proof size, up to lower-order terms, for each input polynomial size. In the setting of a linear-time encodable code, we also improve the protocol’s prover and verifier time by at least twofold, up to lower-order terms, for each input polynomial size. We benchmark our scheme concretely in Section 5.</p>

    <p class="text-gray-300">1.2 Prior Work</p>

    <p class="text-gray-300">Ideas related to ours appear throughout several prior works. Brakedown <em>[x10]</em> identifies <em>Ligero</em> <em>[x2]</em> as the progenitor of many of its ideas, though the latter work treats only <em>arithmetic circuits</em>, and doesn’t present a polynomial commitment scheme <em>per se</em>.</p>

    <p class="text-gray-300">On the other hand, Ligero appears to have initiated the study of proximity gaps; we use extensively that work’s proximity gap result for affine spaces <em>[x2, § A]</em>. In fact, the proof of that result resides in partial form across the two stated results <em>[x2, Lem. 4.3]</em> and <em>[x2, Lem. A.1]</em>. The former is due to Ames, Hazay, Ishai and Venkitasubramaniam, and appears in the original, 2017 conference version of that work; the latter, on the other hand, is attributed by the authors to Roth and Zémor, and was added in a subsequent update. We observe that the former result—that is, <em>[x2, Lem. 4.3]</em>—in fact already contains most of the techniques required to make the proof go through. Roth and Zémor’s <em>[x2, Lem. A.1]</em>, on the other hand, introduces the idea of replacing both generators of the line with elements which are close to the code (though in an unnecessarily complicated form, in which the elements are assumed moreover to reside close to the origin). We synthesize and simplify these various ideas in our treatment below, given in Theorem 2.1.</p>

    <p class="text-gray-300">A further conceptual predecessor to Brakedown <em>[x10]</em> appears in the form of Bootle et al. <em>[Boo+16, § 3]</em>; that work presents a <em>univariate</em> polynomial commitment scheme, which, nonetheless, arranges the polynomial’s coefficients into a square matrix, and commits to its rows. That work doesn’t use an error-correcting code <em>or</em> Merkle hashing, and admits square-root-sized—as opposed to constant-sized—commitments. Moreover, it doesn’t invoke a proximity test at all, so that our topic is inapplicable to it.</p>

    <p class="text-gray-300">The work Bootle, Chiesa and Groth <em>[x5]</em> bears some resemblance to ours, though differs fundamentally. That work presents a protocol for R1CS in the <em>tensor IOP</em> model, as well as a compiler from tensor IOPs to standard IOPs. The latter compiler invokes a proximity test for so-called <em>tensor codes</em>. In that protocol, over the course of multiple rounds, the prover repeatedly “folds” an initial tensor, using verifier-supplied randomness, and, in each round, sends the resulting intermediate tensor to the verifier. While the security proof of that protocol invokes the proximity-gaps result <em>[x2, § A]</em>, that result is applied “fold-wise” to the prover’s successive intermediate tensors. That proof’s structure thus differs importantly from ours; our prover performs <span class="math">\\log m</span> folds “in one shot”, sending only the final result, and our protocol is <em>constant-round</em>. In a sense, our proof of soundness must thus “do more work” than that protocol’s, since it lacks access to the prover’s intermediate folds. (The verifier of <em>[x5, p. 30]</em>, by contrast, has access to these intermediate folds, and can check them “incrementally”.)</p>

    <p class="text-gray-300">Our polynomial commitment scheme, again, exploits the setting in which the verifier’s point query is <em>random</em>. The insight whereby a polynomial commitment scheme suitable only for <em>random</em> points can be made more efficient than one suitable for <em>arbitrary</em> points appears to date to the work <em>Marlin</em> of Chiesa et al. <em>[Chi+20, § 6]</em>, though that work treats univariate polynomials. The work <em>Vortex</em> of Belling and Soleimanian <em>[x11]</em> also makes this observation, in, moreover, the setting of a commitment scheme involving a proximity test, though that work’s polynomials are again univariate. Indeed, Vortex observes that—in the random setting—its scheme’s <em>testing</em> and <em>evaluation</em> phases can be merged. Puzzlingly, Vortex <em>[x11, § 6.2]</em> cites <em>Brakedown</em> for this observation; beyond the fact that Brakedown’s polynomials are multilinear, we have moreover failed to find a remark to this effect in Brakedown. Separately, Vortex claims that the soundness of their merged test is proven by <em>[x5]</em>. As noted above, the result proved by <em>[x5, p. 30]</em> is incomparable to that required to merge Brakedown’s—or Vortex’s—testing and evaluation phases. Rather, in the <em>univariate</em> setting, the soundness of this merge is, at least in the special case of Reed–Solomon codes (which Vortex uses), established in fact by <em>[Ben+23, Thm. 1.5]</em>. In the multilinear setting, the soundness of the merged procedure is precisely what we prove in this paper.</p>

    <p class="text-gray-300">Brakedown <em>[x10]</em> serves as the most direct inspiration for this work. That work isolates the “Ligero-style” multilinear polynomial commitment scheme, citing both <em>[x2]</em> and <em>[x5]</em>. We also take a degree of inspiration from the proof strategy of <em>[x10, § 4]</em>, though we depart from that work’s approach.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.3 Technical Overview</h3>

    <p class="text-gray-300">In this subsection, we discuss in further detail how our proximity gap result allows a certain well-known polynomial commitment scheme to be simplified and improved. Several recent constructions of succinct proofs—such as Brakedown <em>[x10]</em>, Orion <em>[x27]</em>, and Vortex <em>[x11]</em>—make use of a particular subprotocol for multilinear polynomial commitment, which we call the *Brakedown multilinear polynomial commit</p>

    <p class="text-gray-300">ment scheme. The Brakedown scheme—like polynomial commitment schemes in general—allows the prover to commit to a polynomial, and later, given an evaluation point supplied by the verifier, to evaluate the polynomial at the given point, and finally to produce a proof attesting to its evaluation’s correctness.</p>

    <p class="text-gray-300">We observe that—in all of the above protocols—the verifier evaluates each committed polynomial only a <em>random</em> point, as opposed to at an <em>arbitrary</em> point. This latter fact is itself explained by the <em>sum-check</em> reduction, as we briefly explain. That protocol reduces the problem of obtaining the <em>sum</em> of a multivariate polynomial’s respective evaluations over the unit cube to the problem of evaluating the polynomial <em>once</em> at a single point in its domain, which, crucially, is <em>random</em> (sampled throughout the course of the sum-check protocol). We refer to <em>[x29, § 3]</em> for further details. In other words, these succinct proof protocols employ a tool which is more powerful than necessary. Capitalizing on this observation, we isolate a special sort of multilinear polynomial commitment scheme, suitable only for <em>random</em> queries (see Definition 4.3). Our restricted notion serves as a drop-in replacement for the standard scheme in all of the above applications.</p>

    <p class="text-gray-300">We moreover introduce a new commitment scheme—suitable only for random samplers—which significantly simplifies Brakedown’s protocol, as we now explain. We observe that, in that variant of the Brakedown scheme which uses <em>our</em> batching procedure in lieu of the standard, linear-complexity proximity test (and where, once again, we assume that the verifier’s evaluation point is random), the resulting “testing” and “evaluation” phases become identical, and can be consolidated. This measure yields gains in both simplicity and efficiency. Indeed, our approach reduces the Brakedown commitment scheme’s proof size by a <span class="math">\\sqrt{2}</span> factor, and also significantly improves the prover’s and verifier’s concrete computational costs in the random-evaluation setting.</p>

    <p class="text-gray-300">This observation—i.e., whereby a polynomial commitment scheme suitable only for <em>random</em> evaluation points may be made more efficient than one suitable for <em>arbitrary</em> evaluation points—dates back to Chiesa et al.’s <em>Marlin</em> <em>[x10, § 6]</em>, in which the polynomial commitment schemes at hand are proven secure only for so-called “admissible query samplers” (we note, separately, that that work treats commitments to arbitrary-degree, and <em>univariate</em>, polynomials). In that setting, a <em>query sampler</em> is, by definition, an efficient algorithm which determines where the polynomials at hand are to be evaluated; a query sampler is said to be <em>admissible</em> if (roughly) it necessarily requests that each polynomial at hand be evaluated at least once on some point drawn uniformly from a superpolynomially-sized set (with additional queries also permissible). In Marlin’s setting, a <em>general</em> query sampler may always be bootstrapped into an <em>admissible</em> one, by means of the concatenation of additional random queries; this transformation, however, imposes obvious efficiency costs. If the <em>desired</em> query sampler, on the other hand, is admissible to begin with—at is in their applications—then this extra work can be saved. In the language of Marlin, we prove, essentially, that our scheme is secure <em>provided</em> the query sampler is admissible (we treat, however, a restricted notion of “admissibility”, for notational convenience, as we discuss below). Put differently, we apply an insight already independently attained by Marlin to the setting of multilinear commitments.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">The case of <em>Orion</em>.</h5>

    <p class="text-gray-300">Beyond its efficiency advantages, our approach moreover resolves a more serious obstacle in the setting of <em>proof composition</em>. Indeed, in typical applications—which assume the random oracle model—the verifier need not send its combination coefficients <em>explicitly</em> to the prover, as both parties may generate them locally by the means of queries to the random oracle. The generation and transmission of these coefficients, in this setting, thus do <em>not</em> impact the protocol’s verifier or communication complexity. In contrast, in the setting of proof composition—in which the verifier’s check is necessarily encoded into a circuit—the random oracle introduces problems. For one, it must be instantiated concretely, so that it ceases to be a (true) random oracle. This fact may affect the security analysis of the inner protocol. Separately, hash function evaluations are expensive to encode in circuits. To evade these issues, many protocols extract the inner verifier’s generation of the relevant random coefficients from the relevant circuit, and stipulate that the outer verifier instead populate them directly, as public inputs to the <em>outer</em> proof.</p>

    <p class="text-gray-300">This latter strategy may impact the computational complexity of the outer verifier, particularly when, say, the inner verifier uses a proximity test in the style of <em>[x1, § A]</em> or <em>[x1, Thm. 1.6]</em> (with <em>linear</em> randomness complexity in the list size). For example, the <em>Orion</em> zero-knowledge proof protocol of Xie, Zhang and Song <em>[x32, 20]</em> proves satisfiability of a size-<span class="math">N</span> arithmetic circuit by recursively invoking a <em>linear-randomness</em> batched proximity test on a list of <span class="math">\\Theta(\\sqrt{N})</span> vectors, and moreover delegates the randomness-generation required by this latter task to the outermost verifier. This strategy makes the computational complexity of its outermost verifier <span class="math">\\Omega(\\sqrt{N})</span>, and invalidates its stated <span class="math">O(\\log^{2}N)</span> complexity.</p>

    <p class="text-gray-300">Indeed, we explain this issue in detail, using the notation of Orion. In line 7 of <em>[x21, Prot. 4]</em>, the <em>outer</em> prover “receives a random vector <span class="math">\\gamma_{0}\\in\\mathbb{F}^{k}</span> from the verifier”; here, <span class="math">k=\\Theta(\\sqrt{N})</span>. While the outer prover may certainly use Fiat–Shamir to generate <span class="math">\\gamma_{0}</span> locally (i.e., from the statement and transcript), this is beside the point, since the outer <em>verifier</em> must, in this setting, do the same, and supply <span class="math">\\gamma_{0}</span> as a public input to the outer proof in line 18 of <em>[x21, Prot. 4]</em>. Alternatively, the outer verifier could demand that the outer prover <em>prove</em> that it correctly generated <span class="math">\\gamma_{0}\\in\\mathbb{F}^{k}</span> from the transcript during the course of its proof (i.e., that it applied Fiat–Shamir correctly). This, however, would prohibitively increase the outer prover’s cost. Orion does not take this latter measure; its verifier’s complexity is thus actually <span class="math">\\Omega(\\sqrt{N})</span>, contrary to its claims.</p>

    <p class="text-gray-300">The approach whereby <em>single-parameter</em> batching—i.e., using powers of a single random parameter—is instead used does not resolve the issue. Indeed, that approach would prohibitively increase the protocol’s soundness error, by a factor <em>linear</em> in the list length <span class="math">\\Theta(\\sqrt{N})</span> in the Reed–Solomon case <em>[Ben+23, Thm. 1.5]</em>, and—what is much worse—by an <em>exponential</em> factor in the case of general codes <em>[x1, Thm. 12]</em>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Our protocol.</h4>

    <p class="text-gray-300">We now sketch slightly more thoroughly how our batching procedure allows the Brakedown multilinear polynomial commitment scheme to be simplified (in the random-evaluation setting). We recall that the Brakedown scheme begins by collating the <span class="math">m^{2}</span> coefficients of a given multilinear polynomial in <span class="math">2\\cdot\\log m</span> variables (say), expressed moreover with respect to the Lagrange basis over the unit cube <span class="math">\\{0,1\\}^{2\\cdot\\log m}</span>, into the rows of an <span class="math">m\\times m</span> matrix. This matrix is then encoded row-wise, using some fixed linear block code; the resulting matrix is finally committed to. (In Ligero <em>[x1]</em>, as well as in <em>Shockwave</em> <em>[Gol+23]</em>, the Reed–Solomon code is used; in <em>Brakedown</em> <em>[Gol+23, § 4.2]</em>, a newly introduced <em>linear-time-encodable</em> code is used instead.) Crucially, if the committed matrix is close to an <em>interleaved codeword</em>, then the committed polynomial is well-defined, and may be extracted.</p>

    <p class="text-gray-300">The Brakedown-style scheme thus proceeds in two phases. In the <em>testing</em> phase, the verifier applies an interleaved proximity test to the committed matrix. Specifically, the verifier reduces the interleaved proximity problem given by the initial matrix to a standard proximity testing problem, by means of a random combination of its rows. It then solves the latter by directly requesting the message underlying the combination (which is well-defined if the prover is honest), encoding the supplied message, and finally probabilistically testing it for equality with the combination by means of queries at random columns.</p>

    <p class="text-gray-300">Having established the matrix’s proximity to the interleaved code, the verifier initiates the <em>evaluation</em> phase, in which the committed polynomial is evaluated at the verifier’s chosen point. In light of the of committed polynomial’s assumed structure, this latter phase may be effected by means of a <em>further</em> combination of the committed rows (and a further proximity test), where—this time—the coefficient vector is a tensor. Indeed, it is straightforward to check that for each multilinear polynomial <span class="math">t(X_{0},\\cdots,X_{2\\cdot\\log m-1})\\in\\mathbb{F}_{q}[X_{0},\\cdots,X_{2\\cdot\\log m-1}]</span> and each point <span class="math">(r_{0},\\ldots,r_{2\\cdot\\log m-1})\\in\\mathbb{F}_{q}^{2\\cdot\\log m}</span>, we have the equality:</p>

    <p class="text-gray-300">\\[ t(r_{0},\\ldots,r_{2\\cdot\\log m-1})=\\Big{[}\\quad\\bigotimes_{i=\\log m}^{2\\cdot\\log m-1}(1-r_{i},r_{i})\\quad\\Big{]}\\cdot\\begin{bmatrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\begin{matrix}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{\\mbox{}}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{\\mbox{}}\\end{1}\\end{\\mbox{}}\\end{1}\\end{\\mbox{}}\\end{1}\\end{\\mbox{}}\\end{\\mbox{}}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\end{1}\\right, \\]</p>

    <p class="text-gray-300">where both vectors above contain <em>tensor products</em> in the sense of Section 2 below, and where the length-<span class="math">m</span> rows <span class="math">t_{0},\\ldots,t_{m-1}</span> contain <span class="math">t</span>’s collated Lagrange coefficients. It follows that if the verifier requests the message <span class="math">t^{\\prime}\\coloneqq\\bigotimes_{i=\\log m}^{2\\cdot\\log m-1}(1-r_{i},r_{i})\\cdot(t_{i})_{i=0}^{m-1}</span> during the evaluation phase, then it may calculate <span class="math">t</span>’s value at <span class="math">(r_{0},\\ldots,r_{2\\cdot\\log m-1})</span> by means of the further local calculation <span class="math">t^{\\prime}\\cdot\\bigotimes_{i=0}^{\\log m-1}(1-r_{i},r_{i})=t(r_{0},\\ldots,r_{2\\cdot\\log m-1})</span>. If the point <span class="math">(r_{0},\\ldots,r_{2\\cdot\\log m-1})\\in\\mathbb{F}_{q}^{2\\cdot\\log m}</span> is random, then this latter evaluation procedure becomes identical to our batched proximity test, and can supplant the testing phase altogether.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Acknowledgements.</h4>

    <p class="text-gray-300">We would like to thank Benedikt Bünz for suggesting to us that the Brakedown scheme’s testing and evaluation phases could be combined, given a soundness proof for tensor product-based batching. We would like to thank Pratyush Mishra for explaining certain aspects of Marlin. We would like to wholeheartedly thank Gyumin Roh for catching a flaw in an earlier version of our emulator’s Merkle-extraction procedure, as well as for ably assisting our efforts to rectify that flaw.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Background and Notation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We generally adopt the notation of <em>[x1]</em> and <em>[Ben+23]</em>. A <em>code</em> of length <span class="math">n</span> over the alphabet <span class="math">\\Sigma</span> is a subset of <span class="math">\\Sigma^{n}</span>. We write <span class="math">q</span> for a prime power, <span class="math">\\mathbb{F}_{q}</span> for the finite field of order <span class="math">q</span>, and <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> for a <em>linear</em> <span class="math">[n,k,d]</span>-code over <span class="math">\\mathbb{F}_{q}</span>. We write <span class="math">w(u)</span> for the Hamming weight of a vector, <span class="math">d</span> for the Hamming distance, and <span class="math">d(u,C)\\coloneqq\\min_{v\\in C}d(u,v)</span> for the distance from a point to a code. We write $B(u,e)\\coloneqq\\left\\{y\\in\\mathbb{F}_{q}^{n}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right.d(u,y)\\leq e\\right\\}<span class="math"> for the <em>Hamming ball</em> of radius </span>e\\geq 0<span class="math"> centered at </span>u\\in\\mathbb{F}_{q}^{n}<span class="math">. The unique decoding radius of an </span>[n,k,d]<span class="math">-code </span>C<span class="math"> is </span>\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor<span class="math">; in particular, for each </span>u\\in\\mathbb{F}_{q}^{n}<span class="math">, we have that </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\left(u,\\left\\lfloor\\frac{d-1}{2}\\right\\rfloor\\right)\\cap C\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math">. We finally write </span>\\Delta(u,v)\\subset\\{0,\\ldots,n-1\\}<span class="math"> for the <em>disagreement set</em> between </span>u<span class="math"> and a codeword </span>v<span class="math">. The <em>puncturing</em> of a code </span>C<span class="math"> at an index set </span>M\\subset\\{0,\\ldots,n-1\\}<span class="math"> is the projection of </span>C<span class="math"> onto the set of components indexed </span>\\{0,\\ldots,n-1\\}\\setminus M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a linear code <span class="math">C\\subset\\mathbb{F}_{q}^{n}</span> and an integer <span class="math">m\\geq 1</span>, we have its corresponding <em><span class="math">m</span>-fold interleaved code</em>, defined as the subset <span class="math">C^{m}\\subset\\left(\\mathbb{F}_{q}^{n}\\right)^{m}\\cong\\left(\\mathbb{F}_{q}^{m}\\right)^{n}</span>. We understand this latter set as a length-<span class="math">n</span> block code over the alphabet <span class="math">\\mathbb{F}_{q}^{m}</span>. In particular, its elements are naturally identified with matrices in <span class="math">\\mathbb{F}_{q}^{m\\times n}</span>, where two such matrices <em>differ</em> at a column if they differ at <em>any</em> of that column’s components. We write matrices <span class="math">(u_{i})_{i=0}^{m-1}\\in\\mathbb{F}_{q}^{m\\times n}</span> row-wise. That a matrix <span class="math">(u_{i})_{i=0}^{m-1}\\in\\mathbb{F}_{q}^{m\\times n}</span> is within distance <span class="math">e</span> to the code <span class="math">C^{m}</span>—in which event we write <span class="math">d^{m}\\Big{(}(u_{i})_{i=0}^{m-1},C^{m}\\Big{)}\\leq e</span>—entails precisely that there exists a subset <span class="math">D\\coloneqq\\Delta^{m}\\Big{(}(u_{i})_{i=0}^{m-1},C^{m}\\Big{)}</span>, say, of <span class="math">\\{0,\\ldots,n-1\\}</span>, of size at most <span class="math">e</span>, for which, for each <span class="math">i\\in\\{0,\\ldots,m-1\\}</span>, the row <span class="math">u_{i}</span> admits a codeword <span class="math">v_{i}\\in C</span> for which $\\left.u_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{0,\\ldots,n-1\\}\\setminus D}=\\left.v_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{0,\\ldots,n-1\\}\\setminus D}<span class="math">. We emphasize that the subset </span>D\\subset\\{0,\\ldots,n-1\\}<span class="math"> is <em>fixed</em>, and does not vary as the row-index </span>i\\in\\{0,\\ldots,m-1\\}<span class="math"> varies. In this circumstance, following the terminology of <em>[Ben+23]</em>, we say that the vectors </span>(u_{i})_{i=0}^{m-1}<span class="math"> feature <em>correlated agreement</em> outside of the set </span>D<span class="math">, or that they feature </span>e<span class="math">-<em>correlated agreement</em>. We note that the condition whereby the vectors </span>(u_{i})_{i=0}^{m-1}<span class="math"> feature </span>e<span class="math">-correlated agreement with </span>C^{m}<span class="math"> implies <em>a fortiori</em> that every element in </span>(u_{i})_{i=0}^{m-1}<span class="math">’s row-span is itself within distance at most </span>e<span class="math"> from </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define the <em>tensor product</em> of vectors inductively on length-two vectors of the form <span class="math">(1-r,r)</span>, where <span class="math">r\\in\\mathbb{F}_{q}</span>; that is, we stipulate that $(s_{0},\\ldots,s_{m/2-1})\\otimes(1-r,r)\\coloneqq(1-r)\\cdot\\big{(}s_{0},\\ldots,s_{m/2-1}\\big{)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r\\cdot\\big{(}s_{0},\\ldots,s_{m/2-1}\\big{)}<span class="math">. In particular, we thereby give meaning to iterated expressions of the form </span>(1-r_{0},r_{0})\\otimes\\cdots\\otimes(1-r_{\\ell-1},r_{\\ell-1})<span class="math"> by left-association (the natural extension of this definition to operands of arbitrary length <em>is</em> associative). We note that the tensor product operation is <em>not</em> commutative. For notational purposes, we use the abbreviation </span>\\bigotimes_{i=0}^{\\ell-1}(1-r_{i},r_{i})<span class="math"> to refer to the above expression (where the left-to-right order is again understood), which is a length-</span>2^{\\ell}<span class="math"> vector. We note that this vector in fact consists precisely of the evaluations at the fixed point </span>(r_{0},\\ldots,r_{\\ell-1})\\in\\mathbb{F}_{q}^{\\ell}<span class="math"> of the </span>2^{\\ell}<span class="math"> <em>Lagrange basis polynomials</em> in </span>\\mathbb{F}_{q}[X_{0},\\ldots,X_{\\ell-1}]<span class="math">, taken with respect to the evaluation set </span>\\{0,1\\}^{\\ell}\\subset\\mathbb{F}_{q}^{\\ell}<span class="math">. Indeed, this latter basis is precisely the list of polynomials </span>\\bigotimes_{i=0}^{\\ell-1}(1-X_{i},X_{i})<span class="math">. We note that these polynomials are </span>\\mathbb{F}_{q}<span class="math">-linearly independent elements of </span>\\mathbb{F}_{q}[X_{0},\\ldots,X_{\\ell-1}]<span class="math">, where we view the latter ring as an </span>\\mathbb{F}_{q}$-vector space.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The probability distributions we consider are exclusively uniform over sets of the form <span class="math">\\mathbb{F}_{q}^{\\ell}</span>. We write <span class="math">\\mu(R)</span> for the probability mass of the subset <span class="math">R\\subset\\mathbb{F}_{q}^{\\ell}</span>; that is, $\\mu(R)\\coloneqq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{q^{\\ell}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Two distribution ensembles <span class="math">\\{\\mathcal{Y}_{0}(a,\\lambda)\\}_{a\\in\\{0,1\\}^{<em>},\\lambda\\in\\mathbb{N}}</span> and <span class="math">\\{\\mathcal{Y}_{1}(a,\\lambda)\\}_{a\\in\\{0,1\\}^{</em>},\\lambda\\in\\mathbb{N}}</span>, with values in <span class="math">\\{0,1\\}</span>, say, are <em>statistically close</em> if there exists a negligible function <span class="math">\\mathsf{negl}(\\lambda)</span> for which, for each <span class="math">a\\in\\{0,1\\}^{*}</span> and each <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{Y}_{0}(a,\\lambda)=1]-\\Pr[\\mathcal{Y}_{1}(a,\\lambda)=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that the negligible function <span class="math">\\mathsf{negl}</span> must suffice simultaneously for <em>each possible</em> <span class="math">a\\in\\{0,1\\}^{<em>}</span>. For details on indistinguishability and further context, we refer to Lindell </em>[x10]*.</p>

    <p class="text-gray-300">We recall certain notions related to Merkle trees. We fix parameters <span class="math">m</span> and <span class="math">n</span>, which we assume to be powers of <span class="math">2</span>; throughout, we write <span class="math">(u_{i})_{i=0}^{m-1}</span> for an <span class="math">m\\times n</span> matrix with entries in <span class="math">\\mathbb{F}_{q}</span>. For each <span class="math">j\\in\\{0,\\ldots,n-1\\}</span>, we write <span class="math">(u_{i,j})_{i=0}^{m-1}</span> for the <span class="math">j^{\\text{th}}</span> column of <span class="math">(u_{i})_{i=0}^{m-1}</span>.</p>

    <p class="text-gray-300">For our purposes, a <em>Merkle tree</em> on the data <span class="math">(u_{i})_{i=0}^{m-1}</span> is a tree whose leaves take the form <span class="math">H\\Big{(}(u_{i,j})_{i=0}^{m-1}\\Big{)}</span>, for <span class="math">j\\in\\{0,\\ldots,n-1\\}</span>, and where each internal node is the hash of the concatenation of its children. A <em>Merkle opening</em> or <em>Merkle path</em> is the data of a column <span class="math">(u_{i,j})_{i=0}^{m-1}</span>, for some <span class="math">j\\in\\{0,\\ldots,n-1\\}</span>, together with the respective siblings of those nodes contained in the path from the <span class="math">j^{\\text{th}}</span> leaf to the root. For each <span class="math">j\\in\\{0,\\ldots,n-1\\}</span>, the Merkle opening <span class="math">\\Big{(}(u_{i,j})_{i=0}^{m-1},h_{0},\\ldots,h_{\\log n-1}\\Big{)}</span> is <em>valid</em> against the Merkle root <span class="math">c</span> if the following algorithm returns true:</p>

    <p class="text-gray-300">1: procedure VALIDATEMERKLEOPENING  <span class="math">\\left(j,(u_{i,j})_{i = 0}^{m - 1},h_0,\\ldots ,h_{\\log n - 1},c\\right)</span> 2: initialize  <span class="math">h \\coloneqq H\\left((u_i)_{i=0}^{m-1}\\right)</span> . 3: write  <span class="math">j = (j_{\\log n - 1}, \\ldots, j_0)</span>  for the bits of  <span class="math">j \\in \\{0, \\ldots, n - 1\\}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4: for  <span class="math">i \\in \\{0, \\dots, \\log n - 1\\}</span>  do overwrite  $h := H(h \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_i)<span class="math">  if  </span>j_i = 0<span class="math">  else  </span>H(h_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5: return  <span class="math">c \\stackrel{?}{=} h</span> .</p>

    <p class="text-gray-300">Figure 1 below illustrates a Merkle opening. We shade in grey the actual contents of the Merkle opening (i.e., the data it explicitly supplies). We moreover enclose in a solid border those nodes whose values are "determined" by the Merkle opening. Figure 2 below depicts a collection of distinct Merkle openings. In that figure, we shade in grey those nodes explicitly included in some Merkle path; moreover, as before, we enclose in a solid line those nodes collectively determined by the tree's Merkle paths.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A Merkle path.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: A collection of Merkle openings.</p>

    <p class="text-gray-300">We now recapitulate a key result due to Ames, Hazay, Ishai and Venkitasubramaniam [AHIV23, Lem. 4.3] and Roth and Zémor [AHIV23, § A]. For completeness, we record a thorough proof of this result. We closely follow [AHIV23, Lem. 4.3] and [AHIV23, § A], though we manage to significantly simplify those proofs.</p>

    <p class="text-gray-300">Theorem 2.1 (Roth-Zémor [AHIV23, § A]). Fix an arbitrary  <span class="math">[n,k,d]</span> -code  <span class="math">C\\subset \\mathbb{F}_q^n</span> , and a proximity parameter  <span class="math">e\\in \\{0,\\ldots ,\\left\\lfloor \\frac{d - 1}{3}\\right\\rfloor \\}</span> . If given elements  <span class="math">u_{0}</span>  and  <span class="math">u_{1}</span>  of  <span class="math">\\mathbb{F}_q^n</span>  satisfy</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {r \\in \\mathbb {F} _ {q}} [ d ((1 - r) \\cdot u _ {0} + r \\cdot u _ {1}, C) \\leq e ] &amp;gt; \\frac {e + 1}{q},</span></div>

    <p class="text-gray-300">then  <span class="math">d^2\\left((u_i)_{i = 0}^1,C^2\\right)\\leq e</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We write  <span class="math">R^{*} \\coloneqq \\{r \\in \\mathbb{F}_{q} \\mid d((1 - r) \\cdot u_{0} + r \\cdot u_{1}, C) \\leq e\\}</span> . The theorem's hypothesis clearly implies that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; e + 1 \\geq 1<span class="math"> . We thus write  </span>r_{0}^{<em>}<span class="math">  and  </span>r_{1}^{</em>}<span class="math">  for two distinct elements of  </span>R^{<em>}<span class="math"> . Clearly, the elements  </span>(1 - r_{0}^{</em>}) \\cdot u_{0} + r_{0}^{<em>} \\cdot u_{1}<span class="math">  and  </span>(1 - r_{1}^{</em>}) \\cdot u_{0} + r_{1}^{<em>} \\cdot u_{1}<span class="math">  span the same affine line  </span>u_{0}<span class="math">  and  </span>u_{1}<span class="math">  do. It thus suffices to prove the theorem after performing the replacements  </span>u_{0} \\coloneqq (1 - r_{0}^{</em>}) \\cdot u_{0} + r_{0}^{<em>} \\cdot u_{1}<span class="math">  and  </span>u_{1} \\coloneqq (1 - r_{1}^{</em>}) \\cdot u_{0} + r_{1}^{*} \\cdot u_{1}<span class="math"> . In particular, we may safely assume without loss of generality that  </span>d(u_{0}, C) \\leq e<span class="math">  and  </span>d(u_{1}, C) \\leq e<span class="math">  hold. We write  </span>v_{0}<span class="math">  and  </span>v_{1}<span class="math">  for codewords for which  </span>d(u_{0}, v_{0}) \\leq e<span class="math">  and  </span>d(u_{1}, v_{1}) \\leq e$ , respectively, hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We suppose for contradiction that the conclusion of the theorem is false, and that  <span class="math">d^{2}\\Big((u_{i})_{i = 0}^{1},C^{2}\\Big) &amp;gt; e</span> . We note that  <span class="math">(u_{i})_{i = 0}^{1}</span>  clearly has correlated agreement with  <span class="math">C</span>  outside of  <span class="math">\\Delta (u_0,v_0)\\cup \\Delta (u_1,v_1)</span> ; our supposition thus implies in particular that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta (u_0,v_0)\\cup \\Delta (u_1,v_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; e<span class="math"> . For each  </span>j\\in \\Delta (u_0,v_0)\\cup \\Delta (u_1,v_1)$ , we write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R _ {j} := \\left\\{r \\in \\mathbb {F} _ {q} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">((1 - r) \\cdot u _ {0} + r \\cdot u _ {1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\{j \\}} = ((1 - r) \\cdot v _ {0} + r \\cdot v _ {1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\{j \\}} \\right. \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for the set of parameters <span class="math">r \\in \\mathbb{F}_q</span> at which <span class="math">(1 - r) \\cdot u_0 + r \\cdot u_1</span> and <span class="math">(1 - r) \\cdot v_0 + r \\cdot v_1</span> “spuriously agree” at the index <span class="math">j</span>. For each <span class="math">j \\in \\Delta(u_0, v_0) \\cup \\Delta(u_1, v_1)</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math">, as </span>R_j \\subset \\mathbb{F}_q<span class="math"> is the zero locus of a nonzero affine-linear function. By the guarantees </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_0, v_0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_1, v_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e<span class="math">, and because </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_0, v_0) \\cup \\Delta(u_1, v_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; e<span class="math"> (by the above argument), applying the identity </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_0, v_0) \\cup \\Delta(u_1, v_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_0, v_0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_1, v_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_0, v_0) \\cap \\Delta(u_1, v_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we conclude that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u_0, v_0) \\cap \\Delta(u_1, v_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; e<span class="math">. We finally observe that for each </span>j<span class="math"> outside of this intersection, the set </span>R_j<span class="math"> is either </span>\\{0\\}<span class="math"> or </span>\\{1\\}<span class="math">. Specifically, for </span>j \\in \\Delta(u_0, v_0) \\setminus \\Delta(u_1, v_1)<span class="math">, </span>R_j = \\{1\\}<span class="math">, while for </span>j \\in \\Delta(u_1, v_1) \\setminus \\Delta(u_0, v_0)<span class="math">, </span>R_j = \\{0\\}<span class="math">. It thus follows that </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bigcup_{j \\in \\Delta(u_0, v_0) \\cup \\Delta(u_1, v_1)} R_j\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e + 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We fix an element <span class="math">r^<em> \\in R^</em></span>, and write <span class="math">v^<em> \\in C</span>, say, for the (uniquely determined) codeword for which <span class="math">d((1 - r^</em>) \\cdot u_0 + r^<em> \\cdot u_1, v^</em>) \\leq e</span>. We note that <span class="math">d((1 - r^<em>) \\cdot u_0 + r^</em> \\cdot u_1, (1 - r^<em>) \\cdot v_0 + r^</em> \\cdot v_1) \\leq 2 \\cdot e</span>, since these two vectors agree outside of <span class="math">\\Delta(u_0, v_0) \\cup \\Delta(u_1, v_1)</span>. By the triangle inequality, we thus have that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} d \\left(\\left(1 - r ^ {*}\\right) \\cdot v _ {0} + r ^ {*} \\cdot v _ {1}, v ^ {*}\\right) \\leq d \\left(\\left(1 - r ^ {*}\\right) \\cdot v _ {0} + r ^ {*} \\cdot v _ {1}, \\left(1 - r ^ {*}\\right) \\cdot u _ {0} + r ^ {*} \\cdot u _ {1}\\right) + d \\left(\\left(1 - r ^ {*}\\right) \\cdot u _ {0} + r ^ {*} \\cdot u _ {1}, v ^ {*}\\right) \\\\ \\leq 3 \\cdot e \\\\ &amp;lt; d, \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">so that <span class="math">v^{<em>} = (1 - r^{</em>}) \\cdot v_{0} + r^{<em>} \\cdot v_{1}</span>, and in fact <span class="math">d((1 - r^{</em>}) \\cdot u_{0} + r^{<em>} \\cdot u_{1}, (1 - r^{</em>}) \\cdot v_{0} + r^{<em>} \\cdot v_{1}) \\leq e</span> holds. We conclude that <span class="math">r^{</em>} \\in \\bigcup_{j \\in \\Delta(u_{0}, v_{0}) \\cup \\Delta(u_{1}, v_{1})} R_{j}</span>. It follows in turn that <span class="math">R^{*} \\subset \\bigcup_{j \\in \\Delta(u_{0}, v_{0}) \\cup \\Delta(u_{1}, v_{1})} R_{j}</span>, so that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e + 1<span class="math"> and </span>\\operatorname{Pr}_{r \\in \\mathbb{F}_q}[d((1 - r) \\cdot u_0 + r \\cdot u_1, C) \\leq e] \\leq \\frac{e + 1}{q}$, and the theorem's hypothesis is false.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 2.2.</strong> A result exactly analogous to Theorem 2.1—with identical parameters—holds for arbitrary-dimensional affine subspaces, and can moreover be proven using Theorem 2.1. In fact, precisely this reduction is carried out in [Ben+23, § 6.3] (in the list-decoding setting no less, though that work's approach is straightforwardly specialized). Since we don't need this more general result below, we omit its treatment.</p>

    <p class="text-gray-300"><strong>Remark 2.3.</strong> Theorem 2.1 is sharp, in the sense that its false witness probability <span class="math">\\frac{e + 1}{q}</span> cannot be decreased. This fact is demonstrated by the following example of Ben-Sasson et al. [Ben+23, Rem. 1.1]. We fix an <span class="math">[n,k,d]</span>-code <span class="math">C \\subset \\mathbb{F}_q^n</span>, and set <span class="math">e \\in \\{0, \\dots, \\left\\lfloor \\frac{d - 1}{3} \\right\\rfloor\\}</span> arbitrarily. We assume that <span class="math">q &amp;gt; e + 1</span> and <span class="math">d &amp;gt; 1</span>. We fix distinct elements <span class="math">x_0, \\ldots, x_e</span> of <span class="math">\\mathbb{F}_q</span>, and set <span class="math">u_0 := (x_0, \\ldots, x_e, 0, \\ldots, 0)</span> and <span class="math">u_1 := (x_0 - 1, \\ldots, x_e - 1, 0, \\ldots, 0)</span>. Writing again <span class="math">R^<em> := \\{r \\in \\mathbb{F}_q \\mid d((1 - r) \\cdot u_0 + r \\cdot u_1, C) \\leq e\\}</span>, we claim that <span class="math">R^</em> = \\{x_0, \\ldots, x_e\\}</span>. Indeed, for each <span class="math">i \\in \\{0, \\ldots, e\\}</span>, we clearly have <span class="math">d((1 - x_i) \\cdot u_0 + x_i \\cdot u_1, C) \\leq e</span>. On the other hand, for each <span class="math">r \\notin \\{x_0, \\ldots, x_e\\}</span>, we claim that <span class="math">d((1 - r) \\cdot u_0 + r \\cdot u_1, C) &amp;gt; e</span>. Indeed, <span class="math">d((1 - r) \\cdot u_0 + r \\cdot u_1, 0) = e + 1</span> clearly holds; on the other hand, for each nonzero codeword <span class="math">v \\in C</span>, we have by the reverse triangle inequality that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d ((1 - r) \\cdot u _ {0} + r \\cdot u _ {1}, v) \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d (v, 0) - d ((1 - r) \\cdot u _ {0} + r \\cdot u _ {1}, 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d - (e + 1) &gt; e,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where, in the final step, we use the guarantee <span class="math">2 \\cdot e + 1 &amp;lt; d</span> (a consequence of <span class="math">3 \\cdot e &amp;lt; d</span> if <span class="math">e &amp;gt; 0</span>, or else of <span class="math">d &amp;gt; 1</span> in the case <span class="math">e = 0</span>). We see that <span class="math">\\operatorname{Pr}_{r \\in \\mathbb{F}_q}[d((1 - r) \\cdot u_0 + r \\cdot u_1, C) \\leq e] = \\frac{e + 1}{q}</span>. On the other hand, the conclusion <span class="math">d^2\\left((u_i)_{i=0}^1, C^2\\right) \\leq e</span> of Theorem 2.1 certainly fails to hold, since it would imply that <span class="math">R^* = \\mathbb{F}_q</span>, whereas we have instead that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= e + 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the Reed-Solomon setting, Ben-Sasson et al. [Ben+23, Thm. 1.4] achieve an analogue of Theorem 2.1 for <span class="math">e</span> as high as the unique decoding radius, albeit with an upper-bound <span class="math">\\frac{n}{q}</span> on the false witness probability somewhat worse than that of <span class="math">\\frac{e + 1}{q}</span> attained by Theorem 2.1. (They also present results beyond the unique decoding radius, which feature, on the other hand, much-more-complicated bounds.) We record the following analogue of this statement in our setting:</p>

    <p class="text-gray-300"><strong>Conjecture 2.4.</strong> We wonder whether Theorem 2.1 holds even for proximity parameters <span class="math">e \\in \\{0, \\dots, \\left\\lfloor \\frac{d - 1}{2} \\right\\rfloor\\}</span>.</p>

    <p class="text-gray-300">We now describe our new interleaved-to-standard reduction for proximity testing. We assume in what follows that the list length <span class="math">m</span> is a power of 2. In our test, we use the tensor product expression <span class="math">(1 - r_0, r_0) \\otimes \\dots \\otimes (1 - r_{\\log m - 1}, r_{\\log m - 1})</span>, where the elements <span class="math">r_0, \\ldots, r_{\\log m - 1}</span> of <span class="math">\\mathbb{F}_q</span> are independently random, as a combination vector over the input list; our error parameter exceeds that of the affine case by a multiplicative factor of <span class="math">2 \\cdot \\log m</span>. We make blackbox use of Theorem 2.1 throughout.</p>

    <p class="text-gray-300">Theorem 3.1. Fix an arbitrary  <span class="math">[n,k,d]</span> -code  <span class="math">C\\subset \\mathbb{F}_q^n</span> , and a proximity parameter  <span class="math">e\\in \\{0,\\ldots ,\\left\\lfloor \\frac{d - 1}{3}\\right\\rfloor \\}</span> . If given elements  <span class="math">u_{0},\\ldots ,u_{m - 1}</span>  of  <span class="math">\\mathbb{F}_q^n</span>  satisfy</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} _ {(r _ {0}, \\ldots , r _ {\\log m - 1}) \\in \\mathbb {F} _ {q} ^ {\\log m}} \\left[ d \\left(\\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\log m - 1} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; u _ {0} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ &amp;amp; - &amp;amp; u _ {m - 1} \\end{array} \\right], C\\right) \\leq e \\right] &amp;gt; 2 \\cdot \\log m \\cdot \\frac {e + 1}{q},</span></div>

    <p class="text-gray-300">then  <span class="math">d^{m}\\Big((u_{i})_{i = 0}^{m - 1},C^{m}\\Big)\\leq e</span></p>

    <p class="text-gray-300">Proof. We write  <span class="math">\\ell \\coloneqq \\log m</span>  once and for all. In the base case  <span class="math">\\ell = 1</span> , the result follows immediately from Theorem 2.1, since  <span class="math">2 \\cdot \\frac{e + 1}{q} \\geq \\frac{e + 1}{q}</span> .</p>

    <p class="text-gray-300">We now let  <span class="math">\\ell &amp;gt; 1</span>  be arbitrary, and assume the hypothesis of the theorem. By way of induction, we construct two smaller instances of the problem, each of size  <span class="math">\\ell - 1</span> , and establish the theorem's hypothesis on these instances. We prepare the process by introducing notation. For each tuple  <span class="math">(r_0, \\ldots, r_{\\ell - 2}) \\in \\mathbb{F}_q^{\\ell - 1}</span> , we record the following abbreviations, each involving an appropriate half-list of the initial list  <span class="math">(u_i)_{i = 0}^{2^{\\ell} - 1}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">M _ {0} := \\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\ell - 2} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; u _ {0} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; u _ {2 ^ {\\ell - 1} - 1} &amp;amp; - \\end{array} \\right], \\quad M _ {1} := \\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\ell - 2} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; u _ {2 ^ {\\ell - 1}} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; u _ {2 ^ {\\ell} - 1} &amp;amp; - \\end{array} \\right].</span></div>

    <p class="text-gray-300">We emphasize that each pair  <span class="math">M_0 \\coloneqq M_0(r_0, \\ldots, r_{\\ell-2})</span>  and  <span class="math">M_1 \\coloneqq M_1(r_0, \\ldots, r_{\\ell-2})</span>  actually depends on a fixed choice of tuple  <span class="math">(r_0, \\ldots, r_{\\ell-2}) \\in \\mathbb{F}_q^{\\ell-1}</span> ; we slightly abuse notation by omitting this tuple.</p>

    <p class="text-gray-300">Our recursive approach relies on the following identity, valid for each  <span class="math">(r_0,\\ldots ,r_{\\ell -1})\\in \\mathbb{F}_q^\\ell</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c} &amp;amp; \\bigotimes_ {i = 0} ^ {\\ell - 1} (1 - r _ {i}, r _ {i}) &amp;amp; \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; u _ {0} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; u _ {2 ^ {\\ell} - 1} &amp;amp; - \\end{array} \\right] = \\left[ \\begin{array}{c c c} 1 - r _ {\\ell - 1} &amp;amp; r _ {\\ell - 1} \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; M _ {0} &amp;amp; - \\\\ - &amp;amp; M _ {1} &amp;amp; - \\end{array} \\right].</span></div>

    <p class="text-gray-300">This identity follows directly from the definition of the tensor product, and is easily verified by means of an explicit calculation. We finally define various loci in  <span class="math">\\mathbb{F}_q^{\\ell -1}</span> . We write  <span class="math">R_0\\coloneqq \\left\\{(r_0,\\ldots ,r_{\\ell -2})\\in \\mathbb{F}_q^{\\ell -1}\\mid d(M_0,C)\\leq e\\right\\}</span>  and  <span class="math">R_{1}\\coloneqq \\left\\{(r_{0},\\dots,r_{\\ell -2})\\in \\mathbb{F}_{q}^{\\ell -1}\\mid d(M_{1},C)\\leq e\\right\\}</span>  for the loci consisting of those  <span class="math">\\ell -1</span>  -tuples for which  <span class="math">M_0</span>  and  <span class="math">M_{1}</span>  (respectively) are at most  <span class="math">e</span>  -far from the code. We finally write, for each  <span class="math">(r_0,\\ldots ,r_{\\ell -2})\\in \\mathbb{F}_q^{\\ell -1}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">p (r _ {0}, \\ldots , r _ {\\ell - 2}) := \\operatorname * {P r} _ {r _ {\\ell - 1} \\in \\mathbb {F} _ {q}} \\left[ d \\left(\\left[ \\begin{array}{c c c} 1 - r _ {\\ell - 1} &amp;amp; r _ {\\ell - 1} \\end{array} \\right] \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; M _ {0} &amp;amp; - \\\\ - &amp;amp; M _ {1} &amp;amp; - \\end{array} \\right], C\\right) \\leq e \\right],</span></div>

    <p class="text-gray-300">and set  <span class="math">R^{<em>} \\coloneqq \\left\\{(r_{0},\\ldots ,r_{\\ell -2}) \\in \\mathbb{F}_{q}^{\\ell -1} \\mid p(r_{0},\\ldots ,r_{\\ell -2}) &amp;gt; \\frac{e + 1}{q}\\right\\}</span> . In words,  <span class="math">R^{</em>} \\subset \\mathbb{F}_{q}^{\\ell -1}</span>  is that locus consisting of those  <span class="math">\\ell - 1</span> -tuples whose resulting combinations  <span class="math">M_0</span>  and  <span class="math">M_1</span>  (with the initial matrix's lower and upper halves, respectively) span a line a substantial proportion of whose elements reside close to the code.</p>

    <p class="text-gray-300">We begin with the following lemma:</p>

    <p class="text-gray-300">Lemma 3.2.  <span class="math">R^{*}\\subset R_{0}\\cap R_{1}</span></p>

    <p class="text-gray-300">Proof. Indeed, that  <span class="math">(r_0,\\ldots ,r_{\\ell -2})\\in R^*</span>  holds entails, by definition, that the hypothesis of Theorem 2.1 holds with respect to the affine line spanned by the relevant combinations  <span class="math">M_0</span>  and  <span class="math">M_{1}</span> . That theorem implies that  <span class="math">d(M_0,C)\\leq e</span>  (so that  <span class="math">(r_0,\\dots ,r_{\\ell -2})\\in R_0)</span>  and  <span class="math">d(M_1,C)\\leq e</span>  (so that  <span class="math">(r_0,\\dots ,r_{\\ell -2})\\in R_1)</span> .</p>

    <p class="text-gray-300">The following lemma shows that the subset  <span class="math">R^{*}\\subset \\mathbb{F}_{q}^{\\ell -1}</span>  is necessarily large:</p>

    <p class="text-gray-300">Lemma 3.3.  <span class="math">\\mu (R^{*}) &amp;gt; 2\\cdot (\\ell -1)\\cdot \\frac{e + 1}{q}</span></p>

    <p class="text-gray-300">Proof. The result follows from a probability decomposition argument, as we explain below:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 2 \\cdot \\ell \\cdot \\frac{e + 1}{q} &amp;lt; \\Pr_{(r_0, \\dots, r_{\\ell - 1}) \\in \\mathbb{F}_q^{\\ell}} \\left[ d \\left( \\left[ \\bigotimes_{i = 0}^{\\ell - 1} (1 - r_i, r_i) \\right] \\cdot \\left[ \\begin{array}{ccc} \\longrightarrow &amp;amp; u_0 &amp;amp; \\longrightarrow \\\\ \\vdots &amp;amp; &amp;amp; \\\\ \\longrightarrow &amp;amp; u_{2^{\\ell - 1}} &amp;amp; \\longrightarrow \\end{array} \\right], C \\right) \\leq e \\right] \\\\ = \\Pr_{(r_0, \\dots, r_{\\ell - 1}) \\in \\mathbb{F}_q^{\\ell}} \\left[ d \\left( \\left[ 1 - r_{\\ell - 1} \\quad r_{\\ell - 1} \\right] \\cdot \\left[ \\begin{array}{ccc} \\longrightarrow &amp;amp; M_0 &amp;amp; \\longrightarrow \\\\ \\longrightarrow &amp;amp; M_1 &amp;amp; \\longrightarrow \\end{array} \\right], C \\right) \\leq e \\right] \\\\ \\leq \\frac{e + 1}{q} + \\Pr_{(r_0, \\dots, r_{\\ell - 2}) \\in \\mathbb{F}_q^{\\ell - 1}} \\left[ (r_0, \\dots, r_{\\ell - 2}) \\in R^* \\right]. \\end{array}</span></div>

    <p class="text-gray-300">The first step is the hypothesis of the theorem; the second step follows from the recursive substructure explained above. To achieve the final step, we upper-bound the second-to-last expression slice-wise, either by  <span class="math">\\frac{e + 1}{q}</span>  or by 1, depending on whether the slice  <span class="math">(r_0,\\ldots ,r_{\\ell -2})\\in R^<em></span> . In this way, we obtain the upper-bound  <span class="math">\\frac{e + 1}{q}\\cdot \\operatorname </em>{Pr}_{(r_0,\\dots,r_{\\ell -2})\\in \\mathbb{F}_q^{\\ell -1}}\\left[p(r_0,\\dots,r_{\\ell -2})\\leq \\frac{e + 1}{q}\\right] + \\operatorname <em>{Pr}_{(r_0,\\dots,r_{\\ell -2})\\in \\mathbb{F}_q^{\\ell -1}}\\left[p(r_0,\\dots,r_{\\ell -2}) &amp;gt; \\frac{e + 1}{q}\\right]\\leq \\frac{e + 1}{q} +</span> <span class="math">\\operatorname </em>{Pr}_{(r_0,\\dots,r_{\\ell -2})\\in \\mathbb{F}_q^{\\ell -1}}[(r_0,\\dots,r_{\\ell -2})\\in R^<em> ]</span> . From the entire inequality, we conclude finally that  <span class="math">\\mu (R^{</em>})\\geq 2\\cdot \\ell \\cdot</span> <span class="math">\\frac{e + 1}{q} -\\frac{e + 1}{q} = (2\\cdot \\ell -1)\\cdot \\frac{e + 1}{q}\\geq 2\\cdot (\\ell -1)\\cdot \\frac{e + 1}{q}</span> , as desired. This completes the proof of the lemma.</p>

    <p class="text-gray-300">Upon combining Lemmas 3.2 and 3.3, we immediately conclude that the probabilities  <span class="math">\\mu(R_0)</span>  and  <span class="math">\\mu(R_1)</span>  are both themselves greater than  <span class="math">2 \\cdot (\\ell - 1) \\cdot \\frac{e + 1}{q}</span> . In other words, the hypothesis of the theorem is fulfilled with respect to the parameter  <span class="math">\\ell - 1</span>  and to both of the half-sublists  <span class="math">(u_i)_{i=0}^{2^{\\ell - 1} - 1}</span>  and  <span class="math">(u_i)_{i=2^{\\ell - 1}}^{2^{\\ell} - 1}</span> . This justifies our inductive use of the theorem with respect to these half-sublists.</p>

    <p class="text-gray-300">We thus conclude the consequence of the theorem with respect to the sublists  <span class="math">(u_i)_{i=0}^{2^{\\ell-1}-1}</span>  and  <span class="math">(u_i)_{i=2^{\\ell-1}}^{2^{\\ell}-1}</span> . We write  <span class="math">e_0 := d^{2^{\\ell-1}}\\left((u_i)_{i=0}^{2^{\\ell-1}-1}, C^{2^{\\ell-1}}\\right)</span>  and  <span class="math">e_1 := d^{2^{\\ell-1}}\\left((u_i)_{i=2^{\\ell-1}}^{2^{\\ell-1}}, C^{2^{\\ell-1}}\\right)</span>  for these sublists' interleaved distances, as well as  <span class="math">D_0</span>  and  <span class="math">D_1</span>  for their corresponding (correlated) disagreement subsets of  <span class="math">\\{0, \\ldots, n-1\\}</span> . We finally write  <span class="math">(v_i)_{i=0}^{2^{\\ell-1}-1}</span>  and  <span class="math">(v_i)_{i=2^{\\ell-1}}^{2^{\\ell-1}}</span>  for their corresponding lists of close codewords. By analogy with  <span class="math">M_0</span>  and  <span class="math">M_1</span> , we now record, for each  <span class="math">(r_0, \\ldots, r_{\\ell-2}) \\in \\mathbb{F}_q^{\\ell-1}</span> , the following abbreviations:</p>

    <div class="my-4 text-center"><span class="math-block">N_0 := \\left[ \\begin{array}{cccc} \\infty &amp;amp; v_0 &amp;amp; \\longrightarrow \\\\ \\vdots &amp;amp; &amp;amp; \\\\ v_{2^{\\ell - 1} - 1} &amp;amp; \\longrightarrow \\end{array} \\right], \\quad N_1 := \\left[ \\begin{array}{cccc} \\infty &amp;amp; v_{2^{\\ell - 1}} &amp;amp; \\longrightarrow \\\\ \\vdots &amp;amp; &amp;amp; \\\\ v_{2^{\\ell - 1} - 1} &amp;amp; \\longrightarrow \\end{array} \\right].</span></div>

    <p class="text-gray-300">We define further loci in  <span class="math">\\mathbb{F}_q^{\\ell -1}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">B_0 := \\left\\{(r_0, \\dots, r_{\\ell - 2}) \\in \\mathbb{F}_q^{\\ell - 1} \\mid d(M_0, N_0) &amp;lt; e_0 \\right\\}, \\quad B_1 := \\left\\{(r_0, \\dots, r_{\\ell - 2}) \\in \\mathbb{F}_q^{\\ell - 1} \\mid d(M_1, N_1) &amp;lt; e_1 \\right\\}.</span></div>

    <p class="text-gray-300">We understand these loci as the subsets of the parameter space at which  <span class="math">M_0</span>  and  <span class="math">M_1</span>  (respectively) become closer to  <span class="math">N_0</span>  and  <span class="math">N_1</span>  than correlated agreement demands.</p>

    <p class="text-gray-300">The following lemma shows that the loci  <span class="math">B_0</span>  and  <span class="math">B_1</span>  are not too large:</p>

    <p class="text-gray-300"><strong>Lemma 3.4.</strong>  <span class="math">\\mu(B_0) \\leq (\\ell - 1) \\cdot \\frac{e}{q}</span>  and  <span class="math">\\mu(B_1) \\leq (\\ell - 1) \\cdot \\frac{e}{q}</span> .</p>

    <p class="text-gray-300"><strong>Proof.</strong> We let  <span class="math">b \\in \\{0,1\\}</span>  be arbitrary, and prove the result for  <span class="math">B_{b}</span> . For each index  <span class="math">j \\in D_{b}</span> , we write</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{b,j} := \\left\\{(r_0, \\dots, r_{\\ell - 2}) \\in \\mathbb{F}_q^{\\ell - 1} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_b \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{j\\}} = N_b \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{j\\}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for the locus in  <span class="math">\\mathbb{F}_q^{\\ell -1}</span>  on which  <span class="math">M_{b}</span>  and  <span class="math">N_{b}</span>  "spuriously agree" at the index  <span class="math">j</span> . We note that each  <span class="math">R_{b,j} \\subset \\mathbb{F}_q^{\\ell -1}</span>  is precisely the vanishing locus of a certain combination of the  <span class="math">\\ell - 1</span> -variate multilinear Lagrange basis polynomials, where the combination vector—because  <span class="math">j \\in D_b</span> —is not identically zero. We conclude that the combination is itself nonzero; the Schwartz-Zippel lemma in turn implies that  <span class="math">\\mu(R_{b,j}) \\leq \\frac{\\ell - 1}{q}</span> . These sets' union thus has mass at most  $\\mu\\left(\\bigcup_{j \\in D_b} R_{b,j}\\right) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\frac{\\ell - 1}{q} \\leq (\\ell - 1) \\cdot \\frac{e}{q}<span class="math"> , where, in the last step, we exploit the inductive hypothesis  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= e_b \\leq e<span class="math"> . On the other hand,  </span>B_b = \\bigcup_{j \\in D_b} R_{b,j}$ . This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the following lemma, we recall the set <span class="math">R^{*}\\subset\\mathbb{F}_{q}^{\\ell-1}</span> introduced above.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Lemma 3.5.</h6>

    <p class="text-gray-300"><span class="math">R^{*}\\not\\subset B_{0}\\cup B_{1}</span>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Indeed, by Lemma 3.3, <span class="math">\\mu(R^{*})&gt;2\\cdot(\\ell-1)\\cdot\\frac{e+1}{q}</span>; on the other hand, Lemma 3.4 gives that the masses <span class="math">\\mu(B_{0})</span> and <span class="math">\\mu(B_{1})</span> are each at most <span class="math">(\\ell-1)\\cdot\\frac{e}{q}</span>. ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 3.5, there necessarily exists some element <span class="math">(r_{0}^{<em>},\\ldots,r_{\\ell-2}^{</em>})\\in R^{<em>}\\setminus(B_{0}\\cup B_{1})</span>. We write <span class="math">M_{0}^{</em>}</span> and <span class="math">M_{1}^{<em>}</span> for the corresponding values of <span class="math">M_{0}</span> and <span class="math">M_{1}</span>, and moreover define <span class="math">N_{0}^{</em>}</span> and <span class="math">N_{1}^{<em>}</span> analogously. Because <span class="math">(r_{0}^{</em>},\\ldots,r_{\\ell-2}^{<em>})\\in R^{</em>}</span>, an application of Theorem 2.1 to the line spanned by <span class="math">M_{0}^{<em>}</span> and <span class="math">M_{1}^{</em>}</span> yields a subset <span class="math">D^{*}\\subset\\{0,\\ldots,n-1\\}</span>, satisfying $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=e^{<em>}<span class="math">, say, where </span>e^{</em>}\\leq e<span class="math">, together with codewords </span>O_{0}<span class="math"> and </span>O_{1}<span class="math"> which respectively agree with </span>M_{0}^{<em>}<span class="math"> and </span>M_{1}^{</em>}<span class="math"> <em>outside of</em> </span>D^{*}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each <span class="math">b\\in\\{0,1\\}</span>, because <span class="math">(r_{0}^{<em>},\\ldots,r_{\\ell-2}^{</em>})\\not\\in B_{b}</span> moreover holds, we have in fact the disagreement set <em>equality</em> <span class="math">\\Delta(M_{b}^{<em>},N_{b}^{</em>})=D_{b}</span> (as opposed to a proper inclusion). We write <span class="math">\\Delta(M_{b}^{<em>},O_{b})</span> for the disagreement set of <span class="math">M_{b}^{</em>}</span> and <span class="math">O_{b}</span>. By definition of <span class="math">D^{<em>}</span>, <span class="math">\\Delta(M_{b}^{</em>},O_{b})\\subset D^{<em>}</span> clearly holds; on the other hand, because <span class="math">d(M_{b}^{</em>},N_{b}^{<em>})\\leq e_{b}\\leq e</span> and <span class="math">d(M_{b}^{</em>},O_{b})\\leq e^{<em>}\\leq e</span> simultaneously hold, unique decoding implies that <span class="math">N_{b}^{</em>}=O_{b}</span>, and that in fact <span class="math">\\Delta(M_{b}^{<em>},O_{b})=D_{b}</span>. We conclude that <span class="math">D_{b}\\subset D^{</em>}</span>.</p>

    <p class="text-gray-300">It follows that <span class="math">D_{0}\\cup D_{1}\\subset D^{<em>}</span>. We conclude that <span class="math">(u_{i})_{i=0}^{2^{\\ell-1}-1}</span> and <span class="math">(u_{i})_{i=2^{\\ell-1}}^{2^{\\ell}-1}</span> have mutual correlated agreement outside of the set <span class="math">D_{0}\\cup D_{1}</span> of size at most <span class="math">e^{</em>}\\leq e</span>. This completes the proof of the theorem. ∎</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Remark 3.6.</h6>

    <p class="text-gray-300">The false witness probability <span class="math">2\\cdot\\log m\\cdot\\frac{e+1}{q}</span> of Theorem 3.1 seems not to be sharp; for example, we wonder whether the factor of <span class="math">2</span> can be eliminated.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Polynomial Commitment</h2>

    <p class="text-gray-300">In this section, we present our main multilinear polynomial commitment scheme, and analyze its efficiency.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 Definitions and Notions</h3>

    <p class="text-gray-300">We begin by defining multilinear polynomial commitment schemes, following Setty <em>[x20, § 2.4]</em>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">A <em>multilinear polynomial commitment scheme</em> is a tuple of algorithms <span class="math">\\Pi=({\\sf Setup},{\\sf Commit},{\\sf Open},{\\sf Prove},{\\sf Verify})</span>, with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{params}\\leftarrow\\Pi.\\mathsf{Setup}(1^{\\lambda},\\ell)</span>. On input the security parameter <span class="math">\\lambda</span> and a size parameter <span class="math">\\ell=O(\\log\\lambda)</span>, <span class="math">\\Pi.\\mathsf{Setup}</span> samples <span class="math">\\mathsf{params}</span>, which includes (possibly among other things) a finite field order <span class="math">q=2^{O(\\lambda)}</span>.</li>

      <li><span class="math">(c,u)\\leftarrow\\Pi.\\mathsf{Commit}(\\mathsf{params},t)</span>. On input a multilinear polynomial <span class="math">t(X_{0},\\ldots,X_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}[X_{0},\\ldots,X_{2\\cdot\\ell-1}]</span>, <span class="math">\\Pi.\\mathsf{Commit}</span> returns a commitment <span class="math">c</span> to <span class="math">t</span>, together with an <em>opening hint</em> <span class="math">u</span>.</li>

      <li><span class="math">b\\leftarrow\\Pi.\\mathsf{Open}(\\mathsf{params},c;t,u)</span>. On input a commitment <span class="math">c</span>, a multilinear polynomial <span class="math">t(X_{0},\\ldots,X_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}[X_{0},\\ldots,X_{2\\cdot\\ell-1}]</span>, and an opening hint <span class="math">u</span>, <span class="math">\\Pi.\\mathsf{Open}</span> verifies the claimed decommitment <span class="math">t</span> of <span class="math">c</span>, using <span class="math">u</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\Pi.\\mathsf{Prove}(\\mathsf{params},c,s,(r_{0},\\ldots,r_{2\\cdot\\ell-1});t,u)</span>. On input a commitment <span class="math">c</span>, a purported evaluation <span class="math">s\\in\\mathbb{F}_{q}</span>, an evaluation point <span class="math">(r_{0},\\ldots,r_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}^{2\\cdot\\ell}</span>, a multilinear polynomial <span class="math">t(X_{0},\\ldots,X_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}[X_{0},\\ldots,X_{2\\cdot\\ell-1}]</span>, and an opening hint <span class="math">u</span>, <span class="math">\\Pi.\\mathsf{Prove}</span> generates an evaluation proof <span class="math">\\pi</span>.</li>

      <li><span class="math">b\\leftarrow\\Pi.\\mathsf{Verify}(\\mathsf{params},c,s,(r_{0},\\ldots,r_{2\\cdot\\ell-1}),\\pi)</span>. On input a commitment <span class="math">c</span>, a purported evaluation <span class="math">s</span>, an evaluation point <span class="math">(r_{0},\\ldots,r_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}^{2\\cdot\\ell}</span>, and a proof <span class="math">\\pi</span>, <span class="math">\\Pi.\\mathsf{Verify}</span> outputs a success bit <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <p class="text-gray-300">The demand <span class="math">\\ell=O(\\log\\lambda)</span> is necessary, lest the number of coefficients <span class="math">m^{2}=2^{2\\cdot\\ell}</span> of each multilinear <span class="math">t(X_{0},\\ldots,X_{2\\cdot\\ell-1})</span> be superpolynomial in <span class="math">\\lambda</span>. Similarly, the requirement <span class="math">q=2^{O(\\lambda)}</span> ensures that <span class="math">\\mathbb{F}_{q}</span>-elements are efficiently representable.</p>

    <p class="text-gray-300">The scheme <span class="math">\\Pi</span> is <em>complete</em> if the obvious correctness properties hold. That is, for honestly generated <span class="math">\\mathsf{params}\\leftarrow\\Pi.\\mathsf{Setup}(1^{\\lambda},\\ell)</span>, each honestly generated commitment <span class="math">(c,u)\\leftarrow\\Pi.\\mathsf{Commit}(\\mathsf{params},t)</span> to some multilinear polynomial <span class="math">t(X_{0},\\ldots,X_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}[X_{0},\\ldots,X_{2\\cdot\\ell-1}]</span> should satisfy <span class="math">\\Pi.\\mathsf{Open}(\\mathsf{params},c;t,u)=1</span>; moreover, each honestly generated proof <span class="math">\\pi\\leftarrow\\Pi.\\mathsf{Prove}(\\mathsf{params},c,s,(r_{0},\\ldots,r_{2\\cdot\\ell-1});t,u)</span>—for <span class="math">(r_{0},\\ldots,r_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}^{2\\cdot\\ell}</span> given arbitrarily—should satisfy <span class="math">\\Pi.\\mathsf{Verify}(\\mathsf{params},c,s,(r_{0},\\ldots,r_{2\\cdot\\ell-1}),\\pi)=1</span> with probability <span class="math">1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">\\Pi</span> is moreover <em>efficient</em> if the size of each commitment satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(\\lambda)<span class="math">, the size of each proof satisfies </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=o(\\lambda\\cdot m^{2})<span class="math">, the routines </span>\\Pi<span class="math">.Commit, </span>\\Pi<span class="math">.Open, and </span>\\Pi<span class="math">.Prove all run in time </span>\\widetilde{O}(\\lambda\\cdot m^{2})<span class="math">, and </span>\\Pi<span class="math">.Verify runs in time </span>o(\\lambda\\cdot m^{2})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now give security definitions for multilinear polynomial commitment schemes, closely following both Marlin <em>[x10, Def. 6.2]</em> and Setty <em>[x18, Def. 2.11]</em>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">For each multilinear polynomial commitment scheme <span class="math">\\Pi</span>, size parameter <span class="math">\\ell</span>, and PPT adversary <span class="math">\\mathcal{A}</span>, we define the <em>binding experiment</em> <span class="math">\\mathsf{Binding}_{\\mathcal{A}}^{\\Pi,\\ell}(\\lambda)</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The experimenter samples <span class="math">\\mathsf{params}\\leftarrow\\Pi.\\mathsf{Setup}(1^{\\lambda},\\ell)</span>, and gives <span class="math">\\mathsf{params}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>The adversary outputs <span class="math">(c,t^{0},t^{1},u^{0},u^{1})\\leftarrow\\mathcal{A}(\\mathsf{params})</span>, where <span class="math">c</span> is a commitment, <span class="math">t^{0}(X_{0},\\ldots,X_{2\\cdot\\ell-1})</span> and <span class="math">t^{1}(X_{0},\\ldots,X_{2\\cdot\\ell-1})</span> are multilinear polynomials in <span class="math">\\mathbb{F}_{q}[X_{0},\\ldots,X_{2\\cdot\\ell-1}]</span>, and <span class="math">u^{0}</span> and <span class="math">u^{1}</span> are opening hints.</li>

      <li>The output of the experiment is defined to be <span class="math">1</span> if <span class="math">\\Pi.\\mathsf{Open}\\big{(}\\mathsf{params},c;t^{0},u^{0}\\big{)}</span>, <span class="math">\\Pi.\\mathsf{Open}\\big{(}\\mathsf{params},c;t^{1},u^{1}\\big{)}</span>, and <span class="math">t^{0}\\neq t^{1}</span> all hold; otherwise, it is defined to be <span class="math">0</span>.</li>

    </ol>

    <p class="text-gray-300">The multilinear polynomial commitment scheme <span class="math">\\Pi</span> is said to be <em>binding</em> if, for each PPT adversary <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\lambda)</span> for which, for each <span class="math">\\lambda\\in\\mathbb{N}</span> and <span class="math">\\ell=O(\\log\\lambda)</span>, <span class="math">\\Pr\\Big{[}\\mathsf{Binding}_{\\mathcal{A}}^{\\Pi,\\ell}(\\lambda)\\Big{]}\\leq\\mathsf{negl}(\\lambda)</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 4.3.</h6>

    <p class="text-gray-300">For each multilinear polynomial commitment scheme <span class="math">\\Pi</span>, security parameter <span class="math">\\lambda</span>, size parameter <span class="math">\\ell</span>, PPT query sampler <span class="math">\\mathcal{Q}</span>, stateful PPT adversary <span class="math">\\mathcal{A}</span>, expected PPT emulator <span class="math">\\mathcal{E}</span>, and PPT distinguisher <span class="math">\\mathcal{D}</span>, we define two random variables <span class="math">\\mathsf{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span> and <span class="math">\\mathsf{Emul}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span>, each valued in <span class="math">\\{0,1\\}</span>, as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The experimenter samples <span class="math">\\mathsf{params}\\leftarrow\\Pi.\\mathsf{Setup}(1^{\\lambda},\\ell)</span>, and gives <span class="math">\\mathsf{params}</span> to <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{Q}</span> and <span class="math">\\mathcal{E}</span>.</li>

      <li>The adversary outputs a commitment <span class="math">c\\leftarrow\\mathcal{A}(\\mathsf{params})</span>.</li>

      <li>The query sampler outputs <span class="math">(r_{0},\\ldots,r_{2\\cdot\\ell-1})\\leftarrow\\mathcal{Q}(\\mathsf{params})</span>.</li>

      <li>The experimenter proceeds in one of two separate ways:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span>: Run <span class="math">(s,\\pi)\\leftarrow\\mathcal{A}(r_{0},\\ldots,r_{2\\cdot\\ell-1})</span>. Output the single bit <span class="math">\\mathcal{D}(c,s,\\pi)</span>.</li>

      <li><span class="math">\\mathsf{Emul}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span>: Run <span class="math">(s,\\pi;t,u)\\leftarrow\\mathcal{E}^{\\mathcal{A}}(r_{0},\\ldots,r_{2\\cdot\\ell-1})</span>. Output the single bit <span class="math">\\mathcal{D}(c,s,\\pi)\\wedge(\\Pi.\\mathsf{Verify}(\\mathsf{params},c,s,(r_{0},\\ldots,r_{2\\cdot\\ell-1}),\\pi)\\implies(\\Pi.\\mathsf{Open}(\\mathsf{params},c;t,u)\\wedge t(r_{0},\\ldots,r_{2\\cdot\\ell-1})=s))</span>.</li>

    </ul>

    <p class="text-gray-300">The multilinear polynomial commitment scheme <span class="math">\\Pi</span> is said to be <em>extractable</em> with respect to the query sampler <span class="math">\\mathcal{Q}</span> if, for each PPT adversary <span class="math">\\mathcal{A}</span>, there exists an expected PPT emulator <span class="math">\\mathcal{E}</span> for which, for each PPT distinguisher <span class="math">\\mathcal{D}</span>, the distributions <span class="math">\\Big{\\{}\\mathsf{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)\\Big{\\}}_{\\ell,\\lambda\\in\\mathbb{N}}</span> and <span class="math">\\Big{\\{}\\mathsf{Emul}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)\\Big{\\}}_{\\ell,\\lambda\\in\\mathbb{N}}</span> are statistically close.</p>

    <p class="text-gray-300">In step 4 of Definition 4.3, we give <span class="math">\\mathcal{E}</span> full rewinding access to <span class="math">\\mathcal{A}</span>, including its random tape; we suppress this fact for notational convenience. We emphasize that the implicit negligible function <span class="math">\\mathsf{negl}</span> in Definition 4.3, which depends in general on <span class="math">\\mathcal{Q}</span>, <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{E}</span>, and <span class="math">\\mathcal{D}</span>, is <em>not</em> allowed to depend on <span class="math">\\ell</span>; rather, it must work simultaneously for <em>all</em> <span class="math">\\lambda\\in\\mathbb{N}</span> and <span class="math">\\ell\\in\\mathbb{N}</span>.</p>

    <p class="text-gray-300">The following definition is a simplification of <em>[x10, Def. 6.5]</em>, which requires that <span class="math">\\mathcal{Q}</span> sample uniformly randomly (<em>[x10, Def. 6.5]</em> permits <span class="math">\\mathcal{Q}</span> to instead sample uniformly from a superpolynomially large set).</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <p class="text-gray-300">The query sampler <span class="math">\\mathcal{Q}</span> is <em>admissible</em> if, for each <span class="math">\\lambda</span> and <span class="math">\\ell</span>, and each parameter set <span class="math">\\mathsf{params}\\leftarrow\\Pi.\\mathsf{Setup}(1^{\\lambda},\\ell)</span>, containing the field size <span class="math">q</span> say, it holds that <span class="math">(r_{0},\\ldots,r_{2\\cdot\\ell-1})\\leftarrow\\mathcal{Q}(\\mathsf{params})</span> is uniform over <span class="math">\\mathbb{F}_{q}^{2\\cdot\\ell}</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Remark 4.5.</h6>

    <p class="text-gray-300">We compare our definitional framework to those of Setty <em>[x18, Def. 2.11]</em> and Bünz, Fisch and Szepieniec <em>[x2, Def. 4]</em> (which are identical) and to that of Marlin <em>[x10, Def. 6.2]</em>. Our treatment can be viewed as the “meet” of these two approaches, as we presently explain. We prove our scheme’s security only for a certain class of query samplers (as Marlin does); <em>[x18, Def. 2.11]</em> and <em>[x2, Def. 4]</em> on the other hand require the scheme at hand to be simultaneously secure against <em>all</em> efficient query samplers. On the other hand, we allow our extractor full rewinding access to <span class="math">\\mathcal{A}</span> (as <em>[x18, Def. 2.11]</em> and <em>[x2, Def. 4]</em> do); Marlin instead requires that <span class="math">\\mathcal{E}</span> extract <span class="math">t</span> <em>immediately</em> after seeing <span class="math">c</span>, before seeing <span class="math">(r_{0},\\ldots,r_{2\\cdot\\ell-1})</span> or <span class="math">\\pi</span>. Our definition thus selectively incorporates these definitions’ respective slight weakenings with respect to each other. We note that Marlin’s “early extraction” requirement meets the demands imposed by non-constant-round protocols, where, in fact, <span class="math">\\mathcal{E}</span> must moreover be <em>non-rewinding</em>. As this latter setting doesn’t apply to us, we accept the relaxation adopted by <em>[x18, Def. 2.11]</em> and <em>[x2, Def. 4]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">4.2 Our Construction</p>

    <p class="text-gray-300">We now instantiate our concrete scheme <span class="math">\\Pi</span> in the random oracle model. We use Merkle tree commitments, in a manner which evokes Ben-Sasson, Chiesa and Spooner [BCS16]'s transformation from <em>interactive oracle proofs</em> to <em>non-interactive random oracle proofs</em>.</p>

    <p class="text-gray-300">CONSTRUCTION 4.6 (Main polynomial commitment scheme).</p>

    <p class="text-gray-300">We define <span class="math">\\Pi = (\\text{Setup}, \\text{Commit}, \\text{Open}, \\text{Prove}, \\text{Verify})</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{params} \\leftarrow \\Pi.\\text{Setup}(1^{\\lambda}, \\ell)</span>. On input <span class="math">1^{\\lambda}</span> and <span class="math">\\ell</span>, set <span class="math">m \\coloneqq 2^{\\ell}</span>, and return a prime power <span class="math">q \\geq 2^{\\omega(\\log \\lambda)}</span>, an <span class="math">[n, m, d]</span>-code <span class="math">C \\subset \\mathbb{F}_q^n</span> for which <span class="math">n = 2^{O(\\ell)}</span> and <span class="math">d = \\Omega(n)</span>, and a repetition parameter <span class="math">\\gamma = \\Theta(\\lambda)</span>.</li>

      <li><span class="math">(c, u) \\leftarrow \\Pi.\\text{Commit}(\\text{params}, t)</span>. On input <span class="math">t(X_0, \\ldots, X_{2 \\cdot \\ell - 1}) \\in \\mathbb{F}_q[X_0, \\ldots, X_{2 \\cdot \\ell - 1}]</span>, express <span class="math">t = (t_0, \\ldots, t_{m^2 - 1})</span> in coordinates with respect to the Lagrange basis on <span class="math">\\{0, 1\\}^{2 \\cdot \\ell}</span>, collate the resulting vector into an <span class="math">m \\times m</span> matrix <span class="math">(t_i)_{i=0}^{m-1}</span>, and encode <span class="math">(t_i)_{i=0}^{m-1}</span> row-wise, so obtaining a further, <span class="math">m \\times n</span> matrix <span class="math">(u_i)_{i=0}^{m-1}</span>. Output a Merkle commitment <span class="math">c</span> to <span class="math">(u_i)_{i=0}^{m-1}</span> and the opening hint <span class="math">u := (u_i)_{i=0}^{m-1}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">b \\leftarrow \\Pi.\\text{Open}(\\text{params}, c; t, u)</span>. On input the root <span class="math">c</span>, opening <span class="math">t(X_0, \\ldots, X_{2 \\cdot \\ell - 1}) \\in \\mathbb{F}_q[X_0, \\ldots, X_{2 \\cdot \\ell - 1}]</span>, and opening hint a collection of distinct Merkle paths against <span class="math">c</span>, missing the columns <span class="math">M \\subset \\{0, \\ldots, n - 1\\}</span>, say, write <span class="math">t</span> into a matrix <span class="math">(t_i)_{i=0}^{m-1}</span> and check $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^m\\left((u_i)_{i=0}^{m-1}, (\\mathsf{Enc}(t_i))_{i=0}^{m-1}\\right) \\cup M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel{?}{\\sim} \\frac{d}{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define <span class="math">\\Pi</span>.Prove and <span class="math">\\Pi</span>.Verify by applying the Fiat-Shamir heuristic to the following interactive protocol, where <span class="math">\\mathcal{P}</span> has <span class="math">t(X_0,\\ldots ,X_{2\\cdot \\ell -1})</span> and <span class="math">(u_{i})_{i = 0}^{m - 1}</span>, and <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> have <span class="math">c,s,</span> and <span class="math">(r_0,\\dots ,r_{2\\cdot \\ell -1})\\in \\mathbb{F}_q^{2\\cdot \\ell}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V} t&#x27; := \\bigotimes_{i = \\ell}^{2 \\cdot \\ell - 1} (1 - r_i, r_i) \\cdot (t_i)_{i=0}^{m-1}</span> in the clear.</li>

      <li>For each <span class="math">i \\in \\{0, \\dots, \\gamma - 1\\}</span>, <span class="math">\\mathcal{V}</span> samples <span class="math">j_i \\gets \\{0, \\dots, n - 1\\}</span>. <span class="math">\\mathcal{V}</span> sends <span class="math">\\mathcal{P}</span> the set <span class="math">J := \\{j_0, \\dots, j_{\\gamma - 1}\\}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> sends <span class="math">\\mathcal{V}</span> the columns <span class="math">\\left\\{(u_{i,j})_{i=0}^{m-1}\\right\\}_{j \\in J}</span>, each featuring an accompanying Merkle path against <span class="math">c</span>.</li>

      <li><span class="math">\\mathcal{V}</span> computes <span class="math">\\mathsf{Enc}(t&#x27;)</span>. For each <span class="math">j \\in J</span>, <span class="math">\\mathcal{V}</span> verifies the Merkle path attesting to <span class="math">(u_{i,j})_{i=0}^{m-1}</span>, and moreover requires that <span class="math">\\bigotimes_{i=\\ell}^{2 \\cdot \\ell-1} (1 - r_i, r_i) \\cdot (u_{i,j})_{i=0}^{m-1} \\stackrel{?}{=} \\mathsf{Enc}(t&#x27;)_j</span>. Finally, <span class="math">\\mathcal{V}</span> requires <span class="math">s \\stackrel{?}{=} t&#x27; \\cdot \\bigotimes_{i=0}^{\\ell-1} (1 - r_i, r_i)</span>.</li>

    </ul>

    <p class="text-gray-300">In the last step of Construction 4.6 above, we write <span class="math">\\mathsf{Enc}:\\mathbb{F}_q^m\\to \\mathbb{F}_q^n</span> for <span class="math">C</span>'s encoding function.</p>

    <p class="text-gray-300">Our scheme is clearly complete. We note that the requirement <span class="math">n = 2^{O(\\ell)}</span> is necessary merely for <span class="math">C</span> to be efficiently encodable. The requirement <span class="math">d = \\Omega(n)</span> entails that <span class="math">C</span> has constant relative distance.</p>

    <p class="text-gray-300">We moreover have the following security guarantees:</p>

    <p class="text-gray-300">Theorem 4.7. The scheme of Construction 4.6 is binding.</p>

    <p class="text-gray-300">Proof. We fix an adversary <span class="math">\\mathcal{A}</span> who outputs a commitment <span class="math">c</span> and pairs <span class="math">(t^0, u^0)</span> and <span class="math">(t^1, u^1)</span>. Assuming that <span class="math">\\Pi.\\text{Open}(\\text{params}, c; t^0, u^0)</span> and <span class="math">\\Pi.\\text{Open}(\\text{params}, c; t^1, u^1)</span> both hold, we argue as follows. We write <span class="math">M^0</span> and <span class="math">M^1</span> for the subsets of <span class="math">\\{0, \\ldots, n-1\\}</span> respectively missing from the hints <span class="math">u^0</span> and <span class="math">u^1</span>. We moreover write:</p>

    <div class="my-4 text-center"><span class="math-block">X := \\Delta^ {m} \\left(\\left(u _ {i} ^ {0}\\right) _ {i = 0} ^ {m - 1}, \\left(\\mathsf {E n c} (t _ {i} ^ {0})\\right) _ {i = 0} ^ {m - 1}\\right) \\cup M ^ {0} \\cup \\Delta^ {m} \\left(\\left(u _ {i} ^ {1}\\right) _ {i = 0} ^ {m - 1}, \\left(\\mathsf {E n c} (t _ {i} ^ {1})\\right) _ {i = 0} ^ {m - 1}\\right) \\cup M ^ {1}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the one hand, our hypothesis immediately implies that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; d<span class="math">. On the other hand, we claim that </span>\\Delta^m\\left(\\left(\\mathsf{Enc}(t_i^0)\\right)_{i = 0}^{m - 1},\\left(\\mathsf{Enc}(t_i^1)\\right)_{i = 0}^{m - 1}\\right) \\subset X<span class="math">. Indeed, proceeding by contraposition, we fix an index </span>j \\notin X<span class="math">. Since </span>j \\notin M_0 \\cup M_1<span class="math">, we see that the hints </span>u^0<span class="math"> and </span>u^1<span class="math"> respectively Merkle-open the columns </span>\\left(u_{i,j}^{0}\\right)_{i = 0}^{m - 1}<span class="math"> and </span>\\left(u_{i,j}^{1}\\right)_{i = 0}^{m - 1}<span class="math"> against </span>c<span class="math">, so that—barring an oracle collision on the part of </span>\\mathcal{A}<span class="math">—these columns are necessarily identical. On the other hand, since </span>j \\notin \\Delta^m\\left(\\left(u_i^0\\right)_{i = 0}^{m - 1},\\left(\\mathsf{Enc}(t_i^0)\\right)_{i = 0}^{m - 1}\\right) \\cup \\Delta^m\\left(\\left(u_i^1\\right)_{i = 0}^{m - 1},\\left(\\mathsf{Enc}(t_i^1)\\right)_{i = 0}^{m - 1}\\right)<span class="math">, we see that </span>\\left(\\mathsf{Enc}(t_i^0)_j\\right)_{i = 0}^{m - 1} = \\left(u_{i,j}^0\\right)_{i = 0}^{m - 1}<span class="math"> and </span>\\left(\\mathsf{Enc}(t_i^1)_j\\right)_{i = 0}^{m - 1} = \\left(u_{i,j}^1\\right)_{i = 0}^{m - 1}<span class="math">. Combining these facts, we see that </span>\\left(\\mathsf{Enc}(t_i^0)_j\\right)_{i = 0}^{m - 1} = \\left(\\mathsf{Enc}(t_i^1)_j\\right)_{i = 0}^{m - 1}<span class="math">, so that </span>j \\notin \\Delta^m\\left(\\left(\\mathsf{Enc}(t_i^0)\\right)_{i = 0}^{m - 1},\\left(\\mathsf{Enc}(t_i^1)\\right)_{i = 0}^{m - 1}\\right)<span class="math">, as desired. We conclude that </span>\\left(\\mathsf{Enc}(t_i^0)_j\\right)_{i = 0}^{m - 1} = \\left(\\mathsf{Enc}(t_i^1)_j\\right)_{i = 0}^{m - 1}<span class="math">. Since </span>\\mathsf{Enc}<span class="math"> is injective, we conclude finally that </span>t_0 = t_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 4.8. If the query sampler  <span class="math">\\mathcal{Q}</span>  is admissible, then the scheme of Construction 4.6 is extractable.</p>

    <p class="text-gray-300">Proof. We define an emulator  <span class="math">\\mathcal{E}</span> . Given access to  <span class="math">\\mathcal{A}</span> , and on inputs params,  <span class="math">c</span>  and  <span class="math">(r_0,\\ldots ,r_{2\\cdot \\ell -1})</span> ,  <span class="math">\\mathcal{E}</span>  operates as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Having observed and collected  <span class="math">\\mathcal{A}</span> 's queries up until the point of its outputting  <span class="math">c</span> ,  <span class="math">\\mathcal{E}</span>  initializes the empty matrix  <span class="math">(u_i)_{i=0}^{m-1}</span> .  <span class="math">\\mathcal{E}</span>  defines the following algorithm, which is essentially a slight simplification of an algorithm, called Valiant's extractor, given in Ben-Sasson, Chiesa and Spooner [BCS16, § A.1].</li>

    </ol>

    <p class="text-gray-300">1: procedure TREEBUILDER  <span class="math">(h,i,j)</span> 2: if  <span class="math">i = 0</span>  and  <span class="math">h \\stackrel{?}{=} H\\left((x_i)_{i=0}^{m-1}\\right)</span>  arises as some oracle output then 3: overwrite the value of the  <span class="math">j^{\\mathrm{th}}</span>  column  <span class="math">(u_{i,j})_{i = 0}^{m - 1}\\coloneqq (x_i)_{i = 0}^{m - 1}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4: else if  <span class="math">i &amp;gt; 0</span>  and  $h \\stackrel{?}{=} H(h_0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_1)$  arises as some oracle output then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5: recursively kick off TREEBUILDER  <span class="math">(h_0,i - 1,2\\cdot j)</span>  and TREEBUILDER  <span class="math">(h_1,i - 1,2\\cdot j + 1)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span>  executes TREEBUILDER  <span class="math">(c,\\log n,0)</span> .  <span class="math">\\mathcal{E}</span>  writes  <span class="math">M\\subset \\{0,\\ldots ,n - 1\\}</span>  for the set of never-assigned indices.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}</span>  internally runs  <span class="math">\\mathcal{A}</span>  on the further input  <span class="math">(r_0, \\ldots, r_{2\\cdot \\ell - 1})</span>  in a straight-line manner, until  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">s</span>  and  <span class="math">\\pi</span> . If  <span class="math">\\Pi</span> . Verify (params,  <span class="math">c, s, (r_0, \\ldots, r_{2\\cdot \\ell - 1}), \\pi = 0</span> , then  <span class="math">\\mathcal{E}</span>  outputs  <span class="math">(s, \\pi; \\bot, \\bot)</span>  and terminates.</li>

      <li><span class="math">\\mathcal{E}</span>  defines:</li>

    </ol>

    <p class="text-gray-300">1: procedure EXTRACTPROOF() 2: while true do 3: rewind  <span class="math">\\mathcal{A}</span>  to its initial point (i.e., immediately after outputting  <span class="math">c</span> ). 4: freshly sample  <span class="math">(r_0,\\dots ,r_{2\\cdot \\ell -1})\\gets \\mathcal{Q}(\\text{params})</span> 5: run  <span class="math">\\mathcal{A}</span>  on  <span class="math">(r_0,\\dots ,r_{2\\cdot \\ell -1})</span>  , with fresh verifier randomness, until it outputs  <span class="math">(s,\\pi)</span> 6: if  <span class="math">\\Pi</span> . Verify (params,  <span class="math">c, s, (r_0, \\ldots, r_{2 \\cdot \\ell - 1}), \\pi</span> ) then return  <span class="math">t&#x27;</span>  and  <span class="math">(r_0, \\ldots, r_{2 \\cdot \\ell - 1})</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span>  writes  <span class="math">(r_{0,0},\\ldots ,r_{0,2\\cdot \\ell -1})</span>  for the randomness it used in  <span class="math">\\mathcal{A}</span> 's initial proof above and  <span class="math">t_0^\\prime</span>  for the message sent by  <span class="math">\\mathcal{A}</span>  during the course of its initial proof. By running the routine EXTRACTPROOF() above  <span class="math">m - 1</span>  further times,  <span class="math">\\mathcal{E}</span>  extends these quantities to matrices  <span class="math">(t_i^{\\prime})_{i = 0}^{m - 1}</span>  and  <span class="math">(r_{i,0},\\dots,r_{i,2\\cdot \\ell -1})_{i = 0}^{m - 1}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}</span>  checks if the  <span class="math">m\\times m</span>  matrix  <span class="math">\\left(\\bigotimes_{j = \\ell}^{2\\cdot \\ell -1}(1 - r_{i,j},r_{i,j})\\right)_{i = 0}^{m - 1}</span>  is invertible. If it's not,  <span class="math">\\mathcal{E}</span>  outputs  <span class="math">(s,\\pi ;\\bot ,u)</span></li>

      <li>Otherwise,  <span class="math">\\mathcal{E}</span>  performs the matrix operation:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c} - &amp;amp; t _ {0} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; t _ {m - 1} &amp;amp; - \\end{array} \\right] := \\left[ \\begin{array}{c c c} - &amp;amp; \\bigotimes_ {j = \\ell} ^ {2 \\cdot \\ell - 1} (1 - r _ {0, j}, r _ {0, j}) &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; \\bigotimes_ {j = \\ell} ^ {2 \\cdot \\ell - 1} (1 - r _ {m - 1, j}, r _ {m - 1, j}) &amp;amp; - \\end{array} \\right] ^ {- 1} \\cdot \\left[ \\begin{array}{c c c} - &amp;amp; t _ {0} ^ {\\prime} &amp;amp; - \\\\ &amp;amp; \\vdots &amp;amp; \\\\ - &amp;amp; t _ {m - 1} ^ {\\prime} &amp;amp; - \\end{array} \\right],</span></div>

    <p class="text-gray-300">sets as  <span class="math">t(X_0, \\dots, X_{2 \\cdot \\ell - 1}) \\in \\mathbb{F}_q[X_0, \\dots, X_{2 \\cdot \\ell - 1}]</span>  the polynomial whose coefficients (in the multilinear Lagrange basis) are given by the concatenation of  <span class="math">(t_i)_{i=0}^{m-1}</span> 's rows, and outputs  <span class="math">(s, \\pi; t, u)</span> .</p>

    <p class="text-gray-300">In the algorithm TREEBUILDER, we understand the conditions 2 and 4 as demanding that the relevant preimages be well-formed. That is, in case  <span class="math">h</span>  does arise as the output of a prior query, whose input, however, is malformed (in that it doesn't match the format demanded), we understand the relevant condition as failing to be fulfilled. If  <span class="math">h</span>  arises as the output of multiple, distinct, well-formed preimages, then we stipulate that  <span class="math">\\mathcal{E}</span>  select arbitrarily among these preimages (this event can only occur if  <span class="math">\\mathcal{A}</span>  finds an oracle collision).</p>

    <p class="text-gray-300">We now argue that  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time in  <span class="math">\\lambda</span> . We write  <span class="math">\\varepsilon</span>  for the probability that  <span class="math">\\mathcal{A}</span>  passes, conditioned on its state as of the point at which it first outputs  <span class="math">c</span>  (this probability is taken over the coins of both  <span class="math">\\mathcal{Q}</span>  and  <span class="math">\\mathcal{V}</span> , and over the further coins of  <span class="math">\\mathcal{A}</span> ). We note that, for each fixed  <span class="math">c</span> ,  <span class="math">\\mathcal{E}</span>  proceeds beyond step 2 above with probability exactly  <span class="math">\\varepsilon</span> . Moreover, each execution of EXTRACTPROOF terminates in expected time exactly  <span class="math">\\frac{1}{\\varepsilon}</span> , since that algorithm's line 6 passes with probability exactly  <span class="math">\\varepsilon</span>  per iteration of that algorithm. Finally, TREEBUILDER is straight-line and polynomial time. We conclude that  <span class="math">\\mathcal{E}</span> 's total expected runtime is at most that of TREEBUILDER plus  <span class="math">1 + \\varepsilon \\cdot \\frac{m - 1}{\\varepsilon} = m</span>  times the time it takes to run Construction 4.6 once; this total time is thus polynomial in  <span class="math">\\lambda</span>  (and independent of  <span class="math">c</span>  and  <span class="math">\\varepsilon</span> ).</p>

    <p class="text-gray-300">We now analyze the distribution returned by <span class="math">\\mathcal{E}</span>. We note that the outputs <span class="math">(c,s,\\pi)</span> upon which <span class="math">\\mathcal{D}</span> runs are identically distributed in the distributions <span class="math">\\operatorname{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span> and <span class="math">\\operatorname{Emul}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span>. It thus suffices to show that it holds in at most a negligible proportion of executions of <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{Q}</span> and <span class="math">\\mathcal{E}</span> that, simultaneously, <span class="math">\\Pi</span>. Verify <span class="math">(\\text{params},c,s,(r_0,\\ldots,r_{2\\cdot\\ell-1}),\\pi)=1</span> and either <span class="math">\\Pi</span>. Open <span class="math">(\\text{params},t;c,u)=0</span> or <span class="math">t(r_0,\\ldots,r_{2\\cdot\\ell-1})\\neq s</span>. We write <span class="math">Q(\\lambda)</span> for a polynomial upper bound on the number of random oracle queries <span class="math">\\mathcal{A}</span> makes. We recall from <em>[x1, § A.1]</em> that it holds with probability at most <span class="math">\\frac{Q(\\lambda)^2+1}{2^s}</span>, which is negligible, that <span class="math">\\mathcal{A}</span> outputs—during any particular among its executions—either a valid Merkle path on a missing column <span class="math">j\\in M</span> or, for some <span class="math">j\\not\\in M</span>, a valid Merkle opening <span class="math">(u_{i,j})_{i=0}^{m-1}</span> inconsistent with the matrix extracted by <span class="math">\\mathcal{E}</span> in step 1 above.</p>

    <p class="text-gray-300">In the following lemma, we write <span class="math">\\overline{C}</span> for the puncturing of <span class="math">C</span> at <span class="math">M</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 4.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathcal{E}</span>’s matrix satisfies $d^{m}\\Bigl{(}(u_{i})_{i=0}^{m-1},\\overline{C}^{m}\\Bigr{)}\\geq\\frac{d}{3}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then </span>\\mathcal{A}$ passes with negligible probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first argue that we may freely assume that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{d}{3}<span class="math">. Indeed, if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{d}{3}<span class="math">, then </span>J\\cap M=\\varnothing<span class="math"> holds with probability at most </span>\\bigl{(}1-\\frac{d}{3\\cdot n}\\bigr{)}^{\\gamma}<span class="math">, which is negligible, since </span>d=\\Omega(n)<span class="math"> and </span>\\gamma=\\Theta(\\lambda)<span class="math">. On the other hand, </span>\\mathcal{A}<span class="math"> can pass in case </span>J\\cap M\\neq\\varnothing$ only by submitting valid a Merkle opening against a missing column.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We thus assume that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{d}{3}<span class="math">, and moreover write </span>e\\coloneqq\\Bigl{\\lfloor}\\frac{d-1}{3}\\Bigr{\\rfloor}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since the distance, say </span>\\overline{d}<span class="math">, of </span>\\overline{C}<span class="math"> is at least </span>d-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which itself satisfies </span>\\Bigl{\\lfloor}\\frac{\\overline{d}-1}{3}\\Bigr{\\rfloor}\\geq\\Bigl{\\lfloor}\\frac{d-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{3}\\Bigr{\\rfloor}\\geq\\Bigl{\\lfloor}\\frac{d-1}{3}\\Bigr{\\rfloor}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=e<span class="math">, we see that </span>e\\in\\Bigl{\\{}0,\\ldots,\\Bigl{\\lfloor}\\frac{\\overline{d}-1}{3}\\Bigr{\\rfloor}\\Bigr{\\}}<span class="math">. On the other hand, by our hypothesis, </span>d^{m}\\Bigl{(}(u_{i})_{i=0}^{m-1},\\overline{C}^{m}\\Bigr{)}>e<span class="math">. We abbreviate </span>u^{\\prime}\\coloneqq\\bigotimes_{i=\\ell}^{2\\cdot\\ell-1}(1-r_{i},r_{i})\\cdot(u_{i})_{i=0}^{m-1}<span class="math">. Applying the contraposition of Theorem 3.1 to the code </span>\\overline{C}<span class="math">, we conclude that, provided that the second half </span>(r_{\\ell},\\ldots,r_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}^{\\ell}<span class="math"> of the verifier’s random point resides outside a set of mass at most </span>2\\cdot\\ell\\cdot\\frac{e+1}{q}<span class="math"> in </span>\\mathbb{F}_{q}^{\\ell}<span class="math">, we have </span>d\\bigl{(}u^{\\prime},\\overline{C}\\bigr{)}>e<span class="math">. In particular, for each such </span>(r_{\\ell},\\ldots,r_{2\\cdot\\ell-1})<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))\\cup M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>e+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left\\lfloor\\frac{d-1}{3}\\right\\rfloor<span class="math"> in fact holds, since </span>\\operatorname{Enc}(t^{\\prime})<span class="math"> is a codeword. We conclude that </span>J\\cap(\\Delta(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))\\cup M)=\\varnothing<span class="math"> holds with probability at most </span>\\bigl{(}1-\\frac{d}{3\\cdot n}\\bigr{)}^{\\gamma}<span class="math">. On the other hand, if </span>J\\cap(\\Delta(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))\\cup M)\\neq\\varnothing<span class="math">, then we claim that </span>\\mathcal{V}<span class="math"> accepts with negligible probability. Indeed, </span>\\mathcal{A}<span class="math"> can pass on an index </span>j\\in M<span class="math"> only by Merkle-opening a missing column, and on an index </span>j\\in\\Delta(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))\\setminus M<span class="math"> only by Merkle-opening a column inconsistent with that extracted by </span>\\mathcal{E}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Putting the pieces together, we see that <span class="math">\\mathcal{A}</span>’s chance of passing is at most <span class="math">\\frac{Q(\\lambda)^{2}+1}{2^{s}}+2\\cdot\\ell\\cdot\\frac{d}{q}+\\bigl{(}1-\\frac{d}{3\\cdot n}\\bigr{)}^{\\gamma}</span> (here, we crudely upper-bound <span class="math">2\\cdot\\ell\\cdot\\frac{e+1}{q}\\leq 2\\cdot\\ell\\cdot\\frac{d}{q}</span>). As <span class="math">q\\geq 2^{\\omega(\\log\\lambda)}</span> holds by construction, and <span class="math">d</span> and <span class="math">\\ell</span> are polynomial in <span class="math">\\lambda</span>, <span class="math">2\\cdot\\ell\\cdot\\frac{d}{q}</span> is negligible. On the other hand, we again have that <span class="math">\\bigl{(}1-\\frac{d}{3\\cdot n}\\bigr{)}^{\\gamma}</span> is negligible. This completes the proof of the lemma. ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applying Lemma 4.9, we assume henceforth that $d^{m}\\Bigl{(}(u_{i})_{i=0}^{m-1},\\overline{C}^{m}\\Bigr{)}<\\frac{d}{3}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We conclude immediately that there exists an interleaved message </span>(t_{i})_{i=0}^{m-1}<span class="math"> for which </span>\\Bigl{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Delta^{m}\\Bigl{(}(u_{i})_{i=0}^{m-1},(\\operatorname{Enc}(t_{i}))_{i=0}^{m-1}\\Bigr{)}\\cup M\\Bigr{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\frac{d}{3}<span class="math">. We note that, a fortiori, </span>d^{m}\\Bigl{(}(u_{i})_{i=0}^{m-1},(\\operatorname{Enc}(t_{i}))_{i=0}^{m-1}\\Bigr{)}<\\frac{d}{3}<span class="math"> too holds. The following lemma shows that we may further restrict our attention to the case in which </span>\\mathcal{A}<span class="math"> correctly outputs </span>t^{\\prime}=\\bigotimes_{i=\\ell}^{2\\cdot\\ell-1}(1-r_{i},r_{i})\\cdot(t_{i})_{i=0}^{m-1}$ during its initial proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-22" class="text-base font-medium mt-4">Lemma 4.10.</h6>

    <p class="text-gray-300">If its message <span class="math">t^{\\prime}\\neq\\bigotimes_{i=\\ell}^{2\\cdot\\ell-1}(1-r_{i},r_{i})\\cdot(t_{i})_{i=0}^{m-1}</span>, then <span class="math">\\mathcal{A}</span> passes with negligible probability.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We write <span class="math">e\\coloneqq\\Bigl{\\lfloor}\\frac{d-1}{3}\\Bigr{\\rfloor}</span>, and abbreviate <span class="math">u^{\\prime}\\coloneqq\\bigotimes_{i=\\ell}^{2\\cdot\\ell-1}(1-r_{i},r_{i})\\cdot(u_{i})_{i=0}^{m-1}</span>; we moreover write <span class="math">v^{\\prime}\\coloneqq\\bigotimes_{i=\\ell}^{2\\cdot\\ell-1}(1-r_{i},r_{i})\\cdot(\\operatorname{Enc}(t_{i}))_{i=0}^{m-1}</span>. By the argument just given, we may freely assume that <span class="math">d^{m}\\Bigl{(}(u_{i})_{i=0}^{m-1},C^{m}\\Bigr{)}\\leq e</span> holds; in particular, <span class="math">d(u^{\\prime},v^{\\prime})\\leq e</span>. On the other hand, our hypothesis implies that <span class="math">\\operatorname{Enc}(t^{\\prime})\\neq v^{\\prime}</span>. By the reverse triangle inequality, we thus have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$d(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d(\\operatorname{Enc}(t^{\\prime}),v^{\\prime})-d(u^{\\prime},v^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d-e.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We see that <span class="math">J\\cap\\Delta(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))=\\varnothing</span> holds with probability at most <span class="math">\\bigl{(}1-\\frac{d-e}{n}\\bigr{)}^{\\gamma}\\leq\\bigl{(}1-\\frac{2\\cdot d}{3\\cdot n}\\bigr{)}^{\\gamma}</span>, which is negligible. On the other hand, if <span class="math">\\mathcal{V}</span> queries any position <span class="math">j\\in\\Delta(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))</span>, then either <span class="math">j\\in M</span> or <span class="math">j\\in\\Delta(u^{\\prime},\\operatorname{Enc}(t^{\\prime}))\\setminus M</span>; in these cases, <span class="math">\\mathcal{A}</span> can pass only by exhibiting an oracle collision (on a missing or on an existing column, respectively). This again completes the proof, in light of the guarantees <span class="math">d=\\Omega(n)</span> and <span class="math">\\gamma=\\Theta(\\lambda)</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We thus restrict our attention to the case in which <span class="math">\\mathcal{A}</span>'s initial proof <span class="math">\\pi</span> passes and there exists a message <span class="math">(t_i)_{i=0}^{m-1}</span> for which both $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^m\\left((u_i)_{i=0}^{m-1}, (\\mathsf{Enc}(t_i))_{i=0}^{m-1}\\right) \\cup M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\frac{d}{3}<span class="math"> and </span>t' = \\bigotimes_{i=\\ell}^{2 \\cdot \\ell-1}(1 - r_i, r_i) \\cdot (t_i)_{i=0}^{m-1}$ hold. We denote:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\delta := \\frac {Q (\\lambda) ^ {2} + 1}{2 ^ {\\lambda}} + \\left(1 - \\frac {2 \\cdot d}{3 \\cdot n}\\right) ^ {\\gamma} + \\frac {\\ell}{q}.</span></div>

    <p class="text-gray-300">Since <span class="math">\\delta</span> is negligible in <span class="math">\\lambda</span>, <span class="math">\\sqrt{\\delta}</span> also is. In this light, we may simply ignore each execution for which <span class="math">\\mathcal{A}</span>'s probability of success <span class="math">\\varepsilon \\leq \\sqrt{\\delta}</span>, since in that case <span class="math">\\mathcal{E}</span> proceeds into step 3 in the first place with negligible probability. We thus assume that <span class="math">\\varepsilon &amp;gt; \\sqrt{\\delta}</span> in what follows. In the following technical lemma, we write <span class="math">V</span> for the event in which <span class="math">\\mathcal{A}</span> submits an accepting proof, and <span class="math">E</span> for a further, arbitrary event.</p>

    <p class="text-gray-300"><strong>Lemma 4.11.</strong> Assuming as above that <span class="math">\\operatorname<em>{Pr}[V] &amp;gt; \\sqrt{\\delta}</span>, if <span class="math">\\operatorname</em>{Pr}[V \\wedge E] \\leq \\delta</span> moreover holds, then <span class="math">\\operatorname*{Pr}[E \\mid V] \\leq \\sqrt{\\delta}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Assuming the hypotheses of the lemma, we see that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ E \\mid V ] = \\frac {\\Pr [ V \\wedge E ]}{\\Pr [ V ]} &amp;lt;   \\frac {\\delta}{\\sqrt {\\delta}} = \\sqrt {\\delta},</span></div>

    <p class="text-gray-300">as required.</p>

    <p class="text-gray-300"><strong>Lemma 4.12.</strong> The probability that <span class="math">t_i&#x27; \\neq \\bigotimes_{j = \\ell}^{2 \\cdot \\ell - 1}(1 - r_{i,j}, r_{i,j}) \\cdot (t_i)_{i = 0}^{m - 1}</span> for any <span class="math">i \\in \\{1, \\dots, m - 1\\}</span> is negligible.</p>

    <p class="text-gray-300"><strong>Proof.</strong> For each <span class="math">i^<em> \\in \\{1, \\ldots, m - 1\\}</span>, we write <span class="math">E_{i^</em>}</span> for the event in which <span class="math">\\mathcal{A}</span>'s <span class="math">i^{<em>th}</span> message <span class="math">t_{i^</em>}&#x27; \\neq \\bigotimes_{j = \\ell}^{2 \\cdot \\ell - 1}(1 - r_{i^<em>, j}, r_{i^</em>, j}) \\cdot (t_i)_{i = 0}^{m - 1}</span>. By the argument of Lemma 4.10, <span class="math">\\operatorname<em>{Pr}[V \\mid E_{i^</em>}]</span> is at most <span class="math">\\frac{Q(\\lambda)^2 + 1}{2^\\lambda} + \\left(1 - \\frac{2 \\cdot d}{3 \\cdot n}\\right)^\\gamma \\leq \\delta</span>. We thus see that <span class="math">\\operatorname<em>{Pr}[V \\wedge E_{i^</em>}] = \\operatorname<em>{Pr}[V \\mid E_{i^</em>}] \\cdot \\operatorname<em>{Pr}[E_{i^</em>}] \\leq \\delta</span>, so that the hypothesis of Lemma 4.11 is fulfilled, and <span class="math">\\operatorname<em>{Pr}[E_{i^</em>} \\mid V] \\leq \\sqrt{\\delta}</span> holds. The probability that any among the events <span class="math">E_1, \\ldots, E_{m-1}</span> holds is thus at most <span class="math">1 - \\left(1 - \\sqrt{\\delta}\\right)^{m-1} \\leq (m-1) \\cdot \\sqrt{\\delta}</span>, which is negligible (here, we use a standard binomial approximation).</p>

    <p class="text-gray-300"><strong>Lemma 4.13.</strong> The probability that the rows <span class="math">\\left(\\bigotimes_{j = \\ell}^{2\\cdot \\ell -1}(1 - r_{i,j},r_{i,j})\\right)_{i = 0}^{m - 1}</span> are linearly dependent is negligible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> We first argue that for <span class="math">A \\subset \\mathbb{F}_q^m</span> an arbitrary proper linear subspace, and $S \\coloneqq \\left\\{(r_{\\ell}, \\ldots, r_{2 \\cdot \\ell - 1}) \\in \\mathbb{F}_q^\\ell \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bigotimes_{i = \\ell}^{2 \\cdot \\ell - 1}(1 - r_i, r_i) \\in A\\right\\}<span class="math"> its preimage under the tensor map, we have </span>\\mu(S) \\leq \\frac{\\ell}{q}<span class="math">. It suffices to prove the result only in case </span>A<span class="math"> is a hyperplane. We write </span>a = (a_0, \\ldots, a_{m-1})<span class="math"> for a vector of coefficients, not all zero, for which </span>A = \\{u \\in \\mathbb{F}_q^m \\mid u \\cdot a = 0\\}<span class="math"> holds. By construction, </span>(r_{\\ell}, \\ldots, r_{2 \\cdot \\ell - 1}) \\in S<span class="math"> if and only if </span>\\bigotimes_{i = \\ell}^{2 \\cdot \\ell - 1}(1 - r_i, r_i) \\cdot a = 0<span class="math">. We see that </span>S \\subset \\mathbb{F}_q^\\ell<span class="math"> is nothing other than the vanishing locus of that combination of the </span>\\ell<span class="math">-variate multilinear Lagrange polynomials given by the coefficient vector </span>a<span class="math">. Because </span>a<span class="math"> is not identically zero and these polynomials are linearly independent, the combination is itself nonzero. Applying Schwartz-Zippel, we see that the vanishing locus </span>S \\subset \\mathbb{F}_q^\\ell<span class="math"> is of mass at most </span>\\mu(S) \\leq \\frac{\\ell}{q}$, as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that <span class="math">\\bigotimes_{j = \\ell}^{2\\cdot \\ell -1}(1 - r_{0,j},r_{0,j})</span> is not the zero vector, since its components necessarily sum to 1. For each <span class="math">i^{<em>}\\in \\{1,\\ldots ,m - 1\\}</span>, we set as <span class="math">A_{i^</em>}\\subset \\mathbb{F}_q^m</span> the span of <span class="math">\\left(\\bigotimes_{j = \\ell}^{2\\cdot \\ell -1}(1 - r_{i,j},r_{i,j})\\right)_{i = 0}^{i^<em> -1}</span>, and write <span class="math">E_{i^</em>}</span> for the event in which <span class="math">\\bigotimes_{j = \\ell}^{2\\cdot \\ell -1}(1 - r_{i^<em>,j},r_{i^</em>,j})\\in A_{i^<em>}</span>. The argument above implies exactly that <span class="math">\\operatorname</em>{Pr}[E_{i^<em>}]\\leq \\frac{\\ell}{q}\\leq \\delta</span>; we conclude in particular that <span class="math">\\operatorname</em>{Pr}[V\\wedge E_{i^<em>}] = \\operatorname</em>{Pr}[V\\mid E_{i^<em>}]\\cdot \\operatorname</em>{Pr}[E_{i^<em>}]\\leq \\delta</span>, and the hypothesis of Lemma 4.11 is again fulfilled. Applying Lemma 4.11 repeatedly, we conclude again that the probability that any of the events <span class="math">E_{i^</em>}</span> holds, for <span class="math">i^{*}\\in \\{1,\\dots ,m - 1\\}</span>, is at most <span class="math">1 - \\left(1 - \\sqrt{\\delta}\\right)^{m - 1}\\leq (m - 1)\\cdot \\sqrt{\\delta}</span>, which is negligible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We finally argue that the values <span class="math">t</span> and <span class="math">u = (u_{i})_{i = 0}^{m - 1}</span> extracted by <span class="math">\\mathcal{E}</span> satisfy <span class="math">\\Pi .\\mathrm{Open}(\\mathrm{params},c;t,u)</span> and <span class="math">t(r_0,\\ldots ,r_{2\\cdot \\ell -1}) = s</span>. Indeed, under the condition guaranteed by Lemma 4.9, a matrix <span class="math">(t_i)_{i = 0}^{m - 1}</span> for which $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^m\\left((u_i)_{i = 0}^{m - 1},(\\mathsf{Enc}(t_i))_{i = 0}^{m - 1}\\right)\\cup M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\frac{d}{3}<span class="math"> exists. Under the conditions guaranteed by Lemmas 4.12 and 4.13, </span>\\mathcal{E}<span class="math"> extracts precisely this matrix </span>(t_i)_{i = 0}^{m - 1}<span class="math"> in steps 3 and 5. Finally, Lemma 4.10 guarantees that </span>\\mathcal{A}<span class="math">&#x27;s first message satisfies </span>t' = \\bigotimes_{i = \\ell}^{2\\cdot \\ell -1}(1 - r_i,r_i)\\cdot (t_i)_{i = 0}^{m - 1}<span class="math">; on the other hand, </span>\\Pi .\\mathrm{Verify}(\\mathrm{params},c,s,(r_0,\\ldots ,r_{2\\cdot \\ell -1}),\\pi)<span class="math"> implies that </span>s = t^{\\prime}\\cdot \\bigotimes_{i = 0}^{\\ell -1}(1 - r_i,r_i)<span class="math">. We conclude that </span>s = \\bigotimes_{i = \\ell}^{2\\cdot \\ell -1}(1 - r_i,r_i)\\cdot (t_i)_{i = 0}^{m - 1}\\cdot \\bigotimes_{i = 0}^{\\ell -1}(1 - r_i,r_i) = t(r_0,\\ldots ,r_{2\\cdot \\ell -1})$. This completes the proof of the theorem.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We record a few remarks about our proof. Theorem 4.8’s difficulty arises, roughly, from the fact that the <em>conditional</em> distribution of the messages <span class="math">t^{\\prime}</span> and of the random vectors <span class="math">(r_{0},\\ldots,r_{2\\cdot\\ell-1})\\in\\mathbb{F}_{q}^{2\\cdot\\ell}</span> which <span class="math">\\mathcal{E}</span> adds—that is, the distribution of these values, conditioned on <span class="math">\\mathcal{A}</span> passing—can be highly arbitrary; <span class="math">\\mathcal{A}</span> could, for example, output a successful proof with vastly higher probability when <span class="math">\\bigotimes_{i=\\ell}^{2\\cdot\\ell-1}(1-r_{i},r_{i})</span> resides in some fixed low-dimensional subspace <span class="math">A\\subset\\mathbb{F}_{q}^{m}</span> (let’s say) than when it doesn’t, thereby thwarting <span class="math">\\mathcal{E}</span>’s extraction. Our proof thus argues that if <span class="math">\\mathcal{A}</span> succeeds with high enough probability—specifically, with probability greater than a certain cutoff which, crucially, is <em>still negligible</em>, but which decays much more slowly than that of the relevant failure events—then the <em>conditional</em> distribution of <span class="math">\\mathcal{A}</span>’s outputs necessarily concentrates away from these bad events. The key idea is that <span class="math">\\delta</span>, by virtue of being negligible, necessarily admits an expression of the form <span class="math">\\delta=2^{-f(\\lambda)}</span>, for some <span class="math">f(\\lambda)=\\omega(\\log(\\lambda))</span>; we thus have in turn that <span class="math">\\sqrt{\\delta}</span> takes the form <span class="math">2^{-\\frac{1}{2}\\cdot f(\\lambda)}</span>. This latter quantity is <em>greater</em> than <span class="math">\\delta</span> by a factor of <span class="math">2^{\\frac{1}{2}\\cdot f(\\lambda)}</span>, which is superpolynomial; on the other hand, it is <em>itself</em> nonetheless still negligible. This maneuver, whereby the exponent is halved, can be performed on any negligible function. Upon excluding from our treatment those executions for which <span class="math">\\varepsilon\\leq\\sqrt{\\delta}</span>, we find that, in the remaining executions, <span class="math">\\mathcal{A}</span>’s success probability is sufficiently “high” that failure events necessarily figure negligibly in it, regardless of <span class="math">\\mathcal{A}</span>’s strategy. This latter step is made precise by a Bayes-like argument.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Brakedown’s proof.</h4>

    <p class="text-gray-300">We compare our proof strategy to that of Brakedown <em>[x10, Lems. 2 and 3]</em>, which proves a similar result. We ignore purposefully those differences between our proofs which pertain specifically to our consolidation of that protocol’s two phases, and focus instead on the “rest of” the proof, which poses similar challenges in our respective settings.</p>

    <p class="text-gray-300">Brakedown’s proof, essentially, handles the non-uniformity of <span class="math">\\mathcal{A}</span>’s conditional output distribution by stipulating that the emulator <span class="math">\\mathcal{E}</span> filter “actively”, using rejection sampling to curate an artificially uniform distribution over some sufficiently large set of coefficient vectors. This procedure requires that <span class="math">\\mathcal{E}</span> “know” <span class="math">\\mathcal{A}</span>’s success probability <span class="math">\\varepsilon</span>. Brakedown’s emulator brings about this state of affairs using various techniques, including a procedure of Hazay and Lindell <em>[x14, Thm. 6.5.6]</em> (which these latter authors attribute to Goldreich). Informally, Brakedown’s approach makes the independence analysis of the emulator’s coefficient vectors <em>easier</em>, since the relevant vectors are, by fiat, drawn from a uniform distribution over some set (cf. our Lemma 4.13). On the other hand, it makes the acquisition of these vectors more complicated, since it mandates that the emulator evaluate their membership in the relevant set.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We record a few possible issues with that proof as written, which seem, by and large, rectifiable. First of all, <em>[x10, Lem. 2]</em> assumes a <em>deterministic</em> prover. This property is indeed used by that proof, namely in its assertion that <span class="math">\\mathcal{E}</span>’s inspection of <span class="math">\\mathcal{P}</span>’s response <span class="math">u^{\\prime}</span> “enables <span class="math">\\mathcal{E}</span> to determine whether <span class="math">r\\in T</span>”. Sure enough, the membership of each given <span class="math">r\\in\\mathbb{F}^{m}</span> in <span class="math">T</span> depends, in general, <em>both</em> on the coins <span class="math">\\mathcal{P}</span> flips while constructing <em><span class="math">u</span> and</em> on the coins <span class="math">\\mathcal{V}</span> flips while selecting its challenge columns. It would thus fail to hold—for randomized <span class="math">\\mathcal{P}</span>—that <span class="math">\\mathcal{E}</span> could even determine <em>which</em> among its candidates <span class="math">r</span> reside in <span class="math">T</span>, given these vectors’ accompanying responses <span class="math">u^{\\prime}</span> alone, let alone that those vectors <span class="math">r</span> which do belong to <span class="math">T</span> moreover feature responses <span class="math">u^{\\prime}</span> which cause <span class="math">\\mathcal{V}</span> to accept with probability <span class="math">\\epsilon/2</span> or more (over its choice of random columns). This latter condition in turn is invoked—implicitly—in the extraction procedure by which <span class="math">\\mathcal{E}</span>, from the vectors <span class="math">u^{\\prime}_{1},\\ldots,u^{\\prime}_{m}</span>, obtains its witness <em>[x10, pp. 208–209]</em>. (Actually, this latter reduction moreover implicitly assumes that <span class="math">\\epsilon</span> is large enough—that is, greater than both $N/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(1-\\gamma/3)^{\\ell}<span class="math"> and </span>(1-(2/3)\\gamma)^{\\ell}<span class="math"> <em>[x10, (5) and (6)]</em>—and certainly fails otherwise; some hypothesis on </span>\\varepsilon$ is thus necessary for this extraction to go through.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For randomized <span class="math">\\mathcal{P}</span>, <span class="math">\\mathcal{E}</span> may be able to rectify this issue by extracting not just one response <span class="math">u^{\\prime}</span> from <span class="math">\\mathcal{P}</span>, but many (running <span class="math">\\mathcal{P}</span> with fresh random tape each time), and testing <em>each</em> <span class="math">u^{\\prime}</span> for agreement with <span class="math">\\pi</span> vis-à-vis <span class="math">r</span>. By a Chernoff-style calculation akin to that which <em>[x10, Lem. 2]</em>’s current extractor runs with respect to the property <span class="math">r\\in T</span>, that approach might successfully force the existence (with high probability) of at least one response <span class="math">u^{\\prime}</span> whose acceptance probability is sufficiently high as to make <span class="math">\\mathcal{E}</span>’s subsequent extraction go through (or else, barring that, supply sufficiently strong evidence that <span class="math">r\\not\\in T</span> as to justify <span class="math">\\mathcal{E}</span>’s abandoning <span class="math">r</span>). Alternatively, the proof would need to justify its assumption whereby <span class="math">\\mathcal{P}</span> is deterministic. Interestingly, the most compelling strategy whereby this latter assumption might be justified appears to encounter an identical obstacle. That strategy would, it seems, proceed by showing that <span class="math">\\mathcal{E}</span> may bootstrap any given random prover into a deterministic one, without excessively impacting that prover’s probability of success. To do this, <span class="math">\\mathcal{E}</span> would proceed by repeatedly sampling candidate random tapes for its random prover <span class="math">\\mathcal{P}</span> until finding one which causes <span class="math">\\mathcal{P}</span> to pass with “high” probability over <span class="math">\\mathcal{V}</span>’s coins. The problem of determining this suitable random tape is essentially the same as that—just discussed—of determining whether <span class="math">r\\in T</span>.</p>

    <p class="text-gray-300">The proof’s claim that “if <span class="math">\\epsilon</span> is not inverse-polynomial in <span class="math">m</span> and <span class="math">\\lambda</span>, this expected runtime is not polynomial in <span class="math">m</span> and <span class="math">\\lambda</span>” seems unduly pessimistic. While the runtime of <span class="math">\\mathcal{E}</span>—conditioned on its entering the extraction phase in the first place—is certainly not polynomial in <span class="math">\\lambda</span> in general, it is polynomial in <span class="math">\\lambda</span> and <span class="math">\\frac{1}{\\epsilon}</span>. (In fact, that procedure will, roughly, terminate in time either <span class="math">\\frac{36(m+\\lambda)}{\\epsilon}</span> or <span class="math">\\frac{36(m+\\lambda)}{2^{-\\lambda/\\epsilon}}</span>, whichever is smaller.) Since <span class="math">\\mathcal{E}</span> only enters this phase in the first place with probability <span class="math">\\epsilon</span>, it is the latter condition, and not the former, which is necessary to establish an expected polynomial-time emulator. We thus question whether the simultaneous use both of Hazay and Lindell <em>[x13, Thm. 6.5.6]</em> and of the geometric decay technique is necessary.</p>

    <p class="text-gray-300">We find that our proof strategy represents an interesting alternative to Brakedown’s. Our emulator’s description and our estimation of its runtime are significantly simpler. Our emulator’s success probability is perhaps comparably complicated to analyze, though we have undertaken our analysis with considerable attention to detail.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">4.3 Complexity</h3>

    <p class="text-gray-300">We discuss the theoretical efficiency of Construction 4.6. Implemented naïvely, Construction 4.6 admits proofs consisting of exactly <span class="math">m\\cdot(\\gamma+1)</span> <span class="math">\\mathbb{F}_{q}</span>-elements (<span class="math">\\mathcal{P}</span> must send the single <span class="math">m</span>-element message <span class="math">t^{\\prime}</span>, as well as the <span class="math">\\gamma</span> <span class="math">m</span>-element columns <span class="math">(u_{i,j})_{i=0}^{m-1}</span>). We recall an optimization discussed in Brakedown <em>[Gol+23, § 4]</em>, and attributed by that work to Ligero. Construction 4.6 works even when the input matrix <span class="math">(t_{i})_{i=0}^{m-1}</span> is not square, but rather of size <span class="math">m_{0}\\times m_{1}</span>, say, where <span class="math">m_{0}\\cdot m_{1}=2^{2\\cdot\\ell}</span>. Moreover, the resulting variant of the protocol has proof size exactly <span class="math">m_{1}+\\gamma\\cdot m_{0}</span>. To minimize this size, we choose <span class="math">m_{0}</span> and <span class="math">m_{1}</span> so that <span class="math">m_{1}=\\gamma\\cdot m_{0}</span> holds; in particular, we set <span class="math">m_{0}\\coloneqq\\frac{1}{\\sqrt{\\gamma}}\\cdot m</span> and <span class="math">m_{1}\\coloneqq\\sqrt{\\gamma}\\cdot m</span> (where <span class="math">m</span> here denotes <span class="math">2^{\\ell}</span>). The resulting proof clearly has size <span class="math">m_{1}+\\gamma\\cdot m_{0}=2\\cdot\\sqrt{\\gamma}\\cdot m</span>. This measure thus improves the proof size quadratically in <span class="math">\\gamma</span> (compared to the naïve approach in which a square matrix is used).</p>

    <p class="text-gray-300">The standard Brakedown commitment scheme—that is, the variant in which the two phases are not consolidated—features proofs containing <span class="math">2\\cdot m_{1}+\\gamma\\cdot m_{0}</span> elements, since two messages must be sent (our improvement eliminates this factor of two). Brakedown’s optimization thus seeks to achieve <span class="math">2\\cdot m_{1}=\\gamma\\cdot m_{0}</span>, and accordingly sets <span class="math">m_{0}\\coloneqq\\sqrt{\\frac{2}{\\gamma}}\\cdot m</span> and <span class="math">m_{1}\\coloneqq\\sqrt{\\frac{\\omega}{2}}\\cdot m</span>. The resulting proof is thus of size <span class="math">2\\cdot\\sqrt{2\\cdot\\gamma}\\cdot m</span>. We note the resulting extra factor of <span class="math">\\sqrt{2}</span>, absent from our proof’s size.</p>

    <p class="text-gray-300">We finally discuss Construction 4.6’s prover and verifier runtime efficiency. We write <span class="math">\\mathsf{Enc}(\\lambda)</span> for the runtime of <span class="math">C</span>’s encoding procedure. It is easy to see that <span class="math">\\mathcal{P}</span>’s runtime is <span class="math">\\frac{1}{\\sqrt{\\gamma}}\\cdot m\\cdot\\mathsf{Enc}(\\lambda)</span> during the commitment phase and <span class="math">\\frac{1}{\\sqrt{\\gamma}}\\cdot m\\cdot\\sqrt{\\gamma}\\cdot m=m^{2}</span> in the evaluation phase, for a total of <span class="math">\\frac{1}{\\sqrt{\\gamma}}\\cdot m\\cdot\\mathsf{Enc}(\\lambda)+m^{2}</span>. In the special case that <span class="math">\\mathsf{Enc}</span> is linear-time in <span class="math">m</span>—Brakedown’s code <em>[x10, § 5]</em>, e.g., satisfies this property—the total cost across both phases becomes <span class="math">m^{2}+O\\Big{(}\\frac{1}{\\sqrt{\\lambda}}\\cdot m^{2}\\Big{)}</span>; since each polynomial <span class="math">t(X_{0},\\ldots,X_{2\\cdot\\ell-1})</span> requires <span class="math">m^{2}</span> field elements to represent, this efficiency is essentially optimal. The prover cost of the standard Brakedown scheme is <span class="math">\\frac{1}{\\sqrt{\\gamma}}\\cdot m\\cdot\\mathsf{Enc}(\\lambda)+2\\cdot m^{2}</span> (we note the extra factor of 2). Specializing again to the linear-time-encodable case, we obtain a total cost of <span class="math">2\\cdot m^{2}+O\\Big{(}\\frac{1}{\\sqrt{\\lambda}}\\cdot m^{2}\\Big{)}</span> for the standard scheme; we see that we improve the prover runtime of Brakedown’s commitment scheme by a factor of 2, up to lower-order terms. (If the implicit linear constant in the runtime of <span class="math">\\mathsf{Enc}</span> is very large, however, then our improvement may remain limited until <span class="math">\\lambda</span> becomes large.)</p>

    <p class="text-gray-300">Construction 4.6’s verifier complexity is <span class="math">\\mathsf{Enc}(\\lambda)+\\gamma\\cdot\\frac{1}{\\sqrt{\\gamma}}\\cdot m=\\mathsf{Enc}(\\lambda)+\\sqrt{\\gamma}\\cdot m</span>. Assuming again that <span class="math">\\mathsf{Enc}</span> is linear-time in <span class="math">m</span>, this cost becomes <span class="math">\\sqrt{\\gamma}\\cdot m+O(m)</span>, which is of square-root complexity in both <span class="math">\\lambda</span> and the size of <span class="math">t</span>. The verifier complexity of the standard Brakedown scheme is <span class="math">2\\cdot\\mathsf{Enc}(\\lambda)+2\\cdot\\sqrt{2\\cdot\\gamma}\\cdot m</span>. We thus improve the verifier’s complexity as well by a factor of more than two.</p>

    <h2 id="sec-26" class="text-2xl font-bold">5 Concrete Efficiency</h2>

    <p class="text-gray-300">We implemented our polynomial commitment scheme by modifying the open-source repository <code>controi / lcpc</code>. We ran all benchmarks on a <code>c7g.8xlarge</code> AWS instance, with an AWS Graviton3 processor with 32 virtual cores. We used a prime field <span class="math">\\mathbb{F}_{q}</span> of 191 bits, so attaining a security level of at least 128 bits throughout. We used the hash function Blake3. Benchmarks are given in Tables 1, 2 and 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of Coefficients</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Variant</td>

            <td class="px-3 py-2 border-b border-gray-700">Code</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gol+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.054</td>

            <td class="px-3 py-2 border-b border-gray-700">8.146</td>

            <td class="px-3 py-2 border-b border-gray-700">54.256</td>

            <td class="px-3 py-2 border-b border-gray-700">632.380</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.389</td>

            <td class="px-3 py-2 border-b border-gray-700">5.448</td>

            <td class="px-3 py-2 border-b border-gray-700">45.183</td>

            <td class="px-3 py-2 border-b border-gray-700">603.177</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 0.65</td>

            <td class="px-3 py-2 border-b border-gray-700">8.138</td>

            <td class="px-3 py-2 border-b border-gray-700">26.136</td>

            <td class="px-3 py-2 border-b border-gray-700">119.125</td>

            <td class="px-3 py-2 border-b border-gray-700">876.627</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.183</td>

            <td class="px-3 py-2 border-b border-gray-700">4.252</td>

            <td class="px-3 py-2 border-b border-gray-700">27.163</td>

            <td class="px-3 py-2 border-b border-gray-700">314.819</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.122</td>

            <td class="px-3 py-2 border-b border-gray-700">4.190</td>

            <td class="px-3 py-2 border-b border-gray-700">27.011</td>

            <td class="px-3 py-2 border-b border-gray-700">313.479</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 0.65</td>

            <td class="px-3 py-2 border-b border-gray-700">5.197</td>

            <td class="px-3 py-2 border-b border-gray-700">14.173</td>

            <td class="px-3 py-2 border-b border-gray-700">60.700</td>

            <td class="px-3 py-2 border-b border-gray-700">439.457</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Time (ms) for  <span class="math">\\Pi</span>  .Prove,  <span class="math">\\lceil \\log q\\rceil  = {191}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of Coefficients</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Variant</td>

            <td class="px-3 py-2 border-b border-gray-700">Code</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gol+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">4.501</td>

            <td class="px-3 py-2 border-b border-gray-700">11.314</td>

            <td class="px-3 py-2 border-b border-gray-700">34.308</td>

            <td class="px-3 py-2 border-b border-gray-700">119.849</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">4.039</td>

            <td class="px-3 py-2 border-b border-gray-700">9.211</td>

            <td class="px-3 py-2 border-b border-gray-700">24.582</td>

            <td class="px-3 py-2 border-b border-gray-700">79.406</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 0.65</td>

            <td class="px-3 py-2 border-b border-gray-700">23.758</td>

            <td class="px-3 py-2 border-b border-gray-700">89.216</td>

            <td class="px-3 py-2 border-b border-gray-700">384.866</td>

            <td class="px-3 py-2 border-b border-gray-700">2,266.047</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.582</td>

            <td class="px-3 py-2 border-b border-gray-700">6.158</td>

            <td class="px-3 py-2 border-b border-gray-700">17.992</td>

            <td class="px-3 py-2 border-b border-gray-700">61.849</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">3.155</td>

            <td class="px-3 py-2 border-b border-gray-700">7.501</td>

            <td class="px-3 py-2 border-b border-gray-700">21.804</td>

            <td class="px-3 py-2 border-b border-gray-700">75.097</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 0.65</td>

            <td class="px-3 py-2 border-b border-gray-700">12.883</td>

            <td class="px-3 py-2 border-b border-gray-700">45.780</td>

            <td class="px-3 py-2 border-b border-gray-700">194.597</td>

            <td class="px-3 py-2 border-b border-gray-700">1,114.807</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Time (ms) for  <span class="math">\\Pi</span>  .Verify,  <span class="math">\\lceil \\log q\\rceil  = {191}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of Coefficients</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Variant</td>

            <td class="px-3 py-2 border-b border-gray-700">Code</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gol+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.459</td>

            <td class="px-3 py-2 border-b border-gray-700">1.384</td>

            <td class="px-3 py-2 border-b border-gray-700">5.016</td>

            <td class="px-3 py-2 border-b border-gray-700">19.471</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.329</td>

            <td class="px-3 py-2 border-b border-gray-700">1.040</td>

            <td class="px-3 py-2 border-b border-gray-700">3.841</td>

            <td class="px-3 py-2 border-b border-gray-700">14.999</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 0.65</td>

            <td class="px-3 py-2 border-b border-gray-700">5.227</td>

            <td class="px-3 py-2 border-b border-gray-700">9.791</td>

            <td class="px-3 py-2 border-b border-gray-700">26.537</td>

            <td class="px-3 py-2 border-b border-gray-700">92.013</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.365</td>

            <td class="px-3 py-2 border-b border-gray-700">1.009</td>

            <td class="px-3 py-2 border-b border-gray-700">3.516</td>

            <td class="px-3 py-2 border-b border-gray-700">13.471</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Reed-Solomon,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.267</td>

            <td class="px-3 py-2 border-b border-gray-700">0.771</td>

            <td class="px-3 py-2 border-b border-gray-700">2.740</td>

            <td class="px-3 py-2 border-b border-gray-700">10.557</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Brakedown,</td>

            <td class="px-3 py-2 border-b border-gray-700">γ = 0.65</td>

            <td class="px-3 py-2 border-b border-gray-700">4.852</td>

            <td class="px-3 py-2 border-b border-gray-700">8.291</td>

            <td class="px-3 py-2 border-b border-gray-700">20.537</td>

            <td class="px-3 py-2 border-b border-gray-700">68.013</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Proof size (MiB),  <span class="math">\\lceil \\log q\\rceil = 191</span></p>

    <p class="text-gray-300">Tables 1, 2, and 3 exhibit improvements matching those predicted by the abstract efficiency analysis in Section 4. We recall that we used matrix sizes designed to minimize proof size throughout. Different choice strategies could target, for example, verifier time. Finally, all benchmarks include various lower-order costs, including the costs of generating, transmitting, and verifying Merkle paths, for example.</p>

    <p class="text-gray-300">We record a remark about the concrete security achieved by our protocol. The analyses of Lemmas 4.9 and 4.10 show that the prover's soundness is controlled by the expression  <span class="math">2 \\cdot \\ell \\cdot \\frac{d}{q} + \\left(1 - \\frac{d}{3 \\cdot n}\\right)^{\\gamma}</span>  (the soundness error of Lemma 4.9 dominates). This expression's first term is larger by a factor of  <span class="math">2 \\cdot \\ell = 2 \\cdot \\log \\left(\\frac{m}{\\sqrt{\\gamma}}\\right)</span>  than that of the analogous expression in [Gol+23]. For all sizes benchmarked above, for which  <span class="math">m^2 \\leq 2^{28}</span> , we have that  <span class="math">\\log (2 \\cdot \\ell) = \\log \\left(2 \\cdot \\log \\left(\\frac{m}{\\sqrt{\\gamma}}\\right)\\right) \\leq 5</span> ; in this light, our protocol technically requires a field  <span class="math">\\mathbb{F}_q</span>  roughly 5 bits larger (in the worst case) in order to achieve equivalent security. On the other hand, in practice, our chosen field size is governed by the limb size of our machines; this 5-bit difference is thus immaterial in practice. This picture would be different if our logarithmic loss  <span class="math">\\ell</span>  were replaced by, say, a linear loss of  <span class="math">m</span> .</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV23] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: lightweight sublinear arguments without a trusted setup”. In: <em>Designs, Codes and Cryptography</em> (2023). doi: 10.1007/s10623-023-01222-8.</li>

      <li>[BCG20] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. “Linear-Time Arguments with Sublinear Verification from Tensor Codes”. In: <em>Theory of Cryptography</em>. Ed. by Rafael Pass and Krzysztof Pietrzak. Cham: Springer International Publishing, 2020, pp. 19–46. isbn: 978-3-030-64378-2. doi: 10.1007/978-3-030-64378-2_2.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: <em>International Conference on Theory of Cryptography</em>. Vol. 9986. Berlin, Heidelberg: Springer-Verlag, 2016, pp. 31–60. isbn: 978-3-662-53644-5. doi: 10.1007/978-3-662-53644-5_2.</li>

      <li>[Ben+23] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. “Proximity Gaps for Reed–Solomon Codes”. In: <em>Journal of the ACM</em> 70.5 (Oct. 2023). doi: 10.1145/3614423.</li>

      <li>[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. “Transparent SNARKs from DARK Compilers”. In: <em>Advances in Cryptology – EUROCRYPT 2020</em>. Ed. by Anne Canteaut and Yuval Ishai. Cham: Springer International Publishing, 2020, pp. 677–706.</li>

      <li>[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. “Worst-Case to Average Case Reductions for the Distance to a Code”. In: <em>33rd Computational Complexity Conference</em>. Ed. by Rocco A. Servedio. Dagstuhl Publishing, 2018, 24:1–24:23.</li>

      <li>[Boo+16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: <em>Advances in Cryptology – EUROCRYPT 2016</em>. Ed. by Marc Fischlin and Jean-Sébastien Coron. Berlin, Heidelberg: Springer Berlin Heidelberg, 2016, pp. 327–357. isbn: 978-3-662-49896-5. doi: 10.1007/978-3-662-49896-5_12.</li>

      <li>[BS22] Alexandre Belling and Azam Soleimanian. <em>Vortex: Building a Lattice-based SNARK scheme with Transparent Setup</em>. Cryptology ePrint Archive, Paper 2022/1633. 2022. url: https://eprint.iacr.org/2022/1633.</li>

      <li>[Chi+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: <em>Advances in Cryptology – EUROCRYPT 2020</em>. Ed. by Anne Canteaut and Yuval Ishai. Lecture Notes in Computer Science. Full version. Cham: Springer International Publishing, 2020, pp. 738–768. isbn: 978-3-030-45721-1. doi: 10.1007/978-3-030-45721-1_26.</li>

      <li>[Gol+23] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad S. Wahby. “Brakedown: Linear-Time and Field-Agnostic SNARKs for R1CS”. In: <em>Advances in Cryptology – CRYPTO 2023</em>. Ed. by Helena Handschuh and Anna Lysyanskaya. Cham: Springer Nature Switzerland, 2023, pp. 193–226. isbn: 978-3-031-38545-2. doi: 10.1007/978-3-031-38545-2_7.</li>

      <li>[HL10] Carmit Hazay and Yehuda Lindell. <em>Efficient Secure Two-Party Protocols</em>. Ed. by David Basin and Ueli Maurer. Information Security and Cryptography. Berlin, Heidelberg: Springer, 2010.</li>

      <li>[Lin17] Yehuda Lindell. “How to Simulate It – A Tutorial on the Simulation Proof Technique”. In: <em>Tutorials on the Foundations of Cryptography: Dedicated to Oded Goldreich</em>. Ed. by Yehuda Lindell. Cham: Springer International Publishing, 2017, pp. 277–346.</li>

      <li>[Set20] Srinath Setty. “Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup”. In: <em>Advances in Cryptology – CRYPTO 2020</em>. Ed. by Daniele Micciancio and Thomas Ristenpart. Cham: Springer International Publishing, 2020, pp. 704–737. isbn: 978-3-030-56877-1. doi: 10.1007/978-3-030-56877-1_25.</li>

      <li>[XZS22] Tiancheng Xie, Yupeng Zhang, and Dawn Song. “Orion: Zero Knowledge Proof With Linear Prover Time”. In: <em>Advances in Cryptology – CRYPTO 2022</em>. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Berlin, Heidelberg: Springer-Verlag, 2022, pp. 299–328. isbn: 978-3-031-15984-8. doi: 10.1007/978-3-031-15985-5_11.</li>

    </ul>

    <p class="text-gray-300">-</p>`;
---

<BaseLayout title="Proximity Testing with Logarithmic Randomness (2023/630)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/630
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
