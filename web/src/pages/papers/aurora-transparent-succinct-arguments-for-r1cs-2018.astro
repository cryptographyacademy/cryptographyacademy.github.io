---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/828';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Aurora: Transparent Succinct Arguments for R1CS';
const AUTHORS_HTML = 'Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, Nicholas P.  Ward';

const CONTENT = `    <p class="text-gray-300">Aurora: Transparent Succinct Arguments for R1CS</p>

    <p class="text-gray-300">Eli Ben-Sasson eli@cs.technion.ac.il Technion</p>

    <p class="text-gray-300">Alessandro Chiesa alexch@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Michael Riabzev mriabzev@cs.technion.ac.il Technion</p>

    <p class="text-gray-300">Nicholas Spooner nick.spooner@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Madars Virza madars@mit.edu MIT Media Lab</p>

    <p class="text-gray-300">Nicholas P. Ward npward@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">May 8, 2019</p>

    <p class="text-gray-300">We design, implement, and evaluate a zkSNARK for Rank-1 Constraint Satisfaction (R1CS), a widely-deployed NP-complete language that is undergoing standardization. Our construction uses a transparent setup, is plausibly post-quantum secure, and uses lightweight cryptography. A proof attesting to the satisfiability of <span class="math">n</span> constraints has size <span class="math">O(\\log^2 n)</span>; it can be produced with <span class="math">O(n \\log n)</span> field operations and verified with <span class="math">O(n)</span>. At 128 bits of security, proofs are less than <span class="math">130\\mathrm{kB}</span> even for several million constraints, more than <span class="math">20\\times</span> shorter than prior zkSNARK with similar features.</p>

    <p class="text-gray-300">A key ingredient of our construction is a new Interactive Oracle Proof (IOP) for solving a univariate analogue of the classical sumcheck problem [LFKN92], originally studied for multivariate polynomials. Our protocol verifies the sum of entries of a Reed-Solomon codeword over any subgroup of a field.</p>

    <p class="text-gray-300">We also provide libiop, an open-source library for writing IOP-based arguments, in which a toolchain of transformations enables programmers to write new arguments by writing simple IOP sub-components. We have used this library to specify our construction and prior ones.</p>

    <p class="text-gray-300">Keywords: zero knowledge; interactive oracle proofs; succinct arguments; sumcheck protocol</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 The need for a transparent setup  3 1.2 Our goal  4 1.3 Our contributions  5 1.4 Prior implementations of transparent succinct non-interactive arguments  6</p>

    <p class="text-gray-300">2  Techniques  9 2.1 Our interactive oracle proof for R1CS  9 2.2 A sumcheck protocol for univariate polynomials  10 2.3 Efficient zero knowledge from algebraic techniques  11 2.4 Perspective on our techniques  12</p>

    <p class="text-gray-300">3  Roadmap  14</p>

    <p class="text-gray-300">4  Preliminaries  15 4.1 Codes  15 4.2 Representations of polynomials  15 4.3 The fast Fourier transform  15 4.4 Subspace polynomials  15 4.5 Interactive oracle proofs  16 4.6 Zero knowledge  17 4.7 Reed-Solomon encoded IOP  18 4.8 Univariate rowcheck  20</p>

    <p class="text-gray-300">5  Univariate sumcheck  21 5.1 Zero knowledge  23 5.2 Amortization  24</p>

    <p class="text-gray-300">6  Univariate lincheck  26</p>

    <p class="text-gray-300">7  An RS-encoded IOP for rank-one constraint satisfaction  28 7.1 Zero knowledge  30 7.2 Amortization  32</p>

    <p class="text-gray-300">8  From RS-encoded provers to arbitrary provers  34 8.1 Zero knowledge  37</p>

    <p class="text-gray-300">9  Aurora: an IOP for rank-one constraint satisfaction (R1CS)  40</p>

    <p class="text-gray-300">10  libiop: a library for IOP-based non-interactive arguments  43 10.1 Library for IOP protocols  43 10.2 BCS transformation  43 10.3 Portfolio of IOP protocols and sub-components  44</p>

    <p class="text-gray-300">11  Evaluation  45 11.1 Performance of Aurora  45 11.2 Comparison of Ligero, Stark, and Aurora  45</p>

    <p class="text-gray-300">A  Proof of Lemma 5.4  48</p>

    <p class="text-gray-300">B  Adaptation of Ligero to the R1CS relation  49 B.1 Interleaved lincheck  49 B.2 Interleaved rowcheck  50 B.3 Interleaved ZKIPCP for R1CS  51 B.4 From encoded IPCP to regular IPCP  55</p>

    <p class="text-gray-300">C  Additional comparisons  57 C.1 Comparison of the LDTs in Ligero, Stark, and Aurora  57 C.2 Comparison of the IOPs in Ligero, Stark, and Aurora  57</p>

    <p class="text-gray-300">Acknowledgments  59</p>

    <p class="text-gray-300">References  59</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">A zero knowledge proof is a protocol that enables one party (the <em>prover</em>) to convince another (the <em>verifier</em>) that a statement is true without revealing any information beyond the fact that the statement is true. Since their introduction <em>[x10]</em>, zero knowledge proofs have become fundamental tools not only in the theory of cryptography but also, more recently, in the design of real-world systems with strong privacy properties.</p>

    <p class="text-gray-300">For example, zero knowledge proofs are the core technology in Zcash <em>[x3, x26]</em>, a popular cryptocurrency that preserves a user’s payment privacy. While in Bitcoin <em>[x22]</em> users broadcast their private payment details in the clear on the public blockchain (so other participants can check the validity of the payment), users in Zcash broadcast <em>encrypted</em> transaction details and <em>prove</em>, in zero knowledge, the validity of the payments without disclosing what the payments are.</p>

    <p class="text-gray-300">Many applications, including the aforementioned, require that proofs are <em>succinct</em>, namely, that proofs scale <em>sublinearly</em> in the size of the witness for the statement, or perhaps even in the size of the computation performed to check the statement. This strong efficiency requirement cannot be achieved with statistical soundness (under standard complexity assumptions) <em>[x11]</em>, and thus one must consider proof systems that are merely computationally sound, known as <em>argument systems</em> <em>[x2]</em>. Many applications further require that a proof consists of a single non-interactive message that can be verified by anyone; such proofs are cheap to communicate and can be stored for later use (e.g., on a public ledger). Constructions that satisfy these properties are known as (publicly verifiable) <em>succinct non-interactive arguments</em> (SNARGs) <em>[x12]</em>.</p>

    <p class="text-gray-300">In this work we present Aurora, a zero knowledge SNARG of knowledge (zkSNARK) for (an extension of) arithmetic circuit satisfiability whose argument size is polylogarithmic in the circuit size. Aurora also has attractive features: it uses a transparent setup, is plausibly post-quantum secure, and only makes black-box use of fast symmetric cryptography (any cryptographic hash function modeled as a random oracle).</p>

    <p class="text-gray-300">Our work makes an exponential asymptotic improvement in argument size over Ligero <em>[x1]</em>, a recent zero knowledge non-interactive argument with similar features but where proofs scale as the <em>square root</em> of the circuit size. For example, Aurora’s proofs are <span class="math">30\\times</span> smaller than Ligero’s for circuits with a million gates (which already suffices for representative applications such as Zcash).</p>

    <p class="text-gray-300">Our work also complements and improves on Stark <em>[x1]</em>, a recent zkSNARK that targets computations expressed as bounded halting problems on random access machines. While Stark was designed for a different computation model, we can still study its efficiency when applied to arithmetic circuits. In this case Aurora’s prover is faster by a logarithmic factor (in the circuit size) and Aurora’s proofs are concretely much shorter, e.g., <span class="math">20\\times</span> smaller for circuits with a million gates.</p>

    <p class="text-gray-300">The efficiency features of Aurora stem from a new Interactive Oracle Proof (IOP) that solves a <em>univariate</em> analogue of the celebrated sumcheck problem <em>[x16]</em>, in which query complexity is <em>logarithmic</em> in the degree of the polynomial being summed. This is an <em>exponential</em> improvement over the original multi-variate protocol, where communication complexity is (at least) <em>linear</em> in the degree of the polynomial. We believe this protocol and its analysis are of independent interest.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 The need for a transparent setup</h3>

    <p class="text-gray-300">The first succinct argument is due to Kilian <em>[x17]</em>, who showed how to use collision-resistant hashing to compile any Probabilistically Checkable Proof (PCP) <em>[x5, x7, x4, x3]</em> into a corresponding interactive argument. Micali showed how a similar construction, in the random oracle model, yields succinct <em>non</em>-interactive arguments (SNARGs) <em>[x18]</em>. Subsequent work showed that Micali’s construction preserves a PCP’s zero knowledge <em>[x13]</em> and proof of knowledge <em>[x23]</em> properties. However PCPs remain expensive, and this approach has not led to SNARGs with good concrete efficiency.</p>

    <p class="text-gray-300">In light of this, a different approach was initially used to achieve SNARG implementations with good concrete efficiency <em>[x19, x3]</em>. This approach, pioneered in <em>[x12, x13, x16, x2]</em>, relied on combining certain linearly homomorphic encodings with lightweight information-theoretic tools known as linear PCPs <em>[x14, x2, x15, x17]</em>; this approach was refined and optimized in several works <em>[x4, x5, x6, x7, x11]</em>. These constructions underlie widely-used open-source libraries <em>[x20]</em> and deployed systems <em>[x22]</em>, and their main feature is that proofs are very short (a few hundred bytes) and very cheap to verify (a few milliseconds).</p>

    <p class="text-gray-300">Unfortunately, the foregoing approach suffers from a severe limitation, namely, the need for a central party to generate system parameters for the argument system. Essentially, this party must run a probabilistic algorithm, publish its output, and “forget” the secret randomness used to generate it. This party must be trustworthy because knowing these secrets allows forging proofs for false assertions. While this may sound like an inconvenience, it is a colossal challenge to real-world deployments. When using cryptographic proofs in distributed systems, relying on a central party negates the benefits of distributed trust and, even though it is invoked only once in a system’s life, a party trusted by all users typically does not exist!</p>

    <p class="text-gray-300">The responsibility for generating parameters can in principle be shared across multiple parties via techniques that leverage secure multi-party computation <em>[x3, x4, x5]</em>. This was the approach taken for the launch of Zcash <em>[x21]</em>, but it also demonstrated how unwieldy such an approach is, involving a costly and logistically difficult real-world multi-party “ceremony”. Successfully running such a multi-party protocol was a singular feat, and systems without such expensive setup are decidedly preferable.</p>

    <p class="text-gray-300">Some setup is unavoidable because if SNARGs without any setup existed then so would sub-exponential algorithms for SAT <em>[x23]</em>. Nevertheless, one could still aim for a “transparent setup”, namely one that consists of public randomness, because in practice it is cheaper to realize. Recent efforts have thus focused on designing SNARGs with transparent setup (see discussion in Section 1.4).</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Our goal</h3>

    <p class="text-gray-300">The goal of this paper is to obtain transparent zkSNARKs that satisfy the following desiderata.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Post-quantum security. Practitioners, and even standards bodies <em>[x18]</em>, have a strong interest in cryptographic primitives that are plausibly secure against efficient quantum adversaries. This is motivated by the desire to ensure long-term security of deployed systems and protocols.</li>

      <li>Concrete efficiency. We seek argument systems that not only exhibit good asymptotics (in argument size and prover/verifier time) but also demonstrably offer good efficiency via a prototype.</li>

    </ul>

    <p class="text-gray-300">The second bullet warrants additional context. Most argument systems support an NP-complete problem, so they are in principle equivalent under polynomial-time reductions. Yet, whether such protocols can be efficiently used in practice actually depends on: (a) the particular NP-complete problem “supported” by the protocol; (b) the concrete efficiency of the protocol relative to this problem. This creates a complex tradeoff.</p>

    <p class="text-gray-300">Simple NP-complete problems, like boolean circuit satisfaction, facilitate simple argument systems; but reducing the statements we wish to prove to boolean circuits is often expensive. On the other hand, one can design argument systems for rich problems (e.g., an abstract computer) for which it is cheap to express the desired statements; but such argument systems may use expensive tools to support these rich problems.</p>

    <p class="text-gray-300">Our goal is concretely-efficient argument systems for rank-1 constraint satisfaction (R1CS), which is the following natural NP-complete problem: given a vector <span class="math">v\\in\\mathbb{F}^{k}</span> and three matrices <span class="math">A,B,C\\in\\mathbb{F}^{m\\times n}</span>, can one augment <span class="math">v</span> to <span class="math">z\\in\\mathbb{F}^{n}</span> such that <span class="math">Az\\circ Bz=Cz</span>? (We use “<span class="math">\\circ</span>” to denote the entry-wise product.)</p>

    <p class="text-gray-300">We choose R1CS because it strikes an attractive balance: it generalizes circuits by allowing “native” field arithmetic and having no fan-in/fan-out restrictions, but it is simple enough that one can design efficient</p>

    <p class="text-gray-300">argument systems for it. Moreover, R1CS has demonstrated <em>strong empirical value</em>: it underlies real-world systems <em>[x20]</em> and there are compilers that reduce program executions to it (see <em>[x23]</em> and references therein). This has led to efforts to standardize R1CS formats across academia and industry <em>[x21]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 Our contributions</h3>

    <p class="text-gray-300">In this work we study <em>Interactive Oracle Proofs</em> (IOPs) <em>[x1, x13]</em>, a notion of “multi-round PCPs” that has recently received much attention <em>[x2, x3, x4, x5]</em>. These types of interactive proofs can be compiled into non-interactive arguments in the random oracle model <em>[x1]</em>, and in particular can be used to construct transparent SNARGs. The properties of zero knowledge and proof of knowledge are inherited from the IOP, leading to transparent zkSNARKs.</p>

    <p class="text-gray-300">Building on this approach, we present several contributions: (1) an IOP protocol for R1CS with attractive efficiency features; (2) design, implementation, and evaluation of a transparent zkSNARK for R1CS, based on this IOP; (3) a library for writing IOP-based non-interactive arguments. We now describe each contribution.</p>

    <p class="text-gray-300">(1) IOP for R1CS. We construct a zero knowledge IOP protocol for rank-1 constraint satisfaction (R1CS) with <em>linear</em> proof length and <em>logarithmic</em> query complexity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an R1CS instance <span class="math">\\mathcal{C}=(A,B,C)</span> with <span class="math">A,B,C\\in\\mathbb{F}^{m\\times n}</span>, we denote by <span class="math">N=\\Omega(m+n)</span> the total number of non-zero entries in the three matrices and by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the number of bits required to represent these; note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Theta(N\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. One can view </span>N$ as the number of “arithmetic gates” in the R1CS instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1.1 (informal).</h6>

    <p class="text-gray-300">There is an <span class="math">O(\\log N)</span>-round IOP protocol for R1CS with proof length <span class="math">O(N)</span> over alphabet <span class="math">\\mathbb{F}</span> and query complexity <span class="math">O(\\log N)</span>. The prover uses <span class="math">O(N\\log N)</span> field operations, while the verifier uses <span class="math">O(N)</span> field operations. The IOP protocol is public coin and is a zero knowledge proof of knowledge.</p>

    <p class="text-gray-300">The core of our result is a solution to a <em>univariate</em> analogue of the classical sumcheck problem <em>[x17]</em>. Our protocol (including zero knowledge and soundness error reduction) is relatively simple: it is specified in a single page (see Fig. 5 in Section 9), given a low-degree test as a subroutine. The low degree test that we use is a recent highly-efficient IOP for testing proximity to the Reed–Solomon code <em>[x1]</em>.</p>

    <p class="text-gray-300">(2) zkSNARK for R1CS. We design, implement, and evaluate Aurora, a zero knowledge SNARG of knowledge (zkSNARK) for R1CS with several notable features: (a) it only makes black-box use of fast symmetric cryptography (any cryptographic hash function modeled as a random oracle); (b) it has a transparent setup (users merely need to “agree” on which cryptographic hash function to use); (c) it is plausibly post-quantum secure (there are no known efficient quantum attacks against this construction). These features follow from the fact that Aurora is obtained by applying the transformation of <em>[x1]</em> to our IOP for R1CS. This transformation preserves both zero knowledge and proof of knowledge of the underlying IOP. The following theorem is obtained straightforwardly by combining Theorem 1.1 with <em>[x1, Theorem 7.1]</em>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1.2 (informal).</h6>

    <p class="text-gray-300">There exists a zkSNARK for R1CS that is unconditionally secure in the random oracle model with proof length <span class="math">O_{\\lambda}(\\log^{2}N)</span>. The prover runs in time <span class="math">O_{\\lambda}(N\\log N)</span> and the verifier in time <span class="math">O_{\\lambda}(N)</span>. (Here for simplicity we take the field <span class="math">\\mathbb{F}</span> to have size <span class="math">2^{\\Theta(\\lambda)}</span> where <span class="math">\\lambda</span> is the security parameter.)</p>

    <p class="text-gray-300">For example, setting our implementation to a security level of 128 bits over a 192-bit finite field, proofs range from <span class="math">40\\text{\\,}\\mathrm{kB}</span> to <span class="math">130\\text{\\,}\\mathrm{kB}</span> for instances of up to millions of gates; producing proofs takes on the order of several minutes and checking proofs on the order of several seconds. (See Section 11 for details.)</p>

    <p class="text-gray-300">Overall, as indicated in Fig. 2, we achieve the smallest argument size among (plausibly) post-quantum non-interactive arguments for circuits, <em>by more than an order of magnitude</em>. Other approaches achieve smaller argument sizes by relying on (public-key) cryptography that is insecure against quantum adversaries.</p>

    <p class="text-gray-300">(3) libiop: a library for non-interactive arguments. We provide libiop, a codebase that enables the design and implementation of non-interactive arguments based on IOPs. The codebase uses the C++ language and has three main components: (1) a library for writing IOP protocols; (2) a realization of [BCS16]'s transformation, mapping any IOP written with our library to a corresponding non-interactive argument; (3) a portfolio of IOP protocols. We have released libiop under a permissive software license for the community (see https://github.com/scipr-lab/libiop). We believe that our library will serve as a useful tool in meeting the increasing demand by practitioners for transparent non-interactive arguments.</p>

    <p class="text-gray-300">We summarize prior work that has designed and implemented transparent SNARs; see Fig. 2. <span class="math">^{1}</span></p>

    <p class="text-gray-300">Based on asymmetric cryptography. Bulletproofs [BCCGP16; BBBPWM18] proves the satisfaction of an  <span class="math">N</span> -gate arithmetic circuit via a recursive use of a low-communication protocol for inner products, achieving a proof with  <span class="math">O(\\log N)</span>  group elements. Hyrax [WTSTW17] proves the satisfaction of a layered arithmetic circuit of depth  <span class="math">D</span>  and width  <span class="math">W</span>  via proofs of  <span class="math">O(D \\log W)</span>  group elements; the construction applies the Cramer-Damgård transformation [CD98] to doubly-efficient Interactive Proofs [GKR15; CMT12]. Both approaches use Pedersen commitments, and so are vulnerable to quantum attacks. Also, in both approaches the verifier performs many expensive cryptographic operations: in the former, the verifier uses  <span class="math">O(N)</span>  group exponentiations; in the latter, the verifier's group exponentiations are linear in the circuit's witness size. (Hyrax allows fewer group exponentiations but with longer proofs; see [WTSTW17].)</p>

    <p class="text-gray-300">Based on symmetric cryptography. The "original" SNARG construction of Micali [Mic00; IMSX15] has advantages beyond transparency. First, it is unconditionally secure given a random oracle, which can be instantiated with fast symmetric cryptography. Second, it is plausibly post-quantum secure, in that there are no known efficient quantum attacks. But the construction relies on PCPs, which remain expensive.</p>

    <p class="text-gray-300">IOPs are "multi-round PCPs" that can also be compiled into non-interactive arguments in the random oracle model [BCS16]. This compilation retains the foregoing advantages (transparency, lightweight cryptography, and plausible post-quantum security) and, in addition, facilitates greater efficiency, as IOPs have superior efficiency compared to PCPs [BCGV16; BCFGRS17; BBCGGHPRSTV17; BBHR18b; BBHR18a].</p>

    <p class="text-gray-300">In this work we follow the above approach, by constructing a zkSNARK based on a new IOP protocol. Two recent works have also taken the same approach, but with different underlying IOP protocols, which have led to different features. We provide both of these works as part of our library (Section 10), and experimentally compare them with our protocol (Section 11). The discussion below is a qualitative comparison.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ligero [AHIV17] is a non-interactive argument that proves the satisfiability of an  <span class="math">N</span> -gate circuit via proofs of size  <span class="math">O(\\sqrt{N})</span>  that can be verified in  <span class="math">O(N)</span>  cryptographic operations. As summarized in Fig. 1, the IOP underlying Ligero achieves the same oracle proof length, prover time, and verifier time as our IOP. However, we reduce query complexity from  <span class="math">O(\\sqrt{N})</span>  to  <span class="math">O(\\log N)</span> , which is an exponential improvement, at the expense of increasing round complexity from 2 to  <span class="math">O(\\log N)</span> . The arguments that we obtain are still non-interactive, but our smaller query complexity translates into shorter proofs (see Fig. 2).</li>

      <li>Stark [BBHR18a] is a non-interactive argument for bounded halting problems on a random access machine. Given a program  <span class="math">P</span>  and a time bound  <span class="math">T</span> , it proves that  <span class="math">P</span>  accepts within  <span class="math">T</span>  steps on a certain abstract</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">computer (when given suitable nondeterministic advice) via succinct proofs of size <span class="math">\\mathrm{polylog}(T)</span>. Moreover, verification is also succinct: checking a proof takes time only $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathrm{polylog}(T)<span class="math">, which is polynomial in the size of the statement and much better than “naive verification” which takes time </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+T)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The main difference between Stark and Aurora is the computational models that they support. While Stark supports uniform computations specified by a program and a time bound, Aurora supports non-uniform computations specified by an explicit circuit (or constraint system). Despite this difference, we can compare the cost of Stark and Aurora with respect to the explicit circuit model, since one can reduce a given <span class="math">N</span>-gate circuit (or <span class="math">N</span>-constraint system) to a corresponding bounded halting problem with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,T=\\Theta(N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this case, Stark’s verification time is the same as Aurora’s, <span class="math">O(N)</span>; this is best possible because just reading an <span class="math">N</span>-gate circuit takes time <span class="math">\\Omega(N)</span>. But Stark’s prover is a logarithmic factor more expensive because it uses a switching network to verify a program’s accesses to memory. Stark’s prover uses an IOP with oracles of size <span class="math">O(N\\log N)</span>, leading to an arithmetic complexity of <span class="math">O(N\\log^{2}N)</span>. (See Figs. 1 and 2.)</p>

    <p class="text-gray-300">Both Stark and Aurora have argument size <span class="math">O(\\log^{2}N)</span>, but additional costs in Stark (e.g., due to switching networks) result in Stark proofs being one order of magnitude larger than Aurora proofs. That said, we view Stark and Aurora as complementing each other: Stark offers savings in verification time for succinctly represented programs, while Aurora offers savings in argument size for explicitly represented circuits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">protocol type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof length (field elts)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover time (field ops)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time (field ops)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">IPCP†</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Stark</td>

            <td class="px-3 py-2 border-b border-gray-700">IOP</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">IOP</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Asymptotic comparison of the information-theoretic proof systems underlying Ligero, Stark, and Aurora, when applied to an  <span class="math">N</span> -gate arithmetic circuit.</p>

    <p class="text-gray-300">† An IPCP [KR08] is a PCP oracle that is checked via an Interactive Proof; it is a special case of an IOP.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">post quantum?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">argument size asymptotic</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N=10^6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">non-interactivity technology</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gro10][GGPR13] [Lip13][BCIOP13]...</td>

            <td class="px-3 py-2 border-b border-gray-700">various</td>

            <td class="px-3 py-2 border-b border-gray-700">private</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">128 B</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(k) †</td>

            <td class="px-3 py-2 border-b border-gray-700">linear PCP + linear encoding</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[ZGKPP17a]</td>

            <td class="px-3 py-2 border-b border-gray-700">ZK-vSQL</td>

            <td class="px-3 py-2 border-b border-gray-700">private</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(d log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">apply [CD98]-transform to doubly-efficient IP [GKR15; CMT12]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[WTSTW17]</td>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(d log N) ‡</td>

            <td class="px-3 py-2 border-b border-gray-700">50 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">as above (but using a different polynomial commitment)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCCGP16] [BBBPWM18]</td>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">recursive inner product argument</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[AHIV17]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(√N)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">apply [BCS16]-transform to IPCP</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BBHR18a]</td>

            <td class="px-3 py-2 border-b border-gray-700">Stark</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">apply [BCS16]-transform to IOP</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">130 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">apply [BCS16]-transform to IOP</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: Comparison of some non-interactive zero knowledge arguments for proving statements of the form "there exists a secret  <span class="math">w</span>  such that  <span class="math">\\mathcal{C}(x, w) = 1</span> " for a given arithmetic circuit  <span class="math">\\mathcal{C}</span>  of  <span class="math">N</span>  gates (and depth  <span class="math">d</span> ) and public input  <span class="math">x</span>  of size  <span class="math">k</span> . The table is grouped by "technology", and for simplicity assumes that the circuit's underlying field has size  <span class="math">2^{O(\\lambda)}</span>  where  <span class="math">\\lambda</span>  is the security parameter. Approximate argument sizes are given for  <span class="math">N = 10^6</span>  gates over a cryptographically-large field, and a security level of 128 bits; some argument sizes may differ from those reported in the cited works because size had to be re-computed for the security level and  <span class="math">N</span>  used here; also, [ZGKPP17a] reports no implementation.</p>

    <p class="text-gray-300">Given a per-circuit preprocessing step. <span class="math">\\ddagger</span>  A tradeoff between argument size and verifier time is possible; see [WTSTW17].</p>

    <p class="text-gray-300">Our main technical contribution is a linear-length logarithmic-query IOP for R1CS (Theorem 1.1), which we use to design, implement, and evaluate a transparent zkSNARK for R1CS. Below we summarize the main ideas behind our protocol, and postpone to Sections 10 and 11 discussions of our system. In Section 2.1, we describe our approach to obtain the IOP for R1CS; this approach leads us to solve the univariate sumcheck problem, as discussed in Section 2.2; finally, in Section 2.3, we explain how we achieve zero knowledge. In Section 2.4 we conclude with a wider perspective on the techniques used in this paper.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.1 Our interactive oracle proof for R1CS</h2>

    <p class="text-gray-300">The R1CS relation consists of instance-witness pairs <span class="math">((A,B,C,v),w)</span>, where <span class="math">A, B, C</span> are matrices and <span class="math">v, w</span> are vectors over a finite field <span class="math">\\mathbb{F}</span>, such that <span class="math">(Az) \\circ (Bz) = Cz</span> for <span class="math">z := (1, v, w)</span> and “<span class="math">\\circ</span>” denotes the entry-wise product.³ For example, R1CS captures arithmetic circuit satisfaction: <span class="math">A, B, C</span> represent the circuit's gates, <span class="math">v</span> the circuit's public input, and <span class="math">w</span> the circuit's private input and wire values.⁴</p>

    <p class="text-gray-300">We describe the high-level structure of our IOP protocol for R1CS, which has linear proof length and logarithmic query complexity. The protocol tests satisfaction by relying on two building blocks, one for testing the entry-wise vector product and the other for testing the linear transformations induced by the matrices <span class="math">A, B, C</span>. Informally, we thus consider protocols for the following two problems.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rowcheck: given vectors <span class="math">x, y, z \\in \\mathbb{F}^m</span>, test whether <span class="math">x \\circ y = z</span>, where “<span class="math">\\circ</span>” denotes entry-wise product.</li>

      <li>Lincheck: given vectors <span class="math">x \\in \\mathbb{F}^m, y \\in \\mathbb{F}^n</span> and a matrix <span class="math">M \\in \\mathbb{F}^{m \\times n}</span>, test whether <span class="math">x = My</span>.</li>

    </ul>

    <p class="text-gray-300">One can immediately obtain an IOP for R1CS when given IOPs for the rowcheck and lincheck problems. The prover first sends four oracles to the verifier: the satisfying assignment <span class="math">z</span> and its linear transformations <span class="math">y_A := Az, y_B := Bz, y_C := Cz</span>. Then the prover and verifier engage in four IOPs in parallel:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An IOP for the lincheck problem to check that <span class="math">y_A = Az</span>. Likewise for <span class="math">y_B</span> and <span class="math">y_C</span>.</li>

      <li>An IOP for the rowcheck problem to check that <span class="math">y_A \\circ y_B = y_C</span>.</li>

    </ul>

    <p class="text-gray-300">Finally, the verifier checks that <span class="math">z</span> is consistent with the public input <span class="math">v</span>. Clearly, there exist <span class="math">z, y_A, y_B, y_C</span> that yield valid rowcheck and lincheck instances if and only if <span class="math">(A, B, C, v)</span> is a satisfiable R1CS instance.</p>

    <p class="text-gray-300">The foregoing reduces the goal to designing IOPs for the rowcheck and lincheck problems.</p>

    <p class="text-gray-300">As stated, however, the rowcheck and lincheck problems only admit "trivial" protocols in which the verifier queries all entries of the vectors in order to check the required properties. In order to allow for sublinear query complexity, we need the vectors <span class="math">x, y, z</span> to be encoded via some error-correcting code. We use the Reed-Solomon (RS) code because it ensures constant distance with constant rate while at the same time it enjoys efficient IOPs of Proximity [BBHR18b].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an evaluation domain <span class="math">L \\subseteq \\mathbb{F}</span> and rate parameter <span class="math">\\rho \\in [0,1]</span>, <span class="math">\\mathrm{RS}[L, \\rho]</span> is the set of all codewords <span class="math">f: L \\to \\mathbb{F}</span> that are evaluations of polynomials of degree less than $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then, the encoding of a vector </span>v \\in \\mathbb{F}^S<span class="math"> with </span>S \\subseteq \\mathbb{F}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is </span>\\hat{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_L \\in \\mathbb{F}^L<span class="math"> where </span>\\hat{v}<span class="math"> is the unique polynomial of degree </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> such that </span>\\hat{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S = v$. Given this encoding, we consider "encoded" variants of the rowcheck and lincheck problems.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">³Throughout, we assume that <span class="math">\\mathbb{F}</span> is “friendly” to FFT algorithms, i.e., <span class="math">\\mathbb{F}</span> is a binary field or its multiplicative group is smooth.</p>

    <p class="text-gray-300">⁴The reader may be familiar with a standard arithmetization of circuit satisfaction (used, e.g., in the inner PCP of [ALMSS98]). Given an arithmetic circuit with <span class="math">m</span> gates and <span class="math">n</span> wires, each addition gate <span class="math">x_i \\gets x_j + x_k</span> is mapped to the linear constraint <span class="math">x_i = x_j + x_k</span> and each product gate <span class="math">x_i \\gets x_j \\cdot x_k</span> is mapped to the quadratic constraint <span class="math">x_i = x_j \\cdot x_k</span>. The resulting system of equations can be written as <span class="math">A \\cdot ((1,x) \\otimes (1,x)) = b</span> for suitable <span class="math">A \\in \\mathbb{F}^{m \\times (n+1)^2}</span> and <span class="math">b \\in \\mathbb{F}^m</span>. However, this reduction results in a quadratic blowup in the instance size. There is an alternative reduction due to [Mei12; GGPR13] that avoids this.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Univariate rowcheck (Definition 4.9): given a subset <span class="math">H\\subseteq\\mathbb{F}</span> and codewords <span class="math">f,g,h\\in\\mathrm{RS}\\left[L,\\rho\\right]</span>, check that <span class="math">\\hat{f}(a)\\cdot\\hat{g}(a)-\\hat{h}(a)=0</span> for all <span class="math">a\\in H</span>. (This is a special case of the definition that we use later.)</li>

      <li>Univariate lincheck (Definition 6.1): given subsets <span class="math">H_{1},H_{2}\\subseteq\\mathbb{F}</span>, codewords <span class="math">f,g\\in\\mathrm{RS}\\left[L,\\rho\\right]</span>, and a matrix <span class="math">M\\in\\mathbb{F}^{H_{1}\\times H_{2}}</span>, check that <span class="math">\\hat{f}(a)=\\sum_{b\\in H_{2}}M_{a,b}\\cdot\\hat{g}(b)</span> for all <span class="math">a\\in H_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">Given IOPs for the above problems, we can now get an IOP protocol for R1CS roughly as before. Rather than sending <span class="math">z,Az,Bz,Cz</span>, the prover sends their encodings <span class="math">f_{z},f_{Az},f_{Bz},f_{Cz}</span>. The prover and verifier then engage in rowcheck and lincheck protocols as before, but with respect to these encodings.</p>

    <p class="text-gray-300">For these encoded variants, we achieve IOP protocols with linear proof length and logarithmic query complexity, as required. We obtain a protocol for rowcheck via standard techniques from the probabilistic checking literature <em>[x1]</em>. As for lincheck, we do not use any routing and instead use a technique (dating back at least to <em>[x2]</em>) to reduce the given testing problem to a <em>sumcheck instance</em>. However, since we are not working with multivariate polynomials, we cannot rely on the usual (multivariate) sumcheck protocol. Instead, we present a novel protocol that realizes a univariate analogue of the classical sumcheck protocol, and use it as the testing “core” of our IOP protocol for R1CS. We discuss univariate sumcheck next.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 2.1.</h6>

    <p class="text-gray-300">The verifier receives as input an explicit (non-uniform) description of the set of constraints, namely, the matrices <span class="math">A,B,C</span>. In particular, the verifier runs in time that is at least linear in the number of non-zero entries in these matrices (if we consider a sparse-matrix representation for example).</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.2 A sumcheck protocol for univariate polynomials</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A key ingredient in our IOP protocol is a <em>univariate</em> analogue of the classical (multivariate) sumcheck protocol <em>[x12]</em>. Recall that the classical sumcheck protocol is an IP for claims of the form “<span class="math">\\sum_{\\vec{a}\\in H^{m}}f(\\vec{a})=0</span>”, where <span class="math">f</span> is a given polynomial in <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{m}]</span> of individual degree <span class="math">d</span> and <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span>. In this protocol, the verifier runs in time $\\mathrm{poly}(m,d,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and accesses </span>f<span class="math"> at a single (random) location. The sumcheck protocol plays a fundamental role in computational complexity (it underlies celebrated results such as </span>\\mathsf{IP}=\\mathsf{PSPACE}<span class="math"> <em>[x23]</em> and </span>\\mathsf{MIP}=\\mathsf{NEXP}$ <em>[x1]</em>) and in efficient proof protocols <em>[x11, x10, x24, x25, x26, x27, x28]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We work with univariate polynomials instead, and need a univariate analogue of the sumcheck protocol (see previous subsection): <em>how can a prover convince the verifier that “<span class="math">\\sum_{a\\in H}f(a)=0</span>” for a given polynomial <span class="math">f\\in\\mathbb{F}[X]</span> of degree <span class="math">d</span> and subset <span class="math">H\\subseteq\\mathbb{F}</span>?</em> Designing a “univariate sumcheck” is not straightforward because univariate polynomials (the Reed–Solomon code) do not have the tensor structure used by the sumcheck protocol for multivariate polynomials (the Reed–Muller code). In particular, the sumcheck protocol has <span class="math">m</span> rounds, each of which reduces a sumcheck problem to a simpler sumcheck problem with one variable fewer. When there is only one variable, however, it is not clear to what simpler problems one can reduce.</p>

    <p class="text-gray-300">Using different ideas, we design a natural protocol for univariate sumcheck in the cases where <span class="math">H</span> is an additive or multiplicative coset in <span class="math">\\mathbb{F}</span> (i.e., a coset of an additive or multiplicative subgroup of <span class="math">\\mathbb{F}</span>).</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem (informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The univariate sumcheck protocol over additive or multiplicative cosets has a <span class="math">O(\\log d)</span>-round IOP with proof complexity <span class="math">O(d)</span> over alphabet <span class="math">\\mathbb{F}</span> and query complexity <span class="math">O(\\log d)</span>. The IOP prover uses $O(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations and the IOP verifier uses </span>O(\\log d+\\log^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now provide the main ideas behind the protocol, when <span class="math">H</span> is an <em>additive</em> coset in <span class="math">\\mathbb{F}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose for a moment that the degree <span class="math">d</span> of <span class="math">f</span> is less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (we remove this restriction later). A theorem of Byott and Chapman <em>[x4]</em> states that the sum of </span>f<span class="math"> over (an additive coset) </span>H$ is zero if and only if the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">coefficient of $X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> in </span>f<span class="math"> is zero. In particular, </span>\\sum_{a\\in H}f(a)<span class="math"> is zero if and only if </span>f<span class="math"> has degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math">. Thus, the univariate sumcheck problem over </span>H<span class="math"> when </span>d<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is equivalent to low-degree testing.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The foregoing suggests a natural approach: test that <span class="math">f</span> has degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math">. Without any help from the prover, the verifier would need at least </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries to </span>f<span class="math"> to conduct such a test, which is as expensive as querying all of </span>H<span class="math">. However, the prover can help by engaging with the verifier in an IOP of Proximity for the Reed–Solomon code. For this we rely on the recent construction of Ben-Sasson et al. <em>[x1]</em>, which has proof length </span>O(d)<span class="math"> and query complexity </span>O(\\log d)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our setting, however, we need to also handle the case where the degree <span class="math">d</span> of <span class="math">f</span> is larger than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For this case, we observe that we can split any polynomial </span>f<span class="math"> into two polynomials </span>g<span class="math"> and </span>h<span class="math"> such that </span>f(x)\\equiv g(x)+\\prod_{\\alpha\\in H}(x-\\alpha)\\cdot h(x)<span class="math"> with </span>\\deg(g)<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\deg(h)<d-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; in particular, </span>f<span class="math"> and </span>g<span class="math"> agree on </span>H<span class="math">, and thus so do their sums on </span>H<span class="math">. This observation suggests the following extension to the prior approach: the prover sends </span>g<span class="math"> (as an oracle) to the verifier, and then the verifier performs the prior protocol with </span>g<span class="math"> in place of </span>f<span class="math">. Of course, a cheating prover may send a polynomial </span>g<span class="math"> that has nothing to do with </span>f<span class="math">, and so the verifier must also ensure that </span>g<span class="math"> is consistent with </span>f<span class="math">. To facilitate this, we actually have the prover send </span>h<span class="math"> rather than </span>g<span class="math">; the verifier can then “query” </span>g(x)<span class="math"> as </span>f(x)-\\prod_{\\alpha\\in H}(x-\\alpha)\\cdot h(x)<span class="math">; the prover then shows that </span>f,g,h$ are all of the correct degrees.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A similar reasoning works when <span class="math">H</span> is a multiplicative coset in <span class="math">\\mathbb{F}</span> (see Remark 5.6). It remains an interesting open problem to establish whether the foregoing can be extended to any subset <span class="math">H</span> in <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Remark 2.2 (vanishing vs. summing).</h6>

    <p class="text-gray-300">The following are both linear subcodes of the Reed–Solomon code:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{VanishRS}[\\mathbb{F},L,H,d]:=</span> $\\{f\\colon L\\to\\mathbb{F}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,f\\text{ has degree less than }d\\text{ and is zero everywhere on }H\\}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our univariate sumcheck protocol is an IOP of Proximity for <span class="math">\\mathsf{SumRS}</span>, and is reminiscent of IOPs of Proximity for <span class="math">\\mathsf{VanishRS}</span> (e.g., see <em>[x1]</em>). Nevertheless, there are also intriguing differences between the two cases. For example, while it is known how to test proximity to <span class="math">\\mathsf{VanishRS}</span> for general <span class="math">H</span>, we only know how to test proximity to <span class="math">\\mathsf{SumRS}</span> when <span class="math">H</span> is a coset. Additionally, our IOP protocol for R1CS from Section 2.1 can be viewed as a reduction from checking satisfaction of R1CS to testing proximity to <span class="math">\\mathsf{SumRS}</span>; we do not know how to carry out a similar reduction to <span class="math">\\mathsf{VanishRS}</span>. Indeed, there is an interactive reduction from <span class="math">\\mathsf{VanishRS}</span> to <span class="math">\\mathsf{SumRS}</span>, but no reduction in the other direction is known.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.3 Efficient zero knowledge from algebraic techniques</h3>

    <p class="text-gray-300">The ideas discussed thus far yield an IOP protocol for R1CS with linear proof length and logarithmic query complexity. However these by themselves do not provide zero knowledge.</p>

    <p class="text-gray-300">We achieve zero knowledge by leveraging recent algebraic techniques <em>[x2]</em>. Informally, we adapt these techniques to achieve efficient zero knowledge variants of key sub-protocols, including the univariate sumcheck protocol (see Section 5.1) and low-degree testing (see Section 8.1), and combine these to achieve a zero knowledge IOP protocol for R1CS (see Sections 7.1 and 9).</p>

    <p class="text-gray-300">We summarize the basic intuition for how we achieve zero knowledge in our protocols.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we use <em>bounded independence</em>. Informally, rather than encoding a vector <span class="math">z\\in\\mathbb{F}^{H}</span> by the unique polynomial of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> that matches </span>z<span class="math"> on </span>H<span class="math">, we instead sample uniformly at random a polynomial of degree, say, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+9<span class="math"> conditioned on matching </span>z<span class="math"> on </span>H<span class="math">. Any set of </span>10<span class="math"> evaluations of such a polynomial are independently and uniformly distributed in </span>\\mathbb{F}<span class="math"> (and thus reveal no information about </span>z<span class="math">), <em>provided these evaluations are outside of </span>H<span class="math"></em>. To ensure this latter condition, we choose the evaluation domain </span>L$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">ed–Solomon codewords to be disjoint from <span class="math">H</span>. Thus, for example, if <span class="math">H</span> is a linear space (an additive subgroup of <span class="math">\\mathbb{F}</span>) then we choose <span class="math">L</span> to be an affine subspace (a coset of some additive subgroup), since the underlying machinery for low-degree testing (e.g., <em>[x1]</em>) requires codewords to be evaluated over algebraically-structured domains. All of our protocols are robust to these variations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bounded independence alone does not suffice, though. For example, in the sumcheck protocol, consider the case where the input vector <span class="math">z\\in\\mathbb{F}^{H}</span> is all zeroes. The prover samples a random polynomial <span class="math">\\hat{f}</span> of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+9<span class="math">, such that </span>\\hat{f}(a)=0<span class="math"> for all </span>a\\in H<span class="math">, and sends its evaluation </span>f<span class="math"> over </span>L<span class="math"> disjoint from </span>H<span class="math"> to the verifier. As discussed, any ten queries to </span>f<span class="math"> result in ten independent and uniformly random elements in </span>\\mathbb{F}<span class="math">. Observe, however, that when we run the sumcheck protocol on </span>f<span class="math">, the polynomial </span>g<span class="math"> (the remainder of </span>\\hat{f}<span class="math"> when divided by </span>\\prod_{\\alpha\\in H}(x-\\alpha)$) is the zero polynomial: all randomness is removed by the division.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To remedy this, we use <em>self-reducibility</em> to reduce a sumcheck claim about the polynomial <span class="math">f</span> to a sumcheck claim about a random polynomial. The prover first sends a random Reed–Solomon codeword <span class="math">r</span>, along with the value <span class="math">\\beta:=\\sum_{a\\in H}r(a)</span>. The verifier sends a random challenge <span class="math">\\rho\\in\\mathbb{F}</span>. Then the prover and verifier engage in the univariate sumcheck protocol with respect to the new claim “<span class="math">\\sum_{a\\in H}\\rho f(a)+r(a)=\\beta</span>”. Since <span class="math">r</span> is uniformly random, <span class="math">\\rho f+r</span> is uniformly random for any <span class="math">\\rho</span>, and thus the sumcheck protocol is performed on a random polynomial, which ensures zero knowledge. Soundness is ensured by the fact that if <span class="math">f</span> does not sum to <span class="math">0</span> on <span class="math">H</span> then the new claim is true with probability $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the choice of </span>\\rho$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.4 Perspective on our techniques</h3>

    <p class="text-gray-300">A linear-length logarithmic-query IOP for a “circuit-like” NP-complete relation like R1CS (Theorem 1.1) may come as a surprise. We wish to shed some light on our IOP construction by connecting the ideas behind it to prior ideas in the probabilistic checking literature, and use these connections to motivate our construction.</p>

    <p class="text-gray-300">A significant cost in all known PCP constructions with good proof length is using <em>routing networks</em> to reduce combinatorial objects (circuits, machines, and so on) to structured algebraic ones; routing also plays a major role in many IOPs <em>[x5, x4, x1, x3]</em> While it is plausible that one could adapt routing techniques to route the constraints of an R1CS instance (similarly to <em>[x22]</em>), such an approach would likely incur logarithmic-factor overheads, precluding <em>linear</em>-size IOPs.</p>

    <p class="text-gray-300">A recent work <em>[x5]</em> achieves linear-length constant-query IOPs for boolean circuit satisfaction <em>without routing the input circuit</em>. Unfortunately, <em>[x5]</em> relies on other expensive tools, such as algebraic-geometry (AG) codes and quasilinear-size PCPs of proximity <em>[x10]</em>; moreover, it is not zero knowledge. Informally, <em>[x5]</em> tests arbitrary (unstructured) constraints by invoking a sumcheck protocol <em>[x17]</em> on a <span class="math">O(1)</span>-wise tensor product of AG codes; this latter is then locally tested via tools in <em>[x10, x11]</em>.</p>

    <p class="text-gray-300">One may conjecture that, to achieve an IOP for R1CS like ours, it would suffice to merely replace the AG codes in <em>[x5]</em> with the Reed–Solomon code, since both codes have constant rate. But taking a tensor product exponentially deteriorates rate, and testing proximity to that tensor product would be expensive.</p>

    <p class="text-gray-300">An alternative approach is to solve a sumcheck problem <em>directly</em> on the Reed–Solomon code. Existing protocols are not of much use here: the multivariate sumcheck protocol relies on a tensor structure that is <em>not</em> available in the Reed–Solomon code, and recent IOP implementations either use routing <em>[x1, x2]</em> or achieve only sublinear query complexity <em>[x1]</em>.</p>

    <p class="text-gray-300">Instead, we design a completely new IOP for a sumcheck problem on the Reed–Solomon code. We then combine this solution with ideas from <em>[x5]</em> (to avoid routing) and from <em>[x6]</em> (to achieve zero</p>

    <p class="text-gray-300">knowledge) to obtain our linear-length logarithmic-query IOP for R1CS. Along the way, we rely on recent efficient proximity tests for the Reed–Solomon code <em>[x1]</em>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">In Section 4 we provide necessary definitions about codes, proof systems, and other notions. Subsequent sections describe subprotocols, presented as Reed-Solomon encoded IOPs, which are IOPs for which soundness only holds against provers whose messages are Reed-Solomon codewords of specified rates, that are later compiled into standard IOPs. Specifically: the sumcheck protocol is in Section 5; the lincheck protocol in Section 6; and the rowcheck protocol in Section 4.8. In Section 7 we combine the rowcheck and lincheck protocols to obtain an RS-encoded IOP for R1CS. In Section 8 we explain how to transform RS-encoded IOPs to standard IOPs, and in Section 9 we apply this transformation to our RS-encoded IOP for R1CS. Fig. 3 summarizes the structure of our IOP for R1CS. Finally, in Section 10 we describe our implementation and in Section 11 we report on its evaluation.</p>

    <p class="text-gray-300">Throughout, we focus on the case where all relevant domains are additive cosets (affine subspaces) in  <span class="math">\\mathbb{F}</span> . The case where domains are multiplicative cosets is similar, with only minor modifications (see Remark 5.6). Moreover, while for convenience we limit our discussions to establishing soundness, all protocols described in this paper are easily seen to satisfy the stronger notion of proof of knowledge. Informally, this is because we prove soundness by showing that oracles sent by convincing provers can be decoded to valid witnesses.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> IOP for R1CS (Section 9) Figure 3: Structure of our IOP for R1CS in terms of key sub-protocols.</p>

    <p class="text-gray-300">4 Preliminaries</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a relation <span class="math">\\mathcal{R}\\subseteq S\\times T</span>, we denote by <span class="math">\\mathcal{L}(\\mathcal{R})\\subseteq S</span> the set of <span class="math">s\\in S</span> such that there exists <span class="math">t\\in T</span> with <span class="math">(s,t)\\in\\mathcal{R}</span>; for <span class="math">s\\in S</span>, we denote by $\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{s}\\subseteq T<span class="math"> the set </span>\\{t\\in T:(s,t)\\in\\mathcal{R}\\}<span class="math">. Given a set </span>S<span class="math"> and strings </span>v,w\\in S^{n}<span class="math"> for some </span>n\\in\\mathbb{N}<span class="math">, the <em>fractional Hamming distance</em> </span>\\Delta(v,w)\\in[0,1]<span class="math"> is </span>\\Delta(v,w):=\\frac{1}{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i:v_{i}\\neq w_{i}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.1 Codes</h3>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Interleaved codes.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given linear codes <span class="math">C_{1},\\ldots,C_{m}\\subseteq\\mathbb{F}^{n}</span> with alphabet <span class="math">\\mathbb{F}</span>, we denote by <span class="math">\\prod_{i=1}^{m}C_{i}\\subseteq(\\mathbb{F}^{m})^{n}\\equiv\\mathbb{F}^{m\\times n}</span> the linear “interleaved” code with alphabet <span class="math">\\mathbb{F}^{m}</span> that equals the set of all <span class="math">m\\times n</span> matrices whose <span class="math">i</span>-th row is in <span class="math">C_{i}</span>. If <span class="math">C_{1}=\\cdots=C_{m}</span>, we write <span class="math">C^{m}</span> for <span class="math">\\prod_{i=1}^{m}C_{i}</span>. Since the alphabet is <span class="math">\\mathbb{F}^{m}</span>, the Hamming distance is taken <em>column-wise</em>: for <span class="math">A,A^{\\prime}\\in\\mathbb{F}^{m\\times n}</span>, $\\Delta(A,A^{\\prime}):=\\frac{1}{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{j\\in[n]:\\exists\\,i\\in[m]<span class="math"> s.t. </span>A_{i,j}\\neq A^{\\prime}_{i,j}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">The Reed–Solomon code.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a subset <span class="math">L</span> of a field <span class="math">\\mathbb{F}</span> and <span class="math">\\rho\\in(0,1]</span>, we denote by <span class="math">\\mathrm{RS}\\,[L,\\rho]\\subseteq\\mathbb{F}^{L}</span> all evaluations over <span class="math">L</span> of univariate polynomials of degree less than $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. That is, a word </span>c\\in\\mathbb{F}^{L}<span class="math"> is in </span>\\mathrm{RS}\\,[L,\\rho]<span class="math"> if there exists a polynomial </span>p<span class="math"> of degree less than </span>\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>c_{a}=p(a)<span class="math"> for every </span>a\\in L<span class="math">. We denote by </span>\\mathrm{RS}\\,[L,(\\rho_{1},\\ldots,\\rho_{n})]:=\\prod_{i=1}^{n}\\mathrm{RS}\\,[L,\\rho_{i}]<span class="math"> the interleaving of Reed–Solomon codes with rates </span>\\rho_{1},\\ldots,\\rho_{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.2 Representations of polynomials</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We frequently move from univariate polynomials over <span class="math">\\mathbb{F}</span> to their evaluations on chosen subsets of <span class="math">\\mathbb{F}</span>, and back. We use plain letters like <span class="math">f,g,h,\\pi</span> to denote <em>evaluations</em> of polynomials, and “hatted letters” <span class="math">\\hat{f},\\hat{g},\\hat{h},\\hat{\\pi}</span> to denote corresponding polynomials. This bijection is well-defined only if the size of the evaluation domain is larger than the degree. Formally, if <span class="math">f\\in\\mathrm{RS}\\,[L,\\rho]</span> for <span class="math">L\\subseteq\\mathbb{F}</span>, <span class="math">\\rho\\in(0,1]</span>, then <span class="math">\\hat{f}</span> is the unique polynomial of degree less than $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> whose evaluation on </span>L<span class="math"> equals </span>f<span class="math">. Likewise, if </span>\\hat{f}\\in\\mathbb{F}[X]<span class="math"> with </span>\\deg(f)<\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then </span>f_{L}:=\\hat{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}\\in\\mathrm{RS}\\,[L,\\rho]$ (but we will drop the subscript when the choice of subset is clear from context).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.3 The fast Fourier transform</h3>

    <p class="text-gray-300">We often rely on polynomial arithmetic, which can be efficiently performed via fast Fourier transforms and their inverses. In particular, polynomial evaluation and interpolation over an (affine) subspace of size <span class="math">n</span> of a finite field can be performed in <span class="math">O(n\\log n)</span> field operations via an additive FFT <em>[x11]</em>. Because in practice the number of FFTs we perform is important, when discussing complexities we use the notation <span class="math">\\mathrm{FFT}(\\mathbb{F},m)</span> for the cost of a single additive FFT (or IFFT) on a subspace of <span class="math">\\mathbb{F}</span> of size <span class="math">m</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 4.1.</h6>

    <p class="text-gray-300">Strictly, an additive FFT evaluates a polynomial of degree <span class="math">d</span> on a subspace of size <span class="math">d+1</span>. To evaluate on a larger subspace (of size <span class="math">n</span>), one can run an FFT over each coset of the smaller space inside the larger one at a cost of <span class="math">\\frac{n}{d}\\cdot O(d\\log d)=O(n\\log d)</span>. We will suppress this technicality when it appears, and upper bound the cost of such an evaluation by an FFT on a subspace of size <span class="math">n</span>.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">4.4 Subspace polynomials</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be an extension field of a prime field <span class="math">\\mathbb{F}_{p}</span>, and <span class="math">H</span> be a subset of <span class="math">\\mathbb{F}</span>. We denote by <span class="math">\\mathbb{Z}_{H}</span> the unique monic polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero on </span>H<span class="math">. If </span>H<span class="math"> is an (affine) subspace of </span>\\mathbb{F}<span class="math">, then </span>\\mathbb{Z}_{H}<span class="math"> is called an <em>(affine) subspace polynomial</em>. In this case, there exist coefficients </span>c_{0},\\ldots,c_{k}\\in\\mathbb{F}<span class="math">, where </span>k:=\\dim(H)<span class="math">, such that </span>\\mathbb{Z}_{H}(X)=X^{p^{k}}+\\sum_{i=1}^{k}c_{i}X^{p^{i-1}}+c_{0}<span class="math"> (if </span>H<span class="math"> is linear then </span>c_{0}=0<span class="math">). See <em>[x15, Chapter 3.4]</em> and <em>[x2, Remark C.8]</em> for how to find the coefficients </span>c_{0},\\ldots,c_{k}<span class="math"> in </span>O(k^{2}\\log p)$ field operations. Polynomials of this</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">type are called linearized because they are <span class="math">\\mathbb{F}_p</span>-affine maps: if <span class="math">H = H_0 + \\beta</span> for a subspace <span class="math">H_0 \\subseteq \\mathbb{F}</span> and shift <span class="math">\\beta \\in \\mathbb{F}</span>, then <span class="math">\\mathbb{Z}_H(X) \\equiv \\mathbb{Z}_{H_0}(X) - \\mathbb{Z}_{H_0}(\\beta)</span>, and <span class="math">\\mathbb{Z}_{H_0}</span> is an <span class="math">\\mathbb{F}_p</span>-linear map.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4.5 Interactive oracle proofs</h2>

    <p class="text-gray-300">The information-theoretic protocols in this paper are Interactive Oracle Proofs (IOPs) [BCS16; RRR16], which combine aspects of Interactive Proofs [Bab85; GMR89] and Probabilistically Checkable Proofs [BFLS91; AS98; ALMSS98], and also generalize the notion of Interactive PCPs [KR08].</p>

    <p class="text-gray-300">A <span class="math">\\mathsf{k}</span>-round public-coin IOP has <span class="math">\\mathsf{k}</span> rounds of interaction. In the <span class="math">i</span>-th round of interaction, the verifier sends a uniformly random message <span class="math">m_{i}</span> to the prover; then the prover replies with a message <span class="math">\\pi_{i}</span> to the verifier. After <span class="math">\\mathsf{k}</span> rounds of interaction, the verifier makes some queries to the oracles it received and either accepts or rejects.</p>

    <p class="text-gray-300">An IOP system for a relation <span class="math">\\mathcal{R}</span> with round complexity <span class="math">\\mathsf{k}</span> and soundness error <span class="math">\\varepsilon</span> is a pair <span class="math">(P, V)</span>, where <span class="math">P, V</span> are probabilistic algorithms, that satisfies the following properties. (See [BCS16; RRR16] for details.)</p>

    <p class="text-gray-300">Completeness: For every instance-witness pair <span class="math">(\\mathbf{x}, \\mathbf{w})</span> in the relation <span class="math">\\mathcal{R}</span>, <span class="math">(P(\\mathbf{x}, \\mathbf{w}), V(\\mathbf{x}))</span> is a <span class="math">\\mathsf{k}(n)</span>-round interactive oracle protocol with accepting probability 1.</p>

    <p class="text-gray-300">Soundness: For every instance <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span> and unbounded malicious prover <span class="math">\\tilde{P}</span>, <span class="math">(\\tilde{P}, V(\\mathbf{x}))</span> is a <span class="math">\\mathsf{k}(n)</span>-round interactive oracle protocol with accepting probability at most <span class="math">\\varepsilon(n)</span>.</p>

    <p class="text-gray-300">Like the IP model, a fundamental measure of efficiency is the round complexity <span class="math">\\mathsf{k}</span>. Like the PCP model, two additional fundamental measures of efficiency are the proof length <span class="math">\\mathsf{p}</span>, which is the total number of alphabet symbols in all of the prover's messages, and the query complexity <span class="math">\\mathsf{q}</span>, which is the total number of locations queried by the verifier across all of the prover's messages.</p>

    <p class="text-gray-300">We say that an IOP system is non-adaptive if the verifier queries are non-adaptive, namely, the queried locations depend only on the verifier's inputs and its randomness. All of our IOP systems will be non-adaptive.</p>

    <p class="text-gray-300">Since the verifier is public coin, its behavior in the interactive part of the protocol is easy to describe. We can therefore think of <span class="math">V</span> as a randomized algorithm which, given its prior random messages and oracle access to the prover's messages, makes queries to the prover's messages and either accepts or rejects.</p>

    <p class="text-gray-300">The foregoing division allows us to separately consider the randomness and soundness error for these two phases, which is useful for a more fine-grained soundness-error reduction. Letting <span class="math">r_i</span> and <span class="math">r_q</span> be the randomness complexities of interaction and query phases respectively, the quantities <span class="math">\\varepsilon_i</span> and <span class="math">\\varepsilon_q</span> satisfy the following relation (for all instances <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span> and malicious provers <span class="math">\\tilde{P}</span>):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\Pr_{r \\leftarrow \\{0, 1\\}^{\\mathrm{r_q}} [ V^{\\pi_1, \\dots, \\pi_k}(\\mathbf{x}, m_1, \\dots, m_k; r) = 1 ] \\geq \\varepsilon_{\\mathfrak{q}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (m_1, \\dots, m_k) \\leftarrow \\{0, 1\\}^{\\mathrm{r_i}} \\\\ \\pi_1, \\dots, \\pi_k \\leftarrow (\\tilde{P}, (m_1, \\dots, m_k)) \\end{array} \\right. \\right] \\leq \\varepsilon_{\\mathrm{i}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">That is, the probability that random messages make <span class="math">V</span> accept with probability at least <span class="math">\\varepsilon_{\\mathfrak{q}}</span> (over internal randomness) is at most <span class="math">\\varepsilon_{\\mathrm{i}}</span>. In particular, the overall soundness error is at most <span class="math">\\varepsilon_{\\mathrm{i}} + \\varepsilon_{\\mathfrak{q}}</span>. Note that an IOP with <span class="math">\\varepsilon_{\\mathrm{i}} = 0</span> is a PCP, an IOP with <span class="math">\\varepsilon_{\\mathfrak{q}} = 0</span> is an IP, and an IOP with both <span class="math">\\varepsilon_{\\mathrm{i}} = \\varepsilon_{\\mathfrak{q}} = 0</span> is a deterministic (NP) proof.</p>

    <p class="text-gray-300">Given the above, consider a "semi-black-box" example of soundness-error reduction: the interactive phase is run once, and then we repeat the query phase <span class="math">\\ell</span> times with fresh randomness. This yields an IOP with query complexity <span class="math">\\ell \\cdot \\mathfrak{q}</span>, randomness complexity <span class="math">r_i + \\ell \\cdot r_q</span>, and soundness error <span class="math">\\varepsilon_i + \\varepsilon_{\\mathfrak{q}}^{\\ell}</span>, but with the same proof length and number of rounds. The running time of the prover is unchanged, and the verifier runs in time <span class="math">O(\\ell \\cdot t_V)</span>. By comparison, repetition of the entire protocol yields proof length <span class="math">\\ell \\cdot \\mathfrak{p}</span> and <span class="math">\\ell \\cdot \\mathfrak{k}</span> rounds, for soundness error <span class="math">(\\varepsilon_{\\mathrm{i}} + \\varepsilon_{\\mathfrak{q}})^{\\ell}</span>; the prover runs in time <span class="math">O(\\ell \\cdot t_P)</span> and the verifier in time <span class="math">O(\\ell \\cdot t_V)</span>.</p>

    <p class="text-gray-300">Proof of knowledge. The IOP protocols presented in this paper satisfy a stronger notion of soundness called proof of knowledge: if a prover algorithm <span class="math">\\tilde{P}</span> convinces the verifier with sufficiently high probability, it</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is possible to efficiently extract a witness from <span class="math">\\tilde{P}</span>. In order to give a formal definition, we define the quantity $w_{\\mathcal{R}}(n):=\\max\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:(\\mathsf{x},\\mathsf{w})\\in\\mathcal{R},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n\\}<span class="math">, the maximum witness length for an instance of length </span>n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof of knowledge.</h6>

    <p class="text-gray-300">There exists a probabilistic polynomial-time algorithm <span class="math">E</span> such that for every instance <span class="math">\\mathsf{x}</span> and unbounded malicious prover <span class="math">\\tilde{P}</span> that makes <span class="math">V</span> accept with probability <span class="math">\\mu</span>, <span class="math">E^{\\tilde{P}}(\\mathsf{x},1^{w_{\\mathcal{R}}(n)})</span> outputs <span class="math">\\mathsf{w}</span> such that <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span> with probability at least <span class="math">\\mu-\\varepsilon(n)</span>.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">4.5.1 IOPs of proximity</h4>

    <p class="text-gray-300">An IOP of Proximity extends an IOP the same way that PCPs of Proximity extend PCPs. An IOPP system for a relation <span class="math">\\mathcal{R}</span> with round complexity <span class="math">\\mathsf{k}</span>, soundness error <span class="math">\\varepsilon</span>, and proximity parameter <span class="math">\\delta</span> is a pair <span class="math">(P,V)</span> that satisfies the following properties.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Completeness.</h6>

    <p class="text-gray-300">For every instance-witness pair <span class="math">(\\mathsf{x},\\mathsf{w})</span> in the relation <span class="math">\\mathcal{R}</span>, <span class="math">(P(\\mathsf{x},\\mathsf{w}),V^{\\mathsf{w}}(\\mathsf{x}))</span> is a <span class="math">\\mathsf{k}(n)</span>-round interactive oracle protocol with accepting probability <span class="math">1</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Soundness.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every instance-witness pair <span class="math">(\\mathsf{x},\\mathsf{w})</span> with $\\Delta(\\mathsf{w},\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{x}})\\geq\\delta(n)<span class="math"> and unbounded malicious prover </span>\\tilde{P}<span class="math">, </span>(\\tilde{P},V^{\\mathsf{w}}(\\mathsf{x}))<span class="math"> is a </span>\\mathsf{k}(n)<span class="math">-round interactive oracle protocol with accepting probability at most </span>\\varepsilon(n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Efficiency measures for IOPPs are as for IOPs, except that we also count queries to the witness. Namely, if <span class="math">V</span> makes at most <span class="math">\\mathsf{q}_{\\mathsf{w}}</span> queries to <span class="math">\\mathsf{w}</span> and at most <span class="math">\\mathsf{q}_{\\pi}</span> queries across all prover messages, the query complexity is <span class="math">\\mathsf{q}:=\\mathsf{q}_{\\mathsf{w}}+\\mathsf{q}_{\\pi}</span>. Like with IOPs, we divide public-coin IOPPs into an interaction phase and a query phase.</p>

    <p class="text-gray-300">Low-degree testing. For the purposes of this paper, a low-degree test is an IOPP for the Reed–Solomon relation <span class="math">\\mathcal{R}_{\\mathrm{RS}}:=\\{((L,\\rho),p):L\\subseteq\\mathbb{F},\\rho\\in(0,1],p\\in\\mathrm{RS}\\left[L,\\rho\\right]\\}</span>. In this case <span class="math">\\varepsilon</span> and <span class="math">\\delta</span> are functions of <span class="math">\\rho</span>.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.6 Zero knowledge</h3>

    <p class="text-gray-300">The definitions of unconditional (perfect) zero knowledge that we use for IOPs and for IOPPs follow those in <em>[x10, x16, x1]</em>. We first define the notion of a view and of straightline access; after that we define zero knowledge for IOPs and for IOPPs in a way that suffices for our purposes.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">Let <span class="math">A,B</span> be algorithms and <span class="math">x,y</span> strings. We denote by <span class="math">\\mathrm{View}\\ (B(y),A(x))</span> the view of <span class="math">A(x)</span> in an interactive oracle protocol with <span class="math">B(y)</span>, i.e., the random variable <span class="math">(x,r,a_{1},\\ldots,a_{n})</span> where <span class="math">x</span> is <span class="math">A</span>’s input, <span class="math">r</span> is <span class="math">A</span>’s randomness, and <span class="math">a_{1},\\ldots,a_{n}</span> are the answers to <span class="math">A</span>’s queries into <span class="math">B</span>’s messages.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 4.3.</h6>

    <p class="text-gray-300">An algorithm <span class="math">B</span> has straightline access to an algorithm <span class="math">A</span> if <span class="math">B</span> interacts with <span class="math">A</span>, without rewinding, by exchanging messages with <span class="math">A</span> and answering any oracle queries along the way.</p>

    <p class="text-gray-300">We denote by <span class="math">B^{A}</span> the concatenation of <span class="math">A</span>’s random tape and <span class="math">B</span>’s output when it has straightline access to <span class="math">A</span>. (Since <span class="math">A</span>’s random tape could be super-polynomially large, <span class="math">B</span> cannot sample it for <span class="math">A</span> and then output it; instead, we restrict <span class="math">B</span> to not see it, and we prepend it to <span class="math">B</span>’s output.)</p>

    <p class="text-gray-300">For IOPs, we consider unconditional (perfect) zero knowledge against bounded-query verifiers.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An IOP system <span class="math">(P,V)</span> for a relation <span class="math">\\mathcal{R}</span> is (perfect) zero knowledge against query bound <span class="math">\\mathsf{b}</span> if there exists a simulator algorithm <span class="math">S</span> such that for every <span class="math">\\mathsf{b}</span>-query algorithm <span class="math">\\tilde{V}</span> and instance-witness pair <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, <span class="math">S^{\\tilde{V}}(\\mathsf{x})</span> and <span class="math">\\mathrm{View}\\ (P(\\mathsf{x},\\mathsf{w}),\\tilde{V}(\\mathsf{x}))</span> are identically distributed. (An algorithm is <span class="math">\\mathsf{b}</span>-query if, on input <span class="math">\\mathsf{x}</span>, it makes at most $\\mathsf{b}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> queries to any oracles it has access to.) Moreover, </span>S<span class="math"> must run in time </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{q}_{\\tilde{V}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, where </span>\\mathsf{q}_{\\tilde{V}}(\\cdot)<span class="math"> is </span>\\tilde{V}$’s query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For zero knowledge against arbitrary polynomial-time adversaries, it suffices for  <span class="math">\\mathsf{b}</span>  to be superpolynomial. Note that  <span class="math">S</span> 's running time is required to be polynomial in the input size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and the actual number of queries  </span>\\tilde{V}<span class="math">  makes (as a random variable) and, in particular, may be polynomial even if  </span>\\mathsf{b}<span class="math">  is not. We do not restrict  </span>\\tilde{V}$  to make queries only at the end of the interaction; all of our protocols will be zero knowledge against the more general class of verifier that can, at any time, make queries to any oracle it has already received.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For IOPPs, we consider unconditional (perfect) zero knowledge against unbounded-query verifiers.</p>

    <p class="text-gray-300">Definition 4.5. An IOPP system  <span class="math">(P,V)</span>  for a relation  <span class="math">\\mathcal{R}</span>  is (perfect) zero knowledge against unbounded queries if there exists a simulator algorithm  <span class="math">S</span>  such that for every algorithm  <span class="math">\\tilde{V}</span>  and instance-witness pair  <span class="math">(\\mathbf{x},\\mathbf{w})\\in \\mathcal{R}</span> , the following two random variables are identically distributed:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(S ^ {\\tilde {V}, \\mathbf {w}} (\\mathbf {x}), q _ {S}\\right) \\quad a n d \\quad \\left(\\operatorname {V i e w} \\left(P (\\mathbf {x}, \\mathbf {w}), \\tilde {V} ^ {\\mathbf {w}} (\\mathbf {x})\\right), q _ {\\tilde {V}}\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">q_{S}</span>  is the number of queries to  <span class="math">\\mathbf{w}</span>  made by  <span class="math">S</span> , and  <span class="math">q_{\\tilde{V}}</span>  is the number of queries to  <span class="math">\\mathbf{w}</span>  or to prover messages made by  <span class="math">\\tilde{V}</span> . Moreover,  <span class="math">S</span>  must run in time  $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathfrak{q}_{\\tilde{V}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> , where  </span>\\mathfrak{q}_{\\tilde{V}}(\\cdot)<span class="math">  is  </span>\\tilde{V}$ 's query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-35" class="text-2xl font-bold">4.7 Reed-Solomon encoded IOP</h2>

    <p class="text-gray-300">We typically first describe IOPs for which soundness only holds against provers whose messages are Reed-Solomon codewords of specified rates and on which certain rational constraints hold, and later "compile" them into standard IOPs. This facilitates focusing on a protocol's key ideas, and leaves handling provers that do not respect this restriction to generic tools. We first define what we mean by a rational constraint.</p>

    <p class="text-gray-300">Definition 4.6. A rational constraint is a pair  <span class="math">(\\mathcal{C},\\sigma)</span>  where  <span class="math">\\mathcal{C} = (N,D)</span> ,  <span class="math">N\\colon \\mathbb{F}^{1 + \\ell}\\to \\mathbb{F}</span> ,  <span class="math">D\\colon \\mathbb{F}\\to \\mathbb{F}</span>  are arithmetic circuits and  <span class="math">\\sigma \\in (0,1]</span>  is a rate parameter. A rational constraint  <span class="math">(\\mathcal{C},\\sigma)</span>  and an interleaved word  <span class="math">f\\in (L\\to \\mathbb{F})^{\\ell}</span>  jointly define a codeword  <span class="math">\\mathcal{C}[f]\\colon L\\to \\mathbb{F}</span> , given by  <span class="math">\\mathcal{C}f = \\frac{N(\\alpha,f_1(\\alpha),\\ldots,f_\\ell(\\alpha))}{D(\\alpha)}</span>  for all  <span class="math">\\alpha \\in L</span> . A rational constraint  <span class="math">(\\mathcal{C},\\sigma)</span>  is satisfied by  <span class="math">f</span>  if  <span class="math">\\mathcal{C}[f]\\in \\mathrm{RS}[L,\\sigma]</span> .</p>

    <p class="text-gray-300">An Reed-Solomon encoded IOP (RS-encoded IOP) for a relation  <span class="math">\\mathcal{R}</span>  is a tuple  <span class="math">(P, V, (\\vec{\\rho}_{\\mathrm{i}})_{i=1}^{\\mathrm{k}})</span> , where  <span class="math">P</span>  and  <span class="math">V</span>  are probabilistic algorithms and  <span class="math">\\vec{\\rho}_{\\mathrm{i}} \\in (0, 1]^{\\ell_{\\mathrm{i}}}, \\ldots, \\vec{\\rho}_{\\mathrm{k}} \\in (0, 1]^{\\ell_{\\mathrm{k}}}</span> , that satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness:</strong> For every instance-witness pair  <span class="math">(\\mathbf{x},\\mathbf{w})</span>  in the relation  <span class="math">\\mathcal{R}</span> ,  <span class="math">(P(\\mathbf{x},\\mathbf{w}),V(\\mathbf{x}))</span>  is a  <span class="math">\\mathsf{k}(n)</span> -round interactive oracle protocol, where the  <span class="math">i</span> -th message of  <span class="math">P</span>  is a codeword of  <span class="math">\\mathrm{RS}[L,\\vec{\\rho}_{\\mathrm{i}}]</span> , and  <span class="math">V</span>  outputs a set of rational constraints that are satisfied with respect to the prover's messages with probability 1.</p>

    <p class="text-gray-300"><strong>Soundness:</strong> For every instance  <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span>  and unbounded malicious prover  <span class="math">\\tilde{P}</span>  whose  <span class="math">i</span> -th message is a codeword of  <span class="math">\\mathrm{RS}[L, \\vec{\\rho}_i]</span> ,  <span class="math">(\\tilde{P}, V(\\mathbf{x}))</span>  is a  <span class="math">k(n)</span> -round interactive oracle protocol wherein the set of rational constraints output by  <span class="math">V</span>  are satisfied with respect to the prover's messages with probability at most  <span class="math">\\varepsilon(n)</span> .</p>

    <p class="text-gray-300">All RS-encoded IOPs that we consider also satisfy a proof of knowledge property.</p>

    <p class="text-gray-300"><strong>Proof of knowledge:</strong> There exists a probabilistic polynomial-time algorithm  <span class="math">E</span>  such that for every instance  <span class="math">\\mathbf{x}</span>  and unbounded malicious prover  <span class="math">\\tilde{P}</span> , whose  <span class="math">i</span> -th message is a codeword of  <span class="math">\\mathrm{RS}[L, \\vec{\\rho}_i]</span> , that makes  <span class="math">V</span>  output satisfiable rational constraints with probability  <span class="math">\\mu</span> ,  <span class="math">E^{\\tilde{P}}(\\mathbf{x}, 1^{w_{\\mathcal{R}}(n)})</span>  outputs  <span class="math">\\mathbf{w}</span>  such that  <span class="math">(\\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}</span>  with probability at least  <span class="math">\\mu - \\varepsilon(n)</span> .</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">A useful complexity measure of a Reed–Solomon encoded IOP is its <em>maximum rate</em>, which informally is the maximum over the (prescribed) rates of codewords sent by the prover and those induced by the verifier’s rational constraints. To formally define it, we need to first introduce the <em>degree</em> and <em>rate</em> of a circuit.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 4.7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <em>degree</em> of an arithmetic circuit <span class="math">C\\colon\\mathbb{F}^{1+\\ell}\\to\\mathbb{F}</span> on input degrees <span class="math">d_{1},\\ldots,d_{\\ell}\\in\\mathbb{N}</span>, denoted <span class="math">\\deg(C;d_{1},\\ldots,d_{\\ell})</span>, is the smallest integer <span class="math">e</span> such that for all <span class="math">p_{i}\\in\\mathbb{F}^{\\leq d_{i}}[X]</span> there exists a polynomial <span class="math">q\\in\\mathbb{F}^{\\leq e}[X]</span> such that <span class="math">C(X,p_{1}(X),\\ldots,p_{\\ell}(X))\\equiv q(X)</span>. Given domain <span class="math">L\\subseteq\\mathbb{F}</span> and rates <span class="math">\\vec{\\rho}\\in(0,1]^{\\ell}</span>, the <em>rate</em> of <span class="math">C</span> is $\\mathrm{rate}(C;\\vec{\\rho}):=\\deg(C;\\rho_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ldots,\\rho_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. (The domain </span>L<span class="math"> will be clear from context.) Note that if </span>\\ell=0<span class="math"> then the foregoing notion of degree coincides with the usual one (namely, </span>\\deg(C)<span class="math"> is the degree of the polynomial described by </span>C<span class="math">), and the foregoing notion of rate is simply </span>\\mathrm{rate}(C):=\\deg(C)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A Reed–Solomon encoded IOP <span class="math">(P,V,(\\vec{\\rho}_{i})_{i=1}^{\\mathsf{k}})</span> has <em>maximum rate</em> <span class="math">(\\sigma^{<em>},\\rho^{</em>})</span> if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sigma^{*}</span> is (at least) the maximum among the rates in <span class="math">\\vec{\\rho}:=(\\vec{\\rho}_{i})_{i=1}^{\\mathsf{k}}</span> and the rates in <span class="math">\\{\\sigma\\,:\\,\\mathfrak{C}\\in V\\,,\\,(\\mathcal{C},\\sigma)\\in\\mathfrak{C}\\}</span>;</li>

      <li><span class="math">\\rho^{<em>}</span> is (at least) the maximum among <span class="math">\\sigma^{</em>}</span> and the rates in <span class="math">\\{\\mathrm{rate}(N;\\vec{\\rho}),\\sigma+\\mathrm{rate}(D):\\mathfrak{C}\\in V\\,,\\,(\\mathcal{C},\\sigma)\\in\\mathfrak{C}\\}</span>.</li>

    </ul>

    <p class="text-gray-300">This definition above may appear mysterious, but it is naturally motivated by the proof of Theorem 8.1.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 4.8.</h6>

    <p class="text-gray-300">The model of RS-encoded IOPs does not forbid the verifier from making queries to messages. However, in all of our protocols to achieve soundness it suffices for the rational constraints output by the verifier to be satisfied (and so the verifier does not make any queries). For this reason, we do not consider query complexity when discussing RS-encoded IOPs. Naturally, after we “compile” an RS-encoded IOP into a corresponding (regular) IOP, the resulting verifier will make queries to the proof; for details, see Section 8.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">4.7.1 Proximity</h4>

    <p class="text-gray-300">In an RS-encoded IOP <em>of Proximity</em> (RS-encoded IOPP), soundness must hold only if prover messages are Reed–Solomon codewords <em>and</em> the witness is a tuple of Reed–Solomon codewords. Formally, a <em>Reed–Solomon IOPP system</em> for a relation <span class="math">\\mathcal{R}\\subseteq\\{0,1\\}^{n}\\times\\mathrm{RS}\\left[L,\\vec{\\rho}_{\\mathsf{w}}\\right]</span> is a tuple <span class="math">(P,V,(\\vec{\\rho}_{i})_{i=1}^{\\mathsf{k}})</span>, where <span class="math">P</span> and <span class="math">V</span> are probabilistic algorithms, that satisfies the properties below. Note that the rational constraints output by the verifier may now also take the witness as input; the definition of maximum rate is modified accordingly.</p>

    <p class="text-gray-300">For every instance-witness pair <span class="math">(\\mathsf{x},\\mathsf{w})</span> in the relation <span class="math">\\mathcal{R}</span>, <span class="math">(P(\\mathsf{x},\\mathsf{w}),V^{\\mathsf{w}}(\\mathsf{x}))</span> is a <span class="math">\\mathsf{k}(n)</span>-round interactive oracle protocol with accepting probability <span class="math">1</span>, where the <span class="math">i</span>-th message of <span class="math">P</span> is a codeword of <span class="math">\\mathrm{RS}\\left[L,\\vec{\\rho}_{i}\\right]</span>, and <span class="math">V</span> outputs a set of rational constraints that are satisfied with respect to the witness and the prover’s messages with probability <span class="math">1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every instance-witness pair <span class="math">(\\mathsf{x},\\mathsf{w})</span> with $\\mathsf{w}\\in\\left(\\mathrm{RS}\\left[L,\\vec{\\rho}_{\\mathsf{w}}\\right]\\setminus\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{x}}\\right)<span class="math"> and unbounded malicious prover </span>\\tilde{P}<span class="math"> whose </span>i<span class="math">-th message is a codeword of </span>\\mathrm{RS}\\left[L,\\vec{\\rho}_{i}\\right]<span class="math">, </span>(\\tilde{P},V^{\\mathsf{w}}(\\mathsf{x}))<span class="math"> is a </span>\\mathsf{k}(n)<span class="math">-round interactive oracle protocol wherein the set of rational constraints output by </span>V<span class="math"> are satisfied with respect to the witness and the prover’s messages with probability at most </span>\\varepsilon(n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While the soundness condition does not consider “distance” of candidate witnesses to $\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{x}}$ (as in Section 4.5.1), we think of the notion above as an IOPP because soundness holds with respect to a particular witness provided as an oracle to the verifier. (This is analogous to “exact” PCPPs in <em>[x10]</em>.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">4.7.2 Zero knowledge</p>

    <p class="text-gray-300">The definition of zero knowledge for RS-encoded IOPs (resp., RS-encoded IOPPs) equals that for IOPs (resp., IOPPs). This is because the definitions of RS-encoded IOPs and (standard) IOPs differ only in the soundness condition. Note that while the honest verifiers that we consider never make queries, a malicious verifier may do so. Indeed, we <em>must</em> allow malicious verifiers to make queries in order to “lift” zero knowledge guarantees from an RS-encoded IOP to a corresponding (regular) IOP, and thereby achieve the notion of zero knowledge against a given query bound <span class="math">\\mathsf{b}</span> stated in Section 4.6. We further note that the structure of the compiler that performs this lifting (see Section 8) motivates a definition of query bound <span class="math">\\mathsf{b}</span> that can lead to more efficient constructions. Namely, since all of the prover messages and witnesses are over the same domain <span class="math">L</span>, we merely count the number of <em>distinct</em> queries to this common domain, i.e., if a malicious verifier queries multiple prover messages (or witnesses) at the same position <span class="math">\\alpha\\in L</span>, we consider it a single query.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.8 Univariate rowcheck</h3>

    <p class="text-gray-300">We describe <em>univariate rowcheck</em>, a noninteractive RS-encoded IOPP for simultaneously testing satisfaction of a given arithmetic constraint on a large number of inputs. The next definition captures this.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 4.9 (rowcheck relation).</h6>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{\\text{\\tiny ROW}}</span> is the set of all pairs <span class="math">\\big{(}\\,(\\mathbb{F},L,H,\\rho,\\mathsf{w},\\mathsf{c})\\,,(f_{1},\\ldots,f_{\\mathsf{w}})\\big{)}</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">L,H</span> are affine subspaces of <span class="math">\\mathbb{F}</span> with <span class="math">L\\cap H=\\emptyset</span>, <span class="math">\\rho\\in(0,1)</span>, <span class="math">\\mathsf{w}\\in\\mathbb{N}</span>, <span class="math">\\mathsf{c}\\colon\\mathbb{F}^{\\mathsf{w}}\\to\\mathbb{F}</span> is an arithmetic circuit, <span class="math">f_{1},\\ldots,f_{\\mathsf{w}}\\in\\operatorname{\\mathrm{RS}}\\left[L,\\rho\\right]</span>, and <span class="math">\\forall\\,a\\in H\\ \\mathsf{c}(\\hat{f}_{1}(a),\\ldots,\\hat{f}_{\\mathsf{w}}(a))=0</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Standard techniques for testing membership in the <em>vanishing subcode</em> of the Reed–Solomon code <em>[x1]</em> directly imply a non-interactive RS-encoded IOPP for the above rowcheck relation. Namely, the system of equations <span class="math">\\{\\mathsf{c}(\\hat{f}_{1}(a),\\ldots,\\hat{f}_{\\mathsf{w}}(a))=0\\}_{a\\in H}</span> is equivalent via the factor theorem to the statement “there exists $g\\in\\operatorname{\\mathrm{RS}}[L,\\deg(\\mathsf{c})\\rho-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> such that </span>\\hat{g}(X)\\cdot\\prod_{a\\in H}(X-a)\\equiv\\mathsf{c}(\\hat{f}_{1}(X),\\ldots,\\hat{f}_{\\mathsf{w}}(X))<span class="math">”. Therefore, the prover could send </span>g<span class="math"> to the verifier, who could probabilistically check the identity at a random point of </span>L<span class="math">, with a soundness error of </span>\\deg(\\mathsf{c})\\rho<span class="math">. In fact, within the formalism of RS-encoded IOPPs (and given that </span>L\\cap H=\\emptyset<span class="math">) there is no need for the prover to send anything: the verifier can simply check that </span>p\\in\\operatorname{\\mathrm{RS}}[L,\\deg(\\mathsf{c})\\rho-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> for the function </span>p\\colon L\\to\\mathbb{F}$ defined by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,a\\in L\\,,\\ p(a):=\\frac{\\mathsf{c}(\\hat{f}_{1}(a),\\ldots,\\hat{f}_{\\mathsf{w}}(a))}{\\mathbb{Z}_{H}(a)}\\ \\ .</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The maximum rate for the foregoing RS-encoded IOPP is $(\\sigma^{<em>},\\rho^{</em>})=(\\max\\{\\rho,\\deg(\\mathsf{c})\\rho-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\},\\deg(\\mathsf{c})\\cdot\\rho)<span class="math">. Note that the verifier can simulate oracle access to the function </span>p<span class="math"> when given oracle access to the witness oracles </span>f_{1},\\ldots,f_{\\mathsf{w}}<span class="math">. Each query to </span>p<span class="math"> requires evaluating the arithmetic circuit </span>\\mathsf{c}<span class="math"> and the vanishing polynomial </span>\\mathbb{Z}_{H}$. Throughout, we directly use the above ideas without encapsulating them in “rowcheck sub-protocols”.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">We describe univariate sumcheck, an RS-encoded IOPP for testing whether a low-degree univariate polynomial  <span class="math">\\hat{f}</span>  sums to zero on a given subspace  <span class="math">H\\subseteq \\mathbb{F}</span> . This protocol is a univariate analogue of the multi-variate sumcheck protocol [LFKN92].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  <span class="math">\\hat{f}</span>  has degree less than  <span class="math">d</span> , then  <span class="math">\\hat{f}</span>  can be uniquely decomposed into polynomials  <span class="math">\\hat{g}, \\hat{h}</span>  of degrees less than  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>d -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (respectively) such that  </span>\\hat{f} \\equiv \\hat{g} + \\mathbb{Z}_H \\cdot \\hat{h}<span class="math"> , where  </span>\\mathbb{Z}_H<span class="math">  is the vanishing polynomial of  </span>H<span class="math">  (see Section 4.4). This implies that  </span>\\sum_{a \\in H} \\hat{f}(a) = \\sum_{a \\in H} (\\hat{g}(a) + \\mathbb{Z}_H(a) \\cdot \\hat{h}(a)) = \\sum_{a \\in H} \\hat{g}(a)<span class="math"> . By Lemma 5.4 below, this latter expression is equal to  </span>\\beta \\sum_{a \\in H} a^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> , where  </span>\\beta<span class="math">  is the coefficient of  </span>X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math">  in  </span>\\hat{g}(X)<span class="math"> . Note that  </span>\\sum_{a \\in H} a^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1} \\neq 0<span class="math">  since otherwise this would imply that all functions sum to zero on  </span>H<span class="math"> . Thus,  </span>\\sum_{a \\in H} \\hat{f}(a) = 0<span class="math">  if and only if  </span>\\beta = 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This suggests the following RS-encoded IOPP (actually an RS-encoded PCPP). The prover sends  <span class="math">g</span> ,  <span class="math">h</span>  (the evaluations of  <span class="math">\\hat{g}, \\hat{h}</span> ). The verifier now must check that (a)  <span class="math">\\hat{f} \\equiv \\hat{g} + \\mathbb{Z}_H \\cdot \\hat{h}</span> , and (b) the coefficient of  $X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math">  in  </span>\\hat{g}<span class="math">  is zero. For both conditions we use the definition of an RS-encoded IOPP: the verifier outputs a rational constraint specifying that the polynomial  </span>\\hat{f} - \\mathbb{Z}_H \\cdot \\hat{h}<span class="math">  is of degree less than  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> , which corresponds to forcing the coefficient of  </span>X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math">  to be zero. In the final (non-encoded) IOPP protocol this will correspond to testing proximity of  </span>\\hat{f} - \\mathbb{Z}_H \\cdot \\hat{h}<span class="math">  to a Reed-Solomon code with rate parameter  </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Below we consider the more general case of testing that the sum equals a given  <span class="math">\\mu \\in \\mathbb{F}</span>  (rather than zero).</p>

    <p class="text-gray-300">Definition 5.1 (sumcheck relation). The relation  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span>  is the set of all pairs  <span class="math">\\left((\\mathbb{F},L,H,\\rho ,\\mu),f\\right)</span>  where  <span class="math">\\mathbb{F}</span>  is a finite field,  <span class="math">L,H</span>  are affine subspaces of  <span class="math">\\mathbb{F}</span> ,  <span class="math">\\rho \\in (0,1)</span> ,  <span class="math">\\mu \\in \\mathbb{F}</span> ,  <span class="math">f\\in \\mathrm{RS}[L,\\rho ]</span> , and  <span class="math">\\sum_{a\\in H}\\hat{f} (a) = \\mu</span> .</p>

    <p class="text-gray-300">Theorem 5.2. There exists an RS-encoded IOPP (Protocol 5.3) for the sumcheck relation  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span>  with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">) + 2 · FFT(F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">maximum rate</td>

            <td class="px-3 py-2 border-b border-gray-700">(σ<em>, ρ</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(ρ, ρ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol 5.3. Let  <span class="math">f \\in \\mathrm{RS}[L, \\rho]</span>  be the witness oracle, and let  <span class="math">\\hat{f}</span>  be the unique polynomial of degree at most  $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  that agrees with  </span>f<span class="math"> . The RS-encoded IOP protocol  </span>(P, V)<span class="math">  for  </span>\\mathcal{R}_{\\mathrm{SUM}}$  proceeds as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.  <span class="math">P</span>  computes the unique polynomials  <span class="math">\\hat{g}</span>  and  <span class="math">\\hat{h}</span>  and unique element  <span class="math">\\beta \\in \\mathbb{F}</span>  such that  $\\deg (\\hat{g}) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> ,  </span>\\deg (\\hat{h}) &lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and  </span>\\hat{f} (X)\\equiv \\hat{g} (X) + \\beta X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} + \\mathbb{Z}_H(X)\\hat{h} (X)$ .</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3.  <span class="math">V</span>  computes  $\\xi \\coloneqq \\sum_{a\\in H}a^{</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1}<span class="math">  (this can be done efficiently as explained below), and accepts if and only if  </span>p\\in \\mathrm{RS}[L,(</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1) /</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">]<span class="math">  where  </span>\\hat{p} (X)\\coloneqq \\xi \\cdot \\hat{f} (X) - \\mu \\cdot X^{</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1} - \\xi \\cdot \\mathbb{Z}_H(X)\\hat{h} (X)<span class="math"> . In the formalism of RS-encoded IOPs (see Section 4.7), this corresponds to the rational constraint  </span>(\\mathcal{C},\\sigma)\\coloneqq ((N,D),\\frac{</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">})<span class="math">  where  </span>N(X,Z_1,Z_2)\\coloneqq \\xi \\cdot Z_1 - \\mu \\cdot X^{</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1} - \\xi \\cdot \\mathbb{Z}_H(X)\\cdot Z_2<span class="math">  and  </span>D(X)\\coloneqq 1$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the maximum rate in the above protocol (as defined in Section 4.7) is  <span class="math">\\rho</span> .</p>

    <p class="text-gray-300">Proof. Completeness and soundness rely on the following lemma:</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 5.4 (<em>[x1, Theorem 1]</em>, restated).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H</span> be an affine subspace of <span class="math">\\mathbb{F}</span>, and let <span class="math">\\hat{g}(x)</span> be a univariate polynomial over <span class="math">\\mathbb{F}</span> of degree (strictly) less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{a\\in H}\\hat{g}(a)=0.</span></p>

    <p class="text-gray-300">We provide a self-contained proof of this statement in Appendix A.</p>

    <p class="text-gray-300">Completeness. Consider <span class="math">f\\in\\mathrm{RS}\\left[L,\\rho\\right]</span> with <span class="math">\\sum_{a\\in H}\\hat{f}(a)=\\mu</span>. Then, by definition of <span class="math">g,h</span> and Lemma 5.4,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mu=\\sum_{a\\in H}\\left(\\hat{g}(a)+\\beta\\cdot a^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}+\\mathbb{Z}_{H}(a)\\hat{h}(a)\\right)=\\beta\\xi\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\xi\\cdot\\hat{f}(X)-\\mu\\cdot X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}-\\xi\\cdot\\mathbb{Z}_{H}(X)\\hat{h}(X)$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\equiv\\xi\\cdot\\hat{g}(X)+\\xi\\beta X^{</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">-1}-\\mu\\cdot X^{</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">-1}\\equiv\\xi\\cdot\\hat{g}(X)\\enspace.$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hence <span class="math">\\hat{p}(X)\\equiv\\xi\\cdot\\hat{g}(X)</span>, and so $p\\in\\mathrm{RS}[L,\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Consider <span class="math">f\\in\\mathrm{RS}\\left[L,\\rho\\right]</span> with <span class="math">\\sum_{a\\in H}\\hat{f}(a)=\\mu^{\\prime}\\neq\\mu</span>. We show that for any $h\\in\\mathrm{RS}[L,\\rho-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">, it holds that </span>p\\notin\\mathrm{RS}[L,\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">. Suppose towards contradiction that </span>p\\in\\mathrm{RS}[L,\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">. Then, by Lemma 5.4, we have that </span>\\sum_{a\\in H}\\hat{p}(a)=0$. But also we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{a\\in H}\\hat{p}(a)=\\sum_{a\\in H}(\\xi\\cdot\\hat{f}(a)-\\mu\\cdot a^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1})=\\xi(\\mu^{\\prime}-\\mu)\\neq 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">since <span class="math">\\xi\\neq 0</span>. This is a contradiction.</p>

    <p class="text-gray-300">Efficiency. For computational efficiency of the verifier, we use an additional lemma due to <em>[x1]</em>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 5.5 (<em>[x1]</em>, implicit in the proof of Theorem 1).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">H</span> is an affine subspace of <span class="math">\\mathbb{F}</span>, then $\\sum_{a\\in H}a^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> equals the linear term of </span>\\mathbb{Z}_{H}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier runs in time $O(\\log^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">: its work consists of finding the linear term of </span>\\mathbb{Z}_{H}<span class="math">, which can be achieved via a divide-and-conquer algorithm, and evaluating </span>\\mathbb{Z}_{H}<span class="math"> at a single point. The prover runs in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+2\\cdot\\mathrm{FFT}(\\mathbb{F},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">: the polynomial division can be performed by interpolating (one IFFT) over </span>L<span class="math"> to obtain the coefficients of </span>f<span class="math">, running a divide-and-conquer algorithm to obtain the </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> coefficients of </span>\\mathbb{Z}_{H}<span class="math">, performing standard polynomial division to obtain </span>\\hat{h}<span class="math">, and computing its evaluation </span>h$ via an FFT. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-44" class="text-base font-medium mt-4">Remark 5.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The univariate sumcheck relation states that <span class="math">H,L</span> are affine subspaces of <span class="math">\\mathbb{F}</span> (Definition 5.1). One can define a similar relation where <span class="math">H,L</span> are multiplicative cosets in <span class="math">\\mathbb{F}</span>, in which case Theorem 5.2 holds essentially unchanged. The protocol is similar to Protocol 5.3, except that <span class="math">\\hat{g}</span> and <span class="math">\\hat{h}</span> are such that <span class="math">\\hat{f}(X)=X\\cdot\\hat{g}(X)+\\beta+\\mathbb{Z}_{H}(X)\\hat{h}(X)</span>. The rational constraint becomes $(\\mathcal{C},\\sigma):=((N,D),\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> where </span>N(X,Z_{1},Z_{2}):=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot Z_{1}-\\mu-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathbb{Z}_{H}(X)\\cdot Z_{2}<span class="math">, </span>D(X):=X<span class="math">. Correctness of this protocol follows from the fact that, if </span>H<span class="math"> is a multiplicative coset, </span>\\sum_{\\alpha\\in H}\\hat{p}(\\alpha)=\\hat{p}(0)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all polynomials </span>\\hat{p}<span class="math"> with </span>\\deg(\\hat{p})<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe how to modify Protocol 5.3 to achieve zero knowledge; the modification is an adaptation of algebraic techniques from [BCGV16; BCFGRS17]. The prover first sends a random Reed-Solomon codeword  <span class="math">q \\in \\mathrm{RS}[L, \\rho]</span> . The verifier then replies with a random "challenge" element  <span class="math">c \\in \\mathbb{F}</span> . Finally, the prover and verifier engage in Protocol 5.3 with respect to the "virtual" oracle  <span class="math">p := c \\cdot f + q</span> , and new target value  <span class="math">c \\cdot \\mu + \\sum_{a \\in H} \\hat{q}(a)</span> . Since  <span class="math">p</span>  is an (almost) uniformly random Reed-Solomon codeword, one can efficiently simulate the sumcheck prover with input  <span class="math">p</span> . We obtain the following theorem.</p>

    <p class="text-gray-300">Theorem 5.7. There exists an RS-encoded IOPP (Protocol 5.8) for the sumcheck relation  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span>  (Definition 5.1), which is zero knowledge against unbounded queries, with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">= 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">= 2</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">= log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">= 1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">) + 3·FFT(F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(log2</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">maximum rate</td>

            <td class="px-3 py-2 border-b border-gray-700">(σ<em>, ρ</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">= (ρ, ρ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol 5.8. Let  <span class="math">f \\in \\mathrm{RS}[L, \\rho]</span>  be the witness oracle. Let  <span class="math">(P_{\\mathrm{SUM}}, V_{\\mathrm{SUM}})</span>  be the RS-encoded IOP for  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span>  (Protocol 5.3). The zero knowledge RS-encoded IOP  <span class="math">(P, V)</span>  for  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span>  proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P</span>  samples  <span class="math">q \\in \\mathrm{RS}[L, \\rho]</span>  uniformly at random and sends it to  <span class="math">V</span> , along with  <span class="math">\\beta := \\sum_{a \\in H} q(a)</span> .</li>

      <li><span class="math">V</span>  samples  <span class="math">c\\in \\mathbb{F}</span>  uniformly at random, and sends it to  <span class="math">P</span></li>

      <li><span class="math">P</span>  and  <span class="math">V</span>  invoke  <span class="math">\\left(P_{\\mathrm{SUM}}(\\mathbf{x}&#x27;, c \\cdot f + q), V_{\\mathrm{SUM}}^{c \\cdot f + q}(\\mathbf{x}&#x27;)\\right)</span> , where  <span class="math">\\mathbf{x}&#x27; := (\\mathbb{F}, L, H, \\rho, c \\cdot \\mu + \\beta)</span> .</li>

    </ol>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. Follows from the completeness of univariate sumcheck.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that  <span class="math">\\sum_{a\\in H}\\hat{f} (a) = \\alpha \\neq \\mu</span> . Let  <span class="math">\\beta^{\\prime}\\coloneqq \\sum_{a\\in H}q^{\\prime}(a)</span> , where  <span class="math">q^{\\prime}</span>  is sent by  <span class="math">\\tilde{P}</span>  in the first round. Then  <span class="math">\\sum_{a\\in H}(c\\cdot \\hat{f} +q^{\\prime})(a) = c\\cdot \\alpha +\\beta^{\\prime}</span> , which is equal to  <span class="math">c\\cdot \\mu +\\beta</span>  if and only if  <span class="math">c = \\frac{\\beta - \\beta&#x27;}{\\alpha - \\mu}</span> , which happens with probability  $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  for any fixed  </span>\\beta ,\\beta '<span class="math"> . Hence with probability  </span>1 - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>(\\mathbf{x}',c\\cdot \\mu +\\beta)\\notin \\mathcal{R}_{\\mathrm{SUM}}$  and soundness follows by the soundness of the standard protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero knowledge. We describe a simulator  <span class="math">S</span>  that, given straightline access to a (malicious) verifier  <span class="math">\\tilde{V}</span>  and oracle access to a witness oracle  <span class="math">f \\in \\mathrm{RS}[L, \\rho]</span> , perfectly simulates  <span class="math">\\tilde{V}</span> 's view in the real protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">q_{\\mathrm{sim}} \\in \\mathrm{RS}[L, \\rho]</span>  uniformly at random and start simulating  <span class="math">\\tilde{V}</span> .</li>

      <li>Answer any query to  <span class="math">f</span>  by querying  <span class="math">f</span> , and answer any query to  <span class="math">q</span>  by querying  <span class="math">q_{\\mathrm{sim}}</span> . Let  <span class="math">Q_{\\mathrm{sim}} \\subseteq L</span>  be  <span class="math">\\tilde{V}</span> 's queries to  <span class="math">q</span>  from the beginning of the simulation until the next step.</li>

      <li>Send  <span class="math">\\beta_{\\mathrm{sim}}\\coloneqq \\sum_{a\\in H}\\hat{q}_{\\mathrm{sim}}(a)</span>  to  <span class="math">\\tilde{V}</span></li>

      <li>Receive  <span class="math">\\tilde{c}_{\\mathrm{sim}} \\in \\mathbb{F}</span>  from  <span class="math">\\tilde{V}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Sample  <span class="math">p_{\\mathrm{sim}} \\in \\mathrm{RS}[L, \\rho]</span>  uniformly at random such that, for every  <span class="math">\\omega \\in Q_{\\mathrm{sim}}</span> ,  <span class="math">p_{\\mathrm{sim}}(\\omega) = \\tilde{c}_{\\mathrm{sim}} \\cdot f(\\omega) + q_{\\mathrm{sim}}(\\omega)</span>  and  <span class="math">\\sum_{a \\in H} p_{\\mathrm{sim}}(a) = \\tilde{c}_{\\mathrm{sim}} \\cdot \\mu + \\beta_{\\mathrm{sim}}</span> ; this requires  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{\\mathrm{sim}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  queries to  </span>f<span class="math"> . (Note that if  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{\\mathrm{sim}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  then  </span>p_{\\mathrm{sim}} \\equiv \\hat{f} + r_{\\mathrm{sim}}$ .)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Answer any query to  <span class="math">f</span>  by querying  <span class="math">f</span>  (as before), and answer any query to  <span class="math">q</span>  by querying  <span class="math">p_{\\mathrm{sim}} - \\tilde{c}_{\\mathrm{sim}} \\cdot f</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the interaction of  <span class="math">P_{\\mathrm{SUM}}(\\mathbf{x}&#x27;, p_{\\mathrm{sim}})</span>  and  <span class="math">\\tilde{V}</span> .</li>

    </ol>

    <p class="text-gray-300">Note that  <span class="math">S</span>  runs in polynomial time, and the number of queries it makes to  <span class="math">f</span>  is exactly the number of queries that  <span class="math">\\tilde{V}</span>  makes to  <span class="math">f</span>  and  <span class="math">q</span> .</p>

    <p class="text-gray-300">To see that  <span class="math">\\tilde{V}</span> 's view is perfectly simulated, we consider a hybrid experiment in which the "hybrid prover" reads all of  <span class="math">f</span>  (like the honest prover in the real world) but can modify messages after they are sent (like the simulator in the ideal world).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">q \\in \\mathrm{RS}[L, \\rho]</span>  uniformly at random and start simulating  <span class="math">\\tilde{V}</span> .</li>

      <li>Send  <span class="math">q</span>  to  <span class="math">\\tilde{V}</span> , along with  <span class="math">\\beta := \\sum_{a \\in H} q(a)</span> . Let  <span class="math">Q \\subseteq L</span>  be  <span class="math">\\tilde{V}</span> 's queries to  <span class="math">q</span>  from the beginning of the simulation until the next step.</li>

      <li>Receive  <span class="math">\\tilde{c} \\in \\mathbb{F}</span>  from  <span class="math">\\tilde{V}</span> .</li>

      <li>Sample  <span class="math">p \\in \\mathrm{RS}[L, \\rho]</span>  uniformly at random such that, for every  <span class="math">\\omega \\in Q</span> ,  <span class="math">p(\\omega) = \\tilde{c} \\cdot f(\\omega) + q(\\omega)</span>  and  <span class="math">\\sum_{a \\in H} p(a) = \\tilde{c} \\cdot \\mu + \\beta</span> .</li>

      <li>Replace  <span class="math">q</span>  with  <span class="math">p - \\tilde{c} \\cdot f</span> .</li>

      <li>Simulate the interaction of  <span class="math">P_{\\mathrm{SUM}}(\\mathbf{x}&#x27;, p)</span>  and  <span class="math">\\tilde{V}</span> .</li>

    </ol>

    <p class="text-gray-300">The distribution of  <span class="math">\\tilde{V}</span> 's view in the real protocol is identical to the distribution of  <span class="math">\\tilde{V}</span> 's view in the above experiment. In particular, all of  <span class="math">\\tilde{V}</span> 's queries to  <span class="math">q</span>  after its replacement by  <span class="math">p - c \\cdot f</span>  have the correct distribution. Moreover, it is not hard to see that  <span class="math">\\tilde{V}</span> 's view in the above experiment and  <span class="math">S</span> 's output are identically distributed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. Most of the parameters are seen from the protocol description. We require the prover to send  <span class="math">q \\in \\mathrm{RS}[L, \\rho]</span>  uniformly at random, which can be done by choosing  $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  coefficients uniformly at random and performing one FFT to evaluate that polynomial over  </span>L$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given  <span class="math">\\ell</span>  instance-witness pairs for univariate sumcheck  <span class="math">\\left((\\mathbb{F},L,H,\\rho_i,\\mu_i),f_i\\right)_{i\\in [\\ell ]}</span> , we want to test that all of them are in  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}</span> . This is achieved with an  <span class="math">\\ell</span> -fold increase in complexity, but we want to do this much more efficiently. This will be crucial in our final protocol. We first state formally the relation we will test.</p>

    <p class="text-gray-300">Definition 5.9 ( <span class="math">\\ell</span> -sumcheck relation). The relation  <span class="math">\\mathcal{R}_{\\mathrm{SUM}}^{\\ell}</span>  is the set of all  <span class="math">\\ell</span> -tuples  <span class="math">\\left((\\mathbf{x}_1, \\ldots, \\mathbf{x}_\\ell), (f_1, \\ldots, f_\\ell)\\right)</span>  such that, for every  <span class="math">i \\in \\{1, \\ldots, \\ell\\}</span> ,  <span class="math">\\mathbf{x}_i = (\\mathbb{F}, L, H, \\rho_i, \\mu_i)</span> , and  <span class="math">(\\mathbf{x}_i, f_i) \\in \\mathcal{R}_{\\mathrm{SUM}}</span> .</p>

    <p class="text-gray-300">The idea is to have the verifier choose  <span class="math">z_{1},\\ldots ,z_{\\ell}\\in \\mathbb{F}</span>  uniformly at random and send them to the prover, and then to test that  <span class="math">\\sum_{a\\in H}\\sum_{i = 1}^{\\ell}z_{i}f_{i}(a) = \\sum_{i = 1}^{\\ell}z_{i}\\mu_{i}</span> . Completeness is easy to see, and soundness follows from properties of random linear combinations. The verifier runtime is increased only by an additive  <span class="math">\\ell</span>  term, which corresponds to sending  <span class="math">z_{1},\\ldots ,z_{\\ell}</span>  and querying each  <span class="math">f_{i}</span>  in one position. Crucially, the proof length is unchanged, and the prover still only performs three FFTs. We obtain the following lemma.</p>

    <p class="text-gray-300">Lemma 5.10. There is an RS-encoded IOPP for the univariate  <span class="math">\\ell</span> -sumcheck relation (Definition 5.9) with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">+ ℓ·</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">) + 2·FFT(F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">+ ℓ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">maximum rate</td>

            <td class="px-3 py-2 border-b border-gray-700">(σ<em>, ρ</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(ρ, ρ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for any instance  <span class="math">\\vec{\\mathbf{x}} = (\\mathbf{x}_1,\\dots ,\\mathbf{x}_{\\ell}) = \\big((\\mathbb{F},L,H,\\rho_i,\\mu_i)\\big)_{i = 1}^{\\ell}</span> , where  <span class="math">\\rho \\coloneqq \\max_{i}\\rho_{i}</span> .</p>

    <p class="text-gray-300">Protocol 5.11. Let  <span class="math">\\rho \\coloneqq \\max_i\\rho_i</span> , and let  <span class="math">f_{1},\\ldots ,f_{\\ell}\\in \\mathrm{RS}[L,\\rho ]</span>  be the witness oracles. Let  <span class="math">(P_{\\mathrm{SUM}},V_{\\mathrm{SUM}})</span>  be the standard RS-encoded IOP for univariate sumcheck (Protocol 5.3). The RS-encoded IOP protocol for univariate  <span class="math">\\ell</span> -sumcheck proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span>  chooses  <span class="math">z_{1},\\ldots ,z_{\\ell}\\in \\mathbb{F}</span>  uniformly at random, and sends them to  <span class="math">P</span></li>

      <li><span class="math">P</span>  and  <span class="math">V</span>  invoke  <span class="math">\\left(P_{\\mathrm{SUM}}(\\mathbf{x}^<em>,\\mathbf{w}^</em>),V_{\\mathrm{SUM}}^{\\mathbf{w}^<em>}(\\mathbf{x}^</em>)\\right)</span> , where  <span class="math">\\mathbf{x}^{<em>}\\coloneqq (\\mathbb{F},L,H,\\rho ,\\sum_{i = 1}^{\\ell}z_{i}\\mu_{i})</span> ,  <span class="math">\\mathbf{w}^{</em>}\\coloneqq \\sum_{i = 1}^{\\ell}z_{i}f_{i}</span> .</li>

    </ol>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. Suppose that, for all  <span class="math">i \\in [\\ell]</span> ,  <span class="math">(\\mathbf{x}_i, f_i) \\in \\mathcal{R}_{\\mathrm{SUM}}</span> . Then for any choice of  <span class="math">z_1, \\ldots, z_\\ell \\in \\mathbb{F}</span> ,  <span class="math">\\sum_{a \\in H} \\sum_{i=1}^{\\ell} z_i f_i(a) = \\sum_{i=1}^{\\ell} z_i \\mu_i</span> , so  <span class="math">(\\mathbf{x}^<em>, \\mathbf{w}^</em>) \\in \\mathcal{R}_{\\mathrm{SUM}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that, for some  <span class="math">i \\in [\\ell]</span> ,  <span class="math">(\\mathbf{x}_i, f_i) \\notin \\mathcal{R}_{\\mathrm{SUM}}</span> . Then since  <span class="math">z_1, \\ldots, z_\\ell \\in \\mathbb{F}</span>  are uniformly random,  <span class="math">\\sum_{a \\in H} \\sum_{i=1}^{\\ell} z_i f_i(a) = \\sum_{i=1}^{\\ell} z_i \\mu_i</span>  (i.e.,  <span class="math">(\\mathbf{x}^<em>, \\mathbf{w}^</em>) \\in \\mathcal{R}_{\\mathrm{SUM}}</span> ) with probability at most  $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The efficiency of the system corresponds to a single invocation of univariate sumcheck. The prover, in addition to the cost of running  <span class="math">P_{\\mathrm{SUM}}</span> , pays  $O(\\ell \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  to construct  </span>\\mathbf{w}^<em><span class="math"> . The verifier pays only an additive  </span>O(\\ell)<span class="math">  to pick  </span>z_1, \\ldots, z_\\ell<span class="math">  and construct  </span>\\mathbf{x}^</em>$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We describe univariate lincheck, an RS-encoded IOPP for verifying linear relations on Reed-Solomon codewords. Given  <span class="math">H_{1}, H_{2} \\subseteq \\mathbb{F}</span> ,  <span class="math">f_{1}, f_{2} \\in \\mathrm{RS}[L, \\rho]</span> , and a coefficient matrix  <span class="math">M \\in \\mathbb{F}^{H_{1} \\times H_{2}}</span> , we want to check that  $\\hat{f}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H_{1}} = M \\cdot \\hat{f}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H_{2}}<span class="math"> , where  </span>\\cdot<span class="math">  is standard matrix multiplication over  </span>\\mathbb{F}$ . The next definition captures this.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 6.1 (lincheck relation). The relation  <span class="math">\\mathcal{R}_{\\mathrm{LIN}}</span>  is the set of all pairs  <span class="math">\\left((\\mathbb{F},L,H_1,H_2,\\rho ,M),(f_1,f_2)\\right)</span>  where  <span class="math">\\mathbb{F}</span>  is a finite field,  <span class="math">L,H_{1},H_{2}</span>  are affine subspaces of  <span class="math">\\mathbb{F}</span> ,  <span class="math">\\rho \\in (0,1)</span> ,  <span class="math">f_{1},f_{2}\\in \\mathrm{RS}[L,\\rho ]</span> ,  <span class="math">M\\in \\mathbb{F}^{H_1\\times H_2}</span> , and  <span class="math">\\forall a\\in H_1\\hat{f}_1(a) = \\sum_{b\\in H_2}M_{a,b}\\cdot \\hat{f}_2(b)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To build intuition, consider that, given vectors  <span class="math">x \\in \\mathbb{F}^m</span> ,  <span class="math">y \\in \\mathbb{F}^n</span>  and a matrix  <span class="math">M \\in \\mathbb{F}^{m \\times n}</span> , a simple probabilistic test for the claim " <span class="math">x = My</span> " is to check that  <span class="math">\\langle r, x - My \\rangle = 0</span>  for a random  <span class="math">r \\in \\mathbb{F}^m</span> . Indeed, if  <span class="math">x \\neq My</span>  then  $\\operatorname{Pr}_r[\\langle r, x - My \\rangle = 0] = 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . However, this approach would require the verifier to sample  </span>m<span class="math">  random field elements, and send these to the prover. A straightforward modification (used also, e.g., in [BFLS91, §5.2]) requires only a single random field element and incurs only a modest increase in soundness error. Namely, letting  </span>h(X) := \\langle \\vec{X}, x - My \\rangle<span class="math">  where  </span>\\vec{X} := (1, X, \\dots, X^{m-1})<span class="math"> , if  </span>x \\neq My<span class="math">  then  </span>h(X)<span class="math">  is a non-zero polynomial of degree less than  </span>m<span class="math">  over  </span>\\mathbb{F}<span class="math"> , and thus  </span>\\operatorname{Pr}_{\\alpha \\in \\mathbb{F}}[h(\\alpha) = 0] \\leq m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The verifier now merely has to sample and send  </span>\\alpha \\in \\mathbb{F}<span class="math"> , and the prover must then prove the claim &quot; </span>h(\\alpha) = 0<span class="math"> &quot; to the verifier. This latter claim is in fact a claim about sums: one can rewrite  </span>h(X)<span class="math">  as  </span>\\langle \\vec{X}, x \\rangle - \\langle M^\\top \\vec{X}, y \\rangle<span class="math">  and, expanding the inner products, we obtain the two-sum expression  </span>h(\\alpha) = \\sum_{i=1}^{m} \\alpha^{i-1} x_i - \\sum_{j=1}^{n} (\\sum_{i=1}^{m} M_{i,j} \\alpha^{i-1}) y_j$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now return to the RS-encoded version of the problem (defined above), and explain how the prover can handle the claim " <span class="math">h(\\alpha) = 0</span> " via the univariate sumcheck protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can think of  <span class="math">\\hat{f}_1</span>  and  <span class="math">\\hat{f}_2</span>  as the low-degree extensions of some  <span class="math">x \\in \\mathbb{F}^{H_1}</span>  and  <span class="math">y \\in \\mathbb{F}^{H_2}</span>  with  $m :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>n :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The verifier samples and sends  </span>\\alpha \\in \\mathbb{F}<span class="math">  to the prover; the prover and verifier each compute the low-degree extension  </span>\\hat{p}_{\\alpha}^{(1)}<span class="math">  of  </span>\\vec{\\alpha} := (1, \\alpha, \\dots, \\alpha^{m-1})<span class="math"> , and the low-degree extension  </span>\\hat{p}_{\\alpha}^{(2)}<span class="math">  of  </span>M^{\\top} \\vec{\\alpha}<span class="math"> . We can then write  </span>h(\\alpha) = \\sum_{a \\in H_1} \\hat{p}_{\\alpha}^{(1)}(a) \\hat{f}_1(a) - \\sum_{b \\in H_2} \\hat{p}_{\\alpha}^{(2)}(b) \\hat{f}_2(b)<span class="math"> . In sum, we reduced the claim &quot; </span>h(\\alpha) = 0<span class="math"> &quot; to a sumcheck instance of the polynomial  </span>\\hat{p}_{\\alpha}^{(1)}(\\cdot) \\hat{f}_1(\\cdot)<span class="math">  over  </span>H_1<span class="math">  and one of the polynomial  </span>\\hat{p}_{\\alpha}^{(2)}(\\cdot) \\hat{f}_2(\\cdot)<span class="math">  over  </span>H_2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While  <span class="math">h(\\alpha)</span>  equals zero in the honest case, the value of each summation may reveal information. Therefore, to ensure zero knowledge, we combine these two summations into a single summation over the affine space  <span class="math">H_{1} \\diamond H_{2}</span> , defined to be the smallest affine space that contains both  <span class="math">H_{1}</span>  and  <span class="math">H_{2}</span>  (and note that if  <span class="math">H_{1}, H_{2}</span>  are linear subspaces then  <span class="math">H_{1} \\diamond H_{2} = H_{1} + H_{2}</span> ). Since the precise choice of  <span class="math">H_{1}, H_{2}</span>  is not important, for efficiency we will typically choose  <span class="math">H_{1} \\subseteq H_{2}</span>  or  <span class="math">H_{2} \\subseteq H_{1}</span>  in order to minimize  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1} \\diamond H_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 6.2. Protocol 6.3 below is an RS-encoded IOPP for  <span class="math">\\mathcal{R}_{\\mathrm{LIN}}</span>  (Definition 6.1) with parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">H1</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">log s) + 4 · FFT(F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">) + t(PSUM; F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">, s)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+ s) + t(VSUM; F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">, s)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">maximum rate</td>

            <td class="px-3 py-2 border-b border-gray-700">(σ<em>, ρ</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(ρ, ρ + s/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $s \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\diamond H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the number of nonzero entries of  </span>M$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol 6.3. Let <span class="math">f_1, f_2 \\in \\mathrm{RS}[L, \\rho]</span> be the witness oracles, and let <span class="math">\\hat{f}_1, \\hat{f}_1</span> be the unique polynomials of degree at most $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that agree with </span>f_1, f_2<span class="math">. For every </span>\\alpha \\in \\mathbb{F}<span class="math">, we define </span>q_\\alpha \\in \\mathrm{RS}[L, \\rho +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\diamond H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> to be the codeword obtained by evaluating on </span>L$ the following polynomial:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\hat{q}_\\alpha(X) := \\hat{f}_1(X) \\hat{p}_\\alpha^{(1)}(X) - \\hat{f}_2(X) \\hat{p}_\\alpha^{(2)}(X),</span></div>

    <p class="text-gray-300">where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\hat{p}_\\alpha^{(1)}</span> is the unique polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\diamond H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> s.t. </span>\\hat{p}_\\alpha^{(1)}(a) = \\alpha^{\\gamma(a)}<span class="math"> for all </span>a \\in H_1<span class="math">, and </span>\\hat{p}_\\alpha^{(1)}(b) = 0<span class="math"> for all </span>b \\in H_1 \\diamond H_2 \\setminus H_1$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Denote by <span class="math">(P_{\\mathrm{SUM}}, V_{\\mathrm{SUM}})</span> the RS-encoded IOPP for univariate sumcheck (Protocol 5.3). The RS-encoded IOPP <span class="math">(P, V)</span> for <span class="math">\\mathcal{R}_{\\mathrm{LIN}}</span> works as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">P</span> and <span class="math">V</span> agree in advance on an ordering $\\gamma: H_1 \\to \\{0, \\dots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\}<span class="math"> of </span>H_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span> draws a uniformly random <span class="math">\\alpha \\in \\mathbb{F}</span> and sends it to <span class="math">P</span>. This, along with the witness oracles <span class="math">f_1</span> and <span class="math">f_2</span>, defines the polynomial <span class="math">q_\\alpha</span>. Note that <span class="math">V</span> can use its oracles <span class="math">f_1, f_2</span> to simulate access to the oracle <span class="math">q_\\alpha</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <span class="math">P</span> and <span class="math">V</span> run <span class="math">(P_{\\mathrm{SUM}}(\\mathbf{x}&#x27;, q_\\alpha), V_{\\mathrm{SUM}}^{q_\\alpha}(\\mathbf{x}&#x27;)&#x27;)</span> where $\\mathbf{x}' := (\\mathbb{F}, L, H_1 \\diamond H_2, \\rho +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\diamond H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\mu = 0)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span> accepts if and only if <span class="math">V_{\\mathrm{SUM}}</span> accepts.</li>

    </ol>

    <p class="text-gray-300">Proof. Completeness and soundness rely on the fact that, by rearranging terms, for every <span class="math">\\alpha \\in \\mathbb{F}</span> it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} h(\\alpha) := \\sum_{b \\in H_1 \\diamond H_2} \\hat{q}_\\alpha(b) &amp;amp;= \\sum_{a \\in H_1} \\hat{f}_1(a) \\alpha^{\\gamma(a)} - \\sum_{b \\in H_2} \\sum_{a \\in H_1} M_{a,b} \\hat{f}_2(b) \\alpha^{\\gamma(a)} \\\\ &amp;amp;= \\sum_{a \\in H_1} \\left( \\hat{f}_1(a) - \\sum_{b \\in H_2} M_{a,b} \\cdot \\hat{f}_2(b) \\right) \\cdot \\alpha^{\\gamma(a)}. \\end{aligned}</span></div>

    <p class="text-gray-300">Completeness. Suppose that, for all <span class="math">a \\in H_1</span>, <span class="math">\\hat{f}_1(a) = \\sum_{b \\in H_2} M_{a,b} \\cdot \\hat{f}_2(b)</span>. For every <span class="math">\\alpha \\in \\mathbb{F}</span>, <span class="math">h(\\alpha) = 0</span> and thus <span class="math">\\sum_{b \\in H_2} \\hat{q}_\\alpha(b) = 0</span>. Completeness of the univariate sumcheck implies that <span class="math">V_{\\mathrm{SUM}}</span> always accepts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that there exists <span class="math">a \\in H_1</span> such that <span class="math">\\hat{f}_1(a) \\neq \\sum_{b \\in H_2} M_{a,b} \\cdot \\hat{f}_2(b)</span>. This implies that <span class="math">h</span> is a nonzero polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and so </span>\\operatorname{Pr}_{\\alpha \\in \\mathbb{F}}[h(\\alpha) = 0] &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If </span>h(\\alpha) \\neq 0<span class="math">, then </span>\\sum_{b \\in H_2} \\hat{q}_\\alpha(b) \\neq 0<span class="math"> and in this case </span>V_{\\mathrm{SUM}}$ rejects.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. Both parties run the univariate sumcheck as a subroutine. In addition, the prover needs to compute $q_\\alpha = \\hat{q}_\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_L<span class="math"> (the evaluation of </span>\\hat{q}_\\alpha<span class="math"> over </span>L<span class="math">), for example as follows: (i) evaluate </span>\\hat{p}_\\alpha^{(1)}<span class="math"> over </span>L<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\diamond H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 2 \\cdot \\mathrm{FFT}(\\mathbb{F},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; (ii) evaluate </span>\\hat{p}_\\alpha^{(2)}<span class="math"> over </span>L<span class="math"> in time </span>O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\diamond H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 2 \\cdot \\mathrm{FFT}(\\mathbb{F},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; (iii) compute </span>q_\\alpha<span class="math"> from these components in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The verifier needs to construct a circuit that simulates oracle access to </span>q_\\alpha<span class="math">, which can be done in time </span>O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\diamond H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and then run </span>V_{\\mathrm{SUM}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe an RS-encoded IOP for rank-one constraint satisfaction (R1CS). An R1CS instance consists of matrices  <span class="math">A, B, C \\in \\mathbb{F}^{m \\times (n + 1)}</span>  and explicit input  <span class="math">v \\in \\mathbb{F}^k</span> , and it is satisfiable if there exists  <span class="math">w \\in \\mathbb{F}^{n - k}</span>  such that  <span class="math">Az \\circ Bz = Cz</span>  where  <span class="math">z = (1, v, w) \\in \\mathbb{F}^{n + 1}</span>  and  <span class="math">\\circ</span>  denotes entry-wise (Hadamard) product.</p>

    <p class="text-gray-300">Definition 7.1 (R1CS relation). The relation  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  is the set of all pairs  <span class="math">((\\mathbb{F},k,n,m,A,B,C,v),w)</span>  where  <span class="math">\\mathbb{F}</span>  is a finite field,  <span class="math">k,n,m\\in \\mathbb{N}</span>  denote the number of inputs, variables and constraints respectively  <span class="math">(k\\leq n)</span> ,  <span class="math">A,B,C</span>  are  <span class="math">m\\times (1 + n)</span>  matrices over  <span class="math">\\mathbb{F}</span> ,  <span class="math">v\\in \\mathbb{F}^k</span> , and  <span class="math">w\\in \\mathbb{F}^{n - k}</span> , such that for all  <span class="math">i\\in [m]</span> <span class="math">\\left(\\sum_{j = 0}^{n}A_{i,j}z_{j}\\right)\\cdot \\left(\\sum_{j = 0}^{n}B_{i,j}z_{j}\\right) = \\left(\\sum_{j = 0}^{n}C_{i,j}z_{j}\\right)</span> , where  <span class="math">z\\coloneqq (1,v,w)\\in \\mathbb{F}^{n + 1}</span> .</p>

    <p class="text-gray-300">We describe how to obtain an RS-encoded IOP for R1CS by using RS-encoded IOPPs for lincheck (which we obtained in Section 6) and rowcheck (see Section 4.8).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">H_{1}, H_{2}</span>  be subspaces of  <span class="math">\\mathbb{F}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n + 1<span class="math"> , and view  </span>A, B, C<span class="math">  as matrices in  </span>\\mathbb{F}^{H_1 \\times H_2}<span class="math"> . The prover first sends four oracles:  </span>f_{z}<span class="math">  that (purportedly) is the low-degree extension of  </span>z \\colon H_{2} \\to \\mathbb{F}<span class="math"> ; and  </span>f_{Az}, f_{Bz}, f_{Cz}<span class="math">  that (purportedly) are the low-degree extensions of  </span>Az, Bz, Cz \\colon H_{1} \\to \\mathbb{F}<span class="math"> . The verifier uses the lincheck protocol to test that, indeed,  </span>f_{Az}<span class="math">  is a low-degree extension of  </span>Az<span class="math"> , and likewise for  </span>f_{Bz}, f_{Cz}<span class="math"> . Then the verifier uses the rowcheck protocol to check that  </span>f_{Az}(a) \\cdot f_{Bz}(a) = f_{Cz}(a)<span class="math">  for all  </span>a \\in H_{1}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above protocol almost works, with the one problem being that the prover could cheat by sending  <span class="math">f_{z}</span>  that is inconsistent with the explicit input  <span class="math">v</span> . We remedy this by (roughly) having the prover send the low-degree extension  <span class="math">f_{w}</span>  of  <span class="math">w</span>  instead of  <span class="math">f_{z}</span> . The verifier only needs to query one point of  <span class="math">f_{z}</span> , which it can do by making one query to  <span class="math">f_{w}</span>  and evaluating the low-degree extension of  <span class="math">v</span>  at one point.</p>

    <p class="text-gray-300">The above protocol uses three linchecks and one rowcheck. Each lincheck is a probabilistic reduction to sumcheck; this means running the sumcheck protocol three times (in parallel). The sumcheck protocol is relatively expensive, so we use the optimization of bundling these sumcheck instances (see Section 5.2). We also save computation by choosing the same challenge  <span class="math">\\alpha</span>  for each of the linchecks.</p>

    <p class="text-gray-300">Below we provide details about the foregoing intuition. After that we provide additional subsections that explain how to modify the "basic" protocol to achieve additional goals: in Section 7.1 we describe how to achieve zero knowledge; in Section 7.2 we describe how to amortize the cost of verifying the satisfaction of multiple R1CS instances (sharing the same matrices) at the same time.</p>

    <p class="text-gray-300">Theorem 7.2. Protocol 7.3 below is an RS-encoded IOP of knowledge for  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  (Definition 7.1) with parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">m+1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">·log(n+m)+</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">)+17·FFT(F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+n+m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">maximum rate</td>

            <td class="px-3 py-2 border-b border-gray-700">(σ<em>, ρ</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(max(m,n+1)/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">, 2max(m,n+1)/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for any instance  <span class="math">\\mathbf{x} = (\\mathbb{F},k,n,m,A,B,C,v)</span>  and any affine subspace  <span class="math">L</span>  of  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Protocol 7.3. The prover  <span class="math">P</span>  and verifier  <span class="math">V</span>  both receive as input an R1CS instance  <span class="math">(\\mathbb{F}, k, n, m, A, B, C, v)</span> , and the prover  <span class="math">P</span>  also receives as input a corresponding R1CS witness  <span class="math">w</span> ; as above,  <span class="math">z := (1, v, w) \\in \\mathbb{F}^{n+1}</span> .</p>

    <p class="text-gray-300">Below, <span class="math">(P_{\\text{LIN}}, V_{\\text{LIN}})</span> denotes the RS-encoded IOPP for univariate lincheck (Protocol 6.3).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H_{1}, H_{2}</span> be two affine subspaces of <span class="math">\\mathbb{F}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n + 1<span class="math"> such that </span>H_{1} \\subseteq H_{2}<span class="math"> or </span>H_{2} \\subseteq H_{1}<span class="math">; this implies that </span>H_{1} \\diamond H_{2} = H_{1} \\cup H_{2}<span class="math">. (We assume without loss of generality that </span>m, n + 1<span class="math">, and </span>k + 1<span class="math"> are powers of </span>\\operatorname{char}(\\mathbb{F})<span class="math">.) Let </span>\\gamma \\colon H_{1} \\cup H_{2} \\to \\{0, \\dots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1} \\cup H_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\}<span class="math"> be an ordering on </span>H_{1} \\cup H_{2}<span class="math"> such that </span>\\gamma(H_{i}) = \\{0, \\dots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\}<span class="math"> for </span>i \\in \\{1, 2\\}<span class="math">. We view </span>A, B, C<span class="math"> as matrices in </span>\\mathbb{F}^{H_1 \\times H_2}$ via this ordering.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute LDE of the input. Letting <span class="math">H_2^{\\leq k} \\coloneqq \\{b \\in H_2 : 0 \\leq \\gamma(b) \\leq k\\}</span>, <span class="math">P</span> and <span class="math">V</span> construct <span class="math">\\hat{f}_{(1,v)}(X)</span>, the unique polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_2^{\\leq k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= k + 1<span class="math"> such that, for all </span>b \\in H_2^{\\leq k}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\hat{f}_{(1,v)}(b) = \\begin{cases} 1 &amp;amp; \\text{if } \\gamma(b) = 0, \\\\ v_i &amp;amp; \\text{if } \\gamma(b) = i \\text{ and } i \\in \\{1, \\ldots, k\\}. \\end{cases}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Witness and auxiliary oracles. <span class="math">P</span> sends to <span class="math">V</span> the oracle codewords $f_w \\in \\mathrm{RS}[L, \\frac{n-k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> and </span>f_{Az}, f_{Bz}, f_{Cz} \\in \\mathrm{RS}[L, \\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]$ defined as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $f_w := \\hat{f}_w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_L<span class="math"> where </span>\\hat{f}_w<span class="math"> is the unique polynomial of degree less than </span>n - k$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\forall b \\in H_2 \\text{ with } k &amp;lt; \\gamma(b) \\leq n, \\quad \\hat{f}_w(b) = \\frac{w_{\\gamma(b) - k} - \\hat{f}_{(1,v)}(b)}{\\mathbb{Z}_{H_2^{\\leq k}}(b)}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $f_{Az} := \\hat{f}_{Az}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_L<span class="math"> where </span>\\hat{f}_{Az}<span class="math"> is the unique polynomial of degree less than </span>m<span class="math"> such that, for all </span>a \\in H_1<span class="math">, </span>\\hat{f}_{Az}(a) = \\sum_{b \\in H_2} A_{a,b} \\cdot z_{\\gamma(b)} = (Az)_a<span class="math">. The other codewords, </span>f_{Bz}<span class="math"> and </span>f_{Cz}$, are defined similarly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above implicitly define the "virtual oracle" $f_z := \\hat{f}_z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_L<span class="math"> where </span>\\hat{f}_z(X) := \\hat{f}_w(X) \\cdot \\mathbb{Z}_{H_2^{\\leq k}}(X) + \\hat{f}_{(1,v)}(X)<span class="math">. Note that </span>\\hat{f}_z(b) = z_{\\gamma(b)}<span class="math"> for all </span>b \\in H_2<span class="math">, and </span>f_z \\in \\mathrm{RS}[L, \\frac{n+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run subprotocols. <span class="math">P</span> and <span class="math">V</span> run the following in parallel:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) <span class="math">(P_{\\text{LIN}}(\\mathbf{x}_{\\text{LIN}}^A, (f_{Az}, f_z)), V_{\\text{LIN}}^{f_{Az}, f_z}(\\mathbf{x}_{\\text{LIN}}^A))</span> with $\\mathbf{x}_{\\text{LIN}}^A := (\\mathbb{F}, L, H_1, H_2,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\cup H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, A)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) <span class="math">(P_{\\text{LIN}}(\\mathbf{x}_{\\text{LIN}}^B, (f_{Bz}, f_z)), V_{\\text{LIN}}^{f_{Bz}, f_z}(\\mathbf{x}_{\\text{LIN}}^B))</span> with $\\mathbf{x}_{\\text{LIN}}^B := (\\mathbb{F}, L, H_1, H_2,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\cup H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, B)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) <span class="math">(P_{\\text{LIN}}(\\mathbf{x}_{\\text{LIN}}^C, (f_{Cz}, f_z)), V_{\\text{LIN}}^{f_{Cz}, f_z}(\\mathbf{x}_{\\text{LIN}}^C))</span> with $\\mathbf{x}_{\\text{LIN}}^C := (\\mathbb{F}, L, H_1, H_2,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1 \\cup H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, C)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(d) Check that $p \\in \\mathrm{RS}[L, (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> where </span>\\hat{p}(X) := (\\hat{f}_{Az}(X) \\cdot \\hat{f}_{Bz}(X) - \\hat{f}_{Cz}(X)) / \\mathbb{Z}_{H_1}(X)<span class="math">. In the formalism of RS-encoded IOPs (see Section 4.7), this corresponds to the rational constraint </span>(\\mathcal{C}, \\sigma) := ((N, D), (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> where </span>N(X, Z_1, Z_2, Z_3) := Z_1 \\cdot Z_2 - Z_3<span class="math"> and </span>D(X) := \\mathbb{Z}_{H_1}(X)$. This realizes the required rowcheck (see Section 4.8).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span> accepts if and only if all of the above subverifiers accept.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the maximum rate across the protocol is $\\rho^{*} = 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1}\\cup H_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. Suppose that <span class="math">w \\in \\mathbb{F}^{n - k}</span> is a valid witness for the instance <span class="math">(\\mathbb{F}, k, n, m, A, B, C, v)</span>, and define <span class="math">z := (1, v, w) \\in \\mathbb{F}^{n + 1}</span>. By construction, <span class="math">\\hat{f}_z</span> is a low-degree extension of <span class="math">z</span> over <span class="math">H_2</span> (i.e., <span class="math">\\hat{f}_z(b) = z_{\\gamma(b)}</span> for all <span class="math">b \\in H_2</span>). Therefore, for all <span class="math">a \\in H_1</span> it holds that <span class="math">\\hat{f}_A(a) = \\sum_{b \\in H_2} A_{a,b} z_{\\gamma(b)} = \\sum_{b \\in H_2} A_{a,b} \\hat{f}_z(b)</span>, and so Step 3a (lincheck on <span class="math">(f_{Az}, f_z)</span>) always accepts. By the same argument, Steps 3b and 3c always accept. Finally, the fact that <span class="math">w</span> is a valid witness implies that, for all <span class="math">a \\in H_1</span>, it holds that <span class="math">\\hat{f}_A(a) \\cdot \\hat{f}_B(a) - \\hat{f}_C(a) = (\\sum_{b \\in H_2} A_{a,b} z_{\\gamma(b)}) \\cdot (\\sum_{b \\in H_2} B_{a,b} z_{\\gamma(b)}) - (\\sum_{b \\in H_2} C_{a,b} z_{\\gamma(b)}) = 0</span>, which means that Step 3d always accepts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that the instance <span class="math">(\\mathbb{F}, k, n, m, A, B, C, v)</span> is not satisfiable, i.e., for all <span class="math">w \\in \\mathbb{F}^{n - k}</span>, letting <span class="math">z := (1, v, w)</span>, there exists <span class="math">i \\in [m]</span> such that <span class="math">(\\sum_{j=0}^{n} A_{i,j} z_j) \\cdot (\\sum_{j=0}^{n} B_{i,j} z_j) \\neq (\\sum_{j=0}^{n} C_{i,j} z_j)</span>. Let the oracles sent by a malicious prover be <span class="math">f_w&#x27;, f_A&#x27;, f_B&#x27;, f_C&#x27;</span>, and let $f_z' := \\hat{f}_z'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H<span class="math"> where </span>\\hat{f}_z'(X) := \\hat{f}_w'(X) \\cdot \\mathbb{Z}_{H_2^{\\leq k}}(X) + \\hat{f}_{(1,v)}(X)$. We distinguish between multiple cases.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">29</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists <span class="math">a\\in H_{1}</span> for which <span class="math">\\hat{f}^{\\prime}_{A}(a)\\neq\\sum_{b\\in H_{2}}A_{a,b}\\hat{f}^{\\prime}_{z}(b)</span>. Then, by soundness of the lincheck protocol, Step 3a accepts with probability $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If analogous statements hold for <span class="math">f^{\\prime}_{B}</span> or <span class="math">f^{\\prime}_{C}</span>, then analogous conclusions hold for Step 3b or Step 3c.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. For all <span class="math">a\\in H_{1}</span> it holds that <span class="math">\\hat{f}^{\\prime}_{A}(a)=\\sum_{b\\in H_{2}}A_{a,b}\\hat{f}^{\\prime}_{z}(b)</span>, and likewise for <span class="math">\\hat{f}^{\\prime}_{B},\\hat{f}^{\\prime}_{C}</span>. Then by assumption there exists <span class="math">a\\in H_{1}</span> such that <span class="math">f^{\\prime}_{A}(a)\\cdot f^{\\prime}_{B}(a)-f^{\\prime}_{C}(a)\\neq 0</span>. We conclude that <span class="math">\\hat{f}^{\\prime}_{Az}(X)\\cdot\\hat{f}^{\\prime}_{Bz}(X)-\\hat{f}^{\\prime}_{Cz}(X)</span> is not divisible by <span class="math">\\mathbb{Z}_{H_{1}}(X)</span>, which implies that the ratio of these two polynomials does not yield a codeword $p\\in\\mathrm{RS}[L,(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, so the verifier rejects (with probability </span>1$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The soundness error is given by maximizing over the above cases.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we discuss several optimizations that come from viewing the lincheck protocols as probabilistic interactive reductions to sumcheck: given an instance-witness pair <span class="math">\\big{(}\\,(\\mathbb{F},L,H_{1},H_{2},\\rho,M)\\,,(f_{1},f_{2})\\big{)}</span>, the lincheck protocol outputs an instance-witness pair $\\big{(}(\\mathbb{F},L,H_{1}\\cup H_{2},\\rho+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{1}\\cup H_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0),q_{\\alpha}\\big{)}$ for sumcheck.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Optimization: one sumcheck suffices. All lincheck summations are taken over the same space, so we can save costs by running a single execution of the <em>amortized</em> sumcheck protocol (see Lemma 5.10 in Section 5.2).</p>

    <p class="text-gray-300">Optimization: re-use <span class="math">\\boldsymbol{\\alpha}</span>. Each lincheck protocol instructs the verifier to send a random <span class="math">\\alpha\\in\\mathbb{F}</span> to the prover. The verifier thus chooses <span class="math">\\alpha_{1},\\alpha_{2},\\alpha_{3}\\in\\mathbb{F}</span> uniformly and independently, and sends <span class="math">(\\alpha_{1},\\alpha_{2},\\alpha_{3})</span> to the prover. But this means that the verifier must compute <span class="math">\\hat{p}_{\\alpha_{i}}</span> for each <span class="math">i</span>. We observe that choosing <span class="math">\\alpha_{1}=\\alpha_{2}=\\alpha_{3}\\in\\mathbb{F}</span> uniformly at random does not affect soundness, which means that the verifier only has to compute <span class="math">\\hat{p}_{\\alpha}</span> for one <span class="math">\\alpha</span>. This will become more important later in Section 7.2 when we consider amortizing multiple instances.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The prover computes <span class="math">Az</span>, <span class="math">Bz</span>, <span class="math">Cz</span> and their low-degree extensions, along with the low-degree extensions of <span class="math">w</span> and <span class="math">z</span>, in time $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+n+m)+5\\cdot\\mathrm{FFT}(\\mathbb{F},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The verifier evaluates </span>f_{z}<span class="math"> at a single point in </span>L<span class="math">, which costs </span>O(n+m)$. Summing over the costs of the subprotocols and amortizing the sumcheck cost across the four instances yields the stated expressions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of knowledge. Suppose that <span class="math">\\tilde{P}</span> causes the verifier’s rational constraints to be satisfied with probability at least <span class="math">\\mu</span>. Then by the soundness analysis with probability at least <span class="math">\\mu-\\frac{m+1}{\\mathbb{F}}</span> it holds that <span class="math">\\hat{f}_{A}(a)\\cdot\\hat{f}_{B}(a)-\\hat{f}_{C}(a)=(\\sum_{b\\in H_{2}}A_{a,b}\\hat{f}_{z}(b))\\cdot(\\sum_{b\\in H_{2}}B_{a,b}\\hat{f}_{z}(b))-(\\sum_{b\\in H_{2}}C_{a,b}\\hat{f}_{z}(b))=0</span>. Hence it holds that <span class="math">f_{w}</span> encodes a valid witness <span class="math">w</span> for <span class="math">\\mathbbm{x}</span>. The extractor queries <span class="math">f_{w}</span> at sufficiently many points to decode <span class="math">w</span>. ∎</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">7.1 Zero knowledge</h3>

    <p class="text-gray-300">We describe how to modify Protocol 7.3 to achieve zero knowledge against bounded-query malicious verifiers; the modification is an adaptation of algebraic techniques from <em>[x1, x2]</em>. Essentially, instead of providing the <em>unique</em> low-degree extensions of <span class="math">w,Az,Bz,Cz</span>, the prover provides <em>randomized</em> low-degree extensions that are over a domain <span class="math">L\\subseteq\\mathbb{F}</span> chosen such that <span class="math">(H_{1}\\cup H_{2})\\cap L=\\emptyset</span> (in particular, <span class="math">L</span> will be <em>affine</em> so that <span class="math">0_{\\mathbb{F}}\\notin L</span>). This ensures that a bounded number of queries to the witness and auxiliary oracles does not reveal any information about <span class="math">w</span>. Then, both prover and verifier use our zero knowledge sumcheck protocol (see Protocol 5.8 in Section 5.1) instead of the “plain” sumcheck protocol used above.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 7.4.</h6>

    <p class="text-gray-300">For any <span class="math">\\mathtt{b}\\colon\\mathbb{N}\\to\\mathbb{N}</span>, Protocol 7.5 below is an RS-encoded IOP of knowledge for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span></p>

    <p class="text-gray-300">(Definition 7.1) that is zero knowledge against query bound  <span class="math">\\mathsf{b}</span>  with parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">m+1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">·log(n+m)+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">)+18·FFT(F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+n+m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">maximum rate</td>

            <td class="px-3 py-2 border-b border-gray-700">(σ<em>, ρ</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(2max(m,n+1)+2b/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">, 2max(m,n+1)+2b/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for any instance  <span class="math">\\mathbf{x} = (\\mathbb{F},k,n,m,A,B,C,v)</span></p>

    <p class="text-gray-300">Protocol 7.5 (ZK variant of Protocol 7.3). We use the same notation as in Protocol 7.3, with the only additional constraint that  <span class="math">(H_{1} \\cup H_{2}) \\cap L = \\emptyset</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute LDE of the input. Same as Step 1 in Protocol 7.3.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Witness and auxiliary oracles.  <span class="math">P</span>  sends to  <span class="math">V</span>  the oracle codewords  $f_{w} \\in \\mathrm{RS}[L, \\frac{n - k + b}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">  and  </span>f_{Az}, f_{Bz}, f_{Cz} \\in \\mathrm{RS}[L, \\frac{m + b}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]$  defined as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $f_{w} \\coloneqq \\bar{f}_{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}<span class="math">  where  </span>\\bar{f}_{w}<span class="math">  is a random polynomial of degree less than  </span>n - k + \\mathsf{b}$  such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\forall b \\in H _ {2} \\text {w i t h} k &amp;lt;   \\gamma (b) \\leq n, \\quad \\bar {f} _ {w} (b) = \\frac {w _ {\\gamma (b) - k} - \\hat {f} _ {(1 , v)} (b)}{\\mathbb {Z} _ {H _ {2} ^ {\\leq k}} (b)}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $f_{Az} \\coloneqq \\bar{f}_{Az}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_L<span class="math">  where  </span>\\bar{f}_{Az}<span class="math">  is a random polynomial of degree less than  </span>m + b<span class="math">  such that, for all  </span>a \\in H_1<span class="math"> ,  </span>\\bar{f}_{Az}(a) = \\sum_{b \\in H_2} A_{a,b} \\cdot z_{\\gamma(b)} = (Az)_a<span class="math"> . The other codewords,  </span>f_{Bz}<span class="math">  and  </span>f_{Cz}$ , are defined similarly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As before, the above implicitly define the "virtual oracle"  $f_{z} \\coloneqq \\hat{f}_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}<span class="math">  where  </span>\\hat{f}_{z}(X) \\coloneqq \\bar{f}_{w}(X) \\cdot \\mathbb{Z}_{H_{2}^{\\leq k}}(X) + \\hat{f}_{(1,v)}(X)<span class="math"> . Again  </span>\\hat{f}_{z}(b) = z_{\\gamma(b)}<span class="math">  for all  </span>b \\in H_{2}<span class="math"> , but now  </span>f_{z} \\in \\mathrm{RS}[L, \\frac{n+1+b}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">  since  </span>\\bar{f}_{w}$  has higher degree.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run subprotocols. The same as Step 3 in Protocol 7.3, except that  <span class="math">P</span>  and  <span class="math">V</span>  run the (amortized) zero knowledge sumcheck protocol (see Protocol 5.8 in Section 5.1). Several rates need to be adjusted to take into account the fact that the codewords encoding the satisfying assignment (and its linear transformations) have degree higher by  <span class="math">\\mathsf{b}</span> . This results in the following maximum rate</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\sigma^ {<em>}, \\rho^ {</em>}\\right) = \\left(\\frac {2 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H _ {1} \\cup H _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\mathrm {b}}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\frac {2 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H _ {1} \\cup H _ {2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\mathrm {b}}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span>  accepts if and only if all of the above subverifiers accept.</li>

    </ol>

    <p class="text-gray-300">Proof. Completeness, soundness, and proof of knowledge follow almost directly from the proof of Theorem 7.2, so we do not discuss them. Before discussing zero knowledge, we note that the round complexity can be reduced to 2 by running the first round of the zero knowledge sumcheck protocol (Protocol 5.8) in parallel with the first round of Protocol 7.5. We now argue the zero knowledge guarantee (see Definition 4.4): we need to construct a probabilistic simulator  <span class="math">S</span>  that, given as input a satisfiable R1CS instance  <span class="math">(\\mathbb{F}, k, n, m, A, B, C, v)</span>  and straightline access to a b-query malicious verifier  <span class="math">\\tilde{V}</span> , outputs a view that is identically distributed as  <span class="math">\\tilde{V}</span> 's view when interacting with an honest prover.</p>

    <p class="text-gray-300">At a high level,  <span class="math">S</span>  simulates the oracles  <span class="math">f_{w}, f_{Az}, f_{Bz}, f_{Cz}</span>  by answering each query with uniformly random field elements. Given these, it runs the simulator for the amortized zero knowledge sumcheck, answering the subsimulator's queries to the virtual oracle by "querying" the appropriate locations of  <span class="math">f_{w}, f_{Az}, f_{Bz}, f_{Cz}</span> . More precisely, on input  <span class="math">\\mathbf{x}</span> , the simulator operates as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prepare a table <span class="math">T</span> for <span class="math">(f_{Az},f_{Bz},f_{Cz},f_{w})</span> which is initially empty. Whenever we “query” an oracle <span class="math">f_{x}</span> at a point <span class="math">a\\in L</span>, where <span class="math">x</span> is one of <span class="math">Az,Bz,Cz,w</span>, if <span class="math">(a,b_{Az},b_{Bz},b_{Cz},b_{w})\\in T</span> then output <span class="math">b_{x}</span>; otherwise, choose <span class="math">b_{Az},b_{Bz},b_{Cz},b_{w}\\in\\mathbb{F}</span> uniformly at random, add <span class="math">(a,b_{Az},b_{Bz},b_{Cz},b_{w})</span> to <span class="math">T</span> and output <span class="math">b_{x}</span>.</li>

      <li>“Send” the oracles <span class="math">f_{Az},f_{Bz},f_{Cz},f_{w}</span> to <span class="math">\\tilde{V}</span>. In parallel, “send” the first prover message <span class="math">r</span> in the univariate ZK sumcheck protocol (Protocol 5.8), and use the simulator for that protocol to answer queries to <span class="math">r</span>.</li>

      <li>Run the prover for each subprotocol in Step 3, except that we do not explicitly construct any witness (we think of them as arithmetic circuits with oracle gates), and we do not run the sumcheck protocol.</li>

      <li>Pass the instances constructed in the previous step to the simulator for the zero knowledge 3-sumcheck protocol. When the subsimulator queries one of the oracles, evaluate the corresponding circuit and use <span class="math">T</span> to look up the necessary values of <span class="math">f_{Az},f_{Bz},f_{Cz},f_{w}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The subsimulator makes the same number of queries to the “amortized” virtual oracle as the verifier makes to the sumcheck proof oracle; in particular, this is at most <span class="math">\\mathsf{b}</span>. By inspecting the virtual oracle, we see that the answer to a query <span class="math">a\\in\\mathbb{F}</span> depends only on <span class="math">f_{Az}(a),f_{Bz}(a),f_{Cz}(a),f_{w}(a)</span> (and <span class="math">f_{v}(a)</span>, which is known). Hence $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{b}<span class="math">. It remains to show that </span>T$ is consistent with the real view.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We look at <span class="math">f_{w}</span>; the other cases are essentially identical. We can write <span class="math">\\bar{f}_{w}</span> as</p>

    <p class="text-gray-300"><span class="math">\\bar{f}_{w}:=\\hat{f}_{w}(X)+\\mathbb{Z}_{H_{2}^{&gt;k}}(X)\\cdot R(X)\\enspace,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">R(X)</span> is a uniformly random polynomial of degree less than <span class="math">\\mathsf{b}</span> and <span class="math">H_{2}^{&gt;k}:=H_{2}\\setminus H_{2}^{\\leq k}</span>. Since <span class="math">\\mathbb{Z}_{H_{2}^{&gt;k}}</span> is nonzero outside of <span class="math">H_{2}^{&gt;k}</span>, any vector <span class="math">\\big{(}\\bar{f}_{w}(a)\\big{)}_{a\\in Q}</span> is distributed uniformly in <span class="math">\\mathbb{F}^{Q}</span> for any <span class="math">Q\\subseteq\\mathbb{F}</span> such that <span class="math">Q\\cap H_{2}=\\varnothing</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{b}$. In particular, this holds for the set of query positions asked by the subsimulator, even if they are chosen adaptively based on the answers to previous queries. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">7.2 Amortization</h3>

    <p class="text-gray-300">We describe efficiency savings that can be made when one considers multiple R1CS instances <em>with the same constraints</em> (but different inputs). More precisely, we seek an RS-encoded IOP for the following relation:</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 7.6 (<span class="math">\\ell</span>-wise R1CS relation).</h6>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}^{\\ell}</span> is the set of all pairs <span class="math">\\big{(}(\\mathbb{x}_{1},\\ldots,\\mathbb{x}_{\\ell}),(w_{1},\\ldots,w_{\\ell})\\big{)}</span> such that, for every <span class="math">i\\in\\{1,\\ldots,\\ell\\}</span>, <span class="math">\\mathbb{x}_{i}=(\\mathbb{F},k,n,m,A,B,C,v^{(i)})</span> and <span class="math">(\\mathbb{x}_{i},w_{i})\\in\\mathcal{R}_{\\mathrm{R1CS}}</span>.</p>

    <p class="text-gray-300">We have already obtained an RS-encoded IOP for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> (Protocol 7.3), so we can obtain an RS-encoded IOP for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}^{\\ell}</span> by running this IOP in parallel <span class="math">\\ell</span> times. Note, however, that the running time of both the prover and the verifier increases by a multiplicative factor of <span class="math">\\ell</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We modify this strategy to ensure that the verifier’s running time increases by only an <em>additive</em> factor in <span class="math">\\ell</span>, for a total of $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+n+m+\\ell)<span class="math">. This is significant because, as </span>\\ell<span class="math"> increases, the amortized per-instance cost becomes constant. The modification follows from an observation used in the proof of Theorem 7.2: we choose the same random </span>\\alpha\\in\\mathbb{F}<span class="math"> for all lincheck instances that result from the </span>\\ell$ parallel executions, and then amortize all of the resulting sumcheck instances (see Section 5.2). The verifier then only has to evaluate the auxiliary lincheck polynomials <em>once</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Corollary 7.7. For every  <span class="math">\\ell \\in \\mathbb{N}</span>  there exists an RS-encoded IOP for  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}^{\\ell}</span>  (Definition 7.6) with parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">= 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">= (4ℓ + 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(ℓ log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">= m+1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">= ℓ·O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">·log(n+m)+</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)+17·FFT(F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+n+m+ℓ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">maximum rate</td>

            <td class="px-3 py-2 border-b border-gray-700">(σ<em>, ρ</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">= (max(m,n+1)/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">, 2max(m,n+1)/</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">8 From RS-encoded provers to arbitrary provers</p>

    <p class="text-gray-300">In prior sections we have designed IOP protocols based on the simplifying assumption that a malicious prover is restricted to sending Reed–Solomon codewords of prescribed rates. In this section we describe how to transform any IOP protocol that is sound under this assumption into one that is sound against all provers.</p>

    <p class="text-gray-300">This by itself should not be surprising: the probabilistic checking literature is rich with such transformations, which are enabled by the tools of <em>low-degree testing</em> and <em>self-correction</em>. However, our goal here is to obtain a transformation that is particularly efficient for the setting of <em>this</em> paper, as we now explain.</p>

    <p class="text-gray-300">There is a straightforward approach to using low-degree testing, which we now spell out since it serves as a comparison point. Suppose that we have a low-degree test for <span class="math">\\mathrm{RS}\\left[L,\\rho\\right]</span> with soundness error <span class="math">\\varepsilon^{\\textsc{ldt}}</span> and proximity parameter <span class="math">\\delta^{\\textsc{ldt}}</span>, and we wish to transform a given RS-encoded IOP <span class="math">(P,V,(\\vec{\\rho_{i}})_{i=1}^{\\mathsf{k}})</span> into a corresponding IOP that is sound against all provers. Let us assume for simplicity that <span class="math">\\vec{\\rho}_{1}=\\cdots=\\vec{\\rho}_{\\mathsf{k}}=(\\rho)</span> for some <span class="math">\\rho\\in(0,1]</span>, that is, each prover message consists of one codeword in <span class="math">\\mathrm{RS}\\left[L,\\rho\\right]</span>.</p>

    <p class="text-gray-300">The naive approach is to individually run the low-degree test on each prover message. If all tests pass with probability greater than <span class="math">\\varepsilon^{\\textsc{ldt}}</span>, then every message <span class="math">\\tilde{\\pi}_{i}</span> is <span class="math">\\delta^{\\textsc{ldt}}</span>-close to some codeword <span class="math">\\pi_{i}\\in\\mathrm{RS}\\left[L,\\rho\\right]</span>. If the verifier makes <span class="math">\\mathsf{q}</span> uniform queries, the probability that any one of these queries does not “see” <span class="math">(\\pi_{i})_{i=1}^{\\mathsf{k}}</span> is at most <span class="math">\\mathsf{q}\\cdot\\delta^{\\textsc{ldt}}</span>. Conditioned on the verifier “seeing” <span class="math">(\\pi_{i})_{i=1}^{\\mathsf{k}}</span>, the verifier’s acceptance probability is exactly the same as in the RS-encoded protocol.</p>

    <p class="text-gray-300">While the foregoing approach “works”, it has two inefficiencies. First, it runs one low-degree test for each purported codeword, which is undesirable because low-degree tests are expensive. Second, the soundness error of the RS-encoded IOP typically decreases by increasing <span class="math">\\mathsf{q}</span>, which creates a trade-off with the soundness error <span class="math">\\mathsf{q}\\cdot\\delta^{\\textsc{ldt}}</span> of the transformation.</p>

    <p class="text-gray-300">We address the first problem by testing a random linear combination of the <span class="math">\\pi_{i}</span>, following an idea introduced in <em>[x21]</em> (in the context of interactive proofs of proximity) and applied in <em>[x1]</em> (in the context of interactive PCPs of proximity). The verifier samples <span class="math">a_{1},\\ldots,a_{\\mathsf{k}}\\in\\mathbb{F}</span> uniformly and independently at random, and sends these to the prover; the prover and verifier then engage in a low-degree test for the “virtual oracle” <span class="math">\\tilde{\\pi}:=\\sum_{i=1}^{\\mathsf{k}}a_{i}\\tilde{\\pi}_{i}</span>. If <span class="math">\\tilde{\\pi}_{i}\\in\\mathrm{RS}\\left[L,\\rho\\right]</span> for all <span class="math">i</span>, then <span class="math">\\tilde{\\pi}\\in\\mathrm{RS}\\left[L,\\rho\\right]</span>. If instead <span class="math">\\tilde{\\pi}_{i}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathrm{RS}\\left[L,\\rho\\right]</span> for some <span class="math">i</span> (and <span class="math">\\delta</span> small enough), then one can show that <span class="math">\\tilde{\\pi}</span> is also <span class="math">\\delta</span>-far with high probability. Thus, a single low-degree test is run, regardless of the number of oracles <span class="math">\\mathsf{k}</span>.</p>

    <p class="text-gray-300">We address the second problem by using an observation due to <em>[x1]</em> about testing <em>rational constraints</em> (see Section 4.7). In the encoded protocols in this work (and in <em>[x1]</em>), soundness entails testing both that the prover’s messages are low-degree and that they satisfy some existentially-quantified polynomial equations; for example, “message <span class="math">f</span> is low-degree and there is a low-degree <span class="math">g</span> such that <span class="math">f\\equiv g\\cdot\\mathbb{Z}_{H}</span>”. The standard way to test this property is for the prover to send <span class="math">g</span>; the verifier can then check the relation by querying at a uniformly random point in the domain, but this creates the aforementioned trade-off. However, <em>[x1]</em> observe that the verifier can <em>simulate</em> queries to <span class="math">g</span> itself, given query access to <span class="math">f</span>, since <span class="math">g(\\alpha)=f(\\alpha)/\\mathbb{Z}_{H}(\\alpha)</span> (when <span class="math">\\mathbb{Z}_{H}(\\alpha)\\neq 0</span>). Thus the prover does not have to send <span class="math">g</span>, but only has to show that <span class="math">g</span> is low-degree. In all of our protocols, this observation results in RS-encoded IOPs with <span class="math">\\mathsf{q}=0</span>, and we will assume that this is the case in the transformation described in this section.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this exposition we have made the simplifying assumption that the desired rate for each codeword in each proof is the same. In our protocols (in particular, the sumcheck protocol) this will not be the case, and so we must also handle differing rates. In some settings it suffices to test for proximity to <span class="math">\\mathrm{RS}\\left[L,\\max_{i}\\rho_{i}\\right]^{\\mathsf{k}}</span>, but not in our setting. This is because the soundness of univariate sumcheck relies on <span class="math">g</span> being close to $\\mathrm{RS}\\left[L,(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right]<span class="math">; soundness breaks if </span>g<span class="math"> is merely close to (say) </span>\\mathrm{RS}\\left[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right]<span class="math"> (or RS codes with bigger rates). Following <em>[x5]</em>, we instead multiply each </span>\\tilde{\\pi}_{i}$ by an appropriately-chosen monomial and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then take a random linear combination. We show that if  <span class="math">\\tilde{\\Pi}</span>  is  <span class="math">\\delta</span> -far from RS  <span class="math">[L, (\\rho_1, \\ldots, \\rho_k)]</span>  then with high probability  <span class="math">\\tilde{\\pi}</span>  is far from RS  <span class="math">[L, \\max_i \\rho_i]</span> , which suffices for soundness. We obtain the following theorem.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an RS-encoded IOP  <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}}, (\\vec{\\rho}_i)_{i=1}^{k^{\\mathcal{R}}})</span> , with maximum rate  <span class="math">(\\sigma^<em>, \\rho^</em>)</span> , for a relation  <span class="math">\\mathcal{R}</span> ;</li>

      <li>an IOPP  <span class="math">(P_{\\mathrm{LDT}}, V_{\\mathrm{LDT}})</span>  for the RS code RS  <span class="math">[L, \\sigma^{*}]</span> .</li>

    </ul>

    <p class="text-gray-300">Then we can combine these two ingredients to obtain an IOP  <span class="math">(P,V)</span>  for  <span class="math">\\mathcal{R}</span>  with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= ΣR</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">= kR + kLDT</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">= pR + pLDT</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">qπ</td>

            <td class="px-3 py-2 border-b border-gray-700">= qLDT + qLDT + ∑i=1k lR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">(ri, rq)</td>

            <td class="px-3 py-2 border-b border-gray-700">= (riR + rLDT + (∑i=1k lR + c) log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, rLDT)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">(εi, εq)</td>

            <td class="px-3 py-2 border-b border-gray-700">= (εR +</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ εLDT, εLDT)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(tR + tPLDT)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tV</td>

            <td class="px-3 py-2 border-b border-gray-700">= O(tR + tVLDT)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">provided  <span class="math">\\delta^{\\mathrm{LDT}} &amp;lt; \\min \\left(\\frac{1 - 2\\sigma^{<em>}}{2},\\frac{1 - \\sigma^{</em>}}{3},1 - \\rho^{*}\\right)</span> , and where  <span class="math">c</span>  is the maximum size of a constraint set output by  <span class="math">V_{\\mathcal{R}}</span> . (Parameters with superscript "R" and "LDT" are parameters for  <span class="math">(P_{\\mathcal{R}},V_{\\mathcal{R}})</span>  and  <span class="math">(P_{\\mathrm{LDT}},V_{\\mathrm{LDT}})</span>  respectively.) Moreover, if  <span class="math">(P_{\\mathcal{R}},V_{\\mathcal{R}})</span>  is an RS-encoded IOP of knowledge, then  <span class="math">(P,V)</span>  is an IOP of knowledge.</p>

    <p class="text-gray-300">Recall that  <span class="math">\\ell_i^{\\mathcal{R}}</span>  is the height of the  <span class="math">i</span> -th prover message, i.e., the  <span class="math">i</span> -th prover message has alphabet  <span class="math">\\mathbb{F}^{\\ell_i^{\\mathcal{R}}}</span> .</p>

    <p class="text-gray-300">Protocol 8.2. Letting  <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}})</span>  and  <span class="math">(P_{\\mathrm{LDT}}, V_{\\mathrm{LDT}})</span>  be as in the theorem statement, we need to construct an IOP  <span class="math">(P, V)</span>  for  <span class="math">\\mathcal{R}</span> . The prover  <span class="math">P</span>  and verifier  <span class="math">V</span>  both receive as input an instance  <span class="math">\\mathbf{x}</span> , and the prover  <span class="math">P</span>  also receives as input a corresponding witness  <span class="math">\\mathbf{w}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. RS-encoded IOP for  <span class="math">\\mathcal{R}</span> .  <span class="math">P</span>  and  <span class="math">V</span>  simulate  <span class="math">(P_{\\mathcal{R}}(\\mathbf{x},\\mathbf{w}), V_{\\mathcal{R}}(\\mathbf{x}))</span> . During this protocol, the prover sends oracle codewords  <span class="math">\\pi_1 \\in \\mathrm{RS}[L, \\vec{\\rho}_1], \\ldots, \\pi_{\\mathbf{k}^{\\mathcal{R}}} \\in \\mathrm{RS}[L, \\vec{\\rho}_{\\mathbf{k}^{\\mathcal{R}}}]</span> , and the verifier outputs a set of rational constraints  <span class="math">\\mathfrak{C}</span> . Let  $\\ell := \\sum_{i=1}^{\\mathbf{k}^{\\mathcal{R}}} \\ell_i +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>\\vec{\\rho} = (\\vec{\\rho}_1, \\ldots, \\vec{\\rho}_{\\mathbf{k}^{\\mathcal{R}}})<span class="math"> ,  </span>\\vec{\\rho}_{\\mathfrak{C}} := (\\sigma)_{(\\mathcal{C}, \\sigma) \\in \\mathfrak{C}}<span class="math"> , and  </span>\\vec{\\sigma} := (\\vec{\\rho}, \\vec{\\rho}_{\\mathfrak{C}}) \\in (0, 1]^{\\ell}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random linear combination.  <span class="math">V</span>  samples  <span class="math">\\vec{z} \\in \\mathbb{F}^{2\\ell}</span>  uniformly at random and sends it to  <span class="math">P</span> .</li>

      <li>Low-degree test.  <span class="math">P</span>  and  <span class="math">V</span>  simulate  <span class="math">(P_{\\mathrm{LDT}}(\\vec{z}^{\\top}\\Pi), V_{\\mathrm{LDT}}^{\\vec{z}^{\\top}\\Pi})</span>  where  <span class="math">\\Pi := \\frac{[\\Pi_0]}{\\Pi_1} \\in \\mathbb{F}^{2\\ell \\times L}</span>  is as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi_0^{\\prime} \\in \\mathbb{F}^{\\ell \\times L}</span>  is the matrix obtained by "stacking" vertically the matrices  <span class="math">\\pi_1, \\ldots, \\pi_{\\mathbf{k}^{\\mathcal{R}}}</span> , and  <span class="math">\\Pi_0</span>  is obtained by stacking  <span class="math">\\Pi_0^{\\prime}</span>  with  <span class="math">(\\mathcal{C}[\\Pi_0^{\\prime}])_{(\\mathcal{C},\\sigma) \\in \\mathfrak{C}}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\Pi_1 \\in \\mathbb{F}^{\\ell \\times L}</span>  is the matrix whose entries are  $(\\Pi_1)_{i,a} := a^{(\\sigma^* - \\sigma_i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot (\\Pi_0)_{i,a}<span class="math">  for all  </span>i \\in \\{1, \\dots, \\ell\\}<span class="math"> ,  </span>a \\in L$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span>  accepts if and only if  <span class="math">V_{\\mathrm{LDT}}</span>  accepts.</li>

    </ol>

    <p class="text-gray-300">Completeness. If  <span class="math">\\pi_i \\in \\mathrm{RS}[L, \\vec{\\rho}_i]</span>  for all  <span class="math">i</span> , then  <span class="math">\\vec{z}^\\top \\Pi \\in \\mathrm{RS}[L, \\sigma^*]</span>  and thus  <span class="math">P_{\\mathrm{LDT}}</span>  makes  <span class="math">V_{\\mathrm{LDT}}</span>  accept. Completeness then follows immediately from the completeness of the RS-encoded IOP  <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that  <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span>  and fix a malicious prover; let  <span class="math">\\delta \\coloneqq \\delta^{\\mathrm{LDT}}</span> . During the protocol, the prover sends oracles  <span class="math">\\tilde{\\pi}_1, \\ldots, \\tilde{\\pi}_{\\mathbf{k}^{\\mathcal{R}}}</span> ; let  <span class="math">\\tilde{\\Pi} \\coloneqq \\frac{[\\tilde{\\Pi}_0]}{\\tilde{\\Pi}_1}</span>  be as in the protocol description but with respect to the messages  <span class="math">\\tilde{\\pi}_i</span> . We argue that the verifier accepts with probability at most  $\\varepsilon^{\\mathcal{R}} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\varepsilon_{\\mathrm{i}}^{\\mathrm{LDT}}<span class="math"> . To do this, we first show that it must hold that  </span>\\Delta(\\tilde{\\Pi}_0, \\mathrm{RS}[L, \\vec{\\sigma}]) &gt; \\delta<span class="math"> ; then we show that given this, the verifier&#x27;s acceptance probability is bounded as required. Recall that here  </span>\\Delta$  denotes the column-wise distance (see Section 4.1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">E</span> be the event that the verifier accepts in the query phase with probability greater than <span class="math">\\varepsilon_{\\mathbf{q}}^{\\mathrm{LDT}}</span>, given the transcript of the interactive phase. Observe that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Pr [ E ] = \\Pr [ E \\mid \\Delta (\\tilde {\\Pi} _ {0}, \\operatorname {R S} [ L, \\vec {\\sigma} ]) &gt; \\delta ] \\cdot \\Pr [ \\Delta (\\tilde {\\Pi} _ {0}, \\operatorname {R S} [ L, \\vec {\\sigma} ]) &gt; \\delta ] \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\Pr [ E \\mid \\Delta (\\tilde {\\Pi} _ {0}, \\operatorname {R S} [ L, \\vec {\\sigma} ]) \\leq \\delta ] \\cdot \\Pr [ \\Delta (\\tilde {\\Pi} _ {0}, \\operatorname {R S} [ L, \\vec {\\sigma} ]) \\leq \\delta ] \\\\</li>

    </ul>

    <p class="text-gray-300">\\leq \\Pr [ E \\mid \\Delta (\\tilde {\\Pi} _ {0}, \\operatorname {R S} [ L, \\vec {\\sigma} ]) &gt; \\delta ] + \\Pr [ \\Delta (\\tilde {\\Pi} _ {0}, \\operatorname {R S} [ L, \\vec {\\sigma} ]) \\leq \\delta ] . \\end{array} $$</p>

    <p class="text-gray-300">We will bound each of these terms individually. First, recall from Section 4.7 the properties of <span class="math">\\rho^{<em>}</span> and <span class="math">\\sigma^{</em>}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sigma^{*}</span> is (at least) the maximum among the rates in <span class="math">\\vec{\\rho} := (\\vec{\\rho}_i)_{i=1}^k</span> and the rates in <span class="math">\\{\\sigma : \\mathfrak{C} \\in V, (\\mathcal{C}, \\sigma) \\in \\mathfrak{C}\\}</span>;</li>

      <li><span class="math">\\rho^{<em>}</span> is (at least) the maximum among <span class="math">\\sigma^{</em>}</span> and the rates in <span class="math">\\{\\mathrm{rate}(N; \\vec{\\rho}), \\sigma + \\mathrm{rate}(D): \\mathfrak{C} \\in V, (\\mathcal{C}, \\sigma) \\in \\mathfrak{C}\\}</span>. In particular, <span class="math">\\rho^{<em>} \\geq \\sigma^{</em>}</span>.</li>

      <li>The probability of <span class="math">E</span> when <span class="math">\\Delta (\\tilde{\\Pi}_0,\\mathrm{RS}[L,\\vec{\\sigma}]) &amp;gt; \\delta</span>. First we argue that if <span class="math">\\Delta (\\tilde{\\Pi}_0,\\mathrm{RS}[L,\\vec{\\sigma}]) &amp;gt; \\delta</span> then <span class="math">\\Delta (\\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^{<em>}]^{2\\ell}) &amp;gt; \\delta</span>; then we cite a claim stating that, given this, a random linear combination of <span class="math">\\tilde{\\Pi}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathrm{RS}[L,\\sigma^{</em>}]</span> with high probability; finally we derive the bound of the aforementioned probability.</li>

    </ul>

    <p class="text-gray-300"><strong>Claim 8.3.</strong> For any <span class="math">\\delta &amp;lt; (1 - 2\\sigma^{<em>}) / 2</span>, if <span class="math">\\Delta (\\tilde{\\Pi}_0,\\mathrm{RS}[L,\\vec{\\sigma}]) &amp;gt; \\delta</span> then <span class="math">\\Delta (\\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^{</em>}]^{2\\ell}) &amp;gt; \\delta</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose by way of contradiction that <span class="math">\\Delta (\\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^{<em>}]^{2\\ell})\\leq \\delta</span>, and let <span class="math">\\hat{\\Pi} =: \\left[\\frac{\\hat{\\Pi}_0}{\\hat{\\Pi}_1}\\right]\\in \\mathrm{RS}[L,\\sigma^</em>)^\\ell</span> be such that <span class="math">\\Delta (\\tilde{\\Pi},\\hat{\\Pi})\\leq \\delta</span>. For each <span class="math">i</span>, let <span class="math">p_i,p_i&#x27;\\in \\mathrm{RS}[L,\\sigma^*]</span> be the <span class="math">i</span>-th rows of <span class="math">\\hat{\\Pi}_0,\\hat{\\Pi}_1</span> respectively. We argue that <span class="math">p_i\\in \\mathrm{RS}[L,\\sigma_i]</span> for every <span class="math">i</span>, which implies <span class="math">\\hat{\\Pi}_0\\in \\mathrm{RS}[L,\\vec{\\sigma}]</span>, so <span class="math">\\Delta (\\hat{\\Pi}_0,\\mathrm{RS}[L,\\vec{\\sigma}])\\leq \\Delta (\\hat{\\Pi}_0,\\hat{\\Pi}_0)\\leq \\Delta (\\hat{\\Pi},\\hat{\\Pi})\\leq \\delta</span>, which is a contradiction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose towards contradiction that there exists <span class="math">i</span> such that <span class="math">p_i \\in \\mathrm{RS}[L, \\sigma^<em>] \\setminus \\mathrm{RS}[L, \\sigma_i]</span>. Then $q := p_i \\cdot X^{(\\sigma^</em> - \\sigma_i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\in \\mathrm{RS}[L, 2\\sigma^<em> - \\sigma_i] \\setminus \\mathrm{RS}[L, \\sigma^</em>]<span class="math">; in particular, </span>q \\neq p_i'<span class="math">, which implies that </span>\\Delta(q, p_i') \\geq 1 - (2\\sigma^<em> - \\sigma_i)<span class="math">. However, because </span>\\Delta(\\tilde{\\Pi}, \\mathrm{RS}[L, \\sigma^]) \\leq \\delta<span class="math">, we have that, letting </span>\\tilde{p}_i<span class="math"> be the </span>i<span class="math">-th row of </span>\\hat{\\Pi}_0<span class="math">, </span>\\Delta(\\tilde{p}_i \\cdot X^{(\\sigma^</em> - \\sigma_i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, q) = \\Delta(\\tilde{p}_i, p_i) \\leq \\delta<span class="math"> and </span>\\Delta(\\tilde{p}_i \\cdot X^{(\\sigma^* - \\sigma_i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, p_i') \\leq \\delta<span class="math">. By the triangle inequality we have that </span>\\Delta(q, p_i') \\leq 2\\delta &lt; 1 - (2\\sigma^* - \\sigma_i)$, which is a contradiction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim 8.4.</strong> For all $\\delta = d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; (1 - \\sigma^{<em>}) / 3<span class="math">, if </span>\\Delta (\\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^{</em>}]^{2\\ell}) &gt; \\delta$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {\\vec {z} \\leftarrow \\vec {F} ^ {2 \\ell}} \\left[ \\Delta (\\vec {z} ^ {\\top} \\tilde {\\Pi}, \\operatorname {R S} [ L, \\sigma^ {*} ]) \\geq \\delta \\right] \\geq 1 - \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> It suffices to show that there exists <span class="math">\\vec{z}_0</span> such that <span class="math">\\Delta (\\vec{z}_0^\\top \\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^*]) &amp;gt; \\delta</span>. The claim then follows from [BKS18, Theorem 4.1] by setting $\\epsilon := (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-2\\ell})^{-1}<span class="math">, since </span>\\Delta (\\vec{z}^{\\top}\\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^{*}])<span class="math"> is an integer multiple of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math"> and the above probability is an integer multiple of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-2\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If there exists a row <span class="math">\\tilde{\\pi}_i</span> of <span class="math">\\tilde{\\Pi}</span> such that <span class="math">\\Delta (\\tilde{\\pi}_i,\\mathrm{RS}[L,\\sigma^<em>]) &amp;gt; \\delta</span> then we are done. So we assume that all rows are at a distance at most <span class="math">\\delta</span> from <span class="math">\\mathrm{RS}[L,\\sigma^{</em>}]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We may assume without loss of generality that the closest codeword to each row of <span class="math">\\tilde{\\Pi}</span> is zero, since distance is preserved under shifting by codewords. By assumption the number of nonzero columns of <span class="math">\\tilde{\\Pi}</span> is more than <span class="math">d</span>. The probability that the inner product of a nonzero column with <span class="math">\\vec{z}</span> is zero is $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so by a union bound the probability that the inner product of any nonzero column with </span>\\vec{z}<span class="math"> is zero is at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; hence with probability at least </span>1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> it holds that </span>\\Delta (\\vec{z}^{\\top}\\tilde{\\Pi},0) &gt; \\delta<span class="math">. Fix some </span>\\vec{z}<span class="math"> such that this inequality holds. We show that there exists </span>\\vec{z}_0<span class="math"> such that </span>\\Delta (\\vec{z}_0^\\top \\tilde{\\Pi},0)\\leq 2\\delta &lt; 2(1 - \\sigma^<em>) / 3<span class="math">; this implies that </span>\\Delta (\\vec{z}_0^\\top \\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^</em>]) &gt; \\delta$ by the triangle inequality and the distance property of the code.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300">For each <span class="math">i \\in [2\\ell]</span>, let <span class="math">p_i := \\sum_{j=1}^i z_j \\tilde{\\pi}_j</span>; then <span class="math">p_0 = 0</span> and <span class="math">p_{2\\ell} = \\vec{z}^\\top \\tilde{\\Pi}</span>. We therefore have that <span class="math">\\Delta(p_0, 0) = 0</span> and <span class="math">\\Delta(p_{2\\ell}, 0) \\geq \\delta</span>. We also have that <span class="math">\\Delta(p_i, p_{i+1}) \\leq \\delta</span>, and so there exists <span class="math">i^<em></span> such that <span class="math">\\delta &amp;lt; \\Delta(p_{i^</em>}, 0) \\leq 2\\delta</span>. We choose <span class="math">\\vec{z}_0</span> to be the vector of the first <span class="math">i^*</span> entries of <span class="math">\\vec{z}</span> followed by zeroes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Combining the two claims: if <span class="math">\\Delta (\\tilde{\\Pi}_0,\\mathrm{RS}[L,\\vec{\\sigma}]) &amp;gt; \\delta</span> then, with probability at least $1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, it holds that </span>\\Delta (\\vec{z}^{\\top}\\tilde{\\Pi},\\mathrm{RS}[L,\\sigma^{<em>}]) \\geq \\delta<span class="math">. Then </span>\\operatorname</em>{Pr}[E\\mid \\Delta (\\tilde{\\Pi}_0,\\mathrm{RS}[L,\\vec{\\sigma}]) &gt; \\delta ]\\leq \\varepsilon_{\\mathrm{i}}^{\\mathrm{LDT}} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by definition of </span>\\varepsilon_{\\mathbf{q}}^{\\mathrm{LDT}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The probability that <span class="math">\\Delta (\\tilde{\\Pi}_0, \\mathrm{RS}[L, \\vec{\\sigma}]) \\leq \\delta</span>. Let <span class="math">\\pi_1 \\in \\mathrm{RS}[L, \\vec{\\rho}_1], \\ldots, \\pi_{\\mathrm{k}^{\\mathcal{R}}} \\in \\mathrm{RS}[L, \\vec{\\rho}_{\\mathrm{k}^{\\mathcal{R}}}]</span> be the closest codewords to the prover's messages <span class="math">\\tilde{\\pi}_1, \\ldots, \\tilde{\\pi}_{\\mathrm{k}^{\\mathcal{R}}}</span>. We can construct a prover <span class="math">\\hat{P}</span> for the encoded IOP, which sends messages <span class="math">\\pi_1, \\ldots, \\pi_{\\mathrm{k}^{\\mathcal{R}}}</span>. We show that if <span class="math">\\Delta (\\tilde{\\Pi}_0, \\mathrm{RS}[L, \\vec{\\sigma}]) \\leq \\delta</span>, then for all <span class="math">(\\mathcal{C}, \\sigma) \\in \\mathfrak{C}</span> it holds that <span class="math">\\mathcal{C}[\\hat{\\Pi}_0&#x27;] \\in \\mathrm{RS}[L, \\sigma]</span>. By the soundness of the encoded IOP, this occurs with probability at most <span class="math">\\varepsilon^{\\mathcal{R}}</span>.</li>

    </ul>

    <p class="text-gray-300">Take some <span class="math">(\\mathcal{C},\\sigma)\\in \\mathfrak{C}</span>, and let <span class="math">\\pi_{\\mathcal{C}}\\in \\mathrm{RS}[L,\\sigma ]</span> be the (unique) closest codeword to <span class="math">\\mathcal{C}[\\tilde{\\Pi}_0^{\\prime}]</span>. Since <span class="math">\\Delta (\\tilde{\\Pi}_0^{\\prime},\\mathrm{RS}[L,\\vec{\\rho}]) \\leq \\delta</span> and <span class="math">\\mathcal{C}</span> operates column-wise, we have that <span class="math">\\Delta (\\pi_{\\mathcal{C}},\\mathcal{C}[\\hat{\\Pi}_0^{\\prime}]) \\leq \\delta</span>.</p>

    <p class="text-gray-300">Let <span class="math">(N,D) := \\mathcal{C}</span>; then <span class="math">\\Delta(\\pi_{\\mathcal{C}} \\cdot D, N[\\hat{\\Pi}_0&#x27;]) \\leq \\delta</span>. Since <span class="math">\\pi_{\\mathcal{C}} \\cdot D \\in \\mathrm{RS}[L, \\sigma + \\mathrm{rate}(D)]</span> and <span class="math">N[\\hat{\\Pi}_0&#x27;] \\in \\mathrm{RS}[L, \\mathrm{rate}(N; \\vec{\\rho})]</span>, we have that <span class="math">\\pi_{\\mathcal{C}} \\cdot D \\equiv N[\\hat{\\Pi}_0&#x27;]</span> since <span class="math">\\delta &amp;lt; 1 - \\rho^* \\leq 1 - \\max(\\mathrm{rate}(N; \\vec{\\rho}), \\sigma + \\mathrm{rate}(D))</span>. In particular, this implies that <span class="math">D</span> divides <span class="math">N[\\hat{\\Pi}_0&#x27;]</span> as a polynomial, and so <span class="math">\\mathcal{C}[\\hat{\\Pi}_0&#x27;] \\in \\mathrm{RS}[L, \\mathrm{rate}(N; \\vec{\\rho}) - \\mathrm{rate}(D)]</span>. (Note that <span class="math">\\perp \\notin \\mathcal{C}[\\hat{\\Pi}_0&#x27;]</span> because otherwise the completeness condition of the RS-encoded IOP would fail to hold.) We conclude that <span class="math">\\mathcal{C}[\\hat{\\Pi}_0&#x27;] = \\pi_{\\mathcal{C}} \\in \\mathrm{RS}[L, \\sigma]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of knowledge. Suppose that <span class="math">\\tilde{P}</span> causes the verifier to accept with probability <span class="math">\\mu</span>. By a union bound, the probability that <span class="math">\\Delta (\\tilde{\\Pi}_0,\\mathrm{RS}[L,\\vec{\\sigma}]) \\leq \\delta</span> is at least $\\mu - (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\varepsilon_{\\mathrm{i}}^{\\mathrm{LDT}} + \\varepsilon_{\\mathbf{q}}^{\\mathrm{LDT}})<span class="math">. Using an efficient algorithm for Reed-Solomon decoding (such as Berlekamp-Welch), we can recover </span>\\tilde{\\Pi}_0'<span class="math"> from </span>\\tilde{\\Pi}_0'<span class="math">. By the above soundness analysis, we have that for all </span>(\\mathcal{C},\\sigma) \\in \\mathfrak{C}<span class="math"> we have </span>\\mathcal{C}[\\hat{\\Pi}_0'] \\in \\mathrm{RS}[L,\\sigma]<span class="math">. The extractor runs </span>\\tilde{P}<span class="math">, corrects its messages and forwards them to the extractor for the RS-encoded IOP. By the knowledge guarantee of the RS-encoded IOP, the extractor succeeds with probability at least </span>\\mu - (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\varepsilon_{\\mathrm{i}}^{\\mathrm{LDT}} + \\varepsilon_{\\mathbf{q}}^{\\mathrm{LDT}} + \\varepsilon_{\\mathcal{R}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-55" class="text-2xl font-bold">8.1 Zero knowledge</h2>

    <p class="text-gray-300">We describe how to modify the transformation above to preserve zero knowledge, thereby showing how to efficiently convert an RS-encoded IOP with a zero knowledge guarantee into a corresponding IOP with the same zero knowledge guarantee. The transformation uses the random self-reducibility of Reed-Solomon proximity testing, which implies that the low-degree test used in the transformation need not be zero knowledge (the only requirement is that its honest prover must run in polynomial time). In particular, the honest prover in the new protocol will send, in addition to the messages of the underlying RS-encoded IOP, a random codeword <span class="math">r</span>, which is added to the linear combination of messages that are tested for proximity to RS.</p>

    <p class="text-gray-300"><strong>Theorem 8.5.</strong> Suppose that we are given:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an RS-encoded IOP <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}}, (\\vec{\\rho}_i)_{i=1}^{\\mathrm{k}_{\\mathcal{R}}})</span>, with maximum rate <span class="math">(\\sigma^{<em>}, \\rho^{</em>})</span>, for a relation <span class="math">\\mathcal{R}</span> that is zero knowledge against <span class="math">\\mathsf{b}</span> queries;</li>

      <li>an IOPP <span class="math">(P_{\\mathrm{LDT}}, V_{\\mathrm{LDT}})</span> for the RS code <span class="math">\\mathrm{RS}[L, \\sigma^{*}]</span> with a polynomial-time honest prover (not necessarily zero knowledge).</li>

    </ul>

    <p class="text-gray-300">Then we can combine these two ingredients to obtain an IOP <span class="math">(P,V)</span> for <span class="math">\\mathcal{R}</span>, also zero knowledge against <span class="math">\\mathsf{b}</span></p>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">queries, with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ΣR</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">kR + kLDT + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">pR + pLDT + [L]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">qπ</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">qLDT + qLDT · ∑i=1k lR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">(ri, rq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(riR + rLDT + (∑i=1k lR + c) log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, rLDT)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">(εi, εq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(εR + [L]/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ εLDT, εLDT)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(tR + tLDT)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(tV + tLDT)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">provided  <span class="math">\\delta^{\\mathrm{LDT}} &amp;lt; \\min\\left(\\frac{1 - 2\\sigma^{<em>}}{2}, \\frac{1 - \\sigma^{</em>}}{3}, 1 - \\rho^{*}\\right)</span> , and where  <span class="math">c</span>  is the maximum size of a constraint set output by  <span class="math">V_{\\mathcal{R}}</span> . (Parameters with superscript “ <span class="math">\\mathcal{R}</span> ” and “ <span class="math">\\mathrm{LDT}</span> ” are parameters for  <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}})</span>  and  <span class="math">(P_{\\mathrm{LDT}}, V_{\\mathrm{LDT}})</span>  respectively; highlights denote parameter differences with Theorem 8.1.)</p>

    <p class="text-gray-300">Protocol 8.6. Letting  <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}})</span>  and  <span class="math">(P_{\\mathrm{LDT}}, V_{\\mathrm{LDT}})</span>  be as in the theorem statement, we need to construct an IOP  <span class="math">(P, V)</span>  for  <span class="math">\\mathcal{R}</span> . The prover  <span class="math">P</span>  and verifier  <span class="math">V</span>  both receive as input an instance  <span class="math">\\mathbf{x}</span> , and the prover  <span class="math">P</span>  also receives as input a corresponding witness  <span class="math">\\mathbf{w}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Masking codeword for low-degree test.  <span class="math">P</span>  sends to  <span class="math">V</span>  a random  <span class="math">r \\in \\mathrm{RS}[L, \\sigma^*]</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. RS-encoded IOP for  <span class="math">\\mathcal{R}</span> . In parallel to the above,  <span class="math">P</span>  and  <span class="math">V</span>  simulate  <span class="math">(P_{\\mathcal{R}}(\\mathbf{x},\\mathbf{w}), V_{\\mathcal{R}}(\\mathbf{x}))</span> . In the course of this protocol, the prover sends oracle codewords  <span class="math">\\pi_1 \\in \\mathrm{RS}[L, \\vec{\\rho}_1], \\ldots, \\pi_{\\mathrm{k}^{\\mathcal{R}}} \\in \\mathrm{RS}[L, \\vec{\\rho}_{\\mathrm{k}^{\\mathcal{R}}}]</span> , and the verifier specifies a set of rational constraints  <span class="math">\\mathfrak{C}</span> . Let  $\\ell := \\sum_{i=1}^{\\mathrm{k}^{\\mathcal{R}}} \\ell_i +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random linear combination.  <span class="math">V</span>  samples  <span class="math">\\vec{z} \\in \\mathbb{F}^{2\\ell}</span>  uniformly at random and sends it to  <span class="math">P</span> .</li>

      <li>Low-degree test.  <span class="math">P</span>  and  <span class="math">V</span>  simulate  <span class="math">(P_{\\mathrm{LDT}}(\\vec{z}^{\\top}\\Pi +r),V_{\\mathrm{LDT}}^{\\vec{z}^{\\top}\\Pi +r})</span>  where  <span class="math">\\Pi \\coloneqq \\left[\\Pi_0\\right]_{\\Pi_1} \\in \\mathbb{F}^{2\\ell \\times L}</span>  is defined as in Protocol 8.2.</li>

      <li><span class="math">V</span>  accepts if only if  <span class="math">V_{\\mathrm{LDT}}</span>  accepts.</li>

    </ol>

    <p class="text-gray-300">Proof. Completeness and soundness follow almost immediately from those of Protocol 8.2. Indeed, we can view Protocol 8.6 as Protocol 8.2 modified so that  <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}})</span>  begins with an additional "dummy" round where the prover just sends a random codeword. (Note that we can fix  <span class="math">\\vec{z}</span> 's random coefficient for  <span class="math">r</span>  to be 1 almost without loss of generality since distance to Reed-Solomon codewords is preserved under multiplication by a nonzero constant.) We now focus on arguing the zero knowledge property.</p>

    <p class="text-gray-300">Let  <span class="math">S_{\\mathcal{R}}</span>  be the simulator for  <span class="math">(P_{\\mathcal{R}}, V_{\\mathcal{R}})</span> , witnessing zero knowledge against b queries. The simulation guarantee for  <span class="math">S_{\\mathcal{R}}</span>  is that, for any  <span class="math">\\tilde{V}_{\\mathcal{R}}</span>  that makes at most b distinct queries across all oracles,  <span class="math">\\mathrm{View}(P_{\\mathcal{R}}(\\mathbf{x}, \\mathbf{w}), \\tilde{V}_{\\mathcal{R}})</span>  and the output of  <span class="math">S_{\\mathcal{R}}^{\\tilde{V}_{\\mathcal{R}}}(\\mathbf{x})</span>  are identically distributed.</p>

    <p class="text-gray-300">Consider the simulator  <span class="math">S</span>  for  <span class="math">(P,V)</span>  that, given a malicious verifier  <span class="math">\\tilde{V}</span> , constructs a new malicious verifier  <span class="math">\\tilde{V}_{\\mathcal{R}}</span>  (defined below), then runs  <span class="math">S_{\\mathcal{R}}</span>  on  <span class="math">\\tilde{V}_{\\mathcal{R}}</span> , and finally outputs what  <span class="math">\\tilde{V}_{\\mathcal{R}}</span>  outputs given its simulated view.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Start running  <span class="math">\\tilde{V}</span></li>

      <li>Sample  <span class="math">r_{\\mathrm{sim}} \\in \\mathrm{RS}[L, \\sigma^*]</span>  uniformly at random, and answer  <span class="math">\\tilde{V}</span> 's queries to  <span class="math">r</span>  with  <span class="math">r_{\\mathrm{sim}}</span> ; let  <span class="math">Q_{\\mathrm{sim}}</span>  be the verifier's queries to  <span class="math">r</span>  in this phase.</li>

      <li>For  <span class="math">\\mathsf{k}^{\\mathcal{R}}</span>  rounds, forward  <span class="math">\\tilde{V}</span> 's messages to the prover. Answer all of  <span class="math">\\tilde{V}</span> 's queries to the received oracles honestly. Receive a set of rational constraints  <span class="math">\\hat{\\mathfrak{C}}</span>  from  <span class="math">\\tilde{V}</span> .</li>

      <li>Receive  <span class="math">\\tilde{z} \\in \\mathbb{F}^{2\\ell}</span>  from  <span class="math">\\tilde{V}</span> .</li>

      <li>For every  <span class="math">\\omega \\in Q_{\\mathrm{sim}}</span> , query every oracle received at  <span class="math">\\omega</span> . For each oracle defined by a rational constraint  <span class="math">(\\hat{\\mathcal{C}}, \\hat{\\sigma}) \\in \\hat{\\mathfrak{C}}</span> , evaluate  <span class="math">\\hat{\\mathcal{C}}</span>  at  <span class="math">\\omega</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">p_0^{(\\omega)} \\in \\mathbb{F}^\\ell</span> be the value of each oracle at point <span class="math">\\omega</span>, <span class="math">p_1^{(\\omega)}</span> be given by <span class="math">(p_1^{(\\omega)})_i := \\omega^{\\rho - \\sigma_i}(p_0^{(\\omega)})_i</span> for <span class="math">i \\in [\\ell]</span>, and <span class="math">p^{(\\omega)} \\in \\mathbb{F}^{2\\ell}</span> be the concatenation of <span class="math">p_0^{(\\omega)}</span> and <span class="math">p_1^{(\\omega)}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">p_{\\mathrm{sim}} \\in \\mathrm{RS}[L, \\sigma^*]</span> uniformly at random such that, for every <span class="math">\\omega \\in Q_{\\mathrm{sim}}</span>, <span class="math">p_{\\mathrm{sim}}(\\omega) = \\tilde{z}^\\top p^{(\\omega)} + r_{\\mathrm{sim}}(\\omega)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now when <span class="math">\\tilde{V}</span> queries <span class="math">r</span> at <span class="math">\\omega</span>, query every oracle received at <span class="math">\\omega</span> and answer with <span class="math">p_{\\mathrm{sim}}(\\omega) - \\tilde{z}^{\\top}p^{(\\omega)}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the interaction of <span class="math">P_{\\mathrm{LDT}}(p)</span> and <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the view of the simulated <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <p class="text-gray-300">For every query that <span class="math">\\tilde{V}</span> makes to <span class="math">r</span>, <span class="math">\\tilde{V}_{\\mathcal{R}}</span> makes a query to every oracle it has received in the same location. Similarly, for each query <span class="math">\\tilde{V}</span> makes to any other oracle, <span class="math">\\tilde{V}_{\\mathcal{R}}</span> makes at most one query to some received oracle. Hence <span class="math">\\tilde{V}_{\\mathcal{R}}</span> makes at most <span class="math">\\mathsf{b}</span> distinct queries across all oracles, and so the simulation guarantee holds.</p>

    <p class="text-gray-300">To show zero knowledge, we exhibit the following hybrid experiment, in which the view of <span class="math">\\tilde{V}</span> is identically distributed to the output of the simulator.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the honest prover <span class="math">P_{\\mathcal{R}}(\\mathbf{x},f)</span>; let <span class="math">\\Pi</span> be as in the protocol.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">r \\in \\mathrm{RS}[L, \\sigma^*]</span> uniformly at random and send it to <span class="math">\\tilde{V}</span>. Let <span class="math">Q \\subseteq L</span> be the verifier's queries to <span class="math">r</span> in this phase.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive <span class="math">\\tilde{z} \\in \\mathbb{F}^{2\\ell}</span> from <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">p \\in \\mathrm{RS}[L, \\sigma^*]</span> uniformly at random such that, for every <span class="math">\\omega \\in Q</span>, <span class="math">p(\\omega) = (\\tilde{z}^\\top \\Pi)_\\omega + r(\\omega)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Replace <span class="math">r</span> with <span class="math">p - \\tilde{z}^{\\top}\\Pi</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the interaction of <span class="math">P_{\\mathrm{LDT}}(p)</span> and <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <p class="text-gray-300">One can verify that the view of <span class="math">\\tilde{V}</span> in this hybrid is also identically distributed to the view of <span class="math">\\tilde{V}</span> in the real protocol. In particular, all answers to <span class="math">\\tilde{V}</span>'s queries to <span class="math">r</span> after its replacement by <span class="math">p</span> are correctly distributed.</p>

    <p class="text-gray-300">We describe the IOP for R1CS (Definition 7.1) that comprises the main technical contribution of this paper, and also underlies the zkSNARK for R1CS that we have designed and built (more about this in Section 10).</p>

    <p class="text-gray-300">For the discussions below, we introduce notation about the low-degree test in [BBHR18b], known as "Fast Reed-Solomon IOPP" (FRI): given a subspace  <span class="math">L</span>  of a binary field  <span class="math">\\mathbb{F}</span>  and rate  <span class="math">\\rho \\in (0,1)</span> , we denote by  <span class="math">\\varepsilon_{\\mathrm{i}}^{\\mathrm{FRI}}(\\mathbb{F},L)</span>  and  <span class="math">\\varepsilon_{\\mathfrak{q}}^{\\mathrm{FRI}}(L,\\rho ,\\delta)</span>  the soundness error of the interactive and query phases in FRI (respectively) when testing proximity of a  <span class="math">\\delta</span> -far function to RS  <span class="math">[L,\\rho ]</span> . See Appendix C.1 for details about these functions.</p>

    <p class="text-gray-300">We first provide a "barebones" statement with constant soundness error and no zero knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 9.1. There is an IOP of knowledge for  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  (Definition 7.1) over binary fields  <span class="math">\\mathbb{F}</span>  that, given an R1CS instance having  <span class="math">n</span>  variables and  <span class="math">m</span>  constraints, letting  <span class="math">\\rho \\in (0,1)</span>  be a constant and  <span class="math">L</span>  be any subspace of  <span class="math">\\mathbb{F}</span>  such that  $2\\max(m,n+1) \\leq \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , has the following parameters:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(5 + 1/3)</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">qπ</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">(ri, rq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(O(log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">· log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">), O(log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">(εi, εq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(m+1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ εiFRI( F, L), εqFRI( L, ρ, δ))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">· log(n + m) +</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">) + 17 · FFT( F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+ n + m + log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">\\delta \\coloneqq \\min \\left(\\frac{1 - 2(\\rho / 2)}{2},\\frac{1 - (\\rho / 2)}{3},1 - \\rho\\right)</span></p>

    <p class="text-gray-300">Proof. Apply the transformation in Section 8 (see Theorem 8.1) to two ingredients: (a) the RS-encoded IOP for R1CS in Section 7 (see Theorem 7.2); and (b) the FRI low-degree test with proximity parameter  <span class="math">\\delta^{\\mathrm{LDT}}\\coloneqq \\delta</span> . Note that the condition on  <span class="math">\\delta^{\\mathrm{LDT}}</span>  is satisfied by definition. The resulting protocol is sound against all malicious provers (and not just provers that send oracles that are Reed-Solomon codewords).</p>

    <p class="text-gray-300">Next, we provide a statement that additionally has parameters for controlling the soundness error, is zero knowledge, and includes other (whitebox) optimizations; the proof is analogous except that we use zero knowledge components (the RS-encoded IOP of Theorem 7.4 and the transformation of Theorem 8.5). The resulting IOP protocol, fully specified in Fig. 5, underlies our zkSNARK for R1CS (see Section 10).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 9.2. There is an IOP of knowledge for  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  (Definition 7.1) over binary fields  <span class="math">\\mathbb{F}</span>  that, given an R1CS instance having  <span class="math">n</span>  variables and  <span class="math">m</span>  constraints, letting  <span class="math">\\rho \\in (0,1)</span>  be a constant and  <span class="math">L</span>  be any subspace of  <span class="math">\\mathbb{F}</span>  such that  $2\\max(m,n+1) + 2\\mathsf{b} \\leq \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , is zero knowledge against  </span>\\mathsf{b}$  queries and has the following parameters:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(4 + 2λi + λi′λiFRI/3)</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">qπ</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λiλiFRIλiqFRI log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">(ri, rq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(O((λiλi′ + λiFRI log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">) log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">), O(λiFRI log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">(εi, εq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">((m+1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)λi + (</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)λi′ + εiFRI( F, L)λiFRI, εiFRI( L, ρ, δ)λiFRI)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">λi · (O(</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">· (log(n + m) +</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">) + 18 · FFT( F,</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)) + O(λi′λiFRI</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">λi · O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+ n + m + log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">) + O(λi′λiFRIλiqFRI log</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">\\delta \\coloneqq \\min \\left(\\frac{1 - 2\\rho}{2},\\frac{1 - \\rho}{3},1 - \\rho\\right)</span> . Setting  <span class="math">\\mathsf{b}\\geq \\mathsf{q}_{\\pi}</span>  ensures honest-verifier zero knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an R1CS instance  <span class="math">(\\mathbb{F},k,n,m,A,B,C,v)</span> , we fix subspaces  <span class="math">H_{1},H_{2}\\subseteq \\mathbb{F}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n + 1<span class="math">  (padding to the nearest power of 2 if necessary) with  </span>H_{1}\\subseteq H_{2}<span class="math">  or  </span>H_{2}\\subseteq H_{1}<span class="math"> , and a sufficiently large affine subspace  </span>L\\subseteq \\mathbb{F}<span class="math">  such that  </span>L\\cap (H_1\\cup H_2) = \\emptyset<span class="math"> . We let  </span>t\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_1\\cup H_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\max (m,n + 1)<span class="math"> . Fig. 4 below gives polynomials and codewords used in Fig. 5. We also define  </span>\\xi \\coloneqq \\sum_{a\\in H_1\\cup H_2}a^{t - 1}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we note that we have tailored the transformation from Section 8 to the RS-encoded IOP from Section 7 in the sense that for most oracles of sub-maximal rate it actually suffices to test proximity to the maximal rate so they only appear once (unshifted) in the matrix  <span class="math">\\Pi</span> . The single exception is the (virtual) oracle  <span class="math">g_{i}</span>  used in the sumcheck protocol, for which we must test proximity with rate exactly  $(t - 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Because of this,  </span>g_{i}<span class="math">  is the only oracle for which we test both  </span>g_{i}<span class="math">  and a shift of it, as is shown in the matrix  </span>\\Pi$  in Fig. 5.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomial</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">values that define the polynomial</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pα</td>

            <td class="px-3 py-2 border-b border-gray-700">t-1</td>

            <td class="px-3 py-2 border-b border-gray-700">pα(a) = {αγ(a) for a ∈ H10 for a ∈ (H1 ∪ H2) \\ H1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pα(M)</td>

            <td class="px-3 py-2 border-b border-gray-700">t-1</td>

            <td class="px-3 py-2 border-b border-gray-700">pα(M)(b) = {∑a∈H1Ma,b · αγ(a) for b ∈ H20 for b ∈ (H1 ∪ H2) \\ H2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">codeword</td>

            <td class="px-3 py-2 border-b border-gray-700">code</td>

            <td class="px-3 py-2 border-b border-gray-700">polynomial that defines the codeword</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">fw</td>

            <td class="px-3 py-2 border-b border-gray-700">RS [L, n-k+b/L]</td>

            <td class="px-3 py-2 border-b border-gray-700">random polynomial f_w of degree less than n-k+b such that, for all b ∈ H2 with k < γ(b) ≤ n, f_w(b) = wγ(b)-k - f(1,v)(b)/ZH2≤k(b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">fMz</td>

            <td class="px-3 py-2 border-b border-gray-700">RS [L, m+b/L]</td>

            <td class="px-3 py-2 border-b border-gray-700">random polynomial f_Az of degree less than m+b such that, for all a ∈ H1, f_Az(a) = ∑b∈H2Ma,b · zγ(b) = (Mz)a</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Polynomials and codewords used in the IOP protocol given in Fig. 5.</p>

    <p class="text-gray-300">P((\\mathbb{F},k,n,m,A,B,C,v),w)</p>

    <p class="text-gray-300">V(\\mathbb{F},k,n,m,A,B,C,v)</p>

    <p class="text-gray-300">Sample (as in Fig. 4):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $f_{w} \\in \\mathrm{RS}\\left[L, \\frac{n - k + b}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $f_{Az}, f_{Bz}, f_{Cz} \\in \\mathrm{RS}\\left[L, \\frac{m + b}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{w}, f_{Az}, f_{Bz}, f_{Cz}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{z} := f_{w} \\cdot \\mathbb{Z}_{H_{2}^{\\leq k}} + f_{(1,v)} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">repeat for  <span class="math">i = 1,\\dots ,\\lambda_{\\mathrm{i}}</span>  in parallel:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sample  $r_i\\gets \\mathrm{RS}\\left[L,\\frac{2t + b - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right]<span class="math">  for univariate sumcheck below, and compute  </span>\\mu_{i}\\coloneqq \\sum_{a\\in H_{1}\\cup H_{2}}r_{i}(a)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>lincheck</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\alpha_{i}\\gets \\mathbb{F},\\vec{s}_{i}\\gets \\mathbb{F}^{3}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">q_{i,1} := f_{Az} \\cdot p_{\\alpha_i} - f_z \\cdot p_{\\alpha_i}^{(A)}</span></li>

      <li>virtual oracles for lincheck</li>

      <li><span class="math">q_{i,2} := f_{Bz} \\cdot p_{\\alpha_i} - f_z \\cdot p_{\\alpha_i}^{(B)}</span></li>

      <li><span class="math">q_{i,3} := f_{Cz} \\cdot p_{\\alpha_i} - f_z \\cdot p_{\\alpha_i}^{(C)}</span></li>

    </ul>

    <p class="text-gray-300">Compute:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>amortized zero knowledge univariate sumcheck</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$g_{i}\\in \\mathrm{RS}\\left[L,\\frac{t - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right],h_{i}\\in \\mathrm{RS}\\left[L,\\frac{t + \\mathsf{b}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">s.t.  <span class="math">\\hat{r}_i(X) + \\sum_{j = 1}^{3}s_{i,j}\\hat{q}_{i,j}(X)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_i</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">= \\hat{g}_i(X) + \\xi^{-1}\\mu_i\\cdot X^{t - 1}</span></li>

      <li>+  <span class="math">\\mathbb{Z}_{H_1\\cup H_2}(X)\\cdot \\hat{h}_i(X)</span></li>

    </ul>

    <p class="text-gray-300">For all  <span class="math">a\\in L,g_i(a)\\coloneqq</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r_i(a) + \\sum_{j=1}^{3} s_{i,j} q_{i,j}(a)</span></li>

      <li><span class="math">\\xi^{-1}\\mu_i\\cdot a^{t - 1}</span></li>

      <li><span class="math">\\mathbb{Z}_{H_1\\cup H_2}(a)\\cdot h_i(a)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$r_{\\mathrm{LDT}}^{(1)}, \\ldots, r_{\\mathrm{LDT}}^{(\\lambda_i')} \\gets \\mathrm{RS}\\left[L, \\frac{2t + 2b}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">low-degree test</p>

    <p class="text-gray-300"><span class="math">\\Pi \\coloneqq \\left[ \\begin{array}{c}f_w\\\\ f_{Az}\\\\ f_{Bz}\\\\ f_{Cz}\\\\ (f_{Az}\\cdot f_{Bz} - f_{Cz}) / \\mathbb{Z}_{H_1}\\\\ r_1;\\ldots ;r_{\\lambda_i}\\\\ h_1;\\ldots ;h_{\\lambda_i}\\\\ g_1;\\ldots ;g_{\\lambda_i}\\\\ (X^{(2t + 2b) - (t - 1)}g_i)_{i = 1}^{\\lambda_i} \\end{array} \\right]\\quad \\begin{array}{c}r_{L\\mathrm{DT}}^{(1)},\\ldots ,r_{L\\mathrm{DT}}^{(\\lambda_i^{\\prime})}\\\\ \\vec{y}_1,\\ldots ,\\vec{y}_{\\lambda_i^{\\prime}}\\\\ \\vec{y}_1,\\ldots ,\\vec{y}_{\\lambda_i^{\\prime}}\\\\ \\vec{y}_1,\\ldots ,\\vec{y}_{\\lambda_i^{\\prime}}\\\\ \\vec{y}_1,\\ldots ,\\vec{y}_{\\lambda_i^{\\prime}}\\\\ \\vec{y}_1,\\ldots ,\\vec{y}_{\\lambda_i^{\\prime}}\\end{array}\\right]\\quad \\vec{y}_1,\\ldots ,\\vec{y}_{\\lambda_i^{\\prime}}\\gets \\mathbb{F}^{5 + 4\\lambda_i}</span></p>

    <p class="text-gray-300">Figure 5: Diagram of the zero knowledge IOP for R1CS that proves Theorem 9.2.</p>

    <p class="text-gray-300">10 libiop: a library for IOP-based non-interactive arguments</p>

    <p class="text-gray-300">We provide libiop (see https://github.com/scipr-lab/libiop), a codebase that enables the design and implementation of IOP-based non-interactive arguments. The codebase uses the C++ language and has three main components: (1) a library for writing IOP protocols; (2) a realization of the [BCS16] transformation, mapping any IOP written with our library to a corresponding non-interactive argument; (3) a portfolio of IOP protocols. We discuss each of these components in turn.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">10.1 Library for IOP protocols</h3>

    <p class="text-gray-300">We provide a library that enables a programmer to write IOP protocols. Informally, the programmer provides a blueprint of the IOP by specifying, for each round, the number and sizes of oracle messages (and non-oracle messages) sent by the prover, as well as the number of random bytes subsequently sent by the verifier. For the prover, the programmer specifies how each message is to be computed. For the verifier, the programmer specifies how oracle queries are generated and, also, how the verifier’s decision is computed based on its random choices and information received from the prover. Notable features of our library include:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Support for writing new IOPs by using other IOPs as sub-protocols. This includes juxtaposing or interleaving selected rounds of these sub-protocols. This latter feature not only facilitates reducing round complexity in complex IOP constructions but also makes it possible to take advantage of optimizations such as column hashing (discussed in Section 10.2) when constructing a non-interactive argument.</li>

      <li>A realization of the transformation described in Section 8, which constructs an IOP by combining an encoded IOP (as defined in Section 4.7) and a low-degree test (as defined in Section 4.5.1). This is a powerful paradigm (it applies to essentially all published IOP protocols) that reduces the task of writing an IOP to merely providing suitable choices of these two simpler ingredients.</li>

    </ul>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">10.2 BCS transformation</h3>

    <p class="text-gray-300">We realize the transformation of [BCS16], by providing code that maps any IOP written in our library into a corresponding non-interactive argument (which consists of a prover algorithm and a verifier algorithm).</p>

    <p class="text-gray-300">We use BLAKE2b [ANWOW13] to instantiate the random oracle in the [BCS16] transformation (our code allows to conveniently specify alternative instantiations). This hash function is an improvement to BLAKE (a finalist in the SHA-3 competition) [AMPH14], and its performance on all recent x86 platforms is competitive with the most performant (and often hardware-accelerated) hash functions [CS17]. Moreover, BLAKE2b can be configured to output digests of any length between <span class="math">1</span> and <span class="math">64</span> bytes (between <span class="math">8</span> and <span class="math">512</span> bits in multiples of <span class="math">8</span>). When aiming for a security level of <span class="math">\\lambda</span> bits, we only need the hash function to output digests of <span class="math">2\\lambda</span> bits, and our code automatically sets this length.</p>

    <p class="text-gray-300">Our code incorporates additional optimizations that, while simple, are generic and effective.</p>

    <p class="text-gray-300">One is column hashing, which informally works as follows. In many IOP protocols (essentially all published ones, including Ligero [AHIV17] and Stark [BBHR18a]), the prover sends multiple oracles over the same domain in the same round, and the verifier accesses all of them at the same index in the domain. The prover can then build a Merkle tree over columns consisting of corresponding entries of the oracles, rather than building separate Merkle trees for each or a single Merkle tree over their concatenation. This reduces a non-interactive proof’s length, because the proof only has to contain a single authentication path for the desired column, rather than authentication paths corresponding to the indices across all the oracles.</p>

    <p class="text-gray-300">Another optimization is <em>path pruning</em>. When providing multiple authentication paths relative to the same root (in the non-interactive argument), some digests become redundant and can thus be omitted. For example, if one considers the authentication paths for all leaves in a particular sub-tree, then one can simple provide the authentication path for the root of the sub-tree. A simple way to view this optimization is to provide the smallest number of digests to authenticate a <em>set</em> of leaves.</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">10.3 Portfolio of IOP protocols and sub-components</h3>

    <p class="text-gray-300">We have used our library to realize the IOP protocols below. (We have publicly released the first two.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Aurora: our IOP protocol for R1CS (specifically, the one provided in Fig. 5 in Section 9).</li>

      <li>Ligero: an adaptation of the IOP protocol in <em>[x1]</em> to R1CS. While the protocol(s) in <em>[x1]</em> are designed for (boolean or arithmetic) circuit satisfiability, the same ideas can be adapted to support R1CS <em>at no extra cost</em>. This simplifies comparisons with R1CS-based arguments, and confers additional expressivity. For convenience, we provide the foregoing adaptation in Appendix B.</li>

      <li>Stark: the IOP protocol in <em>[x1]</em> for <em>Algebraic Placement and Routing</em> (APR), a language that is a “succinct” analogue of algebraic satisfaction problems such as R1CS. (See <em>[x1]</em> for details.)</li>

    </ul>

    <p class="text-gray-300">Each of these IOPs is obtained by specifying an encoded IOP and a low-degree test. As explained in Sections 10.1 and 10.2, our library compiles these into an IOP protocol, and the latter into a non-interactive argument. This toolchain enables writing protocols with fewer lines of code, and enhances code auditability.</p>

    <p class="text-gray-300">The IOP protocols above benefit from several algebraic components that our library also provides.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Finite field arithmetic.</em> We support prime and binary fields. Our prime field arithmetic uses Montgomery representation <em>[x17]</em>. Our binary field arithmetic uses the carryless multiplication instructions <em>[x10]</em>; these are ubiquitous in x86 CPUs and, being used in AES-GCM computations, are highly optimized.</li>

      <li><em>FFT algorithms.</em> The choice of FFT algorithm depends on whether the R1CS instance (and thus the rest of the protocol) is defined over a prime or binary field. In the former case, we use the radix-2 FFT (whose evaluation domain is a multiplicative coset of order <span class="math">2^{a}</span> for some <span class="math">a</span>) <em>[x5]</em>. In the latter case, we use an additive FFT (whose evaluation domain is an affine subspace of the binary field) <em>[x6, x11, x2, x12, x14]</em>. We also provide the respective inverse FFTs, and variants for cosets of the base domains.</li>

    </ul>

    <h6 id="sec-61" class="text-base font-medium mt-4">Remark 10.1.</h6>

    <p class="text-gray-300">Known techniques can be used to reduce given programs or general machine computations to low-level representations such as R1CS and APR (see, e.g., <em>[x3, x20, x15]</em>). Such techniques have been compared in prior work, and our library does not focus on these.</p>

    <p class="text-gray-300">In Section 11.1 we evaluate the performance of Aurora. Then, in Section 11.2 we compare Aurora with Ligero [AHIV17] and Stark [BBHR18a], two other IOP-based zkSNARKs. Our experiments not only demonstrate that Aurora's performance matches the theoretical predictions implied by the protocol but also that Aurora achieves the smallest argument size of any IOP-based zkSNARK, by more than an order of magnitude.</p>

    <p class="text-gray-300">That said, there is still a sizable gap between the argument sizes of IOP-based zkSNARKs and other zkSNARKs that use public-key cryptographic assumptions vulnerable to quantum adversaries; see Fig. 2 for how argument sizes vary across these. It remains an exciting open problem to close this gap.</p>

    <p class="text-gray-300">Experiments ran on a machine with an Intel Xeon W-2155 3.30GHz 10-core processor and 64GB of RAM.</p>

    <p class="text-gray-300">We consider Aurora at the standard security level of 128 bits, over the binary field  <span class="math">\\mathbb{F}_{2^{192}}</span> . We report data on key efficiency measures of a zkSNARK: the time to generate a proof (running time of the prover), the length of a proof, and the time to check a proof (running time of the verifier). We also indicate how much of each cost is due to the IOP protocol, and how much is due to the BCS transformation [BCS16].</p>

    <p class="text-gray-300">In Aurora, all of these quantities depend on the number of constraints  <span class="math">m</span>  in an R1CS instance. Our experiments report how these quantities change as we vary  <span class="math">m</span>  over the range  <span class="math">\\{2^{10}, 2^{11}, \\ldots, 2^{20}\\}</span> .</p>

    <p class="text-gray-300">Prover running time. In Fig. 6 we plot the running time of the prover, as absolute cost (top graph) and as relative cost when compared to native execution (bottom graph). For R1CS, native execution is the time that it takes to check that an assignment satisfies the constraint system. The plot confirms the quasilinear complexity of the prover; proving times range from fractions of a second to several minutes. Proving time is dominated by the cost of running the underlying IOP prover.</p>

    <p class="text-gray-300">Argument size. In Fig. 7 we plot argument size, as absolute cost (top graph) and as relative cost when compared to native witness size (bottom graph). For R1CS, native witness size is the number of bytes required to represent an assignment to the constraint system. The plot shows that compression (argument size is smaller than native witness size) occurs for  <span class="math">m \\geq 2000</span> . The plot also shows that argument size ranges from  <span class="math">40\\mathrm{kB}</span>  to  <span class="math">130\\mathrm{kB}</span> , and is dominated by the cryptographic digests to authenticate query answers.</p>

    <p class="text-gray-300">Verifier running time. In Fig. 8 we plot the running time of the verifier, as absolute cost (top graph) and as relative cost when compared to native execution (bottom graph). The plot shows that verification times range from milliseconds to seconds, and confirms that our implementation incurs a constant multiplicative overhead over native execution.</p>

    <p class="text-gray-300">In Figs. 9 to 11 we compare costs (proving time, argument size, and verification time) on R1CS instances for three IOP-based zkSNARKs: Ligero [AHIV17], Stark [BBHR18a], and Aurora (this work). As in Section 11.1, we plot costs as the number of constraints  <span class="math">m</span>  increases (and with  <span class="math">n \\approx m</span>  variables as explained in Footnote 8); we also set security to the standard level of 128 bits and use the binary field  <span class="math">\\mathbb{F}_{2^{192}}</span> .</p>

    <p class="text-gray-300">Comparison of Ligero and Aurora. Ligero natively supports R1CS so a comparison with Aurora is straightforward. Fig. 10 shows that argument size in Aurora is much smaller than in Ligero, even for a</p>

    <p class="text-gray-300">relatively small number of constraints. The gap between the two grows bigger as the number of constraints increases, as Aurora's argument size is polylogarithmic while Ligero's is only sublinear (an exponential gap).</p>

    <p class="text-gray-300">Comparison of Stark and Aurora. Stark does not natively support the NP-complete relation R1CS but instead natively supports an NEXP-complete relation known as Algebraic Placement and Routing (APR). These two relations are quite different, <span class="math">^9</span>  and so to achieve a meaningful comparison, we consider an APR instance that simulates a given R1CS instance. We thus plot the costs of Stark on a hand-optimized APR instance that simulates R1CS instances. Relying on the reductions described in [BBHR18a], we wrote an APR instance that realizes a simple abstract computer that checks that a variable assignment satisfies each one of the rank-1 constraints in a given R1CS instance.</p>

    <p class="text-gray-300">Fig. 10 shows that argument size in Aurora is much smaller than in Stark, even if both share the same asymptotic growth. This is due to the fact that R1CS and APR target different computation models (explicit circuits vs. uniform computations), so Stark incurs significant overheads when used for R1CS. Fig. 11 shows that verification time in Stark grows linearly with the number of constraints (like Ligero and Aurora); indeed, the verifier must read the description of the statement being proved, which is the entire constraint system.</p>

    <p class="text-gray-300">Using notation for APR introduced in Appendix C.2, one can think of APR as a succinctly-represented system of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> equations over</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> variables, in which equations have total degree at most D := \\max_{c \\in \\mathcal{C}} \\deg c . When D = 2 , one could be led to view APR as "comparable" to R1CS with</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> constraints over</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> variables. This comparison, however, is misleading in that one is simply comparing the total number of constraints and variables, ignoring what they actually represent.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 6: Proving time in Aurora.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 7: Argument size in Aurora.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 8: Verification time in Aurora.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 9: Proving time in Aurora, Ligero, Stark.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 10: Argument size in Aurora, Ligero, Stark.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 11: Verification time in Aurora, Ligero, Stark.</p>

    <p class="text-gray-300">Definition A.1. For a field <span class="math">\\mathbb{F}</span> of characteristic <span class="math">p</span>, the generalized derivative of a function <span class="math">f</span> in a direction <span class="math">a \\in \\mathbb{F}</span> is <span class="math">\\Delta_a(f) := \\sum_{b \\in \\mathbb{F}_p} f(X + ba)</span>. For <span class="math">a_1, \\ldots, a_k \\in \\mathbb{F}</span>, we inductively define <span class="math">\\Delta_{a_1, \\ldots, a_k}(f) := \\Delta_{a_1}(\\Delta_{a_2, \\ldots, a_k}(f))</span>.</p>

    <p class="text-gray-300">Note that if <span class="math">\\mathbb{F}</span> has characteristic 2 then this coincides with the directional derivative. If <span class="math">H</span> is a subspace of <span class="math">\\mathbb{F}</span> with basis <span class="math">a_1, \\ldots, a_n</span> then for any <span class="math">a_0 \\in \\mathbb{F}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_{a_1, \\dots, a_k}(f)(a_0) = \\sum_{a \\in H_0} f(a_0 + a). \\tag{1}</span></div>

    <p class="text-gray-300">For a natural number <span class="math">c = \\sum_{i=0}^{k} c_i p^i</span>, <span class="math">0 \\leq c_i &amp;lt; p</span>, let <span class="math">\\operatorname{wt}(c) = \\sum_{i=0}^{k} c_i</span>. For a polynomial <span class="math">P(X) = \\sum_{j \\geq 0} \\alpha_j X^j</span> define <span class="math">\\operatorname{wt}(P) := \\max \\{ \\operatorname{wt}(j) : \\alpha_j \\neq 0 \\}</span>.</p>

    <p class="text-gray-300">Claim A.2. For any polynomial <span class="math">P \\in \\mathbb{F}[X]</span> and any <span class="math">a \\in \\mathbb{F}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{wt}(\\Delta_a(P)) \\leq \\max(\\operatorname{wt}(P) - (p - 1), 0).</span></div>

    <p class="text-gray-300">Moreover, if <span class="math">\\operatorname{wt}(P) &amp;lt; p - 1</span>, then <span class="math">\\Delta_a(P)</span> is identically zero.</p>

    <p class="text-gray-300">Proof. By linearity of <span class="math">\\Delta_a</span>, it suffices to prove the claim for a single monomial; that is, <span class="math">P(X) = X^c</span> for some integer <span class="math">c \\geq 0</span>. Let <span class="math">c = \\sum_{i=0}^{k} c_i p^i</span> be the <span class="math">p</span>-ary expansion of <span class="math">c</span> for some integer <span class="math">k</span>. For a natural number <span class="math">d = \\sum_{i=0}^{k} d_i p^i</span> we write <span class="math">d \\leq_p c</span> if <span class="math">d_i \\leq c_i</span> for all <span class="math">i</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\Delta_a(X^c) &amp;amp;= \\sum_{b \\in \\mathbb{F}_p} (X + ba)^c = \\sum_{b \\in \\mathbb{F}_p} \\sum_{d=0}^{c} \\binom{c}{d} X^d b^{c-d} a^{c-d} \\\\ &amp;amp;= \\sum_{d=0}^{c} \\binom{c}{d} X^d a^{c-d} \\left( \\sum_{b \\in \\mathbb{F}_p} b^{c-d} \\right) = \\sum_{d=0}^{c} \\binom{c}{d} X^d a^{c-d} \\left( \\sum_{b \\in \\mathbb{F}_p} b^{\\sum_{i=0}^{k} (c_i - d_i) p^i} \\right) \\\\ &amp;amp;= \\sum_{d=0}^{c} \\binom{c}{d} X^d a^{c-d} \\left( \\sum_{b \\in \\mathbb{F}_p} b^{\\sum_{i=0}^{k} (c_i - d_i)} \\right) = \\sum_{d \\leq p c} \\binom{c}{d} X^d a^{c-d} \\cdot \\left( \\sum_{b \\in \\mathbb{F}_p} b^{\\operatorname{wt}(c) - \\operatorname{wt}(d)} \\right), \\end{aligned}</span></div>

    <p class="text-gray-300">where in the penultimate equality we used that <span class="math">b^{p^i} = b</span> for <span class="math">b \\in \\mathbb{F}_p</span>, and in the last equality we used that <span class="math">\\binom{c}{d} \\equiv 0 \\pmod{p}</span> unless <span class="math">d \\leq_p c</span>. Recall that for <span class="math">0 \\leq m &amp;lt; p - 1</span>, <span class="math">\\sum_{b \\in \\mathbb{F}_p} b^m = 0</span>. Hence the terms in the above sum where <span class="math">\\operatorname{wt}(c) - \\operatorname{wt}(d) &amp;lt; p - 1</span> all vanish. Any remaining terms thus have weight at most <span class="math">\\operatorname{wt}(c) - (p - 1)</span>. In particular, if <span class="math">\\operatorname{wt}(c) &amp;lt; p - 1</span> then all terms vanish.</p>

    <p class="text-gray-300">Lemma A.3. Let <span class="math">\\mathbb{F}</span> be a field of characteristic <span class="math">p</span>, and let <span class="math">P \\in \\mathbb{F}[X]</span> have degree less than <span class="math">p^k - 1</span>. Then for any <span class="math">a_1, \\ldots, a_k \\in \\mathbb{F}</span>, <span class="math">\\Delta_{a_1, \\ldots, a_k}(P)</span> is identically zero.</p>

    <p class="text-gray-300">Proof. We have <span class="math">\\operatorname{wt}(P) &amp;lt; (p - 1)k</span>. By Claim A.2, <span class="math">\\operatorname{wt}(\\Delta_{a_2,\\ldots,a_k}(P)) &amp;lt; p - 1</span>, and so <span class="math">\\Delta_{a_1,\\ldots,a_k}(P)</span> is identically zero.</p>

    <p class="text-gray-300">Proof of Lemma 5.4. For some <span class="math">a_0, a_1, \\ldots, a_k \\in \\mathbb{F}</span>, <span class="math">H = a_0 + H_0</span> where <span class="math">H_0</span> is the linear subspace with basis <span class="math">a_1, \\ldots, a_k</span>. By Eq. (1) and Lemma A.3 we conclude <span class="math">\\sum_{a \\in H} g(a) = \\Delta_{a_1, \\ldots, a_k}(g)(a_0) = 0</span>.</p>

    <p class="text-gray-300">10This quantity is called the 'q-ary digit sum' in [BC99].</p>

    <p class="text-gray-300">B Adaptation of Ligero to the R1CS relation</p>

    <p class="text-gray-300">We describe R1CS-Ligero, an adaptation of the Ligero protocol for the R1CS relation (Definition 7.1). This adaptation captures as a special case, and at no additional cost, the arithmetic circuits considered in <em>[x1]</em>. The high-level structure of the protocol is analogous to that described in Section 2.1. Namely, given a satisfying assignment <span class="math">z</span> to an R1CS instance with matrices <span class="math">A,B,C</span>, the prover computes <span class="math">y_{A}:=Az</span>, <span class="math">y_{B}:=Bz</span>, <span class="math">y_{C}:=Cz</span>, and sends to the verifier certain encodings of <span class="math">z,y_{A},y_{B},y_{C}</span>. After that, the prover convinces the verifier that “<span class="math">y_{M}=Mz</span>” for <span class="math">M\\in\\{A,B,C\\}</span> via three suitable lincheck protocols, and that “<span class="math">y_{A}\\circ y_{B}=y_{C}</span>” via a suitable rowcheck protocol. A key aspect is that the encoding of <span class="math">N</span> field elements consists of <span class="math">O(\\sqrt{N})</span> Reed–Solomon codewords of block length <span class="math">O(\\sqrt{N})</span> rather than a single Reed–Solomon codeword of length <span class="math">O(N)</span> — this aspect is what determines the design of the aforementioned sub-protocols. As in <em>[x1]</em>, the final protocol is an IPCP, i.e., an IOP wherein only the first prover message is an oracle.</p>

    <p class="text-gray-300">The rest of this section is structured as follows. In Appendix B.1 and Appendix B.2 we describe lincheck and rowcheck protocols for information encoded via the interleaved Reed–Solomon code. In Appendix B.3 we show how to combine these to obtain an RS-encoded IPCP for the R1CS relation; this protocol also takes care of additional goals such as zero knowledge and input consistency. In Appendix B.4 we explain how how generic tools can augment this latter protocol to a standard IPCP (that is sound against all provers).</p>

    <p class="text-gray-300">Unlike in an RS-encoded IOP, in an RS-encoded IPCP we count queries to the first (oracle) message only. All other messages are read in full by the verifier, and we charge their length to communication complexity.</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">B.1 Interleaved lincheck</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a field and <span class="math">L,H</span> subsets of <span class="math">\\mathbb{F}</span> of sizes <span class="math">l,h</span> respectively (with <span class="math">l\\geq h</span>). Let <span class="math">M</span> be a <span class="math">m_{1}h\\times m_{2}h</span> matrix over <span class="math">\\mathbb{F}</span>, for two positive integers <span class="math">m_{1},m_{2}</span>. Below we describe an RS-encoded IPCP protocol for testing that two given oracles <span class="math">F_{x}\\in\\mathrm{RS}\\left[L,h/l\\right]^{m_{1}}</span> and <span class="math">F_{y}\\in\\mathrm{RS}\\left[L,h/l\\right]^{m_{2}}</span> encode messages <span class="math">x\\in\\mathbb{F}^{m_{1}h}</span> and <span class="math">y\\in\\mathbb{F}^{m_{2}h}</span> such that <span class="math">x=My</span>. This can be viewed as the interleaved analogue of the RS-encoded IOP in Section 6, and is a modification of the “Test-Linear-Constraints-IRS” protocol in <em>[x1]</em> in which the result of the linear transformation is encoded by an oracle rather than being known to the verifier.</p>

    <p class="text-gray-300">The protocol below is summarized in Fig. 12, and implicitly assumes an ordering <span class="math">\\gamma_{H}\\colon H\\to\\{1,\\ldots,h\\}</span> on <span class="math">H</span>. The parameter <span class="math">\\lambda_{\\mathbf{q}}</span> controls the number of query repetitions in the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">V</span> samples random vectors <span class="math">r_{1},\\ldots,r_{m_{1}}\\in\\mathbb{F}^{h}</span> and sends these to <span class="math">P</span>.</li>

      <li>The verifier <span class="math">V</span> and prover <span class="math">P</span> compute:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(s_{1},\\ldots,s_{m_{2}}):=(r_{1},\\ldots,r_{m_{1}})^{\\top}M</span>;</li>

      <li>for <span class="math">i\\in[m_{1}]</span>, the polynomial <span class="math">\\hat{r}_{i}</span> of degree less than <span class="math">h</span> that evaluates to <span class="math">r_{i}\\in\\mathbb{F}^{h}</span> on <span class="math">H</span>;</li>

      <li>for <span class="math">i\\in[m_{2}]</span>, the polynomial <span class="math">\\hat{s}_{i}</span> of degree less than <span class="math">h</span> that evaluates to <span class="math">s_{i}\\in\\mathbb{F}^{h}</span> on <span class="math">H</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">P</span> sends the <span class="math">2h-1</span> coefficients of the polynomial <span class="math">\\hat{p}=\\sum_{i=1}^{m_{1}}\\hat{r}_{i}\\cdot\\hat{f}_{x,i}-\\sum_{i=1}^{m_{2}}\\hat{s}_{i}\\cdot\\hat{f}_{y,i}</span>, where <span class="math">\\hat{f}_{x,i},\\hat{f}_{y,i}</span> are the polynomials of degree less than <span class="math">h</span> corresponding to the <span class="math">i</span>-th row of <span class="math">F_{x},F_{y}</span>.</li>

      <li>The verifier <span class="math">V</span> samples random indices <span class="math">\\alpha_{1},\\ldots,\\alpha_{\\lambda_{\\mathbf{q}}}\\leftarrow L</span>, queries <span class="math">F_{x},F_{y}</span> at <span class="math">\\alpha_{k}</span> for <span class="math">k\\in[\\lambda_{\\mathbf{q}}]</span>, and checks that: (a) <span class="math">\\sum_{\\alpha\\in H}\\hat{p}(\\alpha)=0</span>; (b) <span class="math">\\hat{p}(\\alpha_{k})=\\sum_{i=1}^{m_{1}}\\hat{r}_{i}(\\alpha_{k})\\cdot F_{x}[i,\\alpha_{k}]-\\sum_{i=1}^{m_{2}}\\hat{s}_{i}(\\alpha_{k})\\cdot F_{y}[i,\\alpha_{k}]</span> for all <span class="math">k\\in[\\lambda_{\\mathbf{q}}]</span>.</li>

    </ol>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Completeness. If  <span class="math">x = My</span>  and  <span class="math">P</span>  sends the correct  <span class="math">\\hat{p}</span>  then, letting  <span class="math">r = (r_1, \\ldots, r_{m_1})</span>  and  <span class="math">s = (s_1, \\ldots, s_{m_2})</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {\\alpha \\in H} \\hat {p} (\\alpha) = \\sum_ {\\alpha \\in H} \\left(\\sum_ {i = 1} ^ {m _ {1}} \\hat {r} _ {i} (\\alpha) \\cdot \\hat {f} _ {x, i} (\\alpha) - \\sum_ {i = 1} ^ {m _ {2}} \\hat {s} _ {i} (\\alpha) \\cdot \\hat {f} _ {y, i} (\\alpha)\\right) \\\\ = \\sum_ {i = 1} ^ {m _ {1}} r _ {i} ^ {\\top} x _ {i} - \\sum_ {i = 1} ^ {m _ {2}} s _ {i} ^ {\\top} y _ {i} \\\\ = r ^ {\\top} x - s ^ {\\top} y \\\\ = r ^ {\\top} (M y) - (r ^ {\\top} M) y \\\\ = 0, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">so the verifier's first test passes. Correctness of the second test follows directly from the definition of  <span class="math">\\hat{p}</span> .</p>

    <p class="text-gray-300">Soundness. If  <span class="math">x \\neq My</span> , there is a  <span class="math">1 / \\mathbb{F}</span>  probability over the choice of  <span class="math">r_1, \\ldots, r_{m_1}</span>  that  <span class="math">(r_1, \\ldots, r_{m_1})^\\top x = (r_1, \\ldots, r_{m_1})^\\top My</span> . Letting  <span class="math">\\hat{p}</span>  be the polynomial to be sent by an honest prover, if  <span class="math">(r_1, \\ldots, r_{m_1})^\\top x \\neq (r_1, \\ldots, r_{m_1})^\\top My</span>  then  <span class="math">\\hat{p}</span>  does not sum to 0 over  <span class="math">H</span> . If the polynomial  <span class="math">\\hat{p}&#x27;</span>  actually sent by the prover is equal to  <span class="math">\\hat{p}</span> , then  <span class="math">V</span>  rejects (always). Otherwise, as both are polynomials of degree less than  <span class="math">2h - 1</span> ,  <span class="math">\\hat{p}</span>  and  <span class="math">\\hat{p}&#x27;</span>  agree on at most  <span class="math">2h - 2</span>  points. The verifier accepts only if all of its queries lie in this set.</p>

    <p class="text-gray-300">Efficiency. The prover and the verifier perform matrix multiplication by  <span class="math">M</span> , whose cost depends on the number of nonzero entries in  <span class="math">M</span> . Each also performs interpolations to find the polynomials  <span class="math">\\hat{s}_i</span>  and  <span class="math">\\hat{r}_i</span> . Additionally, the prover finds  <span class="math">\\hat{p}</span>  by evaluating  <span class="math">\\hat{s}_i</span>  and  <span class="math">\\hat{r}_i</span>  over  <span class="math">L</span> , suitably combining these with evaluations of  <span class="math">\\hat{f}_{x,i}</span>  and  <span class="math">\\hat{f}_{y,i}</span> , and interpolating the result. The verifier also evaluates  <span class="math">\\hat{p}</span>  on  <span class="math">H</span>  for its first test, and performs simple arithmetic to check the answer of each of its queries.</p>

    <p class="text-gray-300">Summary. The aforementioned protocol is an RS-encoded IOP with the following parameters.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">communication</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2h-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(m1+m2)λq</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">(ri, rq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(m1h log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, λq log l)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">(εi, εq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, (2h-2/l)λq)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">) + (m1+m2)FFT(F,h) + (m1+m2+1)FFT(F,l) + O((m1+m2)h)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">) + (m1+m2)FFT(F,h) + FFT(F,2h) + O(λq(m1+m2)h)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}</span>  be a field;  <span class="math">L, H</span>  subsets of  <span class="math">\\mathbb{F}</span>  of sizes  <span class="math">l, h</span>  respectively (with  <span class="math">l \\geq h</span> ). Below we describe an RS-encoded IOP protocol for testing that three given oracles  <span class="math">F_x, F_y, F_z \\in \\mathrm{RS}[L, h / l]^m</span>  encode messages  <span class="math">x, y, z \\in \\mathbb{F}^{mh}</span>  such that  <span class="math">x \\circ y = z</span> . This can be viewed as the interleaved analogue of the RS-encoded IOP in Section 4.8, and is a straightforward modification of the "Test-Quadratic-Constraints-IRS" protocol in [AHIV17].</p>

    <p class="text-gray-300">The protocol below is summarized in Fig. 13, and implicitly assumes an ordering  <span class="math">\\gamma_{H}\\colon H\\to \\{1,\\ldots ,h\\}</span>  on  <span class="math">H</span> . The parameter  <span class="math">\\lambda_{\\mathbf{q}}</span>  controls the number of query repetitions in the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">V</span>  samples random  <span class="math">t \\in \\mathbb{F}^m</span>  and sends  <span class="math">t</span>  to  <span class="math">P</span> .</li>

      <li>The prover  <span class="math">P</span>  sends the  <span class="math">2h - 1</span>  coefficients of the polynomial  <span class="math">\\hat{p} = \\sum_{i=1}^{m} t_i \\cdot (\\hat{f}_{x,i} \\cdot \\hat{f}_{y,i} - \\hat{f}_{z,i})</span>  where  <span class="math">\\hat{f}_{x,i}, \\hat{f}_{y,i}, \\hat{f}_{z,i}</span>  are the polynomials of degree less than  <span class="math">h</span>  corresponding to the  <span class="math">i</span> -th row of  <span class="math">F_x, F_y, F_z</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">V</span>  samples indices  <span class="math">\\alpha_{1},\\ldots ,\\alpha_{\\lambda_{\\mathfrak{q}}}\\gets L</span> , queries  <span class="math">F_{x},F_{y},F_{z}</span>  at  <span class="math">\\alpha_{k}</span>  for every  <span class="math">k\\in [\\lambda_{\\mathfrak{q}}]</span> , and checks that: (a)  <span class="math">\\hat{p} (H) = \\{0\\}</span> ; (b)  <span class="math">\\hat{p} (\\alpha_k) = \\sum_{i = 1}^m t_i\\cdot (F_x[i,\\alpha_k]\\cdot F_y[i,\\alpha_k] - F_z[i,\\alpha_k])</span>  for every  <span class="math">k\\in [\\lambda_{\\mathfrak{q}}]</span> .</li>

    </ol>

    <p class="text-gray-300">Completeness. If  <span class="math">x \\circ y = z</span>  and  <span class="math">P</span>  sends the correct  <span class="math">\\hat{p}</span>  then, for every  <span class="math">\\alpha \\in H</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {p} (\\alpha) = \\sum_ {i = 1} ^ {m} t _ {i} \\cdot \\left(\\hat {f} _ {x, i} (\\alpha) \\cdot \\hat {f} _ {y, i} (\\alpha) - \\hat {f} _ {z, i} (\\alpha)\\right) = \\sum_ {i = 1} ^ {m} t _ {i} \\cdot \\left(x _ {i, \\gamma_ {H} (\\alpha)} \\cdot y _ {i, \\gamma_ {H} (\\alpha)} - z _ {i, \\gamma_ {H} (\\alpha)}\\right) = \\sum_ {i = 1} ^ {m} t _ {i} \\cdot 0 = 0,</span></div>

    <p class="text-gray-300">so the verifier's first test passes. Correctness of the second test follows directly from the definition of  <span class="math">\\hat{p}</span> .</p>

    <p class="text-gray-300">Soundness. If  <span class="math">x \\circ y \\neq z</span> , there is a  <span class="math">1 / \\mathbb{F}</span>  probability over the choice of  <span class="math">t</span>  that  <span class="math">t^{\\top}(x \\circ y - z) = 0</span> , where  <span class="math">x, y, z</span>  are viewed as  <span class="math">m \\times h</span>  matrices. Letting  <span class="math">\\hat{p}</span>  be the polynomial to be sent by an honest prover, if  <span class="math">t^{\\top}(x \\circ y - z) \\neq 0</span>  then  <span class="math">\\hat{p}</span>  does not vanish on  <span class="math">H</span> . If the polynomial  <span class="math">\\hat{p}&#x27;</span>  actually sent by the prover is equal to  <span class="math">\\hat{p}</span> , then  <span class="math">V</span>  rejects (always). Otherwise, as both are polynomials of degree less than  <span class="math">2h - 1</span> ,  <span class="math">\\hat{p}</span>  and  <span class="math">\\hat{p}&#x27;</span>  agree on at most  <span class="math">2h - 2</span>  points. The verifier accepts only if all of its queries lie in this set.</p>

    <p class="text-gray-300">Efficiency. The prover obtains  <span class="math">\\hat{p}</span>  by suitably combining evaluations of  <span class="math">\\hat{f}_{x,i},\\hat{f}_{y,i},\\hat{f}_{z,i}</span>  and then interpolating. The verifier evaluates  <span class="math">\\hat{p}</span>  on  <span class="math">H</span>  for its first test, and performs simple arithmetic to check answers to its queries.</p>

    <p class="text-gray-300">Summary. The aforementioned protocol is an RS-encoded IOP with the following parameters.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">communication</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2h-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">3mλq</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">(ri, rq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(mh log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, λq log l)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">(εi, εq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, (2h-2l)λq)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">FFT(F, l) + O(ml)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">FFT(F, 2h) + O(λqm)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe an RS-encoded IPCP protocol for the R1CS relation (see Definition 7.1). This can be viewed as an interleaved analogue of the RS-encoded IOP for R1CS in Section 7, and is a modification of the IPCP for arithmetic circuits in [AHIV17] to work for R1CS.</p>

    <p class="text-gray-300">Let  <span class="math">(\\mathbb{F},k,n,m,A,B,C,v)</span>  be an R1CS instance and  <span class="math">w</span>  a witness for it. The prover and verifier receive the instance as input, and the prover additionally receives the witness as input. Define  <span class="math">z\\coloneqq (1,v,w)\\in \\mathbb{F}^{n + 1}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">L, H</span>  be disjoint subsets of  <span class="math">\\mathbb{F}</span>  of sizes  <span class="math">l, h</span>  respectively (with  <span class="math">l \\geq h</span> ) and let  <span class="math">m_2, m_1</span>  be integers such that  <span class="math">m_1h = m</span>  and  <span class="math">m_2h = 1 + n</span> . Let  <span class="math">b</span>  be the query bound for zero knowledge.</p>

    <p class="text-gray-300">The protocol below is summarized in Fig. 14, and implicitly assumes an ordering  <span class="math">\\gamma_{H} \\colon H \\to \\{1, \\ldots, h\\}</span>  on  <span class="math">H</span> . The parameter  <span class="math">\\lambda_{i}</span>  controls the number of repetitions of the sub-protocols, and  <span class="math">\\lambda_{q}</span>  controls the number of query repetitions in the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Oracle: The prover  <span class="math">P</span>  sends an oracle  <span class="math">F \\in \\mathrm{RS}\\left[L, \\hat{\\rho}\\right]^{m_2 + 3m_1 + 4\\lambda_i}</span>  that is computed as follows.</li>

    </ul>

    <p class="text-gray-300">Extend the witness  <span class="math">w \\in \\mathbb{F}^{n - k}</span>  to  <span class="math">\\overline{w} \\coloneqq (0^{1 + k}, w) \\in \\mathbb{F}^{1 + n}</span> , and sample a random codeword  <span class="math">F_{\\overline{w}} \\in \\mathrm{RS}\\left[L, \\frac{h + b}{l}\\right]^{m_2}</span>  such that the evaluation over  <span class="math">H</span>  of the interpolation of the  <span class="math">i</span> -th row of  <span class="math">F_{\\overline{w}}</span>  is the  <span class="math">i</span> -th block of  <span class="math">h</span>  entries in  <span class="math">\\overline{w}</span>  (note that  <span class="math">1 + n = m_2h</span> ). Compute vectors  <span class="math">a \\coloneqq Az, b \\coloneqq Bz, c \\coloneqq Cz \\in \\mathbb{F}^m</span> , and sample random codewords  <span class="math">F_a, F_b, F_c \\in \\mathrm{RS}\\left[L, \\frac{h + b}{l}\\right]^{m_1}</span>  such that the evaluation over  <span class="math">H</span>  of the interpolation of the  <span class="math">i</span> -th row of  <span class="math">F_a, F_b, F_c</span>  is the  <span class="math">i</span> -th block of  <span class="math">h</span>  entries in  <span class="math">a, b, c</span>  respectively (note that  <span class="math">m = m_1h</span> ). For</p>

    <p class="text-gray-300">every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, sample random codewords <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c} \\in \\mathrm{RS}\\left[L, \\frac{2h + b - 1}{l}\\right]</span> such that each of <span class="math">\\hat{q}_{\\iota}^{a}, \\hat{q}_{\\iota}^{b}, \\hat{q}_{\\iota}^{c}</span> sums to zero on <span class="math">H</span>, and random codeword <span class="math">q_{\\iota}^{\\mathrm{ROW}} \\in \\mathrm{RS}\\left[L, \\frac{2h + 2b - 1}{l}\\right]</span> such that <span class="math">\\hat{q}_{\\iota}^{\\mathrm{ROW}}</span> vanishes everywhere on <span class="math">H</span>. The oracle <span class="math">F</span> is the vertical juxtaposition of <span class="math">F_{\\overline{w}}, F_{a}, F_{b}, F_{c}</span> as well as <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}}</span>. Note that each codeword in <span class="math">F_{\\overline{w}}, F_{a}, F_{b}, F_{c}</span> is <span class="math">\\mathsf{b}</span>-wise independent (because of the way they are sampled), and thus any set of <span class="math">\\mathsf{b}</span> evaluations are uniformly distributed (in particular, they reveal no information about <span class="math">w, a, b, c</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The interactive protocol:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">P</span> and verifier <span class="math">V</span> extend the public input <span class="math">v</span> to <span class="math">\\overline{v} := (1, v, 0^{n - k})</span>, and compute the codeword <span class="math">F_{\\overline{v}} \\in \\mathrm{RS}\\left[L, \\frac{h}{l}\\right]^{m_2}</span> such that the evaluation over <span class="math">H</span> of the interpolation of the <span class="math">i</span>-th row of <span class="math">F_{\\overline{v}}</span> is the <span class="math">i</span>-th block of <span class="math">h</span> entries in <span class="math">\\overline{v}</span> (note that <span class="math">1 + n = m_2 h</span>). By linearity, <span class="math">F_{\\overline{v}} + F_{\\overline{w}}</span> encodes <span class="math">z = (1, v, w) \\in \\mathbb{F}^{n+1}</span>.</li>

      <li>For every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, <span class="math">V</span> samples vectors <span class="math">r_{\\iota,1}, \\ldots, r_{\\iota,m_1} \\gets \\mathbb{F}^h</span> (for lincheck) and <span class="math">t_\\iota \\in \\mathbb{F}^{m_1}</span> (for rowcheck).</li>

      <li>For every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, the prover <span class="math">P</span> and verifier <span class="math">V</span> compute several vectors:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (s _ {\\iota , 1} ^ {a}, \\dots , s _ {\\iota , m _ {2}} ^ {a}) := (r _ {\\iota , 1}, \\dots , r _ {\\iota , m _ {1}}) ^ {\\top} A, \\\\ (s _ {\\iota , 1} ^ {b}, \\dots , s _ {\\iota , m _ {2}} ^ {b}) := (r _ {\\iota , 1}, \\dots , r _ {\\iota , m _ {1}}) ^ {\\top} B, \\\\ (s _ {\\iota , 1} ^ {c}, \\dots , s _ {\\iota , m _ {2}} ^ {c}) := (r _ {\\iota , 1}, \\dots , r _ {\\iota , m _ {1}}) ^ {\\top} C. \\end{array}</span></div>

    <p class="text-gray-300">They also find the polynomial <span class="math">\\hat{r}_{\\iota,i}</span> of degree less than <span class="math">h</span> that evaluates to <span class="math">r_{\\iota,i}</span> on <span class="math">H</span> (for <span class="math">i \\in [m_1]</span>), and the polynomials <span class="math">\\hat{s}_{\\iota,i}^a, \\hat{s}_{\\iota,i}^b, \\hat{s}_{\\iota,i}^c</span> of degree less than <span class="math">h</span> that evaluate to <span class="math">s_{\\iota,i}^a, s_{\\iota,i}^b, s_{\\iota,i}^c</span> on <span class="math">H</span> (for <span class="math">i \\in [m_2]</span>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, <span class="math">P</span> responds with (the coefficients of) several polynomials:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">\\diamond \\in \\{a, b, c\\}</span>, a lincheck polynomial <span class="math">\\hat{p}_{\\iota}^{\\diamond}</span> of degree less than <span class="math">2h + \\mathsf{b} - 1</span> defined as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\hat {p} _ {\\iota} ^ {\\diamond} := \\hat {q} _ {\\iota} ^ {\\diamond} + \\sum_ {i = 1} ^ {m _ {1}} \\hat {r} _ {\\iota , i} \\cdot \\hat {f} _ {\\diamond , i} - \\sum_ {i = 1} ^ {m _ {2}} \\hat {s} _ {\\iota , i} ^ {\\diamond} \\cdot (\\hat {f} _ {\\overline {{v}}, i} + \\hat {f} _ {\\overline {{w}}, i})</span></div>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{f}_{\\diamond ,i}</span> is the polynomial of degree less than <span class="math">h + \\mathsf{b}</span> that interpolates the <span class="math">i</span>-th row of <span class="math">F_{\\diamond}</span> (for <span class="math">i \\in [m_1]</span>);</li>

      <li><span class="math">\\hat{f}_{\\overline{v},i}</span> is the polynomial of degree less than <span class="math">h + \\mathsf{b}</span> that interpolates the <span class="math">i</span>-th row of <span class="math">F_{\\overline{v}}</span> (for <span class="math">i \\in [m_2]</span>);</li>

      <li><span class="math">\\hat{f}_{\\overline{w},i}</span> is the polynomial of degree less than <span class="math">h + \\mathsf{b}</span> that interpolates the <span class="math">i</span>-th row of <span class="math">F_{\\overline{w}}</span> (for <span class="math">i \\in [m_2]</span>).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A rowcheck polynomial <span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}}</span> of degree less than <span class="math">2h + 2\\mathsf{b} - 1</span> defined as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\hat {p} _ {\\iota} ^ {\\mathrm {R O W}} := \\hat {q} _ {\\iota} ^ {\\mathrm {R O W}} + \\sum_ {i = 1} ^ {m _ {1}} t _ {\\iota , i} \\cdot (\\hat {f} _ {a, i} \\cdot \\hat {f} _ {b, i} - \\hat {f} _ {c, i})</span></div>

    <p class="text-gray-300">where <span class="math">\\{\\hat{f}_{a,i},\\hat{f}_{b,i},\\hat{f}_{c,i}\\}</span> are the polynomials of degree less than <span class="math">h + \\mathsf{b}</span> that interpolate the <span class="math">i</span>-th row of <span class="math">\\{F_a,F_b,F_c\\}</span> respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">V</span> samples random indices <span class="math">\\alpha_{1},\\ldots ,\\alpha_{\\lambda_{\\mathfrak{q}}}\\gets L</span> and, for every <span class="math">k\\in [\\lambda_{\\mathfrak{q}}]</span>, queries <span class="math">F</span> at <span class="math">\\alpha_{k}</span> thereby obtaining</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F [ \\alpha_ {k} ] = (F _ {\\overline {{w}}} [ \\alpha_ {k} ], F _ {a} [ \\alpha_ {k} ], F _ {b} [ \\alpha_ {k} ], F _ {c} [ \\alpha_ {k} ], q _ {\\iota} ^ {a} [ \\alpha_ {k} ], q _ {\\iota} ^ {b} [ \\alpha_ {k} ], q _ {\\iota} ^ {c} [ \\alpha_ {k} ], q _ {\\iota} ^ {\\mathrm {R O W}} [ \\alpha_ {k} ]) .</span></div>

    <p class="text-gray-300">The verifier <span class="math">V</span> accepts if and only if for every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span> the following tests pass.</p>

    <p class="text-gray-300">52</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lincheck tests. For every <span class="math">\\diamond \\in \\{a, b, c\\}</span>, <span class="math">\\sum_{\\alpha \\in H} \\hat{p}_{\\iota}^{\\diamond}(\\alpha) = 0</span> and for every <span class="math">k \\in [\\lambda_{\\mathbf{q}}]</span> it holds that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\hat {p} _ {\\iota} ^ {\\diamond} (\\alpha_ {k}) = q _ {\\iota} ^ {\\diamond} [ \\alpha_ {k} ] + \\sum_ {i = 1} ^ {m _ {1}} \\hat {r} _ {\\iota , i} (\\alpha_ {k}) \\cdot F _ {\\diamond} [ i, \\alpha_ {k} ] - \\sum_ {i = 1} ^ {m _ {2}} \\hat {s} _ {\\iota , i} ^ {\\diamond} (\\alpha_ {k}) \\cdot \\left(F _ {\\overline {{v}}} [ i, \\alpha_ {k} ] + F _ {\\overline {{w}}} [ i, \\alpha_ {k} ]\\right).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rowcheck test. <span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}}(H) = \\{0\\}</span> and for every <span class="math">k \\in [\\lambda_{\\mathbf{q}}]</span> it holds that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\hat {p} _ {\\iota} ^ {\\mathrm {R O W}} (\\alpha_ {k}) = q _ {\\iota} ^ {\\mathrm {R O W}} [ \\alpha_ {k} ] + \\sum_ {i = 1} ^ {m _ {1}} t _ {\\iota , i} \\cdot (F _ {a} [ i, \\alpha_ {k} ] \\cdot F _ {b} [ i, \\alpha_ {k} ] - F _ {c} [ i, \\alpha_ {k} ]) .</span></div>

    <p class="text-gray-300"><strong>Completeness.</strong> If <span class="math">w</span> is in fact a satisfying witness for the R1CS instance, and the prover is honest, then the rowcheck and lincheck correctness tests pass, by arguments analogous to those made for the previous two protocols. The masking codewords <span class="math">\\{q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}}\\}_{\\iota \\in [\\lambda_{\\mathrm{i}}]}</span> are chosen so that completeness is unaffected.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Soundness.</strong> Assume that the R1CS instance is not satisfiable. Let <span class="math">\\tilde{F}</span> be the codeword sent by the prover. Let <span class="math">\\tilde{w}</span> be the candidate witness encoded in <span class="math">\\tilde{F}</span>; note that <span class="math">A\\tilde{z} \\circ B\\tilde{z} \\neq C\\tilde{z}</span> where <span class="math">\\tilde{z} = (1, v, \\tilde{w})</span>. Let <span class="math">\\tilde{a}, \\tilde{b}, \\tilde{c}</span> be the alleged linear transformations of <span class="math">\\tilde{z}</span> encoded in <span class="math">\\tilde{F}</span>. One of the following equations cannot hold: <span class="math">\\tilde{a} = A\\tilde{z}, \\tilde{b} = B\\tilde{z}, \\tilde{c} = C\\tilde{z}, \\tilde{a} \\circ \\tilde{b} = \\tilde{c}</span>. If one of the first three equations fails to hold, the corresponding lincheck sub-protocol will reject with high probability; if the last equation fails to hold, the rowcheck sub-protocol will reject with high probability. The interactive phase of each of these sub-protocols is repeated <span class="math">\\lambda_{\\mathrm{i}}</span> times, bringing the corresponding soundness error down from $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\lambda_{\\mathrm{i}}}<span class="math">; the subsequent query phase is repeated </span>\\lambda_{\\mathbf{q}}<span class="math"> times, bringing the corresponding soundness error down from </span>\\frac{2h + 2\\mathbf{b} - 2}{l}<span class="math"> to </span>(\\frac{2h + 2\\mathbf{b} - 2}{l})^{\\lambda_{\\mathbf{q}}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the masking codewords <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}}</span> do not affect soundness, as we now explain. In the "no" case for the lincheck protocol, the summation <span class="math">\\sum_{\\alpha \\in H} \\hat{p}(\\alpha)</span> is uniform over <span class="math">\\mathbb{F}</span>. In the "no" case for the rowcheck protocol, there exists some <span class="math">\\alpha \\in H</span> such that <span class="math">\\hat{p}(\\alpha)</span> is uniform over <span class="math">\\mathbb{F}</span>. Thus in both cases, regardless of the (possibly malicious) choice of mask the probability that the verifier accepts remains $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Zero knowledge.</strong> We construct a probabilistic simulator <span class="math">S</span> that, given as input a satisfiable R1CS instance <span class="math">(\\mathbb{F}, k, n, m, A, B, C, v)</span> and straightline access to a b-query malicious verifier <span class="math">\\tilde{V}</span>, outputs a view that is identically distributed as <span class="math">\\tilde{V}</span>'s view when interacting with an honest prover.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the public input <span class="math">v</span> to compute <span class="math">F_{\\overline{v}} \\in \\mathrm{RS}\\left[L, \\frac{h}{l}\\right]^{m_2}</span> like the honest prover does.</li>

      <li>Sample <span class="math">F_{\\overline{w}} \\in (\\mathbb{F}^L)^{m_2}</span> and <span class="math">F_a, F_b, F_c \\in (\\mathbb{F}^L)^{m_1}</span> uniformly at random. For every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, sample <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c} \\in \\mathrm{RS}\\left[L, \\frac{2h + \\mathbf{b} - 1}{l}\\right]</span> uniformly at random given that the interpolation of <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}</span> sums to zero on <span class="math">H</span>. For every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, sample <span class="math">q_{\\iota}^{\\mathrm{ROW}} \\in \\mathrm{RS}\\left[L, \\frac{2h + 2\\mathbf{b} - 1}{l}\\right]</span> uniformly at random given that its interpolation vanishes everywhere on <span class="math">H</span>. Set <span class="math">F = (F_{\\overline{w}}, F_a, F_b, F_c, q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}})</span>, and start simulating <span class="math">\\tilde{V}</span>.</li>

      <li>Use <span class="math">F</span> to answer any queries by <span class="math">\\tilde{V}</span>. Let <span class="math">Q \\subseteq L</span> be the queries asked by <span class="math">\\tilde{V}</span> until the next step.</li>

      <li>Receive a challenge <span class="math">\\{r_{\\iota,1}, \\ldots, r_{\\iota,m_1}, t_\\iota\\}_{\\iota \\in [\\lambda_i]}</span> from <span class="math">\\tilde{V}</span>.</li>

      <li>For every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, sample <span class="math">\\hat{p}_{\\iota}^{a}, \\hat{p}_{\\iota}^{b}, \\hat{p}_{\\iota}^{c} \\in \\mathrm{RS}\\left[L, \\frac{2h + \\mathbf{b} - 1}{l}\\right]</span> uniformly at random such that each of <span class="math">\\hat{p}_{\\iota}^{a}, \\hat{p}_{\\iota}^{b}, \\hat{p}_{\\iota}^{c}</span> sums to 0 on <span class="math">H</span> and, for every <span class="math">\\alpha \\in Q</span>, the following hold:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{p}_{\\iota}^{a}(\\alpha) = \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{a}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{a}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha]) - q_{\\iota}^{a}[\\alpha]</span>,</li>

      <li><span class="math">\\hat{p}_{\\iota}^{b}(\\alpha) = \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{b}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{b}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha]) - q_{\\iota}^{b}[\\alpha]</span>,</li>

      <li><span class="math">\\hat{p}_{\\iota}^{c}(\\alpha) = \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{c}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{c}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha]) - q_{\\iota}^{c}[\\alpha]</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span>, sample <span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}} \\in \\mathrm{RS}\\left[L, \\frac{2h + 2\\mathbf{b} - 1}{l}\\right]</span> uniformly at random such that <span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}}</span> evaluates to 0 everywhere on <span class="math">H</span>, and, for every <span class="math">\\alpha \\in Q</span>, the following holds:</li>

    </ol>

    <p class="text-gray-300">53</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}}(\\alpha) = \\sum_{i=1}^{m_1} t_{\\iota,i} \\cdot (F_a[i,\\alpha] \\cdot F_b[i,\\alpha] - F_c[i,\\alpha]) - q_{\\iota}^{\\mathrm{ROW}}[\\alpha]</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send  <span class="math">\\{\\hat{p}_i^a,\\hat{p}_i^b,\\hat{p}_i^c,\\hat{p}_i^{\\mathrm{ROW}}\\}_{\\iota \\in [\\lambda_i]}</span>  to  <span class="math">\\tilde{V}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Answer any query  <span class="math">\\alpha \\in L</span>  by  <span class="math">\\tilde{V}</span>  by using  <span class="math">F_{\\overline{w}}, F_a, F_b, F_c</span>  (as before) but for  <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}}</span>  use:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">q_{\\iota}^{a}[\\alpha] = \\hat{p}_{\\iota}^{a}(\\alpha) - \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{a}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{a}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha])</span> ,</li>

      <li><span class="math">q_{\\iota}^{b}[\\alpha] = \\hat{p}_{\\iota}^{b}(\\alpha) - \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{b}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{b}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha])</span> ,</li>

      <li><span class="math">q_{\\iota}^{c}[\\alpha] = \\hat{p}_{\\iota}^{c}(\\alpha) - \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{c}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{c}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha])</span> ,</li>

      <li><span class="math">q_{\\iota}^{\\mathrm{ROW}}[\\alpha] = \\hat{p}_{\\iota}^{\\mathrm{ROW}}(\\alpha) - \\sum_{i=1}^{m_1} t_{\\iota,i} \\cdot (F_a[i,\\alpha] \\cdot F_b[i,\\alpha] - F_c[i,\\alpha])</span> .</li>

    </ul>

    <p class="text-gray-300">To see that the view of  <span class="math">\\tilde{V}</span>  is perfectly simulated, we consider a hybrid experiment in which a "hybrid prover" sends actual codewords for the blinding vectors (like the honest prover in the real world) but can modify messages after they are sent (like the simulator in the ideal world).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the public input  <span class="math">v</span>  to compute  <span class="math">F_{\\overline{v}} \\in \\mathrm{RS}\\left[L, \\frac{h}{l}\\right]^{m_2}</span>  like the honest prover does.</li>

      <li>Sample  <span class="math">F_{\\overline{w}} \\in (\\mathbb{F}^L)^{m_2}</span>  and  <span class="math">F_a, F_b, F_c \\in (\\mathbb{F}^L)^{m_1}</span>  uniformly at random. For every  <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span> , sample  <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c} \\in \\mathrm{RS}\\left[L, \\frac{2h + b - 1}{l}\\right]</span>  uniformly at random given that the interpolation of  <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}</span>  sums to zero on  <span class="math">H</span> . For every  <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span> , sample  <span class="math">q_{\\iota}^{\\mathrm{ROW}} \\in \\mathrm{RS}\\left[L, \\frac{2h + 2b - 1}{l}\\right]</span>  uniformly at random given that its interpolation vanishes everywhere on  <span class="math">H</span> . Set  <span class="math">F = (F_{\\overline{w}}, F_a, F_b, F_c, q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}})</span> , and start simulating  <span class="math">\\tilde{V}</span> .</li>

      <li>Use  <span class="math">F</span>  to answer any queries by  <span class="math">\\tilde{V}</span> . Let  <span class="math">Q \\subseteq L</span>  be the queries asked by  <span class="math">\\tilde{V}</span>  until the next step.</li>

      <li>Receive a challenge  <span class="math">\\{r_{\\iota,1}, \\ldots, r_{\\iota,m_1}, t_\\iota\\}_{\\iota \\in [\\lambda_i]}</span>  from  <span class="math">\\tilde{V}</span> .</li>

      <li>For every  <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span> , sample  <span class="math">\\hat{p}_{\\iota}^{a}, \\hat{p}_{\\iota}^{b}, \\hat{p}_{\\iota}^{c} \\in \\mathrm{RS}\\left[L, \\frac{2h + b - 1}{l}\\right]</span>  uniformly at random such that each of  <span class="math">\\hat{p}_{\\iota}^{a}, \\hat{p}_{\\iota}^{b}, \\hat{p}_{\\iota}^{c}</span>  sums to 0 on  <span class="math">H</span>  and, for every  <span class="math">\\alpha \\in Q</span> , the following hold:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{p}_{\\iota}^{a}(\\alpha) = \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{a}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{a}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha]) - q_{\\iota}^{a}[\\alpha]</span> ,</li>

      <li><span class="math">\\hat{p}_{\\iota}^{b}(\\alpha) = \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{b}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{b}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha]) - q_{\\iota}^{b}[\\alpha]</span> ,</li>

      <li><span class="math">\\hat{p}_{\\iota}^{c}(\\alpha) = \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{c}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{c}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha]) - q_{\\iota}^{c}[\\alpha]</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every  <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span> , sample  <span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}} \\in \\mathrm{RS}\\left[L, \\frac{2h + 2b - 1}{l}\\right]</span>  uniformly at random such that  <span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}}</span>  evaluates to 0 everywhere on  <span class="math">H</span> , and, for every  <span class="math">\\alpha \\in Q</span> , the following hold:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{p}_{\\iota}^{\\mathrm{ROW}}(\\alpha) = \\sum_{i=1}^{m_1} t_{\\iota,i} \\cdot (F_a[i,\\alpha] \\cdot F_b[i,\\alpha] - F_c[i,\\alpha]) - q_{\\iota}^{\\mathrm{ROW}}[\\alpha]</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send  <span class="math">\\{\\hat{p}_{\\iota}^{a},\\hat{p}_{\\iota}^{b},\\hat{p}_{\\iota}^{c},\\hat{p}_{\\iota}^{\\mathrm{ROW}}\\}_{\\iota \\in [\\lambda_{\\mathrm{i}}]}</span>  to  <span class="math">\\tilde{V}</span> .</li>

      <li>For every  <span class="math">\\iota \\in [\\lambda_{\\mathrm{i}}]</span> , replace  <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}}</span>  with the following codewords respectively:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\hat{p}_{\\iota}^{a}(\\alpha) - \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{a}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{a}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha])\\}_{\\alpha \\in L}</span> ;</li>

      <li><span class="math">\\{\\hat{p}_{\\iota}^{b}(\\alpha) - \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{b}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{b}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha])\\}_{\\alpha \\in L}</span> ;</li>

      <li><span class="math">\\{\\hat{p}_{\\iota}^{c}(\\alpha) - \\sum_{i=1}^{m_{1}} \\hat{r}_{\\iota,i}(\\alpha) \\cdot F_{c}[i,\\alpha] + \\sum_{i=1}^{m_{2}} \\hat{s}_{\\iota,i}^{c}(\\alpha) \\cdot (F_{\\overline{v}}[i,\\alpha] + F_{\\overline{w}}[i,\\alpha])\\}_{\\alpha \\in L}</span> ;</li>

      <li><span class="math">\\{\\hat{p}_{\\iota}^{\\mathrm{ROW}}(\\alpha) - \\sum_{i=1}^{m_1} t_{\\iota,i} \\cdot (F_a[i,\\alpha] \\cdot F_b[i,\\alpha] - F_c[i,\\alpha])\\}_{\\alpha \\in L}</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finish simulating the interaction with  <span class="math">\\tilde{V}</span> .</li>

    </ol>

    <p class="text-gray-300">The distribution of  <span class="math">\\tilde{V}</span> 's view in the real protocol is identical to the distribution of  <span class="math">\\tilde{V}</span> 's view in the above experiment. In particular, since  <span class="math">\\tilde{V}</span>  makes at most  <span class="math">b</span>  queries, the answers to its queries to  <span class="math">F_{a}, F_{b}, F_{c}, F_{\\overline{w}}</span>  are uniformly random in the real world, and hence are perfectly simulated, and it is easy to check that its queries to  <span class="math">q_{\\iota}^{a}, q_{\\iota}^{b}, q_{\\iota}^{c}, q_{\\iota}^{\\mathrm{ROW}}</span>  after their replacement by the new values have the correct distribution. Moreover, it is not hard to see that  <span class="math">\\tilde{V}</span> 's view in the above experiment and  <span class="math">S</span> 's output are identically distributed.</p>

    <p class="text-gray-300">Efficiency. Both the prover and the verifier perform matrix multiplications, which take time proportional to the number of non-zero elements of the matrices. The prover also performs  <span class="math">O(m_2 + m_1 + \\lambda_{\\mathrm{i}})</span>  FFTs</p>

    <p class="text-gray-300">over the systematic subspace  <span class="math">H</span>  (of size  <span class="math">h \\leq l</span> ) and the codeword subspace  <span class="math">L</span>  (of size  <span class="math">l</span> ) to construct the codewords in  <span class="math">F</span>  and, later, also to construct the response polynomials. The verifier performs FFTs to evaluate the four response polynomials over  <span class="math">H</span> ; then, after interpolating its challenges, the verifier also performs  <span class="math">O((m_2 + m_1)h)</span>  field operations for each interactive repetition and each query.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Summary. The aforementioned protocol is an RS-encoded IOP with the following parameters. One should think of  <span class="math">m_{1}, m_{2}, h</span>  as on the order of square root of the number of constraints/variables in the R1CS instance. To achieve soundness  <span class="math">2^{-\\lambda}</span> , we can set  $\\lambda_{\\mathrm{i}} := \\lfloor \\lambda / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rfloor + 1<span class="math">  and  </span>\\lambda_{\\mathbf{q}} := \\lfloor \\lambda / \\log \\left( \\frac{l}{2h + 2\\mathbf{b} - 2} \\right) \\rfloor + 1$  for example.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">number of rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">oracle length</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(m2+3m1+4λi)l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">communication</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">4λi(8h+5b-4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">(m2+3m1+4λi)λq</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">(ri, rq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">((m1+1)hλi log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, λq log l)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">(εi, εq)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">((1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)λi, (2h+2b-2/l)λq)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">) + O(m2+m1+λi)FFT(F, l)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">) + O(m2+m1+λi)FFT(F, l) + O(λiλq(m2+m1)h)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The IPCP for R1CS described in the prior section is RS-encoded because soundness assumes that the oracle sent by the prover is an interleaved Reed-Solomon codeword (a list of Reed-Solomon codewords over the same domain). Such a protocol can be transformed into a (regular) IPCP for R1CS by generically combining it with any low-degree test, as described in Section 8 for example. Informally, the verifier tests that a suitable linear combination of words in the oracle is close to the Reed-Solomon code. The low-degree test that we use here is the direct one, namely, the prover sends, as a message, the coefficients of the polynomial that interpolates the linear combination, and the verifier probabilistically checks that this polynomial is consistent with the oracle; this subroutine corresponds to the "Test-Interleaved" protocol in [AHIV17].</p>

    <p class="text-gray-300">This compilation has an impact on several parameters, which we now sketch. Let  <span class="math">\\lambda_{\\mathrm{i}}^{\\mathrm{LDT}}</span>  denote the number of linear combinations that the verifier considers, and let  <span class="math">\\lambda_{\\mathbf{q}}^{\\mathrm{LDT}}</span>  denote the number of times that the verifier repeats the consistency check. Let  <span class="math">\\ell \\coloneqq m_2 + 3m_1 + 4\\lambda_{\\mathrm{i}}</span>  be the number of words in the oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Randomness complexity in the interactive phase increases by  $\\lambda_{\\mathrm{i}}^{\\mathrm{LDT}}\\ell \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and in the query phase by  </span>\\lambda_{\\mathbf{q}}^{\\mathrm{LDT}}\\log l<span class="math"> ; query complexity increases by  </span>\\ell \\lambda_{\\mathbf{q}}^{\\mathrm{LDT}}<span class="math"> ; communication complexity increases by the maximum degree (plus 1) across all words. Soundness error in the interactive phase increases by  </span>(\\frac{l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{\\lambda_{\\mathrm{i}}^{\\mathrm{LDT}}}<span class="math">  (this is a fairly coarse bound) and soundness error in the query phase becomes  </span>(\\varepsilon_{\\mathbf{q}} + \\delta^{\\mathrm{LDT}})^{\\lambda_{\\mathbf{q}}} + (1 - \\delta^{\\mathrm{LDT}})^{\\lambda_{\\mathbf{q}}^{\\mathrm{LDT}}}<span class="math">  for any proximity parameter  </span>\\delta^{\\mathrm{LDT}} &lt; \\frac{1 - \\rho}{4}<span class="math">  (where  </span>\\rho \\coloneqq \\frac{2h + 2b - 1}{l}<span class="math">  is the maximum codeword rate). The choice of  </span>\\delta^{\\mathrm{LDT}}$  balances the probability of a non-codeword oracle being caught by the low-degree test with its ability to cheat on the protocol's tests; an optimal value, to minimize overall soundness error, can be found numerically for given choices of the other parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 12: Diagram of the interleaved lincheck protocol.</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 13: Diagram of the interleaved rowcheck protocol.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Figure 14: Diagram of the interleaved R1CS protocol.</p>

    <p class="text-gray-300">C Additional comparisons</p>

    <p class="text-gray-300">We provide additional comparisons across Ligero, Stark, and Aurora: in Appendix C.1 we compare the low-degree tests that they rely on, and in Appendix C.2 we compare their underlying IOP protocols.</p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">C.1 Comparison of the LDTs in Ligero, Stark, and Aurora</h3>

    <p class="text-gray-300">A key ingredient in Ligero <em>[x1]</em>, Stark <em>[x3]</em>, and Aurora (this work) are low-degree tests (LDTs). Formally, each of these systems relies on an IOPP for the Reed–Solomon relation (see Section 4.5.1). The LDT is then generically “lifted” to an LDT for the interleaved Reed–Solomon code (see Section 4.1), by taking a random linear combination as in Section 8. Below (and in Fig. 15) we discuss aspects of the LDTs underlying these systems that are important in the comparison in Appendix C.2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Direct LDT. Ligero uses a direct LDT: the verifier is given oracle access to a function <span class="math">f\\colon L\\to\\mathbb{F}</span>, receives from the prover $a_{0},\\ldots,a_{\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}\\in\\mathbb{F}<span class="math"> (allegedly, coefficients of the polynomial </span>\\hat{f}<span class="math"> obtained by interpolating </span>f<span class="math">), and checks that </span>f<span class="math"> and </span>\\sum_{i=0}^{\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}a_{i}X^{i}<span class="math"> agree at a random point of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If </span>f<span class="math"> is </span>\\delta<span class="math">-far from </span>\\operatorname{RS}[L,\\rho]<span class="math"> then the verifier accepts with probability at most </span>1-\\delta<span class="math">. This probability can be reduced to </span>(1-\\delta)^{t}<span class="math"> via </span>t<span class="math"> independent checks. Overall, the verifier queries </span>f<span class="math"> at </span>t<span class="math"> points, and reads </span>\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> field elements sent by the prover. One should think of </span>t<span class="math"> as much less than </span>\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, which facilitates lifting to an LDT for the interleaved Reed–Solomon code.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FRI LDT. Stark and Aurora use FRI <em>[x3]</em>, a LDT in which the verifier is given oracle access to a function <span class="math">f\\colon L\\to\\mathbb{F}</span> and, in each of a sequence of rounds, sends a random field element to the prover, who replies with an oracle; at the end of the interaction, the verifier makes a certain number of queries to <span class="math">f</span> and the oracles, and then either accepts or rejects. (The domain <span class="math">L</span> here is an additive or multiplicative coset in <span class="math">\\mathbb{F}</span> whose order is a power of <span class="math">2</span>.) In more detail, given a localization parameter <span class="math">\\eta\\in\\mathbb{N}</span>, the number of rounds is $\\frac{\\log\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\eta}<span class="math">, and in the </span>i<span class="math">-th round the prover sends an oracle over a domain of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^{i\\eta}<span class="math">; thus, the total number of elements sent across all oracles is less than </span>\\sum_{i=1}^{\\infty}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^{i\\eta}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(2^{\\eta}+1)<span class="math">. After the interaction, the verifier queries </span>f<span class="math"> at a point, and every other oracle at </span>2^{\\eta}-1<span class="math"> points; given the corresponding answers, the verifier performs </span>O(2^{\\eta}\\log\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> arithmetic operations, and then accepts or rejects. If </span>f<span class="math"> is </span>\\delta<span class="math">-far from </span>\\operatorname{RS}[L,\\rho]<span class="math"> then the verifier, with probability at most </span>\\varepsilon^{\\text{\\tiny FRI}}_{i}(\\mathbb{F},L)<span class="math"> over its random messages to the prover, will accept with probability greater than </span>\\varepsilon^{\\text{\\tiny FRI}}_{\\mathbf{q}}(L,\\rho,\\delta)<span class="math">. In <em>[x3]</em> it is proved that </span>\\varepsilon^{\\text{\\tiny FRI}}_{i}(\\mathbb{F},L)=3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\varepsilon^{\\text{\\tiny FRI}}_{\\mathbf{q}}(L,\\rho,\\delta)=1-\\min\\{\\delta,(1-3\\rho-2^{\\eta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/2})/4\\}<span class="math">. In <em>[x1]</em> this was improved to </span>\\varepsilon^{\\text{\\tiny FRI}}_{i}(\\mathbb{F},L)=2\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\epsilon^{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\varepsilon^{\\text{\\tiny FRI}}_{\\mathbf{q}}(L,\\rho,\\delta)=1-\\min\\{\\delta,J_{\\epsilon}(J_{\\epsilon}(1-\\rho))\\}+\\epsilon\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for any </span>\\epsilon>0<span class="math">, where </span>J_{\\epsilon}(x):=1-\\sqrt{1-x(1-\\epsilon)}<span class="math">. In <em>[x3]</em> it is conjectured that the best possible values are </span>\\varepsilon^{\\text{\\tiny FRI}}_{i}(\\mathbb{F},L)=2^{\\eta}\\log^{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/\\epsilon\\eta^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\varepsilon^{\\text{\\tiny FRI}}_{\\mathbf{q}}(L,\\rho,\\delta)=1-\\delta(1-\\epsilon)<span class="math"> for any </span>\\epsilon>0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">C.2 Comparison of the IOPs in Ligero, Stark, and Aurora</h3>

    <p class="text-gray-300">Each of Ligero <em>[x1]</em>, Stark <em>[x3]</em>, and Aurora (this work) is an IOP (satisfying zero knowledge and proof of knowledge) that is compiled into a zkSNARK via a transformation of Ben-Sasson et al. <em>[x2]</em>. Comparing these zkSNARKs (essentially) reduces to comparing the underlying IOPs, which we do below.</p>

    <p class="text-gray-300">Construction blueprint. The IOPs in the aforementioned systems can all be viewed as combining an encoded IOP (as defined in Section 4.7) and a low-degree test (as defined in Section 4.5.1), via the transformation described in Section 8. Informally, this transformation invokes the low-degree test on a suitable random linear combination of the oracles sent by the encoded IOP prover (more generally, of “virtual” oracles implied by these), thereby ensuring that the codeword obtained by stacking these oracles is close to the interleaved</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LDT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">number of queries</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">to f</td>

            <td class="px-3 py-2 border-b border-gray-700">to aux oracles</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">direct</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(1-δ)t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FRI</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700">t·(2η-1)·logρ</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">/η</td>

            <td class="px-3 py-2 border-b border-gray-700">εiFRI(F,L)+εqFRI(L,ρ,δ)t</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 15: Parameters of the direct low-degree test and FRI low-degree test when invoked on a function  <span class="math">f \\colon L \\to \\mathbb{F}</span>  that is  <span class="math">\\delta</span> -far from RS  <span class="math">[L, \\rho] \\subseteq \\mathbb{F}^L</span> . Note that  <span class="math">\\delta</span>  always lies in  <span class="math">[0, 1 - \\rho]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IOP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">relation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">number of queries</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Stark</td>

            <td class="px-3 py-2 border-b border-gray-700">APR</td>

            <td class="px-3 py-2 border-b border-gray-700">qFRI(</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 1, 4(</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">+ b), ρ) + qFRI(</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 1, D(</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">+ b), ρ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">qDIR(4(h + 1), 2m/h, ρ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">qFRI(5, 2m + 2b, ρ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 16: Aspects of the IOPs underlying Stark, Ligero, and Aurora.</p>

    <p class="text-gray-300">Reed-Solomon code (more generally, a codeword obtained by applying a transformation to these oracles is close to the interleaved Reed-Solomon code); one can then reduce to soundness of the encoded IOP.</p>

    <p class="text-gray-300">For a given soundness error, the query complexity of an IOP constructed via the blueprint above is determined by the query complexity of the underlying low-degree test, while (typically) the prover and verifier complexities are dominated by the encoded IOP's prover and verifier complexities.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The three IOPs. In light of the foregoing blueprint, we describe the differences across the three IOPs by discussing the differences across the respective encoded IOPs and low-degree tests (see Fig. 16). Recall that  <span class="math">b</span>  denotes the query bound for zero knowledge (as defined in Section 4.6); the bound is later set to equal the number of queries of the honest verifier. Moreover, for notational simplicity, below we use  <span class="math">q(k, d, \\rho)</span>  to denote the query complexity of a low-degree test invoked on a function  <span class="math">f^* \\colon L \\to \\mathbb{F}</span>  derived entry-wise from  <span class="math">k</span>  oracles  <span class="math">f_i \\colon L \\to \\mathbb{F}</span>  sent by the encoded IOP prover, with each oracle (allegedly) having degree less than  $d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ; using a low-degree test in this way follows the general paradigm described in Section 4.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The IOP in Aurora. The IOP in Aurora is obtained by combining an encoded IOP for R1CS (described in Section 7) and the FRI low-degree test. Given an R1CS instance with  <span class="math">m</span>  constraints, the IOP invokes the low-degree test on 5 oracles having maximal degree  <span class="math">2m + 2b</span> , resulting in  <span class="math">\\mathfrak{q}_{\\mathrm{FRI}}(5, 2m + 2b, \\rho)</span>  queries.</li>

      <li>The IOP in Ligero. The IOP in Ligero (adapted for R1CS) is obtained by combining an encoded IOP for R1CS and a direct low-degree test (see Appendix C.1). Given an R1CS instance with  <span class="math">m</span>  constraints and for a parameter  <span class="math">h \\approx \\sqrt{m}</span> , the IOP invokes the low-degree test on  <span class="math">4(h + 1)</span>  oracles of maximal degree  <span class="math">2m / h</span> , resulting in  <span class="math">\\mathfrak{q}_{\\mathrm{DIR}}(4(h + 1), 2m / h, \\rho)</span>  queries.</li>

      <li>The IOP in Stark. The IOP in Stark natively supports Algebraic Placement and Routing (APR), which is the following problem: given a finite field  <span class="math">\\mathbb{F}</span> , subset  <span class="math">H \\subseteq \\mathbb{F}</span> , algebraic registers  <span class="math">\\mathcal{R}</span> , neighbors  <span class="math">\\mathcal{N}</span> , and set of polynomial constraints  <span class="math">\\mathcal{C}</span> , are there functions  <span class="math">w = (w_{i} \\colon H \\to \\mathbb{F})_{i \\in \\mathcal{R}}</span>  such that for every element  <span class="math">\\alpha \\in H</span>  and every constraint  <span class="math">c \\in \\mathcal{C}</span>  it holds that  <span class="math">c\\big(\\alpha, (w_{i}(f(\\alpha)))_{(i,f) \\in \\mathcal{N}}\\big) = 0</span> ? (See [BBHR18a] for details.)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The IOP in Stark is obtained by combining an encoded IOP for APR and the FRI low-degree test. The latter is used twice: once on  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math">  oracles of maximal degree  </span>4(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ b)<span class="math"> ; once on  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math">  oracles of maximal degree  </span>D(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ b)<span class="math"> . This results in  </span>\\mathfrak{q}_{\\mathrm{FRI}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1, 4(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ b), \\rho) + \\mathfrak{q}_{\\mathrm{FRI}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1, D(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ b), \\rho)$  queries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Alexander Chernyakhovsky and Tom Gur for helpful discussions, Dev Ojha for many useful comments that improved this paper and for terrific help in implementing libiop, and Aleksejs Popovs for help in implementing binary field algorithms. This work was supported in part by: the Ethics and Governance of Artificial Intelligence Fund; a Google Faculty Award; the Israel Science Foundation (grant 1501/14); the UC Berkeley Center for Long-Term Cybersecurity; the US-Israel Binational Science Foundation (grant 2015780); and donations from the Ethereum Foundation, the Interchain Foundation, and Qtum.</p>

    <h2 id="sec-72" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2087–2104.</li>

      <li>[ALMSS98] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. “Proof verification and the hardness of approximation problems”. In: Journal of the ACM 45.3 (1998). Preliminary version in FOCS ’92., pp. 501–555.</li>

      <li>[AMPH14] Jean-Philippe Aumasson, Willi Meier, Raphael Phan, and Luca Henzen. The Hash Function BLAKE. Springer-Verlag Berlin Heidelberg, 2014. isbn: 9783662447567.</li>

      <li>[ANWOW13] Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O’Hearn, and Christian Winnerlein. BLAKE2: simpler, smaller, fast as MD5. https://blake2.net/blake2.pdf. 2013.</li>

      <li>[AS98] Sanjeev Arora and Shmuel Safra. “Probabilistic checking of proofs: a new characterization of NP”. In: Journal of the ACM 45.1 (1998). Preliminary version in FOCS ’92., pp. 70–122.</li>

      <li>[BBBPWM18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 315–334.</li>

      <li>[BBCGGHPRSTV17] Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran Tromer, and Madars Virza. “Computational integrity with a public random string from quasi-linear PCPs”. In: Proceedings of the 36th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’17. 2017, pp. 551–579.</li>

      <li>[BBCPGL18] Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. “Sub-linear Lattice-Based Zero-Knowledge Arguments for Arithmetic Circuits”. In: Proceedings of the 38th Annual International Cryptology Conference. CRYPTO ’18. 2018, pp. 669–699.</li>

      <li>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046. 2018.</li>

      <li>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Ynon Horesh, and Michael Riabzev. “Fast Reed–Solomon Interactive Oracle Proofs of Proximity”. In: Proceedings of the 45th International Colloquium on Automata, Languages and Programming. ICALP ’18. 2018, 14:1–14:17.</li>

      <li>[BC14] Daniel J. Bernstein and Tung Chou. “Faster Binary-Field Multiplication and Faster Binary-Field MACs”. In: Proceedings of the 21st International Conference on Selected Areas in Cryptography. SAC ’14. 2014, pp. 92–111.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BC99] Nigel P. Byott and Robin J. Chapman. “Power Sums over Finite Subspaces of a Field”. In: <em>Finite Fields and Their Applications</em> 5.3 (July 1999), pp. 254–265.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCC88] Gilles Brassard, David Chaum, and Claude Crépeau. “Minimum disclosure proofs of knowledge”. In: <em>Journal of Computer and System Sciences</em> 37.2 (1988), pp. 156–189.</li>

      <li>[BCCGP16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: <em>Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BCFGRS17] Eli Ben-Sasson, Alessandro Chiesa, Michael A. Forbes, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. “Zero Knowledge Protocols from Succinct Constraint Detection”. In: <em>Proceedings of the 15th Theory of Cryptography Conference</em>. TCC ’17. 2017, pp. 172–206.</li>

      <li>[BCGGMTV14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. “Zerocash: Decentralized Anonymous Payments from Bitcoin”. In: <em>Proceedings of the 2014 IEEE Symposium on Security and Privacy</em>. SP ’14. 2014, pp. 459–474.</li>

      <li>[BCGRS17] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. “Interactive Oracle Proofs with Constant Rate and Query Complexity”. In: <em>Proceedings of the 44th International Colloquium on Automata, Languages and Programming</em>. ICALP ’17. 2017, 40:1–40:15.</li>

      <li>[BCGT13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. “Fast Reductions from RAMs to Delegatable Succinct Constraint Satisfaction Problems”. In: <em>Proceedings of the 4th Innovations in Theoretical Computer Science Conference</em>. ITCS ’13. 2013, pp. 401–414.</li>

      <li>[BCGTV13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. “SNARKs for C: Verifying Program Executions Succinctly and in Zero Knowledge”. In: <em>Proceedings of the 33rd Annual International Cryptology Conference</em>. CRYPTO ’13. 2013, pp. 90–108.</li>

      <li>[BCGTV15] Eli Ben-Sasson, Alessandro Chiesa, Matthew Green, Eran Tromer, and Madars Virza. “Secure Sampling of Public Parameters for Succinct Zero Knowledge Proofs”. In: <em>Proceedings of the 36th IEEE Symposium on Security and Privacy</em>. S&amp;P ’15. 2015, pp. 287–304.</li>

      <li>[BCGV16] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, and Madars Virza. “Quasilinear-Size Zero Knowledge from Linear-Algebraic PCPs”. In: <em>Proceedings of the 13th Theory of Cryptography Conference</em>. TCC ’16-A. 2016, pp. 33–64.</li>

      <li>[BCIOP13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. “Succinct Non-Interactive Arguments via Linear Interactive Proofs”. In: <em>Proceedings of the 10th Theory of Cryptography Conference</em>. TCC ’13. 2013, pp. 315–333.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: <em>Proceedings of the 14th Theory of Cryptography Conference</em>. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BCTV14a] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: <em>Proceedings of the 34th Annual International Cryptology Conference</em>. CRYPTO ’14. Extended version at http://eprint.iacr.org/2014/595. 2014, pp. 276–294.</li>

      <li>[BCTV14b] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture”. In: <em>Proceedings of the 23rd USENIX Security Symposium</em>. Security ’14. Extended version at http://eprint.iacr.org/2013/879. 2014, pp. 781–796.</li>

      <li>[BFL91] László Babai, Lance Fortnow, and Carsten Lund. “Non-Deterministic Exponential Time has Two-Prover Interactive Protocols”. In: <em>Computational Complexity</em> 1 (1991). Preliminary version appeared in FOCS ’90., pp. 3–40.</li>

    </ul>

    <p class="text-gray-300">[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. “Checking computations in polylogarithmic time”. In: <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>. STOC ’91. 1991, pp. 21–32.</p>

    <p class="text-gray-300">[BGG17] Sean Bowe, Ariel Gabizon, and Matthew Green. <em>A multi-party protocol for constructing the public parameters of the Pinocchio zk-SNARK</em>. Cryptology ePrint Archive, Report 2017/602. 2017.</p>

    <p class="text-gray-300">[BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers. <em>Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model</em>. Cryptology ePrint Archive, Report 2017/1050. 2017.</p>

    <p class="text-gray-300">[BISW17] Dan Boneh, Yuval Ishai, Amit Sahai, and David J. Wu. “Lattice-Based SNARGs and Their Application to More Efficient Obfuscation”. In: <em>Proceedings of the 36th Annual International Conference on Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’17. 2017, pp. 247–277.</p>

    <p class="text-gray-300">[BKKMS13] Eli Ben-Sasson, Yohay Kaplan, Swastik Kopparty, Or Meir, and Henning Stichtenoth. “Constant Rate PCPs for Circuit-SAT with Sublinear Query Complexity”. In: <em>Proceedings of the 54th Annual IEEE Symposium on Foundations of Computer Science</em>. FOCS ’13. 2013, pp. 320–329.</p>

    <p class="text-gray-300">[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. “Worst-Case to Average Case Reductions for the Distance to a Code”. In: <em>Proceedings of the 33rd ACM Conference on Computer and Communications Security</em>. CCS ’18. 2018, 24:1–24:23.</p>

    <p class="text-gray-300">[BS06] Eli Ben-Sasson and Madhu Sudan. “Robust locally testable codes and products of codes”. In: <em>Random Structures and Algorithms</em> 28.4 (2006), pp. 387–402.</p>

    <p class="text-gray-300">[BS08] Eli Ben-Sasson and Madhu Sudan. “Short PCPs with Polylog Query Complexity”. In: <em>SIAM Journal on Computing</em> 38.2 (2008). Preliminary version appeared in STOC ’05., pp. 551–607.</p>

    <p class="text-gray-300">[Bab85] László Babai. “Trading group theory for randomness”. In: <em>Proceedings of the 17th Annual ACM Symposium on Theory of Computing</em>. STOC ’85. 1985, pp. 421–429.</p>

    <p class="text-gray-300">[CD98] Ronald Cramer and Ivan Damgård. “Zero-Knowledge Proofs for Finite Field Arithmetic; or: Can Zero-Knowledge be for Free?” In: <em>Proceedings of the 18th Annual International Cryptology Conference</em>. CRYPTO ’98. 1998, pp. 424–441.</p>

    <p class="text-gray-300">[CFHKKNPZ15] Craig Costello, Cédric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter, Michael Naehrig, Bryan Parno, and Samee Zahur. “Geppetto: Versatile Verifiable Computation”. In: <em>Proceedings of the 36th IEEE Symposium on Security and Privacy</em>. S&amp;P ’15. 2015, pp. 250–273.</p>

    <p class="text-gray-300">[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. “Practical Verified Computation with Streaming Interactive Proofs”. In: <em>Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science</em>. ITCS ’12. 2012, pp. 90–112.</p>

    <p class="text-gray-300">[CS17] eBACS: ECRYPT Benchmarking of Cryptographic Systems. <em>Measurements of hash functions, indexed by machine</em>. 2017. URL: https://bench.cr.yp.to/results-hash.html.</p>

    <p class="text-gray-300">[CT65] James W. Cooley and John W. Tukey. “An algorithm for the machine calculation of complex Fourier series”. In: <em>Mathematics of Computation</em> 19 (1965), pp. 297–301.</p>

    <p class="text-gray-300">[Can89] David G. Cantor. “On arithmetical algorithms over finite fields”. In: <em>Journal of Combinatorial Theory, Series A</em> 50.2 (1989), pp. 285–300.</p>

    <p class="text-gray-300">[FGLSS96] Uriel Feige, Shafi Goldwasser, Laszlo Lovász, Shmuel Safra, and Mario Szegedy. “Interactive proofs and the hardness of approximating cliques”. In: <em>Journal of the ACM</em> 43.2 (1996). Preliminary version in FOCS ’91., pp. 268–292.</p>

    <p class="text-gray-300">61</p>

    <p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’13. 2013, pp. 626–645.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GH98] Oded Goldreich and Johan Håstad. “On the complexity of interactive proofs with bounded communication”. In: <em>Information Processing Letters</em> 67.4 (1998), pp. 205–214.</li>

      <li>[GIMS10] Vipul Goyal, Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. “Interactive locking, zero-knowledge PCPs, and unconditional cryptography”. In: <em>Proceedings of the 30th Annual Conference on Advances in Cryptology</em>. CRYPTO’10. 2010, pp. 173–190.</li>

      <li>[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating Computation: Interactive Proofs for Muggles”. In: <em>Journal of the ACM</em> 62.4 (2015), 27:1–27:64.</li>

      <li>[GM10] Shuhong Gao and Todd Mateer. “Additive Fast Fourier Transforms Over Finite Fields”. In: <em>IEEE Transactions on Information Theory</em> 56.12 (2010), pp. 6265–6272.</li>

      <li>[GM17] Jens Groth and Mary Maller. “Snarky Signatures: Minimal Signatures of Knowledge from Simulation-Extractable SNARKs”. In: <em>Proceedings of the 37th Annual International Cryptology Conference</em>. CRYPTO ’17. 2017, pp. 581–612.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. “The knowledge complexity of interactive proof systems”. In: <em>SIAM Journal on Computing</em> 18.1 (1989). Preliminary version appeared in STOC ’85., pp. 186–208.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. “Separating Succinct Non-Interactive Arguments From All Falsifiable Assumptions”. In: <em>Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</em>. STOC ’11. 2011, pp. 99–108.</li>

      <li>[Gro10] Jens Groth. “Short Pairing-Based Non-interactive Zero-Knowledge Arguments”. In: <em>Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</em>. ASIACRYPT ’10. 2010, pp. 321–340.</li>

      <li>[Gro16] Jens Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: <em>Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[Gue11] Shay Gueron. <em>Intel Carry-Less Multiplication Instruction and its Usage for Computing the GCM Mode</em>. https://software.intel.com/en-us/articles/intel-carry-less-multiplication-instruction-and-its-usage-for-computing-the-gcm-mode. 2011.</li>

      <li>[IKO07] Yuval Ishai, Eyal Kushilevitz, and Rafail Ostrovsky. “Efficient Arguments without Short PCPs”. In: <em>Proceedings of the Twenty-Second Annual IEEE Conference on Computational Complexity</em>. CCC ’07. 2007, pp. 278–291.</li>

      <li>[IMSX15] Yuval Ishai, Mohammad Mahmoody, Amit Sahai, and David Xiao. <em>On Zero-Knowledge PCPs: Limitations, Simplifications, and Applications</em>. Available at http://www.cs.virginia.edu/~mohammad/files/papers/ZKPCPs-Full.pdf. 2015.</li>

      <li>[IW14] Yuval Ishai and Mor Weiss. “Probabilistically Checkable Proofs of Proximity with Zero-Knowledge”. In: <em>Proceedings of the 11th Theory of Cryptography Conference</em>. TCC ’14. 2014, pp. 121–145.</li>

      <li>[KR08] Yael Kalai and Ran Raz. “Interactive PCP”. In: <em>Proceedings of the 35th International Colloquium on Automata, Languages and Programming</em>. ICALP ’08. 2008, pp. 536–547.</li>

      <li>[Kil92] Joe Kilian. “A note on efficient zero-knowledge proofs and arguments”. In: <em>Proceedings of the 24th Annual ACM Symposium on Theory of Computing</em>. STOC ’92. 1992, pp. 723–732.</li>

    </ul>

    <p class="text-gray-300">[LAH16] Sian-Jheng Lin, Tareq Y. Al-Naffouri, and Yunghsiang S. Han. “FFT Algorithm for Binary Extension Finite Fields and Its Application to Reed–Solomon Codes”. In: IEEE Transactions on Information Theory 62.10 (2016), pp. 5343–5358.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LCH14] Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han. “Novel Polynomial Basis and Its Application to Reed–Solomon Erasure Codes”. In: Proceedings of the 55th Annual IEEE Symposium on Foundations of Computer Science. FOCS ’14. 2014, pp. 316–325.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. “Algebraic Methods for Interactive Proof Systems”. In: Journal of the ACM 39.4 (1992), pp. 859–868.</li>

      <li>[LN97] Rudolf Lidl and Harald Niederreiter. Finite Fields. Second Edition. Cambridge University Press, 1997.</li>

      <li>[Lip13] Helger Lipmaa. “Succinct Non-interactive Zero Knowledge Arguments from Span Programs and Linear Error-Correcting Codes”. In: Proceedings of the 19th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’13. 2013, pp. 41–60.</li>

      <li>[Mei12] Or Meir. “Combinatorial PCPs with Short Proofs”. In: Proceedings of the 26th Annual IEEE Conference on Computational Complexity. CCC ’12. 2012.</li>

      <li>[Mic00] Silvio Micali. “Computationally Sound Proofs”. In: SIAM Journal on Computing 30.4 (2000). Preliminary version appeared in FOCS ’94., pp. 1253–1298.</li>

      <li>[Mon85] Peter L. Montgomery. “Modular Multiplication without Trial Division”. In: Mathematics of Computation 44.170 (1985), pp. 519–521.</li>

      <li>[NIS16] NIST. Post-Quantum Cryptography. 2016. URL: https://csrc.nist.gov/Projects/Post-Quantum-Cryptography.</li>

      <li>[Nak09] Satoshi Nakamoto. Bitcoin: a peer-to-peer electronic cash system. 2009. URL: http://www.bitcoin.org/bitcoin.pdf.</li>

      <li>[PGHR13] Brian Parno, Craig Gentry, Jon Howell, and Mariana Raykova. “Pinocchio: Nearly Practical Verifiable Computation”. In: Proceedings of the 34th IEEE Symposium on Security and Privacy. Oakland ’13. 2013, pp. 238–252.</li>

      <li>[PS94] Alexander Polishchuk and Daniel A. Spielman. “Nearly-linear size holographic proofs”. In: Proceedings of the 26th Annual ACM Symposium on Theory of Computing. STOC ’94. 1994, pp. 194–203.</li>

      <li>[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC ’16. 2016, pp. 49–62.</li>

      <li>[RVW13] Guy N. Rothblum, Salil P. Vadhan, and Avi Wigderson. “Interactive proofs of proximity: delegating computation in sublinear time”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 793–802.</li>

      <li>[SBVBPW13] Srinath Setty, Benjamin Braun, Victor Vu, Andrew J. Blumberg, Bryan Parno, and Michael Walfish. “Resolving the conflict between generality and plausibility in verified computation”. In: Proceedings of the 8th EuoroSys Conference. EuroSys ’13. 2013, pp. 71–84.</li>

      <li>[Sha92] Adi Shamir. “IP = PSPACE”. In: Journal of the ACM 39.4 (1992), pp. 869–877.</li>

      <li>[TRMP12] Justin Thaler, Mike Roberts, Michael Mitzenmacher, and Hanspeter Pfister. “Verifiable Computation with Massively Parallel Interactive Proofs”. In: CoRR abs/1202.1350 (2012).</li>

      <li>[Tha13] Justin Thaler. “Time-Optimal Interactive Proofs for Circuit Evaluation”. In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO ’13. 2013, pp. 71–89.</li>

    </ul>

    <p class="text-gray-300">[Tha15] Justin Thaler. A Note on the GKR Protocol. http://people.cs.georgetown.edu/jthaler/GKRNote.pdf. 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[The] The Zcash Ceremony. https://z.cash/blog/the-design-of-the-ceremony.html. 2016.</li>

      <li>[Val08] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: Proceedings of the 5th Theory of Cryptography Conference. TCC ’08. 2008, pp. 1–18.</li>

      <li>[WB15] Michael Walfish and Andrew J. Blumberg. “Verifying Computations Without Reexecuting Them”. In: Communications of the ACM 58.2 (Jan. 2015), pp. 74–84.</li>

      <li>[WHGSW16] Riad S. Wahby, Max Howald, Siddharth J. Garg, Abhi Shelat, and Michael Walfish. “Verifiable ASICs”. In: Proceedings of the 37th IEEE Symposium on Security and Privacy. S&P ’16. 2016, pp. 759–778.</li>

      <li>[WJBSTWW17] Riad S. Wahby, Ye Ji, Andrew J. Blumberg, Abhi Shelat, Justin Thaler, Michael Walfish, and Thomas Wies. “Full Accounting for Verifiable Outsourcing”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2071–2086.</li>

      <li>[WSRBW15] Riad S. Wahby, Srinath Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walfish. “Efficient RAM and control flow in verifiable outsourced computation”. In: Proceedings of the 22nd Annual Network and Distributed System Security Symposium. NDSS ’15. 2015.</li>

      <li>[WTSTW17] Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. Cryptology ePrint Archive, Report 2017/1132. 2017.</li>

      <li>[Wee05] Hoeteck Wee. “On Round-Efficient Argument Systems”. In: Proceedings of the 32nd International Colloquium on Automata, Languages and Programming. ICALP ’05. 2005, pp. 140–152.</li>

      <li>[ZGKPP17a] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. A Zero-Knowledge Version of vSQL. Cryptology ePrint Archive, Report 2017/1146. 2017.</li>

      <li>[ZGKPP17b] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. “vSQL: Verifying Arbitrary SQL Queries over Dynamic Outsourced Databases”. In: Proceedings of the 38th IEEE Symposium on Security and Privacy. S&P ’17. 2017, pp. 863–880.</li>

      <li>[Zca] ZCash Company. https://z.cash/. 2014.</li>

      <li>[Zks] Zero Knowledge Proof Standardization. https://zkproof.org/. 2017.</li>

      <li>[SCI] SCIPR Lab. libsnark: a C++ library for zkSNARK proofs. URL: https://github.com/scipr-lab/libsnark.</li>

    </ul>`;
---

<BaseLayout title="Aurora: Transparent Succinct Arguments for R1CS (2018/828)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/828
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
