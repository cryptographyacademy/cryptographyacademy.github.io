---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/1893';
---

<BaseLayout title="Binary Poseidon (2025/1893)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Binary Field Versions of Poseidon/Poseidon2
      </h1>
      <p class="text-gray-400 mb-2">
        Lorenzo Grassi, Dmitry Khovratovich, Katharina Koschatko,
        Christian Rechberger, Markus Schofnegger,
        Verena Schr&ouml;ppel, Zhuo Wu
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/1893
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Our Contributions</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Related Works</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                Notation</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Security Definitions</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Specification</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Modes of Operation</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                The Poseidon(2)<sub>B</sub> Permutation</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">
                Comparison of Poseidon(2) and
                Poseidon(2)<sub>B</sub></a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Security Claims</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Collision Resistance</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                (Second-)Preimage Resistance</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                CICO Problem</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">
                Multi-Target Collision Resistance</a>
            </li>
            <li>
              <a href="#sec-4.5"
                class="hover:text-white">
                Fiat&ndash;Shamir Security</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Security Analysis</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Statistical Attacks</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Degree and Density of the Interpolation
                Polynomial</a>
            </li>
            <li>
              <a href="#sec-5.3"
                class="hover:text-white">
                Algebraic Attacks</a>
            </li>
            <li>
              <a href="#sec-5.4"
                class="hover:text-white">
                Rebound Attacks</a>
            </li>
            <li>
              <a href="#sec-5.5"
                class="hover:text-white">
                Round Numbers</a>
            </li>
            <li>
              <a href="#sec-5.6"
                class="hover:text-white">
                Comparison to Poseidon(2)</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Proof Implementation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-6.1"
                class="hover:text-white">
                Overview of Binius</a>
            </li>
            <li>
              <a href="#sec-6.2"
                class="hover:text-white">
                Poseidon(2)<sub>B</sub> for Binius</a>
            </li>
            <li>
              <a href="#sec-6.3"
                class="hover:text-white">
                Plain Implementation</a>
            </li>
            <li>
              <a href="#sec-6.4"
                class="hover:text-white">
                Open Problems</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">Acknowledgment</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a"
            class="hover:text-white">Algebraic Attacks</a>
        </li>
        <li>
          <a href="#app-b"
            class="hover:text-white">
            Matrices Details</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        We present Poseidon<sub>B</sub> and Poseidon2<sub>B</sub>,
        natural variants of Poseidon and Poseidon2, respectively,
        defined over binary extension fields with a target security
        level of 128 bits. They are specifically designed to inherit
        many of the circuit-friendly properties of their prime field
        version, and to be used together with binary extension field
        proving systems such as Binius. Benchmarking demonstrates
        merits in proof size, proving time, and especially
        verification time, in comparison to traditional hash
        functions and other binary circuit-friendly hash functions
        such as Vision-32b and Anemoi.
      </p>
      <p class="text-gray-300">
        Due to the close similarity to their prime field
        counterparts, many existing cryptanalytic results directly
        carry over to Poseidon<sub>B</sub> and
        Poseidon2<sub>B</sub>. Nevertheless, we revisit the security
        analysis to incorporate recent advances in cryptanalysis and
        to account for attack vectors that do not arise in the prime
        field setting. In particular, we focus on algebraic
        cryptanalysis and subspace trails, techniques that resulted
        in attacks on initial versions of Poseidon defined over
        binary extension fields. Our complexity estimates are based
        on the ideal degree, now increasingly adopted as a standard
        measure in algebraic cryptanalysis.
      </p>
      <p class="text-gray-300 text-sm mt-4">
        <strong>Keywords:</strong> Poseidon, Poseidon2, ZK, Binary
        Extension Fields, Binius.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        The Poseidon hash function, introduced in 2019, has gained
        widespread adoption in verifiable computation protocols,
        where one party asserts the correctness of a computation
        using a compact proof. Using only basic algebraic operations
        over a prime field, Poseidon is one of the
        fastest-to-prove hash functions, and is at the same time
        among the fastest ones to compute natively. Its recently
        updated version Poseidon2 is tailored towards smaller prime
        fields, which are gaining in popularity for proving large
        computation blocks such as Ethereum blockchain transitions,
        commonly known as zero-knowledge virtual machines (zkVMs).
      </p>
      <p class="text-gray-300">
        Despite its security margin not being overly large, the full
        and practically used versions of Poseidon have withstood many
        different cryptanalytic attacks, and indeed, while being one
        of the earliest circuit-friendly hash functions, it is
        simultaneously one of the few unbroken ones. For this reason,
        it is among the most trusted hash functions in the community,
        and at the time of writing, it is also a prime candidate for
        adoption in Ethereum as its ZK-friendly hash function.
      </p>
      <p class="text-gray-300">
        While smaller prime fields are convenient and allow for
        arguably fast implementations, they require conversion from
        standard machine words, which comes at the cost of some
        storage waste. Moreover, prime field proof systems inherently
        struggle with bit operations, as a prime field does not
        provide native tools to tackle separate bits.
      </p>
      <p class="text-gray-300">
        All of this has led to various research results on binary
        proof systems, initially univariate ones exploiting
        properties of small elliptic curves to achieve efficient NTTs
        outside of two-adic structures, and most recently
        multivariate ones such as Binius, introducing new techniques
        that separate the committing field size from the constraint
        field size and thus make it possible to mix binary fields
        with specific properties.
      </p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">
        1.1 Our Contributions
      </h3>
      <p class="text-gray-300">
        We formally introduce Poseidon<sub>B</sub> and
        Poseidon2<sub>B</sub>, natural variants of Poseidon and
        Poseidon2, respectively, over a binary extension field. The
        designs aim to:
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          Achieve high performance on a commodity CPU by using sparse
          constants and low-degree power maps.
        </li>
        <li>
          Be efficient in binary proof systems by minimizing the
          number of algebraic constraints.
        </li>
      </ol>
      <p class="text-gray-300">
        The binary variants
        Poseidon(2)<sub>B</sub><sup>&pi;</sup> are obtained by
        redefining the operations of Poseidon(2) over binary
        extension fields, with the goal of inheriting the
        cryptanalysis record of the original designs. Our
        contributions are summarized as follows:
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-2">
        <li>
          We formally revise security properties beyond the classical
          collision and preimage resistance in order to accommodate
          the scenarios arising in the use of a hash function in
          various protocols, such as the Fiat&ndash;Shamir
          conversion.
        </li>
        <li>
          We revisit the security analysis of
          Poseidon(2)<sub>B</sub> from scratch. In particular, we
          confirm the density estimates of the polynomial
          representation, which help establish lower bounds on the
          complexity of the interpolation attack and reanalyze the
          security against algebraic attacks. We base the attack
          complexity on the ideal degree bound.
        </li>
        <li>
          We have conducted benchmarks both in native and circuit
          variants. In particular, we provide a proof implementation
          of the Poseidon(2)<sub>B</sub><sup>&pi;</sup> permutations
          in the Binius framework, showing its efficiency and
          applicability within binary proof systems.
        </li>
      </ol>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">
        1.2 Related Works
      </h3>
      <p class="text-gray-300">
        A binary version of Poseidon was first introduced in the
        original Poseidon paper under the name Starkad. It lies
        between the original Poseidon and the constructions presented
        in this paper. In particular, it uses a binary field and the
        same partial Substitution-Permutation-Network (SPN) scheme,
        but different linear layers. Soon after the publication of
        Starkad, its designers decided to withdraw it due to two main
        reasons:
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          The incapacity of providing a good estimation of the growth
          of the degree, a problem later solved in [Cid+22].
        </li>
        <li>
          The vulnerability of some Starkad instances, resulting from
          the specific choices of linear layers [KR21; Bey+20], a
          problem later solved in [GRS21].
        </li>
      </ul>
      <p class="text-gray-300">
        Another scheme based on binary extension fields is Vision
        Mark-32. It follows the Vision/Rescue design strategy,
        involving a high-degree power map. Whilst being one of the
        few circuit-friendly hash functions defined over binary
        extension fields, Vision Mark-32 is expected to be slow
        natively and may suffer from the FreeLunch attack similarly
        to its prime field counterpart. Further, a variant of Anemoi
        is defined over binary extension fields with odd extension
        degree.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>
      <p class="text-gray-300">
        This section collects the notations and security definitions
        used throughout the remainder of the paper, which provide the
        common framework for the design and security analysis.
      </p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">
        2.1 Notation
      </h3>
      <p class="text-gray-300">
        We denote the binary extension field of size
        <span class="math">2^n</span> by
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>, with
        <span class="math">n</span> being the extension degree. We
        consider transformations on states of finite-field elements
        <span class="math">(x_0, \ldots, x_&#123;t-1&#125;) \in
        \mathbb&#123;F&#125;^t</span>, where <span class="math">t</span>
        denotes the state size. The function
        <span class="math">\mathcal&#123;H&#125;: \mathbb&#123;F&#125;^* \to
        \mathbb&#123;F&#125;^\chi</span> denotes a hash function that maps
        strings of finite field elements to fixed-length outputs of
        length
        <span class="math">\chi \in \mathbb&#123;N&#125;_+</span>. Finally,
        <span class="math">\mathcal&#123;P&#125;: \mathbb&#123;F&#125;^t \to
        \mathbb&#123;F&#125;^t</span> denotes a bijective function.
      </p>
      <p class="text-gray-300">
        We write
        <span class="math">x \| y</span> for concatenation. For
        <span class="math">0 \le i &lt; j \le k</span>, let
        <span class="math">x[i:j]</span> denote the subtuple of
        <span class="math">x</span> from index
        <span class="math">i</span> (inclusive) to
        <span class="math">j</span> (exclusive). We define
        <span class="math">\textsf&#123;left&#125;_\ell(x) := x[0:\ell]</span>
        and
        <span class="math">\textsf&#123;right&#125;_\ell(x) :=
        x[k-\ell:k]</span> as the first and last
        <span class="math">\ell</span> elements of
        <span class="math">x</span>, respectively.
      </p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">
        2.2 Security Definitions
      </h3>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 (Unit of Time)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            We define the "unit of time" as the number of bit
            operations needed to compute
            <span class="math">\mathcal&#123;H&#125;(0)</span>, where
            <span class="math">0 \in \mathbb&#123;F&#125;</span> is a single
            field element.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2 (Preimage Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\mathcal&#123;H&#125;</span> is preimage
            resistant with
            <span class="math">\lambda</span> bits of security if,
            for any adversary that gets random
            <span class="math">h \in \mathbb&#123;F&#125;^\chi</span> as input
            and runs in time
            <span class="math">\tau</span>, the probability to
            output <span class="math">x</span> such that
            <span class="math">\mathcal&#123;H&#125;(x) = h</span> is at most
            <span class="math">\frac&#123;\tau&#125;&#123;2^\lambda&#125;</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3 (Second Preimage Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\mathcal&#123;H&#125;</span> is
            second-preimage resistant with
            <span class="math">\lambda</span> bits of security if,
            for any adversary that gets random
            <span class="math">h \in \mathbb&#123;F&#125;^t</span> as input
            and runs in time
            <span class="math">\tau</span>, given
            <span class="math">y</span> such that
            <span class="math">\mathcal&#123;H&#125;(y) = h</span>, the
            probability to output
            <span class="math">x \neq y</span> such that
            <span class="math">\mathcal&#123;H&#125;(x) = h</span> is at most
            <span class="math">\frac&#123;\tau&#125;&#123;2^\lambda&#125;</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 4 (Collision Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\mathcal&#123;H&#125;</span> is collision
            resistant with
            <span class="math">\lambda</span> bits of security if,
            for any adversary that gets random
            <span class="math">K \in \mathbb&#123;F&#125;^\chi</span> as input
            and runs in time
            <span class="math">\tau</span>, the probability to
            output two inputs
            <span class="math">x, y</span> such that
            <span class="math">\mathcal&#123;H&#125;(K \| x) =
            \mathcal&#123;H&#125;(K \| y)</span> is at most
            <span class="math">\frac&#123;\tau^2&#125;&#123;2^\lambda&#125;</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 5 (Target-Collision Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Consider the following game: (1) The challenger selects
            a secret key
            <span class="math">K \in \mathbb&#123;F&#125;^\chi</span>.
            (2) The adversary submits a message
            <span class="math">M</span> and receives
            <span class="math">\mathcal&#123;H&#125;(K, M)</span>.
            (3) The challenger reveals
            <span class="math">K</span>.
            (4) The adversary submits a new message
            <span class="math">M^*</span>. They win if
            <span class="math">\mathcal&#123;H&#125;(K, M) =
            \mathcal&#123;H&#125;(K, M^*)</span>.
            <span class="math">\mathcal&#123;H&#125;</span> is
            target-collision resistant with
            <span class="math">\lambda</span> bits of security if,
            for any adversary that runs in
            <span class="math">q &lt; 2^\lambda</span> time units,
            the probability of winning the game is at most
            <span class="math">\frac&#123;q&#125;&#123;|\mathbb&#123;F&#125;|^\lambda&#125;
            </span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 6 (Multi-Target-Collision Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">n</span> be an integer. Consider
            the following game: (1) The challenger selects a secret
            key
            <span class="math">K \in \mathbb&#123;F&#125;^\chi</span>.
            (2) The adversary submits
            <span class="math">n</span> distinct messages
            <span class="math">M_i</span> and distinct nonces
            <span class="math">\eta_i</span>, and receives the
            corresponding hashes
            <span class="math">\mathcal&#123;H&#125;(K, \eta_i, M_i)</span>.
            (3) The challenger reveals
            <span class="math">K</span>.
            (4) The adversary submits one of the earlier indices
            <span class="math">i</span> and a new message
            <span class="math">M^*</span>. They win if
            <span class="math">\mathcal&#123;H&#125;(K, \eta_i, M_i) =
            \mathcal&#123;H&#125;(K, \eta_i, M^*)</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 7 (k-Zero-Test Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">Q</span> be a set of polynomial
            mappings of degree <span class="math">d</span> that map
            <span class="math">\mathbb&#123;F&#125;^\chi</span> to
            <span class="math">\mathbb&#123;F&#125;^k</span> for some
            <span class="math">k \in \mathbb&#123;N&#125;_+</span>. Then
            <span class="math">\mathcal&#123;H&#125;</span> is called
            k-zero-test resistant if, for any adversary that gets
            random
            <span class="math">K \in \mathbb&#123;F&#125;^\chi</span> as
            input and runs in
            <span class="math">\tau</span> time units, the
            probability to output
            <span class="math">G \in Q</span> such that
            <span class="math">\mathcal&#123;H&#125;(K, \widehat&#123;G&#125;)</span>
            is a root of <span class="math">G</span> is at most
            <span class="math">\frac&#123;\tau \cdot d&#125;&#123;|\mathbb&#123;F&#125;|^k&#125;
            </span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 8 (CICO-k Security)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\mathcal&#123;P&#125;</span> is CICO-k secure
            if, for any adversary that gets random
            <span class="math">K \in \mathbb&#123;F&#125;^k</span> as input
            and runs in
            <span class="math">\tau</span> time units, the
            probability to output
            <span class="math">x, y \in \mathbb&#123;F&#125;^&#123;t-k&#125;</span>
            such that
            <span class="math">\mathcal&#123;P&#125;(x \| K) = y \| K</span>
            is at most
            <span class="math">\frac&#123;\tau&#125;&#123;|\mathbb&#123;F&#125;|^k&#125;</span>.
          </p>
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 3. SPECIFICATION                                             -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. Specification</h2>
      <p class="text-gray-300">
        Poseidon(2)<sub>B</sub> is a family of hash functions defined
        as a mode of operation over the permutation
        Poseidon(2)<sub>B</sub><sup>&pi;</sup> with a target security
        level of 128 bits. For the permutation, we essentially follow
        the design direction of
        Poseidon(2)<sup>&pi;</sup>, but operate over the binary
        extension field
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>.
      </p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">
        3.1 Modes of Operation
      </h3>
      <p class="text-gray-300">
        Let <span class="math">\chi</span> denote the digest length
        and <span class="math">t</span> the state size, measured in
        finite field elements.
      </p>

      <h4 class="text-lg font-semibold mt-6">3.1.1 Sponge Mode</h4>
      <p class="text-gray-300">
        The sponge construction is one of the most widely used
        constructions for setting up a hash function. Let
        <span class="math">\mathcal&#123;P&#125;</span> be a permutation over
        <span class="math">\mathbb&#123;F&#125;^t</span>, and let
        <span class="math">t = r + c</span>, where
        <span class="math">c</span> denotes the capacity and
        <span class="math">r</span> the rate. Given a padded message
        <span class="math">M \in \mathbb&#123;F&#125;^*</span>, it is first
        split into
        <span class="math">\mathbb&#123;F&#125;^r</span>-blocks
        <span class="math">M_0, M_1, \ldots, M_&#123;\ell-1&#125;</span>.
        Then, the message blocks are compressed one-by-one into a
        <span class="math">\mathbb&#123;F&#125;^t</span>-state:
      </p>
      <div class="math-block">
        S \leftarrow \mathcal&#123;P&#125;\left(S + (M_i \| 0^c)\right)
      </div>
      <p class="text-gray-300">
        for <span class="math">i = 0, 1, \ldots, \ell - 1</span>,
        where <span class="math">S</span> is initialized with
        <span class="math">0^&#123;c-1&#125; \| \chi</span>. After the
        absorption of the last message block, the hash output is
        formed by squeezing: repeatedly applying
        <span class="math">\mathcal&#123;P&#125;</span> and extracting the
        rate portion until
        <span class="math">\chi</span> elements are produced.
      </p>
      <p class="text-gray-300">
        <strong>Security Requirements.</strong> Let
        <span class="math">\mathbb&#123;F&#125; = \mathbb&#123;F&#125;_&#123;2^n&#125;</span>. In
        order to achieve a security level of
        <span class="math">\kappa</span> bits (pre-quantum), the
        capacity <span class="math">c</span> and digest
        <span class="math">\chi</span> must satisfy
        <span class="math">c = \lceil \frac&#123;2\kappa&#125;&#123;n&#125; \rceil</span>
        and
        <span class="math">\chi \ge \lceil \frac&#123;2\kappa&#125;&#123;n&#125;
        \rceil</span>.
      </p>
      <p class="text-gray-300">
        The authors recommend using the sponge-pi construction
        recently proposed by Lefevre et al. [LBM25] at ToSC'25 for
        variable-input hashing with output length
        <span class="math">\chi</span>.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        3.1.2 Compression Mode
      </h4>
      <p class="text-gray-300">
        The <span class="math">t</span>-to-<span class="math">\chi
        </span> compression function is defined as a combination of
        the feed-forward operation and a truncation:
      </p>
      <div class="math-block">
        \text&#123;Compress&#125;_&#123;t,\chi&#125;: \mathbb&#123;F&#125;^t \to \mathbb&#123;F&#125;^\chi,
        \quad x \mapsto \textsf&#123;left&#125;_\chi(\mathcal&#123;P&#125;(x) + x)
      </div>
      <p class="text-gray-300">
        It can be used to hash
        <span class="math">t</span> input elements and generate
        <span class="math">t/2</span> output elements via, e.g., a
        Tree-Hash. The suggested 2-to-1 compression function is:
      </p>
      <div class="math-block">
        \mathcal&#123;H&#125;_&#123;2 \to 1&#125;: \mathbb&#123;F&#125;^&#123;t/2&#125; \times
        \mathbb&#123;F&#125;^&#123;t/2&#125; \to \mathbb&#123;F&#125;^&#123;t/2&#125;, \quad (x, y) \mapsto
        \text&#123;Compress&#125;_&#123;t, t/2&#125;(x \| y)
      </div>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">
        3.2 The Poseidon(2)<sub>B</sub> Permutation
      </h3>
      <p class="text-gray-300">
        Poseidon<sub>B</sub><sup>&pi;</sup> and
        Poseidon2<sub>B</sub><sup>&pi;</sup> are families of
        permutations over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;^t</span> for
        <span class="math">n \in \&#123;32, 64, 128\&#125;</span>, where the
        state size
        <span class="math">t \in \&#123;4, 6, 8, 12, 16, 24\&#125;</span>
        depends on <span class="math">n</span>. A
        Poseidon(2)<sub>B</sub><sup>&pi;</sup> instance
        <span class="math">\mathcal&#123;P&#125;: \mathbb&#123;F&#125;_&#123;2^n&#125;^t \to
        \mathbb&#123;F&#125;_&#123;2^n&#125;^t</span> is defined by:
      </p>
      <div class="math-block">
        \mathcal&#123;P&#125;(x) = \mathcal&#123;E&#125;_&#123;R_F-1&#125; \circ \cdots \circ
        \mathcal&#123;E&#125;_&#123;R_F/2&#125; \circ \mathcal&#123;I&#125;_&#123;R_P-1&#125; \circ \cdots
        \circ \mathcal&#123;I&#125;_0 \circ \mathcal&#123;E&#125;_&#123;R_F/2-1&#125; \circ \cdots
        \circ \mathcal&#123;E&#125;_0(M_\mathcal&#123;E&#125; \cdot x)
      </div>
      <p class="text-gray-300">
        where <span class="math">\mathcal&#123;E&#125;_i</span> and
        <span class="math">\mathcal&#123;I&#125;_i</span> denote the
        <em>i</em>-th full (external) and partial (internal) round
        functions, respectively, and
        <span class="math">M_\mathcal&#123;E&#125;</span> is the invertible
        <span class="math">t \times t</span> matrix used in the
        external rounds. The value
        <span class="math">R_F = 2R_f</span> denotes the number of
        external rounds, and
        <span class="math">R_P</span> denotes the number of
        internal rounds.
      </p>

      <!-- Table 1 -->
      <div id="table-1" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 1.</strong> Instantiations of the
          Poseidon(2)<sub>B</sub> permutations over
          <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> for 128-bit
          security with state size
          <span class="math">t</span>, power-map exponent
          <span class="math">d</span>,
          <span class="math">R_F</span> full rounds and
          <span class="math">R_P</span> partial rounds.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4" colspan="4">
                (a) Poseidon<sub>B</sub><sup>&pi;</sup>
              </th>
              <th class="text-left py-2 pr-4" colspan="4">
                (b) Poseidon2<sub>B</sub><sup>&pi;</sup>
              </th>
            </tr>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">
                <span class="math">n</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">d</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">(R_F, R_P)</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">n</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">d</span>
              </th>
              <th class="text-left py-2">
                <span class="math">(R_F, R_P)</span>
              </th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">16</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2 pr-4">(8, 15)</td>
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">16</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2">(10, 15)</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">24</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2 pr-4">(8, 15)</td>
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">24</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2">(10, 15)</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">8</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2 pr-4">(8, 29)</td>
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">8</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2">(10, 29)</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">12</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2 pr-4">(8, 29)</td>
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">12</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2">(10, 29)</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">128</td>
              <td class="py-2 pr-4">4</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2 pr-4">(8, 58)</td>
              <td class="py-2 pr-4">128</td>
              <td class="py-2 pr-4">4</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2">(8, 58)</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">128</td>
              <td class="py-2 pr-4">6</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2 pr-4">(8, 58)</td>
              <td class="py-2 pr-4">128</td>
              <td class="py-2 pr-4">6</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2">(8, 58)</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4 class="text-lg font-semibold mt-6">
        3.2.1 Invertible Power Maps over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>
      </h4>
      <p class="text-gray-300">
        We recall that
        <span class="math">x \mapsto x^d</span> is invertible over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> if and only if
        <span class="math">\gcd(2^n - 1, d) = 1</span>. The
        invertible S-box of
        Poseidon(2)<sub>B</sub><sup>&pi;</sup> is instantiated with
        <span class="math">x \mapsto x^7</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For each
            <span class="math">m \ge 2</span>,
            <span class="math">2^&#123;2^m&#125; - 1</span> is divisible by 3
            and by 5. Moreover,
            <span class="math">2^&#123;2^m&#125; - 1</span> is never
            divisible by 7.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> By rewriting
        <span class="math">2^&#123;2^m&#125; - 1</span>, one can easily see
        that it is divisible by 3 and by 5:
      </p>
      <div class="math-block">
        2^&#123;2^m&#125; - 1 = (2^&#123;2^&#123;m-1&#125;&#125; - 1) \cdot (2^&#123;2^&#123;m-1&#125;&#125; + 1) =
        \ldots = (2^&#123;2^1&#125; - 1) \cdot \prod_&#123;i=1&#125;^&#123;m-1&#125;(2^&#123;2^i&#125; + 1)
      </div>
      <p class="text-gray-300">
        Now assume that 7 divides
        <span class="math">2^&#123;2^m&#125; - 1</span>, i.e.
        <span class="math">2^&#123;2^m&#125; \equiv 1 \bmod 7</span>. As
        <span class="math">2^3 \equiv 1 \bmod 7</span>, it follows
        that
        <span class="math">2^m \equiv 0 \bmod 3</span>, which never
        happens and thus leads to a contradiction.
      </p>
      <p class="text-gray-300">
        More generally, no exponent with Hamming weight 2 is coprime
        to <span class="math">2^&#123;2^m&#125; - 1</span>, i.e., no S-box
        of the form
        <span class="math">x \mapsto x^&#123;2^i + 2^j&#125;</span> is
        invertible over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For each
            <span class="math">m \ge 2</span> and
            <span class="math">0 &lt; d &lt; 2^m</span> holds
            <span class="math">\gcd(2^&#123;2^m&#125; - 1, 2^d + 1)
            \neq 1</span>.
          </p>
        </div>
      </div>

      <h4 class="text-lg font-semibold mt-6">
        3.2.2 The Full (External) Round
        <span class="math">\mathcal&#123;E&#125;</span>
      </h4>
      <p class="text-gray-300">
        The external round
        <span class="math">\mathcal&#123;E&#125;_i: \mathbb&#123;F&#125;_&#123;2^n&#125;^t \to
        \mathbb&#123;F&#125;_&#123;2^n&#125;^t</span> is given by:
      </p>
      <div class="math-block">
        \mathcal&#123;E&#125;_i(x_0, \ldots, x_&#123;t-1&#125;) = M_\mathcal&#123;E&#125; \cdot
        \left((x_0 \oplus c_0^&#123;(i)&#125;)^7, (x_1 \oplus c_1^&#123;(i)&#125;)^7,
        \ldots, (x_&#123;t-1&#125; \oplus c_&#123;t-1&#125;^&#123;(i)&#125;)^7\right)
      </div>
      <p class="text-gray-300">
        for <span class="math">0 \le i \le R_F - 1</span>, where
        <span class="math">c_j^&#123;(i)&#125;</span> is the
        <em>j</em>-th round constant in the <em>i</em>-th external
        round, and
        <span class="math">M_\mathcal&#123;E&#125;</span> is an invertible
        <span class="math">t \times t</span> matrix. The choice of
        <span class="math">M_\mathcal&#123;E&#125;</span> depends on
        <span class="math">n</span>: for
        <span class="math">n = 128</span>, it is an MDS matrix; for
        <span class="math">n \in \&#123;32, 64\&#125;</span>,
        Poseidon<sub>B</sub><sup>&pi;</sup> uses MDS Cauchy matrices
        while Poseidon2<sub>B</sub><sup>&pi;</sup> uses a tensor
        product structure
        <span class="math">\text&#123;circ&#125;(X, 1, \ldots, 1) \otimes
        M_4</span>.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        3.2.3 The Partial (Internal) Round
        <span class="math">\mathcal&#123;I&#125;</span>
      </h4>
      <p class="text-gray-300">
        The internal round
        <span class="math">\mathcal&#123;I&#125;_i: \mathbb&#123;F&#125;_&#123;2^n&#125;^t \to
        \mathbb&#123;F&#125;_&#123;2^n&#125;^t</span> is given by:
      </p>
      <div class="math-block">
        \mathcal&#123;I&#125;_i(x_0, \ldots, x_&#123;t-1&#125;) = M_\mathcal&#123;I&#125; \cdot
        \left((x_0 \oplus \hat&#123;c&#125;_0^&#123;(i)&#125;)^7, x_1, \ldots,
        x_&#123;t-1&#125;\right)
      </div>
      <p class="text-gray-300">
        where <span class="math">\hat&#123;c&#125;_0^&#123;(i)&#125;</span> is the round
        constant in the <em>i</em>-th internal round, and
        <span class="math">M_\mathcal&#123;I&#125;</span> is an invertible
        <span class="math">t \times t</span> matrix of the form
        <span class="math">\text&#123;diag&#125;(\mu_0, \ldots, \mu_&#123;t-1&#125;) +
        \mathbf&#123;1&#125;</span>, chosen such that
        <span class="math">M_\mathcal&#123;I&#125;</span> is invertible and
        admits no arbitrarily long subspace trails.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        3.2.4 Round Constants
      </h4>
      <p class="text-gray-300">
        The round constants are generated using
        Turbo-SHAKE-256 to break up the symmetry in the design.
      </p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">
        3.3 Comparison of Poseidon(2) and
        Poseidon(2)<sub>B</sub>
      </h3>
      <p class="text-gray-300">
        The original Poseidon<sup>&pi;</sup> permutation was
        introduced for prime fields of roughly 256 bits and employed
        a single fixed Cauchy MDS matrix as its linear layer, without
        an initial linear layer. Subsequent work identified
        weaknesses arising from this design choice, which led to the
        nowadays practically used variant of Poseidon that includes
        an initial linear layer.
      </p>
      <p class="text-gray-300">
        Poseidon2<sup>&pi;</sup> generalizes the original design and
        was introduced to also support prime fields of smaller sizes,
        starting at approximately 32 bits, while allowing for a much
        broader range of parameters.
      </p>
      <p class="text-gray-300">
        Both Poseidon<sub>B</sub> and Poseidon2<sub>B</sub> are
        defined in sponge and 2-to-1 compression mode. For the
        internal rounds, both variants follow the Poseidon2 design
        approach. Consequently, Poseidon<sub>B</sub> and
        Poseidon2<sub>B</sub> differ only in their choice of
        external linear layers
        <span class="math">M_\mathcal&#123;E&#125;</span> for extension
        degrees
        <span class="math">n \in \&#123;32, 64\&#125;</span>. While
        Poseidon<sub>B</sub> adopts conservative MDS matrices,
        Poseidon2<sub>B</sub> employs more aggressive non-MDS
        matrices to improve efficiency.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. SECURITY CLAIMS                                           -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4. Security Claims</h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">
        4.1 Collision Resistance
      </h3>
      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim (Collision Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            All Poseidon(2)<sub>B</sub> instances over
            <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> that output
            <span class="math">\chi</span> field elements are
            collision-resistant with
            <span class="math">\min\&#123;128, \chi \cdot n / 2\&#125;</span>
            bits of security.
          </p>
        </div>
      </div>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">
        4.2 (Second-)Preimage Resistance
      </h3>
      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim ((Second-)Preimage Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            All Poseidon(2)<sub>B</sub> instances over
            <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> that output
            <span class="math">\chi</span> field elements are
            (second-)preimage resistant with
            <span class="math">\min\&#123;128, \chi \cdot n\&#125;</span>
            bits of security.
          </p>
        </div>
      </div>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">
        4.3 CICO Problem
      </h3>
      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim (CICO Security)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            All Poseidon(2)<sub>B</sub> instances over
            <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> are CICO-k
            secure for
            <span class="math">k \le 128/n</span>.
          </p>
        </div>
      </div>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">
        4.4 Multi-Target Collision Resistance
      </h3>
      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim (Multi-Target Collision Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            All Poseidon(2)<sub>B</sub> instances over
            <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> are
            multi-target-collision resistant with 128 bits of
            security.
          </p>
        </div>
      </div>

      <h3 id="sec-4.5" class="text-xl font-semibold mt-8">
        4.5 Fiat&ndash;Shamir Security
      </h3>
      <div class="formal-block formal-block-claim">
        <div class="formal-block-title text-cyan-400">
          Claim (Fiat&ndash;Shamir / Zero-Test Resistance)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            All Poseidon(2)<sub>B</sub> instances over
            <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> are
            k-zero-test resistant for
            <span class="math">k \le 128/n</span>.
          </p>
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 5. SECURITY ANALYSIS                                         -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Security Analysis</h2>
      <p class="text-gray-300">
        Attacks against Poseidon(2)<sub>B</sub> behave in a similar
        way to the attacks against Poseidon(2). As in the case of
        Poseidon(2), the authors do not explicitly address weak
        distinguishers such as zero-sum distinguishers/partitions, as
        they have little to no relevance to practical attacks on hash
        functions.
      </p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">
        5.1 Statistical Attacks
      </h3>
      <p class="text-gray-300">
        Similar to the case of Poseidon(2), the statistical attacks
        are prevented by the external full rounds.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.1.1 Differential Attacks
      </h4>
      <p class="text-gray-300">
        The maximum differential probability of
        <span class="math">x \mapsto x^7</span> is given by:
      </p>
      <div class="math-block">
        DP_&#123;\max&#125;(x \mapsto x^7) = \frac&#123;6&#125;&#123;2^n&#125; = 3 \cdot 2^&#123;-n+1&#125;
      </div>
      <p class="text-gray-300">
        The matrix <span class="math">M_\mathcal&#123;E&#125;</span> has
        branch number at least equal to
        <span class="math">t/4 + 4</span>. Considering 2 consecutive
        two-round segments (for a total of four external rounds), one
        obtains:
      </p>
      <div class="math-block">
        (3 \cdot 2^&#123;-n+1&#125;)^&#123;2 \cdot (t/4+4)&#125; \le (3 \cdot
        2^&#123;-31&#125;)^&#123;12&#125; \approx 2^&#123;-353&#125;
      </div>
      <p class="text-gray-300">
        for <span class="math">n \ge 32</span> and
        <span class="math">t \ge 8</span>, which is much smaller
        than the security level of 128 bits. As a consequence, 4
        external rounds are sufficient to provide security against
        differential attacks, with 2 more rounds as a security
        margin.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.1.2 Truncated Differentials
      </h4>
      <p class="text-gray-300">
        Truncated differential cryptanalysis generalizes differential
        cryptanalysis in the sense that only a part of the difference
        can be predicted. For the full rounds, no truncated
        differential over
        <span class="math">r</span>-round Poseidon(2)<sub>B</sub>
        for
        <span class="math">r \ge 2</span> holds with probability
        substantially smaller than the security level.
      </p>
      <p class="text-gray-300">
        For the partial rounds, since the nonlinear layer uses only
        one nonlinear S-box, there exists an invariant subspace. The
        matrices
        <span class="math">M_\mathcal&#123;I&#125;</span> are chosen such that
        no arbitrarily long subspace trail with active/inactive
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>-word exists for
        Poseidon(2)<sub>B</sub>.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.1.3 Other Statistical Attacks
      </h4>
      <p class="text-gray-300">
        Poseidon(2)<sub>B</sub> is claimed secure against other
        statistical attacks, such as linear cryptanalysis, impossible
        differential attacks, integral attacks, rotational
        cryptanalysis, slide attacks, multiple-of-8, and mixture
        differential cryptanalysis.
      </p>

      <h4 class="text-lg font-semibold mt-6">5.1.4 Summary</h4>
      <p class="text-gray-300">
        As all statistical properties have negligibly low probability
        to hold, the statistical attacks fail for:
      </p>
      <div class="math-block">R_F \ge 4</div>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">
        5.2 Degree and Density of the Interpolation Polynomial
      </h3>

      <h4 class="text-lg font-semibold mt-6">
        5.2.1 Growth of the Degree &mdash; Forward Direction
      </h4>
      <p class="text-gray-300">
        The degree of
        <span class="math">x \mapsto x^7</span> is 7 over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> and
        <span class="math">\text&#123;hw&#125;(7) = 3</span> over
        <span class="math">\mathbb&#123;F&#125;_2</span>, implying that to
        reach maximum degree the total round number
        <span class="math">R</span> must satisfy:
      </p>
      <div class="math-block">
        7^R > t \cdot (2^n - 1) \quad \text&#123;and&#125; \quad 3^R > n \cdot t
      </div>
      <p class="text-gray-300">
        The growth of the degree
        <span class="math">\delta(R)</span> over
        <span class="math">\mathbb&#123;F&#125;_2</span> is given by:
      </p>
      <div class="math-block">
        \delta(R) \le \begin&#123;cases&#125; 3^R & \text&#123;if &#125; R \le 1 +
        \lfloor \log_3(t) \rfloor \\ t \cdot \log_2\left(
        \frac&#123;7^R&#125;&#123;t&#125; + 1\right) & \text&#123;otherwise&#125; \end&#123;cases&#125;
      </div>

      <h4 class="text-lg font-semibold mt-6">
        5.2.2 Growth of the Degree &mdash; Backward Direction
      </h4>
      <p class="text-gray-300">
        Focusing on the backward direction:
      </p>
      <div class="math-block">
        x^&#123;1/7&#125; = \begin&#123;cases&#125; x^&#123;(2^&#123;33&#125;-1)/7&#125; \approx
        x^&#123;2^&#123;30.19&#125;&#125; & \text&#123;if &#125; n = 32 \\ x^&#123;(6(2^&#123;64&#125;-1)+1)/7&#125;
        \approx x^&#123;2^&#123;63.78&#125;&#125; & \text&#123;if &#125; n = 64 \\
        x^&#123;(2(2^&#123;128&#125;-1)+1)/7&#125; \approx x^&#123;2^&#123;126.19&#125;&#125; & \text&#123;if &#125;
        n = 128 \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        This implies that a very high degree is achieved in just a
        few rounds.
      </p>

      <h4 class="text-lg font-semibold mt-6">5.2.3 Density</h4>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 9 (Dense Polynomial)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A polynomial over
            <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;^t</span> is called
            <em>dense</em> if it contains
            <span class="math">\Omega(2^&#123;nt&#125;)</span> monomials.
          </p>
        </div>
      </div>
      <p class="text-gray-300">
        Around
        <span class="math">\log_7(t) + n \cdot \log_7(2)</span>
        rounds are needed to satisfy the density condition.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.2.4 Practical Results
      </h4>
      <p class="text-gray-300">
        Practical tests were conducted for the degree growth and
        density of polynomials with
        <span class="math">t = 4</span> and
        <span class="math">d = 3</span> over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> for
        <span class="math">n \in \&#123;7, 15\&#125;</span>. Full rounds
        contribute better to density than partial rounds; however,
        the difference between them is not asymptotically
        significant. Mixing the rounds in
        Poseidon(2)<sub>B</sub> leads to better behavior than only
        using a P-SPN.
        [Figure 3 in the original paper shows the number of
        monomials reached in SPN, P-SPN, and
        Poseidon(2)<sub>B</sub>.]
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.2.5 Interpolation Attack
      </h4>
      <p class="text-gray-300">
        The interpolation attack aims to reconstruct the polynomial
        that defines the attacked scheme. Security requires:
      </p>
      <div class="math-block">
        R_F + R_P \ge \lceil \log_7(t) \rceil + \left\lceil
        \frac&#123;\min\&#123;n, 128\&#125;&#125;&#123;\log_2(7)&#125; \right\rceil
      </div>

      <h4 class="text-lg font-semibold mt-6">
        5.2.6 Higher-Order Differential Attacks
      </h4>
      <p class="text-gray-300">
        Given a function
        <span class="math">\mathcal&#123;F&#125;</span> over
        <span class="math">\mathbb&#123;F&#125;_2^n</span> of degree
        <span class="math">\delta</span>, then:
      </p>
      <div class="math-block">
        \bigoplus_&#123;x \in \mathfrak&#123;V&#125;&#125; \mathcal&#123;F&#125;(x) = 0
      </div>
      <p class="text-gray-300">
        for any affine subspace
        <span class="math">\mathfrak&#123;V&#125; \subseteq
        \mathbb&#123;F&#125;_2^n</span> of dimension at least
        <span class="math">\delta + 1</span>. The number of rounds
        that ensure security against interpolation attacks also
        guarantees security against higher-order differential attacks.
      </p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">
        5.3 Algebraic Attacks
      </h3>
      <p class="text-gray-300">
        Algebraic attacks describe a cryptographic primitive under a
        specific attack scenario as a system of polynomial equations
        over a finite field and apply system-solving techniques. The
        analysis estimates the attack complexity via the cost of
        retrieving a univariate polynomial in the ideal, taking into
        account the latest cryptanalysis results.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.3.1 Algebraic System Solving
      </h4>
      <p class="text-gray-300">
        <strong>Univariate Solving.</strong> To find solutions to a
        single univariate polynomial equation of degree
        <span class="math">\delta</span> over
        <span class="math">\mathbb&#123;F&#125;_q</span>, one can apply
        factorization algorithms with complexity:
      </p>
      <div class="math-block">
        C_&#123;\text&#123;uni&#125;&#125;(\delta) \in \mathcal&#123;O&#125;\left(\delta \cdot
        \log(\delta) \cdot (\log(\delta) + \log(q)) \cdot
        \log\log(\delta)\right) \ge \delta
      </div>
      <p class="text-gray-300">
        <strong>Gr&ouml;bner Bases.</strong> A Gr&ouml;bner basis
        attack consists of three steps: (1) compute a Gr&ouml;bner
        basis in degrevlex order; (2) convert to lexicographic order
        with cost estimated as
        <span class="math">m \cdot d_I^\omega</span> operations;
        (3) solve the resulting univariate polynomial. The complexity
        is estimated by step (2):
      </p>
      <div class="math-block">
        C_&#123;\text&#123;gb2&#125;&#125;(d_I) \in \mathcal&#123;O&#125;(m \cdot d_I^\omega) \ge
        d_I^2
      </div>
      <p class="text-gray-300">
        <strong>Bivariate Resultants.</strong> Given a bivariate
        equation system, the resultant attack computes
        <span class="math">\text&#123;Res&#125;_&#123;x_2&#125;(p_1, p_2)</span> with
        complexity at least
        <span class="math">\delta^2</span>.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.3.2 Application to Poseidon(2)<sub>B</sub>
      </h4>
      <p class="text-gray-300">
        Poseidon(2)<sub>B</sub> can be modeled over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span> in several ways.
        Three main approaches exploit degrees of freedom:
      </p>
      <ol class="list-[lower-alpha] list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          Random guessing of input variables.
        </li>
        <li>
          Skipping the first external full round.
        </li>
        <li>
          Skipping several internal partial rounds.
        </li>
      </ol>
      <p class="text-gray-300">
        <strong>CICO-k Problem.</strong> Algebraic attacks do not
        apply to the CICO-k problem whenever:
      </p>
      <div class="math-block">
        2^&#123;\min\&#123;k \cdot n, 128\&#125;&#125; \le \begin&#123;cases&#125;
        7^&#123;(R_F-1)+R_P&#125; & \text&#123;if &#125; k = 1 \\
        (7^&#123;(R_F-1)+R_P&#125;)^2 & \text&#123;if &#125; k = 2 \\
        (7^&#123;k(R_F-1)+R_P&#125;)^2 & \text&#123;if &#125; k \ge 2 \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        <strong>Preimage, Collision, and Zero-Test Attacks.</strong>
        All valid preimage attacks that work independently of the
        preimage value are valid CICO attacks. Collision attacks are
        even more expensive due to twice the number of variables.
        Zero-test attacks reduce to CICO-k.
      </p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">
        5.4 Rebound Attacks
      </h3>
      <p class="text-gray-300">
        Rebound attacks are divided into an inbound phase and an
        outbound phase. The inbound phase requires solving a CICO
        problem, and the outbound phase is limited by the strong
        statistical properties of the full external rounds. The
        maximum number of rounds covered by a rebound attack is given
        by the maximum number of rounds that can be broken via a
        Gr&ouml;bner basis attack (assuming
        <span class="math">\le 4</span> external full rounds), plus
        2 external full rounds, for a total of maximum 6 external
        rounds.
      </p>

      <h3 id="sec-5.5" class="text-xl font-semibold mt-8">
        5.5 Round Numbers
      </h3>

      <h4 class="text-lg font-semibold mt-6">
        5.5.1 Number of Full Rounds
      </h4>
      <p class="text-gray-300">
        The analysis of statistical attacks, including rebound
        attacks, implies that
        <span class="math">R_F = 6</span> is sufficient.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        5.5.2 Number of Partial Rounds
      </h4>
      <p class="text-gray-300">
        The partial rounds prevent algebraic attacks on the CICO-k
        problem. The formula is:
      </p>
      <div class="math-block">
        R_P \ge \max\left\&#123; \lceil \log_7(t) \rceil + \left\lceil
        \frac&#123;\min\&#123;n, 128\&#125;&#125;&#123;\log_2(7)&#125; \right\rceil - 3, \;
        \max_&#123;3 \le k \le 128/n&#125; \left\&#123; \left\lceil
        \frac&#123;\min\&#123;kn, 128\&#125;&#125;&#123;2\log_2(7)&#125; \right\rceil - 3k
        \right\&#125; \right\&#125;
      </div>

      <h4 class="text-lg font-semibold mt-6">
        5.5.3 Security Margin
      </h4>
      <p class="text-gray-300">
        The number of full rounds is increased from 6 to 8, in
        general, and another 2 full rounds are added for
        Poseidon2<sub>B</sub> with
        <span class="math">n \in \&#123;32, 64\&#125;</span> due to improved
        full-round skipping techniques in the non-MDS case. The
        number of partial rounds is increased by 30%.
      </p>

      <h3 id="sec-5.6" class="text-xl font-semibold mt-8">
        5.6 Comparison to Poseidon(2)
      </h3>
      <p class="text-gray-300">
        <strong>Number of Partial Rounds.</strong> For Poseidon, the
        analysis was based on the complexity of computing a
        Gr&ouml;bner basis in degrevlex order. For
        Poseidon(2)<sub>B</sub>, the analysis is based on the
        complexity of retrieving or solving a univariate polynomial in
        the ideal. This accounts for: (i) cases where the first step
        of a Gr&ouml;bner basis attack can be skipped; (ii) the
        observation that the degree of regularity is often
        overestimated by the Macaulay bound; (iii) the latest
        cryptanalysis results including resultant-based approaches.
      </p>
      <p class="text-gray-300">
        <strong>Security Margin.</strong> The security margin for
        Poseidon(2) is 7.5% more partial rounds, while for
        Poseidon(2)<sub>B</sub> it is 30%, to remain comfortably
        secure since binary variants are still less explored.
      </p>

      <!-- Table 3 -->
      <div id="table-3" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 3.</strong> Partial round number derivation
          (without security margin) for different instantiations.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">
                <span class="math">n</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">d</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">\chi</span>
              </th>
              <th class="text-left py-2 pr-4">
                [Gra+19b], Eq. (12)
              </th>
              <th class="text-left py-2">
                This work, Eq. (11)
              </th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">31</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">
                max&#123;11,8,13,...&#125; = 13 / 20
              </td>
              <td class="py-2">
                max&#123;13,12,15&#125; = 15
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">7</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">
                max&#123;20,17,...&#125; = 20
              </td>
              <td class="py-2">
                max&#123;22&#125; = 22
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">256</td>
              <td class="py-2 pr-4">2&ndash;3</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">1</td>
              <td class="py-2 pr-4">
                max&#123;52,50,...&#125; = 52
              </td>
              <td class="py-2">
                max&#123;54&#125; = 54
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 6. PROOF IMPLEMENTATION                                      -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6. Proof Implementation</h2>
      <p class="text-gray-300">
        To show a practical use case, the authors focus on the
        setting of a recursive verifier, i.e., a prover that attests
        the validity of a previous proof. A recursive verifier for
        Binius needs to replicate many of the prover's verification
        steps in a corresponding verification circuit. Some of these
        steps require hash function calls, for example, to validate
        commitments.
      </p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">
        6.1 Overview of Binius
      </h3>
      <p class="text-gray-300">
        The Binius and FRI-Binius framework introduces a novel and
        efficient way to extend the Plonkish family of constraint
        systems to operate natively over binary extension fields.
        Binius employs binary extension fields
        <span class="math">\mathbb&#123;F&#125;_&#123;2^k&#125;</span>, enabling each
        field element to map directly to a
        <span class="math">k</span>-bit word in memory. This
        eliminates the need for expensive modular reductions and
        allows all arithmetic operations to be implemented as native
        instructions on CPUs.
      </p>
      <p class="text-gray-300">
        <strong>Tower Fields in Binius.</strong> Binius uses the
        Wiedemann tower, where
        <span class="math">\mathbb&#123;T&#125;_0 := \mathbb&#123;F&#125;_2</span> and
        <span class="math">\mathbb&#123;T&#125;_m</span> is defined
        recursively via quadratic extensions. The advantage is that
        the recursive structure carries over to arithmetic operations,
        improving efficiency of multiplication and inversion.
      </p>
      <p class="text-gray-300">
        <strong>Virtual Polynomials.</strong> In addition to
        committed polynomials, Binius enables the usage of virtual
        polynomials that are algebraically linked to committed
        polynomials but do not require commitment. The evaluation is
        done locally by the verifier using virtual evaluation
        protocols.
      </p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">
        6.2 Poseidon(2)<sub>B</sub> for Binius
      </h3>

      <h4 class="text-lg font-semibold mt-6">
        6.2.1 Overview of the Arithmetization Costs
      </h4>
      <p class="text-gray-300">
        <strong>Non-Linear Components.</strong> For full rounds,
        <span class="math">t</span> S-box computations are committed.
        For partial rounds, only one S-box is computed, resulting in
        one committed column per round.
      </p>
      <p class="text-gray-300">
        <strong>Linear Components.</strong> For full rounds, the
        linear operations can be captured in
        <span class="math">t</span> virtual columns each. For
        partial rounds, the cost for virtual evaluation of the matrix
        multiplication on the verifier side is reduced to
        <span class="math">t</span> constant multiplications and
        <span class="math">t</span> additions.
      </p>
      <p class="text-gray-300">
        <strong>Total:</strong>
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          <span class="math">t \cdot (R_F + 1) + R_P</span>
          committed columns, including
          <span class="math">t</span> for the input state.
        </li>
        <li>
          <span class="math">2t \cdot R_F + (t+2) \cdot R_P +
          t</span> virtual columns.
        </li>
      </ul>

      <h4 class="text-lg font-semibold mt-6">
        6.2.2 Proof Implementation and Benchmarks
      </h4>
      <p class="text-gray-300">
        A proof implementation is provided for each parameter set
        using the Binius Rust framework. The implementation
        demonstrates the costs of proving the calculation of a
        Poseidon(2)<sub>B</sub> hash of a message of approximately
        1 MB (via
        <span class="math">2^&#123;14&#125;</span> permutation calls).
        All performances were benchmarked on an AMD Ryzen 9 7900x
        with 12 cores.
      </p>

      <!-- Table 4 -->
      <div id="table-4" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 4.</strong> Benchmark results for the proof
          implementations in Binius when hashing ~1 MB of data.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Permutation</th>
              <th class="text-left py-2 pr-4">
                <span class="math">n</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t</span>
              </th>
              <th class="text-left py-2 pr-4">Proof (KiB)</th>
              <th class="text-left py-2 pr-4">
                Prove (s, multi)
              </th>
              <th class="text-left py-2">
                Verify (ms, single)
              </th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Keccak-f</td>
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">24</td>
              <td class="py-2 pr-4">438</td>
              <td class="py-2 pr-4">0.425</td>
              <td class="py-2">45.70</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">SHA-256</td>
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">16</td>
              <td class="py-2 pr-4">701</td>
              <td class="py-2 pr-4">1.383</td>
              <td class="py-2">233.55</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Gr&oslash;stl-P</td>
              <td class="py-2 pr-4">8</td>
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">416</td>
              <td class="py-2 pr-4">0.170</td>
              <td class="py-2">114.97</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Vision-32b</td>
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">24</td>
              <td class="py-2 pr-4">560</td>
              <td class="py-2 pr-4">0.605</td>
              <td class="py-2">10.12</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">16</td>
              <td class="py-2 pr-4">402</td>
              <td class="py-2 pr-4">0.129</td>
              <td class="py-2">4.66</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">8</td>
              <td class="py-2 pr-4">366</td>
              <td class="py-2 pr-4">0.143</td>
              <td class="py-2">3.61</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">128</td>
              <td class="py-2 pr-4">4</td>
              <td class="py-2 pr-4">386</td>
              <td class="py-2 pr-4">0.304</td>
              <td class="py-2">3.54</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon2<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">32</td>
              <td class="py-2 pr-4">16</td>
              <td class="py-2 pr-4">411</td>
              <td class="py-2 pr-4">0.150</td>
              <td class="py-2">4.53</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon2<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">64</td>
              <td class="py-2 pr-4">8</td>
              <td class="py-2 pr-4">370</td>
              <td class="py-2 pr-4">0.162</td>
              <td class="py-2">3.68</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon2<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">128</td>
              <td class="py-2 pr-4">4</td>
              <td class="py-2 pr-4">386</td>
              <td class="py-2 pr-4">0.302</td>
              <td class="py-2">3.56</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p class="text-gray-300">
        Key observations from the benchmarks:
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4
        space-y-1">
        <li>
          All Poseidon(2)<sub>B</sub><sup>&pi;</sup> variants
          outperform Keccak-f in single-threaded runtime and
          verification time.
        </li>
        <li>
          SHA-256 shows the slowest performance overall;
          Poseidon(2)<sub>B</sub><sup>&pi;</sup> outperforms it in
          all metrics.
        </li>
        <li>
          Poseidon(2)<sub>B</sub><sup>&pi;</sup> approximately
          halves the verification time of Vision-32b.
        </li>
        <li>
          Anemoi shows significantly slower proving and verification
          times compared to
          Poseidon(2)<sub>B</sub><sup>&pi;</sup>.
        </li>
      </ul>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">
        6.3 Plain Implementation
      </h3>
      <p class="text-gray-300">
        Plain implementations are provided for each parameter set in
        Rust. A binary variant of Anemoi is also implemented for
        comparison.
      </p>

      <!-- Table 5 -->
      <div id="table-5" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 5.</strong> Performance comparison of plain
          implementations (throughput in
          10<sup>4</sup> perms/s, latency in &mu;s/perm).
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Permutation</th>
              <th class="text-left py-2 pr-4">t=4</th>
              <th class="text-left py-2 pr-4">t=6</th>
              <th class="text-left py-2 pr-4">t=8</th>
              <th class="text-left py-2 pr-4">t=12</th>
              <th class="text-left py-2 pr-4">t=16</th>
              <th class="text-left py-2">t=24</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4" colspan="7">
                <strong>10<sup>4</sup> Perms/s</strong>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Anemoi</td>
              <td class="py-2 pr-4">1.2</td>
              <td class="py-2 pr-4">0.9</td>
              <td class="py-2 pr-4">1.7</td>
              <td class="py-2 pr-4">1.2</td>
              <td class="py-2 pr-4">3.6</td>
              <td class="py-2">2.2</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">5.5</td>
              <td class="py-2 pr-4">3.4</td>
              <td class="py-2 pr-4">8.8</td>
              <td class="py-2 pr-4">4.9</td>
              <td class="py-2 pr-4">7.9</td>
              <td class="py-2">4.0</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon2<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">5.6</td>
              <td class="py-2 pr-4">3.4</td>
              <td class="py-2 pr-4">10.1</td>
              <td class="py-2 pr-4">7.0</td>
              <td class="py-2 pr-4">13.2</td>
              <td class="py-2">8.9</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4" colspan="7">
                <strong>&mu;s/Perm</strong>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Anemoi</td>
              <td class="py-2 pr-4">8.3</td>
              <td class="py-2 pr-4">11.7</td>
              <td class="py-2 pr-4">6.0</td>
              <td class="py-2 pr-4">8.4</td>
              <td class="py-2 pr-4">2.8</td>
              <td class="py-2">4.5</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">1.8</td>
              <td class="py-2 pr-4">3.0</td>
              <td class="py-2 pr-4">1.1</td>
              <td class="py-2 pr-4">2.0</td>
              <td class="py-2 pr-4">1.3</td>
              <td class="py-2">2.5</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                Poseidon2<sub>B</sub><sup>&pi;</sup>
              </td>
              <td class="py-2 pr-4">1.8</td>
              <td class="py-2 pr-4">3.0</td>
              <td class="py-2 pr-4">1.0</td>
              <td class="py-2 pr-4">1.4</td>
              <td class="py-2 pr-4">0.8</td>
              <td class="py-2">1.1</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p class="text-gray-300">
        Across all binary-field instantiations,
        Poseidon2<sub>B</sub><sup>&pi;</sup> consistently delivers
        the highest throughput. Compared to
        Poseidon<sub>B</sub>, it yields higher efficiency when
        <span class="math">t \ge 8</span>, as its linear layer
        amortizes better as the state grows. Anemoi exhibits notably
        lower throughput and higher latency across all tested state
        widths.
      </p>

      <h3 id="sec-6.4" class="text-xl font-semibold mt-8">
        6.4 Open Problems
      </h3>
      <p class="text-gray-300">
        Given the importance of efficient zero-knowledge proofs,
        native implementations of Poseidon2<sub>B</sub> tailored
        towards different use cases (such as small versus large
        binary fields), hardware realizations, and adaptations to
        other proof systems or arithmetization techniques remain
        attractive targets for future work.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7. ACKNOWLEDGMENT                                            -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7. Acknowledgment</h2>
      <p class="text-gray-300">
        Authors thank the CiC anonymous Reviewers for pointing out a
        mistake in the analysis of the truncated differentials.
        Lorenzo Grassi was supported by the European Research Council
        (ERC), grant number 101160608 "SYMPZON".
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">Appendix A. Algebraic Attacks</h2>

      <h3 class="text-xl font-semibold mt-8">
        A.1 Round-skipping Tricks Revisited
      </h3>

      <h4 class="text-lg font-semibold mt-6">
        A.1.1 Skipping the first full (external) round
      </h4>
      <p class="text-gray-300">
        The goal is to find a
        <span class="math">k</span>-dimensional affine subspace of
        <span class="math">\mathbb&#123;F&#125;_q^t</span> after the first
        linear layer such that the input constraints are fulfilled
        when going in the backwards direction. Setting individual
        summands to zero yields linear equation systems
        <span class="math">\mathsf&#123;L&#125;_\ell</span>. A non-zero
        solution can only be found if
        <span class="math">k \le \lfloor (t - 2k) / k
        \rfloor</span>. The approach is applicable to CICO-k
        settings whenever
        <span class="math">k \le t/2</span> and the above
        condition is fulfilled, but is not applicable in compression
        mode.
      </p>

      <h4 class="text-lg font-semibold mt-6">
        A.1.2 Skipping several partial (internal) rounds
      </h4>
      <p class="text-gray-300">
        The goal is to find a finite-dimensional affine subspace
        <span class="math">\mathcal&#123;S&#125;^&#123;(\ell)&#125; + \gamma</span>
        which allows to linearize
        <span class="math">\ell \ge 0</span> partial rounds. The
        matrix
        <span class="math">M_\mathcal&#123;I&#125;</span> is carefully
        selected such that the dimension strictly decreases as
        <span class="math">\ell</span> increases. Thus, at most
        <span class="math">t - 1</span> partial rounds can be
        linearized via a non-trivial subspace.
      </p>

      <h3 class="text-xl font-semibold mt-8">
        A.2 Algebraic Models over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>
      </h3>
      <p class="text-gray-300">
        Two primary modeling approaches exist: (1) Direct Forward
        Equations, deriving equations for several rounds in the
        forward direction; (2) Working at Round Level, introducing
        one variable for each S-box input and relating inputs and
        outputs via a single equation. Different strategies (a, b, c)
        can be used to consume available degrees of freedom and
        reduce the solving complexity. When applying a consistent
        approach, the resulting systems exhibit the same ideal
        degree.
      </p>

      <h3 class="text-xl font-semibold mt-8">
        A.3 Practical Results
      </h3>
      <p class="text-gray-300">
        All practical experiments were conducted on a machine with an
        Intel Xeon E5-2630 v3 @ 2.40 GHz (8 cores) and 378 GB RAM
        under Debian 11 using Magma V2.26-2. Results confirm that
        the ideal degree remains identical whether the system is
        modeled via direct forward equations or at round level; the
        difference arises solely from how the degrees of freedom are
        consumed. The B&eacute;zout bound often significantly
        overestimates the ideal degree, which aligns well with the
        conjectured values.
        [Tables 8&ndash;10 in the original paper provide extensive
        B&eacute;zout bound and ideal degree data for different
        algebraic models.]
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX B                                                   -->
    <!-- ============================================================ -->

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix B. Matrices Details
      </h2>

      <h3 class="text-xl font-semibold mt-8">
        B.1 Initialization Vectors for Cauchy Matrices
      </h3>
      <p class="text-gray-300">
        For Poseidon<sub>B</sub><sup>&pi;</sup> with
        <span class="math">n \in \&#123;32, 64\&#125;</span>, the external
        linear layer uses MDS Cauchy matrices. The initialization
        vectors are specified in the official repository.
      </p>

      <h3 class="text-xl font-semibold mt-8">
        B.2 Diagonal Entries of
        <span class="math">M_\mathcal&#123;I&#125;</span>
      </h3>
      <p class="text-gray-300">
        The diagonal entries
        <span class="math">\mu_0, \mu_1, \ldots,
        \mu_&#123;t-1&#125;</span> of the internal matrix
        <span class="math">M_\mathcal&#123;I&#125;</span> are chosen such that
        <span class="math">M_\mathcal&#123;I&#125;</span> is invertible and
        admits no arbitrarily long subspace trails. The concrete
        values are provided in the official
        Poseidon(2)<sub>B</sub> GitHub repository.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="text-sm text-gray-300 space-y-2 mt-4">
        <li>
          [ABM24] Ashur, Buschman, Mahzoun.
          <em>Algebraic Cryptanalysis of the HADES Design Strategy:
          Application to Poseidon and Poseidon2</em>. ACISP 2024.
        </li>
        <li>
          [Aly+20] Aly, Ashur, Ben-Sasson, Dhooghe, Szepieniec.
          <em>Design of Symmetric-Key Primitives for Advanced
          Cryptographic Protocols</em>. ToSC 2020.3.
        </li>
        <li>
          [Ash+24] Ashur, Mahzoun, Posen, Sijacic.
          <em>Vision Mark-32: ZK-Friendly Hash Function Over Binary
          Tower Fields</em>. ePrint 2024/633.
        </li>
        <li>
          [Aum+23] Aumasson, Khovratovich, Mennink, Quine.
          <em>SAFE: Sponge API for Field Elements</em>.
          ePrint 2023/522.
        </li>
        <li>
          [Bak+25a] Bak, Bariant, Boeuf, Briaud, &Oslash;ygarden,
          Phanse. <em>The Algebraic CheapLunch</em>.
          ePrint 2025/2040.
        </li>
        <li>
          [Bak+25b] Bak, Bariant, Boeuf, Hostettler, Jazeron.
          <em>Solving CICO-2 bounty instances of Poseidon</em>.
          EUROCRYPT 2025.
        </li>
        <li>
          [Bar+22] Bariant, Bouvier, Leurent, Perrin.
          <em>Algebraic Attacks against Some
          Arithmetization-Oriented Primitives</em>. ToSC 2022.3.
        </li>
        <li>
          [Bar+24] Bariant, Boeuf, Lemoine et al.
          <em>The Algebraic FreeLunch</em>. CRYPTO 2024.
        </li>
        <li>
          [Bar+25] Bariant, Boeuf, Briaud, Hostettler,
          &Oslash;ygarden, Raddum. <em>Improved Resultant Attack
          Against Arithmetization-Oriented Primitives</em>.
          CRYPTO 2025.
        </li>
        <li>
          [BBS99] Biham, Biryukov, Shamir.
          <em>Cryptanalysis of Skipjack Reduced to 31 Rounds Using
          Impossible Differentials</em>. EUROCRYPT 1999.
        </li>
        <li>
          [Ben+18] Ben-Sasson, Bentov, Horesh, Riabzev.
          <em>Fast Reed-Solomon Interactive Oracle Proofs of
          Proximity</em>. ICALP 2018.
        </li>
        <li>
          [Ber+08] Bertoni, Daemen, Peeters, Van Assche.
          <em>On the Indifferentiability of the Sponge
          Construction</em>. EUROCRYPT 2008.
        </li>
        <li>
          [Bey+20] Beyne, Canteaut, Dinur et al.
          <em>Out of Oddity: New Cryptanalytic Techniques Against
          Symmetric Primitives Optimized for Integrity Proof
          Systems</em>. CRYPTO 2020.
        </li>
        <li>
          [BGL20] Ben-Sasson, Goldberg, Levit.
          <em>STARK Friendly Hash &ndash; Survey and
          Recommendation</em>. ePrint 2020/948.
        </li>
        <li>
          [Bou+23] Bouvier, Briaud, Chaidos, Perrin, Salen,
          Velichkov, Willems. <em>Anemoi Permutations and Jive
          Compression Mode</em>. CRYPTO 2023.
        </li>
        <li>
          [BR97] Bellare, Rogaway.
          <em>Collision-Resistant Hashing: Towards Making UOWHFs
          Practical</em>. CRYPTO 1997.
        </li>
        <li>
          [BS90] Biham, Shamir.
          <em>Differential Cryptanalysis of DES-like
          Cryptosystems</em>. CRYPTO 1990.
        </li>
        <li>
          [Cid+22] Cid, Grassi, Gunsing et al.
          <em>Influence of the Linear Layer on the Algebraic Degree
          in SP-Networks</em>. ToSC 2022.1.
        </li>
        <li>
          [CR25] Campa, Roy.
          <em>Gr&ouml;bner Basis Cryptanalysis of Anemoi</em>.
          EUROCRYPT 2025.
        </li>
        <li>
          [DL18] Duval, Leurent.
          <em>MDS Matrices with Lightweight Circuits</em>.
          ToSC 2018.2.
        </li>
        <li>
          [DP24] Diamond, Posen.
          <em>Polylogarithmic Proofs for Multilinears over Binary
          Towers</em>. ePrint 2024/504.
        </li>
        <li>
          [DP25] Diamond, Posen.
          <em>Succinct Arguments over Towers of Binary Fields</em>.
          EUROCRYPT 2025.
        </li>
        <li>
          [Eth24] Ethereum Foundation.
          <em>Poseidon Cryptanalysis Initiative 2024&ndash;2026</em>.
        </li>
        <li>
          [GKR25] Grassi, Koschatko, Rechberger.
          <em>Poseidon and Neptune: Gr&ouml;bner Basis Cryptanalysis
          Exploiting Subspace Trails</em>. ToSC 2025.2.
        </li>
        <li>
          [GKS23b] Grassi, Khovratovich, Schofnegger.
          <em>Poseidon2: A Faster Version of the Poseidon Hash
          Function</em>. AFRICACRYPT 2023.
        </li>
        <li>
          [Gra+19a] Grassi, Kales, Khovratovich et al.
          <em>Starkad and Poseidon: New Hash Functions for Zero
          Knowledge Proof Systems</em>. ePrint 2019/458.
        </li>
        <li>
          [Gra+19b] Grassi, Khovratovich, Rechberger, Roy,
          Schofnegger. <em>Poseidon: A New Hash Function for
          Zero-Knowledge Proof Systems (Updated Version)</em>.
          ePrint 2019/458.
        </li>
        <li>
          [Gra+21] Grassi, Khovratovich, Rechberger, Roy,
          Schofnegger. <em>Poseidon: A New Hash Function for
          Zero-Knowledge Proof Systems</em>. USENIX Security 2021.
        </li>
        <li>
          [GRS21] Grassi, Rechberger, Schofnegger.
          <em>Proving Resistance Against Infinitely Long Subspace
          Trails</em>. ToSC 2021.2.
        </li>
        <li>
          [JK97] Jakobsen, Knudsen.
          <em>The Interpolation Attack on Block Ciphers</em>.
          FSE 1997.
        </li>
        <li>
          [KR21] Keller, Rosemarin.
          <em>Mind the Middle Layer: The HADES Design Strategy
          Revisited</em>. EUROCRYPT 2021.
        </li>
        <li>
          [LBM25] Lefevre, Beltr&aacute;n, Mennink.
          <em>To Pad or Not to Pad? Padding-Free
          Arithmetization-Oriented Sponges</em>. ToSC 2025.1.
        </li>
        <li>
          [Mer79] Merkle.
          <em>Secrecy, authentication and public key systems</em>.
          PhD thesis, 1979.
        </li>
        <li>
          [Per24] Perrin.
          <em>Security Analysis of XHASH8/12</em>.
          ePrint 2024/605.
        </li>
        <li>
          [Pos25] Poseidon2b.
          <em>Poseidon2b</em>. GitHub repository, 2025.
        </li>
        <li>
          [SV25] Sanso, Vitto.
          <em>Attacking Poseidon via Graeffe-Based Root-Finding
          over NTT-Friendly Fields</em>. ePrint 2025/937.
        </li>
        <li>
          [Yan+24] Yang, Zheng, Yang, Liu, Tang.
          <em>A New Security Evaluation Method Based on Resultant
          for Arithmetic-Oriented Algorithms</em>.
          ASIACRYPT 2024.
        </li>
        <li>
          [ZD25] Zhao, Ding.
          <em>Breaking Poseidon Challenges with Graeffe Transforms
          and Complexity Analysis by FFT Lower Bounds</em>.
          ePrint 2025/950.
        </li>
      </ul>
    </section>

  </article>
</BaseLayout>
