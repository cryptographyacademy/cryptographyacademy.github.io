---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/712';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Survey of Two Verifiable Delay Functions';
const AUTHORS_HTML = 'Dan Boneh, Benedikt Bünz, Ben Fisch';

const CONTENT = `    <p class="text-gray-300">A Survey of Two Verifiable Delay Functions</p>

    <p class="text-gray-300">Dan Boneh</p>

    <p class="text-gray-300">Benedikt Bünz</p>

    <p class="text-gray-300">Ben Fisch</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">A verifiable delay function (VDF) is an important tool used for adding delay in decentralized applications. This short note briefly surveys and compares two recent beautiful Verifiable Delay Functions (VDFs), one due to Pietrzak and the other due to Wesolowski. We also provide a new computational proof of security for one of them, and compare the complexity assumptions needed for both schemes.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 What is a Verifiable Delay Function?</h2>

    <p class="text-gray-300">A verifiable delay function (VDF) <em>[11, 2]</em> is a function <span class="math">f:\\mathcal{X}\\to\\mathcal{Y}</span> that takes a prescribed time to compute, even on a parallel computer. However once computed, the output can be quickly verified by anyone. Moreover, every input <span class="math">x\\in\\mathcal{X}</span> must have a unique valid output <span class="math">y\\in\\mathcal{Y}</span>.</p>

    <p class="text-gray-300">In more detail, a VDF that implements a function <span class="math">\\mathcal{X}\\to\\mathcal{Y}</span> is a tuple of three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup</em>(<span class="math">\\lambda,T)\\to pp</span> is a randomized algorithm that takes a security parameter <span class="math">\\lambda</span> and a time bound <span class="math">T</span>, and outputs public parameters <span class="math">pp</span>,</li>

      <li><em>Eval</em>(<span class="math">pp,x)\\to(y,\\pi)</span> takes an input <span class="math">x\\in\\mathcal{X}</span> and outputs a <span class="math">y\\in\\mathcal{Y}</span> and a proof <span class="math">\\pi</span>.</li>

      <li><em>Verify</em>(<span class="math">pp,x,y,\\pi)\\to\\{\\textit{accept},\\textit{reject}\\}</span> outputs <em>accept</em> if <span class="math">y</span> is the correct evaluation of the VDF on input <span class="math">x</span>.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">(y,\\pi)\\leftarrow F(pp,x)</span> then <em>Verify</em>(<span class="math">pp,x,y,\\pi)</span> = <em>accept</em>, for all <span class="math">x\\in\\mathcal{X}</span> and <span class="math">pp</span> output by <em>Setup</em>(<span class="math">\\lambda,T</span>). A VDF must satisfy three properties. We state these properties informally and refer to <em>[2]</em> for a complete definition:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em><span class="math">\\epsilon</span>-evaluation time</em>: algorithm <em>Eval</em>(<span class="math">pp,x</span>) runs in time at most <span class="math">(1+\\epsilon)T</span>, for all <span class="math">x\\in\\mathcal{X}</span> and all <span class="math">pp</span> output by <em>Setup</em>(<span class="math">\\lambda,T</span>). We will explain how to measure run time in the next section.</li>

      <li><em>Sequentiality</em>: a parallel algorithm <span class="math">\\mathcal{A}</span>, using at most <em>poly</em>(<span class="math">\\lambda</span>) processors, that runs in time less than <span class="math">T</span> cannot compute the function. Specifically, for a random <span class="math">x\\in\\mathcal{X}</span> and <span class="math">pp</span> output by <em>Setup</em>(<span class="math">\\lambda,T</span>), if <span class="math">(y,\\pi)\\leftarrow</span> <em>Eval</em>(<span class="math">pp,x</span>) then <span class="math">\\Pr\\left[\\mathcal{A}(pp,x)=y\\right]</span> is negligible.</li>

      <li><em>Uniqueness</em>: for an input <span class="math">x\\in\\mathcal{X}</span>, exactly one <span class="math">y\\in\\mathcal{Y}</span> will be accepted by <em>Verify</em>. Specifically, let <span class="math">\\mathcal{A}</span> be an efficient algorithm that given <span class="math">pp</span> as input, outputs <span class="math">(x,y,\\pi)</span> such that <em>Verify</em>(<span class="math">pp,x,y,\\pi)</span> = <em>accept</em>. Then <span class="math">Pr[\\textit{Eval}(pp,x)\\neq y]</span> is negligible.</li>

    </ul>

    <p class="text-gray-300">VDFs have many applications. They are useful for constructing a verifiable randomness beacon, and they provide a “proof of elapsed time” for certain blockchain designs <em>[6]</em>. We refer to <em>[2, Sec. 2]</em> for a survey of their applications.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Two Verifiable Delay Functions</p>

    <p class="text-gray-300">A VDF is based on a computational task that cannot be sped up by parallelism. Exponentiation in a group of unknown order is believed to have this property, and was previously used by Rivest, Shamir, and Wagner <em>[13]</em> to construct a time-lock puzzle. The two recent VDF proposals, one due to Pietrzak <em>[12]</em> and the other due to Wesolowski <em>[14]</em>, similarly make use of the serial nature of this task.</p>

    <p class="text-gray-300">Both VDF constructions operate as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The setup algorithm Setup<span class="math">(\\lambda,T)</span> outputs two objects:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A finite abelian group <span class="math">\\mathbb{G}</span> of unknown order – we will discuss concrete groups in Section 6;</li>

      <li>An efficiently computable hash function <span class="math">H:\\mathcal{X}\\rightarrow\\mathbb{G}</span> that we model as a random oracle.</li>

    </ul>

    <p class="text-gray-300">We set the public parameters pp to be pp <span class="math">:=(\\mathbb{G},H,T)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The evaluation algorithm Eval(pp,x) is defined as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>compute <span class="math">\\boxed{y\\leftarrow H(x)^{(2^{T})}\\in\\mathbb{G}}</span> by computing <span class="math">T</span> squarings in <span class="math">\\mathbb{G}</span> starting with <span class="math">H(x)</span>,</li>

      <li>compute the proof <span class="math">\\pi</span> as described later,</li>

      <li>output <span class="math">(y,\\pi)</span>.</li>

    </ul>

    <p class="text-gray-300">We measure running time in terms of the number of group operations in <span class="math">\\mathbb{G}</span> needed to compute the function. It is believed that computing <span class="math">y</span> requires <span class="math">T</span> sequential squarings in <span class="math">\\mathbb{G}</span> even on a parallel computer with poly<span class="math">(\\lambda)</span> processors, as required for sequentiality. As we will see, computing the proof <span class="math">\\pi</span> increases the running time to <span class="math">(1+\\epsilon)T</span>, as needed for <span class="math">\\epsilon</span>-evaluation time. In practice one might set <span class="math">T=2^{30}</span> and <span class="math">\\epsilon=0.01</span>.</p>

    <p class="text-gray-300">The remaining question is how a public verifier Verify(pp,x,y,<span class="math">\\pi</span>) can quickly check that the output <span class="math">y</span> is correct, namely that <span class="math">y=H(x)^{(2^{T})}</span>. This is where the proposal of Pietrzak and the proposal of Wesolowski differ. They give two different public-coin succinct arguments for proving that the output <span class="math">y</span> is correct. Thanks to the public-coin nature of these arguments they can be made non-interactive using the Fiat-Shamir Heuristic <em>[3, Sec. 19.6.1]</em>.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Proving correctness of the output <span class="math">y</span>.</h4>

    <p class="text-gray-300">To state the problem more abstractly, let us use the following notation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">g:=H(x)\\in\\mathbb{G}</span> be the base element given as input to the VDF evaluator;</li>

      <li>let <span class="math">h:=y\\in\\mathbb{G}</span> be the purported output of the VDF, namely <span class="math">h=g^{(2^{T})}</span>;</li>

      <li><span class="math">T&gt;0</span> is a publicly known quantity.</li>

    </ul>

    <p class="text-gray-300">The VDF evaluator needs to produce a proof that a given tuple <span class="math">(\\mathbb{G},g,h,T)</span> satisfies <span class="math">h=g^{(2^{T})}</span> in <span class="math">\\mathbb{G}</span>. More precisely, we need a succinct public-coin interactive argument for the language</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\textsc{exp}}:=\\Big{\\{}(\\mathbb{G},g,h,T)\\ :\\ h=g^{(2^{T})}\\ \\text{in}\\ \\mathbb{G}\\Big{\\}}.</span> (1)</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Wesolowski’s succinct argument</h3>

    <p class="text-gray-300">Wesolowski <em>[14]</em> presents the following succinct public-coin interactive argument for the language <span class="math">\\mathcal{L}_{\\textsc{exp}}</span> defined in (1). Specifically, given a tuple <span class="math">(\\mathbb{G},g,h,T)</span> as input, the prover and verifier engage in the following protocol to prove that <span class="math">h=g^{(2^{T})}</span> in <span class="math">\\mathbb{G}</span>. We let <span class="math">\\mathit{Primes}(\\lambda)</span> be the set containing the first <span class="math">2^{\\lambda}</span> primes, namely <span class="math">2,3,5,7</span>, etc.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that <span class="math">g,h\\in\\mathbb{G}</span> and outputs <em>reject</em> if not,</li>

      <li>The verifier sends to the prover a random prime <span class="math">\\ell</span> sampled uniformly from <span class="math">\\mathit{Primes}(\\lambda)</span>,</li>

      <li>The prover computes <span class="math">q,r\\in\\mathbb{Z}</span> such that <span class="math">2^{T}=q\\ell+r</span> with <span class="math">0\\leq r&lt;\\ell</span>, and sends <span class="math">\\pi\\leftarrow g^{q}</span> to the verifier.</li>

      <li>The verifier computes <span class="math">r\\leftarrow 2^{T}\\bmod\\ell</span> and outputs <em>accept</em> if <span class="math">\\pi\\in\\mathbb{G}</span> and <span class="math">h=\\pi^{\\ell}g^{r}</span> in <span class="math">\\mathbb{G}</span></li>

    </ol>

    <p class="text-gray-300">We note that the protocol works equally well when the exponent <span class="math">2^{T}</span> is an arbitrary integer <span class="math">e</span>, not necessarily a power of two. The verifier just needs a quick way to compute <span class="math">r:=e\\bmod\\ell</span>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Non-interactive variant.</h4>

    <p class="text-gray-300">When the protocol is made non-interactive using the Fiat-Shamir heuristic it is necessary to increase the size of the random prime <span class="math">\\ell</span> generated in step (1), otherwise the protocol is insecure, as explained in Section 3.3. In the non-interactive variant obtained by applying Fiat-Shamir, the prover first generates <span class="math">\\ell</span> by using a hash function that maps the input <span class="math">(\\mathbb{G},g,h,T)</span> to an element of <span class="math">\\mathit{Primes}(2\\lambda)</span>, the set containing the first <span class="math">2^{2\\lambda}</span> primes. The analysis will assume that this hash function is a random oracle. The prover computes <span class="math">\\pi\\leftarrow g^{q}</span> as in step (2) above, and outputs this <span class="math">\\pi\\in\\mathbb{G}</span> as the proof. The verifier computes <span class="math">\\ell</span> the same way as the prover and decides to accept or reject as in step (3) above. Overall, the proof <span class="math">\\pi</span> is a single element in <span class="math">\\mathbb{G}</span>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Verifier efficiency.</h4>

    <p class="text-gray-300">The verifier needs to compute <span class="math">r\\leftarrow 2^{T}\\bmod\\ell</span>, which only takes <span class="math">\\log_{2}T</span> multiplications in <span class="math">\\mathbb{Z}/\\ell</span>. Beyond that, the verifier only computes two small exponentiations in <span class="math">\\mathbb{G}</span>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Prover efficiency.</h4>

    <p class="text-gray-300">The prover needs to compute <span class="math">\\pi=g^{q}\\in\\mathbb{G}</span> where <span class="math">q=\\lfloor 2^{T}/\\ell\\rfloor</span>. Because <span class="math">T</span> is large, we cannot write out <span class="math">q</span> as an explicit integer exponent. Nevertheless, we can compute <span class="math">\\pi=g^{q}</span> in at most <span class="math">2T</span> group operations and constant space using the long-division algorithm, where the quotient is computed in the exponent base <span class="math">g</span>.</p>

    <p class="text-gray-300"><span class="math">\\pi\\leftarrow 1\\in\\mathbb{G},\\quad r\\leftarrow 1\\in\\mathbb{Z}</span> repeat <span class="math">T</span> times: <span class="math">b\\leftarrow\\lfloor 2r/\\ell\\rfloor\\in\\{0,1\\}\\text{ and }r\\leftarrow(2r\\bmod\\ell)\\in\\{0,\\ldots,\\ell-1\\}</span> <span class="math">\\pi\\leftarrow\\pi^{2}g^{b}\\in\\mathbb{G}</span> output <span class="math">\\pi</span> <span class="math">//</span> <span class="math">this\\ \\pi\\ equals\\ g^{q}</span></p>

    <p class="text-gray-300">The running time can be reduced to about <span class="math">T</span> group operations using a windowing method where we process <span class="math">k</span> bits of <span class="math">2^{T}</span> per iteration, for some parameter <span class="math">k\\geq 1</span>, say <span class="math">k=5</span>.</p>

    <p class="text-gray-300">In Appendix A we describe an extension that lets us speed up the computation of <span class="math">g^{q}</span> by a factor of <span class="math">s</span> using <span class="math">s</span> processors. Hence, the VDF output and the proof <span class="math">\\pi</span> can be computed in total time</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that  <span class="math">g, h \\in \\mathbb{G}</span>  and outputs reject if not,</li>

      <li>If  <span class="math">T = 1</span>  the verifier checks that  <span class="math">h = g^2</span>  in  <span class="math">\\mathbb{G}</span> , outputs accept or reject, and stops.</li>

      <li>If  <span class="math">T &amp;gt; 1</span>  the prover and verifier do:</li>

    </ol>

    <p class="text-gray-300">(a) The prover computes  <span class="math">v \\gets g^{(2^{T/2})} \\in \\mathbb{G}</span>  and sends  <span class="math">v</span>  to the verifier. The verifier checks that  <span class="math">v \\in \\mathbb{G}</span>  and outputs reject and stops, if not.</p>

    <p class="text-gray-300">Next, the prover needs to convince the verifier that  <span class="math">h = v^{(2^{T/2})}</span>  and  <span class="math">v = g^{(2^{T/2})}</span> , which proves that  <span class="math">h = g^{(2^T)}</span> . Because the same exponent is used in both equalities, they can be verified simultaneously by checking a random linear combination, namely that</p>

    <div class="my-4 text-center"><span class="math-block">v ^ {r} h = \\left(g ^ {r} v\\right) ^ {\\left(2 ^ {T / 2}\\right)} \\quad \\text {f o r a r a n d o m} r \\text {i n} \\{1, \\dots , 2 ^ {\\lambda} \\}.</span></div>

    <p class="text-gray-300">The verifier and prover do so as follows.</p>

    <p class="text-gray-300">(b) The verifier sends to the prover a random  <span class="math">r</span>  in  <span class="math">\\{1,\\dots ,2^{\\lambda}\\}</span> (c) Both the prover and verifier compute  <span class="math">g_{1} \\gets g^{r}v</span>  and  <span class="math">h_1 \\gets v^rh</span>  in  <span class="math">\\mathbb{G}</span> . (d) The prover and verifier recursively engage in an interactive proof that  <span class="math">(\\mathbb{G}, g_1, h_1, T/2) \\in \\mathcal{L}_{\\mathrm{EXP}}</span> , namely that  <span class="math">h_1 = g_1^{(2^{T/2})}</span>  in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Figure 1: Pietrzak's succinct argument for  <span class="math">(\\mathbb{G},g,h,T)\\in \\mathcal{L}_{\\mathrm{EXP}}</span></p>

    <p class="text-gray-300">approximately  <span class="math">(1 + \\frac{1}{s})T</span>  with  <span class="math">s</span>  processors and space  <span class="math">s</span> . Wesolowski [14] shows that with space  <span class="math">2^k</span>  one can further speed-up the computation by a factor of  <span class="math">k</span> .</p>

    <p class="text-gray-300">Pietrzak [12] presents a different succinct public-coin interactive argument for the language  <span class="math">\\mathcal{L}_{\\mathrm{EXP}}</span>  defined in (1). Specifically, given a tuple  <span class="math">(\\mathbb{G},g,h,T)</span>  as input, the prover and verifier engage in a recursive protocol shown in Figure 1 to prove that  <span class="math">h = g^{(2^T)}</span>  in  <span class="math">\\mathbb{G}</span> . For simplicity, we assume that  <span class="math">T</span>  is a power of two in which case the protocol takes  <span class="math">\\log_2 T</span>  rounds. The protocol can be adjusted to handle arbitrary  <span class="math">T</span> , including a  <span class="math">T</span>  that is not a power of two [12].</p>

    <p class="text-gray-300">Non-interactive variant. When the protocol is made non-interactive using Fiat-Shamir the prover generates the challenge  <span class="math">r</span>  in every level of the recursion by hashing the quantities  <span class="math">(\\mathbb{G}, g, h, T, v)</span>  at that level, and appends  <span class="math">v</span>  to the overall proof  <span class="math">\\pi</span> . Hence, the overall proof  <span class="math">\\pi</span>  contains  <span class="math">\\log_2 T</span>  elements in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Verifier efficiency. At every level of the recursion the verifier does two small exponentiations in  <span class="math">\\mathbb{G}</span>  to compute  <span class="math">g_{1}</span>  and  <span class="math">h_1</span>  for the next level. Hence, verifying the proof takes about  <span class="math">2\\log_2T</span>  small exponentiations in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Prover efficiency. The prover needs to compute the quantity <span class="math">v</span> at every level of the recursion. We let <span class="math">v_{1}, r_{1}</span> be the values of <span class="math">v</span> and <span class="math">r</span> at the top level of the recursion, <span class="math">v_{2}, r_{2}</span> the values at the next level, and so on. Unwinding the recursion shows that these quantities are:</p>

    <p class="text-gray-300"><span class="math">v_{1}</span> <span class="math">=g^{(2^{T/2})}</span> <span class="math">v_{2}</span> <span class="math">=g_{1}^{(2^{T/4})}=(g^{r_{1}}v_{1})^{(2^{T/4})}=\\left(g^{(2^{T/4})}\\right)^{r_{1}}g^{(2^{3T/4})}</span> <span class="math">v_{3}</span> <span class="math">=g_{2}^{(2^{T/8})}=(g_{1}^{r_{2}}v_{2})^{(2^{T/8})}=(g^{r_{1}r_{2}}v_{1}^{r_{2}}v_{2})^{(2^{T/8})}=\\left(g^{(2^{T/8})}\\right)^{r_{1}r_{2}}\\left(g^{(2^{3T/8})}\\right)^{r_{1}}\\left(g^{(2^{5T/8})}\\right)^{r_{2}}g^{(2^{7T/8})}</span> <span class="math">v_{4}</span> <span class="math">=g_{3}^{(2^{T/16})}=\\text{a power product of eight elements }g^{(2^{T/16})},\\ g^{(2^{3T/16})},\\ g^{(2^{5T/16})},\\ \\dots,\\ g^{(2^{15T/16})}.</span></p>

    <p class="text-gray-300">The pattern that emerges suggests an efficient way to construct the proof <span class="math">\\pi</span>. When the VDF evaluator first computes the VDF output <span class="math">h=g^{(2^{T})}</span> it stores <span class="math">2^{d}</span> group elements <span class="math">g^{(2^{(i\\cdot T/2^{d})})}</span> for <span class="math">i=0,\\dots,2^{d}-1</span> as they are encountered along the way. Later, as it constructs the proof <span class="math">\\pi</span>, these <span class="math">2^{d}</span> stored values let it compute the group elements <span class="math">v_{1},\\dots,v_{d}</span> needed for the proof using a total of about <span class="math">2^{d}</span> small exponentiations in <span class="math">\\mathbb{G}</span>. The prover computes the remaining elements <span class="math">v_{d+1},v_{d+2},\\dots,v_{\\log T}</span> from scratch by raising <span class="math">g_{d+1},g_{d+2},\\dots,g_{\\log T}</span> to the appropriate exponents. This step takes a total of <span class="math">T/2^{d}</span> multiplications in <span class="math">\\mathbb{G}</span>. Hence, the total time to compute the proof is about <span class="math">2^{d}+T/2^{d}</span>, which suggests that <span class="math">d=\\frac{1}{2}\\log_{2}T</span> is optimal. Hence, the VDF output and the proof <span class="math">\\pi</span> can be computed in total time approximately <span class="math">(1+\\frac{2}{\\sqrt{T}})T</span>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Security assumptions needed to prove soundness</h2>

    <p class="text-gray-300">To analyze security of these interactive arguments for <span class="math">\\mathcal{L}_{\\textsc{exp}}</span> we rely on two complexity assumptions: the low order assumption and the adaptive root assumption. We prove security of Pietrzak’s argument in groups where the low order assumption holds. We prove security of Wesolowski’s argument in groups where the adaptive root assumption holds. We discuss the relation between these assumptions in Section 4.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Notation.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In what follows we use <span class="math">x\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}S</span> to denote an independent uniform random variable over the set <span class="math">S</span>, and use <span class="math">y\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathcal{A}(x)</span> to denote the random variable that is the output of a randomized algorithm <span class="math">\\mathcal{A}</span> on input <span class="math">x</span>. We say that a function <span class="math">f:\\mathbb{Z}\\rightarrow\\mathbb{R}</span> is a negligible function of <span class="math">\\lambda</span> if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=o(1/\\lambda^{d})<span class="math"> for all </span>d>0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 Security of Pietrzak’s succinct argument</h3>

    <p class="text-gray-300">Let <span class="math">GGen(\\lambda)</span> be a randomized algorithm that outputs the description of a group <span class="math">\\mathbb{G}</span> of unknown order. The low order assumption says that it is hard to find a low order element in a random group output by <span class="math">GGen(\\lambda)</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">We say that the low order assumption holds for GGen if there is no efficient algorithm <span class="math">\\mathcal{A}</span> that takes as input the description of a group <span class="math">\\mathbb{G}</span> generated by GGen<span class="math">(\\lambda)</span>, and outputs a pair <span class="math">(\\mu,d)</span> where <span class="math">\\mu^{d}=1</span> for <span class="math">1\\neq\\mu\\in\\mathbb{G}</span> and <span class="math">1&lt;d&lt;2^{\\lambda}</span>. We say that <span class="math">\\mathcal{A}</span> outputs a low order element <span class="math">\\mu</span> in <span class="math">\\mathbb{G}</span>. More precisely, the advantage</p>

    <p class="text-gray-300"><span class="math">\\textsc{LOadv}_{\\mathcal{A},GGen}(\\lambda):=\\Pr\\left[\\ \\mu^{d}=1,\\ \\ 1\\neq\\mu\\in\\mathbb{G},\\ \\ 1&lt;d&lt;2^{\\lambda},\\ \\ :\\ \\ \\ \\ \\ \\mathbb{G}\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\textsc{GGen}(\\lambda),\\\\ \\ \\ \\ \\ \\ \\ \\ (\\mu,d)\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathcal{A}(\\mathbb{G})\\ \\ \\right]</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">is a negligible function of <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">The following theorem proves soundness of Pietrzak's succinct argument using the low order assumption. The proof is given in Section 5.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Suppose the low order assumption holds for GGen. Then Pietrzak's succinct argument has negligible soundness error.</p>

    <p class="text-gray-300">Concretely, let <span class="math">\\mathcal{A}</span> be an algorithm that succeeds with probability <span class="math">\\epsilon</span> in the following task: <span class="math">\\mathcal{A}</span> takes a description of <span class="math">\\mathbb{G} \\xleftarrow{\\mathrm{u}} \\mathrm{GGen}(\\lambda)</span> as input, outputs a tuple <span class="math">(\\mathbb{G}, g, h, T) \\notin \\mathcal{L}_{\\mathrm{EXP}}</span> where <span class="math">1 \\leq T &amp;lt; 2^t</span> is a power of two, and convinces the verifier to incorrectly accept this tuple. Then there is an algorithm <span class="math">\\mathcal{B}</span>, whose running time is about twice that of <span class="math">\\mathcal{A}</span>, that breaks the low order assumption for GGen with advantage at least <span class="math">\\epsilon&#x27; = (\\epsilon^2 / t) - (\\epsilon / 2^\\lambda)</span>. Hence if <span class="math">\\epsilon&#x27;</span> is negligible then so must be <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300"><strong>Necessity of the low order assumption.</strong> The low order assumption is necessary for soundness of the protocol – if the assumption does not hold for GGen then the protocol becomes insecure. To see why, let <span class="math">\\mathbb{G} \\xleftarrow{\\mathrm{u}} \\mathrm{GGen}(\\lambda)</span> and let <span class="math">\\mu \\in \\mathbb{G}</span> be a known element of order <span class="math">d &amp;gt; 1</span> (i.e., low order is broken). Let <span class="math">(\\mathbb{G}, g, h, T) \\in \\mathcal{L}_{\\mathrm{EXP}}</span>. Then the tuple <span class="math">(\\mathbb{G}, g, h\\mu, T) \\notin \\mathcal{L}_{\\mathrm{EXP}}</span> will be incorrectly accepted by the verifier with probability <span class="math">1/d</span>. To do so the prover sends <span class="math">v \\gets g^{(2^{T/2})}\\mu \\in \\mathbb{G}</span> which causes the tuple <span class="math">(\\mathbb{G}, g, h\\mu, T)</span> to be incorrectly accepted whenever the verifier chooses an <span class="math">r</span> satisfying <span class="math">r + 1 \\equiv 2^{T/2} \\pmod{d}</span>. This happens with probability <span class="math">1/d</span>, which is non-negligible when <span class="math">d</span> is small. Note that when <span class="math">r + 1 \\equiv 2^{T/2} \\pmod{d}</span> we have that <span class="math">(\\mathbb{G}, g^r v, v^r(h\\mu), T/2) \\in \\mathcal{L}_{\\mathrm{EXP}}</span>, which is why the tuple <span class="math">(\\mathbb{G}, g, h\\mu, T)</span> is incorrectly accepted.</p>

    <p class="text-gray-300">Note that if the group <span class="math">\\mathbb{G}</span> contains no low order elements other than the identity, then the low order assumption holds unconditionally, as does soundness of Pietrzak's succinct argument. We discuss this further in Section 6.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3.2 Security of Wesolowski's succinct argument</h2>

    <p class="text-gray-300">For the next assumption recall that <span class="math">\\mathrm{Primes}(\\lambda)</span> denotes the set of first <span class="math">2^{\\lambda}</span> positive integer primes.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> We say that the adaptive root assumption holds for GGen if there is no efficient adversary <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span> that succeeds in the following task. First, <span class="math">\\mathcal{A}_1</span> outputs an element <span class="math">w \\in \\mathbb{G}</span> and some state. Then, a random prime <span class="math">\\ell</span> in <span class="math">\\mathrm{Primes}(\\lambda)</span> is chosen and <span class="math">\\mathcal{A}_2(\\ell, \\text{state})</span> outputs <span class="math">w^{1/\\ell} \\in \\mathbb{G}</span>. More precisely, the advantage</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{ARadv}_{(\\mathcal{A}_1, \\mathcal{A}_2), \\mathrm{GGen}}(\\lambda) := \\Pr \\left[ u^\\ell = w \\neq 1 : \\begin{array}{l} \\mathbb{G} \\xleftarrow{\\mathrm{u}} \\mathrm{GGen}(\\lambda), \\\\ (w, \\text{state}) \\xleftarrow{\\mathrm{u}} \\mathcal{A}_1(\\mathbb{G}), \\\\ \\ell \\xleftarrow{\\mathrm{u}} \\mathrm{Primes}(\\lambda), \\\\ u \\xleftarrow{\\mathrm{u}} \\mathcal{A}_2(\\ell, \\text{state}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">is a negligible function of <span class="math">\\lambda</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The advantage is always at least $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Primes}(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Indeed, if the adversary </span>(\\mathcal{A}_1, \\mathcal{A}_2)<span class="math"> correctly guesses </span>\\ell \\in \\mathrm{Primes}(\\lambda)<span class="math"> ahead of time, then </span>\\mathcal{A}_1<span class="math"> would output </span>w \\gets u^\\ell<span class="math">, for some </span>u \\in \\mathbb{G}<span class="math">, and </span>\\mathcal{A}_2<span class="math"> would output this </span>u<span class="math">. This is why we must choose the set </span>\\mathrm{Primes}(\\lambda)<span class="math"> to be sufficiently large. The reason we cannot choose </span>\\ell<span class="math"> uniformly in some interval, but must choose it from </span>\\mathrm{Primes}(\\lambda)<span class="math">, is because a random </span>\\ell<span class="math"> in </span>\\{1, \\ldots, 2^\\lambda\\}$ has a reasonable chance of being a smooth integer. The adversary can then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{A}_{1}</span> output <span class="math">w\\leftarrow u^{B}</span> where <span class="math">B</span> is a product of small prime powers up to some bound <span class="math">k</span>, and having <span class="math">\\mathcal{A}_{2}</span> output <span class="math">u^{B/\\ell}</span>. This works whenever <span class="math">\\ell</span> is a <span class="math">k</span>-smooth integer. Choosing <span class="math">\\ell</span> as a prime number eliminates this attack.</p>

    <p class="text-gray-300">The following theorem proves soundness of Wesolowski’s succinct argument using the low order assumption. The proof is given in Section 5.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Theorem 2 (Wesolowski <em>[14]</em>).</h6>

    <p class="text-gray-300">Suppose the adaptive root assumption holds for GGen. Then Wesolowski’s succinct argument has negligible soundness error.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Concretely, let <span class="math">\\mathcal{A}</span> be an algorithm that succeeds with probability <span class="math">\\epsilon</span> in the following task: <span class="math">\\mathcal{A}</span> takes <span class="math">\\mathbb{G}\\stackrel{{\\scriptstyle\\circ}}{{{\\leftarrow}}}</span> GGen<span class="math">(\\lambda)</span> as input, outputs a tuple <span class="math">(\\mathbb{G},g,h,T)\\not\\in\\mathcal{L}_{\\text{\\tiny EXP}}</span>, and convinces the verifier to incorrectly accept this tuple. Then there is an adversary <span class="math">(\\mathcal{B}_{1},\\mathcal{B}_{2})</span> whose combined running time is about the same as the running time of <span class="math">\\mathcal{A}</span> plus the time to compute <span class="math">T</span> squarings in <span class="math">\\mathbb{G}</span>. This <span class="math">(\\mathcal{B}_{1},\\mathcal{B}_{2})</span> breaks the adaptive root assumption for GGen with the same advantage <span class="math">\\epsilon</span> that <span class="math">\\mathcal{A}</span> breaks soundness.</p>
    </blockquote>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Necessity of the adaptive root assumption.</h4>

    <p class="text-gray-300">The adaptive root assumption is necessary for soundness of the protocol – if the assumption does not hold for GGen then the protocol becomes insecure. To see why, let <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> be an adaptive root adversary and let <span class="math">\\mathbb{G}\\stackrel{{\\scriptstyle\\circ}}{{{\\leftarrow}}}</span> GGen<span class="math">(\\lambda)</span>. To break the protocol using <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> choose an arbitrary <span class="math">g\\in\\mathbb{G}</span>, fix some <span class="math">T</span>, and run <span class="math">(w,\\texttt{state})\\leftarrow\\mathcal{A}_{1}(\\mathbb{G})</span>, where <span class="math">w\\neq 1</span>. Let <span class="math">h\\leftarrow g^{(2^{T})}</span>. Now, let’s see how to convince the verifier to incorrectly accept the tuple <span class="math">(\\mathbb{G},\\ g,\\ wh,\\ T)\\not\\in\\mathcal{L}_{\\text{\\tiny EXP}}</span>. The verifier outputs a random <span class="math">\\ell\\in Primes(\\lambda)</span> and we need to produce a <span class="math">\\pi</span> such that <span class="math">wh=\\pi^{\\ell}g^{r}</span> where <span class="math">2^{T}=q\\ell+r</span> and <span class="math">0\\leq r&lt;\\ell</span>. To do so, we run <span class="math">\\mathcal{A}_{2}(\\ell,\\texttt{state})</span> to a get <span class="math">u\\in\\mathbb{G}</span> such that <span class="math">u^{\\ell}=w</span>. Then <span class="math">\\pi:=ug^{q}</span> is a valid proof because</p>

    <p class="text-gray-300"><span class="math">\\pi^{\\ell}g^{r}=(ug^{q})^{\\ell}g^{r}=u^{\\ell}g^{q\\ell+r}=u^{\\ell}g^{(2^{T})}=wh,</span></p>

    <p class="text-gray-300">as required.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.3 Security of the non-interactive variants</h3>

    <p class="text-gray-300">While Theorems 1 and 2 analyze the interactive variants of the protocols, the non-interactive variants obtained by applying the Fiat-Shamir heuristic can be similarly shown to be secure by an analysis in the random oracle model.</p>

    <p class="text-gray-300">Interestingly, for Wesolowski’s succinct argument, there is a loss in soundness between the interactive and non-interactive variants of the protocol, as already mentioned in Section 2.1. This forces us to generate the challenge prime <span class="math">\\ell</span> from the set <span class="math">Primes(2\\lambda)</span> instead of <span class="math">Primes(\\lambda)</span>; otherwise there is a <span class="math">\\tilde{O}(2^{\\lambda/2})</span> time attack on the non-interactive succinct argument. Sampling <span class="math">\\ell</span> from <span class="math">Primes(2\\lambda)</span> makes the attack time <span class="math">\\tilde{O}(2^{\\lambda})</span>, which is infeasible. It also makes it possible to prove soundness in the random oracle model <em>[14]</em>. This is an example where the Fiat-Shamir heuristic harms the soundness of an argument, and forces the verifier to choose a larger challenge to compensate.</p>

    <p class="text-gray-300">Let’s see the <span class="math">\\tilde{O}(2^{\\lambda/2})</span> time attack. Suppose <span class="math">\\ell</span> is generated using a hash function <span class="math">H</span> that maps an input <span class="math">(\\mathbb{G},g,h,T)</span> to a prime <span class="math">\\ell</span> in <span class="math">Primes(\\lambda)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">S=\\{\\ell_{1},\\ldots,\\ell_{d}\\}\\subset Primes(\\lambda)</span> be a subset of <span class="math">d=2^{\\lambda/2}</span> primes.</li>

      <li>Set <span class="math">L:=\\prod_{i=1}^{d}\\ell_{i}\\in\\mathbb{Z},\\ \\ \\ w:=g^{L}\\in\\mathbb{G},\\ \\ \\ \\text{and}\\ \\ \\ h:=g^{(2^{T})}\\in\\mathbb{G}.</span></li>

    </ul>

    <p class="text-gray-300">The attacker finds the smallest <span class="math">k\\geq 1</span> such that</p>

    <p class="text-gray-300"><span class="math">H(\\mathbb{G},\\ g,\\ hw^{k},\\ T)=\\ell\\quad\\text{and}\\quad\\ell\\in S.</span> (2)</p>

    <p class="text-gray-300">If we model <span class="math">H</span> as a random oracle, then each candidate <span class="math">k=1,2,\\ldots</span> satisfies (2) with probability <span class="math">d/2^{\\lambda}=2^{-\\lambda/2}</span>. Therefore, finding <span class="math">k</span> takes an expected <span class="math">O(2^{\\lambda/2})</span> tries. Once <span class="math">k</span> is found, observe that</p>

    <p class="text-gray-300"><span class="math">\\pi:=g^{(2^{T}/\\ell]}\\cdot g^{k(L/\\ell)}\\qquad\\text{satisfies}\\qquad\\pi^{\\ell}=\\left(h\\cdot g^{-(2^{T}\\bmod\\ell)}\\right)\\cdot w^{k},</span></p>

    <p class="text-gray-300">and the attacker can compute this <span class="math">\\pi</span> because the exponent <span class="math">(L/\\ell)</span> is an integer. This <span class="math">\\pi</span> incorrectly convinces the verifier that <span class="math">h^{\\prime}:=hw^{k}</span> satisfies <span class="math">h^{\\prime}=g^{(2^{T})}</span>. Indeed, the verification condition</p>

    <p class="text-gray-300"><span class="math">\\pi^{\\ell}\\cdot g^{(2^{T}\\bmod\\ell)}=hw^{k}=h^{\\prime}</span></p>

    <p class="text-gray-300">is satisfied, thus breaking soundness. The complete attack runs in expected time <span class="math">\\tilde{O}(2^{\\lambda/2})</span>, which is needed to compute <span class="math">w</span> and to find <span class="math">k</span>, as promised.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4 Comparison of the two protocols</h2>

    <p class="text-gray-300">Each proof system has its own strengths and no one dominates the other. The proof system of Wesolowski <em>[14]</em> produces shorter proofs (one group element versus <span class="math">\\log_{2}T</span> elements) and proof verification is faster (two exponentiations versus <span class="math">2\\log_{2}T</span>). However, the proof of Pietrzak <em>[12]</em> has two advantages discussed below.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Prover efficiency.</h4>

    <p class="text-gray-300">For the VDF application, Pietrzak’s prover is more efficient. It takes <span class="math">O(\\sqrt{T})</span> group operations to construct the proof, where as for Wesolowski it takes <span class="math">O(T)</span>. Both provers parallelize well and can be sped up by a factor of <span class="math">s</span> using <span class="math">s</span> processors, for a moderate value of <span class="math">s</span>.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Comparison of the assumptions.</h4>

    <p class="text-gray-300">If Wesolowski’s protocol is secure then so is Pietrzak’s, but the converse is not known to be true. The reason is that if the adaptive root assumption holds then so must the low order assumption. In other words, adaptive root is potentially a stronger assumption than low order.</p>

    <p class="text-gray-300">To show that the adaptive root assumption implies the low order assumption we show the converse – if low order is broken then so is adaptive root. Let <span class="math">\\mathbb{G}\\xleftarrow{\\circ}\\ GGen(\\lambda)</span> and let <span class="math">1\\neq\\mu\\in\\mathbb{G}</span> be a public element satisfying <span class="math">\\mu^{d}=1</span> for a known <span class="math">d&gt;1</span> (i.e., low order is broken). To break the adaptive root assumption, the adversary <span class="math">\\mathcal{A}_{1}</span> outputs <span class="math">\\mu</span>, and when given a random prime number <span class="math">\\ell\\in Primes(\\lambda)</span>, adversary <span class="math">\\mathcal{A}_{2}</span> computes <span class="math">\\mu^{1/\\ell}</span> as <span class="math">\\mu^{(\\ell^{-1}\\bmod d)}</span>. This works as long as <span class="math">d</span> is not a multiple of <span class="math">\\ell</span>, which only happens with negligible probability.</p>

    <h2 id="sec-20" class="text-2xl font-bold">5 Security proofs</h2>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Proof of Theorem 2.</h4>

    <p class="text-gray-300">We construct an adaptive root adversary <span class="math">(\\mathcal{B}_{1},\\mathcal{B}_{2})</span> that uses <span class="math">\\mathcal{A}</span>. When <span class="math">\\mathcal{B}_{1}</span> is initialized with input <span class="math">\\mathbb{G}</span>, it runs <span class="math">\\mathcal{A}(\\mathbb{G})</span> and gets back <span class="math">(\\mathbb{G},g,h,T)\\not\\in\\mathcal{L}_{\\text{\\tiny EXP}}</span>. Algorithm <span class="math">\\mathcal{B}_{1}</span> then outputs <span class="math">w\\leftarrow h/g^{(2^{T})}\\in\\mathbb{G},\\ \\mathsf{state}\\leftarrow(\\mathbb{G},g,h,T,w)</span> and exits. Note that because <span class="math">h\\neq g^{(2^{T})}</span> we have that <span class="math">w\\neq 1</span>, as required of an adaptive root adversary.</p>

    <p class="text-gray-300">Next, a random <span class="math">\\ell \\in \\text{Primes}(\\lambda)</span> is chosen and <span class="math">\\mathcal{B}_2(\\ell, \\text{state})</span> is activated. Let <span class="math">2^T = q\\ell + r</span> with <span class="math">0 \\leq r &amp;lt; \\ell</span>. Algorithm <span class="math">\\mathcal{B}_2</span> sends the <span class="math">\\ell</span> it was given to <span class="math">\\mathcal{A}</span>, and <span class="math">\\mathcal{A}</span> outputs <span class="math">\\pi \\in \\mathbb{G}</span>. Now, <span class="math">\\mathcal{B}_2</span> outputs <span class="math">u \\gets \\pi / g^q \\in \\mathbb{G}</span> and exits. If <span class="math">\\mathcal{A}</span> outputs a valid proof, namely <span class="math">\\pi</span> satisfies <span class="math">h = \\pi^\\ell g^r</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">u ^ {\\ell} = \\left(\\pi / g ^ {q}\\right) ^ {\\ell} = \\pi^ {\\ell} g ^ {r} / g ^ {q \\ell + r} = h / g ^ {(2 ^ {T})} = w.</span></div>

    <p class="text-gray-300">Hence, <span class="math">(\\mathcal{B}_1,\\mathcal{B}_2)</span> succeeds in breaking the adaptive root assumption with the same advantage as <span class="math">\\mathcal{A}</span> succeeds in breaking soundness, as required.</p>

    <p class="text-gray-300">Proof of Theorem 1. We use a forking argument to construct an adversary <span class="math">\\mathcal{B}</span> that breaks the low order assumption using <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Recall that <span class="math">2^t</span> is an upper bound on the value <span class="math">T</span> output by <span class="math">\\mathcal{A}</span>. Let <span class="math">\\mathcal{A}(\\mathbb{G}, r_0, \\ldots, r_{t-1}; R)</span> denote an execution of <span class="math">\\mathcal{A}</span> with random tape <span class="math">R</span>, where <span class="math">r_0, \\ldots, r_{t-1}</span> are the verifier's challenges at each level of the recursion. The adversary <span class="math">\\mathcal{A}</span> outputs the protocol transcript which is a sequence of <span class="math">t+1</span> tuples:</p>

    <div class="my-4 text-center"><span class="math-block">(P _ {0}, v _ {0}), \\ldots , (P _ {t}, v _ {t})</span></div>

    <p class="text-gray-300">where <span class="math">P_{i} = (\\mathbb{G},g_{i},h_{i},T / 2^{i})</span> is the input to the recursion at level <span class="math">i</span>, and <span class="math">v_{i}</span> is the prover's message at level <span class="math">i</span>. Recall that <span class="math">g_{i}\\gets g_{i - 1}^{r_{i - 1}}v_{i - 1}</span> and <span class="math">h_i\\gets v_{i - 1}^{r_{i - 1}}h_{i - 1}</span> for <span class="math">i = 1,\\ldots ,t</span>. Here we assume <span class="math">T = 2^t</span>, but if <span class="math">T &amp;lt; 2^{t}</span> then we replicate the last pair <span class="math">(P_{\\log_2T},v_{\\log_2T})</span> to get a full transcript of <span class="math">t + 1</span> tuples.</p>

    <p class="text-gray-300">Next, define the following probabilistic experiment EXP:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>choose a random tape <span class="math">R</span> for <span class="math">\\mathcal{A}</span>.</li>

      <li>choose uniform <span class="math">r_0, \\ldots, r_{t-1}</span> in <span class="math">\\{1, \\ldots, 2^{\\lambda}\\}</span>.</li>

      <li>run <span class="math">\\mathcal{A}(\\mathbb{G},r_0,\\ldots ,r_{t - 1};R)</span> to get <span class="math">(P_0,v_0),\\dots ,(P_t,v_t)</span>.</li>

      <li>if <span class="math">P_0 \\notin \\mathcal{L}_{\\mathrm{EXP}}</span> but <span class="math">P_t \\in \\mathcal{L}_{\\mathrm{EXP}}</span> (i.e., the verifier incorrectly accepts <span class="math">P_0</span>) then:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">j</span> be the lowest index for which <span class="math">P_j \\notin \\mathcal{L}_{\\mathrm{EXP}}</span> but <span class="math">P_{j+1} \\in \\mathcal{L}_{\\mathrm{EXP}}</span>.</li>

      <li>choose fresh uniform <span class="math">r_j&#x27;, \\ldots, r_{t-1}&#x27;</span> in <span class="math">\\{1, \\ldots, 2^{\\lambda}\\}</span>.</li>

      <li>run <span class="math">\\mathcal{A}(\\mathbb{G},r_0,\\ldots ,r_{j - 1},r_j&#x27;,\\ldots ,r_{t - 1}&#x27;;R)</span> to get <span class="math">(P_0,v_0),\\ldots ,(P_j,v_j),(P_{j + 1}&#x27;,v_{j + 1}&#x27;)</span> , <span class="math">\\ldots ,(P_t&#x27;,v_t&#x27;)</span>.</li>

      <li>if <span class="math">P_{j + 1}&#x27; \\in \\mathcal{L}_{\\mathrm{EXP}}</span> and <span class="math">r_j \\neq r_j&#x27;</span>, output <span class="math">(g_j, h_j, T / 2^{j + 1}, v_j, r_j, r_j&#x27;)</span> and stop.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>in all other cases output fail.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}</span> be the event that EXP does not output fail. When <span class="math">\\mathcal{E}</span> happens we have <span class="math">P_{j} \\notin \\mathcal{L}_{\\mathrm{EXP}}</span> and <span class="math">P_{j+1}, P_{j+1}&#x27; \\in \\mathcal{L}_{\\mathrm{EXP}}</span>. Therefore, if EXP outputs <span class="math">(g, h, \\hat{T}, v, r, r&#x27;)</span> we have that</p>

    <div class="my-4 text-center"><span class="math-block">h \\neq g ^ {(2 ^ {\\hat {T}}) \\quad \\text{and} \\quad} (g ^ {r} v) ^ {(2 ^ {\\hat {T}})} = v ^ {r} h \\quad \\text{and} \\quad} (g ^ {r ^ {\\prime}} v) ^ {(2 ^ {\\hat {T}})} = v ^ {r ^ {\\prime}} h. \\tag {3}</span></div>

    <p class="text-gray-300">Re-arranging terms of the two equalities on the right we get</p>

    <div class="my-4 text-center"><span class="math-block">\\left(g ^ {(2 ^ {\\hat {T}})} / v\\right) ^ {r} = h / v ^ {(2 ^ {\\hat {T}})} \\quad \\text{and} \\quad \\left(g ^ {(2 ^ {\\hat {T}})} / v\\right) ^ {r ^ {\\prime}} = h / v ^ {(2 ^ {\\hat {T}})}. \\tag {4}</span></div>

    <p class="text-gray-300">Dividing the left equality by the right we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\left(g ^ {(2 ^ {\\hat {T}})} / v\\right) ^ {r - r ^ {\\prime}} = 1.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hence <span class="math">\\mu\\coloneqq g^{(2^{\\bar{T}})}/v</span> is an element of order at most $0<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r-r^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><2^{\\lambda}<span class="math"> in </span>\\mathbb{G}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let’s see why <span class="math">\\mu\\neq 1</span>. By (3) we have <span class="math">h\\neq g^{(2^{2^{\\bar{T}}})}</span> and therefore either <span class="math">h\\neq v^{(2^{\\bar{T}})}</span> or <span class="math">v\\neq g^{(2^{\\bar{T}})}</span>. But then by (4) it must be that <span class="math">v\\neq g^{(2^{\\bar{T}})}</span>. Hence <span class="math">\\mu\\neq 1</span> and <span class="math">\\mu</span> is of order at most $d\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r-r^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To summarize, algorithm <span class="math">\\mathcal{B}</span> runs experiment EXP, and if it does not fail, it outputs <span class="math">(\\mu,d)</span>. This shows that when event <span class="math">\\mathcal{E}</span> happens, algorithm <span class="math">\\mathcal{B}</span> succeeds in breaking the low order assumption. It remains to determine how likely is event <span class="math">\\mathcal{E}</span> to happen. Fortunately this has already been worked out in the generalized forking lemma of Bellare and Neven <em>[1, Lemma 1]</em>. An application of their lemma shows that if <span class="math">\\mathcal{A}</span> succeeds in fooling the verifier with probability <span class="math">\\epsilon</span>, then event <span class="math">\\mathcal{E}</span> happens with probability at least <span class="math">(\\epsilon^{2}/t)-(\\epsilon/2^{\\lambda})</span>, as required. ∎</p>

    <h2 id="sec-22" class="text-2xl font-bold">6 Concrete groups</h2>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">The RSA group.</h4>

    <p class="text-gray-300">Let GGen be an algorithm that outputs an odd integer <span class="math">N</span> with an unknown factorization. Computing the order of the multiplicative group <span class="math">\\mathbb{G}\\coloneqq(\\mathbb{Z}/N)^{*}</span> is as hard as factoring <span class="math">N</span>, and therefore <span class="math">\\mathbb{G}</span> can be used as a group of unknown order. However, the low order assumption is trivially false in such groups because <span class="math">(-1)\\in\\mathbb{Z}/N</span> is an element of order two. Fortunately, this is the only impediment and it is easily corrected by instead working in the group <span class="math">\\mathbb{G}^{+}\\coloneqq\\mathbb{G}/\\{\\pm 1\\}</span>. Elements in this group are represented as cosets <span class="math">\\{x,-x\\}</span> for <span class="math">x\\in\\mathbb{G}</span> and multiplication is defined as <span class="math">\\{x,-x\\}\\cdot\\{y,-y\\}=\\{xy,-xy\\}</span>. Of course when computing in this group it suffices to represent a coset <span class="math">\\{x,-x\\}</span> by a single number, either <span class="math">x</span> or <span class="math">-x</span>, whichever is in the range <span class="math">[0,N/2)</span>. The low order assumption is believed to hold for a group generator GGen that generates such groups.</p>

    <p class="text-gray-300">We note that while Pietrzak <em>[12]</em> suggested using integers <span class="math">N</span> that are a product of strong primes, our use of the low order assumption suggests that soundness holds for more general <span class="math">N</span>. Recall that a prime number <span class="math">p</span> is strong if <span class="math">(p-1)/2</span> is also a prime number. If <span class="math">N=p\\cdot q</span> is a product of distinct strong primes then the group <span class="math">\\mathbb{G}^{\\prime}</span> of quadratic residues in <span class="math">(\\mathbb{Z}/N)^{<em>}</span> (i.e. <span class="math">\\mathbb{G}^{\\prime}\\coloneqq\\{z^{2}:z\\in(\\mathbb{Z}/N)^{</em>}\\}</span>) contains no elements of low order other than <span class="math">1</span>. Hence, the low order assumption holds unconditionally in this group. Pietrzak proved unconditional soundness of the protocol when used in this group <span class="math">\\mathbb{G}^{\\prime}</span>. By relying on the low order assumption we are able to prove soundness even when <span class="math">N</span> is not a product of strong primes. We note that checking membership in <span class="math">\\mathbb{G}^{\\prime}</span> is difficult and this complicates the protocol. Checking membership in <span class="math">\\mathbb{G}^{+}</span> is easy so that the protocol in Figure 1 can be used as is.</p>

    <p class="text-gray-300">The difficulty with the group <span class="math">(\\mathbb{Z}/N)^{*}</span> is that for best results the group generator GGen must be trusted to not reveal the factorization of <span class="math">N</span>. One can instead make GGen use public randomness to choose a sufficiently large <span class="math">N</span> so that factoring <span class="math">N</span> is hard. However the resulting <span class="math">N</span> must be so large as to be impractical.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">The class group of an imaginary quadratic number field.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To solve the trusted setup problem one can instead use the class group of the number field <span class="math">\\mathbb{Q}(\\sqrt{p})</span>, where <span class="math">p</span> is a negative prime <span class="math">p\\equiv 1\\bmod 4</span>, as suggested by Wesolowski <em>[14]</em>. This class group has odd order and computing its order is believed to be difficult when $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is large. See <em>[4]</em> for a discussion on the choice of cryptographic parameters for such groups. Concretely, the group generator GGen(</span>\\lambda<span class="math">) outputs a negative prime </span>p<span class="math"> from which the class group of </span>\\mathbb{Q}(\\sqrt{p})$ is completely specified.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The Cohen-Lenstra heuristics <em>[7]</em> suggest that for imaginary quadratic number fields:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the frequency of fundamental discriminants for which the odd part of the class group is cyclic is about <span class="math">97.6\\%</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the frequency <span class="math">f(d)</span> of fundamental discriminants for which the order of the class group is divisible by <span class="math">d</span> is approximately:</li>

    </ul>

    <p class="text-gray-300"><span class="math">f(3)=44\\%,\\qquad f(5)=24\\%,\\qquad f(7)=16\\%.</span></p>

    <p class="text-gray-300">These heuristics suggest that the class group is often cyclic, but often contains elements of small odd order. The question is how hard is it to find an element of small odd order, if one exists?</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">An approach to finding low order elements in class groups.</h4>

    <p class="text-gray-300">The low order assumption in the class group of an imaginary quadratic extension has not been studied much, and is a fascinating avenue for future work. For example, can we find an element of order three if one exists?</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We mention one possible avenue for attack based on the work of Ellenberg and Venkatesh <em>[9]</em>. Let <span class="math">I</span> be an ideal of order <span class="math">3</span> in the class group of <span class="math">\\mathbb{Q}(\\sqrt{p})</span>. Then <span class="math">I^{3}</span> is principle meaning that <span class="math">I^{3}=\\langle a+b\\sqrt{p}\\rangle</span> for some <span class="math">a,b\\in\\mathbb{Z}</span>. Then the ideal norm <span class="math">N(I)</span> satisfies $N(I)^{3}=N(I^{3})=a^{2}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b^{2}<span class="math">. Setting </span>z=N(I)$ we see that the existence of an ideal of order three implies an integral point on the surface</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$z^{3}=a^{2}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b^{2}$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\qquad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{3/4},\\qquad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/4}.$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first inequality follows from the fact that we can take <span class="math">I</span> to be a reduced ideal in the class group. The second and third inequalities follow from the first.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we could find an integral point <span class="math">(x,y,z)</span> satisfying (6) on the surface (5), where <span class="math">z</span> is not a perfect square, then we will likely break the low order assumption in the class group of <span class="math">\\mathbb{Q}(\\sqrt{p})</span>. We want a point <span class="math">(x,y,z)</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> is not a perfect square to ensure that </span>z$ is not the norm of a principal ideal. Fortunately for this paper, the bounds (6) are out of reach for Coppersmith’s method for finding low-norm integral points on curves and surfaces <em>[8]</em>. However, perhaps Coppersmith’s method can be tuned specifically for this family of surfaces? We leave that for future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-26" class="text-2xl font-bold">7 Open problems</h2>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Post-quantum security.</h4>

    <p class="text-gray-300">We conclude by pointing out that the two VDFs surveyed here are insecure against an adversary who has access to a quantum computer – a quantum computer can easily calculate the order of the group <span class="math">\\mathbb{G}</span> using Shor’s algorithm and break the VDF. It is a wonderful open problem to find a simple VDF that is post-quantum secure. Some of the VDFs studied in <em>[2]</em> are post-quantum secure, but it would be helpful to have a simpler construction. For example, Buterin <em>[5]</em> describes and implements one of the constructions from <em>[2]</em> using a combination of MiMC and a STARK. Sequential composition of isogenies on elliptic curves is a promising area for a post-quantum VDF. An interesting proposal for a VDF from isogenies is reported in <em>[10]</em>. However, that construction is not designed to be post-quantum secure, and requires a trusted setup.</p>

    <h2 id="sec-28" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Krzysztof Pietrzak, Benjamin Wesolowski, and Justin Drake for their helpful comments about this writeup.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">A A parallel algorithm to compute quotients in the exponent</p>

    <p class="text-gray-300">We conclude with a brief description of how to compute <span class="math">\\pi = g^{\\lfloor 2^{T} / \\ell \\rfloor} \\in \\mathbb{G}</span> in parallel, as needed to speed up Wesolowski's succinct argument. We can accelerate the prover's time to compute <span class="math">\\pi</span> by a factor of <span class="math">s</span> using <span class="math">s</span> processors. We do so by storing <span class="math">s</span> group elements as the prover evaluates the VDF. Taking <span class="math">s = 100</span> seems reasonable in practice.</p>

    <p class="text-gray-300">So, let <span class="math">b \\coloneqq \\lfloor T / (s - 1) \\rfloor</span>. As the prover computes the VDF it stores the following <span class="math">s</span> group elements as they are encountered along the way:</p>

    <div class="my-4 text-center"><span class="math-block">u _ {0} = g, \\quad u _ {1} = g ^ {(2 ^ {b})}, \\quad u _ {2} = g ^ {(2 ^ {2 b})}, \\quad \\ldots , \\quad u _ {s - 1} = g ^ {(2 ^ {(s - 1) b})}.</span></div>

    <p class="text-gray-300">Next, our algorithm to compute <span class="math">\\pi</span> uses the following subroutine <span class="math">\\exp</span>, which is essentially the same as the algorithm from Section 2.1. Here <span class="math">0 \\leq d &amp;lt; \\ell</span> is an additional input parameter.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\exp (h, t, d, \\ell): \\quad \\text{//} \\quad \\text{output } a = h ^ {\\lfloor d 2 ^ {t} / \\ell \\rfloor} \\in \\mathbb {G} \\\\ a \\leftarrow 1 \\in \\mathbb {G}, \\quad r \\leftarrow d \\in \\{0, \\dots , \\ell - 1 \\} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">repeat <span class="math">t</span> times:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} q \\leftarrow \\lfloor 2 r / \\ell \\rfloor \\in \\{0, 1 \\}, \\quad r \\leftarrow (2 r \\bmod \\ell) \\in \\{0, \\dots , \\ell - 1 \\} \\\\ a \\leftarrow a ^ {2} \\cdot h ^ {q} \\in \\mathbb {G} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">output <span class="math">a</span>  // this <span class="math">a</span> is equal to <span class="math">h^{\\lfloor d2^t / \\ell \\rfloor} \\in \\mathbb{G}</span></p>

    <p class="text-gray-300">Using subroutine <span class="math">\\exp</span> we can compute <span class="math">\\pi = g^{\\lfloor 2^T / \\ell \\rfloor} \\in \\mathbb{G}</span> in time <span class="math">O(T / s)</span> as follows. The algorithm starts by quickly computing all the remainders needed for the <span class="math">s</span> steps of long division, and then runs these <span class="math">s</span> steps in parallel.</p>

    <p class="text-gray-300">input: <span class="math">g, T, \\ell, s</span> as well as <span class="math">u_{i} = g^{(2^{ib})} \\in \\mathbb{G}</span> for <span class="math">i = 0, \\ldots, s - 1</span>  (need <span class="math">s &amp;gt; 1</span>, <span class="math">T &amp;gt; s(s - 2)</span>)</p>

    <p class="text-gray-300">output: <span class="math">\\pi \\coloneqq g^{\\lfloor 2^T / \\ell \\rfloor} \\in \\mathbb{G}</span> computed with <span class="math">s</span>-way parallelism in time <span class="math">O(T / s)</span></p>

    <div class="my-4 text-center"><span class="math-block">b \\leftarrow \\lfloor T / (s - 1) \\rfloor \\quad \\text{//} \\quad \\text{batch size}</span></div>

    <p class="text-gray-300">// compute remainders by a quick sequential process</p>

    <div class="my-4 text-center"><span class="math-block">r _ {0} \\leftarrow \\left(2 ^ {(T \\bmod b)} \\bmod \\ell\\right) \\in \\{0, \\dots , \\ell - 1 \\}</span></div>

    <p class="text-gray-300">for <span class="math">i = 1,\\ldots ,s - 1</span></p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} \\leftarrow \\left(2 ^ {b} \\cdot r _ {i - 1} \\bmod \\ell\\right) \\in \\{0, \\dots , \\ell - 1 \\}</span></div>

    <p class="text-gray-300">// compute <span class="math">\\pi</span> in parallel</p>

    <p class="text-gray-300">(1) <span class="math">\\pi_0\\gets \\exp \\bigl (u_{s - 1},(T\\bmod b),1,\\ell \\bigr)</span>  // compute <span class="math">\\pi_0\\gets (u_{s - 1})^{\\lfloor 2^{(T\\bmod b)} / \\ell \\rfloor}\\in \\mathbb{G}</span></p>

    <p class="text-gray-300">for <span class="math">i = 1,\\ldots ,s - 1</span></p>

    <p class="text-gray-300">(2) <span class="math">\\pi_{i}\\gets \\exp \\bigl (u_{s - 1 - i},b,r_{i - 1},\\ell \\bigr)</span>  // compute <span class="math">\\pi_i\\gets (u_{s - 1 - i})^{\\lfloor r_{i - 1}\\cdot 2^b /\\ell \\rfloor}\\in \\mathbb{G}</span></p>

    <p class="text-gray-300">output <span class="math">\\pi \\gets \\prod_{i = 0}^{s - 1}\\pi_{i}</span></p>

    <p class="text-gray-300">The bulk of the work happens on lines (1) and (2), where each call to the function <span class="math">\\exp</span> requires <span class="math">b</span> sequential squarings. The point is that all the calls to <span class="math">\\exp</span> can be processed in parallel. The algorithm needs enough memory to store only <span class="math">s</span> group elements.</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Bellare and G. Neven. Multi-signatures in the plain public-key model and a general forking lemma. In Proceedings of the 13th ACM conference on Computer and communications security, pages 390–399. ACM, 2006.</li>

      <li>[2] D. Boneh, J. Bonneau, B. Bünz, and B. Fisch. Verifiable delay functions. In CRYPTO 2018, pages 757–788, 2018. https://eprint.iacr.org/2018/601.</li>

      <li>[3] D. Boneh and V. Shoup. A graduate course in applied cryptography. Cambridge, 2018.</li>

      <li>[4] J. Buchmann and S. Hamdy. A survey on iq cryptography. In Public-Key Cryptography and Computational Number Theory, pages 1–15, 2001.</li>

      <li>[5] V. Buterin. STARKs, part 3: Into the weeds, 2018. https://vitalik.ca/general/2018/07/21/starks_part_3.html.</li>

      <li>[6] B. Cohen. Proofs of space and time. Blockchain Protocol Analysis and Security Engineering, 2017. https://cyber.stanford.edu/sites/default/files/bramcohen.pdf.</li>

      <li>[7] H. Cohen and H. W. Lenstra. Heuristics on class groups of number fields. In Number Theory Noordwijkerhout 1983, pages 33–62. Springer, 1984.</li>

      <li>[8] D. Coppersmith. Small solutions to polynomial equations, and low exponent rsa vulnerabilities. Journal of Cryptology, 10(4):233–260, 1997.</li>

      <li>[9] J. S. Ellenberg and A. Venkatesh. Reflection principles and bounds for class group torsion. International Mathematics Research Notices, 2007, 2007.</li>

      <li>[10] L. D. Feo, S. Masson, C. Petit, and A. Sanso. Verifiable delay functions from supersingular isogenies and pairings. In ASIACRYPT 2019, pages 248–277, 2019.</li>

      <li>[11] A. K. Lenstra and B. Wesolowski. Trustworthy public randomness with sloth, unicorn, and trx. International Journal of Applied Cryptography, 3(4):330–343, 2017.</li>

      <li>[12] K. Pietrzak. Simple verifiable delay functions. In Innovations in Theoretical Computer Science Conference, ITCS, pages 60:1–60:15, 2019. https://eprint.iacr.org/2018/627.</li>

      <li>[13] R. Rivest, A. Shamir, and D. Wagner. Time-lock puzzles and timed-release crypto, 1996.</li>

      <li>[14] B. Wesolowski. Efficient verifiable delay functions. In EUROCRYPT 2019, pages 379–407, 2019. https://eprint.iacr.org/2018/623.</li>

    </ul>`;
---

<BaseLayout title="A Survey of Two Verifiable Delay Functions (2018/712)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/712
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
