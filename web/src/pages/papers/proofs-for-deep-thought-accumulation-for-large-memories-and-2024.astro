---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/325';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proofs for Deep Thought: Accumulation for large memories and deterministic computations';
const AUTHORS_HTML = 'Benedikt Bünz, Jessica Chen';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz and Jessica Chen</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">An important part in proving machine computation is to prove the correctness of the read and write operations performed from the memory, which we term <em>memory-proving</em>. Previous methodologies required proving Merkle Tree openings or multi-set hashes, resulting in relatively large proof circuits. We construct an efficient memory-proving Incrementally Verifiable Computation (IVC) scheme from accumulation, which is particularly useful for machine computations with large memories and deterministic steps. In our scheme, the IVC prover <span class="math">\\mathsf{P}_{\\mathsf{IVC}}</span> has cost entirely independent of the memory size <span class="math">T</span> and only needs to commit to approximately 15 field elements per read/write operation, marking a more than 100X improvement over prior work. We further reduce this cost by employing a modified, accumulation-friendly version of the GKR protocol. In the optimized version, <span class="math">\\mathsf{P}_{\\mathsf{IVC}}</span> only needs to commit to 6 small memory-table elements per read/write. If the table stores 32-bit values, then this is equivalent to committing to less than one single field element per read and write. Our modified GKR protocol is also valuable for proving other deterministic computations within the context of IVC. Our memory-proving protocol can be extended to support key-value stores.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">Proof system Accumulation Scheme Incrementally Verifiable Computation.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Consider the scenario where one or multiple clients outsource a large computation, possibly of infinite steps, to an untrusted server. For example, clients might want to continuously verify that all transactions in a blockchain are valid. Naturally, the clients would like the server to provide a certificate, which would allow the clients to verify that all the computation steps run up to that point were correct and even to continue the computation from that point onwards. The efficiency of verification necessitates that the size of the proof and the complexity of its verification be independent of the length of the computation. Moreover, since the computation can be long or even unbounded, it would be ideal if the server can provide the current state and a certificate upon request from the client <em>at any point</em>. This is achieved by maintaining a running certificate or proof that can be efficiently updated with each computation step. A system that achieves these</p>

    <p class="text-gray-300">properties is called an <em>incrementally verifiable computation</em> (IVC) system<em>[x10]</em>.</p>

    <p class="text-gray-300">IVC enables the server/prover to produce an output <span class="math">z_{\\textsf{IVC}}</span>, along with a proof <span class="math">\\pi_{\\textsf{IVC}}</span> upon request from the client/verifier without requiring <em>a priori</em> knowledge of an upper bound on the number of computation steps. With a valid <span class="math">\\pi_{\\textsf{IVC}}</span>, a client/verifier can be convinced <span class="math">z_{\\textsf{IVC}}</span> is the output of the correct execution of a (potentially non-deterministic) machine computation up to this point, and can even continue the computation. Recent developments have demonstrated that IVC can be constructed from simple public-coin interactive protocols featuring algebraic verifiers, such as protocols where the prover simply sends the witness. This is achieved through the use of accumulation or folding schemes <em>[x1, x2, x3, x4, x5, x6]</em>. The resulting IVC has essentially the same computational overhead as the accumulation scheme. The cost of the resulting IVC prover depends on two main factors:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The size of the recursive circuit, predominantly comprising the accumulation verifier <span class="math">\\mathsf{V}_{\\textsf{acc}}</span>. Since the size of <span class="math">\\mathsf{V}_{\\textsf{acc}}</span> only depends on the algebraic degree of the verifier and the number of rounds in the underlying protocol (rather than the communication or verification complexity), minimizing these two factors are crucial for reducing the cost of the IVC prover.</li>

      <li>The cost of the accumulation prover <span class="math">\\mathsf{P}_{\\textsf{acc}}</span>, which is mainly influenced by the commitment cost to the prover messages, and thus is dependent on the number of elements in the prover messages of the underlying interactive protocol.</li>

    </ol>

    <p class="text-gray-300">The general paradigm of using IVC to prove machine computations involves first proving the correctness of computation under the assumption that memory accesses were executed correctly, recording all the read/write operations in the circuit, and then proving the correctness of the recorded read/write operations. The primary challenge lies in the latter, i.e. efficiently proving the correctness of memory accesses, which we will refer to as <em>memory-proving</em> in this work. With the above-mentioned recent advancements in IVC construction, we need only to design a public-coin interactive protocol for memory-proving with an algebraic verifier while ensuring that following three parameters remain small: the number of rounds, the verifier degree, and the number of elements in the prover messages (ideally independent of T). These parameters are the only factors on which the cost of <span class="math">\\mathsf{P}_{\\textsf{IVC}}</span> depends. Then, by applying existing accumulation compilers (e.g., the ProtoStar compiler <em>[x2]</em>) to this interactive protocol, we can obtain an efficient accumulation scheme for memory-proving, and finally derive an efficient memory-proving IVC scheme from accumulation by utilizing existing IVC compilers (e.g., <em>[x3]</em>).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The most rudimentary method of performing memory-proving involves unrolling the entire memory into a circuit. However, since a circuit is at least as large as its inputs, this circuit would be of size <span class="math">O(\\ell T)</span>, which is prohibitively large even medium-sized memories. An alternative approach is for the prover to simulate memory-checking internally and prove that the memory accesses would have been accepted by the memory-checking verifier, who only keeps a small local state. In all previous works, using this approach, the prover’s cost is dependent on the memory size <span class="math">T</span> and/or hashing is required within the circuit. For instance, Spice <em>[x21]</em> employed offline memory-checking, requiring approximately 1500 constraints per read and write operation. Since the prover needs to transmit at least one proof element per constraint, this results in 1500 elements in the prover message per read/write operation, and thus 1500 commitments per accumulation step for <span class="math">\\mathsf{P_{IVC}}</span>. In contrast, ProtoStar recently showed a memory-proving protocol for static read-only memory that utilises the LogUp argument <em>[x13]</em>, in which the prover only performs two group scalar multiplications per read instruction <em>[x5]</em>. The prover’s cost in ProtoStar is independent of the memory size <span class="math">T</span> and does not involve multi-set hashing. However, their approach does not support writes into a dynamic memory<em>[x5]</em>.</p>

    <p class="text-gray-300">In this paper, we present an interactive protocol for memory-proving inspired by the LogUp argument <em>[x13]</em>. Using accumulation techniques, we obtain an IVC scheme for memory-proving with minimal prover overhead. We then show an optimization of our scheme which employs an accumulation-friendly version of the GKR protocol to further reduce the prover overhead. We note that this adapted GKR protocol has other applications beyond improving our memory-proving protocol.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6"><span class="math">O(\\ell)</span> memory-proving <span class="math">\\mathsf{P_{IVC}}</span></h4>

    <p class="text-gray-300">ProtoStar has previously demonstrated that LogUp is well suited for accumulation and, thus, IVC. It can be used to verify the existence of a set of witness values in a static table of values <em>[x5]</em>. We design LogUp-styled arguments to support reading from and writing to a fully dynamic table.</p>

    <p class="text-gray-300">One key challenge we address is proving only <span class="math">O(\\ell)</span> table values were altered in a table of size <span class="math">T&gt;&gt;\\ell</span>, while ensuring that the cost of <span class="math">\\mathsf{P_{IVC}}</span> remains independent of <span class="math">T</span>. Our memory-proving protocol is public-coin with an algebraic verifier, featuring 2 rounds of communication, verifier degree 3, and only <span class="math">O(\\ell)</span> elements in prover messages, where <span class="math">\\ell</span> denotes the number of reads and writes performed in each computation step. This means it can be turned into an efficient accumulation scheme using existing accumulation compiler (eg. <em>[x5]</em>). The resulting <span class="math">\\mathsf{P_{IVC}}</span> only needs to commit to <span class="math">O(\\ell)</span> elements, which is independent of the memory size <span class="math">T</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">This significantly improves on prior work, which either relied on Merkle trees requiring  <span class="math">\\log T</span>  hashes per memory access or required multi-set hashes [SAGL18]. These prior methods are particularly costly in the context of memory-proving, where the hashes result in large proving circuits. In contrast, our resulting memory-proving scheme is practically efficient with the prover only having to commit to 15 field values per memory access. In addition, since the prover cost is completely independent of the memory size  <span class="math">T</span> , our protocol can be extended to the setting of key-value store. We describe this extension in detail at the end of Section 5.1.</p>

    <p class="text-gray-300">Optimizing memory-proving with GKR. One limitation of the scheme is that the prover needs to commit to 6 large field elements per memory access, i.e. each of size  <span class="math">\\lambda</span>  bits, even if the memory entries themselves are small. This is because in the memory-proving interactive protocol, the prover needs to send 6 vectors consisting of inverses of the form  <span class="math">\\frac{1}{r + t_i}</span>  where  <span class="math">r</span>  is a constant, and each  <span class="math">t_i</span>  is a small table entry. To resolve this overhead, we draw inspiration from [STW23; PH23] and compute this sum using formal fractions and a modified GKR protocol. Our modified protocol retains GKR's ability to prove deterministic layered computations without committing to the intermediate values. Specifically, the protocol relies on bivariate sumcheck instead of multilinear sumcheck, reducing the number of rounds per layer to 3. In the context of the ProtoStar accumulation compiler, this reduction in number of rounds significantly lowers the recursive overhead in IVC.</p>

    <p class="text-gray-300">With the power of GKR, the memory-proving protocol no longer requires computing and committing to the large inverses. Thus, if we read/write  <span class="math">\\ell</span> <span class="math">s</span> -bit values from memory, the number of group operations decreases from  <span class="math">O(\\lambda \\ell)</span>  to  <span class="math">O(s\\ell)</span> , i.e., the actual size of the data that is read/written. We provide a brief overview of the resulting efficiency of our protocol in Table 1. Most importantly the prover only needs to commit to 6 elements that are as large as the table entries for each read/ write. If the table contains 32-bit entries then this is equivalent to committing to 192bits per read/write or less than a single 256bit field element. We also introduce several optimizations for our GKR-powered memory-proving protocol, which further reduce the number of GKR rounds.</p>

    <p class="text-gray-300">Table 1. Efficiency Table for our Memory-Proving Protocol.  <span class="math">T</span>  is the memory size, and  <span class="math">\\ell</span>  is the number of read/write operations.  <span class="math">\\mathbb{T}</span>  is the set of table entries, which might only contain small field elements. See Table 3 for an explanation of the columns and symbols, and more details.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pacc Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vacc Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plain</td>

            <td class="px-3 py-2 border-b border-gray-700">(6l, T)-MSM + (9l, F)-MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">3G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Using GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">(6l, T)-MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log T)G</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.0.1 IVC for deterministic computations.</h4>

    <p class="text-gray-300">GKR has numerous other applications in accumulation beyond enhancing our memory-proving protocol. In fact, for proving <em>any</em> low-depth deterministic computations, GKR only requires committing to the inputs and outputs, not the intermediate values. We demonstrate the utility of this by describing an accumulation-friendly GKR protocol for computing group scalar multiplications, which is the dominant cost within the recursive circuit.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.1 Related Work</h3>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.1.1 IVC and Accumulation.</h4>

    <p class="text-gray-300">Valiant <em>[x18]</em> introduced incrementally verifiable computation (IVC) and showed that IVC can be built from Succinct Non-interactive ARguments of Knowledge (SNARKs). The core concept involves the prover generating a SNARK at each computation step, certifying both the current step and the verification of the SNARK from the previous step. The latter part is commonly referred to as the <em>recursive circuit</em>. Subsequent to Valiant’s work, an important line of research <em>[x1, x2, x3]</em> has enhanced the practicality of IVC, studied its generalization to arbitrary graphs (Proof-Carrying Data, PCD), and advanced its theoretical foundations.</p>

    <p class="text-gray-300">Halo <em>[x4]</em> showed that IVC can be constructed from simpler assumptions, sparking research on accumulation <em>[x5, x6, x7, x1, x8, x9]</em>. The idea is to construct IVC by simply accumulating or batching the verification of non-interactive arguments, postponing verification to the end of each IVC step. In essence, in each accumulation round, the prover produces a new argument for the current step and proves its correct accumulation into the existing accumulator. The accumulation step can be as straightforward as taking a random linear combination between two vector commitments, and verifying the accumulation step can be significantly cheaper than verifying the proof. The more computationally intensive final verification, which is called the <em>decision</em> step in accumulation, is executed only at the end of IVC step to verify the correctness of the accumulated commitment. A valid accumulator implies that all the accumulated proofs were valid.</p>

    <p class="text-gray-300">Recently, ProtoStar introduced a new recipe for constructing accumulation schemes and IVC <em>[x7]</em> from <em>any</em> interactive public-coin protocol <span class="math">\\Pi</span> with an algebraic verifier. The resulting accumulation verifier <span class="math">\\mathsf{V_{acc}}</span> depends only on the number of rounds and the verifier degree in the underlying interactive protocol <span class="math">\\Pi</span>, and the resulting accumulation prover <span class="math">\\mathsf{P_{acc}}</span>’s main cost is committing to all the prover messages in <span class="math">\\Pi</span>. Using the <em>[x6]</em> compiler, an accumulation scheme for NP directly yields an IVC, where <span class="math">\\mathsf{P_{IVC}}</span>’s cost for computing the predicate is proportional to the cost of <span class="math">\\mathsf{P_{acc}}</span> and the recursive circuit consisting of <span class="math">\\mathsf{V_{acc}}</span>.</p>

    <p class="text-gray-300">Concurrent work <em>[x1]</em> also constructed an accumulation scheme for GKR. However, they utilize the multi-linear version of GKR and batch the polynomial evaluation, similar to <em>[x5]</em>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.1.2 Memory-checking and lookup arguments.</h4>

    <p class="text-gray-300">Memory-checking <em>[x3]</em> enables an untrusted server to convince a client that a set of read/write opera</p>

    <p class="text-gray-300">tions is consistent with a memory without having to send the entire memory to the client. Each entry of read/write operation consists of an address <span class="math">a</span>, a value <span class="math">v</span> and a timestamp <span class="math">t</span>. If a value <span class="math">v</span> was written to <span class="math">a</span> at time <span class="math">t</span>, then any read at time <span class="math">t^{\\prime}&gt;t</span> from <span class="math">a</span> shall return <span class="math">v</span> with the timestamp <span class="math">t</span>, unless there was another write to <span class="math">a</span> in the meantime. We briefly highlight two constructions and their limitations here, and refer to Appendix B of Jolt <em>[x1]</em> for an excellent overview of memory-checking techniques.</p>

    <p class="text-gray-300">One approach stores the memory in a Merkle Tree <em>[x1, x2]</em>. For every read operation, the prover opens the Merkle Tree at the relevant address. For every write operation, the prover shows that the Merkle Tree is correctly updated. The verification for either step requires <span class="math">O(\\log T)</span> hashes, and the prover’s computational work is also <span class="math">O(\\log T)</span>, where <span class="math">T</span> is the size of the memory. When this technique is used within IVC, the memory-checking verifier is part of the proving circuit, and <span class="math">\\log(T)</span> hashes per read and write operation become a significant overhead.</p>

    <p class="text-gray-300">The other common approach, dating back to <em>[x3]</em> and later refined in <em>[x4, x6, x7]</em>, relies on proving that the constructed sets of reads and writes form a permutation. The state-of-the-art work Spice <em>[x19]</em> employs multi-set hashes and proves that the hash was evaluated correctly, which results in over 1500 constraints per read/write operation, two orders of magnitude more than our approach. The approach also requires a linear scan of the memory at the end of the computation, but similar as in our construction this can be deferred to a final decider.</p>

    <p class="text-gray-300">Recently, there has been increased attention to a related primitive called lookup arguments. Lookup arguments can be used to verify read operation in a static, possibly preprocessed memory. A recent line of work <em>[x27, x13, x16, x18]</em> showed that in the preprocessing setting, one can achieve lookup arguments independent of the table size and quasi-linear in the number of read operations. Lasso <em>[x26]</em> improves on these ideas by enabling a fully linear prover and independence of the table size for structured table. In the context of IVC, ProtoStar <em>[x5]</em> gave a lookup argument based on LogUp <em>[x14]</em> that is independent of the table size (for arbitrary tables) and only requires two group scalar multiplications per read. Unfortunately, all these lookup arguments only work for static tables and read operations. We construct a memory-proving argument (which is more general than a lookup) that is still independent of the table size and has minimal overhead.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.2 Technical Overview</h3>

    <p class="text-gray-300">Our construction heavily relies on the ProtoStar compiler <em>[x5]</em>, which we describe in Theorem 1 in Section 2.5. It gives a recipe for constructing accumulation schemes and IVC <em>[x5]</em> from <em>any</em> interactive public-coin protocol with an algebraic verifier. We summarize the recipe here into five steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Begin with <em>any</em> <span class="math">k</span>-round interactive public-coin protocol featuring <span class="math">L</span> verification checks of maximum degree <span class="math">d</span>, and prover messages comprising <span class="math">n</span> nonzero elements.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compress the communication by using a homomorphic vector commitment (e.g. Pedersen commitment) to commit to each vector in the prover messages.</li>

      <li>Make the protocol non-interactive through the Fiat-Shamir transformation.</li>

      <li>Use the ProtoStar compiler to convert the non-interactive protocol into an accumulation scheme. The accumulation scheme combines the current argument with an accumulator (which has the same form as the argument) by taking a random linear combination of the committed prover messages with the accumulator messages. It also computes a new verification equation by appropriately canceling out the cross error terms resulted from the accumulation.</li>

      <li>If the underlying protocol can prove NP-complete relations, such as circuits, then the <em>[x1]</em> IVC compiler can be applied to construct an IVC scheme from the accumulation scheme for any function <span class="math">F</span>. The compiler ensures the correct execution of the accumulation verifier alongside proving <span class="math">F</span>.</li>

    </ol>

    <p class="text-gray-300">Following this recipe, we design special-sound, algebraic protocols for memory-proving and GKR. One important design goal is to keep the complexity of the accumulation verifier <span class="math">\\mathsf{V_{acc}}</span> low, as <span class="math">\\mathsf{V_{acc}}</span> is the dominant component in the recursive circuit. Notably, the complexity of <span class="math">\\mathsf{V_{acc}}</span> relies solely on <span class="math">k</span> and <span class="math">d</span>, without any dependence on <span class="math">n</span> or <span class="math">L</span> whatsoever. Another design goal is to minimize the commitment cost of the accumulation prover <span class="math">\\mathsf{P_{acc}}</span>, which is directly contingent on the number of nonzero elements in prover messages, as committing to <span class="math">0</span> is free in Pedersen commitment. Therefore, to leverage the ProtoStar compiler to design an efficient IVC scheme where <span class="math">\\mathsf{P_{IVC}}</span> cost is independent of the memory size <span class="math">T</span>, we need to design an interactive, algebraic memory-proving protocol with small values for number of rounds <span class="math">k</span>, verifier degree <span class="math">d</span> and number of nonzero elements in prover messages <span class="math">n</span>. This implies that <span class="math">n</span> should be independent of <span class="math">T</span>, since otherwise the cost of <span class="math">\\mathsf{P_{acc}}</span> will be <span class="math">O(T)</span> even if the number of memory accesses is much smaller than <span class="math">T</span>.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.0.1 Constructing Read List and Write List</h4>

    <p class="text-gray-300">We assume the list of “reads” and the list of “writes” were constructed similarly to the way in the classic offline memory-checking process <em>[x3, x10, x25]</em>. Each entry in the lists is in the form of a tuple (address, value, timestamp), with the local timestamp incremented after each write operation. The specific construction is described in Section 3.</p>

    <p class="text-gray-300">If all memory accesses were performed correctly, the constructed lists should satisfy three properties: 1) the read list and the write list should be permutations of each other; 2) the initial reads are consistent with the starting/old memory; and 3) the new memory is updated only at the addresses written to and with the correct amount. Note that the third memory-update (or mem-update for short) property requires examining all <span class="math">T</span> addresses, not only the ones touched by memory accesses but also the ones untouched. Therefore, the main challenge in designing an efficient memory-proving protocol lies in proving correct mem-update in time independent of <span class="math">T</span></p>

    <p class="text-gray-300">LogUp based mem-update.</p>

    <p class="text-gray-300">The starting point of our construction is the <em>LogUp</em> lookup argument <em>[x10]</em> which uses the fact that the set of values in <span class="math">\\mathbf{w}=[\\mathbf{w}_{i}]_{i=1}^{\\ell}</span> is contained in a table <span class="math">\\mathbf{t}=[\\mathbf{t}_{i}]_{i=1}^{T}</span> if and only if</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=1}^{\\ell}\\frac{1}{X+\\mathbf{w}_{j}}=\\sum_{i=1}^{T}\\frac{\\bm{m}_{i}}{X+\\mathbf{t}_{i}},</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{m}_{i}</span> is the multiplicity of <span class="math">\\mathbf{t}_{i}</span> in <span class="math">\\mathbf{w}</span> for every <span class="math">i\\in[T]</span> and <span class="math">X</span> is a random variable. ProtoStar <em>[x3]</em> showed that the LogUp argument can be efficiently accumulated. Importantly, it observes that the prover messages in the protocol for LogUp argument, e.g. <span class="math">\\bm{m}=[\\bm{m}_{i}]_{i=1}^{T}</span>, only contains <span class="math">\\ell</span> nonzero entries. This means, in the context of the ProtoStar compiler and IVC, the accumulation prover <span class="math">\\mathsf{P_{acc}}</span> and thus the IVC prover <span class="math">\\mathsf{P_{IVC}}</span> only needs to do <span class="math">O(\\ell)</span> work. However, the LogUp argument only supports read operations and not write operations.</p>

    <p class="text-gray-300">We attempt to modify the LogUp argument to use it for mem-update. Assume, <span class="math">\\mathbf{w}</span> corresponds to the <span class="math">\\ell</span>-sized update vector (the difference between the final written value and the initial read value from each address), and <span class="math">\\mathbf{t}</span> corresponds to the <span class="math">T</span>-sized vector <span class="math">\\Delta</span> that represents the difference between the new memory and the old memory, i.e. <span class="math">\\Delta:=\\mathsf{NM}-\\mathsf{OM}</span>. However, the LogUp argument only cares about the membership of the <span class="math">\\mathbf{w}</span> values but not their positions in <span class="math">\\Delta</span>; in other words, the argument only indicates that some memory value is changed by <span class="math">\\mathbf{w}_{j}</span>, but does not constrain the change to any specific address. In addition, it is not immediately clear how to update the memory or compute the right hand side with <span class="math">\\Delta</span> in a manner that does not require a linear scan.</p>

    <p class="text-gray-300">To resolve the first issue, we add the address vector to random linear combination in the denominators. That is,</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=1}^{\\ell}\\frac{1}{X+Y\\cdot\\bm{b}_{j}+\\mathbf{w}_{j}}=\\sum_{i=1}^{T}\\frac{\\bm{m}_{i}}{X+Y\\cdot i+\\Delta_{i}}</span></p>

    <p class="text-gray-300">holds if and only if <span class="math">\\mathbf{w}_{j}=\\Delta_{\\bm{b}_{j}}</span> for every <span class="math">j\\in[\\ell]</span>, where <span class="math">\\bm{b}=[\\bm{b}_{j}]_{j=1}^{\\ell}</span> is an address vector and <span class="math">Y</span> is another random variable. Note that this is an <em>indexed</em> LogUp argument where we ensure not only the membership of the values but also their precise indices in the lookup table. In this indexed lookup argument, <span class="math">m_{i}</span> only takes on the values <span class="math">0</span> or <span class="math">1</span>. Still, this modified lookup argument is not sufficient, as it does not ensure that <span class="math">\\Delta</span> is <span class="math">0</span> at the positions for which there had been no read or write operation. This is an important criteria for correct mem-update, since an adversarial prover may use non-zero values in <span class="math">\\Delta</span> to change the memory state arbitrarily.</p>

    <p class="text-gray-300">We make a key observation that the correct <span class="math">\\Delta</span> should simply be a <span class="math">T</span>-sized sparse representation of <span class="math">\\mathbf{w}</span>. To ensure that <span class="math">\\Delta</span> is <span class="math">0</span> at unmodified addresses, we set the numerators to <span class="math">\\mathbf{w}_{j},\\Delta_{i}</span> instead of <span class="math">1,\\bm{m}_{i}</span>. Namely,</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=1}^{\\ell}\\frac{\\mathbf{w}_{j}}{X+Y\\cdot\\bm{b}_{j}+\\mathbf{w}_{j}}=\\sum_{i=1}^{T}\\frac{\\Delta_{i}}{X+Y\\cdot i+\\Delta_{i}}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">Note that the <span class="math">i</span>th fraction on the right hand side is 0 if and only if the <span class="math">i</span>th value is unmodified by any write operation, and is equal to the left hand side if and only if the <span class="math">i</span>th value is modified by the correct amount. Only <span class="math">\\ell</span> out of all <span class="math">T</span> fractions on the right hand side are nonzero, which implies an honest prover only need to do <span class="math">O(\\ell)</span> work, resolving the second issue aforementioned. Section 4.3 shows that this LogUp-style mem-update argument is secure and indeed leads to a protocol with prover complexity independent of <span class="math">T</span>.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">4.2.2 LogUp powered memory-proving.</h4>

    <p class="text-gray-300">The mem-update argument can be used to show that the memory is updated strictly at the addresses written to and with the correct amount. We can then use a homomorphic commitment to <span class="math">\\Delta</span> to efficiently update our commitment to the memory state. In addition, we can use the indexed LogUp argument demonstrated in the intermediate step above to show that all the values initially read are consistent with the old memory. Nevertheless, merely checking these two properties (property 2 and 3) only suffice in a system where all write operations happen synchronously at the end of the computation step. Without additional checks, we would need to first update the memory whenever we read from an address that has been previously written to. This requires an expensive homomorphic commitment operation to be executed by the verifier as part of the recursive circuit. To resolve this we employ the classic permutation-based offline memory-checking idea <em>[x1]</em> and add a check for property 1 in our memory-proving protocol.</p>

    <p class="text-gray-300">All three subprotocols are based on the LogUp argument and are described in Section 4. Section 5 discusses the overall memory-proving protocol and its efficiency.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">4.2.3 Accumulation-friendly verision of GKR.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our memory-proving protocols have <em>almost</em> optimal parameters. It requires committing to only 15 field elements per memory access. However, 9 of these field elements consist of large field elements, i.e. $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-bit, even if the memory itself only consists of small entries. For instance, say the memory only contains 32-bit entries; using homomorphic commitments requires fields of size at least </span>2^{256}$, which is a factor 8 blowup. Concretely, in this example the 9 large elements contribute 2300 bits and the 6 small elements only 192 bits to the prover’s commitment cost.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Removing this blowup motivates the second orthogonal but highly compatible contribution of this paper: We construct an efficient accumulation scheme for the GKR protocol. GKR can be used to prove low-depth deterministic computations while only committing to the computation’s inputs and outputs but not the intermediate values. Note that GKR is a special-sound interactive protocol with an algebraic verifier, which means it can directly be compiled with the ProtoStar compiler to an accumulation scheme. Unfortunately, GKR has</p>

    <p class="text-gray-300"><span class="math">O(k\\cdot\\log n)</span> rounds where <span class="math">k</span> is the depth of the circuit and <span class="math">n</span> its width. Compilation results in an accumulation verifier with <span class="math">k\\cdot\\log n</span> group scalar multiplications. In the context of IVC, the accumulation verifier becomes part of the recursive circuit, and this is a significant overhead, especially when compared with other accumulation schemes which only have 1 to 3 group operations <em>[x11, x12, x3]</em>. Our goal is, therefore, to reduce the number of rounds of GKR while maintaining the attractive efficiency properties and the compatibility with the ProtoStar compiler.</p>

    <p class="text-gray-300">In every round, GKR runs a multivariate sumcheck protocol, which has <span class="math">\\log n</span> rounds. As a strawman, we can replace this multivariate sumcheck with a univariate one. This immediately reduces the number of GKR rounds from <span class="math">k\\cdot\\log n</span> to just <span class="math">k</span>. Univariate sumcheck requires sending a quotient polynomial that is as large as the domain of the sumcheck, in our case <span class="math">O(n)</span>. Committing to this polynomial would be at least as expensive as directly committing to the intermediate wires of the circuit, thus removing the benefit of using GKR. Fortunately, the idea of using a higher degree sumcheck with fewer variables can still help. Moving to a bivariate sumcheck reduces the communication to <span class="math">O(\\sqrt{n})</span> while being only a 3-round protocol. The <span class="math">O(\\sqrt{n})</span> commitment cost is, in most applications, dominated by the cost of committing to the input and output layers; even if not, we show that one can use a <span class="math">c</span>-variate sumcheck to ensure that the sumchecks commitment cost is marginal. Using a bivariate sumcheck presents us with a couple of challenges. First, the verifier needs to evaluate a <span class="math">O(\\sqrt{n})</span> degree polynomial, which is a <span class="math">O(\\sqrt{n})</span> degree check if done naively. To resolve this we built a polynomial evaluation protocol, where with aid from the prover, the verification degree reduces to merely 3, independent of the degree of the polynomial.</p>

    <p class="text-gray-300">Additionally, GKR batches polynomial evaluations, after each sumcheck, in order to only evaluate the next layer at a single point. In bivariate sumcheck, this would require computing a high-degree interpolation polynomial. We show that it is much simpler and more efficient to directly batch the resulting sumchecks. This observation is also applicable to multivariate sumchecks. We then construct a specific GKR protocol for computing the sum of fractions, e.g. <span class="math">\\sum_{i=1}^{n}\\frac{n_{i}}{d_{i}}</span>, similar to <em>[x14]</em>. We also give specific optimizations for this instantiation, such as breaking up the circuit into multiple parts, while still maintaining the asymptotic properties. This optimization takes advantage of the circuit structure of sums of fractions, where the number of sums halves in every layer.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">1.3 Roadmap</h3>

    <p class="text-gray-300">In Section 2, we provide the necessary preliminaries to comprehend our construction. We describe the desired construction for lists of read/write operations in Section 3 and outline three properties that consistent read/write lists should uphold. Subsequently, in Section 4, we introduce three LogUp-style special-sound subprotocols, each tailored for proving one of the three aforementioned properties. These subprotocols are combined in parallel to form the memory-proving interactive protocol <span class="math">\\Pi_{\\textsf{MP}}</span> in Section 5, which exhibits the desired characteristics</p>

    <p class="text-gray-300">for conversion into an efficient accumulation scheme and IVC using the ProtoStar compiler. Specifically, <span class="math">\\Pi_{\\mathsf{MP}}</span> has only 2 rounds and verifier degree 3, and its number of nonzero elements in prover messages is independent of <span class="math">T</span>. In Section 7, we elucidate how our accumulation-friendly version of GKR (components described in Appendix 6) can be leveraged to optimize our memory-proving IVC scheme, and we highlight several other useful applications of GKR in the context of IVC. The extension of our memory-proving protocol to the setting of key-value store is described in Appendix B.1.</p>

    <h2 id="sec-15" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Notation. For <span class="math">n \\in \\mathbb{N}</span>, we use <span class="math">[n]</span> to denote the set <span class="math">\\{1, 2, \\ldots, n\\}</span>. We denote <span class="math">\\lambda</span> as the security parameter and use <span class="math">\\mathbb{F}</span> to denote a field of prime order <span class="math">p</span> such that <span class="math">\\log(p) = \\Omega(\\lambda)</span>. For list of tuples <span class="math">ltup = [(a_i, b_i, c_i, \\ldots)]_{i=1}^k</span> of arbitrary length <span class="math">k</span>, we use <span class="math">ltup.\\mathbf{a}</span> to denote the list <span class="math">[a_i]_{i=1}^k</span>, and <span class="math">ltup.(\\mathbf{a}, \\mathbf{b})</span> to denote the list <span class="math">[(a_i, b_i)]_{i=1}^k</span>. For function <span class="math">f</span>, <span class="math">\\widetilde{f}</span> denotes the bivariate extension of <span class="math">f</span>.</p>

    <h2 id="sec-16" class="text-2xl font-bold">2.1 Special-sound Protocols</h2>

    <p class="text-gray-300">We take the definition of special-soundness from [AFK22; BC23].</p>

    <p class="text-gray-300"><strong>Definition 1 (Public-coin interactive proof).</strong> An interactive proof <span class="math">\\Pi = (\\mathsf{P}, \\mathsf{V})</span> for relation <span class="math">\\mathcal{R}</span> is an interactive protocol between two probabilistic machines, a prover <span class="math">\\mathsf{P}</span>, and a polynomial time verifier <span class="math">\\mathsf{V}</span>. Both <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> take as public input a statement <span class="math">\\mathsf{pi}</span> and, additionally, <span class="math">\\mathsf{P}</span> takes as private input a witness <span class="math">\\mathbf{w} \\in \\mathcal{R}(\\mathsf{pi})</span>. The verifier <span class="math">\\mathsf{V}</span> outputs 0 if it accepts and a non-zero value otherwise. Its output is denoted by <span class="math">(\\mathsf{P}(\\mathbf{w}), \\mathsf{V})(\\mathsf{pi})</span>. Accordingly, we say the corresponding transcript (i.e., the set of all messages exchanged in the protocol execution) is accepting or rejecting. The protocol is public coin if the verifier randomness is public. The verifier messages are referred to as challenges. <span class="math">\\Pi</span> is a <span class="math">(2k - 1)</span>-move protocol if there are <span class="math">k</span> prover messages and <span class="math">k - 1</span> verifier messages.</p>

    <p class="text-gray-300"><strong>Definition 2 (Tree of transcript).</strong> Let <span class="math">\\mu \\in \\mathbb{N}</span> and <span class="math">(a_{1},\\ldots ,a_{\\mu})\\in \\mathbb{N}^{\\mu}</span>. An <span class="math">(a_{1},\\ldots ,a_{\\mu})</span>-tree of transcript for a <span class="math">(2\\mu +1)</span>-move public-coin interactive proof <span class="math">\\Pi</span> is a set of <span class="math">a_1\\dot{a}_2\\dots a_\\mu</span> accepting transcripts arranged in a tree of depth <span class="math">\\mu</span> and arity <span class="math">a_1,\\ldots ,a_\\mu</span> respectively. The nodes in the tree correspond to the prover messages and the edges to the verifier's challenges. Every internal node at depth <span class="math">i - 1</span> <span class="math">(1\\leq i\\leq \\mu)</span> has <span class="math">a_{i}</span> children with distinct challenges. Every transcript corresponds to one path from the root to a leaf node. We simply write the transcripts as an <span class="math">(a^{\\mu})</span>-tree of transcript when <span class="math">a = a_{1} = a_{2} = \\dots = a_{\\mu}</span>.</p>

    <p class="text-gray-300"><strong>Definition 3 (Special-sound Interactive Protocol).</strong> Let <span class="math">\\mu, N \\in \\mathbb{N}</span> and <span class="math">(a_1, \\ldots, a_\\mu) \\in \\mathbb{N}^\\mu</span>. A <span class="math">(2\\mu + 1)</span>-move public-coin interactive proof <span class="math">\\Pi</span> for relation <span class="math">\\mathcal{R}</span> where the verifier samples its challenges from a set of size <span class="math">N</span> is <span class="math">(a_1, \\ldots, a_\\mu)</span>-out-of-<span class="math">N</span> special-sound if there exists a polynomial time algorithm that, on input <span class="math">\\mathsf{pi}</span> and any <span class="math">(a_1, \\ldots, a_\\mu)</span>-tree of transcript for <span class="math">\\Pi</span> outputs <span class="math">\\mathbf{w} \\in \\mathcal{R}(\\mathsf{pi})</span>. We simply denote the protocol as an <span class="math">a^\\mu</span>-out-of-<span class="math">N</span> (or <span class="math">a^\\mu</span>) special-sound protocol if <span class="math">a = a_1 = a_2 = \\dots = a_\\mu</span>.</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">12</p>

    <h2 id="sec-17" class="text-2xl font-bold">2.2 Commitment Scheme</h2>

    <p class="text-gray-300"><strong>Definition 4 (Commitment Scheme).</strong> (Definition 6 from [BC23]) <span class="math">\\mathsf{cm} = (\\mathsf{Setup},\\mathsf{Commit})</span> is a binding commitment scheme, consisting of two algorithms: <span class="math">\\mathsf{Setup}(\\lambda) \\to \\mathsf{ck}</span> takes as input the security parameter and outputs a commitment key <span class="math">\\mathsf{ck}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{ck}, \\mathbf{m} \\in \\mathcal{M}) \\to C \\in \\mathcal{C}</span>, takes as input the commitment key <span class="math">\\mathsf{ck}</span> and a message <span class="math">\\mathbf{m}</span> in <span class="math">\\mathcal{M}</span> and outputs a commitment <span class="math">C \\in \\mathcal{C}</span>.</p>

    <p class="text-gray-300">The scheme is binding if for all polynomial-time randomized algorithms <span class="math">\\mathsf{P}^*</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {Commit} (\\mathsf {ck}, \\boldsymbol {m}) = \\operatorname {Commit} (\\mathsf {ck}, \\boldsymbol {m} ^ {\\prime}) &amp;amp; \\mathsf {ck} \\leftarrow \\operatorname {Setup} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; \\boldsymbol {m} \\neq \\boldsymbol {m} ^ {\\prime} \\end{array} \\right] \\begin{array}{l} \\boldsymbol {m}, \\boldsymbol {m} ^ {\\prime} \\leftarrow \\mathsf {P} ^ {*} (\\mathsf {ck}) \\end{array} \\right] = \\operatorname {negl} (\\lambda)</span></div>

    <p class="text-gray-300"><strong>Homomorphic commitment.</strong> (Adapted from Definition 17 in [KST22]) Let <span class="math">(\\mathcal{C}, +)</span> be an additive group of prime order <span class="math">p</span>. We say the commitment is homomorphic if for all commitment key produced from <span class="math">\\operatorname{Setup}(1^{\\lambda})</span>, and for any <span class="math">\\mathbf{m}_1, \\mathbf{m}_2 \\in \\mathcal{M}^2</span>, <span class="math">\\operatorname{Commit}(\\mathsf{ck}, \\mathbf{m}_1) + \\operatorname{Commit}(\\mathsf{ck}, \\mathbf{m}_2) = \\operatorname{Commit}(\\mathsf{ck}, \\mathbf{m}_1 + \\mathbf{m}_2)</span>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">2.3 Lookup Relation</h2>

    <p class="text-gray-300"><strong>Definition 5.</strong> (Definition 12 of [BC23]) Given configuration <span class="math">\\mathcal{C}_{LK} \\coloneqq (T, \\ell, \\mathbf{t})</span> where <span class="math">\\ell</span> is the number of lookups and <span class="math">\\mathbf{t} \\in \\mathbb{F}^T</span> is the lookup table, the relation <span class="math">\\mathcal{R}_{LK}</span> is the set of tuples <span class="math">\\mathbf{w} \\in \\mathbb{F}^\\ell</span> such that <span class="math">\\mathbf{w}_i \\in \\mathbf{t}</span> for all <span class="math">i \\in [\\ell]</span>.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> (Lemma 5 of [Hab22]) Let <span class="math">\\mathbb{F}</span> be a field of characteristic <span class="math">p &amp;gt; \\max(\\ell, T)</span>. Given two sequences of field elements <span class="math">[\\mathbf{w}_i]_{i=1}^{\\ell}</span> and <span class="math">[\\mathbf{t}_i]_{i=1}^T</span>, we have <span class="math">\\{\\mathbf{w}_i\\} \\subseteq \\{\\mathbf{t}_i\\}</span> as sets (with multiples of values removed) if and only if there exists a sequence <span class="math">[\\mathbf{m}_i]_{i=1}^T</span> of field elements such that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i = 1} ^ {\\ell} \\frac {1}{X + \\mathbf {w} _ {i}} = \\sum_{i = 1} ^ {T} \\frac {\\mathbf {m} _ {i}}{X + \\mathbf {t} _ {i}}. \\tag {1}</span></div>

    <h2 id="sec-19" class="text-2xl font-bold">2.4 Vector-valued lookup</h2>

    <p class="text-gray-300"><strong>Definition 6.</strong> (Definition 13 in [BC23]) Consider configuration <span class="math">\\mathcal{C}_{VLK} \\coloneqq (T, \\ell, v \\in \\mathbb{N}, \\mathbf{t})</span> where <span class="math">\\ell</span> is the number of lookups, and <span class="math">\\mathbf{t} \\in (\\mathbb{F}^v)^T</span> is a lookup table in which the <span class="math">i</span>th (<span class="math">1 \\leq i \\leq T</span>) entry is</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {t} _ {i} := \\left(\\boldsymbol {t} _ {i, 1}, \\dots , \\boldsymbol {t} _ {i, v}\\right) \\in \\mathbb {F} ^ {v}.</span></div>

    <p class="text-gray-300">A sequence of vectors <span class="math">\\mathbf{w} \\in (\\mathbb{F}^v)^\\ell</span> is in relation <span class="math">\\mathcal{R}_{VLK}</span> if and only if for all <span class="math">i \\in [\\ell]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {w} _ {i} := \\left(\\mathbf {w} _ {i, 1}, \\dots , \\mathbf {w} _ {i, v}\\right) \\in \\boldsymbol {t}.</span></div>

    <p class="text-gray-300">6 This lookup argument is unofficially referred to as LogUp.</p>

    <p class="text-gray-300">As noted in Section 3.4 of [Hab22], we can extend Lemma 1 and replace (1) with</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{\\ell} \\frac{1}{X + w_i(Y)} = \\sum_{i=1}^{T} \\frac{\\boldsymbol{m}_i}{X + t_i(Y)} \\tag{2}</span></div>

    <p class="text-gray-300">where the polynomials are defined as</p>

    <div class="my-4 text-center"><span class="math-block">w_i(Y) := \\sum_{j=1}^{v} \\mathbf{w}_{i,j} \\cdot Y^{j-1}, \\quad t_i(Y) := \\sum_{j=1}^{v} \\boldsymbol{t}_{i,j} \\cdot Y^{j-1},</span></div>

    <p class="text-gray-300">which represent the witness vector <span class="math">\\mathbf{w}_i \\in \\mathbb{F}^v</span> and the table vector <span class="math">\\boldsymbol{t}_i \\in \\mathbb{F}^v</span>.</p>

    <h2 id="sec-20" class="text-2xl font-bold">2.5 Incremental Verifiable Computation (IVC)</h2>

    <p class="text-gray-300"><strong>Definition 7 (IVC).</strong> (Adapted Definition 5 from [KST22]) An incrementally verifiable computation (IVC) scheme is defined by PPT algorithms <span class="math">(\\mathsf{G},\\mathsf{P},\\mathsf{V})</span> and deterministic <span class="math">\\mathsf{K}</span> denoting the generator, the prover, the verifier, and the encoder respectively. An IVC scheme <span class="math">(\\mathsf{G},\\mathsf{K},\\mathsf{P},\\mathsf{V})</span> satisfies perfect completeness if for any adversary <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathsf{V}(\\mathsf{vk}, i, z_0, z_i, \\Pi_i) = 0 \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathsf{G}(1^\\lambda), \\\\ F, (i, z_0, z_i, z_{i-1}, \\omega_{i-1}, \\Pi_{i-1}) \\leftarrow \\mathcal{A}(\\mathsf{pp}), \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathsf{K}(\\mathsf{pp}, F), \\\\ z_i = F(z_{i-1}, \\omega_{i-1}), \\\\ \\mathsf{V}(\\mathsf{vk}, i-1, z_0, z_{i-1}, \\Pi_{i-1}) = 0, \\\\ \\Pi_i \\leftarrow \\mathsf{P}(\\mathsf{pk}, i, z_0, z_i; z_{i-1}, \\omega_{i-1}, \\Pi_{i-1}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">where <span class="math">F</span> is a polynomial time computable function. Likewise, an IVC scheme satisfies knowledge soundness if for any constant <span class="math">n \\in \\mathbb{N}</span>, and for all expected polynomial time adversaries <span class="math">\\mathsf{P}^*</span>, there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr_{\\mathsf{r}} \\left[ \\begin{array}{c} z_n = z \\text{ where} \\\\ z_{i+1} \\leftarrow F(z_i, \\omega_i) \\\\ \\forall i \\in \\{0, \\ldots, n-1\\} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{G}(1^\\lambda), \\\\ (F, (z_0, z), \\Pi) \\leftarrow \\mathsf{P}^<em>(\\mathsf{pp}, \\mathsf{r}), \\\\ (\\omega_0, \\ldots, \\omega_{n-1}) \\leftarrow \\mathcal{E}(\\mathsf{pp}, \\mathsf{r}) \\end{array} \\right] \\approx \\\\ \\Pr_{\\mathsf{r}} \\left[ \\mathsf{V}(\\mathsf{vk}, (n, z_0, z), \\Pi) = 0 \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathsf{G}(1^\\lambda), \\\\ (F, (z_0, z), \\Pi) \\leftarrow \\mathsf{P}^</em>(\\mathsf{pp}, \\mathsf{r}), \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathsf{K}(\\mathsf{pp}, F) \\end{array} \\right] \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{r}</span> denotes an arbitrarily long random tape.</p>

    <p class="text-gray-300">An IVC scheme satisfies succinctness if the size of the IVC proof <span class="math">\\Pi</span> does not grow with the number of applications <span class="math">n</span>.</p>

    <p class="text-gray-300"><strong>Definition 8 (Fiat-Shamir Heuristic).</strong> (Definition 9 from [BC23]) The Fiat-Shamir Heuristic, relative to a secure cryptographic hash function <span class="math">\\mathsf{H}</span>, states that a random oracle NARK with negligible knowledge error yields a NARK that has negligible knowledge error in the standard (CRS) model if the random oracle is replaced with <span class="math">\\mathsf{H}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1 (ProtoStar compiler). (Theorem 3 from [BC23]) Let  <span class="math">\\mathbb{F}</span>  be a finite field, such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math">  and  </span>\\mathsf{cm} = (\\mathsf{Setup}, \\mathsf{Commit})<span class="math">  be a binding homomorphic commitment scheme for vectors in  </span>\\mathbb{F}<span class="math"> . Let  </span>\\Pi_{\\mathrm{sps}} = (\\mathsf{P}_{\\mathrm{sps}}, \\mathsf{V}_{\\mathrm{sps}})<span class="math">  be a special-sound protocol for an NP-complete relation  </span>\\mathcal{R}_{\\mathrm{NP}}$  with the following properties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It's  <span class="math">(2k - 1)</span>  move.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- It's  <span class="math">(a_{1},\\ldots ,a_{k - 1})</span>  -out-of-  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  special-sound. Such that the knowledge error  </span>\\kappa = 1 - \\prod_{i = 1}^{k - 1}(1 - \\frac{a_i}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) = \\mathrm{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The inputs are in  <span class="math">\\mathbb{F}^{\\ell_{\\mathrm{in}}}</span></li>

      <li>The verifier is degree  <span class="math">d = \\mathrm{poly}(\\lambda)</span>  with output in  <span class="math">\\mathbb{F}^{\\ell}</span></li>

    </ul>

    <p class="text-gray-300">Then, under the Fiat-Shamir heuristic for a cryptographic hash function  <span class="math">\\mathsf{H}</span>  (Definition 8), there exist two IVC schemes  <span class="math">\\mathsf{IVC} = (\\mathsf{P}_{\\mathsf{IVC}}, \\mathsf{V}_{\\mathsf{IVC}})</span>  and  <span class="math">\\mathsf{IVC}_{\\mathsf{CV}} = (\\mathsf{P}_{\\mathsf{CV},\\mathsf{IVC}}, \\mathsf{V}_{\\mathsf{CV},\\mathsf{IVC}})</span>  with predicates expressed in  <span class="math">\\mathcal{R}_{\\mathsf{NP}}</span>  with the efficiencies shown in Table 2.</p>

    <p class="text-gray-300">Table 2. Efficiency of IVC schemes compiled from sps protocol</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PIVC native</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PIVC recursive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VIVC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πIVC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∑k i=1</td>

            <td class="px-3 py-2 border-b border-gray-700">mi*</td>

            <td class="px-3 py-2 border-b border-gray-700">G P sps + L'(V sps, d+2)</td>

            <td class="px-3 py-2 border-b border-gray-700">k + 2G k + ℓin + d + 1F (k + d + O(1))H + 1Hin</td>

            <td class="px-3 py-2 border-b border-gray-700">∑k i=1</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700">G O(ℓ) + V sps</td>

            <td class="px-3 py-2 border-b border-gray-700">k + ℓin + 1F k + 2G ∑k i=1</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Table 2,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{m}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the prover message length;  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{m}_i^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the number of non-zero elements in  </span>\\mathbf{m}_i<span class="math"> ;  </span>\\mathbb{G}<span class="math">  for rows 1-3 is the total length of the messages committed using Commit.  </span>\\mathbb{F}<span class="math">  are field operations.  </span>\\mathsf{H}<span class="math">  denotes the total input length to a cryptographic hash, and  </span>\\mathsf{H}_{\\mathrm{in}}<span class="math">  is the hash to the public input and accumulator instance.  </span>\\mathsf{P}_{\\mathrm{sps}}<span class="math">  (and  </span>\\mathsf{V}_{\\mathrm{sps}}<span class="math"> ) is the cost of running the prover (and the algebraic verifier) of the special-sound protocol, respectively.  </span>L'(\\mathsf{V}_{\\mathrm{sps}}, d + 2)<span class="math">  is the cost of computing the coefficients of the degree  </span>d + 2$  polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e (X) := \\sum_ {a = 0} ^ {\\sqrt {\\ell} - 1} \\sum_ {b = 0} ^ {\\sqrt {\\ell} - 1} \\left(X \\cdot \\pi . \\beta_ {a} + \\mathsf {a c c}. \\beta_ {a}\\right) \\left(X \\cdot \\pi . \\beta_ {b} ^ {\\prime} + \\mathsf {a c c}. \\beta_ {b} ^ {\\prime}\\right) \\tag {3} \\\\ \\sum_ {j = 0} ^ {d} (\\mu + X) ^ {d - j} \\cdot f _ {j, a + b \\sqrt {\\ell}} ^ {\\mathsf {V} _ {\\mathrm {s p s}}} (\\mathsf {a c c} + X \\cdot \\pi), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where all inputs are linear functions in a formal variable  <span class="math">X^7</span> , and  <span class="math">f_{j,i}^{\\mathsf{V}_{\\mathrm{sps}}}</span>  is the  <span class="math">i</span> th  <span class="math">(0 \\leq i \\leq \\ell - 1)</span>  component of  <span class="math">f_{j}^{\\mathsf{V}_{\\mathrm{sps}}}</span> 's output. For the proof size,  <span class="math">\\mathbb{G}</span>  and  <span class="math">\\mathbb{F}</span>  are the number of commitments and field elements, respectively.</p>

    <p class="text-gray-300">3 Constructing Read List and Write List</p>

    <p class="text-gray-300">In our memory-proving algorithm, we assume that the list of “reads” and the list of “writes” we are given were constructed in a similar way as in the classic offline memory-checking process <em>[x1, x3, x16]</em>. More importantly, our algorithm makes specific use of the “initial reads” and “final writes” in the memory-checking process, which we explicitly define in this section.</p>

    <p class="text-gray-300">Consider an untrusted server who performs read/write operations to a memory. The memory is represented as a <span class="math">T</span>-sized vector of memory values, where the addresses are the indices <span class="math">1,\\ldots,T</span>. Suppose <span class="math">\\mathsf{OM}</span> is the starting, old memory. The server locally intializes two lists, <span class="math">\\mathsf{RL}</span> and <span class="math">\\mathsf{WL}</span>, to empty lists. As in <em>[x1]</em>, we assume both a value and a discrete timestamp of when the value was written are stored at each memory address. The local timestamp <span class="math">t^{*}</span> is incremented when some write operation takes place on the data structure.</p>

    <p class="text-gray-300">When a read operation from address <span class="math">a</span> is performed, and the memory responds with a value-timestamp pair <span class="math">(v,t)</span>, the checker updates its local state as follows:</p>

    <p class="text-gray-300">checks that <span class="math">t^{<em>}&gt;t</span> append <span class="math">(a,v,t)</span> to <span class="math">\\mathsf{RL}</span> stores <span class="math">(v,t^{</em>})</span> at the memory append <span class="math">(a,v,t^{<em>})</span> to <span class="math">\\mathsf{WL}</span> <span class="math">t^{</em>}\\leftarrow t^{*}+1</span></p>

    <p class="text-gray-300">When a write operation of value <span class="math">v^{\\prime}</span> to address <span class="math">a</span> occurs, the checker updates <span class="math">\\mathsf{RL},\\mathsf{WL}</span> in the same way except that the entry appended to <span class="math">\\mathsf{WL}</span> will contain the new value <span class="math">v^{\\prime}</span>.</p>

    <p class="text-gray-300">Then, we extract the “initial reads” <span class="math">R</span> from <span class="math">\\mathsf{RL}</span>, and “final writes” <span class="math">W</span> from <span class="math">\\mathsf{WL}</span> as following:</p>

    <p class="text-gray-300"><span class="math">R,W,A_{R},A_{W}\\leftarrow\\{\\}</span> for <span class="math">(a,v,t)\\in\\mathsf{RL}</span> do if <em>a</em> <span class="math">\\notin A_{R}</span> then do append <span class="math">(a,v,t)</span> to <span class="math">R</span> <span class="math">A_{R}\\leftarrow A_{R}\\cup\\{a\\}</span> for <span class="math">(a,v,t)\\in\\mathsf{WL}.\\text{rev}</span> do if <em>a</em> <span class="math">\\notin A_{W}</span> then do append <span class="math">(a,v,t)</span> to <span class="math">W</span> <span class="math">A_{W}\\leftarrow A_{W}\\cup\\{a\\}</span> sort <em><span class="math">R,W</span> by ascending <span class="math">a</span></em></p>

    <p class="text-gray-300">At a high level, for each address <span class="math">a</span>, we add the tuple containing <span class="math">a</span> in <span class="math">\\mathsf{RL}</span> with the smallest timestamp to <span class="math">R</span>, and add the tuple containing <span class="math">a</span> in <span class="math">\\mathsf{WL}</span> with the largest timestamp to <span class="math">W</span>, and hence the name “initial reads” and “final writes.” Since the entries in <span class="math">\\mathsf{RL}</span> and <span class="math">\\mathsf{WL}</span> would be sorted in increasing order of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">timestamp due to the way they were constructed, traverse the tuples in RL in their natural order, but traverse the tuples in WL backwards (i.e in descending order of timestamp), which is what WL.rev indicates in the pseudocode. Finally, we sort <span class="math">R,W</span> by addresses, and return Rd := RL$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W<span class="math"> and Wr := WL</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">(Contrapositive of Lemma 1 from <em>[x1]</em>) If Rd and Wr are permutations of each other, then the read/write operations are consistent with each other. In other words, for every address, the value and timestamp read are consistent with the value and timestamp previously written.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The protocol guarantees that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{RL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{WL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\textsf{RL}.{\\bm{a}}=\\textsf{WL}.{\\bm{a}}<span class="math"> if the memory functions correctly. It is therefore clear that if Rd and Wr were to be permutations of each other, then it must be </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>W.{\\bm{a}},R.{\\bm{a}}$ are equal as sets.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\ell:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>k:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{RL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{WL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Note that </span>k<span class="math"> is at most </span>2\\ell<span class="math">, therefore </span>k=O(\\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-23" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">The memory accesses and the memory updates were performed correctly if and only if the following three properties are satisfied:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rd and Wr are permutations of each other, as described in Lemma 2</li>

      <li>All the initially read values R.v are consistent with the old memory OM.</li>

      <li>The new memory NM is updated only at the addresses written to and with the correct amount. In other words, the <span class="math">T</span>-sized vector NM - OM should be an <span class="math">\\ell</span> sparse representation of the <span class="math">\\ell</span>-sized vector <span class="math">W-R</span>.</li>

    </ol>

    <h2 id="sec-24" class="text-2xl font-bold">4 Special-Sound Subprotocols for Memory-Proving</h2>

    <p class="text-gray-300">We introduce the three LogUp-style subprotocols that will be combined later to build the Read/Write Memory-proving algorithm.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Handling Tuples.</h4>

    <p class="text-gray-300">For simplicity, we describe the protocols as lookups and permutations on vectors of single values. However, when applied to memory-checking the entries might be tuples of addresses, values, and/or timestamps. Fortunately, this can be handled using a simple random linear combination, akin to the transformation from vector lookups to lookups (Lemma 6 of <em>[x2]</em>). For sequence <span class="math">{\\bm{b}}=[{\\bm{b}}_{i}]_{i=1}^{n}</span> where each entry is a tuple of <span class="math">k&gt;1</span> element (i.e. <span class="math">{\\bm{b}}_{i}=({\\bm{b}}_{(i,j)})_{j=1}^{k}</span> for every <span class="math">i\\in[k]</span>), <span class="math">{\\bm{b}}_{i}</span> will implicitly denote the random linear combination of the elements, i.e. <span class="math">\\sum_{j=1}^{k}Y^{j-1}{\\bm{b}}_{(i,j)}</span>, whenever it appears in a formula. For example,</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{X+{\\bm{b}}_{i}}=\\frac{1}{X+\\sum_{j=1}^{k}Y^{j-1}{\\bm{b}}_{(i,j)}}\\,.</span></p>

    <p class="text-gray-300">This is a <span class="math">k</span>-special-sound transformation, so a previously <span class="math">(a_{1},\\ldots,a_{\\mu})</span>-special-sound protocol becomes <span class="math">(k,a_{1},\\ldots,a_{\\mu})</span>-special sound after it.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Achieving Perfect Completeness. The three protocols we introduce will not yet have perfect completeness since the prover will be sending over vectors of fractions of the form $\\mathbf{h}_{j}=\\frac{\\bm{n}_{j}}{\\bm{d}_{j}}\\quad\\forall j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{h}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, where the computation of the denominator </span>d<span class="math"> is dependent on values in the given witness or lookup table. If there exists any value in some entry of the witness or lookup table such that </span>d=0<span class="math">, then the prover message will be undefined. We can achieve perfect completeness by following the same strategy for achieving perfect completeness in </span>\\Pi_{\\mathrm{LK}}<span class="math"> in <em>[x1]</em>, which is to have the verifier set </span>\\mathbf{h}_{j}=0<span class="math"> in this case and changing the verification equation from </span>\\mathbf{h}_{j}\\cdot\\bm{d}_{j}\\stackrel{{\\scriptstyle?}}{{=}}\\bm{n}_{j}$ to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\bm{d}_{j}\\cdot(\\mathbf{h}_{j}\\cdot\\bm{d}_{j}-\\bm{n}_{j})\\stackrel{{\\scriptstyle?}}{{=}}0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The new check ensures that either <span class="math">\\mathbf{h}_{j}=\\frac{\\bm{n}_{j}}{\\bm{d}_{j}}</span> or <span class="math">\\bm{d}_{j}=0</span>. This increases the verifier degree in all of the three subprotocols to 3. Without these checks, the protocol has a negligible completeness error of $(\\frac{\\sum_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{h}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, where </span>\\mathbf{h}_{1},\\mathbf{h}_{2},\\dots$ are the vectors of fractions sent by the prover. This completeness error is negligible. However, IVC and thus accumulation from which IVC is constructed require the protocols to be perfectly complete <em>[x2]</em> because IVC is designed for distributed computations where the continuance of computation is important, even on adversarially generated inputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">4.1 Checking Permutation Using Lookup Relation</h3>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">(Definition 10 from <em>[x1]</em>) Two sequences of field elements <span class="math">\\mathbf{w}=[\\mathbf{w}_{i}]_{i=1}^{n}</span>, <span class="math">\\mathbf{t}=[\\mathbf{t}_{i}]_{i=1}^{n}</span> are in <span class="math">\\mathcal{R}_{perm}</span> if there exists permutation <span class="math">\\sigma:[n]\\rightarrow[n]</span> such that for all <span class="math">i\\in[n]</span>, <span class="math">\\mathbf{w}_{i}=\\mathbf{t}_{\\sigma(i)}</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a field of characteristic <span class="math">p&gt;\\max(\\ell,T)</span>. Given two sequences of field elements <span class="math">\\mathbf{w}=[\\mathbf{w}_{i}]_{i=1}^{\\ell}</span> and <span class="math">\\mathbf{t}=[\\bm{t}_{i}]_{i=1}^{T}</span>, we have <span class="math">\\mathbf{w},\\mathbf{t}</span> are permutations of each other (i.e. <span class="math">\\mathbf{w},\\mathbf{t}</span> are in <span class="math">\\mathcal{R}_{perm}</span>) if and only if <span class="math">\\ell=T</span> and</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{\\ell}\\frac{1}{X+\\mathbf{w}_{i}}=\\sum_{i=1}^{T}\\frac{1}{X+\\mathbf{t}_{i}}\\,.</span> (4)</p>

    <p class="text-gray-300">See Appendix A.1 for a proof of Lemma 3.</p>

    <p class="text-gray-300">We can therefore describe a special-sound protocol <span class="math">\\Pi_{perm}</span> for <span class="math">\\mathcal{R}_{perm}</span> by simply adding the check <span class="math">\\ell\\stackrel{{\\scriptstyle?}}{{=}}T</span> and removing the need to compute <span class="math">\\bm{m}</span> from <span class="math">\\Pi_{\\mathrm{LK}}</span> for <span class="math">\\mathcal{R}_{\\mathrm{LK}}</span> in <em>[x1]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">|  Special-sound protocol Πperm for Rperm  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | w |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Compute h ∈ F', g ∈ FT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x1 ←# F</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  hj ← 1/x1 + wj ∀j ∈ [l] |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">gi ← 1/x1 + ti ∀i ∈ [T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h, g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l ≠ T</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | ∑j=1l hj ≠ ∑i=1T gi  |</p>

    <p class="text-gray-300">|   |  | hj · (x1 + wj) ≠ 1 ∀j ∈ [l]  |</p>

    <p class="text-gray-300">|   |  | gi · (x1 + ti) ≠ 1 ∀i ∈ [T]  |</p>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{perm}</span>  is a 3-move protocol (i.e.  <span class="math">k = 2</span> ); the degree of the verifier is 2; the number of non-zero elements in the prover message is at most  <span class="math">2\\ell + T</span> .</p>

    <p class="text-gray-300">Special-Soundness. Just as  <span class="math">\\Pi_{\\mathrm{LK}}</span>  from [BC23], the perfect complete version of  <span class="math">\\Pi_{perm}</span>  is  <span class="math">2(\\ell + T)</span> -special-sound, assuming each entry  <span class="math">\\mathbf{w}_j, \\mathbf{t}_i</span>  is a single value for all  <span class="math">j \\in [\\ell], i \\in [T]</span> .</p>

    <p class="text-gray-300">Definition 10. (Indexed-Vector Lookup Relation) Given configuration  <span class="math">\\mathcal{C}_{ivlk} := (T, \\ell, \\mathbf{t})</span>  where  <span class="math">\\ell</span>  is the number of lookups and  <span class="math">\\mathbf{t} \\in \\mathbb{F}^T</span>  is the lookup table, the triple  <span class="math">(\\mathbf{t}, \\mathbf{w} \\in \\mathbb{F}^\\ell, \\mathbf{b} \\in \\mathbb{F}^\\ell)</span>  are in the relation  <span class="math">\\mathcal{R}_{ivlk}</span>  if for all  <span class="math">j \\in [\\ell]</span> ,  <span class="math">\\mathbf{b}_j \\in [T]</span>  and  <span class="math">\\mathbf{w}_j = \\mathbf{t}_{\\mathbf{b}_j}</span> .</p>

    <p class="text-gray-300">Lemma 4 and 5 in the following are extensions on Lemma 4 and 5 from [Hab22], respectively. See Appendix A.2 for proofs of Lemma 4 and Lemma 5.</p>

    <p class="text-gray-300">Lemma 4. Let  <span class="math">\\mathbb{F}</span>  be an arbitrary field and  <span class="math">f_{1}, f_{2} : \\mathbb{F}^{2} \\to \\mathbb{F}</span>  any functions. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {z _ {1}, z _ {2} \\in \\mathbb {F} ^ {2}} \\frac {f _ {1} \\left(z _ {1} , z _ {2}\\right)}{X - z _ {1} \\cdot Y - z _ {2}} = \\sum_ {z _ {1}, z _ {2} \\in \\mathbb {F} ^ {2}} \\frac {f _ {2} \\left(z _ {1} , z _ {2}\\right)}{X - z _ {1} \\cdot Y - z _ {2}} \\tag {5}</span></div>

    <p class="text-gray-300">in the rational function field  <span class="math">\\mathbb{F}(X,Y)</span> , if and only if  <span class="math">f_{1}(z_{1},z_{2}) = f_{2}(z_{1},z_{2})</span>  for every  <span class="math">z_{1},z_{2}\\in \\mathbb{F}^{2}</span> .</p>

    <p class="text-gray-300">Lemma 5. Let  <span class="math">\\mathbb{F}</span>  be a field of characteristic  <span class="math">p &amp;gt; \\max \\{\\ell, T\\}</span> . Given a sequence of field elements  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{\\ell}, \\mathbf{b} \\in \\mathbb{F}^{\\ell}, \\mathbf{t} \\in \\mathbb{F}^{T}</span> , we have  <span class="math">(T, \\ell, \\mathbf{t}, \\mathbf{w}, \\mathbf{b}) \\in \\mathcal{R}_{ivlk}</span>  if and only if the following equation holds in the function field  <span class="math">F(X, Y)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 1} ^ {\\ell} \\frac {1}{X + Y \\cdot \\boldsymbol {b} _ {j} + \\mathbf {w} _ {j}} = \\sum_ {i = 1} ^ {T} \\frac {\\boldsymbol {m} _ {i}}{X + Y \\cdot i + \\mathbf {t} _ {i}} \\tag {6}</span></div>

    <p class="text-gray-300">where  <span class="math">\\pmb{m} = \\{\\pmb{m}_i\\}_{i=1}^T</span>  is the counter vector such that  <span class="math">\\pmb{m}_i</span>  is the count of  <span class="math">(i, \\mathbf{t}_i)</span>  in  <span class="math">(\\pmb{b}, \\mathbf{w})</span> .</p>

    <p class="text-gray-300">We can therefore describe a special-sound protocol for the indexed-vector lookup relation.</p>

    <p class="text-gray-300">|  Special-sound protocol Πivlk for Rivlk  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute m ∈ FT such that |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mi = ∑j=1ℓ 1(wj = ti) ∀i ∈ [T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w, b, m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute h ∈ Fℓ, g ∈ FT |  |   |</p>

    <p class="text-gray-300">|  hj ← 1/x1 + x2 · bj + wj ∀j ∈ [ℓ] |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">gi ← mi/x1 + x2 · i + ti ∀i ∈ [T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h, g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∑j=1ℓ hj ⇒ ∑i=1T gi</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | hj · (x1 + x2 · bj + wj) ⇒ 1 ∀j ∈ [ℓ]  |</p>

    <p class="text-gray-300">|   |  | gi · (x1 + x2 · i + ti) ⇒ mi ∀i ∈ [T]  |</p>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{ivlk}</span>  is a 3-move protocol (i.e.  <span class="math">k = 2</span> ); the degree of the verifier is 3; the number of non-zero elements in the prover message is at most  <span class="math">5\\ell</span> .</p>

    <p class="text-gray-300">Lemma 6.  <span class="math">\\Pi_{ivlk}</span>  is  <span class="math">((\\ell +T),2(\\ell +T))</span>  -special-sound.</p>

    <p class="text-gray-300">See Appendix A.2 for a proof of Lemma 6.</p>

    <h2 id="sec-30" class="text-2xl font-bold">4.3 Mem-Update Relation</h2>

    <p class="text-gray-300">Definition 11 (Mem-Update Relation). Given configuration  <span class="math">\\mathcal{C}_{mu} \\coloneqq (T, \\ell, \\Delta)</span>  where  <span class="math">\\ell</span>  is the number of lookups and  <span class="math">\\Delta \\in \\mathbb{F}^T</span>  is the update table, the triple  <span class="math">(\\mathbf{w} \\in \\mathbb{F}^\\ell, \\mathbf{b} \\in \\mathbb{F}^\\ell, \\Delta)</span>  are in the relation  <span class="math">\\mathcal{R}_{mu}</span>  if for all  <span class="math">j \\in [\\ell]</span> , if  <span class="math">\\mathbf{w}_j \\neq 0</span>  then  <span class="math">\\mathbf{w}_j = \\Delta_{\\mathbf{b}_j}</span> , and for all  <span class="math">i \\in [T]</span> , if  <span class="math">\\Delta_i \\neq 0</span>  then there exists  <span class="math">j \\in [\\ell]</span>  such that  <span class="math">\\mathbf{b}_j = i</span>  and  <span class="math">\\Delta_i = \\mathbf{w}_j</span> .</p>

    <p class="text-gray-300">Lemma 7. Let  <span class="math">\\mathbb{F}</span>  be a field of characteristic  <span class="math">p &amp;gt; \\max \\{\\ell, T\\}</span> . Given the sequences of field elements  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{\\ell}, \\mathbf{b} \\in \\mathbb{F}^{\\ell}, \\Delta \\in \\mathbb{F}^{T}</span> , we have  <span class="math">(T, \\ell, \\Delta, \\mathbf{w}, \\mathbf{b}) \\in \\mathcal{R}_{mu}</span>  if and only if the following equation holds in the function field  <span class="math">F(X, Y)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 1} ^ {\\ell} \\frac {\\mathbf {w} _ {j}}{X + Y \\cdot \\mathbf {b} _ {j} + \\mathbf {w} _ {j}} = \\sum_ {i = 1} ^ {T} \\frac {\\Delta_ {i}}{X + Y \\cdot i + \\Delta_ {i}} \\tag {7}</span></div>

    <p class="text-gray-300">See Appendix A.3 for a proof of Lemma 7.</p>

    <p class="text-gray-300">We describe a  <span class="math">((\\ell +T),2(\\ell +T))</span> -special-sound protocol for the mem-update relation.</p>

    <p class="text-gray-300">|  Special-sound protocol Πmu for Rmu  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | w, b |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x1, x2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x1, x2 ←$ F2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute h ∈ Fℓ, g ∈ FT |  |   |</p>

    <p class="text-gray-300">|  hj ← wj/x1 + x2 · bj + wj ∀j ∈ [ℓ] |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">gi ← Δi/x1 + x2 · i + Δi ∀i ∈ [T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h, g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∑j=1ℓ hj = ∑i=1T gi</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | hj · (x1 + x2 · bj + wj) = wj ∀j ∈ [ℓ]  |</p>

    <p class="text-gray-300">|   |  | gi · (x1 + x2 · i + Δi) = Δi ∀i ∈ [T]  |</p>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{\\mathrm{mu}}</span>  is a 3-move protocol (i.e.  <span class="math">k = 2</span> ); the degree of the verifier is 3; the number of non-zero elements in the prover message is at most  <span class="math">4\\ell</span> .</p>

    <p class="text-gray-300">Lemma 8.  <span class="math">\\Pi_{mu}</span>  is  <span class="math">((\\ell +T),2(\\ell +T))</span> -special-sound, assuming each entry  <span class="math">\\mathbf{w}_j,\\Delta_i</span>  for all  <span class="math">j\\in [\\ell ],i\\in [T]</span>  is a single value.</p>

    <p class="text-gray-300">See Appendix A.3 for a proof of Lemma 8.</p>

    <p class="text-gray-300">Efficiency in Accumulation. We refer to Table 3 for an overview over the efficiency of the protocol. Importantly the prover time is entirely independent of  <span class="math">T</span> . The protocol can also be combined with our GKR protocol as laid out in Section 7. This reduces the prover time by eliminating the multi-scalar multiplication with full field elements. It is, thus, a useful option when the size of the table elements is significantly smaller than the field, e.g. 32-bit elements vs a 256-bit field.</p>

    <h2 id="sec-32" class="text-2xl font-bold">5.1 Using LogUp-style Relations for Memory-Proving</h2>

    <p class="text-gray-300">The full Read/Write Memory-Proving Algorithm  <span class="math">\\varPi_{\\mathsf{MP}}</span>  is given in Appendix B.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 3. Efficiency Table for Accumulating  <span class="math">\\Pi_{\\mathrm{mu}}</span> . We only list the dominant efficiency factors, ignoring the cost for  <span class="math">\\mathsf{P}_{\\mathrm{acc}}</span>  to compute the vectors. Column 2 refers to the total size of the prover messages. Here  <span class="math">\\mathbb{T}</span>  is the set of small elements that are stored in the table, whereas  <span class="math">\\mathbb{F}</span>  refers to full field elements. Column 3 is the verifier degree. Column 5 is the number of prover messages. Note that the number of messages in the GKR case can be further reduced with the optimizations mention in Section 7. Column 6 is the dominant factor in the prover time. An  <span class="math">(a,B)</span> -MSM refers to a multiscalar multiplication of  <span class="math">a</span>  scalars that are each within the set  <span class="math">B</span> . The MSM scales roughly linear in  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . Column 7 is the number of group scalar multiplications the accumulation verifier performs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Msg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(V)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># P Msgs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pacc Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vacc Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plain</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">2ℓ F + 2ℓ T</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">(2ℓ, T)-MSM + (2ℓ, F)-MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">4G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">With GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">2ℓ F + 2ℓ T</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1) log T</td>

            <td class="px-3 py-2 border-b border-gray-700">(2ℓ, T)-MSM + O(ℓ log ℓ)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1) log TG</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given the old memory  <span class="math">\\mathsf{OM} = [\\pmb{v}_i]_{i=1}^T</span> ;  $\\mathsf{Rd} = \\mathsf{RL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W = [(\\pmb{a}_i, \\pmb{v}_i, \\pmb{t}_i)]_{i=1}^k<span class="math">  and  </span>\\mathsf{Wr} = \\mathsf{WL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R = [(\\pmb{a}_i, \\pmb{v}_i, \\pmb{t}_i)]_{i=1}^k<span class="math"> , which were constructed as described in Section 3. Let  </span>\\ell :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In  <span class="math">\\Pi_{\\mathsf{MP}}</span> , the prover takes as input  $(\\mathsf{OM}, \\mathsf{Rd} = \\mathsf{RL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W, \\mathsf{Wr} = \\mathsf{WL}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R)<span class="math"> , and the verifier takes as input  </span>(\\mathsf{OM}^{\\mathsf{V}}, \\mathsf{RL}, \\mathsf{WL})<span class="math"> , where  </span>\\mathsf{OM}^{\\mathsf{V}}<span class="math">  is the verifier&#x27;s stored state of the memory. At the start of the protocol, the prover sends  </span>R, W<span class="math">  to the verifier, and the verifier checks that they are sorted in the same order by addresses, i.e.  </span>R.a \\stackrel{?}{=} W.a$ . The rest of the protocol is composed of the following three LogUp-style protocols:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use  <span class="math">\\varPi_{perm}</span>  to show that  <span class="math">(k,\\mathsf{Rd},\\mathsf{Wr})</span>  are in  <span class="math">\\mathcal{R}_{perm}</span> .</li>

      <li>Use  <span class="math">\\Pi_{ivlk}</span>  to show that  <span class="math">(T,\\ell ,\\mathsf{OM},\\mathbf{r},\\pmb {b})</span>  are in  <span class="math">\\mathcal{R}_{ivlk}</span> , where  <span class="math">\\pmb {b}:= R.\\pmb{a}</span>  and  <span class="math">\\pmb {r}:= R.\\pmb{v}</span> .</li>

      <li>Suppose  <span class="math">W, R</span>  are all ordered by the addresses of the entries. The prover computes  <span class="math">\\mathbf{w} := W \\cdot \\mathbf{v} - R \\cdot \\mathbf{v} \\in \\mathbb{F}^{\\ell}</span> ,  <span class="math">\\mathbf{b} = R \\cdot \\mathbf{a} \\in \\mathbb{F}^{\\ell}</span> , and then use them to efficiently compute  <span class="math">\\Delta \\in \\mathbb{F}^{T}</span>  as follows.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ T ], \\Delta_ {i} = \\left\\{ \\begin{array}{l l} \\mathbf {w} _ {j} &amp;amp; \\text {i f} i = \\boldsymbol {b} _ {j} \\exists j \\in [ \\ell ] \\\\ 0 &amp;amp; \\text {o t h e r w i s e} \\end{array} \\right.</span></div>

    <p class="text-gray-300">which the prover then use to efficiently compute the updated memory NM as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ T ], \\mathsf {N M} _ {i} = \\left\\{ \\begin{array}{l l} \\mathsf {O M} _ {i} + \\varDelta_ {i} &amp;amp; \\text {i f} i = \\boldsymbol {b} _ {j} \\exists j \\in [ \\ell ] \\\\ \\mathsf {O M} _ {i} &amp;amp; \\text {o t h e r w i s e} \\end{array} \\right.</span></div>

    <p class="text-gray-300">This update only takes time linear in  <span class="math">\\ell</span>  and independent of the total memory size  <span class="math">T</span> .</p>

    <p class="text-gray-300">The prover then sends the NM to the verifier, who will compute  <span class="math">\\mathbf{w},\\pmb{b}</span>  from  <span class="math">R,W</span>  and  <span class="math">\\varDelta</span>  from  <span class="math">\\mathsf{NM},\\mathsf{OM}^{\\mathsf{V}}</span>  by himself, and they run  <span class="math">\\varPi_{\\mathrm{mu}}</span>  to show that  <span class="math">(T,\\ell ,\\varDelta ,\\mathbf{w},\\pmb {b})</span>  are in  <span class="math">\\mathcal{R}_{\\mathrm{mu}}</span></p>

    <p class="text-gray-300">If all the check passes, the verifier accepts NM as the correctly updated memory. In the next round, the previously computed NM becomes the new <span class="math">\\mathsf{OM},\\mathsf{OM}^{\\mathsf{V}}</span> for the prover and the verifier, respectively.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Complexity</h5>

    <p class="text-gray-300">It is a 3-move protocol (i.e. <span class="math">k=2</span>); the degree of the verifier is 4; the number of non-zero elements in the prover message is at most <span class="math">8k+6\\ell</span>. This is important because the prover pays linearly in the number of non-zero elements when computing the commitments. It is important to note that the total time of running the protocol is independent of T: running <span class="math">\\Pi_{perm}</span> is linear in <span class="math">k</span>, and <span class="math">\\Pi_{ivlk}</span> and <span class="math">\\Pi_{\\text{mu}}</span> are linear in <span class="math">\\ell</span>; the final step of computing the updated memory can also be done in <span class="math">O(\\ell)</span> time. As we assume <span class="math">k&lt;&lt;T</span>, i.e. the total number of entries in <span class="math">\\mathsf{Rd},\\mathsf{Wr}</span> are much smaller than the total size of the memory, the time it costs to run this memory-proving algorithm is <span class="math">O(\\ell)</span> and independent of <span class="math">T</span>.</p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Security</h5>

    <p class="text-gray-300">In this algorithm, <span class="math">\\Pi_{perm}</span> is <span class="math">(3,4k)</span>-special-sound, <span class="math">\\Pi_{ivlk}</span> is <span class="math">((\\ell+T),2(\\ell+T))</span>-special-sound, and <span class="math">\\Pi_{\\text{mu}}</span> is <span class="math">((\\ell+T),2(\\ell+T))</span>-special-sound. Therefore, the algorithm is <span class="math">((\\ell+T),2(\\ell+T))</span>-special-sound overall.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Computing commitments in the accumulation scheme</h4>

    <p class="text-gray-300">When we use the ProtoStar compiler to turn our memory-proving protocol <span class="math">\\Pi_{\\mathsf{MP}}</span> into an accumulation scheme, the resulting accumulation prover <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span> will send the homomorphic commitments to the prover messages instead of the plain vectors. The homomorphic commitments to the <span class="math">O(\\ell)</span>-sized and <span class="math">\\ell</span>-sparse vectors can all be computed in time independent of <span class="math">T</span> since committing to 0 is free. Moreover, the commitment to NM can be computed in one step by adding the commitment to <span class="math">\\Delta</span> and the commitment to <span class="math">\\mathsf{OM}</span>.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Speeding up Memory-Proving with LogUp-GKR (described in Section 7)</h4>

    <p class="text-gray-300">In the memory-proving protocol the prover’s messages are either <span class="math">O(\\ell)</span> sized or <span class="math">O(\\ell)</span> sparse. However, a more fine-grained view looks at the actual bit-length of the messages. When compiling to an IVC, the prover needs to commit to all the messages and this operation is linear in the bit-length of messages. In the first round of the protocol the prover sends <span class="math">R,W,\\bm{m},\\Delta</span>. These values are representations of values read or written to memory, or their addresses and timestamps respectively. If the memory architecture only supports <span class="math">\\lambda^{\\prime}</span>-bit values, e.g. <span class="math">\\lambda^{\\prime}=32</span>, then these values are all much smaller then the size of the field (which is proportional to the security parameter). In the second prover message, the prover sends multiple inverses. These values are large, even if the denominator itself is small. Note that all vectors are either <span class="math">O(\\ell)</span>-sized or <span class="math">O(\\ell)</span>-sparse.</p>

    <p class="text-gray-300">Instead of sending the second round values and having the verifier perform the sum over the fractions, we will take the approach of LogUp <em>[x23]</em>, where the sum of fractions is computed using formal fractions. Importantly, this does not require sending the fractions itself. This can significantly reduce the prover cost as it now does not need to commit to <span class="math">\\lambda</span>-bit “full” field elements.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The bivariate GKR protocol for LogUp as described in Section 7, requires the prover to commit to messages of size <span class="math">c\\cdot T^{1/c}</span> for any parameter <span class="math">c</span>. We can set <span class="math">c</span> such that <span class="math">T^{1/c}</span> is a marginal cost, compared to committing to the “small” numerators and denominators.</p>

    <p class="text-gray-300">In <span class="math">\\Pi_{\\mathsf{MP}}</span>, some of the vectors of fractions sent by the prover are sparse (E.g. <span class="math">\\bm{g}^{\\mathrm{ivlk}},\\bm{g}^{\\mathrm{mu}}</span>). Even though they contain <span class="math">T</span> entries in total, at most <span class="math">\\ell</span> of them are non-zero. We can take advantage of this sparseness in LogUp GKR by setting <span class="math">d_{i}</span> to 1 whenever <span class="math">n_{i}=0</span> for all <span class="math">i\\in[T]</span>, and the prover will store <span class="math">d_{i}-1=0</span> in its head to facilitate computation. <em>[x10]</em> shows that sumcheck is linear in the sparseness of the vector, which implies that GKR is also linear in the sparseness. Therefore, the time it takes to run LogUp-GKR for those sparse polynomials will be independent of its size.</p>

    <p class="text-gray-300">It is not necessary to run LogUp-GKR from the sum over the entire vector. We can break the overall summation into a sum of several smaller summations, and run LogUp-GKR for each. This reduces the rounds of GKR, and we can then check the final sum in a straightforward manner.</p>

    <p class="text-gray-300">After running GKR, we check that the two fractions are equal by checking the products of one numerator and the other denominator are equal.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Extending to key-value store</h4>

    <p class="text-gray-300">Our protocol can be extended to prove the correctness of key-value store, which is very similar to memory access but the storage does not have a fixed size <span class="math">T</span>. We describe the details of this extension in Appendix B.1.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">5.2 Accumulation prover runs in time independent of <span class="math">T</span></h3>

    <p class="text-gray-300">When we use the ProtoStar compiler to turn <span class="math">\\Pi_{\\mathsf{MP}}</span> into an accumulation scheme, the resulting <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span> will run in time independent of the memory size <span class="math">T</span>, because the messages of the underlying special-sound prover, the cross error terms, and the updated accumulator can all be computed time independent of <span class="math">T</span>.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Underlying special-sound prover runs in <span class="math">\\bm{O}(\\ell)</span> time</h4>

    <p class="text-gray-300">As can be seen in Appendix C, all computations of the prover in <span class="math">\\Pi_{\\mathsf{MP}}</span> can be done in <span class="math">O(\\ell)</span> time. Vectors <span class="math">\\bm{h}^{\\mathrm{perm}},\\bm{g}^{\\mathrm{perm}},\\bm{h}^{\\mathrm{ivlk}},\\bm{h}^{\\mathrm{mu}}</span> all have <span class="math">O(\\ell)</span> size, so they can clearly be computed in <span class="math">O(\\ell)</span> time. Vectors <span class="math">\\bm{m},\\Delta,\\bm{g}^{\\mathrm{ivlk}},\\bm{g}^{\\mathrm{mu}}</span> have size <span class="math">T</span>, but they all have at most <span class="math">\\ell</span> nonzero entries, so an honest prover only needs <span class="math">O(\\ell)</span> time to compute them. Updating the memory also takes <span class="math">O(\\ell)</span> time for an honest prover, since only <span class="math">\\Delta</span> is sparse and only <span class="math">\\ell</span> locations in the memory table need to be changed.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Computing the cross error terms in <span class="math">\\bm{O}(\\ell)</span> time</h4>

    <p class="text-gray-300">In the following, we use <span class="math">\\mathsf{acc}</span> to represent the accumulator, <span class="math">\\pi</span> the current proof, and <span class="math">\\mathsf{acc}^{\\prime}</span> to represent the updated accumulator. We refer the readers to Section 3.4 in <em>[x4]</em> for a general formula on how cross error terms <span class="math">[\\mathbf{e}_{j}]_{j=1}^{d-1}</span> are computed in the accumulation scheme. <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span> will linearly combine the old accumulator and the current proof using a random challenge and use them as inputs to the decider (which is algebraic</p>

    <p class="text-gray-300">of degree <span class="math">d</span>). For an honest prover, the zero coefficient of the polynomial should be the old accumulator’s error term, and the highest-degree coefficient should be 0. The prover needs to then compute and commit to each of the coefficients in between (a.k.a. cross error terms). For most <span class="math">\\mathsf{V_{sps}}</span> checks, it is intuitive how the cross error terms can be computed in <span class="math">O(\\ell)</span> time, as the vectors will be either <span class="math">O(\\ell)</span>-sized or <span class="math">\\ell</span>-sparse. The detailed algorithm for computing the cross error term of the less intuitive <span class="math">\\mathbf{g}_{i}^{\\mathrm{ivlk}}\\cdot(x_{1}+x_{2}\\cdot i+\\mathsf{OM}_{i})\\stackrel{{\\scriptstyle?}}{{=}}\\bm{m}_{i}\\;\\;\\forall i\\in[T]</span> check in time independent of <span class="math">T</span> in the <span class="math">k</span>th round of accumulation is given Appendix C.1.</p>

    <p class="text-gray-300">Note that this helper algorithm is only required when LogUp-GKR (described in Section 7) is <em>not</em> used. Using LogUp-GKR the cross error term computation (using the algorithms described in <em>[x1]</em>) takes only <span class="math">O(c\\cdot T^{1/c})=o(T)</span> time, i.e. is insignificant compared to the rest of the prover computation.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">Updating the accumulator in <span class="math">O(\\ell)</span> time</h4>

    <p class="text-gray-300">The prover still needs to compute the new accumulator <span class="math">\\mathsf{acc^{\\prime}.g}\\leftarrow\\mathsf{acc.g}+X\\cdot\\pi.\\mathbf{g}</span> and <span class="math">\\mathsf{acc^{\\prime}.OM}\\leftarrow\\mathsf{acc.OM}+X\\cdot\\pi.\\mathsf{OM}</span>. While computing <span class="math">\\mathsf{acc^{\\prime}.g}</span> clearly takes <span class="math">O(\\ell)</span> time because <span class="math">\\pi.\\mathbf{g}</span> is <span class="math">\\ell</span>-sparse, the complexity for naively computing <span class="math">\\mathsf{acc^{\\prime}.OM}</span> is linear in <span class="math">T</span>. We show a trick in Appendix C.2 that enables us to accumulate <span class="math">\\mathsf{OM}</span> in time independent of <span class="math">T</span>.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Overall prover efficiency</h4>

    <p class="text-gray-300">We display the effciency metric of both the resulting plain protocol as well as the GKR-version in Table 4. The key prover efficiency is the <span class="math">\\mathsf{P_{acc}}</span> Time. In the plain protocol (see Appendix B), the prover first commits to <span class="math">R,W</span> and <span class="math">\\bm{m}</span>. It also commits to <span class="math">\\Delta</span> in order to compute the commitment to the updated memory <span class="math">\\mathsf{NM}</span>. <span class="math">R</span>, and <span class="math">W</span> are each of size <span class="math">\\ell</span> and contain tuples of three elements <span class="math">(a,v,t)</span>. Note that the <span class="math">a</span> values will be exactly the same in <span class="math">R</span> and <span class="math">W</span>, so committing to <span class="math">R,W</span> takes an MSM of size <span class="math">5\\ell</span>. Committing to <span class="math">\\Delta</span> is an additional sparse MSM with <span class="math">\\ell</span> non-zero elements. Committing to <span class="math">\\bm{m}</span> is a negligble cost as <span class="math">\\bm{m}</span> is a bit-vector. The prover also needs to commit to the vectors of fractions in the second round of the protocol. There are 6 such vectors that are either of size <span class="math">\\ell</span> (for simplicity we assume <span class="math">k=\\ell</span>) or <span class="math">\\ell</span>-sparse. Finally the accumulation prover needs to compute the cross terms for accumulation. We show how to do this in Section 5.2 and it requires an additional 3 <span class="math">\\ell</span>-sparse MSMs. This results in a prover time that only requires committing to <span class="math">15\\ell</span> elements. We can replace the second round of the plain protocol using GKR. The GKR protocol requires committing to <span class="math">O(T^{1/c})</span> for an arbitrary constant <span class="math">c</span>. This reduces the overall accumulation prover complexity to only <span class="math">6\\ell</span> elements, each of which is only as large as the elements stored in the table. Note that this is almost minimal, as even just recording a single read or write, already requires 3 elements, the address, the value and the timestamp.</p>

    <p class="text-gray-300">Table 4. Efficiency Table for Accumulating Memory-Proving Protocol. See Table 3 for an explanation of the columns and symbols. For simplicity we assume that  <span class="math">k = \\ell</span> . They are of the same order.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Msg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(V)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># P Msgs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pacc Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vacc Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plain</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">5ℓT + 6ℓF</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">(6ℓ, T)-MSM + (9ℓ, F)-MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">4G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Using GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ log ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">5ℓT + O(T1/c)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1) · log T</td>

            <td class="px-3 py-2 border-b border-gray-700">(6ℓ, T)-MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1) log TG</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Right now, th prover in our memory-proving IVC scheme needs to commit to 15 field elements per memory access, 9 of which are small memory entries, and 6 of which are large field elements, i.e.  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> -bit, since they are the inverses of the memory entries. As an example, say the memory only contains 32-bit entries. Using homomorphic commitments require fields of size at least  </span>2^{256}<span class="math"> , leading to a factor  </span>256 / 32 = 8$  blowup when computing commitments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An intuitive solution is to employ the GKR protocol, since it has the advantage of only requiring committing to the inputs/outputs and not any intermediate values of the circuit wires. Unfortunately, naively using GKR in accumulation results in  <span class="math">\\log^2 n</span>  rounds (assuming  <span class="math">n</span>  is the number of inputs), which is expensive since the ProtoStar accumulation compiler pays linearly in the number of rounds. We design a version of the GKR protocol that is better suited for accumulation. It takes fewer rounds but retains the desired property of not requiring committing to any intermediate values. The core ingredient is a bivariate sumcheck protocol which only has two rounds.</p>

    <p class="text-gray-300">Bivariate sumcheck requires the verifier to evaluate polynomials of degree  <span class="math">\\Theta(\\sqrt{n})</span> , where  <span class="math">n</span>  is the width of the GKR circuit. This is prohibitively large. Fortunately, we can transform evaluation into a low-degree check by sending additional witnesses. We describe the low-degree evaluation protocol  <span class="math">\\Pi_{eval}</span>  below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Subprotocol Πeval for evaluating f: Fk → F at some a ∈ (F \\ M)k s.t. m :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> deg(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover P(f, a =</td>

            <td class="px-3 py-2 border-b border-gray-700">ai, ..., ai</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">Verifier V(f, a, [f(x)]a∈Fk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">a' ←</td>

            <td class="px-3 py-2 border-b border-gray-700">a</td>

            <td class="px-3 py-2 border-b border-gray-700">, ..., ai</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i ∈ {2,4,...,m}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  A := (a, ak, ak, ..., am) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L(a)(u) := c2(u^m - 1)/u - x ∀x ∈ M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A, L(a)(u) ∀x ∈ M</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | A(0) ⊥ a A(i) ⊥ A(i-1)^2 ∀i ∈ {1,..., log m-1}  |</p>

    <p class="text-gray-300">|   | ∑k=1L(a_i)(a_j) ∑k=1(ai_j - x_j) ⊥ ∑k=1c_{x_j} · (A(log m, j) - 1) ∀x ∈ Mk  |</p>

    <p class="text-gray-300">|   | f(a) ← ∑k∈M^k (∑k=1L(a_i)(a_i) f(x))  |</p>

    <p class="text-gray-300">Efficiency. The verification degree is  <span class="math">2k</span> . The prover sends  <span class="math">m + k \\cdot \\log m</span>  values.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the protocol above,  <span class="math">\\mathbb{H}</span>  is a multiplicative subgroup of  <span class="math">\\mathbb{F}</span> , and we assume  $m :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is a multiple of 2. This implies that the  </span>i<span class="math"> th element of  </span>\\mathbb{H}<span class="math">  is the  </span>i<span class="math"> th root of unity and also that the Lagrange polynomial  </span>L_x<span class="math">  has the form described above, where  </span>c_x<span class="math">  is the barycentric weight. Note that  </span>\\mathsf{P}<span class="math">  sends over a  </span>\\log m \\times k<span class="math">  matrix  </span>A<span class="math"> .  </span>A(i) := a^{2^i}<span class="math">  denotes the  </span>i<span class="math"> th row of  </span>A<span class="math"> , and  </span>A(i,j) := a_j^{2^i}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Security. The protocol has perfect completeness and soundness. The first line of checks ensure that the matrix  <span class="math">A</span>  was computed correctly as claimed by the prover. In the second line of check, note that  <span class="math">A(\\log m,j) = \\pmb{a}_j^{2\\log m} = \\pmb{a}_j^m</span> . Hence if the equality holds, we have</p>

    <div class="my-4 text-center"><span class="math-block">e q (\\pmb {x}, \\pmb {a}) = \\prod_ {j = 1} ^ {k} \\frac {c _ {\\pmb {x} _ {j}} (\\pmb {a} _ {j} ^ {m} - 1)}{\\pmb {a} _ {j} - \\omega_ {\\pmb {x} _ {j}}} = \\prod_ {j = 1} ^ {k} L _ {\\pmb {x} _ {j}} ^ {\\mathbb {H}} (\\pmb {a} _ {j}) \\forall \\pmb {x} \\in \\mathbb {H} ^ {k}</span></div>

    <p class="text-gray-300">which indicates that  <span class="math">eq(\\pmb{x}, \\pmb{a})</span>  was computed correctly as claimed by the verifier. This implies that the two polynomials  <span class="math">f(\\pmb{a})</span>  and  <span class="math">\\sum_{x \\in \\mathbb{H}^k} eq(\\pmb{x}, \\pmb{a}) f(\\pmb{x})</span>  are equal on  <span class="math">m^k</span>  points. Since both of these polynomials have degree strictly smaller than  <span class="math">m</span> , being equal on  <span class="math">m^k</span>  points indicates that they are the same polynomial.</p>

    <h2 id="sec-45" class="text-2xl font-bold">6.2 Bivariate Sumcheck</h2>

    <p class="text-gray-300">We describe a bivariate sumcheck protocol because the ProtoStar compiler pays linearly in the number of rounds, and hence the number of variables in sumcheck. While there is a tradeoff between the number of variables and the degree in each variable, high degrees can be tolerated in the final accumulation scheme because the decider only runs once.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bivariate Sumcheck to prove <span class="math">\\sum_{x \\in \\mathbb{G}_1, y \\in \\mathbb{G}_2} f(x, y) = T</span>, where <span class="math">\\mathbb{G}_1, \\mathbb{G}_2 \\subset \\mathbb{H}</span> s.t. $m :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\deg(f) + 1$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover <span class="math">\\mathbb{P}(f, T)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verifier <span class="math">\\mathbb{V}(f, T)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">f_1(X) \\leftarrow \\sum_{y \\in \\mathbb{G}_2} f(X, y)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">f_1(\\omega_i) \\ \\forall i \\in [m]</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\downarrow</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">a \\leftarrow \\mathbb{F} \\setminus \\mathbb{H}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">f_2(Y) \\leftarrow f(a, Y)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">f_2(\\omega_i) \\ \\forall i \\in [m]</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\downarrow</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">b \\leftarrow \\mathbb{F} \\setminus \\mathbb{H}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">T^* \\leftarrow f_2(b)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">T^*</span></td>

            <td class="px-3 py-2 border-b border-gray-700">Use <span class="math">I_{eval}</span> to evaluate <span class="math">f_1(a), f_2(b)</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   | <span class="math">\\sum_{x \\in \\mathbb{G}_1} f_1(x) \\stackrel{?}{=} T</span>  |</p>

    <p class="text-gray-300">|   |   | <span class="math">\\sum_{y \\in \\mathbb{G}_2} f_2(y) \\stackrel{?}{=} f_1(a)</span>  |</p>

    <p class="text-gray-300">|   |   | <span class="math">T^* \\stackrel{?}{=} f_2(b)</span>  |</p>

    <p class="text-gray-300">|   |   | <span class="math">T^* \\stackrel{?}{=} f(a, b)</span>  |</p>

    <p class="text-gray-300">Security. The protocol is clearly perfectly complete. It is  <span class="math">(m,m)</span> -special-sound. For a fixed challenge  <span class="math">a_i</span> , to show that  <span class="math">f_2(Y) = f(a_i,Y)</span>  requires the equality to hold for  <span class="math">\\deg(f_2) + 1 = \\deg_Y(f) + 1 \\leq \\deg(f) + 1 = m</span>  different challenges for  <span class="math">Y</span> , i.e.  <span class="math">b_1, \\ldots, b_m</span> . Then, since  <span class="math">f_2(Y) = f(a_i,Y)</span> , checking whether  <span class="math">\\sum_{y \\in \\mathbb{G}_2} f_2(y) = f_1(a_i)</span>  is equivalent to checking  <span class="math">\\sum_{y \\in \\mathbb{G}_2} f(a_i,y) = f_1(a_i)</span>  for any fixed  <span class="math">a_i</span> . To show that  <span class="math">f_1(X) = \\sum_{y \\in \\mathbb{G}_2} f(X,y)</span>  requires the equality to hold for  <span class="math">\\deg(f_1) + 1 = \\deg_X(f) + 1 \\leq \\deg(f) + 1 = m</span>  different challenges for  <span class="math">X</span> , i.e.  <span class="math">a_1, \\ldots, a_m</span> . Therefore, with  <span class="math">m</span>  different challenges on  <span class="math">X</span>  and  <span class="math">m</span>  different challenges on  <span class="math">Y</span> , the verifier can be sure that  <span class="math">\\sum_{x \\in \\mathbb{G}_1} f_1(x) = \\sum_{x \\in \\mathbb{G}_1, y \\in \\mathbb{G}_2} f(x,y)</span> . Finally, since  <span class="math">\\sum_{x \\in \\mathbb{G}_1} f(x) = T</span> , it is verified that  <span class="math">\\sum_{x \\in \\mathbb{G}_1, y \\in \\mathbb{G}_2} f(x,y) = T</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 5. Efficiency Table for Accumulating Bivariate SumCheck Using Subprotocol  <span class="math">\\Pi_{eval}</span>  ( $n :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m^2<span class="math"> ). In most applications  </span>f<span class="math">  will be a composition of multiple polynomials; in order to compute  </span>f_1(X)<span class="math"> , the prover will need to perform FFTs which take  </span>n \\log n<span class="math">  operations in  </span>\\mathbb{F}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Msg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(V)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># P Msg</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n log nF</td>

            <td class="px-3 py-2 border-b border-gray-700">4√n + o(√n)F or hashes</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The number of  <span class="math">\\mathsf{P}</span>  messages shown in Table 5 is the number when the polynomial  <span class="math">f</span>  in the sumcheck is non-sparse. Since the polynomial  <span class="math">f</span>  will be sparse (independent of the memory size  <span class="math">T</span> ) when performing memory-proving using our LogUp-powered protocol, the actual number of  <span class="math">\\mathsf{P}</span>  messages will be much smaller.</p>

    <p class="text-gray-300">Description of the Batching Subprotocol for batching  <span class="math">k</span>  sumchecks into one:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given a list of tuples  <span class="math">[(g_j \\in \\mathbb{F}[X_1, \\ldots, X_c], T_j \\in \\mathbb{F})]_{j=1}^k</span>  and  <span class="math">\\mathbb{H}^c</span> , such that  <span class="math">\\sum_{\\boldsymbol{x} \\in \\mathbb{H}^c} g_j(\\boldsymbol{x}) = T_j</span>  for all  <span class="math">j \\in [k]</span> .</li>

      <li>V chooses  <span class="math">r \\gets \\# \\mathbb{F}</span>  at random and sends it to  <span class="math">\\mathsf{P}</span> .</li>

      <li>V batches all  <span class="math">k</span>  sumchecks checks into one as follows</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {\\boldsymbol {x} \\in \\mathbb {H} ^ {c}} f (\\boldsymbol {x}) \\stackrel {?} {=} \\sum_ {j = 1} ^ {k} r ^ {j - 1} T _ {j}</span></div>

    <p class="text-gray-300">for  <span class="math">f(\\pmb{x}) \\coloneqq \\sum_{j=1}^{k} r^{j-1} g_j(\\pmb{x})</span> . Note that if  <span class="math">g_j(\\pmb{x}) = eq(\\pmb{z}_j, \\pmb{x}) g(\\pmb{x})</span>  then  <span class="math">f(\\pmb{x}) = g(\\pmb{x}) \\cdot (\\sum_{j \\in [k]} r^{j-1} \\cdot eq(\\pmb{z}_j, \\pmb{x}))</span></p>

    <p class="text-gray-300">Efficiency. In GKR we call this protocol with  <span class="math">g_{j}(\\pmb{x}) = g(\\pmb{x}) \\cdot eq(\\pmb{z}_{j}, \\pmb{x})</span> . This means that the complexity of the batched sumcheck is equivalent to the complexity of sumcheck over  <span class="math">g</span>  plus evaluating a random linear combination of the  <span class="math">eq</span>  functions. This is only a small additive overhead over a single sumcheck of  <span class="math">g</span> .</p>

    <p class="text-gray-300">Security.</p>

    <p class="text-gray-300">The batching subprotocol is perfectly complete. It is <span class="math">k</span>-special-sound. We can define the following degree <span class="math">(k-1)</span> polynomial:</p>

    <p class="text-gray-300"><span class="math">g(r)</span> <span class="math">:=</span> <span class="math">\\Big{(}\\sum_{x\\in\\mathbb{H}^{c}}f(\\bm{x})\\Big{)}-\\Big{(}\\sum_{j=1}^{k}r^{j-1}T_{j}\\Big{)}</span> <span class="math">=\\sum_{x\\in\\mathbb{H}^{c}}\\Big{(}\\sum_{j=1}^{k}r^{j-1}g_{j}(\\bm{x})\\Big{)}-\\Big{(}\\sum_{j=1}^{k}r^{j-1}T_{j})\\Big{)}=\\sum_{j=1}^{k}r^{j-1}\\Big{(}\\sum_{x\\in\\mathbb{H}^{c}}g_{j}(\\bm{x})-T_{j}\\Big{)}</span></p>

    <p class="text-gray-300">If <span class="math">g(r)</span> is the zero polynomial, then <span class="math">\\sum_{x\\in\\mathbb{H}^{c}}f(\\bm{x})=\\sum_{j=1}^{k}r^{j-1}T_{j}</span>. In order to get <span class="math">g=0</span>, we need <span class="math">\\deg(g)+1=k</span> points of <span class="math">r</span> at which <span class="math">g(r)=0</span>.</p>

    <h2 id="sec-47" class="text-2xl font-bold">7 LogUp GKR protocol using the batching subprotocol</h2>

    <p class="text-gray-300">We incorporate the subprotocols described in Section 6 with LogUp-GKR <em>[x13]</em>, where the circuit is designed for computing the cumulative sums of the fractions using projective coordinates for the additive group of <span class="math">\\mathbb{F}</span>. The full protocol is in Appendix D. We will use this protocol to do the verifier checks for the LogUp-style arguments in <span class="math">\\Pi_{\\mathsf{MP}}</span>.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">Further reducing communication and rounds.</h4>

    <p class="text-gray-300">The bivariate GKR protocol only uses <span class="math">3\\cdot\\log^{2}(k)</span> rounds and has communication complexity <span class="math">\\sqrt{k}</span>. This is significantly fewer rounds than GKR with the standard multi-linear sumcheck which would use <span class="math">O(\\log^{2}k)</span> rounds. In most cases the additional communication of <span class="math">\\sqrt{k}</span> is only marginal, as the prover needed to commit to the input and output layers (of size <span class="math">k</span>). However, in particular when using the protocol with sparse inputs the <span class="math">\\sqrt{k}</span> may indeed become dominant.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6"><span class="math">c</span>-variate sumcheck.</h4>

    <p class="text-gray-300">Fortunately, we can naturally generalize the protocol by relying on a <span class="math">c</span>-variate sumcheck. In this case, the protocol has <span class="math">(c+1)\\cdot\\log_{2}(k)</span> rounds but the communication complexity is only <span class="math">O(c\\cdot k^{1/c})</span>. This exponentially decays as <span class="math">c</span> gets bigger. In the protocol we would expand the dimension in each variable, one by one, such that the size of the layer still grows by a factor of <span class="math">2</span> in each round.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Higher degree reductions.</h4>

    <p class="text-gray-300">Another optimization is to combine <span class="math">2</span> rounds of <span class="math">GKR</span> into one. This increases the degree of the GKR round polynomial by a factor of <span class="math">2</span> but also decreases the number of rounds by the same factor. Using the ProtoStar compiler we only pay for the highest degree verification check, so this optimizations is particularly useful if the circuit already contains high degree checks.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Splitting the summation for round reduction. The core motivation for proving the fractional sum within GKR instead of proving it directly, is that the prover does not need to commit to the inverses. When the numerator and denominator are composed of  <span class="math">c</span> -bit values and  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta(\\lambda)<span class="math">  then this can reduce the commitment cost from  </span>O(\\lambda m)<span class="math">  to just  </span>O(c \\cdot m)<span class="math"> , i.e. save a factor of  </span>\\frac{\\lambda}{c}<span class="math"> . Note that the circuit computed by GKR has a triangle form and each layer is half the width of its parent layer. We can take advantage of this by splitting the sum into  </span>p<span class="math">  parts each of  </span>\\frac{m}{p}<span class="math"> , component. The prover would need to commit to the outputs of each sum, i.e.  </span>p<span class="math">  fractions. The total commitment cost is  </span>O(c \\cdot m + \\lambda p)<span class="math"> . As long as  </span>p \\geq \\frac{cm}{\\lambda}<span class="math"> , the total commitment cost is still  </span>O(c \\cdot m)<span class="math"> . However, the sums computed within GKR are now significantly smaller, and only  </span>\\log \\lambda - \\log c$  GKR layers are required. A similar optimization applies when the input layer is sparse; however, then more layers are required to significantly bring down the cost of committing to the dense output layer.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6. Efficiency Table for Accumulating GKR. See Table 3 for an explanation of the columns. Here,  <span class="math">n</span>  is width of the GKR circuit,  <span class="math">c</span>  is the number of variant in the sumcheck protocol, and  <span class="math">k</span>  is the degree of the sumcheck polynomial.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Variant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P Msg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(V)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># P Msgs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pacc Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vacc Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">bivariate Σ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n1/2)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">3 log n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n1/2)-MSM +O(n log n)F</td>

            <td class="px-3 py-2 border-b border-gray-700">3 log n + 2G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c-variate Σ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(c · n1/c)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1) log n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(c · n1/c)-MSM +O(n log n)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1) log n +2G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">k-round GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(c · n1/c)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1)k</td>

            <td class="px-3 py-2 border-b border-gray-700">O(c · n1/c)-MSM +O(n log n)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1) · k +2G</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">GKR has many applications beyond the use in lookup protocols. For instance, GKR can be used to more efficiently prove that a scalar multiplication was done correctly. This is particularly intriguing as group scalar multiplications are the most expensive operations within the recursive circuit. Concretely the GKR circuit for group scalar multiplication takes as input, a scalar  <span class="math">s</span>  in bit representation  <span class="math">s_{\\lambda - 1} \\ldots s_1 s_0</span>  where  <span class="math">s_i</span>  is either 0 or 1 for every  <span class="math">i \\in \\{0, \\dots, \\lambda - 1\\}</span>  and  <span class="math">s_{\\lambda - 1}</span>  is the most significant bit, a base elliptic curve point in projective coordinates  <span class="math">(X, Y, Z)</span> , and an output curve point also in projective coordinates. The reason to use projective coordinates is that the double-and-add operation can be represented using low-degree (specifically degree 11) algebraic formulas [RCB16]. Using GKR, the prover would only need to commit to 6 scalars and  <span class="math">\\lambda</span>  bits. However, the depth of the circuit might be a bottleneck. We can further reduce the number of layers by providing more intermediary values. E.g. by providing  <span class="math">k</span>  additional curve points, we can reduce the depth from  <span class="math">\\lambda</span>  to  <span class="math">\\lambda / (k + 1)</span> .</p>

    <p class="text-gray-300">In Appendix D.1, we give a concrete formula for scalar multiplication <span class="math">s\\cdot G</span> using GKR in the short Weierstass curves <span class="math">Y^{2}=X^{3}+b</span>.</p>

    <p class="text-gray-300">Acknowledgments. We would like to thank Arasu Arun and Lev Soukhanov for inspiring conversations on memory-checking and accumulation for GKR. We thank Shang Gao for pointing out several typos throughout our paper. We would also like to thank Sebastian Angel for the discussion on Spice and key-value store. This work was supported by Chaincode, and Alpen Labs.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AFK22] Thomas Attema, Serge Fehr, and Michael Klooß. “Fiat-Shamir Transformation of Multi-round Interactive Proofs”. In: TCC 2022, Part I. Ed. by Eike Kiltz and Vinod Vaikuntanathan. Vol. 13747. LNCS. Springer, Heidelberg, Nov. 2022, pp. 113–142. doi: 10.1007/978-3-031-22318-1_5.</li>

      <li>[APPK24] Kasra Abbaszadeh, Christodoulos Pappas, Dimitrios Papadopoulos, and Jonathan Katz. Zero-Knowledge Proofs of Training for Deep Neural Networks. Cryptology ePrint Archive, Paper 2024/162. https://eprint.iacr.org/2024/162. 2024. URL: https://eprint.iacr.org/2024/162.</li>

      <li>[AST23] Arasu Arun, Srinath Setty, and Justin Thaler. Jolt: SNARKs for Virtual Machines via Lookups. Cryptology ePrint Archive, Paper 2023/1217. https://eprint.iacr.org/2023/1217. 2023. URL: https://eprint.iacr.org/2023/1217.</li>

      <li>[BC23] Benedikt Bünz and Binyi Chen. ProtoStar: Generic Efficient Accumulation/Folding for Special Sound Protocols. Cryptology ePrint Archive, Paper 2023/620. https://eprint.iacr.org/2023/620. 2023. URL: https://eprint.iacr.org/2023/620.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. “Recursive composition and bootstrapping for SNARKS and proof-carrying data”. In: 45th ACM STOC. Ed. by Dan Boneh, Tim Roughgarden, and Joan Feigenbaum. ACM Press, June 2013, pp. 111–120. doi: 10.1145/2488608.2488623.</li>

      <li>[BCLMS21] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. “Proof-Carrying Data Without Succinct Arguments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 681–710. doi: 10.1007/978-3-030-84242-0_24.</li>

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. “Recursive Proof Composition from Accumulation Schemes”. In: TCC 2020, Part II. Ed. by Rafael Pass and Krzysztof Pietrzak. Vol. 12551. LNCS. Springer, Heidelberg, Nov. 2020, pp. 1–18. doi: 10.1007/978-3-030-64378-2_1.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: CRYPTO 2014, Part II. Ed. by Juan A. Garay and Rosario Gennaro. Vol. 8617. LNCS. Springer, Heidelberg, Aug. 2014, pp. 276–294. doi: 10.1007/978-3-662-44381-1_16.</li>

      <li>[BDFG21] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. “Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Hei</li>

    </ul>

    <p class="text-gray-300">delberg, Aug. 2021, pp. 649–680. doi: 10.1007/978-3-030-84242-0_23.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BEGKN91] Manuel Blum, William S. Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. “Checking the Correctness of Memories”. In: 32nd FOCS. IEEE Computer Society Press, Oct. 1991, pp. 90–99. doi: 10.1109/SFCS.1991.185352.</li>

      <li>[BFRSBW13] Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Verifying Computations with State (Extended Version). Cryptology ePrint Archive, Report 2013/356. https://eprint.iacr.org/2013/356. 2013.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. https://eprint.iacr.org/2019/1021. 2019.</li>

      <li>[CBBZ22] Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates. Cryptology ePrint Archive, Report 2022/1355. https://eprint.iacr.org/2022/1355. 2022.</li>

      <li>[CDvGS03] Dwaine E. Clarke, Srinivas Devadas, Marten van Dijk, Blaise Gassend, and G. Edward Suh. “Incremental Multiset Hash Functions and Their Application to Memory Integrity Checking”. In: ASIACRYPT 2003. Ed. by Chi-Sung Laih. Vol. 2894. LNCS. Springer, Heidelberg, 2003, pp. 188–207. doi: 10.1007/978-3-540-40061-5_12.</li>

      <li>[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. “Practical verified computation with streaming interactive proofs”. In: ITCS 2012. Ed. by Shafi Goldwasser. ACM, Jan. 2012, pp. 90–112. doi: 10.1145/2090236.2090245.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. “Fractal: Post-quantum and Transparent Recursive Proofs from Holography”. In: EUROCRYPT 2020, Part I. Ed. by Anne Canteaut and Yuval Ishai. Vol. 12105. LNCS. Springer, Heidelberg, May 2020, pp. 769–793. doi: 10.1007/978-3-030-45721-1_27.</li>

      <li>[DNRV09] Cynthia Dwork, Moni Naor, Guy N. Rothblum, and Vinod Vaikuntanathan. “How Efficient Can Memory Checking Be?” In: TCC 2009. Ed. by Omer Reingold. Vol. 5444. LNCS. Springer, Heidelberg, Mar. 2009, pp. 503–520. doi: 10.1007/978-3-642-00457-5_30.</li>

      <li>[EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon. cq: Cached quotients for fast lookups. Cryptology ePrint Archive, Report 2022/1763. https://eprint.iacr.org/2022/1763. 2022.</li>

      <li>[EG23] Liam Eagen and Ariel Gabizon. ProtoGalaxy: Efficient ProtoStar-style folding of multiple instances. Cryptology ePrint Archive, Paper 2023/1106. https://eprint.iacr.org/2023/1106. 2023. url: https://eprint.iacr.org/2023/1106.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GK22] Ariel Gabizon and Dmitry Khovratovich. flookup: Fractional decomposition-based lookups in quasi-linear time independent of table size. Cryptology ePrint Archive, Report 2022/1447. https://eprint.iacr.org/2022/1447. 2022.</li>

      <li>[Hab22] Ulrich Haböck. Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive, Report 2022/1530. https://eprint.iacr.org/2022/1530. 2022.</li>

      <li>[KS23] Abhiram Kothapalli and Srinath Setty. HyperNova: Recursive arguments for customizable constraint systems. Cryptology ePrint Archive, Paper 2023/573. https://eprint.iacr.org/2023/573. 2023. URL: https://eprint.iacr.org/2023/573.</li>

      <li>[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: CRYPTO 2022, Part IV. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13510. LNCS. Springer, Heidelberg, Aug. 2022, pp. 359–388. doi: 10.1007/978-3-031-15985-5_13.</li>

      <li>[PH23] Shahar Papini and Ulrich Haböck. Improving logarithmic derivative lookups using GKR. Cryptology ePrint Archive, Paper 2023/1284. https://eprint.iacr.org/2023/1284. 2023. URL: https://eprint.iacr.org/2023/1284.</li>

      <li>[PK22] Jim Posen and Assimakis A. Kattis. Caulk+: Table-independent lookup arguments. Cryptology ePrint Archive, Report 2022/957. https://eprint.iacr.org/2022/957. 2022.</li>

      <li>[RCB16] Joost Renes, Craig Costello, and Lejla Batina. “Complete Addition Formulas for Prime Order Elliptic Curves”. In: EUROCRYPT 2016, Part I. Ed. by Marc Fischlin and Jean-Sébastien Coron. Vol. 9665. LNCS. Springer, Heidelberg, May 2016, pp. 403–428. doi: 10.1007/978-3-662-49890-3_16.</li>

      <li>[SAGL18] Srinath Setty, Sebastian Angel, Trinabh Gupta, and Jonathan Lee. Proving the correct execution of concurrent services in zero-knowledge. Cryptology ePrint Archive, Report 2018/907. https://eprint.iacr.org/2018/907. 2018.</li>

      <li>[STW23] Srinath Setty, Justin Thaler, and Riad Wahby. Unlocking the lookup singularity with Lasso. Cryptology ePrint Archive, Paper 2023/1216. https://eprint.iacr.org/2023/1216. 2023. URL: https://eprint.iacr.org/2023/1216.</li>

      <li>[Val08] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: TCC 2008. Ed. by Ran Canetti. Vol. 4948. LNCS. Springer, Heidelberg, Mar. 2008, pp. 1–18. doi: 10.1007/978-3-540-78524-8_1.</li>

      <li>[ZBKMNS22] Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. “Caulk: Lookup Arguments in Sublinear Time”. In: ACM CCS 2022. Ed. by Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi. ACM Press, Nov. 2022, pp. 3121–3134. doi: 10.1145/3548606.3560646.</li>

    </ul>

    <p class="text-gray-300">[ZGKMR22] Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, and Carla Ràfols. <em>Baloo: Nearly Optimal Lookup Arguments</em>. Cryptology ePrint Archive, Report 2022/1565. https://eprint.iacr.org/2022/1565. 2022.</p>

    <p class="text-gray-300">A Proofs for Lemmas</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">A.1 Proof for Lemma in Section 4.1</h3>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a field of characteristic <span class="math">p&gt;\\max(\\ell,T)</span>. Given two sequences of field elements <span class="math">\\mathbf{w}=[\\mathbf{w}_{i}]_{i=1}^{\\ell}</span> and <span class="math">\\mathbf{t}=[\\bm{t}_{i}]_{i=1}^{T}</span>, we have <span class="math">\\mathbf{w},\\mathbf{t}</span> are permutations of each other (i.e. <span class="math">\\mathbf{w},\\mathbf{t}</span> are in <span class="math">\\mathcal{R}_{perm}</span>) if and only if <span class="math">\\ell=T</span> and</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{\\ell}\\frac{1}{X+\\mathbf{w}_{i}}=\\sum_{i=1}^{T}\\frac{1}{X+\\mathbf{t}_{i}}\\,.</span> (4)</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose <span class="math">\\ell=T</span> and (4) holds. This implies there exists a sequence <span class="math">[\\bm{m}_{i}]_{i=1}^{T}</span> of field elements where <span class="math">\\bm{m}_{i}=1\\ \\ \\forall i\\in[T]</span> such that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{\\ell}\\frac{1}{X+\\mathbf{w}_{i}}=\\sum_{i=1}^{T}\\frac{\\bm{m}_{i}}{X+\\mathbf{t}_{i}}\\text{ and }\\sum_{i=1}^{\\ell}\\frac{\\bm{m}_{i}}{X+\\mathbf{w}_{i}}=\\sum_{i=1}^{T}\\frac{1}{X+\\mathbf{t}_{i}}</span></p>

    <p class="text-gray-300">By Lemma 1, this means <span class="math">\\{\\mathbf{w}_{i}\\}\\subseteq\\{\\mathbf{t}_{i}\\}</span> and <span class="math">\\{\\mathbf{t}_{i}\\}\\subseteq\\{\\mathbf{w}_{i}\\}</span> as sets. Hence, it must be that <span class="math">\\mathbf{w}=\\bm{t}</span>. The converse direction is trivial.</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">A.2 Proofs for Lemmas in Section 4.2</h3>

    <h6 id="sec-56" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be an arbitrary field and <span class="math">f_{1},f_{2}:\\mathbb{F}^{2}\\to\\mathbb{F}</span> any functions. Then</p>

    <p class="text-gray-300"><span class="math">\\sum_{z_{1},z_{2}\\in\\mathbb{F}^{2}}\\frac{f_{1}(z_{1},z_{2})}{X-z_{1}\\cdot Y-z_{2}}=\\sum_{z_{1},z_{2}\\in\\mathbb{F}^{2}}\\frac{f_{2}(z_{1},z_{2})}{X-z_{1}\\cdot Y-z_{2}}</span> (5)</p>

    <p class="text-gray-300">in the rational function field <span class="math">\\mathbb{F}(X,Y)</span>, if and only if <span class="math">f_{1}(z_{1},z_{2})=f_{2}(z_{1},z_{2})</span> for every <span class="math">z_{1},z_{2}\\in\\mathbb{F}^{2}</span>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Our proof strategy follows the proof of Lemma 4 in <em>[x11]</em>.</p>

    <p class="text-gray-300">Suppose that Equation (5) holds. Then</p>

    <p class="text-gray-300"><span class="math">\\sum_{z_{1},z_{2}\\in\\mathbb{F}^{2}}\\frac{f_{1}(z_{1},z_{2})-f_{2}(z_{1},z_{2})}{X-z_{1}\\cdot Y-z_{2}}=0</span></p>

    <p class="text-gray-300">Fix <span class="math">Y</span> at any arbitrary point <span class="math">y\\in\\mathbb{F}</span>, we get <span class="math">\\sum_{z_{1},z_{2}\\in\\mathbb{F}^{2}}\\frac{f_{1}(z_{1},z_{2})-f_{2}(z_{1},z_{2})}{X-z_{1}\\cdot y-z_{2}}</span>, and therefore have the polynomial</p>

    <p class="text-gray-300"><span class="math">p(X,y)</span> <span class="math">=\\prod_{q\\in\\mathbb{F}}(X-q)\\cdot\\sum_{z_{1},z_{2}\\in\\mathbb{F}^{2}}\\frac{f_{1}(z_{1},z_{2})-f_{2}(z_{1},z_{2})}{X-z_{1}\\cdot y-z_{2}}</span> <span class="math">=\\sum_{z_{1}\\in\\mathbb{F},z_{2}\\in\\mathbb{F}}(f_{1}(z_{1},z_{2})-f_{2}(z_{1},z_{2}))\\cdot\\prod_{q\\in\\mathbb{F}\\setminus\\{z_{1}\\cdot y-z_{2}\\}}(X-q)=0</span></p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">In particular, for every pair <span class="math">z_1 \\in \\mathbb{F}, z_2 \\in \\mathbb{F}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(f _ {1} \\left(z _ {1}, z _ {2}\\right) - f _ {2} \\left(z _ {1}, z _ {2}\\right)\\right) \\cdot \\prod_ {q \\in \\mathbb {F} \\backslash \\{z _ {1} \\cdot y - z _ {2} \\}} \\left(z _ {1} \\cdot y - z _ {2} - q\\right) = 0</span></div>

    <p class="text-gray-300">Since <span class="math">\\prod_{q\\in \\mathbb{F}\\setminus \\{z_1\\cdot y - z_2\\}}(z_1\\cdot y - z_2 - q)</span> is not zero, it must be that <span class="math">f_{1}(z_{1},z_{2}) = f_{2}(z_{1},z_{2})</span> for every pair <span class="math">z_{1},z_{2}\\in \\mathbb{F}^{2}</span>. The other direction is trivial.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Let <span class="math">\\mathbb{F}</span> be a field of characteristic <span class="math">p &amp;gt; \\max \\{\\ell, T\\}</span>. Given a sequence of field elements <span class="math">\\mathbf{w} \\in \\mathbb{F}^{\\ell}, \\mathbf{b} \\in \\mathbb{F}^{\\ell}, \\mathbf{t} \\in \\mathbb{F}^{T}</span>, we have <span class="math">(T, \\ell, \\mathbf{t}, \\mathbf{w}, \\mathbf{b}) \\in \\mathcal{R}_{ivlk}</span> if and only if the following equation holds in the function field <span class="math">F(X, Y)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 1} ^ {\\ell} \\frac {1}{X + Y \\cdot \\boldsymbol {b} _ {j} + \\mathbf {w} _ {j}} = \\sum_ {i = 1} ^ {T} \\frac {\\boldsymbol {m} _ {i}}{X + Y \\cdot i + \\mathbf {t} _ {i}} \\tag {6}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{m} = \\{\\mathbf{m}_i\\}_{i=1}^T</span> is the counter vector such that <span class="math">\\mathbf{m}_i</span> is the count of <span class="math">(i, \\mathbf{t}_i)</span> in <span class="math">(\\mathbf{b}, \\mathbf{w})</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Our proof strategy follows the proof of Lemma 5 in [Hab22].</p>

    <p class="text-gray-300">Suppose <span class="math">(T,\\ell ,\\mathbf{t},\\mathbf{w},\\pmb {b})\\in \\mathcal{R}_{ivlk}</span>, then the equation is guaranteed to be true.</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 1} ^ {T} \\frac {\\boldsymbol {m} _ {i}}{X + Y \\cdot i + \\mathbf {t} _ {i}} = \\sum_ {j = 1} ^ {\\ell} \\frac {\\boldsymbol {m} _ {\\boldsymbol {b} _ {j}}}{X + Y \\cdot \\boldsymbol {b} _ {j} + \\mathbf {t} _ {\\boldsymbol {b} _ {j}}} = \\sum_ {j = 1} ^ {\\ell} \\frac {1}{X + Y \\cdot \\boldsymbol {b} _ {j} + \\mathbf {w} _ {j}}</span></div>

    <p class="text-gray-300">Conversely, suppose (6) holds. Collect fractions with the same denominator for the left side and re-expressing the right side we obtain,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 1} ^ {\\ell} \\frac {1}{X + Y \\cdot \\boldsymbol {b} _ {j} + \\mathbf {w} _ {j}} = \\sum_ {z _ {1} \\in \\mathbb {F}, z _ {2} \\in \\mathbb {F}} \\frac {\\mu_ {\\mathbf {w}} (z _ {1} , z _ {2})}{X + Y \\cdot z _ {1} + z _ {2}} = \\sum_ {i = 1} ^ {T} \\frac {\\boldsymbol {m} _ {i}}{X + Y \\cdot i + \\mathbf {t} _ {i}}</span></div>

    <p class="text-gray-300">where <span class="math">\\mu_{\\mathbf{w}}(z_1,z_2)</span> is the count of the tuple <span class="math">(z_{1},z_{2})</span> in <span class="math">(\\pmb {b},\\mathbf{w})</span>. By the uniqueness of bivariate fractional representations from Lemma 4, we have that for every non-zero <span class="math">\\frac{\\mu_{\\mathbf{w}}(z_1,z_2)}{X + Y\\cdot z_1 + z_2}</span>, there must exist a fraction in the <span class="math">\\sum_{i = 1}^{T}\\frac{\\pmb{m}_i}{X + Y\\cdot i + \\mathbf{t}_i}</span> decomposition with equivalent numerator and denominator. This implies that for non-zero <span class="math">\\mu_{\\mathbf{w}}(z_1,z_2) = \\pmb{m}_{z_1}</span>, and <span class="math">\\mathbf{t}_{z_1} = z_2</span>. Thus, for all <span class="math">j\\in [\\ell ]</span> such that <span class="math">\\mu_{\\mathbf{w}}(z_1,z_2)\\neq 0</span>, <span class="math">\\mathbf{t}_{\\pmb{b}_j} = \\mathbf{w}_j</span> and <span class="math">\\pmb{m}_{\\pmb{b}_j}</span> is the count of <span class="math">(\\pmb {b}_j,\\mathbf{w}_j) = (i,\\mathbf{t}_i)</span> in <span class="math">(\\pmb {b},\\mathbf{w})</span>.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> <span class="math">\\Pi_{ivlk}</span> is <span class="math">((\\ell +T),2(\\ell +T))</span>-special-sound.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We construct an extractor <span class="math">\\mathsf{Ext}</span> that outputs <span class="math">\\mathbf{w},\\pmb{b}</span>. We look at the <span class="math">(\\ell +T)</span> transcripts that all have <span class="math">\\mathbf{w},\\pmb {b},\\pmb{m}</span> as the first message but different <span class="math">(x_{1}^{(p)})</span> as the first challenge in the second message; then for each fixed <span class="math">x_{1}^{(p)}</span>, we look at <span class="math">2(\\ell +T)</span> transcripts that have <span class="math">x_{1}^{(p)}</span> as the first challenge but different <span class="math">(x_{2}^{(q)},\\mathbf{h}^{(q)}\\in \\mathbb{F}^{\\ell},\\mathbf{g}^{(q)}\\in \\mathbb{F}^{T})</span> as the rest of the transcript, totalling <span class="math">2(\\ell +T)^{2}</span> transcripts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the pigeonhole principle, for each <span class="math">p \\in [\\ell + T]</span>, there must exist a subset of <span class="math">S \\subseteq [2(\\ell + T)]</span> transcripts such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell + T<span class="math"> and </span>x_1^{(p)} + x_2^{(q)} \\cdot \\mathbf{b}_j + \\mathbf{w}_j \\neq 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for all <span class="math">j \\in [\\ell]</span> and <span class="math">q \\in S</span>, and <span class="math">x_1^{(p)} + x_2^{(q)} \\cdot i + \\mathbf{t}_i \\neq 0</span> for all <span class="math">i \\in [T]</span> and <span class="math">q \\in S</span>. For these transcripts, we have <span class="math">\\mathbf{h}_j = \\frac{1}{x_1^{(p)} + x_2^{(q)} \\cdot \\mathbf{b}_j + \\mathbf{w}_j}</span> and <span class="math">\\mathbf{g}_i = \\frac{\\mathbf{m}_i}{x_1^{(p)} + x_2^{(q)} \\cdot i + \\mathbf{t}_i}</span>. Define the degree <span class="math">\\ell + T - 1</span> polynomial</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f (X, Y) = \\prod_ {p = 1} ^ {\\ell} \\left(X + Y \\cdot \\boldsymbol {b} _ {p} + \\mathbf {w} _ {p}\\right) \\cdot \\prod_ {q = 1} ^ {T} \\left(X + Y \\cdot 1 + \\mathbf {t} _ {q}\\right) \\\\ \\cdot \\left(\\sum_ {j = 1} ^ {\\ell} \\frac {\\mathbf {w} _ {j}}{X + Y \\cdot \\mathbf {b} _ {j} + \\mathbf {w} _ {j}} - \\sum_ {i = 1} ^ {T} \\frac {\\mathbf {t} _ {i}}{X + Y \\cdot i + \\mathbf {t} _ {i}}\\right) \\end{array}</span></div>

    <p class="text-gray-300">If <span class="math">f(X, Y)</span> is the zero polynomial then <span class="math">\\sum_{j=1}^{\\ell} \\frac{1}{X + Y \\cdot \\mathbf{b}_j + \\mathbf{w}_j} = \\sum_{i=1}^{T} \\frac{\\mathbf{m}_i}{X + Y \\cdot i + \\mathbf{t}_i}</span> and by Lemma 7 <span class="math">(\\mathcal{C}_{ivlk}; \\mathbf{w}, \\mathbf{b}) \\in \\mathcal{R}_{\\mathrm{mu}}</span>. Since we have <span class="math">(\\ell + T)</span> points <span class="math">(x_1^{(p)}, x_2^{(q)})</span> at which <span class="math">f(x_1^{(p)}, x_2^{(q)}) = 0</span>, we get <span class="math">f = 0</span> and thus that the extracted witness <span class="math">(\\mathbf{w}, \\mathbf{b})</span> is valid.</p>

    <h2 id="sec-58" class="text-2xl font-bold">A.3 Proof for Lemma in Section 4.3</h2>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let <span class="math">\\mathbb{F}</span> be a field of characteristic <span class="math">p &amp;gt; \\max \\{\\ell, T\\}</span>. Given the sequences of field elements <span class="math">\\mathbf{w} \\in \\mathbb{F}^{\\ell}, \\mathbf{b} \\in \\mathbb{F}^{\\ell}, \\Delta \\in \\mathbb{F}^{T}</span>, we have <span class="math">(T, \\ell, \\Delta, \\mathbf{w}, \\mathbf{b}) \\in \\mathcal{R}_{mu}</span> if and only if the following equation holds in the function field <span class="math">F(X, Y)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 1} ^ {\\ell} \\frac {\\mathbf {w} _ {j}}{X + Y \\cdot \\mathbf {b} _ {j} + \\mathbf {w} _ {j}} = \\sum_ {i = 1} ^ {T} \\frac {\\Delta_ {i}}{X + Y \\cdot i + \\Delta_ {i}} \\tag {7}</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose <span class="math">(T,\\ell ,\\varDelta ,\\mathbf{w},\\pmb {b})\\in \\mathcal{R}_{\\mathrm{mu}}</span>, then the equation is guaranteed to be true.</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 1} ^ {T} \\frac {\\Delta_ {i}}{X + Y \\cdot i + \\Delta_ {i}} = \\sum_ {j = 1} ^ {\\ell} \\frac {\\Delta_ {\\mathbf {b} _ {j}}}{X + Y \\cdot \\mathbf {b} _ {j} + \\Delta_ {\\mathbf {b} _ {j}}} = \\sum_ {j = 1} ^ {\\ell} \\frac {\\mathbf {w} _ {j}}{X + Y \\cdot \\mathbf {b} _ {j} + \\mathbf {w} _ {j}}</span></div>

    <p class="text-gray-300">Conversely, suppose (7) holds. Collect fractions with the same denominator for the left side and re-expressing the right side we obtain,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 1} ^ {\\ell} \\frac {\\mathbf {w} _ {j}}{X + Y \\cdot \\mathbf {b} _ {j} + \\mathbf {w} _ {j}} = \\sum_ {z _ {1} \\in \\mathbb {F}, z _ {2} \\in \\mathbb {F}} \\frac {z _ {2} \\cdot \\mu_ {\\mathbf {w}} (z _ {1} , z _ {2})}{X + Y \\cdot z _ {1} + z _ {2}} = \\sum_ {i = 1} ^ {T} \\frac {\\Delta_ {i}}{X + Y \\cdot i + \\Delta_ {i}}</span></div>

    <p class="text-gray-300">where <span class="math">\\mu_{\\mathbf{w}}(z_1,z_2)</span> is the count of the tuple <span class="math">(z_{1},z_{2})</span> in <span class="math">(\\pmb {b},\\mathbf{w})</span>. By the uniqueness of bivariate fractional representations from Lemma 4, we have that for every nonzero <span class="math">\\frac{z_2\\cdot\\mu_{\\mathbf{w}}(z_1,z_2)}{X + Y\\cdot z_1 + z_2}</span>, there must exist a fraction in the <span class="math">\\sum_{i = 1}^{T}\\frac{\\Delta_i}{X + Y\\cdot i + \\Delta_i}</span> decomposition with equivalent numerator and denominator. This implies that for non-zero <span class="math">z_{2}\\cdot \\mu_{\\mathbf{w}}(z_1,z_2) = \\varDelta_{z_1}=z_2</span>, so <span class="math">\\mu_w(z_1,z_2) = 1</span>. Thus, for all <span class="math">j\\in [\\ell ]</span> such that <span class="math">\\mathbf{w}_j\\neq 0</span>, <span class="math">\\varDelta_{\\pmb{b}_j}=\\mathbf{w}_j</span>.</p>

    <p class="text-gray-300">For every <span class="math">\\frac{\\Delta_i}{X + Y \\cdot i + \\Delta_i}</span>, there must exist a fraction in the <span class="math">\\sum_{z_1 \\in \\mathbb{F}, z_2 \\in \\mathbb{F}} \\frac{z_2 \\cdot \\mu_{\\mathbf{w}}(z_1, z_2)}{X + Y \\cdot z_1 + z_2}</span> decomposition with the equivalent numerator and denominator, which implies <span class="math">\\Delta_i = z_2 \\cdot \\mu_{\\mathbf{w}}(z_1, z_2) = z_2</span> for every <span class="math">\\Delta_i</span>. Therefore if <span class="math">\\Delta_i \\neq 0</span> then <span class="math">\\mu_{\\mathbf{w}}(z_1, z_2) \\neq 0</span>, and thus there exists <span class="math">j \\in [\\ell]</span> such that <span class="math">\\mathbf{b}_j = i</span> and <span class="math">\\Delta_i = \\mathbf{w}_j</span>.</p>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">Lemma 8. <span class="math">\\Pi_{mu}</span> is <span class="math">((\\ell + T), 2(\\ell + T))</span>-special-sound, assuming each entry <span class="math">\\mathbf{w}_j, \\Delta_i</span> for all <span class="math">j \\in [\\ell], i \\in [T]</span> is a single value.</p>

    <p class="text-gray-300">Proof. We construct an extractor <span class="math">\\mathsf{Ext}</span> that outputs <span class="math">\\mathbf{w}, \\mathbf{b}</span>. We look at the <span class="math">(\\ell + T)</span> transcripts that all have <span class="math">\\mathbf{w}, \\mathbf{b}</span> as the first message but different <span class="math">(x_1^{(p)})</span> as the first challenge in the second message; then for each fixed <span class="math">x_1^{(p)}</span>, we look at <span class="math">2(\\ell + T)</span> transcripts that have <span class="math">x_1^{(p)}</span> as the first challenge but different <span class="math">(x_2^{(q)}, \\mathbf{h}^{(q)} \\in \\mathbb{F}^\\ell, \\mathbf{g}^{(q)} \\in \\mathbb{F}^T)</span> as the rest of the transcript, totalling <span class="math">2(\\ell + T)^2</span> transcripts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the pigeonhole principle, for each <span class="math">p \\in [\\ell + T]</span>, there must exist a subset of <span class="math">S \\subseteq [2(\\ell + T)]</span> transcripts such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell + T<span class="math"> and </span>x_1^{(p)} + x_2^{(q)} \\cdot \\mathbf{b}_j + \\mathbf{w}_j \\neq 0<span class="math"> for all </span>j \\in [\\ell]<span class="math">, and </span>q \\in S<span class="math">, and </span>x_1^{(p)} + x_2^{(q)} \\cdot i + \\Delta_i \\neq 0<span class="math"> for all </span>i \\in [T]<span class="math"> and </span>q \\in S<span class="math">. For these transcripts, we have </span>\\mathbf{h}_j = \\frac{\\mathbf{w}_j}{x_1^{(p)} + x_2^{(q)} \\cdot \\mathbf{b}_j + \\mathbf{w}_j}<span class="math"> and </span>\\mathbf{g}_i = \\frac{\\Delta_i}{x_1^{(p)} + x_2^{(q)} \\cdot i + \\Delta_i}<span class="math">. Define the degree </span>\\ell + T - 1$ polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f (X, Y) = \\prod_ {p = 1} ^ {\\ell} \\left(X + Y \\cdot \\boldsymbol {b} _ {p} + \\mathbf {w} _ {p}\\right) \\cdot \\prod_ {q = 1} ^ {T} \\left(X + Y \\cdot q + \\Delta_ {q}\\right) \\\\ \\cdot \\left(\\sum_ {j = 1} ^ {\\ell} \\frac {\\mathbf {w} _ {j}}{X + Y \\cdot \\mathbf {b} _ {j} + \\mathbf {w} _ {j}} - \\sum_ {i = 1} ^ {T} \\frac {\\Delta_ {i}}{X + Y \\cdot i + \\Delta_ {i}}\\right) \\end{array}</span></div>

    <p class="text-gray-300">If <span class="math">f(X, Y)</span> is the zero polynomial then <span class="math">\\sum_{j=1}^{\\ell} \\frac{\\mathbf{w}_j}{X + Y \\cdot \\mathbf{b}_j + \\mathbf{w}_j} = \\sum_{i=1}^{T} \\frac{\\Delta_i}{X + Y \\cdot i + \\Delta_i}</span> and by Lemma 7 <span class="math">(\\mathcal{C}_{\\mathrm{mu}}; \\mathbf{w}, \\mathbf{b}) \\in \\mathcal{R}_{\\mathrm{mu}}</span>. Since we have <span class="math">(\\ell + T)</span> points <span class="math">(x_1^{(p)}, x_2^{(q)})</span> at which <span class="math">f(x_1^{(p)}, x_2^{(q)}) = 0</span>, we get <span class="math">f = 0</span> and thus that the extracted witness <span class="math">(\\mathbf{w}, \\mathbf{b})</span> is valid.</p>

    <p class="text-gray-300">B Full Memory-Proving Protocol</p>

    <p class="text-gray-300">|  Special-sound Lookup-Powered Memory-Proving Protocol ΠMP  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute b∈T, r∈T, m∈T, w∈T, w∈T, Δ∈T such that: b:=R.a r:=R.v |  |   |</p>

    <p class="text-gray-300">|  mi:=1 if i=bj 2j∈[l], 0 otherwise. ∀i∈[T] |  |   |</p>

    <p class="text-gray-300">|  w:=W.v-R.v |  |   |</p>

    <p class="text-gray-300">|  Δi:=wj if i=bj 2j∈[l], 0 otherwise. ∀i∈[T] |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiently computes NM←Δ+OM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R,W,m,NM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R.a=W.a Rd:=RL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W Wr:=WL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compute, on the fly, the linear combinations of the values in the tuples of Rd,Wr: Rd'←Rdj.a+x2·Rdj.v+x3·Rdj.t ∀j∈[k]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">bT:=R.a rT:=R.v</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Wr'←Wrj.a+x2·Wrj.v+x3·Wrj.t ∀j∈[k]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w:=W.v-R.v Δ:=NM-OMT</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">bj=1/x1+Rd' ∀j∈[k]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Similarly, compute the linear combinations on the fly:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g=1/x1+Rd' ∀j∈[k]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Rd'←Rdj.a+x2·Rdj.v+x3·Rdj.t ∀j∈[k]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g=1/x1+Rd' ∀j∈[k]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Wr'←Wrj.a+x2·Wrj.v+x3·Wrj.t ∀j∈[k]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  bj=1/x1+x2·bj+rj ∀j∈[l] |  |   |</p>

    <p class="text-gray-300">|  g=1/x1+x2·i+OMi ∀i∈[T] |  |   |</p>

    <p class="text-gray-300">|  bj=1/x1+x2·bj+wi ∀j∈[l] |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g=1/x1+x2·i+Δi ∀i∈[T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">bj=1/x1+Rd' ∀i∈[T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  g=1/x1+x2·bi+wi ∀i∈[T] |  |   |</p>

    <p class="text-gray-300">Key-value store bears a strong resemblance to memory access, with two notable differences: 1) Instead of reading/writing to addresses, the server gets/inserts values under specified keys. 2) Unlike memory, the storage does not have a fixed size  <span class="math">T</span> ; rather, it is only as large as the number of distinct keys inserted. In other words, the storage is initially empty and only grows as values are inserted under new keys. Key-value store was the setting considered in Spice [SAGL18]. Although the absence of a fixed storage bound  <span class="math">T</span>  seems problematic when applying our memory-proving protocol, our protocol can be extended to support a verifiable key-value store. We give a brief description below.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Set <span class="math">T</span> to be a cryptographically large number (e.g. <span class="math">2^{256}</span>) and initialize a <span class="math">T</span>-sized storage table to all zeroes (To support actually storing the value 0, one can either use a one-bit flag to indicate whether a 0 entry is empty, or store a special symbol for the value 0). Suppose we perform <span class="math">\\ell</span> key-value get/insert operations. Whenever we need to insert a value under key <span class="math">k</span>, we write that value to the <span class="math">k</span>th entry in the storage table. Since <span class="math">T</span> is huge, obviously <span class="math">\\ell&lt;&lt;T</span>, and only a small subset of <span class="math">\\{1,\\ldots,T\\}</span> would ever be used as keys.</p>

    <p class="text-gray-300">In each round of accumulation, <span class="math">\\mathsf{P_{acc}}</span> needs to commit to the prover messages of the underlying interactive protocol, which includes some <span class="math">T</span>-sized vectors. While committing to the <span class="math">T</span>-sized vectors seems overwhelmingly expensive, we note that those vectors will be sparse with at most <span class="math">\\ell</span> nonzero entries, so the commitment cost is <span class="math">O(\\ell)</span>. However, we do need random access to the commitment keys in order to avoid generating all <span class="math">T</span> commitment keys. For instance, we can use a hash function that maps from <span class="math">\\{1,\\ldots,T\\}</span> to a prime order group; then, we only need to use the hash function for the keys inserted into the storage. Since we only need to do <span class="math">O(\\ell)</span> commitments, only <span class="math">O(\\ell)</span> hashes will be needed in each round.</p>

    <p class="text-gray-300">At the end of each IVC step, the prover needs to send all the decommitted, accumulated vectors to the decider for the final verification checks. Note that the <span class="math">T</span>-sized vectors will again be sparse: suppose we do <span class="math">O(\\ell)</span> get/insert operations per accumulation round and have a total of <span class="math">a</span> accumulation rounds, then the total number of nonsparse entries in the <span class="math">T</span>-sized vectors will be at most <span class="math">O(a\\ell)&lt;&lt;T</span>. Thus, instead of sending the full vectors, we can send a table of the nonsparse vector values.</p>

    <p class="text-gray-300">There are two limitations in extending our memory-proving protocol to verifiable key-value store. First, as previously noted, our scheme necessitates random access to commitment keys. Second, this scheme for verifiable key-value store may not be compatible with our optimization using the accumulation-friendly GKR, because the GKR circuit will be very large with <span class="math">\\log T</span> depth. We leave these as open questions for future research.</p>

    <h2 id="sec-60" class="text-2xl font-bold">Appendix C Subalgorithms for <span class="math">\\boldsymbol{O(\\ell)}</span> accumulation prover time</h2>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">C.1 Computing the cross error terms in <span class="math">\\boldsymbol{O(\\ell)}</span> time</h3>

    <p class="text-gray-300">Let <span class="math">\\mathsf{acc}</span> be the current accumulator, <span class="math">\\pi</span> the current proof, and <span class="math">\\mathsf{acc^{\\prime}}</span> the updated accumulator. We need to compute the cross error terms for</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}_{i}^{\\text{ivlk}}\\cdot(x_{1}+x_{2}\\cdot i+\\mathsf{OM}_{i})-\\boldsymbol{m}_{i}\\ \\ \\forall i\\in[T]</span></p>

    <p class="text-gray-300">We give a description of the idea below. See Figure 1 for the algorithm.</p>

    <p class="text-gray-300">For simplicity, we just use <span class="math">\\mathbf{g}</span> to denote <span class="math">\\mathbf{g}^{\\text{ivlk}}</span>, and <span class="math">\\mathsf{OM^{\\prime}}</span> to denote <span class="math">(x_{1}\\cdot\\mathbf{1}_{T}+x_{2}\\cdot\\boldsymbol{i}+\\mathsf{OM})</span>, where <span class="math">\\boldsymbol{i}=[1,2,\\ldots,T]</span> is the address/index vector of <span class="math">\\mathsf{OM}</span>. In vector form, the above expression is equivalent to</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}\\circ\\mathsf{OM^{\\prime}}-\\boldsymbol{m}</span></p>

    <p class="text-gray-300">When compiled by the ProtoStar compiler, the accumulation prover will combine acc and <span class="math">\\pi</span> using random linearly combination into the new accumulator acc^{′}, and then compute a commit to each of the expanded terms of the verifier polynomial in acc^{′}. In other words, it will compute a commit to each of the expanded terms of the following,</p>

    <p class="text-gray-300"><span class="math">\\textsf{acc}^{\\prime}.\\textsf{g}\\circ\\textsf{acc}^{\\prime}.\\textsf{OM}^{\\prime}-\\textsf{acc}^{\\prime}.\\mu\\circ\\textsf{acc}^{\\prime}.\\bm{m}=</span> <span class="math">(\\textsf{acc}.\\textsf{g}+X\\cdot\\pi.\\textsf{g})\\circ(\\textsf{acc}.\\textsf{OM}^{\\prime}+X\\cdot\\pi.\\textsf{OM}^{\\prime})-(\\textsf{acc}.\\mu+X\\cdot\\pi.\\mu)\\cdot(\\textsf{acc}.\\bm{m}+X\\cdot\\pi.\\bm{m})</span></p>

    <p class="text-gray-300">As stated earlier, for an honest prover, the zero coefficient should be 0 and the highest-degree coefficient should be 0, so the prover only needs to compute and commit to the degree-1 coefficient in this case, which is</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_{1}:=\\textsf{acc}.\\textsf{g}\\circ\\pi.\\textsf{OM}^{\\prime}+\\pi.\\textsf{g}\\circ\\textsf{acc}.\\textsf{OM}^{\\prime}+\\textsf{acc}.\\mu\\cdot\\pi.\\bm{m}+\\pi.\\mu\\cdot\\textsf{acc}.\\bm{m}</span></p>

    <p class="text-gray-300">Since <span class="math">\\pi.\\textsf{g},\\pi.\\bm{m}</span> are sparse (only <span class="math">\\ell</span> out of <span class="math">T</span> nonzero entries), the complexity of computing <span class="math">\\pi.\\textsf{g}\\circ\\textsf{acc}.\\textsf{OM}^{\\prime},\\textsf{acc}.\\mu\\cdot\\pi.\\bm{m},\\pi.\\mu\\cdot\\textsf{acc}.\\bm{m}</span> is clearly <span class="math">O(\\ell)</span>; moreover, since the two resulting Hadamard products will also be sparse vectors, committing them only takes <span class="math">O(\\ell)</span> time. <span class="math">\\pi.\\mu</span> is simply 1 in the accumulation scheme, so the commitment of <span class="math">\\pi.\\mu\\cdot\\textsf{acc}.\\bm{m}</span> is simply <span class="math">\\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc}.\\bm{m})</span>, one of the commitments to accumulated prover messages included in the accumulator instance. The only term remaining to be analyzed is <span class="math">\\textsf{acc}.\\textsf{g}\\circ\\pi.\\textsf{OM}^{\\prime}</span>, which is equivalent to</p>

    <p class="text-gray-300"><span class="math">\\textsf{acc}.\\textsf{g}\\circ\\pi.\\textsf{OM}^{\\prime}</span> <span class="math">:=\\textsf{acc}.\\textsf{g}\\circ(\\pi.x_{1}\\cdot\\mathbf{1}_{T}+\\pi.x_{2}\\cdot\\bm{i}+\\pi.\\textsf{OM})</span> <span class="math">=\\pi.x_{1}\\cdot\\textsf{acc}.\\textsf{g}+\\pi.x_{2}\\cdot\\textsf{acc}.\\textsf{g}\\circ\\bm{i}+\\textsf{acc}.\\textsf{g}\\circ\\pi.\\textsf{OM}</span></p>

    <p class="text-gray-300"><span class="math">\\pi.x_{1}\\cdot\\textsf{acc}.\\textsf{g}</span> can be easily committed as a scalar multiplication of the commitment of <span class="math">\\textsf{acc}.\\textsf{g}</span>, which is included in the accumulator instance as one of the accumulated commitments. As for the other two terms, we can store values from the previous round of accumulation to aid the computation.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{\\textsf{acc}}</span> and <span class="math">\\hat{\\pi}</span> denote the accumulator and the proof in the previous round, and <span class="math">r</span> denote the challenge in the previous round, i.e. <span class="math">\\textsf{acc}=\\hat{\\textsf{acc}}+r\\cdot\\hat{\\pi}</span>. Then, we can re-express the terms in the following way,</p>

    <p class="text-gray-300"><span class="math">\\pi.x_{2}\\cdot\\textsf{acc}.\\textsf{g}\\circ\\bm{i}</span> <span class="math">=\\pi.x_{2}\\cdot(\\hat{\\textsf{acc}}.\\textsf{g}+r\\cdot\\hat{\\pi}.\\textsf{g})\\circ\\bm{i}</span> <span class="math">=\\pi.x_{2}\\cdot(\\hat{\\textsf{acc}}.\\textsf{g}\\circ\\bm{i}+r\\cdot\\hat{\\pi}.\\textsf{g}\\circ\\bm{i})</span> <span class="math">\\textsf{acc}.\\textsf{g}\\circ\\pi.\\textsf{OM}</span> <span class="math">=(\\hat{\\textsf{acc}}.\\textsf{g}+r\\cdot\\hat{\\pi}.\\textsf{g})\\circ\\pi.\\textsf{OM}</span> <span class="math">=\\hat{\\textsf{acc}}.\\textsf{g}\\circ\\pi.\\textsf{OM}+r\\cdot\\hat{\\pi}.\\textsf{g}\\circ\\pi.\\textsf{OM}</span> <span class="math">=\\hat{\\textsf{acc}}.\\textsf{g}\\circ(\\hat{\\pi}.\\textsf{OM}+\\hat{\\pi}.\\Delta)+r\\cdot\\hat{\\pi}.\\textsf{g}\\circ\\pi.\\textsf{OM}</span> <span class="math">=\\hat{\\textsf{acc}}.\\textsf{g}\\circ\\hat{\\pi}.\\textsf{OM}+\\hat{\\textsf{acc}}.\\textsf{g}\\circ\\hat{\\pi}.\\Delta+r\\cdot\\hat{\\pi}.\\textsf{g}\\circ\\pi.\\textsf{OM}</span></p>

    <p class="text-gray-300">Observe that <span class="math">\\hat{\\textsf{acc}}.\\textsf{g}\\circ i</span> and <span class="math">\\hat{\\textsf{acc}}.\\textsf{g}\\circ\\hat{\\pi}.\\textsf{OM}</span> were already computed and committed to in the previous round of accumulation. The other terms can be computed and committed to in time independent of <span class="math">T</span> since <span class="math">\\hat{\\pi}.\\Delta</span> and <span class="math">\\hat{\\pi}.\\textsf{g}</span> are sparse, and the resulting Hadamard products are also sparse. Thus, the prover can compute and commit to <span class="math">\\textsf{acc}.\\textsf{g}\\circ\\pi.\\textsf{OM}^{\\prime}</span> in time independent of <span class="math">T</span>, which means the prover will be able to compute and commit to <span class="math">\\mathbf{e}_{1}</span> in time independent of <span class="math">T</span> as well.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300"><span class="math">\\rho_{\\mathrm{acc}}</span>  - random oracle for accumulation,</p>

    <p class="text-gray-300">ck - commitment key,</p>

    <p class="text-gray-300">acc.  <span class="math">(x_{1},x_{2},\\mu ,\\mathbf{g},\\mathsf{OM})</span>  - items accumulated up to  <span class="math">(k - 1)</span>  th round,</p>

    <p class="text-gray-300"><span class="math">C_{\\mathbf{g}} = \\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc.g}),C_{\\pmb{m}} = \\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc.m})</span>  - accumulated commitments,</p>

    <p class="text-gray-300"><span class="math">\\pi .(x_{1},x_{2},\\mu ,\\mathbf{g},\\mathsf{OM})</span>  - proof items,</p>

    <p class="text-gray-300">The items stored from the previous round:</p>

    <p class="text-gray-300">acc.g - item accumulated up to  <span class="math">(k - 2)</span>  th round,</p>

    <p class="text-gray-300"><span class="math">\\hat{\\pi}.\\mathbf{(g},\\Delta)</span>  - proof items from the  <span class="math">(k - 1)</span>  th round,</p>

    <p class="text-gray-300"><span class="math">r_{(k - 1)}</span>  - random accumulation challenge from the  <span class="math">(k - 1)</span>  th round,</p>

    <p class="text-gray-300"><span class="math">\\hat{E}_{a2} = \\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc.g}\\circ \\boldsymbol {i}),\\hat{E}_{a3} = \\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc.g}\\circ \\hat{\\pi}. \\mathsf{OM})</span>  - partial</p>

    <p class="text-gray-300">commitments from the  <span class="math">(k - 1)</span>  th round.</p>

    <p class="text-gray-300">Goal: Compute a commitment to the degree-1 cross error term</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_1 \\coloneqq \\mathrm{acc.g} \\circ \\pi . \\mathsf{OM}&#x27; + \\pi . \\mathbf{g} \\circ \\mathrm{acc}. \\mathsf{OM}&#x27; + \\mathrm{acc}. \\mu \\cdot \\pi . \\mathbf{m} + \\pi . \\mu \\cdot \\mathrm{acc}. \\mathbf{m}</span></p>

    <p class="text-gray-300"><span class="math">E_{a2}\\gets \\hat{E}_{a2} + r_{(k - 1)}\\cdot \\mathsf{Commit}(\\mathsf{ck},\\hat{\\pi}.\\mathbf{g}\\circ \\boldsymbol {i}),</span></p>

    <p class="text-gray-300"><span class="math">E_{a3}\\gets \\hat{E}_{a3} + \\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc.g}\\circ \\hat{\\pi}.\\Delta +r_{(k - 1)}\\cdot \\hat{\\pi}.\\mathbf{g}\\circ \\pi .\\mathsf{OM}),</span></p>

    <p class="text-gray-300"><span class="math">E_{a}\\gets \\pi .x_{1}\\cdot C_{\\mathbf{g}} + \\pi .x_{2}\\cdot E_{a2} + E_{a3},</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_b\\gets \\pi .\\mathbf{g}\\circ \\mathrm{acc.OM}&#x27;</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_c\\gets \\mathrm{acc}.\\mu \\cdot \\pi .\\pmb {m},</span></p>

    <p class="text-gray-300"><span class="math">E_{1}\\gets E_{a} + \\mathsf{Commit}(\\mathsf{ck},\\mathbf{e}_{b} + \\mathbf{e}_{c}) + C_{\\pmb{m}},</span></p>

    <p class="text-gray-300">Use  <span class="math">\\rho_{\\mathrm{acc}}</span>  to generate the random accumulation for this round  <span class="math">r_{(k)}</span> .</p>

    <p class="text-gray-300"><span class="math">E_{1}</span>  - commitment to the degree-1 cross error term  <span class="math">\\mathbf{e}_1</span></p>

    <p class="text-gray-300">Items to store for the next round of accumulation:</p>

    <p class="text-gray-300">acc.g - item accumulated up to  <span class="math">(k - 1)</span>  th round,</p>

    <p class="text-gray-300"><span class="math">\\pi .(\\mathbf{g},\\Delta)</span>  - proof item from this round,</p>

    <p class="text-gray-300"><span class="math">r_{(k)}</span>  - the random accumulation challenge of this round,</p>

    <p class="text-gray-300"><span class="math">E_{a2}, E_{a3}</span>  - the partial commitments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig.1. Algorithm for computing and committing to the cross error term for  <span class="math">\\mathbf{g}_i^{\\mathrm{ivlk}}</span>  ( <span class="math">x_1 + x_2 \\cdot i + \\mathsf{OM}_i</span> )  <span class="math">\\stackrel{?}{=} \\mathbf{m}_i \\quad \\forall i \\in [m]</span>  in time independent of  <span class="math">T</span>  in the  <span class="math">k</span> th round of accumulation, where  $T :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{OM}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . For simplicity, we refer to  </span>\\mathbf{g}^{\\mathrm{ivlk}}<span class="math">  by just  </span>\\mathbf{g}<span class="math">  in the algorithm.  </span>\\mathsf{OM}'<span class="math">  denotes the sum ( </span>x_1 \\cdot \\mathbf{1}_T + x_2 \\cdot \\mathbf{i} + \\mathsf{OM}_i<span class="math"> ), where  </span>\\mathbf{i} = [1, 2, \\dots, T]$  is the address/index vector for the memory.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The prover still needs to compute the new accumulator  <span class="math">\\mathsf{acc}^{\\prime}.\\mathbf{g}\\gets \\mathsf{acc}.\\mathbf{g} + X\\cdot \\pi .\\mathbf{g}</span>  and  <span class="math">\\mathsf{acc}^{\\prime}.\\mathsf{OM}\\gets \\mathsf{acc}.\\mathsf{OM} + X\\cdot \\pi .\\mathsf{OM}</span> . While computing  <span class="math">\\mathsf{acc}^{\\prime}.\\mathbf{g}</span>  clearly takes  <span class="math">O(\\ell)</span>  time because  <span class="math">\\pi .\\mathbf{g}</span>  is  <span class="math">\\ell</span> -sparse, the complexity for naively computing  <span class="math">\\mathsf{acc}^{\\prime}.\\mathsf{OM}</span>  is</p>

    <p class="text-gray-300">linear in <span class="math">T</span>. Here, we introduce a trick that will enable us to accumulate OM in time independent of <span class="math">T</span>. See Figure 2 for the algorithm.</p>

    <p class="text-gray-300">Let the subscript <span class="math">(j)</span> denote the items in the <span class="math">j</span>th round. We make a key observation that for every round <span class="math">j</span> and every <span class="math">i \\in [T]</span>, <span class="math">\\pi_{(j)}.\\mathsf{OM}_i</span> only differs from <span class="math">\\pi_{(j-1)}.\\mathsf{OM}_i</span> if <span class="math">\\pi_{(j-1)}.\\Delta_i \\neq 0</span>. Then, for <span class="math">k &amp;gt; j &amp;gt; 0</span> such that <span class="math">j</span> is most recent round before round <span class="math">k</span> such that <span class="math">\\pi_{(j-1)}.\\Delta_i \\neq 0</span>, the accumulator of <span class="math">\\mathsf{OM}_i</span> for every <span class="math">i \\in [T]</span> in round <span class="math">k</span> will be</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{acc}_{(k)}.\\mathsf{OM}_i \\\\ = \\mathsf{acc}_{(k-1)}.\\mathsf{OM}_i + r_{(k)} \\cdot \\pi_{(k)}.\\mathsf{OM}_i \\\\ = \\mathsf{acc}_{(k-2)}.\\mathsf{OM}_i + r_{(k-1)} \\cdot \\pi_{(k-1)}.\\mathsf{OM}_i + r_{(k)} \\cdot \\pi_{(k-1)}.\\mathsf{OM}_i + r_{(k)} \\cdot \\pi_{(k-1)}.\\Delta_i \\\\ = \\mathsf{acc}_{(k-2)}.\\mathsf{OM}_i + (r_{(k-1)} + r_{(k)}) \\cdot \\pi_{(k-1)}.\\mathsf{OM}_i + r_{(k)} \\cdot \\pi_{(k-1)}.\\Delta_i \\\\ = \\mathsf{acc}_{(j)}.\\mathsf{OM}_i + (r_{(j+1)} + r_{(j+2)} + \\cdots + r_{(k)}) \\cdot \\pi_{(k-1)}.\\mathsf{OM}_i + r_{(k)} \\cdot \\pi_{(k-1)}.\\Delta_i \\\\ = \\mathsf{acc}_{(j)}.\\mathsf{OM}_i + \\Big( \\sum_{q=j+1}^{k} r_{(q)} \\Big) \\cdot (\\pi_{(k)}.\\mathsf{OM}_i - \\pi_{(k-1)}.\\Delta_i) + r_{(k)} \\cdot \\pi_{(k-1)}.\\Delta_i \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">r_{(j)}^{<em>} \\coloneqq \\sum_{q=1}^{j} r_{(q)}</span> denote the sum of all challenges up to round <span class="math">j</span>. Using the observation above, we can let the prover cache the sum of all the challenges seen so far <span class="math">r^{</em>} = r_{(k)}^{<em>}</span>, the update vector from previous round <span class="math">\\pi_{(k-1)}.\\Delta^{9}</span>, and a separate vector <span class="math">\\mathbf{R} \\in \\mathbb{F}^T</span> (initialized to all zeros at the beginning of accumulation) such that <span class="math">\\mathbf{R}_i = r_{(j)}^{</em>}</span> where <span class="math">j</span> is the most recent round such that <span class="math">\\pi_{(j)}.\\Delta_i \\neq 0</span> respectively for every <span class="math">i \\in [T]</span>. Then, <span class="math">\\mathsf{acc}_{(k)}.\\mathsf{OM}</span> can be expressed as,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{acc}_{(k)}.\\mathsf{OM} \\leftarrow \\mathsf{acc}_{(k-1)}.\\mathsf{OM} + (r^{*} \\cdot \\mathbf{1}_{T} - \\mathbf{R}) \\circ (\\pi_{(k)}.\\mathsf{OM} - \\pi_{(k-1)}.\\Delta) + r_{k} \\cdot \\pi_{(k-1)}.\\Delta</span></div>

    <p class="text-gray-300">In round <span class="math">k</span>, for every <span class="math">i \\in [T]</span>, we evaluate <span class="math">\\mathsf{acc}_{(k)}</span> and set <span class="math">\\mathbf{R}_i \\gets r^<em></span> if and only if <span class="math">\\pi_{(k-1)}.\\Delta_i = 0</span>. This way, in every round, only <span class="math">\\ell</span> positions of the accumulated OM and <span class="math">\\ell</span> positions of <span class="math">\\mathbf{R}</span> need to be computed, achieving <span class="math">O(\\ell)</span> complexity. Whenever we need to use <span class="math">\\mathsf{acc}_{(k)}.\\mathsf{OM}</span> (either in <span class="math">\\mathsf{P}_{\\mathrm{acc}}</span> and in the decider), we substitute it with <span class="math">\\mathsf{acc}_{(k-1)}.\\mathsf{OM} + (r^{</em>} \\cdot \\mathbf{1}_{T} - \\mathbf{R}) \\circ \\pi_{(k)}.\\mathsf{OM}</span>.</p>

    <p class="text-gray-300">Note that, importantly, using this delayed-evaluation trick will not change the computations done by <span class="math">\\mathsf{V}_{\\mathrm{acc}}</span> because the commitment to <span class="math">\\mathsf{acc}_{(k)}.\\mathsf{OM}</span> will still be computed as the random linear combination between the commitment to <span class="math">\\mathsf{acc}_{(k-1)}.\\mathsf{OM}</span> and the commitment to <span class="math">\\pi_{(k)}.\\mathsf{OM}</span>.</p>

    <p class="text-gray-300">9 This is also needed for computing the cross error terms, so we don't need to store it again. See the subsection above and Appendix C</p>

    <p class="text-gray-300">Given: <span class="math">r^{*}</span>  - sum of all random accumulation challenges up to the  <span class="math">(k - 1)</span> th round, <span class="math">r_{(k)}</span>  - the random accumulation challenge of this round, <span class="math">\\mathbf{R}</span>  - helper vector such that  <span class="math">\\mathbf{R}_i = \\sum_{q=1}^j r_{(q)}</span> , where  <span class="math">j</span>  is the most recent round such that  <span class="math">\\pi_{(j)} \\cdot \\Delta_i \\neq 0</span>  for the corresponding  <span class="math">i \\in [T]</span> , <span class="math">\\mathsf{acc}_{(k-1)}.\\mathsf{OM}</span>  - the current accumulated OM, <span class="math">\\pi_{(k)}.(\\mathsf{OM}, \\Delta)</span>  - memory and update vectors in the new proof. Item stored from the previous round: <span class="math">\\hat{\\pi}_{(k-1)}.\\Delta</span>  - update vector from the previous round.</p>

    <p class="text-gray-300">Goal: Compute the updated accumulator item</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {a c c} _ {(k)}. \\mathsf {O M} := \\mathsf {a c c} _ {(k - 1)}. \\mathsf {O M} + r _ {(k)} \\cdot \\pi_ {(k)}. \\mathsf {O M}</span></div>

    <p class="text-gray-300">DO:</p>

    <p class="text-gray-300"><span class="math">r^{<em>}\\gets r^{</em>} + r_{(k)}</span></p>

    <p class="text-gray-300">for  <span class="math">i\\in [T]</span>  s.t.  <span class="math">\\pi_{(k - 1)}.\\varDelta_i\\neq 0</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{acc}_{(k)}.\\mathsf{OM}_i\\gets \\mathsf{acc}_{(k - 1)}.\\mathsf{OM}_i+</span></p>

    <p class="text-gray-300"><span class="math">(r^{*} - \\mathbf{R}_{i})\\cdot (\\pi_{(k)}.\\mathsf{OM}_{i} - \\pi_{(k - 1)}.\\varDelta_{i}) + r_{(k)}\\cdot \\pi_{(k - 1)}.\\varDelta_{i}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}_i\\gets r^*</span></p>

    <p class="text-gray-300">end for</p>

    <p class="text-gray-300"><span class="math">\\backslash \\backslash</span>  Whenever  <span class="math">\\mathsf{acc}_{(k)}.\\mathsf{OM}</span>  is needed for computation,</p>

    <p class="text-gray-300"><span class="math">\\backslash</span>  substitute it with  <span class="math">\\mathsf{acc}_{(k)}.\\mathsf{OM} + (r_{(k)}^{*}\\cdot \\mathbf{1}_{T} - \\mathbf{R})\\circ \\pi_{(k)}.\\mathsf{OM}</span></p>

    <p class="text-gray-300">END DO</p>

    <p class="text-gray-300">Return: <span class="math">\\mathsf{acc}_{(k)}.\\mathsf{OM}</span>  - updated accumulator item, <span class="math">r^{*}</span>  - sum of all random accumulation challenges up to this round, <span class="math">\\mathbf{R}</span>  - updated helper vector. Item to store for the next round of accumulation: <span class="math">\\pi_{(k)}.\\Delta</span>  - update vector of this round.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 2. Algorithm for accumulating OM in the  <span class="math">k</span> th round of accumulation in time independent of  <span class="math">T</span> , where  $T \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{OM}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Since evaluation/update at any accumulated memory index is delayed to when a nonzero change occurs at that index of  </span>\\pi<span class="math"> . OM, only  </span>2\\ell$  updates need to be done per round.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Layer 0 denotes the output layer in the circuit. Let  $\\sqrt{m} \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , then  </span>\\mathbb{H}^2<span class="math">  is a  </span>\\sqrt{m} \\times \\sqrt{m}<span class="math">  2-dimensional square. Assume  </span>\\log m / 2<span class="math">  is a positive integer w.l.o.g. In the protocol,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  for  </span>i = 1, \\ldots, \\log m / 2<span class="math"> , with  </span>\\mathbb{H}_0 = \\{1, 1\\}<span class="math">  and  </span>\\mathbb{H}_{\\log m / 2} = \\mathbb{H}<span class="math"> . The protocol has  </span>\\log m$  rounds in total. We describe the protocol in four phases.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Phase 1 contains round 0 of LogUp-GKR. At the end of phase 1, <span class="math">\\mathsf{V}</span> uses the batching subprotocol and linearly combines the four claimed evaluations sent by <span class="math">\\mathsf{P}</span> using a random value.</p>

    <p class="text-gray-300">In Phase 2 and 3, <span class="math">\\mathsf{V}</span> continues using the batching subprotocol in each round. Phase 2 contains rounds 1 to <span class="math">\\log m / 2 - 1</span> of LogUp-GKR. Round <span class="math">i</span> in Phase 2 does sumcheck in <span class="math">\\mathbb{H}_0 \\times \\mathbb{H}_i</span>. Phase 3 contains rounds <span class="math">\\log m / 2</span> to <span class="math">\\log m - 1</span> of LogUp-GKR. Round <span class="math">i</span> in Phase 3 does sumcheck in <span class="math">\\mathbb{H}_{i - \\log m / 2 + 1} \\times \\mathbb{H}</span>.</p>

    <p class="text-gray-300">Finally, Phase 4 contains the final, direct check done by <span class="math">\\mathsf{V}</span> at the input layer of the circuit.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the start of the protocol, <span class="math">\\mathsf{P}</span> sends over functions <span class="math">D:\\mathbb{H}^2\\to \\mathbb{F}</span> and <span class="math">N:\\mathbb{H}^2\\to \\mathbb{F}</span> claimed to equal <span class="math">d_0</span> and <span class="math">n_0</span> (the output functions that satisfy <span class="math">d_0(1,1) = d^<em></span>, the denominator in the cumulative sum of the fractions, and <span class="math">n_0(1,1) = n^</em></span>, the numerator in the cumulative sum), respectively.</li>

      <li><span class="math">\\mathsf{V}</span> picks random <span class="math">x_0, y_0 \\in \\mathbb{F}^2</span> and random <span class="math">r_0 \\in \\mathbb{F}</span>, and lets <span class="math">T_0 \\gets \\widetilde{N}(x_0, y_0) + r_0 \\cdot \\widetilde{D}(x_0, y_0)</span>.</li>

      <li>In round <span class="math">i = 0</span>:</li>

      <li>Define the univariate polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f_{r_0}(v) := L^{\\mathbb{H}_0}(y_0, v) \\cdot \\left(n_1(1, v) \\cdot d_1(1, \\omega \\cdot v) \\right. \\\\ \\left. + n_1(1, \\omega \\cdot v) \\cdot d_1(1, v) + r_0 \\cdot d_1(1, v) \\cdot d_1(1, \\omega \\cdot v)\\right) \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span> claims that <span class="math">\\sum_{v\\in \\mathbb{H}_0}f_{r_0}(v) = T_0</span>.</li>

      <li><span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> apply the sum-check protocol to <span class="math">f_{r_0}</span>, up until <span class="math">\\mathsf{V}</span>'s final check in that protocol, when <span class="math">\\mathsf{V}</span> must evaluate <span class="math">f_{r_0}</span> at a randomly chosen point <span class="math">y_1 \\in \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathsf{P}</span> sends over <span class="math">[T_j^{(1)}]_{j=1}^4</span>, which are the claimed evaluations of <span class="math">\\widetilde{n}_1</span> and <span class="math">\\widetilde{d}_1</span> on <span class="math">(1, y_1)</span> and <span class="math">(1, \\omega \\cdot y_1)</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T_1^{(1)} := \\widetilde{n}_1(1, y_1) \\quad T_2^{(1)} := \\widetilde{n}_1(1, \\omega \\cdot y_1) \\\\ T_3^{(1)} := \\widetilde{d}_1(1, y_1) \\quad T_4^{(1)} := \\widetilde{d}_1(1, \\omega \\cdot y_1) \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> uses <span class="math">[T_j^{(1)}]_{j=1}^4</span> to perform the final check in the sum-check protocol.</li>

      <li><span class="math">\\mathsf{V}</span> chooses <span class="math">r_1 \\gets \\S \\mathbb{F}</span> at random, sends it to <span class="math">\\mathsf{P}</span>, and sets</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">T_1 \\leftarrow \\sum_{j=1}^4 r_1^{j-1} T_j^{(1)}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1, \\ldots, \\log m / 2</span> : use the batching subprotocol to combine the four checks for the evaluations of  <span class="math">\\widetilde{n}_i, \\widetilde{d}_i</span>  on  <span class="math">(1, y_i)</span>  and  <span class="math">(1, \\omega^{m / 2^i} \\cdot y_i)</span>  into one sumcheck.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the univariate polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {r _ {i}} ^ {(i)} (v) := \\left(L ^ {\\mathbb {H} _ {i}} \\left(y _ {i}, v\\right) + r _ {i} \\cdot L ^ {\\mathbb {H} _ {i}} \\left(\\omega^ {m / 2 ^ {i}} \\cdot y _ {i}, v\\right)\\right) \\\\ \\cdot \\left(n _ {i + 1} (1, v) \\cdot d _ {i + 1} \\left(1, \\omega^ {m / 2 ^ {i}} \\cdot v\\right) \\right. \\\\ + n _ {i + 1} \\left(1, \\omega^ {m / 2 ^ {i}} \\cdot v\\right) \\cdot d _ {i + 1} (1, v) \\Bigg) \\\\ + \\left(r _ {i} ^ {2} \\cdot L ^ {\\mathbb {H} _ {i}} \\left(y _ {i}, v\\right) + r _ {i} ^ {3} \\cdot L ^ {\\mathbb {H} _ {i}} \\left(\\omega^ {m / 2 ^ {i}} \\cdot y _ {i}, v\\right)\\right) \\\\ \\cdot \\left(d _ {i + 1} (1, v) \\cdot d _ {i + 1} \\left(1, \\omega^ {m / 2 ^ {i}} \\cdot v\\right)\\right) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P claims that  <span class="math">\\sum_{v\\in \\mathbb{H}_i}f_{r_i}^{(i)}(v) = T_i</span></li>

      <li>P and V apply the sum-check protocol to  <span class="math">f_{r_i}^{(i)}</span> , up until V's final check in that protocol, when V must evaluate  <span class="math">f_{r_i}^{(i)}</span>  at a randomly chosen point  <span class="math">y_{i+1} \\in \\mathbb{F}</span> .</li>

      <li>P sends over  <span class="math">[T_j^{(i+1)}]_{j=1}^4</span> , which are the claimed evaluations of  <span class="math">\\widetilde{n}_{i+1}</span>  and  <span class="math">\\widetilde{d}_{i+1}</span>  on  <span class="math">(1, y_{i+1})</span>  and  <span class="math">(1, \\omega^{m/2^i} \\cdot y_{i+1})</span></li>

      <li>V uses  <span class="math">[T_j^{(i+1)}]_{j=1}^4</span>  to perform the final check in the sumcheck protocol.</li>

      <li>V chooses  <span class="math">r_{i+1} \\gets \\mathbb{S F}</span>  at random and sets  <span class="math">T_{i+1} \\gets \\sum_{j=1}^{4} r_{i+1}^{j-1} T_j^{(i+1)}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = \\log m / 2 + 1, \\ldots, \\log m - 1</span> : use the batching subprotocol to combine the four checks for the evaluations of  <span class="math">\\widetilde{n}_i, \\widetilde{d}_i</span>  on  <span class="math">(x_i, y_i)</span>  and  <span class="math">(\\omega^{m/2^i} \\cdot x_i, y_i)</span>  into one sumcheck.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">i&#x27; \\coloneqq i - \\log m / 2</span>  Define the bivariate polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {r _ {i}} ^ {(i)} (u, v) := \\\\ \\left(L ^ {\\mathbb {H} _ {i ^ {\\prime}}} \\left(x _ {i}, u\\right) \\cdot L ^ {\\mathbb {H}} \\left(y _ {i}, v\\right) + r _ {i} \\cdot L ^ {\\mathbb {H} _ {i ^ {\\prime}}} \\left(\\omega^ {m / 2 ^ {i}} \\cdot x _ {i}, u\\right) \\cdot L ^ {\\mathbb {H}} \\left(y _ {i}, v\\right)\\right) \\\\ \\cdot \\left(n _ {i + 1} (u, v) \\cdot d _ {i + 1} \\left(\\omega^ {m / 2 ^ {i}} \\cdot u, v\\right) + n _ {i + 1} \\left(\\omega^ {m / 2 ^ {i}} \\cdot u, v\\right) \\cdot d _ {i + 1} (u, v)\\right) \\\\ + \\left(r _ {i} ^ {2} \\cdot L ^ {\\mathbb {H} _ {i ^ {\\prime}}} \\left(x _ {i}, u\\right) \\cdot L ^ {\\mathbb {H}} \\left(y _ {i}, v\\right) + r _ {i} ^ {3} \\cdot L ^ {\\mathbb {H} _ {i ^ {\\prime}}} \\left(\\omega^ {m / 2 ^ {i}} \\cdot x _ {i}, u\\right) \\cdot L ^ {\\mathbb {H}} \\left(y _ {i}, v\\right)\\right) \\\\ \\cdot \\left(d _ {i + 1} (u, v) \\cdot d _ {i + 1} \\left(\\omega^ {m / 2 ^ {i}} \\cdot u, v\\right)\\right) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P claims that  <span class="math">\\sum_{u,v\\in \\mathbb{H}_{i&#x27;},\\mathbb{H}}f_{r_i}^{(i)}(u,v) = T_i</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  apply the sum-check protocol to  <span class="math">f_{r_i}^{(i)}</span> , up until  <span class="math">\\mathsf{V}</span> 's final check in that protocol, when  <span class="math">\\mathsf{V}</span>  must evaluate  <span class="math">f_{r_i}^{(i)}</span>  at a randomly chosen point  <span class="math">(x_{i+1}, y_{i+1}) \\in \\mathbb{F}^2</span> .</li>

      <li><span class="math">\\mathsf{P}</span>  sends over  <span class="math">[T_j^{(i + 1)}]_{j = 1}^4</span> , which are the claimed evaluations of  <span class="math">\\widetilde{n}_{i + 1}</span>  and  <span class="math">\\widetilde{d}_{i + 1}</span>  on  <span class="math">(x_{i + 1},y_{i + 1})</span>  and  <span class="math">(\\omega^{m / 2^i}\\cdot x_{i + 1},y_{i + 1})</span> .</li>

      <li>V uses  <span class="math">[T_j^{(i + 1)}]_{j = 1}^4</span>  to perform the final check in the sumcheck protocol.</li>

      <li>V chooses  <span class="math">r_{i+1} \\gets \\S \\mathbb{F}</span>  at random and sets  <span class="math">T_{i+1} \\gets \\sum_{j=1}^{4} r_{i+1}^{j-1} T_j^{(i+1)}</span> .</li>

    </ul>

    <p class="text-gray-300">a It is implicitly defined that  <span class="math">x_{\\log m / 2} = 1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">d \\coloneqq \\log m</span> . V checks directly whether</li>

    </ul>

    <p class="text-gray-300"><span class="math">T_{d} \\stackrel{?}{=} \\widetilde{n}_{d}(x_{d}, y_{d}) + r_{d} \\cdot \\widetilde{n}_{d}(\\omega \\cdot x_{d}, y_{d}) + r_{d}^{2} \\cdot \\widetilde{d}_{d}(x_{d}, y_{d}) + r_{d}^{3} \\cdot \\widetilde{d}_{d}(\\omega \\cdot x_{d}, y_{d})</span></p>

    <p class="text-gray-300">Suppose we are given a scalar  <span class="math">s</span>  in bit representation  <span class="math">s_{\\lambda - 1} \\ldots s_1 s_0</span> , and a base elliptic curve point in projective coordinates  <span class="math">G = (X, Y, Z)</span>  which is represented using three scalars such that  <span class="math">Y^2 Z = X^3 + bZ^3</span> . We give a concrete example below for scalar multiplication  <span class="math">s \\cdot G</span>  using GKR in the special case short Weierstrass curves with  <span class="math">a = 0</span> . Before running the GKR protocol, prover sends  <span class="math">s = s_{\\lambda - 1} \\ldots s_0</span>  and  <span class="math">G</span> . Note that when the protocol is compiled using the ProtoStar compiler,  <span class="math">s</span>  and  <span class="math">G</span>  will be sent in commitments. Even so, this will not be a problem for accessing  <span class="math">s</span>  and  <span class="math">G</span>  while running GKR, because only the decider will be running GKR with the prover and the decider has access to the original values of all the prover messages/commitments.</p>

    <p class="text-gray-300">Initialize  <span class="math">A_{\\lambda} = (X_{\\lambda},Y_{\\lambda},Z_{\\lambda})</span>  to the identity point  <span class="math">(0,1,0)</span> . At the  <span class="math">i</span> th layer, suppose we have intermediary elliptic curve projective coordinates  <span class="math">A_{i} = (X_{i},Y_{i},Z_{i})</span> . Let  <span class="math">A_{i}^{\\prime} = (X_{i}^{\\prime},Y_{i}^{\\prime},Z_{i}^{\\prime})</span>  be the point of doubled coordinates of  <span class="math">A_{i}</span> . Specifically, the doubling formulas are</p>

    <p class="text-gray-300"><span class="math">X_{i}^{\\prime} = 2X_{i}Y_{i}(Y_{i}^{2} - 9bZ_{i}^{2}),</span> <span class="math">Y_{i}^{\\prime} = (Y_{i}^{2} - 9bZ_{i}^{2})(Y_{i}^{2} + 3bZ_{i}^{2}) + 24bY_{i}^{2}Z_{i}^{2},</span> <span class="math">Z_{i}^{\\prime} = 8Y_{i}^{3}Z_{i}</span></p>

    <p class="text-gray-300">Then, using the double-and-add heuristic, we compute <span class="math">A_{i-1} = (X_{i-1}, Y_{i-1}, Z_{i-1})</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} X_{i-1} = (1 - s_i) \\cdot X_i&#x27; \\\\ \\quad + s_i \\cdot \\left( (X_i&#x27;Y + XY_i&#x27;)(Y_i&#x27;Y - 3bZ_i&#x27;Z) - 3b(Y_i&#x27;Z + YZ_i&#x27;)(X_i&#x27;Z + XZ_i&#x27;) \\right) \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} Y_{i-1} = (1 - s_i) \\cdot Y_i&#x27; \\\\ \\quad + s_i \\cdot \\left( (Y_i&#x27;Y + 3bZ_i&#x27;Z)(Y_i&#x27;Y - 3bZ_i&#x27;Z) + 9bX_i&#x27;X(X_i&#x27;Z + XZ_i&#x27;) \\right) \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} Z_{i-1} = (1 - s_i) \\cdot Z_i&#x27; \\\\ \\quad + s_i \\cdot \\left( (Y_i&#x27;Z + YZ_i&#x27;)(Y_i&#x27;Y + 3bZ_i&#x27;Z) + 3X_i&#x27;X(X_i&#x27;Y + XY_i&#x27;) \\right) \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">A_0 = (X_0, Y_0, Z_0)</span> being the final output of the scalar multiplication <span class="math">s \\cdot G</span>.</p>

    <p class="text-gray-300">The degree is 11 as <span class="math">(X_i&#x27;, Y_i&#x27;, Z_i&#x27;)</span> can be computed using a degree 4 formula and <span class="math">X_{i-1}</span> has a <span class="math">s_i \\cdot X_i&#x27;Y \\cdot Y_i&#x27;Y</span> term. We can turn these algebraic expressions into a layered GKR protocol by having each layer consist of the tuple <span class="math">(X_i, Y_i, Z_i)</span>. This results in 3 checks per layer. We can combine them using the batch sumcheck protocol (Section 6.3). If we are doing multiple EC multiplications in parallel then these can be combined using Lagrange polynomials.</p>`;
---

<BaseLayout title="Proofs for Deep Thought: Accumulation for large memories and... (2024/325)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/325
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
