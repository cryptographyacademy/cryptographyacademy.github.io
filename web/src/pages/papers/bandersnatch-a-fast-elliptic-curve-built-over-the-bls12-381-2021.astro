---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1152';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Bandersnatch: a fast elliptic curve built over the BLS12-381 scalar field';
const AUTHORS_HTML = 'Simon Masson, Antonio Sanso, Zhenfei Zhang';

const CONTENT = `    <p class="text-gray-300">Simon Masson<span class="math">^{1}</span> <span class="math">\\bullet</span> <span class="math">\\varnothing</span>, Antonio Sanso<span class="math">^{2}</span> <span class="math">\\bullet</span> <span class="math">\\varnothing</span> and Zhenfei Zhang<span class="math">^{2}</span> <span class="math">\\bullet</span> <span class="math">\\varnothing</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Anoma</p>

    <p class="text-gray-300"><span class="math">^{2}</span> Ethereum Foundation</p>

    <p class="text-gray-300">Abstract. In this paper, we introduce Bandersnatch, a new elliptic curve built over the BLS12-381 scalar field. The curve is equipped with an efficient endomorphism, allowing a fast scalar multiplication algorithm. Our benchmark shows that the multiplication is 42% faster, 21% reduction in terms of circuit size in the form of rank 1 constraint systems (R1CS), and 10% reduction in terms of Plonk circuit, compared to another curve, called Jubjub, having similar properties. Many zero-knowledge proof systems that rely on the Jubjub curve can benefit from our result.</p>

    <p class="text-gray-300">Keywords: Elliptic curve cryptography MSC Code: 94A60</p>

    <p class="text-gray-300">BLS12-381 is a pairing-friendly curve discovered by Sean Bowe [Bow17] in 2017. Currently, BLS12-381 is undergoing a standardization process from the IRTF Crypto Forum Research Group, and is universally used for digital signatures and zero-knowledge proofs by many projects orbiting in the blockchain universe: Zcash, Ethereum, Filecoin, Anoma, Skale, Algorand, Dfinity, Chia, and more. The ZCash team introduced Jubjub [Zt18], an elliptic curve built over the BLS12-381 scalar field <span class="math">\\mathbb{F}_{r_{\\mathrm{BLS}}}</span>. This curve is not pairing-friendly, but leads to constructions where <span class="math">\\mathbb{F}_{r_{\\mathrm{BLS}}}</span> arithmetic circuits can be manipulated using the BLS12-381 curve. The Jubjub curve can be represented in the twisted Edwards coordinates, allowing efficiency inside zk-SNARK circuits. In order for some cryptographic applications to scale, it is necessary to have efficient scalar multiplication on the non-pairing-friendly curve. The main drawback of Jubjub is the slow scalar multiplication algorithm compared, for example, with the "Bitcoin curve" (SECP256k1). It comes from the fact that the curve does not have an efficiently computable endomorphism, necessary for computing scalar multiplications using the GLV method [GLV01] (a technique protected by a US patent until Sep 2020 [Rob20], but that expired and is freely usable now).</p>

    <p class="text-gray-300">Our contribution. The Jubjub curve is a curve with a large discriminant, meaning that the GLV method is not possible on this curve. We performed an exhaustive search of curves of small discriminant, defined over the BLS12-381 scalar field. This way, we obtain an elliptic curve using the Complex Multiplication method [AM93], where the scalar multiplication algorithm is efficient thanks to the GLV method [GLV01].</p>

    <p class="text-gray-300">We implement this curve in Rust, using the Arkworks framework [Ark], and release our code to the open domain [Ban]. Table 1 shows a comparison of the Bandersnatch and Jubjub curves. Details deferred to Section 4.</p>

    <p class="text-gray-300">E-mail: simon.masson@protonmail.com (Simon Masson), antonio.sanso@ethereum.org (Antonio Sanso), zhenfei.zhang@ethereum.org (Zhenfei Zhang)</p>

    <p class="text-gray-300">Bandersnatch</p>

    <p class="text-gray-300">Table 1: Bandersnatch vs Jubjub</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">multiplication cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R1CS constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TurboPlonk constraints</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Jubjub</td>

            <td class="px-3 py-2 border-b border-gray-700">75 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">3177</td>

            <td class="px-3 py-2 border-b border-gray-700">1865</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bandersnatch</td>

            <td class="px-3 py-2 border-b border-gray-700">44 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">2621</td>

            <td class="px-3 py-2 border-b border-gray-700">1669</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Improvement</td>

            <td class="px-3 py-2 border-b border-gray-700">42%</td>

            <td class="px-3 py-2 border-b border-gray-700">21%</td>

            <td class="px-3 py-2 border-b border-gray-700">10%</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To demonstrate how a zero-knowledge proof system can benefit from our curve, we also report the number of constraints one needs to express a group multiplication in the forms of two commonly used circuit descriptions for zero-knowledge proof systems, namely, rank one constraint system (R1CS), and the Plonk circuit. A group multiplication takes 2621 and 1669 constraints, respectively, when the point is in affine form over the twisted Edwards curve, yielding a  <span class="math">21\\%</span>  and  <span class="math">10\\%</span>  improvement over the Jubjub curve.</p>

    <p class="text-gray-300">Organization of the paper. In Section 2, we describe how we obtained several curves allowing the GLV method together with cryptographic security. Then, we introduce in Section 3 the Bandersnatch curve in different models (in Weierstrass, Montgomery and twisted Edwards coordinates). Finally, we compare the scalar multiplication algorithm over the Bandersnatch and the Jubjub curves in Section 4 from a practical point of view.</p>

    <p class="text-gray-300">The GLV method [GLV01] is a well known trick for accelerating scalar multiplication over particular curve. In a nutshell, it applies to elliptic curves where an endomorphism  <span class="math">\\psi</span>  can be efficiently computed. The GLV method applies in particular for  <span class="math">j</span> -invariant  <span class="math">j = 0</span>  (resp.  <span class="math">j = 1728</span> ) curves because a non-trivial automorphism can be computed using only one modular multiplication. The method also applies for other curves where the endomorphism is slightly more expensive, called small discriminant curves.</p>

    <p class="text-gray-300">Let  <span class="math">E</span>  be an elliptic curve defined over  <span class="math">\\mathbb{F}_p</span>  of trace  <span class="math">t</span> .  <span class="math">E</span>  and its quadratic twist  <span class="math">E^t</span>  are  <span class="math">\\mathbb{F}_{p^2}</span> -isomorphic curves and their orders over  <span class="math">\\mathbb{F}_p</span>  are closely related with the trace  <span class="math">t</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\# E (\\mathbb {F} _ {p}) = p + 1 - t \\quad \\# E ^ {t} (\\mathbb {F} _ {p}) = p + 1 + t.</span></div>

    <p class="text-gray-300">See [Sil86] for a complete introduction to elliptic curves. In this work, we are looking for cryptographic applications based on ordinary elliptic curves, meaning that we look for  <span class="math">t \\neq 0 \\mod p</span> . The endomorphism ring of these curves have a particular structure:  <span class="math">\\operatorname{End}(E)</span>  is an order of the imaginary quadratic field  <span class="math">\\mathbb{Q}(\\sqrt{t^2 - 4p})</span> . From now, we denote  <span class="math">-D</span>  to be the discriminant of  <span class="math">\\operatorname{End}(E)</span> , and  <span class="math">\\{\\operatorname{Id}, \\psi\\}</span>  a basis of the endomorphism ring. The fundamental discriminant corresponds to the discriminant of the maximal order containing  <span class="math">\\operatorname{End}(E)</span> . This way,  <span class="math">\\psi</span>  is of degree  <span class="math">\\frac{D + 1}{4}</span>  or  <span class="math">D / 4</span>  depending on the value of  <span class="math">D</span>  modulo 4, and  <span class="math">\\psi</span>  can be defined using polynomials of degree  <span class="math">O(D)</span>  thanks to the Vělu's formulas [Vél71]. Thus, the evaluation of  <span class="math">\\psi</span>  is efficient only for curves of small discriminant.</p>

    <p class="text-gray-300">In this work, we restrict to curves defined over the BLS12-381 scalar field  <span class="math">\\mathbb{F}_{r_{\\mathrm{BLS}}}</span> . From now, we denote  <span class="math">p = r_{\\mathrm{BLS}}</span>  and we look for curves with a 128-bit cryptographic security. Curves with  <span class="math">-D = -3</span>  and  <span class="math">-4</span>  do not have a large prime subgroup defined over  <span class="math">\\mathbb{F}_p</span> . Hence, we look for small discriminant  <span class="math">-D &amp;lt; -4</span>  curves with subgroup and twist-subgroup security. It means that  <span class="math">\\# E(\\mathbb{F}_p)</span>  has a roughly 256-bit prime factor, as well as  <span class="math">\\# E^t (\\mathbb{F}_p)</span> .</p>

    <p class="text-gray-300">As the endomorphism cost is closely related to the discriminant, we restrict to  <span class="math">-D \\geq -388</span>  so that  <span class="math">\\psi</span>  can be efficiently computed. Moreover, we restrict on fundamental discriminants (discriminants of the maximal orders of imaginary quadratic fields). We denote  <span class="math">\\mathcal{O}_{-D}</span>  the maximal order of discriminant  <span class="math">-D</span> . Elliptic curves with  <span class="math">\\operatorname{End}(E) \\subset \\mathcal{O}_{-D}</span>  are isogenous curves, meaning that there is a rational map between them. Isogenous curves have the same order so that we can restrict on fundamental discriminants for our search.</p>

    <p class="text-gray-300">We compute an exhaustive search following the CM method <em>[x13, x19]</em>. Given a discriminant <span class="math">-D</span>, we deterministically obtain the corresponding curves using number theory tools. More precisely, we consider the Hilbert class polynomial <span class="math">H_{-D}(X)</span>. The roots of <span class="math">H_{-D}</span> are the <span class="math">j</span>-invariants of curves defined over a number field whose endomorphism ring is an order of discriminant <span class="math">D</span>. In practice, for a given discriminant <span class="math">D</span>, roughly half of the curves are supersingular and hence not relevant to our cryptographic applications. As we look for an efficient endomorphism, we consider small discriminant curves. We provide in Algorithm 1 the algorithm we used in order to obtain curves for our interest.</p>

    <p class="text-gray-300">Algorithm 1 Search of curves 1:for each <span class="math">D\\in\\{D_{\\min},\\ldots,D_{\\max}\\}</span> do 2: <span class="math">D_{0}\\leftarrow</span> fundamental discriminant of <span class="math">-D</span> 3: <span class="math">H_{-D_{0}}(X)\\leftarrow</span> Hilbert class polynomial of degree <span class="math">D_{0}</span> 4: Factor <span class="math">H_{-D_{0}}</span> and compute the roots <span class="math">R</span> 5: for each <span class="math">j_{0}\\in R</span> do 6: for each <span class="math">E</span> elliptic curve of <span class="math">j</span>-invariant <span class="math">j_{0}</span> (up to isomorphism) do 7: if <span class="math">E</span> is not supersingular then 8: <span class="math">N\\leftarrow</span> Order(<span class="math">E</span>) 9: Store the factorization of <span class="math">N</span> 10: end if 11: end for 12: end for 13:end for</p>

    <p class="text-gray-300">Starting with <span class="math">-D=-3</span>, we consider elliptic <span class="math">H_{-D}</span> and factor it in order to get the curves of discriminant <span class="math">-D</span> (up to isomorphism). From the elliptic curve, we obtain the trace and then the order of the curve defined over <span class="math">\\mathbb{F}_{p}</span>, and finally factor it in order to obtain a cryptographically interesting curve. We considered curves up to <span class="math">D_{\\max}=388</span>, corresponding to a fundamental discriminant of <span class="math">-292</span>. We list in Table 2 the ordinary curves we obtained. In this table, <span class="math">p_{n}</span> denotes a prime of n bits. The generation of these curves is reproducible using the file at https://github.com/asanso/Bandersnatch/blob/main/python-ref-impl/small-disc-curves.py. We finally obtain an interesting curve for <span class="math">-D=-8</span> with large prime order subgroups on both the curve and its twist. We present in Section 3 the curve in several models, together with the endomorphism in order to apply the GLV scalar multiplication algorithm.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Bandersnatch</h2>

    <p class="text-gray-300">The Bandersnatch is obtained from a discriminant <span class="math">-D=-8</span>, meaning that the endomorphism ring is <span class="math">\\mathbb{Z}[\\sqrt{-2}]</span>. We obtain the curve <span class="math">j</span>-invariant using the Complex Multiplication method, based on the Hilbert class polynomial <span class="math">H_{-D}(X)</span>. The roots of <span class="math">H_{-D}</span> are <span class="math">j</span>-invariants of elliptic curves whose endomorphism ring is of discriminant <span class="math">-D</span>. From a <span class="math">j</span>-invariant, we obtain the curve equation in different models. Before looking into the details of three different representations, we briefly recall how to exhibit the degree 2 endomorphism <span class="math">\\psi</span>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Degree 2 endomorphism.</h4>

    <p class="text-gray-300">The endomorphism <span class="math">\\psi</span> has a kernel generated by a 2-torsion point. Hence, we can obtain the rational maps defining <span class="math">\\psi</span> by looking at the curves 2-isogenous to Bandersnatch. Only one has the same <span class="math">j</span>-invariant, meaning that up to an isomorphism, Vélu’s formulas <em>[x25]</em> let us compute <span class="math">\\psi</span>. For cryptographic use-cases, we are interested in computing <span class="math">\\psi</span> on the <span class="math">p_{253}</span>-order subgroup of the curve. On these points, <span class="math">\\psi</span></p>

    <p class="text-gray-300">Bandersnatch</p>

    <p class="text-gray-300">Table 2: Curves for discriminants  <span class="math">- 3 \\geq   - D \\geq   - {292}</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve sec.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve order</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-3</td>

            <td class="px-3 py-2 border-b border-gray-700">65-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·3·97·19829809·2514214987·423384683867248993·p131</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">14-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">264·9063494·p28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">77-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">7·43·1993·2137·43558993·69032539613749·p154</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">41-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">3·7·13·79·2557·33811·1645861201·75881076241177·86906511869757553·p82</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">13-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">32·112·192·101772·1255272·8592672·25084092·25294032·p26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">118-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">836509·p236</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-4</td>

            <td class="px-3 py-2 border-b border-gray-700">59-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">232·5·73·9063492·2547602932·p119</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">37-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·29·233·34469·1327789373·19609848837063073·159032890827948314857·p74</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">37-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·32·112·13·1481·101772·8592672·524378992·346160718017·p74</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">57-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·5·192·1709·1255272·25084092·25294032·p114</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-8</td>

            <td class="px-3 py-2 border-b border-gray-700">122-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">27·33·p244</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">126-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·p253</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-11</td>

            <td class="px-3 py-2 border-b border-gray-700">69-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">5·191·5581·18793·48163·46253594704380463613·p138</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">73-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">33·112·9269797·17580060420191283788101·p147</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-19</td>

            <td class="px-3 py-2 border-b border-gray-700">110-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">7·112·19·23·397·419·p220</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">74-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">32·5·503·10779490483·433275286013779991·p149</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-24</td>

            <td class="px-3 py-2 border-b border-gray-700">53-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·32·7·192·127·29402034080953·2970884754778276642175743·p106</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">86-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">25·5·39628279·1626653036429383·p172</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-51</td>

            <td class="px-3 py-2 border-b border-gray-700">112-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">32·5·61223923·p224</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">120-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">232·41·p241</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-67</td>

            <td class="px-3 py-2 border-b border-gray-700">67-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">3479887483·56938338857·8474085246072233·p135</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">79-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">32·8478452882270519617659314063·p159</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-88</td>

            <td class="px-3 py-2 border-b border-gray-700">61-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·11·16984307·24567897636186592260640293583411·p122</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">66-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">29·32·31·6133·116471·69487476515565975361139·p133</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-132</td>

            <td class="px-3 py-2 border-b border-gray-700">73-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·1753·101235113104036296384208928969·p147</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">92-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·32·72·11·23·587·701·32299799971·p184</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-136</td>

            <td class="px-3 py-2 border-b border-gray-700">62-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">23·73·193·10939·11131315086725327441688173207·p125</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">87-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·5·5741·30851·533874022134253·p175</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-228</td>

            <td class="px-3 py-2 border-b border-gray-700">114-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·32·19·89·5189·p228</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">81-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·947·277603·28469787063396608749·p162</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-244</td>

            <td class="px-3 py-2 border-b border-gray-700">89-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·13·523·1702319·2827715661581·p179</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">88-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">28·32·5·71·907·2749·146221·2246269·p176</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-264</td>

            <td class="px-3 py-2 border-b border-gray-700">83-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">23·11·131·12543757399·2818746796297·p167</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">82-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">22·3·52·2287·2134790941497418864559·p165</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-276</td>

            <td class="px-3 py-2 border-b border-gray-700">70-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·112·8839·78797899·323360863688748558301·p140</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">88-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·3·5·6197·138617·16664750312513·p177</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">-292</td>

            <td class="px-3 py-2 border-b border-gray-700">92-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·54983·5220799·2671917733·p185</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">86-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">2·112·149·354689·24012883·32483123·p172</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">acts as a scalar multiplication by the eigenvalue</p>

    <p class="text-gray-300"><span class="math">\\lambda = 0x13b4f3dc4a39a493edf849562b38c72bcfc49db970a5056ed13d21408783df05</span></p>

    <p class="text-gray-300">By construction,  <span class="math">\\psi</span>  is the endomorphism  <span class="math">\\sqrt{-2} \\in \\mathcal{O}_{-8}</span> . Thus,  <span class="math">\\lambda</span>  satisfies  <span class="math">\\lambda^2 + 2 = 0 \\mod p_{253}</span> . In the following sections, we provide details on the curve equation, the  <span class="math">\\psi</span>  rational maps, and a generator of the  <span class="math">p_{253}</span> -order subgroup in the case of the affine Weierstrass,</p>

    <p class="text-gray-300">projective Montgomery and projective twisted Edwards representations. The parameters are reproducible using the script available at https://github.com/asanso/Bandersnatch/blob/main/python-ref-impl/get_params.py.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 Weierstrass curve</h3>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Curve equation.</h4>

    <p class="text-gray-300">The Bandersnatch curve can be represented in the Weierstrass model using the equation</p>

    <p class="text-gray-300"><span class="math">E_{W}:y^{2}=x^{3}-3763200000x-78675968000000.</span></p>

    <p class="text-gray-300">Elliptic curves, such as Jubjub and Bandersnatch, have traditionally been represented in the Montgomery or Edwards form. However, recent advancements in research, notably the closed-form formulas presented in <em>[x20]</em>, have enabled the efficient and secure utilization of prime order curves.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Endomorphism.</h4>

    <p class="text-gray-300">The endomorphism <span class="math">\\psi</span> can obtained using the method detailed above. We obtain the following expression:</p>

    <p class="text-gray-300"><span class="math">\\psi_{\\mathrm{W}}(x,y)=</span> <span class="math">\\left(u^{2}\\cdot\\frac{x^{2}+44800x+2257920000}{x+44800},u^{3}\\cdot y\\cdot\\frac{x^{2}+2\\cdot 44800x+t_{0}}{(x+44800)^{2}}\\right),</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">u</span> <span class="math">=0\\mathrm{x}50281\\mathrm{a}c0\\mathrm{f}92\\mathrm{f}c1\\mathrm{b}20\\mathrm{f}d897\\mathrm{a}16\\mathrm{bf}2\\mathrm{b}9\\mathrm{e}132\\mathrm{b}dc\\mathrm{b}06721\\mathrm{c}589296\\mathrm{c}f82245\\mathrm{c}f9382\\mathrm{d}</span> <span class="math">t_{0}</span> <span class="math">=0\\mathrm{x}73\\mathrm{e}\\mathrm{d}\\mathrm{a}753299\\mathrm{d}7\\mathrm{d}483339\\mathrm{d}80809\\mathrm{a}1\\mathrm{d}80553\\mathrm{b}\\mathrm{d}\\mathrm{a}402\\mathrm{f}\\mathrm{f}\\mathrm{f}\\mathrm{e}5\\mathrm{b}\\mathrm{f}\\mathrm{e}\\mathrm{f}\\mathrm{f}\\mathrm{f}\\mathrm{f}\\mathrm{f}\\mathrm{f}\\mathrm{f}\\mathrm{e}\\mathrm{f}10\\mathrm{b}\\mathrm{e}001</span></p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Subgroup generator.</h4>

    <p class="text-gray-300">The generator of the <span class="math">p_{253}</span>-order subgroup is computed by finding the lexicographically smallest valid <span class="math">x</span>-coordinate of a point of the curve, and scaling it by the cofactor <span class="math">4</span> such that the result is not the point at infinity. From a point with <span class="math">x=2</span>, we obtain a generator <span class="math">E_{W}(x_{W},y_{W})</span> where:</p>

    <p class="text-gray-300"><span class="math">x_{W}</span> <span class="math">=0\\mathrm{x}\\mathrm{a}76451786\\mathrm{f}95\\mathrm{a}802\\mathrm{c}0982\\mathrm{b}\\mathrm{b}\\mathrm{d}0\\mathrm{a}\\mathrm{b}\\mathrm{d}68\\mathrm{e}41\\mathrm{b}92\\mathrm{a}\\mathrm{d}\\mathrm{c}86\\mathrm{c}8859\\mathrm{b}4\\mathrm{f}44679\\mathrm{b}21658710,</span> <span class="math">y_{W}</span> <span class="math">=0\\mathrm{x}44\\mathrm{d}150\\mathrm{c}8\\mathrm{b}4\\mathrm{b}\\mathrm{d}14\\mathrm{f}79720\\mathrm{d}021\\mathrm{a}839\\mathrm{e}7\\mathrm{b}7\\mathrm{e}\\mathrm{b}4\\mathrm{e}\\mathrm{e}43844\\mathrm{b}30243126\\mathrm{a}72\\mathrm{a}\\mathrm{c}2375490\\mathrm{a}.</span></p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.2 Twisted Edwards curve</h3>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Curve equation.</h4>

    <p class="text-gray-300">Bandersnatch can also be represented in twisted Edwards coordinates, where the group law is complete. In this model, the Bandersnatch curve can be defined by the equation</p>

    <p class="text-gray-300"><span class="math">E_{\\mathrm{TE}}:-5x^{2}+y^{2}=1+dx^{2}y^{2},</span> <span class="math">d=\\frac{138827208126141220649022263972958607803}{171449701953573178309673572579671231137}.</span></p>

    <p class="text-gray-300">Twisted Edwards group law is more efficient with a coefficient <span class="math">a=-1</span> (see <em>[x13]</em> for details). In our case, <span class="math">-5</span> is not a square in <span class="math">\\mathbb{F}_{p}</span>. Thus, the curve with equation <span class="math">-x^{2}+y^{2}=1-dx^{2}y^{2}/5</span> is the quadratic twist of Bandersnatch. We provide a representation with <span class="math">a=-5</span>, leading to a slightly more expensive group law because multiplying by <span class="math">-5</span> is more expensive than a multiplication by <span class="math">-1</span>, but this cost will be neglected compared to the improvement of the GLV method. See Section 4 for details.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Endomorphism.</h5>

    <p class="text-gray-300">From this representation, we exhibit the degree 2 endomorphism in twisted Edwards coordinates:</p>

    <p class="text-gray-300"><span class="math">\\psi_{\\mathrm{TE}}(x,y,z)=(f(y)h(y),g(y)xy,h(y)xy)</span></p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span class="math">f(y)</span> <span class="math">=c(z^{2}-y^{2}),</span> <span class="math">g(y)</span> <span class="math">=b(y^{2}+bz^{2}),</span> <span class="math">h(y)</span> <span class="math">=y^{2}-bz^{2},</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">b</span> <span class="math">=0\\mathrm{x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b4},</span> <span class="math">c</span> <span class="math">=0\\mathrm{x6cc624cf865457c3a97c6efd6c17d1078456abcfff36f4e9515c806cdf650b3d}.</span></p>

    <p class="text-gray-300">This map can be computed in 3 additions and 9 multiplications by first computing <span class="math">xy</span>, <span class="math">y^{2}</span>, <span class="math">z^{2}</span> and <span class="math">bz^{2}</span>.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Subgroup generator.</h5>

    <p class="text-gray-300">The generator of the <span class="math">p_{253}</span>-order subgroup obtained in Section 3.1 has twisted coordinates of the form <span class="math">E_{\\mathrm{TE}}(x_{\\mathrm{TE}},y_{\\mathrm{TE}},1)</span> with</p>

    <p class="text-gray-300"><span class="math">x_{TE}</span> <span class="math">=0\\mathrm{x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18},</span> <span class="math">y_{TE}</span> <span class="math">=0\\mathrm{x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166}.</span></p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.3 Montgomery curve</h3>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Curve equation.</h5>

    <p class="text-gray-300">A twisted Edwards curve is always birationally equivalent to a Montgomery curve. We obtain the mapping between these two representations following <em>[x10]</em>. While the twisted Edwards model fits better for <span class="math">\\mathbb{F}_{p}</span> circuit arithmetic and more generally for the zero-knowledge proof context, we provide here the Montgomery version because the scalar multiplication is more efficient in this model:</p>

    <p class="text-gray-300"><span class="math">E_{M}:By^{2}=x^{3}+Ax^{2}+x</span> <span class="math">B</span> <span class="math">=0\\mathrm{x300c3385d13bedb7c9e229e185c4ce8b1dd3b71366bb97c30855c0aa41d62727},</span> <span class="math">A</span> <span class="math">=0\\mathrm{x4247698f4e32ad45a293959b4ca17afa4a2d2317e4c6ce5023e1fd63d1b5de98}.</span></p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Endomorphism.</h5>

    <p class="text-gray-300">Montgomery curves allow efficient scalar multiplication using the Montgomery ladder. We provide here the endomorphism <span class="math">\\psi</span> in this model:</p>

    <p class="text-gray-300"><span class="math">\\psi_{\\mathrm{M}}(x,-,z)=(-(x-z)^{2}-cxz,-,2xz)</span></p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span class="math">c</span> <span class="math">=0\\mathrm{x4247698f4e32ad45a293959b4ca17afa4a2d2317e4c6ce5023e1fd63d1b5de9a}.</span></p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Subgroup generator.</h5>

    <p class="text-gray-300">The generator of the <span class="math">p_{253}</span>-order subgroup given above is of the form <span class="math">E_{M}(x_{M},-,1)</span> with:</p>

    <p class="text-gray-300"><span class="math">x_{M}</span> <span class="math">=0\\mathrm{x67c5b5fed18254e8acb66c1e38f33ee0975ae6876f9c5266a883f4604024b3b8}.</span></p>

    <p class="text-gray-300">Simon Masson, Antonio Sanso, Zhenfei Zhang</p>

    <p class="text-gray-300">The Bandersnatch curve order is  <span class="math">2^{2} \\cdot r</span>  for a 253-bit long prime  <span class="math">r</span> . Its quadratic twist has order  <span class="math">2^{7} \\cdot 3^{3} \\cdot r&#x27;</span> , where  <span class="math">r&#x27;</span>  is another prime of 244 bits. Hence, the Bandersnatch curve satisfies twist security after a quick cofactor check. We estimate that the Bandersnatch curve (resp. its quadratic twist) has 126 bits of security (resp. 122 bits of security).</p>

    <p class="text-gray-300">The twisted Edwards representation is the most used in practice, and we now focus on the comparison between Jubjub and Bandersnatch in this model.</p>

    <p class="text-gray-300">Because of its large discriminant, the scalar multiplication on Jubjub is a basic double-and-add algorithm, meaning that it computes a multiplication by  <span class="math">n</span>  in  <span class="math">\\log n</span>  doublings and  <span class="math">\\log n / 2</span>  additions (in average) on the curve.</p>

    <p class="text-gray-300">The endomorphism  <span class="math">\\psi</span>  lets us compute the scalar multiplication faster than a double-and-add algorithm with few precomputations. For a point  <span class="math">P</span>  and a scalar  <span class="math">n</span> , we first evaluate  <span class="math">\\psi</span>  at  <span class="math">P</span>  and decompose  <span class="math">n = n_1 + \\lambda n_2</span> . Then a multi scalar multiplication is computed in  <span class="math">\\log n / 2</span>  doublings and  <span class="math">3\\log n / 8</span>  additions (in average) on the curve.</p>

    <p class="text-gray-300">We benchmarked our implementation with both GLV enabled and disabled, and compared it with Arkworks' own Jubjub implementation. Our benchmark is conducted over an AMD 5900x CPU, with Ubuntu 20.04, rust 1.52 stable version, and Arkwork 0.3.0 release version. We used criterion micro-benchmark toolchain, version 0.3.0, for data collection. We compile Arkworks with two options, namely default and asm, respectively. The default setup relies on num_bigint crate for large integer arithmetics, while asm turns on assembly for finite field multiplication.</p>

    <p class="text-gray-300">Arkworks use the aforementioned double-and-add multiplication methodology, without side channel protections such as Montgomery ladders. Our non-GLV implementation also follows this design. For our GLV implementation, there are three components, namely, the endomorphism, the scalar decomposition, and the multi scalar multiplication (MSM). We implement those schemes and present the micro-benchmarks in Table 3. Specifically, we do not use the MSM implementation in Arkworks: our scalars, after the decomposition, contain roughly 128 bits of leading zeros, and our own MSM implementation is optimized for this setting.</p>

    <p class="text-gray-300">Table 3 presents the full picture of the benchmark. When GLV is disabled, we observe a similar but a little worse performance for Bandersnatch curve, compared to the Jubjub curve, due to the slightly larger coefficient  <span class="math">a = -5</span>  and a larger scalar field of 253 bits (Jubjub curve has  <span class="math">a = -1</span>  and a scalar field of 252 bits). When GLV is enabled, we report a  <span class="math">45\\%</span>  improvement of the Bandersnatch curve, and a  <span class="math">42\\%</span>  improvement over the Jubjub curve.</p>

    <p class="text-gray-300">Table 3: Bandersnatch vs Jubjub: Performance</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">default</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">asm</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Jubjub</td>

            <td class="px-3 py-2 border-b border-gray-700">75 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">69 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bandersnatch without GLV</td>

            <td class="px-3 py-2 border-b border-gray-700">78 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">72 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bandersnatch with GLV</td>

            <td class="px-3 py-2 border-b border-gray-700">44 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">42 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Endomorphism</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Scalar decomposition</td>

            <td class="px-3 py-2 border-b border-gray-700">0.75 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">multi scalar multiplication</td>

            <td class="px-3 py-2 border-b border-gray-700">42 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">40.8 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Overall Improvement</td>

            <td class="px-3 py-2 border-b border-gray-700">42%</td>

            <td class="px-3 py-2 border-b border-gray-700">39%</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To make a meaningful comparison, we benchmark the cost of the group multiplication over the default generators. Note that Arkworks do not implement optimizations for fixed generators nonetheless. We then sample field elements uniformly at random, for each new iteration, and the benchmark result is consolidated over 100 iterations.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">4.2 Multi scalar multiplications</h3>

    <p class="text-gray-300">This section reports the performance of variable-base multi-scalar multiplications (MSM). It is important to note that this MSM is compatible with, but distinct from, the MSM inside the GLV. Specifically, for a sum of <span class="math">k</span> scalar multiplications, we present the data points for:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>invoking the MSM over the <span class="math">k</span> base scalars randomly sampled, expected to be around 256 bits;</li>

      <li>using GLV endomorphism to break the <span class="math">k</span> base scalars into <span class="math">2k</span> new base scalars, of halved size, i.e. of 128 bits.</li>

    </ul>

    <p class="text-gray-300">The data is presented in Figure 1. Specifically, as a baseline, the trivial solution, captained by GLV without MSM, is the product of the number of bases and the cost of doing a single GLV multiplication. Note that the MSM algorithms incur an overhead to build some tables, which make them less favorable compared to the trivial solution when dimension is really small. For a dimension greater than 4, MSM algorithms begin to out-perform trivial solutions. For dimension greater than 128, it is more efficient to invoke the MSM directly, rather than doing it over the GLV basis.</p>

    <p class="text-gray-300">The most popular algorithm to compute MSM is the Pippenger algorithm <em>[x20]</em>. In theory, for <span class="math">\\lambda</span> bits of scalars and <span class="math">n</span> bases, the algorithm takes <span class="math">(1+o(1))\\frac{2\\lambda n}{\\log\\lambda n}</span> to execute <em>[x1]</em>. Notice that whether the endomorphism is adapted, the product <span class="math">\\lambda n</span> remains the same. in other words, we halved the bit-length of the scalars, in exchange of doubling the dimension. However, we observe that the Pippenger algorithm used by our underlying elliptic curve library, namely, Arkworks version 0.3.0 <em>[x1]</em> does not scale as expected. We believe this is due to two reasons. First, notice that the bucket sizes in the Pippenger algorithm are rounded. For small dimensions, it is optimized via benchmarks results, while for larger dimensions it is derived from theoretical analysis. The latter may introduce a larger rounding error. Secondly, we have ignored the memory cost in this analysis which contributes a noticeable but not significant component in the total cost.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.3 SNARK constraints</h3>

    <p class="text-gray-300">The Bandersnatch curve is zk-SNARK friendly: its base field matches the scalar field for the BLS12-381 curve, a pairing-friendly curve, on top of which people build zk-SNARK systems, such as Groth16 <em>[x12]</em> or Plonk <em>[x13]</em>. In such a setting, the prover can sufficiently argue certain relationships over arithmetic circuits rather than binary circuits.</p>

    <p class="text-gray-300">There are two common ways to express operations in SNARK-friendly circuits, namely</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rank-1 constraint system (R1CS)</li>

      <li>Plonk circuit.</li>

    </ul>

    <p class="text-gray-300">In general, the complexity is determined by the number of constraints for both cases. The R1CS is universal, in that it is compatible with multiple prover front-ends. The Plonk circuit is usually bounded to a specific Plonk proving system, since Plonk prove system allows for customized selectors, and thus, customized circuits descriptions. For Plonk circuit, our analysis is based on an ECC optimized Plonk system, with efficient range proofs from dynamic lookup tables <em>[x14]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Simon Masson, Antonio Sanso, Zhenfei Zhang</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Multi-scalar-multiplications</p>

    <p class="text-gray-300">Precisely, we list the breakdown numbers in Table 4; the Bandersnatch with GLV constraints count is a little higher than the sum of its components due to some overhead during setup phase.</p>

    <p class="text-gray-300">Table 4: Bandersnatch vs Jubjub: Constraints count</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R1CS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plonk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraints</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Jubjub</td>

            <td class="px-3 py-2 border-b border-gray-700">3177</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1865</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bandersnatch without GLV</td>

            <td class="px-3 py-2 border-b border-gray-700">3177</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1865</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bandersnatch with GLV</td>

            <td class="px-3 py-2 border-b border-gray-700">2621</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1669</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Endomorphism</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Scalar decomposition</td>

            <td class="px-3 py-2 border-b border-gray-700">405</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">375</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">multi scalar multiplication</td>

            <td class="px-3 py-2 border-b border-gray-700">2176</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1285</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Overall Improvement</td>

            <td class="px-3 py-2 border-b border-gray-700">21%</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">10%</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The Rust implementation of the Bandersnatch scalar multiplication algorithm confirms our estimations: the circuit for GLV method is  <span class="math">21\\%</span>  smaller than the Jubjub implementation with R1CS, and  <span class="math">10\\%</span>  smaller with Plonk.</p>

    <p class="text-gray-300">We evaluate the number of constraints for a variable base group multiplication. For a double-and-add algorithm, our code reports 3177 constraints in total. We use the default double-and-add circuit framework from Arkworks [Ark]. A sketch of the scheme is presented in Algorithm 2. As a sanity check, within the core logic, it takes 6 constraints per addition, 5 constraints per doubling and 2 constraints per bit selection. This adds up to 13 constraints per bit, or 3177 constraints per group multiplication (and we reasonably assume some system overhead consumes another 10 constraints).</p>

    <p class="text-gray-300">Bandersnatch</p>

    <p class="text-gray-300">|  Algorithm 2 Double-and-Add algorithm in circuit  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: G, H, two group elements  |   |</p>

    <p class="text-gray-300">|  Require: x, a scalar field element  |   |</p>

    <p class="text-gray-300">|  Ensure: Constraints that H == xG  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x0, ..., x254) ← BitDecompose(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Decomposition circuit</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  H' = InfinityPoint |   |</p>

    <p class="text-gray-300">|  for i ∈ [0, 254] do |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if x254-i == 1 then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Binary Selection circuit</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  end if |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H' ← H' + H'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Affine Curve Group Double circuit</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  end for |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EnforcePointEq(H, H')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Equality circuit</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, in the case of GLV, the endomorphism is almost free: it requires 6 constraints. The MSM inside the GLV can also be done with 2176 constraints using the above double-then-add techniques. The difficult part is the circuit for scalar decomposition, which is to prove  <span class="math">n = n_1 + \\lambda n_2 \\mod r</span>  where  <span class="math">n</span>  and  <span class="math">\\lambda</span>  are around 256 bits,  <span class="math">n_1</span>  and  <span class="math">n_2</span>  are around 128 bits, and  <span class="math">r</span>  is the order of the scalar field. We implemented this part of the code with 405 constraints via hand optimized circuits.</p>

    <p class="text-gray-300">We apply a similar analysis for our customized, ECC-friendly Plonk system  <span class="math">\\left[\\mathrm{XCZ}^{+}22\\right]</span> . This custom gate design allows us to express a group add or double operation within 2 gates. As a result, in a double-and-add circuit, each bit in the scalar takes 7 constraints in total, i.e., 2 for point selection, 2 for addition, 2 for doubling, and 1 for binary decomposition. For a scalar length of 256 bits, this is roughly 1800 constraints.</p>

    <p class="text-gray-300">In comparison, with GLV, per bit we account for 4 constraints for  <span class="math">2\\mathrm{x}</span>  point selections, 4 constraints for  <span class="math">2\\mathrm{x}</span>  point additions, and 2 constraints for doubling. There is also a bit decomposition cost which was done during scalar decomposition. The gain comes from the fact that our scalars are only 128 bits each.</p>

    <p class="text-gray-300">The last decade has seen great improvements on practical zk-SNARK systems. An essential stepping stone of these schemes is an efficient elliptic curve whose base field matches the scalar field for some pairing-friendly curve. On this note, we present Bandersnatch as an alternative to the commonly used base curve Jubjub. Due to the existence of an efficiently computable endomorphism, the scalar multiplication over this curve is  <span class="math">42\\%</span>  times faster than the Jubjub curve. For multi scalar multiplications, we report a narrowed advantage over Jubjub curve when the dimension is small, but it vanishes for larger dimensions. We also do not observe any improvement in terms of number of constraints in the corresponding R1CS circuit.</p>

    <p class="text-gray-300">Acknowledgments. We would like to thank Weikeng Chen, Luca De Feo, Justin Drake, Youssef El Housni, Dankrad Feist, Gottfried Herold and Daira Hopwood for fruitful discussions. We express our gratitude to the anonymous reviewers for their critical review of the manuscript and for providing detailed and insightful comments. Their valuable feedback significantly enhanced the quality and clarity of the paper.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AM93] A. O. L. Atkin and F. Morain. Elliptic curves and primality proving. Math. Comp, 61:29–68, 1993.</li>

      <li>[Ark] Arkworks contributors. Arkworks: An ecosystem for developing and programming with zkSNARKs. http://arkworks.rs.</li>

      <li>[Ban] Bandersnatch team. Bandersnatch: a fast elliptic curve built over the BLS12-381 scalar field. https://github.com/zhenfeizhang/bandersnatch.</li>

      <li>[Boo] Jonathan Bootle. Efficient multi-exponentiation. https://jbootle.github.io/Misc/pippenger.pdf.</li>

      <li>[Bow17] Sean Bowe. BLS12-381: New zk-SNARK Elliptic Curve Construction, 2017. https://electriccoin.co/blog/new-snark-curve/.</li>

      <li>[CS18] Craig Costello and Benjamin Smith. Montgomery curves and their arithmetic - the case of large characteristic fields. 8(3):227–240, September 2018. doi:10.1007/s13389-017-0157-6.</li>

      <li>[GLV01] Robert P. Gallant, Robert J. Lambert, and Scott A. Vanstone. Faster point multiplication on elliptic curves with efficient endomorphisms. pages 190–200, 2001. doi:10.1007/3-540-44647-8_11.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. pages 305–326, 2016. doi:10.1007/978-3-662-49896-5_11.</li>

      <li>[GW20] Ariel Gabizon and Zachary J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Report 2020/315, 2020. https://eprint.iacr.org/2020/315.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[HWCD08] Hüseyin Hisil, Kenneth Koon-Ho Wong, Gary Carter, and Ed Dawson. Twisted Edwards curves revisited. pages 326–343, 2008. doi:10.1007/978-3-540-89255-7_20.</li>

      <li>[LZ94] Georg-Johann Lay and Horst G. Zimmer. Constructing elliptic curves with given group order over large finite fields. In Leonard M. Adleman and Ming-Deh Huang, editors, Algorithmic Number Theory, pages 250–263, Berlin, Heidelberg, 1994. Springer Berlin Heidelberg.</li>

      <li>[Mor91] François Morain. Building cyclic elliptic curves modulo large primes. In Donald W. Davies, editor, Advances in Cryptology — EUROCRYPT ’91, pages 328–336, Berlin, Heidelberg, 1991. Springer Berlin Heidelberg.</li>

      <li>[Pip80] Nicholas Pippenger. On the evaluation of powers and monomials. SIAM Journal on Computing, 9(2):230–250, 1980. arXiv:https://doi.org/10.1137/0209022, doi:10.1137/0209022.</li>

      <li>[RCB16] Joost Renes, Craig Costello, and Lejla Batina. Complete addition formulas for prime order elliptic curves. pages 403–428, 2016. doi:10.1007/978-3-662-49890-3_16.</li>

    </ul>

    <p class="text-gray-300">Bandersnatch</p>

    <p class="text-gray-300">[Rob20] Robert Gallant, Robert Lambert, Scott A. Vanstone. Method for accelerating cryptographic operations on elliptic curves, 2020. https://patents.google.com/patent/US7110538B2/en.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Sil86] Joseph H. Silverman. The arithmetic of elliptic curves, volume 106 of Graduate texts in mathematics. Springer, 1986.</li>

      <li>[Vél71] Jacques Vélu. Isogénies entre courbes elliptiques. Comptes Rendus de l’Académie des Sciences de Paris, 273:238–241, 1971.</li>

      <li>[XCZ^{+}22] Alex Luoyuan Xiong, Binyi Chen, Zhenfei Zhang, Benedikt Bünz, Ben Fisch, Fernando Krell, and Philippe Camacho. Veri-zexe: Decentralized private computation with universal setup. Cryptology ePrint Archive, Paper 2022/802, 2022. https://eprint.iacr.org/2022/802. URL: https://eprint.iacr.org/2022/802.</li>

      <li>[Zt18] ZCash team. Jubjub, 2018. https://z.cash/technology/jubjub/.</li>

    </ul>`;
---

<BaseLayout title="Bandersnatch: a fast elliptic curve built over the BLS12-381... (2021/1152)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1152
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
