---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/915';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Does Fiat-Shamir Require a Cryptographic Hash Function?';
const AUTHORS_HTML = 'Yilei Chen, Alex Lombardi, Fermi Ma, Willy Quach';

const CONTENT = `    <p class="text-gray-300">Yilei Chen\\* Alex Lombardi† Fermi Ma‡ Willy Quach§</p>

    <p class="text-gray-300">February 23, 2021</p>

    <p class="text-gray-300">The Fiat-Shamir transform is a general method for reducing interaction in public-coin protocols by replacing the random verifier messages with deterministic hashes of the protocol transcript. The soundness of this transformation is usually heuristic and lacks a formal security proof. Instead, to argue security, one can rely on the random oracle methodology, which informally states that whenever a random oracle soundly instantiates Fiat-Shamir, a hash function that is "sufficiently unstructured" (such as fixed-length SHA-2) should suffice. Finally, for some special interactive protocols, it is known how to (1) isolate a concrete security property of a hash function that suffices to instantiate Fiat-Shamir and (2) build a hash function satisfying this property under a cryptographic assumption such as Learning with Errors.</p>

    <p class="text-gray-300">In this work, we abandon this methodology and ask whether Fiat-Shamir truly requires a cryptographic hash function. Perhaps surprisingly, we show that in two of its most common applications — building signature schemes as well as (general-purpose) non-interactive zero-knowledge arguments — there are sound Fiat-Shamir instantiations using extremely simple and non-cryptographic hash functions such as sum-mod- <span class="math">p</span>  or bit decomposition. In some cases, we make idealized assumptions (i.e., we invoke the generic group model), while in others, we prove soundness in the plain model.</p>

    <p class="text-gray-300">On the negative side, we also identify important cases in which a cryptographic hash function is provably necessary to instantiate Fiat-Shamir. We hope this work leads to an improved understanding of the precise role of the hash function in the Fiat-Shamir transformation.</p>

    <p class="text-gray-300">\\<em>Tsinghua University. Email: chenyilei@mail.tsinghua.edu.cn. \\</em>MIT. Email: alexjl@mit.edu. Research supported in part by an NDSEG fellowship. Research supported in part by NSF Grants CNS-1350619 and CNS-1414119, and by the Defense Advanced Research Projects Agency (DARPA) and the U.S. Army Research Office under contracts W911NF-15-C-0226 and W911NF-15-C-0236. \\*Princeton University and NTT Research. Email: fermima@alum.mit.edu. \\$Northeastern University. Email: quach.w@husky.neu.edu.</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Our Contributions 2 1.2 Conclusions 9 1.3 Related Work 10</p>

    <p class="text-gray-300">2 Technical Overview 11 2.1 A Non-Interactive Lattice-Based Identification Scheme 12 2.2 Fiat-Shamir for Schnorr in the Generic Group Model. 13 2.3 Negative Results 20</p>

    <p class="text-gray-300">3 Preliminaries 21</p>

    <p class="text-gray-300">4 Lattice-based Identification Protocols 22 4.1 Preliminaries 22 4.2 SIS-based Identification Protocols 23 4.3 Connection with Lattice Trapdoors and Signatures 26 4.4 LWE-based Identification Protocols 27 4.5 More Efficient Protocols via Rejection Sampling 31</p>

    <p class="text-gray-300">5 Fiat-Shamir in the Generic Group Model 34 5.1 Generic Group Model Preliminaries 34 5.2 The Auxiliary-Input Generic Group Model 35 5.3 Schnorr Signatures 36 5.4 Chaum-Pedersen Protocol 39 5.5 Application: NIZKs for NP 43</p>

    <p class="text-gray-300">6 Negative Results for Fiat-Shamir with Non-Cryptographic Hash Functions 43 6.1 Main Information-Theoretic Lemma 44 6.2 Negative Result for Blum in the Random Oracle Model 46 6.3 A General Polynomial-Query Attack 46 6.4 A General "Cryptography is Necessary" Result 49</p>

    <p class="text-gray-300">A Correlation Intractability and the Idealized Blum Protocol 57</p>

    <p class="text-gray-300">B Security Analysis in Concrete Groups 59 B.1 Analysis of (Our Variant of) Schnorr Signatures 60 B.2 Security Analysis of Chaum-Pederson over Finite Fields 61</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The Fiat-Shamir transform is a general-purpose method for converting public-coin interactive protocols into <em>non-interactive</em> protocols with the same functionality. As a prototypical example, let <span class="math">\\Pi</span> denote a 3-message (public-coin) argument system with transcripts of the form <span class="math">(\\alpha,\\beta,\\gamma)</span>. Then, given any <em>hash function</em> <span class="math">h</span>, the Fiat-Shamir transform of <span class="math">\\Pi</span> using <span class="math">h</span>, denoted <span class="math">\\Pi_{\\mathrm{FS},h}</span>, is a one-message argument system in which the prover sends an entire transcript <span class="math">(\\alpha,\\beta=h(\\alpha),\\gamma)</span> in one shot.</p>

    <p class="text-gray-300">The Fiat-Shamir transform was introduced by <em>[x10]</em> to remove interaction from a 3-message identification scheme, but it was later realized that the transformation is extremely general: it can plausibly be applied to <em>any</em> constant-round public-coin interactive argument system (and more). Due to its generality and its <em>practical efficiency</em> (it removes interaction with very low computational overhead), the transformation has been a cornerstone of both theoretical and practical cryptography for over 30 years. Some of its applications include the construction of efficient signature schemes <em>[x11, x23, x25]</em>, non-interactive zero-knowledge arguments (NIZKs) <em>[x3, x1, CCH^{+}19, x25]</em>, and succinct non-interactive arguments (SNARGs) <em>[x16, x21, x1, BBC^{+}17, x1, x2, BCR^{+}19, x1]</em>.</p>

    <p class="text-gray-300">However, the vast majority of applications of the Fiat-Shamir transform are only <em>heuristically sound</em>. That is, the resulting non-interactive protocols do not have proofs of soundness based on the computational intractability of a well-studied mathematical problem <em>[x13]</em>. Nonetheless, the protocols appear to be sound in practice, so it has been a long-standing goal of theoretical cryptography to <em>justify</em> the soundness of the transformation.</p>

    <p class="text-gray-300">So far, there have been two main approaches for justifying soundness of Fiat-Shamir.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The Random Oracle Model <em>[x3]</em>: In this design methodology, a Fiat-Shamir hash function is first modeled as a random function <span class="math">\\mathcal{O}</span> to which all parties (honest and dishonest) have public query access. Security is “argued” by showing that the protocol <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{O}}</span> is sound “in the random oracle model” (i.e., against query-bounded adversaries). In reality, the hash function <span class="math">h</span> is instantiated by an “unstructured” hash function (such as SHA-2 on bounded-length inputs), where the implicit expectation is that “Fiat-Shamir for <span class="math">\\Pi</span>” is not an application that can distinguish <span class="math">h</span> from a random oracle.</li>

      <li>Correlation Intractability: In a recent line of work <em>[x15, x16, x11, CCH^{+}19, x25, x12, x11, x13]</em>, a different methodology was developed for provably instantiating Fiat-Shamir in the standard model:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Identify a special class <span class="math">\\mathcal{C}</span> of protocols and a cryptographic security property <span class="math">\\mathcal{P}</span> of a hash function family <span class="math">\\mathcal{H}</span> such that if <span class="math">\\mathcal{H}</span> satisfies <span class="math">\\mathcal{P}</span>, then <span class="math">\\mathcal{H}</span> soundly instantiates Fiat-Shamir for every <span class="math">\\Pi\\in\\mathcal{C}</span>. In all cases so far, <span class="math">\\mathcal{P}</span> has been a restricted form of correlation intractability <em>[x9]</em>.</li>

      <li>Construct a hash function family satisfying <span class="math">\\mathcal{P}</span> under reasonable (hopefully standard) cryptographic assumptions.</li>

    </ul>

    <p class="text-gray-300">The first of these approaches attempts to justify the use of Fiat-Shamir in high generality, while the second provides full security proofs for carefully chosen protocols and hash functions.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Why Cryptographic Hash Functions?</h4>

    <p class="text-gray-300">In both approaches above, it is essential that the hash function <span class="math">h</span> possesses a form of <em>cryptographic hardness</em>. In the random oracle methodology, it is heuristically assumed that <span class="math">h</span> is indistinguishable from a truly random function (at least in any meaningful way), while in the standard model, results so far have relied on correlation-intractable hash families <em>[x22, x10]</em> whose security can be based on standard cryptographic assumptions <em>[CCH^{+}19, x25, x2]</em>.</p>

    <p class="text-gray-300">All of these results support the intuition that the Fiat-Shamir hash family <span class="math">\\mathcal{H}</span> provides a form of cryptographic hardness that ensures the soundness of <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span>. In this work, we ask whether this intuition is accurate.</p>

    <p class="text-gray-300">Is it possible to instantiate the Fiat-Shamir heuristic with a <em>non-cryptographic</em> hash function?</p>

    <p class="text-gray-300">We note that this question requires formalizing what it means to be a “non-cryptographic” (rather than cryptographic) hash function; we partially address this issue later, but this remains somewhat up to interpretation.</p>

    <p class="text-gray-300">A related question concerns the <em>design</em> of Fiat-Shamir hash functions. What should they look like? Again, prior works give us some possible answers:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As originally proposed in <em>[x10]</em>, a Fiat-Shamir hash function could be instantiated using a pseudo-random function family <em>[x12]</em> (they give DES as an example instantiation).</li>

      <li>As proposed in the random oracle methodology <em>[x3]</em>, the following design advice is given. “When instantiating a random oracle by a concrete function <span class="math">h</span>, care must be taken first to ensure that it is adequately conservative in its design so as not to succumb to cryptanalytic attack, and second to ensure that <span class="math">h</span> exposes no relevant ‘structure’ attributable to its being designed from some lower-level primitive.” In other words, the hash function should be <em>unstructured</em> and <em>complex</em> enough to be indistinguishable from a random function.</li>

      <li>In the provably secure instantiations of <em>[CCH^{+}19, x21]</em>, the hash function families are based on flavors of <em>fully homomorphic encryption</em>, which can be instantiated from lattice assumptions <em>[x16, x4]</em>.</li>

      <li>In a recent work of <em>[x2]</em>, a (modified) <em>trapdoor hash function</em> <em>[DGI^{+}19]</em> is used, which has instantiations based on the DDH/LWE/QR/DCR assumptions.</li>

    </ul>

    <p class="text-gray-300">A common theme is that all of the candidate Fiat-Shamir hash functions above are <em>complex</em>. Indeed, they have to be complex enough to realize the described security properties. In contrast, we ask:</p>

    <p class="text-gray-300"><em>Is it possible to instantiate Fiat-Shamir with a </em>simple<em> hash function?</em></p>

    <p class="text-gray-300">As an example, can we hope to have a <em>linear</em> Fiat-Shamir hash function <span class="math">h(x)=Ax+b</span>?</p>

    <p class="text-gray-300">We note that for various contrived protocols <span class="math">\\Pi</span>, the answer is “yes” for uninteresting reasons. For example, given any constant-round, public-coin interactive protocol <span class="math">\\Pi</span>, there is a protocol <span class="math">\\tilde{\\Pi}</span> that replaces all prover messages <span class="math">\\alpha_{i}</span> with random-oracle commitments <span class="math">\\mathcal{O}(\\alpha_{i})</span> and requires the prover to open these commitments in the last round. For this protocol <span class="math">\\tilde{\\Pi}</span>, even the identity function can be used to instantiate Fiat-Shamir in the random oracle model, since we have in effect <em>already</em> applied a random-oracle Fiat-Shamir transformation when converting <span class="math">\\Pi</span> to <span class="math">\\tilde{\\Pi}</span>.</p>

    <p class="text-gray-300">To avoid these trivialities, we phrase our goal more specifically: for various <em>naturally occurring</em> protocols (or classes of naturally occurring protocols), determine if simple/non-cryptographic hash functions may suffice for Fiat-Shamir, and give principled justification for this possibility or impossibility.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">We begin the systematic study of instantiating Fiat-Shamir with simple and non-cryptographic hash functions. In particular, we focus on two common and important use cases of Fiat-Shamir:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Round-compressing 3-message identification schemes <em>[x10, x23, x24]</em>, and</li>

      <li>Round-compressing 3-message honest-verifier zero knowledge argument systems to obtain NIZK arguments for NP <em>[x3, CCRR18, CCH^{+}19, x21, x13, x14, x15]</em>.</li>

    </ol>

    <p class="text-gray-300">For these two use cases, we identify some common 3-message protocols to which Fiat-Shamir is applied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Schnorr’s identification scheme <em>[x23]</em>.</li>

      <li>The Chaum-Pedersen interactive proof system for the Diffie-Hellman language <em>[x7]</em>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lyubashevsky’s lattice-based identification scheme <em>[x18]</em>.</li>

      <li>More generally, <span class="math">\\Sigma</span>-protocols <em>[x10]</em>, which are typically repeated in parallel to obtain negligible soundness error.</li>

    </ul>

    <p class="text-gray-300">In this work, we consider whether existing protocols from above can be round-compressed using a simple/non-cryptographic hash function. We are able to show both negative results and (perhaps surprisingly) <em>positive</em> results on this front.</p>

    <p class="text-gray-300">Before stating our results more formally, we discuss (1) the specific problems we want to solve and (2) what constitutes a solution to the problem.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.1.1 Our Methodology</h4>

    <p class="text-gray-300">There are two major issues to resolve in order to define our problem:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>What does it mean for a hash function to be <em>cryptographic</em>?</li>

      <li>How do we give evidence for the soundness (or lack thereof) of our round-compressed protocols?</li>

    </ol>

    <p class="text-gray-300">We first partially address question (i). One appealing intuitive definition of a cryptographic hash function is as follows:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1.1 (Cryptographic Hash Function, definition attempt).</h6>

    <p class="text-gray-300">A hash function <span class="math">h</span> (or hash function family <span class="math">\\mathcal{H}</span>) is <em>cryptographic</em> if there is a game <span class="math">\\mathcal{G}</span> between a challenger and adversary (who is given <span class="math">h</span> or <span class="math">h\\leftarrow\\mathcal{H}</span>) with a <em>statistical-computational gap</em>; that is, the maximum probability that a computationally bounded adversary can win <span class="math">\\mathcal{G}</span> is noticeably smaller than the maximum probability that an unbounded adversary can win <span class="math">\\mathcal{G}</span>.</p>

    <p class="text-gray-300">Unfortunately, this definition has major issues. In particular, under a literal interpretation of the definition, if <span class="math">\\mathsf{NP}\\not\\subset\\mathsf{BPP}</span>, then <em>every</em> hash function is “cryptographic”: just define the game <span class="math">\\mathcal{G}</span> that ignores the hash family <span class="math">\\mathcal{H}</span> and gives the adversary an instance of a hard <span class="math">\\mathsf{NP}</span> problem to solve.</p>

    <p class="text-gray-300">More specific to our application, the soundness of <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span> is precisely a game with a computational-statistical gap so long as an accepting proof exists but is computationally hard to find. Therefore, no matter how “simple” or “non-cryptographic” <span class="math">\\mathcal{H}</span> appears to be, as long as it can compile Fiat-Shamir for some protocol, it is necessarily “cryptographic” under this definition.</p>

    <p class="text-gray-300">Indeed, an important philosophical point in this work is that the “computational hardness” within the soundness property of <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span> can derive from two different places: the hash family <span class="math">\\mathcal{H}</span> and the interactive protocol <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">For our purposes, we appeal to the following intuitive (non-technical) definition of a cryptographic hash function:</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1.2 (Cryptographic Hash Function, intuition-level).</h6>

    <p class="text-gray-300">Informally, a hash function <span class="math">h</span> (or hash function family <span class="math">\\mathcal{H}</span>) is <em>cryptographic</em> if there is a game <span class="math">\\mathcal{G}</span> between a challenger and adversary with a <em>statistical-computational gap</em> that does not derive from some separate hard problem.</p>

    <p class="text-gray-300">Given this partial answer to question (i), we now describe how we handle (ii):</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">How We Give Positive Results.</h5>

    <p class="text-gray-300">In order to obtain a positive result, we accomplish (at least) one of three things:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We show that any hash function <span class="math">h</span> (or hash family <span class="math">\\mathcal{H}</span>) satisfying an <em>information-theoretic property</em> (e.g., pairwise-independence) suffices to instantiate <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span> soundly. We believe that in spirit, this says that Fiat-Shamir for <span class="math">\\Pi</span> does not require a cryptographic hash function (Definition 1.2), as a purely information theoretic property should be insufficient to establish computational hardness.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We show that a <em>single fixed hash function</em> <span class="math">h</span> (rather than a distribution on hash functions) is enough to soundly instantiate <span class="math">\\Pi_{\\text{FS},h}</span>. More specifically, we show “average-case soundness”, i.e., soundness on a random NO-instance. This is at least enough to strongly distinguish our Fiat-Shamir instantiations from random-oracle hash functions as well as correlation-intractable hash functions, which crucially rely on the randomness of the hash function to derive computational hardness.</li>

      <li>We instantiate <span class="math">\\Pi_{\\text{FS},h}</span> with an <em>extremely simple</em> hash function <span class="math">h</span>, such as a linear function modulo a prime <span class="math">p</span> or the bit decomposition function <span class="math">\\mathbf{G}^{-1}:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{2}^{n\\log q}</span>. This does not directly prove that <span class="math">h</span> is not cryptographic, but it again distinguishes our constructions from prior work, in which the Fiat-Shamir hash functions are comparatively complex (see above). Indeed, they are sufficiently complex to guarantee security properties such as correlation intractability.</li>

    </ul>

    <p class="text-gray-300">While some of our positive results hold in the standard model, others are shown to hold in the (auxiliary-input) generic group model <em>[x21, x27, x24, x10, x11]</em>. One might ask why such a result is meaningful — after all, we are replacing one random oracle (the hash function) with another (the generic group labeling). However, the idealized assumptions in our constructions are used quite differently from assuming that a Fiat-Shamir hash function behaves like a random oracle. Indeed, our hash functions are information-theoretic and do not make any calls to the group oracle. As a result, our constructions are examples of <em>naturally occurring</em> interactive protocols <span class="math">\\Pi</span> (unlike the contrived example from the introduction) that possess enough hardness to guarantee that <span class="math">\\Pi_{\\text{FS},h}</span> is sound for <em>simple</em> choices of <span class="math">h</span> satisfying only information-theoretic properties.</p>

    <p class="text-gray-300">Additionally, our lower bounds in the GGM suggest candidate schemes over concrete groups (<span class="math">\\mathbb{Z}_{p}^{\\times}</span> and elliptic curve groups) that are plausibly secure. Although interpreting hardness results in the GGM in the standard model requires care <em>[x12, x20, x13]</em>, we believe that it would be very interesting to understand the real-world security of the resulting (extremely simple!) schemes. We do some preliminary analysis of the concrete schemes — finding non-generic attacks for one of our two GGM-based protocols but not the other — but largely leave these questions open.</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">How We Give Negative Results.</h5>

    <p class="text-gray-300">In order to obtain a negative result, we would like to show that for a particular protocol <span class="math">\\Pi</span>, if <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}</span> is sound, then <span class="math">\\mathcal{H}</span> necessarily satisfies some concrete cryptographic security property <span class="math">\\mathcal{P}</span>. However, as already discussed, such a theorem is not meaningful — <span class="math">\\mathcal{P}</span> can just be “the soundness of <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}</span>.” In other words, this fails to distinguish between hardness in the hash function family <span class="math">\\mathcal{H}</span> from hardness in the protocol <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">Instead, we switch the order of quantifiers in the theorem statement: we show that there exists a <em>universal</em> security property <span class="math">\\mathcal{P}</span> such that for any protocol <span class="math">\\Pi\\in\\mathcal{C}</span> in a large class, if a hash function family <span class="math">\\mathcal{H}</span> soundly instantiates Fiat-Shamir for <span class="math">\\Pi</span> then <span class="math">\\mathcal{H}</span> necessarily satisfies <span class="math">\\mathcal{P}</span>. Since <span class="math">\\mathcal{P}</span> is independent of the protocol <span class="math">\\Pi</span>, this comes closer to distinguishing <span class="math">\\mathcal{H}</span>-hardness from hardness in <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">However, there is still one issue with the above strategy: <span class="math">\\mathsf{NP}</span>-completeness also gives a (trivial) universal property <span class="math">\\mathcal{P}</span>. To avoid this problem, we prove a <em>relativizing</em> result: the same property <span class="math">\\mathcal{P}</span> is satisfied by <span class="math">\\mathcal{H}</span> even if it instantiates Fiat-Shamir for various protocols <span class="math">\\Pi^{\\mathcal{O}(\\cdot)}</span> that exist relative to an oracle distribution <span class="math">\\mathcal{O}</span>. This establishes that the property <span class="math">\\mathcal{P}</span> is not “cheating” using <span class="math">\\mathsf{NP}</span>-completeness. As an example, our negative results will capture the <span class="math">\\{0,1\\}</span>-challenge variant of Schnorr’s identification scheme in the generic group model as well as Blum’s Hamiltonicity protocol <em>[x3]</em> instantiated in the random-oracle model.</p>

    <p class="text-gray-300">Finally, we show that hash functions satisfying our property <span class="math">\\mathcal{P}</span> imply the existence of one-way functions, the quintessential cryptographic object. This results in a formalization of the statement “one-way functions are necessary to instantiate Fiat-Shamir hash functions for natural protocols.”</p>

    <p class="text-gray-300">As an added bonus, we are also sometimes able to give direct attacks on <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}</span> relative to an oracle (i.e., in the generic group model or the random oracle model). That is, for the idealized protocols, we show unconditional polynomial-query attacks on the non-interactive protocol. This is further evidence that a sound Fiat-Shamir instantiation must sometimes rely on hardness from the hash function family <span class="math">\\mathcal{H}</span>, in direct contrast to our positive results.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.1.2 Our Results</p>

    <p class="text-gray-300">With the above discussion in mind, we are now ready to formally state our results. First, we give several positive results for soundly instantiating Fiat-Shamir with <em>non-cryptographic</em> hash functions.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Fiat-Shamir for Lattice-Based Identification Schemes.</h4>

    <p class="text-gray-300">We first describe our positive results in the standard model, which hold for lattice-based analogues of the Schnorr protocol. In particular, we consider common variants of Lyubashevsky’s identification schemes <em>[Lyubashevsky18, Lyubashevsky19, Lyubashevsky20]</em>, which were designed to obtain efficient signature schemes in the random oracle model via Fiat-Shamir.</p>

    <p class="text-gray-300">We obtain a sound Fiat-Shamir instantiation for the main protocol <span class="math">\\Pi</span> defined in <em>[Lyubashevsky19]</em>. Our Fiat-Shamir hash function in <span class="math">\\Pi_{\\text{FS},h}</span> maps <span class="math">\\mathbb{Z}_{q}</span> elements to their bit-decomposition (also known as the <span class="math">\\mathbf{G}^{-1}</span> function).</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.3.</h6>

    <p class="text-gray-300">Consider Lyubashevsky’s identification scheme over <span class="math">\\mathbb{Z}_{q}</span> in dimension <span class="math">n</span>. Define the hash function <span class="math">h:\\mathbb{Z}_{q}^{n}\\rightarrow\\mathbb{Z}_{2}^{n\\log q}</span> as the bit decomposition function</p>

    <p class="text-gray-300"><span class="math">h(v)=\\mathbf{G}^{-1}(v).</span></p>

    <p class="text-gray-300">Then, under the Short Integer Solution (SIS) assumption, Fiat-Shamir applied to Lyubashevsky’s scheme using hash function <span class="math">h</span> is sound on random instances.</p>

    <p class="text-gray-300">We note the following interesting details about our result.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We obtain a meaningful soundness guarantee using a deterministic hash function. This stands in contrast to typical Fiat-Shamir instantiations.</li>

      <li>More generally, we prove Theorem 1.3 for a class of Fiat-Shamir hash functions (including bit-decomposition) satisfying an information-theoretic property.</li>

      <li>Most importantly, and uniquely to the lattice setting, we emphasize that soundness is proved in the standard model! More specifically, the SIS assumption suffices to argue <em>average-case</em> soundness, where soundness requires that a cheating prover cannot convince a verifier to accept on a random instance. We stress that this is the typical soundness notion for the setting of identification/signature schemes and a necessary relaxation for the case of deterministic hash functions.</li>

    </ul>

    <p class="text-gray-300">To contrast this with prior work on Fiat-Shamir in the standard model <em>[Kerr, Cerr, Cerr19, Cerr20, Brem20]</em>, we note that (1) it was not known how to do Fiat-Shamir for the <em>[Lyubashevsky19]</em> protocol in the correlation intractability framework, and (2) our Fiat-Shamir compiler uses the bit decomposition function and <em>not</em> any form of CI.</p>

    <p class="text-gray-300">Finally, as an extension of Theorem 1.3, we prove that variants of our protocol <span class="math">\\Pi_{\\text{FS}}</span> show a surprising connection to Micciancio-Peikert lattice trapdoors <em>[Morrison2012, Lamm2015]</em>. Namely, the prover algorithm in <span class="math">\\Pi_{\\text{FS}}</span> can be interpreted as a preimage sampling algorithm using a Micciancio-Peikert trapdoor.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 1.4 (Informal).</h6>

    <p class="text-gray-300">Lattice-based Lyubashevsky signatures using the bit-decomposition Fiat-Shamir hash function are equivalent to lattice-based Hash-and-Sign signatures.</p>

    <p class="text-gray-300">This highlights a strong connection between two seemingly orthogonal paths to build signatures from lattice-based assumptions: one using lattice trapdoors <em>[Govde2008, Chappin2010, Morrow2012]</em> and the other through the Fiat-Shamir heuristic <em>[Lyubashevsky19, Lyubashevsky20]</em>. To the best of our knowledge (see <em>[Pei2016]</em>), no such connection was known before. We discuss this connection in more detail in the technical overview.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Schnorr Signatures with a Linear Fiat-Shamir Hash Function.</h4>

    <p class="text-gray-300">Our next result concerns the Schnorr signature scheme, obtained by applying Fiat-Shamir to Schnorr’s three-message protocol for proving knowledge of a discrete logarithm. We show that for signing <em>short</em> messages (i.e. the message space is a sparse subset of <span class="math">\\mathbb{Z}_{p}</span>), this classic application of the Fiat-Shamir paradigm does not seem to require any cryptographic properties from the underlying Fiat-Shamir hash function.</p>

    <p class="text-gray-300">Recall that the Schnorr protocol works over a cryptographic group <span class="math">G</span> of order <span class="math">p</span>, and that the Fiat-Shamir hash function takes as input a group element <span class="math">g\\in G</span> along with a message <span class="math">m\\in\\mathcal{M}</span> to be signed, and outputs an element in <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 1.5 (Schnorr Signatures with a <span class="math">\\mathbb{Z}_{p}</span>-Linear Hash Function).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the Schnorr signature scheme over a group <span class="math">G</span> of order <span class="math">p</span>, where the message space <span class="math">\\mathcal{M}</span> is a sparse subset of <span class="math">\\mathbb{Z}_{p}</span>, i.e. <span class="math">\\mathcal{M}\\subset\\mathbb{Z}_{p}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\mathbb{Z}_{p}\\leq\\textup{negl}(\\lambda)<span class="math">. Let </span>\\ell<span class="math"> be the maximum bit-length representation of any group element, so that any </span>g\\in G<span class="math"> can be viewed as </span>g\\in\\{0,1\\}^{\\ell}=[2^{\\ell}]$. Define the hash family</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h_{k}(g,m)\\coloneqq g+m+k\\ (\\textup{mod}\\ p),</span></p>

    <p class="text-gray-300">where on the right-hand side, <span class="math">g</span> is the integer with binary representation <span class="math">g\\in\\{0,1\\}^{\\ell}</span>.</p>

    <p class="text-gray-300">In the auxiliary-input generic group model <em>[x20]</em>, the Schnorr signature scheme instantiated using <span class="math">h</span> as the Fiat-Shamir hash function is existentially unforgeable against chosen message attacks (EUF-CMA).</p>

    <p class="text-gray-300">As in the lattice setting, we can actually prove that Fiat-Shamir for Schnorr is sound whenever <span class="math">h</span> (or the family <span class="math">\\mathcal{H}</span>) satisfies an information-theoretic property. However, our security proof relies on the GGM and does not seem to carry over to the standard model. Nonetheless, we view Theorem 1.5 as another interesting example of a Fiat-Shamir instantiation whose soundness does not rely on any cryptographic property of the hash function. Instead, strong cryptographic hardness from the group turns out to be sufficient!</p>

    <p class="text-gray-300">Another takeaway from Theorem 1.5 is that Schnorr-like signatures can plausibly be obtained by combining a collision-resistant hash function (to implement hash-and-sign) with an information-theoretic Fiat-Shamir hash function (for Schnorr signatures on short messages). While this does not appear significantly different from using a cryptographic Fiat-Shamir hash function <em>in implementation</em>, it highlights the fact that cryptographic hashing is required for signatures only to (computationally) avoid <em>collisions</em> between long messages, and <em>not</em> for ensuring soundness of the Fiat-Shamir compilation.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Aside on Generic Groups.</h4>

    <p class="text-gray-300">The Generic Group Model <em>[x22]</em> models a cryptographic group <span class="math">G</span> as a random injection <span class="math">G\\to[L]</span> for a sufficiently large “label space” <span class="math">L</span>, by providing an oracle <span class="math">\\mathcal{O}</span> that computes group products and inverses on (pairs of) labels. The auxiliary-input GGM <em>[x20, x11]</em> gives the adversary the additional power to <em>record</em> an arbitrary (<span class="math">S</span>-bounded) function of the group’s truth table to use for solving computational problems later.</p>

    <p class="text-gray-300">In the plain GGM, soundness of our variant of Schnorr signatures follows from analysis due to <em>[x23]</em>; this work characterized a security property of <span class="math">\\mathcal{H}</span> that suffices for (long-message) signatures schemes in the GGM. For our purposes, it turns out that an <em>information-theoretic</em> property of <span class="math">h</span> suffices; see Section 2 for details. In fact, using the even simpler (keyless) function <span class="math">h(g,m)=g+m</span> is secure in the GGM.</p>

    <p class="text-gray-300">However, since soundness is proved in the GGM, it is reasonable to ask whether the hardness result plausibly translates to concrete groups such as <span class="math">\\mathbb{Z}_{p}^{\\times}</span> or elliptic curve groups. Indeed, it is known that GGM lower bounds sometimes fail to carry over to these groups in cases of interest (see, e.g., <em>[x10, x24]</em>). In this work, we observe that this issue <em>also</em> comes up in the case of Schnorr signatures as analyzed by <em>[x23]</em>. In more detail, <em>[x23]</em> proves that as long as a hash family <span class="math">\\mathcal{H}</span> satisfies two (possibly computational) properties, then Schnorr signatures using <span class="math">\\mathcal{H}</span> are secure in the GGM. On the other hand, we find choices of <span class="math">\\mathcal{H}</span> that satisfy the premises of <em>[x23]</em>, but attacks exist over <em>all concrete groups</em>. This highlights an important situation where GGM-based analysis spectacularly fails to capture real-world attacks on a scheme.</p>

    <p class="text-gray-300">On the other hand, we further observe that these non-generic attacks can be captured by the auxiliary-input GGM; that is,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given some (possibly hard-to-compute) short piece of information <span class="math">w</span> about <span class="math">G</span> (but independent of the Schnorr public parameters), Schnorr signatures using <span class="math">\\mathcal{H}</span> are insecure, and</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Over important concrete groups such as <span class="math">\\mathbb{Z}_{p}^{\\times}</span> or elliptic curve groups, this information <span class="math">w</span> is actually efficiently computable.</li>

    </ul>

    <p class="text-gray-300">For example, the short information could be a solution <span class="math">z</span> to the equation <span class="math">a^{z}=\\ell</span>, where <span class="math">\\ell\\in[L]</span> is a fixed label such that <span class="math">\\ell\\equiv-1\\pmod{p}</span>. To remedy this problem, we prove a lower bound in the aux-input GGM, thus avoiding an important class of “non-generic” attacks for the hash function in Theorem 1.5 (and more). This proof is the new technical component of Theorem 1.5.</p>

    <p class="text-gray-300">In fact, we know of no efficient attacks on the scheme from Theorem 1.5 over the group <span class="math">\\mathbb{Z}_{p}^{\\times}</span>. We find the question of whether this scheme is secure to be interesting, as it would result in a signature scheme that is extremely simple to write down — in fact, key generation, signing, and verifying only require random sampling and arithmetic over <span class="math">\\mathbb{Z}_{p}</span>. We do some preliminary analysis of the scheme in Appendix B but leave the question largely out of the scope of this paper.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">The Chaum-Pedersen Protocol and NIZKs for <span class="math">\\mathsf{NP}</span>.</h4>

    <p class="text-gray-300">Next, we consider a minor variant of the interactive proof system due to Chaum and Pedersen <em>[x10]</em> for proving membership in the Diffie-Hellman language <span class="math">\\mathcal{L}_{\\text{DH}}\\coloneqq\\{(g,g^{u},g^{v},g^{uv})\\}_{g\\in G,u,v\\in\\mathbb{Z}_{p}}</span>. The protocol was originally introduced to instantiate a (special-purpose) blind signature scheme, but it has since found other applications (e.g., to the Cramer-Shoup cryptosystem <em>[x11]</em>). Notably, a recent line of work <em>[x12, x21, x23, x13]</em> has shown that a non-interactive, adaptively sound, (single-theorem) zero-knowledge argument for <span class="math">\\mathcal{L}_{\\text{DH}}</span> (along with CDH) suffices to instantiate non-interactive zero-knowledge (NIZK) arguments for all of <span class="math">\\mathsf{NP}</span>.</p>

    <p class="text-gray-300">We prove in the (auxiliary-input) GGM that a simple, fixed Fiat-Shamir hash function <span class="math">h</span> suffices to compile the modified Chaum-Pedersen protocol into an argument for <span class="math">\\mathcal{L}_{\\text{DH}}</span> satisfying an intermediate (i.e., in between selective and adaptive) notion of soundness we call <em>semi-adaptive</em> soundness. Here, the prover is given a random <span class="math">g^{u}</span>, and wins if it convinces the verifier to accept a NO-instance of <span class="math">\\mathcal{L}_{\\text{DH}}</span> of the form <span class="math">(g,g^{u},g^{y},g^{z})</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 1.6.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi^{\\text{CP}}</span> denote the modified Chaum-Pedersen protocol over a group <span class="math">G</span> of order <span class="math">p</span>. Let <span class="math">\\ell</span> be the maximum bit-length representation of any group element, so that any <span class="math">g\\in G</span> can be viewed as <span class="math">g\\in\\{0,1\\}^{\\ell}=[2^{\\ell}]</span>. Define the hash function</p>

    <p class="text-gray-300"><span class="math">h(g_{1},g_{2},g_{3},g_{4})=g_{1}+g_{2}+g_{3}+g_{4}\\ (\\text{mod}\\ p),</span></p>

    <p class="text-gray-300">where on the right-hand side, each <span class="math">g_{i}</span> is the integer with binary representation <span class="math">g_{i}\\in\\{0,1\\}^{\\ell}</span>.</p>

    <p class="text-gray-300">In the auxiliary-input generic group model, <span class="math">(\\Pi^{\\text{CP}})_{FS,h}</span> is a semi-adaptively sound argument system for <span class="math">\\mathcal{L}_{\\text{DH}}</span>.</p>

    <p class="text-gray-300">In Section 5, we prove a stronger result: as long as <span class="math">h</span> satisfies an (easily satisfied but complicated to state) information theoretic property, <span class="math">(\\Pi^{\\text{CP}})_{\\text{FS},h}</span> is sound in the aux-input GGM.</p>

    <p class="text-gray-300">By tweaking the hash function to be <span class="math">h^{\\prime}(\\cdot)\\coloneqq h(\\cdot)+r</span> where <span class="math">r</span> is a common random string, <span class="math">(\\Pi^{\\text{CP}})_{\\text{FS},h^{\\prime}}</span> becomes a (single-theorem) NIZK argument for <span class="math">\\mathcal{L}_{\\text{DH}}</span> with semi-adaptive soundness. It turns out that semi-adaptive soundness suffices to instantiate the hidden bits model of <em>[x14]</em>, and consequently NIZKs for <span class="math">\\mathsf{NP}</span> in the standard model <em>[x12, x21, x23, x13]</em>.</p>

    <p class="text-gray-300">However, we also cryptanalyze this protocol over concrete groups such as <span class="math">\\mathbb{Z}_{p}^{\\times}</span> and elliptic curve groups (see Appendix B), and unlike the case of Schnorr signatures above, we find non-generic attacks (that fall outside the aux-input GGM) on the scheme. Thus, Theorem 1.6 should be viewed as a theoretical result that does <em>not</em> have direct implications over commonly used groups. This disparity between the GGM and the standard model appears to be quite subtle and deserves further study, as further discussed in our conclusion (Section 1.2).</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Negative Results.</h4>

    <p class="text-gray-300">To complement our positive results, we also show that for some protocols, Fiat-Shamir necessarily requires a cryptographic hash function. Our negative results apply to a large class <span class="math">\\mathcal{C}</span> of three-message honest-verifier zero-knowledge (HVZK) arguments (or proofs), in particular, those obtained by taking parallel repetitions of sigma protocols with polynomial-size challenge space. Two prototypical examples to have in mind are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Blum’s Hamiltonicity protocol <em>[x10]</em>, repeated in parallel to obtain negligible soundness error.</li>

      <li>The one bit challenge variant <span class="math">\\Pi^{\\text{bit-Sch}}</span> of Schnorr’s identification scheme, again repeated in parallel.</li>

    </ul>

    <p class="text-gray-300">We analyze Fiat-Shamir for these protocols in both the standard model and in idealized models (the random-oracle model and the preprocessing GGM, respectively). We give evidence that analogues to Theorem 1.5, Theorem 1.6, and Theorem 1.3 <em>do not exist</em> for these protocols. Our two results are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial-Query Attacks: First, we show that in idealized models, there will (unconditionally) be a polynomial-query attack on <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}</span>, <em>as long as <span class="math">\\mathcal{H}</span> does not depend on the oracle</em>. In other words, a (poly-query) sound Fiat-Shamir instantiation requires that <span class="math">\\mathcal{H}</span> depends on the oracle, which is one way of arguing that <span class="math">\\mathcal{H}</span> is cryptographic.</li>

    </ul>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 1.7 (Informal).</h6>

    <p class="text-gray-300">For <span class="math">\\Pi=\\Pi^{\\text{bit-Sch}}</span> instantiated in the generic group model, if <span class="math">\\mathcal{H}</span> is a hash family that does not call the group oracle, then <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}^{t}</span> is unsound in the GGM.</p>

    <p class="text-gray-300">For <em>any</em> instantiation of the <em>[x10]</em> protocol in the random oracle model, if <span class="math">\\mathcal{H}</span> is a hash family that does not depend on the oracle <span class="math">\\mathcal{O}</span>, then <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}</span> is unsound.</p>

    <p class="text-gray-300">More generally, for any <span class="math">\\Pi\\in\\mathcal{C}</span> constructed relative to an oracle <span class="math">\\mathcal{O}</span>, if <span class="math">\\mathcal{H}</span> does not depend on <span class="math">\\mathcal{O}</span>, then <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}</span> is unsound.</p>

    <p class="text-gray-300">This is in contrast to Schnorr/Chaum-Pedersen reuslts, in which an oracle-independent hash function suffices for a sound Fiat-Shamir instantiation.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Generalization: What is the class <span class="math">\\mathcal{C}</span>?</h4>

    <p class="text-gray-300">In full generality (see Theorem 6.7), the class <span class="math">\\mathcal{C}</span> of protocols <span class="math">\\Pi</span> for which we give a polynomial-query attack on <span class="math">\\Pi_{\\text{FS},\\mathcal{H}}</span> is informally characterized as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi:=\\Pi_{\\text{Base}}^{t}</span> is the parallel repetition of a 3-message public-coin HVZK argument system <span class="math">\\Pi_{\\text{Base}}=\\Pi_{\\text{Base}}^{\\mathcal{O}(\\cdot)}</span> (with simulator <span class="math">\\mathsf{Sim}</span>) relative to an oracle <span class="math">\\mathcal{O}</span>.</li>

      <li>The Verifier’s challenge space <span class="math">\\Sigma</span> in <span class="math">\\Pi_{\\text{Base}}</span> is polynomial-size.</li>

      <li>The underlying language <span class="math">L\\not\\in\\mathsf{BPP}</span>.</li>

      <li><span class="math">(\\Pi_{\\text{Base}},\\mathsf{Sim})</span> is challenge hiding (Definition 6.4).</li>

    </ul>

    <p class="text-gray-300">The last requirement (challenge hiding) is a technical condition that slightly strengthens the standard notion of HVZK.</p>

    <p class="text-gray-300">We emphasize that our result makes no assumptions about the way in which the oracle <span class="math">\\mathcal{O}</span> is used in the construction of the interactive protocol <span class="math">\\Pi_{\\text{Base}}</span>. The most substantial requirement is that <span class="math">\\Pi</span> is the result of <em>parallel repetition</em> applied to a protocol with a small (i.e., polynomial) challenge space. This property distinguishes the protocols that we can attack from the protocols for which we find sound Fiat-Shamir instantiations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Conditional Polynomial-time Attacks and Mix-and-Match Resistance: We describe a concrete security property (which we call “mix-and-match resistance” (Definition 6.8)) such that for any protocol <span class="math">\\Pi</span> in a large class <span class="math">\\mathcal{C}^{\\prime}</span> (again including the two example protocols above, <em>in the standard model</em>), any hash function (family) <span class="math">\\mathcal{H}</span> that instantiates Fiat-Shamir for <span class="math">\\Pi</span> must possess this security property. In other words, we show:</li>

    </ul>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 1.8 (Informal, see Theorem 6.10).</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{H}</span> is <em>not</em> mix-and-match resistant, then for any <span class="math">\\Pi\\in\\mathcal{C}</span>, there is a polynomial-time attack on the soundness of <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span>.</p>

    <p class="text-gray-300">At a high level, mix-and-match resistance is a security property asserting the hardness of finding a <em>combination</em> of many partial inputs that hashes to a corresponding <em>combination</em> of prescribed outputs. We also show (Lemma 6.9) that mix-and-match resistant hash functions imply the existence of OWFs. Therefore, Theorem 1.8 implies that (in the setting above) if <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span> is sound, then <span class="math">\\mathcal{H}</span> can be used to build a OWF (obliviously to the protocol <span class="math">\\Pi</span>).</p>

    <p class="text-gray-300">This result also holds in the ROM and the GGM, in the sense that if <span class="math">\\mathcal{H}</span> does not depend on the oracle <span class="math">\\mathcal{O}</span> and is <em>not</em> mix-and-match resistant, then the polynomial-query attack from Theorem 1.7 can be upgraded to a polynomial-time attack. As discussed above, this further establishes that the “mix-and-match resistance” property of <span class="math">\\mathcal{H}</span> is not “borrowing hardness” from the protocol <span class="math">\\Pi</span>, since our analysis applies to protocols whose security is unconditional.</p>

    <p class="text-gray-300">Somewhat orthogonally, one might wonder whether mix-and-match resistant hash functions (as introduced in this work) are known to exist under standard cryptographic assumptions. The works of <em>[CCH^{+}19, x20]</em> tell us that the answer is “yes,” because they give a standard-model instantiation of Fiat-Shamir for a protocol <span class="math">\\Pi\\in\\mathcal{C}</span> under standard assumptions. In Appendix A, we explore this connection further by showing that correlation-intractable hash functions (as constructed by <em>[CCH^{+}19, x20]</em>) suffice to instantiate Fiat-Shamir for (a variant of) the <em>idealized</em> Blum protocol.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">1.2 Conclusions</h3>

    <p class="text-gray-300">One of the main takeaways of this work is that our title question “Does Fiat-Shamir require a cryptographic hash function?” is surprisingly deep and difficult to resolve. We believe that our positive and negative results improve our understanding of the ground truth and point to fascinating new research directions.</p>

    <p class="text-gray-300">Before now, the prevailing intuition was that for any natural protocol (Schnorr, Lyubashevsky, Blum, etc.), sound Fiat-Shamir compilation necessitates a carefully-constructed <em>cryptographic</em> hash function. In this methodology, the soundness of Fiat-Shamir has been argued by either (1) treating the hash function as a random oracle or (2) invoking some concrete security property of the function family. That is, the computational hardness of some problem derived from <span class="math">H</span> guarantees the soundness of the protocol.</p>

    <p class="text-gray-300">In this work, we argue soundness of Fiat-Shamir (for certain protocols) by using an <em>information-theoretic</em> property of <span class="math">H</span> together with cryptographic hardness from the interactive protocol. Despite the caveats in our results, the conceptual point is clear: it is possible to prove meaningful notions of soundness for a Fiat-Shamir protocol by using security properties of the interactive protocol itself <em>instead</em> of security properties of the hash function.</p>

    <p class="text-gray-300">Moreover, the instantiations of our positive results have noticeable qualitative differences from prior approaches to Fiat-Shamir, such as being able to use a <em>single</em> hash function <span class="math">h</span> (rather than a family), much simpler hash functions, and ones that contain no associated cryptographic hardness. This constrasts strongly with how we usually think of Fiat-Shamir; essentially all prior work required that the hash function be complex and/or cryptographic.</p>

    <p class="text-gray-300">On the other hand, we also show (and formalize a way to show) that some protocols <em>do</em> require a cryptographic Fiat-Shamir hash function. This implies that the ground truth is complicated and hard to characterize, but in our view, worth understanding.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">What about Fiat-Shamir in Practice?</h5>

    <p class="text-gray-300">Since Schnorr signatures are heavily used in practice, one might ask how our positive results over groups relate to the use of Fiat-Shamir over concrete groups. The answer to this question crucially depends on how accurately the generic group model (with preprocessing) reflects the concrete security of these protocols.</p>

    <p class="text-gray-300">While generic group analysis is often considered to be a meaningful reflection of real-world attacks, we discovered multiple non-generic attacks on Fiat-Shamir protocols over groups. Such attacks are therefore not covered by prior generic analyses such as <em>[x21]</em>.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the case of Schnorr signatures over <span class="math">\\mathbb{Z}_{p}^{\\times}</span>, all of the new attacks we found were captured by the <em>preprocessing</em> generic group model, and so our new analysis in the preprocessing model rules out all such attacks on many variants of Schnorr signatures. Therefore, we view our positive results for Schnorr as a first step towards finding secure simple variants of Schnorr signatures, such as the candidate given in Construction 2.5.</li>

      <li>On the other hand, we have already discovered attacks (see Appendix B) on certain variants of our Chaum-Pedersen protocol over groups such as <span class="math">\\mathbb{F}_{p}^{\\times}</span>, even in settings where we have a valid (preprocessing) generic group analysis.</li>

    </ul>

    <p class="text-gray-300">This results in a bizarre state of affairs in which it is unclear how to interpret generic group analyses for Fiat-Shamir protocols over groups; this deserves future attention and cryptanalytic effort. Nonetheless, we consider the conceptual contributions of these aux-input GGM analyses to be valuable whether they turn out to reflect real-world attacks or not.</p>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Future Work.</h5>

    <p class="text-gray-300">We believe that our framework can serve as a potential complement to the correlation intractability framework for provable Fiat-Shamir soundness. Towards this end, we broadly ask,</p>

    <p class="text-gray-300"><em>Which interactive protocols allow for “simple” Fiat-Shamir compilers?</em></p>

    <p class="text-gray-300">To start with, we consider differences between the protocols in our positive and negative results. Heuristically, we note that all protocols in our positive results achieve negligible soundness error using a <em>single non-separable large challenge</em>. In contrast, the separability of the challenge in the parallel repetition of a <span class="math">\\Sigma</span>-protocol appears to necessitate using a cryptographic hash function.</p>

    <p class="text-gray-300">In this context, our contributions are a starting point for a more precise understanding of <em>when</em> hardness is required from a Fiat-Shamir hash function.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <p class="text-gray-300">To the best of the authors’ knowledge, the only prior work to explicitly consider Fiat-Shamir for <em>non-cryptographic</em> hash functions is the work of Mittelbach and Venturi <em>[x20]</em>. They identify a class of so-called “highly sound” protocols for which Fiat-Shamir can be soundly applied using any <span class="math">q</span>-wise independent hash function. Moreover, they showed that using indistiguishability obfuscation, any <span class="math">3</span>-round public coin interactive proof system can be converted into one that is “highly sound.” However, the class of protocols for which their compiler works is extremely narrow; the only non-trivial protocols we are aware of satisfying their criteria are obtained through indistinguishability obfuscation.</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Negative Results for Fiat-Shamir.</h5>

    <p class="text-gray-300">A celebrated result of <em>[x10]</em> shows that Fiat-Shamir <em>in the standard model</em> is not instantiable for a <span class="math">3</span>-message protocol <span class="math">\\Pi</span> that is <em>malicious-verifier</em> zero knowledge. This result can be seen as an extension of prior impossibility results <em>[x14, x13]</em> for constant-round public-coin zero knowledge.</p>

    <p class="text-gray-300">The basic ideas present in these (and other) negative results — use a zero-knowledge simulator for the protocol to contradict the soundness of a related protocol — appear in an altered form in our negative results (Theorem 6.10, Theorem 6.7). However, in this work, we show that (in some settings) even honest-verifier zero knowledge (which is easily satisfied by many <span class="math">3</span>-message protocols) of the interactive protocol is sufficient to imply that a Fiat-Shamir hash function must be cryptographic.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Correlation Intractability and Fiat-Shamir.</h5>

    <p class="text-gray-300">In a long sequence of works <em>[x18, x7, x11, x12, CCH^{+}19, x22, x1, x16]</em>, it was shown that Fiat-Shamir in the standard model can be provably instantiated (for an interesting class of protocols) by using a Fiat-Shamir hash family <span class="math">\\mathcal{H}</span> satisfying variants</p>

    <p class="text-gray-300">of correlation intractability [CGH98]. A hash family <span class="math">\\mathcal{H}</span> is correlation intractable for a sparse relation <span class="math">R(x,y)</span> if given <span class="math">h \\leftarrow \\mathcal{H}</span>, it is computationally hard to find an input <span class="math">x</span> such that <span class="math">(x,h(x)) \\in R</span>.</p>

    <p class="text-gray-300">There is a fairly strong established connection between correlation-intractability and Fiat-Shamir (see discussion in [CCRR18]); in fact, it is known that (under appropriate formulations) for a hash family <span class="math">\\mathcal{H}</span>, correlation intractability for all sparse relations is equivalent to soundly instantiating Fiat-Shamir for all constant-round public-coin (statistically sound) interactive proofs. This implies a weak negative result for Fiat-Shamir with information-theoretic hash functions: it says that if <span class="math">\\mathcal{H}</span> instantiates Fiat-Shamir simultaneously for a large class of interactive protocols, then <span class="math">\\mathcal{H}</span> is cryptographic.⁵</p>

    <p class="text-gray-300">As a result, one could attempt to study the questions in this paper through the correlation intractability lens. However, our questions do not appear to translate well into the language of correlation intractability. This is mainly because we do not ask <span class="math">\\mathcal{H}</span> to instantiate Fiat-Shamir for such a large class of protocols (such as all 3-round public coin interactive proofs) at once. For any fixed 3-message protocol <span class="math">\\Pi</span>, correlation intractability for the "transcript relation" <span class="math">R_x = \\{(\\alpha, \\beta) : \\exists \\gamma \\text{ such that } V(x, \\alpha, \\beta, \\gamma) = 1\\}</span> is too strong of a security property to exactly capture the soundness of Fiat-Shamir for <span class="math">\\Pi</span>. This is because correlation intractability does not capture the hardness of finding an accepting third message <span class="math">\\gamma</span> along with the first message <span class="math">\\alpha</span>.</p>

    <p class="text-gray-300">On a related note, the work of Dodis et al. [DRV12] shows that a property of hash function families called "entropy preservation" is necessary for the soundness for Fiat-Shamir for proofs (it is shown in [CCR16] that entropy preservation and correlation intractability are equivalent in some parameter settings). This is also a characterization of when a hash family <span class="math">\\mathcal{H}</span> instantiates FS simultaneously for all (constant-round public coin) interactive proofs. The result of Dodis et al. does not show that entropy preservation is necessary for instantiating FS for any fixed protocol such as Blum's protocol for Hamiltonian cycles.</p>

    <p class="text-gray-300">Subsequent Work. A recent work of Mour [Mou20] studies the relationship between Fiat-Shamir/CI and one-way functions by proving a bidirectional black-box separation between the notions. In particular, Mour shows that for every constant-round public-coin interactive proof system <span class="math">\\Pi</span>, there exists an oracle <span class="math">\\mathcal{O}</span> relative to which a Fiat-Shamir hash function for <span class="math">\\Pi</span> exists but OWFs do not. An earlier version of this paper [CLMQ20] did not relate our negative results (Theorems 1.7 and 1.8) to OWFs, but we have updated our paper with a proof that mix-and-match resistant hash functions imply OWFs; as a result, Theorem 1.8 states that certain Fiat-Shamir instantiations imply OWFs. One reason this does not contradict [Mou20] — even though our results relativize! — is that Mour's Fiat-Shamir hash function (which does not imply one-way funcitons) depends on the oracle <span class="math">\\mathcal{O}</span>. Our relativized results crucially assume that the hash function <span class="math">h</span> does not depend on the oracle to show that <span class="math">h</span> implies OWFs.</p>

    <p class="text-gray-300">One possible interpretation of Mour's result is that for any protocol <span class="math">\\Pi</span>, there exists an oracularized form of computational hardness based on <span class="math">\\Pi</span> that can lead to a Fiat-Shamir instantiation without OWFs; on the other hand, we show that (for our class of protocols) a Fiat-Shamir hash function that is not based on an oracle implies OWFs (and that <span class="math">\\Pi_{\\mathrm{FS}}</span> can be broken unconditionally with polynomially many queries and unbounded computation).</p>

    <p class="text-gray-300">We give an overview of our positive results for lattice-based identification protocols in Section 2.1 and our positive results for group-based protocols in Section 2.2. We then describe some of our negative results in Section 2.3.</p>

    <p class="text-gray-300">⁵It is not hard to see that correlation-intractable hash functions (for a fairly small class of sparse relations) imply the existence of one-way functions: in the case that <span class="math">h</span> is shrinking by a factor of 2, consider the function family <span class="math">f(x) = h(x) + p(x)</span> for <span class="math">h \\leftarrow \\mathcal{H}</span> and <span class="math">p</span> sampled from a pairwise independent hash family.</p>

    <p class="text-gray-300">2.1 A Non-Interactive Lattice-Based Identification Scheme</p>

    <p class="text-gray-300">We describe how we obtain positive results in the lattice setting (Theorem 1.3). We consider Lyubashevky’s three-message identification protocol <em>[x19]</em>, which can be seen as a lattice analogue to the Schnorr protocol.</p>

    <p class="text-gray-300">To sample an instance for the protocol, we sample a uniformly random wide matrix <span class="math">\\mathbf{A}</span> over <span class="math">\\mathbb{Z}_{q}</span> along with a wide matrix <span class="math">\\mathbf{R}</span> with random small entries. The shared instance is <span class="math">(\\mathbf{A},\\mathbf{Y}=\\mathbf{A}\\mathbf{R}\\mod q)</span>, and the prover’s goal is to convince the verifier it knows a short <span class="math">\\mathbf{R}</span> satisfying <span class="math">\\mathbf{A}\\mathbf{R}=\\mathbf{Y}\\mod q</span>.</p>

    <p class="text-gray-300">The interactive protocol <span class="math">\\Pi</span> then executes as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover samples a short vector <span class="math">\\mathbf{t}</span> and sends <span class="math">\\boldsymbol{\\alpha}\\coloneqq\\mathbf{A}\\mathbf{t}\\mod q</span>.</li>

      <li>The verifier responds by sending a random vector <span class="math">\\mathbf{c}</span> with small entries.</li>

      <li>The prover responds with <span class="math">\\mathbf{z}\\coloneqq\\mathbf{t}+\\mathbf{R}\\mathbf{c}</span>.</li>

      <li>The verifier accepts if <span class="math">\\mathbf{A}\\cdot\\mathbf{z}=\\boldsymbol{\\alpha}+\\mathbf{Y}\\cdot\\mathbf{c}\\mod q</span> and <span class="math">\\mathbf{z}</span> is short.</li>

    </ul>

    <p class="text-gray-300">As in <em>[x19]</em>, this interactive protocol is average-case sound under the SIS assumption. We now analyze the non-interactive protocol <span class="math">\\Pi_{\\mathrm{FS},\\mathbf{h}}</span> for a (vector-valued) Fiat-Shamir hash function <span class="math">\\mathbf{h}</span>. A malicious prover attacking the average-case soundness of <span class="math">\\Pi_{\\mathrm{FS},\\mathbf{h}}</span> must solve the following problem.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: Random matrices <span class="math">(\\mathbf{A},\\mathbf{Y})</span> and the description of a (vector-valued) hash function <span class="math">\\mathbf{h}</span>.</li>

      <li>Output: Vectors <span class="math">\\boldsymbol{\\alpha},\\mathbf{z}</span> such that <span class="math">\\mathbf{A}\\cdot\\mathbf{z}=\\boldsymbol{\\alpha}+\\mathbf{Y}\\cdot\\mathbf{h}(\\boldsymbol{\\alpha})\\mod q</span> and <span class="math">\\mathbf{z}</span> is short.</li>

    </ul>

    <p class="text-gray-300">Our main insight is that this problem is provably hard for a fixed Fiat-Shamir hash function <span class="math">\\mathbf{h}</span> if simple information-theoretic conditions are satisfied.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 2.1.</h6>

    <p class="text-gray-300">Suppose <span class="math">\\mathbf{h}</span> satisfies the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{h}</span> produces “short” output, i.e, the entries are small relative to the modulus</li>

      <li><span class="math">\\boldsymbol{\\alpha}</span> is a linear function of <span class="math">\\mathbf{h}(\\boldsymbol{\\alpha})</span>, i.e. there exists a matrix <span class="math">\\mathbf{G}</span> such that for all <span class="math">\\boldsymbol{\\alpha}</span>, <span class="math">\\mathbf{G}\\cdot\\mathbf{h}(\\boldsymbol{\\alpha})=\\boldsymbol{\\alpha}\\mod q</span>.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">\\Pi_{\\mathrm{FS},\\mathbf{h}}</span> is one-time (average-case) sound.</p>

    <p class="text-gray-300">Theorem 2.1 can be proved as follows. If the condition in Theorem 2.1 are satisfied, then the relation <span class="math">\\mathbf{A}\\cdot\\mathbf{z}-\\boldsymbol{\\alpha}-\\mathbf{Y}\\cdot\\mathbf{h}(\\boldsymbol{\\alpha})=\\mathbf{0}\\mod q</span> checked by the verifier can be rewritten as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left[\\mathbf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Y}+\\mathbf{G}\\right]\\cdot\\begin{bmatrix}\\mathbf{z}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">-\\mathbf{h}(\\boldsymbol{\\alpha})\\end{bmatrix}=\\mathbf{0}\\mod q. \\] (1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\mathbf{A},\\mathbf{Y}</span> are (statistically) uniformly random and <span class="math">\\mathbf{z},\\mathbf{h}(\\boldsymbol{\\alpha})</span> are short, a malicious prover outputting <span class="math">\\boldsymbol{\\alpha},\\mathbf{z}</span> is solving SIS for the random matrix $[\\mathbf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Y}+\\mathbf{G}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A simple concrete instantiation of <span class="math">\\mathbf{h}</span> is the bit-decomposition function that maps (vectors of) <span class="math">\\mathbb{Z}_{q}</span> elements to (the concatenation of) their bit decomposition in <span class="math">\\{0,1\\}^{\\lceil\\log q\\rceil}</span> (also called <span class="math">\\mathbf{G}^{-1}(\\cdot)</span> in the lattice literature). The corresponding <span class="math">\\mathbf{G}</span> is the “powers-of-two” gadget matrix of Micciancio-Peikert <em>[x20]</em>.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Extensions.</h4>

    <p class="text-gray-300">In Section 4, we study several variants of <span class="math">\\Pi</span> for the purposes of handling security against the <em>verifier</em> (e.g., zero-knowledge):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In its most basic variant, we instantiate <span class="math">\\Pi</span> using noise flooding to ensure (single-theorem) zero-knowledge in the common random string (CRS) model. This gives a conceptually simple protocol closely related to the Schnorr protocol over groups, but at the cost of being less practically efficient. We note that to obtain zero-knowledge, we require a <em>family</em> of hash functions indexed by the CRS (although soundness can be argued for deterministic hash functions).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We also consider more efficient protocols that use rejection sampling <em>[x19, x18, x17]</em>, where the prover aborts the execution of the protocol with some probability to ensure that the transcript is independent of his secret. Those protocols are in the plain model, but only guarantee witness indistinguishability. Note that because the prover has to run his algorithm several times in his head until it does not abort, the resulting non-interactive protocol is not directly the result of applying the Fiat-Shamir heuristic as is, but rather a “Fiat-Shamir with aborts” <em>[x18]</em>.</li>

    </ul>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Connections to Lattice Signatures from Lattice Trapdoors.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Interestingly, it turns out the honest prover algorithm of the rejection sampling-based protocol <em>exactly</em> matches the trapdoor preimage sampling algorithm of Lyubashevsky-Wichs <em>[x20]</em> using a Micciancio-Peikert trapdoor <em>[x22]</em>. This can be seen by considering Eq. (1), which implies that the transcript of the protocol gives a short preimage of <span class="math">\\mathbf{0}</span> of a matrix with a Micciancio-Peikert trapdoor (here <span class="math">\\mathbf{R}</span>). Average-case soundness implies that this should be hard to do without knowledge of <span class="math">\\mathbf{R}</span> (further using that $[\\mathbf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}\\mathbf{R}+\\mathbf{G}]<span class="math"> looks uniformly random over the randomness of </span>\\mathbf{R}<span class="math">), and witness-indistinguishability implies that the preimage sampling algorithm reveals no more information about the trapdoor </span>\\mathbf{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In fact, our protocol shows the connection between seemingly orthogonal paths to obtain signatures from lattice-based assumptions: one relying on lattice trapdoors and trapdoor preimage sampling <em>[x13, x20, x21]</em> and another through Fiat-Shamir <em>[x19, x18, x17]</em>. The lattice signature schemes constructed from lattice trapdoors <em>[x13, x20, x21]</em> can actually be <em>derived</em> by applying the Fiat-Shamir heuristic (with aborts) using the bit-decomposition function (namely <span class="math">\\mathbf{G}^{-1}(\\cdot)</span>) as the hash function to Lyubashevsky’s three-message identification scheme <em>[x17]</em>. Let us start by describing the signature scheme for signing a short random message <span class="math">\\mathbf{v}\\in\\mathbb{Z}_{q}^{n}</span>. The Fiat-Shamir hash function takes as input the first message <span class="math">\\boldsymbol{\\alpha}</span> from the protocol, and the message <span class="math">\\mathbf{v}</span>, and outputs</p>

    <p class="text-gray-300"><span class="math">h(\\boldsymbol{\\alpha},\\mathbf{v})=\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}-\\mathbf{v}).</span></p>

    <p class="text-gray-300">The signature consists of the challenge <span class="math">\\mathbf{c}=\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}-\\mathbf{v})</span> and <span class="math">\\mathbf{z}</span> from the third message of the protocol. The verifier of the signature takes <span class="math">\\mathbf{v}</span> and its signature, and accepts if <span class="math">\\mathbf{A}\\cdot\\mathbf{z}=\\boldsymbol{\\alpha}+\\mathbf{Y}\\cdot\\mathbf{c}\\mod q</span> and <span class="math">\\mathbf{z}</span> is short, that is:</p>

    <p class="text-gray-300">\\[ [\\mathbf{A}\\parallel\\mathbf{G}+\\mathbf{Y}]\\begin{bmatrix}\\mathbf{z}\\\\ -\\mathbf{c}\\end{bmatrix}=\\mathbf{v}\\pmod{q}. \\] (2)</p>

    <p class="text-gray-300">We now argue that this gives a signature scheme for random (short) messages, where the adversary can receive signature of random messages, and seeks to forge a signature for a random message given by the challenger. To handle signing queries, one can sample <span class="math">(\\mathbf{z},\\mathbf{c})</span>, and set the message as <span class="math">\\mathbf{v}=[\\mathbf{A}\\parallel\\mathbf{G}+\\mathbf{Y}]\\begin{bmatrix}\\mathbf{z}\\\\ -\\mathbf{c}\\end{bmatrix}</span>.</p>

    <p class="text-gray-300">Then, the hardness of signing a random message <span class="math">\\mathbf{v}</span> is then equivalent to breaking the SIS problem for a random target <span class="math">\\mathbf{v}</span>.</p>

    <p class="text-gray-300">To sign an arbitrary long message <span class="math">\\mu</span>, we replace <span class="math">\\mathbf{v}</span> in the previous protocol by <span class="math">H(\\mu)</span> where <span class="math">H</span> is a random oracle. This exaclty recovers the trapdoor-based lattice signatures <em>[x13, x20, x21]</em> in the random oracle model. We stress that here, the only purpose of the random oracle is to compress the message (in a hash-and-sign manner), as opposed to collapse an interactive protocol. In particular the Fiat-Shamir hash function is still the non-cryptographic <span class="math">\\mathbf{G}^{-1}</span> function.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">2.2 Fiat-Shamir for Schnorr in the Generic Group Model.</h3>

    <p class="text-gray-300">The following section on the generic group model (GGM) contains a number of technical arguments, designed to motivate and provide intuition for our group-based results. We provide a roadmap for the discussion:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First we explain why Fiat-Shamir for Schnorr is secure in the (plain) GGM, even for simple, information-theoretic hash functions. We start with the case of “no-message” signatures (non-interactive identification) and then extend our reasoning to handle messages and signing queries.</li>

    </ol>

    <p class="text-gray-300">We remark that our security claims for Schnorr in the <em>plain</em> GGM could have been proven using prior analysis of <em>[x20]</em>. However, we have two reasons for “re-doing” the analysis here: (1) our goal is to provide clear intuition tailored to <em>information-theoretic</em> Fiat-Shamir hash functions, and (2) our analysis will readily extend to the auxiliary-input setting, which we motivate next.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We will demonstrate that for Schnorr signatures, a (plain) GGM security proof does not capture a class of non-uniform attacks that work on <em>any concrete group</em>. In fact, we show that for common groups such as <span class="math">\\mathbb{Z}_{p}^{*}</span>, these attacks do not even require non-uniform advice.</li>

      <li>We address these issues by extending our analysis to hold in the <em>auxiliary-input</em> GGM, albeit for a slightly more restricted class of Fiat-Shamir hash functions. We show this class still contains simple, information-theoretic hash functions, and we discuss potential implications of these results.</li>

    </ol>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Non-Interactive Identification in the Generic Group Model.</h5>

    <p class="text-gray-300">We begin by considering the classic Schnorr protocol for proving knowledge of a discrete logarithm. Recall that the protocol relies on a cryptographic group <span class="math">G=\\langle g\\rangle</span> of prime order <span class="math">p</span>. The prover and verifier share an instance <span class="math">g^{u}</span> for a random <span class="math">u</span> known to the honest prover, and engage in the following interaction:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover samples a random <span class="math">r\\leftarrow\\mathbb{Z}_{p}</span> and sends <span class="math">g^{r}</span>.</li>

      <li>The verifier replies with a random <span class="math">c\\leftarrow\\mathbb{Z}_{p}</span>.</li>

      <li>The prover sends <span class="math">z=r+cu</span>.</li>

      <li>The verifier accepts if <span class="math">g^{z}=(g^{r})(g^{u})^{c}</span>.</li>

    </ul>

    <p class="text-gray-300">To build intuition, we will try to construct a (one-time secure) non-interactive identification scheme using a simple Fiat-Shamir hash function. In a moment, we will extend this (to handle messages and signing queries) to build full-fledged digital signatures.</p>

    <p class="text-gray-300">For a Fiat-Shamir hash function <span class="math">h</span>, a malicious prover for the non-interactive Schnorr protocol must solve the following problem.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: A group description <span class="math">G=(g,p)</span>, a hash function <span class="math">h:G\\rightarrow\\mathbb{Z}_{p}</span>, and a random group element <span class="math">g^{u}</span>.</li>

      <li>Output: <span class="math">g^{r},z</span> satisfying <span class="math">g^{z}=(g^{r})(g^{u})^{h(g^{r})}</span>.</li>

    </ul>

    <p class="text-gray-300">We want to identify simple choices of <span class="math">h</span> that make this problem hard in the GGM. However, it will be illuminating to instead identify which choices of <span class="math">h</span> will make this problem <em>easy</em>.</p>

    <p class="text-gray-300">This problem is clearly easy if <span class="math">h</span> is a constant function, i.e. <span class="math">h(g^{x})=c</span> for all <span class="math">g^{x}</span>; the malicious prover could always win by outputting <span class="math">z=0</span> and <span class="math">g^{r}=((g^{u})^{c})^{-1}=g^{-uc}</span>. Taking this a step further, we can argue that for any constant <span class="math">c\\in\\mathbb{Z}_{p}</span>, the hash function <span class="math">h</span> should not output <span class="math">c</span> on a <span class="math">1/\\text{poly}(\\lambda)</span> fraction of its inputs. Otherwise, a malicious prover can pick a random <span class="math">z</span> and set <span class="math">g^{r}=g^{-uc+z}</span>. Since <span class="math">g^{r}</span> is distributed randomly, <span class="math">h(g^{r})=c</span> holds with <span class="math">1/\\text{poly}(\\lambda)</span> probability, in which case <span class="math">z,g^{-uc+z}</span> is a solution.</p>

    <p class="text-gray-300">Put another way, as long as the min-entropy of <span class="math">h</span> on a random input is <span class="math">O(\\log(\\lambda))</span>, the above is a completely generic method (i.e. one that works on any cyclic group) for breaking the resulting non-interactive protocol.</p>

    <p class="text-gray-300">It turns out that this simple class of <span class="math">h</span> — those functions which, on random inputs, produce a low min-entropy output — are the <em>only</em> hash functions for which generic group algorithms (in the sense of Shoup <em>[x22]</em>) exist to solve the above problem. That is, all hash functions <span class="math">h</span> with super-logarithmic min-entropy can be proven to soundly compile non-interactive Schnorr in the GGM:</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 2.2.</h6>

    <p class="text-gray-300">In the generic group model (GGM), the non-interactive Schnorr protocol is one-time secure provided <span class="math">h(\\cdot)</span> on a random input has entropy <span class="math">\\omega(\\log\\lambda)</span>.</p>

    <p class="text-gray-300">Recall that in the generic group model, group elements <span class="math">g^{x}</span> are replaced by labels <span class="math">\\sigma(x)</span> where <span class="math">\\sigma</span> is a random injection from <span class="math">\\mathbb{Z}_{p}</span> to an exponentially-larger label space <span class="math">[L]</span> (say of size <span class="math">\\Omega(p^{3})</span>, where <span class="math">p</span> itself is a <span class="math">\\lambda</span>-bit prime). The attacker interacts with an oracle (who knows the truth table of <span class="math">\\sigma</span>) to perform honest group operations</p>

    <p class="text-gray-300">such as raising a group element to a known exponent, performing the group operation on any two group elements, and taking the inverse.</p>

    <p class="text-gray-300">In this model, the only way an attacker can output a valid group label <span class="math">\\sigma(r)</span> is to obtain this label from oracle queries (with overwhelming probability, any other label it might choose to output will not have a preimage). Furthermore, if the attacker is initialized with <span class="math">\\sigma(1),\\sigma(u)</span> for random <span class="math">u\\leftarrow\\mathbb{Z}_{p}</span>, then any label it obtains from the oracle is of the form <span class="math">\\sigma(\\alpha\\cdot u+\\beta)</span>, where <span class="math">\\alpha,\\beta</span> can be determined from prior oracle queries. In other words, the attacker must “know” <span class="math">\\alpha</span> and <span class="math">\\beta</span>.</p>

    <p class="text-gray-300">The attacker is trying to find <span class="math">z</span> along with <span class="math">\\sigma(r)</span> such that <span class="math">z=r+u\\cdot h(\\sigma(r))</span>. But the attacker knows <span class="math">\\alpha</span> and <span class="math">\\beta</span> such that <span class="math">r=\\alpha\\cdot u+\\beta</span>, so this equation can be written as <span class="math">z=\\alpha\\cdot u+\\beta+u\\cdot h(\\sigma(\\alpha\\cdot u+\\beta))</span>. If <span class="math">\\alpha+h(\\sigma(\\alpha\\cdot u+\\beta))\\neq 0</span>, then the attacker can solve for <span class="math">u</span>. However, this means the attacker has found a discrete log, which it can only do with negligible probability <em>[x18]</em>.</p>

    <p class="text-gray-300">Therefore, it must be the case that <span class="math">\\alpha+h(\\sigma(\\alpha\\cdot u+\\beta))=0</span>. However, the poly-query attacker only learns <span class="math">\\sigma(\\alpha\\cdot u+\\beta)</span> for poly-many choices of <span class="math">(\\alpha,\\beta)</span>, and for each distinct choice of <span class="math">(\\alpha,\\beta)</span>, the resulting label <span class="math">\\sigma(\\alpha\\cdot u+\\beta)</span> is random. <span class="math">h</span> evaluated on a random input has min-entropy <span class="math">\\omega(\\log(\\lambda))</span>, so the probability <span class="math">\\alpha+h(\\sigma(\\alpha\\cdot u+\\beta))=0</span> holds is negligible; a union bound over the polynomially-many <span class="math">(\\alpha,\\beta)</span> oracle queries completes the argument.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Schnorr Signatures in the Generic Group Model.</h4>

    <p class="text-gray-300">We now consider a slightly more difficult task: compiling Schnorr’s identification protocol into a digital signature scheme with existential unforgeability against chosen-message attacks (EUF-CMA security).</p>

    <p class="text-gray-300">Note that the semantics of the hash function itself are now different: the standard Fiat-Shamir compiler for signatures takes as input a message <span class="math">m\\in\\mathcal{M}</span> to be signed (in addition to the first message of the interactive protocol), i.e. <span class="math">h:G\\times\\mathcal{M}\\rightarrow\\mathbb{Z}_{p}</span>. For the purposes of this technical overview, we will restrict to the case where <span class="math">\\mathcal{M}</span> is a poly<span class="math">(\\lambda)</span>-size set. We stress that a restriction to only signing “short” messages will be crucial to the following discussion.</p>

    <p class="text-gray-300">Furthermore, the EUF-CMA security experiment requires security in the presence of an unbounded number of signing queries. So the EUF-CMA attacker must solve following task:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: A group description <span class="math">G=(g,p)</span>, a hash function <span class="math">h:G\\times\\mathcal{M}\\rightarrow\\mathbb{Z}_{p}</span>, and a random group element <span class="math">g^{u}</span>.</li>

      <li>Oracle Queries: The attacker is free to make an unbounded number of queries to a signing oracle who knows <span class="math">u</span>. It submits any <span class="math">m\\in\\mathcal{M}</span>, the signing oracle samples a random <span class="math">r\\leftarrow\\mathbb{Z}_{p}</span>, computes <span class="math">z=r+h(g^{r},m)\\cdot u</span>, and returns the signature <span class="math">(g^{r},z)</span>.</li>

      <li>Output: Any <span class="math">(m^{<em>},(g^{r^{</em>}},z^{<em>}))</span> where <span class="math">m^{</em>}\\in\\mathcal{M}</span> satisfying <span class="math">g^{z^{<em>}}=(g^{r^{</em>}})(g^{u})^{h(g^{r^{<em>}},m^{</em>})\\cdot u}</span> that was not the result of a signing query.</li>

    </ul>

    <p class="text-gray-300">We would like to identify a class of hash functions <span class="math">h</span> for which this problem is hard, and as in the previous section, we will start by identifying choices of <span class="math">h</span> that make this problem easy.</p>

    <p class="text-gray-300">Suppose that <span class="math">h</span> has the following undesirable property: for some choice of <span class="math">m\\in\\mathcal{M}</span>, the random variable obtained by sampling random <span class="math">g^{r}\\leftarrow G</span> and outputting <span class="math">h(g^{r},m)</span> has min-entropy <span class="math">O(\\log\\lambda)</span>. In this case, breaking EUF-CMA security can be done efficiently without any signing queries. Let <span class="math">c\\in\\mathbb{Z}_{p}</span> be such that <span class="math">h(g^{r},m)=c</span> holds with noticeable probability (guaranteed to exist by the low min-entropy property). The attack is to a uniformly random value <span class="math">z\\leftarrow\\mathbb{Z}_{p}</span>, and then compute <span class="math">g^{r}=g^{-uc+z}</span>. Since <span class="math">g^{r}</span> is randomly distributed, then <span class="math">h(g^{r},m)=c</span> with noticeable probability, and the resulting <span class="math">(g^{r},z)</span> constitutes a valid signature on <span class="math">m</span>. To prevent this attack, we must require that for all <span class="math">m\\in\\mathcal{M}</span>, the random variable <span class="math">h(g^{r},m)_{g^{r}\\leftarrow G}</span> has min-entropy <span class="math">\\omega(\\log\\lambda)</span>.</p>

    <p class="text-gray-300">Another undesirable property of <span class="math">h</span> is the following: suppose for some choice of distinct <span class="math">m,m^{\\prime}\\in\\mathcal{M}</span>, the random variable <span class="math">(\\chi_{h(g^{r},m)=h(g^{r},m^{\\prime})})_{g^{r}\\leftarrow G}</span> (where <span class="math">\\chi_{x=y}</span> is the indicator function that equals 1 if <span class="math">x=y</span> and</p>

    <p class="text-gray-300">0 otherwise) has noticeable expected value, i.e. <span class="math">h(g^r,m) = h(g^r,m&#x27;)</span> occurs with noticeable probability. If <span class="math">h</span> satisfies this property, there is a straightforward attack using one signing query: the attacker queries on <span class="math">m</span>, learns a random valid signature <span class="math">(g^r,z)</span>, and then submits <span class="math">(m&#x27;,(g^r,z))</span> as its forgery. Since the signing oracle provides a randomly generated valid signature (i.e. <span class="math">g^r</span> is random in <span class="math">G</span>), the Fiat-Shamir challenge for the <span class="math">m</span> and <span class="math">m&#x27;</span> executions will be identical with noticeable probability, meaning the signature <span class="math">(g^r,z)</span> for <span class="math">m</span> is a valid signature for <span class="math">m&#x27;</span> with noticeable probability. To prevent this attack, we must require that for all distinct <span class="math">m,m&#x27; \\in \\mathcal{M}</span>, the random variable <span class="math">(\\chi_{h(g^r,m) = h(g^r,m&#x27;)} )_{g^r \\gets G}</span> has negligible expectation.</p>

    <p class="text-gray-300">To recap, we have the following minimum requirements on <span class="math">h</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">m \\in \\mathcal{M}</span>, we the min entropy of <span class="math">h(g^{r},m)_{g^{r}\\gets G}</span> is <span class="math">\\omega (\\log \\lambda)</span>.</li>

      <li>For all distinct <span class="math">m, m&#x27; \\in \\mathcal{M}</span>, we have <span class="math">E_{g^r \\gets G}[(\\chi_{h(g^r, m) = h(g^r, m&#x27;)}]) \\leq \\mathrm{negl}(\\lambda)</span>.</li>

    </ol>

    <p class="text-gray-300">It turns out that these minimum requirements on <span class="math">h</span> are sufficient to guarantee EUF-CMA security of Schnorr in the GGM:</p>

    <p class="text-gray-300"><strong>Theorem 2.3.</strong> Suppose <span class="math">\\mathcal{M} \\subset \\mathbb{Z}_p</span> and <span class="math">\\mathcal{M} = \\mathrm{poly}(\\lambda)</span>. Let <span class="math">h: G \\times \\mathcal{M} \\to \\mathbb{Z}_p</span> be any function satisfying conditions (1) and (2) above. Then the resulting Schnorr signature scheme is EUF-CMA secure in the generic group model.</p>

    <p class="text-gray-300">We first note that our proof of Theorem 2.2 implies that an attacker cannot generate a valid forgery before it has received any signing queries. That is, given <span class="math">\\sigma(u)</span>, the attacker cannot output <span class="math">(m^{<em>}, (\\sigma(r^{</em>}), z^{<em>}))</span> where <span class="math">m^{</em>} \\in \\mathcal{M}</span> and <span class="math">z^{<em>} = r^{</em>} + h(\\sigma(r^{<em>}), m^{</em>}) \\cdot u</span>. To see this, note that for any fixed <span class="math">m</span>, the hash function <span class="math">h(\\cdot, m)</span> satisfies the same min-entropy property required for non-interactive identification (by condition (1) on <span class="math">h</span>). A union bound over <span class="math">\\mathcal{M}</span> implies the attacker cannot provide a forgery for any <span class="math">m</span>.</p>

    <p class="text-gray-300">Given this analysis, we prove Theorem 2.3 in two steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1: Generate signing queries without knowledge of <span class="math">u</span>. In this step, we write down a hybrid experiment in which the adversary's view has no explicit dependence on the discrete logarithm <span class="math">u</span>. We accomplish this by instead programming the group oracle.</li>

    </ul>

    <p class="text-gray-300">In more detail, when signing queries are answered honestly, the adversary receives <span class="math">(\\sigma(r), r + u \\cdot h(\\sigma(r), m))</span>. However, these signing queries can be simulated in the following way:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a random label <span class="math">\\ell \\gets [L]</span></li>

      <li>Sample a random exponent <span class="math">z \\gets \\mathbb{Z}_p</span>.</li>

      <li>Program the value <span class="math">\\sigma(z_i - x \\cdot h(\\ell, m)) = \\ell</span>. If the oracle <span class="math">\\sigma</span> was already programmed at <span class="math">\\ell</span>, abort.</li>

      <li>Output the signature <span class="math">(\\ell, z, m)</span></li>

    </ul>

    <p class="text-gray-300">Moreover, this gives us an implicit representation of the group element corresponding to label <span class="math">\\ell</span> as a publicly known linear combination of <span class="math">g^u</span> and <span class="math">g</span>, namely, <span class="math">(g^z \\cdot (g^u)^{-h(\\ell, m)})</span>. These group elements will all be distinct with high probability over the choice of <span class="math">u</span>.</p>

    <p class="text-gray-300">Essentially, this simulated experiment is indistinguishable from the real security game as long as the programmed values <span class="math">\\sigma(z_i - u \\cdot h(\\ell, m)))</span> do not contradict any of the adversary's previous queries to the group oracle. One can show that the probability of this is negligible because of the randomness of <span class="math">u</span> according to the adversary's view. This is effectively an invocation of the generic group hardness of computing discrete logs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 2: Invoke the statistical properties of <span class="math">h</span>. Now that we have simulated all of the signature queries, we consider a potential forgery <span class="math">(\\sigma(r^{<em>}), z^{</em>} = r^{<em>} + u \\cdot h(\\sigma(r^{</em>}), m^{<em>}), m^{</em>})</span> and break into two cases.</li>

    </ul>

    <p class="text-gray-300">This is the characterization for the case</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">. For larger message spaces (that still satisfy</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ p \\leq \\mathrm{negl}(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">), the requirements are mildly strengthened: we require that (1) for all targets c \\in \\mathbb{Z}_p , the probability over a random choice of r that h(g^r, m) = c for any m is negligible, and that for any m \\in \\mathcal{M} , the probability over a random choice of r that h(g^r, m') = h(g^r, m) for any m' is negligible (i.e., we reversed an order of quantifiers in each requirement). These are exactly information-theroetic analogues of the RPP and RPSP properties defined in [NSW09].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\ell^{<em>}:=\\sigma(r^{</em>})</span> matches one of the signing queries. In this case, we claim that a forgery allows us to compute the discrete logarithm <span class="math">u</span>. Indeed, this is because we have a signing query equation of the form</li>

    </ul>

    <p class="text-gray-300"><span class="math">z=r^{<em>}+h(\\ell^{</em>},m)u</span></p>

    <p class="text-gray-300">and a forgery equation of the form</p>

    <p class="text-gray-300"><span class="math">z^{<em>}=r^{</em>}+h(\\ell^{<em>},m^{</em>})u.</span></p>

    <p class="text-gray-300">Moreover, the two hash values <span class="math">(h(\\ell^{<em>},m),h(\\ell^{</em>},m^{<em>}))</span> must be distinct because (1) the marginal distribution on <span class="math">\\ell^{</em>}</span> is random, and (2) we assumed that for a random <span class="math">\\ell^{<em>}</span>, there will not exist an <span class="math">h</span>-collision with prefix <span class="math">\\ell^{</em>}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: <span class="math">\\ell^{*}</span> does not match any signing query. In this case, we also claim that a forgery allows us to compute the discrete logarithm <span class="math">u</span>. Indeed, the forgery equation</li>

    </ul>

    <p class="text-gray-300"><span class="math">z^{<em>}=r^{</em>}+h(\\ell^{<em>},m^{</em>})u</span></p>

    <p class="text-gray-300">along with the adversary’s implicit representation of the exponent</p>

    <p class="text-gray-300"><span class="math">r^{*}=\\alpha+\\beta u</span></p>

    <p class="text-gray-300">(which follows from the fact that the advesary’s view can be computed generically given only <span class="math">g^{u}</span>) implies that</p>

    <p class="text-gray-300"><span class="math">z^{<em>}=\\alpha+(\\beta+h(\\ell^{</em>},m^{*}))u.</span></p>

    <p class="text-gray-300">Then, either <span class="math">\\beta+h(\\ell^{<em>},m^{</em>})\\neq 0</span>, in which case the adversary can indeed compute <span class="math">u</span>, or <span class="math">\\beta+h(\\ell^{<em>},m^{</em>})=0</span>. We claim that the high min-entropy of <span class="math">h(\\ell,m)</span> for <em>random</em> <span class="math">\\ell</span> implies that this event is unlikely. Indeed, <span class="math">\\ell^{<em>}</span> must have been obtained by </em>some* group oracle query, so this follows by a union bound over all group oracle queries made by the adversary.</p>

    <p class="text-gray-300">This completes our proof sketch of Theorem 2.3.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Preprocessing Attacks.</h4>

    <p class="text-gray-300">We next show how the <em>[x20]</em> characterization of Schnorr signature security in the GGM fails to capture security in concrete groups. Since the attacks that we discover fall into the framework of the auxiliary-input GGM <em>[x22, x11]</em>, we then analyze Schnorr signatures in this stronger adversary model.</p>

    <p class="text-gray-300">We first describe an attack in the case of Schnorr signatures for short messages, using the hash function <span class="math">h(g^{r},m)=g^{r}+m\\pmod{p}</span> over the group <span class="math">G=\\mathbb{Z}_{p}^{\\times}</span>. We showed above that this signature scheme is secure in the generic group model, but we will nonetheless give an attack over <span class="math">\\mathbb{Z}_{p}^{\\times}</span>.</p>

    <p class="text-gray-300">In order to have a well-specified protocol, we need to fix a mapping <span class="math">\\operatorname{Int}:G\\to\\mathbb{Z}</span> from group elements to integers. For simplicity, we choose our mapping so that <span class="math">R\\in\\mathbb{Z}_{p}^{\\times}</span> maps to the unique integer <span class="math">a\\in[-\\frac{p-1}{2},\\frac{p-1}{2}]</span> such that <span class="math">R\\equiv a\\pmod{p}</span>.</p>

    <p class="text-gray-300">The attack proceeds as follows: we are given a random group element <span class="math">g^{u}</span> and want to output <span class="math">m,g^{r},z</span> satisfying <span class="math">g^{z}=(g^{r})(g^{u})^{\\operatorname{Int}(g^{r})+m}</span>. We do this by picking <span class="math">r,m</span> such that <span class="math">\\operatorname{Int}(g^{r})+m=0\\pmod{p-1}</span> and then setting <span class="math">r=z</span>. So, for example, if the message space <span class="math">\\mathcal{M}</span> contains <span class="math">m=p-2</span>, then we can pick <span class="math">r=0</span>, so that <span class="math">g^{r}\\equiv 1\\pmod{p}</span> and <span class="math">1+p-2\\equiv 0\\pmod{p-1}</span>. This choice is by no means special; if <span class="math">1\\in\\mathcal{M}</span>, then we can pick <span class="math">r=\\frac{p-1}{2}</span> and obtain another forgery.</p>

    <p class="text-gray-300">This strategy readily generalizes to groups beyond <span class="math">\\mathbb{Z}_{p}^{\\times}</span>: for a cyclic group <span class="math">G</span> of order <span class="math">p</span>, all that is required to produce a forgery is knowledge of an exponent <span class="math">r\\in\\mathbb{Z}_{p}</span> and a message <span class="math">\\mu\\in\\mathcal{M}\\subset\\mathbb{Z}_{p}</span> such that <span class="math">\\operatorname{Int}(g^{r})=-\\mu\\pmod{p}</span>. It also generalizes to the case of full Schnorr signatures over <span class="math">G</span>, using hash functions of the form <span class="math">h(g^{r},m)=\\operatorname{Int}(g^{r})+H(m)</span> for a collision-resistant hash function <span class="math">H</span>. One can check that the</p>

    <p class="text-gray-300">h function (family) <span class="math">h</span> satisfies the hypotheses of <em>[x20]</em>, so Schnorr signatures using <span class="math">h</span> are secure in the GGM. However, if <span class="math">G</span> has a known equation of the form</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Int}(g^{r})=-\\mu,</span></p>

    <p class="text-gray-300">and <span class="math">H</span> additionally satisfies <span class="math">H(0)=\\mu</span> (which can be arranged without sacrificing collision resistance by hard-coding this value into a hash function <span class="math">H</span> whose range excludes <span class="math">\\mu</span>), then again <span class="math">(r,r)</span> is a valid signature. Thus, we see that for every group <span class="math">G</span> with some hard-coded equation <span class="math">\\operatorname{Int}(g^{r})=-\\mu</span>, there exists a hash family <span class="math">h</span> satisfying the <em>[x20]</em> hypotheses which leads to an <em>insecure</em> instantiation of Schnorr signatures.</p>

    <p class="text-gray-300">We now observe that one can view this attack as an attack in the <em>auxiliary-input generic group model</em>. The Aux-Input GGM is the following adversary model for some problem <span class="math">\\mathcal{P}</span> over a group <span class="math">G</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adversary is given the description of a group <span class="math">G</span> as a random injection from <span class="math">G\\to[L]</span> (i.e., the adversary is given the full truth tables of the group operation).</li>

      <li>The adversary then stores <span class="math">S</span> bits of information about this group <span class="math">G</span> (and forgets everything else).</li>

      <li>The adversary then receives an instance of <span class="math">\\mathcal{P}</span> (as characterized by a security game with a challenger). As in the GGM, the adversary can also query the group oracle.</li>

    </ul>

    <p class="text-gray-300">In other words, an aux-input GGM adversary is a GGM adversary that is augmented with some <span class="math">S</span> bits of non-uniform advice about the group.</p>

    <p class="text-gray-300">Given this definition, it is easy to see that the attacks described above fall into the aux-input GGM. Indeed, as long as the adversary “remembers” one equation of the form <span class="math">\\operatorname{Int}(g^{r})=-\\mu</span> (of which many are guaranteed to exist), it will be able to execute an attack. Thus, one can view the attacks on <span class="math">\\mathbb{Z}_{p}^{\\times}</span> and other groups as the result of the following three-step process:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exist attacks on the schemes above in the auxiliary-input GGM. This means that for every concrete group <span class="math">G</span>, there exists a <em>non-uniform</em> attack on the scheme.</li>

      <li>In the case of specific groups such as <span class="math">\\mathbb{Z}_{p}^{\\times}</span>, the non-uniform advice necessary to carry out the attack can be computed efficiently given the group description.</li>

    </ul>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Security in the Aux-Input GGM.</h4>

    <p class="text-gray-300">Given the existence of preprocessing attacks as above, in order to have confidence in the <em>concrete</em> security of a Schnorr signature scheme using hash family <span class="math">h</span>, it is necessary to prove security in the auxiliary-input GGM.</p>

    <p class="text-gray-300">Just as in the case of our GGM lower bounds, we give a characterization of hash functions (and hash function families) <span class="math">h</span> that lead to secure Schnorr signatures in the auxiliary-input GGM. We state a special case of our result (Theorem 5.12) for the purposes of this overview.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 2.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{M}\\subset\\mathbb{Z}_{p}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\mathbb{Z}_{p}\\leq\\operatorname{negl}(\\lambda)<span class="math">. Suppose the (keyed) Fiat-Shamir hash function </span>H_{k}:[L]\\times\\mathcal{M}\\to\\mathbb{Z}_{p}$ satisfies the following properties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For any <span class="math">m\\in\\mathcal{M}</span>, <span class="math">h(g^{u},m)</span> has min-entropy $\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot\\log\\lambda<span class="math"> on a random </span>g^{u}\\leftarrow G$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero-avoidance: For any (stateful, potentially unbounded) adversary <span class="math">\\mathcal{A}</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[H_{k}(\\ell,m)=0\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\ell\\leftarrow\\mathcal{A}(1^{\\lambda}),k\\leftarrow\\mathcal{K},m\\leftarrow\\mathcal{A}(k)\\right]\\leq\\operatorname{negl}(\\lambda);$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then Schnorr signatures with Fiat-Shamir hash function <span class="math">H_{k}</span> are EUF-CMA secure in the AI-GGM against adversaries <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> with advice of size <span class="math">S=\\operatorname{poly}(\\lambda)</span>, <span class="math">T=\\operatorname{poly}(\\lambda)</span> oracle queries, <span class="math">Q=\\operatorname{poly}(\\lambda)</span> signing queries.</p>

    <p class="text-gray-300">The first of the two hypotheses is the same as in Theorem 2.3; the second rules out the preprocessing attacks described above. Similarly to before, Theorem 2.4 says that once these attacks are avoided, no further attacks in the Aux-Input GGM exist.</p>

    <p class="text-gray-300">We prove Theorem 2.4 (formally in Section 5.3) using the framework of <em>[x10]</em>, who show a rough equivalence between the auxiliary-input GGM and an a priori weaker adversary model called the bit-fixing GGM (BF-GGM). Informally, in the BF-GGM, instead of learning an arbitrary <span class="math">S</span> bits of information about a random group <span class="math">G</span>, the adversary can only remember the labels of <span class="math">P</span> group elements (and their corresponding exponents with respect to the canonical generator). In <em>[x10]</em>, it is shown that for any (efficient and generic) challenger-adversary game, security in the AI-GGM follows from security in the (ostensibly weaker) BF-GGM with a slight loss in parameters. We can apply this result directly to the soundness of Schnorr signatures, reducing our problem to proving a lower bound in the BF-GGM.</p>

    <p class="text-gray-300">Now, we can conveniently extend all of our GGM analysis (i.e., the proof of Theorem 2.3 to apply in the BF-GGM (and therefore to the AI-GGM via <em>[x10]</em>). The BF-GGM lower bound will look very similar to before:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1: Generate signing queries without knowledge of <span class="math">u</span>. We simulate signing queries in exactly the same way as before. Some care is required to argue that indistinguishability still holds, because the adversary additionally has access to a short list of hard-coded group labels.</li>

      <li>Step 2: Invoke the statistical properties of <span class="math">h</span>. We again consider a potential forgery <span class="math">(\\sigma(r^{<em>}),z^{</em>}=r^{<em>}+h(\\sigma(r^{</em>}),m^{<em>})u,m^{</em>})</span>. This time, we break into three cases:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 0: <span class="math">\\ell^{*}</span> appears in the adversary’s auxiliary information. This case is unique to the BF-GGM setting; however, the forgery equation</li>

    </ul>

    <p class="text-gray-300"><span class="math">z^{<em>}=r^{</em>}+h(\\ell^{*},m)u</span></p>

    <p class="text-gray-300">allows us to solve for <span class="math">u</span> unless <span class="math">h(\\ell^{*},m)=0</span>, which cannot happen (except with negligible probability) because we assumed that <span class="math">h</span> was <span class="math">0</span>-avoiding.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\ell^{<em>}:=\\sigma(r^{</em>})</span> matches one of the signing queries. This case matches our GGM analysis above.</li>

      <li>Case 2: <span class="math">\\ell^{*}</span> does not match any signing query. This case also matches our GGM analysis above.</li>

    </ul>

    <p class="text-gray-300">This completes our proof sketch of Theorem 2.4.</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Application: (Candidate) Simple Schnorr Signatures.</h5>

    <p class="text-gray-300">One takeaway of our analysis is that it might be possible that simple compilations of Schnorr signatures (for small message space) are secure. The appeal of such a signature scheme is that all of the operations are extremely simple, and can be implemented with random sampling and modular arithmetic. We stress that the only evidence we have for security is that this scheme resists generic preprocessing attacks, and that so far, we have been unable to leverage non-generic properties of <span class="math">\\mathbb{Z}_{p}^{\\times}</span> to break this scheme. Further analysis of this simple scheme is beyond the immediate scope of this work, and we strongly recommend against considering this scheme “secure” unless it withstands significant cryptanalytic effort.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Construction 2.5.</h6>

    <p class="text-gray-300">Consider the Schnorr signature scheme for group <span class="math">\\mathbb{Z}_{p}^{\\times}</span>, where the Fiat-Shamir hash function has random <span class="math">k\\leftarrow\\mathbb{Z}_{q}</span>, and outputs <span class="math">g^{r}+m+k(\\bmod\\ q)</span> on input <span class="math">(g^{r},m)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Group: <span class="math">\\mathbb{Z}_{p}^{\\times}</span> with a generator <span class="math">g</span> of a cyclic subgroup of order <span class="math">q</span>, where <span class="math">p=2q+1</span>.</li>

      <li>Message space: Any subset <span class="math">M\\subset\\mathbb{Z}_{q}</span> of <span class="math">\\operatorname{poly}(\\lambda)</span> size.</li>

      <li>Signing key: <span class="math">sk\\leftarrow\\mathbb{Z}_{q}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification key:  <span class="math">(k, g^{sk})</span>  where  <span class="math">k \\gets \\mathbb{Z}_q</span> .</li>

      <li>Sign(sk, m): Sample  <span class="math">r \\gets \\mathbb{Z}_q</span> . Let  <span class="math">z = r + (g^r + m + k) \\cdot sk(\\bmod q)</span> . Output  <span class="math">(g^r, z)</span> .</li>

      <li>Ver(vk,  <span class="math">m</span> ,  <span class="math">(g^r, z)</span> ): Accept if  <span class="math">g^z = g^r \\cdot (g^{sk})^{g^r + m + k} (\\bmod p)</span> .</li>

    </ul>

    <p class="text-gray-300">Extensions to Chaum-Pedersen and NIZKs for NP. Our analysis for Schnorr signatures in the AIGGM easily extends to prove semi-adaptive soundness of the Chaum-Pedersen protocol for proving validity of a Diffie-Hellman tuple. As the security analysis is extremely similar to our analysis for Schnorr, we defer this result (and its implications for NIZKs for NP) to Section 5.4.</p>

    <p class="text-gray-300">In this section, we give a simple example of a negative result that we can prove using our methods. In particular, we consider an idealized variant of Blum's Hamiltonicity protocol [Blu86] in which the commitment scheme is instantiated with a random oracle.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The Zero Knowledge Proof System  <span class="math">\\Pi^{\\mathrm{Blum}}</span>  for Graph Hamiltonicity.</p>

    <p class="text-gray-300">The Blum protocol  <span class="math">\\Pi = \\Pi^{\\mathrm{Blum}}</span>  is described in Fig. 1. For this example, we instantiate  <span class="math">\\mathsf{Com}(b;r) = \\mathcal{O}(b,r)</span>  as an idealized bitwise commitment scheme in the random oracle model.  <span class="math">\\Pi</span>  then is repeated  <span class="math">t</span>  times in parallel to obtain soundness error  <span class="math">2^{-t}</span> .</p>

    <p class="text-gray-300">At first glance, especially given our positive results for Schnorr and Chaum-Pedersen, one might hypothesize that since we have made the commitment scheme "super-secure", Fiat-Shamir for  <span class="math">\\Pi^t</span>  might be instantiable with a simple hash function  <span class="math">h</span> . In fact, we show that even for this idealized variant of the Blum protocol, a (successful) Fiat-Shamir hash function  <span class="math">h</span>  for this protocol necessarily satisfies a cryptographic security property.</p>

    <p class="text-gray-300">As discussed earlier, there are two variants of this result. First, we give a polynomial-query attack on  <span class="math">\\Pi_{\\mathrm{FS},h}^{t}</span>  for any hash function  <span class="math">h</span>  that does not invoke the random oracle  <span class="math">\\mathcal{O}</span> . Then, we extend this polynomial-query attack to a polynomial-time attack assuming the easiness of some computational problem depending on  <span class="math">h</span> .</p>

    <p class="text-gray-300">To understand our attack, we first consider an "obviously broken" choice of hash function  <span class="math">h</span> : define  <span class="math">h(\\alpha_1, \\ldots, \\alpha_t) = (f(\\alpha_1), \\ldots, f(\\alpha_t))</span>  to be a fixed function applied to each commitment separately. This corresponds to a parallel repetition of  <span class="math">\\Pi_{\\mathrm{FS}, f}</span> , which is the application of Fiat-Shamir to a protocol with constant soundness error. We know that such a non-interactive protocol is unsound via a reset attack: given an instance  <span class="math">G</span> , it is possible to prepare a commitment  <span class="math">\\alpha_1</span>  that can successfully answer either a "0" challenge or a "1" challenge. Therefore, if  <span class="math">\\alpha_1</span>  is prepared to answer the challenge  <span class="math">b</span>  (for a uniformly random bit  <span class="math">b</span> ), we have that  <span class="math">f(\\alpha_1) = b</span>  with probability  <span class="math">1/2</span>  (since  <span class="math">\\alpha_1</span>  hides  <span class="math">b</span> ) and so after an expected constant number of string commitment queries, we obtain an accepting transcript  <span class="math">(\\alpha_1, b_1, \\gamma_1)</span>  for the first repetition. This can be done for each "slot", giving a polynomial-query break of soundness for the overall protocol.</p>

    <p class="text-gray-300">To rephrase the attack, for our example choice of <span class="math">h</span>, if one prepares enough “fake commitments” <span class="math">\\{\\alpha^{(i)}_{1}\\}</span>, <span class="math">\\{\\alpha^{(i)}_{2}\\},\\ldots,\\{\\alpha^{(i)}_{t}\\}</span> for each of the <span class="math">t</span> repetitions, then with high probability, there exists a <em>combination</em> of the individual commitments that hashes to the “bad challenge” whose answer was generated along with the commitments. We show that the above argument generalizes to <em>all</em> hash functions <span class="math">h</span>. The poly-query attack is as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">1\\leq i\\leq t,1\\leq\\ell\\leq q</span>, sample a random bit <span class="math">y_{\\ell}^{(i)}\\leftarrow\\{0,1\\}</span> and sample message <span class="math">\\alpha_{\\ell}^{(i)}</span>: if <span class="math">y_{\\ell}^{(i)}=0</span>, sample <span class="math">\\alpha_{\\ell}^{(i)}</span> as in the honest protocol, while if <span class="math">y_{\\ell}^{(i)}=1</span>, and sample <span class="math">\\alpha_{i}^{(\\ell)}</span> as a commitment to a cycle graph.</li>

      <li>Find <span class="math">v\\in[q]^{t}</span> such that <span class="math">h(\\alpha[v])=y[v]</span>. Abort if no such <span class="math">v</span> exists.</li>

      <li>Output <span class="math">\\alpha[v]</span> as well as the necessary decommitments to <span class="math">\\alpha[v]</span> (either the entire graph or just the edges in the cycle).</li>

    </ol>

    <p class="text-gray-300">This constitutes a poly-query attack on the protocol <span class="math">\\Pi^{t}_{\\mathrm{FS},H}</span> in the random oracle model as long as Step (2) has a solution with high probability over <span class="math">(\\alpha,y)</span>. In the case <span class="math">h=(f,\\ldots,f)</span> as above, this condition follows immediately. We show in Section 6 (Lemma 6.1) that for <em>any</em> <span class="math">h</span>, as long as <span class="math">q=\\omega(t)</span>, Step (2) has a solution with high probability over <span class="math">(\\alpha,y)</span>.</p>

    <p class="text-gray-300">To obtain a (conditional) polynomial-<em>time</em> attack on the protocol, we note that if the solution to the problem in Step (2) can be found <em>efficiently</em>, then the above attack can be implemented in polynomial time.</p>

    <p class="text-gray-300">Crucially, the above analysis generalizes well because the computational problem in Step (2) does not depend on the protocol. We accomplish this by reducing breaking the soundness of <span class="math">\\Pi^{t}_{\\mathrm{FS},h}</span> to solving a “mix-and-match” problem of the following form: given many strings <span class="math">\\{\\alpha_{\\ell}^{(i)}\\}</span> (<span class="math">q</span> strings for each slot) which are each associated with a random bit <span class="math">b_{\\ell}^{(i)}</span>, find a concatenation <span class="math">\\alpha[v]</span> of <span class="math">t</span> different <span class="math">\\alpha_{\\ell}^{(i)}</span> (one for each slot) such that <span class="math">h(\\alpha[v])=b[v]</span> (the corresponding combination of bits). This motivates our definition of “mix-and-match resistance” Definition 6.8, a security property which captures the analogous problems for a wide class of protocols <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">While the analysis above is tailored to (parallel repeated) <span class="math">\\Pi^{\\mathrm{Blum}}</span>, it turns out that the argument only relies on a couple of (basic) properties of the protocol, namely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given a challenge <span class="math">\\beta</span>, it is possible to sample a (pseudorandom) first message <span class="math">\\alpha</span> along with an accepting response <span class="math">\\gamma</span> for <span class="math">\\alpha</span>, even when the statement <span class="math">x</span> is false. This property is used to construct a mix-and-match problem in our attack, and essentially follows from an <em>honest-verifier zero knowledge</em> property of the protocol.</li>

      <li>The protocol is obtained by applying parallel repetition to a protocol with <em>polynomial-size</em> challenge space. This independence property is enough to guarantee that the “mix-and-match” problem information-theoretically has a solution.</li>

    </ul>

    <p class="text-gray-300">We refer the reader to Section 6 for more details on the extent to which the result generalizes.</p>

    <h2 id="sec-43" class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300">In cryptography, the security parameter (denoted as <span class="math">\\lambda</span>) is a variable that is used to parameterize the computational complexity of the cryptographic algorithm or protocol, and the adversary’s probability of breaking security. An algorithm is “efficient” if it runs in (probabilistic) polynomial time over <span class="math">\\lambda</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{R},\\mathbb{Z},\\mathbb{N}</span> be the set of real numbers, integers and positive integers. For <span class="math">q\\in\\mathbb{N}_{\\geq 2}</span>, denote <span class="math">\\mathbb{Z}/q\\mathbb{Z}</span> by <span class="math">\\mathbb{Z}_{q}</span>. For <span class="math">n\\in\\mathbb{N}</span>, let <span class="math">[n]:=\\{1,...,n\\}</span>. A vector in <span class="math">\\mathbb{R}^{n}</span> (represented in column form by default) is written as a bold lower-case letter, e.g. <span class="math">\\mathbf{v}</span>. For a vector <span class="math">\\mathbf{v}</span>, the <span class="math">i^{th}</span> component of <span class="math">\\mathbf{v}</span> will be denoted by <span class="math">v_{i}</span>. A matrix is written as a bold capital letter, e.g. <span class="math">\\mathbf{A}</span>. We denote the transpose of a matrix <span class="math">\\mathbf{A}</span> (resp. of a vector <span class="math">\\mathbf{v}</span>) as <span class="math">\\mathbf{A}^{T}</span> (resp. <span class="math">(\\mathbf{v}^{T})</span>). For matrices <span class="math">\\mathbf{A},\\mathbf{B}</span>, we denote their horizontal concatenation as $[\\mathbf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B}]<span class="math">. The </span>i^{th}<span class="math"> column vector of </span>\\mathbf{A}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is denoted <span class="math">\\mathbf{a}_{i}</span>. The infinity norm of a vector <span class="math">\\mathbf{v}</span> is defined as $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}:=\\max_{i}\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">. When a variable </span>v<span class="math"> is drawn uniformly random from the set </span>S<span class="math"> we denote as </span>v\\leftarrow\\mathcal{U}(S)<span class="math"> or </span>v\\leftarrow S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-44" class="text-base font-medium mt-4">Definition 3.1 (Fiat-Shamir Transformation <em>[x10]</em>).</h6>

    <p class="text-gray-300">Given a three round public coin interactive protocol <span class="math">\\Pi</span>, the Fiat-Shamir transformation with hash function family <span class="math">\\mathcal{H}</span> (possibly a singleton) syntactically transform <span class="math">\\Pi</span> to a non-interactive protocol <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span> as follows. Sample <span class="math">h\\leftarrow\\mathcal{H}</span> and let <span class="math">h</span> be the common reference string. The prover in <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span> runs the prover in <span class="math">\\Pi</span> on <span class="math">h</span> to obtain the first message <span class="math">\\alpha</span>, then compute <span class="math">\\beta=h(\\alpha)</span>, then runs the prover in <span class="math">\\Pi</span> on <span class="math">h,\\alpha,h(\\alpha)</span> to obtain the third message <span class="math">\\gamma</span>. The prover in <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}</span> then outputs <span class="math">\\alpha,\\beta,\\gamma</span> as the proof.</p>

    <p class="text-gray-300">In the most common applications of the Fiat-Shamir transformation like constructing signature schemes or non-interactive protocols, it is crucial to include the strings under the adversary’s control in the input of the hash function (in addition to the first message <span class="math">\\alpha</span>). For example, the message <span class="math">m</span> in the signature schemes should be included in the input of the hash function (the hash function takes input <span class="math">(\\alpha,m)</span>); when considering protocols with adaptive soundness, the instance under the adversary’s choice should be included in the input of the hash function.</p>

    <p class="text-gray-300">The precise security properties for the non-interactive protocol vary in the applications. We will explicitly define them when needed.</p>

    <h2 id="sec-45" class="text-2xl font-bold">4 Lattice-based Identification Protocols</h2>

    <p class="text-gray-300">In this section, we describe our positive results in the lattice setting, where we compile common variants of the Lyubashevsky identification protocol using the bit-decomposition function as the Fiat-Shamir hash function.</p>

    <p class="text-gray-300">In Section 4.1, we recall some definitions and useful properties related to lattices. In Section 4.2, we show our main positive result concerning a basic Lyubashevsky variant and Fiat-Shamir. In Section 4.3, we show a connection between the construction of Section 4.2 and trapdoor preimage sampling algorithms <em>[x22, x23]</em>. In Section 4.4, we show how to extend our techniques to protocols based on LWE rather than SIS. In Section 4.5, we analyze more efficient protocols that rely on rejection sampling rather than noise flooding.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">4.1 Preliminaries</h3>

    <p class="text-gray-300">We review basic definitions and lemmas we will use throughout the section.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 4.1 (Noise flooding).</h6>

    <p class="text-gray-300">Let <span class="math">B=B(\\lambda)</span>, <span class="math">B^{\\prime}=B^{\\prime}(\\lambda)</span> be integers such that <span class="math">B^{\\prime}/B=\\mathrm{negl}(\\lambda)</span>. Then for all <span class="math">x\\in[-B^{\\prime},B^{\\prime}]</span>, the distributions <span class="math">\\mathcal{U}([-B,B]+x)</span> and <span class="math">\\mathcal{U}([-B,B])</span> are within negligible statistical distance from each other.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma 4.2 (Leftover Hash Lemma).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{H}=\\{h:\\mathcal{X}\\rightarrow\\mathcal{Y}\\}</span> be a 2-universal hash function family. Then for any random variable <span class="math">X\\in\\mathcal{X}</span>, for <span class="math">\\epsilon&gt;0</span> s.t. $\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\leq H_{\\infty}(X)-2\\log(1/\\epsilon)$, the distributions</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(h,h(X))\\text{ and }(h,\\mathcal{U}(\\mathcal{Y}))</span></p>

    <p class="text-gray-300">are <span class="math">\\epsilon</span>-statistically close.</p>

    <p class="text-gray-300">Furthermore, the family <span class="math">\\{\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times m}:\\mathbf{r}\\mapsto\\mathbf{Ar}\\}</span> is 2-universal for prime <span class="math">q</span>.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">SIS and LWE.</h4>

    <p class="text-gray-300">We first recall the short integer solution (SIS) problem.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 4.3 (Short Integer Solution (SIS) <em>[x1]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">n,m,q\\in\\mathbb{Z}</span> and <span class="math">B\\in\\mathbb{R}</span>, define the short integer solution problem <span class="math">\\mathrm{SIS}_{n,m,q,B}</span> as follows: Given <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times m}</span>, find a non-zero vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}^{m}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq B$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\mathbf{x}=\\mathbf{0}\\bmod q.</span></p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 4.4 (Inhomogeneous Short Integer Solution (iSIS)).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">n,m,q\\in\\mathbb{Z}</span> and <span class="math">B\\in\\mathbb{R}</span>, define the inhomogeneous short integer solution problem <span class="math">\\mathrm{iSIS}_{n,m,q,B}</span> as follows: Given <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times m}</span>, <span class="math">\\mathbf{y}\\in\\mathbb{Z}_{q}^{n}</span>, find <span class="math">\\mathbf{x}\\in\\mathbb{Z}^{m}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq B$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\mathbf{x}=\\mathbf{y}\\bmod q.</span></p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 4.5 (Hardness of (i)SIS based on the lattice problems in the worst case <em>[x1, x13]</em>).</h6>

    <p class="text-gray-300">For any <span class="math">m=\\Omega(n\\log q)</span>, any <span class="math">\\beta&gt;0</span>, and any sufficiently large <span class="math">q\\geq\\beta\\cdot\\text{poly}(n)</span>, solving <span class="math">\\mathrm{SIS}_{n,m,q,\\beta}</span> or <span class="math">\\mathrm{iSIS}_{n,m,q,\\beta}</span> (where <span class="math">\\mathbf{y}</span> is sampled uniformly from <span class="math">\\mathbb{Z}_{q}^{n}</span>) with non-negligible probability is as hard as solving <span class="math">\\mathrm{GapSVP}_{\\gamma}</span> and <span class="math">\\mathrm{SIVP}_{\\gamma}</span> on arbitrary <span class="math">n</span>-dimensional lattices with overwhelming probability, for some approximation factor <span class="math">\\gamma=\\beta\\cdot\\text{poly}(n)</span>.</p>

    <p class="text-gray-300">We recall the decisional learning with errors (LWE) problem.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 4.6 (Decisional Learning with Errors (LWE) <em>[x21]</em>).</h6>

    <p class="text-gray-300">For <span class="math">n,m\\in\\mathbb{N}</span> and modulus <span class="math">q\\geq 2</span>, distributions for secret vectors, public matrices, and error vectors <span class="math">\\theta,\\pi,\\chi\\subseteq\\mathbb{Z}_{q}</span>. An LWE sample is obtained from sampling <span class="math">\\mathbf{s}\\leftarrow\\theta^{n}</span>, <span class="math">\\mathbf{A}\\leftarrow\\pi^{n\\times m}</span>, <span class="math">\\mathbf{e}\\leftarrow\\chi^{m}</span>, and outputting <span class="math">(\\mathbf{A},\\mathbf{y}^{t}:=\\mathbf{s}^{t}\\mathbf{A}+\\mathbf{e}^{t}\\mod q)</span>.</p>

    <p class="text-gray-300">We say that an algorithm solves <span class="math">\\mathrm{LWE}_{n,m,q,\\theta,\\pi,\\chi}</span> if it distinguishes the LWE sample from a random sample distributed as <span class="math">\\pi^{n\\times m}\\times\\mathcal{U}(\\mathbb{Z}_{q}^{m})</span> with probability greater than <span class="math">1/2</span> plus non-negligible.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Lemma 4.7 (Hardness of LWE based on the lattice problems in the worst case <em>[x21]</em>).</h6>

    <p class="text-gray-300">Given <span class="math">n\\in\\mathbb{N}</span>, for any <span class="math">m=\\text{poly}(n)</span>, <span class="math">q\\leq 2^{\\text{poly}(n)}</span>. Let <span class="math">\\theta=\\pi=\\mathcal{U}(\\mathbb{Z}_{q})</span>, <span class="math">\\chi=D_{\\mathbb{Z},s}</span>, the discrete Gaussian distribution of width <span class="math">s\\geq 2\\sqrt{n}</span>. If there exists an efficient (possibly quantum) algorithm that breaks <span class="math">\\mathrm{LWE}_{n,m,q,\\theta,\\pi,\\chi}</span>, then there exists an efficient (possibly quantum) algorithm for solving <span class="math">GapSVP_{\\gamma}</span> and <span class="math">SIVP_{\\gamma}</span> on arbitrary <span class="math">n</span>-dimensional lattices with overwhelming probability, for some approximation factor <span class="math">\\gamma=\\tilde{O}(nq/s)</span>.</p>

    <p class="text-gray-300">The next lemma shows that LWE with the secret sampled from the error distribution is as hard as the standard LWE.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Lemma 4.8 (<em>[x2]</em>).</h6>

    <p class="text-gray-300">For <span class="math">n,m,q,s</span> chosen as in Lemma 4.7, <span class="math">\\mathrm{LWE}_{n,m^{\\prime},q,D_{\\mathbb{Z},s},\\mathcal{U}(\\mathbb{Z}_{q}),D_{\\mathbb{Z},s}}</span> is as hard as <span class="math">\\mathrm{LWE}_{n,m,q,\\mathcal{U}(\\mathbb{Z}_{q}),\\mathcal{U}(\\mathbb{Z}_{q}),D_{\\mathbb{Z},s}}</span> for <span class="math">m^{\\prime}\\leq m-(16n+4\\log\\log q)</span>.</p>

    <p class="text-gray-300">Throughout the paper we will denote by <span class="math">\\mathrm{LWE}_{n,m,q,\\chi}</span> the assumption implicitly setting <span class="math">\\theta=\\chi</span>, <span class="math">\\pi=\\mathcal{U}(\\mathbb{Z}_{q})</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 4.9 (Gadget Matrix).</h6>

    <p class="text-gray-300">We say that a matrix <span class="math">\\mathbf{G}\\in\\mathbb{Z}_{q}^{k\\times\\ell}</span> is a <em>gadget matrix</em> if there exists an efficient deterministic procedure <span class="math">\\mathbf{G}^{-1}</span>, which, on input <span class="math">\\mathbf{X}\\in\\mathbb{Z}_{q}^{k}</span>, output a matrix <span class="math">\\mathbf{G}^{-1}(\\mathbf{X})</span> with small norm such that <span class="math">\\mathbf{G}\\mathbf{G}^{-1}(\\mathbf{X})=\\mathbf{X}</span>. A common choice of the gadget matrix is the following “power-of-b” matrix, where the base <span class="math">b</span> is a small integer (say <span class="math">b=2</span>). Let <span class="math">\\mathbf{G}=\\mathbf{I}_{k}\\otimes\\mathbf{g}^{t}\\in\\mathbb{Z}_{q}^{k\\times k\\lceil\\log_{b}q\\rceil}</span> with <span class="math">\\mathbf{g}^{t}=(1,b,\\ldots,b^{\\lceil\\log_{b}q\\rceil-1})</span> (implicitly setting <span class="math">\\ell=k\\lceil\\log_{b}q\\rceil</span>). The <span class="math">\\mathbf{G}^{-1}</span> function is then the base-<span class="math">b</span> decomposition function. By default we will consider the “power-of-two” gadget matrix, but all our results apply with any matrix <span class="math">\\mathbf{G}</span> with the following property:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists a deterministic function <span class="math">\\mathbf{G}^{-1}(\\cdot)</span>, which on input <span class="math">\\boldsymbol{\\alpha}\\in\\mathbb{Z}_{q}^{k}</span> outputs a “short” <span class="math">\\mathbf{c}</span> such that <span class="math">\\mathbf{G}(\\mathbf{c})=\\boldsymbol{\\alpha}</span>,</li>

    </ul>

    <p class="text-gray-300">Looking ahead, if we do not use the “powers-of-two” gadge matrix, the “shortness” of <span class="math">\\mathbf{c}=\\mathbf{G}^{-1}(\\boldsymbol{\\alpha})</span> will slightly modify the parameters of the schemes, namely the final check of the verifier with respect to the norm of the third message, and the parameters of the underlying <span class="math">SIS</span> problem used to argue soundness.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">4.2 SIS-based Identification Protocols</h3>

    <p class="text-gray-300">We first describe a common variant of Lyubashevsky identification protocol. This can be also seen as a variant of the Schnorr protocol ported to the SIS setting, using many secrets in parallel. For the sake of simplicity, we will first present a protocol that uses noise flooding rather than rejection sampling, which capture our core ideas. We then present an LWE counterpart and a version based on rejection sampling in Section 4.4 and Section 4.5, respectively.</p>

    <p class="text-gray-300">Let <span class="math">n,m,q</span>, and <span class="math">\\ell,B</span> be integers.</p>

    <p class="text-gray-300">Consider the following identification protocol:</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Identification Protocol  <span class="math">\\Pi^{\\mathrm{SIS}}</span>  based on SIS.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The public key is  <span class="math">(\\mathbf{A},\\mathbf{Y})</span>  where  <span class="math">\\mathbf{A}\\gets \\mathbb{Z}_q^{n\\times m}</span> , and  <span class="math">\\mathbf{Y} = \\mathbf{A}\\mathbf{R}\\in \\mathbb{Z}_q^{n\\times \\ell}</span>  where  <span class="math">\\mathbf{R}\\gets \\{0,1\\}^{m\\times \\ell}</span> . The secret key is  <span class="math">\\mathbf{R}</span> .</li>

      <li>The prover samples  <span class="math">\\mathbf{t} \\gets [-B, B]^m</span> , and sends  <span class="math">\\alpha = \\mathbf{A}\\mathbf{t} \\in \\mathbb{Z}_q^n</span>  to the verifier.</li>

      <li>The verifier sends a challenge  <span class="math">\\mathbf{c} \\gets \\{0,1\\}^{\\ell}</span>  as the second message.</li>

      <li>The prover computes  <span class="math">\\mathbf{z} = \\mathbf{t} + \\mathbf{R}\\mathbf{c} \\in \\mathbb{Z}_q^m</span> , and sends it to the verifier.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier accepts if  <span class="math">\\mathbf{A}\\mathbf{z} = \\boldsymbol{\\alpha} + \\mathbf{Y}\\mathbf{c}</span>  and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq B + \\ell$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim 4.10 (Completeness). The identification protocol  <span class="math">\\Pi^{\\mathrm{SIS}}</span>  is complete.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. By linearity,  <span class="math">\\mathbf{A}\\mathbf{z} = \\mathbf{A}\\mathbf{t} + \\mathbf{A}\\mathbf{R}\\mathbf{c} = \\boldsymbol{\\alpha} + \\mathbf{Y}\\mathbf{c}</span> . Further, we have  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}\\mathbf{c}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\ell<span class="math"> , so that  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we show that  <span class="math">\\Pi^{\\mathrm{SIS}}</span>  satisfies special soundness. Unfortunately, we are not able to extract a short matrix  <span class="math">\\mathbf{R}&#x27;</span>  such that  <span class="math">\\mathbf{A}\\mathbf{R}&#x27; = \\mathbf{Y}</span> . Instead, we show how to obtain a short (non-zero) vector  <span class="math">\\mathbf{r} \\in \\mathbb{Z}_q^{m + \\ell}</span>  such that  $[\\mathbf{A} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Y}] \\cdot \\mathbf{r} = \\mathbf{0}<span class="math"> . Note that for uniformly random  </span>\\mathbf{A}<span class="math">  and  </span>\\mathbf{Y}$ , this is hard to do assuming SIS.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 4.11 (Relaxed Special Soundness). Suppose that  <span class="math">\\alpha, \\mathbf{z}, \\mathbf{z}&#x27;</span>  and  <span class="math">\\mathbf{c} \\neq \\mathbf{c}&#x27;</span>  such that  <span class="math">(\\alpha, \\mathbf{c}, \\mathbf{z})</span>  and  <span class="math">(\\alpha, \\mathbf{c}&#x27;, \\mathbf{z}&#x27;)</span>  are both accepting transcripts for  <span class="math">\\Pi^{\\mathrm{SIS}}</span> . Then there exists an extractor  <span class="math">\\mathcal{E}((\\alpha, \\mathbf{c}, \\mathbf{z}), (\\alpha, \\mathbf{c}&#x27;, \\mathbf{z}&#x27;))</span>  that computes a non-zero element  <span class="math">\\mathbf{r} \\in \\mathbb{Z}_q^{m + \\ell}</span>  such that  $[\\mathbf{A} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Y}] \\cdot \\mathbf{r} = \\mathbf{0}<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq 2(B + \\ell)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We have  <span class="math">\\mathbf{z} - \\mathbf{z}&#x27; = \\mathbf{R}(\\mathbf{c} - \\mathbf{c}&#x27;)</span> , so that  <span class="math">\\mathbf{A}(\\mathbf{z} - \\mathbf{z}&#x27;) = \\mathbf{Y}(\\mathbf{c} - \\mathbf{c}&#x27;)</span> . Therefore  <span class="math">\\mathbf{r} := \\begin{bmatrix} \\mathbf{z} - \\mathbf{z}&#x27; \\\\ \\mathbf{c}&#x27; - \\mathbf{c} \\end{bmatrix}</span>  is a non-zero vector (as  <span class="math">c \\neq c&#x27;</span> ) such that  $[\\mathbf{A} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Y}] \\cdot \\mathbf{r} = \\mathbf{0}<span class="math">  with  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq 2(B + \\ell)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim 4.12 (Honest-Verifier Zero-Knowledge). Suppose  <span class="math">\\ell / B = \\mathrm{negl}(\\lambda)</span> . Then the identification protocol  <span class="math">\\Pi^{\\mathrm{SIS}}</span>  is statistically honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. We define the honest-verifier simulator  <span class="math">S</span>  as follows. On input  <span class="math">(\\mathbf{A},\\mathbf{Y},\\mathbf{c})</span> , it samples  <span class="math">\\mathbf{z}</span>  uniformly from  <span class="math">[-B,B]^m</span> , and sets  <span class="math">\\alpha = \\mathbf{A}\\mathbf{z} - \\mathbf{Y}\\mathbf{c}</span> .</p>

    <p class="text-gray-300">For  <span class="math">\\mathbf{c} \\gets \\{0,1\\}^{\\ell}</span> , by Lemma 4.1, the resulting distribution  <span class="math">(\\mathbf{c},\\mathbf{z})</span>  is statistically close to the one produced by real proofs. Given  <span class="math">(\\mathbf{c},\\mathbf{z})</span> , for accepting proofs,  <span class="math">\\alpha</span>  satisfies  <span class="math">\\alpha = \\mathbf{A}\\mathbf{z} - \\mathbf{Y}\\mathbf{c}</span>  and therefore the output  <span class="math">(\\alpha,\\mathbf{c},\\mathbf{z})</span>  of  <span class="math">S</span>  is distributed statistically close to honestly generated proofs.</p>

    <p class="text-gray-300">Fiat-Shamir for  <span class="math">\\Pi^{\\mathrm{SIS}}</span> . We now show that instantiating the Fiat-Shamir heuristic on  <span class="math">\\Pi^{\\mathrm{SIS}}</span>  with the hash function  <span class="math">\\mathbf{G}^{-1}(\\cdot)</span>  (Fig. 3) preserves (average-case) soundness. In order to preserve zero-knowledge, we additionally rely on a common random string.</p>

    <p class="text-gray-300">Claim 4.13 (Completeness). The protocol  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  is complete.</p>

    <p class="text-gray-300">Proof. This follows by completeness of the interactive variant  <span class="math">\\Pi^{\\mathrm{SIS}}</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Non-interactive Identification Protocol  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  based on SIS.</p>

    <p class="text-gray-300">Claim 4.14 (Average-case soundness). Under the iSIS <span class="math">_{n,m+\\ell,B+\\ell}</span>  assumption, we have that for all efficient cheating prover  <span class="math">P^{*}</span>  for  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> :</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}_{\\mathbf{crs}\\leftarrow \\mathbb{Z}_q^\\ell ,\\mathbf{A}\\leftarrow \\mathbb{Z}_q^{n\\times m},\\mathbf{Y}\\leftarrow \\mathbb{Z}_q^{n\\times \\ell}}[(P^</em> (\\mathbf{crs},\\mathbf{A},\\mathbf{Y})\\leftrightarrow V(\\mathbf{crs},\\mathbf{A},\\mathbf{Y})) = \\mathrm{Accept}]\\leq \\mathrm{negl}(n).</span></p>

    <p class="text-gray-300">In particular,  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  is a one-time secure identification scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Accepting proofs  <span class="math">(\\alpha, \\mathbf{c}, \\mathbf{z})</span>  for  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS}, \\mathbf{G}^{-1}}</span>  satisfy  <span class="math">\\mathbf{A}\\mathbf{z} = \\alpha + \\mathbf{Y}\\mathbf{c}</span>  where  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell$ . This can be rewritten as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\mathbf {A} \\parallel \\mathbf {G} + \\mathbf {Y} \\right] \\left[ \\begin{array}{c} \\mathbf {z} \\\\ - \\mathbf {G} ^ {- 1} (\\boldsymbol {\\alpha} - \\boldsymbol {\\rho}) \\end{array} \\right] = \\boldsymbol {\\rho}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">(\\mathbf{B},\\pmb {\\rho})</span>  be an inhomogeneous SIS instance where  $\\mathbf{B} = [\\mathbf{B}_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B}_2]\\gets \\mathbb{Z}_q^{n\\times (m + \\ell)}<span class="math"> , and  </span>\\pmb {\\rho}\\gets \\mathbb{Z}_q^n<span class="math">  and let  </span>P^{<em>}(\\mathrm{crs},\\mathbf{A},\\mathbf{Y})<span class="math">  be a cheating prover breaking average-case soundness of  </span>(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}<span class="math">  with probability  </span>\\epsilon<span class="math">  over the randomness of  </span>(\\mathrm{crs},\\mathbf{A},\\mathbf{Y})\\gets \\mathbb{Z}_q^n\\times \\mathbb{Z}_q^{n\\times m}\\times \\mathbb{Z}_q^{n\\times \\ell}<span class="math"> . Then, any accepting transcript  </span>(\\alpha ,\\mathbf{c},\\mathbf{z})<span class="math">  produced by  </span>P^{</em>}<span class="math">  on input  </span>(\\pmb {\\rho},\\mathbf{B}_1,\\mathbf{B}_2 - \\mathbf{G})<span class="math">  (which is distributed uniformly) induces an inhomogeneous SIS solution  </span>\\mathbf{r} = \\left[ \\begin{array}{c}\\mathbf{z}\\\\ -\\mathbf{G}^{-1}(\\pmb {\\alpha} - \\pmb {\\rho}) \\end{array} \\right]<span class="math">  which is non-zero, as  </span>(\\mathbf{z},\\mathbf{c})\\neq (\\mathbf{0},\\mathbf{0})<span class="math"> , and such that  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq B + \\ell$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the proof of Claim 4.14 does not strongly rely on the randomness of  <span class="math">\\rho</span> . In particular, we could set  <span class="math">\\rho = \\mathbf{0}</span>  and still argue soundness of  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> , by relying directly on SIS instead of its inhomogeneous version in the proof. In other words, using the single, deterministic Fiat-Shamir hash function  <span class="math">\\mathbf{G}^{-1}(\\cdot)</span>  preserves soundness of  <span class="math">\\Pi^{\\mathrm{SIS}}</span> ; it is only for zero-knowledge that we consider a (slightly modified) family of hash functions  <span class="math">\\mathbf{G}_{\\rho}^{-1}(\\alpha) = \\mathbf{G}^{-1}(\\alpha - \\rho)</span> .</p>

    <p class="text-gray-300">Next, we argue zero-knowledge of our construction. Note that the way we add the CRS to our protocol is technically different from the one we use in the group-based setting. In more details, defining  <span class="math">\\widetilde{\\mathbf{G}^{-1}}_{\\rho}(\\alpha) \\coloneqq \\mathbf{G}^{-1}(\\alpha) + \\rho</span>  would break the structural requirement that we use to argue soundness. Instead, we define  <span class="math">\\mathbf{G}^{-1}_{\\rho}(\\alpha) \\coloneqq \\mathbf{G}^{-1}(\\alpha - \\rho)</span> , and we directly argue (single-theorem) zero-knowledge without using the fact that  <span class="math">\\Pi^{\\mathrm{SIS}}</span>  is honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">Claim 4.15 (Zero-Knowledge). The protocol  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  is (single-theorem) statistically zero-knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We define our simulator  <span class="math">\\mathbf{S}</span>  as follows. On input  <span class="math">(\\mathbf{A},\\mathbf{Y})</span> , it samples  <span class="math">\\mathbf{u} \\gets \\mathbb{Z}_q^n</span> , and sets  <span class="math">\\mathbf{c} = \\mathbf{G}^{-1}(\\mathbf{u})</span> . It samples  <span class="math">\\mathbf{z}</span>  uniformly from  <span class="math">[-B,B]^m</span> , and sets  $\\pmb{\\rho} = [\\mathbf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G} + \\mathbf{Y}]\\left[ \\begin{array}{c}\\mathbf{z}\\\\ -\\mathbf{c} \\end{array} \\right]<span class="math"> . It sets  </span>\\alpha = \\mathbf{u} + \\pmb{\\rho}<span class="math"> , and outputs  </span>(\\mathrm{crs} = \\pmb{\\rho},(\\alpha ,\\mathbf{c},\\mathbf{z}))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us justify that the simulated distribution is statistically close to the real one. In the real distribution,  <span class="math">\\pmb{\\rho}</span>  is distributed uniformly, so  <span class="math">\\alpha +\\pmb{\\rho}</span>  is distributed uniformly. The simulated  <span class="math">\\mathbf{z}</span>  is distributed statistically close to its honestly generated counterpart, by Lemma 4.1, even conditioned on  <span class="math">\\mathbf{c}</span>  and  <span class="math">\\mathbf{u}</span> . Given  <span class="math">\\mathbf{z}</span>  and  <span class="math">\\mathbf{c} = \\mathbf{G}^{-1}(\\mathbf{u})</span> , the simulated  <span class="math">\\pmb{\\rho}</span>  is entirely determined as  $\\pmb{\\rho} = [\\mathbf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G} + \\mathbf{Y}]\\left[ \\begin{array}{c}\\mathbf{z}\\\\ -\\mathbf{c} \\end{array} \\right]<span class="math"> , where  </span>\\pmb{\\rho}<span class="math">  is (taken alone) statistically close to uniform by the leftover hash lemma (over the randomness of  </span>\\mathbf{z}<span class="math"> ). This in turn defines  </span>\\alpha<span class="math">  as  </span>\\mathbf{u} + \\pmb{\\rho}<span class="math"> , which makes the distribution output by  </span>S$  statistically close to honestly generated proofs overall.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Parameters.</h4>

    <p class="text-gray-300">To argue security of <span class="math">\\Pi^{\\text{SIS}}</span> and <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span>, we used the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{G}\\in\\mathbb{Z}_{q}^{n\\times\\ell}</span> is a gadget matrix. It suffices to set <span class="math">\\ell=n\\lceil\\log q\\rceil</span> to satisfy this property when instantiating <span class="math">\\mathbf{G}</span> as the “powers-of-two” matrix. We stress that one could use any gadget matrix satisfying the requirements of Definition 4.9, albeit with slightly different parameters depending on the gadget matrix.</li>

      <li><span class="math">\\ell/B\\leq\\text{negl}(n)</span> to argue zero-knowledge in Claims 4.12 and 4.15;</li>

      <li><span class="math">(\\mathbf{A},\\mathbf{AR})</span> (resp. <span class="math">(\\mathbf{A},\\mathbf{Az})</span>) are statistically close to uniform, to argue that relaxed special soundness of Claim 4.11 is non-vacuous (resp. zero-knowledge of <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span> in Claim 4.15). By the leftover hash lemma it suffices to set <span class="math">m=2n\\log q</span>;</li>

      <li><span class="math">\\text{iSIS}_{n,m+\\ell,q,B+\\ell}</span> is hard, to argue soundness of <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span> in Claim 4.14.</li>

    </ul>

    <p class="text-gray-300">Overall, setting <span class="math">m=2n\\lceil\\log q\\rceil</span>, <span class="math">\\ell=n\\lceil\\log q\\rceil</span>, <span class="math">q=2^{n^{\\epsilon}}</span> for any <span class="math">0&lt;\\epsilon&lt;1</span>, and any <span class="math">B=n^{\\omega(1)}</span>, our scheme is secure under <span class="math">\\text{iSIS}_{n,m+\\ell,q,B+\\ell}</span> (where statistical zero-knowledge holds with statistical distance <span class="math">\\approx\\ell/B+q^{n/2}</span>), and therefore under the hardness of GapCVP and SIVP with sub-exponential approximation factors.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">4.3 Connection with Lattice Trapdoors and Signatures</h3>

    <p class="text-gray-300">It turns out that the prover algorithm for the identification scheme <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span> (Fig. 3) can be seen as a <em>preimage sampling algorithm</em> using a <em>[x13]</em> trapdoor. Namely, it samples a short <span class="math">\\mathbf{r}\\in\\mathbb{Z}_{q}^{m+\\ell}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$[\\mathbf{A}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathbf{G}+\\mathbf{AR}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathbf{r}=\\boldsymbol{\\rho},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">such that the distribution of <span class="math">\\mathbf{r}</span> is independent of the trapdoor <span class="math">\\mathbf{R}</span> (over the randomness of the target <span class="math">\\rho</span>): this follows from <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span> being (single-theorem) zero-knowledge.</p>

    <p class="text-gray-300">While this only gives the ability to perform preimage sampling over <em>random</em> targets <span class="math">\\boldsymbol{\\rho}</span>, looking ahead, starting with our improved variant based on rejection sampling <span class="math">(\\Pi^{\\text{SIS}-\\text{Rej}})_{\\text{FS},\\mathbf{G}^{-1}}</span> (Section 4.5, Fig. 7) allows to remove that restriction. In a nutshell, this is because <span class="math">(\\Pi^{\\text{SIS}-\\text{Rej}})_{\\text{FS},\\mathbf{G}^{-1}}</span> is secure in the <em>plain model</em> (at the cost of only ensuring witness indistinguishability as opposed to zero-knowledge), and the protocol remains secure using <em>arbitrary</em> values <span class="math">\\boldsymbol{\\rho}</span> (computing the challenge as <span class="math">\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}-\\boldsymbol{\\rho})</span> as in <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span>). In fact, the prover algorithm of <span class="math">(\\Pi^{\\text{SIS}-\\text{Rej}})_{\\text{FS},\\mathbf{G}^{-1}}</span> <em>exactly matches</em> the preimage sampling algorithm of <em>[x16]</em>, which uses the same <em>[x13]</em> trapdoor (up to the format of the output). We refer to Section 4.5 for a more detailed comparison of <span class="math">(\\Pi^{\\text{SIS}-\\text{Rej}})_{\\text{FS},\\mathbf{G}^{-1}}</span> and the trapdoor sampling algorithm of <em>[x16]</em>.</p>

    <p class="text-gray-300">We now show that this connection extends to <em>signature schemes</em> built using lattice trapdoors and preimage sampling algorithms <em>[x7, x16]</em> in the random oracle model. More precisely, one can recover the <em>[x7]</em> signature scheme in the random oracle model (using <em>[x13]</em>) trapdoors) by applying Fiat-Shamir on the identification protocol (<span class="math">\\Pi^{\\text{SIS}}</span>). In order to embed messages into the identification scheme, we will rely on a random oracle <span class="math">H</span>, in order to hash the message into a random target for the (i)SIS instance. Notably, even though our connection uses a random oracle, it is only used to <em>hash the message</em>, while we are still using a simple Fiat-Shamir hash function <span class="math">\\mathbf{G}^{-1}(\\cdot)</span> to compress the identification protocol (<span class="math">\\Pi^{\\text{SIS}}</span>).</p>

    <p class="text-gray-300">For comparison, we give a quick overview of the signature scheme of <em>[x7]</em> in the random oracle model. The verification key is a matrix <span class="math">\\mathbf{B}</span>, and the signing key a “trapdoor” for <span class="math">\\mathbf{B}</span> (typically either from <em>[x7]</em> or <em>[x13]</em>). To sign a message <span class="math">\\mu</span>, one samples a “short” <span class="math">\\mathbf{r}</span> such that <span class="math">\\mathbf{B}\\cdot\\mathbf{r}=H(\\mu)</span>, where <span class="math">H</span> is the random oracle. Note that this is possible using the trapdoor for <span class="math">\\mathbf{B}</span>, and more precisely, using a <em>preimage sampling algorithm</em>.</p>

    <p class="text-gray-300">Consider the following signature scheme:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The secret key is a random <span class="math">\\mathbf{R}\\leftarrow\\{0,1\\}^{m\\times\\ell}</span>.</li>

      <li>The public key is <span class="math">(\\mathbf{A},\\mathbf{Y})</span>, where <span class="math">\\mathbf{A}\\leftarrow\\mathbb{Z}_{q}^{n\\times m}</span> and <span class="math">\\mathbf{Y}=\\mathbf{AR}\\in\\mathbb{Z}_{q}^{n\\times\\ell}</span>.</li>

      <li>To sign a message <span class="math">\\mu</span>, the signer</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>samples <span class="math">\\mathbf{t}\\leftarrow[-B,B]^{m}</span>, and computes <span class="math">\\boldsymbol{\\alpha}=\\mathbf{A}\\mathbf{t}\\in\\mathbb{Z}_{q}^{n}</span>,</li>

      <li>obtains the challenge <span class="math">\\mathbf{c}\\in\\{0,1\\}^{\\ell}</span> by computing <span class="math">\\mathbf{c}=\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}-H(\\mu))</span>,</li>

      <li>computes <span class="math">\\mathbf{z}=\\mathbf{u}+\\mathbf{R}\\mathbf{c}\\in\\mathbb{Z}^{m}</span>.</li>

    </ol>

    <p class="text-gray-300">The signer outputs <span class="math">(\\mathbf{z},\\boldsymbol{\\alpha})</span> as the signature.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier takes <span class="math">(\\mu,\\boldsymbol{\\alpha},\\mathbf{z})</span> accepts if $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq B$ and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$[\\mathbf{A}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right.\\mathbf{G}+\\mathbf{Y}]\\left[\\mathbf{\\mathbf{z}\\atop-\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}-H(\\mu))}\\right]=H(\\mu).$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-60" class="text-base font-medium mt-4">Theorem 4.16.</h6>

    <p class="text-gray-300">The signature scheme is EU-CMA in the random oracle model assuming iSIS</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let us first verify correctness. The relation that the verifier checks can be expanded as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$[\\mathbf{A}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right.\\mathbf{G}+\\mathbf{Y}]\\left[\\mathbf{\\mathbf{z}\\atop-\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}-H(\\mu))}\\right]=\\mathbf{A}\\mathbf{z}-\\boldsymbol{\\alpha}+H(\\mu)-\\mathbf{Y}(\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}-H(\\mu)))=\\mathbf{A}(\\mathbf{u}+\\mathbf{R}\\mathbf{c})-\\boldsymbol{\\alpha}+H(\\mu)-\\mathbf{Y}\\mathbf{c}=H(\\mu).$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove EU-CMA in the random oracle model under iSIS, we first simulate the signature queries as follows. Upon receiving a signature query for <span class="math">\\mu^{\\prime}</span>, the simulator calls the (one-time) zero-knowledge simulator of <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span>. It obtains <span class="math">(\\boldsymbol{\\rho},(\\boldsymbol{\\alpha},\\mathbf{c},\\mathbf{z}))</span>, and programs <span class="math">H(\\mu^{\\prime})</span> as <span class="math">\\boldsymbol{\\rho}</span>. This is (statistically) close to the distrubution of real signatures by (statistical, one-time) zero-knowledge of <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To prove it is hard for the adversary to produce the signature for the challenged message <span class="math">\\mu^{*}</span>, we argue that the hardness is equivalent to solving an iSIS instance with public matrix $[\\mathbf{A}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right.\\mathbf{G}+\\mathbf{Y}]<span class="math"> and target </span>H(\\mu^{<em>})<span class="math">. Indeed, if the adversary succeeds by producing </span>\\mathbf{z}<span class="math"> and </span>\\boldsymbol{\\alpha}<span class="math">, we can efficiently compute a short </span>\\mathbf{c}=G^{-1}(\\boldsymbol{\\alpha}-H(\\mu^{</em>}))$ and let \\[ \\begin{bmatrix}\\mathbf{z}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">-\\mathbf{c}\\end{bmatrix} \\] be the short preimage for the iSIS instance.</p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">On the use of random oracles.</h4>

    <p class="text-gray-300">Even though the main objective of the paper is to prove security for concrete (simple) Fiat-Shamir hash functions (as opposed to random oracles), the signature scheme above still relies on random oracles. We believe this does not contradict the spirit of this work: we still use a simple hash function <span class="math">\\mathbf{G}^{-1}(\\cdot)</span> to compress the interactive ID scheme, and only use the random oracle to hash the message to be signed. In other words, the use of the random oracle is similar to the one of <em>[x10]</em> which does not appear to be related to Fiat-Shamir.</p>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">Rejection Sampling.</h4>

    <p class="text-gray-300">Looking ahead, this connection with <em>[x10]</em> signatures also extend to the identification scheme <span class="math">(\\Pi^{\\text{SIS}-\\text{Rej}})_{\\text{FS},\\mathbf{G}^{-1}}</span> (Section 4.5, Fig. 7), which uses rejection sampling instead of noise flooding. In a nutshell, this is because <span class="math">(\\Pi^{\\text{SIS}-\\text{Rej}})_{\\text{FS},\\mathbf{G}^{-1}}</span> using a CRS (in a similar way than <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span>) is actually (single-theorem, statistical) zero-knowledge, which allows the proof above to go through.</p>

    <h3 id="sec-64" class="text-xl font-semibold mt-8">4.4 LWE-based Identification Protocols</h3>

    <p class="text-gray-300">Next, we show LWE counterparts to the identification schemes above. We will consider here the Hermite Normal Form of LWE <em>[x1]</em>, where the secret is sampled from the error distribution. Looking ahead, doing so will make the third message of the protocol short, which will be crucial to analyze the soundness of our non-interactive version.</p>

    <p class="text-gray-300">Let <span class="math">n,m,q</span>, and <span class="math">\\ell,B</span> be integers, and let <span class="math">\\chi</span> be a <span class="math">\\beta</span>-bounded error distribution for some integer <span class="math">\\beta</span>.</p>

    <p class="text-gray-300">Consider the following identification protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The public key is <span class="math">(\\mathbf{A},\\mathbf{Y})</span> where <span class="math">\\mathbf{A}\\leftarrow\\mathbb{Z}_{q}^{n\\times m}</span>, and <span class="math">\\mathbf{Y}=\\mathbf{S}\\mathbf{A}+\\mathbf{E}\\in\\mathbb{Z}_{q}^{\\ell\\times m}</span> where <span class="math">\\mathbf{S}\\leftarrow\\chi^{\\ell\\times n}</span> and <span class="math">\\mathbf{E}\\leftarrow\\chi^{\\ell\\times m}</span>.</li>

    </ul>

    <p class="text-gray-300">The secret key is <span class="math">\\mathbf{S}\\in\\mathbb{Z}_{q}^{\\ell\\times n}</span></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Identification Protocol  <span class="math">\\Pi^{\\mathrm{LWE}}</span>  based on LWE.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover samples  <span class="math">\\mathbf{t} \\gets [-B, B]^{1 \\times n}</span> ,  <span class="math">\\mathbf{e} \\gets \\chi^{1 \\times m}</span> , and sends  <span class="math">\\alpha = \\mathbf{tA} + \\mathbf{e} \\in \\mathbb{Z}_q^{1 \\times m}</span>  to the verifier.</li>

      <li>The verifier sends a challenge  <span class="math">\\mathbf{c} \\gets \\{0,1\\}^{1 \\times \\ell}</span>  as the second message.</li>

      <li>The prover computes  <span class="math">\\mathbf{z} = \\mathbf{t} + \\mathbf{c}\\mathbf{S} \\in \\mathbb{Z}_q^{1 \\times n}</span> , and sends it to the verifier.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier accepts if  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\mathbf{A} - \\pmb{\\alpha} - \\mathbf{c}\\mathbf{Y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq (\\ell + 1)\\beta<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell \\beta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim 4.17 (Completeness). The identification protocol  <span class="math">\\Pi^{\\mathrm{LWE}}</span>  is complete.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We have  <span class="math">\\mathbf{z}\\mathbf{A} - \\boldsymbol{\\alpha} - \\mathbf{c}\\mathbf{Y} = -\\mathbf{e} - \\mathbf{c}\\mathbf{E}</span> , where  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{E}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta<span class="math"> , and therefore  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\mathbf{A} - \\boldsymbol{\\alpha} - \\mathbf{c}\\mathbf{Y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell \\beta<span class="math"> . Similarly,  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta<span class="math"> , so that  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell \\beta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we show that there are no (even inefficient) cheating strategies succeeding over random instances  <span class="math">(\\mathbf{A},\\mathbf{Y})</span> .</p>

    <p class="text-gray-300">Claim 4.18 (Average-Case Soundness). Suppose that  <span class="math">m \\geq 2n \\log q</span>  and  <span class="math">B + \\ell \\beta \\leq q / 2</span> .</p>

    <p class="text-gray-300">Then identification protocol  <span class="math">\\Pi^{\\mathrm{LWE}}</span>  is average-case statistically sound. Namely, for all (potentially inefficient) cheating provers  <span class="math">P^{*}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {\\mathbf {A} \\leftarrow \\mathbb {Z} _ {q} ^ {n \\times m}, \\mathbf {Y} \\leftarrow \\mathbb {Z} _ {q} ^ {\\ell \\times m}} \\left[ \\left(P ^ {*} (\\mathbf {A}, \\mathbf {Y}) \\leftrightarrow V (\\mathbf {A}, \\mathbf {Y})\\right) = \\operatorname {A c c e p t} \\right] \\leq \\operatorname {n e g l} (n),</span></div>

    <p class="text-gray-300">where  <span class="math">P^{<em>}(\\mathbf{A},\\mathbf{Y})\\leftrightarrow V(\\mathbf{A},\\mathbf{Y})</span>  denotes the output of the verifier after interacting with  <span class="math">P^{</em>}</span></p>

    <p class="text-gray-300">Proof. By the leftover hash lemma, the distribution  <span class="math">(\\mathbf{Y},\\mathbf{c}\\mathbf{Y})</span>  is statistically close to  <span class="math">(\\mathbf{Y},\\mathbf{U})</span>  where  <span class="math">\\mathbf{U} \\gets \\mathbb{Z}_q^{1 \\times m}</span> . Let  <span class="math">\\alpha^<em> = \\alpha^</em>(\\mathbf{A},\\mathbf{Y})</span>  be the first message sent by  <span class="math">P^<em></span> . Then  <span class="math">(\\mathbf{A},\\mathbf{Y},\\alpha^</em>,\\mathbf{c}\\mathbf{Y})</span>  is statistically close to  <span class="math">(\\mathbf{A},\\mathbf{Y},\\alpha^*,\\mathbf{U})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix  <span class="math">\\alpha^{*} \\in \\mathbb{Z}_{q}^{1 \\times m}</span> . For a fixed  <span class="math">\\mathbf{z} \\in \\mathbb{Z}_{q}^{1 \\times m}</span> , the probability over  <span class="math">\\mathbf{u} \\gets \\mathbb{Z}_{q}^{1 \\times m}</span>  that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{zA} - \\alpha^{*} - \\mathbf{u} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell \\beta<span class="math">  is at most  </span>((\\ell + 1)\\beta)^{m} / q^{m}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By union bound over  <span class="math">\\mathbf{z}</span> , the probability over  <span class="math">\\mathbf{u} \\gets \\mathbb{Z}_q^{1 \\times m}</span>  that there exists  <span class="math">\\mathbf{z} \\in \\mathbb{Z}_q^{1 \\times n}</span>  such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{zA} - \\boldsymbol{\\alpha}^* - \\mathbf{u} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell \\beta$  is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">q ^ {n} \\cdot (B + \\ell \\beta) ^ {m} / q ^ {m} \\leq q ^ {n} / 2 ^ {m} \\leq q ^ {- n}</span></div>

    <p class="text-gray-300">which is negligible, so that with overwhelming probability no prover message in step 3 can make the verifier accept.</p>

    <p class="text-gray-300">Claim 4.19 (Honest-Verifier Zero-Knowledge). Suppose  <span class="math">(\\ell \\beta) / B \\leq \\mathrm{negl}(\\lambda)</span> . The identification protocol  <span class="math">\\Pi^{\\mathrm{LWE}}</span>  is statistically honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. We define our honest-verifier simulator  <span class="math">\\mathcal{S}</span>  as follows. On input  <span class="math">(\\mathbf{A},\\mathbf{Y},\\mathbf{c})</span> , it samples  <span class="math">\\mathbf{z} \\gets [-B,B]^{1 \\times n}</span> . It samples  <span class="math">\\mathbf{e} \\gets [-B,B]^{1 \\times m}</span> , sets  <span class="math">\\alpha = \\mathbf{zA} - \\mathbf{cY} + \\mathbf{e}</span> ,  <span class="math">\\mathbf{c} = \\mathbf{G}^{-1}(\\alpha)</span> , and outputs  <span class="math">(\\alpha, \\mathbf{c}, \\mathbf{z})</span> .</p>

    <p class="text-gray-300">By Lemma 4.1, the distribution of  <span class="math">\\mathbf{z}</span>  is statistically close to the one produced by real proofs. Then, for accepting proofs,  <span class="math">\\alpha</span>  is distributed as  <span class="math">\\alpha = \\mathbf{tA} + \\mathbf{e} = \\mathbf{zA} - \\mathbf{cY} + \\mathbf{cE} + \\mathbf{e}</span>  where  <span class="math">\\mathbf{Y} = \\mathbf{SA} + \\mathbf{E}</span> ,  <span class="math">\\mathbf{E} \\gets \\chi^{\\ell \\times m}</span> , and  <span class="math">\\mathbf{e} \\gets [-B, B]^{1 \\times m}</span> . But by Lemma 4.1, for all  <span class="math">\\mathbf{c} \\in \\{0, 1\\}^{1 \\times \\ell}</span> , this distribution is statistically close to  <span class="math">\\alpha = \\mathbf{zA} - \\mathbf{cY} + \\mathbf{e}</span>  where  <span class="math">\\mathbf{e} \\gets [-B, B]^{1 \\times m}</span> : this is the distribution output by the simulator  <span class="math">S</span> .</p>

    <p class="text-gray-300">Fiat-Shamir for  <span class="math">\\Pi^{\\mathrm{LWE}}</span> . Next, we show that instantiation the Fiat-Shamir heuristic on  <span class="math">\\Pi^{\\mathrm{LWE}}</span>  with the hash function  <span class="math">\\mathbf{G}^{-1}(\\cdot)</span>  preserves (average-case) soundness. As for the SIS version, we additionally rely on a common random string to argue zero-knowledge.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5: Non-interactive Identification Protocol  <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  based on LWE.</p>

    <p class="text-gray-300">Notice that now  <span class="math">\\alpha, \\rho \\in \\mathbb{Z}_q^{1 \\times m}</span>  are row vectors. Therefore,  <span class="math">(\\mathbf{G}^{-1}(\\pmb{\\alpha}^T + \\pmb{\\rho}^T)) \\in \\mathbb{Z}_q^\\ell</span>  is a column vector and  <span class="math">\\mathbf{c} = (\\mathbf{G}^{-1}(\\pmb{\\alpha}^T + \\pmb{\\rho}^T))^T \\in \\mathbb{Z}_q^{1 \\times \\ell}</span>  is in turn a row vector. In other words, in our syntax,  <span class="math">\\mathbf{G}^{-1}(\\cdot)</span>  expands column vectors to column vectors (instead of row vectors to row vectors), which introduces the transposes in the hash function  <span class="math">\\mathbf{G}^{-1}(\\cdot)</span> .</p>

    <p class="text-gray-300">Claim 4.20 (Completeness). The protocol  <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  is complete.</p>

    <p class="text-gray-300">Proof. This follows by completeness of the interactive variant  <span class="math">\\Pi^{\\mathrm{LWE}}</span> .</p>

    <p class="text-gray-300">Claim 4.21 (Average-case soundness). Under the iSIS <span class="math">_{m,n+\\ell+m,q,B+\\ell\\beta}</span>  assumption, we have that for all efficient cheating prover  <span class="math">P^{*}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {\\mathbf {c r s} \\leftarrow \\mathbb {Z} _ {q} ^ {1 \\times m}, \\mathbf {A} \\leftarrow \\mathbb {Z} _ {q} ^ {n \\times m}, \\mathbf {Y} \\leftarrow \\mathbb {Z} _ {q} ^ {\\ell \\times m}} \\left[ \\left(P ^ {*} (\\mathbf {c r s}, \\mathbf {A}, \\mathbf {Y}) \\leftrightarrow V (\\mathbf {c r s}, \\mathbf {A}, \\mathbf {Y})\\right) = \\text {A c c e p t} \\right] \\leq \\operatorname {n e g l} (n).</span></div>

    <p class="text-gray-300">In particular,  <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  is a one-time secure identification scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Accepting proofs  <span class="math">(\\alpha, \\mathbf{c}, \\mathbf{z})</span>  for  <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS}, \\mathbf{G}^{-1}}</span>  satisfy  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{zA} - \\alpha - \\mathbf{cY} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell \\beta<span class="math">  where  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell$ . This can be rewritten as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\mathbf {z} \\parallel - \\mathbf {c} \\parallel \\mathbf {z A} - \\boldsymbol {\\alpha} - \\mathbf {c Y} \\right] \\left[ \\begin{array}{c} \\mathbf {A} \\\\ \\mathbf {Y} + \\mathbf {G} ^ {T} \\\\ - \\mathbf {I} \\end{array} \\right] = \\boldsymbol {\\rho},</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{c} = (\\mathbf{G}^{-1}(\\pmb{\\alpha}^T - \\pmb{\\rho}^T))^T</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">P^{*}(\\mathbf{A},\\mathbf{Y})</span>  be a cheating prover breaking average-case soundness of  <span class="math">\\Pi^{\\mathrm{LWE}}</span>  over the randomness of  <span class="math">(\\mathbf{crs},\\mathbf{A},\\mathbf{Y}) \\gets \\mathbb{Z}_q^{1\\times m} \\times \\mathbb{Z}_q^{n\\times m} \\times \\mathbb{Z}_q^{\\ell \\times m}</span> . Let  <span class="math">(\\mathbf{B},\\pmb{\\tau}^T)</span>  where  $\\mathbf{B} = [\\mathbf{B}_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B}_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B}_3] \\gets \\mathbb{Z}_q^{m\\times (n + \\ell +m)}<span class="math">  and  </span>\\pmb{\\tau} \\gets \\mathbb{Z}_q^{1\\times m}$  be an inhomogeneous SIS instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define a reduction as follows. If  <span class="math">\\mathbf{B}_3</span>  is not invertible mod  <span class="math">q</span> , the reduction aborts. Otherwise, it computes  $\\mathbf{C} = -\\mathbf{B}_3^{-1}\\mathbf{B} = [\\mathbf{C}_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\mathbf{I}]<span class="math">  where  </span>\\mathbf{C}_1\\in \\mathbb{Z}_q^{m\\times n},\\mathbf{C}_2\\in \\mathbb{Z}_q^{m\\times \\ell}<span class="math"> , and computes  </span>\\pmb{\\rho}^T = -\\mathbf{B}_3^{-1}\\pmb{\\tau}^T<span class="math">  so that  </span>-\\mathbf{B}_3\\pmb{\\rho}^T = \\pmb{\\tau}^T$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, any accepting transcript  <span class="math">(\\alpha, \\mathbf{c}, \\mathbf{z})</span>  produced by  <span class="math">P^{*}</span>  on input  <span class="math">(\\rho, \\mathbf{C}_1^T, (\\mathbf{C}_2 - \\mathbf{G}^T)^T)</span>  (which is distributed uniformly as  <span class="math">\\mathbf{B}_3^{-1}</span>  is invertible) gives  <span class="math">\\mathbf{r} = \\begin{bmatrix} \\mathbf{z}^T \\\\ -\\mathbf{c}^T \\\\ (\\mathbf{zA} - \\boldsymbol{\\alpha} - \\mathbf{cY})^T \\end{bmatrix} \\in \\mathbb{Z}_q^{n + \\ell + m}</span>  which is non-zero, as  <span class="math">(\\mathbf{z}, \\mathbf{c}) \\neq (\\mathbf{0}, \\mathbf{0})</span>  such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{r} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B + \\ell \\beta<span class="math"> . Furthermore, we have  </span>\\mathbf{Cr} = [\\mathbf{C}_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathbf{I}] \\cdot \\mathbf{r} = \\rho^T<span class="math">  so that  </span>\\mathbf{Br} = -\\mathbf{B}_3 \\mathbf{Cr} = -\\mathbf{B}_3 \\rho^T = \\tau^T<span class="math"> , and therefore  </span>\\mathbf{r}<span class="math">  is an inhomogeneous SIS solution for  </span>(\\mathbf{B}, \\tau^T)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for the protocols based on SIS, the randomness of the CRS  <span class="math">\\pmb{\\rho}</span>  is only used for zero-knowledge, and could be set to 0 if we only cared about soundness. So as for the SIS case, using the single, deterministic Fiat-Shamir hash function  <span class="math">\\mathbf{G}^{-1}(\\cdot)</span>  preserves soundness of  <span class="math">\\Pi^{\\mathrm{LWE}}</span> ; it is only for zero-knowledge that we consider</p>

    <p class="text-gray-300">a (slightly modified) family of hash functions <span class="math">(\\mathbf{G}_{\\boldsymbol{\\rho}}^{-1})^{T}(\\boldsymbol{\\alpha}) = (\\mathbf{G}^{-1}(\\boldsymbol{\\alpha}^{T} - \\boldsymbol{\\rho}^{T}))^{T}</span>. Note that, as in the SIS version, we directly argue zero-knowledge of the non-interactive protocol instead of relying on the honest-verifier zero-knowledge property of the interactive version.</p>

    <p class="text-gray-300"><strong>Claim 4.22 (Zero-Knowledge).</strong> Suppose <span class="math">\\ell \\beta / B \\leq \\mathrm{negl}(n)</span>, let <span class="math">\\delta</span> be the uniform distribution over <span class="math">[-B, B]^m</span>. Under the <span class="math">\\mathrm{LWE}_{n,m,q,\\delta}</span> assumption, <span class="math">^{1011}</span> <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS}, \\mathbf{G}^{-1}}</span> is (single-theorem) computationally zero-knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define our simulator <span class="math">\\mathbf{S}</span> as follows. On input <span class="math">(\\mathbf{A},\\mathbf{Y})</span>, it samples <span class="math">\\mathbf{u} \\gets \\mathbb{Z}_q^m</span>, and sets <span class="math">\\mathbf{c} = (\\mathbf{G}^{-1}(\\mathbf{u}))^T</span>. It samples <span class="math">\\mathbf{z}</span> and <span class="math">\\mathbf{e}</span> uniformly from <span class="math">[-B,B]^m</span>, and sets $\\boldsymbol{\\rho} = [\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathbf{c}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}]\\left[ \\begin{array}{c} \\mathbf{A} \\\\ \\mathbf{Y} + \\mathbf{G}^T \\\\ -\\mathbf{I} \\end{array} \\right]<span class="math">. It sets </span>\\boldsymbol{\\alpha} = \\mathbf{u}^T + \\boldsymbol{\\rho}<span class="math">, and outputs </span>(\\mathrm{crs} = \\boldsymbol{\\rho}, (\\boldsymbol{\\alpha}, \\mathbf{c}, \\mathbf{z}))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First, <span class="math">\\mathbf{u}</span> is statistically close to uniform over <span class="math">\\mathbb{Z}_q^m</span> over the randomness of <span class="math">\\pmb{\\rho}</span> alone. Then, by Lemma 4.1, <span class="math">\\mathbf{z}</span> is distributed statistically close to <span class="math">\\mathbf{z} + \\mathbf{cS}</span> even conditioned on <span class="math">\\mathbf{c}</span> and <span class="math">\\mathbf{u}</span>. Similarly, <span class="math">\\mathbf{e}</span> is distributed statistically close to <span class="math">\\mathbf{zA} - \\boldsymbol{\\alpha} - \\mathbf{cY} = \\mathbf{e} + \\mathbf{cE}</span> even conditioned on <span class="math">\\mathbf{c}</span> and <span class="math">\\mathbf{u}</span>. Now <span class="math">\\pmb{\\rho}</span> is entirely determined as</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\rho} = \\left[ \\mathbf {z} \\parallel - \\mathbf {c} \\parallel \\mathbf {z A} - \\boldsymbol {\\alpha} - \\mathbf {c Y} \\right] \\left[ \\begin{array}{c} \\mathbf {A} \\\\ \\mathbf {Y} + \\mathbf {G} ^ {T} \\\\ - \\mathbf {I} \\end{array} \\right].</span></div>

    <p class="text-gray-300">By the <span class="math">\\mathrm{LWE}_{n,m,q,\\chi}</span> assumption, <span class="math">\\pmb{\\rho}</span> is computationally indistinguishable from uniform. This in turn determines <span class="math">\\pmb{\\alpha} = \\mathbf{u}^T - \\pmb{\\rho}</span>, and therefore the distribution output by <span class="math">\\mathcal{S}</span> is computationally indistinguishable to honestly generated proofs.</p>

    <p class="text-gray-300"><strong>Parameters.</strong> To argue security of <span class="math">\\Pi^{\\mathrm{LWE}}</span> and <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>, we used the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{G} \\in \\mathbb{Z}_q^{m \\times \\ell}</span> is a gadget matrix. It suffices to set <span class="math">\\ell = m\\lceil \\log q \\rceil</span> to satisfy this property when instantiating <span class="math">\\mathbf{G}</span> as the "powers-of-two" matrix. We stress that we could technically use any gadget matrix satisfying the requirements of Definition 4.9, albeit with slightly different parameters.</li>

      <li><span class="math">B + \\ell \\beta \\leq q / 2</span> and <span class="math">m \\geq 2n\\log q</span> to argue average-case soundness of <span class="math">\\Pi^{\\mathrm{LWE}}</span>;</li>

      <li><span class="math">\\ell \\beta / B \\leq \\mathrm{negl}(n)</span> to argue zero-knowledge in Claims 4.19 and 4.22;</li>

      <li><span class="math">\\mathrm{LWE}_{n,m,q,[-B,B]^m}</span> holds to argue zero-knowledge of <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> in Claim 4.22. Note that this holds assuming <span class="math">\\mathrm{LWE}_{n,m,q,\\chi}</span> for any <span class="math">\\beta</span>-bounded distribution <span class="math">\\chi</span> such that <span class="math">\\beta / B \\leq \\mathrm{negl}(n)</span>;</li>

      <li><span class="math">\\mathrm{SIS}_{n,m + \\ell ,q,B + \\ell}</span> holds, to argue soundness of <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> in Claim 4.14;</li>

      <li><span class="math">\\mathrm{LWE}_{n,m,q,\\chi}</span> to argue that the base language is hard.</li>

    </ul>

    <p class="text-gray-300">Overall, we can set <span class="math">m = 2n\\lceil \\log q \\rceil</span>, <span class="math">\\ell = m\\lceil \\log q \\rceil</span>, <span class="math">q = 2^{n^{\\epsilon}}</span> for any <span class="math">0 &amp;lt; \\epsilon &amp;lt; 1</span>, any <span class="math">B = n^{\\omega}(1) &amp;lt; q / 4</span>, and <span class="math">\\chi</span> a <span class="math">\\beta</span>-bounded distribution such that <span class="math">\\beta / B \\leq \\mathrm{negl}(n)</span>.</p>

    <p class="text-gray-300">Then our scheme is secure assuming both the <span class="math">\\mathrm{LWE}_{n,m,q,\\chi}</span> and <span class="math">\\mathrm{SIS}_{n,m + \\ell ,q,B + \\ell}</span> assumptions (and where statistical zero-knowledge holds with statistical distance <span class="math">\\approx \\ell \\beta /B + q^{-n / 2}</span>), and is therefore under the (quantum) hardness of GapCVP and SIVP with sub-exponential approximation factors.</p>

    <p class="text-gray-300"><strong>Attacks on Worst-Case Soundness.</strong> Our claims for soundness for <span class="math">\\Pi^{\\mathrm{LWE}}</span> (Claim 4.18) and <span class="math">(\\Pi^{\\mathrm{LWE}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> (Claim 4.21) hold over random instances. One can naturally ask if they satisfy a standard notion of worst-case soundness, which require that no cheating prover should convince a verifier on any false instance. Here, by false instance, we mean any instance <span class="math">(\\mathbf{A},\\mathbf{Y})</span> such that there does not exist <span class="math">\\mathbf{E}</span> (nor <span class="math">\\mathbf{S}</span>) with norm at most <span class="math">\\beta</span> such that <span class="math">\\mathbf{Y} = \\mathbf{SA} + \\mathbf{E}</span>.</p>

    <p class="text-gray-300">10Recall that this refers to the HNF form of LWE, where the secret is also taken from the distribution <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">11This assumption is in particular implied by <span class="math">\\mathrm{LWE}_{n,m,q,\\chi}</span> for any <span class="math">\\beta</span>-bounded distribution <span class="math">\\chi</span> such that <span class="math">\\beta /B\\leq \\mathrm{negl}(n)</span>.</p>

    <p class="text-gray-300">We show here that they do not satisfy worst-case soundness as is, by showing an attack on particular instances <span class="math">\\Pi^{\\text{LWE}}</span> that breaks soundness with probability <span class="math">1/2</span>, and a full attack on particular instances of <span class="math">(\\Pi^{\\text{LWE}})_{\\text{FS},\\mathbf{G}^{-1}}</span>.</p>

    <p class="text-gray-300">Pick <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times m}</span> uniformly at random. Suppose the first <span class="math">\\ell-1</span> rows of <span class="math">\\mathbf{Y}</span> are LWE samples, that is, are set as <span class="math">\\mathbf{Y}_{i}=\\mathbf{S}_{i}\\mathbf{A}+\\mathbf{E}_{i}</span> for some short <span class="math">\\mathbf{S}_{i},\\mathbf{E}_{i}</span>, and suppose the last row of <span class="math">\\mathbf{Y}</span> is <span class="math">(0,\\ldots,0,q/2)</span>. Then, with high probability over the randomness of <span class="math">\\mathbf{A}</span>, <span class="math">(0,\\ldots,0,q/2)</span> cannot be written as <span class="math">\\mathbf{sA}+\\mathbf{e}</span> for any short <span class="math">\\mathbf{e}</span>, and therefore defines a false instance.</p>

    <p class="text-gray-300">Then, if <span class="math">\\mathbf{c}</span> is set such that <span class="math">\\mathbf{c}_{\\ell}=0</span>, then a cheating prover can convince the verifier using his knowledge of <span class="math">\\mathbf{S}_{i}</span>, by running the honest prover (which would not use <span class="math">\\mathbf{S}_{\\ell}</span> in that case). This gives a cheating prover strategy with success probability (negligibly close to) <span class="math">1/2</span>.</p>

    <p class="text-gray-300">The same strategy also applies for <span class="math">(\\Pi^{\\text{LWE}})_{\\text{FS},\\mathbf{G}^{-1}}</span>, but now the cheating prover can sample <span class="math">\\boldsymbol{\\alpha}\\neq 0</span> honestly until the last coordinate of <span class="math">\\mathbf{G}^{-1}(\\boldsymbol{\\alpha})</span> is zero, in which case he succeeds with probability close to <span class="math">1</span> (notice that under the LWE assumption, <span class="math">\\mathbf{G}^{-1}(\\boldsymbol{\\alpha})</span> is distributed computationally close to <span class="math">\\mathbf{G}^{-1}(\\mathbf{u})</span> where <span class="math">\\mathbf{u}\\leftarrow\\mathbb{Z}_{q}^{1\\times m}</span>).</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">4.5 More Efficient Protocols via Rejection Sampling</h3>

    <p class="text-gray-300">One drawback of the previous identification protocols is that zero-knowledge is argued using noise flooding. This requires the modulus <span class="math">q</span> to be super-polynomially larger than the secret (namely, <span class="math">\\mathbf{R}</span> in the SIS versions and <span class="math">\\mathbf{S}</span> in the LWE ones), and in particular <span class="math">q</span> has to be super-polynomial. This leads to quite inefficient schemes in practice.</p>

    <p class="text-gray-300">Here, we describe variants of <span class="math">\\Pi^{\\text{SIS}}</span> (Fig. 2) and <span class="math">(\\Pi^{\\text{SIS}})_{\\text{FS},\\mathbf{G}^{-1}}</span> (Fig. 3) that are compatible with a polynomial modulus <span class="math">q</span>, using the rejection sampling technique of <em>[x19, x20, x21]</em>. In a nutshell, instead of flooding the dependence of the response <span class="math">\\mathbf{z}</span> in the secret, the prover now uses a much smaller masking term, but aborts the protocol with some probability. This will ensure that the distribution of the resulting response is independent of his secret.</p>

    <p class="text-gray-300">Unfortunately, this results in downgrading security from zero-knowledge to witness indistinguishability: this is essentially because sampling from this secret-independent distribution is hard without any secrets. While this is meaningful in the SIS regime, it is vacuous for LWE languages as the witness there is unique (with overwhelming probability over <span class="math">\\mathbf{A}</span>). We therefore focus on the SIS variants in this section.</p>

    <p class="text-gray-300">Our interactive identification scheme only features weak properties: the prover has some chance of aborting the execution of the protocol, compromising both completeness and witness-indistinguishability. Instead, we obtain our non-interactive variant using the Fiat-Shamir with aborts technique of <em>[x19]</em>, where the prover only sends a complete execution over to the verifier.</p>

    <p class="text-gray-300">Interestingly this unveils a connection between lattice trapdoors and identification schemes. Indeed, the transcript of our non-interactive protocol <span class="math">(\\Pi^{\\text{SIS}-\\text{Rej}})_{\\text{FS},\\mathbf{G}^{-1}}</span> (Fig. 7) exactly matches the output of the trapdoor presampling algorithm of <em>[x20]</em> where the target is <span class="math">\\mathbf{0}</span>. We develop on that connection at the end of the section.</p>

    <p class="text-gray-300">Let <span class="math">n,m,q</span>, and <span class="math">\\ell,B</span> be integers. Let <span class="math">P_{\\mathbf{t}}</span> and <span class="math">P_{\\mathbf{z}}</span> be two probability distributions over <span class="math">\\mathbb{Z}_{q}^{m}</span>, and let <span class="math">M&gt;0</span> be a real. We first present an interactive identification protocol based on rejection sampling.</p>

    <p class="text-gray-300">Completeness holds whenever the prover sends <span class="math">\\mathbf{z}\\neq\\bot</span>, and relaxed special soundness follows from a proof nearly identical to Claim 4.11.</p>

    <p class="text-gray-300">The advantages of using rejection sampling comes at the cost of downgrading zero-knowledge to witness-indistinguishability. The proof of the following claim is essentially in <em>[x19, Section 3.1]</em> for the following distributions.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Claim 4.23 (Witness Indistinguishability).</h6>

    <p class="text-gray-300">Suppose <span class="math">P_{\\mathbf{t}}</span> is a <span class="math">m</span>-dimensional discrete gaussian with parameter <span class="math">\\sigma</span>, and let <span class="math">I=[-(mn\\sigma-\\ell),mn\\sigma-\\ell]^{m}</span>. Set <span class="math">M=1/P_{\\mathbf{t}}(I)</span> and define <span class="math">P_{\\mathbf{z}}</span> as <span class="math">P_{\\mathbf{z}}(\\mathbf{z})=P_{\\mathbf{t}}(\\mathbf{z})</span> if <span class="math">\\mathbf{z}\\in I</span> and <span class="math">0</span> otherwise. Then, conditioned on <span class="math">\\mathbf{z}</span> being sent in the third round, <span class="math">\\Pi^{\\text{SIS}-\\text{Rej}}</span> is witness-indistinguishable.</p>

    <p class="text-gray-300">The protocol <span class="math">\\Pi^{\\text{SIS}-\\text{Rej}}</span> has quite a few drawbacks: it only achieves weak completeness and weak witness-indistinguishability. A natural idea to boost completeness would be to repeat the protocol until some <span class="math">\\mathbf{z}\\neq\\bot</span></p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6: Identification Protocol  <span class="math">\\Pi^{\\mathrm{SIS - Rej}}</span>  based on SIS. Figure 7: Identification Protocol  <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  based on SIS.</p>

    <p class="text-gray-300">is sent. However, this is in general breaks witness indistinguishability: even though the third message  <span class="math">\\mathbf{z} = \\mathbf{t} + \\mathbf{R}\\mathbf{c}</span>  itself does not reveal which secret  <span class="math">\\mathbf{R}</span>  is used, the probability of sending  <span class="math">\\mathbf{z} \\neq \\bot</span>  does depend  <span class="math">\\mathbf{R}</span> . In other words, seeing aborted transcripts could break security.</p>

    <p class="text-gray-300">The key idea, introduced by [Lyu09], consists in applying the Fiat-Shamir heuristic regardless of the weak properties of the base protocol. Now, for the resulting non-interactive protocol, the prover can keep producing transcripts in his head until some outputs some  <span class="math">\\mathbf{z} \\neq \\bot</span> : this allows us to obtain (statistical) completeness. Furthermore, the fact the prover only sends the one accepting transcript allows us to argue witness indistinguishability. The resulting protocol is therefore not directly the result of the Fiat-Shamir heuristic itself, but of a Fiat-Shamir with aborts.</p>

    <p class="text-gray-300">We now define our protocol  <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  in Fig. 7.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">Completeness and average-case soundness for  <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  follow from arguments nearly identical to the ones of Section 4.2, where we implicitly set  <span class="math">\\rho = \\mathbf{0}</span> : we do not need any common random string as the rejection sampling will ensure witness indistinguishability.</p>

    <p class="text-gray-300">Claim 4.24 (Completeness). Suppose  <span class="math">P_{\\mathbf{t}}</span>  is a  <span class="math">B</span> -bounded distribution for some  <span class="math">B</span> . Then the expected running time of the prover is at most  <span class="math">2M</span> , and the protocol  <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  is complete.</p>

    <p class="text-gray-300">Claim 4.25 (Average-case soundness). Suppose the distribution  <span class="math">P_{\\mathbf{z}}</span>  is  <span class="math">B</span> -bounded for some  <span class="math">B</span> . Then, under the  <span class="math">\\mathrm{SIS}_{n,m + \\ell,q,B + \\ell}</span>  assumption, we have that for all efficient cheating prover  <span class="math">P^{*}</span>  for  <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> :</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}_{\\mathbf{A}\\leftarrow \\mathbb{Z}_q^{n\\times m},\\mathbf{Y}\\leftarrow \\mathbb{Z}_q^{n\\times \\ell}}[(P^</em> (\\mathbf{A},\\mathbf{Y})\\leftrightarrow V(\\mathbf{A},\\mathbf{Y})) = \\mathrm{Accept}]\\leq \\mathrm{negl}(n).</span></p>

    <p class="text-gray-300">In particular,  <span class="math">(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>  is a one-time secure identification scheme.</p>

    <p class="text-gray-300">It remains to argue witness indistinguishability. This proof of the following claim is identical to the one of [LW15, Section 3].</p>

    <p class="text-gray-300">Claim 4.26 (Witness-Indistinguishability). Suppose that the distributions <span class="math">\\mathbf{At}</span> and <span class="math">\\mathbf{Az}</span> are statistically close to uniform mod <span class="math">q</span>, where <span class="math">\\mathbf{t} \\gets P_{\\mathbf{t}}</span> and <span class="math">\\mathbf{z} \\gets P_{\\mathbf{z}}</span>.</p>

    <p class="text-gray-300">Suppose furthermore that, over the randomness of <span class="math">\\alpha \\gets \\mathbb{Z}_q^n</span>, <span class="math">\\mathbf{c} = \\mathbf{G}^{-1}(\\alpha)</span>, and <span class="math">\\mathbf{z} \\gets P_{\\mathbf{z}}</span> conditioned on <span class="math">\\mathbf{Az} = \\mathbf{u} + \\mathbf{Y}\\mathbf{c}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\frac {P _ {\\mathbf {z}} (\\mathbf {z})}{P _ {\\mathbf {t}} (\\mathbf {z} - \\mathbf {R c})} \\leq M \\right] \\geq 1 - \\operatorname {n e g l} (n).</span></div>

    <p class="text-gray-300">Then the protocol <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> is statistically witness-indistinguishable.</p>

    <p class="text-gray-300">Proof. Consider the following (inefficient) simulator <span class="math">\\mathcal{S}</span>. It first generates <span class="math">\\alpha \\gets \\mathbb{Z}_q^n</span>, and sets <span class="math">\\mathbf{c} = \\mathbf{G}^{-1}(\\alpha)</span>. It then samples <span class="math">\\mathbf{z} \\gets P_{\\mathbf{z}}</span> conditioned on <span class="math">\\mathbf{Az} = \\mathbf{u} + \\mathbf{Y}\\mathbf{c}</span>. Notice that this last step is inefficient. Finally, the simulator outputs <span class="math">(\\alpha, \\mathbf{c}, \\mathbf{z})</span>.</p>

    <p class="text-gray-300">The proof of [LW15, Theorem 3.1] exactly shows that the resulting distribution is statistically indistinguishable from a honestly generated transcript (setting their target <span class="math">\\mathbf{t}</span> as <span class="math">\\mathbf{0}</span>).</p>

    <p class="text-gray-300">Instantiations and parameters. As in Section 4.2, we can use the "powers-of-two" gadget matrix <span class="math">\\mathbf{G} \\in \\mathbb{Z}_q^{n \\times \\ell}</span>, which sets <span class="math">\\ell = n\\lceil \\log q \\rceil</span>. We stress that we could technically use any gadget matrix satisfying the requirements of Definition 4.9, albeit with slightly different parameters.</p>

    <p class="text-gray-300">To ensure the first hypothesis of Claim 4.26, we can set <span class="math">m = n\\lceil \\log q \\rceil</span> as well (and require that the distributions <span class="math">P_{\\mathbf{t}}</span> and <span class="math">P_{\\mathbf{z}}</span> have enough min-entropy to apply the leftover hash lemma).</p>

    <p class="text-gray-300">The main parameters left to instantiate are the distributions <span class="math">P_{\\mathbf{t}}</span> and <span class="math">P_{\\mathbf{z}}</span>. [LW15] proposes two instantiations that can directly be used to instantiate our theorems.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One is to set <span class="math">P_{\\mathbf{t}}</span> to be the uniform distribution over the cube <span class="math">[- (m + 1)\\ell, (m + 1)\\ell)]^m</span>, and <span class="math">P_{\\mathbf{z}}</span> as the uniform distribution over <span class="math">[-m\\ell, m\\ell]^m</span>. This sets <span class="math">M \\approx e</span>, and therefore the prover will run the loop <span class="math">1 / M = 1 / e</span> times in expectation. This leads to a very simple "rejection sampling" step: the prover sends <span class="math">\\mathbf{z} \\neq \\bot</span> if and only if $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">bz\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq m\\ell<span class="math">. This makes the proof rely on the hardness of </span>\\mathrm{SIS}_{n,m + \\ell, q, (m + 1)\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Another possible choice is to set <span class="math">P_{\\mathbf{t}}</span> and <span class="math">P_{\\mathbf{z}}</span> as discrete gaussians over with the same parameter <span class="math">\\sigma = \\Theta(\\ell \\sqrt{\\lambda})</span>, where <span class="math">\\lambda</span> denotes the security parameter. One can set <span class="math">M = e^{1 + 1 / \\lambda}</span>, which makes the prover run the loop <span class="math">&amp;lt; 3.5</span> times in expectation. This makes the proof rely on the hardness of <span class="math">\\mathrm{SIS}_{n,m + \\ell, q, \\Theta(\\ell \\sqrt{\\lambda})}</span>.</p>

    <p class="text-gray-300">In all cases security is implied by the (quantum) hardness of GapCVP and SIVP with polynomial approximation factors.</p>

    <p class="text-gray-300">Relation with the preimage sampling algorithm of [LW15]. As mentioned in Section 4.3, the prover algorithm of the protocol <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> (Fig. 7) is exactly the trapdoor preimage sampling algorithm of [LW15]. In their context, the goal is to sample a short <span class="math">\\mathbf{r} \\in \\mathbb{Z}_q^{m + \\ell}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ \\mathbf {A} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {G} + \\mathbf {A R} ] \\cdot \\mathbf {r} = \\mathbf {0},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">such that the distribution of <span class="math">\\mathbf{r}</span> is independent of the ([MP12]-)trapdoor <span class="math">\\mathbf{R}</span>. One could sample such a vector <span class="math">\\mathbf{r}</span> from Gaussian distribution using the techniques of [MP12]. The main observation of [LW15] is that we can use rejection sampling to sample preimages from more general distributions (using the same trapdoor). Their algorithm is exactly the prover algorithm in <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span>, with the syntactical difference of outputting <span class="math">\\mathbf{r} = \\left[ \\begin{array}{l}\\mathbf{z}\\\\ -\\mathbf{c} \\end{array} \\right]</span> instead of <span class="math">(\\alpha ,\\mathbf{c},\\mathbf{z})</span> (note that <span class="math">\\alpha</span> can be recovered as <span class="math">\\alpha = \\mathbf{G}\\mathbf{c}</span>). In other words, the prover of <span class="math">(\\Pi^{\\mathrm{SIS - Rej}})_{\\mathrm{FS},\\mathbf{G}^{-1}}</span> samples a short preimage of <span class="math">\\mathbf{0}</span> under $[\\mathbf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G} + \\mathbf{A}\\mathbf{R}]<span class="math">: this can be done efficiently using his knowledge of </span>\\mathbf{R}<span class="math">, and witness indistinguishability ensures that the output distribution is independent of </span>\\mathbf{R}<span class="math">. Furthermore, we can augment the protocol with any arbitrary </span>\\rho \\in \\mathbb{Z}_q^n<span class="math"> as in </span>(\\Pi^{\\mathrm{SIS}})_{\\mathrm{FS},\\mathbf{G}^{-1}}<span class="math"> (Section 4.2, Fig. 3), such that the challenge is computed as </span>\\mathbf{c} = \\mathbf{G}^{-1}(\\alpha -\\rho)<span class="math">. This does not affect security, and allows to sample a short </span>\\mathbf{r} = \\left[ \\begin{array}{l}\\mathbf{z}\\\\ -\\mathbf{c} \\end{array} \\right]$ such that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ \\mathbf {A} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {G} + \\mathbf {A R} ] \\cdot \\mathbf {r} = \\boldsymbol {\\rho},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">thus matching the [LW15] preimage sampling algorithm for arbitrary targets <span class="math">\\boldsymbol{\\rho}</span>.</p>

    <p class="text-gray-300">13By the leftover hash lemma, this holds if \\mathbf{A}\\gets \\mathbb{Z}_q^{n\\times m} and P_{\\mathbf{t}} , P_{\\mathbf{z}} have sufficiently high min-entropy.</p>

    <p class="text-gray-300">5 Fiat-Shamir in the Generic Group Model</p>

    <h3 id="sec-67" class="text-xl font-semibold mt-8">5.1 Generic Group Model Preliminaries</h3>

    <p class="text-gray-300">The generic group model (GGM) <em>[x21, x23]</em> is an idealization of a cryptographic group in which the representation of a group element leaks no information about the underlying exponent beyond what can be learned through honest group operations. This is typically formalized by an oracle interface that implements the group operations. Each group element is represented by a randomly chosen “label,” and the attacker interacts with the oracle to perform meaningful operations on the labels. A generic group attacker is measured by the number of oracle queries, but is otherwise computationally unbounded.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 5.1 (Generic Group Model, Standard Formulation).</h6>

    <p class="text-gray-300">In the generic group model, a cyclic group of order <span class="math">p</span> is represented with a label space of size <span class="math">L\\geq p\\cdot 2^{\\lambda}</span>. The generic group labeling function is a randomly sampled injection <span class="math">\\sigma:\\mathbb{Z}_{p}\\to[L]</span>. For any <span class="math">x\\in\\mathbb{Z}_{p}</span>, the corresponding <span class="math">\\sigma(x)\\in[L]</span> is the label representing <span class="math">g^{x}</span>.</p>

    <p class="text-gray-300">In any application of the GGM, an attacker <span class="math">\\mathcal{A}</span> is initialized with a list of labels <span class="math">(\\tau_{1}=\\sigma(1),\\ldots,\\tau_{N}=\\sigma(x_{N}))</span>; the number <span class="math">N</span> of initial labels as well as how each <span class="math">x_{i}</span> is sampled will depend on the particular application. The attacker is usually given access to a canonical group generator, which can be formalized by requiring that <span class="math">\\tau=\\sigma(1)</span> be included in the set of initial labels.</p>

    <p class="text-gray-300">The attacker <span class="math">\\mathcal{A}</span> is given oracle access to the group operation oracle <span class="math">\\mathcal{O}_{G}(\\cdot,\\cdot)</span>, which on input <span class="math">\\tau_{1},\\tau_{2}\\in[L]</span> does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If either of <span class="math">\\sigma^{-1}(\\tau_{1})</span> or <span class="math">\\sigma^{-1}(\\tau_{2})</span> are undefined, return <span class="math">\\bot</span>.</li>

      <li>Otherwise, set <span class="math">x=\\sigma^{-1}(\\tau_{1})</span> and <span class="math">y=\\sigma^{-1}(\\tau_{2})</span>, compute <span class="math">x+y\\in\\mathbb{Z}_{p}</span>, and return <span class="math">\\sigma(x+y)</span>.</li>

    </ul>

    <p class="text-gray-300">We remark that <span class="math">\\mathcal{O}_{G}</span> suffices to implement all of the standard group element manipulations. Raising a known group element to an arbitrary exponent <span class="math">a\\in\\mathbb{Z}_{p}</span> can be done via repeated squaring with <span class="math">O(\\log p)</span> queries to <span class="math">\\mathcal{O}_{G}</span>. Computing the inverse of a group element is equivalent to raising the group element to the exponent <span class="math">p-1</span>, and the attacker is explicitly given <span class="math">p</span> as input.</p>

    <p class="text-gray-300">A cryptographic application is said to be <span class="math">(T,\\epsilon)</span>-secure in the GGM if a (computationally unbounded) <span class="math">T</span>-query attacker <span class="math">\\mathcal{A}</span> cannot succeed with advantage greater than <span class="math">\\epsilon</span> (over the randomness of the application and the labeling function <span class="math">\\sigma</span>).</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Discrete Log and Linear Relations.</h4>

    <p class="text-gray-300">Throughout this section, we will rely on a theorem of Shoup <em>[x21]</em> stating that discrete log is hard in the GGM. Recall that in the discrete-log problem, the attacker <span class="math">\\mathcal{A}</span> is instantiated with labels <span class="math">(\\sigma(1),\\sigma(x))</span> for a random <span class="math">x\\leftarrow\\mathbb{Z}_{p}</span>, and it wins if it can output <span class="math">x</span>.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Theorem 5.2 (Hardness of Discrete Log <em>[x21]</em>).</h6>

    <p class="text-gray-300">The discrete-log problem is <span class="math">(T,O(T^{2}/p))</span>-secure in the GGM.</p>

    <p class="text-gray-300">An almost immediate corollary of Shoup’s result is that if a GGM attacker <span class="math">\\mathcal{A}</span> is instantiated with <span class="math">d</span> random group elements, it is hard to find a non-trivial linear relation among them. Formally, in the linear relation problem parameterized by <span class="math">d\\geq 1</span>, <span class="math">\\mathcal{A}</span> is instantiated with labels <span class="math">(\\sigma(1),\\sigma(x_{1}),\\ldots,\\sigma(x_{d}))</span> where <span class="math">x_{1},\\ldots,x_{d}</span> are all uniformly random in <span class="math">\\mathbb{Z}_{p}</span>, and wins if it outputs a non-zero vector <span class="math">\\vec{\\alpha}\\in\\mathbb{Z}_{p}^{d+1}</span> such that <span class="math">\\langle\\vec{\\alpha},(1,x_{1},\\ldots,x_{d})\\rangle=0</span> over <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Theorem 5.3 (Hardness of Finding a Linear Relation).</h6>

    <p class="text-gray-300">The linear relation problem with parameter <span class="math">d</span> is <span class="math">(T,O(dT^{2}/p))</span>-secure in the GGM.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">A <span class="math">T</span>-query attacker <span class="math">\\mathcal{A}</span> solving outputting a linear relation <span class="math">\\vec{\\alpha}</span> with advantage <span class="math">\\epsilon(\\lambda)</span> implies a <span class="math">T</span>-query attacker <span class="math">\\mathcal{A}</span> for discrete-log with advantage <span class="math">\\epsilon(\\lambda)/d</span>. The reduction randomly samples <span class="math">d-1</span> uniformly random group elements and places the discrete-log challenge <span class="math">\\sigma(u)</span> in a random position. At least one of the entries of <span class="math">\\vec{\\alpha}</span> other than the first entry must be non-zero, so a non-zero entry of <span class="math">\\vec{\\alpha}</span> coincides with the random position of the discrete-log challenge with probability at least <span class="math">1/d</span> independent of the attacker’s view. If this occurs and the attacker succeeds, the reduction can solve for <span class="math">u</span>. ∎</p>

    <p class="text-gray-300">5.1.1 An Alternative Formulation of the GGM</p>

    <p class="text-gray-300">For our purposes, it will be more convenient to think of the GGM as an interface that permits an attacker to perform arbitrary linear queries, but nothing else.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Definition 5.4 (Generic Group Model, Linear-Query Formulation).</h6>

    <p class="text-gray-300">The setup is the same as the previous formulation of the GGM, except the oracle <span class="math">\\mathcal{O}_{G}</span> is replaced by a linear-query oracle <span class="math">\\mathcal{O}_{Lin}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}</span> initializes <span class="math">\\mathcal{A}</span> with the labels <span class="math">\\tau_{1}=\\sigma(x_{1}),\\ldots,\\tau_{N}=\\sigma(x_{N})</span> and the group generator <span class="math">\\tau=\\sigma(1)</span>. <span class="math">\\mathcal{O}_{Lin}</span> takes as input <span class="math">\\alpha_{1},\\ldots,\\alpha_{N},\\beta\\in\\mathbb{Z}_{p}</span>, and outputs</p>

    <p class="text-gray-300"><span class="math">\\sigma((\\sum_{i\\in[N]}\\alpha_{i}\\cdot x_{i})+\\beta).</span></p>

    <p class="text-gray-300">Generic group model security proofs frequently rely on the equivalence of these two formulations. For the sake of completeness, we state this equivalence in the following claims.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Claim 5.5.</h6>

    <p class="text-gray-300">If an application is <span class="math">(T,\\epsilon)</span>-secure in the linear-query GGM, then the application is <span class="math">(T,\\epsilon+O(T/2^{\\lambda}))</span>-secure in the standard GGM.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove that a <span class="math">T</span>-query attacker <span class="math">\\mathcal{A}</span> in the standard GGM attaining advantage <span class="math">\\epsilon</span> implies a <span class="math">T</span>-query attacker <span class="math">\\mathcal{A}^{\\prime}</span> in the linear-query GGM attaining advantage <span class="math">\\epsilon-O(T/2^{\\lambda})</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{E}</span> be the event that the attacker <span class="math">\\mathcal{A}</span> ever queries <span class="math">\\mathcal{O}_{G}</span> on a label <span class="math">\\tau</span> which is not the output of a prior query to <span class="math">\\mathcal{O}_{G}</span>, or one of the elements <span class="math">\\mathcal{A}</span> is initialized with. Since <span class="math">\\sigma</span> is a random injection from <span class="math">\\mathbb{Z}_{p}</span> to <span class="math">[L]</span> where <span class="math">L\\geq p\\cdot 2^{\\lambda}</span>, any label it tries which is not the result of a prior query to <span class="math">\\mathcal{O}_{G}</span> will have a valid preimage under <span class="math">\\sigma</span> with probability at most <span class="math">O(\\frac{1}{2^{\\lambda}})</span>. A union bound over all <span class="math">T</span> queries shows that <span class="math">\\mathsf{E}</span> occurs with probability at most <span class="math">O(\\frac{T}{2^{\\lambda}})</span>.</p>

    <p class="text-gray-300">Conditioned on <span class="math">\\neg\\mathsf{E}</span>, any query that <span class="math">\\mathcal{A}</span> makes to <span class="math">\\mathcal{O}_{G}</span> can be perfectly replaced by a single query to <span class="math">\\mathcal{O}_{Lin}</span>. We argue this by induction on the queries. The first query that <span class="math">\\mathcal{A}</span> makes to <span class="math">\\mathcal{O}_{G}</span> is can be represented as a linear combination of (the preimages of) the initial labels <span class="math">(\\sigma(1),\\sigma(x_{1}),\\ldots,\\sigma(x_{N}))</span> since <span class="math">\\neg\\mathsf{E}</span> implies the inputs to <span class="math">\\mathcal{O}_{G}</span> are in this list. For the inductive step, suppose each of the first <span class="math">i</span> queries to <span class="math">\\mathcal{O}_{G}</span> can be represented as a linear combination of (the preimages of) the initial labels <span class="math">(\\sigma(1),\\sigma(x_{1}),\\ldots,\\sigma(x_{N}))</span>. Given <span class="math">\\neg\\mathsf{E}</span>, the query <span class="math">(\\tau_{1},\\tau_{2})</span> to <span class="math">\\mathcal{O}_{G}</span> must be from the results of prior queries to <span class="math">\\mathcal{O}_{G}</span> or the initial labels. But all such labels are linear combinations of the initial labels, so this must be true for query <span class="math">i+1</span>. It is straightforward to recover the coefficients <span class="math">(\\alpha_{1},\\ldots,\\alpha_{N},\\beta)</span> for the query <span class="math">i+1</span> given the initial labels and the input/output transcript of the first <span class="math">i</span> queries. ∎</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Claim 5.6.</h6>

    <p class="text-gray-300">If an application is <span class="math">(T,\\epsilon)</span>-secure in the standard GGM, then the application is <span class="math">(T/(\\Theta(N\\log p),\\epsilon)</span>-secure in the linear-query GGM.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Any query to <span class="math">\\mathcal{O}_{Lin}</span> can be simulated with <span class="math">\\Theta(N\\log p)</span> total queries to <span class="math">\\mathcal{O}_{G}</span>. Each <span class="math">\\sigma(\\alpha_{i}x_{i})</span> as well as <span class="math">\\sigma(\\beta)</span> can be computed in <span class="math">O(\\log p)</span> queries to <span class="math">\\mathcal{O}_{G}</span> by repeated squaring. Combining these labels to obtain <span class="math">\\sigma((\\sum_{i\\in[N]}\\alpha_{i}\\cdot x_{i})+\\beta)</span> takes an additional <span class="math">\\Theta(N)</span> queries. The cost is dominated by the first step, which takes <span class="math">\\Theta(N\\log p)</span> queries. ∎</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">5.2 The Auxiliary-Input Generic Group Model</h3>

    <p class="text-gray-300">We recall the definition of the Auxiliary-Input Generic Group Model (AI-GGM) <em>[x10]</em>, which extends security of the GGM to adversaries that can mount preprocessing attacks on the group.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Definition 5.7 (Auxiliary-Input Generic Group Model).</h6>

    <p class="text-gray-300">In the auxiliary-input generic group model (AI-GGM), a cyclic group of order <span class="math">p</span> is represented with a label space of size <span class="math">L\\geq p\\cdot 2^{\\lambda}</span>. The generic group labeling function is a randomly sampled injection <span class="math">\\sigma:\\mathbb{Z}_{p}\\to[L]</span>. For any <span class="math">x\\in\\mathbb{Z}_{p}</span>, the corresponding <span class="math">\\sigma(x)\\in[L]</span> is the label representing <span class="math">g^{x}</span>.</p>

    <p class="text-gray-300">In any application of the AI-GGM, an attacker <span class="math">\\mathcal{A}</span> is split into two phases, <span class="math">\\mathcal{A}_{1}</span> and <span class="math">\\mathcal{A}_{2}</span>. In a first phase, a computationally unbounded algorithm <span class="math">\\mathcal{A}_{1}</span> takes as input the whole truth table of <span class="math">\\sigma</span>, and produces an advice</p>

    <p class="text-gray-300"><span class="math">\\mathsf{aux}</span> of size <span class="math">S</span>. In the second phase, <span class="math">\\mathcal{A}_{2}</span> is given the auxiliary information <span class="math">\\mathsf{aux}</span> and proceeds as in the standard GGM Definition 5.1.</p>

    <p class="text-gray-300">A cryptographic application is said to be <span class="math">(S,T,\\epsilon)</span>-secure in the AI-GGM if any (computationally unbounded) attackers <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> where <span class="math">\\mathcal{A}_{1}</span> produces advice of size <span class="math">S</span>, and <span class="math">\\mathcal{A}_{2}</span> makes <span class="math">T</span>-queries to <span class="math">\\mathcal{O}_{G}</span>, cannot succeed with advantage greater than <span class="math">\\epsilon</span> (over the randomness of the application and the labeling function <span class="math">\\sigma</span>).</p>

    <p class="text-gray-300">A more convenient model for us to work with will be the Bit-Fixing GGM (BF-GGM) <em>[x10]</em>, where the preprocessing phase of the adversary is allowed to (weakly) program a limited number of input-output pairs of the labelling function <span class="math">\\sigma</span>, but the preprocessing advice <span class="math">\\mathsf{aux}</span> can only depend on these input-output pairs, as opposed to the whole truth table.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Definition 5.8 (Bit-Fixing Generic Group Model).</h6>

    <p class="text-gray-300">The bit-fixing generic group model (BF-GGM) is defined as the AI-GGM except with the following difference for the first phase attacker <span class="math">\\mathcal{A}_{1}</span> and the labelling function <span class="math">\\sigma</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a first phase, a computationally unbounded algorithm <span class="math">\\mathcal{A}_{1}</span> is given a set of <span class="math">p</span> distinct labels <span class="math">\\mathcal{Y}=\\{\\ell_{i}\\}_{i\\in\\mathbb{Z}_{p}}\\in[L]^{p}</span> sampled at random, which correspond to the range of <span class="math">\\sigma</span>. It produces a set <span class="math">F=\\{(r_{j},\\ell_{i_{j}})\\}_{j\\in[P]}</span> of size $P=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>r_{i}\\in\\mathbb{Z}_{p}<span class="math">. </span>\\mathcal{A}_{1}<span class="math"> additionally produces some auxiliary information </span>\\mathsf{aux}<span class="math"> of size </span>S<span class="math">, which is given to </span>\\mathcal{A}_{2}<span class="math">. The truth table of </span>\\sigma<span class="math"> is then sampled as a random injection </span>\\sigma:\\mathbb{Z}_{p}\\to\\mathcal{Y}<span class="math">, conditioned on </span>\\sigma(r_{j})=\\ell_{i_{j}}<span class="math"> for all </span>j\\in[P]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A cryptographic application is said to be <span class="math">(S,T,P,\\epsilon)</span>-secure in the BF-GGM if any (computationally unbounded) attackers <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> where <span class="math">\\mathcal{A}_{1}</span> programs $P=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> input-output pairs of </span>\\sigma<span class="math">, and produces advice of size </span>S<span class="math">, and where </span>\\mathcal{A}_{2}<span class="math"> makes </span>T<span class="math">-queries to </span>\\mathcal{O}_{G}<span class="math">, cannot succeed with advantage greater than </span>\\epsilon<span class="math"> (over the randomness of the application and the labeling function </span>\\sigma$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-81" class="text-base font-medium mt-4">Theorem 5.9 (Bit-fixing security implies auxiliary-input security <em>[x10]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{App}</span> be an application of the GGM where the challenger <span class="math">\\mathcal{C}</span> makes <span class="math">Q_{\\mathcal{C}}=\\mathrm{poly}(\\lambda)</span> calls to the group oracle. Suppose <span class="math">S,T,P=\\mathrm{poly}(\\lambda)</span>. Suppose <span class="math">\\mathsf{App}</span> is <span class="math">(S,T,P,\\mathrm{negl}(\\lambda))</span>-secure in the BF-GGM. Then there exists <span class="math">S^{\\prime},T^{\\prime}=\\mathrm{poly}(\\lambda)</span> such that <span class="math">\\mathsf{App}</span> is <span class="math">(S^{\\prime},T^{\\prime},\\mathrm{negl}(\\lambda))</span>-secure in the AI-GGM.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Remark 5.10.</h6>

    <p class="text-gray-300">Linear-Query Formulation in the BF-GGM. The equivalence of the linear-query formulation of the GGM directly ports to the bit-fixing setting (up to some mild loss in the parameters). This is because both the group oracle and any reduction can store all the programmed input-output pairs <span class="math">(r_{i},\\ell_{i})\\in F</span> as advice, and consider all the <span class="math">\\ell_{i}</span> as initial labels associated to <span class="math">r_{i}</span>.</p>

    <p class="text-gray-300">We will also use following theorem of hardness of the discrete logarithm problem in the BF-GGM:</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Theorem 5.11 (Hardness of Discrete Log in the BF-GGM <em>[x10]</em>).</h6>

    <p class="text-gray-300">Any algorithm <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> for the discrete logarithm problem in the BF-GGM with advice of size <span class="math">S</span>, that makes <span class="math">T</span> group oracle queries and fixes <span class="math">P</span> input-output pairs in the bit-fixing phase has advantage at most <span class="math">O((TP+T^{2})/N)</span>. In particular, if <span class="math">S,T,P=\\mathrm{poly}(\\lambda)</span>, the advantage of <span class="math">\\mathcal{A}</span> is negligible.</p>

    <h3 id="sec-84" class="text-xl font-semibold mt-8">5.3 Schnorr Signatures</h3>

    <h6 id="sec-85" class="text-base font-medium mt-4">Theorem 5.12.</h6>

    <p class="text-gray-300">Suppose the (keyed) Fiat-Shamir hash function <span class="math">H_{k}:[L]\\times\\mathcal{M}\\to\\mathbb{Z}_{p}</span> satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero-avoidance: For all stateful (potentially unbounded) adversary <span class="math">\\mathcal{A}</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[H_{k}(\\ell,m)=0\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\ell\\leftarrow\\mathcal{A}(1^{\\lambda}),k\\leftarrow\\mathcal{K},m\\leftarrow\\mathcal{A}(k)\\right]\\leq\\mathrm{negl}(\\lambda);$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random-prefix second-preimage resistance (rpsp): For all stateful (potentially unbounded) adversary <span class="math">\\mathcal{A}</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[H_{k}(R,m)=H_{k}(R,m^{\\prime})\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,k\\leftarrow\\mathcal{K},m\\leftarrow\\mathcal{A}(k),R\\leftarrow[L],m^{\\prime}\\leftarrow\\mathcal{A}(k,R)\\right]\\leq\\mathrm{negl}(\\lambda);$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random-prefix preimage resistance (rpp): For all stateful (potentially unbounded) adversary <span class="math">\\mathcal{A}</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[H_{k}(R,m)=h\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,k\\leftarrow\\mathcal{K},h\\leftarrow\\mathcal{A},R\\leftarrow[L],m\\leftarrow\\mathcal{A}(k,R)\\right]\\leq\\text{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then Schnorr signatures with Fiat-Shamir hash function <span class="math">H_{k}</span> are EUF-CMA secure in the BF-GGM against adversaries <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> with advice of size <span class="math">S=\\text{poly}(\\lambda)</span>, <span class="math">T=\\text{poly}(\\lambda)</span> oracle queries, <span class="math">Q=\\text{poly}(\\lambda)</span> signing queries and that fix <span class="math">P=\\text{poly}(\\lambda)</span> input-output pairs during the bit-fixing stage.</p>

    <p class="text-gray-300">Combined with Theorem 5.9, we obtain the following:</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Corollary 5.13.</h6>

    <p class="text-gray-300">Suppose the Fiat-Shamir hash function <span class="math">H_{k}</span> satisfies the properties above. Then Schnorr signatures are unforgeable in the auxiliary-input GGM against adversaries with polynomially-sized advice and polynomial number of group oracle and signing queries.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Remark 5.14 (Keyed and unkeyed hash functions.).</h6>

    <p class="text-gray-300">The properties of the hash function in Theorem 5.12 are stated for keyed functions. It is straightforward to specialize these properties to unkeyed hash functions by considering hash functions that ignore their keys. In that case, the zero-avoidance property collapses to the condition that <span class="math">H(\\ell,m)\\neq 0</span> for all <span class="math">\\ell,m</span>.</p>

    <p class="text-gray-300">We now prove Theorem 5.12.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the initial bit-fixing stage, the attacker <span class="math">\\mathcal{A}_{1}</span> receives a range <span class="math">\\mathcal{Y}=\\{\\ell_{i}\\}_{i\\in\\mathbb{Z}_{p}}</span>. It picks a set <span class="math">F\\subset\\mathbb{Z}_{p}</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\lambda)<span class="math">, and for each </span>r\\in F<span class="math">, it chooses a corresponding label </span>\\ell_{i_{r}}\\in\\mathcal{Y}<span class="math">, and produces some auxiliary information </span>\\mathsf{aux}<span class="math">. Then the generic group oracle is sampled as a uniformly random injection </span>\\sigma:\\mathbb{Z}_{p}\\to\\mathcal{Y}<span class="math"> satisfying </span>\\sigma(r)=\\ell_{i_{r}}<span class="math"> for all </span>r\\in F$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, the challenger samples a uniformly random signing key <span class="math">u\\leftarrow\\mathbb{Z}_{p}</span>, and uniformly random <span class="math">k\\leftarrow\\mathcal{K}</span> as the key for the Fiat-Shamir hash function. The attacker receives <span class="math">(\\sigma(u),k)</span>.</p>

    <p class="text-gray-300">The attacker is free to request <span class="math">t=\\text{poly}(\\lambda)</span> signing queries. On the <span class="math">i</span>th query, the attacker sends a message <span class="math">m_{i}\\in\\mathcal{M}</span>, the challenger samples a uniformly random <span class="math">r_{i}\\leftarrow\\mathbb{Z}_{p}</span>, computes <span class="math">z_{i}=r_{i}+H_{k}(\\sigma(r_{i}),m_{i})u</span>, and returns <span class="math">(\\sigma(r_{i}),z_{i},m_{i})</span> to the attacker.</p>

    <p class="text-gray-300">Finally, the attacker sends a forgery <span class="math">(\\ell^{<em>},z^{</em>},m^{<em>})\\in[L]\\times\\mathbb{Z}_{p}\\times\\mathcal{M}</span>, and wins the game if <span class="math">g^{z^{</em>}}=\\ell^{<em>}\\cdot(g^{u})^{H_{k}(\\ell^{</em>},m^{*})}</span>.</p>

    <p class="text-gray-300">The outline of the proof is as follows. We first define hybrid experiments and prove that they are indistinguishable from the EUF-CMA experiment for the Schnorr signature scheme. Then, we argue that any adversary succeeding in winning the EUF-CMA can be converted in an adversary that breaks one of the properties of the Fiat-Shamir hash function.</p>

    <h3 id="sec-89" class="text-xl font-semibold mt-8">5.10</h3>

    <p class="text-gray-300">This hybrid corresponds to the security experiment in the BF-GGM.</p>

    <h3 id="sec-90" class="text-xl font-semibold mt-8">5.11</h3>

    <p class="text-gray-300">We change the way the signing queries are handled. For a signing query for message <span class="math">m_{i}</span>, the reduction now samples <span class="math">z_{i}\\leftarrow\\mathbb{Z}_{p}</span>. It queries the oracle <span class="math">\\sigma</span> on input <span class="math">(z_{i}-u\\cdot H_{k}(\\ell_{i},m_{i}))</span>, receives a label <span class="math">\\ell_{i}</span> and ouputs the signature <span class="math">(\\ell_{i},z_{i},m_{i})</span>.</p>

    <h3 id="sec-91" class="text-xl font-semibold mt-8">5.12</h3>

    <p class="text-gray-300">We change the way group oracle queries are handled. The queries are internally stored by the reduction as <span class="math">(h,\\alpha,\\beta)\\in[L]\\times\\mathbb{Z}_{p}\\times\\mathbb{Z}_{p}</span>. Intuitively, this will capture the equation <span class="math">h=g^{\\alpha+u\\cdot\\beta}</span>. The group generator <span class="math">g</span> is stored as <span class="math">(g,1,0)</span>; bit-fixing queries <span class="math">r_{i}\\in F</span> stored as <span class="math">(\\ell_{i},r_{i},0)</span>; the verification key for the Schnorr signature scheme <span class="math">g^{u}</span> stored as <span class="math">(g^{u},0,1)</span>. Signature queries are answered by sampling <span class="math">\\ell_{i}\\leftarrow[L]</span>, <span class="math">z\\leftarrow\\mathbb{Z}_{p}</span>, outputting <span class="math">(\\ell_{i},z_{i},m_{i})</span> and storing <span class="math">(\\ell_{i},z_{i},-H_{k}(\\ell_{i},m_{i}))</span> (and implicitly programs <span class="math">\\sigma(z_{i}-u\\cdot H_{k}(\\ell_{i},m_{i}))=\\ell_{i}</span>).</p>

    <p class="text-gray-300">For any group operation query <span class="math">(g_{1},g_{2})</span>, the reduction looks at whether <span class="math">(g_{1},\\alpha_{1},\\beta_{1})</span> and <span class="math">(g_{2},\\alpha_{1},\\beta_{2})</span> have been previously stored, and aborts if not. If there exists some element <span class="math">h</span> such that <span class="math">(h,\\alpha_{1}+\\alpha_{2},\\beta_{1}+\\beta_{2})</span> has been stored, the output is set to <span class="math">h</span>. Otherwise, it samples a random <span class="math">h\\leftarrow[L]</span>, stores <span class="math">(h,\\alpha_{1}+\\alpha_{2},\\alpha_{1}+\\alpha_{2})</span> and answers the query with <span class="math">h</span>.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Claim 5.15.</h6>

    <p class="text-gray-300">The hybrids <span class="math">H_{0}</span> and <span class="math">H_{1}</span> are identically distributed.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Claim 5.16.</h6>

    <p class="text-gray-300">The hybrids <span class="math">H_{1}</span> and <span class="math">H_{2}</span> are statistically indistinguishable.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We change the way the reduction handles the preprocessing phase of <span class="math">H_{2}</span> in the following way. Let <span class="math">Q</span> and <span class="math">Q_{G}</span> be the number of signing and group oracle queries made by <span class="math">\\mathcal{A}_{2}</span>, respectively. Upon receiving <span class="math">p</span> independent labels <span class="math">\\mathcal{Y}=\\{\\overline{\\ell_{i}}\\}_{i\\in[p]}</span> in the bit-fixing stage, the reduction samples <span class="math">\\{\\ell_{i}\\}_{i\\in[Q]}\\leftarrow[L]^{Q}</span> and <span class="math">\\{h_{i}\\}_{i\\in[Q_{G}]}\\leftarrow[L]^{Q_{G}}</span>. It picks a random <span class="math">(p-Q-Q_{G})</span>-sized subset of <span class="math">\\mathcal{Y}=\\{\\overline{\\ell_{i}}\\}_{i\\in[p]}</span> and sends to <span class="math">\\mathcal{A}_{1}</span> the (multi-)set <span class="math">\\mathcal{Y}=\\{\\overline{\\ell_{i_{1}}},\\ldots,\\overline{\\ell_{i_{(p-Q-Q_{G})}}}\\}\\cup\\{\\ell_{i}\\}_{i\\in[Q]}\\cup\\{h_{i}\\}_{i\\in[Q_{G}]}</span> as the labels. The view of <span class="math">\\mathcal{A}_{1}</span> is identical from the one in hybrid <span class="math">H_{0}</span> as long as all the elements of <span class="math">\\mathcal{Y}</span> are distinct, which happen with overwhelming probability by union bound. Furthermore, with overwhelming probability, <span class="math">\\mathcal{A}_{1}</span> does not include any <span class="math">\\ell_{i}</span> or <span class="math">h_{i}</span> in its set <span class="math">F</span> of fixed input-output pairs.</p>

    <p class="text-gray-300">In the online phase, on a signing query <span class="math">m_{i}</span> made by <span class="math">\\mathcal{A}_{2}</span>, the reduction now implicitly programs <span class="math">\\sigma(z_{i}-u\\cdot H_{k}(\\ell_{i},m_{i}))=\\ell_{i}</span>, and <span class="math">\\sigma(\\alpha+u\\cdot\\beta)=h_{i}</span> for previously undefined group oracle queries. It aborts if a previously stored element is of the form <span class="math">(\\ell_{i},<em>,</em>)</span> or <span class="math">(h_{i},<em>,</em>)</span> respectively. Conditioned on not aborting, the marginal distribution of <span class="math">\\sigma</span> in <span class="math">H_{2}</span> is statistically close to the one in <span class="math">H_{1}</span>.</p>

    <p class="text-gray-300">We define the following event:</p>

    <p class="text-gray-300"><span class="math">E</span>: There exists two distinct stored elements <span class="math">(h_{1},\\alpha_{1},\\beta_{1})</span>, <span class="math">(h_{2},\\alpha_{2},\\beta_{2})</span> such that <span class="math">\\alpha_{1}+u\\cdot\\beta_{1}=\\alpha_{2}+u\\cdot\\beta_{2}\\bmod p</span>.</p>

    <p class="text-gray-300"><span class="math">H_{1}</span> and <span class="math">H_{2}</span> only differ if some element <span class="math">\\ell\\in[L]</span> is sampled twice when initializing stored values, or if <span class="math">E</span> occurs. The probability of the first event happening is negligible by union bound.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{L}</span> be the set of (distinct) elements <span class="math">(h,\\alpha,\\beta)</span> stored by the reduction, and <span class="math">\\mathcal{L}_{i}</span> the first (distinct) <span class="math">i</span> stored elements. Let <span class="math">E_{i}</span>, <span class="math">i\\in\\mathcal{L}</span> denote the event that there exists <span class="math">(h_{1},\\alpha_{1},\\beta_{1})</span>, <span class="math">(h_{2},\\alpha_{2},\\beta_{2})\\in\\mathcal{L}_{i}</span> such that <span class="math">\\alpha_{1}+u\\cdot\\beta_{1}=\\alpha_{2}+u\\cdot\\beta_{2}\\bmod p</span>. Conditioned on <span class="math">E_{i}</span> not occurring, the marginal distribution of <span class="math">u</span> given the first <span class="math">i</span> stored elements is uniformly random in <span class="math">\\mathbb{Z}_{p}</span>. Therefore:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[E_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E_{i}]<span class="math"> </span>=\\Pr[\\exists(h_{j},\\alpha_{j},\\beta_{j})\\in\\mathcal{L}_{i}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\alpha_{i}+u\\cdot\\beta_{i}=\\alpha_{j}+u\\cdot\\beta_{j}\\bmod p]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq\\sum_{(h_{j},\\alpha_{j},\\beta_{j})\\in\\mathcal{L}_{i}}\\Pr_{u\\leftarrow\\mathbb{Z}_{p}}[u=(\\alpha_{1}-\\alpha_{2})/(\\beta_{2}-\\beta_{1})\\bmod p]</span> <span class="math">=i/p,</span></p>

    <p class="text-gray-300">which is negligible. Summing over <span class="math">i</span>, we obtain that the probability that <span class="math">E</span> occurs is negligible.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Next, we argue that any adversary succeeding in producing a forgery <span class="math">(\\ell^{<em>},z^{</em>},m^{*})</span> in <span class="math">H_{2}</span> can be used to break some property of the Fiat-Shamir hash function. Our reduction, given <span class="math">F</span> provided by <span class="math">\\mathcal{A}_{1}</span>, distinguishes three cases:</p>

    <h4 id="sec-95" class="text-lg font-semibold mt-6">Case 1: <span class="math">\\ell^{*}\\in F</span>.</h4>

    <p class="text-gray-300">In other words, the group element <span class="math">\\ell^{<em>}</span> from the forgery <span class="math">(\\ell^{</em>},z^{<em>},m^{</em>})</span> is taken from the bit-fixing phase set <span class="math">F</span>. The reduction, given <span class="math">F</span>, first finds <span class="math">r^{<em>}\\in F</span> such that <span class="math">\\ell^{</em>}=\\sigma(r)</span>. If the adversary succeeds, the forged signature satisfies <span class="math">z^{<em>}=r^{</em>}+u\\cdot H_{k}(\\ell^{<em>},m^{</em>})</span>. If <span class="math">H_{k}(\\ell^{<em>},m^{</em>})\\neq 0</span>, one can use <span class="math">z^{<em>},r^{</em>},k,\\ell^{<em>}</span> and <span class="math">m^{</em>}</span> to recover <span class="math">u=z^{<em>}-r^{</em>}/H_{k}(\\ell^{<em>},m^{</em>})\\bmod p</span>. Note that the reduction does not use <span class="math">u</span> in <span class="math">H_{2}</span>. Therefore this case can only happen with negligible probability, given the hardness of the discrete logarithm problem in the BF-GGM (Theorem 5.11). We use here the fact that the reduction would be a <span class="math">(S,(T+Q),P)</span>-algorithm in the BF-GGM for the discrete logarithm problem on instance <span class="math">(g,g^{u})</span> (and in particular does not use <span class="math">u</span> within its execution).</p>

    <h4 id="sec-96" class="text-lg font-semibold mt-6">Case 2: <span class="math">\\ell^{*}=\\ell_{i}</span> where <span class="math">(\\ell_{i},z_{i},m_{i})</span> is the output of a signing query for message <span class="math">m_{i}</span>.</h4>

    <p class="text-gray-300">We show a reduction to the rpsp property of <span class="math">H_{k}</span>. Let <span class="math">Q</span> be the number of signing queries made by <span class="math">\\mathcal{A}_{2}</span>. The reduction guesses <span class="math">i^{<em>}\\leftarrow[Q]</span>, and picks <span class="math">z_{i^{</em>}}\\leftarrow\\mathbb{Z}_{p}</span>. It sets <span class="math">m_{i}</span> for its rpsp experiment, and receives <span class="math">R\\in[L]</span>. It outputs the signature <span class="math">(R,z_{i^{<em>}},m_{i^{</em>}})</span>, and stores the element <span class="math">(R,z_{i^{<em>}},H_{k}(R,m_{i^{</em>}}))</span>. Its adversary <span class="math">\\mathcal{A}_{2}</span> replies with a forgery <span class="math">(\\ell^{<em>},z^{</em>},m^{<em>})</span>. If <span class="math">\\ell^{</em>}\\neq R</span> or if <span class="math">m^{<em>}=m_{i}</span>, the reduction aborts. Otherwise, it outputs <span class="math">m^{</em>}</span> in the rpsp experiment.</p>

    <p class="text-gray-300">First, we show that storing this element <span class="math">(R,z_{i^{<em>}},H_{k}(R,m_{i^{</em>}}))</span> looks consistent with the preprocessing phase, even though <span class="math">R</span> was not among the set of initial labels in the output range <span class="math">\\mathcal{Y}</span> of <span class="math">\\sigma</span> sampled in the</p>

    <p class="text-gray-300">preprocessing phase. This is because <span class="math">\\mathcal{A}_{2}</span> only gets (at most) <span class="math">\\text{poly}(\\lambda)</span> bits of auxiliary information on <span class="math">\\mathcal{Y}</span>, any randomly chosen element of <span class="math">\\mathcal{Y}</span> (implicitly corresponding to the label associated with <span class="math">\\alpha^{<em>}+\\beta^{</em>}u</span>, which is sampled independently after the bit-fixing phase) has (negligibly close to) full entropy even given <span class="math">F</span>. Therefore one can replace any random element of <span class="math">\\mathcal{Y}</span> with <span class="math">R</span> in a statistically indistinguishable manner.</p>

    <p class="text-gray-300">Then, assuming there are no two distinct group elements (queried in the game) with label <span class="math">R</span>, which happens with overwhelming probability over the randomness of the reduction, the view of the forger is identically distributed as in the hybrid <span class="math">H_{2}</span>. Assuming the reduction correctly guesses <span class="math">i^{<em>}</span>, the forgery <span class="math">(\\ell^{</em>},z^{<em>},m^{</em>})</span> is valid if and only if <span class="math">z^{<em>}=z_{i^{</em>}}</span> and <span class="math">m^{<em>}\\neq m_{i^{</em>}}</span>, which implies <span class="math">H_{k}(\\ell_{i},m^{<em>})=H_{k}(\\ell_{i^{</em>}},m_{i^{<em>}})</span> and <span class="math">m^{</em>}\\neq m_{i^{*}}</span>, so that the reduction wins the rpsp experiment of <span class="math">H_{k}</span>.</p>

    <h4 id="sec-97" class="text-lg font-semibold mt-6">Case 3: <span class="math">\\ell^{<em>}\\notin F</span> and <span class="math">\\ell^{</em>}\\neq\\ell_{i}</span> for all signing query answers <span class="math">(\\ell_{i},z_{i},m_{i})</span>.</h4>

    <p class="text-gray-300">Without loss of generality, <span class="math">\\mathcal{A}_{2}</span> has made a query to the reduction, which answered with <span class="math">\\ell^{<em>}</span>; otherwise <span class="math">\\ell^{</em>}</span> does not correspond to a label of a valid group element with high probability. The reduction as a result stored a corresponding tuple <span class="math">(\\ell^{<em>},\\alpha^{</em>},\\beta^{*})</span>. We distinguish two subcases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H_{k}(\\ell^{<em>},m^{</em>})+\\beta^{<em>}\\neq 0</span>. Then the forgery being valid can be rewritten <span class="math">z^{</em>}=\\alpha^{<em>}+u\\cdot(v+H_{k}(\\ell^{</em>},m^{<em>}))</span>, from which the reduction can recover <span class="math">u=(z^{</em>}-\\alpha^{<em>})/(v+H_{k}(\\ell^{</em>},m^{*}))</span> mod <span class="math">p</span>. By the hardness of the discrete logarithm problem in the BF-GGM Theorem 5.11, this can only happen with negligible probability. We use here the fact that the reduction would be a <span class="math">(S,(T+Q),P)</span>-algorithm for the discrete logarithm problem (and in particular does not use <span class="math">u</span> within its execution).</li>

      <li><span class="math">H_{k}(\\ell^{<em>},m^{</em>})+\\beta^{<em>}=0</span>. We show a reduction to the rpp property of <span class="math">H_{k}</span>. Let <span class="math">Q_{G}</span> be the number of group oracle queries on elements that were not previously defined. The reduction picks <span class="math">i^{</em>}\\leftarrow[Q_{G}]</span>. On the <span class="math">i^{<em>}</span>th query to the group oracle, the reduction computes <span class="math">\\alpha^{</em>},\\beta^{<em>}</span> as in hybrid <span class="math">H_{2}</span>, and sets <span class="math">h=-\\beta^{</em>}</span> for the rpp experiment. It receives <span class="math">R\\leftarrow[L]</span> as a result, and stores the tuple <span class="math">(R,\\alpha^{<em>},\\beta^{</em>})</span>. Upon receiving a forgery <span class="math">(\\ell^{<em>},z^{</em>},m^{<em>})</span> from <span class="math">\\mathcal{A}_{2}</span>, if <span class="math">R\\neq\\ell^{</em>}</span>, the reduction aborts. Otherwise it outputs <span class="math">m^{*}</span> in the rpp experiment.</li>

    </ol>

    <p class="text-gray-300">First, we show that storing this element <span class="math">(R,\\alpha^{<em>},\\beta^{</em>})</span> looks consistent with the preprocessing phase, even though <span class="math">R</span> was not among the set of initial labels in the output range <span class="math">\\mathcal{Y}</span> of <span class="math">\\sigma</span> sampled in the preprocessing phase. As argued previously, this is because <span class="math">\\mathcal{A}_{2}</span> only gets (at most) <span class="math">\\text{poly}(\\lambda)</span> bits of auxiliary information on <span class="math">\\mathcal{Y}</span>, and therefore one can replace any random element of <span class="math">\\mathcal{Y}</span> (implicitly corresponding to the label associated with <span class="math">\\alpha^{<em>}+\\beta^{</em>}u</span>, which is sampled independently after the bit-fixing phase) with <span class="math">R</span> in a statistically indistinguishable manner.</p>

    <p class="text-gray-300">Assuming there are no two distinct group elements (queried in the game) with label <span class="math">R</span>, which happens with overwhelming probability over the randomness of the reduction, the view of the forger is identically distributed as in <span class="math">H_{2}</span>. Now assuming the reduction correctly guesses the group oracle query <span class="math">i^{<em>}</span> associated with the forgery <span class="math">\\ell^{</em>}</span>, we have <span class="math">\\ell^{<em>}=R</span>, and <span class="math">H_{k}(R,m^{</em>})=-\\beta^{*}=h</span>, in which the reduction wins the rpp experiment for <span class="math">H_{k}</span>.</p>

    <p class="text-gray-300">This concludes the proof of the theorem.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-98" class="text-xl font-semibold mt-8">5.4 Chaum-Pedersen Protocol</h3>

    <p class="text-gray-300">The Chaum-Pedersen protocol (see Fig. 8) gives an interactive proof of membership for the language Diffie-Hellman tuples</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\text{DH}}\\coloneqq\\{(g,g^{u},g^{v},g^{uv})\\}_{u,v\\in\\mathbb{Z}_{p}}.</span></p>

    <p class="text-gray-300">More precisely, we consider a minor variant where the verifier rejects proofs whenever the last message is <span class="math">0</span>.</p>

    <p class="text-gray-300">We compile the Chaum-Pedersen protocol into a non-interactive protocol satisfying semi-adaptive soundness for the <span class="math">\\mathcal{L}_{\\text{DH}}</span> language. In contrast to fully adaptive soundness, in which the cheating prover attempts to convince the verifier to accept an arbitrary NO-instance of <span class="math">\\mathcal{L}_{\\text{DH}}</span>, the semi-adaptive attacker is forced to</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 8: Protocol  <span class="math">\\Pi^{\\mathrm{CP}}</span>  for proving validity of a DDH tuple.</p>

    <p class="text-gray-300">give a NO-instance whose second group element  <span class="math">g^u</span>  is sampled at random. It then picks  <span class="math">g^v</span>  and  <span class="math">g^w</span>  such that  <span class="math">(g, g^u, g^v, g^w) \\notin \\mathcal{L}_{\\mathrm{DH}}</span> , and wins if the verifier accepts.</p>

    <p class="text-gray-300">In this section, we prove that any fixed Fiat-Shamir hash function  <span class="math">h: G^4 \\to \\mathbb{Z}_p</span>  satisfying the following information theoretic notion suffices to compile Chaum-Pedersen protocol into a semi-adaptively sound argument for  <span class="math">\\mathcal{L}_{\\mathrm{DH}}</span> .</p>

    <p class="text-gray-300">Definition 5.17 (Well-Spread on Repeated Random Inputs). Let  <span class="math">H:[L]^d \\to \\mathbb{Z}_p</span>  be a function. Consider the following random variable  <span class="math">X_{\\mathcal{A}} \\to [L]^d</span>  associated with an (unbounded) adversary  <span class="math">\\mathcal{A}</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span>  produces  <span class="math">d - 1</span>  elements  <span class="math">\\tau_{1},\\ldots ,\\tau_{d - 1}\\in [L]^{d - 1}</span></li>

      <li><span class="math">\\mathcal{A}</span>  receives an uniformly sampled element  <span class="math">\\tau^{<em>} \\gets [L]</span> . Let  <span class="math">E = \\{\\tau_{1}, \\ldots, \\tau_{d-1}, \\tau^{</em>}\\}</span> .</li>

      <li><span class="math">\\mathcal{A}</span>  outputs  <span class="math">(x_{1},\\dots ,x_{d})</span>  such that</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all  <span class="math">i \\in [d]</span> ,  <span class="math">x_i \\in E</span> ;</li>

      <li>There exists (at least) some  <span class="math">i \\in [d]</span>  such that  <span class="math">x_{i} = \\tau^{*}</span> .</li>

    </ul>

    <p class="text-gray-300">We say that  <span class="math">H</span>  is well-spread on repeated random inputs if for all unbounded algorithms  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {H} _ {\\infty} \\left(H \\left(x _ {i _ {1}}, \\dots , x _ {i _ {d}}\\right): \\left(x _ {1}, \\dots , x _ {d}\\right) \\leftarrow X _ {\\mathcal {A}}\\right) = \\omega (\\log \\lambda).</span></div>

    <p class="text-gray-300">We stress that the property defined in Definition 5.17 can be satisfied by very simple hash functions. We give an example below.</p>

    <p class="text-gray-300">Claim 5.18. Let  <span class="math">H_{sum}:[L]^d \\to \\mathbb{Z}_p</span>  be the function which, on input  <span class="math">(x_1,\\ldots ,x_d) \\in [L]^d</span> , computes  <span class="math">\\sum_{i\\leq d}x_i \\mod p</span>  (interpreting the inputs  <span class="math">x_{i}</span>  as integer and reducing the sum modulo  <span class="math">p</span> ).</p>

    <p class="text-gray-300">Suppose  <span class="math">d &amp;lt; p = 2^{\\lambda} &amp;lt; [L]</span> . Then  <span class="math">H_{sum}</span>  is well-spread on random inputs (Definition 5.17).</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathcal{A}</span>  be an unbounded algorithm that outputs  <span class="math">x_{1},\\ldots ,x_{d}\\in [L]^{d}</span> . Let  <span class="math">k</span>  be the number of occurrences of  <span class="math">\\tau^{<em>}</span> : we have  <span class="math">1\\leq k\\leq d &amp;lt; p</span> . We have:  <span class="math">H(x_{1},\\dots ,x_{n}) = k\\tau^{</em>} + \\sum_{i_{j},j\\in [d - k]}\\tau_{i_{j}}</span>  for some indices  <span class="math">i_j</span> . Over the randomness of  <span class="math">\\tau^{<em>}</span>  alone,  <span class="math">H(x_{1},\\dots ,x_{n})</span>  has as much (min-)entropy as  <span class="math">\\tau^{</em>}\\bmod p</span> , which is  <span class="math">\\lambda -O(1)</span> .</p>

    <p class="text-gray-300">For the protocol  <span class="math">\\Pi^{\\mathrm{CP}}</span> , we will consider Fiat-Shamir hash function  <span class="math">H: g^{v}, g^{w}, h_{1}, h_{2} \\mapsto c \\in \\mathbb{Z}_{p}</span> . This is because we will ultimately only guarantee semi-adaptive soundness, where  <span class="math">g^{u}</span>  is picked uniformly independent of the adversary.</p>

    <p class="text-gray-300">Theorem 5.19. Suppose the Fiat-Shamir hash function  <span class="math">H:[L]^4 \\to \\mathbb{Z}_p</span>  is well-spread on repeated random inputs (Definition 5.17). Then the protocol  <span class="math">(\\Pi^{CP})_{FS,H}</span>  is semi-adaptively sound in the BF-GGM against adversaries  <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span>  with advice of size  <span class="math">S = \\mathrm{poly}(\\lambda)</span> ,  <span class="math">T = \\mathrm{poly}(\\lambda)</span>  oracle queries, that fix  <span class="math">P = \\mathrm{poly}(\\lambda)</span>  input-output pairs during the bit-fixing stage.</p>

    <p class="text-gray-300">Combined with Theorem 5.9, we obtain the following:</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Corollary 5.20.</h6>

    <p class="text-gray-300">Suppose the Fiat-Shamir hash function <span class="math">H</span> is well-spread on repeated random inputs (Definition 5.17). Then the protocol <span class="math">(\\Pi^{CP})_{FS,H}</span> is semi-adaptively sound in the AI-GGM against adversaries with polynomially-sized advice and polynomial number of group oracle queries.</p>

    <p class="text-gray-300">We now prove Theorem 5.19.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We consider the bit-fixing generic group model in the linear-query formulation (Definition 5.4).</p>

    <p class="text-gray-300">Suppose a bit-fixing generic group attacker <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> breaks the semi-adaptive soundness of the non-interactive protocol with advantage <span class="math">\\epsilon(\\lambda)</span>. This means <span class="math">\\mathcal{A}_{1}</span>, given the set of labels <span class="math">\\mathcal{Y}=\\{\\tau\\}</span> of all group elements, picks a set of input-output pairs <span class="math">F=\\{(r_{i},\\tau_{i})\\}</span> of size <span class="math">P</span>, and derives from <span class="math">F</span> some auxiliary input <span class="math">\\mathsf{aux}</span> of size <span class="math">S</span>. Then, <span class="math">\\mathcal{A}_{2}</span> instantiated with input <span class="math">(\\sigma(1),\\sigma(u))</span> (and the auxiliary information <span class="math">\\mathsf{aux}</span>) will, with probability <span class="math">\\epsilon(\\lambda)</span> over <span class="math">u</span> and <span class="math">\\sigma</span>, output <span class="math">(\\tau_{v},\\tau_{w})\\in[L]^{2}</span> corresponding to a “no instance” of the DDH language, accompanied by an accepting proof <span class="math">((\\tau_{r},\\tau_{s}),z)</span> where <span class="math">(\\tau_{r},\\tau_{s})\\in[L]^{2}</span> and <span class="math">z\\in\\mathbb{Z}_{p}</span>.</p>

    <p class="text-gray-300">Explicitly, <span class="math">\\mathcal{A}_{2}</span> outputs <span class="math">(\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s},z)</span> satisfying the following conditions with probability <span class="math">\\epsilon(\\lambda)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Condition 1: <span class="math">(\\sigma(u),\\tau_{v},\\tau_{w})</span> is not a valid DDH tuple) Over <span class="math">\\mathbb{Z}_{p}</span>, <span class="math">u\\cdot\\sigma^{-1}(\\tau_{v})\\neq\\sigma^{-1}(\\tau_{w})</span>. If either of <span class="math">\\sigma^{-1}(\\tau_{v})</span> or <span class="math">\\sigma^{-1}(\\tau_{w})</span> do not exist, this condition is failed.</li>

      <li>(Condition 2: the verifier accepts <span class="math">(\\tau_{r},\\tau_{s},z)</span>). The two checks the verifier performs are:</li>

    </ul>

    <p class="text-gray-300"><span class="math">z</span> <span class="math">=\\sigma^{-1}(\\tau_{r})+\\sigma^{-1}(\\tau_{v})\\cdot H(\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s}),</span> (5) <span class="math">u\\cdot z</span> <span class="math">=\\sigma^{-1}(\\tau_{s})+\\sigma^{-1}(\\tau_{w})\\cdot H(\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s}).</span> (6)</p>

    <p class="text-gray-300">In the real protocol, the verifier is checking these relations in the exponent, but the cheating prover must still satisfy them over <span class="math">\\mathbb{Z}_{p}</span>. If either of <span class="math">\\sigma^{-1}(\\tau_{r})</span> or <span class="math">\\sigma^{-1}(\\tau_{w})</span> do not exist, this condition is failed.</p>

    <p class="text-gray-300">Recall that in the linear-query formulation of the GGM (cf. Definition 5.4), any label the attacker <span class="math">\\mathcal{A}_{2}</span> obtains from the group oracle <span class="math">\\mathcal{O}_{lin}</span> is of the form <span class="math">\\sigma(\\alpha\\cdot u+\\beta)</span>, where <span class="math">\\alpha</span> and <span class="math">\\beta</span> are known to the attacker (since <span class="math">\\mathcal{A}</span> explicitly provides <span class="math">\\alpha,\\beta</span> to make the query). Note that <span class="math">\\beta</span> can depend on the values <span class="math">r_{i}\\in\\mathbb{Z}_{p}</span> (contained in <span class="math">F</span>) produced in the preprocessing phase. If any of the labels <span class="math">\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s}</span> that <span class="math">\\mathcal{A}</span> outputs are <em>not</em> the result of a query to <span class="math">\\mathcal{O}_{lin}</span> (or one of <span class="math">\\sigma(1)</span> or <span class="math">\\sigma(u)</span>), nor belong to the set <span class="math">F</span> obtained during the preprocessing phase, then with probability <span class="math">1-O(1/2^{\\lambda})</span> (over the randomness of <span class="math">\\sigma</span>) there will not exist a preimage under <span class="math">\\sigma</span> and the conditions will fail.</p>

    <p class="text-gray-300">Therefore, for any attacker <span class="math">\\mathcal{A}</span>, we can define an attacker that directly outputs those coefficients with overwhelming probability. Up to renaming, we can therefore think of <span class="math">\\mathcal{A}</span> as <em>directly</em> outputting coefficients <span class="math">\\alpha_{v},\\beta_{v},\\alpha_{w},\\beta_{w},\\alpha_{r},\\beta_{r},\\alpha_{s},\\beta_{s}\\in\\mathbb{Z}_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">v</span> <span class="math">=\\alpha_{v}\\cdot u+\\beta_{v},</span> <span class="math">w</span> <span class="math">=\\alpha_{w}\\cdot u+\\beta_{w},</span> <span class="math">r</span> <span class="math">=\\alpha_{r}\\cdot u+\\beta_{r},</span> <span class="math">s</span> <span class="math">=\\alpha_{s}\\cdot u+\\beta_{s},</span></p>

    <p class="text-gray-300">in place of <span class="math">\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s}</span>, as this can only hurt its advantage by an additive <span class="math">O(1/2^{\\lambda})</span>.</p>

    <p class="text-gray-300">We rewrite Eqs. (5) and (6) in terms of <span class="math">\\vec{\\alpha}\\coloneqq(\\alpha_{v},\\alpha_{w},\\alpha_{r},\\alpha_{s})</span> and <span class="math">\\vec{\\beta}\\coloneqq(\\beta_{v},\\beta_{w},\\beta_{r},\\beta_{s})</span>:</p>

    <p class="text-gray-300"><span class="math">z</span> <span class="math">=(\\alpha_{r}\\cdot u+\\beta_{r})+(\\alpha_{v}\\cdot u+\\beta_{v})\\cdot f(\\vec{\\alpha},\\vec{\\beta}),</span> (7) <span class="math">u\\cdot z</span> <span class="math">=(\\alpha_{s}\\cdot u+\\beta_{s})+(\\alpha_{w}\\cdot u+\\beta_{w})\\cdot f(\\vec{\\alpha},\\vec{\\beta}),</span> (8)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">f(\\vec{\\alpha},\\vec{\\beta})\\coloneqq H(\\sigma(\\alpha_{v}+u\\cdot\\beta_{v}),\\sigma(\\alpha_{w}+u\\cdot\\beta_{w}),\\sigma(\\alpha_{r}+u\\cdot\\beta_{r}),\\sigma(\\alpha_{s}+u\\cdot\\beta_{s})).</span></p>

    <p class="text-gray-300">In these equations, the attacker <span class="math">\\mathcal{A}</span> outputs (or can efficiently compute) every value except for <span class="math">u</span>. If these equations can be solved for <span class="math">u</span>, this means the attacker can break discrete log with the same probability</p>

    <p class="text-gray-300">that can satisfy these equations. By Theorem 5.11, a <span class="math">(S,T,P)</span> attacker can only break discrete log in the BF-GGM model with negligible probability <span class="math">O((TP+T^{2})/p)</span>.</p>

    <p class="text-gray-300">Therefore, with probability <span class="math">\\epsilon(\\lambda)-O(1/2^{\\lambda})-O((TP+T^{2})/p)</span>, the attacker outputs <span class="math">\\vec{\\alpha},\\vec{\\beta},z</span> satisfying Eqs. (7) and (8), and furthermore these equations <em>cannot</em> be solved for <span class="math">u</span>. In other words, these equations should not be formally solvable in <span class="math">u</span> as a formal variable. This gives rise to the following four equations, where the first two state the coefficient of <span class="math">u</span> must be equal on both sides of Eqs. (7) and (8), and the last two are the result of setting the constant terms to be equal.</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=\\alpha_{r}+\\alpha_{v}\\cdot f(\\vec{\\alpha},\\vec{\\beta}),</span> (9) <span class="math">z</span> <span class="math">=\\alpha_{s}+\\alpha_{w}\\cdot f(\\vec{\\alpha},\\vec{\\beta}),</span> (10) <span class="math">z</span> <span class="math">=\\beta_{r}+\\beta_{v}\\cdot f(\\vec{\\alpha},\\vec{\\beta}),</span> (11) <span class="math">0</span> <span class="math">=\\beta_{s}+\\beta_{w}\\cdot f(\\vec{\\alpha},\\vec{\\beta}).</span> (12)</p>

    <p class="text-gray-300">We finish the proof by showing that if <span class="math">\\vec{\\alpha},\\vec{\\beta},z</span> does not correspond to a valid DDH tuple, then over the randomness of <span class="math">\\sigma</span>, these equations can only hold with probability <span class="math">O((T+P)^{4}/\\lambda^{\\omega(1)})</span>. This means <span class="math">\\epsilon(\\lambda)-O(1/2^{\\lambda})-O((TP+T^{2})/p)\\leq O((T+P)^{4}/\\lambda^{\\omega(1)})</span>, from which the claimed bound of <span class="math">\\epsilon(\\lambda)\\leq O((T+P)^{4}/\\lambda^{\\omega(1)})</span> follows.</p>

    <p class="text-gray-300">Suppose for a moment that <span class="math">f(\\vec{\\alpha},\\vec{\\beta})</span> is replaced by a formal variable <span class="math">\\mathbf{f}</span> in each of Eqs. (9) to (12). Then for any particular choice of <span class="math">\\vec{\\alpha},\\vec{\\beta}</span>, either (1) none of these equations have any formal dependence on <span class="math">\\mathbf{f}</span> or (2) at least one of these equations determines <span class="math">\\mathbf{f}</span> (if more than one equation determines <span class="math">\\mathbf{f}</span> there may be no solution).</p>

    <p class="text-gray-300">If (1) is the case, then the coefficients of <span class="math">\\mathbf{f}</span> must be equal on both sides in all four equations. This gives rise to the following conditions on <span class="math">\\vec{\\alpha},\\vec{\\beta},z</span>:</p>

    <p class="text-gray-300"><span class="math">\\alpha_{v}</span> <span class="math">=0,</span> <span class="math">\\alpha_{r}</span> <span class="math">=0,</span> <span class="math">\\alpha_{w}</span> <span class="math">=\\beta_{v},</span> <span class="math">\\alpha_{s}</span> <span class="math">=\\beta_{r},</span> <span class="math">\\beta_{w}</span> <span class="math">=0,</span> <span class="math">\\beta_{s}</span> <span class="math">=0,</span> <span class="math">z</span> <span class="math">=\\beta_{r}+\\beta_{v}\\cdot f(\\vec{\\alpha},\\vec{\\beta}).</span></p>

    <p class="text-gray-300">These conditions are equivalent to <span class="math">w=u\\cdot v,s=u\\cdot r</span>, and <span class="math">z=r+H(\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s})\\cdot v</span>, which precisely corresponds to an honest execution of the protocol on a valid DDH tuple.</p>

    <p class="text-gray-300">However, since <span class="math">\\mathcal{A}</span> is outputting <span class="math">(\\vec{\\alpha},\\vec{\\beta},z)</span> corresponding to a DDH “no instance” (with probability <span class="math">\\epsilon(\\lambda)-O(1/2^{\\lambda})-O((TP+T^{2})/p)</span>) this cannot correspond to (1). Therefore, it must be that the choice of <span class="math">\\vec{\\alpha},\\vec{\\beta}</span> determines <span class="math">\\mathbf{f}</span>.</p>

    <p class="text-gray-300">We then distinguish two cases.</p>

    <h5 id="sec-101" class="text-base font-semibold mt-4">Case 1. All the inputs <span class="math">v,w,r,s</span> to the hash function are from the preprocessing stage.</h5>

    <p class="text-gray-300">That is, there exists some elements <span class="math">\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s}</span> such that <span class="math">(v,\\tau_{v}),(w,\\tau_{w}),(r,\\ell_{r}),(s,\\ell_{s})\\in F</span>. In this case, the proof is accepted by the verifier only if <span class="math">(g^{u})^{z}=(h_{2})(g^{w})^{c}</span>, so that <span class="math">u\\cdot z=s+w\\cdot c</span>, where <span class="math">c=H(\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s})</span> and <span class="math">z\\neq 0</span>. As <span class="math">v,w,r</span> and <span class="math">s</span> are computed during the preprocessing phase, and in particular before <span class="math">u</span> is defined, we have that, with overwhelming probability over the randomness of <span class="math">u</span> alone, the verifier rejects the proof. Namely, as <span class="math">z\\neq 0</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{Verifier accepts}]\\leq\\Pr_{u\\leftarrow\\mathbb{Z}_{p}}\\left[u=(s+w\\cdot H(v,w,r,s))\\cdot z^{-1}\\bmod p\\right]=1/p.</span></p>

    <h5 id="sec-102" class="text-base font-semibold mt-4">Case 2. At least one input to the hash function has not been fixed during the preprocessing stage.</h5>

    <p class="text-gray-300">Observe that there are at most <span class="math">(T+P+2)^{4}</span> possible such choices for <span class="math">\\vec{\\alpha},\\vec{\\beta}</span>, since we are already</p>

    <p class="text-gray-300">conditioning on the attacker outputting only <span class="math">(\\alpha,\\beta)</span> pairs corresponding to one of the <span class="math">T</span> queries it made <span class="math">\\mathcal{O}_{Lin}</span>, or one of the two group elements <span class="math">\\sigma(1),\\sigma(u)</span> (i.e. <span class="math">(\\alpha,\\beta)=(0,1)</span> or <span class="math">(1,0)</span>), or ones resulting from the preprocessing phase.</p>

    <p class="text-gray-300">For any such fixed choice of <span class="math">\\vec{\\alpha},\\vec{\\beta}</span>, the value <span class="math">f(\\vec{\\alpha},\\vec{\\beta})</span> will be an evaluation of <span class="math">H</span> on four generic group labels <span class="math">(\\tau_{v},\\tau_{w},\\tau_{r},\\tau_{s})</span>. These labels may be repeated, but at least one (the one not resulting from the preprocessing phase) is (statistically close to) uniformly random by our assumption on the case. Therefore, the well-spread property of <span class="math">H</span> (Definition 5.17) guarantees that <span class="math">H</span> still has min-entropy <span class="math">\\omega(\\log\\lambda)</span>. So the probability that this value of <span class="math">H</span> will equal the prescribed setting for <span class="math">\\mathbf{f}</span> is at most <span class="math">1/2^{\\omega(\\log\\lambda)}</span>. By a union bound over all <span class="math">(T+P+2)^{4}</span> possible choices of <span class="math">(\\vec{\\alpha},\\vec{\\beta})</span>, the probability that the attacker satisfies all the equations is at most <span class="math">(T+P+2)^{4}/2^{\\omega(\\log\\lambda)}</span>. ∎</p>

    <h3 id="sec-103" class="text-xl font-semibold mt-8">5.5 Application: NIZKs for <span class="math">\\mathsf{NP}</span></h3>

    <p class="text-gray-300">We now show that <span class="math">(\\Pi^{\\mathrm{CP}})_{FS,H}</span> can be used to obtain NIZKs for all of <span class="math">\\mathsf{NP}</span>. This follows the recent line work of instantiating the hidden-bits model <em>[x10]</em> from standard assumptions <em>[x11, x23, x26, x12]</em>. In particular, Couteau, Katsumata and Ursu <em>[x12, Theorem 28]</em> show that any NIZK for the language <span class="math">\\mathcal{L}_{\\mathrm{DH}}</span> is sufficient to build so-called Verifiable Pseudorandom Generators (VPRG) <em>[x11]</em> (also known as hidden bits generators <em>[x26]</em>), which in turn allows to instantiate the hidden bits model <em>[x11, x23, x26, x12]</em>.</p>

    <p class="text-gray-300">While the statement of <em>[x12, Theorem 28]</em> specifies that the underlying NIZK for <span class="math">\\mathcal{L}_{\\mathrm{DH}}</span> be <em>adaptively sound</em>, we note that our notion of semi-adaptive soundness suffices. This is because in the proof of <em>[x12, Theorem 28]</em> the <span class="math">g^{u}</span> component of the Diffie-Hellman tuple is randomly sampled and included in the common reference string of the VPRG; this is something which the malicious prover does not have any control over. This gives the following theorem:</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Theorem 5.21 (NIZKs for <span class="math">\\mathcal{L}_{\\mathrm{DH}}</span> imply NIZKs for all of <span class="math">\\mathsf{NP}</span>, adapted from <em>[x12]</em>).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\Pi</span> is a semi-adaptively sound, single-theorem zero-knowledge NIZK argument for <span class="math">\\mathcal{L}_{\\mathrm{DH}}</span>. Then, under the CDH assumption, there exists an (adaptively sound, adaptively multi-theorem) NIZK argument for all of <span class="math">\\mathsf{NP}</span>.</p>

    <p class="text-gray-300">As is, our protocol <span class="math">(\\Pi^{\\mathrm{CP}})_{FS,H}</span> is in the plain model, and is therefore not zero-knowledge (assuming deciding DDH is not in <span class="math">\\mathsf{BPP}</span>). However, one can generically add single-theorem zero-knowledge in the following way. We now use a common random string <span class="math">\\mathsf{crs}\\coloneqq\\rho\\leftarrow\\mathbb{Z}_{p}</span> and define our new hash function <span class="math">H_{\\rho}=H+\\rho</span>. This makes <span class="math">H_{\\rho}</span> 1-wise independent, and allows to lift honest-verifier zero-knowledge of <span class="math">\\Pi^{\\mathrm{CP}}</span> to single-theorem zero-knowledge of <span class="math">(\\Pi^{\\mathrm{CP}})_{FS,H}</span> in the CRS model (by having the simulator program <span class="math">\\rho</span> to map the challenge <span class="math">c</span> to the honest-verifier simulator challenge).</p>

    <h2 id="sec-105" class="text-2xl font-bold">6 Negative Results for Fiat-Shamir with Non-Cryptographic Hash Functions</h2>

    <p class="text-gray-300">In this section, we give evidence that in contrast to our positive results (Section 5, Section 4), Fiat-Shamir for certain protocols <em>necessarily requires</em> a cryptographic hash function. Our prototypical example of such an interactive protocol is Blum’s protocol for graph Hamiltonicity <em>[x5]</em>, but our results extend to a broad class of 3-message HVZK argument systems.</p>

    <p class="text-gray-300">Our results have two different forms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We show that even if one is willing to use an oracle (such as a random oracle or a generic group oracle) to instantiate the 3-message protocol (such as Blum), there is an unconditional break of soundness in the resulting Fiat-Shamir protocol for any hash function <span class="math">h</span> that <em>does not make use of the oracle</em>. This stands in contrast to our results in Section 5, where idealized (GGM) assumptions about 3-message protocols <em>did</em> suffice for the soundness of Fiat-Shamir with an oracle independent hash function.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We describe a concrete security property (which we call “mix-and-match resistance” (Definition 6.8)) such that for any protocol <span class="math">\\Pi</span> in a large class <span class="math">\\mathcal{C}</span>, any hash function (family) <span class="math">\\mathcal{H}</span> that instantiates Fiat-Shamir for <span class="math">\\Pi</span> must possess this security property. This result also holds relative to natural oracle distributions <span class="math">\\mathcal{O}</span>, which further establishes that the “mix-and-match resistance” property of <span class="math">\\mathcal{H}</span> is not “borrowing hardness” from the protocol. This stands in contrast to our results in Section 4, where a simple and non-cryptographic hash function was provably sufficient to instantiate Fiat-Shamir in the standard model.</li>

    </ul>

    <p class="text-gray-300">Moreover, we show that mix-and-match resistant hash functions imply the existence of one-way functions, allowing us to conclude that <span class="math">\\mathcal{H}</span> (if it instantiates Fiat-Shamir soundly) can be used to construct a one-way function.</p>

    <p class="text-gray-300">The two kinds of results are closely related. As described in the technical overview (Section 2), our attacks in the random oracle model (for example) make only a polynomial number of queries to the oracle but require solving some oracle-independent problem in unbounded time. Our concrete security property is then the claim that this oracle-independent problem cannot be solved in polynomial time.</p>

    <p class="text-gray-300">Of course, for this methodology to work, we have to ensure that the oracle-independent problem above actually has an information-theoretic solution. We begin (Section 6.1) with a technical lemma that will guarantee such an information-theoretic solution; this lemma is also used to show that the security property implies that OWFs exist in Section 6.4. We then prove impossibility results for instantiating Fiat-Shamir for the Blum protocol (Section 6.2) and then state and prove our two general negative results (Section 6.3 and Section 6.4).</p>

    <h3 id="sec-106" class="text-xl font-semibold mt-8">6.1 Main Information-Theoretic Lemma</h3>

    <p class="text-gray-300">Let <span class="math">A^{(1)},\\ldots,A^{(t)}</span> be arbitrary <span class="math">q\\times w</span> binary matrices, and let <span class="math">f:\\{0,1\\}^{wt}\\to\\Sigma^{t}</span> be an arbitrary function. Finally, let <span class="math">y^{(1)},\\ldots,y^{(t)}\\leftarrow\\Sigma^{q}</span> be i.i.d. uniformly random elements of <span class="math">\\Sigma^{q}</span>.</p>

    <p class="text-gray-300">For any vector <span class="math">v\\in[q]^{t}</span>, fix the notation <span class="math">A[v]=(A^{(1)}_{v_{1}},\\ldots,A^{(t)}_{v_{t}})</span> and <span class="math">y[v]=(y^{(1)}_{v_{1}},\\ldots,y^{(t)}_{v_{t}})</span>.</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Lemma 6.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $q\\geq t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda<span class="math">, then with </span>1-O\\left(\\frac{1}{\\lambda t}\\right)<span class="math"> probability, there exists a vector </span>v\\in[q]^{t}<span class="math"> such that </span>f(A[v])=y[v]<span class="math">. Moreover, with probability </span>1-O\\left(\\frac{1}{\\lambda t}\\right)<span class="math">, the number of such </span>v<span class="math"> is at least </span>\\frac{1}{2}\\left(\\frac{q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{t}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-108" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For every vector <span class="math">v</span>, define the random variable <span class="math">X_{v}=\\chi\\Big{(}f(A[v])=y[v]\\Big{)}</span> (i.e., the indicator variable for <span class="math">v</span> being a solution to our problem). Define <span class="math">X=\\sum_{v}X_{v}</span>. We will show that <span class="math">X&gt;\\frac{1}{2}\\cdot\\mathbf{E}[X]</span> with high probability.</p>

    <p class="text-gray-300">To do this, we apply the second moment method (Chebyshev’s inequality). We first compute</p>

    <p class="text-gray-300"><span class="math">\\mathbf{E}\\left[X\\right]</span> <span class="math">=\\sum_{v\\in[q]^{t}}\\mathbf{E}[X_{v}]</span> <span class="math">=\\sum_{v\\in[q]^{t}}\\Pr\\left[f(A[v])=y[v]\\right]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$=\\sum_{v\\in[q]^{t}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-t}=\\left(\\frac{q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{t}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The third equality holds because for any vector <span class="math">v</span>, the random variable <span class="math">y[v]</span> is uniform over <span class="math">\\Sigma^{t}</span>. We next compute the second moment of <span class="math">X</span>, as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{E} \\left[ X ^ {2} \\right] = \\sum_ {v, w \\in [ q ] ^ {t}} \\mathbf {E} \\left[ X _ {v} X _ {w} \\right] \\\\ = \\sum_ {d = 0} ^ {t} \\sum_ {\\substack {v, w \\in [ q ] ^ {t} \\\\ \\delta_ {\\mathrm {H}} (v, w) = d}} \\mathbf {E} [ X _ {v} X _ {w} ], \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\delta_{\\mathrm{H}}(v,w)</span> denotes <span class="math">\\Sigma</span>-Hamming distance (the number of symbols on which <span class="math">v</span> and <span class="math">w</span> disagree). We claim that for every <span class="math">v, w</span> such that <span class="math">\\delta_{\\mathrm{H}}(v, w) = d</span>, <span class="math">\\mathbf{E}[X_v X_w] \\leq 2^{-t - d}</span>. This can be seen by the calculation</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\mathbf {E} \\left[ X _ {v} X _ {w} \\right] = \\Pr \\left[ f (A [ v ]) = y [ v ] \\text{ AND } f (A [ w ]) = y [ w ] \\right] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {- t} \\Pr \\left[ f (A [ w ]) = y [ w ] \\mid f (A [ v ]) = y [ v ] \\right] \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the last inequality follows from the fact that <span class="math">y[w]</span> has $d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-bits of min-entropy given </span>y[v]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, we complete the calculation</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\mathbf{E}[X^{2}] = \\sum_{d = 0}^{t}\\sum_{\\substack{v,w\\in [q]^{t}\\\\ \\delta_{\\mathrm{H}}(v,w) = d}}\\mathbf{E}[X_{v}X_{w}] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_{d = 0}^{t}\\sum_{\\substack{v,w\\in [q]^{t}\\\\ \\delta_{\\mathrm{H}}(v,w) = d}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-t - d} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\left(\\frac {q}{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right) ^ {2 t} \\sum_ {d = 0} ^ {t} \\binom {t} {d} \\left(\\frac {</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">}{q}\\right) ^ {t - d}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Thus, we can bound</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname {V a r} [ X ] = \\mathbf {E} [ X ^ {2} ] - \\mathbf {E} [ X ] ^ {2} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left(\\frac {q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {2 t} \\sum_ {d = 0} ^ {t - 1} \\binom {t} {d} \\left(\\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{q}\\right) ^ {t - d} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We conclude that when $q \\geq t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\operatorname {V a r} [ X ]}{\\mathbf {E} [ X ] ^ {2}} = O \\left(\\frac {1}{\\lambda t}\\right),</span></div>

    <p class="text-gray-300">which implies that <span class="math">\\operatorname*{Pr}\\left[X &amp;gt; \\frac{1}{2} \\cdot \\mathbf{E}[X]\\right] \\geq 1 - O\\left(\\frac{1}{\\lambda t}\\right)</span> by Chebyshev's inequality.</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">In this section, we give a simple example of a negative result that we can prove using our methods. In particular, we consider an idealized variant of Blum's Hamiltonicity protocol [Blu86] in which the commitment scheme is instantiated with a random oracle. We show that even for this idealized variant of the Blum protocol, a (successful) Fiat-Shamir hash function  <span class="math">H</span>  for this protocol necessarily satisfies a cryptographic security property.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 9: The Zero Knowledge Proof System  <span class="math">\\Pi^{\\mathrm{Blum}}</span>  for Graph Hamiltonicity.</p>

    <p class="text-gray-300">The Blum protocol  <span class="math">\\Pi</span>  is described in Fig. 9. For this example, we instantiate  <span class="math">\\mathsf{Com}(b;r) = \\mathcal{O}(x,r)</span>  as an idealized bitwise commitment scheme in the random oracle model.  <span class="math">\\Pi</span>  is repeated  <span class="math">t</span>  times in parallel to obtain soundness error  <span class="math">2^{-t}</span> . We now give a polynomial-query attack on  <span class="math">\\Pi_{\\mathrm{FS},H}^{t}</span>  for any hash function  <span class="math">H</span>  that does not invoke the oracle <span class="math">^{14}</span> <span class="math">\\mathcal{O}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">H</span>  denote a candidate Fiat-Shamir hash function for the above protocol  <span class="math">\\Pi_{\\mathrm{Blum}}</span>  when iterated  <span class="math">t</span>  times in parallel. Consider the following attack on the Fiat-Shamir protocol  <span class="math">\\Pi_{\\mathrm{FS},H}^{t}</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">1 \\leq i \\leq t, 1 \\leq \\ell \\leq q</span> , sample a random bit  <span class="math">y_{\\ell}^{(i)} \\gets \\{0,1\\}</span>  and sample message  <span class="math">\\alpha_{\\ell}^{(i)}</span> : if  <span class="math">y_{\\ell}^{(i)} = 0</span> , sample  <span class="math">\\alpha_{\\ell}^{(i)}</span>  as in the honest protocol, while if  <span class="math">y_{\\ell}^{(i)} = 1</span> , and sample  <span class="math">\\alpha_{i}^{(\\ell)}</span>  as a commitment to a cycle graph.</li>

      <li>Find  <span class="math">v \\in [q]^t</span>  such that  <span class="math">H(\\alpha[v]) = y[v]</span> .</li>

      <li>Output  <span class="math">\\alpha[v]</span>  as well as the necessary decommitments to  <span class="math">\\alpha[v]</span>  (either the entire graph or just the edges in the cycle).</li>

    </ol>

    <p class="text-gray-300">By Lemma 6.1, as long as  <span class="math">q = \\omega(t)</span> , Step (2) has a solution with high probability over  <span class="math">(\\alpha, y)</span>  (because the joint distribution  <span class="math">(\\alpha, y)</span>  is statistically close to uniform). Therefore, this constitutes a poly-query attack on the protocol  <span class="math">\\Pi_{\\mathrm{FS}, H}^{t}</span>  in the random oracle model. Moreover, if the computational problem in Step (2) (which does not depend on  <span class="math">\\mathcal{O}</span> ) can be solved efficiently, then there is a poly-time attack on  <span class="math">\\Pi_{\\mathrm{FS}, H}^{t}</span> .</p>

    <p class="text-gray-300">We now generalize our negative result for  <span class="math">\\Pi_{\\mathrm{Blum}}</span>  to a broader class of interactive arguments. Namely, we consider a class of 3-message public-coin honest-verifier zero-knowledge arguments relative to an arbitrary oracle (or efficiently simulatable oracle distribution)  <span class="math">\\mathcal{O}</span>  and give polynomial-query attacks on resulting Fiat-Shamir protocols for any (oracle-independent) hash function  <span class="math">h</span> .</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Definition 6.2 (HVZK Arguments relative to an Oracle).</h6>

    <p class="text-gray-300">An interactive argument system <span class="math">\\Pi^{\\mathcal{O}(\\cdot)}=(P^{\\mathcal{O}(\\cdot)},V^{\\mathcal{O}(\\cdot)})</span> for a language <span class="math">L</span> (with witness relation <span class="math">R_{L}</span>) built relative to an oracle distribution <span class="math">\\mathcal{O}</span> is an HVZK argument system relative to <span class="math">\\mathcal{O}</span> if it satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For any <span class="math">(x,w)\\in R_{L}</span>, at the end of an interaction <span class="math">\\langle P^{\\mathcal{O}(\\cdot)}(x,w),V^{\\mathcal{O}(\\cdot)}(x)\\rangle</span>, the verifier outputs <span class="math">1</span> with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span>.</li>

      <li>Soundness error <span class="math">\\epsilon</span>: For any <span class="math">x\\not\\in L</span> and any efficient <span class="math">P^{<em>\\mathcal{O}(\\cdot)}</span>, <span class="math">V^{\\mathcal{O}(\\cdot)}(x)</span> (in an interaction with <span class="math">P^{</em>}</span>) outputs <span class="math">1</span> with probability at most <span class="math">\\epsilon</span>.</li>

      <li>Honest-Verifier Zero Knowledge: There exists a polynomial-time simulator <span class="math">\\mathsf{Sim}^{\\mathcal{O}(\\cdot)}</span> such that for every <span class="math">(x,w)\\in R_{L}</span>, the following indistinguishability holds:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Sim}^{\\mathcal{O}(\\cdot)}(x)\\approx\\mathsf{view}_{V}\\langle P^{\\mathcal{O}(\\cdot)}(x,w),V^{\\mathcal{O}(\\cdot)}(x;r)\\rangle.</span></p>

    <p class="text-gray-300">That is, the simulator outputs a verifier view that is indistinguishable from the honest verifier’s view in an interaction with an honest prover.</p>

    <p class="text-gray-300">We emphasize that the Simulator is only given query access to <span class="math">\\mathcal{O}</span>; it may not program the oracle.</p>

    <p class="text-gray-300">Two Variants: We say that <span class="math">\\Pi^{\\mathcal{O}}(\\cdot)</span> satisfies HVZK against query-bounded adversaries if simulation indistinguishability holds with respect to all polynomial-query distinguishers. We say that <span class="math">\\Pi^{\\mathcal{O}(\\cdot)}</span> satisfies HVZK against polynomial-time adversaries if the indistinguishability holds with respect to all polynomial-time distinguishers.</p>

    <p class="text-gray-300">For our negative results, we focus on protocols <span class="math">\\Pi^{\\mathcal{O}(\\cdot)}</span> satisfying the following conditions</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public Coin: The verifier messages are assumed to be sampled publicly (no internal verifier state) and uniformly at random. This restriction is necessary for Fiat-Shamir to be well-defined syntactically.</li>

      <li>3-Messages: We assume that <span class="math">\\Pi</span> consists of only three rounds of interaction. This is mainly for simplicity of the analysis.</li>

      <li>Small Challenge Space: We assume that the verifier’s message is an element of a polynomial-size alphabet <span class="math">\\Sigma</span>. Fiat-Shamir is then applied to the protocol <span class="math">\\Pi^{t}</span> repeated <span class="math">t=\\omega(1)</span> times in parallel.</li>

    </ul>

    <p class="text-gray-300">We note that for such protocols, the honest-verifier zero knowledge property is equivalent to special honest-verifier zero knowledge:</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Definition 6.3 (Special Honest-Verifier Zero Knowledge).</h6>

    <p class="text-gray-300">A <span class="math">3</span>-message public-coin protocol <span class="math">\\Pi^{\\mathcal{O}(\\cdot)}</span> is special honest-verifier zero knowledge if there exists a simulator <span class="math">\\mathsf{Sim}(x,\\beta)\\to(\\alpha,\\gamma)</span> such that for all <span class="math">(x,w)\\in R_{L}</span> and all verifier messages <span class="math">\\beta</span>, <span class="math">\\mathsf{Sim}(x,\\beta)</span> is (computationally/query-bounded) indistinguishable from the distribution <span class="math">\\{(\\alpha,\\mathsf{state})\\leftarrow P(x,w),\\gamma\\leftarrow P(\\mathsf{state},\\beta):(\\alpha,\\gamma)\\}</span>.</p>

    <p class="text-gray-300">We now prove our two negative results on Fiat-Shamir using information-theoretic hash functions. For our first result, we generalize the polynomial-query attack on Blum. This attack requires one further property of the protocol <span class="math">\\Pi</span>: a variant of “zero-knowledge” that even holds for false statements:</p>

    <h6 id="sec-113" class="text-base font-medium mt-4">Definition 6.4 (Challenge Hiding).</h6>

    <p class="text-gray-300">For a 3-message special honest-verifier zero knowledge protocol <span class="math">\\Pi</span>, we say that the SHVZK simulator <span class="math">\\mathsf{Sim}</span> is <em>challenge hiding</em> if for all <span class="math">x</span> (not necessarily true statements) and all challenges <span class="math">\\beta,\\beta^{\\prime}\\in\\Sigma</span>, the following (computational/query-bounded) indistinguishability holds:</p>

    <p class="text-gray-300"><span class="math">\\Big{\\{}(\\alpha,\\gamma)\\leftarrow\\mathsf{Sim}(x,\\beta):\\alpha\\Big{\\}}\\approx\\Big{\\{}(\\alpha^{\\prime},\\gamma^{\\prime})\\leftarrow\\mathsf{Sim}(x,\\beta^{\\prime}):\\alpha^{\\prime}\\Big{\\}}.</span></p>

    <p class="text-gray-300">That is, simulated first messages hide their corresponding challenges.</p>

    <p class="text-gray-300">The above definition is a worst-case notion, meaning that we require that the property holds for every false statement (and every true statement). We also consider an average-case variant:</p>

    <h6 id="sec-114" class="text-base font-medium mt-4">Definition 6.5 (Average-Case Challenge Hiding).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> denote a 3-message special honest-verifier zero knowledge protocol <span class="math">\\Pi</span> for a language <span class="math">L</span>, and let <span class="math">\\mathcal{D}</span> be a distribution on NO-instances. We say that the SHVZK simulator <span class="math">\\mathsf{Sim}</span> is <em>challenge hiding on average</em> if the following two distributions are (computationally/query-bounded) indistinguishable:</p>

    <p class="text-gray-300"><span class="math">\\Big{\\{}x\\leftarrow\\mathcal{D},\\beta\\leftarrow\\Sigma,(\\alpha,\\gamma)\\leftarrow\\mathsf{Sim}(x,\\beta):(x,\\alpha,\\beta)\\Big{\\}}\\approx\\Big{\\{}x\\leftarrow\\mathcal{D},\\beta,\\beta^{\\prime}\\leftarrow\\Sigma,(\\alpha,\\gamma)\\leftarrow\\mathsf{Sim}(x,\\beta^{\\prime}):(x,\\alpha,\\beta)\\Big{\\}}.</span></p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Remark 6.6.</h6>

    <p class="text-gray-300">As long as the oracle distribution <span class="math">\\mathcal{O}</span> is efficiently simulatable (such as a random oracle or a GGM oracle), any Special HVZK protocol <span class="math">\\Pi</span> with simulator <span class="math">\\mathsf{Sim}</span> is challenge-hiding against polynomial-time adversaries <em>for at least one false statement</em> <span class="math">x</span> assuming that the underlying language <span class="math">L</span> is hard. Moreover, if <span class="math">L</span> is decisionally hard-on-average – meaning that there are computationally indistinguishable distributions <span class="math">\\mathcal{D}_{Yes}\\approx_{c}\\mathcal{D}_{No}</span> on YES-instances and NO-instances, respectively – then <span class="math">(\\Pi,\\mathsf{Sim})</span> is average-case challenge hiding for the distribution <span class="math">\\mathcal{D}_{No}</span>. However, challenge hiding against query-bounded adversaries does not follow formally from hardness of the underlying language and SHVZK.</p>

    <h6 id="sec-116" class="text-base font-medium mt-4">Theorem 6.7.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\Pi:=\\Pi^{\\mathcal{O}(\\cdot)}</span> is a 3-message public-coin HVZK argument system (with simulator <span class="math">\\mathsf{Sim}</span>) relative to an (efficiently simulatable) oracle distribution <span class="math">\\mathcal{O}</span> satisfying <em>query-bounded</em> HVZK. Moreover, suppose that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The underlying language <span class="math">L\\not\\in\\mathsf{BPP}</span>,</li>

      <li>The Verifier’s challenge space <span class="math">\\Sigma</span> is polynomial-size, and</li>

      <li><span class="math">(\\Pi,\\mathsf{Sim})</span> is challenge hiding (Definition 6.4).</li>

    </ol>

    <p class="text-gray-300">Then, for any <span class="math">t</span> and any hash function <span class="math">h</span> (that does not query the oracle), the protocol <span class="math">\\Pi^{t}_{\\mathrm{FS},h}</span> is unsound relative to <span class="math">\\mathcal{O}</span>. Alternatively, if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L</span> is hard-on-average for a distribution <span class="math">\\mathcal{D}</span> on no-instances</li>

      <li><span class="math">\\Sigma</span> is polynomial-size, and</li>

      <li><span class="math">(\\Pi,\\mathsf{Sim})</span> is <span class="math">\\mathcal{D}</span>-average-case challenge hiding,</li>

    </ol>

    <p class="text-gray-300">then <span class="math">\\Pi^{t}_{\\mathrm{FS},h}</span> is unsound as above.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the “worst-case” variant of the theorem; the “average-case” variant follows by an almost identical argument.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We describe a polynomial-query attack on <span class="math">\\Pi^{t}_{\\mathrm{FS},h}</span>. Given the oracle <span class="math">\\mathcal{O}</span> and an instance <span class="math">x</span>, do the following, with parameter $q=t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">1\\leq i\\leq t</span>, <span class="math">1\\leq\\ell\\leq q</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a uniformly random challenge <span class="math">\\beta_{i}^{(\\ell)}\\leftarrow\\Sigma</span></li>

      <li>Sample fake transcripts <span class="math">(\\alpha_{i}^{(\\ell)},\\gamma_{i}^{\\ell)})\\leftarrow\\mathsf{Sim}^{\\mathcal{O}(\\cdot)}(x,\\beta_{i}^{(\\ell)})</span> using the special honest-verifier zero-knowledge simulator.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">(\\alpha,\\beta)</span>, search for a vector <span class="math">v\\in[q]^{t}</span> such that <span class="math">h(\\alpha[v])=\\beta[v]</span>.</li>

      <li>If such a <span class="math">v</span> exists, output <span class="math">(\\alpha[v],\\beta[v],\\gamma[v])</span>.</li>

    </ol>

    <p class="text-gray-300">We claim that for some <span class="math">x\\not\\in L</span>, this attack outputs an accepting transcript with high probability. To prove this, we have to show two things occur (with non-negligible probability): Step (2) successfully finds a vector <span class="math">v</span> as described, and that the resulting transcript is accepting.</p>

    <p class="text-gray-300">We first show that the former event occurs for <em>every</em> <span class="math">x</span>. To see this, consider the following hybrid experiment (cut off at step (2)):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">1\\leq i\\leq t</span>, <span class="math">1\\leq\\ell\\leq q</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample i.i.d. uniformly random challenges <span class="math">\\beta_{i}^{(\\ell)},\\tilde{\\beta}_{i}^{(\\ell)}\\leftarrow\\Sigma</span>.</li>

      <li>Sample fake transcripts <span class="math">(\\alpha_{i}^{(\\ell)},\\gamma_{i}^{\\ell)})\\leftarrow\\mathsf{Sim}^{\\mathcal{O}(\\cdot)}(x,\\tilde{\\beta}_{i}^{(\\ell)})</span> using the special honest-verifier zero-knowledge simulator.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">(\\alpha,\\beta)</span>, search for a vector <span class="math">v\\in[q]^{t}</span> such that <span class="math">h(\\alpha[v])=\\beta[v]</span>.</li>

    </ol>

    <p class="text-gray-300">We claim that the probability that such a vector <span class="math">v</span> exists in the hybrid experiment is indistinguishable from the analogous probability in the real attack. This follows from the Challenge-Hiding property of <span class="math">(\\Pi,\\mathsf{Sim})</span> (since in both experiments, only polynomially many queries are made to <span class="math">\\mathcal{O}</span>).</p>

    <p class="text-gray-300">Moreover, in the hybrid experiment, the probability that such a vector <span class="math">v</span> exists is <span class="math">1-O(\\frac{1}{M})</span> by Lemma 6.1. Therefore, we conclude that for all statements <span class="math">x</span>, our attack successfully outputs a tuple <span class="math">(\\alpha[v],\\beta[v],\\gamma[v])</span> such that <span class="math">h(\\alpha[v])=\\beta[v]</span> with high probability.</p>

    <p class="text-gray-300">To complete the proof of Theorem 6.7, we show that there exists some <span class="math">x\\not\\in L</span> such that with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span> over the randomness of each <span class="math">(\\alpha_{i}^{(\\ell)},\\gamma_{i}^{(\\ell)})\\leftarrow\\mathsf{Sim}(x,\\beta_{i}^{(\\ell)})</span>, the transcript <span class="math">(\\alpha_{i}^{(\\ell)},\\beta_{i}^{(\\ell)},\\gamma_{i}^{(\\ell)})</span> is accepting. This follows from the SHVZK simulation security of <span class="math">\\Pi</span>, the completeness of <span class="math">\\Pi</span>, as well as the hardness of <span class="math">L</span>. In more detail, by the completeness and SHVZK of <span class="math">\\Pi</span>, we know that simulated transcripts <span class="math">(\\alpha_{i}^{(\\ell)},\\beta_{i}^{(\\ell)},\\gamma_{i}^{(\\ell)})</span> are accepting with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span> whenever <span class="math">x\\in L</span>. Since this property can be verified in polynomial time, we conclude that if <span class="math">L\\not\\in\\mathsf{BPP}</span>, there exists some <span class="math">x\\not\\in L</span> such that simulated transcripts are accepting with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span> as well.</p>

    <p class="text-gray-300">Thus, we conclude that our polynomial-query attack breaks the soundness of <span class="math">\\Pi^{t}_{\\mathrm{FS},h}</span>, completing the proof of Theorem 6.7. ∎</p>

    <p class="text-gray-300">As a corollary to Theorem 6.7, we obtain explicit polynomial-query attacks on the soundness of <span class="math">\\Pi^{t}_{\\mathrm{FS},h}</span> – for any hash function <span class="math">h</span> – for a large class of interactive protocols <span class="math">\\Pi</span>. For example, any “commit-challenge-response” style argument system <em>[x10, x23, x25]</em> instantiated using a commitment scheme that is hiding against bounded-query adversaries in the ROM satisifes the hypotheses of Theorem 6.7, and so Fiat-Shamir cannot be instantiated for such protocols if the Fiat-Shamir hash function does not depend on the random oracle. An analogous result holds for the “single bit challenge” variant of the Schnorr identification protocol <em>[x39]</em> in the generic group model.</p>

    <h3 id="sec-118" class="text-xl font-semibold mt-8">6.4 A General “Cryptography is Necessary” Result</h3>

    <p class="text-gray-300">We move on to our second result, which states that for a broad class of interactive protocols, any sound Fiat-Shamir hash function <span class="math">h</span> (or family <span class="math">\\mathcal{H}</span>) necessarily satisfies a cryptographic security property. This result holds both in the standard model and relative to any efficiently simulatable oracle distribution (which makes the negative result even stronger). The security property we consider is a computational hardness assumption about making Lemma 6.1 effective.</p>

    <h4 id="sec-119" class="text-lg font-semibold mt-6">6.4.1 Mix-and-Match Resistance</h4>

    <h6 id="sec-120" class="text-base font-medium mt-4">Definition 6.8 (<span class="math">(q,\\Sigma)</span>-Mix-and-Match Resistance).</h6>

    <p class="text-gray-300">A hash function (family) <span class="math">\\mathcal{H}</span> with output space <span class="math">\\Sigma^{t}</span> is <em>mix-and-match resistant</em> with parameters <span class="math">(q,\\Sigma)</span> if a computationally bounded adversary cannot win the following game with non-negligible probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger samples a hash function <span class="math">H\\leftarrow\\mathcal{H}</span>.</li>

      <li>The challenger samples <span class="math">t</span> uniformly random <span class="math">q\\times w</span> matrices <span class="math">A^{(1)},\\ldots,A^{(t)}</span> as well as uniformly random <span class="math">y^{(1)},\\ldots,y^{(t)}\\leftarrow\\Sigma^{q}</span>.</li>

      <li>The challenger sends <span class="math">(H,A,y)</span> to the adversary.</li>

      <li>The adversary outputs a string <span class="math">v\\in[q]^{t}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adversary wins if <span class="math">y[v]=H(A[v])</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 6.1, we know that for $q\\geq t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda<span class="math">, an unbounded adversary can win the mix-and-match resistance security game with probability </span>1-o(1)<span class="math">. We emphasize that the matrices </span>A^{(1)},\\ldots,A^{(t)}<span class="math"> are uniformly random in Definition 6.8 so that mix-and-match resistance is a single, universal security property that will not depend on the protocols </span>\\Pi$ discussed below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">While Lemma 6.1 implies that mix-and-match resistance is a non-trivial security property, it is a priori unclear how this relates to more standard cryptographic objects such as one-way functions. We now show that mix-and-match resistant hash functions imply the existence of one-way functions; in fact, a simple variant of the hash function itself will be a <em>weak</em> OWF.</p>

    <h6 id="sec-121" class="text-base font-medium mt-4">Lemma 6.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">\\mathcal{H}</span> (with output space <span class="math">\\Sigma^{t}</span>) is <span class="math">(q,\\Sigma)</span> mix-and-match resistant for some $q\\geq t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda$. Then, the function</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">g:(h,A,y,v)\\mapsto(h,A,y,h(A[v])-y[v]),</span></p>

    <p class="text-gray-300">where <span class="math">A\\leftarrow(\\{0,1\\}^{q\\times w})^{t}</span>, <span class="math">y\\leftarrow(\\Sigma^{q})^{t}</span>, and <span class="math">v\\leftarrow[q]^{t}</span>, is a weak one-way function.</p>

    <h6 id="sec-122" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Define the function <span class="math">f(v)=f_{h,A,y}(v)=h(A[v])-y[v]</span>. We start by noting that mix-and-match resistance of <span class="math">\\mathcal{H}</span> is the computational hardness of the following problem: given a random <span class="math">(h,A,y)</span>, find <span class="math">v</span> such that <span class="math">f_{h,A,y}(v)=0</span>. Meanwhile, we want to prove that it is (mildly) hard, given a random tuple <span class="math">(h,A,y,z=f_{h,A,y}(v^{\\prime}))</span>, to find some <span class="math">v</span> such that <span class="math">f_{h,A,y}(v)=z</span>.</p>

    <p class="text-gray-300">As an intermediate step, we note that mix-and-match resistance <em>also</em> implies that it is computationally hard to find an <span class="math">f</span>-inverse of a <em>uniformly random</em> string <span class="math">r</span> (instead of <span class="math">0</span>). To see this, suppose that an adversary <span class="math">\\mathcal{A}^{\\prime}(h,A,y,r)</span> outputs <span class="math">v</span> such that <span class="math">f_{h,A,y}(v)=r</span> with non-negligible probability. To break mix-and-match resistance, given <span class="math">h,A,y</span>, one can sample a random <span class="math">r</span>, define <span class="math">y^{\\prime(i)}=y^{(i)}-r</span>, and call <span class="math">\\mathcal{A}^{\\prime}(h,A,y^{\\prime},r)</span>. This call to <span class="math">\\mathcal{A}</span> has the correct distribution and will therefore find a <span class="math">v</span> such that <span class="math">h(A[v])-y^{\\prime}[v]=r</span> with non-negligible probability. This equation implies that <span class="math">h(A[v])=y[v]</span>, completing the reduction.</p>

    <p class="text-gray-300">Finally, we show that <span class="math">g:(h,A,y,v)\\mapsto(h,A,y,f_{h,A,y}(v))</span> is weakly one-way. Suppose that an adversary <span class="math">\\mathcal{A}(h,A,y,z)</span> inverts <span class="math">g</span> with probability <span class="math">\\geq\\frac{3}{4}</span>. We claim that the same adversary <span class="math">\\mathcal{A}</span> inverts <span class="math">g</span> on input <span class="math">(h,A,y,r)</span> (for uniformly random <span class="math">r</span>) with non-negligible probability. To see this, we let <span class="math">E</span> denote the event on tuples <span class="math">(h,A,y,z)</span> which holds if and only if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{v}[f_{h,A,y}(v)=z]\\geq\\frac{1}{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-t}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Lemma 6.1 (and the symmetry of our distribution with respect to a random shift <span class="math">r</span>), we know that <span class="math">\\Pr_{h,A,y,r}[(h,A,y,r)\\in E]\\geq 1-O(\\frac{1}{\\lambda t})</span>. Therefore, we see that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{h,A,y,r}[\\mathcal{A}(h,A,y,r)\\text{ fails }]</span> <span class="math">\\leq\\Pr_{h,A,y,r}[(h,A,y,r)\\not\\in E]+2\\cdot\\Pr_{h,A,y,v}[\\mathcal{A}(h,A,y,f_{h,A,y}(v))\\text{ fails }]</span> <span class="math">\\leq O(\\frac{1}{\\lambda t})+\\frac{1}{2}.</span></p>

    <p class="text-gray-300">As shown above, this contradicts the mix-and-match resistance of <span class="math">\\mathcal{H}</span>. We conclude that <span class="math">g</span> is weakly one-way, as desired.</p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-123" class="text-lg font-semibold mt-6">6.4.2 Fiat-Shamir Implies Mix-and-Match Resistance</h4>

    <p class="text-gray-300">Finally, we show that any hash function <span class="math">h</span> (or family <span class="math">\\mathcal{H}</span>) that instantiates Fiat-Shamir for any one of a broad class of protocols must be mix-and-match resistant. By Lemma 6.9, this implies that <span class="math">h</span> can be used to construct a one-way function.</p>

    <h6 id="sec-124" class="text-base font-medium mt-4">Theorem 6.10.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\Pi:=\\Pi^{\\mathcal{O}(\\cdot)}</span> is a 3-message public-coin HVZK argument system (with simulator <span class="math">\\mathsf{Sim}</span>) relative to an efficiently simulatable oracle distribution <span class="math">\\mathcal{O}</span>. Moreover, suppose that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The underlying language <span class="math">L\\not\\in\\mathsf{BPP}</span>,</li>

      <li>The challenge space <span class="math">\\Sigma</span> is polynomial-size, and</li>

      <li>First messages are pseudorandom: that is, for every <span class="math">(x,w)\\in R_{L}</span>, the first message <span class="math">\\alpha\\leftarrow P(x,w)</span> is computationally pseudorandom.</li>

    </ol>

    <p class="text-gray-300">Finally, suppose that a hash function family <span class="math">\\mathcal{H}</span> (which does not make use of the oracle <span class="math">\\mathcal{O}</span>) securely instantiates the Fiat-Shamir heuristic for <span class="math">\\Pi^{t}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, <span class="math">\\mathcal{H}</span> is <span class="math">(q,\\Sigma)</span>-mix-and-match resistant (Definition 6.8) with $q=t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda$. Alternatively, if</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The underlying language <span class="math">L</span> is hard-on-average for a distribution <span class="math">\\mathcal{D}_{Yes}</span> on pairs <span class="math">(x,w)</span>,</li>

      <li>The challenge space <span class="math">\\Sigma</span> is polynomial-size, and</li>

      <li>First messages are pseudorandom-on-average: that is, the distribution <span class="math">(x,\\alpha\\leftarrow P(x,w))</span> is computationally indistinguishable from <span class="math">(x,\\</span>)<span class="math">, for </span>(x,w)\\leftarrow\\mathcal{D}_{Yes}$.</li>

    </ol>

    <p class="text-gray-300">Then, the same conclusion holds.</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the “worst-case” variant of the theorem; the “average-case” variant follows by an almost identical argument.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}</span> be a hash function family with the appropriate input/output lengths, and assume that <span class="math">\\mathcal{H}</span> is not mix-and-match resistant. Then, there is a polynomial-time algorithm <span class="math">\\mathcal{A}</span> breaking the mix-and-match security game for <span class="math">\\mathcal{H}</span>. Assuming that <span class="math">L\\not\\in\\mathsf{BPP}</span>, we use <span class="math">\\mathcal{A}</span> to break the soundness of <span class="math">\\Pi^{t}_{\\mathrm{FS},\\mathcal{H}}</span> (relative to <span class="math">\\mathcal{O}</span>) in polynomial time.</p>

    <p class="text-gray-300">The attack <span class="math">P^{*\\mathcal{O}(\\cdot)}</span> is as follows for an arbitrary instance <span class="math">x</span> and hash function <span class="math">H\\leftarrow\\mathcal{H}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">1\\leq i\\leq t</span>, <span class="math">1\\leq\\ell\\leq q</span>, sample fake transcripts <span class="math">(\\alpha_{i}^{(\\ell)},\\beta_{i}^{(\\ell)},\\gamma_{i}^{\\ell)})\\leftarrow\\mathsf{Sim}^{\\mathcal{O}(\\cdot)}(x,\\beta_{i}^{(\\ell)})</span> using the special honest-verifier zero-knowledge simulator on a uniformly random <span class="math">\\beta_{i}^{(\\ell)}\\leftarrow\\Sigma</span>.</li>

      <li>Call <span class="math">\\mathcal{A}(\\alpha,\\beta)</span> to obtain a vector <span class="math">v\\in[q]^{t}</span>.</li>

      <li>Output <span class="math">(\\alpha[v],\\beta[v],\\gamma[v])</span>.</li>

    </ol>

    <p class="text-gray-300">It now suffices to show that assuming <span class="math">\\Pi</span> is HVZK, <span class="math">\\Pi</span> has pseudorandom first messages, and <span class="math">L\\not\\in\\mathsf{BPP}</span>, there exists <span class="math">x\\not\\in L</span> such that <span class="math">P^{*\\mathcal{O}(\\cdot)}(x)</span> outputs an accepting transcript with non-negligible probability.</p>

    <p class="text-gray-300">To prove this, we consider a sequence of claims that each suffice.</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Claim 6.11.</h6>

    <p class="text-gray-300">For all <span class="math">x\\in L</span>, <span class="math">P^{*\\mathcal{O}(\\cdot)}(x)</span> outputs an accepting transcript with non-negligible probability.</p>

    <p class="text-gray-300">Assuming Claim 6.11, since <span class="math">P^{<em>}</span> is efficient, we conclude that if <span class="math">L\\not\\in\\mathsf{BPP}</span>, there exists an <span class="math">x\\not\\in L</span> such that <span class="math">P^{</em>\\mathcal{O}(\\cdot)}(x)</span> outputs an accepting transcript with non-negligible probability. Otherwise, <span class="math">P^{*}</span> can be used as an experiment to decide <span class="math">L</span>.</p>

    <p class="text-gray-300">Thus, it suffices to prove Claim 6.11. Let <span class="math">(x,w)\\in R_{L}</span> be an arbitrary instance-witness pair. We now consider the following hybrid algorithm <span class="math">\\mathsf{Hybrid}</span>, which is a modification (changes in red) of <span class="math">P^{*}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">1\\leq i\\leq t</span>, <span class="math">1\\leq\\ell\\leq q</span>, sample real transcripts <span class="math">(\\alpha_{i}^{(\\ell)},\\beta_{i}^{(\\ell)},\\gamma_{i}^{\\ell)})\\leftarrow\\langle P^{\\mathcal{O}(\\cdot)}(x,w),V^{\\mathcal{O}(\\cdot)}\\rangle</span> (playing the role of both the prover and verifier).</li>

      <li>Call <span class="math">\\mathcal{A}(\\alpha,\\beta)</span> to obtain a vector <span class="math">v\\in[q]^{t}</span>.</li>

      <li>Output <span class="math">(\\alpha[v],\\beta[v],\\gamma[v])</span>.</li>

    </ol>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">By the honest-verifier zero-knowledge of <span class="math">\\Pi</span>, the algorithm Hybrid outputs an accepting transcript with the same probability as that of <span class="math">\\mathcal{A}</span> (up to negligible difference).</p>

    <p class="text-gray-300">Finally, we note that in an execution of Hybrid, <span class="math">\\mathcal{A}(\\alpha,\\beta)</span> is being called on a joint distribution that is computationally indistinguishable from uniform (since <span class="math">\\alpha</span> is pseudorandom and <span class="math">\\beta</span> is independent of <span class="math">\\alpha</span>). Therefore, the call to <span class="math">\\mathcal{A}</span> in Hybrid outputs a <span class="math">v</span> such that <span class="math">H(\\alpha[v])=\\beta[v]</span> with non-negligible probability. Whenever this condition holds, the transcript <span class="math">(\\alpha[v],\\beta[v],\\gamma[v])</span> is accepting, so we conclude that Hybrid (and the actual cheating prover <span class="math">P^{*}</span>) outputs an accepting transcript with non-negligible probability. This completes the proofs of Claim 6.11 and Theorem 6.10. ∎</p>

    <p class="text-gray-300">Note that Theorem 6.10 applies to protocols in the random oracle model, in the generic group model, and in the standard model (that is, the reduction makes black-box calls to the HVZK simulator but not to the oracle <span class="math">\\mathcal{O}</span> itself). Therefore, this negative result applies to many 3-message argument systems, such as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Blum’s Hamiltonicity protocol <em>[x10]</em>, when the commitment scheme Com outputs pseudorandom values (i.e. Naor commitments <em>[x23]</em> in the CRS model or Blum commitments <em>[x11]</em>) in the plain model).</li>

      <li>The <em>[x16]</em> 3-coloring protocol with either of the above choices of commitment scheme.</li>

      <li>The <em>[x15]</em> “MPC-in-the-head” proof system, for any MPC protocol, when the commitment scheme is instantiated as above.</li>

      <li>The <span class="math">\\{0,1\\}</span>-challenge variant of Schnorr’s identification scheme <em>[x29]</em>, even in the generic group model.</li>

      <li>The <em>[x14]</em> proof system for Quadratic Residuosity.</li>

      <li>A simple proof system for bounded distance decoding (BDD) problem based on the natural “instance-dependent commitment scheme <em>[x1, x22]</em>” for BDD. On a (worst-case) instance <span class="math">(A,y=sA+e)</span> of this language, the prover sends a “commitment” <span class="math">s^{\\prime}A+e^{\\prime}</span> for random <span class="math">s^{\\prime}</span> and random noise <span class="math">e^{\\prime}</span> that floods <span class="math">e</span>. On a challenge bit <span class="math">b</span>, the prover replies with <span class="math">s^{\\prime}+bs</span>. This can also be thought of as a simplification of the <em>[x24]</em> proof system for gap-CVP (restricted to BDD instances). Under the LWE assumption, this protocol has pseudorandom first messages on random instances, so Theorem 6.10 applies.</li>

    </ul>

    <h2 id="sec-127" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Brynmor Chapman, Justin Holmgren, Akshayaram Srinivasan, and Daniel Wichs for many helpful discussions. Part of this work was done while the authors were visiting the Simons Institute for the Theory of Computing in Spring 2020.</p>

    <h2 id="sec-128" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACPS09] Benny Applebaum, David Cash, Chris Peikert, and Amit Sahai. Fast cryptographic primitives and circular-secure encryption based on hard learning problems. In Shai Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 595–618. Springer, Heidelberg, August 2009.</li>

      <li>[Ajt96] Miklós Ajtai. Generating hard instances of lattice problems (extended abstract). In 28th ACM STOC, pages 99–108. ACM Press, May 1996.</li>

      <li>[BBC^{+}17] Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran Tromer, and Madars Virza. Computational integrity with a public random string from quasi-linear PCPs. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part III, volume 10212 of LNCS, pages 551–579. Springer, Heidelberg, April / May 2017.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella, editors, ICALP 2018, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl, July 2018.</p>

    <p class="text-gray-300">[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046.</p>

    <p class="text-gray-300">[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 701–732. Springer, Heidelberg, August 2019.</p>

    <p class="text-gray-300">[BCR⁺19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019.</p>

    <p class="text-gray-300">[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016.</p>

    <p class="text-gray-300">[BKM20] Zvika Brakerski, Venkata Koppula, and Tamer Mour. NIZK from LPN and trapdoor hash via correlation intractability for approximable relations. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 738–767. Springer, Heidelberg, August 2020.</p>

    <p class="text-gray-300">[Blu81] Manuel Blum. Coin flipping by telephone. In Allen Gersho, editor, CRYPTO’81, volume ECE Report 82-04, pages 11–15. U.C. Santa Barbara, Dept. of Elec. and Computer Eng., 1981.</p>

    <p class="text-gray-300">[Blu86] Manuel Blum. How to prove a theorem so no one else can claim it. In Proceedings of the International Congress of Mathematicians, volume 1, page 2. Citeseer, 1986.</p>

    <p class="text-gray-300">[BMO90] Mihir Bellare, Silvio Micali, and Rafail Ostrovsky. Perfect zero-knowledge in constant rounds. In 22nd ACM STOC, pages 482–493. ACM Press, May 1990.</p>

    <p class="text-gray-300">[BR94] Mihir Bellare and Phillip Rogaway. Entity authentication and key distribution. In Douglas R. Stinson, editor, CRYPTO’93, volume 773 of LNCS, pages 232–249. Springer, Heidelberg, August 1994.</p>

    <p class="text-gray-300">[BV11] Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) LWE. In Rafail Ostrovsky, editor, 52nd FOCS, pages 97–106. IEEE Computer Society Press, October 2011.</p>

    <p class="text-gray-300">[CCH⁺19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Moses Charikar and Edith Cohen, editors, 51st ACM STOC, pages 1082–1090. ACM Press, June 2019.</p>

    <p class="text-gray-300">[CCR16] Ran Canetti, Yilei Chen, and Leonid Reyzin. On the correlation intractability of obfuscated pseudorandom functions. In Eyal Kushilevitz and Tal Malkin, editors, TCC 2016-A, Part I, volume 9562 of LNCS, pages 389–415. Springer, Heidelberg, January 2016.</p>

    <p class="text-gray-300">[CCRR18] Ran Canetti, Yilei Chen, Leonid Reyzin, and Ron D. Rothblum. Fiat-Shamir and correlation intractability from strong KDM-secure encryption. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 91–122. Springer, Heidelberg, April / May 2018.</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">[CDG18] Sandro Coretti, Yevgeniy Dodis, and Siyao Guo. Non-uniform bounds in the random-permutation, ideal-cipher, and generic-group models. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part I, volume 10991 of LNCS, pages 693–721. Springer, Heidelberg, August 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CGH98] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited (preliminary version). In 30th ACM STOC, pages 209–218. ACM Press, May 1998.</li>

      <li>[CH19] Geoffroy Couteau and Dennis Hofheinz. Designated-verifier pseudorandom generators, and their applications. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part II, volume 11477 of LNCS, pages 562–592. Springer, Heidelberg, May 2019.</li>

      <li>[CHKP10] David Cash, Dennis Hofheinz, Eike Kiltz, and Chris Peikert. Bonsai trees, or how to delegate a lattice basis. In Henri Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 523–552. Springer, Heidelberg, May / June 2010.</li>

      <li>[CK18] Henry Corrigan-Gibbs and Dmitry Kogan. The discrete-logarithm problem with preprocessing. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 415–447. Springer, Heidelberg, April / May 2018.</li>

      <li>[CKU20] Geoffroy Couteau, Shuichi Katsumata, and Bogdan Ursu. Non-interactive zero-knowledge in pairing-free groups from weaker assumptions. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part III, volume 12107 of LNCS, pages 442–471. Springer, Heidelberg, May 2020.</li>

      <li>[CLMQ20] Yilei Chen, Alex Lombardi, Fermi Ma, and Willy Quach. Does fiat-shamir require a cryptographic hash function? Cryptology ePrint Archive, Report 2020/915, 2020. https://eprint.iacr.org/2020/915.</li>

      <li>[CP93] David Chaum and Torben P. Pedersen. Wallet databases with observers. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 89–105. Springer, Heidelberg, August 1993.</li>

      <li>[CPV20] Michele Ciampi, Roberto Parisella, and Daniele Venturi. On adaptive security of delayed-input sigma protocols and fiat-shamir NIZKs. In Clemente Galdi and Vladimir Kolesnikov, editors, SCN 20, volume 12238 of LNCS, pages 670–690. Springer, Heidelberg, September 2020.</li>

      <li>[CS98] Ronald Cramer and Victor Shoup. A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In Hugo Krawczyk, editor, CRYPTO’98, volume 1462 of LNCS, pages 13–25. Springer, Heidelberg, August 1998.</li>

      <li>[Dam10] Ivan Damgard. On sigma-protocols, lecture notes, faculty of science aarhus university, department of computer science, 2010.</li>

      <li>[Den02] Alexander W. Dent. Adapting the weaknesses of the random oracle model to the generic group model. In Yuliang Zheng, editor, ASIACRYPT 2002, volume 2501 of LNCS, pages 100–109. Springer, Heidelberg, December 2002.</li>

      <li>[DGI^{+}19] Nico Döttling, Sanjam Garg, Yuval Ishai, Giulio Malavolta, Tamer Mour, and Rafail Ostrovsky. Trapdoor hash functions and their applications. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 3–32. Springer, Heidelberg, August 2019.</li>

      <li>[DNRS99] Cynthia Dwork, Moni Naor, Omer Reingold, and Larry J. Stockmeyer. Magic functions. In 40th FOCS, pages 523–534. IEEE Computer Society Press, October 1999.</li>

    </ul>

    <p class="text-gray-300">[DRV12] Yevgeniy Dodis, Thomas Ristenpart, and Salil P. Vadhan. Randomness condensers for efficiently samplable, seed-dependent sources. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 618–635. Springer, Heidelberg, March 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Fis00] Marc Fischlin. A note on security proofs in the generic model. In Tatsuaki Okamoto, editor, ASIACRYPT 2000, volume 1976 of LNCS, pages 458–469. Springer, Heidelberg, December 2000.</li>

      <li>[FLS99] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple noninteractive zero knowledge proofs under general assumptions. SIAM J. Comput., 29(1):1–28, September 1999.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>[Gen09] Craig Gentry. Fully homomorphic encryption using ideal lattices. In Michael Mitzenmacher, editor, 41st ACM STOC, pages 169–178. ACM Press, May / June 2009.</li>

      <li>[GGM84] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions (extended abstract). In 25th FOCS, pages 464–479. IEEE Computer Society Press, October 1984.</li>

      <li>[GK90] Oded Goldreich and Hugo Krawczyk. Sparse pseudorandom distributions. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 113–127. Springer, Heidelberg, August 1990.</li>

      <li>[GM82] Shafi Goldwasser and Silvio Micali. Probabilistic encryption and how to play mental poker keeping secret all partial information. In 14th ACM STOC, pages 365–377. ACM Press, May 1982.</li>

      <li>[GMR85] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In 17th ACM STOC, pages 291–304. ACM Press, May 1985.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to prove all NP-statements in zero-knowledge, and a methodology of cryptographic protocol design. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 171–185. Springer, Heidelberg, August 1987.</li>

      <li>[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. Journal of Cryptology, 7(1):1–32, December 1994.</li>

      <li>[GPV08] Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan. Trapdoors for hard lattices and new cryptographic constructions. In Richard E. Ladner and Cynthia Dwork, editors, 40th ACM STOC, pages 197–206. ACM Press, May 2008.</li>

      <li>[HL18] Justin Holmgren and Alex Lombardi. Cryptographic hashing from strong one-way functions (or: One-way product functions and their applications). In Mikkel Thorup, editor, 59th FOCS, pages 850–858. IEEE Computer Society Press, October 2018.</li>

      <li>[IKOS07] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge from secure multiparty computation. In David S. Johnson and Uriel Feige, editors, 39th ACM STOC, pages 21–30. ACM Press, June 2007.</li>

      <li>[IOS97] Toshiya Itoh, Yuji Ohta, and Hiroki Shizuya. A language-dependent cryptographic primitive. Journal of Cryptology, 10(1):37–50, December 1997.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

    </ul>

    <p class="text-gray-300">[KNYY19] Shuichi Katsumata, Ryo Nishimaki, Shota Yamada, and Takashi Yamakawa. Designated verifier/prover and preprocessing NIZKs from Diffie-Hellman assumptions. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part II, volume 11477 of LNCS, pages 622–651. Springer, Heidelberg, May 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KRR17] Yael Tauman Kalai, Guy N. Rothblum, and Ron D. Rothblum. From obfuscation to the security of Fiat-Shamir for proofs. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 224–251. Springer, Heidelberg, August 2017.</li>

      <li>[LV20] Alex Lombardi and Vinod Vaikuntanathan. Fiat-shamir for repeated squaring with applications to PPAD-hardness and VDFs. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 632–651. Springer, Heidelberg, August 2020.</li>

      <li>[LW15] Vadim Lyubashevsky and Daniel Wichs. Simple lattice trapdoor sampling from a broad class of distributions. In Jonathan Katz, editor, PKC 2015, volume 9020 of LNCS, pages 716–730. Springer, Heidelberg, March / April 2015.</li>

      <li>[Lyu08] Vadim Lyubashevsky. Lattice-based identification schemes secure under active attacks. In Ronald Cramer, editor, PKC 2008, volume 4939 of LNCS, pages 162–179. Springer, Heidelberg, March 2008.</li>

      <li>[Lyu09] Vadim Lyubashevsky. Fiat-Shamir with aborts: Applications to lattice and factoring-based signatures. In Mitsuru Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 598–616. Springer, Heidelberg, December 2009.</li>

      <li>[Lyu12] Vadim Lyubashevsky. Lattice signatures without trapdoors. In David Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 738–755. Springer, Heidelberg, April 2012.</li>

      <li>[Mau05] Ueli Maurer. Abstract models of computation in cryptography. In IMA International Conference on Cryptography and Coding, pages 1–12. Springer, 2005.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000.</li>

      <li>[Mou20] Tamer Mour. Correlation intractability vs. one-wayness, 2020. https://eprint.iacr.org/2021/057.</li>

      <li>[MP12] Daniele Micciancio and Chris Peikert. Trapdoors for lattices: Simpler, tighter, faster, smaller. In David Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 700–718. Springer, Heidelberg, April 2012.</li>

      <li>[MV03] Daniele Micciancio and Salil P. Vadhan. Statistical zero-knowledge proofs with efficient provers: Lattice problems and more. In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS, pages 282–298. Springer, Heidelberg, August 2003.</li>

      <li>[MV16] Arno Mittelbach and Daniele Venturi. Fiat-Shamir for highly sound protocols is instantiable. In Vassilis Zikas and Roberto De Prisco, editors, SCN 16, volume 9841 of LNCS, pages 198–215. Springer, Heidelberg, August / September 2016.</li>

      <li>[Nao90] Moni Naor. Bit commitment using pseudo-randomness. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 128–136. Springer, Heidelberg, August 1990.</li>

      <li>[Nec94] V. I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. Mathematical Notes, 55(2):165–172, 1994.</li>

    </ul>

    <p class="text-gray-300">[NSW09] Gregory Neven, Nigel P Smart, and Bogdan Warinschi. Hash function requirements for schnorr signatures. Journal of Mathematical Cryptology, 3(1):69–87, 2009.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Oka93] Tatsuaki Okamoto. Provably secure and practical identification schemes and corresponding signature schemes. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 31–53. Springer, Heidelberg, August 1993.</li>

      <li>[Pei16] Chris Peikert. A decade of lattice cryptography. Foundations and Trends in Theoretical Computer Science, 10(4):283–424, 2016.</li>

      <li>[PS96] David Pointcheval and Jacques Stern. Provably secure blind signature schemes. In Kwangjo Kim and Tsutomu Matsumoto, editors, ASIACRYPT’96, volume 1163 of LNCS, pages 252–265. Springer, Heidelberg, November 1996.</li>

      <li>[PS19] Chris Peikert and Sina Shiehian. Noninteractive zero knowledge for NP from (plain) learning with errors. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 89–114. Springer, Heidelberg, August 2019.</li>

      <li>[QRW19] Willy Quach, Ron D. Rothblum, and Daniel Wichs. Reusable designated-verifier NIZKs for all NP from CDH. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part II, volume 11477 of LNCS, pages 593–621. Springer, Heidelberg, May 2019.</li>

      <li>[Reg05] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. In Harold N. Gabow and Ronald Fagin, editors, 37th ACM STOC, pages 84–93. ACM Press, May 2005.</li>

      <li>[Sch90] Claus-Peter Schnorr. Efficient identification and signatures for smart cards. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 239–252. Springer, Heidelberg, August 1990.</li>

      <li>[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter Fumy, editor, EUROCRYPT’97, volume 1233 of LNCS, pages 256–266. Springer, Heidelberg, May 1997.</li>

      <li>[SPMS02] Jacques Stern, David Pointcheval, John Malone-Lee, and Nigel P. Smart. Flaws in applying proof methodologies to signature schemes. In Moti Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 93–110. Springer, Heidelberg, August 2002.</li>

      <li>[Unr07] Dominique Unruh. Random oracles and auxiliary input. In Alfred Menezes, editor, CRYPTO 2007, volume 4622 of LNCS, pages 205–223. Springer, Heidelberg, August 2007.</li>

      <li>[WTs^{+}18] Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pages 926–943. IEEE Computer Society Press, May 2018.</li>

    </ul>

    <h2 id="sec-129" class="text-2xl font-bold">Appendix A Correlation Intractability and the Idealized Blum Protocol</h2>

    <p class="text-gray-300">In this section, we show that correlation intractability for efficiently computable functions <em>[CCH^{+}19, PS19]</em> implies a sound instantiation of Fiat-Shamir for a variant of the idealized Blum protocol (Section 6.2).</p>

    <p class="text-gray-300">First, we recall a minor modification of the Blum protocol (as in <em>[CCH^{+}19, PS19]</em>) and instantiate the commitment scheme with a random oracle, as in Section 6.2.</p>

    <p class="text-gray-300">That is, we require the prover to additionally commit to the permutation <span class="math">\\pi</span> and decommit to <span class="math">\\pi</span> if <span class="math">\\beta=0</span>. In this case, the verifier checks that <span class="math">\\pi</span> is a valid permutation and that <span class="math">G^{\\prime}=\\pi(G)</span>. The reason this modification is made is so that given a (partial) decommitment to the first message <span class="math">\\alpha</span>, it is possible to efficiently decide which challenge is answerable using this decommitment. In the original Blum protocol, the analogous computation requires solving a graph isomorphism problem.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 10: A Modified Idealized Blum Protocol II</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As before, we instantiate  <span class="math">\\mathsf{Com}(b;r) = \\mathcal{O}(b,r)</span>  using a random oracle. Concretely, we set  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lambda = \\lambda (n)<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{O}(b,r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\kappa = \\kappa (n)<span class="math">  to be arbitrary polynomial functions in  </span>n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The protocol above is then repeated  </span>t = t(n)$  times in parallel to obtain negligible soundness error. We then prove:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem A.1. Suppose that for every (efficiently computable)  <span class="math">s(n) = \\mathrm{poly}(n)</span> , there exists a hash family  <span class="math">\\mathcal{H} = \\{h_k : \\{0, 1\\}^{m(n)\\kappa(n)t(n)} \\to \\{0, 1\\}^{t(n)}\\}_{k \\in \\{0, 1\\}^{\\ell(n)}}</span>  (for  <span class="math">m(n) = n^2 + n</span> ) that is correlation intractable for all functions computable by size  <span class="math">s(n)</span>  circuits.</p>

    <p class="text-gray-300">Then, for an appropriate fixed choice of function  <span class="math">s(\\cdot)</span> , the same hash family  <span class="math">\\mathcal{H}</span>  soundly instantiates the Fiat-Shamir heuristic for the protocol  <span class="math">\\Pi^t</span>  in the random oracle model.</p>

    <p class="text-gray-300">By Theorem 6.10, we also obtain the following corollary.</p>

    <p class="text-gray-300">Corollary A.2. Under the hypothesis of Theorem A.1, the hash family  <span class="math">\\mathcal{H}</span>  is also  <span class="math">(q,\\Sigma)</span>  mix-and-match resistant (Definition 6.8) for  <span class="math">\\Sigma = \\{0,1\\}</span>  and arbitrary  <span class="math">q = \\mathrm{poly}(n)</span> .</p>

    <p class="text-gray-300">We now prove Theorem A.1.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathcal{H}</span>  be a family of correlation-intractable hash functions with parameters as above (for  <span class="math">s = s(n)</span>  chosen appropriately large). Since correlation-intractable hash functions imply the existence of one-way functions, we additionally let  <span class="math">F_{s}:\\{0,1\\}^{\\kappa (n) - 1}\\to \\{0,1\\}</span>  be a PRF family computable by a family of circuits of size  <span class="math">s(n)</span> .</p>

    <p class="text-gray-300">Now, suppose that an efficient adversary  <span class="math">\\mathcal{A}^{\\mathcal{O}(\\cdot)}</span> , given a non-Hamiltonian graph  <span class="math">G</span>  and random hash function  <span class="math">h</span> , breaks the soundness of  <span class="math">\\Pi_{\\mathrm{FS},\\mathcal{H}}^{t}</span>  on  <span class="math">G</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\tau = \\tau(\\mathcal{A},\\mathcal{O})</span>  denote the transcript of  <span class="math">\\mathcal{O}</span> -queries made by  <span class="math">\\mathcal{A}</span> ; that is, for every  <span class="math">i</span> ,  <span class="math">\\tau_{i} = (b_{i},r_{i},c_{i})</span>  where  <span class="math">(b_{i},r_{i})</span>  is the  <span class="math">i</span> th query made by  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathcal{O}</span> , and  <span class="math">c_{i} = \\mathcal{O}(b_{i},r_{i})</span> . Finally, let  <span class="math">(\\alpha^{<em>},\\beta^{</em>},\\gamma^{*})</span>  denote the output of  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Given an arbitrary first message  <span class="math">\\alpha</span>  and transcript  <span class="math">\\tau</span> , we say that a challenge  <span class="math">\\beta</span>  is a bad challenge for  <span class="math">(\\alpha, \\tau)</span>  if the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every  <span class="math">i</span>  such that  <span class="math">\\beta_{i} = 0</span> , the string of commitments  <span class="math">\\alpha_{i} = (c_{i,0},\\ldots ,c_{i,m})</span>  is entirely contained within the transcript  <span class="math">\\tau</span> , and the corresponding bits  <span class="math">\\{b_{i,j}\\}</span>  consist of a permutation  <span class="math">\\pi</span>  and the graph  <span class="math">\\pi (G)</span> .</li>

      <li>For every  <span class="math">i</span>  such that  <span class="math">\\beta_{i} = 1</span> , the transcript  <span class="math">\\tau</span>  contains a substring of  <span class="math">\\alpha_{i}</span>  consisting of commitments to a cycle.</li>

    </ul>

    <p class="text-gray-300">We now note a sequence of facts about the execution of  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Claim A.3. The probability that  <span class="math">\\mathcal{A}^{\\mathcal{O}(\\cdot)}</span>  wins with output  <span class="math">(\\alpha^{<em>},\\beta^{</em>},\\gamma^{<em>})</span>  and  <span class="math">\\beta^{</em>}</span>  is not a bad challenge for  <span class="math">(\\alpha^{*},\\tau)</span>  is negligible.</p>

    <p class="text-gray-300">This claim follows from binding properties of the (random oracle) commitment scheme. This is because if  <span class="math">\\beta^{<em>}</span>  is not bad for  <span class="math">(\\alpha^{</em>},\\tau)</span>  but  <span class="math">(\\alpha^{<em>},\\beta^{</em>},\\gamma^{<em>})</span>  is accepting, then  <span class="math">\\gamma^{</em>}</span>  contains decommitments to bits that are not present in  <span class="math">\\tau</span> ; this means that  <span class="math">\\mathcal{A}^{\\mathcal{O}(\\cdot)}</span>  solves an (unconditionally) hard problem in the random oracle model.</p>

    <h6 id="sec-130" class="text-base font-medium mt-4">Claim A.4.</h6>

    <p class="text-gray-300">The probability that <span class="math">(\\alpha^{*},\\tau)</span> has multiple bad challenges associated to it is negligible.</p>

    <p class="text-gray-300">This again follows from binding properties of the commitment scheme, and the fact that <span class="math">G</span> is not Hamiltonian. Since <span class="math">G</span> is Hamiltonian, if no string <span class="math">c</span> appears twice (for two different choices of <span class="math">(b,r)</span>) in the transcript <span class="math">\\tau</span>, bad challenges for any <span class="math">(\\alpha,\\tau)</span> are unique (as each <span class="math">\\alpha_{i}</span> cannot have an opening to both a permutation of <span class="math">G</span> and a Hamiltonian graph simultaneously). However, <span class="math">\\tau</span> only contains the same commitment string <span class="math">c</span> twice with negligible probability, since it is (unconditionally) hard to find <span class="math">\\mathcal{O}</span>-collisions.</p>

    <p class="text-gray-300">Thus, given a transcript <span class="math">\\tau</span> and message <span class="math">\\alpha</span>, we define the efficiently computable “transcript bad-challenge function” <span class="math">f(\\tau,\\alpha)</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\alpha_{i}</span> is present in <span class="math">\\tau</span> as a commitment to <span class="math">(G^{\\prime},\\pi)</span> and <span class="math">G^{\\prime}=\\pi(G)</span>, set <span class="math">\\beta_{i}=0</span>.</li>

      <li>Otherwise, set <span class="math">\\beta_{i}=1</span>.</li>

      <li>Output <span class="math">\\beta=(\\beta_{1},\\ldots,\\beta_{t})</span>.</li>

    </ul>

    <p class="text-gray-300">By the above analysis, we conclude:</p>

    <h6 id="sec-131" class="text-base font-medium mt-4">Claim A.5.</h6>

    <p class="text-gray-300">With non-negligible probability, the adversary <span class="math">\\mathcal{A}^{\\mathcal{O}}(G,h)</span> outputs <span class="math">(\\alpha^{<em>},\\beta^{</em>},\\gamma^{*})</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta^{<em>}=h(\\alpha^{</em>})=f(\\alpha^{*},\\tau)</span>, and</li>

      <li><span class="math">\\tau</span> contains all necessary decommitments to answer the challenge <span class="math">\\beta^{*}</span>.</li>

    </ul>

    <p class="text-gray-300">Note that Claim A.5 is an efficiently decidable property of <span class="math">(\\tau,\\alpha^{<em>},\\beta^{</em>})</span>. Thus, Claim A.5 also holds if we replace the truly random oracle <span class="math">\\mathcal{O}</span> with the following oracle distribution <span class="math">\\mathcal{O}^{\\prime}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{O}^{\\prime}</span> has a hard-coded random seed <span class="math">s</span> for the PRF <span class="math">F_{s}:\\{0,1\\}^{\\kappa(n)-1}\\to\\{0,1\\}</span></li>

      <li><span class="math">\\mathcal{O}^{\\prime}(b,r)</span> samples a uniformly random <span class="math">r^{\\prime}\\leftarrow\\{0,1\\}^{\\kappa(n)-1}</span> and outputs <span class="math">(r^{\\prime},F_{s}(r^{\\prime})\\oplus b)</span>.</li>

    </ul>

    <p class="text-gray-300">This follows directly from the pseudorandomness property of the PRF family. Finally, we define the following efficiently computable function <span class="math">g_{s}:\\{0,1\\}^{m(n)\\kappa(n)t(n)}\\to\\{0,1\\}^{t(n)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: <span class="math">\\alpha=(\\alpha_{1},\\ldots,\\alpha_{n})</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For all <span class="math">i</span>, let <span class="math">\\alpha_{i}=(c_{i,1},\\ldots,c_{i,m(n)})</span> and $c_{i,j}=r^{\\prime}_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b^{\\prime}_{i,j}<span class="math">. Compute </span>b_{i,j}=F_{s}(r^{\\prime}_{i,j})\\oplus b^{\\prime}_{i,j}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\tilde{\\tau}</span> denote a transcript containing triples of the form <span class="math">(b_{i,j},r_{i,j},c_{i,j})</span> where <span class="math">r_{i,j}</span> are arbitrary.</li>

      <li>Output <span class="math">f(\\alpha,\\tilde{\\tau})</span>.</li>

    </ul>

    <p class="text-gray-300">We claim that <span class="math">\\mathcal{A}^{\\mathcal{O}^{\\prime}(\\cdot)}</span> breaks the correlation intractability of <span class="math">\\mathcal{H}</span> with respect to the function <span class="math">g_{s}</span>. Indeed, whenever the conditions of Claim A.5 hold, we also claim that <span class="math">h(\\alpha^{<em>})=g_{s}(\\alpha^{</em>})</span>. To see this, we note that any commitment <span class="math">c=(r^{\\prime},b^{\\prime})</span> occurring as <span class="math">(b,r,c)</span> in the transcript <span class="math">\\tau</span> must satisfy the property <span class="math">b^{\\prime}=F_{s}(r^{\\prime})\\oplus b</span>. Thus, the <span class="math">i</span>th bit <span class="math">f(\\alpha^{<em>},\\tau)_{i}=0</span> if and only if the <span class="math">i</span>th bit <span class="math">g_{s}(\\alpha^{</em>})_{i}=0</span>.</p>

    <p class="text-gray-300">We conclude that <span class="math">\\mathcal{A}^{\\mathcal{O}^{\\prime}(\\cdot)}</span>, which can be implemented efficiently given the PRF seed <span class="math">s</span>, contradicts the correlation intractability of <span class="math">\\mathcal{H}</span> with respect to <span class="math">g_{s}</span>. Therefore, the protocol <span class="math">\\Pi^{\\mathrm{f}}_{\\mathrm{FS},\\mathcal{H}}</span> is indeed sound in the ROM. ∎</p>

    <h2 id="sec-132" class="text-2xl font-bold">Appendix B Security Analysis in Concrete Groups</h2>

    <p class="text-gray-300">We give some concrete representations of groups and hash functions and analyze the security of our variant of Schnorr signatures and the Chaum-Pederson protocol for those representations. In all the examples given below, we let <span class="math">G</span> be the group of prime order <span class="math">p</span> and let <span class="math">g</span> be a generator of <span class="math">G</span></p>

    <p class="text-gray-300">B.1 Analysis of (Our Variant of) Schnorr Signatures</p>

    <p class="text-gray-300">Let the secret key be <span class="math">u\\in\\mathbb{Z}_{p}</span>, the public key be <span class="math">U=g^{u}</span>. Let the message space be <span class="math">\\mathcal{M}</span> of size <span class="math">\\approx T</span> such that <span class="math">p/T</span> is super-polynomially large. Let <span class="math">h</span> denote the Fiat-Shamir hash function. Let <span class="math">f:G\\to\\mathbb{Z}</span> be a function that parses a group element as an integer.</p>

    <h4 id="sec-133" class="text-lg font-semibold mt-6">B.1.1 Over Finite Fields</h4>

    <p class="text-gray-300">Let <span class="math">p,q</span> be primes such that <span class="math">q=2p+1</span>. Let the group <span class="math">G</span> be the cyclic subgroup of <span class="math">\\mathbb{F}_{q}^{*}</span> of order <span class="math">p</span>. Let the message space be <span class="math">\\mathcal{M}=[0,...,T]</span>. A valid signature of a message <span class="math">m\\in\\mathcal{M}</span> is of the form <span class="math">(R,z)</span> such that</p>

    <p class="text-gray-300"><span class="math">R\\cdot U^{h(R,m)}=g^{z}\\pmod{q}</span> (13)</p>

    <h5 id="sec-134" class="text-base font-semibold mt-4">Security analysis for <span class="math">h(R,m):=f(R)+m</span>.</h5>

    <p class="text-gray-300">By letting <span class="math">h(R,m):=f(R)+m\\mod p</span>, we mean that <span class="math">f</span> parses <span class="math">R\\in\\mathbb{Z}_{q}</span> as an integer in the range <span class="math">(-q/2,q/2]</span>. Note that the mapping <span class="math">f</span> is well spread.</p>

    <p class="text-gray-300">Here is an attack against such a choices of <span class="math">h</span>: the attacker begins with a known equation of the form <span class="math">f(g^{z^{<em>}})+m^{</em>}=0\\pmod{p}</span> (which can be hard-coded non-uniformly) and sets <span class="math">R=g^{z^{<em>}},m=m^{</em>}</span>. In this case <span class="math">h(f(R),m)=0\\mod p</span>. Therefore, <span class="math">(R,z^{<em>})</span> is a valid signature for <span class="math">m=m^{</em>}</span>.</p>

    <p class="text-gray-300">This attack utilizes the fact that we can easily find (or hard-code) <span class="math">R,m</span> such that <span class="math">h(R,m)=0</span>. We stress that this attack is phrased as a preprocessing GGM attack.</p>

    <h5 id="sec-135" class="text-base font-semibold mt-4">Security analysis for <span class="math">h_{k}(R,m):=f(R)+m+k</span>.</h5>

    <p class="text-gray-300">Let <span class="math">h_{k}(R,m):=f(R)+m+k\\mod p</span>, where the key <span class="math">k</span> is sampled uniformly random from <span class="math">\\mathbb{Z}_{p}</span>. In this case the previous attack strategy does not work since <span class="math">f(R)+k+\\mathcal{M}</span> is unlikely to contain zero for any hard-coded value of <span class="math">R</span> (independent of <span class="math">k</span>) due to the randomness of <span class="math">k</span> and the small message space.</p>

    <p class="text-gray-300">Another potential attack strategy is to make <span class="math">Q</span> signature queries for the same message <span class="math">0</span>, get back signatures <span class="math">\\left\\{R_{i},z_{i}\\right\\}_{i\\in[Q]}</span> such that</p>

    <p class="text-gray-300"><span class="math">R_{i}\\cdot U^{h_{k}(R_{i},0)}=g^{z_{i}}\\pmod{q}</span> (14)</p>

    <p class="text-gray-300">If the adversary is able to find a set of integers <span class="math">\\left\\{a_{i}\\right\\}_{i\\in[Q]}</span> such that</p>

    <p class="text-gray-300"><span class="math">t:=\\prod_{i=1}^{Q}R_{i}^{a_{i}}\\mod q=\\sum_{i=1}^{Q}a_{i}\\cdot(R_{i}+k)-k-m^{*}\\mod p</span> (15)</p>

    <p class="text-gray-300">for some message <span class="math">m^{<em>}\\in\\mathcal{M}</span>, then the adversary can forge the signature of <span class="math">m^{</em>}</span> as <span class="math">(t,\\sum_{i=1}^{Q}a_{i}\\cdot z_{i})</span>.</p>

    <p class="text-gray-300">But we don’t know how to solve Eqn. (15) efficiently. So <span class="math">h_{k}(R,m):=f(R)+m+k\\mod p</span> remains a plausibly secure Fiat-Shamir hash function for Schnorr signature over finite fields.</p>

    <h4 id="sec-136" class="text-lg font-semibold mt-6">B.1.2 Over Elliptic Curve Groups</h4>

    <p class="text-gray-300">In this section, we note that there is an additional attack over elliptic curve groups in Weierstrass form exploiting a common problem with this group representation <em>[x20]</em>: the fact that <span class="math">(x,y)</span> and <span class="math">(x,-y)</span> are inverses of each other.</p>

    <p class="text-gray-300">Let <span class="math">E(\\mathbb{F}_{q})</span> be an elliptic curve group of order <span class="math">p</span> represented by the Weierstrass form</p>

    <p class="text-gray-300"><span class="math">E=\\{y^{2}=x^{3}+ax+b\\mod q\\}\\cup\\mathcal{O},\\text{ where }a,b\\in\\mathbb{F}_{q}.</span></p>

    <p class="text-gray-300">Let the group operation be <span class="math">\\circ</span>. A group element <span class="math">P</span> is represented by <span class="math">P=(x,y)</span>.</p>

    <p class="text-gray-300">A valid signature of a message <span class="math">m\\in\\mathcal{M}</span> is of the form <span class="math">(R,z)</span>, where <span class="math">R=(x,y)\\in E(\\mathbb{F}_{q})</span>, <span class="math">z\\in\\mathbb{Z}_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">R\\circ U^{h(R,m)}=g^{z}</span> (16)</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-137" class="text-lg font-semibold mt-6">Security analysis for <span class="math">h(R,m):=y+m</span> and <span class="math">\\mathcal{M}=[-T/2,...,T/2]</span>.</h4>

    <p class="text-gray-300">If we let <span class="math">h(R,m):=y+m\\mod p</span>, meaning that <span class="math">f(R)</span> outputs the <span class="math">y</span>-coordinate of <span class="math">R</span> and interpret it as an integer (we require <span class="math">R\\neq\\mathcal{O}</span>); and if we choose the message space to be <span class="math">\\mathcal{M}=[-T/2,...,T/2]</span>. Then the attacker can use the fact that <span class="math">R^{-1}=(x,-y)</span> and the symmetry of <span class="math">\\mathcal{M}</span> to mount an attack.</p>

    <p class="text-gray-300">The attacker queries the signature of an arbitrary message <span class="math">m</span>, gets back the signature <span class="math">(R,z)</span> such that</p>

    <p class="text-gray-300"><span class="math">R\\circ U^{y+m}=g^{z}</span> (17)</p>

    <p class="text-gray-300">Then <span class="math">R^{-1},-z</span> is the signature for <span class="math">-m</span> since</p>

    <p class="text-gray-300"><span class="math">R^{-1}\\circ U^{-y-m}=g^{-z}</span> (18)</p>

    <p class="text-gray-300">This attack does not use the trick of making <span class="math">h(R,m)=0</span>. As already noted in prior work <em>[x20]</em>, the symmetry of the short Weierstrass form is not captured by the (preprocessing) generic group model.</p>

    <h4 id="sec-138" class="text-lg font-semibold mt-6">Security analysis for <span class="math">h_{k}(R,m):=y+m+k</span> and <span class="math">\\mathcal{M}=[-T/2,...,T/2]</span>.</h4>

    <p class="text-gray-300">If we let <span class="math">h_{k}(R,m):=y+m+k\\mod p</span>, then we cannot use the symmetry of the Weierstrass model to mount an attack because the message space is too small to cancel out a random <span class="math">k</span>. One can also let <span class="math">h_{k}(R,m):=x+m+k\\mod p</span>, where <span class="math">f(R)</span> outputs the <span class="math">x</span> coordinate of <span class="math">R</span>. All of these fixes pertain to the general problem of Weierstrass form in elliptic curve groups.</p>

    <h3 id="sec-139" class="text-xl font-semibold mt-8">B.2 Security Analysis of Chaum-Pederson over Finite Fields</h3>

    <p class="text-gray-300">Recall in the Chaum-Pederson protocol, the adversary in the semi-adaptive setting is allowed to pick part of the instance <span class="math">g^{v}</span>, <span class="math">g^{w}</span> given <span class="math">g,g^{u}</span>. The adversary breaks the semi-adaptive soundness of the non-interactive Chaum-Pederson protocol if it chooses <span class="math">g^{v},g^{w}</span> such that <span class="math">(g,g^{u},g^{v},g^{w})</span> is not a DDH tuple along with <span class="math">h_{1}</span>, <span class="math">h_{2}</span> and <span class="math">z</span> satisfying</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h(g^{v},g^{w},h_{1},h_{2})=c</span>,</li>

      <li><span class="math">g^{z}=(h_{1})(g^{v})^{c}</span>,</li>

      <li><span class="math">(g^{u})^{z}=(h_{2})(g^{w})^{c}</span>.</li>

    </ol>

    <h4 id="sec-140" class="text-lg font-semibold mt-6">Security analysis for <span class="math">h(V,W,h_{1},h_{2})=V+W+h_{1}+h_{2}\\mod p</span>.</h4>

    <p class="text-gray-300">Here is the strategy of the adversary: fix a desired challenge <span class="math">c</span> (think of <span class="math">c</span> as <span class="math">0</span> or <span class="math">c</span> is a small polynomial for a moment), and is trying to find <span class="math">z,V,W,h_{1},h_{2}</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V+W+h_{1}+h_{2}=c\\pmod{p}</span>;</li>

      <li><span class="math">g^{z}=(h_{1})V^{c}</span>;</li>

      <li><span class="math">(g^{u})^{z}=(h_{2})W^{c}</span>.</li>

    </ol>

    <p class="text-gray-300">To do so the adversary picks an arbitrary <span class="math">z</span>, and let <span class="math">g^{z}=Z_{1}</span>, <span class="math">g^{uz}=Z_{2}</span>. Rearrange the last two equations as</p>

    <p class="text-gray-300"><span class="math">h_{1}=Z_{1}/V^{c},\\quad h_{2}=Z_{2}/W^{c}</span></p>

    <p class="text-gray-300">Then plug <span class="math">h_{1}</span> and <span class="math">h_{2}</span> in</p>

    <p class="text-gray-300"><span class="math">V+W+Z_{1}/V^{c}+Z_{2}/W^{c}=c\\pmod{p}.</span> (19)</p>

    <p class="text-gray-300">Eqn. 19 is a single equation with two unknown variables (<span class="math">V</span> and <span class="math">W</span>). We claim that if the group representation is <span class="math">\\mathbb{F}_{q}^{*}</span> where <span class="math">q</span> is slightly larger than <span class="math">p</span> (say <span class="math">q=2p+1</span>), and when <span class="math">c</span> is polynomially large, then we can efficiently solve Eqn. 19. To do so, we pick a random group element as <span class="math">V</span>. Then finding <span class="math">W</span> requires solving a polynomial of degree <span class="math">c+1</span>. With probability half a valid solution of <span class="math">W</span> is a valid group element, and <span class="math">(g,g^{u},V,W)</span> is not likely to be a DDH tuple.</p>

    <h2 id="sec-141" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">Note that when the attack described above chooses <span class="math">c=0</span> then it is captured by the preprocessing generic group model, but the generic group model requires the group representation to be sparse, i.e., the label space should be super-polynomially larger than the group order. Therefore, the attack above is not a contradiction to the GGM proof.</p>

    <p class="text-gray-300">Here is one possible fix of the hash function for Chaum-Pederson over finite fields. Suppose <span class="math">p\\approx 2^{\\ell}</span>. Let <span class="math">h(V,W,h_{1},h_{2})=[V]_{1}+[W]_{2}+[h_{1}]_{3}+[h_{2}]_{4}\\mod p</span>, where <span class="math">[x]_{i}</span> cuts a string of length <span class="math">\\ell</span> in 4 pieces, each of length <span class="math">\\ell/4</span>, then takes the <span class="math">i^{th}</span> piece out of the 4 pieces and multiply it by <span class="math">2^{(i-1)\\cdot\\ell/4}</span>. This choice of hash function avoids the attack described above.</p>`;
---

<BaseLayout title="Does Fiat-Shamir Require a Cryptographic Hash Function? (2020/915)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/915
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
