---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/957';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Caulk+: Table-independent lookup arguments';
const AUTHORS_HTML = 'Jim Posen, Assimakis A. Kattis';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The recent work of Caulk introduces the security notion of position hiding linkability for vector commitment schemes, providing a zero-knowledge argument that a committed vector&#x27;s elements comprise a subset of some other committed vector. The protocol has very low cost to the prover in the case where the size $m$ of the subset vector is much smaller than the size $n$ of the one containing it. The asymptotic prover complexity is $O(m^2 + m \\log n)$, where the $\\log n$ dependence comes from a subprotocol showing that the roots of a blinded polynomial are all $n$th roots of unity. In this work, we show how to simplify this argument, replacing the subprotocol with a polynomial divisibility check and thereby reducing the asymptotic prover complexity to $O(m^2)$, removing any dependence on $n$.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> polynomial commitments &middot; vector commitments &middot; zero knowledge</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  be cyclic groups of prime order p, written with additive notation. The finite field  <span class="math">\\mathbb{F}_p</span>  with p elements will sometimes be abbreviated as  <span class="math">\\mathbb{F}</span> . Let  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  be a pairing: an efficiently computable, non-degenerate bilinear map. Let there be generators  <span class="math">[1]_1, [1]_2, [1]_T</span>  of  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span> , respectively, with  <span class="math">[1]_T = e([1]_1, [1]_2)</span> . For all elements  <span class="math">\\alpha \\in \\mathbb{F}</span>  and  <span class="math">\\gamma \\in \\{1, 2, T\\}</span> , the notation  <span class="math">[\\alpha]_\\gamma</span>  represents the element  <span class="math">\\alpha[1]_\\gamma \\in \\mathbb{G}_\\gamma</span> . The set of polynomials over  <span class="math">\\mathbb{F}</span>  of degree at most d is written as  <span class="math">\\mathbb{F}_{\\leq d}[X]</span> . For any set  <span class="math">S \\subset \\mathbb{F}, Z_S(X) := \\prod_{v \\in S} (X - v) \\in \\mathbb{F}[X]</span>  is the monic polynomial of degree |S| which vanishes on S. The set of powers of a value can be written  <span class="math">x^S := \\{x^i\\}_{i \\in S}</span>  for  <span class="math">S \\subset \\mathbb{Z}</span> .</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Algebraic Group Model</h3>

    <p class="text-gray-300">We analyze security of our protocols in the Algebraic Group Model (AGM) [FKL18]. In the AGM, whenever an adversary outputs a group element  <span class="math">\\boldsymbol{a} \\in \\mathbb{G}_{\\gamma}</span>  with  <span class="math">\\gamma \\in \\{1, 2\\}</span> , they also output an algebraic representation as a linear combination of the  <span class="math">\\mathbb{G}_{\\gamma}</span>  elements that the adversary has access to from the public parameters and structured reference string (SRS).</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Real and Ideal Pairing Checks</h3>

    <p class="text-gray-300">We borrow the terminology of real and ideal pairing checks from [GWC19]. An SRS has degree q if its elements equal  <span class="math">SRS_i = [f(x)]_i</span>  for uniformly sampled  <span class="math">x \\in_R \\mathbb{F}</span>  and some  <span class="math">f \\in \\mathbb{F}_{&lt;q}[X]</span> , where  <span class="math">i \\in [q]</span> . Let  <span class="math">f_{i,j}</span>  denote the corresponding polynomial for the j-th element of  <span class="math">SRS_i</span>  and a, b be the vectors in  <span class="math">\\mathbb{F}^q</span>  whose encodings in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span>  are returned by algebraic adversary  <span class="math">\\mathcal{A}</span> . A real pairing check is defined as:</p>

    <p class="text-gray-300"><span class="math">$(a \\cdot T_1) \\cdot (T_2 \\cdot b) = 0,</span>$</p>

    <p class="text-gray-300">for some matrices  <span class="math">T_1, T_2</span>  over  <span class="math">\\mathbb{F}</span> . Real pairing checks can be efficiently computed from the encoded elements and pairing function  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> .</p>

    <p class="text-gray-300">If we operate in the AGM, for each output  <span class="math">[a_j]_i</span> ,  <span class="math">\\mathcal{A}</span>  also outputs a vector v for which  <span class="math">a_j = \\sum v_\\ell f_{i,\\ell}(x) = R_{i,j}(x)</span>  for  <span class="math">R_{i,j}(X) := \\sum v_\\ell f_{i,\\ell}(X)</span> . For  <span class="math">i \\in \\{1,2\\}</span> , let  <span class="math">R_i = (R_{i,j})_j</span>  be a vector of polynomials over  <span class="math">\\mathbb{F}</span> . The corresponding ideal check then is given by:</p>

    <p class="text-gray-300"><span class="math">$(R_1 \\cdot T_1) \\cdot (T_2 \\cdot R_2) \\equiv 0.</span>$</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Cryptographic Assumptions</h3>

    <p class="text-gray-300">We use the formulation of the q-DLOG assumption from [GWC19], Definition 2.1.</p>

    <p class="text-gray-300"><strong>Definition 1</strong> (q-DLOG assumption, [GWC19] Definition 2.1, verbatim). Fix integer q. The q-DLOG assumption states that given</p>

    <p class="text-gray-300"><span class="math">$[1]_1, [x]_1, ..., [x^q]_1, [1]_2, [x]_2, ..., [x^q]_2</span>$</p>

    <p class="text-gray-300">for uniformly chosen  <span class="math">x \\in \\mathbb{F}</span> , the probability of an efficient  <span class="math">\\mathcal{A}</span>  outputting x is negligible.</p>

    <p class="text-gray-300">We also use Lemma 2.2 from [GWC19], which follows from the q-DLOG assumption in the AGM.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> ([GWC19] Lemma 2.2, verbatim). Assume the q-DLOG for  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2)</span> . Given an algebraic adversary  <span class="math">\\mathcal{A}</span>  participating in a protocol with a degree q SRS, the probability of any real pairing check passing is larger by at most an additive negligible factor than the probability the corresponding ideal check holds.</p>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Vector Commitments</h3>

    <p class="text-gray-300">We recall vector commitment schemes with a trusted setup. Here PP denotes the public parameters of the protocol.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Setup}(\\operatorname{PP}) \\to (\\operatorname{SRS}, x)</span> . Given the public parameters, perform the trusted setup, producing structured reference string SRS and trapdoor x.</p>

    <p class="text-gray-300"><strong>Commit</strong>(PP, SRS,  <span class="math">\\vec{c}, r</span> )  <span class="math">\\rightarrow C</span> . Given an input vector  <span class="math">\\vec{c}</span>  and randomness r, produce a commitment C.</p>

    <p class="text-gray-300"><strong>Prove</strong><sub>Open</sub>(PP, SRS,  <span class="math">C, i, c_i, \\vec{c}, r) \\to \\pi_i</span> . Given a commitment C and claimed opening  <span class="math">(i, c_i)</span>  along with the committed vector  <span class="math">\\vec{c}</span>  and randomness r, produce a proof  <span class="math">\\pi_i</span> .</p>

    <p class="text-gray-300"><strong>Verify</strong><sub>Open</sub>(PP, SRS,  <span class="math">C, i, c_i, \\pi_i</span> )  <span class="math">\\rightarrow</span>  {0, 1}. Given a commitment C and claimed opening  <span class="math">(i, c_i)</span> , verify the opening proof  <span class="math">\\pi_i</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Prove}_{\\mathrm{Open}}</span>  and  <span class="math">\\mathbf{Verify}_{\\mathrm{Open}}</span>  can be generalized to public-coin interactive protocols allowing interaction between prover and verifier. We write  <span class="math">\\mathbf{Verify}_{\\mathrm{Open}}^{\\mathcal{P}}</span>  for the verification algorithm interacting with a prover  <span class="math">\\mathcal{P}</span> . The following security property is associated with vector commitments:</p>

    <p class="text-gray-300"><strong>Definition 2</strong> (Position Binding). A vector commitment is <em>position binding</em> if for all efficient adversaries  <span class="math">\\mathcal{A}</span>  the following probability is negligible:</p>

    <p class="text-gray-300"><span class="math">$\\Pr \\left[ \\begin{array}{cc} c_i \\neq c_i&#x27; \\\\ \\operatorname{Verify}_{\\mathrm{Open}}^{\\mathcal{A}}(\\operatorname{PP}, \\operatorname{SRS}, C, i, c_i, \\pi) = 1 \\\\ \\operatorname{Verify}_{\\mathrm{Open}}^{\\mathcal{A}}(\\operatorname{PP}, \\operatorname{SRS}, C, i, c_i&#x27;, \\pi&#x27;) = 1 \\end{array} \\right| \\begin{array}{c} \\operatorname{SRS} &amp; \\leftarrow \\operatorname{Setup}(\\operatorname{PP}) \\\\ (C, i, c_i, \\pi, c_i&#x27;, \\pi&#x27;) &amp; \\leftarrow \\mathcal{A}(\\operatorname{PP}, \\operatorname{SRS}) \\end{array} \\right].</span>$</p>

      <h3 id="sec-2.6" class="text-xl font-semibold mt-8">2.6 Position-Hiding Linkability</h3>

    <p class="text-gray-300">We restate the definition of position-hiding linkable vector commitments as stated in [ZBK<sup>+</sup>22], which extends the definition of a vector commitment scheme. A vector commitment scheme has position-hiding linkability if there is a zero-knowledge argument of knowledge for the following witness relation:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_{\\text{Link}} := \\left\\{ \\left( \\begin{array}{c} \\text{PP,SRS;} \\\\ C, A, n, m; \\\\ \\vec{c}, r_c, \\vec{a}, r_a \\end{array} \\right) \\middle| \\begin{array}{c} \\text{Commit}(\\vec{c}, r_c) = C \\\\ \\text{Commit}(\\vec{a}, r_a) = A \\\\ \\forall i \\in [m], \\exists j \\in [n], a_i = c_j \\end{array} \\right\\}.</span>$</p>

      <h3 id="sec-2.7" class="text-xl font-semibold mt-8">2.7 Zero-Knowledge with Precomputation</h3>

    <p class="text-gray-300">We use the standard definition of honest-verifier zero-knowledge for public-coin interactive protocols: informally, that there exists an efficient algorithm <strong>Simulate</strong> which can produce an accepting transcript that is computationally indistingushable from a real one between a prover and an honest verifier. In our setting, the prover is allowed to precompute advice inputs from the public parameters and SRS to reduce its online execution time when given an instance. We consider a model where the distinguisher cannot discriminate based on timing information between an execution where the prover has precomputed advice and one where they have not, assuming the precomputation is polynomial-time. In practice, if timing information is available the prover will precompute and store advice for all instances it may generate proofs for.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Lookup Argument Construction</h2>

    <p class="text-gray-300">Our protocol is based on the one in section 7 of [ZBK<sup>+</sup>22]. The commitments  <span class="math">\\boldsymbol{c}</span>  and  <span class="math">\\boldsymbol{a}</span>  are to vectors  <span class="math">\\vec{c} \\in \\mathbb{F}^n</span>  and  <span class="math">\\vec{a} \\in \\mathbb{F}^m</span>  respectively. Assume both n and m are powers of two<sup>1</sup>. Let  <span class="math">\\mathbb{H}</span>  and  <span class="math">\\mathbb{V}</span>  be multiplicative subgroups of  <span class="math">\\mathbb{F}</span>  of size n and m. The vector commitment scheme used is a KZG commitment over a polynomial which evaluates to the committed vector over some multiplicative subgroup of  <span class="math">\\mathbb{F}</span> . In particular,  <span class="math">\\boldsymbol{c}</span>  commits to a polynomial C(X) which evaluates to  <span class="math">\\vec{c}</span>  over  <span class="math">\\mathbb{H}</span>  and  <span class="math">\\boldsymbol{a}</span>  commits to a polynomial A(X) which evaluates to  <span class="math">\\vec{a}</span>  over  <span class="math">\\mathbb{V}</span> . Let  <span class="math">\\omega</span>  be a generator of  <span class="math">\\mathbb{H}</span>  and  <span class="math">\\boldsymbol{\\nu}</span>  be a generator of  <span class="math">\\mathbb{V}</span> . The protocol is then a zero-knowledge argument for the following relation  <span class="math">\\mathcal{R}_{\\text{Link}}^{\\text{KZG}}</span> , which instantiates  <span class="math">\\mathcal{R}_{\\text{Link}}</span>  with KZG commitments:</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{R}_{\\text{Link}}^{\\text{KZG}} := \\left\\{ \\begin{pmatrix} &amp; \\{[x^{k-1}]_1, [x^{k-1}]_2\\}_{k \\in [d]}; \\\\ &amp; \\boldsymbol{c}, \\boldsymbol{a}, \\mathbb{H}, \\mathbb{V}, \\omega, \\mu; \\\\ &amp; C(X), A(X), I \\subset [n] \\end{pmatrix} \\middle| \\begin{array}{c} \\boldsymbol{c} = [C(x)]_1 \\\\ &amp; \\boldsymbol{a} = [A(x)]_1 \\\\ &amp; \\forall i \\in [m], \\exists j \\in I, A(\\mu^i) = C(\\omega^j) \\end{array} \\right\\}. \\tag{1}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">I \\subset [n]</span>  be the set of indices in  <span class="math">\\vec{c}</span>  that  <span class="math">\\vec{a}</span>  takes values from and  <span class="math">u : [m] \\to I</span>  be a mapping such that  <span class="math">a_i = c_{u(i)}</span>  for all  <span class="math">i \\in [m]</span> . The protocol begins with the prover computing polynomials  <span class="math">Z_I, C_I, U \\in \\mathbb{F}_{\\leq m}[X]</span>  so that the following polynomial identities hold over  <span class="math">Z_I</span> :</p>

    <p class="text-gray-300"><span class="math">$C(X) - C_I(X) = 0 \\mod Z_I, \\tag{2}</span>$</p>

    <p class="text-gray-300">
<span class="math">$Z_{\\mathbb{H}} = 0 \\mod Z_I, \\tag{3}</span>$</p>

    <p class="text-gray-300">and the following identities hold over  <span class="math">Z_{\\mathbb{V}}</span> :</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{1}&lt;/sup&gt;</span> The vectors can always be padded with duplicate elements up to the nearest power of two length.</p>

    <p class="text-gray-300"><span class="math">$C_I(U(X)) - A(X) = 0 \\mod Z_{\\mathbb{V}},\\tag{4}</span>$</p>

    <p class="text-gray-300">
<span class="math">$Z_I(U(X)) = 0 \\mod Z_{\\mathbb{V}}. \\tag{5}</span>$</p>

    <p class="text-gray-300">Intuitively,  <span class="math">Z_I</span>  is a low-degree polynomial which vanishes on  <span class="math">\\omega^I</span> ,  <span class="math">C_I</span>  is a low-degree polynomial which agrees with C on  <span class="math">\\omega^I</span> , and U maps  <span class="math">\\mathbb V</span>  to  <span class="math">\\omega^I</span> . Concretely, the prover computes the Lagrange polynomials  <span class="math">\\{\\tau_i\\}_{i\\in I}\\subset \\mathbb F_{&lt;|I|}[X]</span>  over  <span class="math">\\omega^I</span>  and the Lagrange polynomials  <span class="math">\\{\\mu_j\\}_{j\\in [m]}\\subset \\mathbb F_{&lt; m}[X]</span>  over  <span class="math">\\mathbb V</span> . They then define:</p>

    <p class="text-gray-300"><span class="math">$Z_I(X) = \\prod_{i \\in I} X - \\omega^i,</span>$</p>

    <p class="text-gray-300"><span class="math">$C_I(X) = \\sum_{i \\in I} c_i \\tau_i(X),</span>$</p>

    <p class="text-gray-300"><span class="math">$U(X) = \\sum_{j \\in [m]} u(j) \\mu_j(X).</span>$</p>

    <p class="text-gray-300">Now, we could proceed with the standard compilation of polynomial IOPs to regular IOPs. However, equations 2 and 3 involve polynomials with degree up to n, so computing a KZG commitment opening would take O(n) time. We notice that neither equation involves polynomial composition and so we can enforce the constraints with real pairing checks at the point x from the structured reference string SRS. This approach has the benefit that the quotient elements for the pairing check can be computed in  <span class="math">O(m^2)</span>  time from precomputed values.</p>

    <p class="text-gray-300">Define  <span class="math">W_1, W_2 \\in \\mathbb{F}_{\\leq n}[X]</span>  to be such that  <span class="math">C - C_I = Z_I W_1</span>  and  <span class="math">Z_{\\mathbb{H}} = Z_I W_2</span> . The prover will look up precomputed values  <span class="math">\\{[W_1^{(i)}(x)]_2, [W_2^{(i)}(x)]_2\\}_{i \\in I}</span> , where  <span class="math">W_1^{(i)}(X) = (C(X) - c_i)/(X - \\omega^i), W_2^{(i)}(X) = Z_{\\mathbb{H}}/(X - \\omega^i)</span> , and then compute:</p>

    <p class="text-gray-300"><span class="math">$[W_1(x)]_2 = \\sum_{i \\in I} \\frac{[W_1^{(i)}(x)]_2}{\\prod_{j \\in I, i \\neq j} \\omega^i - \\omega^j},</span>$
<span class="math">$[W_2(x)]_2 = \\sum_{i \\in I} \\frac{[W_2^{(i)}(x)]_2}{\\prod_{j \\in I, i \\neq j} \\omega^i - \\omega^j}.</span>$</p>

    <p class="text-gray-300">After sending these quotient elements for the pairing checks corresponding to equations 2 and 3, the verifier will query equations 4 and 5 at a challenge point  <span class="math">\\alpha</span> . The prover will provide polynomial commitment opening proofs which can be computed in  <span class="math">O(m \\log m)</span>  time due to the lower degree bound on the polynomials involved.</p>

    <p class="text-gray-300">The final ingredient is to blind  <span class="math">Z_I, C_I, U</span>  appropriately to preserve zero-knowledge. While  <span class="math">C_I</span>  and U can be blinded by respectively adding multiples of  <span class="math">Z_I</span>  and  <span class="math">Z_{\\mathbb{V}}, Z_I</span>  can only be blinded by a single multiplicative factor. At first glace, this presents a problem because the prover must present the evaluation of  <span class="math">Z_I</span>  at a challenge point during the last step of the protocol and there may not be sufficient degrees of randomness to blind both the evaluation and commitment to  <span class="math">Z_I</span>  itself. Fortunately however, the KZG openings can be batched together using verifier-supplied randomness in such a way that additional blinding of  <span class="math">C_I</span>  prevents information leakage.</p>

    <p class="text-gray-300">Figure 2: Interactive Protocol for  <span class="math">\\mathcal{R}_{Link}^{KZG}</span></p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Public inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Prime order cyclic groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  with bilinear map e and generators  <span class="math">[1]_1, [1]_2</span></li>
      <li>Scalar field  <span class="math">\\mathbb{F}</span></li>
      <li>Structured reference string  <span class="math">[x]_1,...,[x^{d-1}]_1,[x]_2,...,[x^{d-1}]_2</span></li>
    </ul>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Common inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Multiplicative subgroup  <span class="math">\\mathbb{H} &lt; \\mathbb{F}^*</span>  with order n and generator  <span class="math">\\omega</span></li>
      <li>Multiplicative subgroup  <span class="math">\\mathbb{V} &lt; \\mathbb{F}^*</span>  with order m and generator  <span class="math">\\nu</span></li>
      <li>KZG commitment  <span class="math">\\boldsymbol{c}</span>  to C(X) with evaluation points in  <span class="math">\\mathbb H</span></li>
      <li>KZG commitment  <span class="math">\\boldsymbol{a}</span>  to A(X) with evaluation points in  <span class="math">\\mathbb V</span></li>
    </ul>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">Witness inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set of indices  <span class="math">I \\subset [n]</span></li>
      <li>Values  <span class="math">\\{c_i\\}_{i\\in I}</span></li>
      <li>Polynomials C(X), A(X)</li>
      <li>Mapping  <span class="math">u:[m] \\to I</span></li>
    </ul>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Precomputed inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">[W_1^{(i)}(x)]_2</span>  for all  <span class="math">i \\in I</span>  where  <span class="math">W_1^{(i)}(X) = (C(X) c_i)/(X \\omega^i)</span></li>
      <li><span class="math">[W_2^{(i)}(x)]_2</span>  for all  <span class="math">i \\in I</span>  where  <span class="math">W_2^{(i)}(X) = Z_{\\mathbb{H}}(X)/(X-\\omega^i)</span></li>
    </ul>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Round 1 Prover:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample blinding factors  <span class="math">r_1, ..., r_6</span></li>
      <li>Compute the Lagrange basis polynomials  <span class="math">\\{\\tau_i(X)\\}_{i\\in[m]}</span>  over  <span class="math">\\omega^j_{j\\in I}</span></li>
      <li>Define  <span class="math">Z_I&#x27;(X) = r_1 \\prod_{i \\in I} (X \\omega^i)</span></li>
      <li>Define  <span class="math">C_I(X) = \\sum_{i \\in I} c_i \\tau_i(X)</span></li>
      <li>Define blinded  <span class="math">C&#x27;_{I}(X) = C_{I}(X) + (r_{2} + r_{3}X + r_{4}X^{2})Z&#x27;_{I}(X)</span></li>
      <li>Define U(X) to be the degree m-1 interpolation over  <span class="math">\\mathbb V</span>  with  <span class="math">U(\\nu_i)=\\omega^{u(i)}, \\forall i\\in[m]</span></li>
      <li>Define blinded  <span class="math">U&#x27;(X) = U(X) + (r_5 + r_6 X)Z_{\\mathbb{V}}(X)</span></li>
      <li>Publish  <span class="math">z_I = [Z&#x27;_I(x)]_1, c_I = [C&#x27;_I(x)]_1, u = [U&#x27;(x)]_1</span></li>
    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">[W_1(x) + \\chi_2 W_2(x)]_2 = \\sum_{i \\in I} \\frac{[W_1^{(i)}(x)]_2 + \\chi_2 [W_2^{(i)}(x)]_2}{\\prod_{j \\in I, i \\neq j} \\omega^i \\omega^j}</span></li>
      <li>Compute  <span class="math">H(X) = (Z&#x27;_I(U&#x27;(X)) + \\chi_1(C&#x27;_I(U&#x27;(X)) A(X)))/Z_{\\mathbb{V}}(X)</span></li>
      <li>Publish  <span class="math">\\mathbf{w} = r_1^{-1}[W_1(x) + \\chi_2 W_2(x)]_2 [r_2 + r_3 x + r_4 x^2]_2</span> ,  <span class="math">\\mathbf{h} = [H(x)]_1</span></li>
    </ul>

    <pre><code class="language-text">Round 3 Verifier: Send random challenge &alpha;
Round 3 Prover: Output v1, v2, &pi;1, &pi;2, &pi;3 where
            P1(X) &larr; Z
                        &prime;
                       I
                         (X) + &chi;1C
                                   &prime;
                                   I
                                    (X)
            P2(X) &larr; Z
                        &prime;
                       I
                         (U
                           &prime;
                            (&alpha;)) + &chi;1(C
                                        &prime;
                                        I
                                         (U
                                            &prime;
                                            (&alpha;)) &minus; A(X)) &minus; ZV(&alpha;)H(X)
           (v1, &pi;1) &larr; KZG.Open(U
                                    &prime;
                                    (X), &alpha;)
           (v2, &pi;2) &larr; KZG.Open(P1(X), v1)
            (0, &pi;3) &larr; KZG.Open(P2(X), &alpha;)
Verifer: Compute p1 = zI + &chi;1cI and p2 = [v2]1 &minus; &chi;1a &minus; ZV(&alpha;)h and verify
                               1 &larr; KZG.Verify(u, &alpha;, v1, &pi;1)
                               1 &larr; KZG.Verify(p1, v1, v2, &pi;2)
                               1 &larr; KZG.Verify(p2, &alpha;, 0, &pi;3)
                     e((C &minus; cI ) + &chi;2[x
                                       n &minus; 1]1, [1]2) = e(zI , w)
</code></pre>

    <p class="text-gray-300">Prover complexity is <em>O</em>(<em>m</em><sup>2</sup> ), with the limiting steps being polynomial interpolations of <em>Z<sup>I</sup></em> and <em>C<sup>I</sup></em> in round 1 and the aggregation of the precomputed KZG witnesses to produce <em>w</em> in round 2. The verifier verifies three KZG commitment openings and one additional pairing check. Notice that we can drop one degree of blinding from <em>U</em> &prime; (<em>X</em>) as compared to Caulk because <em>U</em> &prime; (<em>X</em>) is not opened as a KZG commitment in the subprotocol to show well-formedness. Furthermore, one fewer pairing is required for verification because the degree bound check used in the subprotocol is eliminated. We can use the same standard batching techniques described in section 8 of <a href="#page-9-0">[ZBK</a><sup>+</sup>22] to reduce the number of pairing checks from 4 to 3 and the number of G<sup>1</sup> elements in the proof from 8 to 7.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> <em>The protocol in Figure <a href="#page-5-0">2</a> is a zero-knowledge argument of knowledge for the relation in equation <a href="#page-3-3">1</a> with verifier complexity O&lambda;</em>(1) <em>and prover complexity O&lambda;</em>(<em>m</em><sup>2</sup> )<em>, granted the prover has precomputed KZG witnesses for C and X<sup>n</sup></em> &minus; 1 <em>at all indices in I.</em></p>

    <p class="text-gray-300"><em>Proof</em>. The proof of knowledge soundness for Theorem <a href="#page-6-0">1</a> is given in Appendix <a href="#page-9-1">A</a> and the proof of zero-knowledge is given in Appendix <a href="#page-9-2">B.</a></p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> <em>There exists a vector commitment scheme with position-hiding linkability, verifier complexity O&lambda;</em>(1)<em>, and prover complexity O&lambda;</em>(<em>m</em><sup>2</sup> )<em>, for m the size of the subset and n the size of the table. The commitment scheme requires a trusted setup and requires the prover to precompute and store a constant number of elements per linked index that take O</em>(<em>n</em>) <em>time to compute each or O</em>(<em>n</em> log <em>n</em>) <em>time to compute as a batch.</em></p>

    <p class="text-gray-300"><em>Proof</em>. The KZG polynomial commitment scheme over evaluation domains which are multiplicative subgroups is a vector commitment scheme per Section 4.6, &quot;KZG as Vector Commitment Scheme&quot;, of <a href="#page-9-0">[ZBK</a><sup>+</sup>22]. The protocol in Figure <a href="#page-5-0">2</a> provides position-hiding linkability with the required asymptotic complexity per Theorem <a href="#page-6-0">1.</a></p>

    <p class="text-gray-300">Section 6 of <a href="#page-9-0">[ZBK</a><sup>+</sup>22] presents a specific argument for linking a Pedersen commitment to an element in a committed vector. In this setting, the SRS contains one additional random element <em>h</em> &isin; G<sup>1</sup> for which the discrete log relations to all other SRS elements are unknown. Then we can construct a zero-knowledge argument for the witness relation:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_{\\text{PC-Link}} := \\left\\{ \\left( \\begin{array}{c} \\{[x^{k-1}]_1, [x^{k-1}]_2\\}_{k \\in [d]}, \\boldsymbol{h} \\; ; \\\\ \\boldsymbol{c}, \\boldsymbol{v}, \\mathbb{H}, \\boldsymbol{\\omega} \\; ; \\\\ C(X), j, v, r \\end{array} \\right) \\middle| \\begin{array}{c} \\boldsymbol{c} = [C(x)]_1 \\\\ \\boldsymbol{v} = [v]_1 + r\\boldsymbol{h} \\\\ v = C(\\boldsymbol{\\omega}^j) \\end{array} \\right\\}.</span>$</p>

    <p class="text-gray-300">Care must be taken when modifying the argument from section 6 of [ZBK<sup>+</sup>22] to replace the unity subprotocol with a divisibility check. The divisibility check does not guarantee that  <span class="math">Z_I</span>  has a root, and if it is a constant polynomial then the main pairing check does not correspond to a blinded KZG opening. In the generalized argument this is not an issue because equation 5 ensures that  <span class="math">Z_I</span>  has a root.</p>

    <p class="text-gray-300">Instead, we will compose the generalized lookup argument with a generalized Schnorr proof to produce an efficient argument for the single element case. It is well known that the classic Schnorr argument of knowledge of a discrete logarithm can be generalized to more complex group homomorphisms from a scalar field to a prime order group [Sch91]. In this setting we generalize Schnorr's protocol to an argument of knowledge of the shared opening to two Pedersen commitments with different bases in  <span class="math">\\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">The prover samples  <span class="math">k \\leftarrow \\mathbb{F}</span>  and computes a polynomial A(X) = v + k(X-1). The commitment to A(X) is  <span class="math">\\boldsymbol{a} = v[1]_1 + k[x-1]_1</span> . The prover and verifier run the lookup argument as a subprotocol with  <span class="math">\\boldsymbol{a}</span>  and  <span class="math">\\mathbb{V} = \\{1\\}</span> . Finally they engage in a proof of knowledge of v, r, k such that:</p>

    <p class="text-gray-300"><span class="math">$v = v[1]_1 + rh,</span>$</p>

    <p class="text-gray-300"><span class="math">a = v[1]_1 + k[x-1]_1.</span></p>

    <p class="text-gray-300">Figure 3: Interactive Protocol for  <span class="math">\\mathcal{R}_{PC\\text{-Link}}</span></p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">Public inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Prime order cyclic groups  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> ,  <span class="math">\\mathbb{G}_T</span>  with bilinear map e and generators  <span class="math">[1]_1</span> ,  <span class="math">[1]_2</span></li>
      <li>Scalar field  <span class="math">\\mathbb{F}</span></li>
      <li>Structured reference string  <span class="math">[x]_1, ..., [x^{d-1}]_1, [x]_2, ..., [x^{d-1}]_2</span></li>
      <li>Independent  <span class="math">\\mathbb{G}_1</span>  generator h</li>
    </ul>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Common inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Multiplicative subgroup  <span class="math">\\mathbb{H} &lt; \\mathbb{F}^*</span>  with order n and generator  <span class="math">\\omega</span></li>
      <li>KZG commitment C to C(X) with evaluation points in  <span class="math">\\mathbb{H}</span></li>
      <li>Pedersen commitment  <span class="math">{\\pmb v}</span></li>
    </ul>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Witness inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Value v, Pedersen commitment randomness r, index i</li>
      <li>Polynomial C(X)</li>
    </ul>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Precomputed inputs:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">[W_1^{(i)}(x)]_2</span>  where  <span class="math">W_1^{(i)}(X) = (C(X) c_i)/(X \\omega^i)</span></li>
      <li><span class="math">[W_2^{(i)}(x)]_2</span>  where  <span class="math">W_2^{(i)}(X) = Z_{\\mathbb{H}}(X)/(X \\omega^i)</span></li>
    </ul>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6"><strong>Round 1 Prover</strong>:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample blinding factors <em>k, v,</em> &circ; <em>r,</em> &circ; &circ;<em>k</em> &larr; F</li>
      <li>Prover outputs <em>a</em> = [<em>v</em>]<sup>1</sup> + <em>k</em>[<em>x</em> &minus; 1]<sup>1</sup></li>
      <li>Prover and verifier engage in Link protocol with <em>c, a, A</em>(<em>X</em>) = <em>v</em> + <em>k</em>(<em>X</em> &minus; 1)<em>,</em> V = {1}<em>, I</em> = {<em>i</em>} (Figure <a href="#page-5-0">2)</a></li>
    </ul>

    <p class="text-gray-300"><strong>Round 2 Prover</strong>: Output <em>v</em>&tilde; = [&circ;<em>v</em>]<sup>1</sup> + &circ;<em>rh,a</em>&tilde; = [&circ;<em>v</em>]<sup>1</sup> + &circ;<em>k</em>[<em>x</em> &minus; 1]<sup>1</sup></p>

    <p class="text-gray-300"><strong>Round 3 Verifier</strong>: Sample random <em>&chi;</em></p>

    <p class="text-gray-300"><strong>Round 3 Prover</strong>: Output <em>s<sup>v</sup></em> = &circ;<em>v</em> + <em>&chi;v, s<sup>r</sup></em> = &circ;<em>r</em> + <em>&chi;r, s<sup>k</sup></em> = &circ;<em>k</em> + <em>&chi;k</em></p>

    <p class="text-gray-300"><strong>Verifier</strong>: Verify that</p>

    <p class="text-gray-300"><span class="math">$[s_v]_1 + s_r \\mathbf{h} = \\tilde{\\mathbf{v}} + \\chi \\mathbf{v}</span>$
<span class="math">$[s_v]_1 + s_k [x - 1]_1 = \\tilde{\\mathbf{a}} + \\chi \\mathbf{a}.</span>$</p>

    <p class="text-gray-300">We thank Arantxa Zapico for discussions and clarifications on the original Caulk protocol. We thank Oana Ciobotaru for identifying several mistakes in the presentation, including the statement of the verifier complexity. We thank Michal Zajic, Janno Siim, Helger Lipmaa, and Roberto Parisella for identifying mistakes in the protocol specification which violated correctness and zero-knowledge guarantees.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>[FKL18] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. In Hovav Shacham and Alexandra Boldyreva, editors, <em>Advances in Cryptology &ndash; CRYPTO 2018</em>, pages 33&ndash;62, Cham, 2018. Springer International Publishing.</li>
      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Paper 2019/953, 2019. <a href="https://eprint.iacr.org/2019/953" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://eprint.iacr.org/2019/953" target="_blank" rel="noopener noreferrer">//eprint.iacr.org/2019/953</a>.</li>
      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, <em>Advances in Cryptology - ASIACRYPT 2010</em>, pages 177&ndash;194, Berlin, Heidelberg, 2010. Springer Berlin Heidelberg.</li>
      <li>[Sch91] C. P. Schnorr. Efficient signature generation by smart cards. <em>J. Cryptol.</em>, 4(3):161&ndash;174, jan 1991.</li>
      <li>[TAB<sup>+</sup>20] Alin Tomescu, Ittai Abraham, Vitalik Buterin, Justin Drake, Dankrad Feist, and Dmitry Khovratovich. Aggregatable subvector commitments for stateless cryptocurrencies. In Clemente Galdi and Vladimir Kolesnikov, editors, <em>Security and Cryptography for Networks</em>, pages 45&ndash;64, Cham, 2020. Springer International Publishing.</li>
    </ul>

    <p class="text-gray-300">[ZBK<sup>+</sup>22] Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. Caulk: Lookup arguments in sublinear time. Cryptology ePrint Archive, Paper 2022/621, 2022. https://eprint.iacr.org/2022/621.</p>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Proof of Theorem 1: Knowledge Soundness</h2>

    <p class="text-gray-300">The protocol for position-hiding linking has knowledge soundness in the Algebraic Group Model of [FKL18]. Knowledge soundness is defined by a game Game<sub>KS</sub> involving an algebraic adversary  <span class="math">\\mathcal{A}</span>  and an efficient extractor  <span class="math">\\mathcal{E}</span> . Given an SRS, the adversary outputs an instance  <span class="math">\\boldsymbol{c}, \\boldsymbol{a}, \\omega, \\mu</span>  and produces an interactive argument for the verifier. The extractor then outputs polynomials C, A. The adversary wins if 1) the verifier accepts and 2) it is not the case that  <span class="math">\\boldsymbol{c} = [C(x)]_1 \\wedge \\boldsymbol{a} = [A(x)]_1 \\wedge \\forall i \\in [m], \\exists j \\in [n], A(\\mu^i) = C(\\omega^j)</span> . The protocol has knowledge soundness if there exists an  <span class="math">\\mathcal{E}</span>  so that no adversary wins the game with greater than negligible probability over the verifier's randomness.</p>

    <p class="text-gray-300">Because the structured reference string consists of the powers of x up to  <span class="math">x^{d-1}</span>  lifted to  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , an algebraic representation of a group element in either group can be interpreted as the coefficients of a polynomial in  <span class="math">\\mathbb{F}_d[X]</span> . The adversary outputs  <span class="math">\\mathbf{z_I}, \\mathbf{c_I}, \\mathbf{u}, \\mathbf{h} \\in \\mathbb{G}_1, \\mathbf{w} \\in \\mathbb{G}_2</span>  along with their representations, and so the extractor learns the corresponding polynomials  <span class="math">Z_I&#x27;, C_I&#x27;, U&#x27;, W, H</span> . The real pairing check</p>

    <p class="text-gray-300"><span class="math">$e((\\mathbf{C} - \\mathbf{c}_{\\mathbf{I}}) + \\chi_2[x^n - 1]_1, [1]_2) = e(\\mathbf{z}_{\\mathbf{I}}, \\mathbf{w}),</span>$</p>

    <p class="text-gray-300">corresponds to the ideal pairing check</p>

    <p class="text-gray-300"><span class="math">$C - C_I&#x27; + \\chi_2(X^n - 1) = Z_I&#x27;W.</span>$</p>

    <p class="text-gray-300">Consequently by Lemma 1, the above polynomial identity holds except with negligible probability. Therefore,  <span class="math">Z_I&#x27; \\mid C - C_I&#x27; + \\chi_2(X^n - 1)</span> . Since  <span class="math">\\chi_2</span>  is sampled after the prover commits to  <span class="math">C_I&#x27;</span> ,  <span class="math">Z_I&#x27;</span> , except with probability  <span class="math">\\frac{1}{|\\mathbb{F}|}</span>  it must be that  <span class="math">Z_I&#x27; \\mid C - C_I&#x27;</span>  and  <span class="math">Z_I&#x27; \\mid X^n - 1</span> . Let I be the set of roots of  <span class="math">Z_I&#x27;</span> . Since  <span class="math">Z_I&#x27; \\mid X^n - 1</span> , it follows that  <span class="math">I \\subset \\mathbb{H}</span> , and since  <span class="math">Z_I&#x27; \\mid C - C_I&#x27;</span> , it follows that  <span class="math">C(y) = C_I&#x27;(y)</span>  for all  <span class="math">y \\in I</span> .</p>

    <p class="text-gray-300">By the knowledge soundness of the KZG polynomial commitment scheme and the Schwartz-Zippel lemma, the following polynomial identity holds except with negligible probability because the evaluation holds at a random point  <span class="math">\\alpha</span> :</p>

    <p class="text-gray-300"><span class="math">$Z_I&#x27;(U&#x27;(X)) + \\chi_1(C_I&#x27;(U&#x27;(X)) - A(X)) = Z_{\\mathbb{V}}(X)H(X).</span>$</p>

    <p class="text-gray-300">Therefore,  <span class="math">Z_{\\mathbb{V}}(X) \\mid Z_I&#x27;(U&#x27;(X)) + \\chi_1(C_I&#x27;(U&#x27;(X)) - A(X))</span> . Since  <span class="math">\\chi_1</span>  is sampled after the prover commits to  <span class="math">Z_I&#x27;, C_I&#x27;, U&#x27;</span> , except with probability  <span class="math">\\frac{1}{|\\mathbb{F}|}</span>  it must be that  <span class="math">Z_{\\mathbb{V}} \\mid Z_I&#x27;(U&#x27;(X))</span>  and  <span class="math">Z_{\\mathbb{V}} \\mid C_I&#x27;(U&#x27;(X)) - A(X)</span> . Then,  <span class="math">Z_I&#x27;(U&#x27;(y)) = 0</span>  and  <span class="math">C_I&#x27;(U&#x27;(y)) = A(y)</span>  for all  <span class="math">y \\in \\mathbb{V}</span> . Furthermore,  <span class="math">U&#x27;(y) \\in I</span>  for all  <span class="math">y \\in \\mathbb{V}</span> , since I is the set of roots of  <span class="math">Z_I&#x27;</span>  by definition. Now, for any  <span class="math">i \\in [m]</span> ,  <span class="math">A(\\mu^i) = C_I&#x27;(U&#x27;(\\mu^i))</span> . There exists a  <span class="math">y \\in I</span>  with  <span class="math">U&#x27;(\\mu^i) = y</span>  since U' maps  <span class="math">\\mathbb{V}</span>  to I. For all  <span class="math">y \\in I</span> ,  <span class="math">A(\\mu^i) = C_I&#x27;(y) = C(y)</span> . Let j be such that  <span class="math">j = \\omega^j</span> , which we know to exist because  <span class="math">I \\subset \\mathbb{H}</span>  and  <span class="math">\\omega</span>  generates  <span class="math">\\mathbb{H}</span> . Then when the extractor outputs C, A, it holds that for all  <span class="math">\\forall i \\in [m], \\exists j \\in [n], A(\\mu^i) = C(\\omega^j)</span> , meaning the adversary loses the game.</p>

    <p class="text-gray-300">We describe the <strong>Simulate</strong><sub>Link</sub> algorithm that, given an instance  <span class="math">\\boldsymbol{c}, \\boldsymbol{a}</span>  and the trapdoor value x convinces an interactive verifier to accept. This is similar to the argument in Appendix F of [ZBK+22]. The simulator samples  <span class="math">s_1, ..., s_8 \\leftarrow \\mathbb{F}</span>  at random and outputs  <span class="math">\\boldsymbol{z_I} = [s_1]_1, \\boldsymbol{c_I} = \\boldsymbol{c} - [s_2]_1, \\boldsymbol{u} = [s_3]_1</span> . The simulator then receives  <span class="math">\\chi_1, \\chi_2</span>  and outputs</p>

    <p class="text-gray-300"><em>w</em> = <em>s</em> &minus;1 1 [<em>s</em><sup>2</sup> + <em>&chi;</em>2<em>Z</em>H(<em>x</em>)]2<em>, h</em> = [<em>s</em>4]2. As in Appendix F, the simulator receives <em>&alpha;</em>, outputs <em>v</em><sup>1</sup> = <em>s</em>5<em>, v</em><sup>2</sup> = <em>s</em>6, and computes KZG evaluation proofs:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\pi_1 &amp;= (x - \\alpha)^{-1} (\\boldsymbol{u} - [v_1]_1), \\\\ \\pi_2 &amp;= (x - v_1)^{-1} (\\boldsymbol{z_I} + \\chi_1 \\boldsymbol{c_I} - [v_2]_1), \\\\ \\pi_3 &amp;= (x - \\alpha)^{-1} ([v_2]_1 - \\chi_1 \\boldsymbol{a} - Z_{\\mathbb{V}}(\\alpha) \\boldsymbol{h}). \\end{aligned}</span>$</p>

    <p class="text-gray-300">It can be seen that the simulator's outputs satisfy the pairing check.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;e((\\pmb{C}-\\pmb{c_I})+\\chi_2[x^n-1]_1,[1]_2)\\\\ =&amp;e([s_2]_1+\\chi_2[Z_{\\mathbb{H}}(x)]_1,[1]_2)\\\\ =&amp;e([1]_1,[s_2]_2+\\chi_2[Z_{\\mathbb{H}}(x)]_2)\\\\ =&amp;e([s_1]_1,s_1^{-1}([s_2]_2+\\chi_2[Z_{\\mathbb{H}}(x)]_2))\\\\ =&amp;e(\\pmb{z_I},\\pmb{w}) \\end{split}</span>$</p>

    <p class="text-gray-300">We note the distribution of output elements matches a valid distribution because:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>z<sup>I</sup></em> is blinded by <em>r</em><sup>1</sup> for the prover and <em>s</em><sup>1</sup> for the simulator,</li>
      <li><em>c<sup>I</sup></em> is blinded by <em>r</em><sup>2</sup> for the prover and <em>s</em><sup>2</sup> for the simulator,</li>
      <li><em>u</em> is blinded by <em>r</em><sup>5</sup> for the prover and <em>s</em><sup>3</sup> for the simulator,</li>
      <li><em>w</em> uniquely satisfies the pairing check,</li>
      <li><em>h</em> is blinded by <em>r</em><sup>3</sup> for the prover and <em>s</em><sup>4</sup> for the simulator,</li>
      <li><em>v</em><sup>1</sup> is blinded by <em>r</em><sup>6</sup> for the prover and <em>s</em><sup>5</sup> for the simulator,</li>
      <li><em>v</em><sup>2</sup> is blinded by <em>r</em><sup>4</sup> for the prover and <em>s</em><sup>6</sup> for the simulator,</li>
      <li><em>&pi;</em>1<em>, &pi;</em>2<em>, &pi;</em><sup>3</sup> uniquely satisfy the KZG openings.</li>
    </ul>

    </section>
`;
---

<BaseLayout title="Caulk+: Table-independent lookup arguments (2022/957)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/957
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Our Contribution</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Notation</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Algebraic Group Model</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Real and Ideal Pairing Checks</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Cryptographic Assumptions</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Vector Commitments</a></li>
            <li><a href="#sec-2.6" class="hover:text-white">Position-Hiding Linkability</a></li>
            <li><a href="#sec-2.7" class="hover:text-white">Zero-Knowledge with Precomputation</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">Lookup Argument Construction</a></li>
        <li><a href="#sec-4" class="hover:text-white">Linking to Pedersen Commitments</a></li>
        <li><a href="#sec-5" class="hover:text-white">Acknowledgements</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Proof of Theorem 1: Knowledge Soundness</a></li>
        <li><a href="#app-b" class="hover:text-white">Proof of Theorem 1: Zero Knowledge</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="caulk-table-independent-lookup-arguments-2022" />
  </article>
</BaseLayout>
