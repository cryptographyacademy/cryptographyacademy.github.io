---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1148';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="Improvements to the Linear Operations of LowMC: A Faster Picnic (2017/1148)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Improvements to the Linear Operations of LowMC: A Faster Picnic
      </h1>
      <p class="text-gray-400 mb-2">
        Daniel Kales, L&eacute;o Perrin, Angela Promitzer, Sebastian
        Ramacher, and Christian Rechberger
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; Full Version &middot; eprint 2017/1148
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">Contribution</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">LowMC</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                (2,3)-Decomposition of Circuits in Picnic</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Optimizing Linear Operations</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Splitting the Round Key Computation and Round
                Constant Addition</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Reducing Linear Layer Computation</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">
                Fibonacci Feistel Network</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Performance and Memory Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Reduced Round Key Computation and Constant
                Addition</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Reduced Linear Layer</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Fibonacci Feistel Network</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Discussion</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
        <li>
          <a href="#appendix-a"
            class="hover:text-white">Appendix A</a>
        </li>
        <li>
          <a href="#appendix-b"
            class="hover:text-white">Appendix B</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        Picnic is a practical approach to digital signatures where the
        security is primarily based on the existence of a one-way
        function, and the signature size strongly depends on the number
        of multiplications in the circuit describing that one-way
        function. The highly parameterizable block cipher family LowMC
        has the most competitive properties with respect to this metric
        and is hence a standard choice. In this paper, we study various
        options for efficient implementations of LowMC in-depth. First,
        we investigate optimizations of the round key computation of
        LowMC independently of any implementation optimizations. By
        decomposing the round key computations based on the
        keys&rsquo; effect on the S-box layer and general optimizations,
        we reduce runtime costs by up to a factor of 2 and furthermore
        reduce the size of the LowMC matrices by around 45 % compared
        to the original Picnic implementation (CCS&rsquo;17). Second, we
        propose two modifications to the remaining matrix multiplication
        in LowMC&rsquo;s linear layer. The first modification
        decomposes the multiplication into parts depending on their
        effect on the S-box layer. While this requires the linear layer
        matrices to have an invertible submatrix, it reduces the runtime
        and memory costs significantly, both by up to a factor of 4 for
        instances used by Picnic and up to a factor of 25 for LowMC
        instances with only one S-box. The second modification proposes
        a Feistel structure using smaller matrices completely replacing
        the remaining large matrix multiplication in LowMC&rsquo;s
        linear layer. With this approach, we achieve an operation count
        logarithmic in the block size but more importantly, improve over
        Picnic&rsquo;s matrix multiplication by 60 % while retaining a
        constant-time algorithm. Furthermore, this technique also
        enables us to reduce the memory requirements for storing LowMC
        matrices by 60 %.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> LowMC &middot; lightweight block
        cipher &middot; Picnic &middot; post-quantum digital
        signatures &middot; efficient implementation
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        Lightweight cryptographic primitives that only require a low
        number of multiplications have many applications ranging from
        reducing costs for countermeasures against side-channel attacks
        [DPVR00, GLSV14], over improving homomorphic encryption schemes
        [ARS+15, MJSC16, CCF+16, DSES14, NLV11] and multiparty
        computation [GRR+16, RSS17], to SNARKs [AGR+16]. Additionally,
        they also turned out to be useful to efficiently implement and
        reduce signature sizes of post-quantum signature schemes based
        on <span class="math">\Sigma</span>-protocols [CDG+17a] without
        requiring any structured hardness assumptions. The latter in
        particular builds upon LowMC [ARS+15, ARS+16], a highly
        parameterizable block cipher with a low number of
        multiplications.
      </p>
      <p class="text-gray-300">
        We focus on the use of LowMC in the post-quantum digital
        signature scheme Picnic [CDG+17a, CDG+17b] which is based on
        zero-knowledge proofs of knowledge of pre-images of one-way
        functions. There, the one-way functions are instantiated using
        LowMC. Picnic relies on a proof system called ZKB++, which is
        based on the &ldquo;MPC-in-the-head&rdquo; [IKOS07] paradigm.
        To compute proofs in ZKB++, the circuit of the one-way function
        is decomposed into three branches where XOR gates and AND gates
        involving constants can be computed locally, but AND gates
        require communication between the branches. Thus the signature
        size depends on the total number of AND gates required to
        describe the one-way function as a circuit.
      </p>
      <p class="text-gray-300">
        The remaining introductory paragraphs discuss the constraints
        emerging from LowMC&rsquo;s use in Picnic: the number of AND
        gates relates to signature size, while fewer S-boxes lead to
        more rounds and more linear layer operations (XORs). Any
        improvement reducing the number of XOR gates in LowMC&rsquo;s
        linear layer allows targeting smaller signature sizes without
        sacrificing performance. The authors note this follows a long
        line of work on finding efficient alternative descriptions of
        ciphers, similar to the AES competition era.
      </p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Contribution
      </h3>
      <p class="text-gray-300">
        The contributions of this work can be summarized as follows:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
        <li>
          An alternative description of LowMC with a new structure to
          compute round keys and apply round constants. The idea is to
          split the computation into linear and non-linear parts. This
          change allows replacing all round key computations only
          affecting the linear part by exactly one matrix multiplication.
          In the signature scheme use-case, this leads to performance
          improvements ranging from a factor of 1.5 for smaller block
          sizes to a factor of 2 for larger block sizes.
        </li>
        <li>
          An optimization to the matrix multiplication in the linear
          layer of LowMC, employing similar techniques to split the
          computation into linear and non-linear parts. This reduces
          the number of operations for the linear layer computations as
          well as the memory requirements from
          <span class="math">r \cdot n^2</span> to
          <span class="math">r \cdot (n^2 - (n - 3 \cdot m)^2) + n^2</span>,
          for instances of LowMC with
          <span class="math">r</span> rounds, blocksize
          <span class="math">n</span> and
          <span class="math">m</span> S-boxes. This reduces runtime to
          a quarter of the original.
        </li>
        <li>
          Fibonacci Feistel Networks (FFNs), a variant of Generalized
          Feistel Networks providing very fast diffusion. Instantiating
          the network with regular matrices yields a compact
          representation of a larger matrix multiplication with
          logarithmic complexity. This technique reduces the size of the
          LowMC matrices by up to 60 %.
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 LowMC
      </h3>
      <p class="text-gray-300">
        LowMC [ARS+15, ARS+16] is a very parameterizable symmetric
        encryption scheme design enabling instantiation with low AND
        depth and low multiplicative complexity. Let
        <span class="math">n</span> be the block size,
        <span class="math">m</span> be the number of S-boxes,
        <span class="math">k</span> the key size, and
        <span class="math">r</span> the number of rounds. Round
        constants
        <span class="math">C_i \stackrel&#123;R&#125;&#123;\leftarrow&#125; \mathbb&#123;F&#125;_2^n</span>
        for <span class="math">i \in [1, r]</span>, full rank matrices
        <span class="math">K_i \stackrel&#123;R&#125;&#123;\leftarrow&#125; \mathbb&#123;F&#125;_2^&#123;n \times k&#125;</span>
        and regular matrices
        <span class="math">L_i \stackrel&#123;R&#125;&#123;\leftarrow&#125; \mathbb&#123;F&#125;_2^&#123;n \times n&#125;</span>
        are chosen independently during instance generation and kept
        fixed. Keys are generated by sampling from
        <span class="math">\mathbb&#123;F&#125;_2^k</span> uniformly at
        random. LowMC consists of key whitening in the beginning and
        multiple rounds composed of an S-box layer, a linear layer,
        addition with constants and addition of the round key.
      </p>
      <p class="text-gray-300">
        <strong>Algorithm 1</strong> (LowMC encryption): Given key
        matrices
        <span class="math">K_i \in \mathbb&#123;F&#125;_2^&#123;n \times k&#125;</span>
        for <span class="math">i \in [0, r]</span>, linear layer
        matrices
        <span class="math">L_i \in \mathbb&#123;F&#125;_2^&#123;n \times n&#125;</span>
        and round constants
        <span class="math">C_i \in \mathbb&#123;F&#125;_2^n</span> for
        <span class="math">i \in [1, r]</span>, on input plaintext
        <span class="math">p \in \mathbb&#123;F&#125;_2^n</span> and key
        <span class="math">y \in \mathbb&#123;F&#125;_2^k</span>:
      </p>
      <div class="math-block">
        s \leftarrow K_0 \cdot y + p
      </div>
      <p class="text-gray-300">
        For <span class="math">i \in [1, r]</span>:
      </p>
      <div class="math-block">
        s \leftarrow \operatorname&#123;SBOX&#125;(s), \quad
        s \leftarrow L_i \cdot s, \quad
        s \leftarrow s + C_i + K_i \cdot y
      </div>
      <p class="text-gray-300">
        Return <span class="math">s</span>.
      </p>
      <p class="text-gray-300">
        To reduce the multiplicative complexity, the number of S-boxes
        applied in parallel can be reduced, leaving part of the
        substitution layer as the identity mapping.
      </p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 (2,3)-Decomposition of Circuits in Picnic
      </h3>
      <p class="text-gray-300">
        Circuit decomposition is a protocol for jointly computing a
        circuit, similar to an MPC protocol but with higher efficiency.
        In a (2,3)-decomposition there are three players and the
        protocol has 2-privacy, i.e., it remains secure even if two of
        the three players are corrupted.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 ((2,3)-decomposition)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">f</span> be a function computed by an
            <span class="math">n</span>-gate circuit
            <span class="math">\phi</span> such that
            <span class="math">f(x) = \phi(x) = y</span>. Let
            <span class="math">k_1, k_2, k_3</span> be tapes of length
            <span class="math">\kappa</span> chosen uniformly at random
            from
            <span class="math">\&#123;0,1\&#125;^\kappa</span>
            corresponding to players
            <span class="math">P_1, P_2, P_3</span>. The tuple of
            algorithms (Share, Update, Output, Reconstruct) is defined
            as follows:
          </p>
          <p class="text-gray-300 mt-2">
            <strong>Share</strong><span class="math">(x, k_1, k_2, k_3)</span>:
            On input of the secret value
            <span class="math">x</span>, outputs the initial views for
            each player containing the secret share
            <span class="math">x_i</span> of
            <span class="math">x</span>.
          </p>
          <p class="text-gray-300 mt-2">
            <strong>Update</strong>: On input of the views and random
            tapes <span class="math">k_i, k_&#123;i+1&#125;</span>,
            compute wire values for the next gate and return the updated
            view.
          </p>
          <p class="text-gray-300 mt-2">
            <strong>Output</strong>: On input of the final view, returns
            the output share <span class="math">y_i</span>.
          </p>
          <p class="text-gray-300 mt-2">
            <strong>Reconstruct</strong><span class="math">(y_1, y_2, y_3)</span>:
            On input of output shares, reconstructs and returns
            <span class="math">y</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        Correctness requires that reconstructing a (2,3)-decomposed
        evaluation of a circuit <span class="math">\phi</span> yields
        the same value as directly evaluating
        <span class="math">\phi</span> on the input value. The
        2-privacy property requires that revealing the values from two
        shares reveals nothing about the input value.
      </p>
      <p class="text-gray-300">
        The <span class="math">\Sigma</span>-protocol ZKB++ constructs
        the (2,3)-decomposition as follows: Let
        <span class="math">R</span> be an arbitrary finite ring and
        <span class="math">\phi</span> a function such that
        <span class="math">\phi: R^m \to R^\ell</span> can be expressed
        by an <span class="math">n</span>-gate arithmetic circuit over
        the ring using addition/multiplication by constants and binary
        addition/multiplication gates. The decomposition is then given
        by:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
        <li>
          <strong>Addition by constant</strong>
          (<span class="math">w_b = w_a + c</span>):
          <span class="math">w_b^&#123;(i)&#125; = w_a^&#123;(i)&#125; + c</span>
          if <span class="math">i = 1</span> and
          <span class="math">w_b^&#123;(i)&#125; = w_a^&#123;(i)&#125;</span>
          otherwise.
        </li>
        <li>
          <strong>Multiplication by constant</strong>
          (<span class="math">w_b = c \cdot w_a</span>):
          <span class="math">w_b^&#123;(i)&#125; = c \cdot w_a^&#123;(i)&#125;</span>.
        </li>
        <li>
          <strong>Binary addition</strong>
          (<span class="math">w_c = w_a + w_b</span>):
          <span class="math">w_c^&#123;(i)&#125; = w_a^&#123;(i)&#125; + w_b^&#123;(i)&#125;</span>.
        </li>
        <li>
          <strong>Binary multiplication</strong>
          (<span class="math">w_c = w_a \cdot w_b</span>):
          <span class="math">w_c^&#123;(i)&#125; = w_a^&#123;(i)&#125; \cdot w_b^&#123;(i)&#125; + w_a^&#123;(i+1)&#125; \cdot w_b^&#123;(i)&#125; + w_a^&#123;(i)&#125; \cdot w_b^&#123;(i+1)&#125; + R_i(c) - R_&#123;i+1&#125;(c)</span>
          where <span class="math">R_i(c)</span> is the
          <span class="math">c</span>-th output of a pseudorandom
          generator seeded with
          <span class="math">k_i</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        Note that <span class="math">P_i</span> can compute all gate
        types locally except binary multiplication gates, as the latter
        requires inputs from
        <span class="math">P_&#123;i+1&#125;</span>. Only outputs of
        binary multiplication gates need to be serialized, and thus the
        view size and signature size of Picnic depend on the size of the
        ring <span class="math">R</span> and the number of
        multiplication gates.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. OPTIMIZING LINEAR OPERATIONS                              -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Optimizing Linear Operations
      </h2>
      <p class="text-gray-300">
        From the use of LowMC in Picnic, we obtain some constraints on
        the optimizations we are allowed to perform. The S-box serves as
        a synchronization point on the first
        <span class="math">3 \cdot m</span> bits, i.e., the bits that
        are actually touched by the S-box. On the other
        <span class="math">n - 3 \cdot m</span> bits the S-box is
        simply the identity map, and their actual values do not matter
        for S-box evaluations. Thus we have to ensure that the
        evaluation of all AND gates stays invariant under all our
        optimizations. Secondly, we have to assume that the secret key
        &ndash; or more precisely the shares representing it &ndash;
        changes on every encryption.
      </p>

      <!-- 3.1 -->
      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Splitting the Round Key Computation and Round Constant
        Addition
      </h3>
      <p class="text-gray-300">
        We start with the round key computation. Since the secret key is
        freshly shared for each LowMC evaluation in Picnic, the round
        keys cannot be pre-computed once during initialization. However,
        we can observe that due to the structure of the S-box layer, for
        <span class="math">n - 3 \cdot m</span> bits of the round key
        (which coincide with the part of the state where the S-box acts
        as identity map), it does not matter whether those bits are added
        to the state before or after the application of the S-box.
      </p>
      <p class="text-gray-300">
        Due to the linear nature of all operations involved in the
        computation after the S-box, we can simply change the order of
        adding the round key and multiplying the state with
        <span class="math">L_i</span>. We modify each round as follows:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
        <li>
          Modify
          <span class="math">s \leftarrow L_i \cdot s + K_i \cdot y + C_i</span>
          to
          <span class="math">s \leftarrow L_i \cdot (L_i^&#123;-1&#125; \cdot K_i \cdot y + s) + C_i</span>.
          Now split
          <span class="math">L_i^&#123;-1&#125; \cdot K_i \cdot y</span>
          into the lower <span class="math">3 \cdot m</span> bits (the
          &ldquo;non-linear part&rdquo;) and the upper
          <span class="math">n - 3 \cdot m</span> bits (the &ldquo;linear
          part&rdquo;) and move the addition of the upper
          <span class="math">n - 3 \cdot m</span> bits before the S-box
          layer.
        </li>
      </ul>
      <p class="text-gray-300">
        We denote by
        <span class="math">\rho_i^j: \mathbb&#123;F&#125;_2^n \to \mathbb&#123;F&#125;_2^&#123;j - i + 1&#125;</span>
        the map sending <span class="math">n</span>-dimensional vectors
        to a vector consisting of the
        <span class="math">i</span>-th to <span class="math">j</span>-th
        coordinates. In particular, we use
        <span class="math">\rho_L = \rho_&#123;3 \cdot m + 1&#125;^n</span>
        to identify the linear part and
        <span class="math">\rho_N = \rho_1^&#123;3 \cdot m&#125;</span>
        for the non-linear part.
      </p>
      <p class="text-gray-300">
        After iterating this procedure, all linear parts of the round
        key are moved before the first round, leaving a reduced round
        key of <span class="math">3 \cdot m</span> bits per round. The
        linear part can be computed by calculating the matrix
        <span class="math">P_L</span> defined as:
      </p>
      <div class="math-block">
        P_L = \overline&#123;L_1^&#123;-1&#125;&#125; \cdot K_1 + \sum_&#123;j=2&#125;^&#123;r&#125; \left( \prod_&#123;k=1&#125;^&#123;j&#125; \overline&#123;L_k^&#123;-1&#125;&#125; \right) \cdot K_j
      </div>
      <p class="text-gray-300">
        This matrix <span class="math">P_L</span> is precomputed from
        the LowMC matrices before any encryption. Only the
        multiplication with the secret key
        <span class="math">y</span> and addition to the initial state
        <span class="math">s_0</span> is required at the beginning.
        For the non-linear part, we define:
      </p>
      <div class="math-block">
        P_&#123;N,i&#125; = \overline&#123;L_i^&#123;-1&#125;&#125; \cdot K_i + \sum_&#123;j=i+1&#125;^&#123;r&#125; \left( \prod_&#123;k=i&#125;^&#123;j&#125; \overline&#123;L_k^&#123;-1&#125;&#125; \right) \cdot K_j
      </div>
      <p class="text-gray-300">
        The first <span class="math">3 \cdot m</span> rows of
        <span class="math">P_&#123;N,i&#125;</span> from all rounds are
        combined into one matrix
        <span class="math">P_N</span> of dimension
        <span class="math">(3 \cdot m \cdot r \times k)</span>. This
        matrix is multiplied with the secret key
        <span class="math">y</span> before the first round, producing a
        <span class="math">3 \cdot m \cdot r</span> dimensional vector
        <span class="math">v</span>. The appropriate
        <span class="math">3 \cdot m</span> bits of
        <span class="math">v</span> are then added to the non-linear
        part of the state in each round.
      </p>
      <p class="text-gray-300">
        <strong>Algorithm 2</strong> (LowMC with split round key):
        Given key matrix
        <span class="math">K_0 \in \mathbb&#123;F&#125;_2^&#123;n \times k&#125;</span>,
        linear layer matrices
        <span class="math">L_i \in \mathbb&#123;F&#125;_2^&#123;n \times n&#125;</span>,
        and precomputed matrices
        <span class="math">P_L</span>,
        <span class="math">P_N</span> and vectors
        <span class="math">C_L</span>,
        <span class="math">C_N</span>, on input plaintext
        <span class="math">p \in \mathbb&#123;F&#125;_2^n</span> and key
        <span class="math">y \in \mathbb&#123;F&#125;_2^k</span>:
      </p>
      <div class="math-block">
        v \leftarrow P_N \cdot y + C_N
      </div>
      <div class="math-block">
        s \leftarrow (K_0 + P_L) \cdot y + p + C_L
      </div>
      <p class="text-gray-300">
        For <span class="math">i \in [1, r]</span>:
      </p>
      <div class="math-block">
        s \leftarrow \operatorname&#123;SBOX&#125;(s), \quad
        s \leftarrow \rho_&#123;1+3 \cdot m \cdot (i-1)&#125;^&#123;3 \cdot m \cdot i&#125;(v) + s, \quad
        s \leftarrow L_i \cdot s
      </div>
      <p class="text-gray-300">
        Return <span class="math">s</span>.
      </p>

      <!-- 3.2 -->
      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Reducing Linear Layer Computation
      </h3>
      <p class="text-gray-300">
        A similar modification can be applied to the linear layer
        matrices, where a substantial part of the linear layer
        computation can be moved to the first round. We take the linear
        layer matrix <span class="math">L_i</span> and split it into 4
        submatrices depending on the number of S-boxes:
      </p>
      <div class="math-block">
        L_i = \begin&#123;bmatrix&#125; \mathcal&#123;N&#125;_i &amp; \mathcal&#123;A&#125;_i \\ \mathcal&#123;B&#125;_i &amp; \mathcal&#123;L&#125;_i \end&#123;bmatrix&#125;
      </div>
      <p class="text-gray-300">
        where <span class="math">\mathcal&#123;N&#125;_i</span> is
        <span class="math">3 \cdot m \times 3 \cdot m</span>,
        <span class="math">\mathcal&#123;A&#125;_i</span> is
        <span class="math">3 \cdot m \times (n - 3 \cdot m)</span>,
        <span class="math">\mathcal&#123;B&#125;_i</span> is
        <span class="math">(n - 3 \cdot m) \times 3 \cdot m</span>,
        and <span class="math">\mathcal&#123;L&#125;_i</span> is
        <span class="math">(n - 3 \cdot m) \times (n - 3 \cdot m)</span>.
        We also split the state into the non-linear part
        <span class="math">s_N</span>
        (<span class="math">3 \cdot m</span> bits) and the linear part
        <span class="math">s_L</span>
        (<span class="math">n - 3 \cdot m</span> bits). The linear
        layer multiplication is rewritten as:
      </p>
      <div class="math-block">
        \begin&#123;bmatrix&#125; s_N^&#123;i+1&#125; \\ s_L^&#123;i+1&#125; \end&#123;bmatrix&#125; = \begin&#123;bmatrix&#125; \mathcal&#123;N&#125;_i &amp; \mathcal&#123;A&#125;_i \\ \mathcal&#123;B&#125;_i &amp; \mathcal&#123;L&#125;_i \end&#123;bmatrix&#125; \cdot \begin&#123;bmatrix&#125; s_N^i \\ s_L^i \end&#123;bmatrix&#125; = \begin&#123;bmatrix&#125; \mathcal&#123;N&#125;_i \cdot s_N^i + \mathcal&#123;A&#125;_i \cdot s_L^i \\ \mathcal&#123;B&#125;_i \cdot s_N^i + \mathcal&#123;L&#125;_i \cdot s_L^i \end&#123;bmatrix&#125;
      </div>
      <p class="text-gray-300">
        With the precondition that the submatrix
        <span class="math">\mathcal&#123;L&#125;_i</span> is invertible,
        we can move the multiplication by
        <span class="math">\mathcal&#123;L&#125;_i</span> before the
        other multiplications:
      </p>
      <div class="math-block">
        \begin&#123;bmatrix&#125; s_N^&#123;i+1&#125; \\ s_L^&#123;i+1&#125; \end&#123;bmatrix&#125; = \begin&#123;bmatrix&#125; \mathcal&#123;N&#125;_i &amp; \mathcal&#123;A&#125;_i \cdot \mathcal&#123;L&#125;_i^&#123;-1&#125; \\ \mathcal&#123;B&#125;_i &amp; I \end&#123;bmatrix&#125; \cdot \begin&#123;bmatrix&#125; s_N^i \\ \mathcal&#123;L&#125;_i \cdot s_L^i \end&#123;bmatrix&#125;
      </div>
      <p class="text-gray-300">
        By repeating this process for multiple rounds, all
        multiplications by
        <span class="math">\mathcal&#123;L&#125;_i</span> are grouped
        into a single matrix <span class="math">Z_0</span>,
        precomputed and multiplied with the linear part of the state
        before the first round. The modified linear-layer matrices
        <span class="math">Z_i</span> are:
      </p>
      <div class="math-block">
        Z_i = \begin&#123;bmatrix&#125; \mathcal&#123;N&#125;_i &amp; \mathcal&#123;A&#125;_i \cdot \prod_&#123;k=i&#125;^&#123;r&#125; \mathcal&#123;L&#125;_k^&#123;-1&#125; \\ \left(\prod_&#123;k=0&#125;^&#123;r-(i+1)&#125; \mathcal&#123;L&#125;_&#123;r-k&#125;\right) \cdot \mathcal&#123;B&#125;_i &amp; I \end&#123;bmatrix&#125;
      </div>
      <p class="text-gray-300">
        and the combined matrix:
      </p>
      <div class="math-block">
        Z_0 = \begin&#123;bmatrix&#125; I &amp; 0 \\ 0 &amp; \prod_&#123;k=0&#125;^&#123;r-1&#125; \mathcal&#123;L&#125;_&#123;r-k&#125; \end&#123;bmatrix&#125;
      </div>
      <p class="text-gray-300">
        These reduced matrices decrease the multiplications from an
        <span class="math">n \times n</span> matrix-vector
        multiplication to an
        <span class="math">n \times 3 \cdot m</span> and a
        <span class="math">3 \cdot m \times (n - 3 \cdot m)</span>
        matrix-vector multiplication. The improvements are especially
        noticeable when <span class="math">m</span> is very small.
      </p>
      <p class="text-gray-300">
        <strong>Algorithm 3</strong> (LowMC with reduced linear layer):
        Given key matrix
        <span class="math">K_0 \in \mathbb&#123;F&#125;_2^&#123;n \times k&#125;</span>,
        reduced linear layer matrices
        <span class="math">Z_i \in \mathbb&#123;F&#125;_2^&#123;n \times n&#125;</span>,
        precomputed matrices
        <span class="math">P_L, Z_0, P_N</span>, and vectors
        <span class="math">C_L, C_N</span>, on input plaintext
        <span class="math">p</span> and key
        <span class="math">y</span>:
      </p>
      <div class="math-block">
        v \leftarrow P_N \cdot y + C_N
      </div>
      <div class="math-block">
        s \leftarrow (K_0 + P_L) \cdot y + p + C_L
      </div>
      <div class="math-block">
        s \leftarrow Z_0 \cdot s
      </div>
      <p class="text-gray-300">
        For <span class="math">i \in [1, r]</span>:
      </p>
      <div class="math-block">
        s \leftarrow \operatorname&#123;SBOX&#125;(s), \quad
        s \leftarrow \rho_&#123;1+3 \cdot m \cdot (i-1)&#125;^&#123;3 \cdot m \cdot i&#125;(v) + s, \quad
        s \leftarrow Z_i \cdot s
      </div>
      <p class="text-gray-300">
        Return <span class="math">s</span>.
      </p>
      <p class="text-gray-300">
        One downside is that this approach is not compatible with
        standard LowMC, as the generation of random matrices does not
        ensure that
        <span class="math">\mathcal&#123;L&#125;_i</span> is invertible.
        The authors therefore propose LowMC-I, where an additional
        rejection condition ensures invertibility of
        <span class="math">\mathcal&#123;L&#125;_i</span> during matrix
        generation.
      </p>

      <!-- 3.3 -->
      <h3 id="sec-3.3" class="text-xl font-semibold mt-8 mb-3">
        3.3 Fibonacci Feistel Network
      </h3>
      <p class="text-gray-300">
        Given that the cost of storing a binary matrix operating on
        <span class="math">n</span> bits is proportional to
        <span class="math">n^2</span>, it is possible to decrease the
        cost of an <span class="math">n \times n</span> matrix when it
        can be implemented using several
        <span class="math">m \times m</span> matrices with
        <span class="math">m &lt; n</span>. The authors propose a new
        variant called the <em>Fibonacci Feistel Network (FFN)</em>,
        which provides very fast diffusion. This structure uses the
        Fibonacci sequence
        <span class="math">\&#123;\phi_i\&#125;_&#123;i &gt; 0&#125;</span>
        defined by:
      </p>
      <div class="math-block">
        \phi_0 = 0, \; \phi_1 = 1, \; \phi_&#123;i+1&#125; = \phi_i + \phi_&#123;i-1&#125;
      </div>
      <p class="text-gray-300">
        The smallest integer <span class="math">i</span> such that
        <span class="math">\phi_i &gt; b</span> is denoted
        <span class="math">i = \Lambda_\phi(b)</span>.
      </p>
      <p class="text-gray-300">
        <strong>The Fibonacci-Feistel Structure.</strong> A FFN operates
        on <span class="math">2 \times b \times w</span> bits, where
        <span class="math">w \geq 4</span> and
        <span class="math">b \geq 2</span>, using
        <span class="math">R</span> rounds. Each round is a classical
        2-branched Feistel round where the Feistel function maps
        <span class="math">b \times w</span> bits to
        <span class="math">b \times w</span> bits. The Feistel function
        used in round <span class="math">i</span>, denoted
        <span class="math">F_i</span>, works as follows: (1) the state
        is divided into <span class="math">b</span> branches of
        <span class="math">w</span> bits; (2) each branch goes through a
        <span class="math">w</span>-bit L-Box; (3) the branches are
        rotated by <span class="math">\phi_i</span>. The full round
        function is:
      </p>
      <div class="math-block">
        X_&#123;j+b&#125;^&#123;i+1&#125; = X_j^i, \quad X_j^&#123;i+1&#125; = X_&#123;j+b&#125;^i \oplus L_&#123;j - \phi_i&#125;^i\left(X_&#123;j - \phi_i&#125;^i\right)
      </div>
      <p class="text-gray-300">
        where <span class="math">j - \phi_i</span> is taken modulo
        <span class="math">b</span> and
        <span class="math">L_j^i</span> is a
        <span class="math">w</span>-bit L-Box.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Consider a FFN with <span class="math">i</span> rounds,
            where
            <span class="math">\phi_&#123;i+1&#125; \leq b</span>.
            Then the word <span class="math">X_0^0</span> influences all
            words <span class="math">X_j^i</span> with indices
            <span class="math">0 \leq j &lt; \phi_&#123;i+1&#125;</span>
            or
            <span class="math">b \leq j &lt; b + \phi_i</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> By induction. Before round 0, only
        <span class="math">X_0^0</span> depends on
        <span class="math">X_0^0</span>. After round 0 (rotation by
        <span class="math">\phi_0 = 0</span>), only
        <span class="math">X_0^1</span> and
        <span class="math">X_b^1</span> depend on
        <span class="math">X_0^0</span>. Suppose
        <span class="math">X_j^i</span> depends on
        <span class="math">X_0^0</span> iff
        <span class="math">0 \leq j &lt; \phi_i</span> or
        <span class="math">b \leq j &lt; b + \phi_&#123;i-1&#125;</span>.
        The round function maps
        <span class="math">X^i</span> to
        <span class="math">X^&#123;i+1&#125;</span> such that:
      </p>
      <div class="math-block">
        \begin&#123;cases&#125;
        X_j^&#123;i+1&#125; = X_&#123;j+b&#125;^i \oplus L_&#123;j - \phi_i&#125;^i\left(X_&#123;j - \phi_i&#125;^i\right) &amp; \text&#123;if &#125; j &lt; b \\
        X_j^&#123;i+1&#125; = X_&#123;j-b&#125;^i &amp; \text&#123;if &#125; j \geq b
        \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        For <span class="math">j \geq b</span>:
        <span class="math">X_j^&#123;i+1&#125; = X_&#123;j-b&#125;^i</span>
        depends on <span class="math">X_0^0</span> iff
        <span class="math">0 \leq j - b &lt; \phi_i</span>, i.e.,
        <span class="math">b \leq j &lt; b + \phi_i</span>.
        For <span class="math">j &lt; b</span>:
        <span class="math">X_j^&#123;i+1&#125;</span> depends on both
        <span class="math">X_&#123;b+j&#125;^i</span> and
        <span class="math">X_&#123;j - \phi_i&#125;^i</span>. The first
        depends on <span class="math">X_0^0</span> iff
        <span class="math">0 \leq j &lt; \phi_i</span>. The second iff
        <span class="math">\phi_i \leq j &lt; \phi_&#123;i+2&#125;</span>.
        Thus for any <span class="math">j</span> with
        <span class="math">0 \leq j &lt; \phi_&#123;i+2&#125;</span>,
        <span class="math">X_j^&#123;i+1&#125;</span> depends on
        <span class="math">X_0^0</span>.
        <span class="math">\square</span>
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 2</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">R_k</span> be a permutation of
            <span class="math">\&#123;0, \ldots, 2b-1\&#125;</span>
            such that
          </p>
          <div class="math-block">
            R_k(j) = \begin&#123;cases&#125; (j + k) \bmod b &amp; \text&#123;if &#125; j &lt; b \\ b + ((j - b + k) \bmod b) &amp; \text&#123;if &#125; j \geq b \end&#123;cases&#125;
          </div>
          <p class="text-gray-300">
            meaning that applying <span class="math">R_k</span> to the
            indices of the branches rotates separately the left and
            right branches by <span class="math">k</span>. Let
            <span class="math">P</span> be one round of FFN where all
            L-Boxes are the same and let
            <span class="math">(y_0, \ldots, y_&#123;2b-1&#125;) = P(x_0, \ldots, x_&#123;2b-1&#125;)</span>.
            Then the following always holds:
          </p>
          <div class="math-block">
            P(x_&#123;R_k(0)&#125;, \ldots, x_&#123;R_k(2b-1)&#125;) = (y_&#123;R_k(0)&#125;, \ldots, y_&#123;R_k(2b-1)&#125;)
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> If the L-boxes are identical, then all operations
        in a FFN are invariant under word rotations applied to both
        halves of the internal state.
        <span class="math">\square</span>
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">Corollary 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Consider a FFN with <span class="math">i</span> rounds,
            where <span class="math">\phi_i \geq b</span>. Then each
            left input word <span class="math">X_j^0</span>, where
            <span class="math">0 \leq j &lt; b</span>, influences all
            output words <span class="math">X_j^i</span>, where
            <span class="math">0 \leq j &lt; 2b</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Let
        <span class="math">k \leq i + 1</span> be such that
        <span class="math">\phi_&#123;k-1&#125; \leq b &lt; \phi_k</span>.
        By Lemma 1, after <span class="math">k - 2</span> rounds,
        <span class="math">X_0^0</span> influences all words with
        indices <span class="math">j</span> if
        <span class="math">0 \leq j &lt; \phi_&#123;k-1&#125;</span>
        or
        <span class="math">b \leq j &lt; b + \phi_&#123;k-2&#125;</span>.
        After round <span class="math">k - 1</span>, the words on the
        left all depend on <span class="math">X_0^0</span>, and after
        round <span class="math">k \leq i + 1</span>, all output words
        depend on <span class="math">X_0^0</span>. By Lemma 2, we
        generalize to all input words from the left side.
        <span class="math">\square</span>
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 3</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Consider a FFN with
            <span class="math">\Lambda_\phi(b) + 1</span> rounds
            labelled
            <span class="math">-1, 0, 1, \ldots, \Lambda_\phi(b) - 1</span>
            and where we set
            <span class="math">\phi_&#123;-1&#125; = 0</span>. Then each
            input word <span class="math">X_k^&#123;-1&#125;</span>,
            where
            <span class="math">0 \leq k &lt; 2b</span>, influences all
            output words
            <span class="math">X_j^&#123;\Lambda_\phi(b)&#125;</span>,
            where
            <span class="math">0 \leq j &lt; 2b</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> After the initial round, each input word
        <span class="math">X_k^&#123;-1&#125;</span>
        (<span class="math">0 \leq k &lt; 2b</span>) influences one
        left word
        <span class="math">X_k^0 \pmod&#123;b&#125;</span> which in turn
        (see Corollary 1) influences all output words.
        <span class="math">\square</span>
      </p>

      <p class="text-gray-300">
        <strong>Efficient Implementation.</strong> The linear layer can
        be evaluated using
        <span class="math">\mathcal&#123;O&#125;(\Lambda_\phi(b) \cdot w)</span>
        operations on a modern processor, where
        <span class="math">2 \times b \times w = n</span>. The core
        trick is in the definition and implementation of the L-Box layer
        composed with the rotation by
        <span class="math">\phi_i</span>. Using a bit-sliced strategy,
        the Feistel function can be decomposed as:
      </p>
      <div class="math-block">
        F_i = M^&#123;-1&#125; \circ \mathrm&#123;ROT&#125;_&#123;\phi_i&#125; \circ \mathcal&#123;L&#125;_i \circ M
      </div>
      <p class="text-gray-300">
        where <span class="math">M</span> is a bit permutation mapping
        the <span class="math">w</span>-bit word with index
        <span class="math">j</span> to bits with indices congruent to
        <span class="math">j</span> modulo
        <span class="math">b</span>, and
        <span class="math">\mathcal&#123;L&#125;_i</span> is
        parameterized by <span class="math">w</span> words of size
        <span class="math">bw</span> computing:
      </p>
      <div class="math-block">
        \mathcal&#123;L&#125;_i(y) = \bigoplus_&#123;j=0&#125;^&#123;w-1&#125; \ell_j^i \wedge (y \lll (j \cdot b))
      </div>
      <p class="text-gray-300">
        For a 256-bit linear layer
        (<span class="math">n = 256 = 2 \times 32 \times 4</span>), a
        bijective linear layer with full diffusion uses
        <span class="math">1 + \Lambda_\phi(32) = 10</span> rounds.
        In total, this requires 40 copies, 40 rotations, 40 XORs, 40
        ANDs, and 10 swaps, all on 128-bit words.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. PERFORMANCE AND MEMORY EVALUATION                         -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Performance and Memory Evaluation
      </h2>
      <p class="text-gray-300">
        Both suggested optimizations were implemented and evaluated
        against the Picnic implementation available on GitHub. All
        measurements used the LowMC parameters from Picnic with
        blocksizes 128, 192, and 256, each with 10 S-boxes.
      </p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Reduced Round Key Computation and Constant Addition
      </h3>
      <p class="text-gray-300">
        Benchmarks on an Intel Core i7-4790 show improvements of 1.1x
        for the 128-bit case and up to 1.8x for larger instances.
        Results on Raspberry Pi 3 show even larger improvements of
        factors 1.6 to 2 for signing and verifying across all instances.
      </p>
      <p class="text-gray-300">
        For the PICNIC-256 parameter set, the round key calculations
        shrink from 39 matrices of dimension
        <span class="math">256 \times 256</span> (312 KB) to one
        <span class="math">256 \times 256</span> and one
        <span class="math">1140 \times 256</span> matrix. The 38
        round constants (1.2 KB) are replaced with one 256-bit vector
        and one 1140-bit vector (0.17 KB). RRKC reduces storage for
        round key matrices and constants by more than 85 %. Including
        the linear layer, savings are still 43 %.
      </p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Reduced Linear Layer
      </h3>
      <p class="text-gray-300">
        When comparing an implementation without optimizations to one
        with RLL, performance improves by up to a factor of 4 with the
        instances used in Picnic. Compared to RRKC alone, RLL improves
        runtime by up to a factor of 3.
      </p>
      <p class="text-gray-300">
        For LowMC instances with
        <span class="math">m = 1</span>, RLL further reduces runtime
        to <span class="math">1/12</span> and
        <span class="math">1/25</span> of the original, respectively.
        Memory-wise, for Picnic-256 the linear layer shrinks from 304 KB
        to 37.69 KB (87 % reduction). For the 256-bit instance with
        <span class="math">m = 1</span>, the linear layer is reduced
        from 2904 KB to 41.45 KB, representing only 2 % of original
        size.
      </p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 Fibonacci Feistel Network
      </h3>
      <p class="text-gray-300">
        The FFN was benchmarked against a constant-time matrix
        multiplication. The constant-time implementation requires 2302
        cycles for a
        <span class="math">256 \times 256</span> matrix-vector
        multiplication. The FFN with 64-bit branches performs 10 %
        better while using 37 % less memory (5120 bytes vs 8192 bytes
        for the full matrix).
      </p>
      <p class="text-gray-300">
        Various FFN instances for
        <span class="math">n = 256</span> bits were evaluated: with
        <span class="math">2 \times 32 \times 4</span>-bit configuration
        (10 rounds, 4463 cycles, 640 bytes), up to
        <span class="math">2 \times 2 \times 64</span>-bit
        configuration (5 rounds, 2047 cycles, 5120 bytes).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. DISCUSSION                                                -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Discussion</h2>
      <p class="text-gray-300">
        The results suggest that all three optimizations yield even
        better results for larger block sizes, e.g., those used by
        LowMCHash-256 [AGR+16] in post-quantum ring signature schemes
        [DRS18]. For RRKC and RLL, the number of S-boxes is essential
        for the performance gain. If the number of S-boxes remains
        constant while block size increases, the impact is higher. If
        <span class="math">3 \cdot m</span> is almost as large as
        <span class="math">n</span>, then no performance gain is
        expected.
      </p>
      <p class="text-gray-300">
        The proposed FFN will also yield higher gains for larger block
        sizes. While the cost for constant-time multiplication
        quadruples when the block size doubles, the FFN less than
        triples the cost. For a
        <span class="math">4096 = 2 \times 32 \times 64</span>-bit
        instance, the FFN requires only 20,480 XOR operations compared
        to 262,144 for constant-time multiplication.
      </p>
      <p class="text-gray-300">
        Both main contributions will likely also be useful for other
        cipher designs relying heavily on large linear layers, such as
        Rasta [DEG+18].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        We thank Tyge Tiessen for interesting ideas and discussions on
        optimizing LowMC&rsquo;s round key computation. We also thank
        Christoph Dobraunig, Maria Eichlseder and Eik List for comments
        on earlier versions. S. Ramacher and C. Rechberger have been
        supported by H2020 project Prismacloud, grant agreement
        n&deg;644962. C. Rechberger has additionally been supported by
        EU H2020 project PQCRYPTO, grant agreement n&deg;645622.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-decimal list-inside space-y-2 text-gray-400
        text-sm">
        <li>
          [ADKF70] V. Arlazarov, E. Dinic, M. Kronrod, and
          I. Faradzev. &ldquo;On economical construction of the
          transitive closure of a directed graph.&rdquo; In:
          <em>Soviet Math Dokl.</em>, 1970.
        </li>
        <li>
          [AGR+16] Martin R. Albrecht, Lorenzo Grassi, Christian
          Rechberger, Arnab Roy, and Tyge Tiessen. &ldquo;MiMC:
          Efficient Encryption and Cryptographic Hashing with Minimal
          Multiplicative Complexity.&rdquo; In: <em>ASIACRYPT (1)</em>,
          Vol. 10031. LNCS, pp. 191&ndash;219, 2016.
        </li>
        <li>
          [AL00] Kazumaro Aoki and Helger Lipmaa. &ldquo;Fast
          implementations of AES candidates.&rdquo; In: <em>AES
          Candidate Conference</em>, pp. 106&ndash;120, 2000.
        </li>
        <li>
          [ARS+15] Martin R. Albrecht, Christian Rechberger, Thomas
          Schneider, Tyge Tiessen, and Michael Zohner. &ldquo;Ciphers
          for MPC and FHE.&rdquo; In: <em>EUROCRYPT (1)</em>,
          Vol. 9056. LNCS. Springer, pp. 430&ndash;454, 2015.
        </li>
        <li>
          [ARS+16] Martin R. Albrecht, Christian Rechberger, Thomas
          Schneider, Tyge Tiessen, and Michael Zohner. &ldquo;Ciphers
          for MPC and FHE.&rdquo; IACR Cryptology ePrint Archive,
          2016:687, 2016.
        </li>
        <li>
          [Bar06] Gregory V. Bard. &ldquo;Accelerating cryptanalysis
          with the method of four russians.&rdquo; IACR Cryptology
          ePrint Archive, 2006:251, 2006.
        </li>
        <li>
          [BB02] Elad Barkan and Eli Biham. &ldquo;In how many ways
          can you write rijndael?&rdquo; In: <em>ASIACRYPT</em>,
          Vol. 2501. LNCS. Springer, pp. 160&ndash;175, 2002.
        </li>
        <li>
          [BBF+02] Guido Bertoni, Luca Breveglieri, Pasqualina
          Fragneto, Marco Macchetti, and Stefano Marchesin.
          &ldquo;Efficient software implementation of AES on 32-bit
          platforms.&rdquo; In: <em>CHES</em>, Vol. 2523. LNCS.
          Springer, pp. 159&ndash;171, 2002.
        </li>
        <li>
          [BEF18] Dan Boneh, Saba Eskandarian, and Ben Fisch.
          &ldquo;Post-quantum group signatures from symmetric
          primitives.&rdquo; IACR Cryptology ePrint Archive,
          2018:261, 2018.
        </li>
        <li>
          [Ber09] Daniel J. Bernstein. &ldquo;Optimizing linear maps
          modulo 2.&rdquo; 2009. url:
          <a
            href="https://binary.cr.yp.to/linearmod2.html"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >binary.cr.yp.to/linearmod2.html</a>.
        </li>
        <li>
          [BS08] Daniel J. Bernstein and Peter Schwabe. &ldquo;New AES
          software speed records.&rdquo; In: <em>INDOCRYPT</em>,
          Vol. 5365. LNCS. Springer, pp. 322&ndash;336, 2008.
        </li>
        <li>
          [CCF+16] Anne Canteaut, Sergiu Carpov, Caroline Fontaine,
          Tancr&egrave;de Lepoint, Mar&iacute;a Naya-Plasencia, Pascal
          Paillier, and Renaud Sirdey. &ldquo;Stream ciphers: A
          practical solution for efficient homomorphic-ciphertext
          compression.&rdquo; In: <em>FSE</em>, Vol. 9783. LNCS.
          Springer, pp. 313&ndash;333, 2016.
        </li>
        <li>
          [CDG+17a] Melissa Chase, David Derler, Steven Goldfeder,
          Claudio Orlandi, Sebastian Ramacher, Christian Rechberger,
          Daniel Slamanig, and Greg Zaverucha. &ldquo;Post-quantum
          zero-knowledge and signatures from symmetric-key
          primitives.&rdquo; In: <em>CCS</em>. ACM,
          pp. 1825&ndash;1842, 2017.
        </li>
        <li>
          [CDG+17b] Melissa Chase, David Derler, Steven Goldfeder,
          Claudio Orlandi, Sebastian Ramacher, Christian Rechberger,
          Daniel Slamanig, and Greg Zaverucha. <em>The Picnic Signature
          Algorithm Specification</em>, 2017. url:
          <a
            href="https://github.com/Microsoft/Picnic/blob/master/spec.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/Microsoft/Picnic</a>.
        </li>
        <li>
          [DEG+18] Christoph Dobraunig, Maria Eichlseder, Lorenzo
          Grassi, Virginie Lallemand, Gregor Leander, Eik List, Florian
          Mendel, and Christian Rechberger. &ldquo;Rasta: A cipher with
          low AND depth and few ANDs per bit.&rdquo; In: <em>CRYPTO
          (1)</em>, Vol. 10991. LNCS. Springer, pp. 662&ndash;692,
          2018.
        </li>
        <li>
          [Din18] Itai Dinur. &ldquo;Linear equivalence of block
          ciphers with partial non-linear layers: Application to
          LowMC.&rdquo; Cryptology ePrint Archive, Report 2018/772,
          2018. url:
          <a
            href="https://eprint.iacr.org/2018/772"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2018/772</a>.
        </li>
        <li>
          [DPVR00] Joan Daemen, Micha&euml;l Peeters, Gilles Van
          Assche, and Vincent Rijmen. <em>Nessie Proposal:
          NOEKEON</em>, 2000. url:
          <a
            href="http://gro.noekeon.org/Noekeon-spec.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >gro.noekeon.org/Noekeon-spec.pdf</a>.
        </li>
        <li>
          [DRS18] David Derler, Sebastian Ramacher, and Daniel
          Slamanig. &ldquo;Post-quantum zero-knowledge proofs for
          accumulators with applications to ring signatures from
          symmetric-key primitives.&rdquo; In: <em>PQCrypto</em>,
          Vol. 10786. LNCS. Springer, pp. 419&ndash;440, 2018.
        </li>
        <li>
          [DSES14] Yarkin Dor&ouml;z, Aria Shahverdi, Thomas
          Eisenbarth, and Berk Sunar. &ldquo;Toward practical
          homomorphic evaluation of block ciphers using prince.&rdquo;
          In: <em>Financial Cryptography Workshops</em>, Vol. 8438.
          LNCS. Springer, pp. 208&ndash;220, 2014.
        </li>
        <li>
          [GLSV14] Vincent Grosso, Ga&euml;tan Leurent,
          Fran&ccedil;ois-Xavier Standaert, and Kerem Varici.
          &ldquo;LS-designs: Bitslice encryption for efficient masked
          software implementations.&rdquo; In: <em>FSE</em>,
          Vol. 8540. LNCS. Springer, pp. 18&ndash;37, 2014.
        </li>
        <li>
          [GMO16] Irene Giacomelli, Jesper Madsen, and Claudio
          Orlandi. &ldquo;ZKBoo: Faster zero-knowledge for boolean
          circuits.&rdquo; In: <em>USENIX Security Symposium</em>.
          USENIX Association, pp. 1069&ndash;1083, 2016.
        </li>
        <li>
          [GRR+16] Lorenzo Grassi, Christian Rechberger, Dragos
          Rotaru, Peter Scholl, and Nigel P. Smart. &ldquo;MPC-friendly
          symmetric key primitives.&rdquo; In: <em>ACM CCS</em>. ACM,
          pp. 430&ndash;443, 2016.
        </li>
        <li>
          [IKOS07] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky,
          and Amit Sahai. &ldquo;Zero-knowledge from secure multiparty
          computation.&rdquo; In: <em>STOC</em>. ACM,
          pp. 21&ndash;30, 2007.
        </li>
        <li>
          [MJSC16] Pierrick M&eacute;aux, Anthony Journault,
          Fran&ccedil;ois-Xavier Standaert, and Claude Carlet.
          &ldquo;Towards stream ciphers for efficient FHE with low-noise
          ciphertexts.&rdquo; In: <em>EUROCRYPT (1)</em>, Vol. 9665.
          LNCS. Springer, pp. 311&ndash;343, 2016.
        </li>
        <li>
          [NLV11] Michael Naehrig, Kristin E. Lauter, and Vinod
          Vaikuntanathan. &ldquo;Can homomorphic encryption be
          practical?&rdquo; In: <em>CCSW</em>. ACM,
          pp. 113&ndash;124, 2011.
        </li>
        <li>
          [NPV17] Val&eacute;rie Nachef, Jacques Patarin, and
          Emmanuel Volte. <em>Feistel Ciphers &ndash; Security Proofs
          and Cryptanalysis</em>. Springer, 2017.
        </li>
        <li>
          [RSS17] Dragos Rotaru, Nigel P. Smart, and Martijn Stam.
          &ldquo;Modes of operation suitable for computing on encrypted
          data.&rdquo; In: <em>IACR Trans. Symmetric Cryptol.</em>,
          2017(3):294&ndash;324, 2017.
        </li>
        <li>
          [SM10] Tomoyasu Suzaki and Kazuhiko Minematsu.
          &ldquo;Improving the generalized Feistel.&rdquo; In:
          <em>FSE</em>, Vol. 6147. LNCS. Springer,
          pp. 19&ndash;39, 2010.
        </li>
        <li>
          [SME16] Shady Mohamed Soliman, Baher Magdy, and Mohamed A.
          Abd El-Ghany. &ldquo;Efficient implementation of the AES
          algorithm for security applications.&rdquo; In:
          <em>SoCC</em>. IEEE, pp. 206&ndash;210, 2016.
        </li>
        <li>
          [SMMK12] Tomoyasu Suzaki, Kazuhiko Minematsu, Sumio Morioka,
          and Eita Kobayashi. &ldquo;TWINE: A lightweight block cipher
          for multiple platforms.&rdquo; In: <em>Selected Areas in
          Cryptography</em>, Vol. 7707. LNCS. Springer,
          pp. 339&ndash;354, 2012.
        </li>
      </ol>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A: An Example of Fibonacci-Feistel Network
      </h2>
      <p class="text-gray-300">
        The appendix depicts the propagation of the left-most bit
        through a 6-round FFN structure with
        <span class="math">b = 8</span> branches. The rectangles
        correspond to distinct L-Box calls. A branch is highlighted if
        its value depends on the left-most word of the input. This
        illustrates the fast diffusion property described in Lemma 1.
      </p>
      <p class="text-gray-300">
        <em>(Figure 4 from the original paper: 6 rounds of the FFN
        structure for <span class="math">b = 8</span>, showing how
        <span class="math">X_0^0</span> propagates through the
        network.)</em>
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX B                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-b" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix B: Example of Binary Matrices Corresponding to a FFN
      </h2>
      <p class="text-gray-300">
        The matrix presented in the original paper has the following
        properties:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
        <li>It has full rank.</li>
        <li>
          <span class="math">33585 \approx 0.51 \times 2^&#123;16&#125;</span>
          of its coefficients are equal to 1.
        </li>
        <li>
          It can be evaluated using a 10-round FFN with 32 independent
          and random 4-bit linear permutations used as L-boxes in each
          round. A new L-box layer is used for each round.
        </li>
      </ul>
      <p class="text-gray-300">
        Its inverse has similar properties.
      </p>
      <p class="text-gray-300">
        <em>(Figure 5 from the original paper: A matrix
        <span class="math">M</span> and its inverse
        <span class="math">M^&#123;-1&#125;</span> corresponding to a
        10-round 256-bit FFN with
        <span class="math">b = 32</span>,
        <span class="math">w = 4</span>. Black means 1, white means
        0.)</em>
      </p>
    </section>

  </article>
</BaseLayout>
