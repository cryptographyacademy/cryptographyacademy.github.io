---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/481';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Side-Channel Analysis Protection and Low-Latency in Action - case study of PRINCE and Midori';
const AUTHORS_HTML = 'Amir Moradi, Tobias Schneider';

const CONTENT = `    <p class="text-gray-300">– case study of PRINCE and Midori –</p>

    <p class="text-gray-300">Amir Moradi and Tobias Schneider</p>

    <p class="text-gray-300">Horst G¨ortz Institute for IT-Security, Ruhr-Universit¨at Bochum, Germany {amir.moradi, tobias.schneider-a7a}@rub.de</p>

    <p class="text-gray-300">Abstract. During the last years, the industry sector showed particular interest in solutions which allow to encrypt and decrypt data within one clock cycle. Known as low-latency cryptography, such ciphers are desirable for pervasive applications with real-time security requirements. On the other hand, pervasive applications are very likely in control of the end user, and may operate in a hostile environment. Hence, in such scenarios it is necessary to provide security against side-channel analysis (SCA) attacks while still keeping the low-latency feature.</p>

    <p class="text-gray-300">Since the single-clock-cycle concept requires an implementation in a fullyunrolled fashion, the application of masking schemes – as the most widely studied countermeasure – is not straightforward. The contribution of this work is to present and discuss about the difficulties and challenges that hardware engineers face when integrating SCA countermeasures into low-latency constructions. In addition to several design architectures, practical evaluations, and discussions about the problems and potential solutions with respect to the case study PRINCE (also compared with Midori), the final message of this paper is a couple of suggestions for future low-latency designs to – hopefully – ease the integration of SCA countermeasures.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The need for integration of side-channel analysis (SCA) [29] countermeasures into pervasive security-enabled devices is known to both academia and industry. Such a demand has also been motivated by several practical key-recovery attacks on commercial applications, e.g., [2,22,31,34,41,54]. From another perspective, there are several important applications for which a low-latency encryption and instant response time is highly desirable, such as read/write access to encrypted memory modules, which should be preferably conducted in a single clock cycle (initially motivated by [27]). It is also expected that given the ongoing growth of pervasive computing, there will be many more future embedded systems that require lowlatency encryption, especially applications with real-time requirements, e.g., in the automotive domain. Hence, such pervasive applications, where low-latency cryptography is required, should be protected against SCA threats.</p>

    <p class="text-gray-300">Here in this work, we present the challenges one may face by integrating SCA countermeasures into implementations with low-latency target. Insertion of hiding techniques [32] in this scenario is either straightforward (such as noise generation or dual-rail logic) or ineffective (such as time randomization or shuffling) due to the fully unrolled architecture of low-latency implementations. Therefore, our focus is the integration of masking schemes into such designs. In particular, we concentrate on threshold implementation (TI) [40] as a provably-secure scheme against first-order SCA attacks. It should be noted that integration of ad hoc approaches, e.g., random pre-charging of [6], are out of our focus since we target solutions with provable security.</p>

    <p class="text-gray-300">We should point out that it has previously been supposed that unrolled circuits – also the case of low-latency concept – are inherently secure against SCA attacks (see [6]). However, other practical results, e.g., in [36] and [51], showed that unrolling may make the attacks complicated since the common hypothetical power models (Hamming weight/distance) may not fit to the circuit's leakage anymore, but sophisticated yet first-order leakages can be exploited for key recovery.</p>

    <p class="text-gray-300">As a known case study, PRINCE [13] (particularly designed as a low-latency cipher) is targeted in our investigations. We demonstrate design architectures and practical results with respect to the power consumption as well as SCA protection of different variants of implementations of PRINCE. In addition to several discussions about the SCA protection versus low-latency concept, we present a mixture of asynchronous circuit design methodology with threshold implementation which is expected to realize an SCA-protected self-timed design. Finally, having the PRINCE case study in mind, we give a couple of suggestions for the future low-latency cipher designs with the goal of mitigating the challenges, where SCA protection is desirable.</p>

    <p class="text-gray-300">Furthermore, we consider the cipher Midori [3] which was designed with the goal of minimizing energy consumption. Since energy consumption and latency – to some extent – are proportional, we also provide a comparison between PRINCE and Midori with respect to latency when both are equipped with similar masking countermeasure.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2 Preliminaries</h3>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 PRINCE</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRINCE [13] is a 64-bit block cipher that uses a 128-bit secret key k. The key expansion divides k into two 64-bit parts as  $k = (k_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_1)<span class="math"> , and derives  </span>k'_0<span class="math">  from  </span>k_0<span class="math">  by a linear function as  </span>(k_0 \\gg 1) \\oplus (k_0 \\gg 63)<span class="math"> . The subkeys  </span>k_0<span class="math">  and  </span>k'_0<span class="math">  are used as input and output whitening keys respectively, while  </span>k_1$  is used as the round key for the core block cipher PRINCE<sub>core</sub> (see Figure 1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Each of the first five round functions  <span class="math">\\mathcal{R}_i</span>  consists of <strong>S-Layer</strong> (by a 4-bit Sbox), <strong>M'-Layer</strong> (multiplication with a 64 × 64 matrix M'), <strong>ShiftRows</strong> (the same as the AES one but on 4-bit cells),  <span class="math">RC_i</span> -add (XORing the state with a 64-bit constant  <span class="math">RC_i</span> ), and  <span class="math">k_1</span>  add (XORing  <span class="math">k_1</span>  into the 64-bit state).</p>

    <p class="text-gray-300"><img src="_page_2_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 1. A schematic view of PRINCE</p>

    <p class="text-gray-300">The last five inverse round functions  <span class="math">\\mathcal{R}_i^{-1}</span>  are formed by the inverse of the corresponding operations. It is noteworthy that M' matrix is an involution, hence the inverse of  <span class="math">\\mathbf{M&#x27;}</span> -Layer is itself. Further, due to its underlying FX-construction [26] as well as the  <span class="math">\\alpha</span> -reflection, i.e.,  <span class="math">RC_{i \\in \\{0,\\dots,11\\}} \\oplus RC_{11-i} = \\alpha</span> , the PRINCE encryption can turn to its decryption by swapping the whitening keys and XORing  <span class="math">\\alpha</span>  to  <span class="math">k_1</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">PRINCE^{Dec}_{(k_0,k&#x27;_0,k_1)} = PRINCE^{Enc}_{(k&#x27;_0,k_0,k_1 \\oplus \\alpha)}.</span></div>

    <p class="text-gray-300">Note that  <span class="math">RC_0=0</span> , and  <span class="math">RC_{i\\in\\{1,\\dots,5\\}}</span>  as well as  <span class="math">\\alpha</span>  are derived from the fraction part of  <span class="math">\\pi=3.141\\dots</span></p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Threshold Implementation</h3>

    <p class="text-gray-300">Let us denote a 4-bit intermediate value of PRINCE, e.g., the Sbox input, as  <span class="math">\\boldsymbol{x} = \\langle x_1, \\dots, x_4 \\rangle</span> . Under the n-1 order Boolean masking concept,  <span class="math">\\boldsymbol{x}</span>  is represented by  <span class="math">(\\boldsymbol{x}^1, \\dots, \\boldsymbol{x}^n)</span> , where  <span class="math">\\boldsymbol{x} = \\bigoplus_{i=1}^n \\boldsymbol{x}^i</span>  and each  <span class="math">\\boldsymbol{x}^i</span>  similarly denotes a 4-bit vector  <span class="math">\\langle x_1^i, \\dots, x_4^i \\rangle</span> .</p>

    <p class="text-gray-300">The linear functions, such as  <span class="math">\\mathbf{M}&#x27;</span> -Layer, can be simply applied to the shares of  <span class="math">\\boldsymbol{x}</span>  as  <span class="math">\\mathsf{L}(\\boldsymbol{x}) = \\bigoplus_{i=1}^n \\mathsf{L}(\\boldsymbol{x}^i)</span> . Clearly, the non-linear functions, e.g., Sbox, cannot be trivially shared. Following the TI concept [8,40], the minimum number of shares to realize an Sbox to be secure against first-order attacks is n=t+1, where t denotes the algebraic degree of the Sbox. The shared Sbox should provide the output also in a shared form  <span class="math">(\\boldsymbol{y}^1,\\ldots,\\boldsymbol{y}^m)</span> , where  <span class="math">m\\geq n</span>  when the Sbox is a bijection. Obviously, to ensure the <em>correctness</em> of the computation, we should have  <span class="math">\\mathsf{S}(\\boldsymbol{x}) = \\boldsymbol{y} = \\bigoplus_{i=1}^m \\boldsymbol{y}^i</span> .</p>

    <p class="text-gray-300">Each output share  <span class="math">\\boldsymbol{y}^{j\\in\\{1,\\ldots,m\\}}</span>  is given by a component function  <span class="math">\\mathsf{f}^j(\\cdot)</span>  over</p>

    <p class="text-gray-300">Each output share  <span class="math">\\mathbf{y}^{j \\in \\{1, \\dots, m\\}}</span>  is given by a component function  <span class="math">\\mathbf{f}^{j}(\\cdot)</span>  over a subset of input shares. Defined as non-completeness, for first-order security each component function  <span class="math">\\mathbf{f}^{j \\in \\{1, \\dots, m\\}}(\\cdot)</span>  must be independent of at least one input share. The security of masking schemes (to some extent) depends on the uniform distribution of the masks. Therefore, the output of a TI Sbox must be also uniform, since it supplies other non-linear functions. For example, the Sbox</p>

    <p class="text-gray-300">output of one PRINCE round is given to the next S-Layer after being processed by the linear diffusion layers. In case of the bijective PRINCE Sbox (n = m), each (x 1 , . . . , x <sup>n</sup>) should be mapped to a unique (y 1 , . . . , y <sup>n</sup>) to satisfy the uniformity. In other words, it is enough to check whether the TI Sbox also forms a bijection with 4 n input (and output) bit length.</p>

    <p class="text-gray-300">The PRINCE Sbox has an algebraic degree of t = 3. Hence, the number of input and output shares n = m > 3 what directly affects the complexity of the circuit and its associated area overhead. Therefore, it is preferable to decompose the Sboxes into smaller non-linear functions each with maximum algebraic degree of 2, which enables staying with the minimum number of shares n = m = 3. Note that in this case, registers must be placed between the shared decomposed functions. Otherwise, the glitches propagate into cascaded shared non-linear circuits, and violate the non-completeness property. As an example, the authors of [42] presented a decomposition of the PRESENT [12] Sbox into two quadratic bijections g and f.</p>

    <p class="text-gray-300">Above we briefly reviewed the TI concept. For detailed information, the interested reader is referred to the original articles [8, 40].</p>

    <p class="text-gray-300">As stated before, PRINCE cipher has been designed with respect to low-latency feature. The goal was to achieve a short latency when the cipher is implemented in a fully-unrolled fashion. In other words, the implementation contains no sequential elements, e.g., register/flip-flop, and hence no clock.</p>

    <p class="text-gray-300">In our investigations, in order to synthesize for an ASIC platform, we made use of Synopsys Design Compiler using the UMCL18G212T3 [49] ASIC standard cell library, i.e., UMC 0.18µm. As a side note, such a standard library has not been covered by the original article [13], where Nangate 45 nm, UMC 90 nm, and UMC 130 nm technologies have been considered. Therefore, the performance figures which we report here are based on our syntheses. Since the area requirement, i.e., Gate Equivalence (GE), of an implementation varies depending on the desired latency, we give in Figure 2 a curve of GE of the unrolled PRINCE implementation over the latency. We should stress that similar to the target of the seminal work [13], all our design architectures support both encryption and decryption. For the threshold implementations, the syntheses have been performed by keeping the hierarchy to avoid the combination of different shares (otherwise, first-order leakage is probable), and for the unrolled (unprotected) designs the hierarchy is avoided which allows the synthesizer to combine the cascaded circuits and reach the desired latency.</p>

    <p class="text-gray-300">As stated in Section 2.2, in order to realize a masked hardware implementation, the masked non-linear functions (Sboxes) should be separated from each other by means of registers to avoid the propagation of glitches. Therefore, an unrolled architecture can never be properly masked. It is noteworthy that unrolled architectures already change the leakage characteristics of the device (see [6, 51]). Hence, one may suppose that integration of masking into unrolled</p>

    <p class="text-gray-300"><img src="_page_4_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 2. Area versus latency of unrolled PRINCE</p>

    <p class="text-gray-300"><img src="_page_4_Figure_4.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 3. Unrolled TI of PRINCE, only first and last round masked</p>

    <p class="text-gray-300">architectures may complicate the device leakage in such a way that it becomes unexploitable. However, such a combination would definitely lead to first-order leakage detectable e.g., by t-test [18,24,44]. As a heuristic-based example, it can be supposed that masking the first and last rounds of PRINCE should suffice to protect against SCA attacks<sup>1</sup>. The PRINCE Sbox is a cubic 4-bit bijection, i.e., algebraic degree t=3, and at least n=m=4 shares are required. The PRINCE Sbox belongs to the class  <span class="math">C_{231}</span>  (with respect to the category given in [10]), which needs three decomposition stages to be uniformly shared with 3 as well as 4 shares, while it can be uniformly shared in one stage with n=m=5 shares. It has been given in Section 2.2 that the uniformity is required because the output of the shared Sbox feeds the next non-linear functions. Hence, the non-uniform output of the first cipher round does not play any role, if the second cipher round is not masked. Therefore, we can stay with n = m = 4 shares and make the (non-uniform) shared PRINCE Sbox in one stage by direct sharing [11]. We have implemented such a design, whose block diagram is shown in Figure 3 and all the corresponding formulations are given in Appendix A. Further, its timing</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{1}&lt;/sup&gt;</span>  In general, it is not a true statement since i) the unmasking at the end of the first round (see Figure 3) would anyway lead to (although hard-to-exploit) first-order leakage, and ii) the adversary can set certain plaintext bits to a fixed value and target the second cipher round.</p>

    <p class="text-gray-300">and area overheads are listed in Table 1. It turned out that this design is 3-6 times larger than the unprotected unrolled design and 2-3 times slower. We deal with its practical SCA evaluations in Section 3.4. We should emphasize that except for the first and last (i.e., masked) rounds, the hierarchy is not kept. This allows the optimization of the middle rounds, while the functions over the shared signals (in the first and the last rounds) must be kept separate to avoid any combination over the shares. Otherwise, the design would exhibit first-order leakage at the first and/or last rounds.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.1 Round-based Architecture</h3>

    <p class="text-gray-300">Alternatively, we can consider the round-based architecture, although it obviously needs a fast clock, and the setup- and hold-time of the registers increase the whole latency. A round-based design has been given in the original article [13] which is also depicted in Figure 4(a). In this design two separate modules for the Sbox and its inverse are considered. It has been reported in a couple of works [9, 37, 42] that shared Sboxes are the most area consuming part. Therefore, one of our attempts with respect to this issue is to combine these two modules. Indeed, we have realized that the PRINCE Sbox and its inverse are affine equivalent. In other words, we can write</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\boldsymbol{x}, S(\\boldsymbol{x}) = A_2 \\left( S^{-1} \\left( A_1 \\left( \\boldsymbol{x} \\right) \\right) \\right),</span></div>

    <p class="text-gray-300">with A<sup>1</sup> and A<sup>2</sup> input- and output-affine transformations. In case of the PRINCE Sbox, there exists only one pair (A1, A2), and A<sup>1</sup> and A<sup>2</sup> are the same. Hence, we can write S = A ◦ S <sup>−</sup><sup>1</sup> ◦ <sup>A</sup>, with <sup>A</sup>: B8A93021EDFC6574 as<sup>2</sup></p>

    <p class="text-gray-300"><span class="math-block">e = 1 + a + b + d,</span>   <span class="math">f = 1 + a,</span>   <span class="math">g = d,</span>   <span class="math">h = 1 + c,</span></p>

    <p class="text-gray-300">with ha, b, c, di the 4-bit input, he, f, g, hi the 4-bit output, and a and e the least significant bits. Based on this findings, we developed another round-based architecture, shown in Figure 4(b), where only one S-Layer module is instantiated.</p>

    <p class="text-gray-300">More detailed information about the active data path of both round-based designs at each cipher round is given in Appendix B (Figure 17 and Figure 18). Table 1 lists the differences between these two designs. Note that we constrained the syntheses of both designs with different latencies to obtain both fastest and smallest designs for fair comparisons. As stated, the objective is to make use of only one S-Layer, hence our design utilizes more multiplexers compared to the original round-based design. Further, we optimized the way that whitening keys k<sup>0</sup> and k <sup>0</sup> are added to the state considering the fact that it should support both encryption and decryption. Another issue is how to deal with the round constants. As given in Section 2.1, the round constants have been randomly selected, hence a combinatorial circuit should realize the selection of RC<sup>i</sup> at each round. We have examined several cases, and the most optimized design (with respect to area) has been achieved by employing a multiplexer which selects one</p>

    <p class="text-gray-300"><sup>2</sup> It also holds for S <sup>−</sup><sup>1</sup> = A 0 ◦ S ◦ A 0 , with A 0 : 5764FDCE1320B98A.</p>

    <p class="text-gray-300"><img src="_page_6_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 4. Round-based designs</p>

    <p class="text-gray-300">of the  <span class="math">RC_0</span>  to  <span class="math">RC_{11}</span>  by the round counter. The role of optimization was to assign 0111 as the round counter to the round number i = 5. Therefore, the order of the round counter 0010, 0011, ..., 0111, 1000, ..., 1100, 1101 can be reversed (required for decryption) by inverting the round counter bits (see Figure 4(b)). We should also point out that in both original and our round-based designs, the state register is placed right after the multiplexer. That allows the synthesizer to combine them and make use of scan flip-flop, which is smaller than a sum of a multiplexer and a flip-flop [43].</p>

    <p class="text-gray-300">As a side note, our round-based design is not necessarily the most optimized design. The tricks, that we used in our design, can be also applied in the original one (Figure 4(a)). However, since our target is to instantiate one <strong>S-Layer</strong> to ease the threshold implementations, we consider our round-based architecture as the basis of the further designs.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.2 Uniform Sharing of the Sbox</h4>

    <p class="text-gray-300">The uniform sharing of the cubic 4-bit bijection  <span class="math">C_{231}</span> , to which the PRINCE Sbox belongs, with 3 shares can only be achieved by a three-stage quadratic decomposition [11]. As listed in [11], there exist 5 quadratic classes,  <span class="math">Q_4</span> ,  <span class="math">Q_{12}</span> ,  <span class="math">Q_{293}</span> ,  <span class="math">Q_{294}</span> , and  <span class="math">Q_{299}</span> , that can be uniformly shared in one stage<sup>3</sup>. With respect</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>3</sup> One more quadratic class  <span class="math">Q_{300}</span>  exists, but needs two stages for a uniform sharing with 3 shares.</p>

    <p class="text-gray-300">to their size, i.e., the number of 2-input AND and XOR gates in their Algebraic Normal Form (ANF),  <span class="math">Q_4</span> ,  <span class="math">Q_{294}</span> ,  <span class="math">Q_{12}</span> ,  <span class="math">Q_{293}</span> , and  <span class="math">Q_{299}</span>  are respectively the smallest to the largest functions. We tried to decompose  <span class="math">C_{231}</span>  by a set of the smallest quadratic functions. Indeed, several decompositions exist (see Table 2 in Appendix C for a complete list). If  <span class="math">Q_4</span>  is involved in the decomposition, the other quadratic functions are a combination of  <span class="math">(Q_{293}, Q_{299})</span>  or  <span class="math">(Q_{293}, Q_{293})</span>  or  <span class="math">(Q_{299}, Q_{299})</span> . None of these combinations lead to a small design since  <span class="math">Q_{293}</span>  and  <span class="math">Q_{299}</span>  are amongst the largest classes. Instead, we can do the decomposition by  <span class="math">Q_{294}</span>  in three stages. To this end, we first extracted all affine transformations  <span class="math">A_1</span> ,  <span class="math">A_2</span> , and  <span class="math">A_3</span>  in such a way that</p>

    <p class="text-gray-300"><span class="math-block">S^{-1} = A_3 \\circ C_{223} \\circ A_2 \\circ Q_{294} \\circ A_1</span> .</p>

    <p class="text-gray-300">There exist 2048 such  <span class="math">(A_1, A_2, A_3)</span>  triples<sup>4</sup>, and several solutions exist to decompose  <span class="math">\\mathcal{C}_{223}</span>  (see Appendix C). One of the smallest ones is  <span class="math">\\mathcal{C}_{223} = A_6 \\circ \\mathcal{Q}_{294} \\circ A_5 \\circ \\mathcal{Q}_{294} \\circ A_4</span> , and we found 262 144 affine triples  <span class="math">(A_4, A_5, A_6)</span>  for such a decomposition. At the last step, we combined these two decompositions as</p>

    <div class="my-4 text-center"><span class="math-block">S^{-1} = \\underbrace{A_3 \\circ A_6}_{A_{out}} \\circ \\mathcal{Q}_{294} \\circ \\underbrace{A_5}_{A_{m2}} \\circ \\mathcal{Q}_{294} \\circ \\underbrace{A_4 \\circ A_2}_{A_{m1}} \\circ \\mathcal{Q}_{294} \\circ \\underbrace{A_1}_{A_{in}}, \\tag{1}</span></div>

    <p class="text-gray-300">and examined all  <span class="math">2048 \\times 262\\,144</span>  cases<sup>5</sup>. With respect to the size of the resulting affines, we considered the number of 2-input XOR gates as well as the Hamming weight of the constants. The smallest combination has been achieved as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{llllllllllllllllllllllllllllllllllll</span></div>

    <p class="text-gray-300">In order to share  <span class="math">Q_{294}</span> : 0123456789BAEFDC as</p>

    <p class="text-gray-300"><span class="math-block">e = a + bd</span> ,  <span class="math">f = b + cd</span> ,  <span class="math">g = c</span> ,  <span class="math">h = d</span> ,</p>

    <p class="text-gray-300">we can follow the direct sharing [11], which has been applied in [38]. The component function  <span class="math">f_{\\mathcal{Q}_{294}}^{i,j}(\\langle a^i,b^i,c^i,d^i\\rangle,\\langle a^j,b^j,c^j,d^j\\rangle)=\\langle e,f,g,h\\rangle</span>  has been defined in [38] as</p>

    <p class="text-gray-300"><span class="math-block">e = a^{i} + b^{i}d^{i} + d^{i}b^{j} + b^{i}d^{j}</span>   <span class="math">g = c^{i}</span></p>

    <p class="text-gray-300"><span class="math-block">f = b^{i} + c^{i}d^{i} + d^{i}c^{j} + c^{i}d^{j}</span>   <span class="math">h = d^{i},</span>  (3)</p>

    <p class="text-gray-300">and it has been given that the three 4-bit output shares provided by  <span class="math">f_{\\mathcal{Q}_{294}}^{2,3}(.,.)</span> ,  <span class="math">f_{\\mathcal{Q}_{294}}^{3,1}(.,.)</span>  and  <span class="math">f_{\\mathcal{Q}_{294}}^{1,2}(.,.)</span>  make a uniform first-order sharing of  <span class="math">\\mathcal{Q}_{294}</span> .</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>4</sup> It is the same for  <span class="math">S^{-1} = A_3 \\circ Q_{294} \\circ A_2 \\circ C_{223} \\circ A_1</span> .</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{5}&lt;/sup&gt;</span>  The result is a multiset, i.e., with repeated elements.</p>

    <p class="text-gray-300"><img src="_page_8_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 5. Round-based first-order threshold implementation of PRINCE</p>

    <p class="text-gray-300">Since the affine functions applied on all shares do not change the uniformity, our construction – given in Equation (1) – in addition to the set of affines (Equation (2)) and component function  <span class="math">f_{\\mathcal{Q}_{294}}</span>  (Equation (3)) form a uniform first-order sharing of the PRINCE Sbox inverse. To the best of our knowledge, this is amongst the smallest construction which fulfills all the TI properties with n=m=3 shares. Note that the shared quadratic functions should be separated by registers to avoid the propagation of glitches.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.3 Implementation</h3>

    <p class="text-gray-300">Our construction of the first-order TI of PRINCE is depicted in Figure 5. All operations except key and constant additions (and the <strong>S-Layer</strong>) are repeated three times. It suffices if the constant of the affine functions A,  <span class="math">A_{in}</span> ,  <span class="math">A_{m1}</span> ,  <span class="math">A_{m2}</span> , and  <span class="math">A_{out}</span>  are applied on only one share<sup>6</sup>. The key and the constants are not shared, which is the same scenario applied in several works, e.g., [7–9, 37, 42], and is adequate to resist against first-order attacks. Hence, the keys and constant are also applied on only one share.</p>

    <p class="text-gray-300">Due to the registers integrated into the shared Sbox, the design realizes a pipeline with three stages. In other words, three consecutive (shared) inputs (plaintexts/ciphertexts) can be fed into the design, and after 40 clock cycles three outputs (ciphertexts/plaintexts) are consecutively given out. Thanks to the uniform sharing of the Sbox, excluding the masks required to share the input, the design does not require any fresh randomness during the computations. The performance figures of this design are also given in Table 1 for comparison purposes.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.4 Practical Evaluations</h4>

    <p class="text-gray-300">For the practical investigations – rather than ASIC-based experiments or simulation – we ported the designs to an FPGA-based platform. We have used a</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>6</sup> It does not affect either the functionality or the uniformity.</p>

    <p class="text-gray-300">SAKURA-X board [1] with a Kintex-7 FPGA, particularly designed for SCA evaluations. In order to monitor the power consumption, we measured the voltage drop over a shunt resistor placed at the Vdd path of the Kintex FPGA. The power traces have been collected by means of a digital LeCroy oscilloscope at the sampling rate of 500 MS/s. Because of the low amplitude of the measured signal (due to the underlying low-power technology of Xilinx 7 series FPGAs), we employed an AC amplifier ZFL-1000LN+ from Mini-Circuits with 10 dB gain.</p>

    <p class="text-gray-300">For SCA evaluation purposes, we applied the non-specific t-test (also known as fixed versus random t-test). This test procedure, originally called TVLA, has been proposed in [18], extended in [44] and [20, 21], and applied in e.g., [7, 8, 38]. The test – which compares the leakages associated to random inputs with that to a fixed input – can examine the existence of a detectable leakage, but cannot give any impression whether the leakage is exploitable. Hence, in case the t-test reports a first-order detectable leakage, we perform a signal-to-noise ratio (SNR) check. In such a check, the variance of the average leakage traces classified by e.g., the value of a plaintext nibble (divided by the variance of the noise) is examined [32]. It indeed can give an overview about the dependency of the average (first-order) leakages to the processed data. Here, we do not show any attack results, and only discuss about the existence of detectable leakages, and compare the amount of dependency of the leakages to the processed data.</p>

    <p class="text-gray-300">For the unrolled unprotected design, Figure 6 shows a sample power trace, the t-test result as well as the SNR over all 16 plaintext nibbles. Since the design is not masked, the t-test as expected shows a pretty strong first-order leakage. Along the same lines, the corresponding SNR exhibit a clear dependency between the traces and the plaintext nibbles. Hence, a successful key-recovery attack is expected (e.g., in [51]). We should here note that 23.3 mV power peak is relatively large<sup>7</sup> for this low-power FPGA. Since several gates are packed into one LUT, the equivalent design in ASIC can be more glitchy, and hence (probably) more energy consuming<sup>8</sup> . This may harden the development of fully unrolled (even low-latency) designs into low-energy, e.g., battery-powered, applications (see simulation-based results in [3] and [4]).</p>

    <p class="text-gray-300">We have shown the corresponding results of the unrolled TI design in Figure 7. As stated before, only the first and the last rounds are masked by means of four shares (see Figure 3). During the measurements, the 4-share input as well as other 3 independent fresh random masks (m1, m2, m<sup>3</sup> for the last round) are given to the Kintex-7 FPGA. The output is also provided in a 4-share masked form. As discussed before, since the middle rounds are not masked, we expected that the t-test exhibits first-order leakage. However, the SNR over plaintext nibbles shows a significant reduction, a factor of about 0.03, compared to the unrolled unprotected design (Figure 6(c) vs. Figure 7(c)). It indeed gives an impression that the first-order attacks on the first round are expect to be challenging. However, if the attacker fixes certain plaintext parts, he can target the second cipher round, which is not masked.</p>

    <p class="text-gray-300"><sup>7</sup> We showed real voltage values, i.e., output of the amplifier divided by 10.</p>

    <p class="text-gray-300"><sup>8</sup> This is a guess by the authors and should be examined in practice</p>

    <p class="text-gray-300"><img src="_page_10_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 8. Evaluation results, round-based TI design</p>

    <p class="text-gray-300"><strong>Table 1.</strong> Performance figures of different PRINCE implementations. For each design, the first and the second row represents the smallest and the fastest variant respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Design</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area<br>[GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Crit. Path [ns]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clock<br>#</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Latency [ns]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput<br>[Gbps]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DPA res.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Unrolled</td>

            <td class="px-3 py-2 border-b border-gray-700">8 512<br>17 675</td>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">13<br>9</td>

            <td class="px-3 py-2 border-b border-gray-700">4.923<br>7.111</td>

            <td class="px-3 py-2 border-b border-gray-700">23.3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Unrolled TI</td>

            <td class="px-3 py-2 border-b border-gray-700">48 012<br>77 921</td>

            <td class="px-3 py-2 border-b border-gray-700">38<br>13.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">38<br>13.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.684<br>4.848</td>

            <td class="px-3 py-2 border-b border-gray-700">59.5</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\sim^b</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Round-based [13]</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2809 \\\\ 4698</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">72.8<br>19.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.879<br>3.282</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">1.7^c</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Round-based ours</td>

            <td class="px-3 py-2 border-b border-gray-700">2 286<br>4 663</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">68.6<br>28</td>

            <td class="px-3 py-2 border-b border-gray-700">0.933<br>2.285</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">1.5^c</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Round-based TI</td>

            <td class="px-3 py-2 border-b border-gray-700">9 292<br>11 275</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">160<br>76</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">1.143^d</span> <span class="math">2.406^d</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2.3^{c} \\ 21^{e}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Round-based TI<br>Asynchronous<br>(simple Ack)</td>

            <td class="px-3 py-2 border-b border-gray-700">25 701<br>31 936</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">40 \\times 2^f</span></td>

            <td class="px-3 py-2 border-b border-gray-700">800</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">0.208^d</span> <span class="math">0.423^d</span></td>

            <td class="px-3 py-2 border-b border-gray-700">53.7</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Midori64<br>Round-based TI</td>

            <td class="px-3 py-2 border-b border-gray-700">7 297<br>9 237</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">124<br>58.9</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">1.000^{g}</span> <span class="math">2.105^{g}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">20.2^{e}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><b>√</b></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><sup>&</sup>lt;sup>a</sup> measured from the FPGA implementations</p>

    <p class="text-gray-300">Compared to these, the round-based TI design, whose results are depicted in Figure 8, exhibits no first-order leakage with 100 million traces confirming the correctness of our TI construction. We should here emphasize that the design was operating at a frequency of 6 MHz during the measurements, and we filled the 3-stage pipeline with the same data. In other words, this way we have reduced the algorithmic noise of the pipeline architecture (see [46]), that allows us to mitigate the side effects into the evaluations. As expected, the higher-order t-tests report detectable leakages through higher-order moments. Regardless of the difference in their SCA-resistance levels, the power peak of the round-based TI architecture is significantly smaller than that of the unrolled designs, i.e., 10 times and 30 times compared to the unprotected and the TI unrolled designs respectively.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>b</sup> only at the first and the last rounds</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^&lt;/sup&gt;c</span>  @  <span class="math">^c</span>  MHz</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{&lt;/sup&gt;d}</span>  considering the 3-stage pipeline</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>e</sup> by controlled ring-oscillator clock</p>

    <p class="text-gray-300">f doubled due to pre-charge/evaluation phases</p>

    <p class="text-gray-300">g considering the 2-stage pipeline</p>

    <h2 id="sec-11" class="text-2xl font-bold">4 Asynchronous Design</h2>

    <p class="text-gray-300">We have already discussed in Section 1 that low-latency concept is closely connected to the unrolled (single-cycle) architecture since the high clock rates (needed to rapidly run register-based designs) are not available or supported by many systems. For instance, in many FPGA designs clock rates above 200 MHz are often difficult to realize. In this settings, asynchronous circuits seem to be an alternative to this issue. With asynchronous circuit design, also known as self-timed and clock-less design, it is possible to realize circuits with high performance parameters in terms of their power, throughput, electromagnetic emissions, etc. [39,45]. Asynchronous design is not as well-established and widely-used as synchronous design methodology. Hence, the standard tools for asynchronous design are not available, or not widely known, or particularly customized for certain technologies.</p>

    <p class="text-gray-300">Because the field of asynchronous circuit design covers a wide range, we focus only on certain concepts which are relevant to our case studies. In terms of PRINCE, consider the round-based synchronous architecture in Figure 4(a). The maximum clock frequency is defined by the longest critical path (most likely when both Sbox and its inverse are active). However, such a path is not always active. In other words, in all clock cycles except the middle one the design can be clocked faster. If this design is realized by asynchronous design methodology, the end of the computation of one cipher round initiates the start of the next round. Hence, the design operates at its maximum speed, or let say with its lowest latency. In this case – similar to the unrolled architectures – the time when the computations are finished, i.e., the ciphertext is ready to be read, depends on the given inputs, but the maximum latency can be estimated.</p>

    <p class="text-gray-300">As shown in Section 3, the round-based TI design can provide the first-order resistance, but it needs a clock with a frequency between 250 MHz and 500 MHz to achieve the highest throughput (see Table 1). Hence, our objective in this section is to realize the round-based TI design with an asynchronous design methodology.</p>

    <p class="text-gray-300">State of the art. We should emphasize that the asynchronous design has been previously applied as a sole SCA countermeasure. One of the earlier works [33] describes a smartcard chip which relies on self-timed circuits to provide protection against physical attacks. The authors proposed to solely use dual-rail encoding to reduce the threat of data-dependent power consumption but also noted the obvious difficulties of this approach, e.g., varying wire lengths. Furthermore, they highlighted the problem of timing leakage of asynchronous circuits and advise to minimize data dependent gate delays coupled with the insertion of dummy delays to reduce this leakage. Later in [23] the security of a similar selftimed circuit has thoroughly been tested in practice. The authors found that small imbalances in the dual-rail circuits cause data-dependent leakage which enables an attacker to perform a successful DPA on the asynchronous circuit. They showed that their asynchronous design alone is not sufficient to prevent SCA attacks, and that these imbalances need to be eliminated during the design process to increase the level of security. This is in line with [30,53] where some of the difficulties, e.g., no global clock, with respect to performing DPA on asynchronous designs are described.</p>

    <p class="text-gray-300">One of the first clock-less implementation of AES was presented in [52]. It also relies on power-balancing capability of dual-rail and the absence of a global clock to thwart DPA. The dual-rail circuits were found to be more secure than the single-rail one, however this is only based on simulation results and a thorough practical evaluation is missing.</p>

    <p class="text-gray-300">Another approach to secure AES using clock-less circuits is presented in [14]. It again relies on an asynchronous style called quasi delay insensitive (QDI) which has a range of supply voltages. The authors noted the above-mentioned limitation of this implementation style with respect to SCA resistance [15]. Therefore, they proposed to lower the supply voltage to reduce the SNR and thwart DPA. However, [14] does not include practical experiments related to this approach. Further techniques [16, 17] have been proposed to harden QDI against DPA based on the introduction of random timing and path swapping. However, their efficiency was only evaluated using electrical simulations.</p>

    <p class="text-gray-300">More recently, an AES round function in Null Convention logic - another delay insensitive logic paradigm - has been proposed in [50] in which the SCA resistance has again been only evaluated with simulations.</p>

    <p class="text-gray-300">It should be noted that in a majority of the aforementioned articles SCA resistance was not the sole motivation for asynchronous circuits. Other beneficial properties include a low-power consumption for embedded devices and some form of an integrated fault tolerant scheme.</p>

    <p class="text-gray-300">What we want to examine here is not the application of asynchronous design to prevent SCA leakages. In short, we do not aim at e.g., realizing the round-based <strong>unprotected</strong> architecture with asynchronous methodology and examine its SCA resistance. Instead, our goal is to investigate the challenges and outcomes of implementing a correctly-masked design, e.g., round-based threshold implementation (Figure 5), under the concept of asynchronous designs. Such an investigation is conducted with the goal of achieving a clock-less design while it is expected to still satisfy the desired first-order SCA protection due to its underlying uniform TI construction.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">4.1 Fundamentals</h4>

    <p class="text-gray-300">Different parts of an asynchronous circuit need to communicate with each other. For example, the finish of one PRINCE round should initiate the next round. A couple of different handshaking protocols exist to establish such a communication.</p>

    <p class="text-gray-300">The 4-phase dual-rail protocol encodes the data signals into two wires per bit (see Figure 9). Each logical '1' or '0' is represented by  <span class="math">\\{1,0\\}</span>  or  <span class="math">\\{0,1\\}</span>  respectively, while  <span class="math">\\{0,0\\}</span>  is known as "no data" (or "empty") and  <span class="math">\\{1,1\\}</span>  as invalid. A transition from one valid coding to another is not allowed, unless an "empty" value is</p>

    <p class="text-gray-300"><img src="_page_14_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 9. A delay-insensitive 4-phase dual-rail protocol (taken from [45])</p>

    <p class="text-gray-300"><img src="_page_14_Figure_4.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 10. Exemplary circuits to generate the Ack and <em>clk</em> signals (a) and (b) for asynchronous designs, (c) for a synchronous design</p>

    <p class="text-gray-300">transmitted in-between, that forms a <em>return-to-zero</em> protocol. This protocol is very robust; two parties can communicate reliably regardless of delays in the wires, i.e., it is <em>delay-insensitive</em> [45].</p>

    <p class="text-gray-300">This concept is very similar to the WDDL logic style [48], which has been designed to mitigate SCA leakages. The underlying dual-rail pre-charge logic is the same encoding; the valid encodings  <span class="math">\\{0,1\\}</span>  and  <span class="math">\\{1,0\\}</span>  are known as evaluation phase and the empty value  <span class="math">\\{0,0\\}</span>  as pre-charge phase. A WDDL circuit is usually a synchronous design, where the evaluation/pre-charge phases are controlled by the clock signal (the same concept as in Figure 9 by replacing the Ack signal with clock). This protocol is familiar to most digital designers, and avoids any glitches in the circuit hence achieving a low-power construction. However, it has a disadvantage due to the extra return-to-zero transitions that cost time and energy.</p>

    <p class="text-gray-300">We can implement the combinatorial parts of a design based on the WDDL concept, and add extra logic to detect the end of the pre-charge as well as evaluation phase. This allows us to form the Ack signal (see Figure 9). As shown in Figure 10(a), we can integrate n 2-input NOR gates, each of which for a dual-rail signal, and by means of an n-input AND and an n-input NOR gate<sup>9</sup> we can generate  <span class="math">Ack_p</span>  and  <span class="math">Ack_e</span>  respectively. When all n dual-rail signals are in pre-charge phase (resp. in evaluation phase), it can be detected by observing  <span class="math">Ack_p</span></p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>9</sup> Such large gates are made by cascading the smaller gates.</p>

    <p class="text-gray-300">(resp. Acke). These two signals can drive an SR-latch to generate the desired Ack signal.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.2 Asynchronous Round-based TI</h3>

    <p class="text-gray-300">WDDL combinatorial circuits (generally asynchronous circuits) are glitch free, i.e., each dual-rail signal changes only once at each pre-charge/evaluation phase. Threshold implementation has been developed mainly for glitchy circuits, and the registers should be placed between the non-linear shared functions to avoid the propagation of the glitches [40]. Hence, at the first glance it seems that it is not essential anymore to instantiate such registers if the circuit is glitch free.</p>

    <p class="text-gray-300">Following this concept, we have implemented the round-based TI design presented in Figure 11, and did not integrate registers between the shared Q<sup>294</sup> functions. The state register is moved to the end of the round function, and the Ack signal is generated based on the state register input. By a couple of engineering tricks the design is mapped to our FPGA platform. We should here emphasize that Xilinx FPGAs are developed yet only for synchronous designs, and integration of asynchronous circuits is neither straightforward nor efficient. For example, each dual-rail WDDL gate should be implemented by a LUT [5].</p>

    <p class="text-gray-300">Our design is a self-timed circuit, i.e., it does not require an external clock, and once the reset signal goes LO, the circuit starts the first evaluation phase, which is the first PRINCE round. Controlled by the internally-generated Ack signal, the end of the evaluation phase triggers the state register to save the cipher state and simultaneously the start of the pre-charge phase. As stated before, a disadvantage of such a concept is its required interleaved pre-charge/evaluation phases. Because we avoided the extra registers within the Sbox, the design does not form a pipeline anymore. Therefore, a full PRINCE is performed by 14 (pre-charge, evaluation) cycles. Figure 12 shows a sample power trace of such a design, where the cipher rounds can be identified. However, the t-test indicates a pretty strong first-order leakage. Note that the design still realizes a uniform threshold implementation with 3 shares, and we have not used WDDL as an SCA countermeasure, rather as a 4-phase dual-rail protocol to enable detection of the end of the evaluation (and pre-charge) of the combinatorial circuit.</p>

    <p class="text-gray-300">A more careful investigation about the detected first-order leakage clarified that although the circuit is glitch free, the non-linear circuits are cascaded. One of the component functions of the second non-linear circuit (the second shared Q<sup>294</sup> in Figure 11) starts to evaluate when two output shares of the first non-linear circuit are both evaluated. Further, these two shares depend on all three shares of the Sbox input. Therefore, the start of the evaluation of the second non-linear circuit depends on all three input shares of the Sbox. This, which is a non-linear condition (i.e., when both two output shares of the first non-linear circuit are evaluated) is the reason for such a detectable first-order leakage (see [23] for a similar experience on an unmasked design). Although placing registers between the shared non-linear functions was initially introduced to avoid the propagation of glitches, it also synchronizes the start of their evaluation to be independent</p>

    <p class="text-gray-300"><img src="_page_16_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"> <span class="math">{\\bf Fig.\\,11.}\\ {\\bf Asynchronous\\ round-based\\ first-order\\ threshold\\ implementation\\ of\\ PRINCE</span></p>

    <p class="text-gray-300"><img src="_page_16_Figure_4.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"> <span class="math">{\\bf Fig.\\,12.}</span>  Evaluation results, asynchronous round-based TI design</p>

    <p class="text-gray-300">of the timing of the previous stage. As a result, the shared non-linear functions should also be isolated from each other even in asynchronous circuits.</p>

    <p class="text-gray-300">If we isolate the shared non-linear circuits by means of registers, and trigger the registers to store when all 3 shares are evaluated, again the time of triggering the registers as well as the circuit which generates the Ack signals (Figure 10(a)) depends on all 3 shares and leak through first-order moments. As a proof of concept, we have examined this issue by realizing the asynchronous round-based TI design with registers in the Sbox module where the combinatorial parts are made by WDDL gates. In this case, the Ack signals are generated by observing the input of all three registers, i.e., when the pre-charge/evaluation of the entire circuit – pipeline with 3 stages – is completed. The evaluation of this construction</p>

    <p class="text-gray-300"><img src="_page_17_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 13. Evaluation results, asynchronous round-based TI design with simple Ack</p>

    <p class="text-gray-300">has also showed detectable first-order leakage. So, we omit the corresponding results.</p>

    <p class="text-gray-300">As a side note, the early propagation effect [47] of WDDL aggravates this issue. In the above explained experiments we have used the noEE version [5] of WDDL (available only for FPGAs), that avoids early propagation only in evaluation phase. We have also made use of its successor, AWDDL [35] (also only for FPGAs) which avoids early propagation in both phases. Regardless of its double area requirements, its utilization in our case slightly reduced the first-order leakage, but could not avoid it due to the known imbalances between the delay of dual rails. In other words, the time required for full pre-charge/evaluation phase of non-linear circuits still depends on three shares and hence on unshared input.</p>

    <p class="text-gray-300">Therefore, the only solution which we could consider for a secure design is to simplify the Ack generator circuit. It means that if we generate the Ack signal based on only one share of one of the state registers, the start time of the next pre-charge/evaluation phase should be independent from the unshared values. However, such a circuit cannot guarantee that the pre-charge/evaluation of the other parts of the circuit are also finished. Therefore, we have found a path with the largest delay and connected the Ack generator circuit accordingly. To ensure the end of the pre-charge/evaluation of the other circuits, the generated Ack signal is delayed (see Figure 10(b)).</p>

    <p class="text-gray-300">A sample trace as well as the <em>t</em>-test results are shown in Figure 13, which confirms the prevention of first-order leakages. This construction is still a self-timed asynchronous circuit without external clock, but it is vastly customized. For instance, it does not operate at its maximum speed, and controlled mainly</p>

    <p class="text-gray-300"><img src="_page_18_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 14. Evaluation results, round-based TI design clocked by a controlled ring oscillator</p>

    <p class="text-gray-300">by a delayed periodic signal. Hence, we do not benefit from all the features of asynchronous methodology. If we ignore the low-power feature of this construction, it is not significantly different from the corresponding synchronous design with a high speed clock. As we listed in Table 1, the asynchronous design is much larger than its synchronous variant. Further, due to the interleaved (pre-charge, evaluation) phases, the latency of the asynchronous design is also not convincing.</p>

    <p class="text-gray-300">The interleaved (pre-charge, evaluation) phases of 4-phase dual-rail protocols (e.g., WDDL which we used here) doubles the latency of the design. Alternatively, one can utilize a 2-phase dual-rail protocol [45], where '1' and '0' values are encoded as signal transitions. Such protocols lead to faster but much more complex circuits. We have applied Level-Encoded Dual-Rail (LEDR) [19] concept and designed and evaluated the corresponding circuit, but due to the similarity of the results to that of the WDDL, their presentation is omitted. In short, the design was much bigger than its WDDL variant, but slightly faster. However, all issues with respect to isolation of non-linear functions as well as the Ack generator circuit hold true.</p>

    <p class="text-gray-300">In this situation, where the operation of non-linear circuits must be isolated and independent of other non-linear parts, we believe that the synchronous design is favorable. For the remaining issue, i.e., absence of a fast clock in many applications where low-latency cryptography is required, we suggest to generate such a clock by means of a ring oscillator. Since the energy consumption of large clock-trees (operated at a high frequency) is not desirable in many applications, the ring oscillator can be controlled by the start and end of e.g., the encryption module. A schematic view of an exemplary circuit is depicted in Figure 10(c). Obviously the ring oscillator should be adjusted based on the critical path delay of the circuit.</p>

    <p class="text-gray-300">We have practically evaluated such a construction as well, whose results are shown by Figure 14. As expected, higher power consumption peak compared to the same design operated at 6 MHz (see Figure 8(a)) is observed. However, the first-order leakage is still avoided, and more interestingly the higher-order leakages are mitigated (Figure 14 vs. Figure 8). The reason is due to the overlap between the adjacent power peaks, which leads to higher amount of noise, and consecutively harder higher-order leakages to detect, e.g., in [38].</p>

    <p class="text-gray-300">We have discussed and shown that SCA-protected designs (by means of masking) should involve registers even in case of asynchronous designs. Therefore, the low-latency concept – with a perspective of unrolled architectures – is in contradiction with masking in hardware. As a result, round-based architectures are the only possible solution for applications, where provably-secure SCA protection is required. In this scenario, in order to achieve a low latency two parameters play the most important role: i) the latency of each cipher round, and ii) the number of rounds.</p>

    <p class="text-gray-300">Obviously, the most challenging issue, which we faced, was uniform realization of the shared Sbox with 3 shares. In the seminal article [13], 8 different Sboxes (up to affine equivalent) are suggested for the PRINCE-family. However, all of them need at least a 3-stage decomposition to be able to uniformly shared with 3 shares. Such a decomposition, as shown in Section 3.3, leads to a pipeline round-based architecture with 3 stages. This – as stated above – increases the number of clock cycles required for each cipher round, and negatively affect the latency.</p>

    <p class="text-gray-300">For the future designs, our first suggestion is to select Sboxes, whose uniform sharing needs a low number of stages. The extreme case is to apply quadratic Sboxes, which can be shared in one stage, but such a choice leads to higher number of rounds (see PrintCipher [28]), which affect the low-latency target as well. Hence, the trade-off here is to select either a quadratic Sbox, which needs more number of rounds, or a cubic TI-friendly Sbox which forms a pipeline, hence more number of clock cycles per round.</p>

    <p class="text-gray-300">The second challenging issue was to deal with round constants. In case of PRINCE, the round constants have been selected from a semi-random source (fraction of π = 3.141 . . .). This design decision does not have any performance penalty in case of unrolled architecture, since a round constant just turns some XOR gates of the prior AddRoundKey to XNOR, i.e., for free<sup>10</sup>. However, for a round-based design, this leads to a relatively large combinatorial circuit since each round constant should be selected at each round based on the round</p>

    <p class="text-gray-300"><sup>10</sup> 2-input XOR and XNOR gates need the same area [43].</p>

    <p class="text-gray-300"><img src="_page_20_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 15. Round-based first-order threshold implementation of Midori64</p>

    <p class="text-gray-300">counter<sup>11</sup>. Hence, it is advisable to systematically generate the round constants, e.g., by means of an LFSR. Note that if a large LFSR is chosen, the area required to save its state (by registers) has also a negative impact on the area overhead.</p>

    <p class="text-gray-300">In case of PRINCE, due to its underlying  <span class="math">\\alpha</span> -reflection structure, encryption and decryption circuits are very similar. M'-Layer of PRINCE is self-inverse, and the Sbox is affine equivalent to its inverse, but it consists of two different round functions. Such a construction makes the round-based architecture (required for SCA protection) more complicated as both round functions need to be implemented (see Figure 4), which obviously increases the area requirements. Hence, it is preferred to have a design with a unique round function. In this case, achieving highly-similar encryption and decryption might be challenging.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">5.1 Comparison to Midori</h3>

    <p class="text-gray-300">The Midori cipher has been introduced in [3] with the main goal of reducing the energy consumption. Based on the simulation results and the discussions given in [3, 4], a round-based architecture is targeted to achieve the minimum energy consumption per bit. Further, it has been shown that the full latency of a round-based implementation of Midori outperforms that of other considered ciphers including PRINCE. Therefore, we considered Midori64 for comparison purposes<sup>12</sup>.</p>

    <p class="text-gray-300">Midori64 state is a 64-bit block, and its 4-bit Sbox (applied on all state nibbles) is an involution. Its linear layer includes an involutional MixColumn operation (made of a couple of XORs), and a ShiftCell which swaps the 4-bit cells of the state. It consists of 15 rounds, and respectively 15 round constants (each 16 bits) which are added to the LSB of the state nibbles. The 128-bit key is divided into two parts which are alternatively added to the sate at each round, and their XOR is used as a pre- and post-whitening key.</p>

    <p class="text-gray-300">Figure 15 shows a round-based implementation of Midori64, which supports both encryption and decryption. Note that the authors of [3] proposed to apply</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{11}&lt;/sup&gt;</span>  In our round-based designs, the selection of the round constant followed by 64-bit XOR need an area of 265 GE.</p>

    <p class="text-gray-300">We are aware of the weakness reported in [25], but to be compatible with PRINCE, i.e., 64-bit block size, we excluded Midori128 in our investigations.</p>

    <p class="text-gray-300"><img src="_page_21_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 16. Evaluation results, round-based TI design of Midori64 clocked by a controlled ring oscillator</p>

    <p class="text-gray-300">the inverse of the linear operations, i.e., ShiftCell−<sup>1</sup> ◦ MixColumn, over the round keys and round constants for the decryption. However, we found our solution (see Figure 15) which needs 64 extra 2-input XOR gates, cheaper than the original suggestion.</p>

    <p class="text-gray-300">In order to realize its threshold implementation, the linear layers are simply repeated over the 3 shares, and a uniform representation of its Sbox is constructed. The Midori64 Sbox is affine equivalent to C<sup>266</sup> class [11], which can be decomposed to two quadratic bijections with uniform TI. Amongst many possible solutions we selected Q<sup>12</sup> × Q<sup>12</sup> and found affine functions as</p>

    <div class="my-4 text-center"><span class="math-block">S = A_{out} \\circ \\mathcal{Q}_{12} \\circ A_m \\circ \\mathcal{Q}_{12} \\circ A_{in}.</span></div>

    <p class="text-gray-300">There exist 147 456 such (Ain, Am, Aout) triples, and we selected the following settings (with respect to the same criteria explained in Section 3.2):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{lll} A_{in}: {\\tt OA1B82934E5FC6D7}, \\ e=b, &amp; f=a, &amp; g=d, &amp; h=a+c, \\\\ A_m: {\\tt 84B70C3F95A61D2E}, \\ e=b+d, &amp; f=b, &amp; g=a, &amp; h=1+a+c, \\\\ A_{out}: {\\tt 8A02DF57CE469B13}, \\ e=c, &amp; f=a, &amp; g=c+d, &amp; h=1+b. \\end{array} \\tag{4}</span></div>

    <p class="text-gray-300">The sharing of Q<sup>12</sup> : 0123456789CDEFAB with</p>

    <p class="text-gray-300"><span class="math-block">e = a,</span>   <span class="math">f = b + bd + cd,</span>   <span class="math">g = c + bd,</span>   <span class="math">h = d</span></p>

    <p class="text-gray-300">can be derived by direct sharing [11]. If we define the component function f i,j Q12 (ha i , bi , c<sup>i</sup> , d<sup>i</sup> i,ha j , b<sup>j</sup> , c<sup>j</sup> , d<sup>j</sup> i) = he, f, g, hi as</p>

    <div class="my-4 text-center"><span class="math-block">e = a^{i}, g = b^{i}d^{i} + d^{i}b^{j} + b^{i}d^{j},</span></div>

    <div class="my-4 text-center"><span class="math-block">f = b^{i} + b^{i}d^{i} + d^{i}b^{j} + b^{i}d^{j} + c^{i}d^{i} + d^{i}c^{j} + c^{i}d^{j}, h = d^{i}, (5)</span></div>

    <p class="text-gray-300">we can form a uniform shared representation of Q<sup>12</sup> by f 2,3 Q12 (., .), f 3,1 Q12 (., .) and f 1,2 (., .), as shown in Figure 15.</p>

    <p class="text-gray-300">Q12 We have also practically examined its SCA resistance by the FPGA prototype. For comparison purposes we considered only a synchronous version, where the clock is provided by a controlled ring oscillator (with the same number of inverters as in the corresponding PRINCE design). The results (indicating firstorder resistance and stronger leakage through higher-order moments compared to its corresponding PRINCE) are shown in Figure 16, and the performance results are listed in Table 1.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">5.2 Conclusions</h4>

    <p class="text-gray-300">We have presented the results of an extensive study on application of masking, particularly TI, on PRINCE considering its low-latency goal. As given in Table 1, the asynchronous design is around 2.8 times larger and around 2.6 times slower than its synchronous variant. Further, an overview about its power consumption (FPGA prototype) shows no advantage, even compared to the case when the synchronous design operates at a high frequency<sup>13</sup>. More importantly, we faced several issues regarding its detectable first-order leakage. Finally, the design, which could prevent the leakages, was not much structurally different to a synchronous design, whose clock is internally generated.</p>

    <p class="text-gray-300">Based on Table 1, the fastest synchronous round-based TI needs 11 275 GE which is in the range of the unprotected unrolled design (8 512 - 17 675 GE). Although its critical path with 1.9 ns delay is around than 4 times shorter than that of the fastest unrolled design, its 40 clock cycle latency leads to 76 ns which is around 8 times more than 9 ns latency of the unrolled design. However, its underlying pipeline architecture compensates in terms of throughput to be between 2 and 3 times less than the unprotected unrolled designs.</p>

    <p class="text-gray-300">Compared to the synchronous round-based TI of PRINCE, Midori64 is smaller and achieves lower latency (58.9 ns vs. 76 ns for the fastest designs), but their throughput are comparable considering the full capacity of the pipelines. We should emphasize that most of the suggestions (given above) can be seen in the design of Midori: i) the Sbox is an involution and TI friendly, ii) MixColumn is an involution, iii) it consists of only one type of round function, and iv) the round constants are short (16 bits per round) although they cannot be generated systematically. However, with respect to [25] our observation is that: there is still</p>

    <p class="text-gray-300"><sup>13</sup> Note here the difference between power consumption of equivalent FPGA and ASIC circuits.</p>

    <p class="text-gray-300">a gap to fill, i.e., a low-latency cipher, which in addition to the desired cryptographic strength, can easily deal with the challenges addressed in this article. In short, the candidate should still achieve a low latency when fully unrolled as well as in a round-based fashion, and at the same time its masked (TI) round-based variant is efficient in terms of area and latency for the applications, where provably-secure SCA protection is required.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">Acknowledgment</h3>

    <p class="text-gray-300">The authors would like to acknowledge Ventzislav Nikov for his help with the decomposition process and Alexander Kühn for his help with implementation of different asynchronous variants of PRINCE on FPGA. The research in this work was supported in part by the DFG Research Training Group GRK 1817/1.</p>

    <p class="text-gray-300">To share the Sbox and its inverse with 4 shares, we represented the Sbox as  <span class="math">S=A_2\\circ\\mathcal{C}_{231}\\circ A_1</span>  and its inverse as  <span class="math">S^{-1}=A_4\\circ\\mathcal{C}_{231}\\circ A_3</span>  with  <span class="math">A_1:</span>  EF548932AB10CD76,  <span class="math">A_2:</span>  08192A3B4C5D6E7F,  <span class="math">A_3:</span>  92386DC7F45E0BA1,  <span class="math">A_4:</span>  51736240FBD9C8EA, and  <span class="math">\\mathcal{C}_{231}:</span>  0123468B59CEDA7F as</p>

    <div class="my-4 text-center"><span class="math-block">e = a + d + ac + ad + bd + abc + bcd</span></div>

    <p class="text-gray-300"> <span class="math">f = b + ac + bc + bd + abd</span>  <span class="math">g = c + d + bc + ad + cd + abd + bcd</span>  <span class="math">h = bc + ad + bd + cd + abd + acd + bcd</span> .</p>

    <p class="text-gray-300">By applying direct sharing on  <span class="math">C_{231}</span>  we reach the component function  <span class="math">f_{C_{231}}^{i,j,k}(\\langle a^i,b^i,c^i,d^i\\rangle,\\langle a^j,b^j,c^j,d^j\\rangle,\\langle a^k,b^k,c^k,d^k\\rangle) = \\langle e,f,g,h\\rangle</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} e = &amp; a^i + d^i + a^i c^i + a^i c^j + a^i c^k + a^j c^i + a^i d^i + a^i d^j + a^i d^k + a^j d^i + b^i d^i + b^i d^j + b^i d^k + b^j d^i + a^i b^i c^i + a^i b^j c^k + a^i b^k c^j + a^j b^i c^k + a^j b^k c^i + a^k b^i c^j + a^k b^j c^i + a^i b^i c^j + a^i b^i c^k + a^i b^k c^k + a^j b^j c^i + a^j b^i c^i + a^i b^j c^i + a^i b^k c^i + a^j b^i c^j + b^i c^i d^i + b^i c^j d^k + b^i c^k d^j + b^j c^i d^k + b^j c^k d^i + b^k c^i d^j + b^i c^i d^j + b^i c^j d^j + b^i c^i d^k + b^j c^j d^i + b^j c^i d^i + b^i c^j d^i + b^i c^k d^i + b^j c^i d^j \\end{split}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} f = &amp;b^i + a^i c^i + a^i c^j + a^i c^k + a^j c^i + b^i c^i + b^i c^j + b^i c^k + b^j c^i + b^i d^i + b^i d^j + b^i d^k + b^j d^i + a^i b^i d^i + a^i b^j d^k + a^i b^k d^j + a^j b^i d^k + a^j b^k d^i + a^k b^i d^j + a^i b^j d^i + a^i b^i d^j + a^i b^i d^k + a^i b^k d^k + a^j b^j d^i + a^j b^i d^i + a^i b^j d^i + a^j b^i d^j \\end{split}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} g = &amp;c^i + d^i + b^i c^i + b^i c^j + b^i c^k + b^j c^i + a^i d^i + a^i d^j + a^i d^k + a^j d^i + c^i d^i + c^i d^j + \\\\ &amp;c^i d^k + c^j d^i + a^i b^i d^i + a^i b^j d^k + a^i b^k d^j + a^j b^i d^k + a^j b^k d^i + a^k b^i d^j + \\\\ &amp;a^k b^j d^i + a^i b^i d^j + a^i b^j d^j + a^i b^i d^k + a^i b^k d^k + a^j b^j d^i + a^j b^i d^i + a^i b^j d^i + \\\\ &amp;a^i b^k d^i + a^j b^i d^j + b^i c^i d^i + b^i c^j d^k + b^i c^k d^j + b^j c^i d^k + b^j c^k d^i + b^k c^i d^j + \\\\ &amp;b^k c^j d^i + b^i c^i d^j + b^i c^j d^j + b^i c^i d^k + b^i c^k d^k + b^j c^j d^i + b^j c^i d^i + b^i c^j d^i + \\\\ &amp;b^i c^k d^i + b^j c^i d^j \\end{split}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} h = &amp;b^i c^i + b^i c^j + b^i c^k + b^j c^i + a^i d^i + a^i d^j + a^i d^k + a^j d^i + b^i d^i + b^i d^j + b^i d^k + b^j d^i + c^i d^i + c^i d^j + c^i d^k + c^j d^i + a^i b^i d^i + a^i b^j d^k + a^i b^k d^j + a^j b^i d^k + a^j b^k d^i + a^k b^i d^j + a^k b^j d^i + a^i b^i d^j + a^i b^j d^j + a^i b^i d^k + a^i b^k d^k + a^j b^j d^i + a^j b^i d^i + a^i b^j d^i + a^i b^j d^i + a^i b^j d^i + a^i b^j d^i + a^i b^j d^i + a^i b^j d^i + a^i b^j d^i + a^i c^j d^i + a^i c^j d^k + a^i c^k d^j + a^j c^i d^k + a^j c^i d^k + a^j c^i d^j + a^i c^i d^j + a^i c^j d^j + a^i c^i d^k + a^i c^k d^k + a^j c^j d^i + a^j c^i d^i + a^i c^j d^i + a^i c^j d^j + b^i c^j d^i + b^i c^j d^k + b^i c^k d^j + b^j c^i d^k + b^j c^i d^i + b^k c^i d^j + b^k c^j d^i + b^i c^i d^j + b^i c^j d^j + b^i c^i d^k + b^i c^k d^k + b^j c^j d^i + b^i c^i d^i + b^i c^j d^i + b^i c^k d^i + b^i c^k d^i + b^i c^k d^i + b^i c^k d^i + b^i c^i d^j + b^i c^i d^j + b^i c^i d^j + b^i c^i d^j + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^j + b^i c^i d^j + b^i c^i d^j + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^j + b^i c^i d^j + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b^i c^i d^i + b</span></div>

    <p class="text-gray-300">By implementing four instances of this component function  <span class="math">f_{\\mathcal{C}_{231}}^{2,3,4}(.,.,.)</span> ,  <span class="math">f_{\\mathcal{C}_{231}}^{3,4,1}(.,.,.)</span> ,  <span class="math">f_{\\mathcal{C}_{231}}^{4,1,2}(.,.,.)</span> , and  <span class="math">f_{\\mathcal{C}_{231}}^{1,2,3}(.,.,.)</span>  we reach a correct, non-complete, but non-uniform sharing of  <span class="math">\\mathcal{C}_{231}</span> . Note that the 64-bit masks  <span class="math">m_1, m_2</span> , and  <span class="math">m_3</span>  required to share the last input round are independent of the masks used to share the cipher input.</p>

    <p class="text-gray-300"><img src="_page_25_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 17. Detailed active parts of the original round-based architecture [13]</p>

    <p class="text-gray-300"><img src="_page_26_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"> <span class="math">{\\bf Fig.~18.~Detailed~active~parts~of~our~round-based~architecture}</span></p>

    <p class="text-gray-300">Q<sup>4</sup> × ×</p>

    <p class="text-gray-300">Table 2. All possible ways to decompose C<sup>231</sup> by selected quadratic bijections in three stages</p>

    <p class="text-gray-300">C<sup>231</sup> <sup>C</sup><sup>150</sup> <sup>C</sup><sup>151</sup> <sup>C</sup><sup>158</sup> <sup>C</sup><sup>159</sup> <sup>C</sup><sup>168</sup> <sup>C</sup><sup>171</sup> <sup>C</sup><sup>172</sup> <sup>C</sup><sup>214</sup> <sup>C</sup><sup>215</sup> <sup>C</sup><sup>223</sup> <sup>C</sup><sup>262</sup> <sup>C</sup><sup>266</sup> <sup>C</sup><sup>296</sup> <sup>C</sup><sup>297</sup></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">×</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q293</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q294</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q299</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| C150 :<br>Q12 × Q293  |                           |                       |   |           |   |                                                            |   |             |   |  |                         |   |   |            |             |</p>

    <p class="text-gray-300">| C151 :<br>Q293 × Q12  |                           |                       |   |           |   |                                                            |   |             |   |  |                         |   |   |            |             |</p>

    <p class="text-gray-300">| C158 :<br>Q299 × Q293 |                           |                       |   |           |   |                                                            |   |             |   |  |                         |   |   |            |             |</p>

    <p class="text-gray-300">| C159 :<br>Q293 × Q299 |                           |                       |   |           |   |                                                            |   |             |   |  |                         |   |   |            |             |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C168 :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q293 × Q293</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C172 :</td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q293<br>Q293 × Q294</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C214 :</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q4 × Q299</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q294</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q299</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q293 × Q4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q293 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q293 × Q294 Q293 × Q299 Q294 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q294 × Q294 Q294 × Q299</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C215 :</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q4 × Q293</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q293</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q294</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q294 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q294 × Q293</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q294 × Q294 Q299 × Q4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q299 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q299 × Q293 Q299 × Q294</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C223 :</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q299</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q293 × Q293 Q293 × Q294 Q294 × Q293 Q294 × Q294 Q299 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|                       |                           | Q299 × Q299           |   |           |   |                                                            |   |             |   |  |                         |   |   |            |             |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C262 :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q12 × Q299</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q294 × Q299 Q299 × Q12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q299 × Q294</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C296 :</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q12 × Q299</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q293 × Q293 Q294 × Q12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Q299 × Q294 Q299 × Q299</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|                       |                           |                       |   |           |   |                                                            |   |             |   |  |                         |   |   |            |             |</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Side-channel AttacK User Reference Architecture. http://satoh.cs.uec.ac.jp/ SAKURA/index.html.</li>

      <li>2. J. Balasch, B. Gierlichs, R. Verdult, L. Batina, and I. Verbauwhede. Power Analysis of Atmel CryptoMemory - Recovering Keys from Secure EEPROMs. In Topics in Cryptology - CT-RSA 2012, volume 7178 of Lecture Notes in Computer Science, pages 19–34. Springer, 2012.</li>

      <li>3. S. Banik, A. Bogdanov, T. Isobe, K. Shibutani, H. Hiwatari, T. Akishita, and F. Regazzoni. Midori: A Block Cipher for Low Energy. In ASIACRYPT 2015, volume 9453 of Lecture Notes in Computer Science, pages 411–436. Springer, 2015.</li>

      <li>4. S. Banik, A. Bogdanov, and F. Regazzoni. Exploring Energy Efficiency of Lightweight Block Ciphers. In SAC 2015, volume 9566 of Lecture Notes in Computer Science, pages 178–194. Springer, 2016.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5. S. Bhasin, S. Guilley, F. Flament, N. Selmane, and J. Danger. Countering early evaluation: an approach towards robust dual-rail precharge logic. In Workshop on Embedded Systems Security - WESS 2010, page 6. ACM, 2010.</li>

      <li>6. S. Bhasin, S. Guilley, L. Sauvage, and J. Danger. Unrolling Cryptographic Circuits: A Simple Countermeasure Against Side-Channel Attacks. In CT-RSA 2010, volume 5985 of Lecture Notes in Computer Science, pages 195–207. Springer, 2010.</li>

      <li>7. B. Bilgin, B. Gierlichs, S. Nikova, V. Nikov, and V. Rijmen. A More Efficient AES Threshold Implementation. In Progress in Cryptology - AFRICACRYPT 2014, volume 8469 of Lecture Notes in Computer Science, pages 267–284. Springer, 2014.</li>

      <li>8. B. Bilgin, B. Gierlichs, S. Nikova, V. Nikov, and V. Rijmen. Higher-Order Threshold Implementations. In Advances in Cryptology - ASIACRYPT 2014, Part II, volume 8874 of Lecture Notes in Computer Science, pages 326–343. Springer, 2014.</li>

      <li>9. B. Bilgin, B. Gierlichs, S. Nikova, V. Nikov, and V. Rijmen. Trade-Offs for Threshold Implementations Illustrated on AES. IEEE Trans. on CAD of Integrated Circuits and Systems, 34(7):1188–1200, 2015.</li>

      <li>10. B. Bilgin, S. Nikova, V. Nikov, V. Rijmen, and G. St¨utz. Threshold Implementations of All 3×3 and 4×4 S-Boxes. In Cryptographic Hardware and Embedded Systems - CHES 2012, volume 7428 of Lecture Notes in Computer Science, pages 76–91. Springer, 2012.</li>

      <li>11. B. Bilgin, S. Nikova, V. Nikov, V. Rijmen, N. Tokareva, and V. Vitkup. Threshold implementations of small S-boxes. Cryptography and Communications, 7(1):3–33, 2015.</li>

      <li>12. A. Bogdanov, L. R. Knudsen, G. Leander, C. Paar, A. Poschmann, M. J. B. Robshaw, Y. Seurin, and C. Vikkelsoe. PRESENT: An Ultra-Lightweight Block Cipher. In Cryptographic Hardware and Embedded Systems - CHES 2007, volume 4727 of Lecture Notes in Computer Science, pages 450–466. Springer, 2007.</li>

      <li>13. J. Borghoff, A. Canteaut, T. G¨uneysu, E. B. Kavun, M. Knezevic, L. R. Knudsen, G. Leander, V. Nikov, C. Paar, C. Rechberger, P. Rombouts, S. S. Thomsen, and T. Yal¸cin. PRINCE - A Low-Latency Block Cipher for Pervasive Computing Applications - Extended Abstract. In ASIACRYPT 2012, volume 7658 of Lecture Notes in Computer Science, pages 208–225. Springer, 2012.</li>

      <li>14. G. Bouesse, M. Renaudin, A. Witon, and F. Germain. A clock-less low-voltage aes crypto-processor. In Solid-State Circuits Conference, 2005. ESSCIRC 2005. Proceedings of the 31st European, pages 403–406. IEEE, 2005.</li>

      <li>15. G. F. Bouesse, M. Renaudin, S. Dumont, and F. Germain. DPA on quasi delay insensitive asynchronous circuits: Formalization and improvement. In DATE, pages 424–429. IEEE Computer Society, 2005.</li>

      <li>16. G. F. Bouesse, M. Renaudin, and G. Sicard. Improving DPA resistance of quasi delay insensitive circuits using randomly time-shifted acknowledgment signals. In VLSI-SoC, volume 240 of IFIP, pages 11–24. Springer, 2005.</li>

      <li>17. G. F. Bouesse, G. Sicard, and M. Renaudin. Path swapping method to improve DPA resistance of quasi delay insensitive asynchronous circuits. In CHES, volume 4249 of Lecture Notes in Computer Science, pages 384–398. Springer, 2006.</li>

      <li>18. J. Cooper, E. Demulder, G. Goodwill, J. Jaffe, G. Kenworthy, and P. Rohatgi. Test Vector Leakage Assessment (TVLA) Methodology in Practice. International Cryptographic Module Conference, 2013.</li>

      <li>19. M. E. Dean, T. E. Williams, and D. L. Dill. Efficient self-timing with level-encoded 2-phase dual-rail (ledr). In Conference on Advanced Research in VLSI, pages 55– 70. MIT Press, 1991.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>20. A. A. Ding, C. Chen, and T. Eisenbarth. Simpler, Faster, and More Robust T-Test Based Leakage Detection. In COSADE 2016, volume 9689 of Lecture Notes in Computer Science, pages 163–183. Springer, 2016.</li>

      <li>21. F. Durvaux, F. Standaert, and S. M. D. Pozo. Towards Easy Leakage Certification. In CHES 2016, volume 9813 of Lecture Notes in Computer Science, pages 40–60. Springer, 2016.</li>

      <li>22. T. Eisenbarth, T. Kasper, A. Moradi, C. Paar, M. Salmasizadeh, and M. T. M. Shalmani. On the Power of Power Analysis in the Real World: A Complete Break of the KeeLoqCode Hopping Scheme. In Advances in Cryptology - CRYPTO 2008, volume 5157 of Lecture Notes in Computer Science, pages 203–220. Springer, 2008.</li>

      <li>23. J. J. A. Fournier, S. W. Moore, H. Li, R. D. Mullins, and G. S. Taylor. Security evaluation of asynchronous circuits. In CHES, volume 2779 of Lecture Notes in Computer Science, pages 137–151. Springer, 2003.</li>

      <li>24. G. Goodwill, B. Jun, J. Jaffe, and P. Rohatgi. A testing methodology for side channel resistance validation. In NIST non-invasive attack testing workshop, 2011. http://csrc.nist.gov/news\\_events/ non-invasive-attack-testing-workshop/papers/08\\_Goodwill.pdf.</li>

      <li>25. J. Guo, J. Jean, I. Nikoli´c, K. Qiao, Y. Sasaki, and S. M. Sim. Invariant Subspace Attack Against Full Midori64. Cryptology ePrint Archive, Report 2015/1189, 2015. http://eprint.iacr.org/.</li>

      <li>26. J. Kilian and P. Rogaway. How to Protect DES Against Exhaustive Key Search. In CRYPTO 1996, volume 1109 of Lecture Notes in Computer Science, pages 252–267. Springer, 1996.</li>

      <li>27. M. Knezevic, V. Nikov, and P. Rombouts. Low-Latency Encryption Is "Lightweight = Light + Wait"? In CHES 2012, volume 7428 of Lecture Notes in Computer Science, pages 426–446. Springer, 2012.</li>

      <li>28. L. R. Knudsen, G. Leander, A. Poschmann, and M. J. B. Robshaw. PRINTcipher: A Block Cipher for IC-Printing. In CHES 2010, volume 6225 of Lecture Notes in Computer Science, pages 16–32. Springer, 2010.</li>

      <li>29. P. C. Kocher, J. Jaffe, and B. Jun. Differential Power Analysis. In CRYPTO 1999, volume 1666 of Lecture Notes in Computer Science, pages 388–397. Springer, 1999.</li>

      <li>30. K. J. Kulikowski, M. Su, A. B. Smirnov, A. Taubin, M. G. Karpovsky, and D. Mac-Donald. Delay insensitive encoding and power analysis: A balancing act. In ASYNC, pages 116–125. IEEE Computer Society, 2005.</li>

      <li>31. J. Liu, Y. Yu, F. Standaert, Z. Guo, D. Gu, W. Sun, Y. Ge, and X. Xie. Small Tweaks Do Not Help: Differential Power Analysis of MILENAGE Implementations in 3G/4G USIM Cards. In ESORICS 2015, volume 9326 of Lecture Notes in Computer Science, pages 468–480. Springer, 2015.</li>

      <li>32. S. Mangard, E. Oswald, and T. Popp. Power Analysis Attacks: Revealing the Secrets of Smart Cards. Springer, 2007.</li>

      <li>33. S. W. Moore, R. D. Mullins, P. A. Cunningham, R. J. Anderson, and G. S. Taylor. Improving smart card security using self-timed circuits. In ASYNC, pages 211–218. IEEE Computer Society, 2002.</li>

      <li>34. A. Moradi, A. Barenghi, T. Kasper, and C. Paar. On the vulnerability of FPGA bitstream encryption against power analysis attacks: extracting keys from xilinx Virtex-II FPGAs. In ACM Conference on Computer and Communications Security - CCS 2011, pages 111–124. ACM, 2011.</li>

      <li>35. A. Moradi and V. Immler. Early Propagation and Imbalanced Routing, How to Diminish in FPGAs. In CHES 2014, volume 5984 of Lecture Notes in Computer Science, pages 598–615. Springer, 2014.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>36. A. Moradi, O. Mischke, and C. Paar. Practical evaluation of DPA countermeasures on reconfigurable hardware. In HOST 2011, pages 154–160. IEEE, 2011.</li>

      <li>37. A. Moradi, A. Poschmann, S. Ling, C. Paar, and H. Wang. Pushing the Limits: A Very Compact and a Threshold Implementation of AES. In Advances in Cryptology - EUROCRYPT 2011, volume 6632 of Lecture Notes in Computer Science, pages 69–88. Springer, 2011.</li>

      <li>38. A. Moradi and A. Wild. Assessment of Hiding the Higher-Order Leakages in Hardware - What Are the Achievements Versus Overheads? In CHES 2015, volume 9293 of Lecture Notes in Computer Science, pages 453–474. Springer, 2015.</li>

      <li>39. C. J. Myers. Asynchronous Circuit Design. Wiley, 2001.</li>

      <li>40. S. Nikova, V. Rijmen, and M. Schl¨affer. Secure Hardware Implementation of Nonlinear Functions in the Presence of Glitches. J. Cryptology, 24(2):292–321, 2011.</li>

      <li>41. D. Oswald and C. Paar. Breaking Mifare DESFire MF3ICD40: Power Analysis and Templates in the Real World. In CHES 2011, volume 6917 of Lecture Notes in Computer Science, pages 207–222. Springer, 2011.</li>

      <li>42. A. Poschmann, A. Moradi, K. Khoo, C. Lim, H. Wang, and S. Ling. Side-Channel Resistant Crypto for Less than 2, 300 GE. J. Cryptology, 24(2):322–345, 2011.</li>

      <li>43. A. Y. Poschmann. Lightweight Cryptography: Cryptographic Engineering for a Pervasive World. PhD thesis, Ruhr University Bochum, 2009.</li>

      <li>44. T. Schneider and A. Moradi. Leakage Assessment Methodology A Clear Roadmap for Side-Channel Evaluations. In CHES, volume 9293 of Lecture Notes in Computer Science, pages 495–513. Springer, 2015.</li>

      <li>45. J. Spars and S. Furber. Principles of Asynchronous Circuit Design: A Systems Perspective. Springer Publishing Company, Incorporated, 1st edition, 2010.</li>

      <li>46. F. Standaert, S. B. Ors, and B. Preneel. Power Analysis of an FPGA: Implemen- ¨ tation of Rijndael: Is Pipelining a DPA Countermeasure? In CHES 2004, volume 3156 of Lecture Notes in Computer Science, pages 30–44. Springer, 2004.</li>

      <li>47. D. Suzuki and M. Saeki. Security Evaluation of DPA Countermeasures Using Dual-Rail Pre-charge Logic Style. In Cryptographic Hardware and Embedded Systems - CHES 2006, volume 4249 of Lecture Notes in Computer Science, pages 255–269. Springer, 2006.</li>

      <li>48. K. Tiri and I. Verbauwhede. A Logic Level Design Methodology for a Secure DPA Resistant ASIC or FPGA Implementation. In Design, Automation and Test in Europe - DATE 2004, pages 246–251. IEEE Computer Society, 2004.</li>

      <li>49. Virtual Silicon Inc. 0.18 µm VIP Standard Cell Library Tape Out Ready, Part Number: UMCL18G212T3, Process: UMC Logic 0.18 µm Generic II Technology: 0.18µm, July 2004.</li>

      <li>50. J. Wu, Y. Kim, and M. Choi. Low-power side-channel attack-resistant asynchronous s-box design for AES cryptosystems. In ACM Great Lakes Symposium on VLSI, pages 459–464. ACM, 2010.</li>

      <li>51. V. Yli-M¨ayry, N. Homma, and T. Aoki. Improved Power Analysis on Unrolled Architecture and Its Application to PRINCE Block Cipher. In LightSec 2015, volume 9542 of Lecture Notes in Computer Science, pages 148–163. Springer, 2016.</li>

      <li>52. A. Yu and D. S. Br´ee. A clock-less implementation of the AES resists to power and timing attacks. In ITCC (2), pages 525–532. IEEE Computer Society, 2004.</li>

      <li>53. Z. C. Yu, S. B. Furber, and L. A. Plana. An investigation into the security of self-timed circuits. In ASYNC, pages 206–215. IEEE Computer Society, 2003.</li>

      <li>54. Y. Zhou, Y. Yu, F. Standaert, and J. Quisquater. On the Need of Physical Security for Small Embedded Devices: A Case Study with COMP128-1 Implementations in SIM Cards. In Financial Cryptography and Data Security - FC 2013, volume 7859 of Lecture Notes in Computer Science, pages 230–238. Springer, 2013.</li>

    </ul>`;
---

<BaseLayout title="Side-Channel Analysis Protection and Low-Latency in Action -... (2016/481)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/481
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="side-channel-analysis-protection-and-low-latency-in-action-2016" />
  </article>
</BaseLayout>
