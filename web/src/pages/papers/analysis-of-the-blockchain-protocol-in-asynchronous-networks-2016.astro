---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/454';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'Analysis of the Blockchain Protocol in Asynchronous Networks';
const AUTHORS_HTML = 'Rafael Pass, Lior Seeman, abhi shelat';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Nakamoto&#x27;s famous blockchain protocol enables achieving consensus in a so-called \\emph{permissionless setting}---anyone can join (or leave) the protocol execution, and the protocol instructions do not depend on the identities of the players.
His ingenious protocol prevents \`\`sybil attacks&#x27;&#x27; (where an adversary spawns any number of new players) by relying on computational puzzles (a.k.a. \`\`moderately hard functions&#x27;&#x27;) introduced by Dwork and Naor (Crypto&#x27;92).

The analysis of the blockchain consensus protocol (a.k.a. Nakamoto consensus) has been a notoriously difficult task. Prior works that analyze it either make the simplifying assumption that network channels are fully synchronous (i.e. messages are instantly delivered without delays) (Garay et al, Eurocrypt&#x27;15) or only consider specific attacks (Nakamoto&#x27;08; Sampolinsky and Zohar, FinancialCrypt&#x27;15); additionally, as far as we know, none of them deal with players joining or leaving the protocol.

In this work we prove that the blockchain consensus mechanism satisfies a strong forms of *consistency* and *liveness* in an asynchronous network with adversarial delays that are a-priori bounded, within a formal model allowing for adaptive corruption and spawning of new players, assuming that the computational puzzle is modeled as a random oracle. (We complement this result by showing a simple attack against the blockchain protocol in a fully asynchronous setting, showing that the &ldquo;puzzle-hardness&rdquo; needs to be appropriately set as a function of the maximum network delay; this attack applies even for static corruption.)

As an independent contribution, we define an abstract notion of a blockchain protocol and identify appropriate security properties of such protocols; we prove that Nakamoto&#x27;s blockchain protocol satisfies them and that these properties are sufficient for typical applications; we hope that this abstraction may simplify further applications of blockchains.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> blockchain &middot; Nakamoto consensus</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Distributed systems have been historically analyzed in a closed setting in which both the number of participants in the system, as well as their identities, are common knowledge. A departure from this model started with the design of peer-to-peer systems, e.g. with systems such as Napster and Gnutella for file sharing. The success of those systems led to academically designed systems such as Freenet [CSWH00], CAN [RFH+00], Chord [SMK+01], and Pastry [DR01] which offered redundant file storage, distributed hashing, selection of nearby servers, and hierarchical naming.</p>

    <p class="text-gray-300">A novel aspect of these peer systems is that they are permissionless&mdash; anyone can join (or leave) the protocol execution (without getting permission from a centralized or distributed authority), and the protocol instructions do not depend on the identities of the players. As participants may continuously join and leave the system, successful permissionless systems require a fault-tolerant design. Unfortunately, the mentioned systems, while &quot;robust&quot; with respect to measures such as connectivity [DLN02], were not designed to tolerate against adversarial behavior. For example, there were no guarantee that one participant's experience with the system was consistent with another's: Two participants requesting the same file may end up receiving different versions and never know that they did. At first sight one may think that using standard consensus/Byzantine agreement methods (e.g., [CL99, MA05, Lam10, Lam11]) could help overcome this issue. The problem is that such protocols require that a large fraction of the participating players are honest, but in the permissionless setting an attacker can trivially mount a so-called &quot;sybil attack&quot;&mdash;it simply spawns lots of players (that it controls) and can thus easily ensure that it controls a majority of all the players. Indeed, Barak et al [BCL+05] proved that this is a fundemental problem with the permissionless model.</p>

    <p class="text-gray-300">Nakamoto's Blockchain In 2008, Nakamoto [Nak08] proposed his celebrated &quot;blockchain protocol&quot; which overcomes the above-mentioned problems by relying on the idea of computational puzzles&mdash;a.k.a. moderately hard functions or proofs of work&mdash;put forth by Dwork and Naor [DN92]. Rather than attempting to provide robustness whenever the majority of the participants are honest (since participants can be easily spawned in the permissionless setting), it attempts to provide robustness as long as a majority of the computing power is held by honest participants. It explicitly claims consistency properties that are strong enough to support a financial transaction system; indeed, the first application of a blockchain is the Bitcoin digital currency which needs strong properties to prevent fraud and double-spending attacks. A number of follow-up digital currencies [Lit], micro-payment schemes [PS15, PD15], time-stamping [BTP], naming [Nam], fair secure computation [BK14] and secure messaging and PKI applications [FVY14] are based on the blockchain idea. Additionally, financial firms have announced intentions of using the blockchain to lower transaction costs, remove geopolitical barriers to transferring assets, and reconcile differences between systems.</p>

    <p class="text-gray-300">The core blockchain protocol (a.k.a. &quot;Nakamoto consensus&quot;, or the &quot;Bare-bones blockchain protocol&quot;), roughly speaking, is a method for maintaining a public, immutable and ordered ledger of records (for instance, in the bitcoin application, these records are simply transactions); that is, records can be added to the end of the ledger at any time (but only to the end of it); additionally, we are guaranteed that records previously added cannot be removed or reordered and that all honest users have a consistent view of the ledger. While standard consensus/Byzantine agreement mechanisms could be used to achieve such an immutable ordered sequence of records, the amazing aspect of Nakamoto's consensus mechanism is that it functions in a fully permissionless setting.</p>

    <p class="text-gray-300">Roughly speaking, in his protocol each participant maintains its own local &quot;chain&quot; of &quot;blocks&quot; of records/messages&mdash;called the blockchain. Each block consist of a triple (h&minus;1, &eta;, m) where h&minus;<sup>1</sup> is a pointer to the previous block in chain, m is the record component of the block, and &eta; is a &quot;proof-of-work&quot;&mdash;a solution to a computational puzzle that is derived from the pair (h&minus;1, m). The</p>

    <p class="text-gray-300">proof of work can be thought of as a &quot;key-less digital signature&quot; on the whole blockchain up until this point.</p>

    <p class="text-gray-300">Concretely, Nakamoto's protocol is parametrized by a parameter p&mdash;which we refer to as the mining hardness parameter, and a proof-of-work is deemed valid if &eta; is a string such that H(h&minus;1, &eta;, m) &lt; Dp, where H is a hash function (modeled as a random oracle) and D<sup>p</sup> is set so that the probability that an input satisfies the relation is less than p. (In practice, the hardness parameter p is adaptively modified through some external process to incorporate an estimate of the number of participants in the system and the network delays; we shall return to the choice of p later.) At any point of the protocol execution, each participant attempts to increase the length of its own chain by &quot;mining&quot; for a new block: upon receiving some record m, it picks a random &eta; and checks whether &eta; is a valid proof of work w.r.t. m and h&minus;1, where h&minus;<sup>1</sup> is a pointer to the last block of its current chain; if so, it extends is own local chain and broadcast it to the all the other participants (the broadcast takes places through some gossip protocol, which we do not discuss here). Whenever a participant receives a chain that is longer than its own local chain, it replaces its own chain with the longer one.</p>

    <p class="text-gray-300">The fundamental question with such an approach is whether honest participants eventually end up with the same longest chain of blocks, and thus, the same ordered list of records, or whether the system devolves into a state where participants have inconsistent local chains.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Does Nakamoto's Protocol Achieve Consistency?</h3>

    <p class="text-gray-300">Requiring that all participant agree on the whole chain is a too strong consistency requirement if the protocol is executed on a network with message delays (as Nakamoto's protocol is intended to be)&mdash;for instance, some players may have received the &quot;last block&quot; whereas other have not. Rather, as discussed by Nakamoto [Nak08], the appropriate notion of consistency for the blockchain&mdash;which we refer to as T-consistency&mdash;should require that honest players agree on the current chain, except for potentially a small number, T, of &quot;unconfirmed&quot; blocks at the end of the chain. If we can show this property holds except with exponentially small probability in T, honest parties are guaranteed that for a sufficiently large choice of T (except with tiny probability), &quot;confirmed&quot; blocks will never be lost from the chain (which is what is needed for all the above-mentioned applications; for instance, for the case of bitcoin, it ensures that players cannot double-spend money).</p>

    <p class="text-gray-300">Nakamoto provides an initial analysis of consistency assuming that the adversary only mounts a particular attack strategy (namely, an attacker tries to generate a chain faster than the honest players); for instance, his analysis does not consider more sophisticated attack strategies where the adversary may attempt to &quot;split the players&quot; and have them work on different chains.</p>

    <p class="text-gray-300">A beautiful recent work by Garay, Kiayas and Leonardos [GKL15] provides a more formal model for studying Nakamoto's blockchain protocol; their analysis, however, only considers a synchronous network with a rushing adversary&mdash;that is, messages sent in a particular round arrive in the next round without any delays, but the adversary gets to see all messages sent by honest parties before having to send its own message. In this model, they demonstrate that the blockchain protocol satisfies consistency (under appropriate assumptions on the mining hardness and the relative computational power held by the attacker), in a setting with a fixed number of players (but the protocol is not aware of the exact number of players).</p>

    <p class="text-gray-300">Assuming a synchronous network, however, is a very strong, possibly unrealistic assumption; indeed, Nakamoto's protocol is explicitly designed to work in a network with message delays, and indeed is executed on such a network (i.e., the Internet).</p>

    <p class="text-gray-300">The Power of Network Delays Consequently, we are here interested in analyzing to what extent the blockchain protocol satisfies consistency in the more realistic setting of an asynchronous network, where an adversary controls the scheduling/delivery of messages between honest parties. As we observe (and formally prove in Theorem 8.1), in a fully asynchronous setting, where an adversary can arbitrarily delay messages, consistency cannot be satisfied: an adversary controlling a small percentage of the computational power can simply delay messages from honest parties for sufficiently long to ensure that the adversary can come up with its own chain (containing any set of records it desires) which is longer than the chain held by all honest players, and consequently it can make the honest players switch to the adversarial chain at any point. In fact, our attack works even in the setting of partial synchrony (see e.g. [DLS88]) where there is an a-priori bound  <span class="math">\\Delta</span>  on the network latency (that is, the adversary may arbitrary delay messages as long as it delivers them within time  <span class="math">\\Delta</span> ), as long as the mining hardness parameter p exceeds  <span class="math">\\frac{1}{pn\\Delta}</span> , where  <span class="math">\\rho</span>  is the fraction of the computational power held by the adversary and p is the number of players (and p is the mining-hardness parameter in Nakamoto's protocol). Indeed, Decker and Wattenhofer [DW13] already experimentally observed that increasing the networks delays in Nakamoto's protocol leads to increased forks, and they noted (through heuristic calculations) that an attacker could use these delays to violate consistency with an attack that requires less than 50% of the mining power.</p>

    <p class="text-gray-300">Motivated by the work by Decker and Wattenhofer, an elegant work by Sompolinsky and Zohar [SZ15] provides some initial analysis of the blockchain protocol even in a network with (bounded) delays. They show how to extend Nakamoto's analysis to deal with (bounded) delays, but again (just like Nakamoto) they only consider particular attack strategies&mdash;e.g., they do not consider &quot;block-withholding (or &quot;pre-mining&quot;) attacks&quot; where the attacker withholds blocks for later use [mtg10, ES14]; furthermore, their analysis only shows that consistency holds in the limit (when T goes to infinity), and consequently their bounds (even for the restricted attacker setting) are not useful for applications.</p>

    <p class="text-gray-300">This leaves open the question of providing an analysis of Nakamoto's blockchain protocol or in fact any consensus protocol in the permissionless setting&mdash;with respect to arbitrary attack strategies in networks with  <span class="math">\\Delta</span> -bounded delays.</p>

    <p class="text-gray-300">Does Nakamoto's blockchain protocol satisfy consistency when executed in asynchronous networks with  <span class="math">\\Delta</span> -bounded delays?</p>

    <p class="text-gray-300">As mentioned above, Garay et al [GKL15] provide a positive answer for the special case when  <span class="math">\\Delta=1</span>  (i.e., messages are delivered in the next time step<sup>1</sup>), and Sampolinsky and Zohar [SZ15] show that certain (natural, but restricted) strategies cannot be employed to break consistency of Nakamoto's protocol (in the limit) in  <span class="math">\\Delta</span> -bounded delay networks.</p>

    <p class="text-gray-300">Let us highlight why dealing with network delays in the &quot;proof-of-work&quot; setting (where we assume that a majority of the computing power is honest) is significantly more challenging than in the &quot;standard&quot; permissioned setting: In the standard model, any synchronous protocol can be turned into a protocol that is secure also in  <span class="math">\\Delta</span> -delay networks by simply requiring all honest players to always &quot;wait&quot; (without doing anything) for  <span class="math">\\Delta</span>  time steps before responding to any message, effectively emulating synchronous rounds. This approach completely fails in the proof-of-work setting&mdash;the adversary can now increase its computational resources by a factor  <span class="math">\\Delta</span>  (since it can try to solve puzzle when the honest players are &quot;waiting&quot;).</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Main Results</h3>

    <p class="text-gray-300">In this paper, we resolve the above-mentioned problem and demonstrate that (assuming puzzles are modeled as random oracles) Nakamoto's protocol satisfies consistency (under appropriate assumptions on the mining hardness and the relative computational power held by the attacker) also</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup>Alternatively, one way to interpret the result of Garay et al, is that it shows consistency of Nakamoto's protocol also with  <span class="math">\\Delta</span>  delays, but with a <em>particular delay structure</em> where time is divided into intervals of length  <span class="math">\\Delta</span> , and any message sent within an interval is delayed to the end of it.</p>

    <p class="text-gray-300">in networks with message delays. We emphasize that our analysis is not just a combination of the techniques/ideas from [GKL15] and [SZ15]&mdash;in fact, the bulk of our proof consists of dealing with the attack strategies which are omitted from the analysis in [SZ15], and dealing with them requires us to consider an altogether different proof technique. Additionally, our analysis considers adaptive corruption and spawning of new players (i.e., new players joining); as far as we know, it is the first analysis to formally deal with spawning of new players (which is a cruical desidrata of the blockchain protocol).</p>

    <p class="text-gray-300">A Consistency Theorem with Delays We provide a rough overview of our model and consistency theorem. Consider Nakamoto's protocol with mining-hardness p (that is, a single random oracle query is a successful &quot;in mining&quot; with probability p), and consider an execution with n players, each of them with identical computing power&mdash;we assume the protocol proceeds in rounds (timesteps), and in each round each player gets a single random oracle query and the adversary controlling a  <span class="math">\\rho</span>  fraction of the players gets  <span class="math">\\rho n</span>  random oracles queries (as in [GKL15], the honest players need to make their queries in parallel, but we allow the adversary to makes the queries sequentially). Let  <span class="math">\\alpha = 1 - (1-p)^{(1-\\rho)n}</span>  be the probability that some honest player succeeds in solving a puzzle in one round, and let  <span class="math">\\beta = \\rho np</span>  be the expected number of blocks that an attacker can mine in a round. When  <span class="math">p \\ll 1/n</span>  (which is the case considered in practice), we have that  <span class="math">\\alpha \\approx p(1-\\rho)n</span>  and thus  <span class="math">\\frac{\\alpha}{\\beta} \\approx \\frac{1-\\rho}{\\rho}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 1.1.</strong> Assume there exists some  <span class="math">\\delta &gt; 0</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\alpha(1 - (2\\Delta + 2)\\alpha) \\ge (1 + \\delta)\\beta.</span>$</p>

    <p class="text-gray-300">Then, except with exponentially small probability (in T), Nakamoto's protocol satisfies T-consistency in the random oracle model, assuming the network's latency is bounded by  <span class="math">\\Delta</span> .</p>

    <p class="text-gray-300">As a consequence we have that as long as  <span class="math">\\rho &lt; \\frac{1}{2}</span>  (i.e., the adversary controls less than half of the computational power), for every  <span class="math">\\Delta</span>  there exists some (sufficiently small) p, such that Nakamoto's protocol satisfies consistency. (Note that as mentioned above, if  <span class="math">p &gt; \\frac{1}{\\rho n \\Delta}</span> , Nakamoto's fails to satisfy consistency.)</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 What is a Blockchain?</h3>

    <p class="text-gray-300">As an independent contribution, we formally define an <em>abstract</em> notion of a blockchain (as opposed to <em>the</em> blockchain protocol proposed by Nakamoto) and put forward desired security properties of such a blockchain. We believe that having such a notion will a) simplify applications of blockchains (as we can ignore the implementation details of the blockchain protocol) and b) enable formally studying to what extent the protocol can be improved. (As we explain below, both of these points have been illustrated in subsequent works [PS16a, PS16b].) We mention that while abstract models for <em>higher-level applications</em> of the blockchain (e.g., a &quot;smart contract&quot; abstraction) were provided in the UC framework&mdash;see [KMS<sup>+</sup>15, BK14]&mdash;it is not clear to what extent those abstractions can be satisfied by Nakamoto's protocol; rather, we are here interested in having a simple notion of the blockchain itself that we can prove is satisfied by Nakamoto's protocol and yet is useful for applications.</p>

    <p class="text-gray-300">Roughly speaking, a blockchain is an interactive protocol where each participant has a local variable state which contains a list of messages  <span class="math">\\vec{m}</span> , called the &quot;chain&quot;. Players receive inputs, called records/batches/messages, that they attempt to include in the chain of themselves and of others. We require the following properties from a secure blockchain:</p>

    <p class="text-gray-300">&bull; consistency: with overwhelming probability (in T), at any point, the chains of two honest players can differ only in the last T blocks;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>future self-consistence: with overwhelming probability (in T), at any two points r, s the chains of any honest player at r and s differ only within the last T blocks;</li>
      <li>g-chain-growth: with overwhelming probability (in T), at any point in the execution, the chain of honest players grows by at least T messages in the last  <span class="math">\\frac{T}{g}</span>  rounds; g is called the chain-growth of the protocol.</li>
      <li>the  <span class="math">\\mu</span> -chain quality with overwhelming probability (in T), for any T consecutive messages in any chain held by some honest player, the fraction of messages that were &quot;contributed by honest players&quot; is at least  <span class="math">\\mu</span> .</li>
    </ul>

    <p class="text-gray-300">The consistency property is just the &quot;plain&quot; one considered already by Nakamoto [Nak08] (and formalized by Garay et al [GKL15]). As we note, however, this consistency property is typically not sufficient for applications. In particular, it does not rule out a protocol that oscillates between two different chains  <span class="math">\\vec{m}_1, \\vec{m}_2</span> ; on even rounds all players have  <span class="math">\\vec{m}_1</span>  as their chain, and on odd rounds  <span class="math">\\vec{m}_2</span> . Clearly such a protocol does not suffice for typical applications (e.g., bitcoin, or achieving a public ledger). Thus, to prevent it, we introduce the <em>future self-consistency</em> property.</p>

    <p class="text-gray-300">The lower bound on chain-growth was explicitly considered by Sampolinsky and Zohar [SZ15] (but they only consider growth in expectation); Garay et al [GKL15] implicitly show a lower-bound on on chain growth within one of their proofs, and [KP15] explicitly introduce it as a desideratum. In this paper, we additionally introduce an <em>upper-bound</em> on chain growth as a desirable property; as shown in subsequent work [PS16a, PS16b], this property is useful in applications.</p>

    <p class="text-gray-300">Finally, the chain quality property was first discussed on the Bitcoin forum [mtg10] and made explicit in the selfish mining attacks by Eyal and Sirer [ES14] w.r.t. the bitcoin application of the blockchain.<sup>2</sup> The property was first formalized, and given the name &quot;chain quality&quot; by Garay et al [GKL15]; Garay et al [GKL15] furthermore show new applications of it (as we discuss shortly).</p>

    <p class="text-gray-300">We show the usefulness of these properties by demonstrating that any blockchain protocol satisfying them can be used to achieve a public ledger (i.e., consensus) satisfying a) persistency (namely, if a message gets added to the public ledger, it never gets removed) and b) liveness (that is, if all honest players want to add a some message to the ledger, the message should eventually appear on it). We mention that Garay et al [GKL15] already noted that, intuitively, the chain quality property implies liveness (since, by chain quality the adversary cannot monopolize the chain), and consistency implies persistence. However, although they show how to use Nakamoto's protocol to obtain a public ledger (in the synchronous model), they use those two properties and additional properties of the concrete protocol to establish it. Kiayias and Panagiotakos [KP15] demonstrate that by additionally requiring chain growth suffices to prove liveness in a black-box way, but proving persistence still required an analysis of the concrete protocol. We highlight that it is our notion of future-self consistency that allows us to obtain also persistence in a black-box way. Subsequent works by Pass and Shi [PS16a, PS16b] give further evidence to the usefulness of our abstract notion of a blockchain (and its security properties).</p>

    <p class="text-gray-300"><strong>Main theorem</strong> Our main result demonstrates that Nakamoto's protocol achieves consistency as well as all of our other desiderata. Let  <span class="math">\\gamma = \\frac{\\alpha}{1+\\Delta\\alpha}</span> ; think of  <span class="math">\\gamma</span>  as a &quot;discounted&quot; version of  <span class="math">\\alpha</span>  due to delays on the network. Intuitively, by delaying messages the adversary gets additional computation time.</p>

    <p class="text-gray-300"><strong>Theorem 1.2.</strong> Assume there exists some  <span class="math">\\delta &gt; 0</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\alpha(1 - 2(\\Delta + 1)\\alpha) \\ge (1 + \\delta)\\beta.</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>In the bitcoin application of the blockchain, each player receives a reward whenever if mines a block; the chain quality thus dictates a bound on how much more reward an adversary can get by deviating from the protocol.</p>

    <p class="text-gray-300">Let  <span class="math">g = \\frac{\\gamma}{1+\\delta}</span>  and  <span class="math">\\mu = 1 - (1+\\delta)\\frac{\\beta}{\\gamma}</span> . Then Nakamoto's protocol satisfies consistency, future self consistency,  <span class="math">\\mu</span> -chain quality and g-chain growth.</p>

    <p class="text-gray-300">Note that when  <span class="math">p \\ll 1/n\\Delta</span>  (which is the case considered in practice), we have that  <span class="math">\\gamma \\approx \\alpha \\approx (1-\\rho)np</span>  and thus  <span class="math">\\frac{\\gamma}{\\beta} \\approx \\frac{1-\\rho}{\\rho}</span> . As a consequence, we have the following corollary:</p>

    <p class="text-gray-300"><strong>Corollary 1.3.</strong> Assume  <span class="math">\\rho &lt; \\frac{1}{2}</span> . Then for every  <span class="math">n, \\Delta</span> , there exists some sufficiently small  <span class="math">p_0 = \\Theta(\\frac{1}{\\Delta n})</span>  such that Nakamoto's protocol with mining parameter  <span class="math">p \\leq p_0</span>  satisfies consistency, future self consistency,  <span class="math">1 - \\frac{\\rho}{1-\\rho}</span> -chain quality and  <span class="math">\\frac{pn}{2}</span> -growth.</p>

    <p class="text-gray-300">Thus, as long as  <span class="math">\\rho &lt; \\frac{1}{2}</span> , Nakamoto's protocol guarantees that messages contributed by honest players will eventually end up on the chain, and as long as  <span class="math">\\rho &lt; \\frac{1}{3}</span> , we have that half of the messages on the chain will be contributed by honest players. We mention that our chain quality bound matches that established by Garay et al [GKL15] assuming no delays (i.e.,  <span class="math">\\Delta = 1</span> ), and is tight due to the selfish mining (a.k.a. &quot;mining-cartel&quot;) attacks of [mtg10, ES14]).</p>

    <p class="text-gray-300">A natural question left open by our main theorem is whether there exists protocols satisfying our abstract notion of a blockchain that improve upon the parameters achieved by Nakamoto's protocol (i.e., is Nakamoto's protocol &quot;optimal&quot;?). A subsequent result by Pass and Shi [PS16a] shows how we can &quot;amplify&quot; the chain quality in Nakamoto's protocol to achieve a &quot;close-to-optimal&quot; chain quality of  <span class="math">1 - (1 - \\delta)\\rho</span> , where  <span class="math">\\delta</span>  is an arbitrary small constant. We highlight that the results in [PS16a] relies on the analysis from this paper in a blackbox way.</p>

      <h3 id="sec-1.4" class="text-xl font-semibold mt-8">1.4 Is Nakamoto's Protocol Really Permissionless?</h3>

    <p class="text-gray-300">Our theorem only shows that for every  <span class="math">n, \\Delta</span> , there exists some mining-hardness parameter p that makes the protocol secure, so it might seem like the protocol needs to know n and therefore cannot be &quot;permissionless&quot;; see Section 1.5 for an experimental evaluation of how the level of security depends on the choice of p. (As we pointed out above, this is not an anomaly of our analysis; when  <span class="math">p &gt; \\frac{1}{n\\rho\\Delta}</span>  the protocol is insecure.) The point, however, is that the protocol only needs to know a very rough upper-bound on the number of players n (but the worse the upper-bound gets, the worse the efficiency of the protocol becomes.)</p>

    <p class="text-gray-300">We additionally remark that our theorem regarding the lower bound on the chain growth actually does not make any assumption about p; this means that the honest players can use an initial set-up phase to estimate the chain growth and from this deduce a weak upper-bound on the number of players n, and then use this new upperbound to run the protocol. Indeed, as we hinted to before, the bitcoin protocol recalibrates the mining hardness parameter p every 2016 blocks (roughly 2 weeks) based on the time it took to find 2016 blocks. We leave a formal analysis of this update procedure for future work.</p>

      <h3 id="sec-1.5" class="text-xl font-semibold mt-8">1.5 An Experimental Interpretation</h3>

    <p class="text-gray-300">In this section, we provide an experimental interpretation of our theorems by using estimates of parameters in a real world setting. In early 2016, the Bitcoin network collectively performed roughly  <span class="math">10^{18}</span>  hash operations per second [Blo16]. Several companies sell mining hardware that operates at  <span class="math">10^{12}</span>  hash operations per second. To be consistent with these values, we consider  <span class="math">n=10^5</span>  participants and  <span class="math">\\Delta=10^{13}</span> , which corresponds to roughly 10s delay for the network at the given hashing rates. The 10s estimation is based on an assumption that most of the computational power contributing to the Bitcoin network operates with a connection that exceeds 1mb/s, thus, each block takes roughly 1s to transmit, and the diameter of the network is less than 10 hops. These</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup>An &quot;optimal&quot; chain quality of  <span class="math">1 - \\rho</span>  means a  <span class="math">\\rho</span>  fraction attacker gets a  <span class="math">\\rho</span>  fraction of the blocks.</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: For  <span class="math">n=10^5</span>  and  <span class="math">\\Delta=10^{13}</span>  (i.e., 10s delays at 1TH/s for commercially available mining hardware&mdash;these parameters roughly coincide with estimates of hashrate as of February 2016), we set hardness parameter  <span class="math">p=\\frac{1}{c\\cdot n\\Delta}</span>  where c varies along the x-axis. We can interpret c as the expected blocktime in terms of the network delay  <span class="math">\\Delta</span> . The blue graph depicts a numerically-computed maximum value of  <span class="math">\\rho</span>  for which  <span class="math">\\alpha(1-(2\\Delta+2)\\alpha)&gt;\\beta</span> , i.e. parameters under which our theorem 4.3 shows consistency of the Nakamoto protocol. The red plot shows when our best attack succeeds in violating consistency. When c=60, the hardness roughly corresponds to an expected 10-minute blocktime, and our theorem shows that Nakamoto tolerates a  <span class="math">\\rho&lt;49.57\\%</span>  attack, and our best attack succeeds when  <span class="math">\\rho&gt;49.79\\%</span> .</p>

    <p class="text-gray-300">assumptions align with the empirical measurements made by Decker and Wattenhofer [DW13]. For a period during the summer of 2012, they computed the average blocktime to be roughly 10.55m and the &quot;weighted average&quot;  <span class="math">\\Delta \\sim 11.37s</span>  (their model realistically allows for  <span class="math">\\Delta</span>  to be a distribution with a long tail). Their measurements are supported by website bitcoinstats.com for 2016. However, in both cases, they measure connectivity by number of nodes instead of by computational resources; thus their &quot;95<sup>th</sup> percentile&quot; estimations are biased larger because they include many hobby nodes which are connected by slow network connections and do not contribute any noticeable computation to the protocol.</p>

    <p class="text-gray-300">The hardness parameter in Nakamoto's protocol reflects the expected time between the discovery of blocks among all participants. Here, we can explore how consistency is related to this parameter  <span class="math">p = \\frac{1}{n\\Delta \\cdot c}</span>  by changing c. One can interpret c as the scale-free <em>expected block-time</em> expressed in terms of the number of networks delays.</p>

    <p class="text-gray-300">For these choices, Fig. 1 depicts when our consistency theorm holds in Nakamoto's protocol by graphing c against the fraction  <span class="math">(\\rho)</span>  of computation controlled by the adversary. The blue graph depicts a numerically-computed maximum value of  <span class="math">\\rho</span>  for which  <span class="math">\\alpha(1-(2\\Delta+2)\\alpha)&gt;\\beta</span> , i.e. parameters under which our theorem 4.3 shows consistency of the Nakamoto protocol. The red plot shows when our best attack succeeds in violating consistency.</p>

    <p class="text-gray-300">Nakamoto's protocol attempts to maintain a 10-minute block time by varying hardness p. For a delay  <span class="math">\\Delta \\sim 10s</span> , this corresponds to a setting of c=60. In this range, the Nakamoto protocol, as well as our attack give essentially the same result: Nakamoto tolerates an adversary with  <span class="math">\\rho &lt; 49.57\\%</span>  and our best attack succeeds when &rho; &gt; 49.79%. If we make a very conservative estimate of network delays being 1m, then c = 10, and Nakamoto remains consistent with respect to a 47.2% coalition.</p>

    <p class="text-gray-300">Finally, let us remark that the reason that our analysis is not tight when c is small is that in our attack we only consider the probability that the adversary is able to completely control the chain. When c is small, there is also a large probability that honest players do not converge on a chain even without any adversarial messages.</p>

      <h3 id="sec-1.6" class="text-xl font-semibold mt-8">1.6 Proof Highlights</h3>

    <p class="text-gray-300">Although our high-level approach follows similar intuitions as the analyses from Garay et al [GKL15] and Sompolinsky and Zohar [SZ15], our actual proof uses a quite different proof strategy. As mentioned, the bulk of our proof consists of dealing with the attack strategies which are omitted from the analysis in [SZ15], and dealing with them requires us to consider an altogether different proof technique: instead of directly analyzing the whole blockchain process, we consider a sequence of simplified processes which are &quot;dominated&quot; by the original one but are simpler to analyze. For instance, we aim to show that in the optimal attack, the adversary should always delay messages for as long as possible (so that messages are always delivered after &#8710; steps). An obstacle in performing such a stochastic domination analysis is that once we start delaying messages, honest parties start to &quot;mine&quot; different blocks and the executions of our two processes diverge and become hard to compare: Ideally, to perform the domination argument we would like to consider a fixed execution (where the randomness of all parties are fixed) and to show by induction delaying messages less than &#8710; never helps the attacker in that particular execution. The problem is that such a domination claim is not true: one can come up with scenarios (where the randomness is fixed) where, &quot;by luck&quot; delaying messages improves things for the honest parties (they now start mining blocks that magically lead to more successes). Of course, the probability of this happening should be small, but formally showing this would require us to somehow couple the experiments with and without maximum delays which is non-trivial (due to dependencies created by the random oracle)</p>

    <p class="text-gray-300">The Ftree model. To overcome this issue, we rely on &quot;simulation techniques&quot; from the cryptographic literature on secure computation [GMW87, Can00]: we first consider an idealized scenario where the players do not mine blocks but instead have access to an idealized &quot;mining&quot; functionality, which we call Ftree. This functionality determines whether honest parties succeed in mining (at random) and the success probability is independent of the current chain an honest party is trying to extend. In this model, we can now perform a domination argument for every fixed randomness for the experiment. One of our main technical lemmas, which turns out to be quite subtle to prove, shows that any attack that succeeds in the &quot;real-life&quot; protocol in the random oracle model can be turned into (i.e., simulated by) an attack in the idealized Ftree model. The key technical issue here is to deal with the dependencies created by the random oracle. (As an independent contribution, we believe that our Ftree simulation lemma can be helpful in formalizing some steps left informal in e.g., [GKL15, KP15, SZ15].)</p>

    <p class="text-gray-300">The chain growth lowerbound. Armed with the above-mentioned techniques, the next crucial step is demonstrating a lowerbound on the chain growth. Roughly speaking, we prove by induction that (in the Ftree model) the chain grows at least as fast in the real execution of the protocol, as in a &quot;hybrid&quot; experiment where a) all messages are maximally delayed, b) honest parties &quot;freeze&quot; and stop mining for &#8710; steps whenever some honest player mines a block and c) all messages sent by the adversary are removed. The advantage of this hybrid experiment is that the chain growth process can now be described as a simple Markov chain&mdash;there are no longer any &quot;adversarial transitions&quot; and due to the &quot;freezing&quot;, honest players never have any chain conflict. This process can next be analyzed using standard Chernoff bounds. We emphasize that for the induction proof to go through, we cruicially rely on the fact that our analysis is in the Ftree-model.</p>

    <p class="text-gray-300">No &quot;long&quot; block withholding. We next use the chain growth lowerbound to demonstrate a central property of the blockchain protocol, which we refer to as the &quot;no long block withholding&quot; property : an adversary cannot &quot;withhold&quot; a block that it has mined for too &quot;long&quot;&mdash;unless it broadcasts the block to the honest players within some short amount of time, the block becomes &quot;irrelevant&quot; and will never be accepted by the honest players. Roughly speaking, we prove this by showing that, assuming that the adversary controls less than half of the computational power in the network, the chain of honest players will grow at a faster rate than any private chain the adversary can create, and thus unless it releases any block it finds quickly, the honest players' chain will be too long for the block to ever be relevant.</p>

    <p class="text-gray-300">Proving consistency. Finally, proving consistency is the most challenging part of our proof. We start by first considering an execution without adversarial messages, and with deterministic delays, and identify a &quot;pattern&quot; which ensures that the chain of honest players converges: roughly, the pattern&mdash;which we refer to as a &quot;convergence opportunity&quot;&mdash;is that 1) there is a period of &quot;silence&quot; for &#8710; rounds where no honest player mines a block, 2) this is followed by a round where a single honest player mines a block, 3) which is followed by another &#8710; rounds of silence. Note that whenever such a pattern occurs, at the end of it all honest players have converged on the chain (which is why we call it a convergence opportunity): after the first period of silence, they all agree on the length of the chain (but may still have different chains), and thus the lone miner who finds a new block extends this longest chain by 1, and finally after the second period of silence this chain has propagated to all honest players (and since it is longer than all their current chains, they will switch to it). We are now interested in understanding how many such patterns happen within some specific period of time t. The cruicial points here is that the process we now are analyzing is memoryless, and thus can be described by a (somewhat simple) Markov chain. On the negative side, the Markov chain that arises from this problem is too complicated to be analyzed with standard concentration bounds for Markov chains (see e.g., [CLLM12]); we instead, provide a direct analysis of a simplified experiment (which, roughly speaking, instead analyzes the times between successful mining of honest players.) and we then use this to provide a lowerbound on the number of convergence opportunities.</p>

    <p class="text-gray-300">Finally, once we have established a strong concentration bound on the number of occurrences of such convergence opportunities, we argue that the only way that an attacker can &quot;ruin&quot; such a pattern is by itself mining a block that is accepted by the honest players during it. We here rely on the block-withholding lemma to argue that any block that the attacker can use to ruin a convergence opportunity must have been mined by the adversary not long before the beginning of the period of time we are analyzing; we then show that the number of adversarial block mined during this (slightly extended) period of time is smaller than the number of &quot;convergence opportunities&quot;, and thus conclude that at least one convergence opportunity will remain even in the presence of the adversary, and thus honest parties still converge on their chain.</p>

      <h3 id="sec-1.7" class="text-xl font-semibold mt-8">1.7 Related Work</h3>

    <p class="text-gray-300">The problem of reaching agreement in the presence of faulty participants, described first by Pease, Shostak, and Lamport [PSL80], and also known as distributed consensus has been very well studied over the past 40 years. The basic problem considers a set of n parties connected by reliable and authenticated pairwise network channels who wish to agree on a common output in the presence of an adversary who controls a fraction of the participants. Many aspects of the problem have been studied, with relaxations concerning the fraction of corrupted parties, the channels available to the participants, whether the protocols are deterministic or randomized and whether the participants are computationally bounded. Some protocols only consider fail-stop adversaries, while others consider a Byzantine setting in which some of the participants are malicious adversaries who attempt to disrupt the agreement. In the Byzantine agreement (BA) version of the problem, Castro and Liskov [CL99] implemented a replication library that was practical enough to use for a file system; subsequently, other works have considered &quot;fast&quot; or &quot;simpler&quot; versions of the Paxos protocol [MA05, Lam10, Lam11]. All of these works assume, however, common knowledge of the number of participants n, as well as identities for the participants.</p>

    <p class="text-gray-300">Okun [Oku05a, Oku05b, OB08] considers BA in an &quot;anonymous [synchronous] model without port awareness&quot; in which processors do not have identifiers and cannot correlate messages to their sources; Okun shows both an impossibility result for deterministic protocols, and a feasibility result for probabilistic ones. Aspnes et al. [AJK05] shows how using a proof-of-work in a pre-processing step for this model can be used to assign interim identities to parties so that the number of identities assigned was proportional to computational power. After the pre-processing, a standard authenticated BA protocol is used. Neither results, however, are in the peer-to-peer setting in which new users can join and leave during the execution.</p>

    <p class="text-gray-300">Miller and LaViola [ML14] show that variant of Nakamoto's protocol can be used to solve the single-shot Byzantine agreement problem in the presence of a minority of faults in an asynchronous setting. The single-shot setting is substantially easier, since the adversary is limited, and for example, cannot mount block-withholding attacks. Garay, Kiayias, and Leonardas [GKL15] provide a better analysis of Nakamoto's protocol, and also propose two protocols based on Nakamoto's protocol that satisfy all the properties of BA in the multiple-instance setting. They only consider synchronous networks (and no spawning of new honest players). (As mentioned above, however, in synchronous networks, simpler solutions are possible.)</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Blockchain Protocols and Executions</h2>

    <p class="text-gray-300">In this section, we present an abstract model for blockchain protocols which aims to cover many variants of blockchain protocols.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Blockchain Protocols</h3>

    <p class="text-gray-300">A blockchain protocol is a pair of algorithms  <span class="math">(\\Pi, \\mathcal{C})</span>  where  <span class="math">\\Pi</span>  is a stateful algorithm that receives a security parameter  <span class="math">\\kappa</span>  as inputs and maintains a local state state. The algorithm  <span class="math">\\mathcal{C}(\\kappa, \\mathsf{state})</span>  outputs an <em>ordered</em> sequence of &quot;records&quot;, or &quot;batches&quot;,  <span class="math">\\vec{\\mathsf{m}}</span>  (e.g., in the bitcoin protocol, each such record is an ordered sequence of transactions). We call  <span class="math">\\mathcal{C}(\\kappa, \\mathsf{state})</span>  the &quot;record chain&quot; of a player with security parameter  <span class="math">\\kappa</span>  and local variable state; to simplify notation, whenever  <span class="math">\\kappa</span>  is clear from context we often write  <span class="math">\\mathcal{C}(\\mathsf{state})</span>  to denote  <span class="math">\\mathcal{C}(\\kappa, \\mathsf{state})</span> .</p>

    <p class="text-gray-300">Algorithm  <span class="math">\\Pi</span>  is parameterized by a <em>validity</em> predicate V (denoted by  <span class="math">\\Pi^V</span> ) that encapsulates the semantic properties (e.g., &quot;no double spending&quot;) that a blockchain application aims to achieve.  <span class="math">V(\\vec{\\mathbf{m}})</span>  returns 1 if and only if the chain  <span class="math">\\vec{\\mathbf{m}}</span>  is <em>valid</em> for some notion of validity.</p>

    <p class="text-gray-300">A Blockchain Execution Following the framework for Universal Composability [Can00], we consider the execution of a blockchain protocol ( <span class="math">\\Pi^V, \\mathcal{C}</span> ) that is directed by an environment  <span class="math">Z(1^{\\kappa})</span>  (where  <span class="math">\\kappa</span>  is a security parameter), which activates a number of parties  <span class="math">1, 2, \\ldots, n</span>  as either &quot;honest&quot; or corrupted parties. Honest parties execute  <span class="math">\\Pi</span>  on input  <span class="math">1^{\\kappa}</span>  with an empy local state state; corrupt parties are controlled by an attacker A which reads all their inputs/message and sets their outputs/messages to be sent.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The execution proceeds in rounds that model time steps. In round r, each honest player i receives a message (a &quot;record&quot;) m from Z (that it attempts to &quot;add&quot; to its chain) and potentially receives incoming network messages (delivered by A). It may then perform any computation, broadcast a message to all other players (which will be delivered by the adversary; see below) and update its local state  <span class="math">state_i</span> .</li>
      <li>A is responsible for delivering all messages sent by parties (honest or corrupted) to all other parties. A cannot modify the content of messages broadcast by honest players, but it may delay or reorder the delivery of a message as long as it eventually delivers all messages. (Later, we shall consider restrictions on the delivery time.) The identity of the sender is not known to the recipient.<sup>4</sup></li>
      <li>At any point, Z can communicate with adversary A or access  <span class="math">C(\\mathsf{state}_i)</span>  where  <span class="math">\\mathsf{state}_i</span>  is the local state of player i.</li>
      <li>At any point, Z can corrupt an honest party j which means that A gets access to its local state and subsequently, A controls party j. (In particular, this means we consider a model with &quot;erasures&quot;; random coin tosses that are no longer stored in the local state of j are not visible to A.)<sup>5</sup></li>
      <li>At any point, Z can uncorrupt a corrupted player j, which means that A no longer controls j and instead player j starts executing  <span class="math">\\Pi(1^{\\kappa})</span>  with a fresh state  <span class="math">\\mathsf{state}_j</span> . (This is also how we model Z spawning a &quot;new&quot; honest player.) A gets informed of all such uncorrupt messages and is required to deliver all messages previously sent by (currently alive) honest players.<sup>6</sup></li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa)</span>  be a random variable denoting the joint view of all parties (i.e., all their inputs, random coins and messages received, including those from the random oracle) in the above execution; note that this joint view fully determines the execution.</p>

    <p class="text-gray-300"><strong>Admissible Environments</strong> We will be considering executions with restricted adversaries and environments; these restrictions will be specified by a predicate  <span class="math">\\Gamma(\\cdot,\\cdot,\\cdot,\\cdot)</span> .</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (Admissible Environments). We say that the tuple  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span>  is  <span class="math">\\Gamma</span> -admissible w.r.t.  <span class="math">(\\Pi^V, \\mathcal{C})</span>  if A and Z are non-uniform probabilistic polynomial-time algorithms,  <span class="math">\\Gamma(n(\\cdot), \\rho, \\Delta) = 1</span>  and for every  <span class="math">\\kappa \\in N</span> , every view view in the support of  <span class="math">\\mathsf{EXEC}^{(\\Pi^V, \\mathcal{C})}(A, Z, \\kappa)</span> , the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Z activates  <span class="math">n = n(\\kappa)</span>  parties in view;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A delays messages by at most  <span class="math">\\Delta = \\Delta(\\kappa)</span>  rounds (and in the case of newly spawned players, instantly delivers messages that were sent more than  <span class="math">\\Delta</span>  rounds ago);</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>at any round r in view, A controls at most  <span class="math">\\rho \\cdot n(\\kappa)</span>  parties; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>in every round r in view, Z only sends local inputs m to an honest player i, if  <span class="math">V(\\mathcal{C}(\\mathsf{state}_i)||m) = 1</span> , where  <span class="math">\\mathsf{state}_i</span>  is player i's local state at round r in view.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Whenever the protocol  <span class="math">(\\Pi^V, \\mathcal{C})</span>  is clear from context, we simply call  <span class="math">(n, \\rho, \\Delta, A, Z)</span>   <span class="math">\\Gamma</span> -admissible.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>We could also consider a seemingly weaker model where messages sent by corrupted parties need not be delivered to all honest players. We can easily convert the weaker model to the stronger model by having honest parties &quot;gossip&quot; all messages they receive.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>Our proof actually extends also to the model &quot;without erasures&quot;.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>This models the fact that a player is not considered &quot;honest&quot; before it has joined the network and gotten &quot;initialized&quot;. In the real-life execution of bitcoin, new players joining send out a message to the network, request to be initialized and download the longest chain known to the network. We only consider them honest once this process is over.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 A remark about the communication model</h3>

    <p class="text-gray-300">Our model assumed that any player can send a message to all other players in the network, and that those messages arrive within  <span class="math">\\Delta</span>  rounds, no matter how long they are. This is clearly not a very realistic model. In real-life, player communicate their messages through a gossip network, and thus we need to assume that this network is sufficiently connected and has sufficiently many honest players to ensure  <span class="math">\\Delta</span>  delivery time. This still clearly is infeasible if messages can be arbitrary long. However, in the applications we consider&mdash;assuming that records  <span class="math">\\mathbf{m}</span>  provided by the environment are of length  <span class="math">O(\\kappa)</span>  (i.e., there is a &quot;block-size limit&quot;)&mdash;honest players only communicate messages that differ in the last  <span class="math">O(\\kappa)</span>  bits from messages that they have previously received. For such cases it seems reasonable to assume that a sufficiently connected routing network has the desired property of ensuring delivery of all messages within  <span class="math">\\Delta</span>  rounds.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Blockchain protocols in the ROM</h3>

    <p class="text-gray-300">To model Nakamoto's blockchain protocol, we need to extend the model with a random oracle. In an execution with security parameter  <span class="math">\\kappa</span> , we assume all parties have access to a random function  <span class="math">H:\\{0,1\\}^* \\to \\{0,1\\}^\\kappa</span>  which they can access through two oracles: H(x) simply outputs H(x) and H.ver(x,y) output 1 iff H(x)=y and 0 otherwise. In any round r, the players (as well as A) may make any number of queries to H.ver. On the other hand, in each round r, honest players can make only a single query to H, and an adversary A controlling q parties, can make q sequential queries to H. (This modeling is meant to capture the assumption that we only &quot;charge&quot; for the effort of finding a solution to a &quot;proof of work&quot; [DN92], but checking the validity of a solution is cheap. We discuss this further after introducing Nakamoto's protocol.) We emphasize that the environment Z does not get direct access to the random oracle (but can instruct A to make queries).</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Nakamoto's Protocol</h3>

    <p class="text-gray-300">We turn to describing Nakamoto's protocol [Nak08], which we refer to as  <span class="math">(\\Pi^p_{Nak}, \\mathcal{C}^p_{Nak})</span> . The local state state maintained by  <span class="math">\\Pi^p_{Nak}</span>  is a sequence of (mined) blocks  <span class="math">\\vec{\\mathbf{b}}</span> , where each mined block is a tuple  <span class="math">(h_{-1}, n, \\mathbf{m}, h)</span>  that consists of a hash  <span class="math">h_{-1}</span>  (a pointer to the previous record), a nonce  <span class="math">\\eta</span> , a record  <span class="math">\\mathbf{m}</span> , and a hash h (a pointer to the current record<sup>8</sup>) and is initialized to a special &quot;genesis&quot; block:  <span class="math">(0, 0, \\bot)</span> ,  <span class="math">\\mathsf{H}(0, 0, \\bot)</span> . Let  <span class="math">\\mathcal{C}(\\mathsf{state})</span>  be the sequence of records  <span class="math">\\vec{\\mathbf{m}}</span>  contained in the sequence of blocks state. The protocol is parameterized by a hardness function  <span class="math">p(\\cdot)</span>  which defines a constant  <span class="math">D_p = p(\\kappa) \\cdot 2^{\\kappa}</span>  such that for all (h, b),  <span class="math">\\Pr_{\\eta}[\\mathsf{H}(h, \\eta, b) &lt; D_p] = p(\\kappa)</span> . Whenever p is clear for context, we simply denote the protocol  <span class="math">(\\Pi_{Nak}, \\mathcal{C}_{Nak})</span>  (without the p superscript); additionally, whenever  <span class="math">\\kappa</span>  is clear from context, we let  <span class="math">p = p(\\kappa)</span> .</p>

    <p class="text-gray-300">We say a block  <span class="math">b = (h_{-1}, \\eta, m, h)</span>  is valid with respect to (a predecessor block)  <span class="math">b_{-1} = (h&#x27;_{-1}, n&#x27;, m&#x27;, h&#x27;)</span>  if three conditions hold:  <span class="math">h_{-1} = h&#x27;</span> ,  <span class="math">h = H(h_{-1}, \\eta, m)</span> , and  <span class="math">h &lt; D_p</span> . A sequence of blocks state  <span class="math">= (b_0, \\ldots, b_\\ell)</span>  is valid if a)  <span class="math">b_0 = (0, 0, \\perp, H(0, 0, \\perp))</span>  is the genesis block, b) for all  <span class="math">i \\in [\\ell]</span> ,  <span class="math">b_i</span>  is valid with respect to  <span class="math">b_{i-1}</span> , and c)  <span class="math">V(\\mathcal{C}(\\text{state})) = 1</span> .</p>

    <p class="text-gray-300">Each round of  <span class="math">\\Pi^{V}_{Nak}</span>  proceeds as follows:</p>

    <p class="text-gray-300">&bull; Read all incoming messages (delivered by A). If any incoming message state' is a valid sequence of blocks that is longer than its local state state, replace state by state'. (Note that checking the validity of state' can be done using only H.ver queries)</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>In Bitcoin's instantiation of the blockchain protocol, there is currently a severe restriction on the block-size. There is currently an active debate whether to raise the block-size limit or to leave it small.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{8}&lt;/sup&gt;</span> In reality (as well as in the description in the introduction), h is not included in the block (as it can be easily determined from the remaining elements); we include it to ensure that we can verify validity of a block using only H.ver.</p>

    <p class="text-gray-300">&bull; Read local message m (from Z). If m is such that  <span class="math">V(\\mathcal{C}(\\mathsf{state})||\\mathsf{m}) \\neq 1</span> , proceed to the next round. Otherwise, pick a random nonce  <span class="math">n \\in \\{0,1\\}^{\\kappa}</span>  and issue query  <span class="math">h = \\mathsf{H}(h_{-1},\\eta,\\mathsf{m})</span>  where  <span class="math">h_{-1}</span>  is the 4'th element in the last block in state. If  <span class="math">h &lt; D_p</span> , then  <span class="math">\\Pi</span>  adds the newly mined block  <span class="math">(h_{-1},\\eta,b,h)</span>  to state and broadcasts the updated state.</p>

    <p class="text-gray-300">Depending on the definition of V, one can instantiate either Bitcoin, e.g., by having V enforce that  <span class="math">\\mathbf{m}</span>  can be parsed into a sequence of well-formed transactions each of which is authorized and spends money from a source account to a destination account at most once without deficit, etc., as well as other cryptocurrencies with different semantics such as Namecoin. We may also consider a simpler predicate  <span class="math">V_{\\mathcal{L}}</span>  that simply accepts all messages; that is  <span class="math">V_{\\mathcal{L}}(\\vec{\\mathbf{m}}) = 1</span> ; such a predicate is useful, for instance, to use a blockchain to provide a public ledger.</p>

    <p class="text-gray-300">A Remark on our use of the Random Oracle Recall that in our model, we restrict players to a single evaluation query H per round, but allow them any number of verification queries H.ver in the same round. We do this to model the fact that checking the validity of mined blocks is &quot;cheap&quot; whereas the mining process is expensive. (To enable this, we have included a pointer h to the current record in every mined block in the description of Nakamoto; thus a player need not spend an H query to compute the pointer to the previous record.)</p>

    <p class="text-gray-300">In practice, the cost of evaluating a hash function (which is used to instantiate the random oracle) is the same as verifying its outputs, but our modeling attempts to capture the phenomena that a miner typically use various heuristics (such as black lists of IP addresses that have sent invalid blocks) and different hardware to check the validity of a mined block versus to mine a new block.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Formal Definitions of the Desiderata</h2>

    <p class="text-gray-300">In this section, we provide formal definitions of the desiderata mentioned in the introduction. We start of with some notation and preliminaries.</p>

    <p class="text-gray-300"><strong>Notation</strong> For some A, Z, consider some view in the support of  <span class="math">\\mathsf{EXEC}^{(\\Pi^V, \\mathcal{C})}(A, Z, \\kappa)</span> . We use the notation |view| to denote the number of rounds in the execution, view<sup>r</sup> to denote the prefix of view up until round r,  <span class="math">\\mathsf{state}_i(\\mathsf{view})</span>  denotes the local state of player i in  <span class="math">\\mathsf{view}</span> ,  <span class="math">\\mathcal{C}_i(\\mathsf{view}) = \\mathcal{C}(\\mathsf{state}_i(\\mathsf{view}))</span>  and  <span class="math">\\mathcal{C}_i^r(\\mathsf{view}) = \\mathcal{C}_i(\\mathsf{view}^r)</span> .</p>

    <p class="text-gray-300">(Strongly) Negligible Functions A function  <span class="math">\\epsilon(\\cdot)</span>  is said to be negligible if for every polynomial  <span class="math">p(\\cdot)</span> , there exists some  <span class="math">\\kappa_0</span>  such that  <span class="math">\\epsilon(\\kappa) \\leq \\frac{1}{p(\\kappa)}</span>  for all  <span class="math">\\kappa \\geq \\kappa_0</span> . Our bounds will actually also apply to an exponentially-strong interpretation of what it means for a function to be negligible. A function  <span class="math">\\epsilon(\\cdot)</span>  is said to be (strongly) negligible if there exists constants  <span class="math">c_0 &gt; 0</span> ,  <span class="math">c_1</span>  such that for all  <span class="math">\\kappa</span> ,  <span class="math">\\epsilon(\\kappa) \\leq e^{-c_0\\kappa + c_1}</span> . In the rest of the paper, we simply use the term &quot;negligible&quot;, but all uses of it can be replaced by strongly negligible. We often use the shorthand  <span class="math">\\operatorname{neg}(\\kappa)</span>  to denote a function that is negligible as a function of  <span class="math">\\kappa</span> .</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Chain Growth</h3>

    <p class="text-gray-300">Our first desiderata is that the chain grows proportionally with the number of rounds of the protocol. This intuitive property was explicitly considered by Sompolinsky and Zohar [SZ15] but they only consider growth in expectation; it was also implicitly considered in Garay et al [GKL15] within one of their proofs (but was not highlighted as a desideratum), and explicitly highlighted as a desideratum by Kiayias and Panagiotakos [KP15]. We here generalize these definitions to</p>

    <p class="text-gray-300">&quot;abstract&quot; blockchain protocols, and add a useful &quot;length&quot; consistency property. (Looking forward, in Section 3.4, we will also consider an upper-bound on chain growth.)</p>

    <p class="text-gray-300">Let.</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{min\\text{-}chain\\text{-}increase}_{r,t}(\\mathsf{view}) = \\min_{i,j} |\\mathcal{C}_j^{r+t}(\\mathsf{view})| - |\\mathcal{C}_i^r(\\mathsf{view})|</span>$</p>

    <p class="text-gray-300">where we quantify over players i, j such that i is honest at  <span class="math">\\mathsf{view}^r</span>  and j is honest at  <span class="math">\\mathsf{view}^{r+t}</span> . Let  <span class="math">\\mathsf{growth}^t(\\mathsf{view}, \\Delta, T) = 1</span>  iff the following two properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(consistent length) for all rounds  <span class="math">r \\leq |\\mathsf{view}| \\Delta</span> ,  <span class="math">r + \\Delta \\geq r&#x27; \\leq |\\mathsf{view}|</span> , for every two players i, j such that in view i is honest at r and j is honest at r', we have that  <span class="math">|\\mathcal{C}_i^{r&#x27;}(\\mathsf{view})| \\geq |\\mathcal{C}_i^{r}(\\mathsf{view})|</span></li>
      <li>(chain growth) for every round  <span class="math">r \\leq |\\mathsf{view}| t</span> , we have</li>
    </ul>

    <p class="text-gray-300">min-chain-increase<sub><span class="math">$r,t</span><span class="math">&lt;/sub&gt;(view)  </span>\\geq T$ .</p>

    <p class="text-gray-300">In other words,  <span class="math">growth^t</span>  is a predicate which tests that a) honest parties have chains of roughly the same length, and b) during any t rounds in the execution, all honest parties' chains increase by at least T.</p>

    <p class="text-gray-300"><strong>Definition 3.1.</strong> A blockchain protocol  <span class="math">(\\Pi, \\mathcal{C})</span>  has chain growth rate  <span class="math">g(\\cdot, \\cdot, \\cdot, \\cdot)</span>  in &Gamma;-environments if for all &Gamma;-admissible  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> , there exists some constant c and negligible functions  <span class="math">\\epsilon_1, \\epsilon_2</span>  such that for every  <span class="math">\\kappa \\in \\mathbb{N}, T \\geq c \\log(\\kappa)</span> , and  <span class="math">t \\geq \\frac{T}{g(n(\\kappa), \\rho, \\Delta(\\kappa))}</span> , the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa) : \\textit{growth}^t(\\textit{view},\\Delta(\\kappa),T) = 1\\right] \\geq 1 - \\epsilon_1(\\kappa) - \\epsilon_2(T)</span>$</p>

    <p class="text-gray-300">Additionally, if  <span class="math">\\epsilon_1 = 0</span> , we say that  <span class="math">(\\Pi, \\mathcal{C})</span>  has error-less chain growth rate g in  <span class="math">\\Gamma</span> -environments.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Chain Quality</h3>

    <p class="text-gray-300">Our second desideratum is that the number of records contributed by the adversary is proportional to its relative power. This property was first discussed on the Bitcoin forum [mtg10] and made explicit in the selfish mining attacks by Eyal and Sirer [ES14] w.r.t. the bitcoin application of the blockchain. The property was first formalized, and given the name &quot;chain quality&quot; by Garay et al [GKL15]. We generalize their definition to abstract blockchain protocols. Doing so is somewhat non-trivial in that it is not directly clear what it means for a record to be adversarial (Garay et al [GKL15] only provide a definition of an adversarial block for the particular protocol of Nakamoto, and their definition only applies in the random oracle model).</p>

    <p class="text-gray-300">We say that a record m is non-adversarial (or honest) w.r.t. view and prefix  <span class="math">\\vec{m}</span>  if there exists a player j and some round r' such that in viewr', j is honest, the environment provided m as input to j, and  <span class="math">\\vec{m}</span>  is a prefix of  <span class="math">C_i(\\text{view}^{r&#x27;})</span> . (That is, there exists some honest player that received m as an input when their chain contained  <span class="math">\\vec{m}</span> ).</p>

    <p class="text-gray-300">Let quality<sup>T</sup>(view,  <span class="math">\\mu</span> ) = 1 iff for every round r and every player i such that i is honest in view<sup>r</sup>, among any consecutive sequence of T records M in  <span class="math">C_i^r</span> (view), the fraction of records m that are honest w.r.t. view<sup>r</sup> and  <span class="math">\\vec{m}</span> , where  <span class="math">\\vec{m}</span>  is the prefix of  <span class="math">C_i^r</span> (view) preceding M, is at least  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300"><strong>Definition 3.2.</strong> A blockchain protocol  <span class="math">(\\Pi, \\mathcal{C})</span>  has chain quality  <span class="math">\\mu(\\cdot, \\cdot, \\cdot, \\cdot)</span>  in  <span class="math">\\Gamma</span>  environments, if for all  <span class="math">\\Gamma</span> -admissible  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> , there exists some constant c and negligible functions  <span class="math">\\epsilon_1, \\epsilon_2</span>  such that for every  <span class="math">\\kappa \\in \\mathbb{N}, T &gt; c \\log(\\kappa)</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa): \\textit{quality}^T(\\textit{view},\\mu(\\kappa,n(\\kappa),\\rho,\\Delta(\\kappa))) = 1\\right] \\geq 1 - \\epsilon_1(\\kappa) - \\epsilon_2(T)</span>$</p>

    <p class="text-gray-300">Additionally, if  <span class="math">\\epsilon_1 = 0</span> , we say that  <span class="math">(\\Pi, \\mathcal{C})</span>  has errorless chain quality  <span class="math">\\mu</span>  in  <span class="math">\\Gamma</span> -environments.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup>In the bitcoin application of the blockchain, each player receives a reward whenever if mines a block; the chain quality thus dictates a bound on how much more reward an adversary can get by deviating from the protocol.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Consistency</h3>

    <p class="text-gray-300">The common-prefix property by Garay et al [GKL15], which was already considered and studied by Nakamoto [Nak08], requires that in any round r, the record chains of any two honest players i, j agree on all, but potentially the last T, records. We note that this property (even in combination with the other two desiderata) provides quite weak guarantees: even if any two honest parties perfectly agree on the chains, the chain could be completely different on, say, even rounds and odd rounds. We here consider a stronger notion of consistency which additionally stipulates players should be consistent with their &quot;future selves&quot;.  <span class="math">^{10}</span></p>

    <p class="text-gray-300">Let consistent<sup>T</sup>(view) = 1 iff for all rounds  <span class="math">r \\leq r&#x27;</span> , and all players i, j (potentially the same) such that i is honest at view<sup>r</sup> and j is honest at view<sup>r'</sup>, we have that the prefixes of  <span class="math">\\mathcal{C}_i^r(\\text{view})</span>  and  <span class="math">\\mathcal{C}_j^{r&#x27;}(\\text{view})</span>  consisting of the first  <span class="math">\\ell = |\\mathcal{C}_i^r(\\text{view})| - T</span>  records are identical.<sup>11</sup></p>

    <p class="text-gray-300"><strong>Definition 3.3.</strong> A blockchain protocol  <span class="math">(\\Pi, \\mathcal{C})</span>  satisfies consistency in  <span class="math">\\Gamma</span>  environments, if for all  <span class="math">\\Gamma</span> -admissible  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> , there exists some constant c and negligible functions  <span class="math">\\epsilon_1, \\epsilon_2</span>  such that for every  <span class="math">\\kappa \\in \\mathbb{N}, T &gt; c \\log(\\kappa)</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa) : \\textit{consistent}^T(\\textit{view}) = 1\\right] \\geq 1 - \\epsilon_1(\\kappa) - \\epsilon_2(T)</span>$</p>

    <p class="text-gray-300">Additionally, if  <span class="math">\\epsilon_1 = 0</span> , we say that  <span class="math">(\\Pi, \\mathcal{C})</span>  has errorless consistency in  <span class="math">\\Gamma</span> -environments.</p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that the chain length of any two honest players can differ by at most T (except with negligible probability in T).</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Chain Growth Upperbound</h3>

    <p class="text-gray-300">Our final desiderata is the existence of an <em>upperbound on the chain growth</em>. While we do not present any applications of this property in the current paper, it is an intuitively useful property&mdash;for instance, combined with the chain growth lower bound, it implies we can use a blockchain as a &quot;partially-synchronized clock&quot;. (Additionally, subsequent work by Pass and Shi [PS16a, PS16b] demonstrate the usefulness of this property.)</p>

    <p class="text-gray-300">Let.</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{max\\text{-}chain\\text{-}increase}_{r,t}(\\mathsf{view}) = \\max_{i,j} |\\mathcal{C}_j^{r+t}(\\mathsf{view})| - |\\mathcal{C}_i^r(\\mathsf{view})|</span>$</p>

    <p class="text-gray-300">where we quantify over players i, j such that i is honest at  <span class="math">\\mathsf{view}^r</span>  and j is honest at  <span class="math">\\mathsf{view}^{r+t}</span> . Let  <span class="math">\\mathsf{upper-growth}^t(\\mathsf{view}, \\Delta, T) = 1</span>  iff for every round  <span class="math">r \\leq |\\mathsf{view}| - t</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\max</span>$
-chain-increase<sub>r,t</sub>(view)  <span class="math">\\leq T</span> .</p>

    <p class="text-gray-300"><strong>Definition 3.4.</strong> A blockchain protocol  <span class="math">(\\Pi, \\mathcal{C})</span>  has upper-bound on chain growth rate  <span class="math">g&#x27;(\\cdot, \\cdot, \\cdot, \\cdot)</span>  in &Gamma;-environments if for all &Gamma;-admissible  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> , there exists some constant c and negligible functions  <span class="math">\\epsilon_1, \\epsilon_2</span>  such that for every  <span class="math">\\kappa \\in \\mathbb{N}, T \\geq c \\log(\\kappa)</span> , and  <span class="math">t = \\frac{T}{g&#x27;(n(\\kappa), \\rho, \\Delta(\\kappa))}</span> , the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa) : \\textit{upper-growth}^t(\\textit{view},\\Delta(\\kappa),T) = 1\\right] \\geq 1 - \\epsilon_1(\\kappa) - \\epsilon_2(T)</span>$</p>

    <p class="text-gray-300">Additionally, if  <span class="math">\\epsilon_1 = 0</span> , we say that  <span class="math">(\\Pi, \\mathcal{C})</span>  has error-less upper-bound on chain growth rate g' in  <span class="math">\\Gamma</span> -environments.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{10}&lt;/sup&gt;</span> This stronger notion of consistency combines what we called &quot;plain&quot; consistency and &quot;future-self&quot; consistency in the introduction.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup>Pedantically, the &quot;first  <span class="math">\\ell</span>  records of  <span class="math">C_j^{r&#x27;}</span>  (view) is not defined if  <span class="math">C_j^{r&#x27;}</span>  (view)  <span class="math">&lt; \\ell</span> ; to formalize it, we may represent the chains as infinite sequences of records, where all records after the end of the chain is a special &quot;nil&quot; symbol. In particular, this ensures that consistent T (view) = 0 if  <span class="math">C_j^{r&#x27;}</span>  (view)  <span class="math">&lt; \\ell</span> .</p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">3.5 Some Remarks on T v.s. <span class="math">\\kappa</span></h3>

    <p class="text-gray-300">Our definitions of the above properties are quite strong in the sense that we require the probability of &quot;bad&quot; events happening to decrease exponentially with T, even for  <span class="math">small\\ T &gt; c\\log \\kappa</span> . A simpler definition of an abstract blockchain would require the above definitions to hold when  <span class="math">T \\geq T_0(\\kappa)</span> , where  <span class="math">T_0</span>  is some polynomial, in this case, we may simply require that the probability of the bad event is  <span class="math">neg(\\kappa)</span> .</p>

    <p class="text-gray-300">The reason we here distinguish between T and  <span class="math">\\kappa</span>  (and in particular, require the above definitions to hold when T is small) is that we aim to use the definitions to analyze Nakamoto's specific blockchain protocol, and real-life instantiations of it typically consider quite different settings of values of  <span class="math">\\kappa</span>  and T; for instance, in the Bitcoin application, we are interested in achieving T-consistency for T=6 (i.e., transactions are only considered confirmed when they appear at depth 6 in the chain), but  <span class="math">\\kappa</span>  is typically 128.</p>

    <p class="text-gray-300">We emphasize, however, that if our goal is to study optimal parameters (for e.g., consistency and chain quality), the more general notion seems more appropriate.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Main Theorem Statements</h2>

    <p class="text-gray-300">Our main results will be most convenient to parameterize in the following two quantities (which are defined for some fixed mining hardness function  <span class="math">p(\\cdot)</span> ; recall that Nakamoto's protocol is parametrized by p):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let  <span class="math">\\alpha(\\kappa, n, \\rho, \\Delta) = 1 (1 p(\\kappa))^{(1-\\rho)n}</span> . That is,  <span class="math">\\alpha</span>  is the probability that <em>some</em> honest player succeeds in mining a block in a round;</li>
      <li>let  <span class="math">\\beta(\\kappa, n, \\rho, \\Delta) = \\rho n p(\\kappa)</span> . That is  <span class="math">\\beta</span>  is the expected number blocks that an attacker can mine in a round.</li>
    </ul>

    <p class="text-gray-300">Whenever  <span class="math">\\kappa, n, \\rho, \\Delta</span>  are clear from the context, we simply write  <span class="math">\\alpha, \\beta</span> . In essence, the quantities capture the per round expected &quot;chain length increase&quot; by the honest parties and the adversary; the reason the quantities are defined differently is that we assume that the adversary can sequentialize its queries in a round, whereas honest players make a single parallel query (they each act independently), and thus even if they manage to mine several blocks, the longest chain held by honest players can increase by at most 1. Note, however, that when p is small (in comparison to 1/n), which is case for the Bitcoin protocol,  <span class="math">\\alpha</span>  is well approximated by  <span class="math">(1-\\rho)np</span>  and thus  <span class="math">\\frac{\\alpha}{\\beta} \\approx \\frac{1-\\rho}{\\rho}</span> , so this difference is minor.</p>

    <p class="text-gray-300">We will also consider the following quantity:</p>

    <p class="text-gray-300">&bull; let
<span class="math">$\\gamma(\\kappa, n, \\rho, \\Delta) = \\frac{\\alpha}{1 + \\Delta \\alpha}</span>$</p>

    <p class="text-gray-300">(Again, whenever  <span class="math">\\kappa, n, \\rho, \\Delta</span>  are clear from the context, we simply write  <span class="math">\\gamma</span> .) Roughly speaking,  <span class="math">\\gamma</span>  should be thought of a &quot;discounted&quot; version of  <span class="math">\\alpha</span>  due to the fact that messages sent by honest parties can be delayed by  <span class="math">\\Delta</span>  rounds and this may lead to honest players &quot;redoing work&quot;;  <span class="math">\\gamma</span>  corresponds to their &quot;effective&quot; mining power. Note that if p is sufficiently small then  <span class="math">\\gamma \\approx \\alpha</span>  and thus  <span class="math">\\frac{\\gamma}{\\beta} \\approx \\frac{1-\\rho}{\\rho}</span> .</p>

    <p class="text-gray-300">We are now ready to state our main theorems. We will consider two environments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the least restrictive environment,  <span class="math">\\Gamma^0</span> , we make <em>no restrictions</em> on the parameters (more than them being &quot;valid&quot;). Namely, let  <span class="math">\\Gamma_0(n(\\cdot), \\rho, \\Delta(\\cdot)) = 1</span>  iff  <span class="math">n(\\cdot), \\Delta(\\cdot)</span>  are functions  <span class="math">\\mathcal{N} \\to \\mathcal{N}^+</span>  and  <span class="math">0 \\le \\rho \\le 1</span> .</li>
      <li>In the more restrictive environment, we additionally assume that the adversary controls a sufficiently small fraction of the computational power. Let  <span class="math">\\Gamma^p_{\\lambda}(n(\\cdot), \\rho, \\Delta(\\cdot)) = 1</span>  iff  <span class="math">\\Gamma_0(n(\\cdot), \\rho, \\Delta(\\cdot)) = 1</span>  and for all  <span class="math">\\kappa, n = n(\\kappa), \\Delta = \\Delta(k)</span> ,</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\alpha(1 - 2(\\Delta + 1)\\alpha) \\ge \\lambda\\beta</span>$</p>

    <p class="text-gray-300">The following three theorems formalize Theorem 1.2 from the introduction (which in turn implies Theorem 1.1). We first prove a lower-bound on the chain growth.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong> (Chain growth). For any  <span class="math">\\delta &gt; 0</span> , any  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{Nak}, \\mathcal{C}^p_{nak})</span>  has chain growth rate</p>

    <p class="text-gray-300"><span class="math">$g_{\\delta}^{p}(\\kappa, n, \\rho, \\Delta) = (1 - \\delta)\\gamma</span>$</p>

    <p class="text-gray-300">in  <span class="math">\\Gamma_0</span>  environments.</p>

    <p class="text-gray-300">We next prove a lowerbound on the chain quality.</p>

    <p class="text-gray-300"><strong>Theorem 4.2</strong> (Chain quality). For all  <span class="math">\\delta &gt; 0</span> , any  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{Nak}, \\mathcal{C}^p_{nak})</span>  has chain quality</p>

    <p class="text-gray-300"><span class="math">$\\mu^p_\\delta(\\kappa,n,\\rho,\\Delta) = 1 - (1+\\delta)\\frac{\\beta}{\\gamma}</span>$</p>

    <p class="text-gray-300">in  <span class="math">\\Gamma_0</span>  environments.</p>

    <p class="text-gray-300">We finally show consistency.</p>

    <p class="text-gray-300"><strong>Theorem 4.3</strong> (Consistency). For any  <span class="math">\\lambda &gt; 1</span> , any  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{nak}, \\mathcal{C}^p_{nak})</span>  satisfies consistency in  <span class="math">\\Gamma^p_{\\lambda}</span>  environments.</p>

    <p class="text-gray-300">Chain growth upperbound We additionally present an upperbound on the the chain growth. (As mentioned before, this property is not needed for any of the applications that we present in the current paper, nor for the statement of the main result in the introduction, but may be useful in other contexts (and indeed, subsequent work [PS16a, PS16b] show its usefulness).)</p>

    <p class="text-gray-300"><strong>Theorem 4.4</strong> (Upperbound on Chain growth). For any  <span class="math">\\delta &gt; 0</span> , any  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{Nak}, \\mathcal{C}^p_{nak})</span>  has upperbound on chain growth rate</p>

    <p class="text-gray-300"><span class="math">$\\hat{g}^p_{\\delta}(\\kappa, n, \\rho, \\Delta) = (1 + \\delta)np</span>$</p>

    <p class="text-gray-300">in  <span class="math">\\Gamma^p_{\\lambda}</span>  environments.</p>

    <p class="text-gray-300">We prove these theorems in the following two sections.</p>

    <p class="text-gray-300">Towards proving that Nakamoto's protocol satisfies the above properties, we first show that it suffices to prove these properties for a simplified protocol having access to an &quot;idealized tree&quot; functionality,  <span class="math">\\mathcal{F}_{tree}</span> , instead of a random oracle.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 The <span class="math">\\mathcal{F}_{tree}</span> Oracle</h3>

    <p class="text-gray-300">This  <span class="math">\\mathcal{F}^p_{tree}</span>  functionality is parameterized by a hardness parameter p and keeps track of &quot;valid chains&quot; of records through a tree. Upon initialization, the tree contains just the root&mdash;a special genesis record  <span class="math">\\bot</span> . Upon receiving a message Tree.extend( <span class="math">(\\mathsf{m}_1,\\ldots,\\mathsf{m}_{\\ell-1}),\\mathsf{m}</span> ), it checks whether  <span class="math">\\mathsf{m}_1,\\ldots,\\mathsf{m}_{\\ell-1}</span>  is a path on the tree it keeps track of, and if so, with probability  <span class="math">p(\\kappa)</span> , extends this path in the tree with the record  <span class="math">\\mathsf{m}</span>  (unless it was already part of the tree) and returns 1, and otherwise, returns 0. Upon receiving a message Tree.ver( <span class="math">m_1,\\ldots,\\mathsf{m}_\\ell</span> ) from player i,  <span class="math">\\mathcal{F}_{tree}</span>  return 1 if  <span class="math">(\\mathsf{m}_1,\\ldots,\\mathsf{m}_\\ell)</span>  is a path in the tree it keeps track of, and 0 otherwise. In analogy with how  <span class="math">\\mathsf{H}</span>  is treated, we allow each honest party to make a single query to Tree.extend per round, and the adversary controlling q parties is allowed to make q sequential queries to Tree.extend. In analogy with how  <span class="math">\\mathsf{H}</span> .ver is treated, we allow parties (honest or corrupted) to make any number of queries to Tree.ver per round. Whenever p is clear from context, we simply denote the functionality  <span class="math">\\mathcal{F}_{tree}</span> .</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Nakamoto in the <span class="math">\\mathcal{F}_{tree}</span> -hybrid</h3>

    <p class="text-gray-300">We now define a version of Nakamoto's protocol  <span class="math">(\\Pi^p_{Nak}, \\mathcal{C}^p_{nak})</span>  in the  <span class="math">\\mathcal{F}^p_{tree}</span> -hybrid model. Essentially, this protocol replaces the random oracle with calls to  <span class="math">\\mathcal{F}^p_{tree}</span> . state is initialized to just  <span class="math">\\bot</span>  (i.e., the genesis record). Let  <span class="math">\\mathcal{C}_{\\mathsf{tree}}(\\mathsf{state}) = \\mathsf{state}</span>  (i.e., the state of a player is now simply the sequence of records, as opposed to blocks). Let  <span class="math">\\Pi^p_{\\mathsf{tree}}</span>  be  <span class="math">\\Pi^p_{Nak}</span>  with the exception that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When a player is trying to add a new record m to their current state state, instead of trying to &quot;mine&quot; it by picking a random nonce n etc, the player simply calls Tree.extend(state, m) and if it gets back the answer 1, it adds m to state and broadcasts (the whole updated chain) state.</li>
      <li>Upon receiving a message state' from some other player, instead of checking whether it is &quot;valid&quot; using H.ver, simply check validity using Tree.ver(state').</li>
    </ul>

    <p class="text-gray-300">Whenever p is clear from context we simply denote the protocol  <span class="math">(\\Pi_{\\mathsf{tree}}, \\mathcal{C}_{\\mathsf{tree}})</span> .</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Reducing the security of <span class="math">(\\Pi_{\\text{tree}}, \\mathcal{C}_{\\text{tree}})</span> to the security of <span class="math">(\\Pi_{Nak}, \\mathcal{C}_{Nak})</span></h3>

    <p class="text-gray-300">We now show that if our three desiderata hold w.r.t.  <span class="math">(\\Pi_{\\mathsf{tree}}, \\mathcal{C}_{\\mathsf{tree}})</span> , then they also hold w.r.t.  <span class="math">(\\Pi_{Nak}, \\mathcal{C}_{Nak})</span> . In fact, we show something stronger:  <span class="math">(\\Pi_{Nak}, \\mathcal{C}_{Nak})</span>  is as &quot;secure as&quot;  <span class="math">(\\Pi_{\\mathsf{tree}}, \\mathcal{C}_{\\mathsf{tree}})</span>  w.r.t. any property that is a function of the view of the environment (which is the case for the properties in our desiderata&mdash;more formally, for any  <span class="math">g, \\mu</span> , growth(view, g), quality(view,  <span class="math">\\mu</span> ) and consistent(view) are only of function of the view of Z in view).</p>

    <p class="text-gray-300">Let  <span class="math">view_Z(view)</span>  denote the view of Z in the (full) view view.</p>

    <p class="text-gray-300"><strong>Lemma 5.1.</strong> For every non-uniform PPT A, there exists a non-uniform PPT A' such that for every  <span class="math">V, \\Gamma</span>  such that if  <span class="math">n(\\cdot), \\rho, \\Delta(\\cdot), A, Z</span>  is  <span class="math">\\Gamma</span> -admissible w.r.t.  <span class="math">(\\Pi^V_{Nak}, \\mathcal{C}_{Nak})</span> , it holds that  <span class="math">n(\\cdot), \\rho, \\Delta(\\cdot), A&#x27;, Z</span>  is  <span class="math">\\Gamma</span> -admissible w.r.t.  <span class="math">(\\Pi^V_{tree}, \\mathcal{C}_{tree})</span>  and the following ensembles are statistically close</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ \\{\\mathit{view}_Z(\\mathit{EXEC}^{(\\Pi^V_{Nak},\\mathcal{C}_{Nak})}(A,Z,\\kappa))\\}_{\\kappa \\in \\mathbb{N}}</span></li>
      <li><span class="math">\\{\\mathit{view}_Z(\\mathit{EXEC}^{(\\Pi^V_{\\mathit{tree}},\\mathcal{C}_{\\mathit{tree}})}(A&#x27;,Z,\\kappa))\\}_{\\kappa\\in\\mathbb{N}}.</span></li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> Consider some non-uniform PPT adversary A for  <span class="math">(\\Pi_{Nak}^V, \\mathcal{C}_{Nak})</span> . We construct a non-uniform PPT A' that proceeds as follows on input  <span class="math">1^{\\kappa}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A' maintains a table  <span class="math">T = \\{(x_i, y_i)\\}_i</span>  of random oracle queries  <span class="math">x_i</span>  and answers  <span class="math">y_i</span> . Initially, the table contains only the pair  <span class="math">((0, 0, \\bot), h_0)</span>  where  <span class="math">h_0</span>  is a uniformly random string in  <span class="math">\\{0, 1\\}^{\\kappa}</span> . If A' ever attempts to add a pair (x', y) that &quot;collides&quot; with a pair (x, y) already in T, A' aborts and outputs collision.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever A makes a  <span class="math">\\mathsf{H.ver}(x,y)</span>  query, return 1 if  <span class="math">(x,y) \\in T</span>  (and otherwise 0). We define validity of a chain of blocks  <span class="math">(\\mathsf{b}_0,\\ldots,\\mathsf{b}_\\ell)</span>  in exactly the same way as in the random oracle model (See Section 2.4), with the exception that any &quot; <span class="math">\\mathsf{H.ver}(x,y)</span>  check&quot; is replaced by a &quot; <span class="math">(x,y) \\in T</span> &quot; check.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever A makes a H(x) query:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Check whether there exists some record  <span class="math">(x,y) \\in T</span>  and if so return y to A; otherwise continue.</li>
    </ul></li>
      <li><p class="text-gray-300">(b) If x is of the form  <span class="math">(h_{\\ell-1}, \\eta_{\\ell}, \\mathsf{m}_{\\ell})</span>  such that there exists a &quot;valid chain of blocks&quot;  <span class="math">\\vec{\\mathsf{b}} = (\\mathsf{b}_0, \\ldots, \\mathsf{b}_{\\ell-1})</span>  where the 4'th component of  <span class="math">\\mathsf{b}_{\\ell-1}</span>  equals  <span class="math">h_{\\ell-1}</span>  (this can be determined in polynomial time by &quot;tracing&quot; back from  <span class="math">h_{\\ell-1}</span>  using the table T, assuming there are no &quot;collisions&quot;) proceed as follows. Let  <span class="math">\\vec{\\mathsf{m}}</span>  denote the records contained in the sequence of blocks  <span class="math">\\vec{\\mathsf{b}}</span> . If Tree.ver( <span class="math">\\vec{\\mathsf{m}}</span> )  <span class="math">\\neq 1</span>  abort outputting tree-failure. If Tree.extend( <span class="math">\\vec{\\mathsf{m}}</span> ,  <span class="math">\\mathsf{m}_{\\ell}</span> ) outputs 1, pick y uniformly at random from  <span class="math">\\{0,1\\}^{\\kappa}</span>  conditioned on  <span class="math">y &lt; D_p</span>  (this event happens w.p. p so it can be done efficiently with rejection sampling), and otherwise pick y uniformly at random from  <span class="math">\\{0,1\\}^{\\kappa}</span>  conditioned on  <span class="math">y \\geq D_p</span> . Store (x,y) in T and return y.</p></li>
      <li><p class="text-gray-300">(c) Otherwise, pick y uniformly at random from  <span class="math">\\{0,1\\}^{\\kappa}</span> , store (x,y) in T and return y.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever A wants to deliver a message  <span class="math">\\vec{b}</span>  to an honest player j such that  <span class="math">\\vec{b}</span>  is a valid chain of blockss, deliver  <span class="math">\\vec{m}</span>  to j, where  <span class="math">\\vec{m}</span>  is the record sequence contained in  <span class="math">\\vec{b}</span> . All other messages are dropped.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever an honest party j attempts to broadcast a chain of records  <span class="math">\\vec{m} = (\\bot, m_1, \\ldots, m_\\ell)</span> , replace it by a chain of blocks  <span class="math">\\vec{b}</span>  and relay it to A, where  <span class="math">\\vec{b}</span>  is computed as follows:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Compute  <span class="math">b_0, \\ldots, b_{\\ell-1}</span>  as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. If  <span class="math">\\ell &lt; 1</span>  (i.e., the chain is of length 0 or 1), abort outputting chain-length-failure.</li>
      <li>ii. If  <span class="math">\\ell=1</span>  (i.e., the chain is of length 2) , let  <span class="math">b_0=(0,0,\\perp,h_0).</span></li>
      <li>iii. If  <span class="math">\\ell &gt; 1</span> , let  <span class="math">(b_0, \\ldots, b_{\\ell-1})</span>  be longest valid chain that A previously received from, or delivered to j; if there are two such chains, we break ties by giving a preference to received messages (over delivered ones), and to earlier messages (over later ones). If no such chain exists, abort outputting no-chain-found.</li>
    </ul></li>
      <li>(b) Compute  <span class="math">b_{\\ell}</span>  as follows: Pick  <span class="math">h_{\\ell}</span>  uniformly at random from  <span class="math">\\{0,1\\}^{\\kappa}</span>  conditioned on  <span class="math">h_{\\ell} &lt; D_p</span> , pick  <span class="math">\\eta_{\\ell}</span>  uniformly at random from  <span class="math">\\{0,1\\}^{\\kappa}</span> , add  <span class="math">((h_{\\ell-1},\\eta_{\\ell},\\mathsf{m}_{\\ell}),h_{\\ell})</span>  to T (where  <span class="math">h_{\\ell-1}</span>  is the last component of  <span class="math">b_{\\ell-1}</span> ), and let  <span class="math">b_{\\ell} = (h_{\\ell-1},\\eta_{\\ell},\\mathsf{m}_{\\ell},h_{\\ell})</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever an honest party j becomes corrupted, replace its chain of records  <span class="math">\\vec{m}</span>  by a chain of blocks  <span class="math">\\vec{b}</span> , just as in step 5.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Directly relay all messages from Z to A and vice versa.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Now, consider some V, some  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span>  that are  <span class="math">\\Gamma</span> -admissible w.r.t.  <span class="math">(\\Pi^V_{Nak}, \\mathcal{C}_{Nak})</span> . By construction, it directly follows that  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A&#x27;, Z)</span>  is  <span class="math">\\Gamma</span> -admissible w.r.t.  <span class="math">(\\Pi^V_{\\mathsf{tree}}, \\mathcal{C}_{\\mathsf{tree}})</span> .</p>

    <p class="text-gray-300">We now turn to show that  <span class="math">\\{\\mathsf{view}_Z(\\mathsf{EXEC}^{(\\Pi^V_{Nak},\\mathcal{C}_{Nak})}(A,Z,\\kappa))\\}_{\\kappa\\in\\mathcal{N}}</span>  and  <span class="math">\\{\\mathsf{view}_Z(\\mathsf{EXEC}^{(\\Pi^V_{tree},\\mathcal{C}_{\\mathsf{tree}})}(A&#x27;,Z,\\kappa))\\}_{\\kappa\\in\\mathcal{N}}</span>  are statistically close. Towards this goal, we consider a sequence of hybrid experiments.</p>

    <p class="text-gray-300">&bull; Define HYB1 <span class="math">(A, Z, \\kappa)</span>  just like  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_{Nak}, \\mathcal{C}_{Nak})}(A, Z, \\kappa)</span>  except that we simulate the random oracle queries H, H.ver using a table T' as follows: Initially, the table contains only the pair  <span class="math">((0,0,\\bot),h_0)</span>  where  <span class="math">h_0</span>  is a uniformly random string in  <span class="math">\\{0,1\\}^{\\kappa}</span> . Whenever any party makes an  <span class="math">\\mathsf{H}(x)</span>  query such that  <span class="math">(x,y) \\in T&#x27;</span> , return y, and otherwise pick a random  <span class="math">y \\in \\{0,1\\}^{\\kappa}</span> , add (x,y) to T' and return y. H.ver(x,y) queries are answered by checking if  <span class="math">(x,y) \\in T&#x27;</span> .</p>

    <p class="text-gray-300">Note that in  <span class="math">\\mathsf{HYB1}(A, Z, \\kappa)</span> , all H queries return a perfectly random string, and H.ver queries are answered as a function of H queries. In contrast, in  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_{Nak}, \\mathcal{C}_{Nak})}(A, Z, \\kappa)</span> , H.ver queries can (slightly) skew the distribution of an H query. This gap in statistical distance, however, is negligible. Let bad0 denote the event that some  <span class="math">\\mathsf{H.ver}(x,\\cdot)</span>  query returns 1, yet no party has previously called  <span class="math">\\mathsf{H}(x)</span> . Note that conditioned on bad0 not happening, the answer to every individual  <span class="math">\\mathsf{H}(x)</span>  query is statistically close to uniform (we sample uniformly at random from</p>

    <p class="text-gray-300">a set  <span class="math">\\{0,1\\}^{\\kappa}\\setminus \\mathbf{W}</span>  where  <span class="math">\\mathbf{W}</span>  is some set of polynomial size&mdash;namely,  <span class="math">\\mathbf{W}</span>  is the set of outputs y for which the emulation up until this point of  <span class="math">\\mathsf{H.ver}(x,y)</span>  gave the answer 0). By a hybrid argument, we have that conditioned on bad0 not happening, the answers to all  <span class="math">\\mathsf{H}</span>  queries are statistically close to uniform; additionally, under the same conditioning, the answer to all  <span class="math">\\mathsf{H.ver}</span>  queries are just a function of what  <span class="math">\\mathsf{H}</span>  queries have been made. It follows that conditioned on bad0 not happening,  <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span>  is statistically close to  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_{Nak},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span> . Finally, by union bound over all queries we have that the probability of bad0 happening in either  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_{Nak},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span>  or  <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span>  is bounded by  <span class="math">poly(\\kappa) \\cdot 2^{-\\kappa}</span>  and we thus conclude that  <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span>  is statistically close to  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_{Nak},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span> .</p>

    <p class="text-gray-300">&bull; Define  <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span>  just like  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_{Nak},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span>  except that we simulate the oracle queries  <span class="math">\\mathsf{H},\\mathsf{H}.\\mathsf{ver}</span>  using the table T used by A' (in the same way as A' simulates the answers to those queries for A), as opposed to using the table T' used in  <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> ; note that the only differences between these methods is that in the emulation using T, we may also abort outputting collision or tree-failure.</p>

    <p class="text-gray-300">Let bad1 denote the event that some player makes an  <span class="math">\\mathsf{H}(h_{-1},\\cdot,\\cdot)</span> , or  <span class="math">\\mathsf{H.ver}((h_{-1},\\cdot,\\cdot),\\cdot)</span>  query without any player ever having received  <span class="math">h_{-1}</span>  as the answer to some  <span class="math">\\mathsf{H}</span>  query, but then, later, some player does receive  <span class="math">h_{-1}</span>  as the answer to some  <span class="math">\\mathsf{H}</span>  query. We note that the probability of bad1 happening in either  <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span>  or  <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span>  is negligible: for any query  <span class="math">(h_{-1},n,b)</span> , the probability of any subsequent  <span class="math">\\mathsf{H}</span>  query returning  <span class="math">h_{-1}</span>  is  <span class="math">2^{-\\kappa}</span> , and thus by a union bound, with probability  <span class="math">poly(\\kappa) \\cdot 2^{-\\kappa}</span> , no subsequent query (that was not already asked before) will output  <span class="math">h_{-1}</span> ; finally, the claim follows by another union bound over all queries  <span class="math">(h_{-1},n,\\mathsf{m})</span>  made during the execution.</p>

    <p class="text-gray-300">Let bad2 denote the event that some (possibly the same) players query two different x, x' such that H(x) = H(x'). It follows by a similar (but slightly simpler) argument that the probability of this event happening in either  <span class="math">\\mathsf{HYB1}(A, Z, \\kappa)</span>  or  <span class="math">\\mathsf{HYB2}(A, Z, \\kappa)</span>  is negligible. Note that we trivially have that if bad2 does not happen,  <span class="math">\\mathsf{HYB2}(A, Z, \\kappa)</span>  does not abort outputting collision.</p>

    <p class="text-gray-300">Let us argue that conditioned on bad1 and bad2 not happening, HYB2( <span class="math">A, Z, \\kappa</span> ) also does not abort outputting tree-failure. Assume for contradiction that the experiment aborts outputting tree-failure conditioned on bad1 and bad2 not happening. Let  <span class="math">(b_0, \\ldots, b_\\ell)</span>  s.t.  <span class="math">b_i = (h_{i-1}, \\eta_i, \\mathsf{m}_i, h_i)</span>  be the shortest valid chain (obtained in the emulation of H) such that Tree.ver <span class="math">(\\mathsf{m}_0, \\ldots, \\mathsf{m}_{\\ell-1}) = 1</span>  but Tree.ver <span class="math">(\\mathsf{m}_0, \\ldots, \\mathsf{m}_\\ell) \\neq 1</span> . Since  <span class="math">\\vec{m}</span>  is valid, we have that the pair  <span class="math">((h_{\\ell-1}, \\eta_{\\ell-1}, \\mathsf{m}_{\\ell-1}), h_{\\ell-1}) \\in T</span> , but at the time when it was added to T (through an H query), there was no valid chain that ended with  <span class="math">h_{\\ell-1}</span>  (or else the whole chain would have been in the tree). This means that there could not have been any earlier H queries that returned  <span class="math">h_{\\ell-1}</span> , since a) if the query was  <span class="math">(h_{\\ell-2}, \\eta_{\\ell-2}, \\mathsf{m}_{\\ell-2})</span>  then  <span class="math">\\vec{b}</span>  could not have been the shortest chain with the above properties, and b) if the query was not  <span class="math">(h_{\\ell-2}, \\eta_{\\ell-2}, \\mathsf{m}_{\\ell-2})</span>  then event bad2 must happen. We conclude that event bad1 must have happened, which is a contradiction.</p>

    <p class="text-gray-300">It follows that conditioned on bad1 and bad2 not happening,  <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span>  proceed identically the same as  <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> : the answers to all H queries x are answered independently and uniformly at random (and H.ver queries are treated the same way). We conclude that  <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span>  is statistically close to  <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> .</p>

    <p class="text-gray-300">&bull; Define HYB3 <span class="math">(A, Z, \\kappa)</span>  just like HYB2 <span class="math">(A, Z, \\kappa)</span>  except that whenever an honest player fails in a mining operation (i.e., if  <span class="math">h = \\mathsf{H}(h_{-1}, n, \\mathsf{m}) \\geq D_p</span> ), we do not store the pair  <span class="math">(h_{-1}, n, \\mathsf{m}), h</span> ) in T. Note that conditioned on the event that such &quot;failed queries&quot; x are never queried again (by either honest parties or A), we have that  <span class="math">\\mathsf{HYB2}(A, Z, \\kappa)</span>  and  <span class="math">\\mathsf{HYB3}(A, Z, \\kappa)</span>  are identically distributed. Since the nonce n inside every failed query x is randomly selected in  <span class="math">\\{0,1\\}^{\\kappa}</span> ,</p>

    <p class="text-gray-300">it follows that except with probability  <span class="math">poly(\\kappa) \\cdot 2^{-\\kappa}</span> , x is different from every earlier query; additionally, since an honest party discards every failed query (and never communicates it to anyone), we additionally have that except with probability  <span class="math">poly(\\kappa) \\cdot 2^{-\\kappa}</span> , x is also different from every later query. Finally, by a union bound over all (failed) query, we have that except with the probability  <span class="math">poly(\\kappa) \\cdot 2^{-\\kappa}</span> , failed queries of an honest player are never queried twice. We conclude that  <span class="math">\\mathsf{HYB3}(A, Z, \\kappa)</span>  is statistically close to  <span class="math">\\mathsf{HYB2}(A, Z, \\kappa)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define HYB4 <span class="math">(A, Z, \\kappa)</span>  just like HYB3 <span class="math">(A, Z, \\kappa)</span>  except that honest parties now run  <span class="math">\\Pi_{\\mathsf{tree}}</span>  (as opposed to  <span class="math">\\Pi_{Nak}</span> ) but first process incoming and outgoing messages exactly as A' does them for A in Step 4 and 5 (and we update T in exactly the same way). Note that it follows from the definition of the honest party strategy that the experiment never aborts outputting chainlength-failure or no-chain-found (honest players start of with a chain of length 1, containing the genesis block, and only broadcast a chain once they have increased their chain length, thus will never broadcast a chain of length &lt; 2 so chain-length-failure does not happen; they will only broadcast a chain of length  <span class="math">\\ell&#x27; &gt; 2</span>  if they have previously received, or broadcast, a chain of length  <span class="math">\\ell&#x27;-1</span> , thus no-chain-found does not happen.) Additionally, it follows from the definition of the honest party strategies that both T and all messages and &quot;observable states&quot; (i.e., the record chains) of honest parties are updated in exactly the same way in  <span class="math">\\mathsf{HYB4}(A,Z,\\kappa)</span>  and  <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span> .  <span class="math">\\mathsf{HYB4}(A,Z,\\kappa)</span>  and  <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span>  are not identical (or even statistically close) since a) in HYB4 <span class="math">(A, Z, \\kappa)</span>  honest parties have less (none) H queries in their view, and b) their local variable state is different; but since everything else in the experiment proceeds the same (and in particular, the &quot;projection&quot;  <span class="math">\\mathcal{C}(\\mathsf{state})</span>  seen by the environment) is identically distributed, we have that  <span class="math">\\mathsf{view}_Z(\\mathsf{HYB4}(A,Z,\\kappa))</span>  is identically distributed to  <span class="math">\\mathsf{view}_Z(\\mathsf{HYB3}(A, Z, \\kappa))</span></li>
      <li>HYB4 <span class="math">(A,Z,\\kappa)</span>  is just an rephrasing of the experiment  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_\\mathsf{tree},\\mathcal{C}_\\mathsf{tree})}(A&#x27;,Z,\\kappa)</span>  where we push operations &quot;performed by the experiment&quot; into the players. It follows that  <span class="math">\\mathsf{view}_Z(\\mathsf{HYB4}(A,Z,\\kappa))</span>  is identically distributed to  <span class="math">\\mathsf{view}_Z(\\mathsf{EXEC}^{(\\Pi^V_\\mathsf{tree},\\mathcal{C}_\\mathsf{tree})}(A&#x27;,Z,\\kappa))</span>  (note however that the views of the players are different since they perform different oracle operations).</li>
    </ul>

    <p class="text-gray-300">We conclude that  <span class="math">\\mathsf{view}_Z(\\mathsf{EXEC}^{(\\Pi^V_{Nak},\\mathcal{C}_{Nak})}(A,Z,\\kappa))</span>  and  <span class="math">\\mathsf{view}_Z(\\mathsf{EXEC}^{(\\Pi^V_{\\mathsf{tree}},\\mathcal{C}_{\\mathsf{tree}})}(A&#x27;,Z,\\kappa))</span>  are statistically close, which concludes the proof of the theorem</p>

    <p class="text-gray-300">In this section, we finally prove Theorems 4.1, 4.2 and 4.3. By Lemma 5.1, it will suffice to prove them w.r.t. ( <span class="math">\\Pi_{\\mathsf{tree}}, \\mathcal{C}_{\\mathsf{tree}}</span> ). We will heavily make use of the (multiplicative) Chernoff bound, which we recall in Appendix A.</p>

    <p class="text-gray-300">Notation Although Nakamoto's protocol in the  <span class="math">\\mathcal{F}_{tree}</span>  hybrid model does not utilize the notion of a &quot;block&quot; or &quot;mining&quot;, for intuition, we still employ those terminologies with the following interpretations. A block b refers to a &quot;path&quot;  <span class="math">\\vec{m}</span> ; such a block b is valid at some point in the execution if b is a path (starting at the root) in the tree maintained by  <span class="math">\\mathcal{F}_{tree}</span> . We say that a block b was mined at round r if in the view view, r is the round in which the block b became valid (i.e., the path b was included in tree). Given a (record) chain  <span class="math">C = (m_0, \\ldots, m_\\ell)</span> , we refer to the blocks in C as sub-paths  <span class="math">m_0, \\ldots, m_k</span>  of C; we say that C is valid at a round r if all the blocks in C are valid at r. We say that chain C was mined at round r if r was the first round in which C became valid. Let REAL( <span class="math">\\sigma</span> ) denote the output of EXEC( <span class="math">\\Pi^V_{tree}, \\mathcal{C}_{tree}</span> )( <span class="math">A&#x27;, Z, \\kappa</span> ) with the randomness of the experiment fixed to  <span class="math">\\sigma</span>  and let REAL = EXEC( <span class="math">\\Pi^V_{tree}, \\mathcal{C}_{tree}</span> )( <span class="math">A&#x27;, Z, \\kappa</span> ).</p>

    <p class="text-gray-300">For the remainder of this section, we consider some fixed  <span class="math">A, Z, n, \\rho, \\Delta</span>  such that (A, Z) is  <span class="math">(n, \\rho, \\Delta)</span> -valid. Unless we explicitly mention it, we also consider some fixed  <span class="math">\\kappa</span> .</p>

    <p class="text-gray-300">An abuse of notation To simplify notation, we abuse of notation and ignore  <span class="math">\\mathsf{poly}(\\kappa)</span>  factors when describing error probabilities such as  <span class="math">\\mathsf{neg}(T)</span>  and  <span class="math">e^{-O(T)}</span> ; that is, when writing  <span class="math">\\mathsf{neg}(T)</span>  or  <span class="math">e^{-O(T)}</span>  we actually meant  <span class="math">\\mathsf{poly}(\\kappa) \\cdot \\mathsf{neg}(T)</span>  or  <span class="math">\\mathsf{poly}(\\kappa) \\cdot e^{-O(T)}</span> ; since our final theorem statements restrict to the case when  <span class="math">T &gt; c \\log \\kappa</span>  for some sufficiently large c, this will suffice to conclude it. We mention that these  <span class="math">\\mathsf{poly}(\\kappa)</span>  factors in the error probability arise from the fact that we often apply a union bound over the number of rounds in the execution (which is bounded by  <span class="math">\\mathsf{poly}(\\kappa)</span> , since Z is polynomial time in  <span class="math">\\kappa</span> ).</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Proof of the Chain-Growth Property (Theorem 4.1)</h3>

    <p class="text-gray-300">The following theorem (which proves chain growth for the protocol in the  <span class="math">\\mathcal{F}_{tree}</span> -hybrid model), combined with Lemma 5.1, yields Theorem 4.1.</p>

    <p class="text-gray-300"><strong>Theorem 6.1.</strong> For any  <span class="math">\\delta &gt; 0</span> ,  <span class="math">(\\Pi^p_{tree}, C^p_{tree})</span>  has (errorless) chain growth rate  <span class="math">g^p_{\\delta}(\\kappa, n, \\rho, \\Delta) = (1-\\delta)\\gamma</span>  in  <span class="math">\\Gamma_0</span>  environments.</p>

    <p class="text-gray-300"><em>Proof.</em> We first observe that the consistent length property holds, and then turn to lower-bounding the chain growth.</p>

    <p class="text-gray-300">Consistent Length The following claim shows that if some honest player has a chain of length  <span class="math">\\ell</span>  at round r, then all other honest players will have a chain of length at least  <span class="math">\\ell</span>  at round  <span class="math">r + \\Delta</span> , which proves the desired consistent length property.</p>

    <p class="text-gray-300">Claim 6.2. If in view, i is honest at r and j is honest at  <span class="math">r + \\Delta</span> , then  <span class="math">|C_i^{r+\\Delta}(\\text{view})| \\geq |C_i^r(\\text{view})|</span></p>

    <p class="text-gray-300"><em>Proof.</em> Due to the fact that all messages are delivered within  <span class="math">\\Delta</span>  steps, we have that whenever some player either receives a chain of length  <span class="math">\\ell</span>  all other honest players will receive the same chain within  <span class="math">\\Delta</span>  step; additionally, whenever an honest player mines a block, it broadcasts it to all other players and they will thus receive it within  <span class="math">\\Delta</span>  steps.</p>

    <p class="text-gray-300">Chain Growth Towards proving the chain growth property, we first consider a hybrid experiment. Let  <span class="math">\\mathsf{HYB}_r(\\sigma)</span>  denote the output of  <span class="math">\\mathsf{EXEC}^{(\\Pi^V_{\\mathsf{tree}},\\mathcal{C}_{\\mathsf{tree}})}(A&#x27;,Z,\\kappa)</span>  with the randomness of the experiment fixed to  <span class="math">\\sigma</span> , where the experiment is modified as follows: after round r, a) fix all messages/actions by Z to be the ones in  <span class="math">\\mathsf{REAL}(\\sigma)</span> ; b) remove all new messages sent by the adversary to honest players, and delay currently undelivered messages from corrupted parties to the maximum of  <span class="math">\\Delta</span>  round; c) delay all messages sent by honest players (that have not already been delivered by round r) to the maximum of  <span class="math">\\Delta</span>  rounds; and d) whenever some message is being delayed, all honest players &quot;freeze&quot; (i.e., stop &quot;mining&quot;) until the message is delivered. Finally, let  <span class="math">\\mathsf{HYB}_r</span>  denote the output of  <span class="math">\\mathsf{HYB}_r(\\sigma)</span>  for a randomly sampled  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">The following lemma shows that the chain of every honest player cannot decrease in length if we maximally delay messages from honest parties, freeze all honest players during this delay, and drop all adversarial messages for every fixed randomness  <span class="math">\\sigma</span> . We emphasize that for this lemma to hold it is crucial that we consider the protocol in the  <span class="math">\\mathcal{F}_{tree}</span>  model and not the random oracle model. Otherwise, there exists randomness  <span class="math">\\sigma</span>  such that if we fixed the randomness of the experiment to  <span class="math">\\sigma</span> , honest parties could end up on a &quot;better path&quot; once we, for example, remove adversarial message. Additionally, to prove this lemma it is important that we fix the messages/actions of Z (which is enabled by us fixing  <span class="math">\\sigma</span> ), or else Z could &quot;help&quot; honest players if it notices that messages from A are delayed.</p>

    <p class="text-gray-300"><strong>Lemma 6.3.</strong> For all  <span class="math">\\sigma</span> ,  <span class="math">r,t \\geq 0</span>  and player j that is honest at round r+t in  <span class="math">REAL(\\sigma)</span> ,  <span class="math">|\\mathcal{C}_{j}^{r+t}(REAL(\\sigma))| \\geq |\\mathcal{C}_{j}^{r+t}(HYB_{r}(\\sigma))|</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Fix some r. We prove the lemma by induction on t. The base case (t=0) is trivial. Assume the lemma holds for all t' &lt; t. We prove it for t. Consider some  <span class="math">\\sigma</span>  and some player j that is honest at round s = r + t in  <span class="math">\\mathsf{REAL}(\\sigma)</span>  and assume for contradiction that  <span class="math">|\\mathcal{C}_j^s(\\mathsf{REAL}(\\sigma))| &lt; |\\mathcal{C}_j^s(\\mathsf{HYB}_r(\\sigma))|</span> . We distinguish between two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>j is corrupted at round s-1 in REAL <span class="math">(\\sigma)</span> : Note that mining at round s is successful in HYB <span class="math">_r(\\sigma)</span> only if it is successful in  <span class="math">REAL(\\sigma)</span> , <sup>12</sup> so the only possibility of j's chain to be longer in at round s in  <span class="math">HYB_r(\\sigma)</span>  is if it started off with a longer chain in  <span class="math">HYB_r(\\sigma)</span> , before it did its mining in this round. We now argue that this is impossible. Since j is honest at round s, j must have been &quot;uncorrupted&quot; in round s, j will thus start with a &quot;blank state&quot; and receive incoming messages (sent by honest parties before round s-1) and potentially also messages from the adversary. By construction, the same players are honest in  <span class="math">REAL(\\sigma)</span>  and  <span class="math">HYB_r(\\sigma)</span> . In both experiments A needs to deliver all messages sent by these honest players in rounds on or before  <span class="math">s - \\Delta</span> ; in HYB<sub>r</sub>( <span class="math">\\sigma</span> ) these are the only messages being delivered, and in REAL( <span class="math">\\sigma</span> ), A may deliver additional messages (from honest parties sent after  <span class="math">s - \\Delta</span> , or from adversarial players). Let j' be the player that sends j its currently longest chain in  <span class="math">HYB_r(\\sigma)</span>  and let r' be the round when it &quot;mined&quot; this chain; since  <span class="math">\\sigma</span>  determines when players are successful in &quot;mining&quot; in both experiments, we have that j' also mines a chain in round r' in  <span class="math">\\mathsf{REAL}(\\sigma)</span> (and this chain will be delivered to j by round s). By the induction hypothesis, the chain of j' at r' is at least as long in REAL <span class="math">(\\sigma)</span>  as in HYB <span class="math">_r(\\sigma)</span> , which contradicts that the chain of j (before mining) is longer in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span> .</li>
      <li>j is honest at round s-1 in  <span class="math">\\mathsf{REAL}(\\sigma)</span> : By the induction hypothesis we have that the chain of j is at least as long at round s-1 in  <span class="math">\\mathsf{REAL}(\\sigma)</span>  as in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span> , thus the chain of j must have grown at round s in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span>  (or else it could not be longer at round s as we assumed for contradiction). Also, note that mining at round s is successful in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span>  only if it is successful in  <span class="math">\\mathsf{REAL}(\\sigma)</span> ,  <span class="math">^{13}</span>  so the only possibility of j's chain to be longer in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span>  is if it received a chain in round s that extended its chain. This chain must have come from an honest player, since the exact same messages sent by corrupt parties and delivered in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span>  are also delivered in  <span class="math">\\mathsf{REAL}(\\sigma)</span>  at the same or earlier round. Let j' be the honest player that sent the chain, and let  <span class="math">r&#x27; = s \\Delta</span>  be the round in which j' mined the chain; as before, we also have that j' mines a chain in round r' in  <span class="math">\\mathsf{REAL}(\\sigma)</span>  and this chain must have been delivered to j by round s (and potentially earlier). The chain delivered in  <span class="math">\\mathsf{REAL}(\\sigma)</span>  may not be the exact same chain delivered in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span> , but by the induction hypothesis the chain of j' at r' is at least as long in  <span class="math">\\mathsf{REAL}(\\sigma)</span>  as in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span> , which contradicts that the chain of j is longer in  <span class="math">\\mathsf{HYB}_r(\\sigma)</span> .</li>
    </ul>

    <p class="text-gray-300">We turn to prove a lower bound on the chain growth of the longest chain known to the honest players. Let  <span class="math">\\ell^r(\\text{view})</span>  denote the length of the longest chain  <span class="math">C_i^r(\\text{view})</span>  of any honest player i at round r in view.</p>

    <p class="text-gray-300"><strong>Lemma 6.4.</strong> For any  <span class="math">r, t \\ge 0</span>  and any  <span class="math">\\delta &gt; 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\ell^{r+t}(\\mathit{HYB}_r) &lt; \\ell^r(\\mathit{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)}</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;12</sup>We do not have an &quot;if and only if&quot; since the players may also be &quot;freezed&quot; in  <span class="math">HYB_r(\\sigma)</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;13</sup>Again, we do not have an &quot;if and only if&quot; since the players may also be &quot;freezed&quot; in  <span class="math">HYB_r(\\sigma)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Fix some r. Note that at every round  <span class="math">s&#x27; \\geq r</span>  in  <span class="math">\\mathsf{HYB}_r</span>  where the honest players are not frozen, they have <em>all</em> received all sent messages; they, thus, all have chains of the same length (but not necessarily the same chain). In every such round, the probability that the longest chain (known to the honest parties) is successfully extended is thus exactly  <span class="math">\\alpha</span> , <em>independent</em> of the prefix of the experiment.</p>

    <p class="text-gray-300">If after t rounds, the longest chain's increase is less than c, it means that there were at least  <span class="math">t-c\\Delta</span>  &quot;unfrozen&quot; rounds (each success leads to  <span class="math">\\Delta</span>  frozen rounds, and we potentially have  <span class="math">\\Delta</span>  initially frozen rounds). Moreover, in those  <span class="math">t-c\\Delta</span>  rounds there were less than c successes. Thus, the probability that the longest chain grows by less than c blocks is upper bounded by  <span class="math">\\Pr[W^{t-c\\Delta} &lt; c]</span>  where  <span class="math">W^k</span>  is the sum of k independent binary random variables  <span class="math">w_i</span>  that are 1 with probability  <span class="math">\\alpha</span> . Let's find a c such that  <span class="math">E[W^{t-c\\Delta}] = c</span> . That is,</p>

    <p class="text-gray-300"><span class="math">$E[W^{t-c\\Delta}] = \\alpha t - \\alpha c \\Delta = c</span>$</p>

    <p class="text-gray-300">which implies that</p>

    <p class="text-gray-300"><span class="math">$c = \\frac{\\alpha t}{1 + \\alpha \\Delta} = \\gamma t</span>$</p>

    <p class="text-gray-300">Thus, if we set  <span class="math">c = \\gamma t</span> , we have</p>

    <p class="text-gray-300"><span class="math">$E[W^{t-c\\Delta}] = t\\gamma</span>$</p>

    <p class="text-gray-300">By the Chernoff bound (see Appendix A), we thus have:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[W^{t-c\\Delta} &lt; (1-\\delta)t\\gamma] \\le e^{-\\Omega(\\delta^2\\gamma t)}</span>$</p>

    <p class="text-gray-300">Since the probability that the longest chain grows by less than  <span class="math">(1 - \\delta)\\gamma t</span>  blocks is upper bounded by  <span class="math">\\Pr[W^{t-(1-\\delta)\\gamma t\\Delta} &lt; (1-\\delta)\\gamma t]</span> , which proves the lemma.</p>

    <p class="text-gray-300">By combining Lemma 6.3 and Lemma 6.4, we get the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 6.5.</strong> For any  <span class="math">r, t \\ge 0</span>  and any  <span class="math">\\delta &gt; 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\ell^{r+t}(\\textit{REAL}) &lt; \\ell^r(\\textit{REAL}) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> By Lemma 6.4, we have that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\ell^{r+t}(\\mathsf{HYB}_r) &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)}</span>$</p>

    <p class="text-gray-300">By definition, for every  <span class="math">\\sigma</span> , we have that  <span class="math">\\ell^r(\\mathsf{HYB}_r(\\sigma)) = \\ell^r(\\mathsf{REAL}(\\sigma))</span> . By Lemma 6.3, for every  <span class="math">\\sigma</span> , we have that  <span class="math">\\ell^{r+t}(\\mathsf{HYB}_r(\\sigma)) \\leq \\ell^{r+t}(\\mathsf{REAL}(\\sigma))</span> . Thus,</p>

    <p class="text-gray-300"><span class="math">$Pr\\left[\\ell^{r+t}(\\mathsf{REAL}) &lt; \\ell^r(\\mathsf{REAL}) + (1-\\delta)\\gamma t\\right] \\leq Pr\\left[\\ell^{r+t}(\\mathsf{HYB}_r) \\right. \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)} \\\\ \\left. &lt; \\ell^r(\\mathsf{HYB}_r) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)}</span>$</p>

    <p class="text-gray-300">Lemma 6.5 only gives a bound on the growth of the <em>longest chain</em>. We now give a bound on the chain growth between any two honest users by combining Lemma 6.5 and Claim 6.2 (i.e., the consistent length property).</p>

    <p class="text-gray-300"><strong>Lemma 6.6.</strong> For any  <span class="math">r, t \\ge 0</span>  and any  <span class="math">\\delta &gt; 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[ \\textit{min-chain-increase}_{r,t}(\\textit{REAL}) &lt; (1-\\delta)\\gamma t \\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)}</span>$</p>

    <p class="text-gray-300">Proof. Note that for any view,</p>

    <p class="text-gray-300"><span class="math">$\\min_{i,j} |\\mathcal{C}_j^{r+t}(\\mathsf{view})| - |\\mathcal{C}_i^r(\\mathsf{view})| = \\min_j |\\mathcal{C}_j^{r+t}(\\mathsf{view})| - \\max_i |\\mathcal{C}_i^r(\\mathsf{view})|</span>$</p>

    <p class="text-gray-300">By Claim 6.2, min<sup>j</sup> |Cr+<sup>t</sup> j (view)| &ge; max<sup>j</sup> |Cr+t&minus;<sup>&#8710;</sup> j (view)|. Thus,</p>

    <p class="text-gray-300"><span class="math">$\\min_{i,j} |\\mathcal{C}_j^{r+t}(\\mathsf{view})| - |\\mathcal{C}_i^r(\\mathsf{view})| \\geq \\max_j |\\mathcal{C}_j^{r+t-\\Delta}(\\mathsf{view})| - \\max_i |\\mathcal{C}_i^r(\\mathsf{view})| = \\ell^{r+t-\\Delta}(\\mathsf{view}) - \\ell^r(\\mathsf{view}).</span>$</p>

    <p class="text-gray-300">By Lemma 6.5, we have that for every constant &delta; 0 ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\ell^{r+t-\\Delta}(\\mathsf{REAL}) &lt; \\ell^r(\\mathsf{REAL}) + (1-\\delta&#x27;)\\gamma(t-\\Delta)\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma(t-\\Delta)\\right)}.</span>$</p>

    <p class="text-gray-300">Since &gamma;&#8710; = <sup>&alpha;</sup><sup>&#8710;</sup> 1+&alpha;<sup>&#8710;</sup> &lt; 1, it follows that for every constant &delta; (by picking a sufficiently small &delta; 0 ), we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\ell^{r+t-\\Delta}(\\mathsf{REAL}) &lt; \\ell^r(\\mathsf{REAL}) + (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)}.</span>$</p>

    <p class="text-gray-300">We thus conclude that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\min_{i,j} |\\mathcal{C}_j^{r+t}(\\mathsf{REAL})| - |\\mathcal{C}_i^r(\\mathsf{REAL})| &lt; (1-\\delta)\\gamma t\\right] &lt; e^{-\\Omega\\left(\\delta^2\\gamma t\\right)}.</span>$</p>

    <p class="text-gray-300">which proves the lemma.</p>

    <p class="text-gray-300">The proof of Theorem 6.1 is concluded by combining 6.6 with a union bound over the rounds r.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Proof of the Chain Quality Property (Theorem 4.2)</h3>

    <p class="text-gray-300">Towards proving the chain quality property, the following two simple lemmas will be useful.</p>

    <p class="text-gray-300">Lemma 6.7 (Upperbound on Blocks). Let Qt(view) be the maximum number of blocks mined in any windows of t rounds (i.e., between round r and r + t for any r) in view. For any t &ge; 0 and any &delta; &gt; 0,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[Q_t(\\textit{REAL}) &gt; (1+\\delta) \\, np \\cdot t\\right] &lt; e^{-\\Omega\\left(\\delta^2 npt\\right)}</span>$</p>

    <p class="text-gray-300">Proof. In t rounds, the players get tn chances to mine a block; each chance succeeds with probability p. The desired bound follows directly from the Chernoff bound and a union bound of the rounds r.</p>

    <p class="text-gray-300">Lemma 6.8 (Upperbound on Adversarial Blocks). Let Ar(view) be the maximum number of blocks mined by the adversary in any window of r rounds. For any t and &delta; &gt; 0</p>

    <p class="text-gray-300"><span class="math">$\\Pr[A_t(REAL) &gt; (1+\\delta)\\beta t] &lt; e^{-\\Omega(\\delta^2\\beta t)}.</span>$</p>

    <p class="text-gray-300">Proof. In t rounds, the adversary gets t&rho;n chances to mine a block; each chance succeeds with probability p. The desired bound follows directly from the Chernoff bound and a union bound over the rounds r.</p>

    <p class="text-gray-300">Armed with these lemma, we are now ready to prove Theorem 4.2. The following theorem (which proves the chain quality property for the protocol in the Ftree-hybrid model), combined with Lemma 5.1, yields Theorem 4.2.</p>

    <p class="text-gray-300"><strong>Theorem 6.9.</strong> For all  <span class="math">\\delta \\geq 0</span> , any  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{tree}, \\mathcal{C}^p_{tree})</span>  has (errorless) chain quality  <span class="math">\\mu^p_{\\delta}(n, \\rho, \\Delta) = 1 - (1 + \\delta) \\frac{\\beta}{\\gamma}</span>  in  <span class="math">\\Gamma_0</span>  environments.</p>

    <p class="text-gray-300">Proof. Consider some view view in the support of REAL, some round r and player i that is honest at view<sup>r</sup>. Let  <span class="math">C = C_i^r(\\text{view})</span> , let  <span class="math">b_0, \\ldots, b_{|C|}</span>  be the blocks in C, let  <span class="math">m_0, \\ldots, m_{|C|}</span>  be the records contained in them and let  <span class="math">b_j, \\ldots, b_{j+T}</span>  be T consecutive blocks in C for some j. We say that a block  <span class="math">b_i</span>  is adversarial w.r.t. view if  <span class="math">b_i</span>  was mined by the adversary in view; note that the record  <span class="math">m_i</span>  (s.t.  <span class="math">i \\geq j</span> ) contained in  <span class="math">b_i</span>  can only be adversarial w.r.t view<sup>r</sup> and the prefix  <span class="math">m_0, \\ldots, m_{j-1}</span>  if  <span class="math">b_i</span>  is adversarial w.r.t view. We show that except with probability neg(T) over view  <span class="math">\\leftarrow</span>  REAL, the fraction of adversarial blocks in any such sequence  <span class="math">b_j, \\ldots, b_{j+T}</span>  is upper-bounded by  <span class="math">(1 + \\delta)\\frac{\\beta}{\\gamma}</span> .</p>

    <p class="text-gray-300">Let us start by noting that it suffices to provide a bound assuming that  <span class="math">b_{j-1}</span>  is not adversarial (i.e., it was either mined by an honest player, or it is the genesis block), and that  <span class="math">b_{j+T+1}</span>  is not adversarial (i.e., it was either mined by an honest player or |C| = j + T); otherwise, the fraction of adversarial blocks can only increase if we &quot;enlarge&quot; the segment (by considering a smaller j and/or a bigger T).</p>

    <p class="text-gray-300">Consider such a sequence. Let r' be the round when  <span class="math">b_{j-1}</span>  was mined; since it was not adversarial it was the chain of some honest player at this point. Let r'+t be the round when  <span class="math">b_{j+T}</span>  first appeared as an honest players' chain; by construction such a round exists (since  <span class="math">b_{j+T+1}</span>  is not adversarial). Note that by the definition of  <span class="math">\\mathcal{F}_{tree}</span> , all the adversarial blocks in  <span class="math">b_j, \\ldots, b_{j+T}</span>  must have been mined between round r' and r' + t.</p>

    <p class="text-gray-300">We simplify the experiment by &quot;ignoring&quot; bad events that happen with negligible probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By Lemma 6.7, for every  <span class="math">0 &lt; \\tilde{\\delta} &lt; 1</span> , except with probability  <span class="math">e^{-\\Omega(\\delta^2 T)}</span> , we have that  <span class="math">Q_{\\frac{T}{(1+\\delta)np}}(\\text{view}) &lt; T</span> . Thus except with probability  <span class="math">e^{-\\Omega(\\delta^2 T)}</span> , we have that  <span class="math">t &gt; \\frac{T}{(1+\\delta)np}</span> . Assume this holds and let bad1 denote the event that it does not (for <em>some</em> sequence  <span class="math">b_j, \\ldots, b_{j+T}</span> ).</li>
      <li>Since by Theorem 6.1, for every  <span class="math">\\delta&#x27;</span> , the chain growth is lower bounded by  <span class="math">(1 \\delta&#x27;)\\gamma</span> , except with probability neg(T), we have that,</li>
    </ul>

    <p class="text-gray-300"><span class="math">$t \\le \\frac{T}{(1 - \\delta&#x27;)\\gamma}.</span>$</p>

    <p class="text-gray-300">Assume this holds, and let bad2 denote the event that it does not (again for <em>some</em> sequence  <span class="math">b_j, \\ldots, b_{j+T}</span> ).</p>

    <p class="text-gray-300">&bull; By Lemma 6.8, we have that for every  <span class="math">\\delta&#x27;&#x27;</span> , except with probability  <span class="math">e^{-\\Omega(\\delta&#x27;&#x27;^2\\beta t)}</span> , the number of adversarial blocks mined during this period is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$(1+\\delta&#x27;&#x27;)\\beta t \\le \\frac{(1+\\delta&#x27;&#x27;)}{1-\\delta&#x27;} \\cdot T \\cdot \\frac{\\beta}{\\gamma}</span>$</p>

    <p class="text-gray-300">Let bad3 denote the event that this does not happen. Since we assumed that bad1 does not happens,  <span class="math">\\beta t = \\rho npt &gt; \\rho np \\frac{T}{(1+\\delta)np} = \\frac{\\rho T}{1+\\delta}</span> , thus bad3 only happens with probability  <span class="math">\\operatorname{neg}(T)</span> .</p>

    <p class="text-gray-300">We conclude by noting that assuming that none of the bad events happen, the fraction of adversarial blocks in any such sequence is</p>

    <p class="text-gray-300"><span class="math">$\\frac{(1+\\delta&#x27;&#x27;)}{1-\\delta&#x27;}\\cdot\\frac{\\beta}{\\gamma}</span>$</p>

    <p class="text-gray-300">For every  <span class="math">\\delta &gt; 0</span> , by picking sufficiently small  <span class="math">\\delta&#x27;, \\delta&#x27;&#x27;</span> , this quantity is upperbounded by</p>

    <p class="text-gray-300"><span class="math">$(1+\\delta)\\frac{\\beta}{\\gamma}</span>$
.</p>

    <p class="text-gray-300">Finally, by applying the union bound over the bad events, we have that the upperbound on the fraction of adversarial blocks holds except with probability neg(T).</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Proof of the Consistency Property (Theorem 4.3)</h3>

    <p class="text-gray-300">Towards proving consistency, we first show that if an adversary &quot;withholds&quot; a block for &quot;too long&quot;, it will never make it to the chain. Let witholding-time(view) be the longest number of rounds t such that in view, 1) the adversary mines a block b at some round r, and 2) there exists some honest player i such that b appeared (for the first time) as i's chain at round r + t.</p>

    <p class="text-gray-300"><strong>Lemma 6.10</strong> (&quot;No long block witholding&quot;). Assume  <span class="math">\\gamma \\geq (1+\\delta)\\beta</span>  for some  <span class="math">\\delta \\in (0,1)</span> . Then, for every constant  <span class="math">0 &lt; \\omega &lt; 1</span>  there exists a negligible function  <span class="math">\\epsilon(\\cdot)</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{REAL}: \\textit{witholding-time}(\\textit{view}) \\geq \\omega t\\right] \\leq \\epsilon(\\beta t)</span>$</p>

    <p class="text-gray-300">Proof. Consider some view view where the adversary mines block  <span class="math">b_l = (m_0, ..., m_l)</span>  at round r and some honest party i accepts a block b as its chain in round s, such that  <span class="math">s - r \\ge \\omega t</span> . Let block  <span class="math">b_{l-k} = (m_0, ..., m_{l-k})</span>  be the most recent (i.e., smallest k) non-adversarial block (i.e., it was mined by an honest party or it was a genesis block) that is a prefix of block  <span class="math">b_l</span> . Since  <span class="math">b_{l-k}</span>  is not adversarial, it was the chain of some honest player j at some round  <span class="math">r&#x27; \\le r</span> ; thus at least  <span class="math">\\omega t</span>  rounds have elapsed from r' to s. As in Theorem 6.9, we simplify the experiment by &quot;ignoring&quot; bad events that happen with negligible probability:</p>

    <p class="text-gray-300">&bull; At round r' some honest player has a chain of length l-k and at s some (potentially other) honest player has a chain of length l. Since by Theorem 6.1, for every  <span class="math">\\delta&#x27;</span> , the chain growth is lower bounded by  <span class="math">(1 - \\delta&#x27;)\\gamma</span> , except with probability  <span class="math">neg(\\gamma t)</span> , we thus have that,</p>

    <p class="text-gray-300"><span class="math">$k \\ge (1 - \\delta&#x27;)\\gamma \\omega t</span>$
.</p>

    <p class="text-gray-300">Assume this holds, and let bad1 denote the event that it does not. Since by assumption  <span class="math">\\gamma &gt; \\beta</span> , we thus have that bad1 only happens with probability  <span class="math">neg(\\beta t)</span> .</p>

    <p class="text-gray-300">&bull; By Lemma 6.8, we have that for every  <span class="math">\\delta&#x27;&#x27;</span> , except with probability  <span class="math">e^{-\\Omega(\\beta t)}</span>  the number of adversarial blocks mined during this period is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$(1+\\delta&#x27;&#x27;)\\beta\\omega t</span>$</p>

    <p class="text-gray-300">Assume it holds and let bad2 denote the event that does not. By construction, all the blocks from  <span class="math">b_{l-k}</span>  to  <span class="math">b_l</span>  are adversarial, thus we have that</p>

    <p class="text-gray-300"><span class="math">$k \\le (1 + \\delta&#x27;&#x27;)\\beta\\omega t</span>$</p>

    <p class="text-gray-300">We conclude that, assuming that none of the bad events happen,</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)\\gamma\\omega t \\le (1 + \\delta&#x27;&#x27;)\\beta\\omega t</span>$</p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math">$\\gamma \\le \\frac{(1+\\delta&#x27;&#x27;)}{(1-\\delta&#x27;)}\\beta</span>$</p>

    <p class="text-gray-300">By picking  <span class="math">\\delta&#x27;</span>  and  <span class="math">\\delta&#x27;&#x27;</span>  sufficiently small, we get that</p>

    <p class="text-gray-300"><span class="math">$\\gamma &lt; (1+\\delta)\\beta</span>$</p>

    <p class="text-gray-300">which is a contradiction.</p>

    <p class="text-gray-300">We next prove that the chains of the honest players can only diverge &quot;recently&quot; (i.e., in the last t rounds); we then use the upper-bound on chain growth to conclude the theorem. We say that two chains  <span class="math">C_1 = \\vec{m}_1, C_2 = \\vec{m}_2</span>  diverge at round r in view if the last block  <span class="math">b = (m_0, \\ldots, m_k)</span>  they have in common was mined before round r. (Note that by definition of a block in the  <span class="math">\\mathcal{F}_{tree}</span>  model, if  <span class="math">C_1, C_2</span>  have some block in common the chains up to this block must be identical.)</p>

    <p class="text-gray-300"><strong>Lemma 6.11.</strong> Assume there is an  <span class="math">0 &lt; \\delta &lt; 1</span>  such that  <span class="math">\\alpha(1 - 2(\\Delta + 1)\\alpha) \\ge (1 + \\delta)\\beta</span> . Except with probability  <span class="math">e^{-\\Omega(\\beta t)}</span>  over view  <span class="math">\\leftarrow</span>  REAL, there does not exists rounds  <span class="math">r \\ge r&#x27;</span>  and players i, j such that i is honest at r, j is honest at r' and  <span class="math">C_i^r(\\text{view})</span>  and  <span class="math">C_j^{r&#x27;}(\\text{view})</span>  diverge at round s = r - t.</p>

    <p class="text-gray-300"><em>Proof.</em> We start by noting that by a simple induction over r' - r, it suffices to show the lemma for the special cases that a) r' = r or b) r' = r + 1; the base case of the induction is case a), and the inductive step follows directly from b) and the observation that if two chains do not diverge at r' &gt; r, then they clearly do not diverge at r either.</p>

    <p class="text-gray-300">We now turn to prove the lemma for the special case (that  <span class="math">r \\leq r&#x27; \\leq r+1</span> ). We begin with a proof outline and then turn to the actual proof.</p>

    <p class="text-gray-300"><strong>Proof outline.</strong> We show that between the rounds s = r - t and r, there are many &quot;patterns&quot; of rounds such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for  <span class="math">\\Delta</span>  rounds no honest player mines a block;</li>
      <li>then a single player mines a new block;</li>
      <li><span class="math">\\bullet</span>  which is followed by  <span class="math">\\Delta</span>  rounds in which no honest player mines a block.</li>
    </ul>

    <p class="text-gray-300">Whenever such a pattern occurs, unless the adversary mines a chain of length  <span class="math">\\ell + 1^{14}</span> , where  <span class="math">\\ell</span>  is the length of the longest chain known to the honest players when the pattern begins, there exists a unique block that can appear on position  <span class="math">\\ell+1</span>  in any chain held by an honest player at round r (and thus by the definition of a block, the prefixes of all chains held by honest players are identical up until position  <span class="math">\\ell+1</span> ). Intuitively this follows since, &quot;after the first period of silence&quot;, unless the adversary mines a chain of length  <span class="math">\\ell + 1</span> , the honest players all agree on the length of the chain (being exactly  <span class="math">\\ell</span> ), then agree on the newly mined block after the second silence; no honest player will therefore attempt to mine a chain that is shorter and thus will never mine a block for position  <span class="math">\\ell+1</span> ). Furthermore, each new pattern gives rise to a new such &quot;converge opportunity&quot;. Thus, unless between the rounds s and  <span class="math">r&#x27; \\leq s + (t+1)</span> , the number of times the adversary succeeds in mining a chain of length  <span class="math">\\ell+1</span>  (where as before  <span class="math">\\ell</span>  is the length of the longest chain known to the honest players) is smaller than the number of such patterns, chains of honest players at rounds r, r' cannot diverge at s. The proof is concluded by showing that the number of such patterns increases at a faster rate than the number of blocks mined by the adversary; to do this, we rely on the block withholding lemma (Lemma 6.10) to argue that the adversary cannot make use of any blocks mined too long ago in order to create disagreement.</p>

    <p class="text-gray-300">The actual proof. We start by making the following useful observations.</p>

    <p class="text-gray-300">Claim 6.12. For every  <span class="math">0 &lt; \\delta &lt; 1</span>  there exists  <span class="math">0 &lt; \\delta&#x27; &lt; 1</span>  such that for all positive  <span class="math">\\kappa, n, \\rho, \\Delta, \\alpha, \\beta</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\alpha(1 - 2\\alpha(\\Delta + 1)) \\ge (1 + \\delta)\\beta</span>$</p>

    <p class="text-gray-300">holds, the following holds</p>

    <p class="text-gray-300"><span class="math">$\\alpha &gt; \\gamma &gt; (1 + \\delta&#x27;)\\beta \\tag{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;) &gt; (\\Delta + 1)\\alpha \\tag{2}</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;14</sup>That is, the adversary mines a block of length  <span class="math">\\ell+1</span>  since recall that a block is vector m of records.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof follows by simple calculation. We start by proving Equation 1. For any  <span class="math">\\Delta &gt; 0</span>  and any  <span class="math">\\alpha &gt; 0</span> , it follows that</p>

    <p class="text-gray-300"><span class="math">$2(\\Delta+1) &gt; \\frac{\\Delta}{1+\\Delta\\alpha}</span>$</p>

    <p class="text-gray-300">Multiplying both sides by  <span class="math">\\alpha</span> , and breaking out fractions:</p>

    <p class="text-gray-300"><span class="math">$2\\alpha(\\Delta+1)&gt;1-\\left(\\frac{1}{1+\\Delta\\alpha}\\right)</span>$</p>

    <p class="text-gray-300">and finally, moving the fraction to the left, rearranging, and multiplying by  <span class="math">\\alpha</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\alpha &gt; \\gamma = \\alpha \\left(\\frac{1}{1 + \\Delta \\alpha}\\right) &gt; \\alpha \\left(1 - 2\\alpha(\\Delta + 1)\\right) \\ge (1 + \\delta)\\beta</span>$</p>

    <p class="text-gray-300">where the last inequality follows from the hypothesis.</p>

    <p class="text-gray-300">To prove Equation 2, divide both sides of the hypothesis by  <span class="math">\\alpha</span> , distribute the left-hand side of the hypothesis and rearrange to get</p>

    <p class="text-gray-300"><span class="math">$1 - \\left( (1 + \\delta) \\frac{\\beta}{\\alpha} \\right) \\ge 2\\alpha(\\Delta + 1) &gt; \\alpha(\\Delta + 1)</span>$</p>

    <p class="text-gray-300">Because  <span class="math">\\alpha</span>  and  <span class="math">\\Delta</span>  are positive, the left side too must be positive, and thus, we can pick  <span class="math">0 &lt; \\delta&#x27; &lt; \\min\\left\\{\\delta, (1+\\delta)\\frac{\\beta}{\\alpha}\\right\\} &lt; 1</span>  to satisfy both conditions.</p>

    <p class="text-gray-300">Now, consider some view view in the execution of REAL and consider some round  <span class="math">r \\leq |\\text{view}|</span>  and some t such that  <span class="math">s = r - t \\geq 0</span> .</p>

    <p class="text-gray-300">We simplify the experiment by &quot;ignoring&quot; bad events that happen with negligible probability. In the sequel we will define various random variables  <span class="math">\\mathbf{L}(\\mathsf{view}), \\mathbf{X}(\\mathsf{view}), \\mathbf{R}_i(\\mathsf{view})</span> ; to simplify the notation, we omit view whenever it is clear from context.</p>

    <p class="text-gray-300">&bull; We say that a round  <span class="math">\\tilde{r}</span>  in view is <em>successful</em> if there exists some honest player that mines a block at round  <span class="math">\\tilde{r}</span> . Note that (by definition),  <span class="math">\\alpha</span>  is the probability that a round  <span class="math">\\tilde{r}</span>  is successful. Let  <span class="math">\\mathbf{L}(\\text{view})</span>  be the number of successful rounds between s and r and let  <span class="math">L = (1 - \\delta&#x27;) \\alpha t</span>  for some constant  <span class="math">0 &lt; \\delta&#x27; &lt; 1</span> . Let bad1 be the event that  <span class="math">\\mathbf{L} &lt; L</span> . By the Chernoff bound we have,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{bad1}] = \\Pr\\left[\\mathbf{L} &lt; L\\right] \\le e^{-\\Omega(\\delta&#x27;^2 \\alpha t)} \\le e^{-\\Omega(\\delta&#x27;^2 \\beta t)}</span>$</p>

    <p class="text-gray-300">where the last inequality follows by Claim 6.12(1).</p>

    <p class="text-gray-300">&bull; Let  <span class="math">\\mathbf{R}_1(\\text{view})</span>  be the number of rounds from s to the first successful round, and let  <span class="math">\\mathbf{R}_i(\\text{view})</span>  for i &gt; 1 be the number of rounds between the  <span class="math">(i-1)^{\\text{th}}</span>  successful round to the  <span class="math">i^{\\text{th}}</span>  successful round. Let  <span class="math">\\mathbf{X}_i(\\text{view}) = 1</span>  if  <span class="math">\\mathbf{R}_i &gt; \\Delta</span>  and exactly one player mines a block in the i+1'st successful round (and 0 otherwise). Note that the random variables  <span class="math">\\mathbf{X}_i</span> 's are independent (when view  <span class="math">\\leftarrow</span>  REAL). Because the probability that some player mines a block in a round is  <span class="math">\\alpha</span> , by the union bound, we have that  <span class="math">\\Pr[\\mathbf{X}_i(\\text{REAL}) = 0] \\geq (\\Delta + 1)\\alpha</span>  (the bad event happens if somebody mines a block in one of the  <span class="math">\\Delta</span>  rounds after the i'th successful round, or if somebody else mines a block in the (i+1)'st successful round). Let  <span class="math">\\mathbf{X}(\\text{view}) = \\sum_{i=1}^L \\mathbf{X}_i</span>  and let  <span class="math">X = (1 - \\delta&#x27;&#x27;) (1 - (\\Delta + 1)\\alpha) L</span> . By the Chernoff bound, we have that,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{X} \\le X\\right] \\le e^{-\\Omega(\\delta&#x27;&#x27;^2 X)}</span>$
.</p>

    <p class="text-gray-300">Let bad2 be the event that  <span class="math">\\mathbf{X} \\leq X</span> . Since by Claim 6.12, there exists some constant  <span class="math">0 &lt; \\tilde{\\delta} &lt; 1</span>  such that a)  <span class="math">(\\Delta + 1)\\alpha &lt; 1 - \\tilde{\\delta}</span>  and b)  <span class="math">\\alpha \\geq \\beta</span> , it follows that bad2 happens with probability at most  <span class="math">e^{-\\Omega(\\delta&#x27;&#x27;^2\\beta t)}</span> .</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{15}&lt;/sup&gt;</span> Formally, we consider an extended experiment where the honest players continue mining blocks forever (even after the environment Z stops sending them messages.</p>

    <p class="text-gray-300">&bull; Let  <span class="math">\\mathbf{Y}_i(\\mathsf{view}) = 1</span>  if  <span class="math">\\mathbf{X}_i = 1</span>  and  <span class="math">\\mathbf{X}_{i+1} = 1</span>  (that is, we have a period of at least  <span class="math">\\Delta</span>  rounds &quot;of silence&quot;, followed by a round in which exactly one honest players successfully mines a block, followed by at least  <span class="math">\\Delta</span>  rounds of silence); we refer to such an event as a convergence opportunity. Let  <span class="math">\\mathbf{Y}(\\mathsf{view}) = \\sum_{i=1}^{L} \\mathbf{Y}_i</span> . Since each  <span class="math">\\mathbf{X}_i = 0</span>  can &quot;ruin&quot; at most two convergence opportunities, we have that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Y} \\ge \\sum_{i=1}^{L} 1 - 2 \\sum_{i=1}^{L} (1 - \\mathbf{X}_i) = 2\\mathbf{X} - L</span>$</p>

    <p class="text-gray-300">We conclude that conditioned on bad1 and bad2 not happening, the number of convergence opportunities is at least</p>

    <p class="text-gray-300"><span class="math">$2X - L = \\left[2(1 - \\delta&#x27;&#x27;)\\left(1 - (\\Delta + 1)\\alpha\\right)L\\right] - L</span>$
<span class="math">$= L\\left[1 - 2\\delta&#x27;&#x27; - 2\\alpha(\\Delta + 1)(1 - \\delta&#x27;&#x27;)\\right]</span>$
<span class="math">$\\geq L\\left[1 - 2\\delta&#x27;&#x27; - 2\\alpha(\\Delta + 1)\\right]</span>$
<span class="math">$= \\left((1 - \\delta&#x27;)\\alpha t\\right)\\left[1 - 2\\delta&#x27;&#x27; - 2\\alpha(\\Delta + 1)\\right]</span>$</p>

    <p class="text-gray-300">It follows that for every constant  <span class="math">0 &lt; \\delta&#x27;&#x27;&#x27; &lt; 1</span> , by appropriately picking (sufficiently small)  <span class="math">\\delta&#x27;</span>  and  <span class="math">\\delta&#x27;&#x27;</span> , we have that conditioned on bad1 and bad2 do not happening, the number of convergence opportunities is at least</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;&#x27;&#x27;)(1 - 2\\alpha(\\Delta + 1))\\alpha t</span>$</p>

    <p class="text-gray-300">Additionally, by a union bound, the probability that either of these events occur is at most  <span class="math">e^{-\\Omega(\\beta t)}</span> .</p>

    <p class="text-gray-300">Whenever such a convergence opportunity occurs, unless the adversary mines a chain of length  <span class="math">\\ell+1</span>  before round r', where  <span class="math">\\ell</span>  is the length of the longest chain known to the honest players when the convergence opportunity begins, there exists a unique block that can appear on position  <span class="math">\\ell+1</span>  in any chain held by an honest player after the convergence opportunity and up until round r'. This follows because of three reasons: first, after the first  <span class="math">\\Delta</span>  period of silence, all honest parties have chains of the same length  <span class="math">\\ell</span>  (the longest chain known to the honest players before the period of silence must have been delivered to all of them by this point, and the only way the adversary can disrupt this is if it mines a longer chain which is only possible if it first mines a chain of length  <span class="math">\\ell+1</span> ; secondly, there is a unique miner that succeeds in extending its chain, thus obtaining a chain of length  <span class="math">\\ell+1</span> ; and finally, by the end of the second period of silence, all players must have received this extension or potentially some other chain (by the adversary) which is at least as long, which means that no honest player will ever try to mine from a chain of length smaller than  <span class="math">\\ell+1</span>  and thus no other block mined by an honest player can appear in position  <span class="math">\\ell+1</span>  in any valid chain.</p>

    <p class="text-gray-300">Additionally, note that at every such convergence opportunity, the length of the longest chain  <span class="math">\\ell</span>  grows by at least 1. Thus the only way for the chains of two honest player i,j at rounds r,r' to diverge at s is if between the rounds s and r', the adversary mines a block of length  <span class="math">\\ell+1</span>  for every such convergence opportunity (or else they will have a block in common after s, and thus in fact, all blocks in common up until this point). Thus it needs to mine at least</p>

    <p class="text-gray-300"><span class="math">$T_{\\delta&#x27;&#x27;&#x27;} = (1 - \\delta&#x27;&#x27;&#x27;)(1 - 2\\alpha(\\Delta + 1))\\alpha t</span>$</p>

    <p class="text-gray-300">new blocks. Furthermore, these blocks all need to be accepted by some honest player at round s (or later).</p>

    <p class="text-gray-300">Since by Claim 6.12, there exists some constant  <span class="math">0 &lt; \\tilde{\\delta} &lt; 1</span>  such that a)  <span class="math">\\gamma &gt; (1 + \\tilde{\\delta})\\beta</span> , we can apply the block witholding lemma (Lemma 6.10), to conclude that for any constant  <span class="math">\\omega</span> , any such block must have been mined by round  <span class="math">s - \\omega t</span>  except probability  <span class="math">e^{-\\Omega(\\beta t)}</span> . But, by the &quot;upper-bound on adversarial blocks&quot; lemma (Lemma 6.8), for every constant  <span class="math">\\omega&#x27;</span> , except with probability  <span class="math">e^{-\\Omega(\\beta t)}</span> ,</p>

    <p class="text-gray-300">the adversary can only have mined  <span class="math">(1 + \\omega&#x27;)(1 + \\omega)(t + 1)\\beta</span>  blocks between round s and round r' &lt; s + (t + 1); under the conditions of the theorem, it thus follows that the adversary could have mined at most</p>

    <p class="text-gray-300"><span class="math">$\\frac{(1+\\omega&#x27;)(1+\\omega)}{(1+\\delta)}\\cdot(1-2\\alpha(\\Delta+1))\\alpha(t+1)</span>$</p>

    <p class="text-gray-300">blocks. By picking a sufficiently small  <span class="math">\\delta&#x27;&#x27;&#x27;, \\omega, \\omega&#x27;</span> , we have that  <span class="math">T_{\\delta&#x27;&#x27;&#x27;}</span>  is greater than this quantity, and it follows that the chains diverge at s only with probability  <span class="math">e^{-\\Omega(\\beta t)}</span> .</p>

    <p class="text-gray-300">Armed with these lemmas, we now prove the following theorem (which proves consistency for the protocol in the  <span class="math">\\mathcal{F}_{tree}</span> -hybrid model), which combined with Lemma 5.1, yields Theorem 4.3.</p>

    <p class="text-gray-300"><strong>Theorem 6.13.</strong> For any  <span class="math">\\lambda &gt; 1</span> , any  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{\\mathsf{tree}}, \\mathcal{C}^p_{\\mathsf{tree}})</span>  satisfies (errorless) consistency in  <span class="math">\\Gamma^p_{\\lambda}</span>  environments.</p>

    <p class="text-gray-300"><em>Proof.</em> Consider some view view in the execution REAL, let i, j be players such that, in view, i is honest at round r and j is honest at round r' &gt; r; let  <span class="math">C_1 = \\mathcal{C}_i^r(\\mathsf{view})</span>  and  <span class="math">C_2 = \\mathcal{C}_j^{r&#x27;}(\\mathsf{view})</span> . For every constant  <span class="math">0 &lt; \\delta &lt; 1</span> , by Lemma 6.11 the probability that  <span class="math">C_1</span>  and  <span class="math">C_2</span>  diverge at</p>

    <p class="text-gray-300">For every constant  <span class="math">0 &lt; \\delta &lt; 1</span> , by Lemma 6.11 the probability that  <span class="math">C_1</span>  and  <span class="math">C_2</span>  diverge at  <span class="math">s = r - \\frac{T}{\\gamma(1+\\delta)}</span>  is at most  <span class="math">e^{-\\Omega(T\\frac{\\beta}{\\gamma})} = e^{-\\Omega(T\\frac{1}{\\rho})} = e^{-\\Omega(T)}</span> . By Lemma 6.7, except with probability  <span class="math">e^{-\\Omega(T)}</span> , the number of blocks mined between rounds s and r is smaller than  <span class="math">(1+\\delta) \\cdot \\gamma \\cdot \\frac{T}{\\gamma(1+\\delta)} = T</span> . Thus, by a union bound we have that except with probability  <span class="math">e^{-\\Omega(T)}</span> ,  <span class="math">C_1</span>  and  <span class="math">C_2</span>  are identical except for potentially the last T blocks.</p>

      <h3 id="sec-6.4" class="text-xl font-semibold mt-8">6.4 Proof of the Upperbound on Chain Growth Property (Theorem 4.4)</h3>

    <p class="text-gray-300">We finally prove the following theorem (which proves the upperbound on chain growth for the protocol in the  <span class="math">\\mathcal{F}_{tree}</span> -hybrid model), which combined with Lemma 5.1, yields Theorem 4.4.</p>

    <p class="text-gray-300"><strong>Theorem 6.14.</strong> For any  <span class="math">\\delta &gt; 0</span> , any  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{\\mathsf{tree}}, \\mathcal{C}^p_{\\mathsf{tree}})</span>  has (errorless) upperbound on chain growth rate</p>

    <p class="text-gray-300"><span class="math">$\\hat{g}^p_{\\delta}(\\kappa, n, \\rho, \\Delta) = (1 + \\delta)np</span>$</p>

    <p class="text-gray-300">in  <span class="math">\\Gamma^p_{\\lambda}</span>  environments.</p>

    <p class="text-gray-300"><em>Proof.</em> Consider some view view and some T; let  <span class="math">t = \\frac{T}{\\hat{g}(n(\\kappa), \\rho, \\Delta(\\kappa))}</span> . By Lemma 6.7, we have that for any  <span class="math">\\delta&#x27; &gt; 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[Q_t(\\mathsf{REAL}) &gt; (1 + \\delta&#x27;) \\, np \\cdot t\\right] &lt; e^{-\\Omega\\left(\\delta^2 npt\\right)} = \\mathsf{neg}(T)</span>$</p>

    <p class="text-gray-300">where  <span class="math">Q_t(\\text{view})</span>  is the maximum number of blocks mined in any window of t rounds in view.</p>

    <p class="text-gray-300">By Claim 6.12 and Lemma 6.10, for every constant  <span class="math">0 &lt; \\omega &lt; 1</span> , except with probability  <span class="math">\\operatorname{neg}(\\beta t) = \\operatorname{neg}(\\rho np) = \\operatorname{neg}(T)</span> , at most  <span class="math">\\omega t</span>  extra block may be accepted by some honest player in such a window. Thus, except with probability  <span class="math">\\operatorname{neg}(T)</span> , the chain can grow by at most  <span class="math">((1 + \\delta&#x27;)np + \\omega) \\cdot t</span>  in any window; for every  <span class="math">\\delta</span> , by appropriately setting  <span class="math">\\delta&#x27;</span> , this quantity can be made smaller than  <span class="math">(1+\\delta)np \\cdot t</span> , which proves the theorem.</p>

    <p class="text-gray-300">In this section, we demonstrate how to use <em>any</em> blockchain satisfying the growth, quality, and consistency properties defined in &sect;3 to construct a secure <em>public ledger</em> system. Garay et al. [GKL15] show a similar theorem, in the synchronous setting, for the <em>specific</em> blockchain of Nakamoto.</p>

    <p class="text-gray-300">Informally, a <em>public ledger</em> serves as an immutable &quot;bulletin board&quot; to which anyone can post a message, and everyone can read all messages posted. As descibed by Garay et al. [GKL15], such a bulletin board ought to satisfy two properties, <em>liveness</em> and <em>persistence</em>:<sup>16</sup></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Liveness: The liveness property stipulates that from any given round r, if a sufficiently long period of time t elapses&mdash;we refer to this time as the wait-time of the ledger&mdash;every honest player will output a message m as part of their (local) ledger, where m was provided as an input to some honest player between rounds r and r + t. (In particular, this implies the liveness condition of [GKL15] which requires that if the same message was provided to all honest players between rounds r and r + t, this messages will be output in the ledger.)</li>
      <li>Persistence: The persistence property stipulates that if some honest player i outputs a message m at position i in its local ledger, then 1) m is the only message that can ever be output at position i of any other honest player's ledger and 2) every honest player will eventually output m at position i.</li>
    </ul>

    <p class="text-gray-300">Let us turn to a formal definition.</p>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8">7.1 Definition of a Public Ledger</h3>

    <p class="text-gray-300">Just like the blockchain protocol, a public ledger is pair of algorithms  <span class="math">(\\Pi, \\mathcal{L})</span>  where  <span class="math">\\Pi</span>  is a stateful algorithm that maintains a local state state. The algorithm  <span class="math">\\mathcal{L}(\\kappa, \\text{state})</span>  outputs ordered sequence of messages  <span class="math">\\vec{m}</span> . We call  <span class="math">\\mathcal{L}(\\kappa, \\text{state})</span>  the (local) ledger of a player with security parameter  <span class="math">\\kappa</span>  and local variable state. We define the execution of a public ledger protocol in exactly the same way as the execution of a blockchain protocol (see Section 2.1), and define the random variable  <span class="math">\\mathsf{EXEC}^{(\\Pi,\\mathcal{L})}(A,Z,\\kappa)</span>  in exactly the same way. Let  <span class="math">\\mathcal{L}_i(\\mathsf{view})</span>  denote the ledger of player i in the view view and let  <span class="math">\\mathcal{L}_i^r(\\mathsf{view}) = \\mathcal{L}_i(\\mathsf{view}^r)</span> .</p>

    <p class="text-gray-300"><strong>Liveness</strong> Let live(view, t) = 1 iff for any t consecutive rounds r, ..., r+t in view there exists some round  <span class="math">t&#x27; \\in [r, r+t]</span>  and players i such that in view, 1) i is honest at t', 2) i received a message m as input at round t', and 3) for every player t' that is honest at t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view, t' in view,</p>

    <p class="text-gray-300"><strong>Definition 7.1</strong> (Liveness). We say that public ledger  <span class="math">(\\Pi, \\mathcal{L})</span>  is live with wait-time  <span class="math">w(\\cdot, \\cdot, \\cdot, \\cdot)</span>  in &Gamma; environments if for all &Gamma;-admissible  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> , there exists a negligible function  <span class="math">\\epsilon</span>  in the security parameter  <span class="math">\\kappa \\in \\mathbb{N}</span> , such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{(\\Pi,\\mathcal{L})}(A,Z,\\kappa) : \\textit{live}(\\textit{view},w(\\kappa,n(\\kappa),\\rho,\\Delta(\\kappa)) = 1\\right] \\geq 1 - \\epsilon(\\kappa)</span>$</p>

    <p class="text-gray-300"><strong>Persistence</strong> Let  <span class="math">\\mathsf{persist}_\\Delta(\\mathsf{view}) = 1</span>  iff for every round  <span class="math">r \\leq |\\mathsf{view}| - \\Delta</span> , every player i that is honest at  <span class="math">\\mathsf{view}^r</span>  and every position  <span class="math">\\mathsf{pos} \\leq |\\mathcal{L}_i^r(\\mathsf{view})|</span> , if  <span class="math">\\mathcal{L}_i^r(\\mathsf{view})</span>  contains the message  <span class="math">\\mathsf{m}</span>  at position  <span class="math">\\mathsf{pos}</span> , then for every round r' such that  <span class="math">r + \\Delta \\leq r&#x27;</span>  and every honest player j (possibly the same as i) we have that  <span class="math">\\mathsf{m}</span>  is also at position  <span class="math">\\mathsf{pos}</span>  in  <span class="math">\\mathcal{L}_i^{r&#x27;}(\\mathsf{view})</span> .</p>

    <p class="text-gray-300"><strong>Definition 7.2</strong> (Persistence). We say that  <span class="math">(\\Pi, \\mathcal{L})</span>  is persistent in  <span class="math">\\Gamma</span>  environments if for all  <span class="math">\\Gamma</span> -admissible  <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> , there exists a negligible function  <span class="math">\\epsilon</span>  such that for every security parameter  <span class="math">\\kappa \\in \\mathbb{N}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathit{view} \\leftarrow \\mathit{EXEC}^{(\\Pi,\\mathcal{L})}(A,Z,\\kappa) : \\mathit{persist}_{\\Delta(\\kappa)}(\\mathit{view}) = 1\\right] \\geq 1 - \\epsilon(\\kappa)</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;16</sup>The notion of Garay et al. [GKL15] is actually somewhat different and weaker: for instance, 1) they only require these properties to hold for records that are sufficiently &quot;deep&quot; in the ledger (we feel it is more natural/simpler to require it for <em>all</em> records in the ledger), and 2) they only require the liveness property to hold if all players received the <em>same</em> message.</p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8">7.2 Constructing a Public Ledger from a Blockchain</h3>

    <p class="text-gray-300">We turn to constructing a public ledger from any blockchain protocol. Let TRUE be the predicate that always outputs 1 (on any input).</p>

    <p class="text-gray-300"><strong>Definition 7.3.</strong> Given a blockchain protocol  <span class="math">(\\Pi, \\mathcal{C})</span> , we call  <span class="math">(\\Pi&#x27;, \\mathcal{L})</span>  the public ledger  <span class="math">T(\\kappa)</span> -induced by  <span class="math">(\\Pi, \\mathcal{C})</span> , where  <span class="math">\\Pi&#x27; = \\Pi^{TRUE}</span>  and  <span class="math">\\mathcal{L}(\\kappa, \\mathsf{state})</span>  computes  <span class="math">\\mathcal{C}(\\kappa, \\mathsf{state})</span> , truncates the last  <span class="math">T(\\kappa)</span>  records of it, and outputs the results.</p>

    <p class="text-gray-300"><strong>Theorem 7.4.</strong> Let  <span class="math">T(\\cdot)</span>  be a strictly positive, super-constant, polynomial,  <span class="math">(\\Pi, \\mathcal{C})</span>  a blockchain protocol satisfying chain growth g, chain quality  <span class="math">\\mu</span>  and chain consistency in  <span class="math">\\Gamma</span> -environments, where  <span class="math">\\mu</span>  and g are strictly positive. Then, for every  <span class="math">\\delta &gt; 0</span> , the public ledger  <span class="math">(\\Pi&#x27;, \\mathcal{L})</span>   <span class="math">T(\\cdot)</span> -induced by  <span class="math">(\\Pi, \\mathcal{C})</span>  is persistent and live with wait-time  <span class="math">w(\\kappa, n, \\rho, \\Delta) = (1 + \\delta) \\frac{T(\\kappa)}{g(\\kappa, n, \\rho, \\Delta)}</span>  in  <span class="math">\\Gamma</span> -environments.<sup>17</sup></p>

    <p class="text-gray-300"><em>Proof.</em> Consider  <span class="math">\\Gamma</span> -admissible  <span class="math">n(\\cdot), \\rho, \\Delta(\\cdot), A, Z</span> , some  <span class="math">\\delta &gt; 0</span> , some  <span class="math">\\kappa</span> , and some view view  <span class="math">\\leftarrow \\mathsf{EXEC}^{(\\Pi,\\mathcal{L})}(A,Z,\\kappa)</span> . Let  <span class="math">n = n(\\kappa), \\Delta = \\Delta(\\kappa), g = g(\\kappa,n,\\rho,\\Delta)</span>  and  <span class="math">\\mu = \\mu(\\kappa,n,\\rho,\\Delta), T = T(\\kappa)</span> . We now separately show liveness and persistence.</p>

    <p class="text-gray-300"><strong>Liveness</strong> Let  <span class="math">T&#x27; = (1 + \\delta)T</span>  and let  <span class="math">t = \\frac{T&#x27;}{g}</span> . Pick  <span class="math">\\delta&#x27;</span>  such that  <span class="math">0 &lt; \\delta&#x27; &lt; \\delta</span> . Condition on the events that  <span class="math">\\operatorname{growth}^t(\\operatorname{view}, \\Delta(\\kappa), T&#x27;) = 1</span> , consistent  <span class="math">\\delta&#x27;^{T-1}(\\operatorname{view}) = 1</span> , and  <span class="math">\\operatorname{quality}^{T&#x27;-T}(\\operatorname{view}) = 1</span> ; by our assumptions and the union bound, these events occur with probability  <span class="math">1 - \\operatorname{neg}(T)</span> ; since T is polynomial in  <span class="math">\\kappa</span> , these events occur except with probability  <span class="math">\\operatorname{neg}(\\kappa)</span> . Let j, j' be players such that in view, j' is honest at r and j is honest at r + t such that  <span class="math">r + t \\leq |\\operatorname{view}|</span> .</p>

    <p class="text-gray-300">By the conditioning, we have that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By chain growth,  <span class="math">|\\mathcal{C}_{j}^{r+t}(\\mathsf{view})| |\\mathcal{C}_{j&#x27;}^{r}(\\mathsf{view})| \\ge T + \\delta T</span> ; thus  <span class="math">|\\mathcal{C}_{j}^{r+t}(\\mathsf{view})| \\ge T + \\delta T</span></li>
      <li>By &quot;truncation&quot;, at least  <span class="math">\\delta T</span>  records that were not part of the chain of j' at r are thus output as part of j's ledger.</li>
      <li>By consistency, before round r, no honest player has ever had a chain whose length exceeds  <span class="math">|\\mathcal{C}_{i&#x27;}^r(\\mathsf{view})| + \\delta&#x27; T 1</span> .</li>
      <li>Thus, we have a segment of length at least  <span class="math">(\\delta \\delta&#x27;)T</span>  of records in  <span class="math">C_j^{r+t}(\\text{view})</span>  which is output as part of j's ledger such that each record appears at a position which exceeds  <span class="math">|C_{j&#x27;}^r(\\text{view})| + \\delta&#x27;T</span> . By (strictly positive) chain quality, at least  <span class="math">(\\delta \\delta&#x27;)T\\mu &gt; 0</span>  records at a position exceeding  <span class="math">|C_{j&#x27;}^r(\\text{view})| + \\delta&#x27;T</span>  are &quot;non-adversarial&quot;; since no honest player ever had a chain of length  <span class="math">|C_{j&#x27;}^r(\\text{view})| + \\delta&#x27;T</span>  before round r, these non-adversarial records must have been provided by the environment at or after round r.</li>
    </ul>

    <p class="text-gray-300"><strong>Persistence</strong> Let  <span class="math">t = \\frac{T}{g}</span> . Condition on the events that  <span class="math">\\operatorname{growth}^t(\\operatorname{view}, \\Delta(\\kappa), T) = 1</span>  and  <span class="math">\\operatorname{consistent}^T(\\operatorname{view}) = 1</span> ; by our assumptions and the union bound, these events occur with probability  <span class="math">1 - \\operatorname{neg}(T)</span> ; since T is polynomial in  <span class="math">\\kappa</span> , these events occur except with probability  <span class="math">\\operatorname{neg}(\\kappa)</span> . Consider players i, j such that in view, i is honest at round r, and j is honest at round r' such that  <span class="math">r&#x27; \\geq r + \\Delta</span> . By the conditioning, we have that:</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{17}&lt;/sup&gt;</span> We are grateful to Elaine Shi for pointing out that a variant of our proof for the liveness property works with a sharper wait-time bound. Our original theorem and proof (which set parameters in a non-optimal way) only claimed  <span class="math">w(\\kappa,n,\\rho,\\Delta) = \\frac{(1+\\delta)T(\\kappa)}{\\mu(\\kappa,n,\\rho,\\Delta)\\cdot g(\\kappa,n,\\rho,\\Delta)}</span> . The reason we do not need a dependency on  <span class="math">\\mu</span>  is that by our definition of chain quality, it suffices for the fraction of non-adversarial blocks to be <em>positive</em> (as opposed to greater than  <span class="math">\\frac{1}{T}</span> ) to conclude the existence of at least one non-adversarial block.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Because consistent<sup>T</sup>(view) = 1, prefixes of  <span class="math">C_i^T</span> (view) and  <span class="math">C_j^{T&#x27;}</span> (view) consisting of the first  <span class="math">|C_i^T(\\text{view})| T</span>  records are identical.</li>
      <li>By the consistent-length property of the chain-growth property, it also follows that  <span class="math">|\\mathcal{C}_i^{r&#x27;}(\\mathsf{view})| \\geq |\\mathcal{C}_i^r(\\mathsf{view})|</span> .</li>
    </ul>

    <p class="text-gray-300">By the above two statements, and the fact that  <span class="math">\\mathcal{L}</span>  simply truncates the last T records of the chain, it follows that  <span class="math">\\mathcal{L}_i^r(\\text{view})</span>  is a prefix of  <span class="math">\\mathcal{L}_j^{r&#x27;}(\\text{view})</span> . Therefore, if  <span class="math">\\mathcal{L}_i^r(\\text{view})</span>  contains a message m at position p, then so does  <span class="math">\\mathcal{L}_j^{r&#x27;}(\\text{view})</span> . Because this holds for all such  <span class="math">r, r&#x27; &gt; r + \\Delta, i, j</span> , it follows that  <span class="math">persist_{\\Delta(\\kappa)}(\\text{view}) = 1</span> .</p>

    <p class="text-gray-300">Corollary 7.5. For any  <span class="math">\\lambda &gt; 1</span> , any  <span class="math">\\delta &gt; 0</span> , any  <span class="math">p(\\cdot)</span> , and any strictly positive, super-constant, polynomial  <span class="math">T(\\cdot)</span> , the public ledger  <span class="math">(\\Pi_{Nak}, \\mathcal{L}_{Nak})</span>  that is  <span class="math">T(\\cdot)</span> -induced by the blockchain protocol  <span class="math">(\\Pi_{Nak}^p, \\mathcal{C}_{Nak}^p)</span>  is persistent and live with wait-time</p>

    <p class="text-gray-300"><span class="math">$w(n,\\kappa,\\rho,\\Delta) = (1+\\delta) \\, \\frac{T(\\kappa)}{\\gamma}</span>$</p>

    <p class="text-gray-300">in  <span class="math">\\Gamma^p_{\\lambda}</span>  environments.</p>

    <p class="text-gray-300"><em>Proof.</em> From Thm. 4.1, Thm 4.2 and Thm. 4.3, for every  <span class="math">\\delta&#x27;</span> ,  <span class="math">\\delta&#x27;&#x27;</span> ,  <span class="math">(\\Pi^p_{Nak}, C^p_{Nak})</span>  has growth  <span class="math">(1 - \\delta&#x27;)\\gamma</span> , chain quality  <span class="math">1 - (1 + \\delta&#x27;&#x27;)\\frac{\\beta}{\\gamma}</span> , and satisfies consistency. By Claim 6.12 (item 1), the chain quality is thus strictly positive. From Thm. 7.4, for every  <span class="math">\\delta&#x27;&#x27;</span> ,  <span class="math">(\\Pi_{Nak}, \\mathcal{L}_{Nak})</span>  thus has rate</p>

    <p class="text-gray-300"><span class="math">$w(n,\\kappa,\\rho,\\Delta) = (1+\\delta&#x27;&#x27;&#x27;)\\frac{T(\\kappa)}{(1-\\delta&#x27;)\\gamma} &lt; (1+\\delta)\\,\\frac{T(\\kappa)}{\\gamma}</span>$</p>

    <p class="text-gray-300">where the last inequality follows by picking sufficiently small  <span class="math">\\delta&#x27;, \\delta&#x27;&#x27;&#x27;</span> .</p>

    <p class="text-gray-300">In this section, we formally demonstrate that Nakamoto's protocol satisfies neither consistency nor positive chain quality, in a fully asynchronous network without an upperbound  <span class="math">\\Delta</span>  on the network delay, even if the adversary controls just a tiny fraction of computational power. More specifically, we show that for every hardness parameter p,  <span class="math">\\Pi^p_{Nak}</span> ,  <span class="math">\\mathcal{C}^p_{Nak}</span> , satisfies neither consistency nor chain quality when  <span class="math">\\Delta = \\frac{1+\\delta}{\\rho np}</span>  for some  <span class="math">\\delta &gt; 0</span> . This demonstrates why our consistency theorem needs to rely on the assumption that  <span class="math">p \\leq \\frac{\\Theta(1)}{\\Delta n}</span> , and why the chain quality we get is  <span class="math">1 - \\frac{\\beta}{\\gamma}</span>  as opposed to just  <span class="math">1 - \\frac{\\beta}{\\alpha}</span>  (recall that  <span class="math">\\gamma = \\frac{\\alpha}{1+\\Delta\\alpha}</span>  is a discounted version of  <span class="math">\\alpha</span>  that takes delays into account.) In particular, we present a &quot;51%&quot; attack a la Nakamoto&mdash;where the attacker at some point in the future replace the whole chain with a chain of its choice, even if it only controls a small fraction of the computational power.</p>

    <p class="text-gray-300">Intuitively, in every segment of  <span class="math">\\Delta</span>  rounds, if we delay all messages between honest players until the end of the segment, honest players are effectively &quot;mining on their own&quot; and thus are unlikely to extend their chain by more than 1. The adversary, on the other hand, may coordinate its mining and thus in expectation extends its chain by  <span class="math">\\Delta \\cdot \\rho np</span> ; so if we set  <span class="math">\\Delta &gt; \\rho np</span>  the adversary can mine its own chain (without sending it to the honest player) and is likely to have a longer (private) chain.</p>

    <p class="text-gray-300"><strong>Theorem 8.1</strong> (Inconsistency of Nakamoto with Unbounded Delays). Let  <span class="math">\\widehat{\\Gamma}^p_{\\rho&#x27;,\\delta}(\\kappa,n,\\rho,\\Delta) = 1</span>  iff 1)  <span class="math">n = \\frac{2}{\\rho^2} \\cdot \\kappa</span> , 2)  <span class="math">\\rho = \\rho&#x27;</span>  and 3)  <span class="math">\\Delta = \\frac{1+\\delta}{\\rho np}</span> . For every  <span class="math">0 &lt; \\delta &lt; \\frac{1}{2}, 0 &lt; \\rho&#x27; &lt; 1</span> , and every inverse polynomial  <span class="math">p(\\cdot)</span> ,  <span class="math">(\\Pi^p_{Nak}, \\mathcal{C}^p_{Nak})</span>  does not satisfy neither consistency nor chain quality q in  <span class="math">\\widehat{\\Gamma}^p_{\\rho&#x27;,\\delta}</span> -valid environments, where q &gt; 0.</p>

    <p class="text-gray-300"><em>Proof.</em> Consider an environment Z that invokes  <span class="math">n = \\frac{2}{\\rho^2} \\cdot \\kappa</span>  players, a fraction  <span class="math">\\rho</span>  of them being adversarial, and sends messages  <span class="math">m_1, m_2 \\dots</span>  to the honest players; for simplicity, assume  <span class="math">m_i = 0</span>  for all i. The environment runs for  <span class="math">\\kappa \\Delta + 1</span>  steps.</p>

    <p class="text-gray-300">The attacker A proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A divides the rounds into  <span class="math">\\kappa</span>  segments of  <span class="math">\\Delta</span>  rounds and delays all messages sent by honest players within such a segment to the end of it (note that this means no messages are delayed more than  <span class="math">\\Delta</span> );</li>
      <li>A ignores the content of the messages sent by honest players and tries to independently build its own chain  <span class="math">\\hat{C}</span>  with messages  <span class="math">m&#x27;_1, m&#x27;_2, \\ldots</span>  such that  <span class="math">m_i \\neq m&#x27;_i</span>  for  <span class="math">\\kappa \\Delta</span>  rounds (for simplicity, assume  <span class="math">m&#x27;_i = 1</span>  for all i);</li>
      <li>In the next to last round  <span class="math">r = \\kappa \\Delta</span> , it sends  <span class="math">\\hat{C}</span>  to any (strict) subset of the honest players (and delivers it instantly).</li>
    </ul>

    <p class="text-gray-300">Note that in any view  <span class="math">\\mathsf{view} \\in \\mathsf{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa)</span>  where 1)  <span class="math">|\\hat{C}| &gt; \\kappa</span>  and 2)  <span class="math">\\hat{C}</span>  is longer than the longest chain known to the honest players, we have that  <span class="math">\\mathsf{consistent}^{\\kappa}(\\mathsf{view}) = 0</span>  and  <span class="math">\\mathsf{quality}^{\\kappa}(\\mathsf{view},1) = 0</span> . We show that the probability that both events happen is constant, which proves the theorem.</p>

    <p class="text-gray-300">The following two claims bound the probability that either event does not happen; by a union bound we can then conclude that the probability that both happen is constant.</p>

    <p class="text-gray-300">Claim 8.2. Let  <span class="math">\\hat{C}(\\text{view})</span>  denote the length of the adversary's chain in the next to last round (i.e., round  <span class="math">\\kappa\\Delta</span> ) of view. Then,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathit{view} \\leftarrow \\mathit{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa) : |\\hat{C}(\\mathit{view})| &lt; (1+\\frac{\\delta}{2})\\kappa] \\leq e^{-\\Omega(\\kappa)}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> In the  <span class="math">\\kappa\\Delta</span>  rounds, the adversary has  <span class="math">\\rho np \\cdot \\kappa\\Delta</span>  chances to mine a block; each chance succeeds with probability p; since  <span class="math">\\Delta = \\frac{(1+\\delta)}{\\rho np}</span> , the expected number of mined blocks is thus  <span class="math">(1+\\delta)\\kappa</span> . The desired bound thus follows directly from the Chernoff bound.</p>

    <p class="text-gray-300">Claim 8.3. Let  <span class="math">\\ell(\\text{view})</span>  denote the length of the longest chain known to the honest players in the last round of view. Then,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathit{view} \\leftarrow \\mathit{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa) : \\ell(\\mathit{view}) \\geq \\kappa] \\leq \\frac{3}{4}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> In every fixed segment of  <span class="math">\\Delta</span>  rounds, the number of blocks mined by a <em>single</em> honest player is distributed as a binomial distribution with parameters  <span class="math">\\Delta</span>  (trials) and p (success probability). Let X be such a random variable. The probability that some <em>fixed</em> single honest player mines more than 1 block in any <em>fixed</em> segment is</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} Pr[X &gt; 1] &amp;= 1 - Pr[X \\le 1] \\\\ &amp;= 1 - Pr[X = 0] - Pr[X = 1] \\\\ &amp;= 1 - (1 - p)^{\\Delta} - \\Delta p (1 - p)^{\\Delta - 1} \\\\ &amp;= 1 - (1 - p)^{\\Delta - 1} (1 + (\\Delta - 1)p) \\\\ &amp;\\le 1 - (1 - (\\Delta - 1)p)(1 + (\\Delta - 1)p) \\\\ &amp;= (\\Delta - 1)^2 p^2 \\\\ &amp;\\le \\frac{(1 + \\delta)}{\\rho^2 n^2} \\\\ &amp;\\le \\frac{(1 + \\delta)}{2n\\kappa} \\end{split}</span>$</p>

    <p class="text-gray-300">By a union bound over the number of players n and the number of segments  <span class="math">\\kappa</span> , we have that except with probability  <span class="math">\\frac{1+\\delta}{2} \\leq \\frac{3}{4}</span> , no honest player mines more than one block in any segment, and whenever that happens, the length of the longest chain grows by at most 1 for each segement and thus becomes of length at most  <span class="math">\\kappa</span>  after  <span class="math">\\kappa</span>  segments.</p>

    <p class="text-gray-300"><strong>Remark 8.4.</strong> We note that our proof applies even in the setting of static corruptions, and already to a weaker notion of consistency which ignores &quot;future-self consistency&quot;. In addition, the attacker never looks at the messages sent by honest players.</p>

    <p class="text-gray-300">Remark 8.5. We additionally point out that at the cost of complicating the proof (and increasing the number of players), we can obtain an even stronger attack&mdash;which works also when  <span class="math">\\Delta &gt; \\frac{1}{c \\cdot np}</span>  where  <span class="math">\\frac{1}{c} &gt; \\frac{1}{\\rho} - \\frac{1}{1-\\rho}</span>  (as opposed to just  <span class="math">\\frac{1}{\\rho}</span>  as in our previous proof)&mdash;as follows: instead or partitioning the rounds into segments, simply always delay messages between honest players by  <span class="math">\\Delta</span> . Intuitively (but significantly oversimlifying), when we delay the messages between honest parties by  <span class="math">\\Delta</span> , the expected time they need to wait until finding and propagating a block is roughly  <span class="math">\\frac{1}{(1-\\rho)np} + \\Delta</span> , whereas the adversaries only needs to wait  <span class="math">\\frac{1}{\\rho np}</span>  in expectation; thus, the attacker succeeds whenever it mines faster (i.e., when  <span class="math">\\frac{1}{\\rho} &lt; \\frac{1}{1-\\rho} + \\Delta np</span> ), and since  <span class="math">\\Delta np = \\frac{1}{c}</span> , the attack succeeds when  <span class="math">\\frac{1}{c} &gt; \\frac{1}{\\rho} - \\frac{1}{1-\\rho}</span> .</p>

    <p class="text-gray-300">We turn to describe how to formalize this attack (following the proof of 8.3). We, in fact, show an attack that works as long as  <span class="math">\\beta &gt; \\gamma</span>  (i.e., the adversary mining rate is higher than the &quot;discounted&quot; honest player mining rate), and then use this to deduce that the attack applies when  <span class="math">\\frac{1}{c} &gt; \\frac{1}{\\rho} - \\frac{1}{1-\\rho}</span> .</p>

    <p class="text-gray-300">It follows using exactly the same proof as the lowerbound on chain growth in the &quot;hybrid&quot;</p>

    <p class="text-gray-300">It follows using exactly the same proof as the lowerbound on chain growth in the &quot;hybrid&quot; model (see Claim 6.4) that we can get  <span class="math">(1+\\delta)\\gamma</span>  as an upperbound on the chain growth of the honest players in a modified game where all honest players &quot;freeze&quot; for  <span class="math">\\Delta</span>  rounds whenever some honest player mines a block (just as in the &quot;hybrid&quot; model in Claim 6.4). Since successes in each round are independent, it follows that conditioned on no single player ever mining two blocks within  <span class="math">\\Delta</span>  rounds, the chain growth of honest players is upperbounded by  <span class="math">(1+\\delta)\\gamma</span> , whereas the chain growth of the adversary is lowerbounded by  <span class="math">(1-\\delta)\\beta</span> . Thus when  <span class="math">\\beta &gt; (1+\\delta&#x27;)\\gamma</span> , if we run the experiment for t steps (and condition on no single player ever mining two blocks within  <span class="math">\\Delta</span>  rounds), we get an attack except with probability  <span class="math">e^{-\\Omega(\\gamma t)}</span> . Since  <span class="math">\\gamma</span>  is monotonically increasing in  <span class="math">\\alpha</span>  and  <span class="math">\\alpha \\leq (1-\\rho)np</span> , it follows that the above also holds when  <span class="math">\\alpha</span></p>

    <p class="text-gray-300"><span class="math">$\\beta = \\rho np &gt; \\frac{(1-\\rho)np}{1+\\Delta(1-\\rho)np}</span>$</p>

    <p class="text-gray-300">and thus when</p>

    <p class="text-gray-300"><span class="math">$\\Delta np &gt; \\frac{1}{\\rho} - \\frac{1}{1 - \\rho}</span>$</p>

    <p class="text-gray-300">So if we set  <span class="math">\\Delta = \\frac{1}{cnp}</span> , we get an attack (conditioned on no single player ever mining two blocks within  <span class="math">\\Delta</span>  rounds) when  <span class="math">\\frac{1}{c} &gt; \\frac{1}{\\rho} - \\frac{1}{1-\\rho}</span> . Finally, as in the proof of Claim 8.3 we have that at any given round r, for any fixed player</p>

    <p class="text-gray-300">Finally, as in the proof of Claim 8.3 we have that at any given round r, for any fixed player j, the probability of j mining more that 1 block within the next  <span class="math">\\Delta</span>  rounds is upperbounded by  <span class="math">(\\Delta-1)^2p^2 \\leq \\frac{1}{c^2n^2}</span> . Thus, if we set n&gt;2t, it follows that no player every mines more than 1 block within  <span class="math">\\Delta</span>  rounds, except with probability 1/2 (by the union bound).</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;18</sup>For readability, we ignore the  <span class="math">(1 + \\delta&#x27;)</span>  term.</p>

    </section>

    <section id="sec-9" class="mb-10">
      <h2 class="text-2xl font-bold">9 Acknowledgements</h2>

    <p class="text-gray-300">We are very grateful to Elaine Shi for many helpful comments on an earlier draft of this paper.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[AJK05] J. Aspnes, C. Jackson, and A. Krishnamurthy. Exposing computationally-challenged byzantine impostors, 2005.</p></li>
      <li><p class="text-gray-300">[BCL+05] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin. Secure computation without authentication. In CRYPTO'05, 2005.</p></li>
      <li><p class="text-gray-300">[BK14] Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to design fair protocols. In Advances in Cryptology&ndash;CRYPTO 2014, pages 421&ndash;439. Springer, 2014.</p></li>
      <li><p class="text-gray-300">[Blo16] Blockchain.info. Hash rate for blockchain. https://blockchain.info/charts/ hash-rate, February 2016.</p></li>
      <li><p class="text-gray-300">[BTP] BTProof. https://www.btproof.com.</p></li>
      <li><p class="text-gray-300">[Can00] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067, 2000. http://eprint.iacr.org/ 2000/067.</p></li>
      <li><p class="text-gray-300">[CL99] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI'99, 1999.</p></li>
      <li><p class="text-gray-300">[CLLM12] Kai-Min Chung, Henry Lam, Zhenming Liu, and Michael Mitzenmacher. Chernoffhoeffding bounds for markov chains: Generalized and simplified. In 29th International Symposium on Theoretical Aspects of Computer Science, STACS 2012, February 29th - March 3rd, 2012, Paris, France, pages 124&ndash;135, 2012.</p></li>
      <li><p class="text-gray-300">[CSWH00] I. Clarke, O. Sandberg, B. Wiley, and T.W. Hong. Freenet: A distributed anonymous information storage and retrieval system. In Proceedings of the ICSI Workshop on Design Issues in Anonymity and Unobservability, 2000.</p></li>
      <li><p class="text-gray-300">[DLN02] David Karger David Liben-Nowell, Hari Balakrishnan. Analysis of the evolution of peer-to-peer systems. In PODC'02, 2002.</p></li>
      <li><p class="text-gray-300">[DW13] Christian Decker and Roger Wattenhofer. Information propagation in the bitcoin network. In IEEE International Conference on Peer-to-Peer Computing, pages 1&ndash;10, 2013.</p></li>
      <li><p class="text-gray-300">[DR01] P. Druschel and A. Rowstron. Past: Persistent and anonymous storage in a peer-to-peer networking environment. In HotOS 2001, pages 65&ndash;70, 2001.</p></li>
      <li><p class="text-gray-300">[DLS88] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. Journal of the ACM (JACM), 35(2):288&ndash;323, 1988.</p></li>
      <li><p class="text-gray-300">[DN92] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In CRYPTO'92, pages 139&ndash;147, 1992.</p></li>
      <li><p class="text-gray-300">[ES14] Ittay Eyal and Emin G&uml;un Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Financial Cryptography and Data Security, pages 436&ndash;454. Springer, 2014.</p></li>
      <li><p class="text-gray-300">[FVY14] Conner Fromknecht, Dragos Velicanu, and Sophia Yakoubov. A decentralized public key infrastructure with identity retention. IACR Cryptology ePrint Archive, 2014:803, 2014.</p></li>
      <li><p class="text-gray-300">[GKL15] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology-EUROCRYPT 2015, pages 281&ndash; 310. Springer, 2015.</p></li>
      <li><p class="text-gray-300">[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or a completeness theorem for protocols with honest majority. In STOC, pages 218&ndash;229, 1987.</p></li>
      <li><p class="text-gray-300">[KP15] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols, 2015.</p></li>
      <li><p class="text-gray-300">[KMS+15] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. Technical report, Cryptology ePrint Archive, Report 2015/675, 2015. http://eprint. iacr. org, 2015.</p></li>
      <li><p class="text-gray-300">[Lam10] Leslie Lamport. Byzantizing paxos by refinement, 2010.</p></li>
      <li><p class="text-gray-300">[Lam11] Leslie Lamport. Leaderless byzantine paxos. In DISC'11, 2011.</p></li>
      <li><p class="text-gray-300">[Lit] Litecoin. https://litecoin.org.</p></li>
      <li><p class="text-gray-300">[MA05] Jean-Philippe Martin and Lorenzo Alvisi. Fast byzantine consensus. In DSN'05, 2005.</p></li>
      <li><p class="text-gray-300">[ML14] A. Miller and J. J. LaViola. Anonymous byzantine consensus from moderately-hard puzzles: A model for bitcoin, 2014.</p></li>
      <li><p class="text-gray-300">[mtg10] mtgox. https://bitcointalk.org/index.php?topic=2227.msg29606#msg29606, 2010.</p></li>
      <li><p class="text-gray-300">[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.</p></li>
      <li><p class="text-gray-300">[Nam] Namecoin. https://www.namecoin.org.</p></li>
      <li><p class="text-gray-300">[Oku05a] M. Okun. Agreement among unacquainted byzantine generals. In DISC'05, pages 499&ndash;500, 2005.</p></li>
      <li><p class="text-gray-300">[Oku05b] M. Okun. Distributed computing among unacquainted processors in the presence of byzantine failures, 2005.</p></li>
      <li><p class="text-gray-300">[OB08] M. Okun and A. Barak. Efficient algorithms for anonymous byzantine agreement. Theor. Comp. Sys., 42:222&ndash;238, 2008.</p></li>
      <li><p class="text-gray-300">[PS15] Rafael Pass and Abhi Shelat. Micropayments for decentralized currencies. In CCS'15, 2015.</p></li>
      <li><p class="text-gray-300">[PS16a] Rafael Pass and Elaine Shi. Fruitchains: An (almost) optimally fair blockchain, 2016.</p></li>
      <li><p class="text-gray-300">[PS16b] Rafael Pass and Elaine Shi. Hybrid consensus, 2016.</p></li>
      <li><p class="text-gray-300">[PSL80] M. C. Pease, R. E. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27:228&ndash;234, 1980.</p></li>
      <li><p class="text-gray-300">[PD15] Joseph Poon and Thaddeus Dryja. The bitcoin lightning network: Scalable off-chain instant payments draft 0.5.9.1. https://lightning.network/ lightning-network-paper.pdf, 2015.</p></li>
      <li><p class="text-gray-300">[RFH+00] S. Ratanasamy, P. Francis, M. Handley, R. Karp, and S. Shenker. A scalable contentaddressable network. In SIGCOMM'00, 2000.</p></li>
      <li><p class="text-gray-300">[SZ15] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security, pages 507&ndash;527. Springer, 2015.</p></li>
      <li><p class="text-gray-300">[SMK+01] Ion Stoica, Robert Morris, David Karger, M. Frans Kaashoek, and Hari Balakrishnan. Chord: A scalable peer-to-peer lookup service for internet applications. In SIG-COMM'01, 2001.</p></li>
    </ul>

    <p class="text-gray-300">We recall the standard Chernoff bound.</p>

    <p class="text-gray-300">Lemma A.1 (Multiplicative Chernoff Bound). Let X1, . . . X<sup>n</sup> be independent Boolean random variables, such that for all i, Pr[X<sup>i</sup> = 1] = p; let X be the sum of these variables, and &micro; be the expectation of the sum. Then for any &delta; &isin; (0, 1], we have</p>

    <p class="text-gray-300"><span class="math">$Pr[X &gt; (1+\\delta)\\mu] &lt; e^{-\\Omega(\\delta^2\\mu)}</span>$</p>

    <p class="text-gray-300"><span class="math">$Pr\\left[X &lt; (1 - \\delta)\\,\\mu\\right] &lt; e^{-\\Omega\\left(\\delta^2\\mu\\right)}</span>$</p>

    </section>
`;
---

<BaseLayout title="Analysis of the Blockchain Protocol in Asynchronous Networks (2016/454)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/454
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Does Nakamoto&#x27;s Protocol Achieve Consistency?</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Main Results</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">What is a Blockchain?</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Is Nakamoto&#x27;s Protocol Really Permissionless?</a></li>
            <li><a href="#sec-1.5" class="hover:text-white">An Experimental Interpretation</a></li>
            <li><a href="#sec-1.6" class="hover:text-white">Proof Highlights</a></li>
            <li><a href="#sec-1.7" class="hover:text-white">Related Work</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Blockchain Protocols and Executions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Blockchain Protocols</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">A remark about the communication model</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Blockchain protocols in the ROM</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Nakamoto&#x27;s Protocol</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Formal Definitions of the Desiderata</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Chain Growth</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Chain Quality</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Consistency</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Chain Growth Upperbound</a></li>
            <li><a href="#sec-3.5" class="hover:text-white">Some Remarks on T v.s. \kappa</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">Main Theorem Statements</a></li>
        <li>
          <a href="#sec-5" class="hover:text-white">The \mathcal&#123;F&#125;_&#123;tree&#125; Hybrid Model</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">The \mathcal&#123;F&#125;_&#123;tree&#125; Oracle</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Nakamoto in the \mathcal&#123;F&#125;_&#123;tree&#125;-hybrid</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Reducing the security of (\Pi_&#123;\text&#123;tree&#125;&#125;, \mathcal&#123;C&#125;_&#123;\text&#123;tree&#125;&#125;) to the security of (\Pi_&#123;Nak&#125;, \mathcal&#123;C&#125;_&#123;Nak&#125;)</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Proofs of Security in the \mathcal&#123;F&#125;_&#123;tree&#125; Hybrid Model</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Proof of the Chain-Growth Property (Theorem 4.1)</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Proof of the Chain Quality Property (Theorem 4.2)</a></li>
            <li><a href="#sec-6.3" class="hover:text-white">Proof of the Consistency Property (Theorem 4.3)</a></li>
            <li><a href="#sec-6.4" class="hover:text-white">Proof of the Upperbound on Chain Growth Property (Theorem 4.4)</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-7" class="hover:text-white">Application: Public Ledger</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-7.1" class="hover:text-white">Definition of a Public Ledger</a></li>
            <li><a href="#sec-7.2" class="hover:text-white">Constructing a Public Ledger from a Blockchain</a></li>
          </ol>
        </li>
        <li><a href="#sec-8" class="hover:text-white">An Attack on Nakamoto with &quot;Long&quot; Delays</a></li>
        <li><a href="#sec-9" class="hover:text-white">Acknowledgements</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Appendix</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="analysis-of-the-blockchain-protocol-in-asynchronous-networks-2016" />
  </article>
</BaseLayout>
