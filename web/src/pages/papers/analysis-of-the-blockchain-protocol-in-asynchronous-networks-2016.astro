---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/454';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Analysis of the Blockchain Protocol in Asynchronous Networks';
const AUTHORS_HTML = 'Rafael Pass, Lior Seeman, abhi shelat';

const CONTENT = `    <p class="text-gray-300">Analyis of the Blockchain Protocol in Asynchronous Networks</p>

    <p class="text-gray-300">Rafael Pass* Cornell Tech rafael@cornell.edu</p>

    <p class="text-gray-300">Lior Seeman Harvard University lior.seeman@gmail.com</p>

    <p class="text-gray-300">abhi shelat† U of Virginia abhi@virginia.edu</p>

    <p class="text-gray-300">September 13, 2016</p>

    <p class="text-gray-300">Nakamoto's famous blockchain protocol enables achieving consensus in a so-called permissionless setting—anyone can join (or leave) the protocol execution, and the protocol instructions do not depend on the identities of the players. His ingenious protocol prevents "sybil attacks" (where an adversary spawns any number of new players) by relying on computational puzzles (a.k.a. "moderately hard functions") introduced by Dwork and Naor (Crypto'92).</p>

    <p class="text-gray-300">The analysis of the blockchain consensus protocol (a.k.a. Nakamoto consensus) has been a notoriously difficult task. Prior works that analyze it either make the simplifying assumption that network channels are fully synchronous (i.e. messages are instantly delivered without delays) (Garay et al, Eurocrypt'15) or only consider specific attacks (Nakamoto'08; Sampolinsky and Zohar, FinancialCrypt'15); additionally, as far as we know, none of them deal with players joining or leaving the protocol.</p>

    <p class="text-gray-300">In this work we prove that the blockchain consensus mechanism satisfies a strong forms of consistency and liveness in an asynchronous network with adversarial delays that are  <span class="math">a</span> -priori bounded, within a formal model allowing for adaptive corruption and spawning of new players, assuming that the computational puzzle is modeled as a random oracle. (We complement this result by showing a simple attack against the blockchain protocol in a fully asynchronous setting, showing that the puzzle-hardness needs to be appropriately set as a function of the maximum network delay; this attack applies even for static corruption.)</p>

    <p class="text-gray-300">As an independent contribution, we define an abstract notion of a blockchain protocol and identify appropriate security properties of such protocols; we prove that Nakamoto's blockchain protocol satisfies them and that these properties are sufficient for typical applications; we hope that this abstraction may simplify further applications of blockchains.</p>

    <p class="text-gray-300">*</p>

    <p class="text-gray-300">Supported in part by NSF Award CNS-1217821, AFOSR Award FA9550-15-1-0262, a Microsoft Faculty Fellowship, and a Google Faculty Research Award.</p>

    <p class="text-gray-300">†Supported in part by NSF grants CNS-0845811, TC-1111781, TC-0939718, a Microsoft Faculty Fellowship, an SAIC Faculty Award, and a Google Faculty Research Award.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Distributed systems have been historically analyzed in a closed setting in which both the number of participants in the system, as well as their identities, are common knowledge. A departure from this model started with the design of peer-to-peer systems, e.g. with systems such as Napster and Gnutella for file sharing. The success of those systems led to academically designed systems such as Freenet <em>[x10]</em>, CAN <em>[RFH^{+}00]</em>, Chord <em>[SMK^{+}01]</em>, and Pastry <em>[x15]</em> which offered redundant file storage, distributed hashing, selection of nearby servers, and hierarchical naming.</p>

    <p class="text-gray-300">A novel aspect of these peer systems is that they are permissionless— anyone can join (or leave) the protocol execution (without getting permission from a centralized or distributed authority), and the protocol instructions do not depend on the identities of the players. As participants may continuously join and leave the system, successful permissionless systems require a fault-tolerant design. Unfortunately, the mentioned systems, while “robust” with respect to measures such as connectivity <em>[x11]</em>, were not designed to tolerate against adversarial behavior. For example, there were no guarantee that one participant’s experience with the system was consistent with another’s: Two participants requesting the same file may end up receiving different versions and never know that they did. At first sight one may think that using standard consensus/Byzantine agreement methods (e.g., <em>[x12, x22, x21, x22]</em>) could help overcome this issue. The problem is that such protocols require that a large fraction of the participating players are honest, but in the permissionless setting an attacker can trivially mount a so-called “sybil attack”—it simply spawns lots of players (that it controls) and can thus easily ensure that it controls a majority of all the players. Indeed, Barak et al <em>[BCL^{+}05]</em> proved that this is a fundemental problem with the permissionless model.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Nakamoto’s Blockchain</h4>

    <p class="text-gray-300">In 2008, Nakamoto <em>[x24]</em> proposed his celebrated “blockchain protocol” which overcomes the above-mentioned problems by relying on the idea of computational puzzles—a.k.a. moderately hard functions or proofs of work—put forth by Dwork and Naor <em>[x13]</em>. Rather than attempting to provide robustness whenever the majority of the participants are honest (since participants can be easily spawned in the permissionless setting), it attempts to provide robustness as long as a majority of the computing power is held by honest participants. It explicitly claims consistency properties that are strong enough to support a financial transaction system; indeed, the first application of a blockchain is the Bitcoin digital currency which needs strong properties to prevent fraud and double-spending attacks. A number of follow-up digital currencies <em>[x20]</em>, micro-payment schemes <em>[x27, x23]</em>, time-stamping <em>[x4]</em>, naming <em>[x25]</em>, fair secure computation <em>[x5]</em> and secure messaging and PKI applications <em>[x17]</em> are based on the blockchain idea. Additionally, financial firms have announced intentions of using the blockchain to lower transaction costs, remove geopolitical barriers to transferring assets, and reconcile differences between systems.</p>

    <p class="text-gray-300">The core blockchain protocol (a.k.a. “Nakamoto consensus”, or the “Bare-bones blockchain protocol”), roughly speaking, is a method for maintaining a public, immutable and ordered ledger of records (for instance, in the bitcoin application, these records are simply transactions); that is, records can be added to the end of the ledger at any time (but only to the end of it); additionally, we are guaranteed that records previously added cannot be removed or reordered and that all honest users have a consistent view of the ledger. While standard consensus/Byzantine agreement mechanisms could be used to achieve such an immutable ordered sequence of records, the amazing aspect of Nakamoto’s consensus mechanism is that it functions in a fully permissionless setting.</p>

    <p class="text-gray-300">Roughly speaking, in his protocol each participant maintains its own local “chain” of “blocks” of records/messages—called the blockchain. Each block consist of a triple <span class="math">(h_{-1},\\eta,\\mathsf{m})</span> where <span class="math">h_{-1}</span> is a pointer to the previous block in chain, <span class="math">\\mathsf{m}</span> is the record component of the block, and <span class="math">\\eta</span> is a “proof-of-work”—a solution to a computational puzzle that is derived from the pair <span class="math">(h_{-1},\\mathsf{m})</span>. The</p>

    <p class="text-gray-300">proof of work can be thought of as a “key-less digital signature” on the whole blockchain up until this point.</p>

    <p class="text-gray-300">Concretely, Nakamoto’s protocol is parametrized by a parameter <span class="math">p</span>—which we refer to as the <em>mining hardness parameter</em>, and a proof-of-work is deemed valid if <span class="math">\\eta</span> is a string such that <span class="math">\\mathsf{H}(h_{-1},\\eta,\\mathsf{m})&lt;D_{p}</span>, where <span class="math">\\mathsf{H}</span> is a hash function (modeled as a random oracle) and <span class="math">D_{p}</span> is set so that the probability that an input satisfies the relation is less than <span class="math">p</span>. (In practice, the hardness parameter <span class="math">p</span> is adaptively modified through some external process to incorporate an estimate of the number of participants in the system and the network delays; we shall return to the choice of <span class="math">p</span> later.) At any point of the protocol execution, each participant attempts to increase the length of its own chain by “mining” for a new block: upon receiving some record <span class="math">\\mathsf{m}</span>, it picks a random <span class="math">\\eta</span> and checks whether <span class="math">\\eta</span> is a valid proof of work w.r.t. <span class="math">\\mathsf{m}</span> and <span class="math">h_{-1}</span>, where <span class="math">h_{-1}</span> is a pointer to the last block of its current chain; if so, it extends is own local chain and broadcast it to the all the other participants (the broadcast takes places through some gossip protocol, which we do not discuss here). Whenever a participant receives a chain that is longer than its own local chain, it replaces its own chain with the longer one.</p>

    <p class="text-gray-300">The fundamental question with such an approach is whether honest participants eventually end up with the same longest chain of blocks, and thus, the same ordered list of records, or whether the system devolves into a state where participants have <em>inconsistent</em> local chains.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Does Nakamoto’s Protocol Achieve Consistency?</h3>

    <p class="text-gray-300">Requiring that all participant agree on the <em>whole</em> chain is a too strong consistency requirement if the protocol is executed on a network with message delays (as Nakamoto’s protocol is intended to be)—for instance, some players may have received the “last block” whereas other have not. Rather, as discussed by Nakamoto <em>[x18]</em>, the appropriate notion of consistency for the blockchain—which we refer to as <em><span class="math">T</span>-consistency</em>—should require that honest players agree on the current chain, <em>except</em> for potentially a small number, <span class="math">T</span>, of “unconfirmed” blocks at the end of the chain. If we can show this property holds except with exponentially small probability in <span class="math">T</span>, honest parties are guaranteed that for a sufficiently large choice of <span class="math">T</span> (except with tiny probability), “confirmed” blocks will never be lost from the chain (which is what is needed for all the above-mentioned applications; for instance, for the case of bitcoin, it ensures that players cannot double-spend money).</p>

    <p class="text-gray-300">Nakamoto provides an initial analysis of consistency assuming that the adversary only mounts a particular attack strategy (namely, an attacker tries to generate a chain faster than the honest players); for instance, his analysis does not consider more sophisticated attack strategies where the adversary may attempt to “split the players” and have them work on different chains.</p>

    <p class="text-gray-300">A beautiful recent work by Garay, Kiayas and Leonardos <em>[x11]</em> provides a more formal model for studying Nakamoto’s blockchain protocol; their analysis, however, only considers a <em>synchronous network</em> with a rushing adversary—that is, messages sent in a particular round arrive in the next round <em>without any delays</em>, but the adversary gets to see all messages sent by honest parties before having to send its own message. In this model, they demonstrate that the blockchain protocol satisfies consistency (under appropriate assumptions on the mining hardness and the relative computational power held by the attacker), in a setting with a fixed number of players (but the protocol is not aware of the exact number of players).</p>

    <p class="text-gray-300">Assuming a synchronous network, however, is a very strong, possibly unrealistic assumption; indeed, Nakamoto’s protocol is explicitly designed to work in a network <em>with message delays</em>, and indeed is executed on such a network (i.e., the Internet).</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">The Power of Network Delays</h4>

    <p class="text-gray-300">Consequently, we are here interested in analyzing to what extent the blockchain protocol satisfies consistency in the more realistic setting of an <em>asynchronous network</em>, where an adversary controls the scheduling/delivery of messages between honest parties.</p>

    <p class="text-gray-300">As we observe (and formally prove in Theorem 8.1), in a <em>fully</em> asynchronous setting, where an adversary can arbitrarily delay messages, consistency cannot be satisfied: an adversary controlling a small percentage of the computational power can simply delay messages from honest parties for sufficiently long to ensure that the adversary can come up with its own chain (containing <em>any</em> set of records it desires) which is longer than the chain held by all honest players, and consequently it can make the honest players switch to the adversarial chain at any point. In fact, our attack works even in the setting of <em>partial synchrony</em> (see e.g. <em>[x10]</em>) where there is an <em>a-priori</em> bound <span class="math">\\Delta</span> on the network latency (that is, the adversary may arbitrary delay messages as long as it delivers them within time <span class="math">\\Delta</span>), as long as the mining hardness parameter <span class="math">p</span> exceeds <span class="math">\\frac{1}{\\rho n\\Delta}</span>, where <span class="math">\\rho</span> is the fraction of the computational power held by the adversary and <span class="math">n</span> is the number of players (and <span class="math">p</span> is the mining-hardness parameter in Nakamoto’s protocol). Indeed, Decker and Wattenhofer <em>[x12]</em> already experimentally observed that increasing the networks delays in Nakamoto’s protocol leads to increased forks, and they noted (through heuristic calculations) that an attacker could use these delays to violate consistency with an attack that requires less than 50% of the mining power.</p>

    <p class="text-gray-300">Motivated by the work by Decker and Wattenhofer, an elegant work by Sompolinsky and Zohar <em>[x24]</em> provides some initial analysis of the blockchain protocol even in a network with (bounded) delays. They show how to extend Nakamoto’s analysis to deal with (bounded) delays, but again (just like Nakamoto) they only consider particular attack strategies—e.g., they do not consider “block-withholding (or “pre-mining”) attacks” where the attacker withholds blocks for later use <em>[x20, x11]</em>; furthermore, their analysis only shows that consistency holds in the limit (when <span class="math">T</span> goes to infinity), and consequently their bounds (even for the restricted attacker setting) are not useful for applications.</p>

    <p class="text-gray-300">This leaves open the question of providing an analysis of Nakamoto’s blockchain protocol—or in fact <em>any</em> consensus protocol in the permissionless setting—with respect to <em>arbitrary</em> attack strategies in networks with <span class="math">\\Delta</span>-bounded delays.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><em>Does Nakamoto’s blockchain protocol satisfy consistency when executed in asynchronous networks with <span class="math">\\Delta</span>-bounded delays?</em></p>
    </blockquote>

    <p class="text-gray-300">As mentioned above, Garay et al <em>[x16]</em> provide a positive answer for the special case when <span class="math">\\Delta=1</span> (i.e., messages are delivered in the next time step), and Sampolinsky and Zohar <em>[x24]</em> show that certain (natural, but restricted) strategies cannot be employed to break consistency of Nakamoto’s protocol (in the limit) in <span class="math">\\Delta</span>-bounded delay networks.</p>

    <p class="text-gray-300">Let us highlight why dealing with network delays in the “proof-of-work” setting (where we assume that a majority of the computing power is honest) is significantly more challenging than in the “standard” permissioned setting: In the standard model, any synchronous protocol can be turned into a protocol that is secure also in <span class="math">\\Delta</span>-delay networks by simply requiring all honest players to always “wait” (without doing anything) for <span class="math">\\Delta</span> time steps before responding to any message, effectively emulating synchronous rounds. This approach completely fails in the proof-of-work setting—the adversary can now increase its computational resources by a factor <span class="math">\\Delta</span> (since it can try to solve puzzle when the honest players are “waiting”).</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Main Results</h3>

    <p class="text-gray-300">In this paper, we resolve the above-mentioned problem and demonstrate that (assuming puzzles are modeled as random oracles) Nakamoto’s protocol satisfies consistency (under appropriate assumptions on the mining hardness and the relative computational power held by the attacker) also</p>

    <p class="text-gray-300">in networks with message delays. We emphasize that our analysis is not just a combination of the techniques/ideas from <em>[x11]</em> and <em>[x29]</em>—in fact, the bulk of our proof consists of dealing with the attack strategies which are omitted from the analysis in <em>[x29]</em>, and dealing with them requires us to consider an altogether different proof technique. Additionally, our analysis considers adaptive corruption and spawning of new players (i.e., new players joining); as far as we know, it is the first analysis to formally deal with spawning of new players (which is a cruical desidrata of the blockchain protocol).</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">A Consistency Theorem with Delays</h4>

    <p class="text-gray-300">We provide a rough overview of our model and consistency theorem. Consider Nakamoto’s protocol with mining-hardness <span class="math">p</span> (that is, a single random oracle query is a successful “in mining” with probability <span class="math">p</span>), and consider an execution with <span class="math">n</span> players, each of them with identical computing power—we assume the protocol proceeds in rounds (timesteps), and in each round each player gets a single random oracle query and the adversary controlling a <span class="math">\\rho</span> fraction of the players gets <span class="math">\\rho n</span> random oracles queries (as in <em>[x11]</em>, the honest players need to make their queries in parallel, but we allow the adversary to makes the queries sequentially). Let <span class="math">\\alpha=1-(1-p)^{(1-\\rho)n}</span> be the probability that some honest player succeeds in solving a puzzle in one round, and let <span class="math">\\beta=\\rho np</span> be the expected number of blocks that an attacker can mine in a round. When <span class="math">p\\ll 1/n</span> (which is the case considered in practice), we have that <span class="math">\\alpha\\approx p(1-\\rho)n</span> and thus <span class="math">\\frac{\\alpha}{\\beta}\\approx\\frac{1-\\rho}{\\rho}</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1.1.</h6>

    <p class="text-gray-300">Assume there exists some <span class="math">\\delta&amp;gt;0</span> such that</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-(2\\Delta+2)\\alpha)\\geq(1+\\delta)\\beta.</span></p>

    <p class="text-gray-300">Then, except with exponentially small probability (in <span class="math">T</span>), Nakamoto’s protocol satisfies <span class="math">T</span>-consistency in the random oracle model, assuming the network’s latency is bounded by <span class="math">\\Delta</span>.</p>

    <p class="text-gray-300">As a consequence we have that as long as <span class="math">\\rho&amp;lt;\\frac{1}{2}</span> (i.e., the adversary controls less than half of the computational power), for every <span class="math">\\Delta</span> there exists some (sufficiently small) <span class="math">p</span>, such that Nakamoto’s protocol satisfies consistency. (Note that as mentioned above, if <span class="math">p&amp;gt;\\frac{1}{\\rho n\\Delta}</span>, Nakamoto’s fails to satisfy consistency.)</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.3 What is a Blockchain?</h3>

    <p class="text-gray-300">As an independent contribution, we formally define an <em>abstract</em> notion of a blockchain (as opposed to <em>the</em> blockchain protocol proposed by Nakamoto) and put forward desired security properties of such a blockchain. We believe that having such a notion will a) simplify applications of blockchains (as we can ignore the implementation details of the blockchain protocol) and b) enable formally studying to what extent the protocol can be improved. (As we explain below, both of these points have been illustrated in subsequent works <em>[x27, x28]</em>.) We mention that while abstract models for <em>higher-level applications</em> of the blockchain (e.g., a “smart contract” abstraction) were provided in the UC framework—see <em>[KMS^{+}15, x3]</em>—it is not clear to what extent those abstractions can be satisfied by Nakamoto’s protocol; rather, we are here interested in having a simple notion of the blockchain itself that we can prove is satisfied by Nakamoto’s protocol and yet is useful for applications.</p>

    <p class="text-gray-300">Roughly speaking, a blockchain is an interactive protocol where each participant has a local variable state which contains a list of messages <span class="math">\\vec{m}</span>, called the “chain”. Players receive inputs, called records/batches/messages, that they attempt to include in the chain of themselves and of others. We require the following properties from a secure blockchain:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>consistency</em>: with overwhelming probability (in <span class="math">T</span>), at any point, the chains of two honest players can differ only in the last <span class="math">T</span> blocks;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>future self-consistence</em>: with overwhelming probability (in <span class="math">T</span>), at any two points <span class="math">r,s</span> the chains of any honest player at <span class="math">r</span> and <span class="math">s</span> differ only within the last <span class="math">T</span> blocks;</li>

      <li><em><span class="math">g</span>-chain-growth</em>: with overwhelming probability (in <span class="math">T</span>), at any point in the execution, the chain of honest players grows by at least <span class="math">T</span> messages in the last <span class="math">\\frac{T}{g}</span> rounds; <span class="math">g</span> is called the chain-growth of the protocol.</li>

      <li>the <em><span class="math">\\mu</span>-chain quality</em> with overwhelming probability (in <span class="math">T</span>), for any <span class="math">T</span> consecutive messages in any chain held by some honest player, the fraction of messages that were “contributed by honest players” is at least <span class="math">\\mu</span>.</li>

    </ul>

    <p class="text-gray-300">The consistency property is just the “plain” one considered already by Nakamoto <em>[x11]</em> (and formalized by Garay et al <em>[x6]</em>). As we note, however, this consistency property is typically not sufficient for applications. In particular, it does not rule out a protocol that oscillates between two different chains <span class="math">\\vec{m}_{1},\\vec{m}_{2}</span>; on even rounds all players have <span class="math">\\vec{m}_{1}</span> as their chain, and on odd rounds <span class="math">\\vec{m}_{2}</span>. Clearly such a protocol does not suffice for typical applications (e.g., bitcoin, or achieving a public ledger). Thus, to prevent it, we introduce the <em>future self-consistency</em> property.</p>

    <p class="text-gray-300">The lower bound on chain-growth was explicitly considered by Sampolinsky and Zohar <em>[x15]</em> (but they only consider growth in expectation); Garay et al <em>[x6]</em> implicitly show a lower-bound on on chain growth within one of their proofs, and <em>[x10]</em> explicitly introduce it as a desideratum. In this paper, we additionally introduce an <em>upper-bound</em> on chain growth as a desirable property; as shown in subsequent work <em>[x14, x15]</em>, this property is useful in applications.</p>

    <p class="text-gray-300">Finally, the chain quality property was first discussed on the Bitcoin forum <em>[x13]</em> and made explicit in the selfish mining attacks by Eyal and Sirer <em>[x5]</em> w.r.t. the bitcoin application of the blockchain. The property was first formalized, and given the name “chain quality” by Garay et al <em>[x6]</em>; Garay et al <em>[x6]</em> furthermore show new applications of it (as we discuss shortly).</p>

    <p class="text-gray-300">We show the usefulness of these properties by demonstrating that <em>any</em> blockchain protocol satisfying them can be used to achieve a <em>public ledger (i.e., consensus)</em> satisfying a) <em>persistency</em> (namely, if a message gets added to the public ledger, it never gets removed) and b) <em>liveness</em> (that is, if all honest players want to add a some message to the ledger, the message should eventually appear on it). We mention that Garay et al <em>[x6]</em> already noted that, <em>intuitively</em>, the chain quality property implies liveness (since, by chain quality the adversary cannot monopolize the chain), and consistency implies persistence. However, although they show how to use Nakamoto’s protocol to obtain a public ledger (in the synchronous model), they use those two properties <em>and</em> additional properties of the concrete protocol to establish it. Kiayias and Panagiotakos <em>[x10]</em> demonstrate that by additionally requiring chain growth suffices to prove liveness in a black-box way, but proving persistence still required an analysis of the concrete protocol. We highlight that it is our notion of future-self consistency that allows us to obtain also persistence in a black-box way. Subsequent works by Pass and Shi <em>[x14, x15]</em> give further evidence to the usefulness of our abstract notion of a blockchain (and its security properties).</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Main theorem</h4>

    <p class="text-gray-300">Our main result demonstrates that Nakamoto’s protocol achieves consistency as well as all of our other desiderata. Let <span class="math">\\gamma=\\frac{\\alpha}{1+\\Delta\\alpha}</span>; think of <span class="math">\\gamma</span> as a “discounted” version of <span class="math">\\alpha</span> due to delays on the network. Intuitively, by delaying messages the adversary gets additional computation time.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.2.</h6>

    <p class="text-gray-300">Assume there exists some <span class="math">\\delta&gt;0</span> such that</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-2(\\Delta+1)\\alpha)\\geq(1+\\delta)\\beta.</span></p>

    <p class="text-gray-300">Let <span class="math">g=\\frac{\\gamma}{1+\\delta}</span> and <span class="math">\\mu=1-(1+\\delta)\\frac{\\beta}{\\gamma}</span>. Then Nakamoto’s protocol satisfies consistency, future self consistency, <span class="math">\\mu</span>-chain quality and <span class="math">g</span>-chain growth.</p>

    <p class="text-gray-300">Note that when <span class="math">p\\ll 1/n\\Delta</span> (which is the case considered in practice), we have that <span class="math">\\gamma\\approx\\alpha\\approx(1-\\rho)np</span> and thus <span class="math">\\frac{\\gamma}{\\beta}\\approx\\frac{1-\\rho}{\\rho}</span>. As a consequence, we have the following corollary:</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Corollary 1.3.</h6>

    <p class="text-gray-300">Assume <span class="math">\\rho&lt;\\frac{1}{2}</span>. Then for every <span class="math">n,\\Delta</span>, there exists some sufficiently small <span class="math">p_{0}=\\Theta(\\frac{1}{\\Delta n})</span> such that Nakamoto’s protocol with mining parameter <span class="math">p\\leq p_{0}</span> satisfies consistency, future self consistency, <span class="math">1-\\frac{\\rho}{1-\\rho}</span>-chain quality and <span class="math">\\frac{pn}{2}</span>-growth.</p>

    <p class="text-gray-300">Thus, as long as <span class="math">\\rho&lt;\\frac{1}{2}</span>, Nakamoto’s protocol guarantees that messages contributed by honest players will eventually end up on the chain, and as long as <span class="math">\\rho&lt;\\frac{1}{3}</span>, we have that half of the messages on the chain will be contributed by honest players. We mention that our chain quality bound matches that established by Garay et al <em>[x11]</em> assuming <em>no delays</em> (i.e., <span class="math">\\Delta=1</span>), and is tight due to the selfish mining (a.k.a. “mining-cartel”) attacks of <em>[x23, x10]</em>).</p>

    <p class="text-gray-300">A natural question left open by our main theorem is whether there exists protocols satisfying our abstract notion of a blockchain that improve upon the parameters achieved by Nakamoto’s protocol (i.e., is Nakamoto’s protocol “optimal”?). A subsequent result by Pass and Shi <em>[x25]</em> shows how we can “amplify” the chain quality in Nakamoto’s protocol to achieve a “close-to-optimal” chain quality of <span class="math">1-(1-\\delta)\\rho</span>, where <span class="math">\\delta</span> is an arbitrary small constant. We highlight that the results in <em>[x25]</em> relies on the analysis from this paper in a blackbox way.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">1.4 Is Nakamoto’s Protocol Really Permissionless?</h3>

    <p class="text-gray-300">Our theorem only shows that for every <span class="math">n,\\Delta</span>, there exists some mining-hardness parameter <span class="math">p</span> that makes the protocol secure, so it might seem like the protocol needs to know <span class="math">n</span> and therefore cannot be “permissionless”; see Section 1.5 for an experimental evaluation of how the level of security depends on the choice of <span class="math">p</span>. (As we pointed out above, this is not an anomaly of our analysis; when <span class="math">p&gt;\\frac{1}{n\\rho\\Delta}</span> the protocol is insecure.) The point, however, is that the protocol only needs to know a <em>very rough upper-bound</em> on the number of players <span class="math">n</span> (but the worse the upper-bound gets, the worse the efficiency of the protocol becomes.)</p>

    <p class="text-gray-300">We additionally remark that our theorem regarding the lower bound on the chain growth actually does not make any assumption about <span class="math">p</span>; this means that the honest players can use an initial set-up phase to estimate the chain growth and from this deduce a weak upper-bound on the number of players <span class="math">n</span>, and then use this new upperbound to run the protocol. Indeed, as we hinted to before, the bitcoin protocol recalibrates the mining hardness parameter <span class="math">p</span> every 2016 blocks (roughly 2 weeks) based on the time it took to find 2016 blocks. We leave a formal analysis of this update procedure for future work.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">1.5 An Experimental Interpretation</h3>

    <p class="text-gray-300">In this section, we provide an experimental interpretation of our theorems by using estimates of parameters in a real world setting. In early 2016, the Bitcoin network collectively performed roughly <span class="math">10^{18}</span> hash operations per second <em>[x3]</em>. Several companies sell mining hardware that operates at <span class="math">10^{12}</span> hash operations per second. To be consistent with these values, we consider <span class="math">n=10^{5}</span> participants and <span class="math">\\Delta=10^{13}</span>, which corresponds to roughly <span class="math">10s</span> delay for the network at the given hashing rates. The 10s estimation is based on an <em>assumption</em> that most of the <em>computational power</em> contributing to the Bitcoin network operates with a connection that exceeds 1mb/s, thus, each block takes roughly 1s to transmit, and the diameter of the network is less than 10 hops. These</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: For  <span class="math">n = 10^5</span>  and  <span class="math">\\Delta = 10^{13}</span>  (i.e., 10s delays at 1TH/s for commercially available mining hardware—these parameters roughly coincide with estimates of hashrate as of February 2016), we set hardness parameter  <span class="math">p = \\frac{1}{c \\cdot n\\Delta}</span>  where  <span class="math">c</span>  varies along the  <span class="math">x</span> -axis. We can interpret  <span class="math">c</span>  as the expected blocktime in terms of the network delay  <span class="math">\\Delta</span> . The blue graph depicts a numerically-computed maximum value of  <span class="math">\\rho</span>  for which  <span class="math">\\alpha(1 - (2\\Delta + 2)\\alpha) &amp;gt; \\beta</span> , i.e. parameters under which our theorem 4.3 shows consistency of the Nakamoto protocol. The red plot shows when our best attack succeeds in violating consistency. When  <span class="math">c = 60</span> , the hardness roughly corresponds to an expected 10-minute blocktime, and our theorem shows that Nakamoto tolerates a  <span class="math">\\rho &amp;lt; 49.57\\%</span>  attack, and our best attack succeeds when  <span class="math">\\rho &amp;gt; 49.79\\%</span> .</p>

    <p class="text-gray-300">assumptions align with the empirical measurements made by Decker and Wattenhofer [DW13]. For a period during the summer of 2012, they computed the average blocktime to be roughly  <span class="math">10.55\\mathrm{m}</span>  and the "weighted average"  <span class="math">\\Delta \\sim 11.37s</span>  (their model realistically allows for  <span class="math">\\Delta</span>  to be a distribution with a long tail). Their measurements are supported by website bitcoinstats.com for 2016. However, in both cases, they measure connectivity by number of nodes instead of by computational resources; thus their "95th percentile" estimations are biased larger because they include many hobby nodes which are connected by slow network connections and do not contribute any noticeable computation to the protocol.</p>

    <p class="text-gray-300">The hardness parameter in Nakamoto's protocol reflects the expected time between the discovery of blocks among all participants. Here, we can explore how consistency is related to this parameter  <span class="math">p = \\frac{1}{n\\Delta \\cdot c}</span>  by changing  <span class="math">c</span> . One can interpret  <span class="math">c</span>  as the scale-free expected block-time expressed in terms of the number of networks delays.</p>

    <p class="text-gray-300">For these choices, Fig. 1 depicts when our consistency theorem holds in Nakamoto's protocol by graphing  <span class="math">c</span>  against the fraction  <span class="math">(\\rho)</span>  of computation controlled by the adversary. The blue graph depicts a numerically-computed maximum value of  <span class="math">\\rho</span>  for which  <span class="math">\\alpha (1 - (2\\Delta +2)\\alpha) &amp;gt; \\beta</span> , i.e. parameters under which our theorem 4.3 shows consistency of the Nakamoto protocol. The red plot shows when our best attack succeeds in violating consistency.</p>

    <p class="text-gray-300">Nakamoto's protocol attempts to maintain a 10-minute blocktime by varying hardness  <span class="math">p</span> . For a delay  <span class="math">\\Delta \\sim 10s</span> , this corresponds to a setting of  <span class="math">c = 60</span> . In this range, the Nakamoto protocol, as well as our attack give essentially the same result: Nakamoto tolerates an adversary with  <span class="math">\\rho &amp;lt; 49.57\\%</span></p>

    <p class="text-gray-300">and our best attack succeeds when <span class="math">\\rho&gt;49.79\\%</span>. If we make a very conservative estimate of network delays being 1m, then <span class="math">c=10</span>, and Nakamoto remains consistent with respect to a 47.2% coalition.</p>

    <p class="text-gray-300">Finally, let us remark that the reason that our analysis is not tight when <span class="math">c</span> is small is that in our attack we only consider the probability that the adversary is able to completely control the chain. When <span class="math">c</span> is small, there is also a large probability that honest players do not converge on a chain even without any adversarial messages.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">1.6 Proof Highlights</h3>

    <p class="text-gray-300">Although our high-level approach follows similar intuitions as the analyses from Garay et al <em>[x11]</em> and Sompolinsky and Zohar <em>[x29]</em>, our actual proof uses a quite different proof strategy. As mentioned, the bulk of our proof consists of dealing with the attack strategies which are omitted from the analysis in <em>[x29]</em>, and dealing with them requires us to consider an altogether different proof technique: instead of <em>directly</em> analyzing the whole blockchain process, we consider a sequence of simplified processes which are “dominated” by the original one but are simpler to analyze. For instance, we aim to show that in the optimal attack, the adversary should always delay messages for as long as possible (so that messages are always delivered after <span class="math">\\Delta</span> steps). An obstacle in performing such a stochastic domination analysis is that once we start delaying messages, honest parties start to “mine” different blocks and the executions of our two processes diverge and become hard to compare: Ideally, to perform the domination argument we would like to consider a <em>fixed</em> execution (where the randomness of all parties are fixed) and to show by induction delaying messages <em>less than</em> <span class="math">\\Delta</span> never helps the attacker in that <em>particular</em> execution. The problem is that such a domination claim is not true: one can come up with scenarios (where the randomness is fixed) where, “by luck” delaying messages improves things for the honest parties (they now start mining blocks that magically lead to more successes). Of course, the probability of this happening should be small, but formally showing this would require us to somehow couple the experiments with and without maximum delays which is non-trivial (due to dependencies created by the random oracle)</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">The <span class="math">\\mathcal{F}_{tree}</span> model.</h4>

    <p class="text-gray-300">To overcome this issue, we rely on “simulation techniques” from the cryptographic literature on secure computation <em>[x14, x10]</em>: we first consider an idealized scenario where the players do not mine blocks but instead have access to an idealized “mining” functionality, which we call <span class="math">\\mathcal{F}_{tree}</span>. This functionality determines whether honest parties succeed in mining (at random) and the success probability is independent of the current chain an honest party is trying to extend. In this model, we can now perform a domination argument for every <em>fixed</em> randomness for the experiment. One of our main technical lemmas, which turns out to be quite subtle to prove, shows that any attack that succeeds in the “real-life” protocol in the random oracle model can be turned into (i.e., simulated by) an attack in the idealized <span class="math">\\mathcal{F}_{tree}</span> model. The key technical issue here is to deal with the dependencies created by the random oracle. (As an independent contribution, we believe that our <span class="math">\\mathcal{F}_{tree}</span> simulation lemma can be helpful in formalizing some steps left informal in e.g., <em>[x11, x20, x29]</em>.)</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">The chain growth lowerbound.</h4>

    <p class="text-gray-300">Armed with the above-mentioned techniques, the next crucial step is demonstrating a lowerbound on the chain growth. Roughly speaking, we prove by induction that (in the <span class="math">\\mathcal{F}_{tree}</span> model) the chain grows at least as fast in the real execution of the protocol, as in a “hybrid” experiment where a) all messages are maximally delayed, b) honest parties “freeze” and stop mining for <span class="math">\\Delta</span> steps whenever some honest player mines a block and c) all messages sent by the adversary are removed. The advantage of this hybrid experiment is that the chain growth process can now be described as a simple Markov chain—there are no longer any “adversarial transitions” and due to the “freezing”, honest players never have any chain conflict. This process can next be</p>

    <p class="text-gray-300">analyzed using standard Chernoff bounds. We emphasize that for the induction proof to go through, we cruicially rely on the fact that our analysis is in the <span class="math">\\mathcal{F}_{tree}</span>-model.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">No “long” block withholding.</h4>

    <p class="text-gray-300">We next use the chain growth lowerbound to demonstrate a central property of the blockchain protocol, which we refer to as the “no long block withholding” property : an adversary cannot “withhold” a block that it has mined for too “long”—unless it broadcasts the block to the honest players within some short amount of time, the block becomes “irrelevant” and will never be accepted by the honest players. Roughly speaking, we prove this by showing that, assuming that the adversary controls less than half of the computational power in the network, the chain of honest players will grow at a faster rate than any private chain the adversary can create, and thus unless it releases any block it finds quickly, the honest players’ chain will be too long for the block to ever be relevant.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Proving consistency.</h4>

    <p class="text-gray-300">Finally, proving consistency is the most challenging part of our proof. We start by first considering an execution <em>without adversarial messages</em>, and with deterministic delays, and identify a “pattern” which ensures that the chain of honest players converges: roughly, the pattern—which we refer to as a “convergence opportunity”—is that 1) there is a period of “silence” for <span class="math">\\Delta</span> rounds where no honest player mines a block, 2) this is followed by a round where a <em>single</em> honest player mines a block, 3) which is followed by another <span class="math">\\Delta</span> rounds of silence. Note that whenever such a pattern occurs, at the end of it all honest players have converged on the chain (which is why we call it a convergence opportunity): after the first period of silence, they all agree on the length of the chain (but may still have different chains), and thus the lone miner who finds a new block extends this longest chain by 1, and finally after the second period of silence this chain has propagated to all honest players (and since it is longer than all their current chains, they will switch to it). We are now interested in understanding how many such patterns happen within some specific period of time <span class="math">t</span>. The cruicial points here is that the process we now are analyzing is memoryless, and thus can be described by a (somewhat simple) Markov chain. On the negative side, the Markov chain that arises from this problem is too complicated to be analyzed with standard concentration bounds for Markov chains (see e.g., <em>[x10]</em>); we instead, provide a direct analysis of a simplified experiment (which, roughly speaking, instead analyzes the times between successful mining of honest players.) and we then use this to provide a lowerbound on the number of convergence opportunities.</p>

    <p class="text-gray-300">Finally, once we have established a strong concentration bound on the number of occurrences of such convergence opportunities, we argue that the only way that an attacker can “ruin” such a pattern is by itself mining a block that is accepted by the honest players during it. We here rely on the block-withholding lemma to argue that any block that the attacker can use to ruin a convergence opportunity must have been mined by the adversary not long before the beginning of the period of time we are analyzing; we then show that the number of adversarial block mined during this (slightly extended) period of time is smaller than the number of “convergence opportunities”, and thus conclude that at least one convergence opportunity will remain even in the presence of the adversary, and thus honest parties still converge on their chain.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">1.7 Related Work</h3>

    <p class="text-gray-300">The problem of reaching agreement in the presence of faulty participants, described first by Pease, Shostak, and Lamport <em>[x23]</em>, and also known as distributed consensus has been very well studied over the past 40 years. The basic problem considers a set of <span class="math">n</span> parties connected by reliable and authenticated pairwise network channels who wish to agree on a common output in the presence of an adversary who controls a fraction of the participants. Many aspects of the problem have been studied, with relaxations concerning the fraction of corrupted parties, the channels available</p>

    <p class="text-gray-300">to the participants, whether the protocols are deterministic or randomized and whether the participants are computationally bounded. Some protocols only consider fail-stop adversaries, while others consider a Byzantine setting in which some of the participants are malicious adversaries who attempt to disrupt the agreement. In the Byzantine agreement (BA) version of the problem, Castro and Liskov <em>[x10]</em> implemented a replication library that was practical enough to use for a file system; subsequently, other works have considered “fast” or ”simpler” versions of the Paxos protocol <em>[x23, x16, x17]</em>. All of these works assume, however, common knowledge of the number of participants <span class="math">n</span>, as well as identities for the participants.</p>

    <p class="text-gray-300">Okun <em>[x25, x26, x22]</em> considers BA in an “anonymous [synchronous] model without port awareness” in which processors do not have identifiers and cannot correlate messages to their sources; Okun shows both an impossibility result for deterministic protocols, and a feasibility result for probabilistic ones. Aspnes et al. <em>[x1]</em> shows how using a proof-of-work in a pre-processing step for this model can be used to assign interim identities to parties so that the number of identities assigned was proportional to computational power. After the pre-processing, a standard authenticated BA protocol is used. Neither results, however, are in the peer-to-peer setting in which new users can join and leave during the execution.</p>

    <p class="text-gray-300">Miller and LaViola <em>[x21]</em> show that variant of Nakamoto’s protocol can be used to solve the single-shot Byzantine agreement problem in the presence of a minority of faults in an asynchronous setting. The single-shot setting is substantially easier, since the adversary is limited, and for example, cannot mount block-withholding attacks. Garay, Kiayias, and Leonardas <em>[x13]</em> provide a better analysis of Nakamoto’s protocol, and also propose two protocols based on Nakamoto’s protocol that satisfy all the properties of BA in the multiple-instance setting. They only consider synchronous networks (and no spawning of new honest players). (As mentioned above, however, in synchronous networks, simpler solutions are possible.)</p>

    <h2 id="sec-20" class="text-2xl font-bold">2 Blockchain Protocols and Executions</h2>

    <p class="text-gray-300">In this section, we present an abstract model for blockchain protocols which aims to cover many variants of blockchain protocols.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.1 Blockchain Protocols</h3>

    <p class="text-gray-300">A blockchain protocol is a pair of algorithms <span class="math">(\\Pi,\\mathcal{C})</span> where <span class="math">\\Pi</span> is a stateful algorithm that receives a security parameter <span class="math">\\kappa</span> as inputs and maintains a local state state. The algorithm <span class="math">\\mathcal{C}(\\kappa,\\textsf{state})</span> outputs an <em>ordered</em> sequence of “records”, or “batches”, <span class="math">\\vec{\\mathfrak{m}}</span> (e.g., in the bitcoin protocol, each such record is an ordered sequence of transactions). We call <span class="math">\\mathcal{C}(\\kappa,\\textsf{state})</span> the “record chain” of a player with security parameter <span class="math">\\kappa</span> and local variable state; to simplify notation, whenever <span class="math">\\kappa</span> is clear from context we often write <span class="math">\\mathcal{C}(\\textsf{state})</span> to denote <span class="math">\\mathcal{C}(\\kappa,\\textsf{state})</span>.</p>

    <p class="text-gray-300">Algorithm <span class="math">\\Pi</span> is parameterized by a <em>validity</em> predicate <span class="math">V</span> (denoted by <span class="math">\\Pi^{V}</span>) that encapsulates the semantic properties (e.g., “no double spending”) that a blockchain application aims to achieve. <span class="math">V(\\vec{\\mathfrak{m}})</span> returns <span class="math">1</span> if and only if the chain <span class="math">\\vec{\\mathfrak{m}}</span> is <em>valid</em> for some notion of validity.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">A Blockchain Execution</h4>

    <p class="text-gray-300">Following the framework for Universal Composability <em>[x9]</em>, we consider the execution of a blockchain protocol <span class="math">(\\Pi^{V},\\mathcal{C})</span> that is directed by an environment <span class="math">Z(1^{\\kappa})</span> (where <span class="math">\\kappa</span> is a security parameter), which activates a number of parties <span class="math">1,2,\\ldots,n</span> as either “honest” or corrupted parties. Honest parties execute <span class="math">\\Pi</span> on input <span class="math">1^{\\kappa}</span> with an empy local state state; corrupt parties are controlled by an attacker <span class="math">A</span> which reads all their inputs/message and sets their outputs/messages to be sent.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The execution proceeds in rounds that model time steps. In round <span class="math">r</span>, each honest player <span class="math">i</span> receives a message (a “record”) <span class="math">\\mathfrak{m}</span> from <span class="math">Z</span> (that it attempts to “add” to its chain) and potentially receives incoming network messages (delivered by <span class="math">A</span>). It may then perform any computation, broadcast a message to all other players (which will be delivered by the adversary; see below) and update its local state <span class="math">\\textsf{state}_i</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A</span> is responsible for delivering all messages sent by parties (honest or corrupted) to all other parties. <span class="math">A</span> cannot modify the content of messages broadcast by honest players, but it may delay or reorder the delivery of a message as long as it eventually delivers all messages. (Later, we shall consider restrictions on the delivery time.) The identity of the sender is not known to the recipient.⁴</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any point, <span class="math">Z</span> can communicate with adversary <span class="math">A</span> or access <span class="math">\\mathcal{C}(\\textsf{state}_i)</span> where <span class="math">\\textsf{state}_i</span> is the local state of player <span class="math">i</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any point, <span class="math">Z</span> can corrupt an honest party <span class="math">j</span> which means that <span class="math">A</span> gets access to its local state and subsequently, <span class="math">A</span> controls party <span class="math">j</span>. (In particular, this means we consider a model with “erasures”; random coin tosses that are no longer stored in the local state of <span class="math">j</span> are not visible to <span class="math">A</span>.)⁵</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any point, <span class="math">Z</span> can uncorrupt a corrupted player <span class="math">j</span>, which means that <span class="math">A</span> no longer controls <span class="math">j</span> and instead player <span class="math">j</span> starts executing <span class="math">\\Pi(1^{\\kappa})</span> with a fresh state <span class="math">\\textsf{state}_j</span>. (This is also how we model <span class="math">Z</span> spawning a “new” honest player.) <span class="math">A</span> gets informed of all such uncorrupt messages and is required to deliver all messages previously sent by (currently alive) honest players.⁶</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathsf{EXEC}^{(\\Pi^V,\\mathcal{C})}(A,Z,\\kappa)</span> be a random variable denoting the joint view of all parties (i.e., all their inputs, random coins and messages received, including those from the random oracle) in the above execution; note that this joint view fully determines the execution.</p>

    <p class="text-gray-300">Admissible Environments We will be considering executions with restricted adversaries and environments; these restrictions will be specified by a predicate <span class="math">\\Gamma(\\cdot, \\cdot, \\cdot, \\cdot)</span>.</p>

    <p class="text-gray-300">Definition 2.1 (Admissible Environments). We say that the tuple <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> is <span class="math">\\Gamma</span>-admissible w.r.t. <span class="math">(\\Pi^V, \\mathcal{C})</span> if <span class="math">A</span> and <span class="math">Z</span> are non-uniform probabilistic polynomial-time algorithms, <span class="math">\\Gamma(n(\\cdot), \\rho, \\Delta) = 1</span> and for every <span class="math">\\kappa \\in N</span>, every view view in the support of <span class="math">\\mathsf{EXEC}^{(\\Pi^V, \\mathcal{C})}(A, Z, \\kappa)</span>, the following holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Z</span> activates <span class="math">n = n(\\kappa)</span> parties in view;</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A delays messages by at most <span class="math">\\Delta = \\Delta(\\kappa)</span> rounds (and in the case of newly spawned players, instantly delivers messages that were sent more than <span class="math">\\Delta</span> rounds ago);</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>at any round <span class="math">r</span> in view, <span class="math">A</span> controls at most <span class="math">\\rho \\cdot n(\\kappa)</span> parties; and</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. in every round <span class="math">r</span> in view, <span class="math">Z</span> only sends local inputs <span class="math">\\mathfrak{m}</span> to an honest player <span class="math">i</span>, if $V(\\mathcal{C}(\\text{state}_i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{m}) = 1<span class="math">, where </span>\\text{state}_i<span class="math"> is player </span>i<span class="math">&#x27;s local state at round </span>r$ in view.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Whenever the protocol <span class="math">(\\Pi^V, \\mathcal{C})</span> is clear from context, we simply call <span class="math">(n, \\rho, \\Delta, A, Z)</span> <span class="math">\\Gamma</span>-admissible.</p>

    <p class="text-gray-300">⁴We could also consider a seemingly weaker model where messages sent by corrupted parties need not be delivered to all honest players. We can easily convert the weaker model to the stronger model by having honest parties “gossip” all messages they receive.</p>

    <p class="text-gray-300">⁵Our proof actually extends also to the model “without erasures”.</p>

    <p class="text-gray-300">⁶This models the fact that a player is not considered “honest” before it has joined the network and gotten “initialized”. In the real-life execution of bitcoin, new players joining send out a message to the network, request to be initialized and download the longest chain known to the network. We only consider them honest once this process is over.</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">12</p>

    <h2 id="sec-23" class="text-2xl font-bold">2.2 A remark about the communication model</h2>

    <p class="text-gray-300">Our model assumed that any player can send a message to all other players in the network, and that those messages arrive within <span class="math">\\Delta</span> rounds, no matter how long they are. This is clearly not a very realistic model. In real-life, player communicate their messages through a gossip network, and thus we need to assume that this network is sufficiently connected and has sufficiently many honest players to ensure <span class="math">\\Delta</span> delivery time. This still clearly is infeasible if messages can be arbitrary long. However, in the applications we consider—assuming that records <span class="math">\\mathfrak{m}</span> provided by the environment are of length <span class="math">O(\\kappa)</span> (i.e., there is a “block-size limit”)—honest players only communicate messages that differ in the last <span class="math">O(\\kappa)</span> bits from messages that they have previously received. For such cases it seems reasonable to assume that a sufficiently connected routing network has the desired property of ensuring delivery of all messages within <span class="math">\\Delta</span> rounds.</p>

    <h2 id="sec-24" class="text-2xl font-bold">2.3 Blockchain protocols in the ROM</h2>

    <p class="text-gray-300">To model Nakamoto’s blockchain protocol, we need to extend the model with a random oracle. In an execution with security parameter <span class="math">\\kappa</span>, we assume all parties have access to a random function <span class="math">H: \\{0,1\\}^* \\to \\{0,1\\}^\\kappa</span> which they can access through two oracles: <span class="math">\\mathsf{H}(x)</span> simply outputs <span class="math">H(x)</span> and <span class="math">\\mathsf{H.ver}(x,y)</span> output 1 iff <span class="math">H(x) = y</span> and 0 otherwise. In any round <span class="math">r</span>, the players (as well as <span class="math">A</span>) may make any number of queries to <span class="math">\\mathsf{H.ver}</span>. On the other hand, in each round <span class="math">r</span>, honest players can make only a single query to <span class="math">\\mathsf{H}</span>, and an adversary <span class="math">A</span> controlling <span class="math">q</span> parties, can make <span class="math">q</span> sequential queries to <span class="math">\\mathsf{H}</span>. (This modeling is meant to capture the assumption that we only “charge” for the effort of finding a solution to a “proof of work” [DN92], but checking the validity of a solution is cheap. We discuss this further after introducing Nakamoto’s protocol.) We emphasize that the environment <span class="math">Z</span> does not get direct access to the random oracle (but can instruct <span class="math">A</span> to make queries).</p>

    <h2 id="sec-25" class="text-2xl font-bold">2.4 Nakamoto’s Protocol</h2>

    <p class="text-gray-300">We turn to describing Nakamoto’s protocol [Nak08], which we refer to as <span class="math">(\\Pi_{Nak}^{p},\\mathcal{C}_{Nak}^{p})</span>. The local state state maintained by <span class="math">\\Pi_{Nak}^{p}</span> is a sequence of (mined) blocks <span class="math">\\vec{\\mathsf{b}}</span>, where each mined block is a tuple <span class="math">(h_{-1},n,\\mathfrak{m},h)</span> that consists of a hash <span class="math">h_{-1}</span> (a pointer to the previous record), a nonce <span class="math">\\eta</span>, a record <span class="math">\\mathfrak{m}</span>, and a hash <span class="math">h</span> (a pointer to the current record<span class="math">^{8}</span>) and is initialized to a special “genesis” block: <span class="math">(0,0,\\bot),\\mathsf{H}(0,0,\\bot)</span>. Let <span class="math">\\mathcal{C}(\\text{state})</span> be the sequence of records <span class="math">\\vec{\\mathfrak{m}}</span> contained in the sequence of blocks state. The protocol is parameterized by a hardness function <span class="math">p(\\cdot)</span> which defines a constant <span class="math">D_{p} = p(\\kappa)\\cdot 2^{\\kappa}</span> such that for all <span class="math">(h,b)</span>, <span class="math">\\operatorname*{Pr}_{\\eta}[\\mathsf{H}(h,\\eta ,b) &amp;lt; D_p] = p(\\kappa)</span>. Whenever <span class="math">p</span> is clear for context, we simply denote the protocol <span class="math">(\\Pi_{Nak},\\mathcal{C}_{Nak})</span> (without the <span class="math">p</span> superscript); additionally, whenever <span class="math">\\kappa</span> is clear from context, we let <span class="math">p = p(\\kappa)</span>.</p>

    <p class="text-gray-300">We say a block <span class="math">\\mathsf{b} = (h_{-1},\\eta ,\\mathsf{m},h)</span> is valid with respect to (a predecessor block) <span class="math">\\mathsf{b}_{-1} = (h_{-1}^{\\prime},n^{\\prime},\\mathsf{m}^{\\prime},h^{\\prime})</span> if three conditions hold: <span class="math">h_{-1} = h^{\\prime}</span>, <span class="math">h = \\mathsf{H}(h_{-1},\\eta ,\\mathsf{m})</span>, and <span class="math">h &amp;lt; D_p</span>. A sequence of blocks state <span class="math">= (\\mathsf{b}_0,\\ldots ,\\mathsf{b}_{\\ell})</span> is valid if a) <span class="math">\\mathsf{b}_0 = (0,0,\\bot ,\\mathsf{H}(0,0,\\bot))</span> is the genesis block, b) for all <span class="math">i\\in [\\ell ]</span>, <span class="math">\\mathsf{b}_i</span> is valid with respect to <span class="math">\\mathsf{b}_{i - 1}</span>, and c) <span class="math">V(\\mathcal{C}(\\text{state})) = 1</span>.</p>

    <p class="text-gray-300">Each round of <span class="math">\\Pi_{Nak}^{V}</span> proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Read all incoming messages (delivered by <span class="math">A</span>). If any incoming message state' is a valid sequence of blocks that is longer than its local state state, replace state by state'. (Note that checking the validity of state' can be done using only H.ver queries)</li>

    </ul>

    <p class="text-gray-300"><span class="math">^{7}</span>In Bitcoin’s instantiation of the blockchain protocol, there is currently a severe restriction on the block-size. There is currently an active debate whether to raise the block-size limit or to leave it small.</p>

    <p class="text-gray-300"><span class="math">^{8}</span>In reality (as well as in the description in the introduction), <span class="math">h</span> is not included in the block (as it can be easily determined from the remaining elements); we include it to ensure that we can verify validity of a block using only H.ver.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Read local message <span class="math">\\mathsf{m}</span> (from <span class="math">Z</span>). If <span class="math">\\mathsf{m}</span> is such that $V(\\mathcal{C}(\\mathsf{state})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{m})\\neq 1<span class="math">, proceed to the next round. Otherwise, pick a random nonce </span>n\\in\\{0,1\\}^{\\kappa}<span class="math"> and issue query </span>h=\\mathsf{H}(h_{-1},\\eta,\\mathsf{m})<span class="math"> where </span>h_{-1}<span class="math"> is the 4’th element in the last block in </span>\\mathsf{state}<span class="math">. If </span>h<D_{p}<span class="math">, then </span>\\Pi<span class="math"> adds the <em>newly mined</em> block </span>(h_{-1},\\eta,b,h)<span class="math"> to </span>\\mathsf{state}<span class="math"> and broadcasts the updated </span>\\mathsf{state}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Depending on the definition of <span class="math">V</span>, one can instantiate either Bitcoin, e.g., by having <span class="math">V</span> enforce that <span class="math">\\mathsf{m}</span> can be parsed into a sequence of well-formed <em>transactions</em> each of which is <em>authorized</em> and spends money from a source account to a destination account at most once without deficit, etc., as well as other cryptocurrencies with different semantics such as Namecoin. We may also consider a simpler predicate <span class="math">V_{\\mathcal{L}}</span> that simply accepts all messages; that is <span class="math">V_{\\mathcal{L}}(\\vec{\\mathsf{m}})=1</span>; such a predicate is useful, for instance, to use a blockchain to provide a public ledger.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">A Remark on our use of the Random Oracle</h4>

    <p class="text-gray-300">Recall that in our model, we restrict players to a single evaluation query <span class="math">\\mathsf{H}</span> per round, but allow them any number of verification queries <span class="math">\\mathsf{H}.\\mathsf{ver}</span> in the same round. We do this to model the fact that checking the validity of mined blocks is “cheap” whereas the mining process is expensive. (To enable this, we have included a pointer <span class="math">h</span> to the current record in every mined block in the description of Nakamoto; thus a player need not spend an <span class="math">\\mathsf{H}</span> query to compute the pointer to the previous record.)</p>

    <p class="text-gray-300">In practice, the cost of evaluating a hash function (which is used to instantiate the random oracle) is the same as verifying its outputs, but our modeling attempts to capture the phenomena that a miner typically use various heuristics (such as black lists of IP addresses that have sent invalid blocks) and different hardware to check the validity of a mined block versus to mine a new block.</p>

    <h2 id="sec-27" class="text-2xl font-bold">3 Formal Definitions of the Desiderata</h2>

    <p class="text-gray-300">In this section, we provide formal definitions of the desiderata mentioned in the introduction. We start of with some notation and preliminaries.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Notation</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For some <span class="math">A,Z</span>, consider some <span class="math">\\mathsf{view}</span> in the support of <span class="math">\\mathsf{EXEC}^{(\\Pi^{V},\\mathcal{C})}(A,Z,\\kappa)</span>. We use the notation $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to denote the number of rounds in the execution, </span>\\mathsf{view}^{r}<span class="math"> to denote the prefix of </span>\\mathsf{view}<span class="math"> up until round </span>r<span class="math">, </span>\\mathsf{state}_{i}(\\mathsf{view})<span class="math"> denotes the local state of player </span>i<span class="math"> in </span>\\mathsf{view}<span class="math">, </span>\\mathcal{C}_{i}(\\mathsf{view})=\\mathcal{C}(\\mathsf{state}_{i}(\\mathsf{view}))<span class="math"> and </span>\\mathcal{C}_{i}^{r}(\\mathsf{view})=\\mathcal{C}_{i}(\\mathsf{view}^{r})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">(Strongly) Negligible Functions</h4>

    <p class="text-gray-300">A function <span class="math">\\epsilon(\\cdot)</span> is said to be <em>negligible</em> if for every polynomial <span class="math">p(\\cdot)</span>, there exists some <span class="math">\\kappa_{0}</span> such that <span class="math">\\epsilon(\\kappa)\\leq\\frac{1}{p(\\kappa)}</span> for all <span class="math">\\kappa\\geq\\kappa_{0}</span>. Our bounds will actually also apply to an <em>exponentially-strong</em> interpretation of what it means for a function to be negligible. A function <span class="math">\\epsilon(\\cdot)</span> is said to be <em>(strongly) negligible</em> if there exists constants <span class="math">c_{0}&gt;0,c_{1}</span> such that for all <span class="math">\\kappa</span>, <span class="math">\\epsilon(\\kappa)\\leq e^{-c_{0}\\kappa+c_{1}}</span>. In the rest of the paper, we simply use the term “negligible”, but all uses of it can be replaced by strongly negligible. We often use the shorthand <span class="math">\\mathsf{neg}(\\kappa)</span> to denote a function that is negligible as a function of <span class="math">\\kappa</span>.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">3.1 Chain Growth</h3>

    <p class="text-gray-300">Our first desiderata is that the chain grows proportionally with the number of rounds of the protocol. This intuitive property was explicitly considered by Sompolinsky and Zohar <em>[x25]</em> but they only consider growth in expectation; it was also implicitly considered in Garay et al <em>[x11]</em> within one of their proofs (but was not highlighted as a desideratum), and explicitly highlighted as a desideratum by Kiayias and Panagiotakos <em>[x14]</em>. We here generalize these definitions to</p>

    <p class="text-gray-300">“abstract” blockchain protocols, and add a useful “length” consistency property. (Looking forward, in Section 3.4, we will also consider an <em>upper-bound</em> on chain growth.)</p>

    <p class="text-gray-300">Let,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{min\\text{-}chain\\text{-}increase}_{r,t}(\\mathsf{view})=\\min_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{j}^{r+t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}^{r}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where we quantify over players <span class="math">i,j</span> such that <span class="math">i</span> is honest at <span class="math">\\mathsf{view}^{r}</span> and <span class="math">j</span> is honest at <span class="math">\\mathsf{view}^{r+t}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{growth}^{t}(\\mathsf{view},\\Delta,T)=1</span> iff the following two properties hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (consistent length) for all rounds $r\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\Delta<span class="math">, </span>r+\\Delta\\geq r^{\\prime}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, for every two players </span>i,j<span class="math"> such that in </span>\\mathsf{view}<span class="math"> </span>i<span class="math"> is honest at </span>r<span class="math"> and </span>j<span class="math"> is honest at </span>r^{\\prime}<span class="math">, we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{j}^{r^{\\prime}}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}^{r}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{min\\text{-}chain\\text{-}increase}_{r,t}(\\mathsf{view})\\geq T.</span></p>

    <p class="text-gray-300">In other words, <span class="math">\\mathsf{growth}^{t}</span> is a predicate which tests that a) honest parties have chains of roughly the same length, and b) during any <span class="math">t</span> rounds in the execution, all honest parties’ chains increase by at least <span class="math">T</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">(\\Pi,\\mathcal{C})</span> has <em>chain growth rate</em> <span class="math">g(\\cdot,\\cdot,\\cdot,\\cdot)</span> in <span class="math">\\Gamma</span>-environments if for all <span class="math">\\Gamma</span>-admissible <span class="math">(n(\\cdot),\\rho,\\Delta(\\cdot),A,Z)</span>, there exists some constant <span class="math">c</span> and negligible functions <span class="math">\\epsilon_{1},\\epsilon_{2}</span> such that for every <span class="math">\\kappa\\in\\mathbb{N},T\\geq c\\log(\\kappa)</span>, and <span class="math">t\\geq\\frac{T}{g(n(\\kappa),\\rho,\\Delta(\\kappa))}</span>, the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{(\\Pi^{V},\\mathcal{C})}(A,Z,\\kappa):\\mathsf{growth}^{t}(\\mathsf{view},\\Delta(\\kappa),T)=1\\Big{]}\\geq 1-\\epsilon_{1}(\\kappa)-\\epsilon_{2}(T)</span></p>

    <p class="text-gray-300">Additionally, if <span class="math">\\epsilon_{1}=0</span>, we say that <span class="math">(\\Pi,\\mathcal{C})</span> has <em>error-less chain growth rate</em> <span class="math">g</span> in <span class="math">\\Gamma</span>-environments.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">3.2 Chain Quality</h3>

    <p class="text-gray-300">Our second desideratum is that the number of records contributed by the adversary is proportional to its relative power. This property was first discussed on the Bitcoin forum <em>[x15]</em> and made explicit in the selfish mining attacks by Eyal and Sirer <em>[x10]</em> w.r.t. the bitcoin application of the blockchain. The property was first formalized, and given the name “chain quality” by Garay et al <em>[x13]</em>. We generalize their definition to abstract blockchain protocols. Doing so is somewhat non-trivial in that it is not directly clear what it means for a record to be adversarial (Garay et al <em>[x13]</em> only provide a definition of an adversarial block for the particular protocol of Nakamoto, and their definition only applies in the random oracle model).</p>

    <p class="text-gray-300">We say that a <em>record</em> <span class="math">\\mathsf{m}</span> is non-adversarial (or honest) w.r.t. <span class="math">\\mathsf{view}</span> and prefix <span class="math">\\vec{\\mathsf{m}}</span> if there exists a player <span class="math">j</span> and some round <span class="math">r^{\\prime}</span> such that in <span class="math">\\mathsf{view}^{r^{\\prime}}</span>, <span class="math">j</span> is honest, the environment provided <span class="math">\\mathsf{m}</span> as input to <span class="math">j</span>, and <span class="math">\\vec{\\mathsf{m}}</span> is a prefix of <span class="math">\\mathcal{C}_{i}(\\mathsf{view}^{r^{\\prime}})</span>. (That is, there exists some honest player that received <span class="math">\\mathsf{m}</span> as an input when their chain contained <span class="math">\\vec{\\mathsf{m}}</span>).</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{quality}^{T}(\\mathsf{view},\\mu)=1</span> iff for every round <span class="math">r</span> and every player <span class="math">i</span> such that <span class="math">i</span> is honest in <span class="math">\\mathsf{view}^{r}</span>, among any consecutive sequence of <span class="math">T</span> records <span class="math">M</span> in <span class="math">\\mathcal{C}_{i}^{r}(\\mathsf{view})</span>, the fraction of records <span class="math">\\mathsf{m}</span> that are honest w.r.t. <span class="math">\\mathsf{view}^{r}</span> and <span class="math">\\vec{\\mathsf{m}}</span>, where <span class="math">\\vec{\\mathsf{m}}</span> is the prefix of <span class="math">\\mathcal{C}_{i}^{r}(\\mathsf{view})</span> preceeding <span class="math">M</span>, is at least <span class="math">\\mu</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 3.2.</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">(\\Pi,\\mathcal{C})</span> has <em>chain quality</em> <span class="math">\\mu(\\cdot,\\cdot,\\cdot,\\cdot)</span> in <span class="math">\\Gamma</span> environments, if for all <span class="math">\\Gamma</span>-admissible <span class="math">(n(\\cdot),\\rho,\\Delta(\\cdot),A,Z)</span>, there exists some constant <span class="math">c</span> and negligible functions <span class="math">\\epsilon_{1},\\epsilon_{2}</span> such that for every <span class="math">\\kappa\\in\\mathbb{N},T&gt;c\\log(\\kappa)</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{(\\Pi^{V},\\mathcal{C})}(A,Z,\\kappa):\\mathsf{quality}^{T}(\\mathsf{view},\\mu(\\kappa,n(\\kappa),\\rho,\\Delta(\\kappa)))=1\\Big{]}\\geq 1-\\epsilon_{1}(\\kappa)-\\epsilon_{2}(T)</span></p>

    <p class="text-gray-300">Additionally, if <span class="math">\\epsilon_{1}=0</span>, we say that <span class="math">(\\Pi,\\mathcal{C})</span> has <em>errorless chain quality</em> <span class="math">\\mu</span> in <span class="math">\\Gamma</span>-environments.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">15</p>

    <h2 id="sec-34" class="text-2xl font-bold">3.3 Consistency</h2>

    <p class="text-gray-300">The common-prefix property by Garay et al [GKL15], which was already considered and studied by Nakamoto [Nak08], requires that in any round <span class="math">r</span>, the record chains of any two honest players <span class="math">i, j</span> agree on all, but potentially the last <span class="math">T</span>, records. We note that this property (even in combination with the other two desiderata) provides quite weak guarantees: even if any two honest parties perfectly agree on the chains, the chain could be completely different on, say, even rounds and odd rounds. We here consider a stronger notion of consistency which additionally stipulates players should be consistent with their “future selves”.¹⁰</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\text{consistent}^T(\\text{view}) = 1</span> iff for all rounds <span class="math">r \\leq r&#x27;</span>, and all players <span class="math">i, j</span> (potentially the same) such that <span class="math">i</span> is honest at <span class="math">\\text{view}^r</span> and <span class="math">j</span> is honest at <span class="math">\\text{view}^{r&#x27;}</span>, we have that the prefixes of <span class="math">\\mathcal{C}_i^r(\\text{view})</span> and <span class="math">\\mathcal{C}_j^{r&#x27;}(\\text{view})</span> consisting of the first $\\ell =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_i^r(\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- T$ records are identical.¹¹</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 3.3.</strong> A blockchain protocol <span class="math">(\\Pi, \\mathcal{C})</span> satisfies consistency in <span class="math">\\Gamma</span> environments, if for all <span class="math">\\Gamma</span>-admissible <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span>, there exists some constant <span class="math">c</span> and negligible functions <span class="math">\\epsilon_1, \\epsilon_2</span> such that for every <span class="math">\\kappa \\in \\mathbb{N}, T &amp;gt; c \\log(\\kappa)</span> the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow \\text{EXEC}^{(\\Pi^V, \\mathcal{C})}(A, Z, \\kappa) : \\text{consistent}^T(\\text{view}) = 1 \\right] \\geq 1 - \\epsilon_1(\\kappa) - \\epsilon_2(T)</span></div>

    <p class="text-gray-300">Additionally, if <span class="math">\\epsilon_1 = 0</span>, we say that <span class="math">(\\Pi, \\mathcal{C})</span> has errorless consistency in <span class="math">\\Gamma</span>-environments.</p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that the chain length of any two honest players can differ by at most <span class="math">T</span> (except with negligible probability in <span class="math">T</span>).</p>

    <h2 id="sec-35" class="text-2xl font-bold">3.4 Chain Growth Upperbound</h2>

    <p class="text-gray-300">Our final desiderata is the existence of an upperbound on the chain growth. While we do not present any applications of this property in the current paper, it is an intuitively useful property—for instance, combined with the chain growth lower bound, it implies we can use a blockchain as a “partially-synchronized clock”. (Additionally, subsequent work by Pass and Shi [PS16a, PS16b] demonstrate the usefulness of this property.)</p>

    <p class="text-gray-300">Let,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\max\\text{-chain-increase}_{r,t}(\\text{view}) = \\max_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_j^{r+t}(\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_i^r(\\text{view})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we quantify over players <span class="math">i, j</span> such that <span class="math">i</span> is honest at <span class="math">\\text{view}^r</span> and <span class="math">j</span> is honest at <span class="math">\\text{view}^{r+t}</span>. Let <span class="math">\\text{upper-growth}^t(\\text{view}, \\Delta, T) = 1</span> iff for every round $r \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- t$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\max\\text{-chain-increase}_{r,t}(\\text{view}) \\leq T.</span></div>

    <p class="text-gray-300"><strong>Definition 3.4.</strong> A blockchain protocol <span class="math">(\\Pi, \\mathcal{C})</span> has upper-bound on chain growth rate <span class="math">g&#x27;(\\cdot, \\cdot, \\cdot, \\cdot)</span> in <span class="math">\\Gamma</span>-environments if for all <span class="math">\\Gamma</span>-admissible <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span>, there exists some constant <span class="math">c</span> and negligible functions <span class="math">\\epsilon_1, \\epsilon_2</span> such that for every <span class="math">\\kappa \\in \\mathbb{N}, T \\geq c \\log(\\kappa)</span>, and <span class="math">t = \\frac{T}{g&#x27;(n(\\kappa), \\rho, \\Delta(\\kappa))}</span>, the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow \\text{EXEC}^{(\\Pi^V, \\mathcal{C})}(A, Z, \\kappa) : \\text{upper-growth}^t(\\text{view}, \\Delta(\\kappa), T) = 1 \\right] \\geq 1 - \\epsilon_1(\\kappa) - \\epsilon_2(T)</span></div>

    <p class="text-gray-300">Additionally, if <span class="math">\\epsilon_1 = 0</span>, we say that <span class="math">(\\Pi, \\mathcal{C})</span> has error-less upper-bound on chain growth rate <span class="math">g&#x27;</span> in <span class="math">\\Gamma</span>-environments.</p>

    <p class="text-gray-300">¹⁰ This stronger notion of consistency combines what we called “plain” consistency and “future-self” consistency in the introduction.</p>

    <p class="text-gray-300">¹¹ Pedantically, the “first <span class="math">\\ell</span> records of <span class="math">\\mathcal{C}_j^{r&#x27;}(\\text{view})</span> is not defined if <span class="math">\\mathcal{C}_j^{r&#x27;}(\\text{view}) &amp;lt; \\ell</span>; to formalize it, we may represent the chains as infinite sequences of records, where all records after the end of the chain is a special “nil” symbol. In particular, this ensures that <span class="math">\\text{consistent}^T(\\text{view}) = 0</span> if <span class="math">\\mathcal{C}_j^{r&#x27;}(\\text{view}) &amp;lt; \\ell</span>.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">3.5 Some Remarks on <span class="math">T</span> v.s. <span class="math">\\kappa</span></h3>

    <p class="text-gray-300">Our definitions of the above properties are quite strong in the sense that we require the probability of “bad” events happening to decrease exponentially with <span class="math">T</span>, even for <em>small</em> <span class="math">T&gt;c\\log\\kappa</span>. A simpler definition of an abstract blockchain would require the above definitions to hold when <span class="math">T\\geq T_{0}(\\kappa)</span>, where <span class="math">T_{0}</span> is some polynomial, in this case, we may simply require that the probability of the bad event is <span class="math">\\mathsf{neg}(\\kappa)</span>.</p>

    <p class="text-gray-300">The reason we here distinguish between <span class="math">T</span> and <span class="math">\\kappa</span> (and in particular, require the above definitions to hold when <span class="math">T</span> is small) is that we aim to use the definitions to analyze Nakamoto’s specific blockchain protocol, and real-life instantiations of it typically consider quite different settings of values of <span class="math">\\kappa</span> and <span class="math">T</span>; for instance, in the Bitcoin application, we are interested in achieving <span class="math">T</span>-consistency for <span class="math">T=6</span> (i.e., transactions are only considered confirmed when they appear at depth 6 in the chain), but <span class="math">\\kappa</span> is typically 128.</p>

    <p class="text-gray-300">We emphasize, however, that if our goal is to study optimal parameters (for e.g., consistency and chain quality), the more general notion seems more appropriate.</p>

    <h2 id="sec-37" class="text-2xl font-bold">4 Main Theorem Statements</h2>

    <p class="text-gray-300">Our main results will be most convenient to parameterize in the following two quantities (which are defined for some fixed mining hardness function <span class="math">p(\\cdot)</span>; recall that Nakamoto’s protocol is parametrized by <span class="math">p</span>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\alpha(\\kappa,n,\\rho,\\Delta)=1-(1-p(\\kappa))^{(1-\\rho)n}</span>. That is, <span class="math">\\alpha</span> is the probability that <em>some</em> honest player succeeds in mining a block in a round;</li>

      <li>let <span class="math">\\beta(\\kappa,n,\\rho,\\Delta)=\\rho np(\\kappa)</span>. That is <span class="math">\\beta</span> is the expected number blocks that an attacker can mine in a round.</li>

    </ul>

    <p class="text-gray-300">Whenever <span class="math">\\kappa,n,\\rho,\\Delta</span> are clear from the context, we simply write <span class="math">\\alpha,\\beta</span>. In essence, the quantities capture the per round expected “chain length increase” by the honest parties and the adversary; the reason the quantities are defined differently is that we assume that the adversary can sequentialize its queries in a round, whereas honest players make a single parallel query (they each act independently), and thus even if they manage to mine several blocks, the longest chain held by honest players can increase by at most 1. Note, however, that when <span class="math">p</span> is small (in comparison to <span class="math">1/n</span>), which is case for the Bitcoin protocol, <span class="math">\\alpha</span> is well approximated by <span class="math">(1-\\rho)np</span> and thus <span class="math">\\frac{\\alpha}{\\beta}\\approx\\frac{1-\\rho}{\\rho}</span>, so this difference is minor.</p>

    <p class="text-gray-300">We will also consider the following quantity:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\gamma(\\kappa,n,\\rho,\\Delta)=\\frac{\\alpha}{1+\\Delta\\alpha}</span></li>

    </ul>

    <p class="text-gray-300">(Again, whenever <span class="math">\\kappa,n,\\rho,\\Delta</span> are clear from the context, we simply write <span class="math">\\gamma</span>.) Roughly speaking, <span class="math">\\gamma</span> should be thought of a “discounted” version of <span class="math">\\alpha</span> due to the fact that messages sent by honest parties can be delayed by <span class="math">\\Delta</span> rounds and this may lead to honest players “redoing work”; <span class="math">\\gamma</span> corresponds to their “effective” mining power. Note that if <span class="math">p</span> is sufficiently small then <span class="math">\\gamma\\approx\\alpha</span> and thus <span class="math">\\frac{\\gamma}{\\beta}\\approx\\frac{1-\\rho}{\\rho}</span>.</p>

    <p class="text-gray-300">We are now ready to state our main theorems. We will consider two environments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the least restrictive environment, <span class="math">\\Gamma^{0}</span>, we make <em>no restrictions</em> on the parameters (more than them being “valid”). Namely, let <span class="math">\\Gamma_{0}(n(\\cdot),\\rho,\\Delta(\\cdot))=1</span> iff <span class="math">n(\\cdot),\\Delta(\\cdot)</span> are functions <span class="math">\\mathcal{N}\\to\\mathcal{N}^{+}</span> and <span class="math">0\\leq\\rho\\leq 1</span>.</li>

      <li>In the more restrictive environment, we additionally assume that the adversary controls a sufficiently small fraction of the computational power. Let <span class="math">\\Gamma_{\\lambda}^{p}(n(\\cdot),\\rho,\\Delta(\\cdot))=1</span> iff <span class="math">\\Gamma_{0}(n(\\cdot),\\rho,\\Delta(\\cdot)))=1</span> and for all <span class="math">\\kappa,n=n(\\kappa),\\Delta=\\Delta(k)</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\alpha(1-2(\\Delta+1)\\alpha)\\geq\\lambda\\beta</span></p>

    <p class="text-gray-300">The following three theorems formalize Theorem 1.2 from the introduction (which in turn implies Theorem 1.1). We first prove a lower-bound on the chain growth.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 4.1 (Chain growth).</h6>

    <p class="text-gray-300">For any <span class="math">\\delta&gt;0</span>, any <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi^{p}_{Nak},\\mathcal{C}^{p}_{nak})</span> has chain growth rate</p>

    <p class="text-gray-300"><span class="math">g^{p}_{\\delta}(\\kappa,n,\\rho,\\Delta)=(1-\\delta)\\gamma</span></p>

    <p class="text-gray-300">in <span class="math">\\Gamma_{0}</span> environments.</p>

    <p class="text-gray-300">We next prove a lowerbound on the chain quality.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 4.2 (Chain quality).</h6>

    <p class="text-gray-300">For all <span class="math">\\delta&gt;0</span>, any <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi^{p}_{Nak},\\mathcal{C}^{p}_{nak})</span> has chain quality</p>

    <p class="text-gray-300"><span class="math">\\mu^{p}_{\\delta}(\\kappa,n,\\rho,\\Delta)=1-(1+\\delta)\\frac{\\beta}{\\gamma}</span></p>

    <p class="text-gray-300">in <span class="math">\\Gamma_{0}</span> environments.</p>

    <p class="text-gray-300">We finally show consistency.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 4.3 (Consistency).</h6>

    <p class="text-gray-300">For any <span class="math">\\lambda&gt;1</span>, any <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi^{p}_{nak},\\mathcal{C}^{p}_{nak})</span> satisfies consistency in <span class="math">\\Gamma^{p}_{\\lambda}</span> environments.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">Chain growth upperbound</h4>

    <p class="text-gray-300">We additionally present an upperbound on the the chain growth. (As mentioned before, this property is not needed for any of the applications that we present in the current paper, nor for the statement of the main result in the introduction, but may be useful in other contexts (and indeed, subsequent work <em>[x13, x14]</em> show its usefulness).)</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 4.4 (Upperbound on Chain growth).</h6>

    <p class="text-gray-300">For any <span class="math">\\delta&gt;0</span>, any <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi^{p}_{Nak},\\mathcal{C}^{p}_{nak})</span> has upperbound on chain growth rate</p>

    <p class="text-gray-300"><span class="math">\\hat{g}^{p}_{\\delta}(\\kappa,n,\\rho,\\Delta)=(1+\\delta)np</span></p>

    <p class="text-gray-300">in <span class="math">\\Gamma^{p}_{\\lambda}</span> environments.</p>

    <p class="text-gray-300">We prove these theorems in the following two sections.</p>

    <h2 id="sec-43" class="text-2xl font-bold">5 The <span class="math">\\mathcal{F}_{tree}</span> Hybrid Model</h2>

    <p class="text-gray-300">Towards proving that Nakamoto’s protocol satisfies the above properties, we first show that it suffices to prove these properties for a simplified protocol having access to an “idealized tree” functionality, <span class="math">\\mathcal{F}_{tree}</span>, instead of a random oracle.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">5.1 The <span class="math">\\mathcal{F}_{tree}</span> Oracle</h3>

    <p class="text-gray-300">This <span class="math">\\mathcal{F}^{p}_{tree}</span> functionality is parameterized by a hardness parameter <span class="math">p</span> and keeps track of “valid chains” of records through a tree. Upon initialization, the tree contains just the root—a special genesis record <span class="math">\\bot</span>. Upon receiving a message <span class="math">\\mathsf{Tree.extend}((\\mathsf{m}_{1},\\ldots,\\mathsf{m}_{\\ell-1}),\\mathsf{m})</span>, it checks whether <span class="math">\\mathsf{m}_{1},\\ldots,\\mathsf{m}_{\\ell-1}</span> is a path on the tree it keeps track of, and if so, with probability <span class="math">p(\\kappa)</span>, extends this path in the tree with the record <span class="math">\\mathsf{m}</span> (unless it was already part of the tree) and returns <span class="math">1</span>, and otherwise, returns <span class="math">0</span>. Upon receiving a message <span class="math">\\mathsf{Tree.ver}(m_{1},\\ldots,\\mathsf{m}_{\\ell})</span> from player <span class="math">i</span>, <span class="math">\\mathcal{F}_{tree}</span> return <span class="math">1</span> if <span class="math">(\\mathsf{m}_{1},\\ldots,\\mathsf{m}_{\\ell})</span> is a path in the tree it keeps track of, and <span class="math">0</span> otherwise. In analogy with how <span class="math">\\mathsf{H}</span> is treated, we allow each honest party to make a single query to <span class="math">\\mathsf{Tree.extend}</span> per round, and the adversary controlling <span class="math">q</span> parties is allowed to make <span class="math">q</span> sequential queries to <span class="math">\\mathsf{Tree.extend}</span>. In analogy with how <span class="math">\\mathsf{H.ver}</span> is treated, we allow parties (honest or corrupted) to make any number of queries to <span class="math">\\mathsf{Tree.ver}</span> per round. Whenever <span class="math">p</span> is clear from context, we simply denote the functionality <span class="math">\\mathcal{F}_{tree}</span></p>

    <p class="text-gray-300">18</p>

    <h2 id="sec-45" class="text-2xl font-bold">5.2 Nakamoto in the <span class="math">\\mathcal{F}_{tree}</span>-hybrid</h2>

    <p class="text-gray-300">We now define a version of Nakamoto's protocol <span class="math">(\\Pi_{Nak}^{p},\\mathcal{C}_{nak}^{p})</span> in the <span class="math">\\mathcal{F}_{tree}^{p}</span>-hybrid model. Essentially, this protocol replaces the random oracle with calls to <span class="math">\\mathcal{F}_{tree}^{p}</span>. state is initialized to just <span class="math">\\bot</span> (i.e., the genesis record). Let <span class="math">\\mathcal{C}_{\\text{tree}}(\\text{state}) = \\text{state}</span> (i.e., the state of a player is now simply the sequence of records, as opposed to blocks). Let <span class="math">\\Pi_{\\text{tree}}^{p}</span> be <span class="math">\\Pi_{Nak}^{p}</span> with the exception that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When a player is trying to add a new record <span class="math">\\mathfrak{m}</span> to their current state state, instead of trying to "mine" it by picking a random nonce <span class="math">n</span> etc, the player simply calls Tree.extend(state, <span class="math">\\mathfrak{m}</span>) and if it gets back the answer 1, it adds <span class="math">\\mathfrak{m}</span> to state and broadcasts (the whole updated chain) state.</li>

      <li>Upon receiving a message state' from some other player, instead of checking whether it is "valid" using H.ver, simply check validity using Tree.ver(state').</li>

    </ul>

    <p class="text-gray-300">Whenever <span class="math">p</span> is clear from context we simply denote the protocol <span class="math">(\\Pi_{\\text{tree}}, \\mathcal{C}_{\\text{tree}})</span>.</p>

    <h2 id="sec-46" class="text-2xl font-bold">5.3 Reducing the security of <span class="math">(\\Pi_{\\text{tree}}, \\mathcal{C}_{\\text{tree}})</span> to the security of <span class="math">(\\Pi_{Nak}, \\mathcal{C}_{Nak})</span></h2>

    <p class="text-gray-300">We now show that if our three desiderata hold w.r.t. <span class="math">(\\Pi_{\\text{tree}}, \\mathcal{C}_{\\text{tree}})</span>, then they also hold w.r.t. <span class="math">(\\Pi_{Nak}, \\mathcal{C}_{Nak})</span>. In fact, we show something stronger: <span class="math">(\\Pi_{Nak}, \\mathcal{C}_{Nak})</span> is as "secure as" <span class="math">(\\Pi_{\\text{tree}}, \\mathcal{C}_{\\text{tree}})</span> w.r.t. any property that is a function of the view of the environment (which is the case for the properties in our desiderata—more formally, for any <span class="math">g, \\mu</span>, growth(view, <span class="math">g</span>), quality(view, <span class="math">\\mu</span>)) and consistent(view) are only of function of the view of <span class="math">Z</span> in view).</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{view}_Z(\\mathsf{view})</span> denote the view of <span class="math">Z</span> in the (full) view view.</p>

    <p class="text-gray-300"><strong>Lemma 5.1.</strong> For every non-uniform PPT <span class="math">A</span>, there exists a non-uniform PPT <span class="math">A&#x27;</span> such that for every <span class="math">V, \\Gamma</span> such that if <span class="math">n(\\cdot), \\rho, \\Delta(\\cdot), A, Z</span> is <span class="math">\\Gamma</span>-admissible w.r.t. <span class="math">(\\Pi_{Nak}^{V}, \\mathcal{C}_{Nak})</span>, it holds that <span class="math">n(\\cdot), \\rho, \\Delta(\\cdot), A&#x27;, Z</span> is <span class="math">\\Gamma</span>-admissible w.r.t. <span class="math">(\\Pi_{tree}^{V}, \\mathcal{C}_{tree})</span> and the following ensembles are statistically close</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\text{view}_Z(\\text{EXEC}^{(\\Pi_{Nak}^V, \\mathcal{C}_{Nak})}(A, Z, \\kappa)) \\}_{\\kappa \\in \\mathbb{N}}</span></li>

      <li><span class="math">\\{\\text{view}_Z(\\text{EXEC}^{(\\Pi_{tree}^V, \\mathcal{C}_{tree})}(A&#x27;, Z, \\kappa)) \\}_{\\kappa \\in \\mathbb{N}}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Proof.</strong> Consider some non-uniform PPT adversary <span class="math">A</span> for <span class="math">(\\Pi_{Nak}^{V}, \\mathcal{C}_{Nak})</span>. We construct a non-uniform PPT <span class="math">A&#x27;</span> that proceeds as follows on input <span class="math">1^{\\kappa}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A&#x27;</span> maintains a table <span class="math">T = \\{(x_i, y_i)\\}_i</span> of random oracle queries <span class="math">x_i</span> and answers <span class="math">y_i</span>. Initially, the table contains only the pair <span class="math">((0, 0, \\bot), h_0)</span> where <span class="math">h_0</span> is a uniformly random string in <span class="math">\\{0, 1\\}^\\kappa</span>. If <span class="math">A&#x27;</span> ever attempts to add a pair <span class="math">(x&#x27;, y)</span> that "collides" with a pair <span class="math">(x, y)</span> already in <span class="math">T</span>, <span class="math">A&#x27;</span> aborts and outputs collision.</li>

      <li>Whenever <span class="math">A</span> makes a <span class="math">\\mathsf{H.ver}(x, y)</span> query, return 1 if <span class="math">(x, y) \\in T</span> (and otherwise 0). We define validity of a chain of blocks <span class="math">(\\mathsf{b}_0, \\ldots, \\mathsf{b}_{\\ell})</span> in exactly the same way as in the random oracle model (See Section 2.4), with the exception that any "H.ver<span class="math">(x, y)</span> check" is replaced by a "(x, y) <span class="math">\\in T</span>" check.</li>

      <li>Whenever <span class="math">A</span> makes a <span class="math">\\mathsf{H}(x)</span> query:</li>

    </ol>

    <p class="text-gray-300">(a) Check whether there exists some record <span class="math">(x,y)\\in T</span> and if so return <span class="math">y</span> to <span class="math">A</span>; otherwise continue.</p>

    <p class="text-gray-300">(b) If <span class="math">x</span> is of the form <span class="math">(h_{\\ell - 1}, \\eta_{\\ell}, \\mathfrak{m}_{\\ell})</span> such that there exists a "valid chain of blocks" <span class="math">\\vec{\\mathsf{b}} = (\\mathsf{b}_0, \\ldots, \\mathsf{b}_{\\ell - 1})</span> where the 4'th component of <span class="math">\\mathsf{b}_{\\ell - 1}</span> equals <span class="math">h_{\\ell - 1}</span> (this can be determined in polynomial time by "tracing" back from <span class="math">h_{\\ell - 1}</span> using the table <span class="math">T</span>, assuming there are no "collisions") proceed as follows. Let <span class="math">\\vec{\\mathfrak{m}}</span> denote the records contained in the sequence of blocks <span class="math">\\vec{\\mathsf{b}}</span>. If <span class="math">\\text{Tree.ver}(\\vec{\\mathfrak{m}}) \\neq 1</span> abort outputting tree-failure. If <span class="math">\\text{Tree extend}(\\vec{\\mathfrak{m}}, \\mathfrak{m}_{\\ell})</span> outputs 1, pick <span class="math">y</span> uniformly at random from <span class="math">\\{0, 1\\}^{\\kappa}</span> conditioned on <span class="math">y &amp;lt; D_p</span> (this event happens w.p. <span class="math">p</span> so it can be done efficiently with rejection sampling), and otherwise pick <span class="math">y</span> uniformly at random from <span class="math">\\{0, 1\\}^{\\kappa}</span> conditioned on <span class="math">y \\geq D_p</span>. Store <span class="math">(x, y)</span> in <span class="math">T</span> and return <span class="math">y</span>.</p>

    <p class="text-gray-300">(c) Otherwise, pick <span class="math">y</span> uniformly at random from <span class="math">\\{0,1\\}^{\\kappa}</span>, store <span class="math">(x,y)</span> in <span class="math">T</span> and return <span class="math">y</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">A</span> wants to deliver a message <span class="math">\\vec{b}</span> to an honest player <span class="math">j</span> such that <span class="math">\\vec{b}</span> is a valid chain of blockss, deliver <span class="math">\\vec{m}</span> to <span class="math">j</span>, where <span class="math">\\vec{m}</span> is the record sequence contained in <span class="math">\\vec{b}</span>. All other messages are dropped.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever an honest party <span class="math">j</span> attempts to broadcast a chain of records <span class="math">\\vec{\\mathfrak{m}} = (\\bot, \\mathfrak{m}_1, \\ldots, \\mathfrak{m}_\\ell)</span>, replace it by a chain of blocks <span class="math">\\vec{b}</span> and relay it to <span class="math">A</span>, where <span class="math">\\vec{b}</span> is computed as follows:</li>

    </ol>

    <p class="text-gray-300">(a) Compute <span class="math">\\mathsf{b}_0, \\ldots, \\mathsf{b}_{\\ell - 1}</span> as follows:</p>

    <p class="text-gray-300">i. If <span class="math">\\ell &amp;lt; 1</span> (i.e., the chain is of length 0 or 1), abort outputting chain-length-failure.</p>

    <p class="text-gray-300">ii. If <span class="math">\\ell = 1</span> (i.e., the chain is of length 2), let <span class="math">\\mathsf{b}_0 = (0,0,\\bot ,h_0)</span>.</p>

    <p class="text-gray-300">iii. If <span class="math">\\ell &amp;gt; 1</span>, let <span class="math">(\\mathsf{b}_0, \\ldots, \\mathsf{b}_{\\ell - 1})</span> be longest valid chain that <span class="math">A</span> previously received from, or delivered to <span class="math">j</span>; if there are two such chains, we break ties by giving a preference to received messages (over delivered ones), and to earlier messages (over later ones). If no such chain exists, abort outputting no-chain-found.</p>

    <p class="text-gray-300">(b) Compute <span class="math">\\mathsf{b}_{\\ell}</span> as follows: Pick <span class="math">h_{\\ell}</span> uniformly at random from <span class="math">\\{0,1\\}^{\\kappa}</span> conditioned on <span class="math">h_{\\ell} &amp;lt; D_{p}</span>, pick <span class="math">\\eta_{\\ell}</span> uniformly at random from <span class="math">\\{0,1\\}^{\\kappa}</span>, add <span class="math">((h_{\\ell - 1}, \\eta_{\\ell}, \\mathfrak{m}_{\\ell}), h_{\\ell})</span> to <span class="math">T</span> (where <span class="math">h_{\\ell - 1}</span> is the last component of <span class="math">\\mathsf{b}_{\\ell - 1}</span>), and let <span class="math">\\mathsf{b}_{\\ell} = (h_{\\ell - 1}, \\eta_{\\ell}, \\mathfrak{m}_{\\ell}, h_{\\ell})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever an honest party <span class="math">j</span> becomes corrupted, replace its chain of records <span class="math">\\vec{\\mathfrak{m}}</span> by a chain of blocks <span class="math">\\vec{\\mathsf{b}}</span>, just as in step 5.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Directly relay all messages from <span class="math">Z</span> to <span class="math">A</span> and vice versa.</li>

    </ol>

    <p class="text-gray-300">Now, consider some <span class="math">V</span>, some <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span> that are <span class="math">\\Gamma</span>-admissible w.r.t. <span class="math">(\\Pi_{Nak}^{V}, \\mathcal{C}_{Nak})</span>. By construction, it directly follows that <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A&#x27;, Z)</span> is <span class="math">\\Gamma</span>-admissible w.r.t. <span class="math">(\\Pi_{\\mathrm{tree}}^{V}, \\mathcal{C}_{\\mathrm{tree}})</span>.</p>

    <p class="text-gray-300">We now turn to show that <span class="math">\\{\\mathsf{view}_Z(\\mathsf{EXEC}^{(\\Pi_{Nak}^V,\\mathcal{C}_{Nak})}(A,Z,\\kappa))_{\\kappa \\in N}</span> and <span class="math">\\{\\mathsf{view}_Z(\\mathsf{EXEC}^{(\\Pi_{\\mathrm{tree}}^V,\\mathcal{C}_{\\mathrm{tree}})}(A&#x27;,Z,\\kappa))_{\\kappa \\in \\mathcal{N}}</span> are statistically close. Towards this goal, we consider a sequence of hybrid experiments.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define HYB1 <span class="math">(A,Z,\\kappa)</span> just like EXEC <span class="math">^{(\\Pi_{Nak}^V,\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span> except that we simulate the random oracle queries H, H.ver using a table <span class="math">T&#x27;</span> as follows: Initially, the table contains only the pair <span class="math">((0,0,\\bot),h_0)</span> where <span class="math">h_0</span> is a uniformly random string in <span class="math">\\{0,1\\}^\\kappa</span>. Whenever any party makes an <span class="math">\\mathsf{H}(x)</span> query such that <span class="math">(x,y)\\in T&#x27;</span>, return <span class="math">y</span>, and otherwise pick a random <span class="math">y\\in \\{0,1\\}^\\kappa</span>, add <span class="math">(x,y)</span> to <span class="math">T&#x27;</span> and return <span class="math">y</span>. H.ver <span class="math">(x,y)</span> queries are answered by checking if <span class="math">(x,y)\\in T&#x27;</span>.</li>

    </ul>

    <p class="text-gray-300">Note that in HYB1 <span class="math">(A,Z,\\kappa)</span>, all <span class="math">\\mathsf{H}</span> queries return a perfectly random string, and <span class="math">\\mathsf{H.ver}</span> queries are answered as a function of <span class="math">\\mathsf{H}</span> queries. In contrast, in EXEC <span class="math">^{(\\Pi_{Nak}^V,\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span>, <span class="math">\\mathsf{H.ver}</span> queries can (slightly) skew the distribution of an <span class="math">\\mathsf{H}</span> query. This gap in statistical distance, however, is negligible. Let bad0 denote the event that some <span class="math">\\mathsf{H.ver}(x,\\cdot)</span> query returns 1, yet no party has previously called <span class="math">\\mathsf{H}(x)</span>. Note that conditioned on bad0 not happening, the answer to every individual <span class="math">\\mathsf{H}(x)</span> query is statistically close to uniform (we sample uniformly at random from</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">a set <span class="math">\\{0,1\\}^{\\kappa}\\setminus\\mathbf{W}</span> where <span class="math">\\mathbf{W}</span> is some set of <em>polynomial size</em>—namely, <span class="math">\\mathbf{W}</span> is the set of outputs <span class="math">y</span> for which the emulation up until this point of <span class="math">\\mathsf{H.ver}(x,y)</span> gave the answer 0). By a hybrid argument, we have that conditioned on <span class="math">\\mathsf{bad0}</span> not happening, the answers to <em>all</em> <span class="math">\\mathsf{H}</span> queries are statistically close to uniform; additionally, under the same conditioning, the answer to all <span class="math">\\mathsf{H.ver}</span> queries are just a function of what <span class="math">\\mathsf{H}</span> queries have been made. It follows that conditioned on <span class="math">\\mathsf{bad0}</span> not happening, <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> is statistically close to <span class="math">\\mathsf{EXEC}^{(\\Pi_{Nak}^{V},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span>. Finally, by union bound over all queries we have that the probability of <span class="math">\\mathsf{bad0}</span> happening in either <span class="math">\\mathsf{EXEC}^{(\\Pi_{Nak}^{V},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span> or <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> is bounded by <span class="math">poly(\\kappa)\\cdot 2^{-\\kappa}</span> and we thus conclude that <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> is statistically close to <span class="math">\\mathsf{EXEC}^{(\\Pi_{Nak}^{V},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> just like <span class="math">\\mathsf{EXEC}^{(\\Pi_{Nak}^{V},\\mathcal{C}_{Nak})}(A,Z,\\kappa)</span> except that we simulate the oracle queries <span class="math">\\mathsf{H},\\mathsf{H.ver}</span> using the table <span class="math">T</span> used by <span class="math">A^{\\prime}</span> (in the same way as <span class="math">A^{\\prime}</span> simulates the answers to those queries for <span class="math">A</span>), as opposed to using the table <span class="math">T^{\\prime}</span> used in <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span>; note that the only differences between these methods is that in the emulation using <span class="math">T</span>, we may also abort outputting collision or tree-failure.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathsf{bad1}</span> denote the event that some player makes an <span class="math">\\mathsf{H}(h_{-1},\\cdot,\\cdot)</span>, or <span class="math">\\mathsf{H.ver}((h_{-1},\\cdot,\\cdot),\\cdot)</span> query without any player ever having received <span class="math">h_{-1}</span> as the answer to some <span class="math">\\mathsf{H}</span> query, but then, later, some player does receive <span class="math">h_{-1}</span> as the answer to some <span class="math">\\mathsf{H}</span> query. We note that the probability of <span class="math">\\mathsf{bad1}</span> happening in either <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> or <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> is negligible: for any query <span class="math">(h_{-1},n,b)</span>, the probability of any subsequent <span class="math">\\mathsf{H}</span> query returning <span class="math">h_{-1}</span> is <span class="math">2^{-\\kappa}</span>, and thus by a union bound, with probability <span class="math">poly(\\kappa)\\cdot 2^{-\\kappa}</span>, no subsequent query (that was not already asked before) will output <span class="math">h_{-1}</span>; finally, the claim follows by another union bound over all queries <span class="math">(h_{-1},n,\\mathsf{m})</span> made during the execution.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{bad2}</span> denote the event that some (possibly the same) players query two different <span class="math">x,x^{\\prime}</span> such that <span class="math">\\mathsf{H}(x)=\\mathsf{H}(x^{\\prime})</span>. It follows by a similar (but slightly simpler) argument that the probability of this event happening in either <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> or <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> is negligible. Note that we trivially have that if <span class="math">\\mathsf{bad2}</span> does not happen, <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> does not abort outputting collision.</p>

    <p class="text-gray-300">Let us argue that conditioned on <span class="math">\\mathsf{bad1}</span> and <span class="math">\\mathsf{bad2}</span> not happening, <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> also does not abort outputting tree-failure. Assume for contradiction that the experiment aborts outputting tree-failure conditioned on <span class="math">\\mathsf{bad1}</span> and <span class="math">\\mathsf{bad2}</span> not happening. Let <span class="math">(\\mathsf{b}_{0},\\ldots,\\mathsf{b}_{\\ell})</span> s.t. <span class="math">\\mathsf{b}_{i}=(h_{i-1},\\eta_{i},\\mathsf{m}_{i},h_{i})</span> be the shortest valid chain (obtained in the emulation of <span class="math">\\mathsf{H}</span>) such that <span class="math">\\mathsf{Tree.ver}(\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{\\ell-1})=1</span> but <span class="math">\\mathsf{Tree.ver}(\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{\\ell})\\neq 1</span>. Since <span class="math">\\vec{m}</span> is valid, we have that the pair <span class="math">((h_{\\ell-1},\\eta_{\\ell-1},\\mathsf{m}_{\\ell-1}),h_{\\ell-1})\\in T</span>, but at the time when it was added to <span class="math">T</span> (through an <span class="math">\\mathsf{H}</span> query), there was no valid chain that ended with <span class="math">h_{\\ell-1}</span> (or else the whole chain would have been in the tree). This means that there could not have been any earlier <span class="math">\\mathsf{H}</span> queries that returned <span class="math">h_{\\ell-1}</span>, since a) if the query was <span class="math">(h_{\\ell-2},\\eta_{\\ell-2},\\mathsf{m}_{\\ell-2})</span> then <span class="math">\\vec{b}</span> could not have been the shortest chain with the above properties, and b) if the query was not <span class="math">(h_{\\ell-2},\\eta_{\\ell-2},\\mathsf{m}_{\\ell-2})</span> then event <span class="math">\\mathsf{bad2}</span> must happen. We conclude that event <span class="math">\\mathsf{bad1}</span> must have happened, which is a contradiction.</p>

    <p class="text-gray-300">It follows that conditioned on <span class="math">\\mathsf{bad1}</span> and <span class="math">\\mathsf{bad2}</span> not happening, <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> proceed identically the same as <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span>: the answers to all <span class="math">\\mathsf{H}</span> queries <span class="math">x</span> are answered independently and uniformly at random (and <span class="math">\\mathsf{H.ver}</span> queries are treated the same way). We conclude that <span class="math">\\mathsf{HYB1}(A,Z,\\kappa)</span> is statistically close to <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span> just like <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> except that whenever an honest player fails in a mining operation (i.e., if <span class="math">h=\\mathsf{H}(h_{-1},n,\\mathsf{m})\\geq D_{p}</span>), we do not store the pair <span class="math">(h_{-1},n,\\mathsf{m}),h)</span> in <span class="math">T</span>. Note that conditioned on the event that such “failed queries” <span class="math">x</span> are never queried again (by either honest parties or <span class="math">A</span>), we have that <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span> and <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span> are identically distributed. Since the nonce <span class="math">n</span> inside every failed query <span class="math">x</span> is randomly selected in <span class="math">\\{0,1\\}^{\\kappa}</span>,</li>

    </ul>

    <p class="text-gray-300">it follows that except with probability <span class="math">poly(\\kappa)\\cdot 2^{-\\kappa}</span>, <span class="math">x</span> is different from every earlier query; additionally, since an honest party discards every failed query (and never communicates it to anyone), we additionally have that except with probability <span class="math">poly(\\kappa)\\cdot 2^{-\\kappa}</span>, <span class="math">x</span> is also different from every later query. Finally, by a union bound over all (failed) query, we have that except with the probability <span class="math">poly(\\kappa)\\cdot 2^{-\\kappa}</span>, failed queries of an honest player are never queried twice. We conclude that <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span> is statistically close to <span class="math">\\mathsf{HYB2}(A,Z,\\kappa)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\mathsf{HYB4}(A,Z,\\kappa)</span> just like <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span> except that honest parties now run <span class="math">\\Pi_{\\mathsf{tree}}</span> (as opposed to <span class="math">\\Pi_{Nak}</span>) but first process incoming and outgoing messages exactly as <span class="math">A^{\\prime}</span> does them for <span class="math">A</span> in Step 4 and 5 (and we update <span class="math">T</span> in exactly the same way). Note that it follows from the definition of the honest party strategy that the experiment never aborts outputting chain-length-failure or no-chain-found (honest players start of with a chain of length 1, containing the genesis block, and only broadcast a chain once they have increased their chain length, thus will never broadcast a chain of length <span class="math">&lt;2</span> so chain-length-failure does not happen; they will only broadcast a chain of length <span class="math">\\ell^{\\prime}&gt;2</span> if they have previously received, or broadcast, a chain of length <span class="math">\\ell^{\\prime}-1</span>, thus no-chain-found does not happen.) Additionally, it follows from the definition of the honest party strategies that both <span class="math">T</span> and all messages and “observable states” (i.e,. the record chains) of honest parties are updated in exactly the same way in <span class="math">\\mathsf{HYB4}(A,Z,\\kappa)</span> and <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span>. <span class="math">\\mathsf{HYB4}(A,Z,\\kappa)</span> and <span class="math">\\mathsf{HYB3}(A,Z,\\kappa)</span> are not identical (or even statistically close) since a) in <span class="math">\\mathsf{HYB4}(A,Z,\\kappa)</span> honest parties have less (none) <span class="math">\\mathsf{H}</span> queries in their view, and b) their local variable state is different; but since everything else in the experiment proceeds the same (and in particular, the “projection” <span class="math">\\mathcal{C}(\\mathsf{state})</span> seen by the environment) is identically distributed, we have that <span class="math">\\mathsf{view}_{Z}(\\mathsf{HYB4}(A,Z,\\kappa))</span> is identically distributed to <span class="math">\\mathsf{view}_{Z}(\\mathsf{HYB3}(A,Z,\\kappa))</span></li>

      <li><span class="math">\\mathsf{HYB4}(A,Z,\\kappa)</span> is just an rephrasing of the experiment <span class="math">\\mathsf{EXEC}^{(\\Pi_{\\mathsf{tree}}^{V},\\mathcal{C}_{\\mathsf{tree}})}(A^{\\prime},Z,\\kappa)</span> where we push operations “performed by the experiment” into the players. It follows that <span class="math">\\mathsf{view}_{Z}(\\mathsf{HYB4}(A,Z,\\kappa))</span> is identically distributed to <span class="math">\\mathsf{view}_{Z}(\\mathsf{EXEC}^{(\\Pi_{\\mathsf{tree}}^{V},\\mathcal{C}_{\\mathsf{tree}})}(A^{\\prime},Z,\\kappa))</span> (note however that the views of the players are different since they perform different oracle operations).</li>

    </ul>

    <p class="text-gray-300">We conclude that <span class="math">\\mathsf{view}_{Z}(\\mathsf{EXEC}^{(\\Pi_{Nak}^{V},\\mathcal{C}_{Nak})}(A,Z,\\kappa))</span> and <span class="math">\\mathsf{view}_{Z}(\\mathsf{EXEC}^{(\\Pi_{\\mathsf{tree}}^{V},\\mathcal{C}_{\\mathsf{tree}})}(A^{\\prime},Z,\\kappa))</span> are statistically close, which concludes the proof of the theorem ∎</p>

    <h2 id="sec-47" class="text-2xl font-bold">6 Proofs of Security in the <span class="math">\\mathcal{F}_{tree}</span> Hybrid Model</h2>

    <p class="text-gray-300">In this section, we finally prove Theorems 4.1, 4.2 and 4.3. By Lemma 5.1, it will suffice to prove them w.r.t. <span class="math">(\\Pi_{\\mathsf{tree}},\\mathcal{C}_{\\mathsf{tree}})</span>. We will heavily make use of the (multiplicative) Chernoff bound, which we recall in Appendix A.</p>

    <h5 id="sec-48" class="text-base font-semibold mt-4">Notation</h5>

    <p class="text-gray-300">Although Nakamoto’s protocol in the <span class="math">\\mathcal{F}_{tree}</span> hybrid model does not utilize the notion of a “block” or “mining”, for intuition, we still employ those terminologies with the following interpretations. A block <span class="math">b</span> refers to a “path” <span class="math">\\vec{\\mathsf{m}}</span>; such a block <span class="math">b</span> is valid at some point in the execution if <span class="math">b</span> is a path (starting at the root) in the tree maintained by <span class="math">\\mathcal{F}_{tree}</span>. We say that a block <span class="math">b</span> was mined at round <span class="math">r</span> if in the view <span class="math">\\mathsf{view}</span>, <span class="math">r</span> is the round in which the block <span class="math">b</span> became valid (i.e., the path <span class="math">b</span> was included in tree). Given a (record) chain <span class="math">C=(\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{\\ell})</span>, we refer to the blocks in <span class="math">C</span> as sub-paths <span class="math">\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{k}</span> of <span class="math">C</span>; we say that <span class="math">C</span> is valid at a round <span class="math">r</span> if all the blocks in <span class="math">C</span> are valid at <span class="math">r</span>. We say that chain <span class="math">C</span> was mined at round <span class="math">r</span> if <span class="math">r</span> was the first round in which <span class="math">C</span> became valid. Let <span class="math">\\mathsf{REAL}(\\sigma)</span> denote the output of <span class="math">\\mathsf{EXEC}^{(\\Pi_{\\mathsf{tree}}^{V},\\mathcal{C}_{\\mathsf{tree}})}(A^{\\prime},Z,\\kappa)</span> with the randomness of the experiment fixed to <span class="math">\\sigma</span> and let <span class="math">\\mathsf{REAL}=\\mathsf{EXEC}^{(\\Pi_{\\mathsf{tree}}^{V},\\mathcal{C}_{\\mathsf{tree}})}(A^{\\prime},Z,\\kappa)</span>.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">For the remainder of this section, we consider some fixed <span class="math">A,Z,n,\\rho,\\Delta</span> such that <span class="math">(A,Z)</span> is <span class="math">(n,\\rho,\\Delta)</span>-valid. Unless we explicitly mention it, we also consider some <em>fixed</em> <span class="math">\\kappa</span>.</p>

    <h5 id="sec-49" class="text-base font-semibold mt-4">An abuse of notation</h5>

    <p class="text-gray-300">To simplify notation, we abuse of notation and ignore <span class="math">\\mathsf{poly}(\\kappa)</span> factors when describing error probabilities such as <span class="math">\\mathsf{neg}(T)</span> and <span class="math">e^{-O(T)}</span>; that is, when writing <span class="math">\\mathsf{neg}(T)</span> or <span class="math">e^{-O(T)}</span> we actually meant <span class="math">\\mathsf{poly}(\\kappa)\\cdot\\mathsf{neg}(T)</span> or <span class="math">\\mathsf{poly}(\\kappa)\\cdot e^{-O(T)}</span>; since our final theorem statements restrict to the case when <span class="math">T&gt;c\\log\\kappa</span> for some sufficiently large <span class="math">c</span>, this will suffice to conclude it. We mention that these <span class="math">\\mathsf{poly}(\\kappa)</span> factors in the error probability arise from the fact that we often apply a union bound over the number of rounds in the execution (which is bounded by <span class="math">\\mathsf{poly}(\\kappa)</span>, since <span class="math">Z</span> is polynomial time in <span class="math">\\kappa</span>).</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">6.1 Proof of the Chain-Growth Property (Theorem 4.1)</h3>

    <p class="text-gray-300">The following theorem (which proves chain growth for the protocol in the <span class="math">\\mathcal{F}_{tree}</span>-hybrid model), combined with Lemma 5.1, yields Theorem 4.1.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 6.1.</h6>

    <p class="text-gray-300">For any <span class="math">\\delta&gt;0</span>, <span class="math">(\\Pi^{p}_{tree},\\mathcal{C}^{p}_{tree})</span> has (errorless) chain growth rate <span class="math">g^{p}_{\\delta}(\\kappa,n,\\rho,\\Delta)=(1-\\delta)\\gamma</span> in <span class="math">\\Gamma_{0}</span> environments.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first observe that the consistent length property holds, and then turn to lower-bounding the chain growth.</p>

    <h5 id="sec-53" class="text-base font-semibold mt-4">Consistent Length</h5>

    <p class="text-gray-300">The following claim shows that if some honest player has a chain of length <span class="math">\\ell</span> at round <span class="math">r</span>, then <em>all</em> other honest players will have a chain of length at least <span class="math">\\ell</span> at round <span class="math">r+\\Delta</span>, which proves the desired consistent length property.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Claim 6.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If in view, <span class="math">i</span> is honest at <span class="math">r</span> and <span class="math">j</span> is honest at <span class="math">r+\\Delta</span>, then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+\\Delta}_{j}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r}_{i}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Due to the fact that all messages are delivered within <span class="math">\\Delta</span> steps, we have that whenever some player either receives a chain of length <span class="math">\\ell</span> all other honest players will receive the same chain within <span class="math">\\Delta</span> step; additionally, whenever an honest player mines a block, it broadcasts it to all other players and they will thus receive it within <span class="math">\\Delta</span> steps. ∎</p>

    <h5 id="sec-56" class="text-base font-semibold mt-4">Chain Growth</h5>

    <p class="text-gray-300">Towards proving the chain growth property, we first consider a hybrid experiment. Let <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> denote the output of <span class="math">\\mathsf{EXEC}^{(\\Pi^{p}_{tree},\\mathcal{C}_{tree})}(A^{\\prime},Z,\\kappa)</span> with the randomness of the experiment fixed to <span class="math">\\sigma</span>, where the experiment is modified as follows: after round <span class="math">r</span>, a) <em>fix</em> all messages/actions by <span class="math">Z</span> to be the ones in <span class="math">\\mathsf{REAL}(\\sigma)</span>; b) remove all new messages <em>sent by the adversary</em> to honest players, and delay currently undelivered messages from corrupted parties to the maximum of <span class="math">\\Delta</span> round; c) delay all messages sent by honest players (that have not already been delivered by round <span class="math">r</span>) to the maximum of <span class="math">\\Delta</span> rounds; and d) whenever some message is being delayed, all honest players “freeze” (i.e., stop “mining”) until the message is delivered. Finally, let <span class="math">\\mathsf{HYB}_{r}</span> denote the output of <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> for a randomly sampled <span class="math">\\sigma</span>.</p>

    <p class="text-gray-300">The following lemma shows that the chain of every honest player cannot decrease in length if we maximally delay messages from honest parties, freeze all honest players during this delay, and drop all adversarial messages <em>for every fixed randomness</em> <span class="math">\\sigma</span>. We emphasize that for this lemma to hold it is crucial that we consider the protocol in the <span class="math">\\mathcal{F}_{tree}</span> model and not the random oracle model. Otherwise, there exists randomness <span class="math">\\sigma</span> such that if we fixed the randomness of the experiment to <span class="math">\\sigma</span>, honest parties could end up on a “better path” once we, for example, remove adversarial message. Additionally, to prove this lemma it is important that we fix the messages/actions of <span class="math">Z</span> (which is enabled by us fixing <span class="math">\\sigma</span>), or else <span class="math">Z</span> could “help” honest players if it notices that messages from <span class="math">A</span> are delayed.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 6.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For all <span class="math">\\sigma</span>, <span class="math">r,t\\geq 0</span> and player <span class="math">j</span> that is honest at round <span class="math">r+t</span> in <span class="math">\\mathsf{REAL}(\\sigma)</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t}_{j}(\\mathsf{REAL}(\\sigma))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t}_{j}(\\mathsf{HYB}_{r}(\\sigma))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix some <span class="math">r</span>. We prove the lemma by induction on <span class="math">t</span>. The base case (<span class="math">t=0</span>) is trivial. Assume the lemma holds for all <span class="math">t^{\\prime}&lt;t</span>. We prove it for <span class="math">t</span>. Consider some <span class="math">\\sigma</span> and some player <span class="math">j</span> that is honest at round <span class="math">s=r+t</span> in <span class="math">\\mathsf{REAL}(\\sigma)</span> and assume for contradiction that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{s}_{j}(\\mathsf{REAL}(\\sigma))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{s}_{j}(\\mathsf{HYB}_{r}(\\sigma))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. We distinguish between two cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">j</span> is corrupted at round <span class="math">s-1</span> in <span class="math">\\mathsf{REAL}(\\sigma)</span>: Note that mining at round <span class="math">s</span> is successful in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> only if it is successful in <span class="math">\\mathsf{REAL}(\\sigma)</span>, so the only possibility of <span class="math">j</span>’s chain to be longer in at round <span class="math">s</span> in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> is if it started off with a longer chain in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>, <em>before it did its mining in this round</em>. We now argue that this is impossible. Since <span class="math">j</span> is honest at round <span class="math">s</span>, <span class="math">j</span> must have been “uncorrupted” in round <span class="math">s</span>. <span class="math">j</span> will thus start with a “blank state” and receive incoming messages (sent by honest parties before round <span class="math">s-1</span>) and potentially also messages from the adversary. By construction, the same players are honest in <span class="math">\\mathsf{REAL}(\\sigma)</span> and <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>. In both experiments <span class="math">A</span> needs to deliver all messages sent by these honest players in rounds on or before <span class="math">s-\\Delta</span>; in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> these are the only messages being delivered, and in <span class="math">\\mathsf{REAL}(\\sigma)</span>, <span class="math">A</span> may deliver additional messages (from honest parties sent after <span class="math">s-\\Delta</span>, or from adversarial players). Let <span class="math">j^{\\prime}</span> be the player that sends <span class="math">j</span> its currently longest chain in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> and let <span class="math">r^{\\prime}</span> be the round when it “mined” this chain; since <span class="math">\\sigma</span> determines when players are successful in “mining” in both experiments, we have that <span class="math">j^{\\prime}</span> also mines a chain in round <span class="math">r^{\\prime}</span> in <span class="math">\\mathsf{REAL}(\\sigma)</span> (and this chain will be delivered to <span class="math">j</span> by round <span class="math">s</span>). By the induction hypothesis, the chain of <span class="math">j^{\\prime}</span> at <span class="math">r^{\\prime}</span> is at least as long in <span class="math">\\mathsf{REAL}(\\sigma)</span> as in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>, which contradicts that the chain of <span class="math">j</span> (before mining) is longer in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>. <span class="math">j</span> is honest at round <span class="math">s-1</span> in <span class="math">\\mathsf{REAL}(\\sigma)</span>: By the induction hypothesis we have that the chain of <span class="math">j</span> is at least as long at round <span class="math">s-1</span> in <span class="math">\\mathsf{REAL}(\\sigma)</span> as in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>, thus the chain of <span class="math">j</span> must have grown at round <span class="math">s</span> in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> (or else it could not be longer at round <span class="math">s</span> as we assumed for contradiction). Also, note that mining at round <span class="math">s</span> is successful in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> only if it is successful in <span class="math">\\mathsf{REAL}(\\sigma)</span>, so the only possibility of <span class="math">j</span>’s chain to be longer in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> is if it received a chain in round <span class="math">s</span> that extended its chain. This chain must have come from an honest player, since the <em>exact same</em> messages sent by corrupt parties and delivered in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span> are also delivered in <span class="math">\\mathsf{REAL}(\\sigma)</span> at the same or earlier round. Let <span class="math">j^{\\prime}</span> be the honest player that sent the chain, and let <span class="math">r^{\\prime}=s-\\Delta</span> be the round in which <span class="math">j^{\\prime}</span> mined the chain; as before, we also have that <span class="math">j^{\\prime}</span> mines a chain in round <span class="math">r^{\\prime}</span> in <span class="math">\\mathsf{REAL}(\\sigma)</span> and this chain must have been delivered to <span class="math">j</span> by round <span class="math">s</span> (and potentially earlier). The chain delivered in <span class="math">\\mathsf{REAL}(\\sigma)</span> may not be the <em>exact same</em> chain delivered in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>, but by the induction hypothesis the chain of <span class="math">j^{\\prime}</span> at <span class="math">r^{\\prime}</span> is at least as long in <span class="math">\\mathsf{REAL}(\\sigma)</span> as in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>, which contradicts that the chain of <span class="math">j</span> is longer in <span class="math">\\mathsf{HYB}_{r}(\\sigma)</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We turn to prove a lower bound on the chain growth of the <em>longest chain</em> known to the honest players. Let <span class="math">\\ell^{r}(\\mathsf{view})</span> denote the length of the <em>longest</em> chain <span class="math">\\mathcal{C}^{r}_{i}(\\mathsf{view})</span> of any honest player <span class="math">i</span> at round <span class="math">r</span> in <span class="math">\\mathsf{view}</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Lemma 6.4.</h6>

    <p class="text-gray-300">For any <span class="math">r,t\\geq 0</span> and any <span class="math">\\delta&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ell^{r+t}(\\mathsf{HYB}_{r})&lt;\\ell^{r}(\\mathsf{HYB}_{r})+(1-\\delta)\\gamma t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}</span></p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix some <span class="math">r</span>. Note that at every round <span class="math">s^{\\prime}\\geq r</span> in <span class="math">\\mathsf{HYB}_{r}</span> where the honest players are not frozen, they have <em>all</em> received all sent messages; they, thus, all have chains of the same length (but not necessarily the same chain). In every such round, the probability that the longest chain (known to the honest parties) is successfully extended is thus exactly <span class="math">\\alpha</span>, <em>independent</em> of the prefix of the experiment.</p>

    <p class="text-gray-300">If after <span class="math">t</span> rounds, the longest chain’s increase is less than <span class="math">c</span>, it means that there were at least <span class="math">t-c\\Delta</span> “unfrozen” rounds (each success leads to <span class="math">\\Delta</span> frozen rounds, and we potentially have <span class="math">\\Delta</span> initially frozen rounds). Moreover, in those <span class="math">t-c\\Delta</span> rounds there were less than <span class="math">c</span> successes. Thus, the probability that the longest chain grows by less than <span class="math">c</span> blocks is upper bounded by <span class="math">\\Pr[W^{t-c\\Delta}&lt;c]</span> where <span class="math">W^{k}</span> is the sum of <span class="math">k</span> independent binary random variables <span class="math">w_{i}</span> that are <span class="math">1</span> with probability <span class="math">\\alpha</span>. Let’s find a <span class="math">c</span> such that <span class="math">E[W^{t-c\\Delta}]=c</span>. That is,</p>

    <p class="text-gray-300"><span class="math">E[W^{t-c\\Delta}]=\\alpha t-\\alpha c\\Delta=c</span></p>

    <p class="text-gray-300">which implies that</p>

    <p class="text-gray-300"><span class="math">c=\\frac{\\alpha t}{1+\\alpha\\Delta}=\\gamma t</span></p>

    <p class="text-gray-300">Thus, if we set <span class="math">c=\\gamma t</span>, we have</p>

    <p class="text-gray-300"><span class="math">E[W^{t-c\\Delta}]=t\\gamma</span></p>

    <p class="text-gray-300">By the Chernoff bound (see Appendix A), we thus have:</p>

    <p class="text-gray-300"><span class="math">\\Pr[W^{t-c\\Delta}&lt;(1-\\delta)t\\gamma]\\leq e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}</span></p>

    <p class="text-gray-300">Since the probability that the longest chain grows by less than <span class="math">(1-\\delta)\\gamma t</span> blocks is upper bounded by <span class="math">\\Pr[W^{t-(1-\\delta)\\gamma t\\Delta}&lt;(1-\\delta)\\gamma t]</span>, it is also upper bounded by <span class="math">\\Pr[W^{t-\\gamma t\\Delta}&lt;(1-\\delta)\\gamma t]</span>, which proves the lemma. ∎</p>

    <p class="text-gray-300">By combining Lemma 6.3 and Lemma 6.4, we get the following lemma.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Lemma 6.5.</h6>

    <p class="text-gray-300">For any <span class="math">r,t\\geq 0</span> and any <span class="math">\\delta&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ell^{r+t}(\\textsf{REAL})&lt;\\ell^{r}(\\textsf{REAL})+(1-\\delta)\\gamma t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}</span></p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By Lemma 6.4, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ell^{r+t}(\\mathsf{HYB}_{r})&lt;\\ell^{r}(\\mathsf{HYB}_{r})+(1-\\delta)\\gamma t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}</span></p>

    <p class="text-gray-300">By definition, for every <span class="math">\\sigma</span>, we have that <span class="math">\\ell^{r}(\\mathsf{HYB}_{r}(\\sigma))=\\ell^{r}(\\mathsf{REAL}(\\sigma))</span>. By Lemma 6.3, for every <span class="math">\\sigma</span>, we have that <span class="math">\\ell^{r+t}(\\mathsf{HYB}_{r}(\\sigma))\\leq\\ell^{r+t}(\\mathsf{REAL}(\\sigma))</span>. Thus,</p>

    <p class="text-gray-300"><span class="math">Pr\\left[\\ell^{r+t}(\\mathsf{REAL})&lt;\\ell^{r}(\\mathsf{REAL})+(1-\\delta)\\gamma t\\right]\\leq Pr\\left[\\ell^{r+t}(\\mathsf{HYB}_{r})~{}&lt;\\ell^{r}(\\mathsf{HYB}_{r})+(1-\\delta)\\gamma t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Lemma 6.5 only gives a bound on the growth of the <em>longest chain</em>. We now give a bound on the chain growth between any two honest users by combining Lemma 6.5 and Claim 6.2 (i.e., the consistent length property).</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Lemma 6.6.</h6>

    <p class="text-gray-300">For any <span class="math">r,t\\geq 0</span> and any <span class="math">\\delta&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\textsf{min-chain-increase}_{r,t}(\\textsf{REAL})&lt;(1-\\delta)\\gamma t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}</span></p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that for any view,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\min_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t}_{j}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r}_{i}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\min_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t}_{j}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\max_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r}_{i}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Claim 6.2, $\\min_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t}_{j}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\max_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t-\\Delta}_{j}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Thus,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\min_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t}_{j}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r}_{i}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\max_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t-\\Delta}_{j}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\max_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r}_{i}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell^{r+t-\\Delta}(\\textsf{view})-\\ell^{r}(\\textsf{view}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Lemma 6.5, we have that for every constant <span class="math">\\delta^{\\prime}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ell^{r+t-\\Delta}(\\textsf{REAL})&lt;\\ell^{r}(\\textsf{REAL})+(1-\\delta^{\\prime})\\gamma(t-\\Delta)\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\gamma(t-\\Delta)\\right)}.</span></p>

    <p class="text-gray-300">Since <span class="math">\\gamma\\Delta=\\frac{\\alpha\\Delta}{1+\\alpha\\Delta}&lt;1</span>, it follows that for every constant <span class="math">\\delta</span> (by picking a sufficiently small <span class="math">\\delta^{\\prime}</span>), we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ell^{r+t-\\Delta}(\\textsf{REAL})&lt;\\ell^{r}(\\textsf{REAL})+(1-\\delta)\\gamma t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}.</span></p>

    <p class="text-gray-300">We thus conclude that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\min_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r+t}_{j}(\\textsf{REAL})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{r}_{i}(\\textsf{REAL})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><(1-\\delta)\\gamma t\\right]<e^{-\\Omega\\left(\\delta^{2}\\gamma t\\right)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which proves the lemma. ∎</p>

    <p class="text-gray-300">The proof of Theorem 6.1 is concluded by combining 6.6 with a union bound over the rounds <span class="math">r</span>. ∎</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">6.2 Proof of the Chain Quality Property (Theorem 4.2)</h3>

    <p class="text-gray-300">Towards proving the chain quality property, the following two simple lemmas will be useful.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma 6.7 (Upperbound on Blocks).</h6>

    <p class="text-gray-300">Let <span class="math">Q_{t}(\\textsf{view})</span> be the maximum number of blocks mined in any windows of <span class="math">t</span> rounds (i.e., between round <span class="math">r</span> and <span class="math">r+t</span> for any <span class="math">r</span>) in view. For any <span class="math">t\\geq 0</span> and any <span class="math">\\delta&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[Q_{t}(\\textsf{REAL})&gt;(1+\\delta)\\,np\\cdot t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}npt\\right)}</span></p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In <span class="math">t</span> rounds, the players get <span class="math">tn</span> chances to mine a block; each chance succeeds with probability <span class="math">p</span>. The desired bound follows directly from the Chernoff bound and a union bound of the rounds <span class="math">r</span>. ∎</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma 6.8 (Upperbound on Adversarial Blocks).</h6>

    <p class="text-gray-300">Let <span class="math">A_{r}(\\textsf{view})</span> be the maximum number of blocks mined by the adversary in any window of <span class="math">r</span> rounds. For any <span class="math">t</span> and <span class="math">\\delta&gt;0</span></p>

    <p class="text-gray-300"><span class="math">\\Pr[A_{t}(\\textsf{REAL})&gt;(1+\\delta)\\beta t]&lt;e^{-\\Omega(\\delta^{2}\\beta t)}.</span></p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In <span class="math">t</span> rounds, the adversary gets <span class="math">tpn</span> chances to mine a block; each chance succeeds with probability <span class="math">p</span>. The desired bound follows directly from the Chernoff bound and a union bound over the rounds <span class="math">r</span>. ∎</p>

    <p class="text-gray-300">Armed with these lemma, we are now ready to prove Theorem 4.2. The following theorem (which proves the chain quality property for the protocol in the <span class="math">\\mathcal{F}_{tree}</span>-hybrid model), combined with Lemma 5.1, yields Theorem 4.2.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Theorem 6.9.</h6>

    <p class="text-gray-300">For all <span class="math">\\delta\\geq 0</span>, any <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi^{p}_{tree},\\mathcal{C}^{p}_{tree})</span> has (errorless) chain quality <span class="math">\\mu^{p}_{\\delta}(n,\\rho,\\Delta)=1-(1+\\delta)\\frac{\\beta}{\\gamma}</span> in <span class="math">\\Gamma_{0}</span> environments.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider some view view in the support of REAL, some round <span class="math">r</span> and player <span class="math">i</span> that is honest at view^{r}. Let <span class="math">C=\\mathcal{C}^{r}_{i}(\\textsf{view})</span>, let $\\mathsf{b}_{0},\\ldots,\\mathsf{b}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> be the blocks in </span>C<span class="math">, let </span>\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> be the records contained in them and let </span>\\mathsf{b}_{j},\\ldots,\\mathsf{b}_{j+T}<span class="math"> be </span>T<span class="math"> consecutive blocks in </span>C<span class="math"> for some </span>j<span class="math">. We say that a block </span>b_{i}<span class="math"> is <em>adversarial</em> w.r.t. view if </span>\\mathsf{b}_{i}<span class="math"> was mined by the adversary in view; note that the record </span>\\mathsf{m}_{i}<span class="math"> (s.t. </span>i\\geq j<span class="math">) contained in </span>\\mathsf{b}_{i}<span class="math"> can only be adversarial w.r.t view^{r} and the prefix </span>\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{j-1}<span class="math"> if </span>\\mathsf{b}_{i}<span class="math"> is adversarial w.r.t view. We show that except with probability </span>\\mathsf{neg}(T)<span class="math"> over view </span>\\leftarrow<span class="math"> REAL, the fraction of adversarial blocks in any such sequence </span>\\mathsf{b}_{j},\\ldots,\\mathsf{b}_{j+T}<span class="math"> is upper-bounded by </span>(1+\\delta)\\frac{\\beta}{\\gamma}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us start by noting that it suffices to provide a bound assuming that <span class="math">\\mathsf{b}_{j-1}</span> is not adversarial (i.e., it was either mined by an honest player, or it is the genesis block), and that <span class="math">\\mathsf{b}_{j+T+1}</span> is not adversarial (i.e., it was either mined by an honest player or $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=j+T<span class="math">); otherwise, the fraction of adversarial blocks can only increase if we “enlarge” the segment (by considering a smaller </span>j<span class="math"> and/or a bigger </span>T$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consider such a sequence. Let <span class="math">r^{\\prime}</span> be the round when <span class="math">\\mathsf{b}_{j-1}</span> was mined; since it was not adversarial it was the chain of some honest player at this point. Let <span class="math">r^{\\prime}+t</span> be the round when <span class="math">\\mathsf{b}_{j+T}</span> first appeared as an honest players’ chain; by construction such a round exists (since <span class="math">\\mathsf{b}_{j+T+1}</span> is not adversarial). Note that by the definition of <span class="math">\\mathcal{F}_{tree}</span>, all the adversarial blocks in <span class="math">\\mathsf{b}_{j},\\ldots,\\mathsf{b}_{j+T}</span> must have been mined between round <span class="math">r^{\\prime}</span> and <span class="math">r^{\\prime}+t</span>.</p>

    <p class="text-gray-300">We simplify the experiment by “ignoring” bad events that happen with negligible probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Lemma 6.7, for every <span class="math">0&lt;\\tilde{\\delta}&lt;1</span>, except with probability <span class="math">e^{-\\Omega(\\delta^{2}T)}</span>, we have that <span class="math">Q_{\\frac{T}{(1+\\delta)np}}(\\textsf{view})&lt;T</span>. Thus except with probability <span class="math">e^{-\\Omega(\\delta^{2}T)}</span>, we have that <span class="math">t&gt;\\frac{T}{(1+\\delta)np}</span>. Assume this holds and let bad1 denote the event that it does not (for <em>some</em> sequence <span class="math">\\mathsf{b}_{j},\\ldots,\\mathsf{b}_{j+T}</span>).</li>

      <li>Since by Theorem 6.1, for every <span class="math">\\delta^{\\prime}</span>, the chain growth is lower bounded by <span class="math">(1-\\delta^{\\prime})\\gamma</span>, except with probability <span class="math">\\mathsf{neg}(T)</span>, we have that,</li>

    </ul>

    <p class="text-gray-300"><span class="math">t\\leq\\frac{T}{(1-\\delta^{\\prime})\\gamma}.</span></p>

    <p class="text-gray-300">Assume this holds, and let bad2 denote the event that it does not (again for <em>some</em> sequence <span class="math">\\mathsf{b}_{j},\\ldots,\\mathsf{b}_{j+T}</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Lemma 6.8, we have that for every <span class="math">\\delta^{\\prime\\prime}</span>, except with probability <span class="math">e^{-\\Omega(\\delta^{\\prime\\prime}{}^{2}\\beta t)}</span>, the number of adversarial blocks mined during this period is upper bounded by</li>

    </ul>

    <p class="text-gray-300"><span class="math">(1+\\delta^{\\prime\\prime})\\beta t\\leq\\frac{(1+\\delta^{\\prime\\prime})}{1-\\delta^{\\prime}}\\cdot T\\cdot\\frac{\\beta}{\\gamma}</span></p>

    <p class="text-gray-300">Let bad3 denote the event that this does not happen. Since we assumed that bad1 does not happens, <span class="math">\\beta t=\\rho npt&gt;\\rho np\\frac{T}{(1+\\delta)np}=\\frac{\\rho T}{1+\\delta}</span>, thus bad3 only happens with probability <span class="math">\\mathsf{neg}(T)</span>.</p>

    <p class="text-gray-300">We conclude by noting that assuming that none of the bad events happen, the fraction of adversarial blocks in <em>any</em> such sequence is</p>

    <p class="text-gray-300"><span class="math">\\frac{(1+\\delta^{\\prime\\prime})}{1-\\delta^{\\prime}}\\cdot\\frac{\\beta}{\\gamma}</span></p>

    <p class="text-gray-300">For every <span class="math">\\delta&gt;0</span>, by picking sufficiently small <span class="math">\\delta^{\\prime},\\delta^{\\prime\\prime}</span>, this quantity is upperbounded by</p>

    <p class="text-gray-300"><span class="math">(1+\\delta)\\frac{\\beta}{\\gamma}.</span></p>

    <p class="text-gray-300">Finally, by applying the union bound over the bad events, we have that the upperbound on the fraction of adversarial blocks holds except with probability <span class="math">\\mathsf{neg}(T)</span>. ∎</p>

    <p class="text-gray-300">6.3 Proof of the Consistency Property (Theorem 4.3)</p>

    <p class="text-gray-300">Towards proving consistency, we first show that if an adversary “withholds” a block for “too long”, it will never make it to the chain. Let witholding-time(view) be the longest number of rounds <span class="math">t</span> such that in view, 1) the adversary mines a block b at some round <span class="math">r</span>, and 2) there exists some honest player <span class="math">i</span> such that b appeared (for the first time) as <span class="math">i</span>’s chain at round <span class="math">r+t</span>.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Lemma 6.10 (“No long block witholding”).</h6>

    <p class="text-gray-300">Assume <span class="math">\\gamma\\geq(1+\\delta)\\beta</span> for some <span class="math">\\delta\\in(0,1)</span>. Then, for every constant <span class="math">0&lt;\\omega&lt;1</span> there exists a negligible function <span class="math">\\epsilon(\\cdot)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\text{view}\\leftarrow\\text{REAL}:\\text{witholding-time}(\\text{view})\\geq\\omega t\\right]\\leq\\epsilon(\\beta t)</span></p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider some view view where the adversary mines block <span class="math">\\mathsf{b}_{l}=(\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{l})</span> at round <span class="math">r</span> and some honest party <span class="math">i</span> accepts a block b as its chain in round <span class="math">s</span>, such that <span class="math">s-r\\geq\\omega t.</span> Let block <span class="math">\\mathsf{b}_{l-k}=(\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{l-k})</span> be the most recent (i.e., smallest <span class="math">k</span>) non-adversarial block (i.e., it was mined by an honest party or it was a genesis block) that is a prefix of block <span class="math">\\mathsf{b}_{l}.</span> Since <span class="math">\\mathsf{b}_{l-k}</span> is not adversarial, it was the chain of some honest player <span class="math">j</span> at some round <span class="math">r^{\\prime}\\leq r</span>; thus at least <span class="math">\\omega t</span> rounds have elapsed from <span class="math">r^{\\prime}</span> to <span class="math">s.</span> As in Theorem 6.9, we simplify the experiment by “ignoring” bad events that happen with negligible probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At round <span class="math">r^{\\prime}</span> some honest player has a chain of length <span class="math">l-k</span> and at <span class="math">s</span> some (potentially other) honest player has a chain of length <span class="math">l.</span> Since by Theorem 6.1, for every <span class="math">\\delta^{\\prime}</span>, the chain growth is lower bounded by <span class="math">(1-\\delta^{\\prime})\\gamma</span>, except with probability <span class="math">\\mathsf{neg}(\\gamma t)</span>, we thus have that,</li>

    </ul>

    <p class="text-gray-300"><span class="math">k\\geq(1-\\delta^{\\prime})\\gamma\\omega t.</span></p>

    <p class="text-gray-300">Assume this holds, and let bad1 denote the event that it does not. Since by assumption <span class="math">\\gamma&gt;\\beta</span>, we thus have that bad1 only happens with probability <span class="math">\\mathsf{neg}(\\beta t)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Lemma 6.8, we have that for every <span class="math">\\delta^{\\prime\\prime}</span>, except with probability <span class="math">e^{-\\Omega(\\beta t)}</span> the number of adversarial blocks mined during this period is upper bounded by</li>

    </ul>

    <p class="text-gray-300"><span class="math">(1+\\delta^{\\prime\\prime})\\beta\\omega t</span></p>

    <p class="text-gray-300">Assume it holds and let bad2 denote the event that does not. By construction, all the blocks from <span class="math">\\mathsf{b}_{l-k}</span> to <span class="math">\\mathsf{b}_{l}</span> are adversarial, thus we have that</p>

    <p class="text-gray-300"><span class="math">k\\leq(1+\\delta^{\\prime\\prime})\\beta\\omega t</span></p>

    <p class="text-gray-300">We conclude that, assuming that none of the bad events happen,</p>

    <p class="text-gray-300"><span class="math">(1-\\delta^{\\prime})\\gamma\\omega t\\leq(1+\\delta^{\\prime\\prime})\\beta\\omega t</span></p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math">\\gamma\\leq\\frac{(1+\\delta^{\\prime\\prime})}{(1-\\delta^{\\prime})}\\beta</span></p>

    <p class="text-gray-300">By picking <span class="math">\\delta^{\\prime}</span> and <span class="math">\\delta^{\\prime\\prime}</span> sufficiently small, we get that</p>

    <p class="text-gray-300"><span class="math">\\gamma&lt;(1+\\delta)\\beta</span></p>

    <p class="text-gray-300">which is a contradiction.</p>

    <p class="text-gray-300">We next prove that the chains of the honest players can only diverge “recently” (i.e., in the last <span class="math">t</span> rounds); we then use the upper-bound on chain growth to conclude the theorem. We say that two chains <span class="math">C_{1}=\\vec{m}_{1},C_{2}=\\vec{m}_{2}</span> diverge at round <span class="math">r</span> in view if the last block <span class="math">\\mathsf{b}=(\\mathsf{m}_{0},\\ldots,\\mathsf{m}_{k})</span> they have in common was mined before round <span class="math">r</span>. (Note that by definition of a block in the <span class="math">\\mathcal{F}_{tree}</span> model, if <span class="math">C_{1},C_{2}</span> have some block in common the chains up to this block must be identical.)</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 6.11.</h6>

    <p class="text-gray-300">Assume there is an <span class="math">0&lt;\\delta&lt;1</span> such that <span class="math">\\alpha(1-2(\\Delta+1)\\alpha)\\geq(1+\\delta)\\beta</span>. Except with probability <span class="math">e^{-\\Omega(\\beta t)}</span> over view <span class="math">\\leftarrow</span> REAL, there does not exists rounds <span class="math">r\\geq r^{\\prime}</span> and players <span class="math">i,j</span> such that <span class="math">i</span> is honest at <span class="math">r</span>, <span class="math">j</span> is honest at <span class="math">r^{\\prime}</span> and <span class="math">\\mathcal{C}_{i}^{r}(\\textsf{view})</span> and <span class="math">\\mathcal{C}_{j}^{r^{\\prime}}(\\textsf{view})</span> diverge at round <span class="math">s=r-t</span>.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We start by noting that by a simple induction over <span class="math">r^{\\prime}-r</span>, it suffices to show the lemma for the special cases that a) <span class="math">r^{\\prime}=r</span> or b) <span class="math">r^{\\prime}=r+1</span>; the base case of the induction is case a), and the inductive step follows directly from b) and the observation that if two chains do not diverge at <span class="math">r^{\\prime}&gt;r</span>, then they clearly do not diverge at <span class="math">r</span> either.</p>

    <p class="text-gray-300">We now turn to prove the lemma for the special case (that <span class="math">r\\leq r^{\\prime}\\leq r+1</span>). We begin with a proof outline and then turn to the actual proof.</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">Proof outline.</h4>

    <p class="text-gray-300">We show that between the rounds <span class="math">s=r-t</span> and <span class="math">r</span>, there are many “patterns” of rounds such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">\\Delta</span> rounds no honest player mines a block;</li>

      <li>then <em>a single player mines</em> a new block;</li>

      <li>which is followed by <span class="math">\\Delta</span> rounds in which no honest player mines a block.</li>

    </ul>

    <p class="text-gray-300">Whenever such a pattern occurs, <em>unless the adversary mines a chain of length <span class="math">\\ell+1</span></em>, where <span class="math">\\ell</span> is the length of the longest chain known to the honest players when the pattern begins, there exists a <em>unique</em> block that can appear on position <span class="math">\\ell+1</span> in any chain held by an honest player at round <span class="math">r</span> (and thus by the definition of a block, the prefixes of all chains held by honest players are identical up until position <span class="math">\\ell+1</span>). Intuitively this follows since, “after the first period of silence”, unless the adversary mines a chain of length <span class="math">\\ell+1</span>, the honest players all agree on the length of the chain (being exactly <span class="math">\\ell</span>), then agree on the newly mined block after the second silence; no honest player will therefore attempt to mine a chain that is shorter and thus will never mine a block for position <span class="math">\\ell+1</span>). Furthermore, each new pattern gives rise to a new such “converge opportunity”. Thus, unless between the rounds <span class="math">s</span> and <span class="math">r^{\\prime}\\leq s+(t+1)</span>, the number of times the adversary succeeds in mining a chain of length <span class="math">\\ell+1</span> (where as before <span class="math">\\ell</span> is the length of the longest chain known to the honest players) is smaller than the number of such patterns, chains of honest players at rounds <span class="math">r,r^{\\prime}</span> cannot diverge at <span class="math">s</span>. The proof is concluded by showing that the number of such patterns increases at a faster rate than the number of blocks mined by the adversary; to do this, we rely on the block withholding lemma (Lemma 6.10) to argue that the adversary cannot make use of any blocks mined too long ago in order to create disagreement.</p>

    <h4 id="sec-77" class="text-lg font-semibold mt-6">The actual proof.</h4>

    <p class="text-gray-300">We start by making the following useful observations.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Claim 6.12.</h6>

    <p class="text-gray-300">For every <span class="math">0&lt;\\delta&lt;1</span> there exists <span class="math">0&lt;\\delta^{\\prime}&lt;1</span> such that for all positive <span class="math">\\kappa,n,\\rho,\\Delta,\\alpha,\\beta</span> such that</p>

    <p class="text-gray-300"><span class="math">\\alpha(1-2\\alpha(\\Delta+1))\\geq(1+\\delta)\\beta</span></p>

    <p class="text-gray-300">holds, the following holds</p>

    <p class="text-gray-300"><span class="math">\\alpha</span> <span class="math">&gt;\\gamma&gt;(1+\\delta^{\\prime})\\beta</span> (1) <span class="math">(1-\\delta^{\\prime})</span> <span class="math">&gt;(\\Delta+1)\\alpha</span> (2)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">The proof follows by simple calculation. We start by proving Equation 1. For any <span class="math">\\Delta&gt;0</span> and any <span class="math">\\alpha&gt;0</span>, it follows that</p>

    <p class="text-gray-300"><span class="math">2(\\Delta+1)&gt;\\frac{\\Delta}{1+\\Delta\\alpha}</span></p>

    <p class="text-gray-300">Multiplying both sides by <span class="math">\\alpha</span>, and breaking out fractions:</p>

    <p class="text-gray-300"><span class="math">2\\alpha(\\Delta+1)&gt;1-\\left(\\frac{1}{1+\\Delta\\alpha}\\right)</span></p>

    <p class="text-gray-300">and finally, moving the fraction to the left, rearranging, and multiplying by <span class="math">\\alpha</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\alpha&gt;\\gamma=\\alpha\\left(\\frac{1}{1+\\Delta\\alpha}\\right)&gt;\\alpha\\Big{(}1-2\\alpha(\\Delta+1)\\Big{)}\\geq(1+\\delta)\\beta</span></p>

    <p class="text-gray-300">where the last inequality follows from the hypothesis.</p>

    <p class="text-gray-300">To prove Equation 2, divide both sides of the hypothesis by <span class="math">\\alpha</span>, distribute the left-hand side of the hypothesis and rearrange to get</p>

    <p class="text-gray-300"><span class="math">1-\\Big{(}\\left(1+\\delta\\right)\\frac{\\beta}{\\alpha}\\Big{)}\\geq 2\\alpha(\\Delta+1)&gt;\\alpha(\\Delta+1)</span></p>

    <p class="text-gray-300">Because <span class="math">\\alpha</span> and <span class="math">\\Delta</span> are positive, the leftside too must be positive, and thus, we can pick <span class="math">0&lt;\\delta^{\\prime}&lt;\\min\\left\\{\\delta,(1+\\delta)\\frac{\\beta}{\\alpha}\\right\\}&lt;1</span> to satisfy both conditions. ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, consider some view view in the execution of REAL and consider some round $r\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">view</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and some </span>t<span class="math"> such that </span>s=r-t\\geq 0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We simplify the experiment by “ignoring” bad events that happen with negligible probability. In the sequel we will define various random variables <span class="math">\\mathbf{L}(\\textsf{view}),\\mathbf{X}(\\textsf{view})</span>, <span class="math">\\mathbf{R}_{i}(\\textsf{view})</span>; to simplify the notation, we omit view whenever it is clear from context.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We say that a round <span class="math">\\tilde{r}</span> in view is <em>successful</em> if there exists some honest player that mines a block at round <span class="math">\\tilde{r}</span>. Note that (by definition), <span class="math">\\alpha</span> is the probability that a round <span class="math">\\tilde{r}</span> is successful. Let <span class="math">\\mathbf{L}(\\textsf{view})</span> be the number of successful rounds between <span class="math">s</span> and <span class="math">r</span> and let <span class="math">L=\\left(1-\\delta^{\\prime}\\right)\\alpha t</span> for some constant <span class="math">0&lt;\\delta^{\\prime}&lt;1</span>. Let bad1 be the event that <span class="math">\\mathbf{L}&lt;L</span>. By the Chernoff bound we have,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\textsf{bad1}]=\\Pr\\left[\\mathbf{L}&lt;L\\right]\\leq e^{-\\Omega(\\delta^{\\prime 2}\\alpha t)}\\leq e^{-\\Omega(\\delta^{\\prime 2}\\beta t)}</span></p>

    <p class="text-gray-300">where the last inequality follows by Claim 6.12(1).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{R}_{1}(\\textsf{view})</span> be the number of rounds from <span class="math">s</span> to the first successful round, and let <span class="math">\\mathbf{R}_{i}(\\textsf{view})</span> for <span class="math">i&gt;1</span> be the number of rounds between the <span class="math">(i-1)^{\\text{th}}</span> successful round to the <span class="math">i^{\\text{th}}</span> successful round. Let <span class="math">\\mathbf{X}_{i}(\\textsf{view})=1</span> if <span class="math">\\mathbf{R}_{i}&gt;\\Delta</span> and <em>exactly</em> one player mines a block in the <span class="math">i+1</span>’st successful round (and 0 otherwise). Note that the random variables <span class="math">\\mathbf{X}_{i}</span>’s are independent (when view <span class="math">\\leftarrow</span> REAL). Because the probability that some player mines a block in a round is <span class="math">\\alpha</span>, by the union bound, we have that <span class="math">\\Pr[\\mathbf{X}_{i}(\\textsf{REAL})=0]\\geq(\\Delta+1)\\alpha</span> (the bad event happens if somebody mines a block in one of the <span class="math">\\Delta</span> rounds after the <span class="math">i</span>’th successful round, or if somebody else mines a block in the <span class="math">(i+1)</span>’st successful round). Let <span class="math">\\mathbf{X}(\\textsf{view})=\\sum_{i=1}^{L}\\mathbf{X}_{i}</span> and let <span class="math">X=\\left(1-\\delta^{\\prime\\prime}\\right)\\left(1-(\\Delta+1)\\alpha\\right)L</span>. By the Chernoff bound, we have that,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathbf{X}\\leq X\\right]\\leq e^{-\\Omega(\\delta^{\\prime\\prime 2}X)}.</span></p>

    <p class="text-gray-300">Let bad2 be the event that <span class="math">\\mathbf{X}\\leq X</span>. Since by Claim 6.12, there exists some constant <span class="math">0&lt;\\tilde{\\delta}&lt;1</span> such that a) <span class="math">(\\Delta+1)\\alpha&lt;1-\\tilde{\\delta}</span> and b) <span class="math">\\alpha\\geq\\beta</span>, it follows that bad2 happens with probability at most <span class="math">e^{-\\Omega(\\delta^{\\prime\\prime 2}\\beta t)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{Y}_{i}(\\mathsf{view})=1</span> if <span class="math">\\mathbf{X}_{i}=1</span> and <span class="math">\\mathbf{X}_{i+1}=1</span> (that is, we have a period of at least <span class="math">\\Delta</span> rounds “of silence”, followed by a round in which <em>exactly one</em> honest players successfully mines a block, followed by at least <span class="math">\\Delta</span> rounds of silence); we refer to such an event as a <em>convergence opportunity</em>. Let <span class="math">\\mathbf{Y}(\\mathsf{view})=\\sum_{i=1}^{L}\\mathbf{Y}_{i}</span>. Since each <span class="math">\\mathbf{X}_{i}=0</span> can “ruin” at most two convergence opportunities, we have that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{Y}\\geq\\sum_{i=1}^{L}1-2\\sum_{i=1}^{L}(1-\\mathbf{X}_{i})=2\\mathbf{X}-L</span></p>

    <p class="text-gray-300">We conclude that conditioned on <span class="math">\\mathsf{bad1}</span> and <span class="math">\\mathsf{bad2}</span> not happening, the number of convergence opportunities is at least</p>

    <p class="text-gray-300"><span class="math">2X-L</span> <span class="math">=\\left[2(1-\\delta^{\\prime\\prime})\\left(1-(\\Delta+1)\\alpha\\right)L\\right]-L</span> <span class="math">=L\\left[1-2\\delta^{\\prime\\prime}-2\\alpha(\\Delta+1)(1-\\delta^{\\prime\\prime})\\right]</span> <span class="math">\\geq L\\left[1-2\\delta^{\\prime\\prime}-2\\alpha(\\Delta+1)\\right]</span> <span class="math">=\\left((1-\\delta^{\\prime})\\alpha t\\right)\\left[1-2\\delta^{\\prime\\prime}-2\\alpha(\\Delta+1)\\right]</span></p>

    <p class="text-gray-300">It follows that for every constant <span class="math">0&lt;\\delta^{\\prime\\prime\\prime}&lt;1</span>, by appropriately picking (sufficiently small) <span class="math">\\delta^{\\prime}</span> and <span class="math">\\delta^{\\prime\\prime}</span>, we have that conditioned on <span class="math">\\mathsf{bad1}</span> and <span class="math">\\mathsf{bad2}</span> do not happening, the number of convergence opportunities is at least</p>

    <p class="text-gray-300"><span class="math">(1-\\delta^{\\prime\\prime\\prime})(1-2\\alpha(\\Delta+1))\\alpha t</span></p>

    <p class="text-gray-300">Additionally, by a union bound, the probability that either of these events occur is at most <span class="math">e^{-\\Omega(\\beta t)}</span>.</p>

    <p class="text-gray-300">Whenever such a convergence opportunity occurs, <em>unless the adversary mines a chain of length <span class="math">\\ell+1</span></em> before round <span class="math">r^{\\prime}</span>, where <span class="math">\\ell</span> is the length of the longest chain known to the honest players when the convergence opportunity begins, there exists a <em>unique</em> block that can appear on position <span class="math">\\ell+1</span> in any chain held by an honest player after the convergence opportunity and up until round <span class="math">r^{\\prime}</span>. This follows because of three reasons: first, after the first <span class="math">\\Delta</span> period of silence, all honest parties have chains of the same length <span class="math">\\ell</span> (the longest chain known to the honest players before the period of silence must have been delivered to all of them by this point, and the only way the adversary can disrupt this is if it mines a longer chain which is only possible if it first mines a chain of length <span class="math">\\ell+1</span>); secondly, there is a unique miner that succeeds in extending its chain, thus obtaining a chain of length <span class="math">\\ell+1</span>; and finally, by the end of the second period of silence, all players must have received this extension or potentially some other chain (by the adversary) which is at least as long, which means that no honest player will ever try to mine from a chain of length smaller than <span class="math">\\ell+1</span> and thus no other block mined by an honest player can appear in position <span class="math">\\ell+1</span> in any valid chain.</p>

    <p class="text-gray-300">Additionally, note that at every such convergence opportunity, the length of the longest chain <span class="math">\\ell</span> grows by at least <span class="math">1</span>. Thus the only way for the chains of two honest player <span class="math">i,j</span> at rounds <span class="math">r,r^{\\prime}</span> to diverge at <span class="math">s</span> is if between the rounds <span class="math">s</span> and <span class="math">r^{\\prime}</span>, the adversary mines a block of length <span class="math">\\ell+1</span> for every such convergence opportunity (or else they will have a block in common after <span class="math">s</span>, and thus in fact, all blocks in common up until this point). Thus it needs to mine at least</p>

    <p class="text-gray-300"><span class="math">T_{\\delta^{\\prime\\prime\\prime}}=(1-\\delta^{\\prime\\prime\\prime})(1-2\\alpha(\\Delta+1))\\alpha t</span></p>

    <p class="text-gray-300">new blocks. Furthermore, these blocks all need to be accepted by some honest player at round <span class="math">s</span> (or later).</p>

    <p class="text-gray-300">Since by Claim 6.12, there exists some constant <span class="math">0&lt;\\tilde{\\delta}&lt;1</span> such that a) <span class="math">\\gamma&gt;(1+\\tilde{\\delta})\\beta</span>, we can apply the block witholding lemma (Lemma 6.10), to conclude that for any constant <span class="math">\\omega</span>, any such block must have been mined by round <span class="math">s-\\omega t</span> except probability <span class="math">e^{-\\Omega(\\beta t)}</span>. But, by the “upper-bound on adversarial blocks” lemma (Lemma 6.8), for every constant <span class="math">\\omega^{\\prime}</span>, except with probability <span class="math">e^{-\\Omega(\\beta t)}</span>,</p>

    <p class="text-gray-300">the adversary can only have mined <span class="math">(1+\\omega^{\\prime})(1+\\omega)(t+1)\\beta</span> blocks between round <span class="math">s</span> and round <span class="math">r^{\\prime}&lt;s+(t+1)</span>; under the conditions of the theorem, it thus follows that the adversary could have mined at most</p>

    <p class="text-gray-300"><span class="math">\\frac{(1+\\omega^{\\prime})(1+\\omega)}{(1+\\delta)}\\cdot(1-2\\alpha(\\Delta+1))\\alpha(t+1)</span></p>

    <p class="text-gray-300">blocks. By picking a sufficiently small <span class="math">\\delta^{\\prime\\prime\\prime},\\omega,\\omega^{\\prime}</span>, we have that <span class="math">T_{\\delta^{\\prime\\prime\\prime}}</span> is greater than this quantity, and it follows that the chains diverge at <span class="math">s</span> only with probability <span class="math">e^{-\\Omega(\\beta t)}</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Armed with these lemmas, we now prove the following theorem (which proves consistency for the protocol in the <span class="math">\\mathcal{F}_{tree}</span>-hybrid model), which combined with Lemma 5.1, yields Theorem 4.3.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Theorem 6.13.</h6>

    <p class="text-gray-300">For any <span class="math">\\lambda&gt;1</span>, any <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi_{tree}^{p},\\mathcal{C}_{tree}^{p})</span> satisfies (errorless) consistency in <span class="math">\\Gamma_{\\lambda}^{p}</span> environments.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider some view view in the execution REAL, let <span class="math">i,j</span> be players such that, in view, <span class="math">i</span> is honest at round <span class="math">r</span> and <span class="math">j</span> is honest at round <span class="math">r^{\\prime}&gt;r</span>; let <span class="math">C_{1}=\\mathcal{C}_{i}^{r}(\\textsf{view})</span> and <span class="math">C_{2}=\\mathcal{C}_{j}^{r^{\\prime}}(\\textsf{view})</span>.</p>

    <p class="text-gray-300">For every constant <span class="math">0&lt;\\delta&lt;1</span>, by Lemma 6.11 the probability that <span class="math">C_{1}</span> and <span class="math">C_{2}</span> diverge at <span class="math">s=r-\\frac{T}{\\gamma(1+\\delta)}</span> is at most <span class="math">e^{-\\Omega(T\\frac{\\beta}{\\gamma})}=e^{-\\Omega(T\\frac{1}{\\rho})}=e^{-\\Omega(T)}</span>. By Lemma 6.7, except with probability <span class="math">e^{-\\Omega(T)}</span>, the number of blocks mined between rounds <span class="math">s</span> and <span class="math">r</span> is smaller than <span class="math">(1+\\delta)\\cdot\\gamma\\cdot\\frac{T}{\\gamma(1+\\delta)}=T</span>. Thus, by a union bound we have that except with probability <span class="math">e^{-\\Omega(T)}</span>, <span class="math">C_{1}</span> and <span class="math">C_{2}</span> are identical except for potentially the last <span class="math">T</span> blocks. ∎</p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">6.4 Proof of the Upperbound on Chain Growth Property (Theorem 4.4)</h3>

    <p class="text-gray-300">We finally prove the following theorem (which proves the upperbound on chain growth for the protocol in the <span class="math">\\mathcal{F}_{tree}</span>-hybrid model), which combined with Lemma 5.1, yields Theorem 4.4.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Theorem 6.14.</h6>

    <p class="text-gray-300">For any <span class="math">\\delta&gt;0</span>, any <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi_{tree}^{p},\\mathcal{C}_{tree}^{p})</span> has (errorless) upperbound on chain growth rate</p>

    <p class="text-gray-300"><span class="math">\\hat{g}_{\\delta}^{p}(\\kappa,n,\\rho,\\Delta)=(1+\\delta)np</span></p>

    <p class="text-gray-300">in <span class="math">\\Gamma_{\\lambda}^{p}</span> environments.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider some view view and some <span class="math">T</span>; let <span class="math">t=\\frac{T}{\\hat{g}(n(\\kappa),\\rho,\\Delta(\\kappa))}</span>. By Lemma 6.7, we have that for any <span class="math">\\delta^{\\prime}&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[Q_{t}(\\textsf{REAL})&gt;\\left(1+\\delta^{\\prime}\\right)np\\cdot t\\right]&lt;e^{-\\Omega\\left(\\delta^{2}npt\\right)}=\\textsf{neg}(T)</span></p>

    <p class="text-gray-300">where <span class="math">Q_{t}(\\textsf{view})</span> is the maximum number of blocks mined in any window of <span class="math">t</span> rounds in view.</p>

    <p class="text-gray-300">By Claim 6.12 and Lemma 6.10, for every constant <span class="math">0&lt;\\omega&lt;1</span>, except with probability <span class="math">\\textsf{neg}(\\beta t)=\\textsf{neg}(\\rho np)=\\textsf{neg}(T)</span>, at most <span class="math">\\omega t</span> extra block may be accepted by some honest player in such a window. Thus, except with probability <span class="math">\\textsf{neg}(T)</span>, the chain can grow by at most <span class="math">((1+\\delta^{\\prime})np+\\omega)\\cdot t</span> in any window; for every <span class="math">\\delta</span>, by appropriately setting <span class="math">\\delta^{\\prime}</span>, this quantity can be made smaller than <span class="math">(1+\\delta)np\\cdot t</span>, which proves the theorem. ∎</p>

    <h2 id="sec-84" class="text-2xl font-bold">7 Application: Public Ledger</h2>

    <p class="text-gray-300">In this section, we demonstrate how to use <em>any</em> blockchain satisfying the growth, quality, and consistency properties defined in §3 to construct a secure <em>public ledger</em> system. Garay et al. <em>[x13]</em> show a similar theorem, in the synchronous setting, for the <em>specific</em> blockchain of Nakamoto.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Informally, a public ledger serves as an immutable “bulletin board” to which anyone can post a message, and everyone can read all messages posted. As described by Garay et al. [GKL15], such a bulletin board ought to satisfy two properties, liveness and persistence:¹⁶</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Liveness: The liveness property stipulates that from any given round <span class="math">r</span>, if a sufficiently long period of time <span class="math">t</span> elapses—we refer to this time as the wait-time of the ledger—every honest player will output a message <span class="math">\\mathfrak{m}</span> as part of their (local) ledger, where <span class="math">\\mathfrak{m}</span> was provided as an input to some honest player between rounds <span class="math">r</span> and <span class="math">r + t</span>. (In particular, this implies the liveness condition of [GKL15] which requires that if the same message was provided to all honest players between rounds <span class="math">r</span> and <span class="math">r + t</span>, this messages will be output in the ledger.)</li>

      <li>Persistence: The persistence property stipulates that if some honest player <span class="math">i</span> outputs a message <span class="math">\\mathfrak{m}</span> at position <span class="math">i</span> in its local ledger, then 1) <span class="math">\\mathfrak{m}</span> is the only message that can ever be output at position <span class="math">i</span> of any other honest player’s ledger and 2) every honest player will eventually output <span class="math">\\mathfrak{m}</span> at position <span class="math">i</span>.</li>

    </ul>

    <p class="text-gray-300">Let us turn to a formal definition.</p>

    <h2 id="sec-85" class="text-2xl font-bold">7.1 Definition of a Public Ledger</h2>

    <p class="text-gray-300">Just like the blockchain protocol, a public ledger is pair of algorithms <span class="math">(\\Pi, \\mathcal{L})</span> where <span class="math">\\Pi</span> is a stateful algorithm that maintains a local state state. The algorithm <span class="math">\\mathcal{L}(\\kappa, \\text{state})</span> outputs ordered sequence of messages <span class="math">\\vec{\\mathfrak{m}}</span>. We call <span class="math">\\mathcal{L}(\\kappa, \\text{state})</span> the (local) ledger of a player with security parameter <span class="math">\\kappa</span> and local variable state. We define the execution of a public ledger protocol in exactly the same way as the execution of a blockchain protocol (see Section 2.1), and define the random variable <span class="math">\\mathsf{EXEC}^{(\\Pi, \\mathcal{L})}(A, Z, \\kappa)</span> in exactly the same way. Let <span class="math">\\mathcal{L}_i(\\text{view})</span> denote the ledger of player <span class="math">i</span> in the view view and let <span class="math">\\mathcal{L}_i^r(\\text{view}) = \\mathcal{L}_i(\\text{view}^r)</span>.</p>

    <p class="text-gray-300"><strong>Liveness</strong> Let <span class="math">\\text{live}(\\text{view}, t) = 1</span> iff for any <span class="math">t</span> consecutive rounds <span class="math">r, \\ldots, r + t</span> in view there exists some round <span class="math">r&#x27; \\in [r, r + t]</span> and players <span class="math">i</span> such that in view, 1) <span class="math">i</span> is honest at <span class="math">r&#x27;</span>, 2) <span class="math">i</span> received a message <span class="math">\\mathfrak{m}</span> as input at round <span class="math">r&#x27;</span>, and 3) for every player <span class="math">j</span> that is honest at <span class="math">r + t</span> in view, <span class="math">\\mathfrak{m} \\in \\mathcal{L}_j^{r + t}(\\text{view})</span>.</p>

    <p class="text-gray-300"><strong>Definition 7.1 (Liveness).</strong> We say that public ledger <span class="math">(\\Pi, \\mathcal{L})</span> is live with wait-time <span class="math">w(\\cdot, \\cdot, \\cdot, \\cdot)</span> in <span class="math">\\Gamma</span> environments if for all <span class="math">\\Gamma</span>-admissible <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span>, there exists a negligible function <span class="math">\\epsilon</span> in the security parameter <span class="math">\\kappa \\in \\mathbb{N}</span>, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow \\text{EXEC}^{(\\Pi, \\mathcal{L})}(A, Z, \\kappa): \\text{live}(\\text{view}, w(\\kappa, n(\\kappa), \\rho, \\Delta(\\kappa)) = 1 \\right] \\geq 1 - \\epsilon(\\kappa)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Persistence</strong> Let <span class="math">\\text{persist}_{\\Delta}(\\text{view}) = 1</span> iff for every round $r \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\Delta<span class="math">, every player </span>i<span class="math"> that is honest at </span>\\text{view}^r<span class="math"> and every position </span>\\text{pos} \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}_i^r(\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, if </span>\\mathcal{L}_i^r(\\text{view})<span class="math"> contains the message </span>\\mathfrak{m}<span class="math"> at position </span>\\text{pos}<span class="math">, then for every round </span>r'<span class="math"> such that </span>r + \\Delta \\leq r'<span class="math"> and every honest player </span>j<span class="math"> (possibly the same as </span>i<span class="math">) we have that </span>\\mathfrak{m}<span class="math"> is also at position </span>\\text{pos}<span class="math"> in </span>\\mathcal{L}_j^{r'}(\\text{view})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 7.2 (Persistence).</strong> We say that <span class="math">(\\Pi, \\mathcal{L})</span> is persistent in <span class="math">\\Gamma</span> environments if for all <span class="math">\\Gamma</span>-admissible <span class="math">(n(\\cdot), \\rho, \\Delta(\\cdot), A, Z)</span>, there exists a negligible function <span class="math">\\epsilon</span> such that for every security parameter <span class="math">\\kappa \\in \\mathbb{N}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow \\text{EXEC}^{(\\Pi, \\mathcal{L})}(A, Z, \\kappa): \\text{persist}_{\\Delta(\\kappa)}(\\text{view}) = 1 \\right] \\geq 1 - \\epsilon(\\kappa)</span></div>

    <p class="text-gray-300">¹⁶ The notion of Garay et al. [GKL15] is actually somewhat different and weaker: for instance, 1) they only require these properties to hold for records that are sufficiently “deep” in the ledger (we feel it is more natural/simpler to require it for all records in the ledger), and 2) they only require the liveness property to hold if all players received the same message.</p>

    <p class="text-gray-300">7.2 Constructing a Public Ledger from a Blockchain</p>

    <p class="text-gray-300">We turn to constructing a public ledger from any blockchain protocol. Let <span class="math">\\mathsf{TRUE}</span> be the predicate that always outputs 1 (on any input).</p>

    <p class="text-gray-300">Definition 7.3. Given a blockchain protocol <span class="math">(\\Pi, \\mathcal{C})</span>, we call <span class="math">(\\Pi&#x27;, \\mathcal{L})</span> the public ledger <span class="math">T(\\kappa)</span>-induced by <span class="math">(\\Pi, \\mathcal{C})</span>, where <span class="math">\\Pi&#x27; = \\Pi^{\\text{TRUE}}</span> and <span class="math">\\mathcal{L}(\\kappa, \\text{state})</span> computes <span class="math">\\mathcal{C}(\\kappa, \\text{state})</span>, truncates the last <span class="math">T(\\kappa)</span> records of it, and outputs the results.</p>

    <p class="text-gray-300">Theorem 7.4. Let <span class="math">T(\\cdot)</span> be a strictly positive, super-constant, polynomial, <span class="math">(\\Pi, \\mathcal{C})</span> a blockchain protocol satisfying chain growth <span class="math">g</span>, chain quality <span class="math">\\mu</span> and chain consistency in <span class="math">\\Gamma</span>-environments, where <span class="math">\\mu</span> and <span class="math">g</span> are strictly positive. Then, for every <span class="math">\\delta &amp;gt; 0</span>, the public ledger <span class="math">(\\Pi&#x27;, \\mathcal{L})</span> <span class="math">T(\\cdot)</span>-induced by <span class="math">(\\Pi, \\mathcal{C})</span> is persistent and live with wait-time <span class="math">w(\\kappa, n, \\rho, \\Delta) = (1 + \\delta)\\frac{T(\\kappa)}{g(\\kappa, n, \\rho, \\Delta)}</span> in <span class="math">\\Gamma</span>-environments.<span class="math">^{17}</span></p>

    <p class="text-gray-300">Proof. Consider <span class="math">\\Gamma</span>-admissible <span class="math">n(\\cdot), \\rho, \\Delta(\\cdot), A, Z</span>, some <span class="math">\\delta &amp;gt; 0</span>, some <span class="math">\\kappa</span>, and some view <span class="math">\\text{view} \\leftarrow \\text{EXEC}^{(\\Pi, \\mathcal{L})}(A, Z, \\kappa)</span>. Let <span class="math">n = n(\\kappa), \\Delta = \\Delta(\\kappa), g = g(\\kappa, n, \\rho, \\Delta)</span> and <span class="math">\\mu = \\mu(\\kappa, n, \\rho, \\Delta)</span>, <span class="math">T = T(\\kappa)</span>. We now separately show liveness and persistence.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Liveness Let <span class="math">T&#x27; = (1 + \\delta)T</span> and let <span class="math">t = \\frac{T&#x27;}{g}</span>. Pick <span class="math">\\delta&#x27;</span> such that <span class="math">0 &amp;lt; \\delta&#x27; &amp;lt; \\delta</span>. Condition on the events that <span class="math">\\text{growth}^t(\\text{view}, \\Delta(\\kappa), T&#x27;) = 1</span>, <span class="math">\\text{consistent}^{\\delta&#x27;T - 1}(\\text{view}) = 1</span>, and <span class="math">\\text{quality}^{T&#x27; - T}(\\text{view}) = 1</span>; by our assumptions and the union bound, these events occur with probability <span class="math">1 - \\text{neg}(T)</span>; since <span class="math">T</span> is polynomial in <span class="math">\\kappa</span>, these events occur except with probability <span class="math">\\text{neg}(\\kappa)</span>. Let <span class="math">j, j&#x27;</span> be players such that in <span class="math">\\text{view}</span>, <span class="math">j&#x27;</span> is honest at <span class="math">r</span> and <span class="math">j</span> is honest at <span class="math">r + t</span> such that $r + t \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the conditioning, we have that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- By chain growth, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_j^{r + t}(\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{j'}^r (\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq T + \\delta T<span class="math">; thus </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_j^{r + t}(\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq T + \\delta T$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By "truncation", at least <span class="math">\\delta T</span> records that were not part of the chain of <span class="math">j&#x27;</span> at <span class="math">r</span> are thus output as part of <span class="math">j</span>'s ledger.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- By consistency, before round <span class="math">r</span>, no honest player has ever had a chain whose length exceeds $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{j'}^r (\\mathrm{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\delta' T - 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Persistence Let <span class="math">t = \\frac{T}{g}</span>. Condition on the events that <span class="math">\\text{growth}^t(\\text{view}, \\Delta(\\kappa), T) = 1</span> and <span class="math">\\text{consistent}^T(\\text{view}) = 1</span>; by our assumptions and the union bound, these events occur with probability <span class="math">1 - \\text{neg}(T)</span>; since <span class="math">T</span> is polynomial in <span class="math">\\kappa</span>, these events occur except with probability <span class="math">\\text{neg}(\\kappa)</span>.</p>

    <p class="text-gray-300">Consider players <span class="math">i, j</span> such that in view, <span class="math">i</span> is honest at round <span class="math">r</span>, and <span class="math">j</span> is honest at round <span class="math">r&#x27;</span> such that <span class="math">r&#x27; \\geq r + \\Delta</span>. By the conditioning, we have that:</p>

    <p class="text-gray-300"><span class="math">^{17}</span>We are grateful to Elaine Shi for pointing out that a variant of our proof for the liveness property works with a sharper wait-time bound. Our original theorem and proof (which set parameters in a non-optimal way) only claimed <span class="math">w(\\kappa, n, \\rho, \\Delta) = \\frac{(1 + \\delta)T(\\kappa)}{\\mu(\\kappa, n, \\rho, \\Delta) \\cdot g(\\kappa, n, \\rho, \\Delta)}</span>. The reason we do not need a dependency on <span class="math">\\mu</span> is that by our definition of chain quality, it suffices for the fraction of non-adversarial blocks to be positive (as opposed to greater than <span class="math">\\frac{1}{T}</span>) to conclude the existence of at least one non-adversarial block.</p>

    <p class="text-gray-300">33</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Because <span class="math">\\text{consistent}^{T}(\\text{view})=1</span>, prefixes of <span class="math">\\mathcal{C}_{i}^{r}(\\text{view})</span> and <span class="math">\\mathcal{C}_{j}^{r^{\\prime}}(\\text{view})</span> consisting of the first $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}^{r}(\\text{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-T$ records are identical.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the above two statements, and the fact that <span class="math">\\mathcal{L}</span> simply truncates the last <span class="math">T</span> records of the chain, it follows that <span class="math">\\mathcal{L}_{i}^{r}(\\text{view})</span> is a <em>prefix</em> of <span class="math">\\mathcal{L}_{j}^{r^{\\prime}}(\\text{view})</span>. Therefore, if <span class="math">\\mathcal{L}_{i}^{r}(\\text{view})</span> contains a message <span class="math">\\mathsf{m}</span> at position <span class="math">p</span>, then so does <span class="math">\\mathcal{L}_{j}^{r^{\\prime}}(\\text{view})</span>. Because this holds for all such <span class="math">r,r^{\\prime}&gt;r+\\Delta,i,j</span>, it follows that <span class="math">\\text{persist}_{\\Delta(\\kappa)}(\\text{view})=1</span>. ∎</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Corollary 7.5.</h6>

    <p class="text-gray-300">For any <span class="math">\\lambda&gt;1</span>, any <span class="math">\\delta&gt;0</span>, any <span class="math">p(\\cdot)</span>, and any strictly positive, super-constant, polynomial <span class="math">T(\\cdot)</span>, the public ledger <span class="math">(\\Pi_{\\mathsf{Nak}},\\mathcal{L}_{\\mathsf{Nak}})</span> that is <span class="math">T(\\cdot)</span>-induced by the blockchain protocol <span class="math">(\\Pi_{\\mathsf{Nak}}^{p},\\mathcal{C}_{\\mathsf{Nak}}^{p})</span> is persistent and live with wait-time</p>

    <p class="text-gray-300"><span class="math">w(n,\\kappa,\\rho,\\Delta)=(1+\\delta)\\,\\frac{T(\\kappa)}{\\gamma}</span></p>

    <p class="text-gray-300">in <span class="math">\\Gamma_{\\lambda}^{p}</span> environments.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">From Thm. 4.1, Thm 4.2 and Thm. 4.3, for every <span class="math">\\delta^{\\prime},\\delta^{\\prime\\prime}</span>, <span class="math">(\\Pi_{\\mathsf{Nak}}^{p},\\mathcal{C}_{\\mathsf{Nak}}^{p})</span> has growth <span class="math">(1-\\delta^{\\prime})\\gamma</span>, chain quality <span class="math">1-(1+\\delta^{\\prime\\prime})\\frac{\\beta}{\\gamma}</span>, and satisfies consistency. By Claim 6.12 (item 1), the chain quality is thus strictly positive. From Thm. 7.4, for every <span class="math">\\delta^{\\prime\\prime}</span>, <span class="math">(\\Pi_{\\mathsf{Nak}},\\mathcal{L}_{\\mathsf{Nak}})</span> thus has rate</p>

    <p class="text-gray-300"><span class="math">w(n,\\kappa,\\rho,\\Delta)=(1+\\delta^{\\prime\\prime\\prime})\\frac{T(\\kappa)}{(1-\\delta^{\\prime})\\gamma}&lt;(1+\\delta)\\,\\frac{T(\\kappa)}{\\gamma}</span></p>

    <p class="text-gray-300">where the last inequality follows by picking sufficiently small <span class="math">\\delta^{\\prime},\\delta^{\\prime\\prime\\prime}</span>. ∎</p>

    <h2 id="sec-88" class="text-2xl font-bold">8 An Attack on Nakamoto with “Long” Delays</h2>

    <p class="text-gray-300">In this section, we formally demonstrate that Nakamoto’s protocol satisfies neither consistency nor positive chain quality, in a fully asynchronous network without an upperbound <span class="math">\\Delta</span> on the network delay, even if the adversary controls just a tiny fraction of computational power. More specifically, we show that for every hardness parameter <span class="math">p</span>, <span class="math">\\Pi_{Nak}^{p},\\mathcal{C}_{Nak}^{p}</span>, satisfies neither consistency nor chain quality when <span class="math">\\Delta=\\frac{1+\\delta}{\\rho np}</span> for some <span class="math">\\delta&gt;0</span>. This demonstrates why our consistency theorem needs to rely on the assumption that <span class="math">p\\leq\\frac{\\Theta(1)}{\\Delta n}</span>, and why the chain quality we get is <span class="math">1-\\frac{\\beta}{\\gamma}</span> as opposed to just <span class="math">1-\\frac{\\beta}{\\alpha}</span> (recall that <span class="math">\\gamma=\\frac{\\alpha}{1+\\Delta\\alpha}</span> is a discounted version of <span class="math">\\alpha</span> that takes delays into account.) In particular, we present a “51%” attack a la Nakamoto—where the attacker at some point in the future replace the <em>whole chain</em> with a chain of its choice, even if it only controls a small fraction of the computational power.</p>

    <p class="text-gray-300">Intuitively, in every segment of <span class="math">\\Delta</span> rounds, if we delay all messages between honest players until the end of the segment, honest players are effectively “mining on their own” and thus are unlikely to extend their chain by more than 1. The adversary, on the other hand, may coordinate its mining and thus in expectation extends its chain by <span class="math">\\Delta\\cdot\\rho np</span>; so if we set <span class="math">\\Delta&gt;\\rho np</span> the adversary can mine its own chain (without sending it to the honest player) and is likely to have a longer (private) chain.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Theorem 8.1 (Inconsistency of Nakamoto with Unbounded Delays).</h6>

    <p class="text-gray-300">Let <span class="math">\\widehat{\\Gamma}_{\\rho^{\\prime},\\delta}^{p}(\\kappa,n,\\rho,\\Delta)=1</span> iff 1) <span class="math">n=\\frac{2}{\\rho^{2}}\\cdot\\kappa</span>, 2) <span class="math">\\rho=\\rho^{\\prime}</span> and 3) <span class="math">\\Delta=\\frac{1+\\delta}{\\rho np}</span>. For every <span class="math">0&lt;\\delta&lt;\\frac{1}{2},0&lt;\\rho^{\\prime}&lt;1</span>, and every inverse polynomial <span class="math">p(\\cdot)</span>, <span class="math">(\\Pi_{Nak}^{p},\\mathcal{C}_{Nak}^{p})</span> does not satisfy neither consistency nor chain quality <span class="math">q</span> in <span class="math">\\widehat{\\Gamma}_{\\rho^{\\prime},\\delta}^{p}</span>-valid environments, where <span class="math">q&gt;0</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an environment <span class="math">Z</span> that invokes <span class="math">n=\\frac{2}{\\rho^{2}}\\cdot\\kappa</span> players, a fraction <span class="math">\\rho</span> of them being adversarial, and sends messages <span class="math">m_{1},m_{2}\\ldots</span> to the honest players; for simplicity, assume <span class="math">m_{i}=0</span> for all <span class="math">i</span>. The environment runs for <span class="math">\\kappa\\Delta+1</span> steps.</p>

    <p class="text-gray-300">The attacker <span class="math">A</span> proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A</span> divides the rounds into <span class="math">\\kappa</span> segments of <span class="math">\\Delta</span> rounds and delays all messages sent by honest players within such a segment to the end of it (note that this means no messages are delayed more than <span class="math">\\Delta</span>);</li>

      <li><span class="math">A</span> ignores the content of the messages sent by honest players and tries to independently build its own chain <span class="math">\\hat{C}</span> with messages <span class="math">m^{\\prime}_{1},m^{\\prime}_{2},\\ldots</span> such that <span class="math">m_{i}\\neq m^{\\prime}_{i}</span> for <span class="math">\\kappa\\Delta</span> rounds (for simplicity, assume <span class="math">m^{\\prime}_{i}=1</span> for all <span class="math">i</span>);</li>

      <li>In the next to last round <span class="math">r=\\kappa\\Delta</span>, it sends <span class="math">\\hat{C}</span> to any (strict) subset of the honest players (and delivers it instantly).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that in any view <span class="math">\\mathsf{view}\\in\\mathsf{EXEC}^{(\\Pi^{V},\\mathcal{C})}(A,Z,\\kappa)</span> where 1) $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\kappa<span class="math"> and 2) </span>\\hat{C}<span class="math"> is longer than the longest chain known to the honest players, we have that </span>\\mathsf{consistent}^{\\kappa}(\\mathsf{view})=0<span class="math"> and </span>\\mathsf{quality}^{\\kappa}(\\mathsf{view},1)=0$. We show that the probability that both events happen is constant, which proves the theorem.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following two claims bound the probability that either event does not happen; by a union bound we can then conclude that the probability that both happen is constant.</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Claim 8.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\hat{C}(\\mathsf{view})</span> denote the length of the adversary’s chain in the next to last round (i.e., round <span class="math">\\kappa\\Delta</span>) of <span class="math">\\mathsf{view}</span>. Then,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{(\\Pi^{V},\\mathcal{C})}(A,Z,\\kappa):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{C}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><(1+\\frac{\\delta}{2})\\kappa]\\leq e^{-\\Omega(\\kappa)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-92" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In the <span class="math">\\kappa\\Delta</span> rounds, the adversary has <span class="math">\\rho np\\cdot\\kappa\\Delta</span> chances to mine a block; each chance succeeds with probability <span class="math">p</span>; since <span class="math">\\Delta=\\frac{(1+\\delta)}{\\rho np}</span>, the expected number of mined blocks is thus <span class="math">(1+\\delta)\\kappa</span>. The desired bound thus follows directly from the Chernoff bound. ∎</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Claim 8.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\ell(\\mathsf{view})</span> denote the length of the longest chain known to the honest players in the last round of <span class="math">\\mathsf{view}</span>. Then,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{(\\Pi^{V},\\mathcal{C})}(A,Z,\\kappa):\\ell(\\mathsf{view})\\geq\\kappa]\\leq\\frac{3}{4}.</span></p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In every fixed segment of <span class="math">\\Delta</span> rounds, the number of blocks mined by a <em>single</em> honest player is distributed as a binomial distribution with parameters <span class="math">\\Delta</span> (trials) and <span class="math">p</span> (success probability). Let <span class="math">X</span> be such a random variable. The probability that some <em>fixed</em> single honest player mines more than 1 block in any <em>fixed</em> segment is</p>

    <p class="text-gray-300"><span class="math">Pr[X&gt;1]</span> <span class="math">=1-Pr[X\\leq 1]</span> <span class="math">=1-Pr[X=0]-Pr[X=1]</span> <span class="math">=1-(1-p)^{\\Delta}-\\Delta p(1-p)^{\\Delta-1}</span> <span class="math">=1-(1-p)^{\\Delta-1}(1+(\\Delta-1)p)</span> <span class="math">\\leq 1-(1-(\\Delta-1)p)(1+(\\Delta-1)p)</span> <span class="math">=(\\Delta-1)^{2}p^{2}</span> <span class="math">\\leq\\frac{(1+\\delta)}{\\rho^{2}n^{2}}</span> <span class="math">\\leq\\frac{(1+\\delta)}{2n\\kappa}</span></p>

    <p class="text-gray-300">By a union bound over the number of players <span class="math">n</span> and the number of segments <span class="math">\\kappa</span>, we have that except with probability <span class="math">\\frac{1+\\delta}{2}\\leq\\frac{3}{4}</span>, no honest player mines more than one block in any segment, and whenever that happens, the length of the longest chain grows by at most <span class="math">1</span> for each segement and thus becomes of length at most <span class="math">\\kappa</span> after <span class="math">\\kappa</span> segments. ∎</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Remark 8.4.</h6>

    <p class="text-gray-300">We note that our proof applies even in the setting of static corruptions, and already to a weaker notion of consistency which ignores “future-self consistency”. In addition, the attacker never looks at the messages sent by honest players.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Remark 8.5.</h6>

    <p class="text-gray-300">We additionally point out that at the cost of complicating the proof (and increasing the number of players), we can obtain an even stronger attack—which works also when <span class="math">\\Delta&gt;\\frac{1}{c\\cdot np}</span> where <span class="math">\\frac{1}{c}&gt;\\frac{1}{\\rho}-\\frac{1}{1-\\rho}</span> (as opposed to just <span class="math">\\frac{1}{\\rho}</span> as in our previous proof)—as follows: instead or partitioning the rounds into segments, simply always delay messages between honest players by <span class="math">\\Delta</span>. Intuitively (but significantly oversimlifying), when we delay the messages between honest parties by <span class="math">\\Delta</span>, the expected time they need to wait until finding and propagating a block is roughly <span class="math">\\frac{1}{(1-\\rho)np}+\\Delta</span>, whereas the adversaries only needs to wait <span class="math">\\frac{1}{\\rho np}</span> in expectation; thus, the attacker succeeds whenever it mines faster (i.e., when <span class="math">\\frac{1}{\\rho}&lt;\\frac{1}{1-\\rho}+\\Delta np</span>), and since <span class="math">\\Delta np=\\frac{1}{c}</span>, the attack succeeds when <span class="math">\\frac{1}{c}&gt;\\frac{1}{\\rho}-\\frac{1}{1-\\rho}</span>.</p>

    <p class="text-gray-300">We turn to describe how to formalize this attack (following the proof of 8.3). We, in fact, show an attack that works as long as <span class="math">\\beta&gt;\\gamma</span> (i.e., the adversary mining rate is higher than the “discounted” honest player mining rate), and then use this to deduce that the attack applies when <span class="math">\\frac{1}{c}&gt;\\frac{1}{\\rho}-\\frac{1}{1-\\rho}</span>.</p>

    <p class="text-gray-300">It follows using exactly the same proof as the lowerbound on chain growth in the “hybrid” model (see Claim 6.4) that we can get <span class="math">(1+\\delta)\\gamma</span> as an upperbound on the chain growth of the honest players in a modified game where all honest players “freeze” for <span class="math">\\Delta</span> rounds whenever some honest player mines a block (just as in the “hybrid” model in Claim 6.4). Since successes in each round are independent, it follows that conditioned on no single player ever mining two blocks within <span class="math">\\Delta</span> rounds, the chain growth of honest players is upperbounded by <span class="math">(1+\\delta)\\gamma</span>, whereas the chain growth of the adversary is lowerbounded by <span class="math">(1-\\delta)\\beta</span>. Thus when <span class="math">\\beta&gt;(1+\\delta^{\\prime})\\gamma</span>, if we run the experiment for <span class="math">t</span> steps (and condition on no single player ever mining two blocks within <span class="math">\\Delta</span> rounds), we get an attack except with probability <span class="math">e^{-\\Omega(\\gamma t)}</span>. Since <span class="math">\\gamma</span> is monotonically increasing in <span class="math">\\alpha</span> and <span class="math">\\alpha\\leq(1-\\rho)np</span>, it follows that the above also holds when</p>

    <p class="text-gray-300"><span class="math">\\beta=\\rho np&gt;\\frac{(1-\\rho)np}{1+\\Delta(1-\\rho)np}</span></p>

    <p class="text-gray-300">and thus when</p>

    <p class="text-gray-300"><span class="math">\\Delta np&gt;\\frac{1}{\\rho}-\\frac{1}{1-\\rho}</span></p>

    <p class="text-gray-300">So if we set <span class="math">\\Delta=\\frac{1}{cnp}</span>, we get an attack (conditioned on no single player ever mining two blocks within <span class="math">\\Delta</span> rounds) when <span class="math">\\frac{1}{c}&gt;\\frac{1}{\\rho}-\\frac{1}{1-\\rho}</span>.</p>

    <p class="text-gray-300">Finally, as in the proof of Claim 8.3 we have that at any given round <span class="math">r</span>, for any fixed player <span class="math">j</span>, the probability of <span class="math">j</span> mining more that 1 block within the next <span class="math">\\Delta</span> rounds is upperbounded by <span class="math">(\\Delta-1)^{2}p^{2}\\leq\\frac{1}{c^{2}n^{2}}</span>. Thus, if we set <span class="math">n&gt;2t</span>, it follows that no player every mines more than 1 block within <span class="math">\\Delta</span> rounds, except with probability <span class="math">1/2</span> (by the union bound).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">9 Acknowledgements</p>

    <p class="text-gray-300">We are very grateful to Elaine Shi for many helpful comments on an earlier draft of this paper.</p>

    <h2 id="sec-97" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AJK05] J. Aspnes, C. Jackson, and A. Krishnamurthy. Exposing computationally-challenged byzantine impostors, 2005.</li>

      <li>[BCL^{+}05] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin. Secure computation without authentication. In CRYPTO’05, 2005.</li>

      <li>[BK14] Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to design fair protocols. In Advances in Cryptology–CRYPTO 2014, pages 421–439. Springer, 2014.</li>

      <li>[Blo16] Blockchain.info. Hash rate for blockchain. https://blockchain.info/charts/hash-rate, February 2016.</li>

      <li>[BTP] BTProof. https://www.btproof.com.</li>

      <li>[Can00] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067, 2000. http://eprint.iacr.org/2000/067.</li>

      <li>[CL99] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI’99, 1999.</li>

      <li>[CLLM12] Kai-Min Chung, Henry Lam, Zhenming Liu, and Michael Mitzenmacher. Chernoff-hoeffding bounds for markov chains: Generalized and simplified. In 29th International Symposium on Theoretical Aspects of Computer Science, STACS 2012, February 29th - March 3rd, 2012, Paris, France, pages 124–135, 2012.</li>

      <li>[CSWH00] I. Clarke, O. Sandberg, B. Wiley, and T.W. Hong. Freenet: A distributed anonymous information storage and retrieval system. In Proceedings of the ICSI Workshop on Design Issues in Anonymity and Unobservability, 2000.</li>

      <li>[DLN02] David Karger David Liben-Nowell, Hari Balakrishnan. Analysis of the evolution of peer-to-peer systems. In PODC’02, 2002.</li>

      <li>[DW13] Christian Decker and Roger Wattenhofer. Information propagation in the bitcoin network. In IEEE International Conference on Peer-to-Peer Computing, pages 1–10, 2013.</li>

      <li>[DR01] P. Druschel and A. Rowstron. Past: Persistent and anonymous storage in a peer-to-peer networking environment. In HotOS 2001, pages 65–70, 2001.</li>

      <li>[DLS88] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. Journal of the ACM (JACM), 35(2):288–323, 1988.</li>

      <li>[DN92] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In CRYPTO’92, pages 139–147, 1992.</li>

      <li>[ES14] Ittay Eyal and Emin Gün Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Financial Cryptography and Data Security, pages 436–454. Springer, 2014.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[FVY14] Conner Fromknecht, Dragos Velicanu, and Sophia Yakoubov. A decentralized public key infrastructure with identity retention. IACR Cryptology ePrint Archive, 2014:803, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GKL15] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology-EUROCRYPT 2015, pages 281–310. Springer, 2015.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or a completeness theorem for protocols with honest majority. In STOC, pages 218–229, 1987.</li>

      <li>[KP15] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols, 2015.</li>

      <li>[KMS^{+}15] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. Technical report, Cryptology ePrint Archive, Report 2015/675, 2015. http://eprint.iacr.org, 2015.</li>

      <li>[Lam10] Leslie Lamport. Byzantizing paxos by refinement, 2010.</li>

      <li>[Lam11] Leslie Lamport. Leaderless byzantine paxos. In DISC’11, 2011.</li>

      <li>[Lit] Litecoin. https://litecoin.org.</li>

      <li>[MA05] Jean-Philippe Martin and Lorenzo Alvisi. Fast byzantine consensus. In DSN’05, 2005.</li>

      <li>[ML14] A. Miller and J. J. LaViola. Anonymous byzantine consensus from moderately-hard puzzles: A model for bitcoin, 2014.</li>

      <li>[mtg10] mtgox. https://bitcointalk.org/index.php?topic=2227.msg29606#msg29606, 2010.</li>

      <li>[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.</li>

      <li>[Nam] Namecoin. https://www.namecoin.org.</li>

      <li>[Oku05a] M. Okun. Agreement among unacquainted byzantine generals. In DISC’05, pages 499–500, 2005.</li>

      <li>[Oku05b] M. Okun. Distributed computing among unacquainted processors in the presence of byzantine failures, 2005.</li>

      <li>[OB08] M. Okun and A. Barak. Efficient algorithms for anonymous byzantine agreement. Theor. Comp. Sys., 42:222–238, 2008.</li>

      <li>[PS15] Rafael Pass and Abhi Shelat. Micropayments for decentralized currencies. In CCS’15, 2015.</li>

      <li>[PS16a] Rafael Pass and Elaine Shi. Fruitchains: An (almost) optimally fair blockchain, 2016.</li>

      <li>[PS16b] Rafael Pass and Elaine Shi. Hybrid consensus, 2016.</li>

      <li>[PSL80] M. C. Pease, R. E. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27:228–234, 1980.</li>

    </ul>

    <p class="text-gray-300">[PD15] Joseph Poon and Thaddeus Dryja. The bitcoin lightning network: Scalable off-chain instant payments draft 0.5.9.1. https://lightning.network/lightning-network-paper.pdf, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RFH^{+}00] S. Ratanasamy, P. Francis, M. Handley, R. Karp, and S. Shenker. A scalable content-addressable network. In SIGCOMM’00, 2000.</li>

      <li>[SZ15] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security, pages 507–527. Springer, 2015.</li>

      <li>[SMK^{+}01] Ion Stoica, Robert Morris, David Karger, M. Frans Kaashoek, and Hari Balakrishnan. Chord: A scalable peer-to-peer lookup service for internet applications. In SIGCOMM’01, 2001.</li>

    </ul>

    <h2 id="sec-98" class="text-2xl font-bold">Appendix A Appendix</h2>

    <p class="text-gray-300">We recall the standard Chernoff bound.</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Lemma A.1 (Multiplicative Chernoff Bound).</h6>

    <p class="text-gray-300">Let <span class="math">X_{1},\\ldots X_{n}</span> be independent Boolean random variables, such that for all <span class="math">i</span>, <span class="math">\\Pr[X_{i}=1]=p</span>; let <span class="math">X</span> be the sum of these variables, and <span class="math">\\mu</span> be the expectation of the sum. Then for any <span class="math">\\delta\\in(0,1]</span>, we have</p>

    <p class="text-gray-300"><span class="math">Pr\\left[X&gt;\\left(1+\\delta\\right)\\mu\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\mu\\right)}</span> <span class="math">Pr\\left[X&lt;\\left(1-\\delta\\right)\\mu\\right]&lt;e^{-\\Omega\\left(\\delta^{2}\\mu\\right)}</span></p>

    <p class="text-gray-300">######</p>`;
---

<BaseLayout title="Analysis of the Blockchain Protocol in Asynchronous Networks (2016/454)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/454
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
