---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/925';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Wolverine: Fast, Scalable, and Communication-Efficient Zero-Knowledge Proofs for Boolean and Arithmetic Circuits';
const AUTHORS_HTML = 'Chenkai Weng, Kang Yang, Jonathan Katz, Xiao Wang';

const CONTENT = `    <p class="text-gray-300">Chenkai Weng Northwestern University ckweng@u.northwestern.edu Kang Yang State Key Laboratory of Cryptology yangk@sklc.org Jonathan Katz†* University of Maryland jkatz2@gmail.com Xiao Wang Northwestern University wangxiao@cs.northwestern.edu</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Efficient zero-knowledge (ZK) proofs for arbitrary boolean or arithmetic circuits have recently attracted much attention. Existing solutions suffer from either significant prover overhead (i.e., high memory usage) or relatively high communication complexity (at least <span class="math">\\kappa</span> bits per gate, for computational security parameter <span class="math">\\kappa</span>). In this paper, we propose a new protocol for constant-round interactive ZK proofs that simultaneously allows for an efficient prover with asymptotically optimal memory usage and significantly lower communication compared to protocols with similar memory efficiency. Specifically:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover in our ZK protocol has linear running time and, perhaps more importantly, memory usage linear in the memory needed to evaluate the circuit non-cryptographically. This allows our proof system to scale easily to very large circuits.</li>

      <li>For statistical security parameter <span class="math">\\rho=40</span>, our ZK protocol communicates roughly 9 bits/gate for boolean circuits and 2–4 field elements/gate for arithmetic circuits over large fields.</li>

    </ul>

    <p class="text-gray-300">Using 5 threads, 400 MB of memory, and a 200 Mbps network to evaluate a circuit with hundreds of billions of gates, our implementation (<span class="math">\\rho=40,\\kappa=128</span>) runs at a rate of 0.45 <span class="math">\\mu s</span>/gate in the boolean case, and 1.6 <span class="math">\\mu s</span>/gate for an arithmetic circuit over a 61-bit field.</p>

    <p class="text-gray-300">We also present an improved subfield Vector Oblivious Linear Evaluation (sVOLE) protocol with malicious security that is of independent interest.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero-knowledge (ZK) proofs (of knowledge) <em>[x10, x11]</em> are a fundamental cryptographic tool. They allow a prover <span class="math">\\mathcal{P}</span> to convince a verifier <span class="math">\\mathcal{V}</span>, who holds a circuit <span class="math">\\mathcal{C}</span>, that the prover knows a witness <span class="math">w</span> for which <span class="math">\\mathcal{C}(w)=1</span>, without leaking any extra information. While ZK proofs for arbitrary circuits are possible <em>[x10]</em>, until recently such proofs were inefficient as they relied on reductions to generic NP-complete problems. Over the past decade, however, several ZK proof systems have been developed that yield far more efficient protocols. These include <em>zero-knowledge succinct non-interactive arguments of knowledge</em> (zk-SNARKs) <em>[x12, x11, BCC^{+}13, BCTV14, BCC^{+}16, BBB^{+}18, WTS^{+}18, BCR^{+}19, x1]</em>, ZK proofs based on Interactive Oracle</p>

    <p class="text-gray-300">Proofs (IOPs) and techniques from the setting of verifiable outsourcing <em>[x13, XZZ+19, x1, x12]</em>, ZK proofs following the “MPC-in-the-head” approach <em>[x14, x15, CDG+17, x2, x16, x17]</em>, and a line of work constructing ZK proofs from garbled circuits (ZKGC) <em>[x18, x10, x12, x14]</em>. Each of these works offers different tradeoffs between underlying assumptions (both computational hardness assumptions as well as setup assumptions), round complexity (in particular, whether the proof requires interaction or can be made non-interactive), expressiveness (e.g., whether the scheme natively handles boolean or arithmetic circuits), and efficiency. With regard to efficiency, measures of interest include the prover complexity (including time complexity and memory requirements), the verifier complexity, and the communication as a function of the circuit size.</p>

    <p class="text-gray-300">One important factor is the memory overhead of ZK protocols. In particular, high memory requirements can impose a hard limit on the maximum circuit size that a protocol can support in practice. As shown in Table 1, prior ZK proof systems can be characterized roughly as either (1) having short proofs (e.g., sublinear in the circuit size, or even sublinear in the length of a witness) but significant memory overhead for the prover as in the case of zk-SNARKs, IOP-based schemes, and some schemes following the MPC-in-the-head paradigm, or (2) imposing low memory overhead for the prover but having high communication complexity, as in the case of ZKGC schemes.</p>

    <p class="text-gray-300">In this paper, we propose a new approach to ZK proofs that enables an extremely efficient prover in both running time and memory usage while having lower communication compared to the ZKGC approach that offers similar prover efficiency. As in the ZKGC approach, we obtain prover complexity—in terms of both time and memory usage—linear in the complexity required to evaluate the circuit non-cryptographically; this allows our ZK protocol to scale easily to very large circuits. At the same time, we achieve communication complexity that is more than an order of magnitude lower than what can be achieved using the ZKGC approach, while natively supporting boolean or arithmetic circuits. As compared to the other work in Table 1, the main drawback of our protocol—shared by the ZKGC approach—is that it requires interaction. Our protocol does, however, offer a non-interactive <em>online</em> phase following an interactive offline phase that can be executed by the parties before the circuit is known.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Outline of Our Solution</h3>

    <p class="text-gray-300">Our ZK protocol (named Wolverine) can be separated into two phases: an interactive offline phase that can be executed by the prover and verifier before both the circuit and the witness are known, and an online phase that can be made non-interactive in the random-oracle model. We view the online phase as our main conceptual contribution, though we offer efficiency improvements for the offline phase as well.</p>

    <p class="text-gray-300">Online phase. The online phase of our protocol can be viewed as adapting the core idea of the ZKGC approach by viewing a ZK proof as a special case of secure two-party computation (2PC) where one party has no input. We differ from the ZKGC approach in the underlying 2PC protocol we use as our starting point: rather than using garbled circuits, we instead rely on a “GMW-style” approach <em>[x11]</em> using authenticated multiplication triples <em>[x3, x19]</em> (whose values are known to the prover) generated during the offline phase. A drawback of GMW-style protocols in the context of generic 2PC is that they have round complexity linear in the depth of the circuit being evaluated. Crucially, in the ZK context, we can exploit the fact that only one party has input to obtain an online phase that runs in constant rounds (or can even be non-interactive in the random-oracle model).</p>

    <p class="text-gray-300">The prover and verifier run in linear time since they each make only one pass over the circuit. Moreover, they can evaluate the circuit “on-the-fly” (i.e., with memory overhead linear in what is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol Type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Spartan [Set20]zk-SNARK</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Virgo [ZXZS20]IOP-based</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ligero [AHIV17]MPC-in-the-head</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[HK20]ZKGC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Wolverine sVOLE-based</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Merkle tree (boolean circuit)</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">55 s</td>

            <td class="px-3 py-2 border-b border-gray-700">53 s</td>

            <td class="px-3 py-2 border-b border-gray-700">400 s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">11 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">11 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Overall time</td>

            <td class="px-3 py-2 border-b border-gray-700">55 s</td>

            <td class="px-3 py-2 border-b border-gray-700">53 s</td>

            <td class="px-3 py-2 border-b border-gray-700">400 s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">11 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Communication</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 100 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">253 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">182.2 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">12.4 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prover memory</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 7 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 1 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 5 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 400 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 400 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Matrix mult. (arithmetic circuit)</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">677 s</td>

            <td class="px-3 py-2 border-b border-gray-700">64 s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">320 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">< 0.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">320 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Overall time</td>

            <td class="px-3 py-2 border-b border-gray-700">677 s</td>

            <td class="px-3 py-2 border-b border-gray-700">64 s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">320 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Communication</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 100 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 200 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2 GB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prover memory</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 86 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 18 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 400 MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparing our ZK protocol with prior work. The first example proves knowledge of 256 leaves that hash to a public root of a Merkle tree based on SHA-256 (511 hash-function evaluations). The second example proves knowledge of two  <span class="math">512 \\times 512</span>  matrices over a 61-bit field whose product is a public matrix (roughly 134 million field multiplications). Performance of our protocol ( <span class="math">\\rho = 40</span> ,  <span class="math">\\kappa = 128</span> ) is measured by running the prover and verifier on two machines, each using 1 thread, connected via a 200 Mbps network, and is the total running time of both the offline and online phases. For ZKGC and Wolverine, the prover and verifier can execute the protocol in a pipelined fashion, which is why the overall time is the maximum of the prover and verifier times. Spartan uses a 256-bit field while Virgo and Wolverine use a 61-bit field. See Section 6 for details.</p>

    <p class="text-gray-300">needed to evaluate the circuit non-cryptographically), which allows our protocol to scale easily to very large circuits. Our approach is communication-efficient as well: for a circuit with  <span class="math">C</span>  multiplication gates over an arbitrary finite field  <span class="math">\\mathbb{F}_p</span> , the marginal communication complexity is only either  <span class="math">3\\rho / \\log C + 1</span>  elements per gate for small fields or 2-4 elements per gate for large fields.</p>

    <p class="text-gray-300">Instantiating the offline phase. During the offline phase we set up authenticated multiplication triples (over the relevant field  <span class="math">\\mathbb{F}_p</span> ) between the prover and verifier using subfield Vector Oblivious Linear Evaluation (sVOLE) [BCGI18, BCG+19b]. For boolean circuits (i.e.,  <span class="math">p = 2</span> ), we use the recent work by Yang et al. [YWL+20] to generate an initial pool of authenticated bits, and then use those authenticated bits to generate authenticated triples as in prior work [NO09]. For  <span class="math">p &amp;gt; 2</span> , we extend the protocol of Yang et al. to obtain an efficient sVOLE protocol for arbitrary fields (which we believe to be of independent interest). We defer further details to Section 4.</p>

    <p class="text-gray-300">We have implemented Wolverine for both boolean and arithmetic circuits. Running over a 200 Mbps network, Wolverine processes boolean circuits at the rate of 2,000,000 AND gates per second (XOR gates are free), and arithmetic circuits over a 61-bit large field at the rate of 600,000 multiplication gates per second (addition gates are free). In Table 1 we provide benchmarks comparing Wolverine to prior work for two examples: proving knowledge of the leaves that hash to a Merkle-tree root (naturally represented as a boolean circuit) and proving knowledge of the inputs to matrix multiplication over a large field (naturally represented as an arithmetic circuit). In the boolean setting, Wolverine uses  <span class="math">15 \\times</span>  less communication than ZKGC [HK20] along with lower running time; Wolverine outperforms all other work in terms of overall time and memory usage. In the arithmetic setting, Wolverine is  <span class="math">5 \\times</span>  slower than Virgo [ZXZS20] but needs only  <span class="math">3\\%</span>  of the memory. The advantage in memory usage would be even larger for larger circuits, and would enable Wolverine to scale to circuits larger than what can be feasibly handled by Virgo.</p>

    <p class="text-gray-300">Comparison to ZK proofs based on VOLE/OT. Boyle et al. [BCGI18, BCG+19b] also pro</p>

    <p class="text-gray-300">posed a framework for ZK proofs in which an offline phase is used to set up correlated randomness between the prover and verifier, and the subsequent online phase is non-interactive. With regard to the online phase, the primary advantages of their work are that the online phase can be non-interactive without the random-oracle model, and can be run any polynomial number of times following a single execution of the offline phase (that is, the offline phase is reusable). An advantage of our work is that it applies to circuits over arbitrary fields, whereas the work of Boyle et al. applies either to boolean circuits <em>[BCG^{+}19b]</em> or arithmetic circuits over large fields <em>[x10]</em>. More to the point, the focus of our work is concrete efficiency, which was not investigated by Boyle et al. For boolean circuits, the ZK protocol of Boyle et al. <em>[BCG^{+}19b]</em> based on oblivious transfer requires communicating over 100,000 bits per gate when <span class="math">\\rho=40</span>, which is four orders of magnitude larger than our protocol. For large fields, the VOLE-based ZK protocol of Boyle et al. <em>[x10]</em> requires communication of at least 16 elements per gate, whereas our protocol sends only 2–4 elements per gate. We also offer concrete efficiency improvements for the offline phase in the large-field case. In particular, our sVOLE protocol avoids the generic, maliciously secure two-party computation used by Boyle et al. <em>[x10]</em>.</p>

    <p class="text-gray-300">Comparison to zk-SNARKs. Our ZK protocol occupies a different portion of the solution space than (existing) zk-SNARKs. Existing zk-SNARKs impose concretely high memory requirements on the prover (cf. Table 1), even when the memory requirements are linear in the circuit size. (While there are zk-SNARKs in which the prover asymptotically uses sublinear memory <em>[x13]</em>, such schemes are currently <span class="math">\\approx 200\\times</span> slower than state-of-the-art zk-SNARKs that uses linear memory <em>[x26]</em>.) The prover memory in Wolverine is significantly lower, allowing Wolverine to scale to very large circuits. On the other hand, zk-SNARKs have many advantages: they are non-interactive and have lower communication. They also have better efficiency for the verifier, although their <em>overall</em> time (i.e., including the time for the prover to generate the proof) might be longer.</p>

    <p class="text-gray-300">In independent and concurrent work, Dittmer, Ishai, and Ostrovsky <em>[x12]</em> have also developed a ZK protocol based on VOLE. They focus on communication complexity rather than concrete performance; their protocol only considers the case of large fields, and has lower communication complexity than our protocol in that case. Subsequent to our work, Baum, Malozemoff, Rosen and Scholl <em>[x1]</em> have also proposed a different VOLE-based ZK protocol.</p>

    <p class="text-gray-300">Organization of the paper. After reviewing some preliminaries in Section 2, we describe the online phase of our ZK proof in Section 3. In Section 4 we describe the details of our sVOLE construction used in the offline phase of our ZK proof. We provide experimental results in Section 6.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We use <span class="math">\\kappa</span> and <span class="math">\\rho</span> to denote the computational and statistical security parameters, respectively. We let <span class="math">\\mathsf{negl}(\\cdot)</span> denote a negligible function, and use log to denote logarithms in base 2. We write <span class="math">x\\leftarrow S</span> to denote sampling <span class="math">x</span> uniformly from a set <span class="math">S</span>, and <span class="math">x\\leftarrow\\mathcal{D}</span> to denote sampling <span class="math">x</span> according to a distribution <span class="math">\\mathcal{D}</span>. We define <span class="math">[a,b)=\\{a,\\ldots,b-1\\}</span> and write <span class="math">[n]=\\{1,\\ldots,n\\}</span>. We use bold lower-case letters like <span class="math">\\bm{a}</span> for row vectors, and bold upper-case letters like <span class="math">\\mathbf{A}</span> for matrices. We let <span class="math">\\bm{a}[i]</span> denote the <span class="math">i</span>th component of <span class="math">\\bm{a}</span> (with <span class="math">\\bm{a}[0]</span> the first entry), and let <span class="math">\\bm{a}[i:j)</span> represent the subvector <span class="math">(\\bm{a}[i],\\ldots,\\bm{a}[j-1])</span>.</p>

    <p class="text-gray-300">A circuit <span class="math">\\mathcal{C}</span> over a field <span class="math">\\mathbb{F}_{p}</span> is defined by a set of input wires <span class="math">\\mathcal{I}_{\\mathsf{in}}</span> and output wires <span class="math">\\mathcal{I}_{\\mathsf{out}}</span>, along with a list of gates of the form <span class="math">(\\alpha,\\beta,\\gamma,T)</span>, where <span class="math">\\alpha,\\beta</span> are the indices of the input wires of the gate, <span class="math">\\gamma</span> is the index of the output wire of the gate, and <span class="math">T\\in\\{\\mathsf{Add},\\mathsf{Mult}\\}</span> is the type of the gate. If <span class="math">p=2</span>, then <span class="math">\\mathcal{C}</span> is a boolean circuit with <span class="math">\\mathsf{Add}=\\oplus</span> and <span class="math">\\mathsf{Mult}=\\wedge</span>. If <span class="math">p&gt;2</span> is prime, then <span class="math">\\mathcal{C}</span> is an arithmetic</p>

    <p class="text-gray-300">circuit where <span class="math">\\mathsf{Add}/\\mathsf{Mult}</span> correspond to addition/multiplication in <span class="math">\\mathbb{F}_p</span>. We let <span class="math">C</span> denote the number of <span class="math">\\mathsf{Mult}</span> gates in the circuit.</p>

    <p class="text-gray-300">When we work in an extension field <span class="math">\\mathbb{F}_{p^r}</span> of <span class="math">\\mathbb{F}_p</span>, we fix some monic, irreducible polynomial <span class="math">f(X)</span> of degree <span class="math">r</span> and so <span class="math">\\mathbb{F}_{p^r} \\cong \\mathbb{F}_p[X]/f(X)</span>. We let <span class="math">\\mathsf{X} \\in \\mathbb{F}_{p^r}</span> denote the element corresponding to <span class="math">X \\in \\mathbb{F}_p[X]/f(X)</span>; thus, every <span class="math">w \\in \\mathbb{F}_{p^r}</span> can be written uniquely as <span class="math">w = \\sum_{i=0}^{r-1} w_i \\cdot \\mathsf{X}^i</span> with <span class="math">w_i \\in \\mathbb{F}_p</span> for all <span class="math">i</span>, and we may view elements of <span class="math">\\mathbb{F}_{p^r}</span> equivalently as vectors in <span class="math">\\mathbb{F}_p^r</span>. When we write arithmetic expressions involving both elements of <span class="math">\\mathbb{F}_p</span> and elements of <span class="math">\\mathbb{F}_{p^r}</span>, it is understood that values in <span class="math">\\mathbb{F}_p</span> are viewed as lying in <span class="math">\\mathbb{F}_{p^r}</span> in the natural way. We let <span class="math">\\mathbb{F}^*</span> denote the nonzero elements of a field <span class="math">\\mathbb{F}</span>.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2.1 Information-Theoretic MACs and Batch Opening</h2>

    <p class="text-gray-300">We use information-theoretic message authentication codes (IT-MACs) [NNOB12, DPSZ12] to authenticate values in a finite field <span class="math">\\mathbb{F}_p</span> using an extension field <span class="math">\\mathbb{F}_{p^r} \\supseteq \\mathbb{F}_p</span>. In more detail, let <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span> be a global key, sampled uniformly, that is known only by one party <span class="math">\\mathsf{P_B}</span>. A value <span class="math">x \\in \\mathbb{F}_p</span> known by the other party <span class="math">\\mathsf{P_A}</span> can be authenticated by giving <span class="math">\\mathsf{P_B}</span> a uniform key <span class="math">\\mathsf{K}[x] \\in \\mathbb{F}_{p^r}</span> and giving <span class="math">\\mathsf{P_A}</span> the corresponding MAC tag</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{M}[x] = \\mathsf{K}[x] + \\Delta \\cdot x \\in \\mathbb{F}_{p^r}.</span></div>

    <p class="text-gray-300">We denote such an authenticated value by <span class="math">[x]</span>. Authenticated values are additively homomorphic, i.e., if <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> and <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> hold authenticated values <span class="math">[x], [x&#x27;]</span> then they can locally compute <span class="math">[x&#x27;&#x27;] = [x + x&#x27;]</span> by having <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> set <span class="math">x&#x27;&#x27; := x + x&#x27;</span> and <span class="math">\\mathsf{M}[x&#x27;&#x27;] := \\mathsf{M}[x] + \\mathsf{M}[x&#x27;]</span> and having <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> set <span class="math">\\mathsf{K}[x&#x27;&#x27;] := \\mathsf{K}[x] + \\mathsf{K}[x&#x27;]</span>. Similarly, for a public value <span class="math">b \\in \\mathbb{F}_p</span>, the parties can locally compute <span class="math">[y] = [x + b]</span> or <span class="math">[z] = [bx]</span>. We denote these operations by <span class="math">[x&#x27;&#x27;] = [x] + [x&#x27;]</span>, <span class="math">[y] = [x] + b</span>, and <span class="math">[z] = b \\cdot [x]</span>, respectively.</p>

    <p class="text-gray-300">We extend the above notation to vectors of authenticated values as well. In that case, <span class="math">[\\pmb{u}]</span> means that (for some <span class="math">n</span>) <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> holds <span class="math">\\pmb{u} \\in \\mathbb{F}_p^n</span> and <span class="math">\\pmb{w} \\in \\mathbb{F}_{p^r}^n</span>, while <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> holds <span class="math">\\pmb{v} \\in \\mathbb{F}_{p^r}^n</span> with <span class="math">\\pmb{w} = \\pmb{v} + \\Delta \\cdot \\pmb{u}</span>. An authenticated multiplication triple consists of authenticated values <span class="math">[x], [y], [z]</span> where <span class="math">z = x \\cdot y</span>.</p>

    <p class="text-gray-300"><strong>Batch opening of authenticated values.</strong> An authenticated value <span class="math">[x]</span> can be "opened" by having <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> send <span class="math">x \\in \\mathbb{F}_p</span> and <span class="math">\\mathsf{M}[x] \\in \\mathbb{F}_{p^r}</span> to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>, who then verifies that <span class="math">\\mathsf{M}[x] \\stackrel{?}{=} \\mathsf{K}[x] + \\Delta \\cdot x</span>. This has soundness error <span class="math">1/p^r</span>, and requires sending an additional <span class="math">r \\log p</span> bits (beyond <span class="math">x</span> itself). While this can be repeated in parallel when opening multiple authenticated values <span class="math">[x_1], \\ldots, [x_\\ell]</span>, communication can be reduced using batching [NNOB12, DPSZ12]. We describe two approaches in Appendix B. Hereafter, we write <span class="math">\\mathsf{Open}([\\pmb{x}])</span> to denote a generic batch opening of a vector of authenticated values. In addition, we write <span class="math">\\mathsf{CheckZero}([\\pmb{x}])</span> for the special case where all <span class="math">x_i</span> are supposed to be 0 and so need not be sent. We let <span class="math">\\varepsilon_{\\mathsf{open}}</span> denote the soundness error (which depends on the technique used); when using either of the techniques described above, <span class="math">\\varepsilon_{\\mathsf{open}}</span> is independent of the number <span class="math">\\ell</span> of authenticated values opened.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 Security Model and Functionalities</h2>

    <p class="text-gray-300">We use the universal composability (UC) framework [Can01] to prove security in the presence of a malicious, static adversary. We say that a protocol <span class="math">\\Pi</span> UC-realizes an ideal functionality <span class="math">\\mathcal{F}</span> if for any probabilistic polynomial time (PPT) adversary <span class="math">\\mathcal{A}</span>, there exists a PPT adversary (simulator) <span class="math">\\mathcal{S}</span> such that for any PPT environment <span class="math">\\mathcal{Z}</span> with arbitrary auxiliary input <span class="math">z</span>, the output distribution of <span class="math">\\mathcal{Z}</span> in the real-world execution where the parties interact with <span class="math">\\mathcal{A}</span> and execute <span class="math">\\Pi</span> is computationally indistinguishable from the output distribution of <span class="math">\\mathcal{Z}</span> in the ideal-world execution where the parties interact with <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{F}</span>.</p>

    <p class="text-gray-300">The protocol that we construct in this work UC-realizes the standard zero-knowledge functionality <span class="math">\\mathcal{F}_{\\mathsf{ZK}}</span>, reproduced in Figure 1 for completeness. (We omit session identifiers in all our ideal</p>

    <p class="text-gray-300">Upon receiving (prove,  <span class="math">\\mathcal{C}, w</span> ) from a prover  <span class="math">\\mathcal{P}</span>  and (verify,  <span class="math">\\mathcal{C}</span> ) from a verifier  <span class="math">\\mathcal{V}</span>  where the same (boolean or arithmetic) circuit  <span class="math">\\mathcal{C}</span>  is input by both parties, send true to  <span class="math">\\mathcal{V}</span>  if  <span class="math">\\mathcal{C}(w) = 1</span> ; otherwise, send false to  <span class="math">\\mathcal{V}</span> .</p>

    <p class="text-gray-300">Initialize: Upon receiving init from  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , sample  <span class="math">\\Delta \\gets \\mathbb{F}_{p^r}</span>  if  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is honest or receive  <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span>  from the adversary otherwise. Store global key  <span class="math">\\Delta</span>  and send  <span class="math">\\Delta</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , and ignore all subsequent init commands.</p>

    <p class="text-gray-300">Extend: This procedure can be run multiple times. Upon receiving (extend,  <span class="math">\\ell</span> ) from  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , do:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is honest, sample  <span class="math">\\mathsf{K}[\\pmb {x}]\\gets \\mathbb{F}_{p^r}^\\ell</span>  . Otherwise, receive  <span class="math">\\mathsf{K}[\\pmb {x}]\\in \\mathbb{F}_{p^r}^\\ell</span>  from the adversary.</li>

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  is honest, sample  <span class="math">\\pmb {x}\\gets \\mathbb{F}_p^\\ell</span>  and compute  <span class="math">\\mathsf{M}[\\pmb {x}]\\coloneqq \\mathsf{K}[\\pmb {x}] + \\Delta \\cdot \\pmb {x}\\in \\mathbb{F}_{p^r}^\\ell</span>  . Otherwise, receive  <span class="math">\\pmb {x}\\in \\mathbb{F}_p^\\ell</span>  and  <span class="math">\\mathsf{M}[\\pmb {x}]\\in \\mathbb{F}_{p^r}^\\ell</span>  from the adversary, and then recompute  <span class="math">\\mathsf{K}[\\pmb {x}]\\coloneqq \\mathsf{M}[\\pmb {x}] - \\Delta \\cdot \\pmb {x}\\in \\mathbb{F}_{p^r}^\\ell</span></li>

      <li>Send  <span class="math">(\\pmb{x},\\mathsf{M}[\\pmb{x}])</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{K}[\\pmb{x}]</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

    </ol>

    <p class="text-gray-300">Global-key query: If  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  is corrupted, receive (guess,  <span class="math">\\Delta^{\\prime}</span> ) from the adversary with  <span class="math">\\Delta^{\\prime} \\in \\mathbb{F}_{p^{r}}</span> . If  <span class="math">\\Delta^{\\prime} = \\Delta</span> , send success to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and ignore any subsequent global-key query. Otherwise, send abort to both parties and abort.</p>

    <p class="text-gray-300">functionalities for the sake of readability.) Our ZK protocol relies on the subfield Vector Oblivious Linear Evaluation (sVOLE) functionality (see Figure 2), which is the same as that by Boyle et al.  <span class="math">\\left[\\mathrm{BCG}^{+}19\\mathrm{a}\\right]</span> , except that the adversary is allowed to make a global-key query on  <span class="math">\\Delta</span>  and would incur aborting for an incorrect guess. After an initialization that is done once, this functionality allows two parties to repeatedly generate a vector of authenticated values known to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> . Other functionalities are given for reference in Appendix A.</p>

    <p class="text-gray-300">In Figure 3, we describe our zero-knowledge protocol  <span class="math">\\Pi_{\\mathsf{ZK}}</span> , which operates in the  <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span> -hybrid model. As noted in Section 1.1, our protocol can be viewed as following a "GMW-style" approach to secure two-party computation using authenticated multiplication triples [NNOB12, DPSZ12]. In the secure-computation setting, the evaluation of a multiplication gate requires two rounds of interaction, since the parties hold shares of the values on the input wires, but neither party knows those values. In the ZK setting, however, the prover  <span class="math">\\mathcal{P}</span>  knows the values on all wires; thus, evaluation of a multiplication gate can be done without any interaction at all.</p>

    <p class="text-gray-300">At a high level, our protocol consists of the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. The parties prepare authenticated values  <span class="math">\\{[\\lambda_i]\\}</span>  for the witness, and  <span class="math">\\{[s_i]\\}</span>  for each multiplication gate in the circuit. The parties also generate some number of authenticated multiplication triples  <span class="math">\\{([x_i], [y_i], [z_i])\\}</span> ; a malicious prover may cause some or all of these triples to be incorrect (i.e.,  <span class="math">z_i \\neq x_i \\cdot y_i</span> ).</li>

      <li>Circuit evaluation. Starting with the authenticated values  <span class="math">\\{[w_i]\\}</span>  at the input wires, the parties inductively compute authenticated values for all the wires in the circuit. For addition gates,</li>

    </ol>

    <p class="text-gray-300">Inputs and parameters: The prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  hold a circuit  <span class="math">\\mathcal{C}</span>  over a finite field  <span class="math">\\mathbb{F}_p</span>  with  <span class="math">C</span>  multiplication gates;  <span class="math">\\mathcal{P}</span>  holds a witness  <span class="math">w</span>  such that  <span class="math">\\mathcal{C}(w) = 1</span> . Fix parameters  <span class="math">B, c</span> , and  <span class="math">r</span> , and let  <span class="math">\\ell = C \\cdot B + c</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  (acting as  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> ) and  <span class="math">\\mathcal{V}</span>  (acting as  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> ) send init to  <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> , which returns a uniform  <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span>  to  <span class="math">\\mathcal{V}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  send (extend,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}_{\\mathrm{in}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3\\ell + C<span class="math"> ) to  </span>\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}<span class="math"> , which returns authenticated values  </span>\\{[\\lambda_i]\\}_{i \\in \\mathcal{I}_{\\mathrm{in}}}<span class="math"> ,  </span>\\{([x_i], [y_i], [r_i])\\}_{i \\in [\\ell]}<span class="math"> , and  </span>\\{[s_i]\\}_{i \\in [C]}<span class="math">  to the parties. (If  </span>\\mathcal{V}<span class="math">  receives abort from  </span>\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}$ , then it aborts.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\in [\\ell]</span> ,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">d_i := x_i \\cdot y_i - r_i \\in \\mathbb{F}_p</span>  to  <span class="math">\\mathcal{V}</span> , and then both parties compute  <span class="math">[z_i] := [r_i] + d_i</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\in \\mathcal{I}_{\\mathrm{in}}</span> ,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\Lambda_i := w_i - \\lambda_i \\in \\mathbb{F}_p</span>  to  <span class="math">\\mathcal{V}</span> , and then both parties compute  <span class="math">[w_i] := [\\lambda_i] + \\Lambda_i</span> .</li>

      <li>For each gate  <span class="math">(\\alpha, \\beta, \\gamma, T) \\in \\mathcal{C}</span> , in topological order:</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">T = \\mathsf{Add}</span> , then the two parties locally compute  <span class="math">[w_{\\gamma}] := [w_{\\alpha}] + [w_{\\beta}]</span> . (b) If  <span class="math">T = \\mathsf{Mult}</span>  and this is the  <span class="math">i</span> th multiplication gate,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">d := w_{\\alpha} \\cdot w_{\\beta} - s_i \\in \\mathbb{F}_p</span>  to  <span class="math">\\mathcal{V}</span> , and then both parties compute  <span class="math">[w_{\\gamma}] := [s_i] + d</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  samples a random permutation  <span class="math">\\pi</span>  on  <span class="math">\\{1, \\ldots, \\ell\\}</span>  and sends it to  <span class="math">\\mathcal{P}</span> . The two parties use  <span class="math">\\pi</span>  to permute the  <span class="math">\\{([x_i], [y_i], [z_i])\\}_{i \\in [\\ell]}</span>  obtained in step 3.</li>

      <li>For the  <span class="math">i</span> th multiplication gate  <span class="math">(\\alpha, \\beta, \\gamma, \\mathsf{Mult})</span> , where the parties obtained  <span class="math">([w_{\\alpha}], [w_{\\beta}], [w_{\\gamma}])</span>  in step 5, do the following for  <span class="math">j = 1, \\ldots, B</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Let  <span class="math">([x],[y],[z])</span>  be the  <span class="math">((i - 1)B + j)</span> th authenticated triple (after applying  <span class="math">\\pi</span>  in step 6). (b) The parties run  <span class="math">\\delta_{\\alpha} := \\mathsf{Open}([w_{\\alpha}] - [x])</span>  and  <span class="math">\\delta_{\\beta} := \\mathsf{Open}([w_{\\beta}] - [y])</span> . The parties then compute  <span class="math">[\\mu] := [z] - [w_{\\gamma}] + \\delta_{\\beta} \\cdot [x] + \\delta_{\\alpha} \\cdot [y] + \\delta_{\\alpha} \\cdot \\delta_{\\beta}</span> , and finally run CheckZero([ <span class="math">\\mu</span> ]).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each of the remaining  <span class="math">c</span>  authenticated triples, say  <span class="math">([x],[y],[z])</span> , the parties run  <span class="math">x := \\mathsf{Open}([x])</span>  and  <span class="math">y := \\mathsf{Open}([y])</span> . They also compute  <span class="math">[\\nu] := [z] - x \\cdot y</span>  and then run CheckZero([ <span class="math">\\nu</span> ]).</li>

      <li>For the single output wire  <span class="math">o \\in \\mathcal{I}_{\\mathrm{out}}</span>  with authenticated value  <span class="math">[w_o]</span> , the parties run CheckZero([ <span class="math">w_o</span> ] - 1).</li>

    </ol>

    <p class="text-gray-300">this is easy. For the  <span class="math">i</span> -th multiplication gate, the prover uses  <span class="math">[s_i]</span>  to enable the verifier to compute its component of the authenticated value for the output wire without revealing information about the values on the input wires. Specifically, given authenticated values  <span class="math">[w_{\\alpha}], [w_{\\beta}]</span>  on the input wires to the  <span class="math">i</span> th multiplication gate, the prover sends  <span class="math">w_{\\alpha} \\cdot w_{\\beta} - s_i</span>  to the verifier; the prover and verifier then compute</p>

    <div class="my-4 text-center"><span class="math-block">[ w _ {\\gamma} ] := [ s _ {i} ] + (w _ {\\alpha} \\cdot w _ {\\beta} - s _ {i})</span></div>

    <p class="text-gray-300">as the authenticated value of the output wire. All communication here is from the prover to the verifier, so the entire circuit can be evaluated using only one round of communication.</p>

    <p class="text-gray-300">Once the parties have an authenticated value  <span class="math">[w_o]</span>  for the output wire, the prover simply opens that value, and the verifier checks that it is equal to 1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifying correct behavior. So far, nothing prevents a malicious prover from cheating. To detect cheating, the verifier needs to check the behavior of the prover at each multiplication gate</li>

    </ol>

    <p class="text-gray-300">using the initial set of authenticated multiplication triples the parties generated. This can be done in various ways. In the protocol as described in Figure 3, which works for circuits over an arbitrary field, the verifier checks the behavior of the prover as follows (adapting <em>[ABF^{+}17]</em>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks a random subset of the authenticated triples to make sure they are correctly formed. For an authenticated multiplication triple <span class="math">([x],[y],[z])</span>, this can be done by having the prover run <span class="math">\\mathsf{Open}([x])</span> and <span class="math">\\mathsf{Open}([y])</span> followed by <span class="math">\\mathsf{CheckZero}([z]-x\\cdot y)</span>.</li>

      <li>The verifier then uses the remaining authenticated triples to check that each multiplication gate was computed correctly. For a multiplication gate with authenticated values <span class="math">[w_{\\alpha}],[w_{\\beta}]</span> on the input wires and <span class="math">[w_{\\gamma}]</span> on the output wire, the relation <span class="math">w_{\\gamma}=w_{\\alpha}w_{\\beta}</span> can be checked using an authenticated multiplication triple <span class="math">([x],[y],[z])</span> by having the prover run <span class="math">\\delta_{\\alpha}:=\\mathsf{Open}([w_{\\alpha}]-[x])</span> and <span class="math">\\delta_{\\beta}:=\\mathsf{Open}([w_{\\beta}]-[y])</span>, followed by</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{CheckZero}\\left([z]-[w_{\\gamma}]+\\delta_{\\beta}\\cdot[x]+\\delta_{\\alpha}\\cdot[y]+\\delta_{\\alpha}\\cdot\\delta_{\\beta}\\right).</span></p>

    <p class="text-gray-300">Each multiplication gate is checked in this way using <span class="math">B</span> authenticated multiplication triples.</p>

    <p class="text-gray-300">In Section 3.2, we describe other approaches for verifying correct behavior.</p>

    <p class="text-gray-300">Note that the checks for the openings of all the authenticated values (i.e., all the executions of <span class="math">\\mathsf{Open}</span> and <span class="math">\\mathsf{CheckZero}</span>) can be batched together at the end of the protocol.</p>

    <p class="text-gray-300">Non-interactive online phase. The ZK protocol described in Figure 3 can be implemented in constant rounds. If we use the Fiat-Shamir heuristic both for deriving the permutation <span class="math">\\pi</span> as well as for non-interactive opening of authenticated values, the online phase can be made non-interactive.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1 Proof of Security</h3>

    <p class="text-gray-300">Before giving the proof of security for <span class="math">\\Pi_{\\mathsf{ZK}}</span>, we analyze the procedure used to check correctness of the multiplication gates. Consider some multiplication gate with authenticated values <span class="math">[w_{\\alpha}]</span>, <span class="math">[w_{\\beta}]</span> on the input wires and <span class="math">[w_{\\gamma}]</span> on the output wire. If <span class="math">\\mathcal{P}</span> cheated, so <span class="math">w_{\\gamma}\\neq w_{\\alpha}\\cdot w_{\\beta}</span>, then this cheating will be detected in step 7 of the protocol unless all <span class="math">B</span> of the multiplication triples used to check that gate are incorrect. (We ignore for now the possibility that <span class="math">\\mathcal{P}</span> is able to successfully cheat when running <span class="math">\\mathsf{Open}/\\mathsf{CheckZero}</span>.) But if too many of the initial multiplication triples are incorrect, then there is a high probability that <span class="math">\\mathcal{P}</span> will be caught in step 8. We can analyze the overall probability with which a cheating <span class="math">\\mathcal{P}</span> can successfully evade detection by considering an abstract “balls-and-bins” game with an adversary <span class="math">\\mathcal{A}</span>, which is based on a similar game considered previously in the context of secure three-party computation <em>[ABF^{+}17]</em>. The game proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> prepares <span class="math">\\ell=CB+c</span> balls <span class="math">\\mathcal{B}_{1},\\ldots,\\mathcal{B}_{\\ell}</span>, each of which is either <span class="math">\\mathsf{good}</span> or <span class="math">\\mathsf{bad}</span>. <span class="math">\\mathcal{A}</span> also prepares <span class="math">C</span> bins, each of which is either <span class="math">\\mathsf{good}</span> or <span class="math">\\mathsf{bad}</span>. The balls <span class="math">\\{\\mathcal{B}_{i}\\}_{i\\in[\\ell]}</span> correspond to the triples <span class="math">\\{([x_{i}],[y_{i}],[z_{i}])\\}_{i\\in[\\ell]}</span> defined in step 3 of the protocol, and the bins correspond to the triples <span class="math">\\{([w_{\\alpha}],[w_{\\beta}],[w_{\\gamma}])\\}</span> defined for the multiplication gates during the circuit evaluation.</li>

      <li>Then, <span class="math">c</span> random balls are chosen. If any of the chosen balls is <span class="math">\\mathsf{bad}</span>, <span class="math">\\mathcal{A}</span> loses. Otherwise, the game proceeds to the next step.</li>

      <li>The remaining <span class="math">CB</span> balls are randomly partitioned into the <span class="math">C</span> bins, with each bin receiving exactly <span class="math">B</span> balls.</li>

      <li>We say that a bin is fully <span class="math">\\mathsf{good}</span> (resp., fully <span class="math">\\mathsf{bad}</span>) if it is labeled <span class="math">\\mathsf{good}</span> and all the balls inside it are <span class="math">\\mathsf{good}</span> (resp., labeled <span class="math">\\mathsf{bad}</span> and all the balls inside it are <span class="math">\\mathsf{bad}</span>). <span class="math">\\mathcal{A}</span> wins if and only if there exists at least one bin that is fully <span class="math">\\mathsf{bad}</span>, and all other bins are either fully <span class="math">\\mathsf{good}</span> or fully <span class="math">\\mathsf{bad}</span></li>

    </ol>

    <p class="text-gray-300">Lemma 1. Assume <span class="math">c \\geq B</span>. Then <span class="math">\\mathcal{A}</span> wins the above game with probability at most <span class="math">\\binom{CB+c}{B}^{-1}</span>.</p>

    <p class="text-gray-300">Proof. Assume <span class="math">\\mathcal{A}</span> makes <span class="math">m</span> bins <span class="math">\\mathsf{bad}</span> for <span class="math">1 \\leq m \\leq C</span>. It is easy to see that <span class="math">\\mathcal{A}</span> can only possibly win if exactly <span class="math">mB</span> balls among <span class="math">\\mathcal{B}_1, \\ldots, \\mathcal{B}_\\ell</span> are <span class="math">\\mathsf{bad}</span>, and they are exactly placed in the <span class="math">m</span> bins that are <span class="math">\\mathsf{bad}</span>. We compute the probability that <span class="math">\\mathcal{A}</span> wins for some fixed <span class="math">m</span>.</p>

    <p class="text-gray-300">Since exactly <span class="math">mB</span> balls of the <span class="math">\\ell = CB + c</span> balls are <span class="math">\\mathsf{bad}</span>, the probability that none of the <span class="math">\\mathsf{bad}</span> balls is chosen in step 2 of the game is exactly</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\binom {\\ell - m B} {c}}{\\binom {\\ell} {c}} = \\frac {(\\ell - m B) ! \\cdot (\\ell - c) !}{\\ell ! \\cdot (\\ell - m B - c) !} = \\frac {(C B + c - m B) ! \\cdot (C B) !}{(C B + c) ! \\cdot (C B - m B) !}.</span></div>

    <p class="text-gray-300">Assume that this occurs. We are left with <span class="math">\\ell - c = CB</span> balls, of which <span class="math">mB</span> are <span class="math">\\mathsf{bad}</span>. The probability that <span class="math">B</span> balls are placed in each <span class="math">\\mathsf{bad}</span> bin is</p>

    <div class="my-4 text-center"><span class="math-block">p _ {1} = \\frac {(m B) ! \\cdot (C B - m B) !}{(C B) !}.</span></div>

    <p class="text-gray-300">Thus, the probability that <span class="math">\\mathcal{A}</span> wins is exactly</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\binom {\\ell - m B} {c}}{\\binom {\\ell} {c}} \\cdot p _ {1} = \\frac {(C B + c - m B) ! \\cdot (m B) !}{(C B + c) !} = \\binom {C B + c} {m B} ^ {- 1}.</span></div>

    <p class="text-gray-300">For <span class="math">c \\geq B</span>, <span class="math">1 \\leq m \\leq C</span>, this is maximized when <span class="math">m = 1</span>.</p>

    <p class="text-gray-300">Now we prove security of protocol <span class="math">\\Pi_{\\mathsf{ZK}}</span>.</p>

    <p class="text-gray-300">Theorem 1. Let <span class="math">c \\geq B</span>. Protocol <span class="math">\\Pi_{\\mathsf{ZK}}</span> UC-realizes <span class="math">\\mathcal{F}_{\\mathsf{ZK}}</span> in the <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span>-hybrid model. In particular, no environment <span class="math">\\mathcal{Z}</span> can distinguish the real-world execution from the ideal-world execution except with probability at most <span class="math">\\binom{CB+c}{B}^{-1} + p^{-r} + \\varepsilon_{\\mathrm{open}}</span>.</p>

    <p class="text-gray-300">Proof. We first consider the case of a malicious prover (i.e., soundness) and then consider the case of a malicious verifier (i.e., zero knowledge). In each case, we construct a PPT simulator <span class="math">\\mathcal{S}</span> given access to <span class="math">\\mathcal{F}_{\\mathsf{ZK}}</span>, and running the PPT adversary <span class="math">\\mathcal{A}</span> as a subroutine while emulating functionality <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span> for <span class="math">\\mathcal{A}</span>. We always implicitly assume that <span class="math">\\mathcal{S}</span> passes all communication between <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span>.</p>

    <p class="text-gray-300">Malicious prover. <span class="math">\\mathcal{S}</span> interacts with adversary <span class="math">\\mathcal{A}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> for <span class="math">\\mathcal{A}</span> by choosing uniform <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span> and recording all the values <span class="math">\\{\\lambda_i\\}_{i\\in \\mathcal{I}_{\\mathrm{in}}}</span>, <span class="math">\\{(x_{i},y_{i},r_{i})\\}_{i\\in [\\ell]}</span>, and <span class="math">\\{s_i\\}_{i\\in [C]}</span>, and their corresponding MAC tags, sent to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> by <span class="math">\\mathcal{A}</span>. These values define corresponding keys in the natural way.</li>

      <li>If <span class="math">\\mathcal{A}</span> makes a global-key query <span class="math">(\\mathrm{guess}, \\Delta&#x27;)</span> to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>, then <span class="math">\\mathcal{S}</span> checks if <span class="math">\\Delta = \\Delta&#x27;</span>. If not, <span class="math">\\mathcal{S}</span> sends abort to <span class="math">\\mathcal{A}</span>, sends <span class="math">(\\mathrm{prove}, \\mathcal{C}, \\bot)</span> to <span class="math">\\mathcal{F}_{\\mathrm{ZK}}</span>, and aborts. Otherwise, <span class="math">\\mathcal{S}</span> sends success to <span class="math">\\mathcal{A}</span> and continues.</li>

      <li>When <span class="math">\\mathcal{A}</span> sends <span class="math">\\{\\Lambda_i\\}_{i\\in \\mathcal{I}_{\\mathrm{in}}}</span> in step 4, <span class="math">\\mathcal{S}</span> sets <span class="math">w_{i} := \\lambda_{i} + \\Lambda_{i}</span> for <span class="math">i \\in \\mathcal{I}_{\\mathrm{in}}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> runs the rest of the protocol as an honest verifier, using <span class="math">\\Delta</span> and the keys defined in the first step. If the honest verifier outputs false, then <span class="math">\\mathcal{S}</span> sends <span class="math">(\\mathrm{prove}, \\mathcal{C}, \\bot)</span> to <span class="math">\\mathcal{F}_{\\mathrm{ZK}}</span> and aborts. If the honest verifier outputs true, then <span class="math">\\mathcal{S}</span> sends <span class="math">(\\mathrm{prove}, \\mathcal{C}, w)</span> to <span class="math">\\mathcal{F}_{\\mathrm{ZK}}</span> where <span class="math">w</span> is defined as above.</li>

    </ol>

    <p class="text-gray-300">We assume that <span class="math">\\mathcal{A}</span> does not correctly guess <span class="math">\\Delta</span>; this is true except with probability at most <span class="math">p^{-r}</span>. It is clear that the view of <span class="math">\\mathcal{A}</span> is perfectly simulated by <span class="math">\\mathcal{S}</span>. Whenever the verifier simulated by <span class="math">\\mathcal{S}</span> outputs false, the real verifier outputs false as well (since <span class="math">\\mathcal{S}</span> sends <span class="math">\\perp</span> to <span class="math">\\mathcal{F}_{\\mathsf{ZK}}</span>). It thus only remains to bound the probability with which the simulated verifier run by <span class="math">\\mathcal{S}</span> outputs true but the witness <span class="math">w</span> sent by <span class="math">\\mathcal{S}</span> to <span class="math">\\mathcal{F}_{\\mathsf{ZK}}</span> satisfies <span class="math">\\mathcal{C}(w)=0</span>. Below, we show that if <span class="math">\\mathcal{C}(w)=0</span> then the probability that the simulated verifier outputs true is at most <span class="math">\\binom{CB+c}{B}^{-1}+\\varepsilon_{\\mathsf{open}}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{C}(w)=0</span> then either <span class="math">w_{o}=0</span> or else at least one of the triples <span class="math">\\{([w_{\\alpha}],[w_{\\beta}],[w_{\\gamma}])\\}</span> defined at the multiplication gates during the circuit evaluation must be incorrect. In the former case, the probability that <span class="math">\\mathcal{P}</span> succeeds when running CheckZero<span class="math">([w_{o}]-1)</span> is at most <span class="math">\\varepsilon_{\\mathsf{open}}</span>. In the latter case, Lemma 1 shows that the probability that <span class="math">\\mathcal{A}</span> avoids being “caught” in steps 6–8 is at most <span class="math">\\binom{CB+c}{B}^{-1}</span>; if <span class="math">\\mathcal{A}</span> is caught, then it succeeds in opening some incorrect value with probability at most <span class="math">\\varepsilon_{\\mathsf{open}}</span>. This completes the proof for the case of a malicious prover.</p>

    <p class="text-gray-300">Malicious verifier. If <span class="math">\\mathcal{S}</span> receives false from <span class="math">\\mathcal{F}_{\\mathsf{ZK}}</span>, then it simply aborts. Otherwise, <span class="math">\\mathcal{S}</span> interacts with adversary <span class="math">\\mathcal{A}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span> by recording the global key <span class="math">\\Delta</span>, and the keys for all the authenticated values, sent to the functionality by <span class="math">\\mathcal{A}</span>. Then, <span class="math">\\mathcal{S}</span> samples uniform values for <span class="math">\\{\\lambda_{i}\\}_{i\\in\\mathcal{I}_{\\mathsf{in}}}</span>, <span class="math">\\{(x_{i},y_{i},r_{i})\\}_{i\\in[\\ell]}</span>, and <span class="math">\\{s_{i}\\}_{i\\in[C]}</span>, and computes their corresponding MAC tags in the natural way.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\mathcal{S}</span> executes steps 3–8 of protocol <span class="math">\\Pi_{\\mathsf{ZK}}</span> by simulating the honest prover with input $w=0^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}_{\\mathsf{in}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In step 9, <span class="math">\\mathcal{S}</span> computes <span class="math">\\mathsf{K}[w_{o}]</span> (based on the keys sent to <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span> by <span class="math">\\mathcal{A}</span>) and then sets <span class="math">\\mathsf{M}[w_{o}]:=\\mathsf{K}[w_{o}]+\\Delta</span>. Finally, it uses <span class="math">\\mathsf{M}[w_{o}]</span> to run CheckZero<span class="math">([w_{o}]-1)</span> with <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <p class="text-gray-300">The view of <span class="math">\\mathcal{A}</span> simulated by <span class="math">\\mathcal{S}</span> is distributed identically to its view in the real protocol execution. This completes the proof. ∎</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.2 Other Approaches for Verifying Correct Behavior</h3>

    <p class="text-gray-300">Here we describe alternative approaches for checking correctness of multiplication gates for large <span class="math">p</span> (i.e., <span class="math">\\log p\\geq\\rho</span>).</p>

    <p class="text-gray-300">Approach 1. The first approach can be viewed as a simplified version of the check used by SPDZ <em>[x10]</em>. Both parties now prepare a <em>single</em> authenticated multiplication triple <span class="math">([x],[y],[z])</span> per multiplication gate (so only <span class="math">C</span> in total), which may be incorrect if <span class="math">\\mathcal{P}</span> is malicious. To check correctness of a multiplication gate with authenticated values <span class="math">[w_{\\alpha}]</span>, <span class="math">[w_{\\beta}]</span> on the input wires and <span class="math">[w_{\\gamma}]</span> on the output wire, the verifier sends a uniform <span class="math">\\eta\\in\\mathbb{F}_{p}</span> to the prover, who responds by running <span class="math">\\delta_{\\alpha}:=\\mathsf{Open}(\\eta\\cdot[w_{\\alpha}]-[x])</span> and <span class="math">\\delta_{\\beta}:=\\mathsf{Open}([w_{\\beta}]-[y])</span>, followed by</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CheckZero}([z]-\\eta\\cdot[w_{\\gamma}]+\\delta_{\\beta}\\cdot[x]+\\delta_{\\alpha}\\cdot[y]+\\delta_{\\alpha}\\cdot\\delta_{\\beta}).</span></p>

    <p class="text-gray-300">This has soundness error <span class="math">1/p+\\varepsilon_{\\mathsf{open}}</span>. To see this, say <span class="math">w_{\\gamma}=w_{\\alpha}w_{\\beta}+\\Delta_{w}</span> with <span class="math">\\Delta_{w}\\neq 0</span>, and let <span class="math">z=xy+\\Delta_{z}</span>. Then <span class="math">z-\\eta\\cdot w_{\\gamma}+\\delta_{\\beta}\\cdot x+\\delta_{\\alpha}\\cdot y+\\delta_{\\alpha}\\cdot\\delta_{\\beta}=0</span> iff <span class="math">\\eta=\\Delta_{z}/\\Delta_{w}</span>, which occurs with probability <span class="math">1/p</span>. Note that this checking procedure can be done for all multiplication gates in parallel using a single value <span class="math">\\eta</span>, and the overall soundness error remains unchanged. It can also be made non-interactive using the Fiat-Shamir heuristic in the random-oracle model.</p>

    <p class="text-gray-300">Approach 2: Trading off communication and computation. This approach, which is a simplified and improved variant of the polynomial approach used by SPDZ <em>[x10]</em>, reduces the communication complexity by roughly half (from 4 to 2 field elements per gate) at the expense</p>

    <p class="text-gray-300">of increased computation. Intuitively, the prover and verifier define polynomials <span class="math">F, G, H</span> that interpolate to <span class="math">\\{w_{\\alpha}^{i}\\}</span>, <span class="math">\\{w_{\\beta}^{i}\\}</span>, and <span class="math">\\{w_{\\gamma}^{i}\\}</span>, respectively. If <span class="math">w_{\\gamma}^{i} = w_{\\alpha}^{i} \\cdot w_{\\beta}^{i}</span> for all <span class="math">i</span>, then <span class="math">H = F \\cdot G</span>, and this can be verified by checking whether <span class="math">H(\\nu) = F(\\nu) \\cdot G(\\nu)</span> at a random point <span class="math">\\nu \\in \\mathbb{F}_{p^r}</span>. Details follow.</p>

    <p class="text-gray-300">Assume <span class="math">p \\geq 2C - 1</span>. Let <span class="math">([w_{\\alpha}^{i}], [w_{\\beta}^{i}], [w_{\\gamma}^{i}])</span> be the authenticated values corresponding to the <span class="math">i</span>th multiplication gate. The parties additionally compute <span class="math">C - 1</span> authenticated values <span class="math">\\{[s_i]\\}_{i \\in [C + 1, 2C)}</span>; they also compute an authenticated multiplication triple <span class="math">([x], [y], [z])</span> (which may be incorrect if <span class="math">\\mathcal{P}</span> is malicious) with <span class="math">x, y, z \\in \\mathbb{F}_{p^r}</span>. They then do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">F \\in \\mathbb{F}_p[X]</span> (resp., <span class="math">G \\in \\mathbb{F}_p[X]</span>) be the polynomial of degree at most <span class="math">C - 1</span> such that <span class="math">F(i) = w_{\\alpha}^{i}</span> (resp., <span class="math">G(i) = w_{\\beta}^{i}</span>) for <span class="math">i \\in [C]</span>. Note that <span class="math">\\mathcal{P}</span> can compute <span class="math">F</span> and <span class="math">G</span> explicitly, and <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> can compute the authenticated value <span class="math">[w_{\\alpha}^{k}] \\stackrel{\\mathrm{def}}{=} [F(k)]</span> (resp., <span class="math">[w_{\\beta}^{k}] \\stackrel{\\mathrm{def}}{=} [G(k)]</span>) for any <span class="math">k \\in \\mathbb{F}_{p^r}</span> using Lagrange interpolation over the shares <span class="math">\\{[w_{\\alpha}^{i}]\\}_{i \\in [C]}</span> (resp., <span class="math">\\{[w_{\\beta}^{i}]\\}_{i \\in [C]}</span>).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">k \\in [C + 1, 2C)</span>, <span class="math">\\mathcal{P}</span> sends <span class="math">d_k&#x27; := w_\\alpha^k \\cdot w_\\beta^k - s_k</span> to <span class="math">\\mathcal{V}</span>, and both parties compute <span class="math">[w_\\gamma^k] := [s_k] + d_k&#x27;</span>. Let <span class="math">H \\in \\mathbb{F}_p[X]</span> be the polynomial of degree at most <span class="math">2C - 2</span> such that <span class="math">H(i) = w_\\gamma^i</span> for <span class="math">i \\in [2C - 1]</span>. Note that <span class="math">\\mathcal{P}</span> can compute <span class="math">H</span> explicitly, while <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> can compute the authenticated value <span class="math">[H(k)]</span> for any <span class="math">k \\in \\mathbb{F}_{p^r}</span> using Lagrange interpolation over the shares <span class="math">[w_\\gamma^i]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> sends a uniform <span class="math">\\nu \\in \\mathbb{F}_{p^r}</span> to <span class="math">\\mathcal{P}</span>. Then the parties compute authenticated values <span class="math">[F(\\nu)]</span>, <span class="math">[G(\\nu)]</span>, and <span class="math">[H(\\nu)]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, <span class="math">\\mathcal{V}</span> verifies that <span class="math">F(\\nu) \\cdot G(\\nu) = H(\\nu)</span> as in approach 1, above. That is, <span class="math">\\mathcal{V}</span> sends a uniform <span class="math">\\eta \\in \\mathbb{F}_{p^r}</span> to <span class="math">\\mathcal{P}</span>, who responds by running <span class="math">\\delta := \\mathrm{Open}(\\eta \\cdot [F(\\nu)] - [x])</span> and <span class="math">\\sigma := \\mathrm{Open}([G(\\nu)] - [y])</span>, followed by</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{CheckZero}([z] - \\eta \\cdot [H(\\nu)] + \\sigma \\cdot [x] + \\delta \\cdot [y] + \\delta \\cdot \\sigma).</span></div>

    <p class="text-gray-300">This has soundness error <span class="math">(2C - 1) / p^{r} + \\varepsilon_{\\mathrm{open}}</span>. To see this, note that if there exists an <span class="math">i \\in [C]</span> with <span class="math">w_{\\alpha}^{i} \\cdot w_{\\beta}^{i} \\neq w_{\\gamma}^{i}</span> then the polynomials <span class="math">F \\cdot G</span> and <span class="math">H</span> are different, and so agree in at most <span class="math">2C - 2</span> points. Thus, <span class="math">F(\\nu) \\cdot G(\\nu) \\neq H(\\nu)</span> except with probability at most <span class="math">(2C - 2) / p^{r}</span>. When that is the case, an analysis in the first approach shows that the final check fails except with probability at most <span class="math">1 / p^{r} + \\varepsilon_{\\mathrm{open}}</span>.</p>

    <p class="text-gray-300">This approach can also be made non-interactive using the Fiat-Shamir heuristic in the random-oracle model.</p>

    <h2 id="sec-20" class="text-2xl font-bold">4 Subfield VOLE</h2>

    <p class="text-gray-300">In this section, we present an sVOLE protocol that can be used during the offline phase of our ZK protocol. In Section 5, we first present an sVOLE protocol with linear communication complexity. Although this already suffices for our ZK protocol, we can obtain much better efficiency using "sVOLE extension" (by analogy with OT extension), by which we extend a small number of "base" sVOLE correlations into a larger number of sVOLE correlations. Toward this end, in Section 5.1 we construct a protocol for single-point sVOLE (spsVOLE) in the <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>-hybrid model, where spsVOLE is like sVOLE except that the vector of authenticated values has only a single nonzero entry. Then, in Section 5.2, we present an efficient protocol for "sVOLE extension" using spsVOLE</p>

    <p class="text-gray-300">1 A uniform authenticated value [z] with z \\in \\mathbb{F}_{p^r} can be generated from r uniform authenticated values [z_1], \\ldots, [z_r] with z_i \\in \\mathbb{F}_p by setting z = \\sum_{i} z_i \\cdot \\mathsf{X}^i . An authenticated multiplication triple can be computed from such authenticated values in the natural way.</p>

    <p class="text-gray-300">Initialize: Upon receiving init from parties  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> ,  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , sample  <span class="math">\\Delta \\gets \\mathbb{F}_{p^r}</span>  if  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is honest, and receive  <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span>  from the adversary otherwise. Store global key  <span class="math">\\Delta</span> , send  <span class="math">\\Delta</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , and ignore all subsequent init commands. Let  <span class="math">\\Delta_B \\in \\{0,1\\}^{rm}</span>  be the bit-decomposition of  <span class="math">\\Delta</span> , where  <span class="math">m = \\lceil \\log p \\rceil</span> .</p>

    <p class="text-gray-300">Extend: Upon receiving (extend,  <span class="math">u</span> ) with  <span class="math">u \\in \\mathbb{F}_p</span>  from  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and (extend) from  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , this functionality operates as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">v \\gets \\mathbb{F}_{p^r}</span> . If  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is corrupted, instead receive  <span class="math">v \\in \\mathbb{F}_{p^r}</span>  from the adversary.</li>

      <li>Compute  <span class="math">w \\coloneqq v + \\Delta \\cdot u \\in \\mathbb{F}_{p^r}</span> .</li>

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  is corrupted, receive  <span class="math">w\\in \\mathbb{F}_{p^r}</span>  and  <span class="math">\\pmb {u}\\in \\mathbb{F}_p^{rm}</span>  from the adversary, and recompute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">v := w - \\left\\langle \\boldsymbol {g} * \\boldsymbol {u}, \\boldsymbol {\\Delta} _ {B} \\right\\rangle \\in \\mathbb {F} _ {p ^ {r}},</span></div>

    <p class="text-gray-300">where  <span class="math">*</span>  denotes the component-wise product.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">(u, w)</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">v</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 4: Functionality for correlated oblivious product evaluation with errors (COPEe).</p>

    <p class="text-gray-300">as a subroutine and relying on a variant of the Learning Parity with Noise (LPN) assumption. We provide some intuition for each protocol in the relevant section. Our implementation shows that this protocol outperforms all prior work; we discuss its concrete performance in Section 6.1.</p>

    <p class="text-gray-300">We present a "base" sVOLE protocol that is based on oblivious transfer (OT) and is inspired by prior work of Keller et al. [KOS15, KOS16]. Our protocol relies on the correlated oblivious product evaluation with errors (COPEe) functionality  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}</span> , which extends the analogous functionality introduced by Keller et al. [KOS16] to the subfield case we are interested in. We show in Appendix B.1 how to UC-realize  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}</span>  from OT.</p>

    <p class="text-gray-300">Functionality  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}</span>  is described in Figure 4, where  <span class="math">m = \\lceil \\log p \\rceil</span> . In  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}</span> , we define a "gadget vector"  <span class="math">\\pmb{g} \\in \\mathbb{F}_{p^r}^{rm}</span>  by</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {g} = \\left((1, 2, \\dots , 2 ^ {m - 1}), (1, 2, \\dots , 2 ^ {m - 1}) \\cdot \\mathsf {X}, \\dots , (1, 2, \\dots , 2 ^ {m - 1}) \\cdot \\mathsf {X} ^ {r - 1}\\right).</span></div>

    <p class="text-gray-300">For a vector  <span class="math">\\pmb{x} \\in \\mathbb{F}_{p^r}^{rm}</span> , we define</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\boldsymbol {g}, \\boldsymbol {x} \\rangle = \\sum_ {i = 0} ^ {r - 1} \\left(\\sum_ {j = 0} ^ {m - 1} \\boldsymbol {x} [ i \\cdot m + j ] \\cdot 2 ^ {j}\\right) \\cdot \\mathsf {X} ^ {i} \\in \\mathbb {F} _ {p ^ {r}},</span></div>

    <p class="text-gray-300">where the definition can be extended to the cases  <span class="math">\\pmb{x} \\in \\{0,1\\}^{rm}</span>  or  <span class="math">\\pmb{x} \\in \\mathbb{F}_p^{rm}</span>  by viewing  <span class="math">\\pmb{x}</span>  as lying in  <span class="math">\\mathbb{F}_{p^r}^{rm}</span>  in the natural way. The bit-decomposition of  <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span>  is the string  <span class="math">\\pmb{\\Delta}_B \\in \\{0,1\\}^{rm}</span>  satisfying  <span class="math">\\langle \\pmb{g}, \\pmb{\\Delta}_B \\rangle = \\Delta</span> .</p>

    <p class="text-gray-300">In Figure 5, we present a protocol  <span class="math">\\Pi_{\\text{base-sVOLE}}^{p,r}</span>  that UC-realizes  <span class="math">\\mathcal{F}_{\\text{sVOLE}}^{p,r}</span>  in the  <span class="math">\\mathcal{F}_{\\text{COPEe}}</span> -hybrid model. We first describe a sub-protocol  <span class="math">\\Pi_{\\text{base-LsVOLE}}^{p,r}</span> , which allows two parties to generate sVOLE correlations with a selective-failure leakage on  <span class="math">\\Delta</span> , meaning that a malicious  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  is allowed to guess</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  send init to  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}^{p,r}</span> , which returns  <span class="math">\\Delta</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  samples  <span class="math">u_{i}\\gets \\mathbb{F}_{p}</span>  for  <span class="math">i\\in [0,n)</span>  and  <span class="math">a_{h}\\leftarrow \\mathbb{F}_{p}</span>  for  <span class="math">h\\in [0,r)</span> . For  <span class="math">i\\in [0,n)</span> ,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends (extend,  <span class="math">u_{i}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}^{p,r}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  sends (extend) to  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}^{p,r}</span> , which returns  <span class="math">w_{i}\\in \\mathbb{F}_{p^{r}}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">v_{i}\\in \\mathbb{F}_{p^{r}}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  such that  <span class="math">w_{i} = v_{i} + \\Delta \\cdot u_{i}</span> . For  <span class="math">h\\in [0,r)</span> , both parties also call  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}^{p,r}</span>  on respective inputs (extend,  <span class="math">a_{h}</span> ) and (extend), following which  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  gets  <span class="math">c_{h}\\in \\mathbb{F}_{p^{r}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  obtains  <span class="math">b_{h}\\in \\mathbb{F}_{p^{r}}</span>  such that  <span class="math">c_{h} = b_{h} + \\Delta \\cdot a_{h}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  samples  <span class="math">\\chi_0,\\ldots ,\\chi_{n - 1}\\gets \\mathbb{F}_{p^r}</span> , and sends them to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> . Then  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  computes  <span class="math">x\\coloneqq \\sum_{i = 0}^{n - 1}\\chi_i\\cdot u_i + \\sum_{h = 0}^{r - 1}a_h\\cdot X^h</span> ,  <span class="math">z\\coloneqq \\sum_{i = 0}^{n - 1}\\chi_i\\cdot w_i + \\sum_{h = 0}^{r - 1}c_h\\cdot X^h</span> , and sends  <span class="math">(x,z)</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  computes  <span class="math">y\\coloneqq \\sum_{i = 0}^{n - 1}\\chi_i\\cdot v_i + \\sum_{h = 0}^{r - 1}b_h\\cdot X^h</span>  and checks that  <span class="math">z = y + \\Delta \\cdot x</span> . If not,  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  aborts.</li>

      <li>For  <span class="math">i \\in [0, n)</span> ,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  defines  <span class="math">\\pmb{u}[i] = u_i</span>  and  <span class="math">\\pmb{w}[i] = w_i</span> , and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  sets  <span class="math">\\pmb{v}[i] = v_i</span> .</li>

    </ol>

    <p class="text-gray-300">Full protocol without any leakage: Let  <span class="math">\\ell = \\lceil 2\\rho /r\\log p\\rceil +1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both parties execute the above sub-protocol with parameters  <span class="math">p</span>  and  <span class="math">k = \\ell \\cdot r</span> . Then,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  obtains  <span class="math">(\\pmb{u},\\pmb{w}) \\in \\mathbb{F}_p^n \\times \\mathbb{F}_{p^k}^n</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  gets  <span class="math">\\Delta \\in \\mathbb{F}_{p^k}</span>  and  <span class="math">\\pmb{v} \\in \\mathbb{F}_{p^k}^n</span>  such that  <span class="math">\\pmb{w} = \\pmb{v} + \\Delta \\cdot \\pmb{u}</span> . By viewing an element in  <span class="math">\\mathbb{F}_{p^k}</span>  as a vector in  <span class="math">\\mathbb{F}_{p^r}^\\ell</span> , two parties obtain  <span class="math">\\{\\pmb{w}_i\\}_{i \\in [\\ell]}</span>  and  <span class="math">\\{(\\Delta_i, \\pmb{v}_i)\\}_{i \\in [\\ell]}</span>  respectively such that  <span class="math">\\pmb{w}_i = \\pmb{v}_i + \\pmb{u} \\cdot \\Delta_i</span> ,  <span class="math">\\pmb{w}_i, \\pmb{v}_i \\in \\mathbb{F}_{p^r}^n</span>  and  <span class="math">\\Delta_i \\in \\mathbb{F}_{p^r}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  samples  <span class="math">\\alpha_{1},\\ldots ,\\alpha_{\\ell}\\gets \\mathbb{F}_{p^{r}}</span>  and sends them to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  computes  <span class="math">\\pmb {t}\\coloneqq \\sum_{i = 1}^{\\ell}\\alpha_{i}\\cdot \\pmb{w}_{i};\\mathsf{P}_{\\mathsf{B}}</span>  computes  <span class="math">\\pmb {s}\\coloneqq \\sum_{i = 1}^{\\ell}\\alpha_{i}\\cdot \\pmb{v}_{i}</span>  and  <span class="math">\\Gamma \\coloneqq \\sum_{i = 1}^{\\ell}\\alpha_{i}\\cdot \\Delta_{i}</span> , where  <span class="math">\\pmb {t} = \\pmb {s} + \\Gamma \\cdot \\pmb{u}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  outputs  <span class="math">\\pmb{u}</span>  and  <span class="math">\\pmb{t}</span> ;  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  outputs  <span class="math">\\Gamma</span>  and  <span class="math">\\pmb{s}</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 5: Base sVOLE protocol in the  <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}</span> -hybrid model.</p>

    <p class="text-gray-300">a subset of  <span class="math">\\Delta</span>  and the protocol execution aborts for an incorrect guess. In this sub-protocol,  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  performs a correlation check in steps 3 and 4 to verify that the resulting sVOLE correlations are correct (i.e.,  <span class="math">\\pmb{w} = \\pmb{v} + \\Delta \\cdot \\pmb{u}</span> ). Then, based on  <span class="math">\\Pi_{\\mathrm{base - LsVOLE}}^{p,r}</span> , we show how to generate sVOLE correlations without such leakage using the leftover hash lemma [ILL89]. In protocol  <span class="math">\\Pi_{\\mathrm{base - sVOLE}}^{p,r}</span> , all the uniform coefficients (i.e.,  <span class="math">\\{\\chi_i\\}, \\{\\alpha_i\\}</span> ) can be computed from a random seed and a hash function modeled as a random oracle.</p>

    <p class="text-gray-300">We prove the following in the full version of our work.</p>

    <p class="text-gray-300">Theorem 2. Protocol  <span class="math">\\Pi_{\\text{base-sVOLE}}^{p,r}</span>  UC-realizes  <span class="math">\\mathcal{F}_{\\text{sVOLE}}^{p,r}</span>  in the  <span class="math">\\mathcal{F}_{\\text{COPEe}}^{p,r}</span> -hybrid model. In particular, no PPT environment  <span class="math">\\mathcal{Z}</span>  can distinguish the real-world execution from the ideal-world execution, except with probability at most  <span class="math">(r\\log p)^2 / p^r + 1/2^\\rho</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Optimization. For many applications (e.g., our protocols) where learning the entire global key  <span class="math">\\Delta</span>  is necessary in order to violate security of some higher-level protocol, it is unnecessary to eliminate the selective-failure leakage about  <span class="math">\\Delta</span> . This can be argued as follows. Assume the adversary guesses a set  <span class="math">S</span>  (if there are multiple guesses then  <span class="math">S</span>  is the intersection of all guessed sets) and is caught cheating if  <span class="math">\\Delta \\notin S</span> . The probability that the selective-failure attack is successful is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ p^r<span class="math"> ; conditioned on this event, the min-entropy of  </span>\\Delta<span class="math">  is reduced to  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Therefore, the overall probability for the adversary to determine  </span>\\Delta<span class="math">  is  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ p^r \\cdot 2^{-\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = p^{-r}$ , which is the same as the probability in the absence of any leakage. Similar observations have been used in secure-computation protocols [KOS16, CDE+18, YWZ20].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Initialize: Upon receiving init from  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , sample  <span class="math">\\Delta \\gets \\mathbb{F}_{p^r}</span>  if  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is honest and receive  <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span>  from the adversary otherwise. Store global key  <span class="math">\\Delta</span> , send  <span class="math">\\Delta</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , and ignore all subsequent init commands.</p>

    <p class="text-gray-300">Extend: Upon receiving (sp-extend,  <span class="math">n</span> ), where  <span class="math">n = 2^h</span>  for some  <span class="math">h \\in \\mathbb{N}</span> , from  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , do:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is honest, sample  <span class="math">\\pmb {v}\\gets \\mathbb{F}_{p^r}^n</span>  . Otherwise, receive  <span class="math">\\pmb {v}\\in \\mathbb{F}_{p^r}^n</span>  from the adversary.</li>

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  is honest, then sample uniform  <span class="math">\\pmb {u}\\in \\mathbb{F}_p^n</span>  with exactly one nonzero entry, and compute  <span class="math">\\pmb {w}:= \\pmb {v} + \\Delta \\cdot \\pmb {u}\\in \\mathbb{F}_{p^r}^n</span>  . Otherwise, receive  <span class="math">\\pmb {u}\\in \\mathbb{F}_p^n</span>  (with at most one nonzero entry) and  <span class="math">\\pmb {w}\\in \\mathbb{F}_{p^r}^n</span>  from the adversary, and recompute  <span class="math">\\pmb {v}:= \\pmb {w} - \\Delta \\cdot \\pmb {u}\\in \\mathbb{F}_{p^r}^n</span></li>

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is corrupted, receive a set  <span class="math">I \\subseteq [0,n)</span>  from the adversary. Let  <span class="math">\\alpha \\in [0,n)</span>  be the index of the nonzero entry of  <span class="math">\\pmb{u}</span> . If  <span class="math">\\alpha \\in I</span> , send success to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  and continue. Otherwise, send abort to both parties and abort.</li>

      <li>Send  <span class="math">(\\pmb{u},\\pmb{w})</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\pmb{v}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

    </ol>

    <p class="text-gray-300">Global-key query: If  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  is corrupted, receive (guess,  <span class="math">\\Delta^{\\prime}</span> ) from the adversary with  <span class="math">\\Delta^{\\prime} \\in \\mathbb{F}_{p^{r}}</span> . If  <span class="math">\\Delta^{\\prime} = \\Delta</span> , send success to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and ignore any subsequent global-key query. Otherwise, send abort to both parties and abort.</p>

    <p class="text-gray-300">Figure 6: Functionality for single-point sVOLE.</p>

    <p class="text-gray-300">Single-point sVOLE is a variant of sVOLE where the vector of authenticated values contains exactly one nonzero entry. We present the associated functionality  <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>  in Figure 6, where the vector length  <span class="math">n = 2^h</span>  is assumed to be a power of two for simplicity. In Figure 7, we present a protocol  <span class="math">\\Pi_{\\mathrm{spsVOLE}}^{p,r}</span>  that UC-realizes  <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>  in the  <span class="math">(\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r},\\mathcal{F}_{\\mathrm{OT}},\\mathcal{F}_{\\mathrm{EQ}})</span> -hybrid model, where  <span class="math">\\mathcal{F}_{\\mathrm{OT}}</span>  is the standard OT functionality and  <span class="math">\\mathcal{F}_{\\mathrm{EQ}}</span>  corresponds to a weak equality test that reveals  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> ’s input to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> . (See Appendix A for formal definitions of both functionalities.) Conceptually, the protocol can be divided into two steps: (1) the parties run a semi-honest protocol for generating a vector of authenticated values  <span class="math">[\\pmb{u}]</span>  having a single nonzero entry; then (2) a consistency check is performed to detect malicious behavior. We explain both steps in what follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  begins by choosing a uniform  <span class="math">\\beta \\in \\mathbb{F}_p^*</span>  and a uniform index  <span class="math">\\alpha</span> . Letting  <span class="math">\\pmb{u} \\in \\mathbb{F}_p^n</span>  be the vector that is 0 everywhere except that  <span class="math">\\pmb{u}[\\alpha] = \\beta</span> , the goal is for the parties to generate  <span class="math">[\\pmb{u}]</span> . That is, they want  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  to hold  <span class="math">\\pmb{w} \\in \\mathbb{F}_{p^r}^n</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  to hold  <span class="math">\\pmb{v} \\in \\mathbb{F}_{p^r}^n</span>  such that  <span class="math">\\pmb{w} = \\pmb{v} + \\Delta \\cdot \\pmb{u}</span> . To do so, the parties begin by generating the authenticated value  <span class="math">[\\beta]</span> ; this is easy to do using a call to  <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> . Next, they use a subroutine [BGI15, BGI16, BCG+17] based on the GGM construction [GGM86] to enable  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  to generate  <span class="math">\\pmb{v} \\in \\mathbb{F}_{p^r}^n</span>  while allowing  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  to learn all the components of that vector except for  <span class="math">\\pmb{v}[\\alpha]</span> . This is done in the following way. Let  <span class="math">G: \\{0,1\\}^\\kappa \\to \\{0,1\\}^{2\\kappa}</span>  and  <span class="math">G&#x27;: \\{0,1\\}^\\kappa \\to \\mathbb{F}_{p^r}^2</span>  be pseudorandom generators (PRGs).  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  chooses uniform  <span class="math">s \\in \\{0,1\\}^\\kappa</span>  and computes all nodes in a GGM tree of depth  <span class="math">h</span>  with  <span class="math">s</span>  at the root: That is, letting  <span class="math">s_j^i</span>  denote the value at the  <span class="math">j</span> th node on the  <span class="math">i</span> th level of the tree,  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  defines  <span class="math">s_0^0 := s</span>  and then for  <span class="math">i \\in [1,h)</span>  and  <span class="math">j \\in [0,2^{i-1})</span>  computes  <span class="math">\\left(s_{2j}^i, s_{2j+1}^i\\right) := G(s_j^{i-1})</span> ; finally,  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  computes a vector  <span class="math">\\pmb{v}</span>  at the leaves as  <span class="math">(\\pmb{v}[2j], \\pmb{v}[2j+1]) := G&#x27;(s_j^{h-1})</span>  for  <span class="math">j \\in [0,2^{h-1})</span> . Next,  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  lets  <span class="math">K_0^i</span>  (resp.,  <span class="math">K_1^i</span> ) be the XOR of the values at the even (resp., odd) nodes on the  <span class="math">i</span> th level. (When  <span class="math">i = h</span>  we replace XOR with addition in  <span class="math">\\mathbb{F}_{p^r}</span> .) We write</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left\\{v _ {j} \\right\\} _ {j \\in [ 0, n)}, \\left\\{\\left(K _ {0} ^ {i}, K _ {1} ^ {i}\\right) \\right\\} _ {i \\in [ h ]}\\right) := \\mathsf {G G M} \\left(1 ^ {n}, s\\right)</span></div>

    <p class="text-gray-300">Initialize: This procedure is executed only once.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  send init to  <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> , which returns  <span class="math">\\Delta</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

    </ul>

    <p class="text-gray-300">Extend: This procedure can be run multiple times. On input  <span class="math">n = 2^h</span> , the parties do:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  send (extend, 1) to  <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> , which returns  <span class="math">(a,c)\\in \\mathbb{F}_p\\times \\mathbb{F}_{p^r}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">b\\in \\mathbb{F}_{p^r}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  such that  <span class="math">c = b + \\Delta \\cdot a</span> . Then,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  samples  <span class="math">\\beta \\gets \\mathbb{F}_p^*</span> , sets  <span class="math">\\delta \\coloneqq c</span> , and sends  <span class="math">a^\\prime \\coloneqq \\beta -a\\in \\mathbb{F}_p</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , who computes  <span class="math">\\gamma \\coloneqq b - \\Delta \\cdot a&#x27;</span> . Note that  <span class="math">\\delta = \\gamma +\\Delta \\cdot \\beta \\in \\mathbb{F}_{p^r}</span> , so the parties now hold  <span class="math">[\\beta]</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  samples  <span class="math">\\alpha \\gets [0,n)</span>  and defines  <span class="math">\\pmb {u}\\in \\mathbb{F}_p^n</span>  as the vector that is 0 everywhere except  <span class="math">\\pmb {u}[\\alpha ] = \\beta</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  samples  <span class="math">s\\gets \\{0,1\\}^{\\kappa}</span> , runs  <span class="math">\\mathsf{GGM}(1^n,s)</span>  to obtain  <span class="math">\\left(\\{v_j\\}_{j\\in [0,n)},\\{(K_0^i,K_1^i)\\}_{i\\in [h]}\\right)</span> , and sets  <span class="math">\\pmb {v}[j]\\coloneqq v_{j}</span>  for  <span class="math">j\\in [0,n)</span> .  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  lets  <span class="math">\\bar{\\alpha}_i</span>  be the complement of the  <span class="math">i</span> th bit of the binary representation of  <span class="math">\\alpha</span> . For  <span class="math">i\\in [h]</span> ,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends  <span class="math">\\bar{\\alpha}_i\\in \\{0,1\\}</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{OT}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  sends  <span class="math">(K_0^i,K_1^i)</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{OT}}</span> , which returns  <span class="math">K_{\\bar{\\alpha}_i}^i</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> . Then  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  runs  <span class="math">\\{v_j\\}_{j\\neq \\alpha}\\coloneqq \\mathsf{GGM}&#x27;(\\alpha ,\\{K_{\\bar{\\alpha}_i}^i\\}_{i\\in [h]})</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  sends  <span class="math">d\\coloneqq \\gamma -\\sum_{i\\in [0,n)}\\pmb {v}[i]\\in \\mathbb{F}_{p^r}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> . Then,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  defines  <span class="math">\\pmb {w}\\in \\mathbb{F}_{p^r}^n</span>  as the vector with  <span class="math">\\pmb {w}[i]\\coloneqq v_i</span>  for  <span class="math">i\\neq \\alpha</span>  and  <span class="math">\\pmb {w}[\\alpha ]\\coloneqq \\delta -\\Big(d + \\sum_{i\\neq \\alpha}\\pmb {w}[i]\\Big)</span> . Note that  <span class="math">\\pmb {w} = \\pmb {v} + \\Delta \\cdot \\pmb{u}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both parties send (extend,  <span class="math">r</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> , which returns  <span class="math">(\\pmb{x},\\pmb{z}) \\in \\mathbb{F}_p^r \\times \\mathbb{F}_{p^r}^r</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\pmb{y}^{<em>} \\in \\mathbb{F}_{p^r}^r</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  such that  <span class="math">\\pmb{z} = \\pmb{y}^{</em>} + \\Delta \\cdot \\pmb{x}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  samples  <span class="math">\\chi_{i}\\gets \\mathbb{F}_{p^{r}}</span>  for  <span class="math">i\\in [0,n)</span> , and writes  <span class="math">\\chi_{\\alpha} = \\sum_{i = 0}^{r - 1}\\chi_{\\alpha ,i}\\cdot \\mathsf{X}^{i}</span> . Let  <span class="math">\\pmb{\\chi}_{\\alpha} = (\\chi_{\\alpha ,0},\\dots ,\\chi_{\\alpha ,r - 1})\\in \\mathbb{F}_p^r</span> .  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  then computes  <span class="math">\\pmb{x}^{<em>}\\coloneqq \\beta \\cdot \\pmb{\\chi}_{\\alpha} - \\pmb {x}\\in \\mathbb{F}_p^r</span>  and sends  <span class="math">\\left(\\{\\chi_i\\}_{i\\in [0,n)},\\pmb{x}^</em>\\right)</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , who computes  <span class="math">\\pmb{y}\\coloneqq \\pmb{y}^{<em>} - \\Delta \\cdot \\pmb{x}^{</em>}\\in \\mathbb{F}_{p^{r}}^{r}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  computes  <span class="math">Z := \\sum_{i=0}^{r-1} \\mathbf{z}[i] \\cdot \\mathsf{X}^i \\in \\mathbb{F}_{p^r}</span>  and  <span class="math">V_{\\mathsf{A}} := \\sum_{i=0}^{n-1} \\chi_i \\cdot \\mathbf{w}[i] - Z \\in \\mathbb{F}_{p^r}</span> , while  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  computes  <span class="math">Y := \\sum_{i=0}^{r-1} \\mathbf{y}[i] \\cdot \\mathsf{X}^i \\in \\mathbb{F}_{p^r}</span>  and  <span class="math">V_{\\mathsf{B}} := \\sum_{i=0}^{n-1} \\chi_i \\cdot \\mathbf{v}[i] - Y \\in \\mathbb{F}_{p^r}</span> . Then  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends  <span class="math">V_{\\mathsf{A}}</span>  to  <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> , and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  sends  <span class="math">V_{\\mathsf{B}}</span>  to  <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> . If either party receives false or abort from  <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> , it aborts.</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  outputs  <span class="math">(\\pmb {u},\\pmb {w})</span>  and  <span class="math">\\mathsf{P_B}</span>  outputs  <span class="math">\\pmb{v}</span></li>

    </ol>

    <p class="text-gray-300">Figure 7: Single-point sVOLE protocol in the  <span class="math">(\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r},\\mathcal{F}_{\\mathrm{OT}},\\mathcal{F}_{\\mathrm{EQ}})</span> -hybrid model.</p>

    <p class="text-gray-300">to denote this computation done by  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> . It is easily verified that if  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  is given  <span class="math">\\{K_{\\bar{\\alpha}_i}^i\\}_{i\\in [h]}</span>  (where  <span class="math">\\bar{\\alpha}_i</span>  is the complement of the  <span class="math">i</span> th bit of  <span class="math">\\alpha</span> ), then  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  can compute  <span class="math">\\{\\pmb {v}[j]\\}_{j\\neq \\alpha}</span> , while  <span class="math">\\pmb {v}[\\alpha ]</span>  remains computationally indistinguishable from uniform given  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> ’s view. We denote the resulting computation of  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  by  <span class="math">\\{v_j\\}_{j\\neq \\alpha}\\coloneqq \\mathsf{GGM}&#x27;(\\alpha ,\\{K_{\\bar{\\alpha}_i}^i\\}_{i\\in [h]})</span> . ( <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  can obtain  <span class="math">\\{K_{\\bar{\\alpha}_i}^i\\}_{i\\in [h]}</span>  using  <span class="math">h</span>  OT invocations.)</p>

    <p class="text-gray-300">Following the above,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sets  <span class="math">\\pmb {w}[i]\\coloneqq \\pmb {v}[i]</span>  for  <span class="math">i\\neq \\alpha</span> . Note that  <span class="math">\\pmb {w}[i] = \\pmb {v}[i] + \\Delta \\cdot \\pmb {u}[i]</span>  for  <span class="math">i\\neq \\alpha</span>  (since  <span class="math">\\pmb {u}[i] = 0</span>  for  <span class="math">i\\neq \\alpha</span> ), so all that remains is for  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  to obtain the missing value  <span class="math">\\pmb {w}[\\alpha ] = \\pmb {v}[\\alpha ] + \\Delta \\cdot \\beta</span>  (without revealing  <span class="math">\\alpha ,\\beta</span>  to  <span class="math">\\mathsf{P_B}</span> ). Recall the parties already hold [β], meaning that  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  holds  <span class="math">\\mathsf{M}[\\beta ]</span>  and  <span class="math">\\mathsf{P_B}</span>  holds  <span class="math">\\mathsf{K}[\\beta ]</span>  with  <span class="math">\\mathsf{M}[\\beta ] = \\mathsf{K}[\\beta ] + \\Delta \\cdot \\beta</span> . So if  <span class="math">\\mathsf{P_B}</span>  sends  <span class="math">\\mathsf{K}[\\beta ] - \\sum_{i}\\pmb {v}[i]</span> , then  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  can compute the missing value as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\boldsymbol {w} [ \\alpha ] = \\mathsf {M} [ \\beta ] - (\\mathsf {K} [ \\beta ] - \\sum_ {i} \\boldsymbol {v} [ i ]) - \\sum_ {i \\neq \\alpha} \\boldsymbol {v} [ i ] \\\\ = \\mathsf {M} [ \\beta ] - \\mathsf {K} [ \\beta ] + \\boldsymbol {v} [ \\alpha ] = \\boldsymbol {v} [ \\alpha ] + \\Delta \\cdot \\beta . \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This completes the "semi-honest" portion of the protocol.</p>

    <p class="text-gray-300">To verify correct behavior, we generalize the approach of Yang et al.  <span class="math">\\mathrm{[YWL^{+}20]}</span>  that applies only to the case  <span class="math">p = 2</span> . We want to verify that  <span class="math">\\boldsymbol {w}[i] = \\boldsymbol {v}[i]</span>  for  <span class="math">i\\neq \\alpha</span> , and  <span class="math">\\boldsymbol {w}[\\alpha ] = \\boldsymbol {v}[\\alpha ] + \\Delta \\cdot \\beta</span> . Intuitively, the parties do this by having  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  choose uniform  <span class="math">\\chi_0,\\ldots ,\\chi_{n - 1}\\in \\mathbb{F}_{p^r}</span>  and then checking</p>

    <p class="text-gray-300">that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{w}[i] = \\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{v}[i] + \\Delta \\cdot \\beta \\cdot \\chi_\\alpha.</span></div>

    <p class="text-gray-300">Of course, this must be done without revealing <span class="math">\\alpha, \\beta</span> to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. To do so, <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> and <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> use <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> to compute <span class="math">Z, Y \\in \\mathbb{F}_{p^r}</span>, respectively, such that <span class="math">Z = Y + \\Delta \\cdot \\beta \\cdot \\chi_\\alpha</span>. (We discuss below how this is done.) They then use <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> to check if <span class="math">V_{\\mathsf{A}} = \\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{w}[i] - Z</span> is equal to <span class="math">V_{\\mathsf{B}} = \\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{v}[i] - Y</span>.</p>

    <p class="text-gray-300">To complete the description, we show how the parties can generate <span class="math">Z, Y</span> (held by <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>, <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>, respectively) such that <span class="math">Z = Y + \\Delta \\cdot \\beta \\cdot \\chi_\\alpha</span>. (This is like an authenticated value <span class="math">[\\beta \\cdot \\chi_\\alpha]</span>, but note that <span class="math">\\beta \\cdot \\chi_\\alpha</span> lies in <span class="math">\\mathbb{F}_{p^r}</span> rather than <span class="math">\\mathbb{F}_p</span>.) <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> views <span class="math">\\chi_\\alpha \\in \\mathbb{F}_{p^r}</span> as <span class="math">\\chi_\\alpha = (\\chi_{\\alpha,0}, \\ldots, \\chi_{\\alpha,r-1}) \\in \\mathbb{F}_p^r</span> (i.e., <span class="math">\\chi_\\alpha = \\sum_{i \\in [0,r)} \\chi_{\\alpha,i} \\cdot \\mathsf{X}^i</span>, where <span class="math">\\{\\mathsf{X}^i\\}_{i \\in [0,r)}</span> form a basis for <span class="math">\\mathbb{F}_{p^r}</span> over <span class="math">\\mathbb{F}_p</span>), and then the parties use <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> to generate the vector of authenticated values <span class="math">[\\beta \\cdot \\chi_\\alpha]</span>. This means <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> holds <span class="math">\\boldsymbol{z}</span> and <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> holds <span class="math">\\boldsymbol{y}</span> such that <span class="math">\\boldsymbol{z} = \\boldsymbol{y} + \\Delta \\cdot \\beta \\cdot \\chi_\\alpha</span>. Let <span class="math">Z = \\sum_{i \\in [0,r)} \\boldsymbol{z}[i] \\cdot \\mathsf{X}^i</span> and <span class="math">Y = \\sum_{i \\in [0,r)} \\boldsymbol{y}[i] \\cdot \\mathsf{X}^i</span>. We have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} Z = \\sum_{i=0}^{r-1} \\boldsymbol{z}[i] \\cdot \\mathsf{X}^i &amp;amp;= \\sum_{i=0}^{r-1} (\\boldsymbol{y}[i] + \\Delta \\cdot \\beta \\cdot \\chi_\\alpha[i]) \\cdot \\mathsf{X}^i \\\\ &amp;amp;= \\sum_{i=0}^{r-1} \\boldsymbol{y}[i] \\cdot \\mathsf{X}^i + \\Delta \\cdot \\beta \\cdot \\sum_{i=0}^{r-1} \\chi_\\alpha[i] \\cdot \\mathsf{X}^i \\\\ &amp;amp;= Y + \\Delta \\cdot \\beta \\cdot \\chi_\\alpha, \\end{aligned}</span></div>

    <p class="text-gray-300">as desired.</p>

    <p class="text-gray-300">We remark that this check allows a malicious <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> to guess <span class="math">\\Delta</span>, and allows a malicious <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> to guess a subset in which the index <span class="math">\\alpha</span> lies. (This will become evident in the proof of security.) Such guesses are incorporated into the ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> If <span class="math">G</span> and <span class="math">G&#x27;</span> are pseudorandom generators, then <span class="math">\\Pi_{\\mathrm{spsVOLE}}^{p,r}</span> UC-realizes <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span> in the <span class="math">(\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}, \\mathcal{F}_{\\mathrm{OT}}, \\mathcal{F}_{\\mathrm{EQ}})</span>-hybrid model. In particular, no PPT environment <span class="math">\\mathcal{Z}</span> can distinguish the real-world execution from the ideal-world execution except with probability at most <span class="math">1/p^r + \\mathrm{negl}(\\kappa)</span>.</p>

    <p class="text-gray-300">The proof of Theorem 3 is given in Appendix B.3.</p>

    <p class="text-gray-300"><strong>Optimizations.</strong> We discuss various optimizations of the protocol shown in Figure 7:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For large <span class="math">p</span> (i.e., <span class="math">\\log p \\geq \\rho</span>), the parties can use the output of <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> directly as <span class="math">[\\beta]</span> in step 1 of protocol <span class="math">\\Pi_{\\mathrm{spsVOLE}}^{p,r}</span>, since <span class="math">\\beta \\neq 0</span> with overwhelming probability.</li>

      <li>In the consistency check, <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> can send uniform <span class="math">\\mathsf{seed} \\in \\{0,1\\}^\\kappa</span> to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>, who then derives the <span class="math">\\{\\chi_i\\}</span> from <span class="math">\\mathsf{seed}</span> using a hash function modeled as a random oracle.</li>

      <li>When <span class="math">t</span> extend executions are needed, we can batch the consistency checks using the ideas of Yang et al. [YWL+20] to reduce the total number of sVOLE correlations needed from <span class="math">t \\cdot (1 + r)</span> to <span class="math">t + r</span>. The approach is as follows:</li>

    </ol>

    <p class="text-gray-300">(a) After <span class="math">t</span> executions of the semi-honest portion of the extend phase, the parties hold <span class="math">\\{(\\boldsymbol{u}_j, \\boldsymbol{w}_j)\\}_{j=1}^t</span> and <span class="math">\\{\\boldsymbol{v}_j\\}_{j=1}^t</span>, respectively, where for all <span class="math">j \\in [t]</span> we have <span class="math">\\boldsymbol{w}_j = \\boldsymbol{v}_j + \\Delta \\cdot \\boldsymbol{u}_j</span> with <span class="math">\\boldsymbol{u}_j</span> a vector that is 0 everywhere except <span class="math">\\boldsymbol{u}_j[\\alpha_j] = \\beta_j</span>. Then <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> and <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> send <span class="math">(\\text{extend}, r)</span> to <span class="math">\\mathcal{F}_{\\text{sVOLE}}^{p,r}</span>, which returns <span class="math">(\\boldsymbol{x}, \\boldsymbol{z})</span> to <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> and <span class="math">\\boldsymbol{y}^*</span> to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>.</p>

    <p class="text-gray-300">(b) For <span class="math">j \\in [t]</span>, <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> samples <span class="math">\\chi_{i,j} \\gets \\mathbb{F}_{p^r}</span> for <span class="math">i \\in [0,n)</span>, and views <span class="math">\\chi_{\\alpha_j,j}</span> as the vector <span class="math">\\chi_{\\alpha_j,j} \\in \\mathbb{F}_p^r</span>. It then computes <span class="math">\\boldsymbol{x}^<em> := \\sum_{j \\in [t]} \\beta_j \\cdot \\chi_{\\alpha_j,j} - \\boldsymbol{x}</span> and sends <span class="math">\\{\\chi_{i,j}\\}_{i \\in [0,n), j \\in [t]}</span> and <span class="math">\\boldsymbol{x}^</em></span> to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>, who computes <span class="math">\\boldsymbol{y} := \\boldsymbol{y}^<em> - \\Delta \\cdot \\boldsymbol{x}^</em> \\in \\mathbb{F}_{p^r}^r</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{\\mathsf{A}}</span> computes <span class="math">V_{\\mathsf{A}}:=\\sum_{i=0}^{n-1}\\sum_{j=1}^{t}\\chi_{i,j}\\cdot\\boldsymbol{w}_{j}[i]-\\sum_{i=0}^{r-1}\\boldsymbol{z}[i]\\cdot\\mathsf{X}^{i}</span>; <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> computes <span class="math">V_{\\mathsf{B}}:=\\sum_{i=0}^{n-1}\\sum_{j=1}^{t}\\chi_{i,j}\\cdot\\boldsymbol{v}_{j}[i]-\\sum_{i=0}^{r-1}\\boldsymbol{y}[i]\\cdot\\mathsf{X}^{i}</span>. Then both parties check whether <span class="math">V_{\\mathsf{A}}=V_{\\mathsf{B}}</span> by calling <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.2 sVOLE Extension</h3>

    <p class="text-gray-300">We show here a protocol that can be viewed as a means of performing “sVOLE extension.” That is, our protocol allows two parties to efficiently extend a small number of sVOLE correlations (created in a setup phase) to an arbitrary polynomial number of sVOLE correlations. The protocol relies on spsVOLE as a subroutine, as well as a variant of the LPN assumption that has been used in prior work <em>[x13, BCG^{+}19a, YWL^{+}20]</em>.</p>

    <p class="text-gray-300">Protocol overview. The parties use the base-sVOLE protocol to generate a length-<span class="math">k</span> vector of authenticated values <span class="math">[\\boldsymbol{u}]</span>. They also use spsVOLE to generate <span class="math">t</span> vectors of authenticated values, each of length <span class="math">n/t</span> and having a single nonzero entry; they let <span class="math">[\\boldsymbol{e}]</span> be the concatenation of those vectors. The parties then use a public matrix <span class="math">\\mathbf{A}</span> to define the length-<span class="math">n</span> vector of authenticated values <span class="math">[\\boldsymbol{u}\\cdot\\mathbf{A}+\\boldsymbol{e}]</span>; by the LPN assumption, the corresponding values (which <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> knows) will appear pseudorandom to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. This provides a way to extend <span class="math">k</span> random sVOLE correlations to <span class="math">n</span> pseudorandom sVOLE correlations once. As in prior work <em>[YWL^{+}20]</em>, however, we can generate <span class="math">\\ell=n-k</span> correlations as many times as desired by simply using this idea to generate <span class="math">n</span> sVOLE correlations and reserving the first <span class="math">k</span> of those correlations for the next iteration of the extend phase.</p>

    <p class="text-gray-300">LPN assumption. Let <span class="math">\\mathcal{D}_{n,t}</span> denote the distribution over an error vector <span class="math">\\boldsymbol{e}\\in\\mathbb{F}_{p}^{n}</span> in which <span class="math">\\boldsymbol{e}</span> is divided into <span class="math">t</span> blocks (each of length <span class="math">n/t</span>), and each block of contains exactly one uniform nonzero entry at a uniform location within that block.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 1 (LPN with static leakage <em>[BCG^{+}19a]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{G}</span> be a polynomial-time algorithm that on input <span class="math">1^{k},1^{n},p</span> outputs <span class="math">\\mathbf{A}\\in\\mathbb{F}_{p}^{k\\times n}</span>. Let parameters <span class="math">k,n,t</span> be implicit functions of security parameter <span class="math">\\kappa</span>. We say that the <span class="math">\\mathsf{LPN}^{\\mathcal{G}}_{k,n,t,p}</span> assumption holds if for all PPT algorithms <span class="math">\\mathcal{A}</span> we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,\\mathsf{Pr}[\\mathsf{LPN}\\cdot\\mathsf{Succ}^{\\mathcal{G}}_{\\mathcal{A}}(\\kappa)=1]-1/2\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\mathsf{negl}(\\kappa),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the experiment <span class="math">\\mathsf{LPN}\\cdot\\mathsf{Succ}^{\\mathcal{G}}_{\\mathcal{A}}(\\kappa)</span> is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\mathbf{A}\\leftarrow\\mathcal{G}(1^{k},1^{n},p)</span>, <span class="math">\\boldsymbol{u}\\leftarrow\\mathbb{F}_{p}^{k}</span>, and <span class="math">\\boldsymbol{e}\\leftarrow\\mathcal{D}_{n,t}</span>. Let <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}</span> be the indices of the nonzero entries in <span class="math">\\boldsymbol{e}</span> (each of which is located in a disjoint block of length <span class="math">n/t</span>).</li>

      <li><span class="math">\\mathcal{A}</span> outputs <span class="math">t</span> subsets <span class="math">I_{1},\\ldots,I_{t}\\subseteq[0,n)</span>. If <span class="math">\\alpha_{i}\\in I_{i}</span> for all <span class="math">i\\in[t]</span>, then send <span class="math">\\mathsf{success}</span> to <span class="math">\\mathcal{A}</span>; otherwise, abort the experiment and define <span class="math">b^{\\prime}:=0</span>.</li>

      <li>Pick <span class="math">b\\leftarrow\\{0,1\\}</span>. If <span class="math">b=0</span>, let <span class="math">\\boldsymbol{x}:=\\boldsymbol{u}\\cdot\\mathbf{A}+\\boldsymbol{e}</span>; otherwise, sample <span class="math">\\boldsymbol{x}\\leftarrow\\mathbb{F}_{p}^{n}</span>. Send <span class="math">\\boldsymbol{x}</span> to <span class="math">\\mathcal{A}</span>, who then outputs a bit <span class="math">b^{\\prime}</span> (if the experiment did not abort).</li>

      <li>The experiment outputs 1 iff <span class="math">b^{\\prime}=b</span>.</li>

    </ol>

    <p class="text-gray-300">Protocol description. In Figure 8, we present our sVOLE extension protocol in the <span class="math">(\\mathcal{F}^{p,r}_{\\mathsf{sVOLE}},\\mathcal{F}^{p,r}_{\\mathsf{spsVOLE}})</span>-hybrid model. For simplicity, we assume a public matrix <span class="math">\\mathbf{A}\\in\\mathbb{F}_{p}^{k\\times n}</span>, output by an efficient algorithm <span class="math">\\mathcal{G}(1^{k},1^{n},p)</span>, that is fixed at the outset of the protocol. (It is also possible to have <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> generate <span class="math">\\mathbf{A}</span> and then send it to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>.) We assume that <span class="math">\\mathcal{F}^{p,r}_{\\mathsf{spsVOLE}}</span> and <span class="math">\\mathcal{F}^{p,r}_{\\mathsf{sVOLE}}</span> share the same initialization (i.e., use the same global key <span class="math">\\Delta</span>). This holds, in particular, when we use protocol <span class="math">\\Pi^{p,r}_{\\mathsf{spsVOLE}}</span> from the previous section to UC-realize <span class="math">\\mathcal{F}^{p,r}_{\\mathsf{spsVOLE}}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Parameters: Fix  <span class="math">n, k, t</span> , and define  <span class="math">\\ell = n - k</span>  and  <span class="math">m = n / t</span> . Let  <span class="math">\\mathbf{A} \\in \\mathbb{F}_p^{k \\times n}</span>  be a matrix output by  <span class="math">\\mathcal{G}(1^k, 1^n, p)</span> .</p>

    <p class="text-gray-300">Initialize: This procedure is executed only once.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  send init to  <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> , which returns  <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  send (extend,  <span class="math">k</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> , which returns  <span class="math">(\\pmb{u},\\pmb{w})</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\pmb{v}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  such that  <span class="math">\\pmb{w} = \\pmb{v} + \\Delta \\cdot \\pmb{u} \\in \\mathbb{F}_{p^r}^k</span> .</li>

    </ol>

    <p class="text-gray-300">Extend: This procedure can be executed multiple times.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\in [t]</span> ,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  send (sp-extend,  <span class="math">m</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span> , which returns  <span class="math">(\\pmb{e}_i, \\pmb{c}_i)</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\pmb{b}_i</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  such that  <span class="math">\\pmb{c}_i = \\pmb{b}_i + \\Delta \\cdot \\pmb{e}_i \\in \\mathbb{F}_{p^r}^m</span>  and  <span class="math">\\pmb{e}_i \\in \\mathbb{F}_p^m</span>  has exactly one nonzero entry. If either party receives abort from  <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>  in any of these spsVOLE executions, it aborts.</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  defines  <span class="math">\\pmb {e} = (\\pmb {e}_1,\\dots ,\\pmb {e}_t)\\in \\mathbb{F}_p^n</span>  and  <span class="math">\\pmb {c} = (\\pmb {c}_1,\\dots ,\\pmb {c}_t)\\in \\mathbb{F}_{p^r}^n</span>  . Then  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  computes  <span class="math">\\pmb {x}\\coloneqq \\pmb {u}\\cdot \\mathbf{A} + \\pmb {e}\\in \\mathbb{F}_p^n</span>  and  <span class="math">\\pmb {z}\\coloneqq \\pmb {w}\\cdot \\mathbf{A} + \\pmb {c}\\in \\mathbb{F}_{p^r}^n</span>  .  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  defines  <span class="math">\\pmb {b} = (\\pmb {b}_1,\\dots ,\\pmb {b}_t)\\in \\mathbb{F}_{p^r}^n</span>  and computes  <span class="math">\\pmb {y}\\coloneqq \\pmb {v}\\cdot \\mathbf{A} + \\pmb {b}\\in \\mathbb{F}_{p^r}^n</span></li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  updates  <span class="math">\\pmb{u},\\pmb{w}</span>  by setting  <span class="math">\\pmb{u} := \\pmb{x}[0:k)\\in \\mathbb{F}_p^k</span>  and  <span class="math">\\pmb{w} := \\pmb{z}[0:k)\\in \\mathbb{F}_{p^r}^k</span> , and outputs  <span class="math">(s,M[s]):= (\\pmb{x}[k:n),\\pmb{z}[k:n))\\in \\mathbb{F}_p^\\ell \\times \\mathbb{F}_{p^r}^\\ell</span> .  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  updates  <span class="math">\\pmb{v}</span>  by setting  <span class="math">\\pmb{v} := \\pmb{y}[0:k)\\in \\mathbb{F}_{p^r}^k</span> , and outputs  <span class="math">\\mathsf{K}[s] := \\pmb{y}[k:n)\\in \\mathbb{F}_{p^r}^\\ell</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 8: The sVOLE extension protocol in the  <span class="math">(\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r},\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r})</span>  -hybrid model.</p>

    <p class="text-gray-300">Theorem 4. If the  <span class="math">\\mathsf{LPN}_{k,n,t,p}^{\\mathcal{G}}</span>  assumption holds, then  <span class="math">\\Pi_{\\mathsf{sVOLE}}^{p,r}</span>  UC-realizes  <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span>  in the  <span class="math">(\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r},\\mathcal{F}_{\\mathsf{spsVOLE}}^{p,r})</span> -hybrid model.</p>

    <p class="text-gray-300">A proof of the above can be found in Appendix B.4, where we also describe further optimizations for protocol  <span class="math">\\Pi_{\\mathrm{sVOLE}}^{p,r}</span> .</p>

    <p class="text-gray-300">In this section, we report on the performance of our sVOLE protocol and our overall ZK protocol for both boolean and arithmetic circuits. All our protocols were implemented in the EMP toolkit [WMK16], and we will release an open-source version of our code. In all our experiments, we use two Amazon EC2 instances of type m5.4xlarge with 16 vCPUs and 64 GB of RAM, using 5 threads. We artificially limit the network bandwidth as indicated in each experiment. All implementations achieve the statistical security parameter  <span class="math">\\rho \\geq 40</span>  and computational security parameter  <span class="math">\\kappa = 128</span> .</p>

    <p class="text-gray-300">We focus here on the performance of protocol  <span class="math">\\Pi_{\\mathrm{sVOLE}}^{p,r}</span>  over large fields; specifically, we fix the Mersenne prime  <span class="math">p = 2^{61} - 1</span>  and set  <span class="math">r = 1</span> . (Since  <span class="math">r = 1</span> , sVOLE is equivalent to VOLE in this case.)</p>

    <p class="text-gray-300">Parameter selection. As suggested in prior work [BCGI18, SGRR19, YWL+20], we choose the public LPN matrix  <span class="math">\\mathbf{A}</span>  as a generator of a 10-local linear code, which means that each column of  <span class="math">\\mathbf{A}</span>  contains exactly 10 (uniform) nonzero entries. This is advantageous since it means that computing each entry of  <span class="math">\\pmb{u} \\cdot \\mathbf{A}</span>  involves reading only 10 positions of  <span class="math">\\pmb{u} \\in \\mathbb{F}_p^k</span> . To ensure that reading those</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One-time setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Extend execution</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">k0</td>

            <td class="px-3 py-2 border-b border-gray-700">n0</td>

            <td class="px-3 py-2 border-b border-gray-700">t0</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">19,870</td>

            <td class="px-3 py-2 border-b border-gray-700">642,048</td>

            <td class="px-3 py-2 border-b border-gray-700">2,508</td>

            <td class="px-3 py-2 border-b border-gray-700">589,760</td>

            <td class="px-3 py-2 border-b border-gray-700">10,805,248</td>

            <td class="px-3 py-2 border-b border-gray-700">1,319</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: LPN parameters used in our VOLE protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20 Mbps</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">50 Mbps</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">100 Mbps</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">500 Mbps</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 Gbps</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Init. (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">1343</td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

            <td class="px-3 py-2 border-b border-gray-700">478</td>

            <td class="px-3 py-2 border-b border-gray-700">451</td>

            <td class="px-3 py-2 border-b border-gray-700">438</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Extend (ns/VOLE)</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">positions can be done quickly, we set  <span class="math">k</span>  so that  <span class="math">\\mathbf{u}</span>  fits in the L1 CPU cache (i.e., the size of  <span class="math">\\mathbf{u}</span>  is less than 8 MB). With  <span class="math">k</span>  fixed, for any choice of  <span class="math">n &amp;gt; k</span>  we can take the smallest  <span class="math">t</span>  for which all known attacks on the LPN problem require at least  <span class="math">2^{128}</span>  operations [BCGI18, BCG+19a]. When we apply the optimizations described at the end of the previous section to our protocol, we see that using LPN parameters  <span class="math">(n,k,t)</span>  means that each invocation of the extend procedure results in  <span class="math">n - k - t - 1</span>  usable VOLE correlations. We perform exhaustive search to find the smallest  <span class="math">n</span>  so that  <span class="math">n - k - t - 1 \\geq 10^7</span> . For the parameters of the setup phase, we follow the same step as above, except that we will ensure that  <span class="math">n_0 - k_0 - t_0 - 1 \\geq k</span> . This results in the LPN parameters shown in Table 2.</p>

    <p class="text-gray-300">Performance. We evaluate the efficiency of protocol  <span class="math">\\Pi_{\\mathrm{sVOLE}}^{p,r}</span>  in Table 3. The extend procedure requires very little communication (less than half a bit per usable VOLE correlation), and its execution time is largely unaffected by the network bandwidth above 100 Mbps. The one-time initialization only communicates 1.1 MB and takes roughly 478 milliseconds under a 100 Mbps network.</p>

    <p class="text-gray-300">In Table 4, we compare our VOLE protocol with the best known protocols that have been implemented [SGRR19, dCJV20]. Since our protocol needs an one-time setup, that can be amortized over multiple executions, we report our performance both without one-time setup (in case multiple extensions are executed), and the one with one-time setup (in case only one extension is executed). We fix the network bandwidth to 500 Mbps to match the experiments of Castro et al. [dCJV20]. Our protocol outperforms prior work even though prior work is secure only against semi-honest adversaries, whereas our protocol is secure in the malicious setting. Note in particular that the communication complexity of our protocol is orders of magnitude lower than prior work. Boyle et al.  <span class="math">\\mathrm{[BCG^{+}19a]}</span>  also proposed a maliciously secure sVOLE protocol but only implemented their protocol for the special case  <span class="math">p = 2, r = 128</span> . Based on their implementation in that case, we estimate that for our choice of  <span class="math">p</span>  their protocol would communicate roughly 0.14 bits per sVOLE;</p>

    <p class="text-gray-300">Table 3: Efficiency of our VOLE protocol as a function of network bandwidth. The communication per VOLE correlation is 0.42 bits; the overall communication of the one-time setup is 1.1 MB.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[SGRR19]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[dCJV20]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ours (w/o setup)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ours (w/ setup)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Communication (bits)</td>

            <td class="px-3 py-2 border-b border-gray-700">960</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">1.32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Execution time (ns)</td>

            <td class="px-3 py-2 border-b border-gray-700">2000</td>

            <td class="px-3 py-2 border-b border-gray-700">400</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">130</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Our VOLE protocol vs. prior protocols. We fix the network bandwidth to 500 Mbps and report the marginal cost per VOLE correlation. Running time for the protocol of Schoppmann et al. [SGRR19] is the time for communication alone; numbers for the protocol of Castro et al. [dCJV20] are taken from their paper and are based on the same network and CPU configuration but using 8 threads.</p>

    <p class="text-gray-300">however their computation is much heavier than ours and would take time at least 900 <em>ns</em> per VOLE correlation. Therefore, we believe that our protocol is still more efficient for most network bandwidth settings.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">6.2 Zero-Knowledge Proofs</h3>

    <p class="text-gray-300">We report on the performance of our ZK protocol for boolean and arithmetic circuits. In both cases, we use pipelining <em>[x10]</em> to streamline the protocol execution. This significantly reduces the memory usage (from linear in the circuit size to linear in the memory needed to evaluate the circuit non-cryptographically) and allows us to scale to very large circuits.</p>

    <p class="text-gray-300">To further reduce the memory usage for large circuits, we changed the protocol so that rather than checking the correctness of all <span class="math">C</span> multiplication gates at the end, we check blocks of <span class="math">C^{\\prime}&lt;C</span> gates at a time. This increases the round complexity to <span class="math">\\mathcal{O}(C/C^{\\prime})</span> but reduces the memory usage to <span class="math">\\mathcal{O}(C^{\\prime})</span>.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">6.2.1 Zero-Knowledge Proofs for Boolean Circuits</h4>

    <p class="text-gray-300">In the boolean setting, we check correctness of multiplication gates as in Figure 3. Theorem 1 shows that to achieve <span class="math">\\rho</span>-bit statistical security we need <span class="math">\\binom{C^{\\prime}B+c}{B}&gt;2^{\\rho}</span>. Setting <span class="math">c=B</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\binom{C^{\\prime}B+B}{B}=\\frac{\\prod_{i=1}^{B}(C^{\\prime}B+i)}{B!}=\\prod_{i=0}^{B-1}\\left(\\frac{B}{B-i}\\cdot C^{\\prime}+1\\right)\\geq C^{\\prime B},</span></p>

    <p class="text-gray-300">and so we need <span class="math">C^{\\prime}\\geq 2^{\\rho/B}</span>. For the best efficiency, we set <span class="math">B=2</span> when possible. For batched opening of authenticated values, we use the second approach described in Section 2.1 along with the Fiat-Shamir heuristic to make it non-interactive. We instantiate <span class="math">\\mathcal{F}_{\\textsf{sVOLE}}^{p,r}</span> using <span class="math">\\mathsf{Ferret}</span> <em>[YWL+20]</em> with <span class="math">p=2</span> and <span class="math">r=128</span>.</p>

    <p class="text-gray-300">Performance. The execution of our protocol can be split into two stages: input processing, whose cost is proportional to the witness length, and circuit processing, whose cost is proportional to the number of AND gates. Therefore, we measure the scalability of our ZK protocol by increasing either the witness length or the circuit size while artificially keeping the other value fixed. The experimental results in Figure 9 show that the execution time is indeed linear in both the witness length and the circuit size, with very small marginal cost for each bit of the witness or each AND gate. For example, under a 50 Mbps network, the marginal time of our protocol is 3.35 <span class="math">\\mu s</span> per bit of the witness and 0.5 <span class="math">\\mu s</span> per AND gate of the circuit.</p>

    <p class="text-gray-300">The ZKGC approach <em>[x15, x16]</em> is the only previous approach for efficient ZK proofs that scales to large circuits while using less than 10 GB of memory. The communication complexity of our protocol is roughly 15<span class="math">\\times</span> lower than the ZKGC approach. For this reason, our protocol is particularly well-suited for settings involving a low-bandwidth network.</p>

    <p class="text-gray-300">Example 1: Merkle trees. As a representative example highlighting the efficiency and scalability of our protocol, we consider proving knowledge of the <span class="math">n=2^{d}</span> leaves in a complete Merkle tree of depth <span class="math">d</span> using SHA-256 as the internal hash function, where the root digest is known to both parties. In Figure 10, we report on the running time and overall memory usage of our protocol for <span class="math">d</span> ranging from 6 to 19 (totaling 63–524,287 calls to SHA-256). Since the boolean circuit for SHA-256 has 22,573 AND gates, the largest circuit in these experiments contains more than 11 billion gates.</p>

    <p class="text-gray-300">The overall memory consumption of our protocol is about 400 MB; this is dominated by the initial generation of <span class="math">10^{7}</span> sVOLE correlations during the offline phase of the execution. During the</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 9: Scalability of Wolverine for boolean circuits.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 10: Running time and memory usage of Wolverine when proving knowledge of all leaves in a Merkle tree of a given depth.</p>

    <p class="text-gray-300">online phase, the Merkle-tree computation is implemented in a post-order, depth-first fashion so that the additional memory usage at any point corresponds only to authenticated values for  <span class="math">\\mathcal{O}(d)</span>  tree nodes (at most  <span class="math">150\\mathrm{KB}</span> ). Since this is dominated by the memory usage during the online phase, the memory usage plotted in Figure 10 is nearly constant even as  <span class="math">d</span>  increases.</p>

    <p class="text-gray-300">In Table 1, we compare the performance of our protocol to that of the state-of-the-art protocols for the same problem, in a 200 Mbps network. (There, we report on the performance of our protocol using only one thread.) We benchmarked all prior work except for Ligero [AHIV17], for which we obtained performance estimates from the authors. Spartan [Set20] uses the R1CS representation, so we conservatively assume that each SHA-256 hash requires 22,573 constraints. Virgo [ZXZS20] does not support free-XOR, and thus for each SHA-256 hash it uses roughly  <span class="math">2^{18}</span>  gates. (For this reason, the running time of Virgo for the Merkle-tree example is close to its running time for the matrix-multiplication example.) Compared to the ZKGC approach, Wolverine achieves better running time and about  <span class="math">15 \\times</span>  lower communication, which means that it will be up to  <span class="math">15 \\times</span>  faster when running in a low-bandwidth network. Compared to other protocols, we achieve at least a  <span class="math">5 \\times</span>  improvement in execution time while using less memory.</p>

    <p class="text-gray-300">Example 2: Proving existence of a bug in programs. We also apply our system to prove the existence of a bug in one out of a set of  <span class="math">n</span>  program snippets in zero knowledge (in particular, without revealing which snippet contains the bug). This problem was recently studied by Heath and Kolesnikov [HK20], who showed how to adapt the ZKGC approach using a technique called stacked garbling so as to obtain communication proportional to the size  <span class="math">\\ell</span>  of the largest program snippet, rather than the total size  <span class="math">\\mathcal{O}(n \\cdot \\ell)</span>  of all programs snippets.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of snippets</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10 Mbps</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">100 Mbps</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Stacked garbling (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">22.1</td>

            <td class="px-3 py-2 border-b border-gray-700">22.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">3.18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our protocol (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">5.2</td>

            <td class="px-3 py-2 border-b border-gray-700">20.8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.15</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Comparing Wolverine to ZKGC with stacked garbling for proving the existence of a bug in one of multiple code snippets.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DECO [ZMM+20]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Blind CA [WAP+19]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">DECO</td>

            <td class="px-3 py-2 border-b border-gray-700">Wolverine</td>

            <td class="px-3 py-2 border-b border-gray-700">Blind CA</td>

            <td class="px-3 py-2 border-b border-gray-700">Wolverine</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Execution time</td>

            <td class="px-3 py-2 border-b border-gray-700">12.6 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28 s</td>

            <td class="px-3 py-2 border-b border-gray-700">71 s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Communication</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">184 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">85.1 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8 MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Using our protocol Wolverine in ZK-enabled applications. All benchmarks are based on a 10 Mbps network and reflect the ZK component only.</p>

    <p class="text-gray-300">We performed experiments using the same programs as in the work of Heath and Kolesnikov. These result in boolean circuits whose sizes range from 70,869-90,772 AND gates and whose largest input length is 112 bits. We show the results in Table 5. Wolverine does not use the stacked garbling optimization, <span class="math">^{2}</span>  and so has communication complexity  <span class="math">\\mathcal{O}(n\\cdot \\ell)</span> . Nevertheless, for moderate values of  <span class="math">n</span> , Wolverine is still noticeably faster than ZKGC with stacked garbling. The effect is more pronounced in lower-bandwidth networks.</p>

    <p class="text-gray-300">Example 3: Accelerating ZK-enabled applications. Here we discuss the use of Wolverine in two recent applications that rely on ZK proofs. Both applications require interaction anyway, and so there is no real disadvantage to using an interactive ZK proof in these cases. We describe the applications below, and present the relevant benchmarking results in Table 6.</p>

    <p class="text-gray-300">DECO  <span class="math">\\left[\\mathrm{ZMM}^{+}20\\right]</span>  allows third-party proofs of data provenance for TLS connections, i.e., it allows a client to prove that certain data originated at a particular website. (We confirmed with the authors that interactive ZK proofs can also be used in their system.) One example considered by DECO is where a customer proves the existence of price discrimination by proving in zero knowledge that it was sent a price exceeding a certain threshold. Proving this statement involves a boolean circuit containing roughly 163,000 AND gates. In the original paper  <span class="math">\\left[\\mathrm{ZMM}^{+}20\\right]</span> , a ZK proof for this statement was implemented using libSNARK; this resulted in a short proof but required high computational overhead. When running over a 10 Mbps network, Wolverine is able to reduce the execution time of the ZK-proof component by  <span class="math">45\\times</span> , resulting in a  <span class="math">9\\times</span>  end-to-end improvement in the overall DECO protocol.</p>

    <p class="text-gray-300">A blind Certificate Authority (CA) is able to issue a valid certificate binding a party with an associated public key, without learning the party's identity. A recent proposal of a blind CA  <span class="math">\\left[\\mathrm{WAP}^{+}19\\right]</span>  required a ZK proof of a statement corresponding to a boolean circuit with roughly 2.5 million AND gates. The existing implementation used a ZK proof based on the MPC-in-the-head approach; the proof took more than 70 seconds to execute over a 10 Mbps network. Plugging Wolverine into their protocol, we improve the communication complexity by  <span class="math">30\\times</span>  and the execution time by  <span class="math">20\\times</span> , compared to the original protocol  <span class="math">\\left[\\mathrm{WAP}^{+}19\\right]</span>  for CA-proof generation.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 11: Performance of Wolverine for arithmetic circuits.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">We also evaluated Wolverine for arithmetic circuits over  <span class="math">\\mathbb{F}_p</span>  with  <span class="math">p = 2^{61} - 1</span>  using our VOLE implementation shown in Section 6.1. In this setting we check correctness of multiplication gates using the first optimization described in Section 3.2, and we use the first approach discussed in Section 2.1 for batched opening of authenticated values.</p>

    <p class="text-gray-300">Performance. Similar to the boolean case, we study the performance of Wolverine as a function of the witness length and circuit size; the experimental results are reported in in Figure 11. As the communication complexity is inherently higher for the arithmetic case than the boolean setting (since each field element is 61 bits long), we benchmarked performance in higher-bandwidth networks. Wolverine can execute proofs at a rate of about 1 million multiplication gates per second in a 500 Mbps network, and roughly 200,000 multiplication gates per second in a 50 Mbps.</p>

    <p class="text-gray-300">We are not aware of any memory-efficient ZK protocol that natively works with arithmetic circuits. While one could always convert an arithmetic circuit to a boolean circuit, this will generally impose significant overhead.</p>

    <p class="text-gray-300">Example 1: Matrix multiplication. We apply our ZK protocol to prove knowledge of two  <span class="math">n \\times n</span>  matrices whose product is a publicly known matrix. While the problem itself is meaningless, it has been used as a benchmark in prior work [BCC+16, WTS+18, XZZ+19, ZXZS20]. We experimented with  <span class="math">n</span>  ranging from 64-768 (with the witness ranging from 8,192 to over 1 million field elements), using a matrix-multiplication circuit corresponding to the naive  <span class="math">\\mathcal{O}(n^3)</span> -time algorithm. The time and memory usage of Wolverine are shown in Figure 12. The memory usage of Wolverine grows slowly as  <span class="math">n</span>  increases, and never exceeds 350 MB.</p>

    <p class="text-gray-300">As shown in Table 1, our protocol is  <span class="math">2 \\times</span>  faster than Spartan but  <span class="math">5 \\times</span>  slower than Virgo. Importantly, however, the prover memory of Wolverine is only  <span class="math">3\\%</span>  of that used by Virgo and  <span class="math">0.5\\%</span>  of that needed by Spartan.</p>

    <p class="text-gray-300">Example 2: Solutions to lattice problems. Various prior works have explored ZK proofs for the Short Integer Solution (SIS) problem. Here, we have public  <span class="math">\\mathbf{A} \\in \\mathbb{Z}_q^{n \\times m}</span>  and  <span class="math">\\pmb{t} \\in \\mathbb{Z}_q^n</span> , and the prover's goal is to convince the verifier that it knows a short  <span class="math">\\pmb{s}</span>  such that  <span class="math">\\mathbf{A}\\pmb{s} = \\pmb{t} \\mod q</span> . We evaluate Wolverine based on different notions of shortness for  <span class="math">\\pmb{s}</span>  as explained next.</p>

    <p class="text-gray-300">Baum and Nof [BN20] recently showed a ZK proof for SIS in the case where  <span class="math">s \\in \\{0,1\\}^m</span>  is a binary vector. We compare Wolverine to their protocol in Table 7. In our experiments, we use  <span class="math">q \\approx 2^{61}</span> ,  <span class="math">n = 1024</span> , and  <span class="math">m = 4096</span>  to align with the parameters used by Baum and Nof; those parameters are also sufficient for the somewhat homomorphic encryption scheme used for the SPDZ setup phase [BGV12]. As shown in Table 7, our protocol is over  <span class="math">16 \\times</span>  more efficient than the protocol of Baum and Nof even when run over a much slower network.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 12: Using Wolverine for matrix multiplication.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our ZK protocol Wolverine (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[BN20]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">50 Mbps</td>

            <td class="px-3 py-2 border-b border-gray-700">100 Mbps</td>

            <td class="px-3 py-2 border-b border-gray-700">500 Mbps</td>

            <td class="px-3 py-2 border-b border-gray-700">10 Gbps</td>

            <td class="px-3 py-2 border-b border-gray-700">10 Gbps</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">74</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">1228</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7: Running time of Wolverine vs. the protocol by Baum and Nof [BN20] for proving knowledge of an SIS solution. The solution is assumed to be a binary vector.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLS [BLS19]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aurora [BCOS20]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ENS [ENS20]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ours</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Communication</td>

            <td class="px-3 py-2 border-b border-gray-700">384 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">233 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">53 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">32.8 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8: Communication complexity of Wolverine vs. dedicated protocols for proving knowledge of an SIS solution. The solution is assumed to be a vector over  <span class="math">\\{-1,0,1\\}</span> . Numbers for prior work are taken from Esgin et al. [ENS20].</p>

    <p class="text-gray-300">In Table 8, we compare Wolverine with other ZK proofs for SIS [BLS19, BCOS20, ENS20] that apply when  <span class="math">s \\in \\{-1,0,1\\}^m</span> . Here we fix  <span class="math">q \\approx 2^{32}</span> ,  <span class="math">n = 2048</span> , and  <span class="math">m = 1024</span>  to align with prior work. We see that Wolverine uses only  <span class="math">60\\%</span>  of the communication compared to the best prior work. (We are not able to compare the running time, since it was not reported by prior work.)</p>

    <p class="text-gray-300">This material is based upon work supported in part by DARPA under Contract No. HR001120C0087. The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government. Work of Kang Yang is supported by the National Natural Science Foundation of China (Grant No. 61932019). Distribution Statement "A" (Approved for Public Release, Distribution Unlimited).</p>

    <p class="text-gray-300">[ABF+17] Toshinori Araki, Assi Barak, Jun Furukawa, Tamar Lichter, Yehuda Lindell, Ariel Nof, Kazuma Ohara, Adi Watzman, and Or Weinstein. Optimized honest-majority MPC for malicious adversaries - breaking the 1 billion-gate per second barrier. In IEEE Symp. Security and Privacy 2017, pages 843-862. IEEE, 2017.</p>

    <p class="text-gray-300">[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In ACM Conf. on Computer and Communications Security (CCS) 2017, pages 2087–2104. ACM Press, 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In IEEE Symp. Security and Privacy 2018, pages 315–334. IEEE, 2018.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Advances in Cryptology—Crypto 2019, Part III, volume 11694 of LNCS, pages 701–732. Springer, 2019.</li>

      <li>[BCC^{+}16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Advances in Cryptology—Eurocrypt 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, 2016.</li>

      <li>[BCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Advances in Cryptology—Crypto 2013, Part II, volume 8043 of LNCS, pages 90–108. Springer, 2013.</li>

      <li>[BCG^{+}17] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, and Michele Orrù. Homomorphic secret sharing: Optimizations and applications. In ACM Conf. on Computer and Communications Security (CCS) 2017, pages 2105–2122. ACM Press, 2017.</li>

      <li>[BCG^{+}19a] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Peter Rindal, and Peter Scholl. Efficient two-round OT extension and silent non-interactive secure computation. In ACM Conf. on Computer and Communications Security (CCS) 2019, pages 291–308. ACM Press, 2019.</li>

      <li>[BCG^{+}19b] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter Scholl. Efficient pseudorandom correlation generators: Silent OT extension and more. In Advances in Cryptology—Crypto 2019, Part III, volume 11694 of LNCS, pages 489–518. Springer, 2019.</li>

      <li>[BCGI18] Elette Boyle, Geoffroy Couteau, Niv Gilboa, and Yuval Ishai. Compressing vector OLE. In ACM Conf. on Computer and Communications Security (CCS) 2018, pages 896–912. ACM Press, 2018.</li>

      <li>[BCOS20] Cecilia Boschini, Jan Camenisch, Max Ovsiankin, and Nicholas Spooner. Efficient post-quantum SNARKs for RSIS and RLWE and their applications to privacy. In PQCrypto 2020, pages 247–267. Springer, April 9–11 2020.</li>

      <li>[BCR^{+}19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Advances in Cryptology—Eurocrypt 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, 2019.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In USENIX Security Symposium 2014, pages 781–796. USENIX Association, 2014.</li>

    </ul>

    <p class="text-gray-300">[Bea92] Donald Beaver. Efficient multiparty protocols using circuit randomization. In Advances in Cryptology—Crypto 1991, LNCS, pages 420–432. Springer, 1992.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Advances in Cryptology—Eurocrypt 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, 2020.</li>

      <li>[BGI15] Elette Boyle, Niv Gilboa, and Yuval Ishai. Function secret sharing. In Advances in Cryptology—Eurocrypt 2015, Part II, volume 9057 of LNCS, pages 337–367. Springer, 2015.</li>

      <li>[BGI16] Elette Boyle, Niv Gilboa, and Yuval Ishai. Function secret sharing: Improvements and extensions. In ACM Conf. on Computer and Communications Security (CCS) 2016, pages 1292–1303. ACM Press, 2016.</li>

      <li>[BGV12] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (Leveled) fully homomorphic encryption without bootstrapping. In ITCS 2012, pages 309–325, Cambridge, MA, USA, January 8–10, 2012. Association for Computing Machinery.</li>

      <li>[BLS19] Jonathan Bootle, Vadim Lyubashevsky, and Gregor Seiler. Algebraic techniques for short(er) exact lattice-based zero-knowledge proofs. In Advances in Cryptology—Crypto 2019, Part I, volume 11692 of LNCS, pages 176–202. Springer, 2019.</li>

      <li>[BMRS20] Carsten Baum, Alex J. Malozemoff, Marc Rosen, and Peter Scholl. Mac’n’cheese: Zero-knowledge proofs for arithmetic circuits with nested disjunctions. Cryptology ePrint Archive, Report 2020/1410, 2020. https://eprint.iacr.org/2020/1410.</li>

      <li>[BN20] Carsten Baum and Ariel Nof. Concretely-efficient zero-knowledge arguments for arithmetic circuits and their application to lattice-based cryptography. In Intl. Conference on Theory and Practice of Public Key Cryptography 2020, Part I, LNCS, pages 495–526. Springer, 2020.</li>

      <li>[Can01] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd Annual Symposium on Foundations of Computer Science (FOCS), pages 136–145. IEEE, 2001.</li>

      <li>[CDE^{+}18] Ronald Cramer, Ivan Damgård, Daniel Escudero, Peter Scholl, and Chaoping Xing. SPD <span class="math">\\mathbb{Z}_{2^{k}}</span>: Efficient MPC mod <span class="math">2^{k}</span> for dishonest majority. In Advances in Cryptology—Crypto 2018, Part II, volume 10992 of LNCS, pages 769–798. Springer, 2018.</li>

      <li>[CDG^{+}17] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In ACM Conf. on Computer and Communications Security (CCS) 2017, pages 1825–1842. ACM Press, 2017.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Advances in Cryptology—Eurocrypt 2020, Part I, volume 12105 of LNCS, pages 769–793. Springer, 2020.</li>

      <li>[dCJV20] Leo de Castro, Chiraag Juvekar, and Vinod Vaikuntanathan. Fast vector oblivious linear evaluation from ring learning with errors. Cryptology ePrint Archive, Report 2020/685, 2020. https://eprint.iacr.org/2020/685.</li>

    </ul>

    <p class="text-gray-300">[DOS19] Cyprien de Saint Guilhem, Lauren De Meyer, Emmanuela Orsini, and Nigel P. Smart. BBQ: Using AES in picnic signatures. In Annual International Workshop on Selected Areas in Cryptography (SAC) 2019, LNCS, pages 669–692. Springer, 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DIO20] Samuel Dittmer, Yuval Ishai, and Rafail Ostrovsky. Line-point zero knowledge and its applications. Cryptology ePrint Archive, Report 2020/1446, 2020. https://eprint.iacr.org/2020/1446.</li>

      <li>[DPSZ12] Ivan Damgård, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. Multiparty computation from somewhat homomorphic encryption. In Advances in Cryptology—Crypto 2012, volume 7417 of LNCS, pages 643–662. Springer, 2012.</li>

      <li>[ENS20] Muhammed F. Esgin, Ngoc Khanh Nguyen, and Gregor Seiler. Practical exact proofs from lattices: New techniques to exploit fully-splitting rings, 2020.</li>

      <li>[FNO15] Tore Kasper Frederiksen, Jesper Buus Nielsen, and Claudio Orlandi. Privacy-free garbled circuits with applications to efficient zero-knowledge. In Advances in Cryptology—Eurocrypt 2015, Part II, volume 9057 of LNCS, pages 191–219. Springer, 2015.</li>

      <li>[GGM86] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. J. ACM, 33(4):792–807, October 1986.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Advances in Cryptology—Eurocrypt 2013, LNCS, pages 626–645. Springer, 2013.</li>

      <li>[Gil99] Niv Gilboa. Two party RSA key generation. In Advances in Cryptology—Crypto 1999, volume 1666 of LNCS, pages 116–129. Springer, 1999.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In 40th Annual ACM Symposium on Theory of Computing (STOC), pages 113–122. ACM Press, 2008.</li>

      <li>[GMO16] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. ZKBoo: Faster zero-knowledge for Boolean circuits. In USENIX Security Symposium 2016, pages 1069–1083. USENIX Association, 2016.</li>

      <li>[GMR85] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In 17th Annual ACM Symposium on Theory of Computing (STOC), pages 291–304. ACM Press, 1985.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness theorem for protocols with honest majority. In 19th Annual ACM Symposium on Theory of Computing (STOC), pages 218–229. ACM Press, 1987.</li>

      <li>[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. J. ACM, 38(3):691–729, 1991.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Advances in Cryptology—Asiacrypt 2010, LNCS, pages 321–340. Springer, 2010.</li>

    </ul>

    <p class="text-gray-300">[HEKM11] Yan Huang, David Evans, Jonathan Katz, and Lior Malka. Faster secure two-party computation using garbled circuits. In USENIX Security Symposium 2011. USENIX Association, 2011.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[HK20] David Heath and Vladimir Kolesnikov. Stacked garbling for disjunctive zero-knowledge proofs. In Advances in Cryptology—Eurocrypt 2020, Part III, volume 12107 of LNCS, pages 569–598. Springer, 2020.</li>

      <li>[HOSS18] Carmit Hazay, Emmanuela Orsini, Peter Scholl, and Eduardo Soria-Vazquez. TinyKeys: A new approach to efficient multi-party computation. In Advances in Cryptology—Crypto 2018, Part III, volume 10993 of LNCS, pages 3–33. Springer, 2018.</li>

      <li>[IKNP03] Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank. Extending oblivious transfers efficiently. In Advances in Cryptology—Crypto 2003, volume 2729 of LNCS, pages 145–161. Springer, 2003.</li>

      <li>[IKOS07] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge from secure multiparty computation. In 39th Annual ACM Symposium on Theory of Computing (STOC), pages 21–30. ACM Press, 2007.</li>

      <li>[ILL89] Russell Impagliazzo, Leonid A. Levin, and Michael Luby. Pseudo-random generation from one-way functions (extended abstracts). In 21st Annual ACM Symposium on Theory of Computing (STOC), pages 12–24. ACM Press, 1989.</li>

      <li>[JKO13] Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. Zero-knowledge using garbled circuits: how to prove non-algebraic statements efficiently. In ACM Conf. on Computer and Communications Security (CCS) 2013, pages 955–966. ACM Press, 2013.</li>

      <li>[KKW18] Jonathan Katz, Vladimir Kolesnikov, and Xiao Wang. Improved non-interactive zero knowledge with applications to post-quantum signatures. In ACM Conf. on Computer and Communications Security (CCS) 2018, pages 525–537. ACM Press, 2018.</li>

      <li>[KOS15] Marcel Keller, Emmanuela Orsini, and Peter Scholl. Actively secure OT extension with optimal overhead. In Advances in Cryptology—Crypto 2015, Part I, volume 9215 of LNCS, pages 724–741. Springer, 2015.</li>

      <li>[KOS16] Marcel Keller, Emmanuela Orsini, and Peter Scholl. MASCOT: Faster malicious arithmetic secure computation with oblivious transfer. In ACM Conf. on Computer and Communications Security (CCS) 2016, pages 830–842. ACM Press, 2016.</li>

      <li>[NNOB12] Jesper Buus Nielsen, Peter Sebastian Nordholt, Claudio Orlandi, and Sai Sheshank Burra. A new approach to practical active-secure two-party computation. In Advances in Cryptology—Crypto 2012, volume 7417 of LNCS, pages 681–700. Springer, 2012.</li>

      <li>[NO09] Jesper Buus Nielsen and Claudio Orlandi. LEGO for two-party secure computation. In 6th Theory of Cryptography Conference—TCC 2009, volume 5444 of LNCS, pages 368–386. Springer, 2009.</li>

      <li>[Set20] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Advances in Cryptology—Crypto 2020, Part III, LNCS, pages 704–737. Springer, 2020.</li>

    </ul>

    <p class="text-gray-300">[SGRR19] Phillipp Schoppmann, Adrià Gascón, Leonie Reichert, and Mariana Raykova. Distributed vector-OLE: Improved constructions and implementation. In ACM Conf. on Computer and Communications Security (CCS) 2019, pages 1055–1072. ACM Press, 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[WAP^{+}19] Liang Wang, Gilad Asharov, Rafael Pass, Thomas Ristenpart, and Abhi Shelat. Blind certificate authorities. In IEEE Symp. Security and Privacy 2019, pages 1015–1032. IEEE, 2019.</li>

      <li>[WMK16] Xiao Wang, Alex J. Malozemoff, and Jonathan Katz. EMP-toolkit: Efficient Multi-Party computation toolkit. https://github.com/emp-toolkit, 2016.</li>

      <li>[WTS^{+}18] Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In IEEE Symp. Security and Privacy 2018, pages 926–943. IEEE, 2018.</li>

      <li>[XZZ^{+}19] Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In Advances in Cryptology—Crypto 2019, Part III, volume 11694 of LNCS, pages 733–764. Springer, 2019.</li>

      <li>[YWL^{+}20] Kang Yang, Chenkai Weng, Xiao Lan, Jiang Zhang, and Xiao Wang. Ferret: Fast extension for correlated OT with small communication. In ACM Conf. on Computer and Communications Security (CCS) 2020, pages 1607–1626. ACM Press, 2020.</li>

      <li>[YWZ20] Kang Yang, Xiao Wang, and Jiang Zhang. More efficient MPC from improved triple generation and authenticated garbling. In ACM Conf. on Computer and Communications Security (CCS) 2020, pages 1627–1646. ACM Press, 2020.</li>

      <li>[ZMM^{+}20] Fan Zhang, Deepak Maram, Harjasleen Malvai, Steven Goldfeder, and Ari Juels. DECO: Liberating web data using decentralized oracles for TLS. In ACM Conf. on Computer and Communications Security (CCS) 2020, pages 1919–1938. ACM Press, 2020.</li>

      <li>[ZRE15] Samee Zahur, Mike Rosulek, and David Evans. Two halves make a whole - reducing data transfer in garbled circuits using half gates. In Advances in Cryptology—Eurocrypt 2015, Part II, volume 9057 of LNCS, pages 220–250. Springer, 2015.</li>

      <li>[ZXZS20] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. Transparent polynomial delegation and its applications to zero knowledge proof. In IEEE Symp. Security and Privacy 2020, pages 859–876. IEEE, 2020.</li>

    </ul>

    <h2 id="sec-39" class="text-2xl font-bold">Appendix A Other Functionalities</h2>

    <p class="text-gray-300">We review the standard ideal functionality for oblivious transfer (OT) in Figure 13.</p>

    <p class="text-gray-300">In Figure 14 we define a functionality <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> implementing a weak equality test that reveals <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>’s input to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. This functionality can be easily realized as follows: (1) <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> commits to <span class="math">V_{\\mathsf{B}}</span>; (2) <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> sends <span class="math">V_{\\mathsf{A}}</span> to <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>; (3) <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> outputs (<span class="math">V_{\\mathsf{A}}\\stackrel{{\\scriptstyle?}}{{=}}V_{\\mathsf{B}}</span>) and aborts if they are not equal, and then opens <span class="math">V_{\\mathsf{B}}</span>; (4) if <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> opened its commitment to a value <span class="math">V_{\\mathsf{B}}</span>, then <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> outputs (<span class="math">V_{\\mathsf{A}}\\stackrel{{\\scriptstyle?}}{{=}}V_{\\mathsf{B}}</span>); otherwise it aborts. UC commitments can be realized efficiently in the random-oracle model.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On receiving  <span class="math">(m_0, m_1)</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  from a sender  </span>\\mathsf{P}_{\\mathsf{A}}<span class="math">  and  </span>b \\in \\{0, 1\\}<span class="math">  from a receiver  </span>\\mathsf{P}_{\\mathsf{B}}<span class="math"> , send  </span>m_b<span class="math">  to  </span>\\mathsf{P}_{\\mathsf{B}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 13: The OT functionality between  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</p>

    <p class="text-gray-300">Upon receiving  <span class="math">V_{\\mathsf{A}}</span>  from  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  and  <span class="math">V_{\\mathsf{B}}</span>  from  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , send  <span class="math">(V_{\\mathsf{A}} \\stackrel{?}{=} V_{\\mathsf{B}})</span>  and  <span class="math">V_{\\mathsf{A}}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> , and do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is honest and  <span class="math">V_{\\mathsf{A}} = V_{\\mathsf{B}}</span> , or is corrupted and sends continue, then send  <span class="math">(V_{\\mathsf{A}} \\stackrel{?}{=} V_{\\mathsf{B}})</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> .</li>

      <li>If  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is honest and  <span class="math">V_{\\mathsf{A}} \\neq V_{\\mathsf{B}}</span> , or is corrupted and sends abort, then send abort to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 14: Functionality for a weak equality test.</p>

    <p class="text-gray-300">We describe two approaches for batch checking of authenticated values. The first relies on a cryptographic hash function  <span class="math">\\mathsf{H}</span> . Specifically,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends (in addition to the values  <span class="math">x_{1},\\ldots ,x_{\\ell}</span>  themselves) a digest  <span class="math">h\\coloneqq \\mathsf{H}(\\mathsf{M}[x_1],\\ldots ,\\mathsf{M}[x_\\ell])</span>  of all the MAC tags;  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  then checks that  <span class="math">h\\stackrel {?}{=}\\mathsf{H}(\\mathsf{K}[x_1] + \\Delta \\cdot x_1,\\ldots ,\\mathsf{K}[x_\\ell ] + \\Delta \\cdot x_\\ell)</span> . Modeling  <span class="math">\\mathsf{H}</span>  as a random oracle with  <span class="math">2\\kappa</span> -bit output, it is not hard to see that the soundness error (i.e., the probability that  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  can successfully cheat about any value) is upper bounded by  <span class="math">(q_{\\mathsf{H}}^{2} + 1) / 2^{2\\kappa} + 1 / p^{r}</span> , where  <span class="math">q_{\\mathsf{H}}</span>  denotes the number of queries that  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  makes to  <span class="math">\\mathsf{H}</span> . The communication overhead is only  <span class="math">2\\kappa</span>  bits, independent of  <span class="math">\\ell</span> .</p>

    <p class="text-gray-300">The second approach, which is information theoretic, works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends  <span class="math">x_{1},\\ldots ,x_{\\ell}\\in \\mathbb{F}_{p}</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span></li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  picks uniform  <span class="math">\\chi_1,\\ldots ,\\chi_\\ell \\in \\mathbb{F}_{p^r}</span>  and sends them to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span></li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  computes  <span class="math">\\mathsf{M}[x] := \\sum_{i=1}^{\\ell} \\chi_i \\cdot \\mathsf{M}[x_i]</span> , and sends it to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  computes  <span class="math">x\\coloneqq \\sum_{i = 1}^{\\ell}\\chi_{i}\\cdot x_{i}\\in \\mathbb{F}_{p^{r}}</span>  and  <span class="math">\\mathsf{K}[x]\\coloneqq \\sum_{i = 1}^{\\ell}\\chi_{i}\\cdot \\mathsf{K}[x_{i}]\\in \\mathbb{F}_{p^{r}}</span> . It accepts the opened values if and only if  <span class="math">\\mathsf{M}[x] = \\mathsf{K}[x] + \\Delta \\cdot x</span> .</li>

    </ol>

    <p class="text-gray-300">The soundness error of this approach is given by Lemma 2.</p>

    <p class="text-gray-300">Lemma 2. Let  <span class="math">x_{1},\\ldots ,x_{\\ell}\\in \\mathbb{F}_{p}</span>  and  <span class="math">\\mathsf{M}[x_1],\\ldots ,\\mathsf{M}[x_\\ell ]\\in \\mathbb{F}_{p^r}</span>  be arbitrary values known to  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  , and let  <span class="math">\\Delta</span>  and  <span class="math">\\{\\mathsf{K}[x_i] = \\mathsf{M}[x_i] - \\Delta \\cdot x_i\\}_{i = 1}^{\\ell}</span>  , for uniform  <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span>  , be given to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  . The probability that  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  can successfully open values  <span class="math">(x_1&#x27;,\\dots,x_\\ell&#x27;)\\neq (x_1,\\dots,x_\\ell)</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  is at most  <span class="math">2 / p^{r}</span></p>

    <p class="text-gray-300">Proof. Fix  <span class="math">(x_1&#x27;,\\ldots ,x_\\ell &#x27;)\\neq (x_1,\\ldots ,x_\\ell)</span>  sent by  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  in the first step. If we let  <span class="math">\\omega \\stackrel {\\mathrm{def}}{=}\\sum_{i = 1}^{\\ell}\\chi_i\\cdot (x_i&#x27; - x_i)</span> , then the probability (over uniform choice of  <span class="math">\\{\\chi_i\\}</span> ) that  <span class="math">\\omega = 0</span>  is at most  <span class="math">1 / p^{r}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">m = \\lceil \\log p \\rceil</span>  and PRF be a keyed function.</p>

    <p class="text-gray-300">Initialize: This initialization procedure is executed only once.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\in [rm]</span> ,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  samples  <span class="math">K_0^i, K_1^i \\gets \\{0, 1\\}^n</span> .  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  samples  <span class="math">\\Delta \\gets \\mathbb{F}_{p^r}</span>  and lets  <span class="math">\\Delta_B = (\\Delta_1, \\ldots, \\Delta_{rm}) \\in \\{0, 1\\}^{rm}</span>  be its bit-decomposition.</li>

      <li>For  <span class="math">i \\in [rm]</span> ,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends  <span class="math">(K_0^i, K_1^i)</span>  to  <span class="math">\\mathcal{F}_{\\mathsf{OT}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  sends  <span class="math">\\Delta_i \\in \\{0, 1\\}</span>  to  <span class="math">\\mathcal{F}_{\\mathsf{OT}}</span> , which returns  <span class="math">K_{\\Delta_i}^i</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> .</li>

    </ol>

    <p class="text-gray-300">Extend: This procedure can be executed multiple times. For the  <span class="math">j</span> th input  <span class="math">u \\in \\mathbb{F}_p</span>  from  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> , the parties execute the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\in [rm]</span> , do the following in parallel:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sets  <span class="math">w_0^i \\coloneqq \\mathsf{PRF}(K_0^i, j)</span>  and  <span class="math">w_1^i \\coloneqq \\mathsf{PRF}(K_1^i, j)</span>  with  <span class="math">w_0^i, w_1^i \\in \\mathbb{F}_p</span> ;  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  computes  <span class="math">w_{\\Delta_i}^i \\coloneqq \\mathsf{PRF}(K_{\\Delta_i}^i, j)</span> . (b)  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends  <span class="math">\\tau^i \\coloneqq w_0^i - w_1^i - u \\in \\mathbb{F}_p</span>  to  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> . (c)  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  computes  <span class="math">v^{i}\\coloneqq w_{\\Delta_{i}}^{i} + \\Delta_{i}\\cdot \\tau^{i} = w_{0}^{i} - \\Delta_{i}\\cdot u\\in \\mathbb{F}_{p}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\pmb{v} = (v^{1},\\dots,v^{rm})</span>  and  <span class="math">\\pmb{w} = (w_0^1,\\dots,w_0^{rm})</span>  such that  <span class="math">\\pmb{w} = \\pmb{v} + u\\cdot \\pmb{\\Delta}_B\\in \\mathbb{F}_p^{rm}</span></li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  outputs  <span class="math">w = \\langle \\pmb {g},\\pmb {w}\\rangle \\in \\mathbb{F}_{p^r}</span>  and  <span class="math">\\mathsf{P_B}</span>  outputs  <span class="math">v = \\langle \\pmb {g},\\pmb {v}\\rangle \\in \\mathbb{F}_{p^r}</span> , where  <span class="math">w = v + \\Delta \\cdot u\\in \\mathbb{F}_{p^r}</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 15: COPEe protocol in the  <span class="math">\\mathcal{F}_{\\mathrm{OT}}</span> -hybrid model.</p>

    <p class="text-gray-300">Assume  <span class="math">\\omega \\neq 0</span> . If  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  sends  <span class="math">\\mathsf{M} \\in \\mathbb{F}_{p^r}</span> , then  <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>  accepts only if</p>

    <p class="text-gray-300">M =  <span class="math">\\sum_{i=1}^{\\ell} \\chi_i \\cdot \\mathsf{K}[x_i] + \\Delta \\cdot \\sum_{i=1}^{\\ell} \\cdot \\chi_i \\cdot x_i&#x27;</span> <span class="math">= \\sum_{i = 1}^{\\ell}\\chi_{i}\\cdot (\\mathsf{M}[x_{i}] - \\Delta \\cdot x_{i}) + \\Delta \\cdot \\sum_{i = 1}^{\\ell}\\chi_{i}\\cdot x_{i}^{\\prime}</span> <span class="math">= \\sum_{i = 1}^{\\ell}\\chi_{i}\\cdot \\mathsf{M}[x_{i}] + \\Delta \\cdot \\omega .</span></p>

    <p class="text-gray-300">Everything in the final expression is fixed except for  <span class="math">\\Delta</span> . Moreover,  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  succeeds iff  <span class="math">\\Delta = \\omega^{-1} \\cdot (\\mathsf{M} - \\sum_{i=1}^{\\ell} \\chi_i \\cdot \\mathsf{M}[x_i])</span> , which occurs with probability  <span class="math">1/p^r</span> .</p>

    <p class="text-gray-300">We can make the second approach non-interactive, using the Fiat-Shamir heuristic in the random-oracle model, by computing the coefficients  <span class="math">\\{\\chi_i\\}</span>  as the output of a hash function  <span class="math">\\mathsf{H}</span>  evaluated on the values  <span class="math">\\{x_i\\}</span>  sent by  <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>  in the first step. Adapting the above proof, one can show that this has soundness error at most  <span class="math">(q_{\\mathsf{H}} + 2) / p^r</span> .</p>

    <p class="text-gray-300">In Figure 15, we present a protocol  <span class="math">\\Pi_{\\mathsf{COPEe}}^{p,r}</span>  that UC-realizes  <span class="math">\\mathcal{F}_{\\mathsf{COPEe}}^{p,r}</span>  in the  <span class="math">\\mathcal{F}_{\\mathsf{OT}}</span> -hybrid model. This protocol follows the construction of Keller et al. [KOS16], which is in turn based on the IKNP OT-extension protocol [IKNP03] and Gilboa's approach [Gil99] for oblivious product evaluation. The main difference from prior work is that we support the subfield case.</p>

    <p class="text-gray-300">Lemma 3. If <span class="math">\\mathsf{PRF}</span> is a pseudorandom function, then <span class="math">\\Pi_{\\mathsf{COPEe}}^{p,r}</span> UC-realizes <span class="math">\\mathcal{F}_{\\mathsf{COPEe}}^{p,r}</span> in the <span class="math">\\mathcal{F}_{\\mathsf{OT}}</span>-hybrid model.</p>

    <p class="text-gray-300">The proof of Lemma 3 can be straightforwardly obtained by following the proof of Keller et al. [KOS16], and is thus omitted.</p>

    <h2 id="sec-45" class="text-2xl font-bold">B.2 Proof of Theorem 2</h2>

    <p class="text-gray-300">Recall that our protocol <span class="math">\\Pi_{\\text{base-sVOLE}}^{p,r}</span> is established over the sub-protocol <span class="math">\\Pi_{\\text{base-LsVOLE}}^{p,r}</span> with a selective-failure leakage on <span class="math">\\Delta</span> (the first part of Figure 5). Thus, we first prove that protocol <span class="math">\\Pi_{\\text{base-LsVOLE}}^{p,r}</span> UC-realizes functionality <span class="math">\\mathcal{F}_{\\text{LsVOLE}}^{p,r}</span>, where <span class="math">\\mathcal{F}_{\\text{LsVOLE}}^{p,r}</span> is the same as <span class="math">\\mathcal{F}_{\\text{sVOLE}}^{p,r}</span> except that the global-key query is replaced with the following selective-failure queries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wait for the adversary to input <span class="math">(\\mathsf{guess}, S)</span> where <span class="math">S</span> efficiently describes a subset of <span class="math">\\mathbb{F}_{p^r}</span>. If <span class="math">\\Delta \\in S</span>, then send success to the adversary and continue. Otherwise, send abort to both parties and abort.</li>

    </ul>

    <p class="text-gray-300">Based on the leftover hash lemma [ILL89], we can prove that the full protocol (the second part of Figure 5) UC-realizes <span class="math">\\mathcal{F}_{\\text{sVOLE}}^{p,r}</span> in the <span class="math">\\mathcal{F}_{\\text{LsVOLE}}^{p,\\ell \\cdot r}</span>-hybrid model, where the resulting global key <span class="math">\\Gamma</span> is uniform in <span class="math">\\mathbb{F}_{p^r}</span> except with probability at most <span class="math">1 / 2^{\\rho}</span>, as the inner product defines a universal hash function. Replacing <span class="math">\\mathcal{F}_{\\text{LsVOLE}}^{p,\\ell \\cdot r}</span> with sub-protocol <span class="math">\\Pi_{\\text{LsVOLE}}^{p,\\ell \\cdot r}</span>, we obtain that protocol <span class="math">\\Pi_{\\text{base-sVOLE}}^{p,r}</span> UC-realizes <span class="math">\\mathcal{F}_{\\text{sVOLE}}^{p,r}</span>.</p>

    <p class="text-gray-300">Below, we focus on proving that sub-protocol <span class="math">\\Pi_{\\text{base-LsVOLE}}^{p,r}</span> UC-realizes <span class="math">\\mathcal{F}_{\\text{LsVOLE}}^{p,r}</span>. We first consider the case of a malicious <span class="math">\\mathsf{P_A}</span> and then consider the case of a malicious <span class="math">\\mathsf{P_B}</span>. In each case, we construct a PPT simulator <span class="math">\\mathcal{S}</span> that runs a PPT adversary <span class="math">\\mathcal{A}</span> as a subroutine and emulates <span class="math">\\mathcal{F}_{\\mathsf{COPEe}}^{p,r}</span>. We always implicitly assume that <span class="math">\\mathcal{S}</span> passes all communication between <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span>.</p>

    <p class="text-gray-300">Malicious <span class="math">\\mathsf{P_A}</span>. Given access to <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}, \\mathcal{S}</span> interacts with <span class="math">\\mathcal{A}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathsf{COPEe}}^{p,r}</span>, and receives <span class="math">(w_{i}, \\boldsymbol{u}_{i})</span> for <span class="math">i \\in [0, n)</span> and <span class="math">(c_{h}, \\boldsymbol{a}_{h})</span> for <span class="math">h \\in [0, r)</span> from <span class="math">\\mathcal{A}</span>, where <span class="math">\\boldsymbol{u}_{i}, \\boldsymbol{a}_{h} \\in \\mathbb{F}_{p}^{rm}</span> and <span class="math">m = \\lceil \\log p \\rceil</span>. (In the honest case, we have that <span class="math">\\boldsymbol{u}_{i} = (u_{i}, \\dots, u_{i})</span> for some <span class="math">u_{i} \\in \\mathbb{F}_{p}</span> and <span class="math">\\boldsymbol{a}_{h} = (a_{h}, \\dots, a_{h})</span> for some <span class="math">a_{h} \\in \\mathbb{F}_{p}</span>.)</li>

      <li><span class="math">\\mathcal{S}</span> samples <span class="math">\\chi_0, \\ldots, \\chi_{n-1} \\gets \\mathbb{F}_{p^r}</span> and sends them to <span class="math">\\mathcal{A}</span>. Then, <span class="math">\\mathcal{S}</span> receives <span class="math">x \\in \\mathbb{F}_{p^r}</span> and <span class="math">z \\in \\mathbb{F}_{p^r}</span> from <span class="math">\\mathcal{A}</span>. Next, <span class="math">\\mathcal{S}</span> computes an adversarially chosen error</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e _ {z} := z - \\sum_ {i = 0} ^ {n - 1} \\chi_ {i} \\cdot w _ {i} - \\sum_ {h = 0} ^ {r - 1} c _ {h} \\cdot \\mathrm {X} ^ {h} \\in \\mathbb {F} _ {p ^ {r}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> computes a set <span class="math">S_{\\Delta}</span> as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Solve the following equation:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\langle \\boldsymbol {g} \\cdot x - \\boldsymbol {g} * \\sum_ {i = 0} ^ {n - 1} \\chi_ {i} \\cdot \\boldsymbol {u} _ {i} - \\boldsymbol {g} * \\sum_ {h = 0} ^ {r - 1} \\boldsymbol {a} _ {h} \\cdot \\mathrm {X} ^ {h}, \\boldsymbol {\\Delta} _ {B} \\right\\rangle = e _ {z} \\tag {1}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each solution <span class="math">\\pmb{\\Delta}_{B}</span>, compute <span class="math">\\Delta \\coloneqq \\langle \\pmb{g},\\pmb{\\Delta}_B\\rangle</span> and add <span class="math">\\Delta</span> to the set <span class="math">S_{\\Delta}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> sends (guess, <span class="math">S_{\\Delta}</span>) to <span class="math">\\mathcal{F}_{\\text{LsVOLE}}^{p,r}</span>. If receiving abort from <span class="math">\\mathcal{F}_{\\text{LsVOLE}}^{p,r}</span>, <span class="math">\\mathcal{S}</span> aborts. Otherwise, <span class="math">\\mathcal{S}</span> continues the simulation.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> computes another set <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span> as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Solve the following equation:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left\\langle\\bm{g}\\cdot x-\\bm{g}<em>\\sum_{i=0}^{n-1}\\chi_{i}\\cdot\\bm{u}_{i}-\\bm{g}</em>\\sum_{h=0}^{r-1}\\bm{a}_{h}\\cdot\\mathsf{X}^{h},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle=0</span> (2)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each solution <span class="math">\\tilde{\\bm{\\Delta}}_{B}</span>, compute <span class="math">\\tilde{\\Delta}:=\\left\\langle\\bm{g},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle</span> and add <span class="math">\\tilde{\\Delta}</span> into the set <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span> only involves a single entry <span class="math">0</span>, then <span class="math">\\mathcal{S}</span> aborts. Otherwise, <span class="math">\\mathcal{S}</span> chooses any nonzero element <span class="math">\\tilde{\\Delta}\\in\\tilde{S}_{\\tilde{\\Delta}}</span>, and then for <span class="math">i\\in[0,n)</span>, computes</li>

    </ol>

    <p class="text-gray-300"><span class="math">u_{i}:=\\tilde{\\Delta}^{-1}\\cdot\\left\\langle\\bm{g}*\\bm{u}_{i},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle</span> (3)</p>

    <p class="text-gray-300">where <span class="math">\\left\\langle\\bm{g},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle=\\tilde{\\Delta}</span>. (In the following analysis, we will show that <span class="math">u_{i}</span> is unique over all possible <span class="math">\\tilde{\\Delta}</span> in set <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span>.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i\\in[0,n)</span>, <span class="math">\\mathcal{S}</span> computes an adversarially chosen error <span class="math">\\bm{e}_{i}:=\\bm{u}_{i}-(u_{i},\\ldots,u_{i})\\in\\mathbb{F}_{p}^{rm}</span>, and then computes <span class="math">w^{\\prime}_{i}:=w_{i}-\\left\\langle\\bm{g}*\\bm{e}_{i},\\bm{\\Delta}_{B}\\right\\rangle\\in\\mathbb{F}_{p^{r}}</span> for any <span class="math">\\bm{\\Delta}_{B}</span> such that <span class="math">\\left\\langle\\bm{g},\\bm{\\Delta}_{B}\\right\\rangle\\in S_{\\Delta}</span>. Then, <span class="math">\\mathcal{S}</span> sends <span class="math">\\bm{u}=(u_{0},\\ldots,u_{n-1})</span> and <span class="math">\\bm{w}=(w^{\\prime}_{0},\\ldots,w^{\\prime}_{n-1})</span> to functionality <span class="math">\\mathcal{F}^{p,r}_{\\textsc{LsVOLE}}</span>.</li>

    </ol>

    <p class="text-gray-300">The simulation for the protocol transcript is straightforward. Below, we first consider the case of <span class="math">p=2</span>, and later discuss the case of a prime <span class="math">p&gt;2</span>. In the real protocol execution, the correlation check has the following equation:</p>

    <p class="text-gray-300"><span class="math">x\\cdot\\Delta=z-y=\\sum_{i=0}^{n-1}\\chi_{i}\\cdot(w_{i}-v_{i})+\\sum_{h=0}^{r-1}(c_{h}-b_{h})\\cdot\\mathsf{X}^{h}+e_{z}</span> (4)</p>

    <p class="text-gray-300">For a malicious <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>, we have that <span class="math">w_{i}-v_{i}=\\left\\langle\\bm{g}<em>\\bm{u}_{i},\\bm{\\Delta}_{B}\\right\\rangle</span> for <span class="math">i\\in[0,n)</span> and <span class="math">c_{h}-b_{h}=\\left\\langle\\bm{g}</em>\\bm{a}_{h},\\bm{\\Delta}_{B}\\right\\rangle</span> for <span class="math">h\\in[0,r)</span>. Thus, we can rewrite equation (4) as follows:</p>

    <p class="text-gray-300"><span class="math">x\\cdot\\Delta-\\sum_{i=0}^{n-1}\\chi_{i}\\cdot\\left\\langle\\bm{g}<em>\\bm{u}_{i},\\bm{\\Delta}_{B}\\right\\rangle-\\sum_{h=0}^{r-1}\\left\\langle\\bm{g}</em>\\bm{a}_{h},\\bm{\\Delta}_{B}\\right\\rangle\\cdot\\mathsf{X}^{h}=e_{z}</span> <span class="math">\\Leftrightarrow\\left\\langle\\bm{g}\\cdot x-\\bm{g}<em>\\sum_{i=0}^{n-1}\\chi_{i}\\cdot\\bm{u}_{i}-\\bm{g}</em>\\sum_{h=0}^{r-1}\\bm{a}_{h}\\cdot\\mathsf{X}^{h},\\bm{\\Delta}_{B}\\right\\rangle=e_{z}.</span></p>

    <p class="text-gray-300">Therefore, the set <span class="math">S_{\\Delta}</span> corresponds to <span class="math">\\mathcal{A}</span>’s guess of <span class="math">\\Delta</span>, and the probability of aborting in the ideal-world execution is the same as that in the real-world execution.</p>

    <p class="text-gray-300">For any two different solutions <span class="math">\\Delta,\\Delta^{\\prime}\\in S_{\\Delta}</span>, we define <span class="math">\\tilde{\\Delta}=\\Delta-\\Delta^{\\prime}\\in\\mathbb{F}_{p^{r}}</span> and thus <span class="math">\\tilde{\\bm{\\Delta}}_{B}=\\bm{\\Delta}_{B}-\\bm{\\Delta}^{\\prime}_{B}\\in\\{0,1\\}^{rm}</span>. From equation (1), we easily obtain that equation (2) holds. This also shows that the set <span class="math">S_{\\Delta}</span> for equation (1) is an affine subspace of <span class="math">\\mathbb{F}_{p^{r}}</span>. Note that the set <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span> from equation (2) is a linear space parallel to <span class="math">S_{\\Delta}</span>. If there is only one solution for equation (1), then <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span> includes only one zero entry. In this case, <span class="math">\\mathcal{S}</span> aborts, and the probability that the real protocol execution does not abort is at most <span class="math">1/p^{r}</span>.</p>

    <p class="text-gray-300">For <span class="math">h\\in[0,r)</span>, we define</p>

    <p class="text-gray-300"><span class="math">a_{h}=\\tilde{\\Delta}^{-1}\\cdot\\left\\langle\\bm{g}*\\bm{a}_{h},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle</span> (5)</p>

    <p class="text-gray-300">where <span class="math">\\tilde{\\Delta}=\\left\\langle\\bm{g},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle\\in\\tilde{S}_{\\tilde{\\Delta}}</span> is used to compute <span class="math">u_{i}</span> for <span class="math">i\\in[0,n)</span> in equation (3). Clearly, equations (3) and (5) provide a solution for <span class="math">x=\\sum_{i=0}^{n-1}\\chi_{i}\\cdot u_{i}+\\sum_{h=0}^{r-1}u_{h}\\cdot\\mathsf{X}^{h}</span> such that for some <span class="math">\\tilde{\\Delta}=\\left\\langle\\bm{g},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle\\in\\tilde{S}_{\\tilde{\\Delta}}</span> we have <span class="math">\\sum_{h=0}^{r-1}\\left\\langle\\bm{g}\\cdot a_{h}-\\bm{g}<em>\\bm{a}_{h},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle=0</span> for all <span class="math">h\\in[0,r)</span> and <span class="math">\\left\\langle\\bm{g}\\cdot u_{i}-\\bm{g}</em>\\bm{u}_{i},\\tilde{\\bm{\\Delta}}_{B}\\right\\rangle=0</span> for all <span class="math">i\\in[0,n)</span>.</p>

    <p class="text-gray-300">Below, we need to prove that the <span class="math">\\{u_{i}\\}_{i\\in[0,n)}</span> computed by equation (3) give the unique solution for a sufficiently large subspace of <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span>. Now, we assume that for some <span class="math">l\\in\\mathbb{N}</span>, for each <span class="math">f\\in[l]</span>, there exists a different set <span class="math">\\{u_{f,i}\\}_{i\\in[0,n)}</span> along with the set <span class="math">\\{a_{f,h}\\}_{h\\in[0,r)}</span> such that <span class="math">x=\\sum_{i=0}^{n-1}\\chi_{i}\\cdot u_{f,i}+\\sum_{h=0}^{r-1}a_{f,h}\\cdot\\mathsf{X}^{h}</span> and</p>

    <p class="text-gray-300"><span class="math">\\langle\\bm{g}\\cdot u_{f,i}-\\bm{g}\\ast\\bm{u}_{i},\\tilde{\\bm{\\Delta}}_{B}^{f}\\rangle=0\\text{ for all }i\\in[0,n)\\text{ and }\\sum_{h=0}^{r-1}\\langle\\bm{g}\\cdot a_{f,h}-\\bm{g}\\ast\\bm{a}_{h},\\tilde{\\bm{\\Delta}}_{B}^{f}\\rangle\\cdot\\mathsf{X}^{h}=0,</span> (6)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for all <span class="math">\\tilde{\\Delta}^{f}=\\langle\\bm{g},\\tilde{\\bm{\\Delta}}_{B}^{f}\\rangle\\in\\tilde{S}_{f}\\subseteq\\tilde{S}_{\\tilde{\\Delta}}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{S}_{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>1<span class="math">. The condition of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{S}_{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>1<span class="math"> is required for </span>\\mathcal{A}<span class="math"> to pass the correlation check with probability more than </span>1/p^{r}<span class="math">. Since </span>\\tilde{S}_{f}<span class="math"> is a linear space for all </span>f\\in[l]<span class="math"> and </span>\\tilde{S}_{f}\\cap\\tilde{S}_{f^{\\prime}}=\\{0\\}<span class="math"> from the definition, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{S}_{\\tilde{\\Delta}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq p^{r}<span class="math"> by definition, we have that </span>l\\leq r\\log p$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">f\\neq f^{\\prime}\\in[l]</span>. From equation (2) and <span class="math">x=\\sum_{i=0}^{n-1}\\chi_{i}\\cdot u_{f^{\\prime},i}+\\sum_{h=0}^{r-1}a_{f^{\\prime},h}\\cdot\\mathsf{X}^{h}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{n-1}\\chi_{i}\\cdot u_{f^{\\prime},i}\\cdot\\tilde{\\Delta}^{f}-\\sum_{i=0}^{n-1}\\chi_{i}\\cdot\\langle\\bm{g}\\ast\\bm{u}_{i},\\tilde{\\bm{\\Delta}}_{B}^{f}\\rangle+\\sum_{h=0}^{r-1}a_{f^{\\prime},h}\\cdot\\tilde{\\Delta}^{f}\\cdot\\mathsf{X}^{h}-\\sum_{h=0}^{r-1}\\langle\\bm{g}\\ast\\bm{a}_{h},\\tilde{\\bm{\\Delta}}_{B}^{f}\\rangle\\cdot\\mathsf{X}^{h}=0.</span></p>

    <p class="text-gray-300">Using equation (6), we obtain</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{n-1}\\chi_{i}\\cdot(u_{f^{\\prime},i}-u_{f,i})\\cdot\\tilde{\\Delta}^{f}+\\sum_{h=0}^{r-1}(a_{f^{\\prime},h}-a_{f,h})\\cdot\\tilde{\\Delta}^{f}\\cdot\\mathsf{X}^{h}=0</span> (7)</p>

    <p class="text-gray-300">By definition, there exists some <span class="math">j\\in[0,n)</span> such that <span class="math">u_{f,j}\\neq u_{f^{\\prime},j}</span>. Furthermore, there are at least two values for <span class="math">\\tilde{\\Delta}^{f}\\in\\tilde{S}_{f}</span>, and thus we assume that in the above equation <span class="math">\\tilde{\\Delta}^{f}\\neq 0</span>. Thus, <span class="math">(u_{f^{\\prime},j}-u_{f,j})\\cdot\\tilde{\\Delta}^{f}\\neq 0</span>. Note that <span class="math">\\chi_{0},\\ldots,\\chi_{n-1}</span> are sampled uniformly at random and independent from the other values involved in equation (7). Therefore, equation (7) holds with probability at most <span class="math">1/p^{r}</span>. There are fewer than <span class="math">l^{2}\\leq(r\\log p)^{2}</span> pairs <span class="math">f\\neq f^{\\prime}\\in[l]</span>. Thus, the overall probability is bounded by <span class="math">(r\\log p)^{2}/p^{r}</span>.</p>

    <p class="text-gray-300">We have established that there exists a unique solution <span class="math">u_{i}</span> for <span class="math">i\\in[0,n)</span>. This means that for all <span class="math">\\tilde{\\Delta}=\\langle\\bm{g},\\tilde{\\bm{\\Delta}}_{B}\\rangle\\in\\tilde{S}_{\\tilde{\\Delta}}</span>, we have that <span class="math">\\langle\\bm{g}\\cdot u_{i}-\\bm{g}\\ast\\bm{u}_{i},\\tilde{\\bm{\\Delta}}_{B}\\rangle=0</span> for <span class="math">i\\in[0,n)</span>. Therefore, we obtain that <span class="math">\\langle\\bm{g}\\ast\\bm{e}_{i},\\tilde{\\bm{\\Delta}}_{B}\\rangle=0</span> for all <span class="math">i\\in[0,n)</span>. If there exists two different <span class="math">\\Delta,\\Delta^{\\prime}\\in S_{\\Delta}</span> such that <span class="math">\\langle\\bm{g}\\ast\\bm{e}_{i},\\bm{\\Delta}_{B}\\rangle\\neq\\langle\\bm{g}\\ast\\bm{e}_{i},\\bm{\\Delta}_{B}^{\\prime}\\rangle</span> for some <span class="math">i\\in[0,n)</span> where <span class="math">\\langle\\bm{g},\\bm{\\Delta}_{B}\\rangle=\\Delta</span> and <span class="math">\\langle\\bm{g},\\bm{\\Delta}_{B}^{\\prime}\\rangle=\\Delta^{\\prime}</span>, then we define <span class="math">\\tilde{\\bm{\\Delta}}_{B}:=\\bm{\\Delta}_{B}-\\bm{\\Delta}_{B}^{\\prime}</span> and have that <span class="math">\\tilde{\\Delta}=\\langle\\bm{g},\\tilde{\\bm{\\Delta}}_{B}\\rangle\\in\\tilde{S}_{\\tilde{\\Delta}}</span> and <span class="math">\\langle\\bm{g}\\ast\\bm{e}_{i},\\tilde{\\bm{\\Delta}}_{B}\\rangle\\neq 0</span>. This is contradict with <span class="math">\\langle\\bm{g}\\ast\\bm{e}_{i},\\tilde{\\bm{\\Delta}}_{B}\\rangle=0</span>. This concludes that <span class="math">\\langle\\bm{g}\\ast\\bm{e}_{i},\\bm{\\Delta}_{B}\\rangle</span> is a unique value for all possible <span class="math">\\Delta=\\langle\\bm{g},\\bm{\\Delta}_{B}\\rangle\\in S_{\\Delta}</span>, and can be computed by the simulator using any <span class="math">\\Delta\\in S_{\\Delta}</span>. In the real protocol execution, <span class="math">\\mathcal{A}</span> can compute <span class="math">w_{i}^{\\prime}:=w_{i}-\\langle\\bm{g}\\ast\\bm{e}_{i},\\bm{\\Delta}_{B}\\rangle</span> for <span class="math">i\\in[0,n)</span> just as that computed by <span class="math">\\mathcal{S}</span>. Together with that <span class="math">w_{i}=v_{i}+\\langle\\bm{g}\\ast\\bm{u}_{i},\\bm{\\Delta}_{B}\\rangle</span>, we have that</p>

    <p class="text-gray-300"><span class="math">w_{i}^{\\prime}=v_{i}+\\langle\\bm{g}\\ast\\bm{u}_{i},\\bm{\\Delta}_{B}\\rangle-\\langle\\bm{g}\\ast\\bm{e}_{i},\\bm{\\Delta}_{B}\\rangle=v_{i}+\\Delta\\cdot u_{i}.</span></p>

    <p class="text-gray-300">We now discuss the case of a prime <span class="math">p&gt;2</span>. The main difference from the case of <span class="math">p=2</span> is that the canonical maps between <span class="math">\\Delta\\in\\mathbb{F}_{p^{r}}</span> and <span class="math">\\bm{\\Delta}_{B}\\in\\{0,1\\}^{rm}</span> are not bijective. This implies that the solutions of equations (1) and (2) are not necessarily vectors of bits rather than elements of <span class="math">\\mathbb{F}_{p}</span>. Following the proof of <em>[x13, Lemma 2]</em>, we have that if <span class="math">\\tilde{S}_{f}</span> includes at least two vectors that only consist of bits, which is necessary for the adversary to pass the correlation check with probability more than <span class="math">1/p^{r}</span>, then it has dimension at least <span class="math">1</span> for all <span class="math">f\\in[l]</span>. We also have the fact that <span class="math">\\tilde{S}_{\\tilde{\\Delta}}</span> has dimension at most <span class="math">r\\log p</span> and <span class="math">\\tilde{S}_{f}\\cap\\tilde{S}_{f^{\\prime}}=\\{0\\}</span> for <span class="math">f\\neq f^{\\prime}\\in[l]</span> by definition. Together, we obtain that <span class="math">l\\leq r\\log p</span> as above.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Overall, we have that no environment <span class="math">\\mathcal{Z}</span> can distinguish the real-world execution from the ideal-world execution, except with probability at most <span class="math">(r\\log p)^2 /p^r</span>.</p>

    <p class="text-gray-300">Malicious <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. <span class="math">\\mathcal{S}</span> is given access to <span class="math">\\mathcal{F}_{\\mathsf{LsVOLE}}^{p,r}</span>, and interacts with adversary <span class="math">\\mathcal{A}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathsf{COPEe}}^{p,r}</span>, and receives the values <span class="math">\\Delta</span>, <span class="math">v_{i}</span> for <span class="math">i \\in [0, n)</span> and <span class="math">b_{h}</span> for <span class="math">h \\in [0, r)</span> from <span class="math">\\mathcal{A}</span>.</li>

      <li>After receiving coefficients <span class="math">\\chi_{1},\\ldots ,\\chi_{n}\\in \\mathbb{F}_{p^{r}}</span>, <span class="math">\\mathcal{S}</span> samples <span class="math">x\\gets \\mathbb{F}_{p^r}</span>, computes <span class="math">y\\coloneqq \\sum_{i = 1}^{n}\\chi_{i}\\cdot v_{i} + \\sum_{h = 1}^{r}b_{h}\\cdot \\mathsf{X}^{h - 1}\\in \\mathbb{F}_{p^r}</span>, and computes <span class="math">z\\coloneqq y + x\\cdot \\Delta \\in \\mathbb{F}_{p^r}</span>. Then <span class="math">\\mathcal{S}</span> sends <span class="math">(x,z)</span> to adversary <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> defines <span class="math">\\pmb {v} = (v_{1},\\dots ,v_{n})</span> and sends <span class="math">\\pmb {v}\\in \\mathbb{F}_{p^r}^n</span> to functionality <span class="math">\\mathcal{F}_{\\mathrm{LsVOLE}}^{p,r}</span>.</li>

    </ol>

    <p class="text-gray-300">In the real protocol execution, the elements <span class="math">a_{h}</span> for all <span class="math">h\\in [0,r)</span> output by <span class="math">\\mathcal{F}_{\\mathrm{COPEe}}^{p,r}</span> are uniform in <span class="math">\\mathbb{F}_p</span>. Therefore, <span class="math">\\sum_{h = 1}^{r}a_{h}\\cdot \\mathsf{X}^{h - 1}</span> is uniform in <span class="math">\\mathbb{F}_{p^r}</span>, and thus <span class="math">x = \\sum_{i = 1}^{n}\\chi_{i}\\cdot u_{i} + \\sum_{h = 1}^{r}a_{h}\\cdot \\mathsf{X}^{h - 1}</span> is uniformly random in <span class="math">\\mathbb{F}_{p^r}</span>. We obtain that the simulation is perfect. It is easy to see that the outputs of two parties have the same distribution between the real-world execution and the ideal-world execution.</p>

    <h2 id="sec-46" class="text-2xl font-bold">B.3 Proof of Theorem 3</h2>

    <p class="text-gray-300">We first consider the case of a malicious <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> and then consider the case of a malicious <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. In each case, we construct a PPT simulator <span class="math">\\mathcal{S}</span> given access to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span> that runs the PPT adversary <span class="math">\\mathcal{A}</span> as a subroutine, and emulates functionalities <span class="math">\\mathcal{F}_{\\mathrm{OT}}</span>, <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>, and <span class="math">\\mathcal{F}_{\\mathrm{EQ}}</span>. We always implicitly assume that <span class="math">\\mathcal{S}</span> passes all communication between <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span>.</p>

    <p class="text-gray-300">Malicious <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>. Every time the extend procedure is run (on input <span class="math">n</span>), <span class="math">\\mathcal{S}</span> interacts with <span class="math">\\mathcal{A}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> and records the values <span class="math">(a,c)</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>. When <span class="math">\\mathcal{A}</span> sends the message <span class="math">a&#x27; \\in \\mathbb{F}_p</span>, then <span class="math">\\mathcal{S}</span> sets <span class="math">\\beta \\coloneqq a&#x27; + a \\in \\mathbb{F}_p</span> and <span class="math">\\delta \\coloneqq c</span>.</li>

      <li>For <span class="math">i \\in [1, h)</span>, <span class="math">\\mathcal{S}</span> samples <span class="math">K^i \\gets \\{0, 1\\}^\\kappa</span>; it also samples <span class="math">K^h \\gets \\mathbb{F}_{p^r}</span>. Then for <span class="math">i \\in [h]</span>, <span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathrm{OT}}</span> by receiving <span class="math">\\bar{\\alpha}_i \\in \\{0, 1\\}</span> from <span class="math">\\mathcal{A}</span>, and returning <span class="math">K_{\\bar{\\alpha}_i}^i \\coloneqq K^i</span> to <span class="math">\\mathcal{A}</span>. It sets <span class="math">\\alpha \\coloneqq \\alpha_1 \\cdots \\alpha_h</span> and defines <span class="math">\\boldsymbol{u} \\in \\mathbb{F}_p^n</span> as the vector that is 0 everywhere except that <span class="math">\\boldsymbol{u}[\\alpha] \\coloneqq \\beta</span>. Next, <span class="math">\\mathcal{S}</span> computes <span class="math">\\{v_j\\}_{j \\neq \\alpha} := \\mathsf{GGM}&#x27;(\\alpha, \\{K_{\\bar{\\alpha}_i}^i\\}_{i \\in [h]})</span>.</li>

      <li><span class="math">\\mathcal{S}</span> picks <span class="math">d \\gets \\mathbb{F}_{p^r}</span> and sends it to <span class="math">\\mathcal{A}</span>. Then, <span class="math">\\mathcal{S}</span> defines <span class="math">\\boldsymbol{w}</span> as the vector of length <span class="math">n</span> with <span class="math">\\boldsymbol{w}[i] := v_i</span> for <span class="math">i \\neq \\alpha</span> and <span class="math">\\boldsymbol{w}[\\alpha] := \\delta - (d + \\sum_{i \\neq \\alpha} \\boldsymbol{w}[i])</span>.</li>

      <li><span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> by recording <span class="math">(\\boldsymbol{x},\\boldsymbol{z})</span> from <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> receives <span class="math">\\{\\chi_i\\}_{i\\in [0,n)}</span> and <span class="math">\\pmb{x}^{<em>} \\in \\mathbb{F}_{p}^{r}</span> from <span class="math">\\mathcal{A}</span>, and sets <span class="math">\\pmb{x}&#x27; := \\pmb{x}^{</em>} + \\pmb{x} \\in \\mathbb{F}_{p}^{r}</span> and <span class="math">x&#x27; := \\sum_{i=0}^{r-1} \\pmb{x}&#x27;[i] \\cdot \\mathsf{X}^i</span>.</li>

      <li><span class="math">\\mathcal{S}</span> records <span class="math">V_{\\mathsf{A}} \\in \\mathbb{F}_{p^r}</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span>. It then computes <span class="math">V_{\\mathsf{A}}&#x27; := \\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{w}[i] - \\sum_{i=0}^{r-1} \\boldsymbol{z}[i] \\cdot \\mathsf{X}^i \\in \\mathbb{F}_{p^r}</span> and does:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x&#x27; = \\beta \\cdot \\chi_{\\alpha}</span>, then <span class="math">\\mathcal{S}</span> checks whether <span class="math">V_{\\mathsf{A}} = V_{\\mathsf{A}}&#x27;</span>. If so, <span class="math">\\mathcal{S}</span> sends true to <span class="math">\\mathcal{A}</span>, and sends <span class="math">\\boldsymbol{u}, \\boldsymbol{w}</span> to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>. Otherwise, <span class="math">\\mathcal{S}</span> sends abort to <span class="math">\\mathcal{A}</span> and aborts.</li>

      <li>Otherwise, <span class="math">\\mathcal{S}</span> computes <span class="math">\\Delta&#x27; := (V_{\\mathsf{A}}&#x27; - V_{\\mathsf{A}}) / (\\beta \\cdot \\chi_{\\alpha} - x&#x27;) \\in \\mathbb{F}_{p^r}</span> and sends a global-key query <span class="math">(\\text{guess}, \\Delta&#x27;)</span> to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>. If <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span> returns success, <span class="math">\\mathcal{S}</span> sends true to <span class="math">\\mathcal{A}</span>, and sends <span class="math">\\boldsymbol{u}, \\boldsymbol{w}</span> to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>. Otherwise, <span class="math">\\mathcal{S}</span> sends abort to <span class="math">\\mathcal{A}</span> and aborts.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">\\mathcal{A}</span> sends a global-key query <span class="math">(\\text{guess}, \\tilde{\\Delta})</span> to functionality <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>, <span class="math">\\mathcal{S}</span> forwards the query to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span> and returns the answer to <span class="math">\\mathcal{A}</span>. If the answer is abort, <span class="math">\\mathcal{S}</span> aborts.</li>

    </ol>

    <p class="text-gray-300">In the above simulation, if <span class="math">\\mathcal{A}</span> succeeds to guess <span class="math">\\Delta</span>, then <span class="math">\\mathcal{S}</span> simulates the <span class="math">\\mathcal{A}</span>'s view using <span class="math">\\Delta</span> without making any further global-key query to <span class="math">\\mathcal{F}_{\\text{sysVOLE}}^{p,r}</span>.</p>

    <p class="text-gray-300">We claim that the joint distribution of the view of <span class="math">\\mathcal{A}</span> and the output of the honest <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> in the ideal-world execution above is computationally indistinguishable from their distribution in the real-world execution. By the standard analysis of the GGM construction, it is not hard to see that <span class="math">d</span> and the <span class="math">\\{K_{\\hat{\\alpha}_i}^i\\}</span> sent to <span class="math">\\mathcal{A}</span> in the above simulation, as well as the vector <span class="math">\\pmb{v}</span> that would be output by <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> when it does not abort, are computationally indistinguishable from the corresponding values in the real protocol execution. It thus only remains to analyze steps 4-6, which determine whether <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> aborts.</p>

    <p class="text-gray-300">Let <span class="math">\\beta = a&#x27; + a</span>, <span class="math">\\pmb{x}&#x27; = \\pmb{x}^<em> + \\pmb{x}</span>, and <span class="math">x&#x27; = \\sum_{i=0}^{r-1} \\pmb{x}&#x27;[i] \\cdot \\mathsf{X}^i</span>, as above. (Note that <span class="math">a&#x27;, a, \\pmb{x}^</em>, \\pmb{x}</span> are well-defined in the real-world execution as well.) In the real-world execution, <span class="math">\\mathsf{P}_{\\mathsf{B}}</span> computes</p>

    <p class="text-gray-300">$$ \\begin{array}{l} V_{\\mathsf{B}} = \\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{v}[i] - \\sum_{i=0}^{r-1} \\boldsymbol{y}[i] \\cdot \\mathsf{X}^i \\\\ = \\sum_{i \\neq \\alpha} \\chi_i \\cdot \\boldsymbol{v}[i] + \\chi_\\alpha \\cdot \\boldsymbol{v}[\\alpha] - \\sum_{i=0}^{r-1} (\\boldsymbol{z}[i] - \\Delta \\cdot \\boldsymbol{x}'[i]) \\cdot \\mathsf{X}^i \\\\ = \\sum_{i \\neq \\alpha} \\chi_i \\cdot \\boldsymbol{v}[i] + \\chi_\\alpha \\cdot (\\delta - \\Delta \\cdot \\beta - d - \\sum_{i \\neq \\alpha} \\boldsymbol{v}[i]) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{i=0}^{r-1} \\boldsymbol{z}[i] \\cdot \\mathsf{X}^i + \\Delta \\cdot x' \\\\</li>

    </ul>

    <p class="text-gray-300">= \\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{w}[i] - \\sum_{i=0}^{r-1} \\boldsymbol{z}[i] \\cdot \\mathsf{X}^i - \\Delta \\cdot (\\beta \\cdot \\chi_\\alpha - x') \\\\ = V_{\\mathsf{A}}' - \\Delta \\cdot (\\beta \\cdot \\chi_\\alpha - x'). \\end{array} $$</p>

    <p class="text-gray-300">where <span class="math">\\pmb{w}</span> and <span class="math">V_{\\mathsf{A}}&#x27;</span> are defined as in the description of <span class="math">\\mathcal{S}</span> above. Say that <span class="math">\\mathcal{A}</span> sends <span class="math">V_{\\mathsf{A}}</span> to <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span>. If <span class="math">x&#x27; = \\beta \\cdot \\chi_{\\alpha}</span> (as will be the case when <span class="math">\\mathcal{A}</span> behaves honestly), then <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> returns true iff <span class="math">V_{\\mathsf{A}} = V_{\\mathsf{A}}&#x27;</span>. Otherwise, <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> returns true iff <span class="math">\\Delta = (V_{\\mathsf{A}}&#x27; - V_{\\mathsf{A}}) / (\\beta \\cdot \\chi_{\\alpha} - x&#x27;)</span>. We thus see that the ideal-world behavior of <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> matches what would occur in the real world.</p>

    <p class="text-gray-300">Malicious <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. Simulator <span class="math">\\mathcal{S}</span> interacts with <span class="math">\\mathcal{A}</span> as follows. First, <span class="math">\\mathcal{S}</span> simulates the initialization step by recording the global key <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span>. Then, every time the extend procedure is executed (on input <span class="math">n</span>), <span class="math">\\mathcal{S}</span> does:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> records <span class="math">b \\in \\mathbb{F}_{p^r}</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span>. Then <span class="math">\\mathcal{S}</span> samples <span class="math">a&#x27; \\gets \\mathbb{F}_p</span> and sends it to <span class="math">\\mathcal{A}</span>. Next, <span class="math">\\mathcal{S}</span> computes <span class="math">\\gamma := b - \\Delta \\cdot a&#x27;</span>, and then samples <span class="math">\\beta \\gets \\mathbb{F}_p^*</span> and sets <span class="math">\\delta := \\gamma + \\Delta \\cdot \\beta</span>.</li>

      <li><span class="math">\\mathcal{S}</span> records the values <span class="math">\\{(K_0^i, K_1^i)\\}_{i \\in [h]}</span> sent to <span class="math">\\mathcal{F}_{\\mathrm{OT}}</span> by <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> receives <span class="math">d \\in \\mathbb{F}_{p^r}</span> from <span class="math">\\mathcal{A}</span>. Then, for each <span class="math">\\alpha \\in [0,n)</span>, it computes a vector <span class="math">\\boldsymbol{w}_{\\alpha}</span> as follows:</li>

    </ol>

    <p class="text-gray-300">(a) Execute <span class="math">\\{v_j^\\alpha\\}_{j \\neq \\alpha} := \\mathsf{GGM}&#x27;(\\alpha, \\{K_{\\hat{\\alpha}_i}^i\\}_{i \\in [h]})</span> and set <span class="math">\\boldsymbol{w}_\\alpha[i] = v_i^\\alpha</span> for <span class="math">i \\neq \\alpha</span>.</p>

    <p class="text-gray-300">(b) Compute <span class="math">\\boldsymbol{w}_\\alpha[\\alpha] := \\delta - (d + \\sum_{i \\neq \\alpha} \\boldsymbol{w}_\\alpha[i])</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> records the vector <span class="math">\\boldsymbol{y}^*</span> sent to <span class="math">\\mathcal{F}_{\\mathsf{sVOLE}}^{p,r}</span> by <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> samples <span class="math">\\chi_i \\gets \\mathbb{F}_{p^r}</span> for <span class="math">i \\in [0, n)</span> and <span class="math">\\boldsymbol{x}^<em> \\gets \\mathbb{F}_p^r</span>, and sends them to <span class="math">\\mathcal{A}</span>. Then <span class="math">\\mathcal{S}</span> computes <span class="math">\\boldsymbol{y} := \\boldsymbol{y}^</em> - \\Delta \\cdot \\boldsymbol{x}^*</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> computes <span class="math">Y := \\sum_{i=0}^{r-1} \\boldsymbol{y}[i] \\cdot \\mathsf{X}^i</span>. It then records <span class="math">V_{\\mathsf{B}}</span> sent to <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span> by <span class="math">\\mathcal{A}</span>. Next, <span class="math">\\mathcal{S}</span> computes a set <span class="math">I \\subseteq [0,n)</span> as follows:</li>

    </ol>

    <p class="text-gray-300">(a) For <span class="math">\\alpha \\in [0,n)</span>, compute <span class="math">V_{\\mathsf{A}}^{\\alpha} := \\sum_{i=0}^{n-1} \\chi_i \\cdot \\boldsymbol{w}_{\\alpha}[i] - \\Delta \\cdot \\beta \\cdot \\chi_{\\alpha} - Y</span>.</p>

    <p class="text-gray-300">(b) Define <span class="math">I := \\{\\alpha \\in [0, n) \\mid V_{\\mathsf{A}}^{\\alpha} = V_{\\mathsf{B}}\\}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> sends <span class="math">I</span> to <span class="math">\\mathcal{F}_{\\mathrm{spSVOLE}}^{p,r}</span>; if it returns abort, <span class="math">\\mathcal{S}</span> picks <span class="math">\\tilde{\\alpha} \\gets [0,n) \\backslash I</span>, sends <span class="math">(\\text{false}, V_{\\mathsf{A}}^{\\tilde{\\alpha}})</span> to <span class="math">\\mathcal{A}</span> on behalf of <span class="math">\\mathcal{F}_{\\mathsf{EQ}}</span>, and then aborts. Otherwise, <span class="math">\\mathcal{S}</span> sends <span class="math">(\\text{true}, V_{\\mathsf{B}})</span> to <span class="math">\\mathcal{A}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> chooses an arbitrary <span class="math">\\alpha \\in I</span> and computes a vector <span class="math">\\boldsymbol{v}</span> as follows:</li>

    </ol>

    <p class="text-gray-300">(a) Set <span class="math">\\boldsymbol{v}[i] := \\boldsymbol{w}_{\\alpha}[i]</span> for <span class="math">i \\in [0, n), i \\neq \\alpha</span>.</p>

    <p class="text-gray-300">(b) Set <span class="math">\\boldsymbol{v}[\\alpha] := \\gamma - d - \\sum_{i \\neq \\alpha} \\boldsymbol{v}[i]</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> sends <span class="math">\\boldsymbol{v}</span> to <span class="math">\\mathcal{F}_{\\mathrm{spSVOLE}}^{p,r}</span> and outputs whatever <span class="math">\\mathcal{A}</span> outputs.</p>

    <p class="text-gray-300">We first consider the view of adversary <span class="math">\\mathcal{A}</span> in the ideal-world execution and the real-world execution. The values <span class="math">a&#x27;</span> and <span class="math">\\boldsymbol{x}^<em></span> simulated by <span class="math">\\mathcal{S}</span> have the same distribution as the real values, which are masked by a uniform element/vector output by <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>. The set <span class="math">I</span> extracted by <span class="math">\\mathcal{S}</span> corresponds to the selective failure attack on the output index <span class="math">\\alpha^</em></span> of <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>. If <span class="math">\\mathcal{S}</span> receives abort from <span class="math">\\mathcal{F}_{\\mathrm{spSVOLE}}^{p,r}</span>, we have that <span class="math">\\alpha^<em> \\notin I</span>. In the real protocol execution, if <span class="math">V_{\\mathsf{B}} \\neq V_{\\mathsf{A}}^{\\alpha^</em>}</span>, then <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> aborts. By previous considerations, this is equivalent to <span class="math">\\alpha^<em> \\notin I</span>. Therefore, <span class="math">\\mathcal{F}_{\\mathrm{spSVOLE}}^{p,r}</span> aborts if and only if the real protocol execution aborts. For an honest <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>, the index <span class="math">\\alpha^</em> \\in [0,n)</span> is sampled uniformly in both the real-world execution and the ideal-world execution. If receiving abort from <span class="math">\\mathcal{F}_{\\mathrm{spSVOLE}}^{p,r}</span>, then <span class="math">\\mathcal{S}</span> needs to send false along with an element <span class="math">V_{\\mathsf{A}}^{\\tilde{\\alpha}} \\neq V_{\\mathsf{B}}</span> to <span class="math">\\mathcal{A}</span>. Although <span class="math">\\mathcal{S}</span> does not know the actual index <span class="math">\\alpha^<em></span>, it can sample a random index <span class="math">\\tilde{\\alpha}</span> from the set <span class="math">[0,n) \\backslash I</span> and send <span class="math">V_{\\mathsf{A}}^{\\tilde{\\alpha}}</span> to <span class="math">\\mathcal{A}</span>. In the case of aborting, this simulation is perfect, since <span class="math">\\mathcal{Z}</span> cannot obtain the output of <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> due to aborting, and the dummy index <span class="math">\\tilde{\\alpha}</span> has the same distribution as the actual index <span class="math">\\alpha^</em></span> under the condition that <span class="math">I</span> is an incorrect guess.</p>

    <p class="text-gray-300">Overall, we have that the adversary's view is perfectly indistinguishable between the real-world execution and the ideal-world execution. Below, we prove that except with probability <span class="math">1 / p^r</span>, the distribution of <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>'s output in the real-world execution is the same as that in the ideal-world execution. It is easy to see that the output vector <span class="math">\\boldsymbol{u}^<em></span> that is 0 everywhere except that <span class="math">\\boldsymbol{u}^</em>[\\alpha^<em>] = \\beta^</em></span> in the ideal-world execution and the real-world execution have the same distribution, from the above analysis and that <span class="math">\\beta^<em></span> is perfectly hidden. In the following, we focus on proving the indistinguishability of <span class="math">\\boldsymbol{w}^</em></span> output by <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> between the ideal-world execution and the real-world execution. Firstly, we prove that the vector <span class="math">\\boldsymbol{v} \\in \\mathbb{F}_{p^r}^n</span> computed by <span class="math">\\mathcal{S}</span> in the step 7 is unique (i.e., independent of the choice <span class="math">\\alpha \\in I</span>).</p>

    <p class="text-gray-300"><strong>Claim 1.</strong> For any <span class="math">\\alpha, \\alpha&#x27; \\in [0, n)</span>, let <span class="math">\\boldsymbol{v}_{\\alpha}, \\boldsymbol{v}_{\\alpha&#x27;}</span> be the vectors computed by <span class="math">\\mathcal{S}</span> with <span class="math">\\alpha, \\alpha&#x27;</span> following the step 7, then we have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left\\{\\boldsymbol {v} _ {\\alpha} \\neq \\boldsymbol {v} _ {\\alpha^ {\\prime}} \\mid V _ {\\mathsf {A}} ^ {\\alpha} = V _ {\\mathsf {A}} ^ {\\alpha^ {\\prime}} \\right\\} \\leq \\frac {1}{p ^ {r}}.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Since <span class="math">V_{\\mathsf{A}}^{\\alpha} = V_{\\mathsf{A}}^{\\alpha&#x27;}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {i \\in [ 0, n)} \\chi_ {i} \\cdot \\boldsymbol {w} _ {\\alpha} [ i ] - \\Delta \\cdot \\beta \\cdot \\chi_ {\\alpha} - Y = \\sum_ {i \\in [ 0, n)} \\chi_ {i} \\cdot \\boldsymbol {w} _ {\\alpha^ {\\prime}} [ i ] - \\Delta \\cdot \\beta \\cdot \\chi_ {\\alpha^ {\\prime}} - Y \\Leftrightarrow \\\\ \\sum_ {i \\neq \\alpha , \\alpha^ {\\prime}} \\chi_ {i} \\cdot (\\boldsymbol {w} _ {\\alpha} [ i ] - \\boldsymbol {w} _ {\\alpha^ {\\prime}} [ i ]) + \\chi_ {\\alpha} \\cdot (\\boldsymbol {w} _ {\\alpha} [ \\alpha ] - \\boldsymbol {w} _ {\\alpha^ {\\prime}} [ \\alpha ] - \\Delta \\cdot \\beta) + \\chi_ {\\alpha^ {\\prime}} \\cdot (\\boldsymbol {w} _ {\\alpha} [ \\alpha^ {\\prime} ] - \\boldsymbol {w} _ {\\alpha^ {\\prime}} [ \\alpha^ {\\prime} ] + \\Delta \\cdot \\beta) = 0. \\end{array}</span></div>

    <p class="text-gray-300">Note that <span class="math">\\Delta</span>, <span class="math">\\beta</span>, <span class="math">\\pmb{w}_{\\alpha}</span> and <span class="math">\\pmb{w}_{\\alpha&#x27;}</span> have already been defined before <span class="math">\\{\\chi_i\\}_{i\\in [0,n)}</span> are sampled. Furthermore, each coefficient <span class="math">\\chi_{i}</span> is uniform. Therefore, except with probability <span class="math">1 / p^r</span>, we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {w} _ {\\alpha} [ i ] = \\boldsymbol {w} _ {\\alpha^ {\\prime}} [ i ] \\text { for } i \\in [ 0, n), i \\neq \\alpha , \\alpha^ {\\prime},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {w} _ {\\alpha} [ \\alpha ] - \\boldsymbol {w} _ {\\alpha^ {\\prime}} [ \\alpha ] = \\boldsymbol {w} _ {\\alpha^ {\\prime}} [ \\alpha^ {\\prime} ] - \\boldsymbol {w} _ {\\alpha} [ \\alpha^ {\\prime} ] = \\Delta \\cdot \\beta .</span></div>

    <p class="text-gray-300">From the first equation, we directly obtain that <span class="math">\\pmb{v}_{\\alpha}[i] = \\pmb{v}_{\\alpha&#x27;}[i]</span> for <span class="math">i \\neq \\alpha, \\alpha&#x27;</span>. From the definitions of <span class="math">\\pmb{w}_{\\alpha}[\\alpha]</span> and <span class="math">\\pmb{v}_{\\alpha}[\\alpha]</span>, we have that <span class="math">\\pmb{v}_{\\alpha}[\\alpha] = \\pmb{w}_{\\alpha}[\\alpha] - \\Delta \\cdot \\beta</span>. Together with <span class="math">\\pmb{w}_{\\alpha}[\\alpha] = \\pmb{w}_{\\alpha&#x27;}[\\alpha] + \\Delta \\cdot \\beta</span>, we further have that <span class="math">\\pmb{v}_{\\alpha}[\\alpha] = \\pmb{w}_{\\alpha&#x27;}[\\alpha] = \\pmb{v}_{\\alpha&#x27;}[\\alpha]</span>. Similarly we also have <span class="math">\\pmb{v}_{\\alpha&#x27;}[\\alpha&#x27;] = \\pmb{v}_{\\alpha}[\\alpha&#x27;]</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\pmb{w}^{<em>}, \\pmb{u}^{</em>}</span> be the output of <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> and <span class="math">\\pmb{v}</span> be the input from <span class="math">\\mathcal{S}</span> (or <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>). It is obvious that <span class="math">\\pmb{w}^{<em>} = \\pmb{v} + \\Delta \\cdot \\pmb{u}^{</em>}</span> in the ideal-world execution. Now we look at the real-world execution. We define a vector <span class="math">\\pmb{v}^{<em>}</span> as <span class="math">\\pmb{v}^{</em>}[i] = \\pmb{w}_{\\alpha^{<em>}}[i]</span> for <span class="math">i \\neq \\alpha^{</em>}</span> and <span class="math">\\pmb{v}^{<em>}[\\alpha^{</em>}] = \\gamma - d - \\sum_{i \\neq \\alpha^{<em>}} \\pmb{v}^{</em>}[i]</span>, where recall that <span class="math">\\alpha^{<em>}</span> is the output index of <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>. From <span class="math">\\pmb{w}_{\\alpha^{</em>}}[\\alpha^{<em>}] = \\gamma + \\Delta \\cdot \\beta^{</em>} - (d + \\sum_{i \\neq \\alpha^{<em>}} \\pmb{w}_{\\alpha^{</em>}}[i])</span>, we have that <span class="math">\\pmb{w}_{\\alpha^{<em>}}[\\alpha^{</em>}] = \\pmb{v}^{<em>}[\\alpha^{</em>}] + \\Delta \\cdot \\beta^{<em>}</span>. Therefore, we obtain that <span class="math">\\pmb{w}^{</em>} = \\pmb{v}^{<em>} + \\Delta \\cdot \\pmb{u}^{</em>}</span> where <span class="math">\\pmb{w}^{<em>} = \\pmb{w}_{\\alpha^{</em>}}</span>. Note that <span class="math">\\pmb{v}^{<em>}</span> in both the ideal-world execution and the real-world execution are defined in the identical way, and thus have the same distribution. Based on Claim 1, we know that in the ideal-world execution, <span class="math">\\pmb{v}^{</em>}</span> is indistinguishable from <span class="math">\\pmb{v}</span> computed by <span class="math">\\mathcal{S}</span>, except with probability at most <span class="math">1/p^r</span>. Therefore <span class="math">\\pmb{v}</span> in the ideal-world execution is indistinguishable from <span class="math">\\pmb{v}^{*}</span> in the real-world execution, which implies the indistinguishability of the output of <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> in the ideal world and the real world.</p>

    <h2 id="sec-47" class="text-2xl font-bold">B.4 Proof of Theorem 4 and Protocol Optimizations</h2>

    <p class="text-gray-300">Proof. We first consider the case of a malicious <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> and then consider the case of a malicious <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. In each case, we construct a PPT simulator <span class="math">\\mathcal{S}</span> given access to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> that runs the adversary <span class="math">\\mathcal{A}</span> as a subroutine, and emulates functionalities <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> and <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>. We always implicitly assume that <span class="math">\\mathcal{S}</span> passes all communication between <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span>.</p>

    <p class="text-gray-300">Malicious <span class="math">\\mathsf{P}_{\\mathsf{A}}</span>. <span class="math">\\mathcal{S}</span> records the vectors <span class="math">(\\pmb {u},\\pmb {w})\\in \\mathbb{F}_p^k\\times \\mathbb{F}_{p^r}^k</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> during initialization. Then in each iteration, <span class="math">\\mathcal{S}</span> runs as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [t]</span>, <span class="math">\\mathcal{S}</span> emulates <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span> and receives the value <span class="math">\\pmb{e}_i \\in \\mathbb{F}_p^m</span> (with at most one nonzero entry) and <span class="math">\\pmb{c}_i \\in \\mathbb{F}_{p^r}^m</span> from <span class="math">\\mathcal{A}</span>; it then defines <span class="math">\\pmb{e} := (\\pmb{e}_1, \\dots, \\pmb{e}_t) \\in \\mathbb{F}_p^n</span> and <span class="math">\\pmb{c} := (\\pmb{c}_1, \\dots, \\pmb{c}_t) \\in \\mathbb{F}_{p^r}^n</span>.</li>

      <li><span class="math">\\mathcal{S}</span> computes <span class="math">\\pmb{x} \\coloneqq \\pmb{u} \\cdot \\mathbf{A} + \\pmb{e} \\in \\mathbb{F}_p^n</span> and <span class="math">\\pmb{z} \\coloneqq \\pmb{w} \\cdot \\mathbf{A} + \\pmb{c} \\in \\mathbb{F}_{p^r}^n</span>, and sends <span class="math">\\pmb{x}[k:n) \\in \\mathbb{F}_p^\\ell</span> and <span class="math">\\pmb{z}[k:n) \\in \\mathbb{F}_{p^r}^\\ell</span> to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>. It also locally updates <span class="math">\\pmb{u} \\coloneqq \\pmb{x}[0:k) \\in \\mathbb{F}_p^k</span> and <span class="math">\\pmb{w} \\coloneqq \\pmb{z}[0:k) \\in \\mathbb{F}_{p^r}^k</span> for the next iteration.</li>

      <li>If <span class="math">\\mathcal{A}</span> ever makes a global key query <span class="math">\\Delta&#x27;</span> to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>, then <span class="math">\\mathcal{S}</span> forwards that query to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>. If <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> responds with abort, <span class="math">\\mathcal{S}</span> aborts; otherwise, it continues.</li>

    </ol>

    <p class="text-gray-300">It is easy to see that the simulation provided by <span class="math">\\mathcal{S}</span> is perfect.</p>

    <p class="text-gray-300">Malicious <span class="math">\\mathsf{P}_{\\mathsf{B}}</span>. <span class="math">\\mathcal{S}</span> runs <span class="math">\\mathcal{G}(1^k, 1^n, p)</span> to generate <span class="math">\\mathbf{A} \\in \\mathbb{F}_p^{k \\times n}</span>. During initialization, <span class="math">\\mathcal{S}</span> records the values <span class="math">\\Delta \\in \\mathbb{F}_{p^r}</span> and <span class="math">\\boldsymbol{v} \\in \\mathbb{F}_{p^r}^k</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>, and sends <span class="math">\\Delta</span> to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>. Then in each iteration, <span class="math">\\mathcal{S}</span> runs as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [t]</span>, <span class="math">\\mathcal{S}</span> receives the value <span class="math">\\pmb{b}_i \\in \\mathbb{F}_{p^r}^m</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>; it sets <span class="math">\\pmb{b} := (\\pmb{b}_1, \\dots, \\pmb{b}_t) \\in \\mathbb{F}_{p^r}^n</span>.</li>

      <li>For <span class="math">i \\in [t]</span>, <span class="math">\\mathcal{S}</span> receives the set <span class="math">I_i \\subseteq [0, m)</span> that <span class="math">\\mathcal{A}</span> sends to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>. Then <span class="math">\\mathcal{S}</span> samples <span class="math">\\boldsymbol{e} \\gets \\mathcal{D}_{n,t}</span> and defines <span class="math">\\{\\alpha_1, \\ldots, \\alpha_t\\}</span> to be the nonzero entries of <span class="math">\\boldsymbol{e}</span>. If <span class="math">\\alpha_i \\bmod m \\in I_i</span> for all <span class="math">i</span>, then <span class="math">\\mathcal{S}</span> continues; otherwise, it aborts.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> computes <span class="math">\\pmb{y} \\coloneqq \\pmb{v} \\cdot \\mathbf{A} + \\pmb{b} \\in \\mathbb{F}_{p^r}^n</span>, and sends <span class="math">\\pmb{y}[k:n) \\in \\mathbb{F}_{p^r}^\\ell</span> to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>. It also locally updates <span class="math">\\pmb{v} \\coloneqq \\pmb{y}[0:k) \\in \\mathbb{F}_{p^r}^k</span> for the next iteration.</li>

    </ol>

    <p class="text-gray-300">The view of <span class="math">\\mathcal{A}</span> is simulated perfectly, and in both the ideal-world simulation and the ideal-world execution of the protocol the output <span class="math">(\\pmb{s},\\mathsf{M}[\\pmb{s}])</span> of <span class="math">\\mathsf{P}_{\\mathsf{A}}</span> satisfies <span class="math">\\pmb {y}[k,n) = \\mathsf{M}[\\pmb {s}] - \\Delta \\cdot \\pmb{s}</span>. The difference is that in the ideal world <span class="math">\\pmb{s}</span> is uniform, whereas in the real world <span class="math">\\pmb {s} = \\pmb {u}\\cdot \\mathbf{A} + \\pmb{e}</span> for a uniform vector <span class="math">\\pmb{u}</span>. It is not hard to see that this difference is undetectable if the <span class="math">\\mathsf{LPN}_{k,n,t,p}^{\\vec{u}}</span> assumption holds.</p>

    <p class="text-gray-300">Optimizations. In each iteration of the extend procedure, protocol <span class="math">\\Pi_{\\mathrm{sVOLE}}^{p,r}</span> makes <span class="math">t</span> calls to <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span>. If <span class="math">\\mathcal{F}_{\\mathrm{spsVOLE}}^{p,r}</span> is instantiated by protocol <span class="math">\\Pi_{\\mathrm{spsVOLE}}^{p,r}</span> from Section 5.1, and we use the optimization described at the end of that section, the <span class="math">t</span> calls to <span class="math">\\Pi_{\\mathrm{spsVOLE}}^{p,r}</span> require only <span class="math">t + r</span> calls to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>.</p>

    <p class="text-gray-300">Moreover, we can push all the calls to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> into the initialization phase, so that the extend procedure does not invoke <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> at all. Specifically, if we make <span class="math">n_0 = k + t + r</span> calls to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span> during initialization, we can run the extend procedure without any additional call to <span class="math">\\mathcal{F}_{\\mathrm{sVOLE}}^{p,r}</span>. Each time the extend procedure is run, we reserve <span class="math">n_0</span> of the sVOLE correlations that are produced for the following iteration, and output <span class="math">n - n_0</span> "usable" sVOLE correlations.</p>

    <p class="text-gray-300">We can further optimize the generation of the initial set of <span class="math">n_0</span> sVOLE correlations during initialization. Let <span class="math">(k_0, n_0, t_0)</span> be another set of LPN parameters. (Note that <span class="math">n_0 \\ll n</span>, so we can take <span class="math">k_0 \\ll k</span> and <span class="math">t_0 \\approx t</span> while achieving security comparable to what is achieved for the LPN parameters <span class="math">(n, k, t)</span>.) We then make <span class="math">n_0&#x27; = k_0 + t_0 + r</span> calls to the base-sVOLE protocol described in Section 5 to generate that number of sVOLE correlations, after which we run the extend procedure of <span class="math">\\Pi_{\\mathrm{sVOLE}}^{p,r}</span> once to obtain <span class="math">n_0</span> sVOLE correlations.</p>`;
---

<BaseLayout title="Wolverine: Fast, Scalable, and Communication-Efficient Zero-... (2020/925)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/925
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
