---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/617';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'ADSNARK: Nearly Practical and Privacy-Preserving Proofs on Authenticated Data';
const AUTHORS_HTML = 'Michael Backes, Manuel Barbosa, Dario Fiore, Raphael M.  Reischuk';

const CONTENT = `    <p class="text-gray-300">Michael Backes^{1}, Manuel Barbosa^{2}, Dario Fiore^{3}, and Raphael M. Reischuk^{4} ^{1} CISPA, Saarland University, Germany ^{2} HASLab – INESC TEC and Universidade do Minho, Portugal ^{3} IMDEA Software Institute, Madrid, Spain ^{4} ETH Zurich, Switzerland</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We study the problem of privacy-preserving proofs on authenticated data, where a party receives data from a trusted source and is requested to prove computations over the data to third parties in a correct and private way, i.e., the third party learns no information on the data but is still assured that the claimed proof is valid. Our work particularly focuses on the challenging requirement that the third party should be able to verify the validity with respect to the specific data authenticated by the source — even without having access to that source. This problem is motivated by various scenarios emerging from several application areas such as wearable computing, smart metering, or general business-to-business interactions. Furthermore, these applications also demand any meaningful solution to satisfy additional properties related to usability and scalability.</p>

    <p class="text-gray-300">In this paper, we formalize the above three-party model, discuss concrete application scenarios, and then we design, build, and evaluate ADSNARK, a nearly practical system for proving arbitrary computations over authenticated data in a privacy-preserving manner. ADSNARK improves significantly over state-of-the-art solutions for this model. For instance, compared to corresponding solutions based on Pinocchio (Oakland’13), ADSNARK achieves up to <span class="math">25\\times</span> improvement in proof-computation time and a <span class="math">20\\times</span> reduction in prover storage space.</p>

    <p class="text-gray-300">ADSNARK: Nearly Practical and Privacy-Preserving Proofs on Authenticated Data 1 Michael Backes, Manuel Barbosa, Dario Fiore, and Raphael M. Reischuk</p>

    <p class="text-gray-300">1 Introduction 3 1.1 Detailed Contributions 5 1.2 An Intuitive Description of Our Techniques 7 1.3 Organization 8</p>

    <p class="text-gray-300">2 Background 8 3 Zero-Knowledge SNARKs over Authenticated Data 11 3.1 SNARKs over Authenticated Data 11 3.2 A Generic Construction of Zero-Knowledge AD-SNARKs 15 3.3 Signature Verification Overhead 16</p>

    <p class="text-gray-300">4 Our Construction of Zero-Knowledge AD-SNARKs 17 4.1 Completeness 22 4.2 Adaptive Proof of Knowledge 24 4.3 Proof of the Zero-Knowledge Property 30</p>

    <p class="text-gray-300">5 Evaluation 31 5.1 Implementation 31 5.2 Experiments Setup 32 5.3 Performance for General Circuits 35 5.4 Performance for Smart Metering Billing 35</p>

    <p class="text-gray-300">6 Further Related Work 35 7 More Applications 36 8 Conclusions 37</p>

    <p class="text-gray-300">A AD-SNARK Extensions 40 A.1 Multi-Source AD-SNARKs 40 A.2 A Zero-Knowledge AD-SNARK with Constant-Time Verification 41</p>

    <p class="text-gray-300">B Definition of Zero Knowledge SNARKs 42 C The PGHR Zero-Knowledge SNARK 43</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">With the emergence of modern IT services, many aspects of the operation of our society have come to critically depend on the ability to share information between multiple parties, subject to complex information flow restrictions. The advance of information and communication technology has often lead to the deployment of systems that offer the desired functionality, but do not offer a technical solution to enforcing the secure information flow restrictions. Instead, parties must simply trust each other, often without reasonable grounds.</p>

    <p class="text-gray-300">The last few years have seen exciting developments in cryptography, where (quasi-)practical solutions to some of these problems were proposed, prototyped, and sometimes deployed (as we will see later in this section). In this paper, we make further progress in this direction by proposing and efficiently instantiating a new cryptographic primitive called AD-SNARK, which targets an important class of applications that is out of reach of current technology. Such applications involve a potentially large set of secret data and three parties with the following trust relationships:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The data owner wishes to keep her data secret, but is forced by circumstances to reveal partial information on this data to a service provider. Typically, this is an aggregated result computed by some public function <span class="math">f</span> on the secret data.</li>

      <li>The service provider does not trust the data owner to correctly compute the partial information on the data, but wants to be convinced of its validity.</li>

      <li>The data owner has access to a trusted source, who can be given local access to the data, and who is trusted by the service provider to vouch for the quality and legitimacy of the data.</li>

    </ul>

    <p class="text-gray-300">For concreteness, let us look at a few applications that fall into this model, and where the public function that must be applied to the data has varying degrees of complexity.</p>

    <p class="text-gray-300">Health Risk Assessment. A wearable biosensor <em>[x21, x1]</em> collects fine-grained health information of an individual; the individual should give this information to a health insurance company that wants to assess her health risk in order to evaluate a corresponding premium. Privacy determines that the fine-grained health data collected by the sensor remains secret as it may reveal more about the individual’s lifestyle and habits than she wishes to reveal. The computation of the premium due to the insurance company (or an aggregate, less privacy-invasive, information of the collected data) should therefore be carried out by the client. However, the client must convince the insurance company that this computation is correct and performed on legitimate data produced by the biosensor (we call this property integrity). In this setting, the biosensor can play the role of the trusted source, provided that it is equipped to cryptographically authenticate the individual measurements that it produces. Then the AD-SNARK primitive can be used to provide the required assurance to the health insurance company.</p>

    <p class="text-gray-300">Smart Metering. The service provider of some commodity installs a trusted device in the facilities of the client. This trusted device periodically measures consumptions and produces a list of readings, which are delivered to the client; the client should give these readings to the service provider for billing purposes. For privacy, the client may not want to disclose these measurements as they may reveal more about the client’s habits than she wishes to reveal (see, e.g., <em>[x1]</em>). For integrity, the supplier wants to evaluate a correct bill and prevent customers from cheating. As before, the customer keeps all the readings provided by the local meter, which must be able to authenticate the data and operate as a trusted source. Then, the customer computes the amount due to the provider, and uses AD-SNARK to prove that the result is correct.</p>

    <p class="text-gray-300">Financial Audits. Organizations are often subject to financial audits. Auditors will typically look at specific parts of the accounting data and assert that the results of relevant computations are accurate. However the accounting data should be treated as sensitive information due to its business-critical nature, and minimizing the amount of information disclosed to auditors is desirable. In this scenario, the auditor plays the role of the service provider, and the organization the role of the data owner. The natural entity to play the role of the trusted source is the person (or third party) who is legally responsible for certifying the accounts of the organization, e.g., the official bookkeeper. This entity would authenticate the accounting data, so that the organization could internally compute the audit data in a way that is verifiable by the auditors with respect to both correctness and legitimacy. As intended, using AD-SNARK in this context will transfer the responsibility of any wrongdoing to the official bookkeeper.</p>

    <p class="text-gray-300">In Section 7 we present three more example applications: pay-as-you-drive insurance, loyalty cards, and health statistics. We believe that, with the rise of small computing devices and an increased awareness with respect to privacy protection, many more applications will come to fall into this three-party scenario.</p>

    <p class="text-gray-300">Although the trust model in all of the previous applications is the same, the complexity of the associated computations varies significantly. Solutions have been proposed for smart-metering, pay-as-you-drive insurance, and loyalty cards, e.g., in <em>[x21, x11]</em>, and <em>[x10]</em>, respectively (and also for other applications of similarly low complexity). However, currently no generic solution is able to scale in a satisfactory way to deal with computations of arbitrary size such as those required for scenarios like the ones of financial audits or health statistics. Furthermore, although some scenarios admit to a close relation between the trusted source and the service provider that could lead to secret information being shared between the two (in the style of symmetric cryptography), other scenarios require verification for multiple parties, i.e., a form of public verifiability that is even more challenging. The AD-SNARK primitive and the efficient instantiation that we propose in this paper provides a practical solution for the moderately complex computations, even with public verifiability. Furthermore, the proposed AD-SNARK construction is as practical as the existing state of the art solutions for computations of arbitrary size on non-authenticated data.</p>

    <p class="text-gray-300">Formal Model. We now illustrate more formally the three party model we have introduced above (see Figure 1). We consider a scenario in which a prover <span class="math">\\mathcal{P}</span> (the data owner) is requested to prove certain computations <span class="math">C(D)</span> on input data <span class="math">D</span> to third parties <span class="math">\\mathcal{V}</span> (one or more service providers), which we call the verifiers. Since the two parties <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> may not trust each other, we are interested in the simultaneous achievement of two main security properties: (1) integrity, in the sense that <span class="math">\\mathcal{V}</span> should be convinced about the correctness of <span class="math">C(D)</span>. In particular, in order to verify that this statement holds for some specific input <span class="math">D</span>, the data is assumed to be generated and authenticated by some trusted source <span class="math">\\mathcal{S}</span>; and (2) privacy, in the sense that <span class="math">\\mathcal{V}</span> should not learn any information about <span class="math">D</span> beyond what is trivially revealed by <span class="math">C(D)</span>.</p>

    <p class="text-gray-300">In addition to the security requirements above, any meaningful solution has to meet the following properties that have been identified as key for practical scalability in previous work: (3) efficiency, meaning that <span class="math">\\mathcal{V}</span>’s verification cost should be much cheaper than the cost of computing <span class="math">C(D)</span>; and (4) data independence, in the sense that the data source <span class="math">\\mathcal{S}</span> should be independent of <span class="math">\\mathcal{P}</span>, i.e., <span class="math">\\mathcal{S}</span> should be able to provide <span class="math">D</span> without knowing in advance what computations will be executed on <span class="math">D</span></p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1. Three-party scenario in which a source  <span class="math">S</span>  authenticates data  <span class="math">x_{k}</span> , and a prover  <span class="math">\\mathcal{P}</span>  proves to a verifier  <span class="math">\\mathcal{V}</span>  the satisfiability of a circuit  <span class="math">C</span>  based on  <span class="math">x_{k}</span> . The source and the prover are interested in data privacy, whereas the verifier is interested in integrity and efficiency.</p>

    <p class="text-gray-300">(e.g., the billing function may change over time). In particular, also  <span class="math">D</span> 's size should not be fixed in advance, i.e.,  <span class="math">S</span>  can continuously provide data to  <span class="math">\\mathcal{P}</span> , even after some proofs have been generated.</p>

    <p class="text-gray-300">Related Work. The simultaneous achievement of integrity and privacy is a fundamental goal that has a long research history starting with the seminal work on zero-knowledge proofs [GMR89]. In the last years, the efficiency of zero-knowledge proofs has improved a lot, and nowadays we are on the verge of having nearly practical schemes for general-purpose computations [PGHR13, BSCG+13, BSCTV14]. Proofs on authenticated data are an important class of proofs that have been considered earlier especially in very specialized contexts such as credentials and electronic cash [Cha85, Dam88, LRSW99, MEK+10]. In the more general case of proving arbitrary computations over authenticated data, there is however little prior work, especially if one is concerned about achieving practical efficiency. While we review this related work later in Section 6, at this point we mention that the recent work ZQL [FKDL13] aimed to address this problem by considering a three party setting such as the one we presented above. ZQL provides an expression language for (privacy-preserving) processing of data that can be originated (i.e., authenticated) by trusted data sources, and proposes a cryptographic scheme that achieves integrity, privacy, and data independence. However, the current ZQL language has some intrinsic limitations that limit its applicability to arbitrary computations while achieving efficiency (i.e., if the verifier should perform less work than that required to generate the proof). In summary, while we do have efficient zero-knowledge proof systems for arbitrary computations, in the case of proofs on authenticated data the situation is not satisfactory.</p>

    <p class="text-gray-300">Inspired by the goals of ZQL, we formalize a cryptographic primitive for privacy-preserving proofs on authenticated data, and we propose a new realization that achieves the desired efficiency goal for arbitrary computations. We then build a system called ADSNARK and evaluate its performance in comparison with solutions based on the state of the art. More in detail, our contributions are the following.</p>

    <p class="text-gray-300">We fully formalize a model for the above problem by defining a new cryptographic primitive that we call Succinct Non-Interactive Arguments of Knowledge on Authenticated Data (or AD-SNARK,</p>

    <p class="text-gray-300">for short). Succinct Non-Interactive Arguments, first introduced by Micali under the name of “CS proofs” <em>[x13]</em>, are proof systems that provide <em>succinct verification</em>, i.e., the verifier is able to check a long poly-time computation in much less time than that required to run the computation, given the witness. Our new notion of AD-SNARKs extends SNARKs to explicitly capture proofs of <span class="math">\\mathcal{NP}</span> relations <span class="math">R(x,w)</span> in which the statement <span class="math">x</span> (or a part of it) is <em>authenticated</em>. More precisely, the main difference between SNARKs and AD-SNARKs is that in the former, the verifier always knows the statement, whereas in the latter, the authenticated statements are not disclosed to the verifier, yet the verifier can be assured about the existence of <span class="math">w</span> such that <span class="math">R(x,w)</span> holds for the specific <span class="math">x</span> authenticated by some trusted source. Moreover, to model privacy (and looking ahead to our applications) we define the zero-knowledge property to hold not only for the witnesses of the relation, but also for the authenticated statements. In particular, our zero-knowledge definition holds also against adversaries who generate the authentication keys.</p>

    <p class="text-gray-300">Turning our attention to realizations, we show that AD-SNARKs can be constructed in a generic fashion by embedding digital signatures into SNARKs. However, motivated by the fact that this “generic construction” is not efficient in practice, our second contribution is a <em>direct and more efficient realization</em> of AD-SNARKs, that from now on we refer to as ADSNARK. Compared to instantiating the generic construction with state-of-the-art SNARK schemes, ADSNARK performs way better on the prover side, and achieves a level of efficiency that makes it a plausible candidate for real-world deployment. In what follows we give more details on this efficiency aspect: We first discuss the efficiency of the generic construction with state-of-the-art instantiations, and then we describe our solution.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">On the (in)efficiency of the generic construction.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The idea of the generic (not very practical) construction of AD-SNARK for an <span class="math">\\mathcal{NP}</span> relation <span class="math">R(x,w)</span> is to let the prover <span class="math">\\mathcal{P}</span> prove an extended <span class="math">\\mathcal{NP}</span> relation <span class="math">R^{\\prime}</span> which contains the set of tuples <span class="math">(x^{\\prime},w^{\\prime})</span> with $x^{\\prime}=(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\mathsf{pk})<span class="math">, </span>w^{\\prime}=(w,x,\\sigma)<span class="math">, and </span>\\sigma=(\\sigma_{1},\\ldots,\\sigma_{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, such that there is a valid signature </span>\\sigma_{i}<span class="math"> for every statement value </span>x_{i}<span class="math"> at position </span>i<span class="math"> under public key </span>\\mathsf{pk}<span class="math">. The problem with this generic construction is that, in practice, a proof for such extended relation </span>R^{\\prime}<span class="math"> is much more expensive than a proof for </span>R<span class="math">. The issue is that </span>R^{\\prime}<span class="math"> needs to “embed” the verification algorithm of a signature scheme. If we consider very efficient SNARKs, such as the recent optimization of Pinocchio <em>[x11]</em> proposed in <em>[x2]</em>, then embedding the verification algorithm means encoding the verification algorithm of the signature with an arithmetic circuit over a specific finite field </span>\\mathbb{F}_{p}<span class="math"> (where </span>p$ is a large prime, the order of some bilinear groups), and then creating a Quadratic Arithmetic Program <em>[x6]</em>, a QAP for short, out of this circuit. Without going into the details of QAPs (we will review them later in Section 2), we note that the efficiency of the prover in these systems depends on the size of the QAP, which in turn depends on the number of multiplication gates in the relation satisfiability circuit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our main observation is that the circuit resulting from expressing the verification algorithm of a digital signature scheme is very likely to be quite inefficient (from a QAP perspective), especially for the prover. Such inefficiency stems from the fact that the circuit would contain a huge number of multiplication gates. In Section 3.3 we discuss why this is the case for various examples of signatures in both the random oracle and the standard model, and based on different algebraic problems. Our conclusions indicate that a QAP encoding a signature verification circuit is likely to have significantly more that one thousand multiplications for <em>every</em> signature that must be checked. If, for instance, we consider smart-metering, in which the prover wants to certify about 1 000 (signed) meter readings (amounting to approximately 1 month of electricity measurements), the costs can become prohibitive!</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AD-PGHR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ADSNARK</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Improvement</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key Generator</td>

            <td class="px-3 py-2 border-b border-gray-700">299 s</td>

            <td class="px-3 py-2 border-b border-gray-700">16 s</td>

            <td class="px-3 py-2 border-b border-gray-700">18.7×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover</td>

            <td class="px-3 py-2 border-b border-gray-700">491 s</td>

            <td class="px-3 py-2 border-b border-gray-700">20 s</td>

            <td class="px-3 py-2 border-b border-gray-700">24.5×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier</td>

            <td class="px-3 py-2 border-b border-gray-700">0.062 s</td>

            <td class="px-3 py-2 border-b border-gray-700">(PK) 0.61 s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(SK) 0.035 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proving key size</td>

            <td class="px-3 py-2 border-b border-gray-700">319 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">16 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">19.9×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verification key size</td>

            <td class="px-3 py-2 border-b border-gray-700">31 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">31 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">same</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">(PK) 126 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.002×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(SK) 0.4 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.75×</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2. Comparison between ADSNARK and the generic solution (AD-PGHR) based on the [BSCTV14] SNARK considering an arithmetic circuit with 50K multiplication gates and 1000 authenticated inputs. Results obtained by running libsnark for AD-PGHR and our implementation (based on libsnark) of ADSNARK, both at a 128-bits security level.</p>

    <p class="text-gray-300">OUR SOLUTION. In contrast, we propose ADSNARK, a new, direct, AD-SNARK scheme that achieves the same efficiency as state-of-the-art SNARKs, e.g., [BSCTV14], yet it additionally allows for proofs on authenticated statements. Our scheme builds upon an optimized version of Pinocchio proposed and implemented in [BSCTV14], and our key technical contribution is a technique (illustrated in Section 1.2) for embedding the authentication verification mechanism directly in the proof system, without having to resort to extended relations that would incur the efficiency loss discussed earlier. As a result, the performance of our scheme is almost the same as that of running [BSCTV14], but with the additional benefit of obtaining proofs about authenticated values.</p>

    <p class="text-gray-300">When comparing our direct construction with an instantiation of the generic scheme with [BSCTV14], ADSNARK introduces a dramatic improvement (cf. Figure 2 above) in the generation of setup keys (for the relation) and proofs, which is currently the main bottleneck of state-of-the-art SNARKs (e.g., [PGHR13, BSCG+13, BSCTV14]). Namely, while these schemes perform excellently in terms of verification time and proof size, the performances get much worse when it comes to generating keys and proofs, especially for relations that have "unfriendly" arithmetic circuit representations, such as signature verification algorithms, as discussed earlier. This is where our technique for avoiding the explicit encoding of signature verification in the circuits allows us to use much smaller QAPs, thus saving at least one thousand multiplication gates per authenticated input. This improvement is clearly evident in our experimental results that show that the prover can obtain up to a  <span class="math">25 \\times</span>  speed-up (20 s vs. 8 mins) and a  <span class="math">20 \\times</span>  reduction in storage (16 MB vs. 320 MB). As we discuss later, on the verifier side ADSNARK allows for two different verification modes: one using the secret authentication key and one completely public. Although in the secret-key case, ADSNARK essentially achieves the same verification efficiency and proof size of the generic solution, our scheme pays more for public verification. However, in contrast to what happens on the prover side of the generic solution, the public verification of ADSNARK still achieves timing (0.61 s) and proof size (126 KB) that can be definitely considered practical.</p>

    <p class="text-gray-300">The key idea for the construction of our AD-SNARK scheme is to build upon SNARKs based on QAPs, and in particular on the PGHR scheme in [BSCTV14]. At a high level, our technique consists of extending PGHR by embedding a linearly-homomorphic MAC that enforces the prover to run the PGHR's Prove algorithm on correctly authenticated statements.</p>

    <p class="text-gray-300">More precisely, the PGHR verifier, given a statement <span class="math">x=(x_{1},\\ldots,x_{n})</span>, has to compute the linear combination <span class="math">a_{in}=\\sum_{k=1}^{n}x_{k}\\cdot a_{k}(X)</span> (where the <span class="math">a_{k}(X)</span> are the QAP polynomials). However, recall that in AD-SNARKs the verifier does not know the statement <span class="math">x</span>, and thus is not able to compute <span class="math">a_{in}</span>. Our key idea to solve this issue is to shift the computation of the linear combination <span class="math">a_{in}</span> from the verifier to the prover. Then, to enforce a cheating prover to provide the correct <span class="math">a_{in}</span>, we ask the prover to additionally show that <span class="math">a_{in}</span> was indeed obtained by using authenticated values <span class="math">x_{k}</span>. To this end, we employ another proof system, namely efficient linearly-homomorphic MACs <em>[x10, x11]</em>, that are particularly suitable for linear computations over authenticated data. Specifically, we designed a novel homomorphic MAC (which is implicitly embedded in our AD-SNARK construction) that fits the above setting.</p>

    <p class="text-gray-300">This technique, however, does not completely solve the problem: a further complication arises from the fact that in order to achieve zero-knowledge, the value <span class="math">a_{in}</span> computed by the prover must be randomized (by adding a random multiple of the QAP target polynomial <span class="math">z(X)</span>). Unfortunately, homomorphic MACs are known to authenticate only deterministic computations. We solve this issue using the following ideas. First, we provide a novel technique to publicly re-randomize our homomorphic MACs: roughly speaking, by publicly revealing a MAC of <span class="math">z(X)</span>. Second, we enforce the prover to use the same random coefficient for <span class="math">z(X)</span> in both <span class="math">a_{in}</span> and its MAC. Intuitively, this is achieved by asking the prover to provide the linear combination <span class="math">a_{in}</span> in two distinct subspaces. A final observation is that by using a MAC we only get secret-key verification. Although this may not be an issue in several applications, we also show how to further generalize these techniques to obtain public verification.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.3 Organization</h3>

    <p class="text-gray-300">The paper is organized as follows. In Section 2, we recall common definitions and background information on QAPs. Section 3 presents our definition of AD-SNARKs, the generic construction, and a discussion on the efficiency of encoding signature verification with arithmetic circuits. We describe our ADSNARK scheme in Section 4 together with a theoretical evaluation and comparison to the generic solution. In Section 5, we present our implementation and discuss the experimental results. Section 6 discusses further related work, Section 7 provides the description of more application scenarios, and finally Section 8 concludes the paper. The appendix includes additional background and the discussion of two extensions of AD-SNARKs: handling multiple data sources, and achieving (amortized) constant-time verification.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Background</h2>

    <p class="text-gray-300">In this section, we review the notation and some basic definitions that we will use in our work.</p>

    <p class="text-gray-300">Notation. We will denote with <span class="math">\\lambda\\in\\mathbb{N}</span> a security parameter. We say that a function <span class="math">\\epsilon</span> is negligible if it vanishes faster than the inverse of any polynomial. If not explicitly specified otherwise, negligible functions are negligible with respect to <span class="math">\\lambda</span>. If <span class="math">S</span> is a set, <span class="math">x\\leftarrow_{\\mathcal{R}}S</span> denotes the process of selecting <span class="math">x</span> uniformly at random in <span class="math">S</span>. If <span class="math">\\mathcal{A}</span> is a probabilistic algorithm, <span class="math">x\\leftarrow_{\\mathcal{R}}\\mathcal{A}(\\cdot)</span> denotes the process of running <span class="math">\\mathcal{A}</span> on some appropriate input and assigning its output to <span class="math">x</span>. Moreover, for a positive integer <span class="math">n</span>, we denote by <span class="math">[n]</span> the set <span class="math">\\{1,\\ldots,n\\}</span>. We denote by <span class="math">\\mathbb{F}</span> a finite field and <span class="math">\\mathbb{F}_{n}</span> is the field of size <span class="math">n</span>. When <span class="math">n</span> is a prime number, then elements of <span class="math">\\mathbb{F}_{n}</span> are represented as integers modulo <span class="math">n</span>. Elements of <span class="math">\\mathbb{F}</span> are typically denoted by greek letters. <span class="math">\\mathbb{F}[X]</span> denotes the field of polynomials in one variable <span class="math">X</span> and coefficients in <span class="math">\\mathbb{F}</span>, while <span class="math">\\mathbb{F}^{\\leq d}[X]</span> is the subring of polynomials in <span class="math">\\mathbb{F}[X]</span> of degree at most <span class="math">d</span>.</p>

    <p class="text-gray-300">Figure 3. Part (a): A bilinear gate representing the arithmetic function  <span class="math">(7 + 3s_{1} - 1s_{2})\\cdot (2 + s_{2} - 4s_{3})</span>  specified by coefficients  <span class="math">a</span>  and  <span class="math">b</span> . !<a href="img-1.jpeg">img-1.jpeg</a> Part (b): A QAP for an arithmetic circuit with 4 input wires, 1 output wire, 3 bilinear gates. The circuit encodes the function  <span class="math">f(s_{1}, s_{2}, s_{3}, s_{4}) = (4 + 2s_{1} + s_{2}) \\cdot (5 + s_{1} + 3s_{2}) \\cdot (1 + 4s_{3} + 3s_{4}) \\cdot (3 + 2s_{4})</span> . The non-zero equations for the QAP polynomials are shown on the right.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">Algebraic Tools. Let  <span class="math">\\mathcal{G}(1^{\\lambda})</span>  be an algorithm that, upon input of the security parameter  <span class="math">1^{\\lambda}</span> , outputs the description of (asymmetric) bilinear groups  <span class="math">\\mathsf{bgpp} = (p,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,\\mathcal{P}_1,\\mathcal{P}_2)</span>  where  <span class="math">\\mathbb{G}_1,\\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span>  are groups of the same prime order  <span class="math">p &amp;gt; 2^{\\lambda}</span> ;  <span class="math">\\mathcal{P}_1\\in \\mathbb{G}_1</span>  and  <span class="math">\\mathcal{P}_2\\in \\mathbb{G}_2</span>  are the respective generators; and  <span class="math">e:\\mathbb{G}_1\\times \\mathbb{G}_2\\to \\mathbb{G}_T</span>  is an efficiently computable bilinear map. We call such an algorithm  <span class="math">\\mathcal{G}</span>  a bilinear group generator. Note that  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are additive groups, whereas  <span class="math">\\mathbb{G}_T</span>  is a multiplicative group. In this work we rely on specific computational assumptions in such bilinear groups: the  <span class="math">q</span> -DHE [CKS09], the  <span class="math">q</span> -BDHE [BBG05], and the  <span class="math">q</span> -PKE [Gro10] assumptions.</p>

    <p class="text-gray-300">Arithmetic Circuits and Quadratic Arithmetic Programs. An arithmetic circuit  <span class="math">C</span>  over a finite field  <span class="math">\\mathbb{F}</span>  consists of addition and multiplication gates and of a set of wires between the gates. The wires carry values over  <span class="math">\\mathbb{F}</span> . As in previous work [BSCTV14], here we consider only arithmetic circuits with bilinear gates: a gate with inputs  <span class="math">\\vec{x} = (x_1, \\ldots, x_k)</span>  is bilinear if its output can be written as inner product  <span class="math">\\langle \\vec{a}, (1, x_1, \\ldots, x_k) \\rangle \\cdot \\langle \\vec{b}, (1, x_1, \\ldots, x_k) \\rangle</span>  for some  <span class="math">\\vec{a}, \\vec{b} \\in \\mathbb{F}^{k+1}</span> . Note that this definition includes addition, multiplication, and constant gates (cf. Fig. 3(a) for an example).</p>

    <p class="text-gray-300">Associated to any arithmetic circuit, we define a satisfaction problem as follows.</p>

    <p class="text-gray-300">Definition 1 (Arith. Circuit Satisfaction [BSCTV14]). The circuit satisfaction problem of a circuit  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  with bilinear gates is defined by the relation  <span class="math">\\mathcal{R}_C = \\{(\\vec{x}, \\vec{w}) \\in \\mathbb{F}^n \\times \\mathbb{F}^h : C(\\vec{x}, \\vec{w}) = 0^l\\}</span>  and its language is  <span class="math">\\mathcal{L}_C = \\{\\vec{x} \\in \\mathbb{F}^n : \\exists \\vec{w} \\in \\mathbb{F}^h, C(\\vec{x}, \\vec{w}) = 0^l\\}</span> .</p>

    <p class="text-gray-300">The state-of-the-art SNARK schemes that we build on in this paper directly operate on a different model to represent computations called quadratic arithmetic programs (QAPs).</p>

    <p class="text-gray-300">Definition 2 (QAP [GGPR13]). A quadratic arithmetic program  <span class="math">Q</span>  of size  <span class="math">m</span>  and degree  <span class="math">d</span>  over  <span class="math">\\mathbb{F}</span>  consists of three vectors of  <span class="math">m + 1</span>  polynomials  <span class="math">\\vec{a}, \\vec{b}, \\vec{c} \\in \\mathbb{F}^{\\leq d - 1}[X]</span>  of degree at most  <span class="math">d - 1</span> , and a target polynomial  <span class="math">z(X) \\in \\mathbb{F}[X]</span>  of degree exactly  <span class="math">d</span> .</p>

    <p class="text-gray-300">Associated to any QAP, there is a satisfaction problem defined as follows.</p>

    <p class="text-gray-300">Definition 3 (QAP Satisfaction). The satisfaction problem of a QAP <span class="math">Q = (\\vec{a}, \\vec{b}, \\vec{c}, z)</span> of size <span class="math">m</span> and degree <span class="math">d</span> is the relation <span class="math">\\mathcal{R}_Q</span> of pairs <span class="math">(\\vec{x}, \\vec{s})</span> such that:</p>

    <p class="text-gray-300">(1) <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>, <span class="math">\\vec{s} \\in \\mathbb{F}^m</span> for some <span class="math">n \\leq m</span>; (2) <span class="math">x_i = s_i</span> for <span class="math">i \\in [n]</span>, i.e., <span class="math">\\vec{s}</span> extends <span class="math">\\vec{x}</span>; (3) <span class="math">z(X)</span> divides the polynomial <span class="math">p(X)</span> defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} p(X) = \\left(a_0(X) + \\sum_{i=1}^{m} s_i a_i(X)\\right) \\cdot \\left(b_0(X) + \\sum_{i=1}^{m} s_i b_i(X)\\right) \\\\ \\quad - \\left(c_0(X) + \\sum_{i=1}^{m} s_i c_i(X)\\right) \\end{array}</span></div>

    <p class="text-gray-300">The following result implies that one can use any QAP-based SNARK scheme as an efficient SNARK scheme taking computations more conveniently represented as arithmetic circuits.</p>

    <p class="text-gray-300">Lemma 1 (Constructing QAPs [GGPR13, BSCTV14]). There exist two polynomial time algorithms QAPInst and QAPwit such that, for any circuit <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span> with <span class="math">u</span> wires and <span class="math">v</span> (bilinear) gates, <span class="math">Q_C = (\\vec{a}, \\vec{b}, \\vec{c}, z) = \\text{QAPInst}(C)</span> is a QAP of size <span class="math">m</span> and degree <span class="math">d</span> over <span class="math">\\mathbb{F}</span> satisfying the following properties:</p>

    <p class="text-gray-300">Efficiency: <span class="math">m = u</span>, and <span class="math">d = v + l + 1</span>.</p>

    <p class="text-gray-300">Completeness: For any <span class="math">(\\vec{x},\\vec{w}) \\in \\mathcal{R}_C</span>, if it holds that <span class="math">\\vec{s} = \\text{QAPwit}(C, \\vec{x},\\vec{w})</span> then <span class="math">(\\vec{x},\\vec{s}) \\in \\mathcal{R}_{Q_C}</span>.</p>

    <p class="text-gray-300">Proof of Knowledge: For any <span class="math">(\\vec{x}, \\vec{s}) \\in \\mathcal{R}_{Q_C}</span>, it holds <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span> where <span class="math">\\vec{w}</span> is a prefix of <span class="math">\\vec{s}</span>.</p>

    <p class="text-gray-300">Non-Degeneracy: the polynomials <span class="math">a_0(X), \\ldots, a_n(X)</span> are all nonzero and distinct.</p>

    <p class="text-gray-300">The very basic intuition for building a QAP according to Lemma 1 is to encode the input-output correctness for each bilinear gate in the polynomials <span class="math">\\vec{a}, \\vec{b}, \\vec{c}, z</span> (see Fig. 3(b) for a simple example). Slightly more in detail, for a gate <span class="math">g</span> this is done by first selecting an arbitrary value <span class="math">r_g \\in \\mathbb{F}</span> (a "root") and then, for every left wire <span class="math">i</span> going to gate <span class="math">g</span>, one imposes <span class="math">a_i(r_g) = c</span>, where <span class="math">c</span> is the coefficient which multiplies the value of wire <span class="math">i</span> in <span class="math">g</span>'s left input (note that <span class="math">c = 0</span> if wire <span class="math">i</span> is not a left input). A similar process is done for polynomials <span class="math">b_i</span> and <span class="math">c_i</span> w.r.t. right input and output wires respectively. Once this procedure has been iterated for every bilinear gate <span class="math">g</span> (selecting distinct roots <span class="math">r_g</span>), one will have essentially obtained three tables of size <span class="math">u \\cdot v</span> with entries <span class="math">a_i(r_j), b_i(r_j)</span>, and <span class="math">c_i(r_j)</span>, respectively, where <span class="math">i = 0</span> to <span class="math">u</span> are all the wires (where the 0 wire represents constants) and <span class="math">j = 1</span> to <span class="math">v</span> are all the bilinear gates. The final QAP polynomials <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span> are built by extending each row <span class="math">i</span> of the table into a polynomial <span class="math">a_i(X)</span> (resp. <span class="math">b_i(X), c_i(X)</span>) of degree <span class="math">v - 1</span> via interpolation in <span class="math">\\mathbb{F}</span>. The target polynomial <span class="math">z(X)</span> is the degree-<span class="math">v</span> polynomial defined over the roots <span class="math">r_g</span> of the <span class="math">v</span> bilinear gates: <span class="math">z(X) := \\prod_{g=1}^{v} (X - r_g)</span>. To see why the satisfiability of the QAP implies the satisfiability of the circuit, the key observation is that the third condition of Definition 3, i.e., <span class="math">z(X) \\mid p(X)</span>, means that <span class="math">\\langle (1, \\vec{s}), \\vec{a}(r_g) \\rangle \\cdot \\langle (1, \\vec{s}), \\vec{b}(r_g) \\rangle = \\langle (1, \\vec{s}), \\vec{c}(r_g) \\rangle</span> for all roots <span class="math">r_g</span> of the target polynomial <span class="math">z(X)</span>. In other words, given the specific construction of the polynomials, the input-output correctness of every bilinear gate <span class="math">g</span> of the circuit is satisfied.</p>

    <p class="text-gray-300">6 The case of <span class="math">c_i</span> is slightly different as coefficients are only 0 or 1.</p>

    <p class="text-gray-300">7 More precisely, in construction of Lemma 1 one needs to add one "artificial" bilinear gate for every output wire, plus an additional constraint to guarantee non-degeneracy: from which the final degree is <span class="math">d = v + l + 1</span>.</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">3 Zero-Knowledge SNARKs over Authenticated Data</p>

    <p class="text-gray-300">In this section, we define the notion of SNARKs <em>[x19, x3]</em> on authenticated data (AD-SNARKs, for short). Let <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}^{l}</span> be an arithmetic circuit, and let <span class="math">\\mathcal{R}_{C}=\\{(\\overrightarrow{x},\\overrightarrow{w})\\}\\subseteq\\mathbb{F}^{n}\\times\\mathbb{F}^{h}</span> be the corresponding circuit satisfaction relation, where <span class="math">\\overrightarrow{x}\\in\\mathbb{F}^{n}</span> is called the <em>statement</em>, and <span class="math">\\overrightarrow{w}\\in\\mathbb{F}^{h}</span> is the <em>witness</em>.</p>

    <p class="text-gray-300">Proof systems for the circuit satisfaction of <span class="math">C</span> typically consider the problem in which a prover <span class="math">\\mathcal{P}</span> tries to convince a verifier <span class="math">\\mathcal{V}</span> about the existence of a witness <span class="math">\\overrightarrow{w}</span> such that <span class="math">(\\overrightarrow{x},\\overrightarrow{w})\\in\\mathcal{R}_{C}</span>. In this scenario, the statement <span class="math">\\overrightarrow{x}</span> is supposed to be public, i.e., it is known to both the prover and the verifier. For example, <span class="math">\\mathcal{V}</span> could be convinced by <span class="math">\\mathcal{P}</span> that 3 colors are sufficient to color a public graph <span class="math">\\overrightarrow{x}</span> such that no two adjacent vertices are assigned the same color. The coloring serves as witness <span class="math">\\overrightarrow{w}</span>.</p>

    <p class="text-gray-300">In this work, we consider a variation of the above problem in setting in which (1) the statement <span class="math">\\overrightarrow{x}</span> (or part of it) is provided to the prover by a trusted source <span class="math">\\mathcal{S}</span>, and (2) the portion of <span class="math">\\overrightarrow{x}</span> provided by <span class="math">\\mathcal{S}</span> is not known to <span class="math">\\mathcal{V}</span> (see Figure 1 for illustration). Yet, <span class="math">\\mathcal{V}</span> wants to be convinced by <span class="math">\\mathcal{P}</span> that <span class="math">(\\overrightarrow{x},\\overrightarrow{w})\\in\\mathcal{R}_{C}</span> holds for the specific <span class="math">\\overrightarrow{x}</span> provided by <span class="math">\\mathcal{S}</span>, and not for some other <span class="math">\\overrightarrow{x}^{\\prime}</span> of <span class="math">\\mathcal{P}</span>’s choice (which can still be in the language <span class="math">\\mathcal{L}_{C}</span>). For example, <span class="math">\\mathcal{S}</span> might have provided a graph <span class="math">\\overrightarrow{x}</span> – not known to <span class="math">\\mathcal{V}</span> – for which <span class="math">\\mathcal{P}</span> proves to <span class="math">\\mathcal{V}</span> that <span class="math">\\overrightarrow{x}</span> is 3-colorable. A proof for any other graph <span class="math">\\overrightarrow{x}^{\\prime}</span> is meaningless.</p>

    <p class="text-gray-300">To formalize the idea that <span class="math">\\mathcal{V}</span> checks that some values unknown to <span class="math">\\mathcal{V}</span> have been authenticated by <span class="math">\\mathcal{S}</span>, we adopt the concept of <em>labeling</em> used for homomorphic authenticators <em>[x13, x4]</em>. Namely, we assume that the source <span class="math">\\mathcal{S}</span> authenticates a set of values <span class="math">X_{\\mathit{auth}}=\\{x_{i},\\ldots,x_{\\ell}\\}</span> against a set of (public) labels <span class="math">\\mathsf{L}=\\{\\mathsf{L}_{i},\\ldots,\\mathsf{L}_{\\ell}\\}</span> by using a secret authentication key (e.g., a signing key). <span class="math">\\mathcal{S}</span> then sends the authenticated <span class="math">X_{\\mathit{auth}}</span> to <span class="math">\\mathcal{P}</span>. Later, <span class="math">\\mathcal{P}</span>’s goal is to prove to <span class="math">\\mathcal{V}</span> that <span class="math">(\\overrightarrow{x},\\overrightarrow{w})\\in\\mathcal{R}_{C}</span> for a statement <span class="math">\\overrightarrow{x}</span> in which some positions have been correctly authenticated by <span class="math">\\mathcal{S}</span>, i.e., <span class="math">x_{i}\\in X_{\\mathit{auth}}</span> for some <span class="math">i\\in[n]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For such a proof system, we define the usual properties of <em>completeness</em> and <em>soundness</em>, and in addition, to model privacy, we define a <em>zero-knowledge</em> property. Moreover, since we are interested in efficient and scalable protocols, we define <em>succinctness</em> to model that the size of the proofs (and implicitly the verifier’s running time) should be independent of the witness’ size $h=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overrightarrow{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Finally, we consider AD-SNARKs that can have either public or secret verifiability, the difference being in whether the adversary knows or not the verification key for the authentication tags produced by the data source </span>\\mathcal{S}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 SNARKs over Authenticated Data</h3>

    <p class="text-gray-300">First, we provide the formal definition for SNARGs over authenticated data. The definition of SNARGs of knowledge (i.e., SNARKs) over authenticated data is provided later.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 4 (AD-SNARG)</h6>

    <p class="text-gray-300">A scheme for <em>Succinct Non-interactive Arguments over Authenticated Data</em> (AD-SNARG, for short) for arithmetic circuit satisfiability consists of a tuple of algorithms <span class="math">(\\mathsf{Setup},\\mathsf{AuthKG},\\mathsf{Auth},\\mathsf{AuthVer},\\mathsf{Gen},\\mathsf{Prove},\\mathsf{Ver})</span> satisfying <em>authentication correctness, completeness, succinctness</em>, and <em>adaptive soundness</em> (as defined below):</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda})</span>: On input the security parameter <span class="math">\\lambda</span>, output some common public parameters <span class="math">\\mathsf{pp}</span>. The parameters also define the finite field <span class="math">\\mathbb{F}</span> over which the circuits will be defined. <span class="math">\\mathsf{AuthKG}(\\mathsf{pp})</span>: given the public parameters <span class="math">\\mathsf{pp}</span>, the key generation algorithm outputs a secret authentication key <span class="math">\\mathsf{sk}</span>, a verification key <span class="math">\\mathsf{vk}</span>, and public authentication parameters <span class="math">\\mathsf{pap}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Auth}(\\mathsf{sk},\\mathsf{L},x)</span>: the authentication algorithm takes as input the secret authentication key <span class="math">\\mathsf{sk}</span>, a label <span class="math">\\mathsf{L}\\in\\mathcal{L}</span>, and a value <span class="math">x\\in\\mathbb{F}</span>, and it outputs an authentication tag <span class="math">\\sigma</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AuthVer}(\\mathsf{vk},\\sigma,\\mathsf{L},x)</span>: the authentication verification algorithm takes as input a verification key <span class="math">\\mathsf{vk}</span>, a tag <span class="math">\\sigma</span>, a label <span class="math">\\mathsf{L}\\in\\mathcal{L}</span>, and a value <span class="math">x\\in\\mathbb{F}</span>. It outputs <span class="math">\\perp</span> (reject) or <span class="math">\\top</span> (accept).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Gen}(\\mathsf{pap},C)</span>: given the public authentication parameters <span class="math">\\mathsf{pap}</span> and an arithmetic circuit <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}^{l}</span>, the algorithm outputs an evaluation key <span class="math">\\mathsf{EK}_{C}</span> and a verification key <span class="math">\\mathsf{VK}_{C}</span>. <span class="math">\\mathsf{Gen}</span> can hence be seen as a circuit encoding algorithm.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}(\\mathsf{EK}_{C},\\overrightarrow{x},\\overrightarrow{w},\\overrightarrow{\\sigma})</span>: on input an evaluation key <span class="math">\\mathsf{EK}_{C}</span>, a statement <span class="math">\\overrightarrow{x}\\in\\mathbb{F}^{n}</span>, a witness <span class="math">\\overrightarrow{w}\\in\\mathbb{F}^{h}</span>, and authentication tags for the statement <span class="math">\\overrightarrow{\\sigma}=(\\sigma_{1},\\ldots,\\sigma_{n})</span>, the proof algorithm outputs a proof of membership <span class="math">\\pi</span> for <span class="math">(\\overrightarrow{x},\\overrightarrow{w})\\in\\mathcal{R}_{C}</span>. We stress that <span class="math">\\overrightarrow{\\sigma}</span> does not need to contain authentication tags for all positions: in case a value at position <span class="math">i</span> is not authenticated, the empty tag <span class="math">\\sigma_{i}=\\star</span> is used instead.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ver}(\\mathsf{vk},\\mathsf{VK}_{C},\\overrightarrow{\\mathsf{L}},\\{x_{i}\\}_{\\mathsf{L}_{i}=\\star},\\pi)</span>: given the verification key <span class="math">\\mathsf{vk}</span>, a circuit verification key <span class="math">\\mathsf{VK}_{C}</span>, labels <span class="math">\\overrightarrow{\\mathsf{L}}=({\\mathsf{L}}_{1},\\ldots,{\\mathsf{L}}_{n})</span> for the statement, unauthenticated statement components <span class="math">x_{i}</span>, and a proof <span class="math">\\pi</span>, the verification algorithm outputs <span class="math">\\perp</span> (reject) or <span class="math">\\top</span> (accept).</p>

    <p class="text-gray-300">Authentication Correctness. Intuitively, an AD-SNARG scheme has authentication correctness if any tag <span class="math">\\sigma</span> generated by <span class="math">\\mathsf{Auth}(\\mathsf{sk},\\mathsf{L},x)</span> authenticates <span class="math">x</span> with respect to <span class="math">\\mathsf{L}</span>. More formally, we say that a AD-SNARG scheme satisfies authentication correctness if for any value <span class="math">x\\in\\mathbb{F}</span>, all keys <span class="math">(\\mathsf{sk},\\mathsf{vk},\\mathsf{pap})\\leftarrow_{\\mathcal{R}}\\mathsf{AuthKG}(1^{\\lambda})</span>, any label <span class="math">\\mathsf{L}\\in\\mathcal{L}</span>, and any authentication tag <span class="math">\\sigma\\leftarrow_{\\mathcal{R}}\\mathsf{Auth}(\\mathsf{sk},\\mathsf{L},x)</span>, we have that <span class="math">\\mathsf{AuthVer}(\\mathsf{vk},\\sigma,\\mathsf{L},x)=\\top</span> with probability 1.</p>

    <p class="text-gray-300">Completeness. This property aims at capturing that if the <span class="math">\\mathsf{Prove}</span> algorithm produces <span class="math">\\pi</span> when run on <span class="math">(\\overrightarrow{x},\\overrightarrow{w},\\overrightarrow{\\sigma})</span> for some <span class="math">(\\overrightarrow{x},\\overrightarrow{w})\\in\\mathcal{R}_{C}</span>, then verification <span class="math">\\mathsf{Ver}(\\mathsf{vk},\\mathsf{VK}_{C},\\mathsf{L},\\{x_{i}\\}_{\\mathsf{L}_{i}=\\star},\\pi)</span> must output <span class="math">\\top</span> with probability 1 whenever <span class="math">\\mathsf{AuthVer}(\\mathsf{vk},\\sigma_{i},\\mathsf{L}_{i},x_{i})=\\top</span>. More formally, let us fix <span class="math">(\\mathsf{sk},\\mathsf{vk},\\mathsf{pap})\\leftarrow_{\\mathcal{R}}\\mathsf{AuthKG}(\\mathsf{pp})</span>, and a circuit <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}^{l}</span> with keys <span class="math">(\\mathsf{EK}_{C},\\mathsf{VK}_{C})\\leftarrow_{\\mathcal{R}}\\mathsf{Gen}(\\mathsf{pap},C)</span>. Let <span class="math">(\\overrightarrow{x},\\overrightarrow{w})\\in\\mathcal{R}_{C}</span> be given. Let <span class="math">\\overrightarrow{\\mathsf{L}}=({\\mathsf{L}}_{1},\\ldots,{\\mathsf{L}}_{n})\\in(\\mathcal{L}\\cup\\{\\star\\})^{n}</span> be a vector of labels, and let <span class="math">\\overrightarrow{\\sigma}=(\\sigma_{1},\\ldots,\\sigma_{n})</span> be tags for the statement such that <span class="math">\\{\\mathsf{AuthVer}(\\mathsf{vk},\\sigma_{i},\\mathsf{L}_{i},x_{i})=\\top\\}_{\\mathsf{L}_{i}\\neq\\star}</span>. Then if <span class="math">\\pi\\leftarrow_{\\mathcal{R}}\\mathsf{Prove}(\\mathsf{EK}_{C}</span>, <span class="math">\\overrightarrow{x},\\overrightarrow{w},\\overrightarrow{\\sigma})</span>, we have that <span class="math">\\mathsf{Ver}(\\mathsf{vk},\\mathsf{VK}_{C},\\overrightarrow{\\mathsf{L}},\\{x_{i}\\}_{\\mathsf{L}_{i}=\\star},\\pi)=\\top</span> with probability 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinctness. Given a circuit <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}^{l}</span>, the length of the proof <span class="math">\\pi</span> is bounded by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda)\\mathrm{polylog}(n,h)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Adaptive Soundness. Intuitively, the soundness property captures that no malicious party can produce proofs that verify correctly for a statement which is not in the language. We formalize our definition via an experiment, called <span class="math">\\mathbf{Exp}_{\\mathcal{A}}^{\\mathsf{AD-Soundness}}</span>, which is described in Figure 4. The experiment is parametrized by an adversary <span class="math">\\mathcal{A}</span> who is given access to three oracles (aka procedures) <span class="math">\\mathbf{Gen}</span>, <span class="math">\\mathbf{Auth}</span>, and <span class="math">\\mathbf{Ver}</span> that can be (concurrently) run.</p>

    <p class="text-gray-300">The three procedures <span class="math">\\mathbf{Gen}</span>, <span class="math">\\mathbf{Auth}</span>, and <span class="math">\\mathbf{Ver}</span> essentially give to the adversary oracle access to the algorithms <span class="math">\\mathsf{Gen}</span>, <span class="math">\\mathsf{Auth}</span>, and <span class="math">\\mathsf{Ver}</span>, respectively, with some additional bookkeeping information. In particular, it is worth noting that <span class="math">\\mathbf{Ver}</span> returns the output of <span class="math">\\mathsf{Ver}</span>, and additionally, checks whether a proof accepted by <span class="math">\\mathsf{Ver}</span> (i.e., <span class="math">v=\\top</span>) proves a false statement according to <span class="math">\\mathcal{R}_{C}</span>. In this case, <span class="math">\\mathbf{Ver}</span> sets <span class="math">\\mathsf{GameOutput}\\leftarrow 1</span>.</p>

    <p class="text-gray-300">More formally, let <span class="math">\\mathcal{C}</span> be a class of circuits. Then for any <span class="math">\\lambda\\in\\mathbb{N}</span>, we define the advantage of an adversary <span class="math">\\mathcal{A}</span> in the experiment <span class="math">\\mathbf{Exp}_{\\mathcal{A}}^{\\mathsf{AD-Soundness}}(\\mathcal{C},1^{\\lambda})</span> against <span class="math">\\mathsf{AD-Soundness}</span> for <span class="math">\\mathcal{C}</span> as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\mathcal{A}}^{\\mathsf{AD-Soundness}}(\\mathcal{C},\\lambda)\\ =\\ \\Pr[\\mathbf{Exp}_{\\mathcal{A}}^{\\mathsf{AD-Soundness}}(\\mathcal{C},1^{\\lambda})=1].</span></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 4. Game AD-Soundness.</p>

    <p class="text-gray-300">An AD-SNARK with respect to a class of circuits  <span class="math">\\mathcal{C}</span>  is adaptive computationally sound if for any PPT  <span class="math">\\mathcal{A}</span> , it holds that  <span class="math">\\mathbf{Adv}_{\\mathcal{A}}^{\\mathrm{AD-Soundness}}(\\mathcal{C},\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Our soundness definition is inspired by the security definition for homomorphic MACs [GW13, CF13, BFR13]. The catch here is that there are essentially two ways to create a "cheating proof", and thus to break the soundness of an AD-SNARG. The first way, Type 1, is to produce an accepting proof without having ever queried an authentication tag for a label  <span class="math">\\mathsf{L}_i</span> . This basically captures that, in order to create a valid proof, one needs to have all authenticated parts of the statement, each with a valid authentication tag. The second way to break the security, Type 2, is the more "classical" one, i.e., generating a proof that accepts for a tuple  <span class="math">(\\vec{x},\\vec{w})</span>  which is not the correct one, i.e.,  <span class="math">\\vec{x} \\notin \\mathcal{L}_C</span> .</p>

    <p class="text-gray-300">Second, we note that the above game definition captures the setting in which the verification key  <span class="math">\\mathsf{vk}</span>  is kept secret. The definition for the publicly verifiable setting is obtained by providing  <span class="math">\\mathsf{vk}</span>  to the adversary.</p>

    <p class="text-gray-300">AD-SNARKs. An AD-SNARG of knowledge (AD-SNARK) is an AD-SNARG where adaptive soundness is strengthened as follows.</p>

    <p class="text-gray-300">Definition 5 (AD-SNARK). A tuple of algorithms (Setup, AuthKG, Auth, AuthVer, Gen, Prove, Ver) is an AD-SNARK if it is an AD-SNARG where adaptive soundness is replaced by the stronger property of adaptive proof of knowledge (as defined below).</p>

    <p class="text-gray-300">ADAPTIVE PROOF OF KNOWLEDGE. Consider a variation of the adaptive soundness experiment that is parametrized by an additional algorithm  <span class="math">E</span>  called the extractor. Both  <span class="math">\\mathcal{A}</span>  and  <span class="math">E</span>  run on exactly the same input and random tape, including some auxiliary input  <span class="math">z</span> .  <span class="math">E</span>  is an algorithm that, for every verification query of  <span class="math">\\mathcal{A}</span>  that is accepted by the Ver algorithm, outputs a witness  <span class="math">\\vec{w}</span> . One should think of such  <span class="math">E</span>  as  <span class="math">\\mathcal{A}</span>  itself, and the extraction capability intuitively means that if  <span class="math">\\mathcal{A}</span>  is able to produce an accepting proof, then  <span class="math">\\mathcal{A}</span>  must know the corresponding witness, and thus such witness can be extracted from  <span class="math">\\mathcal{A}</span> 's memory. A detailed description of the experiment procedures is presented in Figure 5.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 5. Experiment for the adaptive proof of knowledge definition.</p>

    <p class="text-gray-300">Then we say that a scheme ADSNARK satisfies adaptive proof of knowledge for  <span class="math">\\mathcal{C}</span>  if for any sufficiently large  <span class="math">\\lambda \\in \\mathbb{N}</span> , and for every PPT adversary  <span class="math">\\mathcal{A}</span> , there exists a PPT extractor  <span class="math">E</span>  such that for every polynomial-size auxiliary input  <span class="math">z \\in \\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span>  the probability  <span class="math">\\operatorname*{Pr}[\\mathbf{Exp}_{\\mathcal{A},E}^{\\mathrm{AD - PoK}}(\\mathcal{C},\\lambda,z) = 1]</span>  is negligible.</p>

    <p class="text-gray-300">Zero-Knowledge AD-SNARKs. Finally we extend the AD-SNARK definition with the zero-knowledge property. Loosely speaking, a zero-knowledge AD-SNARK is an AD-SNARK in which the Prove algorithm generates proofs  <span class="math">\\pi</span>  that reveal no information: neither about the witness, nor about the authenticated statements. In other words, the proofs do not reveal anything beyond what is known by the verifiers when checking a proof. A formal definition follows.</p>

    <p class="text-gray-300">Definition 6 (Zero-Knowledge AD-SNARKs). A zero-knowledge AD-SNARK is an AD-SNARK that satisfies the following additional property "ZERO-KNOWLEDGE". Let  <span class="math">C \\in \\mathcal{C}</span>  be an arithmetic circuit. Then there exists a simulator  <span class="math">\\mathrm{Sim} = (\\mathrm{Sim}_1, \\mathrm{Sim}_2)</span> , such that for all PPT distinguishers  <span class="math">\\mathcal{D}</span> , the following difference is negligible</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">| \\Pr [ \\mathbf {E x p} _ {R e a l} ^ {\\mathcal {D}, C} (1 ^ {\\lambda}) = 1 ] - \\Pr [ \\mathbf {E x p} _ {S i m} ^ {\\mathcal {D}, C} (1 ^ {\\lambda}) = 1 ] | $$</p>

    <p class="text-gray-300">where the experiments Real and Sim are defined as follows:</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">Note that the distinguisher <span class="math">\\mathcal{D}</span> in the above game has a shared state that is persistent over all invocations of <span class="math">\\mathcal{D}</span> during an experiment.</p>

    <p class="text-gray-300">We stress that the above zero-knowledge notion aims at capturing, in the strongest possible sense, that the verifier cannot learn any useful information on the inputs, even if it knows (or chooses) the secret authentication key. Indeed, as one can see, our definition allows the distinguisher to choose the authentication key pair as well as the authentication tags.</p>

    <p class="text-gray-300">Interestingly, we note that the notion of AD-SNARKs immediately implies a corresponding notion of verifiable computation on authenticated data (similar to [BFR13]). In [BCCT12], it is discussed how to construct a verifiable computation scheme from SNARGs for <span class="math">\\mathcal{NP}</span> with adaptive soundness. This is simply based on the fact that the correctness of a computation can be described with an <span class="math">\\mathcal{NP}</span> statement. It is not hard to see that, in a very similar way, one can construct verifiable computation on authenticated data from AD-SNARKs.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.2 A Generic Construction of Zero-Knowledge AD-SNARKs</h2>

    <p class="text-gray-300">We show how to construct a zero-knowledge AD-SNARK scheme from SNARKs and digital signatures. A similar construction was informally sketched in [BCCT12][Appendix 10.1.2 of the full version]. Here we make it more formal with the main purpose of offering a comparison with our direct AD-SNARK construction proposed in the next section.</p>

    <p class="text-gray-300">The high-level idea of the generic construction is to embed digital signatures into SNARKs. Let therefore <span class="math">\\Pi&#x27; = (\\mathsf{Gen}&#x27;, \\mathsf{Prove}&#x27;, \\mathsf{Ver}&#x27;)</span> be a SNARK scheme, and <span class="math">\\Sigma = (\\Sigma .\\mathsf{KG}, \\Sigma .\\mathsf{Sign}, \\Sigma .\\mathsf{Ver})</span> be a signature scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will use the signature scheme to sign pairs consisting of a label <span class="math">\\mathsf{L}</span> and an actual message <span class="math">m</span>. Although labels and messages can be arbitrary binary strings, for ease of description we assume that labels can take a special value <span class="math">\\star</span>. Also, we modify the signature scheme in such a way that $\\Sigma .\\mathrm{Sign}(\\mathsf{sk},\\star</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m) = \\star<span class="math"> and </span>\\Sigma .\\mathrm{Ver}(\\mathsf{vk},\\star</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m',\\star) = 1<span class="math">. Basically, we let everyone (trivially) generate a valid signature on a message with label </span>\\star$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define an AD-SNARK <span class="math">\\Pi = (\\mathsf{Setup},\\mathsf{AuthKG},\\mathsf{Auth},\\mathsf{AuthVer},\\mathsf{Prove},\\mathsf{Ver})</span> as follows.</p>

    <p class="text-gray-300">Setup(1^λ): Output <span class="math">\\mathsf{pp} = 1^{\\lambda}</span>.</p>

    <p class="text-gray-300">AuthKG(pp): run <span class="math">(\\mathsf{sk}&#x27;,\\mathsf{vk}&#x27;)\\gets_{\\mathcal{R}}\\Sigma .\\mathsf{KG}(1^{\\lambda})</span> to generate the key pair of the signature scheme and return <span class="math">\\mathsf{sk} = \\mathsf{sk}&#x27;</span> and <span class="math">\\mathsf{vk} = \\mathsf{pap} = \\mathsf{vk}&#x27;</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Auth(sk, L, x): compute a signature on the concatenation of the label L and the value x, i.e., $\\sigma' \\gets \\Sigma .\\mathrm{Sign}(\\mathsf{sk}',\\mathsf{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)<span class="math">. Finally, output </span>\\sigma = (\\sigma',\\mathsf{L})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AuthVer(vk, <span class="math">\\sigma, \\mathsf{L}, x</span>): let <span class="math">\\sigma = (\\sigma&#x27;, \\mathsf{L}&#x27;)</span>. Output the result of the signature verification algorithm $\\mathsf{Ver}'(\\mathsf{vk}', \\mathsf{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, \\sigma')$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gen(pap, C): for the given circuit <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span> we define <span class="math">C&#x27;</span> as the circuit that outputs <span class="math">0^l</span> on all the pairs <span class="math">(\\vec{x}, \\vec{w})</span> such that <span class="math">C(\\vec{x}, \\vec{w}) = 0^l</span> and each <span class="math">x_i</span> is correctly signed with respect to a set of labels and a public key. More formally, define <span class="math">C&#x27;: \\mathbb{F}^{n&#x27;} \\times \\mathbb{F}^{h&#x27;} \\to \\mathbb{F}^l</span> as the circuit that takes as inputs pairs <span class="math">(\\vec{x}&#x27;, \\vec{w}&#x27;)</span> with <span class="math">\\vec{x}&#x27; = (y_1, L_1, \\ldots, y_n, L_n, \\mathsf{vk})</span> and <span class="math">\\vec{w}&#x27; = (\\vec{w}, z_1, \\sigma_1, \\ldots, z_n, \\sigma_n)</span> such that, by setting <span class="math">x_i = y_i</span> if <span class="math">L_i = \\star</span> and <span class="math">x_i = z_i</span> otherwise, for all <span class="math">i \\in [n]</span>, it holds: (i) <span class="math">((x_1, \\ldots, x_n), \\vec{w}) \\in \\mathcal{R}_C</span>, and (ii) $\\Sigma .\\mathrm{Ver}(\\mathsf{vk}, L_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i, \\sigma_i) = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, run <span class="math">\\mathsf{Gen}&#x27;(1^{\\lambda}, C&#x27;)</span> to generate <span class="math">(\\mathsf{EK}_{C&#x27;}&#x27;, \\mathsf{VK}_{C&#x27;})&#x27;</span> and output <span class="math">\\mathsf{EK}_C = \\mathsf{EK}_{C&#x27;}&#x27;</span>, <span class="math">\\mathsf{VK}_C = \\mathsf{VK}_{C&#x27;}&#x27;</span>.</p>

    <p class="text-gray-300">Prove(EK_C, <span class="math">\\vec{x}</span>, <span class="math">\\vec{w}</span>, <span class="math">\\vec{\\sigma}</span>): Let <span class="math">\\mathsf{EK}_C</span> be the evaluation key as defined above, <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathbb{F}^n \\times \\mathbb{F}^h</span> be a statement-witness pair, and <span class="math">\\vec{\\sigma} = (\\sigma_1, \\ldots, \\sigma_n)</span> be a tuple of authentication tags for <span class="math">\\vec{x} = (y_1, \\ldots, y_n, \\sigma_1, \\ldots, \\sigma_n)</span></p>

    <p class="text-gray-300"><span class="math">(x_{1},\\ldots ,x_{n})</span>. If all the tags verify correctly, define <span class="math">\\vec{x}^{\\prime \\prime} = (y_{1},\\mathsf{L}_{1},\\dots ,y_{n},\\mathsf{L}_{n},\\mathsf{vk})</span>, <span class="math">\\vec{w}^{\\prime \\prime} = (\\vec{w},z_1,\\sigma_1^{\\prime},\\dots ,z_n,\\sigma_n^{\\prime})</span> so that for all <span class="math">i\\in [n]</span>: <span class="math">z_{i} = x_{i}</span>, <span class="math">y_{i} = x_{i}</span> if <span class="math">\\sigma_{i} = \\star</span> and <span class="math">y_{i} = 0</span> otherwise. Next, run <span class="math">\\pi \\leftarrow_{\\mathcal{R}}\\mathrm{Prove}(\\mathsf{EK}_{C^{\\prime}}^{\\prime},\\vec{x}^{\\prime},\\vec{w}^{\\prime})</span> to generate a proof for <span class="math">(\\vec{x}^{\\prime},\\vec{w}^{\\prime})\\in \\mathcal{R}_{C^{\\prime}}</span> and return <span class="math">\\pi</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ver}(\\mathsf{vk},\\mathsf{VK}_C,\\mathsf{L},\\{x_i\\}_{\\mathsf{L}_i = \\star},\\pi)</span>: given the verification key <span class="math">\\mathsf{vk}</span>, a circuit verification key <span class="math">\\mathsf{VK}_C</span>, statement labels <span class="math">\\mathsf{L} = (\\mathsf{L}_1,\\ldots ,\\mathsf{L}_n)</span>, unauthenticated statement components <span class="math">x_{i}</span>, and a proof <span class="math">\\pi</span>, the verification algorithm defines <span class="math">\\vec{x}^{\\prime} = (y_{1},\\mathsf{L}_{1},\\dots ,y_{n},\\mathsf{L}_{n},\\mathsf{vk})</span> with <span class="math">y_{i} = x_{i}</span> if <span class="math">\\mathsf{L}_i = \\star</span> and <span class="math">y_{i} = 0</span> otherwise. Finally, it returns the output of <span class="math">\\mathsf{Ver}&#x27;(\\mathsf{VK}_{C&#x27;}&#x27;&#x27;,\\vec{x}&#x27;&#x27;,\\pi)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the input size of <span class="math">C&#x27;</span> is a circuit larger than <span class="math">C</span> as follows: $n' = n + n \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{L}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>h' = h + n + n \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{L}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> represent the size, in terms of field elements, of the public key, a label, and a signature, respectively. In terms of gates and wires, </span>C'<span class="math"> is at least as large as </span>C<span class="math"> plus the circuit size of </span>\\Sigma<span class="math">. </span>\\mathsf{Ver}<span class="math"> for every signature verification, that is up to </span>n$ of such circuits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Theorem 1.</strong> If <span class="math">\\Pi&#x27;</span> is a zero-knowledge SNARK and <span class="math">\\Sigma</span> is a secure digital signature, then the scheme described above is a zero-knowledge AD-SNARK.</p>

    <p class="text-gray-300"><strong>Proof (Sketch).</strong> We provide a proof sketch to show that the generic construction satisfies all the properties. First, it is easy to see that if the SNARK is succinct, then the AD-SNARK proofs are succinct as well. Moreover, authentication correctness and completeness immediately follow from the correctness of the signature scheme and the completeness of the SNARK respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second, to see that adaptive proof of knowledge holds, note that for every adversary producing an accepting proof for statement <span class="math">\\vec{x}^{\\prime \\prime}</span> there is an extractor that returns a corresponding witness <span class="math">\\vec{w}^{\\prime \\prime}</span> (since <span class="math">\\Pi^{\\prime}</span> is an argument of knowledge) such that <span class="math">(\\vec{x}^{\\prime},\\vec{w}^{\\prime})\\in \\mathcal{R}_{C^{\\prime}}</span> with all but negligible probability. Such witness <span class="math">\\vec{w}^{\\prime}</span>, by definition, will contain a statement-witness pair <span class="math">\\vec{x},\\vec{w}</span> for <span class="math">\\mathcal{R}_C</span> and a collection of signatures. Moreover, <span class="math">(\\vec{x}^{\\prime},\\vec{w}^{\\prime})\\in \\mathcal{R}_{C^{\\prime}}</span> implies that <span class="math">(\\vec{x},\\vec{w})\\in \\mathcal{R}_C</span> and all signatures are valid. Then, if for such a proof there is a message-label pair $\\mathsf{L}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i<span class="math"> which was not queried to the <strong>Auth</strong> oracle, then </span>\\mathsf{L}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i<span class="math"> and the corresponding signature </span>\\sigma_{i}<span class="math"> can be used as a forgery to break the unforgeability of the signature scheme. Otherwise, if no forgery occurs, all signatures are valid for the same statement values queried to <strong>Auth</strong> (and thus stored in </span>T<span class="math">). This means that in the check of <strong>Ver</strong>, it also holds </span>(\\vec{x},\\vec{w})\\in \\mathcal{R}_C$, i.e., GameOutput remains 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Third, the zero-knowledge of the AD-SNARK follows from the one of the SNARK in a straightforward way.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3.3 Signature Verification Overhead</h2>

    <p class="text-gray-300">We now discuss why the circuit <span class="math">C&#x27;</span> resulting from explicitly encoding the verification algorithm of a digital signature scheme, as described in the generic construction, is bound to render the construction very inefficient. We consider various examples of signatures in both the random oracle and the standard model, and based on different algebraic problems.</p>

    <p class="text-gray-300">If one considers signature schemes in the random oracle model (which include virtually all the schemes used in practice), any such scheme uses a collision-resistant hash function (e.g., SHA-1) which is thus part of the verification algorithm computation. Unfortunately, as shown also in [PGHR13], a QAP (just) for a SHA-1 computation is terribly inefficient due to the high number of multiplication gates (roughly 24 000, for inputs of 416 bits). On the other hand, if we focus on standard model signature schemes, it does not get any better: These schemes involve specific algebraic computations, and encoding these computations into an arithmetic circuit over a field <span class="math">\\mathbb{F}_p</span> is</p>

    <p class="text-gray-300">costly. For instance, signatures based on pairings <em>[x1, x32]</em> require pairing computations that amount to, roughly, 10 000 multiplications. RSA-based standard-model signatures (e.g., Cramer-Shoup <em>[x10]</em>) require exponentiations over rings of large order (e.g., 3 000 bits), and simulating such computations over <span class="math">\\mathbb{F}_{p}</span> ends up with thousands of multiplication gates as well. Lattice-based signatures (in the standard model), e.g., <em>[x5]</em>, can be cheaper in terms of the number of multiplications. However, such multiplications typically work over <span class="math">\\mathbb{Z}_{q}</span> for a <span class="math">q</span> much smaller than our <span class="math">p</span>. An option would be to implement mod-<span class="math">q</span>-reductions in <span class="math">\\mathbb{F}_{p}</span> circuits, which is costly. Another option would be to let these schemes work over <span class="math">\\mathbb{Z}_{p}</span>, but then one has to work with higher dimensional lattices (or polynomial rings) for security reasons, again incurring a large number of multiplications.</p>

    <p class="text-gray-300">This state of affairs suggests that a QAP encoding a signature verification circuit is likely to require at least (and this is a very optimistic estimate) one thousand multiplications for <em>every</em> signature that must be checked.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Our Construction of Zero-Knowledge AD-SNARKs</h2>

    <p class="text-gray-300">In this section we describe our construction of an AD-SNARK scheme for the satisfiability of arbitrary arithmetic circuits. The scheme can be used with either secret or public verifiability. The main difference between the two verification modes is that the size of the proof in the secretly verifiable case is a fixed constant, whereas in the publicly verifiable case, the proof grows linearly with the number of authenticated statement values. Although we loose constant-size proofs for public verifiability, we stress that: (i) proofs are linear only in the number <span class="math">N\\leq n</span> of authenticated values and their size does not depend on the complexity of the circuit, and (ii) the verification algorithm runs linearly in <span class="math">N</span> in any case (even in the generic construction). Furthermore, when considering concrete implementations and applications, although the proof size of ADSNARK with public verifiability is not constant, it still scales very well, e.g., the size of an ADSNARK proof for a monthly electricity bill is under 170 KB vs. a constant-size proof of 0.3 KB when using the generic scheme with <em>[x6]</em>. In contrast, when considering the prover’s performance, ADSNARK remains in the realm of practicality – 18 seconds for a monthly bill – whereas for the generic scheme the timing goes up to 10 minutes.</p>

    <p class="text-gray-300">For verifiers that know the secret authentication key (e.g., as in a smart metering/insurance application where companies install a symmetric key in the devices), ADSNARK proofs have constant size, and – crucially – the knowledge of such a secret key by the verifier does <em>not</em> compromise privacy.</p>

    <p class="text-gray-300">Our scheme is proven secure under two computational assumptions in bilinear groups, the <span class="math">q</span>-Diffie-Hellman Exponent assumption (<span class="math">q</span>-DHE) <em>[x11]</em> and the <span class="math">q</span>-Power Knowledge of Exponent assumption (<span class="math">q</span>-PKE) <em>[x12]</em>. We note that the latter one is a non-falsifiable assumption. As discussed in Section 6, this kind of assumption is likely to be inherent for SNARKs for <span class="math">\\mathcal{NP}</span>. For privacy, we show that the scheme offers statistical zero-knowledge. We stress that this property holds even against adversaries who know (and even generate) the authentication keys.</p>

    <p class="text-gray-300">A detailed description of our scheme follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda})</span>: On input the security parameter <span class="math">1^{\\lambda}</span>, run <span class="math">\\mathsf{pp}=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,\\mathcal{P}_{1},\\mathcal{P}_{2})\\longleftarrow_{\\mathcal{R}}\\mathcal{G}(1^{\\lambda})</span> to generate a bilinear group description, where <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span>, and <span class="math">\\mathbb{G}_{T}</span> are groups of the same prime order <span class="math">p&gt;2^{\\lambda}</span>, <span class="math">\\mathcal{P}_{1}\\in\\mathbb{G}_{1}</span> and <span class="math">\\mathcal{P}_{2}\\in\\mathbb{G}_{2}</span> are the respective generators, and <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is an efficiently computable bilinear map. We let the finite field <span class="math">\\mathbb{F}</span> be the set of integers modulo <span class="math">p</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KG}(\\mathsf{pp})</span>: Create a key pair <span class="math">(\\mathsf{sk}&#x27;,\\mathsf{vk}&#x27;) \\leftarrow_{\\mathcal{R}} \\Sigma . \\mathsf{KG}(1^{\\lambda})</span> for a regular signature scheme. Run <span class="math">(S, \\mathsf{prfpp}) \\leftarrow_{\\mathcal{R}} \\mathsf{F}. \\mathsf{KG}(1^{\\lambda})</span> to obtain the seed <span class="math">S</span> and the public parameters <span class="math">\\mathsf{prfpp}</span> of a pseudorandom function <span class="math">\\mathsf{F}_S : \\{0,1\\}^* \\to \\mathbb{F}</span>. Choose a random value <span class="math">\\kappa \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> and compute <span class="math">K_1 = \\kappa \\mathcal{P}_1 \\in \\mathbb{G}_1</span>, <span class="math">K_2 = \\kappa \\mathcal{P}_2 \\in \\mathbb{G}_2</span>. Return the secret key <span class="math">\\mathsf{sk} = (\\mathsf{sk}&#x27;, S, \\kappa)</span>, the public verification key <span class="math">\\mathsf{vk} = (\\mathsf{vk}&#x27;, K_2)</span>, and the public authentication parameters <span class="math">\\mathsf{pap} = (\\mathsf{pp}, \\mathsf{prfpp}, K_1)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{sk}, \\mathsf{L}, x)</span>: To authenticate a value <span class="math">x \\in \\mathbb{F}</span> with label <span class="math">\\mathsf{L}</span>, generate <span class="math">\\phi \\gets \\mathsf{F}_S(\\mathsf{L})</span> using the PRF, compute <span class="math">\\mu = \\phi + \\kappa \\cdot x \\in \\mathbb{F}</span> and <span class="math">\\varPhi = \\phi \\mathcal{P}_2 \\in \\mathbb{G}_2</span>. Then compute a signature $\\sigma' \\leftarrow_{\\mathcal{R}} \\Sigma . \\mathrm{Sign}(\\mathsf{sk}', \\varPhi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{L})<span class="math">, and output the tag </span>\\sigma = (\\mu, \\varPhi, \\sigma')$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Ver}(\\mathsf{vk}, \\sigma, \\mathsf{L}, x)</span>: Let <span class="math">\\mathsf{vk} = (\\mathsf{vk}&#x27;, K_2)</span> be the verification key. To verify that <span class="math">\\sigma = (\\mu, \\varPhi, \\sigma&#x27;)</span> is a valid authentication tag for a value <span class="math">x \\in \\mathbb{F}</span> with respect to label <span class="math">\\mathsf{L}</span>, output <span class="math">\\top</span> if <span class="math">\\mu \\mathcal{P}_2 = \\varPhi + x K_2</span> in <span class="math">\\mathbb{G}_2</span>, and if $\\Sigma . \\mathsf{Ver}(\\mathsf{vk}', \\varPhi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{L}, \\sigma') = 1<span class="math">. Output </span>\\bot<span class="math"> otherwise. In the secret key setting (i.e., if </span>\\mathsf{vk}<span class="math"> is replaced by </span>\\mathsf{sk}<span class="math">), the tag </span>\\sigma<span class="math"> can be verified by checking whether </span>\\mu = \\mathsf{F}_S(\\mathsf{L}) + \\kappa \\cdot x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Gen}(\\mathsf{pap}, C)</span>: Let <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span> be an arithmetic circuit. To generate the keys, proceed as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">Q_{C} = (\\vec{a}, \\vec{b}, \\vec{c}, z) = \\mathsf{QAPInst}(C)</span> to build a QAP of size <span class="math">m</span> and degree <span class="math">d</span> for <span class="math">C</span>. Recall that <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span> are vectors of <span class="math">m + 1</span> polynomials in <span class="math">\\mathbb{F}^{\\leq d - 1}[X]</span>, while the target polynomial <span class="math">z \\in \\mathbb{F}[X]</span> has degree <span class="math">d</span>. Extend <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span> with 3 more polynomials each, by setting:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">a_{m+1}(X) = b_{m+2}(X) = c_{m+3}(X) = z(X),</span></div>

    <div class="my-4 text-center"><span class="math-block">a_{m+2}(X) = a_{m+3}(X) = b_{m+1}(X) = b_{m+3}(X) = c_{m+1}(X) = c_{m+2}(X) = 0.</span></div>

    <p class="text-gray-300">Let <span class="math">I_x, I_{mid}</span> be the following partitions of <span class="math">\\{1, \\ldots, m + 3\\}</span>: <span class="math">I_x = \\{1, \\ldots, n\\}</span>, <span class="math">I_{mid} = \\{n + 1, \\ldots, m + 3\\}</span>. In other words, we partition all the circuit wires into the <span class="math">n</span> statement wires <span class="math">I_x</span>, and the remaining "internal" wires <span class="math">I_{mid}</span> (which include the <span class="math">h</span> witness wires).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick <span class="math">\\rho_{\\mathsf{a}}, \\rho_{\\mathsf{b}}, \\tau, \\alpha_{\\mathsf{a}}, \\alpha_{\\mathsf{b}}, \\alpha_{\\mathsf{c}}, \\beta, \\gamma \\gets_{\\mathcal{R}} \\mathbb{F}</span> uniformly at random, set <span class="math">\\rho_{\\mathsf{c}} = \\rho_{\\mathsf{a}} \\cdot \\rho_{\\mathsf{b}}</span>, and compute the following values:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Z = z(\\tau) \\rho_{\\mathsf{c}} \\mathcal{P}_2, \\quad K_{\\mathsf{a}} = z(\\tau) \\rho_{\\mathsf{a}} K_1,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in \\{0, \\dots, m + 3\\}: \\quad A_k = a_k(\\tau) \\rho_{\\mathsf{a}} \\mathcal{P}_1, \\quad A&#x27;_k = \\alpha_{\\mathsf{a}} a_k(\\tau) \\rho_{\\mathsf{a}} \\mathcal{P}_1,</span></div>

    <div class="my-4 text-center"><span class="math-block">B_k = b_k(\\tau) \\rho_{\\mathsf{b}} \\mathcal{P}_2, \\quad B&#x27;_k = \\alpha_{\\mathsf{b}} b_k(\\tau) \\rho_{\\mathsf{b}} \\mathcal{P}_1,</span></div>

    <div class="my-4 text-center"><span class="math-block">C_k = c_k(\\tau) \\rho_{\\mathsf{c}} \\mathcal{P}_1, \\quad C&#x27;_k = \\alpha_{\\mathsf{c}} c_k(\\tau) \\rho_{\\mathsf{c}} \\mathcal{P}_1,</span></div>

    <div class="my-4 text-center"><span class="math-block">E_k = \\beta (a_k(\\tau) \\rho_{\\mathsf{a}} + b_k(\\tau) \\rho_{\\mathsf{b}} + c_k(\\tau) \\rho_{\\mathsf{c}}) \\mathcal{P}_1.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the evaluation key <span class="math">\\mathsf{EK}_C</span> and the verification key <span class="math">\\mathsf{VK}_C</span> defined as follows:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{EK}_C = \\left(Q_C, \\vec{A}, \\vec{A}&#x27;, \\vec{B}, \\vec{B}&#x27;, \\vec{C}, \\vec{C}&#x27;, \\vec{E}, \\{\\tau^i \\mathcal{P}_1\\}_{i \\in \\{0, \\dots, d\\}}, K_{\\mathsf{a}}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{VK}_C = \\left(\\mathcal{P}_1, \\mathcal{P}_2, \\alpha_{\\mathsf{a}} \\mathcal{P}_2, \\alpha_{\\mathsf{b}} \\mathcal{P}_1, \\alpha_{\\mathsf{c}} \\mathcal{P}_2, \\gamma \\mathcal{P}_2, \\beta \\gamma \\mathcal{P}_1, \\beta \\gamma \\mathcal{P}_2, Z, \\{A_k\\}_{k=0}^n\\right)</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}(\\mathsf{EK}_C, \\vec{x}, \\vec{w}, \\vec{\\sigma})</span>: Let <span class="math">\\mathsf{EK}_C</span> the an evaluation key defined as above, <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathbb{F}^n \\times \\mathbb{F}^h</span> be a statement-witness pair, and <span class="math">\\sigma = (\\sigma_1, \\dots, \\sigma_n)</span> be a tuple of authentication tags for <span class="math">x</span> such that, for any <span class="math">i \\in [n]</span>, either <span class="math">\\sigma_i = (\\mu_i, \\Phi_i, \\sigma_i&#x27;)</span> or <span class="math">\\sigma_i = \\star</span>. We define <span class="math">I_{\\sigma} = \\{i \\in I_x : \\sigma_i \\neq \\star\\} \\subseteq I_x</span> as the set of indices for which there is an authenticated statement value, and let <span class="math">I_{\\star} = I_x \\setminus I_{\\sigma}</span> be its complement. To produce a proof for the satisfiability of <span class="math">C(\\vec{x}, \\vec{w}) = 0^l</span> proceed as follows.</p>

    <p class="text-gray-300">18</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\vec{s} = \\mathsf{QAPwit}(C, \\vec{x}, \\vec{w}) \\in \\mathbb{F}^m</span> (and recall that <span class="math">s_i = x_i</span> for all <span class="math">i \\in [n]</span>).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomly sample <span class="math">\\delta_{\\mathsf{a}}^{\\sigma}, \\delta_{\\mathsf{a}}^{mid}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}} \\gets_{\\mathcal{R}} \\mathbb{F}</span>, and set <span class="math">\\delta_{\\mathsf{a}} = \\delta_{\\mathsf{a}}^{\\sigma} + \\delta_{\\mathsf{a}}^{mid}</span>. Also, define the vector <span class="math">\\vec{u} = (1, \\vec{s}, \\delta_{\\mathsf{a}}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}}) \\in \\mathbb{F}^{m+4}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Solve the QAP <span class="math">Q_{C}</span> by computing the coefficients <span class="math">(h_0, \\ldots, h_d) \\in \\mathbb{F}^{d+1}</span> of the polynomial <span class="math">h \\in \\mathbb{F}[X]</span> such that <span class="math">h(X)z(X) = a(X)b(X) - c(X)</span>, where <span class="math">a, b, c \\in \\mathbb{F}[X]</span> are</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">a (X) = a _ {0} (X) + \\sum_ {k \\in [ m ]} s _ {k} \\cdot a _ {k} (X) + \\delta_ {\\mathbf {a}} \\cdot z (x)</span></div>

    <div class="my-4 text-center"><span class="math-block">b (X) = b _ {0} (X) + \\sum_ {k \\in [ m ]} s _ {k} \\cdot b _ {k} (X) + \\delta_ {\\mathbf {b}} \\cdot z (x)</span></div>

    <div class="my-4 text-center"><span class="math-block">c (X) = c _ {0} (X) + \\sum_ {k \\in [ m ]} s _ {k} \\cdot c _ {k} (X) + \\delta_ {\\mathbf {c}} \\cdot z (x)</span></div>

    <p class="text-gray-300">Then compute <span class="math">H = h(\\tau)\\mathcal{P}_1</span> using the values <span class="math">\\tau_{-}^{i}\\mathcal{P}_{1}</span> contained in the evaluation key <span class="math">\\mathsf{EK}_C</span>. Note that we have <span class="math">a(X) = \\langle \\vec{u},\\vec{a}\\rangle</span>, <span class="math">b(X) = \\langle \\vec{u},\\vec{b}\\rangle</span> and <span class="math">c(X) = \\langle \\vec{u},\\vec{c}\\rangle</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the following values:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\mathsf {b}} = \\langle \\vec {u}, \\vec {B} \\rangle , \\quad \\pi_ {\\mathsf {b}} ^ {\\prime} = \\langle \\vec {u}, \\vec {B ^ {\\prime}} \\rangle , \\qquad \\pi_ {\\mathsf {c}} = \\langle \\vec {u}, \\vec {C} \\rangle , \\quad \\pi_ {\\mathsf {c}} ^ {\\prime} = \\langle \\vec {u}, \\vec {C ^ {\\prime}} \\rangle ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\sigma} = \\langle \\vec {u}, \\vec {A} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} A _ {m + 1}, \\quad \\pi_ {\\sigma} ^ {\\prime} = \\langle \\vec {u}, \\vec {A ^ {\\prime}} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} A _ {m + 1} ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {m i d} = \\langle \\vec {u}, \\vec {A} \\rangle_ {I _ {m i d}} - \\delta_ {\\mathsf {a}} ^ {\\sigma} A _ {m + 1}, \\quad \\pi_ {m i d} ^ {\\prime} = \\langle \\vec {u}, \\vec {A ^ {\\prime}} \\rangle_ {I _ {\\sigma}} - \\delta_ {\\mathsf {a}} ^ {\\sigma} A _ {m + 1} ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {E} = \\langle \\vec {u}, \\vec {E} \\rangle .</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Authenticate the value <span class="math">\\pi_{\\sigma}</span> by computing</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\mu} = \\langle \\vec {\\mu}, \\vec {A} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} K _ {\\mathsf {a}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct and return proof <span class="math">\\pi</span> as the tuple <span class="math">(\\pi_{\\mu}, \\pi_{\\sigma}, \\pi_{\\sigma}^{\\prime}, \\pi_{mid}, \\pi_{mid}^{\\prime}, \\pi_{\\mathsf{b}}, \\pi_{\\mathsf{b}}^{\\prime}, \\pi_{\\mathsf{c}}, \\pi_{\\mathsf{c}}^{\\prime}, \\pi_{E}, H)</span>. To make the proof publicly verifiable, include also <span class="math">\\{\\varPhi_k, \\sigma_k&#x27;\\}_{k \\in I_\\sigma}</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Ver}(\\mathsf{vk}, \\mathsf{VK}_C, \\mathsf{L}, \\{x_i\\}_{\\mathsf{L}_i = \\star}, \\pi)</span>: Let <span class="math">\\mathsf{VK}_C</span> be the verification key for the circuit <span class="math">C</span>, <span class="math">\\vec{\\mathsf{L}} = (\\mathsf{L}_1, \\ldots, \\mathsf{L}_n)</span> be a vector of labels, and let <span class="math">\\pi</span> be a proof as defined above. In a similar way as in Prove, we define <span class="math">I_{\\sigma} = \\{i \\in I_x : \\mathsf{L}_i \\neq \\star\\} \\subseteq I_x</span> and <span class="math">I_{\\star} = I_x \\setminus I_{\\sigma}</span>. The verification algorithm computes <span class="math">A_{\\star} = A_0 + \\langle \\vec{x}, \\vec{A} \\rangle_{I_{\\star}}</span> and proceeds as follows:</p>

    <p class="text-gray-300">(A.1 secret) If verification is done using the secret key <span class="math">\\mathsf{sk} = (S, \\kappa)</span>, check the authenticity of <span class="math">\\pi_{\\sigma}</span> against the labels <span class="math">\\vec{\\mathsf{L}}</span> by checking whether the following equation holds in <span class="math">\\mathbb{G}_1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\mu} = \\langle \\mathsf {F} _ {S} (\\vec {\\mathsf {L}}), \\vec {A} \\rangle_ {I _ {\\sigma}} + \\kappa \\pi_ {\\sigma}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(A.1 public) If the verification is performed using the public verification key <span class="math">\\mathsf{vk} = (\\mathsf{vk}&#x27;, K_2)</span>: first, check the validity of all <span class="math">\\Phi_k</span> by verifying that $\\Sigma.\\mathsf{Ver}(\\mathsf{vk}', \\Phi_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{L}_k, \\sigma_k') = 1<span class="math"> for all </span>k \\in I_\\sigma<span class="math">; second, check the authenticity of </span>\\pi_\\sigma<span class="math"> by verifying that the following equation is satisfied over </span>\\mathbb{G}_T$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\pi_ {\\mu}, \\mathcal {P} _ {2}\\right) = \\prod_ {k \\in I _ {\\sigma}} e \\left(A _ {k}, \\Phi_ {k}\\right) \\cdot e \\left(\\pi_ {\\sigma}, K _ {2}\\right)</span></div>

    <p class="text-gray-300">8 The expansion of <span class="math">\\langle \\mathsf{F}_S(\\vec{\\mathsf{L}}),\\vec{A}\\rangle_I</span> is defined as the component-wise application of <span class="math">\\mathsf{F}</span>, i.e., <span class="math">\\sum_{i\\in I}\\mathsf{F}_S(\\mathsf{L}_i)\\cdot A_i</span>.</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">(A.2) Check the validity of knowledge commitments for the authenticated values:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\pi_ {\\sigma} ^ {\\prime}, \\mathcal {P} _ {2}\\right) = e \\left(\\pi_ {\\sigma}, \\alpha_ {\\mathrm {a}} \\mathcal {P} _ {2}\\right)</span></div>

    <p class="text-gray-300">(P.1) Check the satisfiability of the QAP:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(A _ {\\star} + \\pi_ {\\sigma} + \\pi_ {m i d}, \\pi_ {\\mathbf {b}}\\right) = e (H, Z) \\cdot e \\left(\\pi_ {\\mathbf {c}}, \\mathcal {P} _ {2}\\right)</span></div>

    <p class="text-gray-300">(P.2) Check the validity of knowledge commitments:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\pi_ {m i d} ^ {\\prime}, \\mathcal {P} _ {2}\\right) = e \\left(\\pi_ {m i d}, \\alpha_ {\\mathrm {a}} \\mathcal {P} _ {2}\\right) \\wedge e \\left(\\pi_ {\\mathrm {b}} ^ {\\prime}, \\mathcal {P} _ {2}\\right) = e \\left(\\alpha_ {\\mathrm {b}} \\mathcal {P} _ {1}, \\pi_ {\\mathrm {b}}\\right) \\wedge e \\left(\\pi_ {\\mathrm {c}} ^ {\\prime}, \\mathcal {P} _ {2}\\right) = e \\left(\\pi_ {\\mathrm {c}}, \\alpha_ {\\mathrm {c}} \\mathcal {P} _ {2}\\right)</span></div>

    <p class="text-gray-300">(P.3) Check that all the QAP linear combinations use the same coefficients:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(\\pi_ {E}, \\gamma \\mathcal {P} _ {2}\\right) = \\\\ e \\left(A _ {\\star} + \\pi_ {\\sigma} + \\pi_ {m i d} + \\pi_ {c}, \\beta \\gamma \\mathcal {P} _ {2}\\right) \\cdot e \\left(\\beta \\gamma \\mathcal {P} _ {1}, \\pi_ {b}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If all the checks above are satisfied, then return  <span class="math">\\top</span> ; otherwise return  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ReRand}(\\mathsf{EK}_C,\\mathsf{L},\\{x_i\\}_{\\mathsf{L}_i = \\star},\\pi)</span> : The scheme also allows for perfect re-randomization of an existing proof, say  <span class="math">\\pi</span>  given by tuple  <span class="math">(\\pi_{\\mu},\\pi_{\\sigma},\\pi_{\\sigma}^{\\prime},\\pi_{mid},\\pi_{mid}^{\\prime},\\pi_{\\mathsf{b}},\\pi_{\\mathsf{b}}^{\\prime},\\pi_{\\mathsf{c}},\\pi_{\\mathsf{c}}^{\\prime},\\pi_{E},H)</span> . If  <span class="math">\\pi</span>  verifies for a set of labels  <span class="math">\\mathsf{L}</span>  and a set of non-authenticated values  <span class="math">\\{x_i\\}_{\\mathsf{L}_i = \\star}</span> , then  <span class="math">\\pi</span>  can be re-randomized as follows. First, choose random values  <span class="math">\\tilde{\\delta}_{\\mathsf{a}}^{\\sigma},\\tilde{\\delta}_{\\mathsf{a}}^{mid},\\tilde{\\delta}_{\\mathsf{b}},\\tilde{\\delta}_{\\mathsf{c}}\\gets_{\\mathcal{R}}\\mathbb{F}</span> , and set  <span class="math">\\tilde{\\delta}_{\\mathsf{a}} = \\tilde{\\delta}_{\\mathsf{a}}^{\\sigma} + \\tilde{\\delta}_{\\mathsf{a}}^{mid}</span> .</p>

    <p class="text-gray-300">Second, compute</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\pi} _ {\\mathsf {b}} = \\pi_ {\\mathsf {b}} + \\tilde {\\delta} _ {\\mathsf {b}} B _ {m + 2}, \\quad \\tilde {\\pi} _ {\\mathsf {b}} ^ {\\prime} = \\pi_ {\\mathsf {b}} ^ {\\prime} + \\tilde {\\delta} _ {\\mathsf {b}} B _ {m + 2} ^ {\\prime},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\pi} _ {c} = \\pi_ {c} + \\tilde {\\delta} _ {c} C _ {m + 3}, \\quad \\tilde {\\pi} _ {c} ^ {\\prime} = \\pi_ {c} + \\tilde {\\delta} _ {c} C _ {m + 3} ^ {\\prime},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\pi} _ {\\sigma} = \\pi_ {\\sigma} + \\tilde {\\delta} _ {a} ^ {\\sigma} A _ {m + 1}, \\quad \\tilde {\\pi} _ {\\sigma} ^ {\\prime} = \\pi_ {\\sigma} ^ {\\prime} + \\tilde {\\delta} _ {a} ^ {\\sigma} A _ {m + 1} ^ {\\prime},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\pi} _ {m i d} = \\pi_ {m i d} + \\tilde {\\delta} _ {a} ^ {m i d} A _ {m + 1},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\pi} _ {m i d} ^ {\\prime} = \\pi_ {m i d} ^ {\\prime} + \\tilde {\\delta} _ {a} ^ {m i d} A _ {m + 1} ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\pi} _ {E} = \\pi_ {E} + \\tilde {\\delta} _ {a} E _ {m + 1} + \\tilde {\\delta} _ {b} E _ {m + 2} + \\tilde {\\delta} _ {c} E _ {m + 3},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\pi} _ {\\mu} = \\pi_ {\\mu} + \\tilde {\\delta} _ {a} ^ {\\sigma} K _ {a},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {H} = H + \\tilde {\\delta} _ {a} \\pi_ {b} + \\tilde {\\delta} _ {b} \\pi_ {a} + \\tilde {\\delta} _ {a} \\tilde {\\delta} _ {b} z (\\tau) \\mathcal {P} _ {1} - \\tilde {\\delta} _ {c} \\mathcal {P} _ {1}.</span></div>

    <p class="text-gray-300">where  <span class="math">z(\\tau)\\mathcal{P}_1</span>  can be included in  <span class="math">\\mathsf{EK}_C</span> . Finally, output the re-randomised proof  <span class="math">\\tilde{\\pi}</span>  as</p>

    <p class="text-gray-300"><span class="math">(\\tilde{\\pi}_{\\mu},\\tilde{\\pi}_{\\sigma},\\tilde{\\pi}_{\\sigma}^{\\prime},\\tilde{\\pi}_{mid},\\tilde{\\pi}_{mid}^{\\prime},\\tilde{\\pi}_{\\mathsf{b}},\\tilde{\\pi}_{\\mathsf{b}}^{\\prime},\\tilde{\\pi}_{\\mathsf{c}},\\tilde{\\pi}_{\\mathsf{c}}^{\\prime},\\tilde{\\pi}_{E},\\tilde{H})</span></p>

    <p class="text-gray-300">It is not hard to check that  <span class="math">\\tilde{\\pi}</span>  is identically distributed as a fresh proof  <span class="math">\\pi</span>  generated by Prove.</p>

    <p class="text-gray-300">The following theorem shows that the scheme ADSNARK described above is a zero-knowledge AD-SNARK as in Definition 5.</p>

    <p class="text-gray-300">Theorem 2. If  <span class="math">\\mathsf{F}</span>  is a pseudorandom function, and the  <span class="math">q</span> -PKE [Gro10] and the  <span class="math">q</span> -DHE [CKS09] assumptions hold, then ADSNARK is a secretly-verifiable zero-knowledge AD-SNARK. Furthermore, if additionally  <span class="math">\\Sigma</span>  is a secure signature scheme, then ADSNARK is a publicly-verifiable zero-knowledge AD-SNARK.</p>

    <p class="text-gray-300">We prove theorem by showing separately that the properties of completeness, adaptive proof of knowledge and zero-knowledge are all satisfied. This is done in Sections 4.1, 4.2 and 4.3 respectively.</p>

    <p class="text-gray-300">Performance and Comparison. Before proving Theorem 2, we pause to discuss the performance of our scheme ADSNARK in comparison with the SNARK of Parno et al. <em>[x13]</em> that we call PGHR (more precisely, we consider its optimization proposed by Ben-Sasson et al. <em>[x2]</em> that for convenience we recall in Appendix C).</p>

    <p class="text-gray-300">First, we note that the Gen algorithm is virtually the same in both schemes except that in ADSNARK we have one more exponentiation in <span class="math">\\mathbb{G}_{1}</span> to generate <span class="math">K_{\\mathsf{a}}=z(\\tau)\\,\\rho_{\\mathsf{a}}\\,K_{1}</span>. Also, from a bandwidth point of view, the evaluation key of <span class="math">\\mathsf{EK}_{C}</span> of ADSNARK contains only one more <span class="math">\\mathbb{G}_{1}</span> element, <span class="math">K_{\\mathsf{a}}</span>, compared to the evaluation key of PGHR. The verification key instead is the same in both schemes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second, let us focus on the differences in the Prove algorithm. ADSNARK’s Prove has to compute three more <span class="math">\\mathbb{G}_{1}</span> elements: <span class="math">\\pi_{\\sigma}</span>, <span class="math">\\pi_{\\sigma}^{\\prime}</span>, and <span class="math">\\pi_{\\mu}</span>. Generating these elements amounts to performing three multi-exponentiations that involve $N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{\\sigma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> terms each. When looking at the proof size, ADSNARK’s proof contains such three additional elements in the group </span>\\mathbb{G}_{1}<span class="math">, plus the signatures </span>\\{\\sigma_{k}\\}_{k\\in I_{\\sigma}}$ in the publicly verifiable setting.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Third, we analyze the differences between ADSNARK and PGHR in the Ver algorithm. The equations (P.1), (P.2), and (P.3) are identical in both schemes and thus require the same computational effort. In PGHR one computes <span class="math">A_{x}=A_{0}+\\sum_{k=1}^{n}x_{k}A_{k}\\in\\mathbb{G}_{1}</span>, whereas in ADSNARK we compute a similar value <span class="math">A_{\\star}=A_{0}+\\sum_{k\\in I_{\\star}}x_{k}A_{k}\\in\\mathbb{G}_{1}</span> which involves fewer terms: precisely $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{\\star}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n-N<span class="math">. Then, ADSNARK has to perform some additional computation for verifying equations (A.1) and (A.2). (A.2) costs only two pairings – a constant overhead. The first equation instead requires different computations according to whether we are in the secretly verifiable case ((A.1)^{secret}) or in the publicly verifiable case ((A.1)^{public}). (A.1)^{secret} requires one multi-exponentiation with </span>N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{\\sigma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> terms (plus the cost of running the PRF which is unnoticeable compared to the multi-exponentiation). Hence, considering the cost of computing </span>A_{x}<span class="math"> in PGHR and the total cost of computing </span>A_{\\star}$ and (A.1)^{secret} in ADSNARK, these are essentially the same. In other words, ADSNARK’s secretly verifiable case is slightly slower than PGHR for the cost of computing two pairings in (A.2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the publicly verifiable case, equation (A.1)^{public} requires to check a total of <span class="math">N</span> signatures, <span class="math">\\{\\sigma_{k}\\}_{k\\in I_{\\sigma}}</span>, and then to compute <span class="math">e(\\pi_{\\mu},\\mathcal{P}_{2})e(\\pi_{\\sigma},-K_{2})</span> and <span class="math">\\prod_{k\\in I_{\\sigma}}e(A_{k},\\Phi_{k})</span>. In general, note that the verification of such <span class="math">N</span> signatures can be done by using batching techniques, and the “multi pairings” can also be computed efficiently. In particular, as we show in our instantiation, this cost is close to the cost of computing <span class="math">A_{x}</span> in PGHR. In other words, ADSNARK’s publicly verifiable case is slightly slower than PGHR for the cost of computing the pairings in (A.1) and (A.2) and for checking the signatures.</p>

    <p class="text-gray-300">In Section 5, we give concrete comparisons resulting from our experiments, which are consistent with the analysis above. Indeed, we show based on concrete timings that ADSNARK performs almost as PGHR used without authenticated data. These results conclude that our technique added an important property to the SNARK at almost no cost.</p>

    <p class="text-gray-300">However, for the sake of fairness, we should also consider a comparison of the two protocols when they are used to provide equivalent guarantees, i.e., when proving statements on authenticated data. To this end, we now compare ADSNARK against the best possible instantiation of the generic construction of Section 3.2, which we take to be PGHR working with the “extended” circuit <span class="math">C^{\\prime}</span></p>

    <p class="text-gray-300">We call this scheme AD-PGHR. In our analysis, we assume that the verification of every signature requires an arithmetic circuit with <span class="math">c</span> multiplication gates, and also assume (very optimistically) that this is the only additional cost for the design of <span class="math">C&#x27;</span>. This means that: if <span class="math">C</span> yields a QAP of size <span class="math">m</span> and degree <span class="math">d</span>, then <span class="math">C&#x27;</span> yields a QAP of, at least, size <span class="math">m&#x27; = m + cN</span> and degree <span class="math">d&#x27; = d + cN</span>.</p>

    <p class="text-gray-300">In AD-PGHR, the performance of <span class="math">\\mathsf{Ver}</span> remains the same as the one of <span class="math">\\mathsf{Ver}</span> in PGHR discussed above. On the other hand, the Prove algorithm of AD-PGHR heavily depends on the QAP size <span class="math">m&#x27;</span> and degree <span class="math">d&#x27;</span>. Precisely, Prove performs multi-exponentiations with <span class="math">m&#x27;</span> and <span class="math">d&#x27;</span> terms, and a polynomial division operation whose cost is <span class="math">O(d&#x27;\\log^2 d&#x27;)</span>.</p>

    <p class="text-gray-300">In conclusion, if we fix a circuit <span class="math">C</span> and a number <span class="math">N</span> of authenticated values, and we compare ADSNARK for circuit <span class="math">C</span> against AD-PGHR for the same <span class="math">C</span> (i.e., PGHR with the extended circuit <span class="math">C&#x27;</span>), then we obtain:</p>

    <p class="text-gray-300">For secret verification, both schemes perform almost the same, the only difference being that we need to perform two more pairings; for public verification, ADSNARK has an additional cost of one multi-pairing computation with <span class="math">N</span> terms plus the signature verification. For proof generation, AD-PGHR has to perform additional operations that involve a factor at least linear in <span class="math">c \\cdot N</span>. We recall from the discussion in Section 3.3 that such <span class="math">c</span> is likely to be larger than 1000. Therefore, one can see that while our solution charges a little more to the verifier (and only in the public verification case), the costs of our scheme on the prover side can be much cheaper, at least by a factor <span class="math">c \\cdot N</span>. We confirm the above asymptotic comparison in Section 5 by showing the experimental results obtained by running our implementation.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4.1 Completeness</h2>

    <p class="text-gray-300"><strong>Theorem 3.</strong> The scheme ADSNARK satisfies authentication correctness and completeness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> It is straightforward to see that the scheme has authentication correctness by the correctness of the regular signature scheme and by construction. To show the completeness, we prove the satisfaction of all verification equations in the order they appear in the verification procedure.</p>

    <div class="my-4 text-center"><span class="math-block">(A. 1 ^ {\\text {s e c r e t}})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\mu} \\stackrel {{\\text {P r o v e}}} {{=}} \\langle \\vec {\\mu}, \\vec {A} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} K _ {\\mathsf {a}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel {\\text {G e n}} {=} \\langle \\vec {\\mu}, \\vec {A} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} z (\\tau) \\rho_ {\\mathsf {a}} K _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel {\\text {A u t h}} {=} \\langle \\mathsf {F} _ {S} (\\vec {\\mathsf {L}}) + \\kappa \\cdot \\vec {x}, \\vec {A} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} z (\\tau) \\rho_ {\\mathsf {a}} K _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel {\\text {A u t h K G}} {=} \\langle \\mathsf {F} _ {S} (\\vec {\\mathsf {L}}), \\vec {A} \\rangle_ {I _ {\\sigma}} + \\kappa \\langle \\vec {x}, \\vec {A} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} z (\\tau) \\rho_ {\\mathsf {a}} \\kappa \\mathcal {P} _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel {\\text {G e n}} {=} \\langle \\mathsf {F} _ {S} (\\vec {\\mathsf {L}}), \\vec {A} \\rangle_ {I _ {\\sigma}} + \\kappa (\\langle \\vec {x}, \\vec {A} \\rangle_ {I _ {\\sigma}} + \\delta_ {\\mathsf {a}} ^ {\\sigma} A _ {m + 1})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel {\\text {P r o v e}} {=} \\langle \\mathsf {F} _ {S} (\\vec {\\mathsf {L}}), \\vec {A} \\rangle_ {I _ {\\sigma}} + \\kappa \\cdot \\pi_ {\\sigma}</span></div>

    <p class="text-gray-300">(A.1pub)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e(πμ, P2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove = e(⟨μ, A⟩Iσ + δaσ Kα, P2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Gen = e(⟨μ, A⟩Iσ + δaσ z(τ)ραK1, P2) |   |</p>

    <p class="text-gray-300">|  Auth = e(⟨F_S( L) + κ · x, A⟩Iσ + δaσ z(τ)ραK1, P2) |   |</p>

    <p class="text-gray-300">|  AuthKG = e(⟨F_S( L), A⟩Iσ, P2) · e(κ⟨x, A⟩Iσ + δaσ z(τ)ρακP1, P2) |   |</p>

    <p class="text-gray-300">|  Gen = e(∑k∈Iσ(F_S(Lk)ραak(τ))P1, P2) · e(⟨x, A⟩Iσ + δaσ z(τ)ραP1, P2)κ |   |</p>

    <p class="text-gray-300">|  AuthKG,Prove = e(∑k∈Iσραak(τ)P1, F_S(Lk)P2) · e(⟨x, A⟩Iσ + δaσ Am+1, K2) |   |</p>

    <p class="text-gray-300">|  Gen,Auth = ∏k∈Iσe(Ak, Φk) · e(⟨x, A⟩Iσ + δaσ Am+1, K2) |   |</p>

    <p class="text-gray-300">|  Prove = ∏k∈Iσe(Ak, Φk) · e(πσ, K2) |   |</p>

    <p class="text-gray-300">(A.2)</p>

    <p class="text-gray-300">|  e(π′σ, P2) = e(⟨u, A′⟩Iσ + δaσ A′m+1, P2)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Gen = e(αa⟨u, A⟩Iσ + δaσ αaA m+1, P2)  |</p>

    <p class="text-gray-300">|  = e(⟨u, A⟩Iσ + δaσ A m+1, αaP2)  |</p>

    <p class="text-gray-300">|  = e(πσ, αaP2)  |</p>

    <p class="text-gray-300">(P.1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e(A* + πσ + πmid πb)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove = e(A0 + ⟨u, A⟩Iσ + ⟨u, A⟩I* + ⟨u, A⟩Imid, ⟨u, B⟩)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Prove = e(⟨u, A⟩, ⟨u, B⟩)  |</p>

    <p class="text-gray-300">|   | Gen = e((∑k=0m+4ukak(τ))ρaP1, (∑k=0m+4ukbk(τ))ρbP2)  |</p>

    <p class="text-gray-300">|   | Gen = e(P1, P2)ρaρb a(τ)b(τ)  |</p>

    <p class="text-gray-300">|   | Gen,Prove = e(P1, P2)ρc(h(τ)z(τ)+c(τ))  |</p>

    <p class="text-gray-300">|   | = e(h(τ)P1, ρc z(τ)P2) · e(ρc c(τ)P1, P2)  |</p>

    <p class="text-gray-300">|   | Prove = e(H, Z) · e(ρc ⟨u, C⟩ P1, P2)  |</p>

    <p class="text-gray-300">|   | Prove = e(H, Z) · e(πc, P2)  |</p>

    <p class="text-gray-300">(P.2) We refer to the proof of (A.2), which is very similar to the cases of  <span class="math">\\pi_{mid}</span> ,  <span class="math">\\pi_{\\mathbf{b}}</span> , and  <span class="math">\\pi_{\\mathbf{c}}</span> .</p>

    <p class="text-gray-300">(P.3)</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e(\\pi_E, \\gamma \\mathcal{P}_2) \\stackrel{\\text{Prove}}{=} e\\left(\\langle \\vec{u}, \\vec{E} \\rangle, \\gamma \\mathcal{P}_2\\right) \\stackrel{\\text{Gen}}{=} e\\left(\\beta \\langle \\vec{u}, (\\rho_{\\mathsf{a}} \\vec{a}(\\tau) + \\rho_{\\mathsf{b}} \\vec{b}(\\tau) + \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}} \\vec{c}(\\tau)) \\mathcal{P}_1 \\rangle, \\gamma \\mathcal{P}_2\\right) \\\\ = e\\left(\\langle \\vec{u}, (\\rho_{\\mathsf{a}} \\vec{a}(\\tau) + \\rho_{\\mathsf{b}} \\vec{b}(\\tau) + \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}} \\vec{c}(\\tau)) \\mathcal{P}_1 \\rangle, \\beta \\gamma \\mathcal{P}_2\\right) \\\\ = e\\left(\\langle \\vec{u}, \\rho_{\\mathsf{a}} \\vec{a}(\\tau) \\mathcal{P}_1 \\rangle, \\beta \\gamma \\mathcal{P}_2\\right) \\cdot e\\left(\\langle \\vec{u}, \\rho_{\\mathsf{b}} \\vec{b}(\\tau) \\mathcal{P}_1 \\rangle, \\beta \\gamma \\mathcal{P}_2\\right) \\cdot e\\left(\\langle \\vec{u}, \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}} \\vec{c}(\\tau) \\mathcal{P}_1 \\rangle, \\beta \\gamma \\mathcal{P}_2\\right) \\\\ = e\\left(\\langle \\vec{u}, \\vec{A} \\rangle, \\beta \\gamma \\mathcal{P}_2\\right) \\cdot e\\left(\\beta \\gamma \\mathcal{P}_1, \\langle \\vec{u}, \\rho_{\\mathsf{b}} \\vec{b}(\\tau) \\mathcal{P}_2 \\rangle\\right) \\cdot e\\left(\\langle \\vec{u}, \\vec{C} \\rangle, \\beta \\gamma \\mathcal{P}_2\\right) \\\\ = e\\left(\\langle \\vec{u}, \\vec{A} \\rangle_+ \\langle \\vec{u}, \\vec{C} \\rangle, \\beta \\gamma \\mathcal{P}_2\\right) \\cdot e\\left(\\beta \\gamma \\mathcal{P}_1, \\langle \\vec{u}, \\vec{B} \\rangle\\right) \\\\ \\stackrel{\\text{Prove}}{=} e\\left(A_0 + \\langle \\vec{u}, \\vec{A} \\rangle_{I_\\sigma} + \\langle \\vec{u}, \\vec{A} \\rangle_{I_\\star} + \\langle \\vec{u}, \\vec{A} \\rangle_{I_{mid}} + \\pi_{\\mathsf{c}}, \\beta \\gamma \\mathcal{P}_2\\right) \\cdot e\\left(\\beta \\gamma \\mathcal{P}_1, \\pi_{\\mathsf{b}}\\right) \\\\ \\stackrel{\\text{Prove}}{=} e\\left(A_\\star + \\pi_\\sigma + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\beta \\gamma \\mathcal{P}_2\\right) \\cdot e\\left(\\beta \\gamma \\mathcal{P}_1, \\pi_{\\mathsf{b}}\\right) \\end{array}</span></div>

    <p class="text-gray-300">□</p>

    <h2 id="sec-15" class="text-2xl font-bold">4.2 Adaptive Proof of Knowledge</h2>

    <p class="text-gray-300">In the following theorem we prove that the scheme ADSNARK described in Section 4 satisfies the adaptive proof of knowledge property. For this purpose, we base (part of) the security directly on the proof of knowledge property of the SNARK of Parno et al. [PGHR13] (with the adaptation of [BSCTV14], see Appendix C), that is in turn based on the <span class="math">q</span>-PKE and the <span class="math">q</span>-DHE assumptions.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> If PGHR is a SNARK, <span class="math">\\mathsf{F}</span> is a pseudorandom function, the <span class="math">q</span>-PKE [Gro10] and the <span class="math">q</span>-DHE [CKS09] assumptions hold, then ADSNARK is a secretly-verifiable AD-SNARK with adaptive proof of knowledge.</p>

    <p class="text-gray-300">Before giving the proof, we first recall the <span class="math">q</span>-DHE and the <span class="math">q</span>-PKE assumptions.</p>

    <p class="text-gray-300"><strong>Definition 7 (q-Diffie-Hellman Exponent assumption [CKS09]).</strong> The <span class="math">q</span>-DHE problem is defined as follows. Let <span class="math">\\mathcal{G}</span> be a bilinear group generator, and let <span class="math">\\mathsf{bgpp} = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, \\mathcal{P}_1, \\mathcal{P}_2) \\leftarrow_{\\mathcal{R}} \\mathcal{G}(1^\\lambda)</span>. Let <span class="math">\\tau \\leftarrow_{\\mathcal{R}} \\mathbb{Z}_p</span> be chosen uniformly at random. We define the advantage of an adversary <span class="math">\\mathcal{A}</span> in solving the <span class="math">q</span>-DHE problem as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{Adv}_{\\mathcal{A}}^{q - \\mathrm{DHE}}(\\lambda) = \\Pr \\left[ \\mathcal{A} (\\mathsf{bgpp}, \\tau \\mathcal{P}_1, \\tau \\mathcal{P}_2, \\dots, \\tau^q \\mathcal{P}_1, \\right. \\\\ \\left. \\tau^q \\mathcal{P}_2, \\tau^{q+2} \\mathcal{P}_1, \\tau^{q+2} \\mathcal{P}_2, \\dots, \\tau^{2q} \\mathcal{P}_1, \\tau^{2q} \\mathcal{P}_2) = \\tau^{q+1} \\mathcal{P}_1 \\right]. \\end{array}</span></div>

    <p class="text-gray-300">We say that the <span class="math">q</span>-DHE assumption holds for <span class="math">\\mathcal{G}</span> if for every PPT algorithm <span class="math">\\mathcal{A}</span> and any polynomially-bounded <span class="math">q = \\mathrm{poly}(\\lambda)</span> we have that <span class="math">\\mathbf{Adv}_{\\mathcal{A}}^{q - \\mathrm{DHE}}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300"><strong>Definition 8 (q-Power Knowledge of Exponent assumption [Gro10]).</strong> Let <span class="math">\\mathcal{G}</span> be a bilinear group generator, <span class="math">\\lambda</span> be a security parameter and <span class="math">q = \\mathrm{poly}(\\lambda)</span>. The <span class="math">q</span>-PKE assumption holds for <span class="math">\\mathcal{G}</span> if for every non-uniform PPT adversary <span class="math">\\mathcal{A}</span> there exists a non-uniform PPT extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> such that:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Pr \\left[ \\alpha H = \\hat{H} \\wedge H \\neq \\left(\\sum_{i=0}^q \\tilde{v}_i \\tau^i\\right) \\mathcal{P}_1: \\right. \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left. (H, \\hat{H}; \\tilde{v}_0, \\dots, \\tilde{v}_q) \\leftarrow (\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{\\mathcal{A}}) (\\mathsf{bgpp}, \\tau \\mathcal{P}_1, \\tau \\mathcal{P}_2, \\dots, \\tau^q \\mathcal{P}_1, \\tau^q \\mathcal{P}_2, \\alpha \\mathcal{P}_1, \\alpha \\tau \\mathcal{P}_1, \\dots, \\alpha \\tau^q \\mathcal{P}_1, aux) \\right] = \\mathsf{negl}(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathsf{bgpp} = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, \\mathcal{P}_1, \\mathcal{P}_2) \\leftarrow_{\\mathcal{R}} \\mathcal{G}(1^\\lambda)</span>, <span class="math">\\tau, \\alpha \\leftarrow_{\\mathcal{R}} \\mathbb{Z}_p</span> are chosen uniformly at random, and <span class="math">aux</span> is any auxiliary information that is generated independently of <span class="math">\\alpha</span>. The notation $(H, \\hat{H}; \\tilde{v}_i) \\leftarrow (\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}_{\\mathcal{A}})(\\text{inp})<span class="math"> means that </span>\\mathcal{A}<span class="math"> upon input of inp returns </span>(H, \\hat{H})<span class="math"> and </span>\\mathcal{E}_{\\mathcal{A}}<span class="math"> on the same input returns </span>\\tilde{v}_i<span class="math">. In this case, </span>\\mathcal{E}_{\\mathcal{A}}<span class="math"> has access to </span>\\mathcal{A}$'s random tape.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">In order to prove Theorem 4, we describe a series of hybrid experiments <span class="math">\\mathsf{G}_{0}-\\mathsf{G}_{4}</span>, where experiment <span class="math">\\mathsf{G}_{0}</span> is identical to the real adaptive proof of knowledge experiment and the remaining experiments <span class="math">\\mathsf{G}_{1}-\\mathsf{G}_{4}</span> are progressively modified in such a way that each consecutive pair is proven to be (computationally) indistinguishable. Some of the games use some flag values <span class="math">\\mathsf{bad}_{i}</span> that are initially set to false. If at the end of a game any of these values is set to true, the game simply outputs <span class="math">0</span>. For notation, we denote with <span class="math">\\mathsf{G}_{i}</span> the event that a run of <span class="math">\\mathsf{G}_{i}</span> with the adversary outputs <span class="math">1</span>, and we call <span class="math">\\mathsf{Bad}_{i}</span> the event that <span class="math">\\mathsf{bad}_{i}</span> is set to true during a run of <span class="math">\\mathsf{G}_{i}</span>. Essentially, whenever an event <span class="math">\\mathsf{Bad}_{i}</span> occurs, the corresponding game may deviate its outcome. This is the adaptive proof of knowledge experiment described in Section 3 and Figure 5. This is the same as <span class="math">\\mathsf{G}_{0}</span> except that the PRF <span class="math">\\mathsf{F}_{S}(\\cdot)</span> is replaced by a truly random function <span class="math">\\mathcal{R}:\\{0,1\\}^{*}\\to\\mathbb{F}</span>. By the security of the PRF, <span class="math">\\mathsf{G}_{1}</span> is computationally indistinguishable from <span class="math">\\mathsf{G}_{0}</span>, i.e.,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Pr}[\\mathsf{G}_{0}]-\\mathrm{Pr}[\\mathsf{G}_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathbf{Adv}_{\\mathcal{D},\\mathsf{F}}^{PRF}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This is the same as <span class="math">\\mathsf{G}_{1}</span> except that the procedure <span class="math">\\mathbf{Ver}</span> sets <span class="math">\\mathsf{bad}_{2}\\leftarrow</span> true if the adversary makes verification queries that (a) verify correctly with respect to the equation (A.1)^{secret}, and in which (b) there is a label <span class="math">\\mathsf{L}\\notin T</span> (i.e., <span class="math">\\mathcal{A}</span> never asked to authenticate a value under label <span class="math">\\mathsf{L}</span>). Clearly, <span class="math">\\mathsf{G}_{1}</span> and <span class="math">\\mathsf{G}_{2}</span> are identical until <span class="math">\\mathsf{Bad}_{2}</span>, i.e.,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Pr}[\\mathsf{G}_{1}]-\\mathrm{Pr}[\\mathsf{G}_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathrm{Pr}[\\mathsf{Bad}_{2}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We show that <span class="math">\\mathsf{G}_{2}</span> is statistically close to <span class="math">\\mathsf{G}_{1}</span>, by proving in Lemma 2 that <span class="math">\\mathrm{Pr}[\\mathsf{Bad}_{2}]</span> is (unconditionally) negligible. Intuitively, this follows from the fact that when <span class="math">\\mathsf{L}\\notin\\mathsf{T}</span> the first verification check is an equation with an almost-freshly sampled element <span class="math">\\phi_{\\mathsf{L}}=\\mathcal{R}(\\mathsf{L})\\in\\mathbb{F}</span>, i.e., the equation will be satisfied only with negligible probability, which is at most <span class="math">1/(p-Q)</span> where <span class="math">Q</span> is the number of verification queries made by <span class="math">\\mathcal{A}</span>. This is the same as <span class="math">\\mathsf{G}_{2}</span> except for the following change in <span class="math">\\mathbf{Ver}</span> when answering Type 2 verification queries, i.e., we assume every label <span class="math">\\mathsf{L}</span> was previously used to authenticate a value. Let <span class="math">\\pi_{\\mu},\\pi_{\\sigma}</span> be the elements in the proof <span class="math">\\pi</span> queried by the adversary. In <span class="math">\\mathsf{G}_{3}</span> we compute <span class="math">\\pi_{\\sigma}^{<em>}=\\sum_{k\\in I_{\\sigma}}x_{k}A_{k}\\in\\mathbb{G}_{1}</span>, as well as its corresponding authentication tag <span class="math">\\pi_{\\mu}^{</em>}=\\sum_{k\\in I_{\\sigma}}\\mu_{k}A_{k}</span>, where each <span class="math">\\mu_{k}</span> is the tag previously generated for <span class="math">(\\mathsf{L}_{k},x_{k})</span> upon the respective authentication query. Next, we replace the check of equations (A.1)^{secret} with checking whether</p>

    <p class="text-gray-300"><span class="math">e(\\pi_{\\mu}/\\pi_{\\mu}^{<em>},\\mathcal{P}_{2})=e(\\pi_{\\sigma}/\\pi_{\\sigma}^{</em>},K_{2})</span> (1)</p>

    <p class="text-gray-300">is satisfied. Then, if equation (A.2) is satisfied (hence <span class="math">\\pi_{\\sigma}^{\\prime}=\\alpha_{\\mathsf{a}}\\,\\pi_{\\sigma}</span>), we can run an extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> to obtain a polynomial <span class="math">\\tilde{a}_{\\sigma}(X)</span> of degree at most <span class="math">d</span>. If <span class="math">\\pi_{\\sigma}\\neq\\tilde{a}_{\\sigma}(\\tau)\\rho_{\\mathsf{a}}\\mathcal{P}_{1}</span>, then we set <span class="math">\\mathsf{bad}_{3}\\leftarrow</span> true.</p>

    <p class="text-gray-300">First, we observe that by correctness, checking equation (1) is equivalent to checking the verification equation (A.1)^{secret}. Second, to see that we can run the extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>, we observe that the input received by the adversary <span class="math">\\mathcal{A}</span> can indeed be expressed as a pair <span class="math">(T,aux)</span>, where <span class="math">T=\\{\\tau^{i}\\mathcal{P}_{j},\\alpha\\tau^{i}\\mathcal{P}_{j}\\}_{i\\in[0,d],j=1,2}</span> and <span class="math">aux</span> is some auxiliary information independent of <span class="math">\\alpha</span> – as in the definition of the <span class="math">d</span>-PKE assumption. Hence, <span class="math">\\mathsf{G}_{2}</span> and <span class="math">\\mathsf{G}_{3}</span> are identical up to <span class="math">\\mathsf{Bad}_{3}</span>, i.e.,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Pr}[\\mathsf{G}_{2}]-\\mathrm{Pr}[\\mathsf{G}_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathrm{Pr}[\\mathsf{Bad}_{3}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and it is easy to see that the <span class="math">d</span>-PKE assumption immediately implies that the probability of <span class="math">\\mathsf{Bad}_{3}</span> (i.e., that the extractor outputs a polynomial which is not a correct one) is negligible.</p>

    <p class="text-gray-300">This game proceeds as <span class="math">\\mathsf{G}_{3}</span> except for the following change in the Ver procedure. Assume that the equation (1) is satisfied and that <span class="math">\\mathsf{bad}_{3}\\leftarrow\\mathsf{true}</span> is not set (i.e., <span class="math">\\pi_{\\sigma}=\\tilde{a}_{\\sigma}(\\tau)\\rho_{\\mathsf{a}}\\mathcal{P}_{1}</span> holds). Then, compute the polynomials <span class="math">a_{\\sigma}^{<em>}(X)=\\sum_{k\\in I_{\\sigma}}x_{k}a_{k}(X)</span> and <span class="math">\\delta_{\\mathsf{a}}(X)=\\tilde{a}_{\\sigma}(X)-a_{\\sigma}^{</em>}(X)</span>, where <span class="math">\\tilde{a}_{\\sigma}(X)</span> is the polynomial obtained from the extractor. If <span class="math">\\delta_{\\mathsf{a}}(X)</span> is not divisible by <span class="math">z(X)</span> then set <span class="math">\\mathsf{bad}_{4}\\leftarrow\\mathsf{true}</span>.</p>

    <p class="text-gray-300">Clearly, <span class="math">\\mathsf{G}_{3}</span> and <span class="math">\\mathsf{G}_{4}</span> are identical up to <span class="math">\\mathsf{Bad}_{4}</span>, i.e.,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathsf{G}_{3}]-\\Pr[\\mathsf{G}_{4}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[\\mathsf{Bad}_{4}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To show that the two games are negligibly close, we prove in Lemma 3 that <span class="math">\\Pr[\\mathsf{Bad}_{4}]</span> is negligible under the <span class="math">q</span>-DHE assumption, for some <span class="math">q=2d+1</span>.</p>

    <p class="text-gray-300">Finally, we observe that at this point, if <span class="math">\\mathsf{Bad}_{4}</span> does not occur, we have verified that <span class="math">\\pi_{\\sigma}</span> was computed by using the correct (i.e., authenticated) statement values. Namely, except for having a randomized element <span class="math">\\pi_{\\sigma}</span>, we are almost in the same conditions for breaking the proof of knowledge of PGHR. In fact, in Lemma 4 we show that if any adversary has advantage at most <span class="math">\\epsilon</span> in breaking the adaptive proof of knowledge of PGHR, then <span class="math">\\Pr[\\mathsf{G}_{4}]\\leq Q\\cdot\\epsilon</span>, where <span class="math">Q</span> is the number of Gen queries made by the adversary.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{Bad}_{2}]\\leq Q/(p-Q)</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">Q</span> be the number of verification queries made by the adversary in <span class="math">\\mathsf{G}_{2}</span>, and let <span class="math">B_{i}</span> be the event that <span class="math">\\mathsf{bad}_{2}</span> is first set from false to true in the <span class="math">i</span>-th verification query. Clearly, we have:</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{Bad}_{2}]=\\Pr\\Big{[}\\bigvee_{i=1}^{Q}\\mathsf{B}_{i}\\Big{]}\\leq\\sum_{i=1}^{Q}\\Pr[\\mathsf{B}_{i}]</span></p>

    <p class="text-gray-300">To prove the lemma we will bound the probability <span class="math">\\Pr[\\mathsf{B}_{i}]</span> for any <span class="math">1\\leq i\\leq Q</span>, where the probability is taken over the random choices of the function <span class="math">\\mathcal{R}(\\cdot)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By definition of <span class="math">\\mathsf{B}_{i}</span> we have $\\Pr[\\mathsf{B}_{i}]=\\Pr[\\mathsf{B}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathsf{B}}_{1}\\wedge\\cdots\\wedge\\overline{\\mathsf{B}}_{i-1}]<span class="math">. Also, observe that </span>\\mathsf{bad}_{2}<span class="math"> is set to true if </span>\\exists k\\in I_{\\sigma}<span class="math"> such that </span>(\\mathsf{L}_{k},\\cdot)\\notin\\mathsf{T}$ and the equation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\pi_{\\mu}=\\Big{[}\\sum_{k\\in I_{\\sigma}}\\!\\!\\mathcal{R}(\\mathsf{L}_{k})A_{k}\\Big{]}+\\kappa\\cdot\\pi_{\\sigma}</span> (2)</p>

    <p class="text-gray-300">is satisfied.</p>

    <p class="text-gray-300">Let us fix one such index <span class="math">\\bar{k}\\in I_{\\sigma}</span> such that <span class="math">(\\mathsf{L}_{\\bar{k}},\\cdot)\\notin\\mathsf{T}</span>. If <span class="math">\\phi_{\\bar{k}}=\\mathcal{R}(\\mathsf{L}_{\\bar{k}})</span> is sampled uniformly at random in the <span class="math">i</span>-th query, then the equation above will be satisfied with probability <span class="math">1/p</span>. However, the adversary might have asked <span class="math">\\mathsf{L}_{\\bar{k}}</span> in some previous verification query, and such a query might have leaked some information about <span class="math">\\phi_{\\bar{k}}=\\mathcal{R}(\\mathsf{L}_{\\bar{k}})</span>. Yet, since it holds <span class="math">\\overline{\\mathsf{B}}_{1}\\wedge\\cdots\\wedge\\overline{\\mathsf{B}}_{i-1}</span>, the only information leaked to the adversary is that a bunch of equations involving <span class="math">\\phi_{\\bar{k}}</span> were not satisfied. For each of these unsatisfied equations, one can exclude at most one possible value of <span class="math">\\phi_{\\bar{k}}</span>. In conclusion, we have that in the <span class="math">i</span>-th query, the equation (2) is satisfied with probability at most <span class="math">\\frac{1}{p-(i-1)}</span>. Hence,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{Bad}_{2}]\\leq\\sum_{i=1}^{Q}\\frac{1}{p-(i-1)}\\leq\\frac{Q}{p-Q}.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Lemma 3. If the <span class="math">q</span>-DHE assumption [CKS09] holds for <span class="math">\\mathcal{G}</span>, we have that <span class="math">\\operatorname{Pr}[\\mathsf{Bad}_4]</span> is negligible for any PPT adversary <span class="math">\\mathcal{A}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Assume that there is an adversary <span class="math">\\mathcal{A}</span> such that <span class="math">\\operatorname{Pr}[\\mathsf{Bad}_4] \\geq \\epsilon</span> is non-negligible. We show how to build an adversary <span class="math">\\mathcal{B}</span> that breaks the <span class="math">q</span>-DHE assumption with probability $\\epsilon / DQ - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that: (a) </span>D = \\mathsf{poly}(\\lambda)<span class="math"> is an upper bound on the number of multiplication gates (and thus the degree of the corresponding QAP) in the </span>Q<span class="math"> circuits </span>C_1, \\ldots, C_Q<span class="math"> queried by </span>\\mathcal{A}<span class="math"> to </span>\\mathbf{Gen}<span class="math">, and (b) </span>q = 2d^<em> + 1<span class="math"> for some </span>d^</em> \\leq D<span class="math">, which is the degree of the QAP in the circuit </span>C^*<span class="math"> for which </span>\\mathsf{Bad}_4$ occurs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> takes as input an instance of the <span class="math">q</span>-DHE assumption <span class="math">(\\mathsf{bgpp}, \\tau \\mathcal{P}_1, \\tau \\mathcal{P}_2, \\ldots, \\tau^q \\mathcal{P}_1, \\tau^q \\mathcal{P}_2, \\tau^{q+2} \\mathcal{P}_1, \\tau^{q+2} \\mathcal{P}_2, \\ldots, \\tau^{2q} \\mathcal{P}_1, \\tau^{2q} \\mathcal{P}_2)</span> and its goal is to compute the missing element <span class="math">\\tau^{q+1} \\mathcal{P}_1</span>. To do so, <span class="math">\\mathcal{B}</span> simulates <span class="math">\\mathsf{G}_4</span> to <span class="math">\\mathcal{A}</span> as described in the following. Assume that <span class="math">\\mathsf{Bad}_4</span> occurs for the circuit <span class="math">C^*</span> which is the <span class="math">j</span>-th circuit queried to <span class="math">\\mathbf{Gen}</span>.</p>

    <p class="text-gray-300">Game setup:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{B}</span> sets up the experiment for <span class="math">\\mathcal{A}</span> as in <span class="math">G_4</span> with the following modifications.</li>

      <li>It picks random <span class="math">j^{<em>} \\gets_{\\mathcal{R}} \\{1, \\ldots, Q\\}</span>, <span class="math">d^{</em>} \\gets_{\\mathcal{R}} \\{1, \\ldots, D\\}</span> to guess the query's index of <span class="math">C^{*}</span> and its QAP's degree respectively.</li>

      <li><span class="math">\\mathcal{B}</span> sets <span class="math">q \\gets 2d^{*} + 1</span>, and takes as input an instance <span class="math">(\\mathsf{bgpp}, \\tau \\mathcal{P}_1, \\tau \\mathcal{P}_2, \\ldots, \\tau^q \\mathcal{P}_1, \\tau^q \\mathcal{P}_2, \\tau^{q+2} \\mathcal{P}_1, \\tau^{q+2} \\mathcal{P}_2, \\ldots, \\tau^{2q} \\mathcal{P}_1, \\tau^{2q} \\mathcal{P}_2)</span> of the <span class="math">q</span>-DHE assumption.</li>

      <li>It defines the degree-<span class="math">d^{<em>}</span> polynomial <span class="math">z^{</em>}(X) = \\prod_{k=1}^{d^{*}} (X - r_{k})</span> where <span class="math">\\{r_k\\}</span> is a set of canonical roots used to build the QAP. <span class="math">^{10}</span></li>

      <li><span class="math">\\mathcal{B}</span> chooses <span class="math">\\kappa^{<em>}(X)</span> as a random polynomial in <span class="math">\\mathbb{F}[X]</span> of degree <span class="math">d^{</em>} + 1</span> such that the polynomial <span class="math">\\kappa^{<em>}(X)z^{</em>}(X)</span> of degree <span class="math">2d^{<em>} + 1</span> has a zero coefficient in front of <span class="math">X^{d^{</em>} + 1}</span>.</li>

      <li><span class="math">\\mathcal{B}</span> simulates the secret <span class="math">\\kappa</span> with <span class="math">\\kappa^{<em>}(\\tau)</span> by computing <span class="math">K_{j} = \\kappa^{</em>}(\\tau)\\mathcal{P}_{j}</span>, for <span class="math">j = 1,2</span>. Observe that <span class="math">\\kappa^{<em>}(\\tau)\\mathcal{P}_{j}</span> can be computed efficiently using <span class="math">\\{\\tau^i\\mathcal{P}_j\\}_{i = 0}^{d^</em> +1}</span> contained in the <span class="math">q</span>-DHE instance.</li>

      <li><span class="math">\\mathcal{B}</span> generates a key pair <span class="math">(\\mathsf{sk}&#x27;, \\mathsf{vk}&#x27;) \\gets_{\\mathcal{R}} \\Sigma . \\mathsf{KG}(1^{\\lambda})</span> for the regular signature scheme and gives to the adversary <span class="math">\\mathsf{pap} = (\\mathsf{pp}, \\mathsf{prfpp}, K_1, K_2)</span> and <span class="math">\\mathsf{vk} = (\\mathsf{vk}&#x27;, K_2)</span>.</li>

    </ul>

    <p class="text-gray-300">Gen(C)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> proceeds as follows to simulate the <span class="math">i</span>-th query.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Case <span class="math">i \\neq j^{*}</span>] <span class="math">\\mathcal{B}</span> runs the real <span class="math">\\mathsf{Gen}(\\mathsf{pap}, C)</span> algorithm and returns its output.</li>

      <li>[Case <span class="math">i = j^{<em>}</span>] Let us call <span class="math">C^</em></span> the queried circuit. <span class="math">\\mathcal{B}</span> simulates the answer to this query as follows. First, it builds the QAP for <span class="math">C^<em></span> and if its degree <span class="math">d</span> is not the <span class="math">d^</em></span> guessed earlier, then <span class="math">\\mathcal{B}</span> aborts the simulation. Otherwise, we have <span class="math">d = d^{<em>}</span> and hence <span class="math">z(X) = z^{</em>}(X)</span> and <span class="math">\\mathcal{B}</span> can proceed as follows. For the value <span class="math">\\tau</span>, instead of randomly choosing it, <span class="math">\\mathcal{B}</span> implicitly uses the same value <span class="math">\\tau</span> from the <span class="math">q</span>-DHE assumption. Namely, <span class="math">\\mathcal{B}</span> implicitly sets <span class="math">\\rho_{\\mathsf{a}} = \\rho_{\\mathsf{a}}^{\\prime} \\tau^{d+1}</span> and <span class="math">\\rho_{\\mathsf{c}} = \\rho_{\\mathsf{a}}^{\\prime} \\rho_{\\mathsf{b}} \\tau^{d+1} \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}}</span>, where <span class="math">\\rho_{\\mathsf{a}}^{\\prime}, \\rho_{\\mathsf{b}} \\gets_{\\mathcal{R}} \\mathbb{F}</span>, by computing, for <span class="math">k = 0, \\ldots, m</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">A _ {k} = \\tau^ {d + 1} a _ {k} (\\tau) \\rho_ {\\mathsf {a}} ^ {\\prime} \\mathcal {P} _ {1}, \\quad C _ {k} = \\tau^ {d + 1} c _ {k} (\\tau) \\rho_ {\\mathsf {a}} ^ {\\prime} \\rho_ {\\mathsf {b}} \\mathcal {P} _ {1}, \\quad A _ {m + 1} = \\tau^ {d + 1} z (\\tau) \\rho_ {\\mathsf {a}} ^ {\\prime} \\mathcal {P} _ {1}, \\quad C _ {m + 3} = \\tau^ {d + 1} z (\\tau) \\rho_ {\\mathsf {a}} ^ {\\prime} \\rho_ {\\mathsf {b}} \\mathcal {P} _ {1}.</span></div>

    <p class="text-gray-300">Notice that these values can be computed efficiently since all the polynomials <span class="math">\\tau^{d+1}a_k(\\tau)</span> and <span class="math">\\tau^{d+1}c_k(\\tau)</span> have degree at most <span class="math">2d^<em> &amp;lt; q</span>, while <span class="math">\\tau^{d+1}z(\\tau)</span> has degree <span class="math">2d^</em> + 1 = q</span>. Similarly, all the remaining values <span class="math">\\{B_k\\}</span> can be simulated as the degree of the polynomials encoded in the exponent is at most <span class="math">d^* &amp;lt; q</span>. The simulation of the remaining elements <span class="math">Z, A_k&#x27;, B_k&#x27;, C_k&#x27;, E_k</span> can be done in a very similar way.</p>

    <p class="text-gray-300">10 The roots of the QAP target polynomial can be chosen arbitrarily.</p>

    <p class="text-gray-300">Finally, <span class="math">K_{\\mathsf{a}} = (A_{m + 1})^{\\kappa}</span> is simulated by computing <span class="math">\\rho_{\\mathsf{a}}^{\\prime}(\\tau^{d + 1}\\kappa^{<em>}(\\tau)z(\\tau)\\mathcal{P}_{1})</span>. In particular, note that <span class="math">(\\tau^{d + 1}\\kappa^{</em>}(\\tau)z(\\tau)\\mathcal{P}_{1}</span> can be computed since <span class="math">\\tau^{d + 1}\\kappa^{<em>}(\\tau)z(\\tau)</span> has degree <span class="math">3d + 2</span> and has a zero coefficient in front of <span class="math">\\tau^{2d + 2} = \\tau^{q + 1}</span>, by construction of <span class="math">\\kappa^{</em>}(X)</span>.</p>

    <p class="text-gray-300"><strong>Auth</strong>(L, x)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To simulate authentication queries, <span class="math">\\mathcal{B}</span> samples a random <span class="math">\\mu \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span>, computes <span class="math">\\varPhi=\\mu \\mathcal{P}_2-xK_2</span>, generates $\\sigma' \\leftarrow_{\\mathcal{R}} \\Sigma . \\mathrm{Sign}(\\mathrm{sk}', \\varPhi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{L})<span class="math">, updates </span>\\mathsf{T} \\leftarrow \\mathsf{T} \\cup \\{(\\mathsf{L}, x)\\}<span class="math">, and returns </span>\\sigma = (\\mu, \\varPhi, \\sigma')<span class="math">. Observe that such </span>\\sigma<span class="math"> is identically distributed as an authentication tag returned by Auth in </span>\\mathsf{G}_4<span class="math">. Also, although </span>\\mathcal{B}<span class="math"> is not explicitly generating </span>\\phi \\leftarrow \\mathcal{R}(\\mathsf{L})$, as one can notice, these values are no longer used to answer the verification queries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Ver</strong>(C, L, {xi} L, ≠*, π)</p>

    <p class="text-gray-300">Finally, we describe how <span class="math">\\mathcal{B}</span> handles verification queries. First, note that for those queries that fall in the Type 1 branch, <span class="math">\\mathcal{B}</span> can directly answer <span class="math">\\perp</span> (reject), and it does not have to use the values <span class="math">\\mathcal{R}(\\mathsf{L})</span>. Clearly, due to definition of game <span class="math">\\mathsf{G}_4</span> and since <span class="math">\\mathsf{Bad}_2</span> does not occur, answers to these queries are correctly distributed. Second, for queries in the Type 2 branch, we distinguish two cases according to whether the queried circuit <span class="math">C</span> is <span class="math">C^*</span> or not.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">C \\neq C^*</span>, then <span class="math">\\mathcal{B}</span> can answer as is done in game <span class="math">\\mathsf{G}_4</span>. In particular, note that equation (A.1) secret has been replaced by equation (1) that requires only public values to be checked.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">C = C^<em></span>, then <span class="math">\\mathcal{B}</span> proceeds as in <span class="math">\\mathsf{G}_4</span>. First, set <span class="math">\\delta_{\\mathsf{a}}(X) = \\tilde{a}_{\\sigma}(X) - a_{\\sigma}^{</em>}(X)</span>. Now, since we assume that <span class="math">\\mathsf{Bad}_4</span> occurs in the experiment, this means that <span class="math">\\delta_{\\mathsf{a}}(X)</span> is not divisible by <span class="math">z^{<em>}(X)</span>, i.e., <span class="math">\\delta_{\\mathsf{a}} \\notin \\operatorname{Span}(z^{</em>}(X))</span>. Then <span class="math">\\mathcal{B}</span> checks whether <span class="math">\\omega(X) = \\delta_{\\mathsf{a}}(X)\\kappa^{*}(X)</span> is such that its coefficient <span class="math">\\omega_{d+1}</span> is zero. If so, <span class="math">\\mathcal{B}</span> aborts the simulation (however, by Lemma 10 [GGPR13], this happens with probability at most $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). Otherwise, if </span>\\omega_{d+1} \\neq 0<span class="math">, </span>\\mathcal{B}$ returns</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Omega = \\left(\\omega_{d + 1} \\rho_{\\mathsf{a}}^{\\prime}\\right) ^ {- 1} \\left[ \\pi_{\\mu} - \\pi_{\\mu}^{*} - \\sum_{k = 0, k \\neq d + 1}^{2d + 1} \\rho_{\\mathsf{a}}^{\\prime} \\omega_{k} \\left(\\tau^{k + d + 1} \\mathcal{P}_{1}\\right) \\right]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notice that <span class="math">\\mathcal{B}</span>'s simulation to <span class="math">\\mathcal{A}</span> is perfect except if <span class="math">\\mathcal{B}</span> aborts. However, <span class="math">\\mathcal{B}</span> can abort only in three cases: if its guess on <span class="math">j^<em></span> is wrong, i.e., if <span class="math">j \\neq j^</em></span> (which happens with probability <span class="math">1 - 1/Q</span>); if its guess on <span class="math">d^<em></span> is wrong, i.e., if <span class="math">d \\neq d^</em></span> (which happens with probability <span class="math">1 - 1/D</span>); if <span class="math">\\omega_{d+1} = 0</span> (which holds unconditionally with probability at most $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). Also, it is not hard to see that if </span>\\mathsf{Bad}_4<span class="math"> occurs, then </span>\\mathcal{B}$ returns</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\Omega &amp;amp;= \\left(\\omega_{d + 1} \\rho_{\\mathsf{a}}^{\\prime}\\right) ^ {- 1} \\left[ \\kappa \\left(\\pi_{\\sigma} - \\pi_{\\sigma}^{*}\\right) - \\sum_{k = 0, k \\neq d + 1}^{2d + 1} \\rho_{\\mathsf{a}}^{\\prime} \\omega_{k} \\left(\\tau^{k + d + 1} \\mathcal{P}_{1}\\right) \\right] \\\\ &amp;amp;= \\left(\\omega_{d + 1} \\rho_{\\mathsf{a}}^{\\prime}\\right) ^ {- 1} \\left[ \\rho_{\\mathsf{a}}^{\\prime} \\tau^{d + 1} \\delta_{\\mathsf{a}} (\\tau) \\kappa^{*} (\\tau) \\mathcal{P}_{1} - \\sum_{k = 0, k \\neq d + 1}^{2d + 1} \\rho_{\\mathsf{a}}^{\\prime} \\omega_{k} \\left(\\tau^{k + d + 1} \\mathcal{P}_{1}\\right) \\right] \\\\ &amp;amp;= \\left(\\omega_{d + 1} \\rho_{\\mathsf{a}}^{\\prime}\\right) ^ {- 1} \\left[ \\rho_{\\mathsf{a}}^{\\prime} \\tau^{d + 1} \\omega (\\tau) - \\rho_{\\mathsf{a}}^{\\prime} \\tau^{d + 1} \\left(\\omega (\\tau) - \\omega_{d + 1} \\tau^{d + 1}\\right) \\right] \\mathcal{P}_{1} \\\\ &amp;amp;= \\left(\\omega_{d + 1} \\rho_{\\mathsf{a}}^{\\prime}\\right) ^ {- 1} \\left[ \\rho_{\\mathsf{a}}^{\\prime} \\tau^{d + 1} \\omega_{d + 1} \\tau^{d + 1} \\right] \\mathcal{P}_{1} \\\\ &amp;amp;= \\tau^{2d + 2} \\mathcal{P}_{1} \\end{aligned}</span></div>

    <p class="text-gray-300">and breaks the <span class="math">q</span>-DHE assumption, as desired.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, by putting together the probability that <span class="math">\\mathcal{B}</span> does not abort, with our assumption that <span class="math">\\operatorname{Pr}[\\mathsf{Bad}_4] \\geq \\epsilon</span>, then we obtain that <span class="math">\\mathcal{B}</span> breaks the <span class="math">q</span>-DHE assumption with probability $\\geq \\epsilon / DQ - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> If PGHR satisfies adaptive proof of knowledge, and the <span class="math">q</span>-PKE assumption holds, then for any PPT adversary <span class="math">\\mathcal{A}</span> we have that <span class="math">\\operatorname{Pr}[\\mathsf{G}_4]</span> is negligible.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Assume by contradiction that there exists an adversary <span class="math">\\mathcal{A}</span> such that <span class="math">\\operatorname{Pr}[\\mathsf{G}_4] \\geq \\epsilon</span> is nonnegligible. We show how to build an adversary <span class="math">\\mathcal{B}</span> that breaks the security of PGHR with probability at least <span class="math">\\epsilon / Q_1 Q_2</span>, where <span class="math">Q_1</span> is the number of circuits <span class="math">C_1, \\ldots, C_{Q_1}</span> queried by <span class="math">\\mathcal{A}</span> to <span class="math">\\mathbf{Gen}</span> during game <span class="math">\\mathsf{G}_4</span>, and <span class="math">Q_2</span> is the number of verification queries. Without loss of generality, assume that <span class="math">\\mathcal{B}</span> receives the parameters <span class="math">\\mathsf{bgpp}</span> of the bilinear groups before choosing the circuit <span class="math">C^*</span> to attack.^[11]</p>

    <p class="text-gray-300"><strong>Game setup:</strong></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{B}</span> picks a random <span class="math">j^{<em>} \\gets_{\\mathcal{R}} \\{1, \\ldots, Q_{1}\\}</span> to guess the query's index of <span class="math">C^{</em>}</span>, the circuit for which <span class="math">\\mathcal{A}</span> will break the security of our ADSNARK scheme in game <span class="math">\\mathsf{G}_{4}</span>.</li>

      <li><span class="math">\\mathcal{B}</span> generates a key pair <span class="math">(\\mathsf{sk}&#x27;, \\mathsf{vk}&#x27;) \\gets_{\\mathcal{R}} \\Sigma . \\mathsf{KG}(1^{\\lambda})</span> for the regular signature scheme, and then samples a random <span class="math">\\kappa \\gets_{\\mathcal{R}} \\mathbb{F}</span>. It gives to <span class="math">\\mathcal{A}</span> <span class="math">\\mathsf{pap} = (\\mathsf{bgpp}, \\mathsf{prfpp}, K_1 = \\kappa \\mathcal{P}_1, K_2 = \\kappa \\mathcal{P}_2)</span> and <span class="math">\\mathsf{vk} = (\\mathsf{vk}&#x27;, K_2)</span>.</li>

    </ul>

    <p class="text-gray-300"><strong><span class="math">\\operatorname{Gen}(C)</span></strong></p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> proceeds as follows to simulate the <span class="math">i</span>-th generation query.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Case <span class="math">i \\neq j^{*}</span>] <span class="math">\\mathcal{B}</span> runs the real <span class="math">\\operatorname{Gen}(\\mathsf{pap}, C)</span> algorithm and returns its output.</li>

      <li>[Case <span class="math">i = j^{<em>}</span>] Let us call <span class="math">C^{</em>}</span> the queried circuit. <span class="math">\\mathcal{B}</span> forwards <span class="math">C^{<em>}</span> to its challenger and receives a pair of keys <span class="math">(\\mathsf{VK}_P^</em>, \\mathsf{EK}_P^<em>)</span> of the PGHR scheme. <span class="math">\\mathcal{B}</span> then uses <span class="math">\\kappa</span> to compute <span class="math">K_{\\mathsf{a}} = \\kappa A_{m+1}</span>, sets the key pair of the ADSNARK scheme to <span class="math">(\\mathsf{VK}^</em>, \\mathsf{EK}^<em>)</span>, where <span class="math">\\mathsf{VK}^</em> = \\mathsf{VK}_P^<em></span> and <span class="math">\\mathsf{EK}^</em></span> consists of <span class="math">\\mathsf{EK}_P^*</span> and the additional value <span class="math">K_{\\mathsf{a}}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong><span class="math">\\operatorname{Auth}(\\mathsf{L}, x)</span></strong></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{B}</span> runs <span class="math">\\mathbf{Auth}</span> as in <span class="math">\\mathsf{G}_4</span>, i.e., <span class="math">\\mathcal{B}</span> outputs $\\sigma = (\\mu = \\mathcal{R}(\\mathsf{L}) + \\kappa x, \\Phi = \\mathcal{R}(\\mathsf{L})\\mathcal{P}_2, \\sigma' = \\Sigma . \\mathrm{Sign}(\\mathsf{sk}', \\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{L}))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong><span class="math">\\operatorname{Ver}(C, \\mathsf{L}, \\{x_i\\}_{\\mathsf{L}_i \\neq \\star}, \\tilde{\\pi})</span></strong></p>

    <p class="text-gray-300">Finally, we describe how <span class="math">\\mathcal{B}</span> simulates verification queries to <span class="math">\\mathcal{A}</span>. Notice that all the equation checks require only public values. Also, observe that in <span class="math">\\mathsf{G}_4</span> the adversary <span class="math">\\mathcal{A}</span> can win only by returning a Type 2 forgery, and by returning a proof <span class="math">\\pi</span> containing values <span class="math">\\pi_{\\sigma}, \\pi_{\\sigma}&#x27;</span> of the "correct form", i.e., <span class="math">\\pi_{\\sigma} = (a_{\\sigma}^{<em>}(\\tau) + \\delta_{\\mathsf{a}}^{\\sigma}z(\\tau))\\rho_{\\mathsf{a}}\\mathcal{P}_{1}</span> and <span class="math">\\pi_{\\sigma}&#x27; = (a_{\\sigma}^{</em>}(\\tau) + \\delta_{\\mathsf{a}}^{\\sigma}z(\\tau))\\rho_{\\mathsf{a}}\\alpha_{\\mathsf{a}}\\mathcal{P}_{1} = \\alpha_{\\mathsf{a}}\\pi_{\\sigma}</span> respectively, for some <span class="math">\\delta_{\\mathsf{a}}^{\\sigma} \\in \\mathbb{F}</span>.</p>

    <p class="text-gray-300">So, for every verification query that passes the verification checks and that involves the circuit <span class="math">C^*</span>, <span class="math">\\mathcal{B}</span> translates the given proof <span class="math">\\pi</span> into a proof <span class="math">\\pi_P</span> as described below.</p>

    <p class="text-gray-300"><strong>Translation of <span class="math">\\pi</span> to <span class="math">\\pi_P</span>.</strong> Let <span class="math">\\pi = (\\pi_{\\mu}, \\pi_{\\sigma}, \\pi_{\\sigma}&#x27;, \\pi_{mid}, \\pi_{mid}&#x27;, \\pi_{\\mathsf{b}}, \\pi_{\\mathsf{b}}&#x27;, \\pi_{\\mathsf{c}}, \\pi_{\\mathsf{c}}&#x27;, \\pi_E, H)</span>. First, <span class="math">\\mathcal{B}</span> computes <span class="math">\\hat{\\pi}_{mid} = \\pi_{mid} + (\\pi_{\\sigma} - \\pi_{\\sigma}^{<em>})</span> and <span class="math">\\hat{\\pi}_{mid}&#x27; = \\pi_{mid}&#x27; + (\\pi_{\\sigma}&#x27; - \\pi_{\\sigma}&#x27;</em>)</span>, where <span class="math">\\pi_{\\sigma}^{<em>} = \\langle \\vec{x}, \\vec{A} \\rangle_{I_{\\sigma}}</span> and <span class="math">\\pi_{\\sigma}&#x27;^{</em>} = \\langle \\vec{x}, \\vec{A&#x27;} \\rangle_{I_{\\sigma}}</span>. Then, <span class="math">\\mathcal{B}</span> computes <span class="math">\\hat{\\pi}_E = \\pi_E + \\delta_{\\mathsf{a}}^\\sigma E_{m+1}</span> where <span class="math">\\delta_{\\mathsf{a}}^\\sigma = (\\hat{a}_{\\sigma}(X) - a_{\\sigma}^*(X)) / z(X)</span>. Next, <span class="math">\\mathcal{B}</span> changes the (accepting) proof <span class="math">\\pi</span> produced by <span class="math">\\mathcal{A}</span> by: replacing <span class="math">\\pi_{mid}</span>, <span class="math">\\pi_{mid}&#x27;</span> and <span class="math">\\pi_E</span> with the values <span class="math">\\hat{\\pi}_{mid}</span>, <span class="math">\\hat{\\pi}_{mid}&#x27;</span> and <span class="math">\\hat{\\pi}_E</span> (as computed above) respectively; removing <span class="math">\\pi_{\\sigma}</span>, <span class="math">\\pi_{\\sigma}&#x27;</span>, <span class="math">\\pi_{\\mu}</span>. Let <span class="math">\\pi_P</span> be such modified proof. <span class="math">\\mathcal{B}</span> stores the tuple <span class="math">(\\{x_k\\}_{k \\in \\mathcal{I}_x}, \\pi_P)</span> into a list <span class="math">\\Omega</span>.</p>

    <p class="text-gray-300">First, observe that the proof <span class="math">\\pi_P</span> is identical to a proof in the scheme PGHR, and in particular it has the same distribution. Second, we claim that if <span class="math">\\pi</span> is accepted in <span class="math">\\mathsf{G}_4</span> for the circuit <span class="math">C^*</span> and labels</p>

    <p class="text-gray-300">^[11] We note that this reduction to the security of PGHR is done for ease of exposition. Indeed, we could have included in our simulator <span class="math">\\mathcal{B}</span> the same code of the simulator in the security proof of the PGHR scheme, where the parameters of the bilinear groups are received at the very beginning.</p>

    <p class="text-gray-300"><span class="math">\\{\\mathsf{L}_k\\}_{k\\in \\mathcal{I}_\\sigma}</span> (used to authenticate <span class="math">\\{x_{k}\\}_{k\\in \\mathcal{I}_{\\sigma}}</span>), then <span class="math">\\pi_P</span> is accepted for statement <span class="math">\\{x_{k}\\}_{k\\in \\mathcal{I}_{\\varepsilon}}</span> in the given instance of the PGHR scheme for circuit <span class="math">C^*</span>.</p>

    <p class="text-gray-300">The first claim follows by inspection and by observing that since <span class="math">\\mathsf{Bad}_4</span> does not occur, the value <span class="math">(\\pi_{\\sigma} - \\pi_{\\sigma}^{<em>})</span> contains a multiple of <span class="math">z(\\tau)</span>, i.e., the correct form of <span class="math">\\pi_{mid}</span> is preserved. In particular, the value <span class="math">\\delta_{\\mathsf{a}}^{\\sigma}</span> is a scalar value since <span class="math">(\\tilde{a}_{\\sigma}(X) - a_{\\sigma}^{</em>}(X))</span> is divisible by <span class="math">z(X)</span> which has degree <span class="math">d</span>, and <span class="math">\\deg (\\tilde{a}_{\\sigma}(X)),\\deg (a_{\\sigma}^{*}(X))\\leq d</span>.</p>

    <p class="text-gray-300">The second claim follows from the fact that the value <span class="math">A = \\pi_{\\sigma} + A_{\\star} + \\pi_{mid}</span> computed to verify the proof <span class="math">\\pi</span> in the ADSNARK scheme, and the value <span class="math">A_P = \\langle \\vec{x},\\vec{A}\\rangle_{[0,n]} + \\hat{\\pi}_{mid}</span> computed to verify the proof <span class="math">\\pi_P</span> in PGHR are identical - as <span class="math">\\hat{\\pi}_{mid} = \\pi_{mid} + (\\pi_{\\sigma} - \\pi_{\\sigma}^{*})</span>. Since <span class="math">\\mathsf{Bad}_4</span> does not occur, the value <span class="math">\\delta_{\\mathsf{a}}^{(\\sigma)}</span> is exactly the coefficient used by <span class="math">\\mathcal{A}</span> for the randomization of <span class="math">\\pi_{\\sigma}</span>.</p>

    <p class="text-gray-300">After <span class="math">\\mathcal{A}</span> stops running, <span class="math">\\mathcal{B}</span> picks a random tuple <span class="math">(\\{x_{k}\\}_{k\\in \\mathcal{I}_{\\varepsilon}},\\pi_{P})</span> from the list <span class="math">\\Omega</span> (which contains at most <span class="math">Q_{2}</span> elements) and returns this tuple to its challenger.</p>

    <p class="text-gray-300">To complete the proof we analyze <span class="math">\\mathcal{B}</span>'s success probability. We claim that if <span class="math">\\mathcal{A}</span> breaks the security of the ADSNARK scheme in game <span class="math">\\mathsf{G}_4</span>, then <span class="math">\\mathcal{B}</span> breaks the adaptive proof of knowledge property of PGHR with probability at least <span class="math">1 / Q_1Q_2</span>. It is not hard to see that <span class="math">\\mathcal{B}</span>'s simulation has a distribution which is statistically close to the distribution of game <span class="math">\\mathsf{G}_4</span>. Also, if <span class="math">\\mathcal{A}</span> breaks the scheme it means that for at least one of its verification queries that accepts, say the <span class="math">\\ell</span>-th query, we have that <span class="math">x \\notin \\mathcal{R}_C</span>. Assume that <span class="math">C</span> was the <span class="math">j</span>-th circuit queried to <span class="math">\\mathbf{Gen}</span>, and that <span class="math">\\mathcal{B}</span> returns the <span class="math">\\ell^<em></span>-th tuple in the list <span class="math">\\Omega</span>. Since the simulation does not leak any information on <span class="math">j^</em></span> and <span class="math">\\ell^<em></span>, we have that <span class="math">\\operatorname</em>{Pr}[j^<em> = j \\wedge \\ell^</em> = \\ell] \\geq 1 / Q_1Q_2</span>. Therefore, if <span class="math">\\mathcal{A}</span> breaks the security of the ADSNARK scheme in game <span class="math">\\mathsf{G}_4</span> with probability at least <span class="math">\\epsilon</span>, then <span class="math">\\mathcal{B}</span> breaks the security of PGHR with probability <span class="math">\\geq \\epsilon / Q_1Q_2</span>.</p>

    <p class="text-gray-300"><strong>Adaptive Proof of Knowledge with Public Verifiability.</strong> It is easy to adapt the proof of Theorem 4 in order to show that our scheme satisfies adaptive proof of knowledge even in the case where the proof is made publicly verifiable. Hence, it is possible to prove the following theorem:</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> If PGHR is a SNARK, <span class="math">\\mathsf{F}</span> is a pseudorandom function, <span class="math">\\Sigma</span> is a secure signature scheme, the <span class="math">d</span>-PKE [Gro10] and the <span class="math">q</span>-DHE [CKS09] assumptions hold, then the scheme described above is a publicly-verifiable AD-SNARK with adaptive proof of knowledge.</p>

    <p class="text-gray-300">In the publicly verifiable case, since the adversary can verify the proofs on its own, we can assume that it makes a single verification query to <span class="math">\\mathbf{Ver}</span>. To obtain the proof of Theorem 5, we use the same games as those for Theorem 4. The only difference is that the probability <span class="math">\\operatorname*{Pr}[\\mathsf{Bad}_2]</span> is now shown to be negligible under the assumption that the regular signature scheme is secure. Such claim is rather straightforward: an adversary which returns a proof involving a statement value with label <span class="math">\\mathsf{L}_k</span> that had not been queried to the Auth oracle, has to show at least one signature <span class="math">\\sigma_k&#x27;</span> that verifies correctly for some non-queried label <span class="math">\\mathsf{L}</span>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">4.3 Proof of the Zero-Knowledge Property</h2>

    <p class="text-gray-300"><strong>Theorem 6.</strong> The ADSNARK scheme described in Section 4 is statistically zero-knowledge in the sense of Definition 6.</p>

    <p class="text-gray-300"><strong>Proof.</strong> To see that our scheme satisfies zero-knowledge, our first observation is that the group elements <span class="math">\\pi_{\\sigma}</span>, <span class="math">\\pi_{mid}</span>, and <span class="math">\\pi_{\\mathsf{c}}</span>, are statistically uniform over <span class="math">\\mathbb{G}_1</span> and the same holds for <span class="math">\\pi_{\\mathsf{b}}</span> over <span class="math">\\mathbb{G}_2</span>. Indeed, as long as <span class="math">z(\\tau) \\neq 0</span>, each of these elements is uniformly randomized.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sim1(pp,C,sk,vk,pap)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sim2(td,L,{xi}Li=*)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Run Gen(pap,C) to obtain (EKC,VKC) and also store sk,τ,β,αs,αb,αc,ρs,ρb,ρc in td</td>

            <td class="px-3 py-2 border-b border-gray-700">let a*(X)=a0(X)+∑k∈Ixk aak(X), {φk←FS(Lk)}k∈Iσ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return (EKC,VKC,td)</td>

            <td class="px-3 py-2 border-b border-gray-700">Choose random aσ(X),amid(X)←R F[X]a(X)←aσ(X)+a*(X)+amid(X)Choose random b(X),c(X)←R F[X], such that z(Z)</td>

            <td class="px-3 py-2 border-b border-gray-700">a(X)b(X)-c(X)h(X)←{a(X)b(X)-c(X)/z(X)πμ←{φ, A}Iσ+ρsaσ(τ)κP1πσ←ρsaσ(τ)P1, π′σ←αsπσ, πmid←ρsamid(τ)P1, π′mid←αsπmidπb←ρb(τ)P2, π′b←αbρb(τ)P1, πc←ρcc(τ)P1, π′c←αcπc,πE←β[πσ+πmid+(ρsa*(τ)+ρb(τ))P1+πc]H←h(τ)P1Return π=(πμ,πσ,π′σ,πmid,π′mid,πb,π′b,πc,π′c,πE,H)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 6. Simulator Sim.</p>

    <p class="text-gray-300">Second, we notice that once the elements  <span class="math">\\pi_{\\sigma}</span> ,  <span class="math">\\pi_{mid}</span> ,  <span class="math">\\pi_{\\mathsf{b}}</span> ,  <span class="math">\\pi_{\\mathsf{c}}</span> , are fixed, the values of all the remaining elements in  <span class="math">\\pi</span> , i.e.,  <span class="math">\\pi_{\\mu}</span> ,  <span class="math">\\pi_{\\sigma}^{\\prime}</span> ,  <span class="math">\\pi_{mid}^{\\prime}</span> ,  <span class="math">\\pi_{\\mathsf{b}}^{\\prime}</span> ,  <span class="math">\\pi_{\\mathsf{c}}^{\\prime}</span> ,  <span class="math">\\pi_{E}</span> , and  <span class="math">H</span>  get determined according to the constraints of the verification equations (A.1), (A.2), (P.1), (P.2), (P.3).</p>

    <p class="text-gray-300">Finally, we show that there is a simulator  <span class="math">(\\mathsf{Sim}_1,\\mathsf{Sim}_2)</span> , formally described in Figure 6, that satisfies Definition 6. The simulated keys generated by  <span class="math">\\mathsf{Sim}_1</span>  are distributed as in the real experiment. Regarding  <span class="math">\\mathsf{Sim}_2</span> , it is not hard to see that the simulated values  <span class="math">\\pi_{\\sigma},\\pi_{mid},\\pi_{\\mathsf{b}},\\pi_{\\mathsf{c}}</span>  are statistically uniform. Also, given the trapdoor,  <span class="math">\\mathsf{Sim}_2</span>  can generate (without knowing inputs  <span class="math">\\{x_k\\}_{k\\in I_\\sigma}</span> ) all remaining elements of  <span class="math">\\pi</span>  with the correct distribution, i.e., such that verification equations (A.1), (A.2), (P.1), (P.2), (P.3) are satisfied.</p>

    <p class="text-gray-300">We now describe our implementation of the ADSNARK scheme proposed in Section 4 and then present the experimental results we obtained to support the efficiency and practical applicability claims for our construction.</p>

    <p class="text-gray-300">We have implemented our ADSNARK scheme as an extension to the libsnark library <span class="math">^{12}</span>  [BSCG <span class="math">^{+}</span> 13, BSCTV14]. Our scheme extends the PGHR SNARK implementation offered by this library and supports the same class of statements expressed in the NP-complete language R1CS (rank-1 constraint systems), which is similar to arithmetic circuit satisfiability. The resulting implementation is totally generic, following the libsnark code writing policies, and can be instantiated with arbitrary digital signatures and PRF constructions (in addition to the various parameterization options already offered by the libsnark library). The source code is available upon request.</p>

    <p class="text-gray-300">The modifications to the original PGHR SNARK implementation required by our extensions were relatively small. In the global parameter generation algorithm, the modifications were limited to one additional exponentiation. In the symmetric verification algorithm, we replaced the computations performed on the (known) inputs with (essentially equivalent) computations on the</p>

    <p class="text-gray-300">corresponding authentication elements. In the prover algorithm, the extra code comprises the three multi-exponentiations required to compute the extra authentication elements. Finally, our extensions are most visible in the public verification algorithm where, in addition to the digital signature verification operations, the number of pairings to be computed also increases linearly with the number of authenticated inputs. Our implementation strategy was to employ the optimizations available in the <code>libsnark</code> codebase whenever possible, taking advantage of the existing multi- and batch- exponentiation algorithms. The additional pairing computations required in public verification are performed two-by-two, exploiting the available <em>double Miller loop</em> optimization.</p>

    <p class="text-gray-300">For the extra cryptographic components required by our construction, i.e., the generic signature scheme and the PRF mapping labels to field elements, we have turned to the state-of-the-art implementations offered by the most recent version of the <code>Supercop</code> framework. For the signature scheme, we have used the <code>ed25519</code> implementation described in <em>[BDL^{+}12]</em>, which offers extremely fast batch verification that we incorporated in the <code>ADSNARK</code> public verification algorithm (recall that one signature per input must be verified). For the PRF implementation, we have fixed labels to be 128-bit binary strings and the PRF key to be a 256-bit string partitioned as two AES keys. The PRF construction uses one AES computation to map the input label to a 128-bit pseudorandom seed, applies an independent instance of AES in counter mode to expand the seed to 384 pseudorandom bits, and then uses modular reduction to obtain a pseudorandom 254-bit field element. To select the best <code>ed25519</code> and AES implementations, we have simply run <code>Supercop</code> on our target machine to exhaustively evaluate all available implementations, and then used the recommendations that this framework produced for the fastest implementations and corresponding compilation options.</p>

    <p class="text-gray-300">Microbenchmarks. All measurements were taken in a modest machine with two Dual-Core AMD Opteron 2218 processors clocked at 1 GHz, with 12 GB RAM. The reported values for every parameter correspond to the median of measurements computed over at least 100 runs. Following the original implementation of the <code>libsnark</code> library, we have equipped our implementation of the verification algorithm with the capability to perform part of the computation off-line. However, all our results pessimistically report the full verification time. The security level was set at 128-bits.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.2 Experiments Setup</h3>

    <p class="text-gray-300">We have conducted experiments to carry out two types of performance evaluation: the first targeting general circuits, and the second focusing on a concrete application.</p>

    <p class="text-gray-300">General circuits. To obtain our first set of experimental results, we have relied on the <code>libsnark</code> functionality that permits generating random instances of constraint systems of arbitrary sizes. This allowed us to evaluate the performance of our protocol when dealing with proof goals corresponding to computations of growing complexity and with a varying number of inputs. Our goal here was to corroborate the theoretical analysis presented in Section 4, by benchmarking our protocol</p>

    <p class="text-gray-300">against both the original (unauthenticated) PGHR SNARK protocol and the generic AD-SNARK construction described in Section 3.2 instantiated with PGHR, that we call AD-PGHR.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 7. Experimental results showing generation, proving and verification times for random constraint systems of size  <span class="math">50\\mathrm{K}</span>  and varying number of inputs. For AD-PGHR, the number of multiplication gates is  <span class="math">50K + 1000 \\times \\# \\text{inputs}</span> . For ADSNARK in the public verification variant, the proof size is equal to the SNARK proof size plus the size of the authentication data, which is 128 bytes per input.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generation Time (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving Time (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification Time (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Inputs</td>

            <td class="px-3 py-2 border-b border-gray-700">PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">SK ADSNARK PK</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">16.259</td>

            <td class="px-3 py-2 border-b border-gray-700">44.441</td>

            <td class="px-3 py-2 border-b border-gray-700">16.269</td>

            <td class="px-3 py-2 border-b border-gray-700">19.600</td>

            <td class="px-3 py-2 border-b border-gray-700">56.349</td>

            <td class="px-3 py-2 border-b border-gray-700">19.558</td>

            <td class="px-3 py-2 border-b border-gray-700">0.017</td>

            <td class="px-3 py-2 border-b border-gray-700">0.017</td>

            <td class="px-3 py-2 border-b border-gray-700">0.014</td>

            <td class="px-3 py-2 border-b border-gray-700">0.073</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

            <td class="px-3 py-2 border-b border-gray-700">16.312</td>

            <td class="px-3 py-2 border-b border-gray-700">84.695</td>

            <td class="px-3 py-2 border-b border-gray-700">16.358</td>

            <td class="px-3 py-2 border-b border-gray-700">19.651</td>

            <td class="px-3 py-2 border-b border-gray-700">111.008</td>

            <td class="px-3 py-2 border-b border-gray-700">19.597</td>

            <td class="px-3 py-2 border-b border-gray-700">0.025</td>

            <td class="px-3 py-2 border-b border-gray-700">0.025</td>

            <td class="px-3 py-2 border-b border-gray-700">0.017</td>

            <td class="px-3 py-2 border-b border-gray-700">0.165</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">16.317</td>

            <td class="px-3 py-2 border-b border-gray-700">159.943</td>

            <td class="px-3 py-2 border-b border-gray-700">16.335</td>

            <td class="px-3 py-2 border-b border-gray-700">19.561</td>

            <td class="px-3 py-2 border-b border-gray-700">212.162</td>

            <td class="px-3 py-2 border-b border-gray-700">19.473</td>

            <td class="px-3 py-2 border-b border-gray-700">0.038</td>

            <td class="px-3 py-2 border-b border-gray-700">0.038</td>

            <td class="px-3 py-2 border-b border-gray-700">0.023</td>

            <td class="px-3 py-2 border-b border-gray-700">0.316</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">750</td>

            <td class="px-3 py-2 border-b border-gray-700">16.344</td>

            <td class="px-3 py-2 border-b border-gray-700">236.379</td>

            <td class="px-3 py-2 border-b border-gray-700">16.307</td>

            <td class="px-3 py-2 border-b border-gray-700">19.602</td>

            <td class="px-3 py-2 border-b border-gray-700">380.563</td>

            <td class="px-3 py-2 border-b border-gray-700">19.672</td>

            <td class="px-3 py-2 border-b border-gray-700">0.050</td>

            <td class="px-3 py-2 border-b border-gray-700">0.050</td>

            <td class="px-3 py-2 border-b border-gray-700">0.029</td>

            <td class="px-3 py-2 border-b border-gray-700">0.470</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1000</td>

            <td class="px-3 py-2 border-b border-gray-700">16.350</td>

            <td class="px-3 py-2 border-b border-gray-700">299.314</td>

            <td class="px-3 py-2 border-b border-gray-700">16.276</td>

            <td class="px-3 py-2 border-b border-gray-700">19.513</td>

            <td class="px-3 py-2 border-b border-gray-700">490.852</td>

            <td class="px-3 py-2 border-b border-gray-700">19.612</td>

            <td class="px-3 py-2 border-b border-gray-700">0.062</td>

            <td class="px-3 py-2 border-b border-gray-700">0.062</td>

            <td class="px-3 py-2 border-b border-gray-700">0.035</td>

            <td class="px-3 py-2 border-b border-gray-700">0.613</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proving Key Size (KBytes)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verification Key Size (KBytes)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof size (Kbytes)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Inputs</td>

            <td class="px-3 py-2 border-b border-gray-700">PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">SK ADSNARK PK</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">15650</td>

            <td class="px-3 py-2 border-b border-gray-700">45944</td>

            <td class="px-3 py-2 border-b border-gray-700">15657</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">12.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

            <td class="px-3 py-2 border-b border-gray-700">15640</td>

            <td class="px-3 py-2 border-b border-gray-700">91885</td>

            <td class="px-3 py-2 border-b border-gray-700">15657</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">31.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">15622</td>

            <td class="px-3 py-2 border-b border-gray-700">167092</td>

            <td class="px-3 py-2 border-b border-gray-700">15657</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">62.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">750</td>

            <td class="px-3 py-2 border-b border-gray-700">15605</td>

            <td class="px-3 py-2 border-b border-gray-700">250459</td>

            <td class="px-3 py-2 border-b border-gray-700">15657</td>

            <td class="px-3 py-2 border-b border-gray-700">23.8</td>

            <td class="px-3 py-2 border-b border-gray-700">23.8</td>

            <td class="px-3 py-2 border-b border-gray-700">23.8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">94.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1000</td>

            <td class="px-3 py-2 border-b border-gray-700">15587</td>

            <td class="px-3 py-2 border-b border-gray-700">318590</td>

            <td class="px-3 py-2 border-b border-gray-700">15657</td>

            <td class="px-3 py-2 border-b border-gray-700">31.5</td>

            <td class="px-3 py-2 border-b border-gray-700">31.5</td>

            <td class="px-3 py-2 border-b border-gray-700">31.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">125.4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have arbitrarily fixed the complexity of the computation associated with the proof goal to involve 50K restrictions (or equivalent, roughly 50K multiplication gates), which typically corresponds to a computation of intermediate complexity according to the state of the art (see for example [PGHR13]). The concrete size of the computation is not important, since we will be concerned with the relative degradation of the performance of the various protocols, as we gradually increase the number of (possibly authenticated) inputs to the computation from 100 to 1000. For the generic construction AD-PGHR, we have (very optimistically) taken the penalty for including the signature verification circuit in the proof goal to be only of 1000 multiplications per signature. The fact that, in practice, the cost will probably be higher only strengthens our claims.</p>

    <p class="text-gray-300">Concrete Application. Our second set of experimental results targets a real-world scenario, where the security guarantees provided by an AD-SNARK are highly relevant: a concrete smart-metering application like the one described in the introduction. Analogous results can be obtained for similar applications such as the pay-as-you-drive insurance or the health risk assessment. Our goal here is to indeed demonstrate the practical applicability of our ADSNARK implementation and to show that the overhead incurred by the generic construction can be prohibitive in practice, as it may</p>

    <p class="text-gray-300">lead to a significant increase in the complexity of the proof goal. This is particularly true if the proof goal is reasonably simple to start with, as is the case in the application that follows.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 8. Experimental results showing generation, proving, and verification times for the smart metering application, with the number of measurements varying from 1 day to 28 days (with 48 measurements per day). For AD-PGHR, the number of multiplication gates is  <span class="math">\\# \\text{Mgates} + 1000 \\times \\# \\text{days} \\times 48</span> . For ADSNARK in the public verification variant, the proof size is equal that of the SNARK proof plus the size of the authentication data (128 bytes per input).</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generation Time (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving Time (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification Time (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Days</td>

            <td class="px-3 py-2 border-b border-gray-700">Mgates</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK SK</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK PK</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">8641</td>

            <td class="px-3 py-2 border-b border-gray-700">17.929</td>

            <td class="px-3 py-2 border-b border-gray-700">3.262</td>

            <td class="px-3 py-2 border-b border-gray-700">21.760</td>

            <td class="px-3 py-2 border-b border-gray-700">0.622</td>

            <td class="px-3 py-2 border-b border-gray-700">0.013</td>

            <td class="px-3 py-2 border-b border-gray-700">0.013</td>

            <td class="px-3 py-2 border-b border-gray-700">0.042</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">60481</td>

            <td class="px-3 py-2 border-b border-gray-700">110.164</td>

            <td class="px-3 py-2 border-b border-gray-700">18.296</td>

            <td class="px-3 py-2 border-b border-gray-700">151.146</td>

            <td class="px-3 py-2 border-b border-gray-700">4.463</td>

            <td class="px-3 py-2 border-b border-gray-700">0.030</td>

            <td class="px-3 py-2 border-b border-gray-700">0.020</td>

            <td class="px-3 py-2 border-b border-gray-700">0.219</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">120961</td>

            <td class="px-3 py-2 border-b border-gray-700">214.457</td>

            <td class="px-3 py-2 border-b border-gray-700">34.507</td>

            <td class="px-3 py-2 border-b border-gray-700">306.705</td>

            <td class="px-3 py-2 border-b border-gray-700">9.078</td>

            <td class="px-3 py-2 border-b border-gray-700">0.047</td>

            <td class="px-3 py-2 border-b border-gray-700">0.028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.421</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">181441</td>

            <td class="px-3 py-2 border-b border-gray-700">213.647</td>

            <td class="px-3 py-2 border-b border-gray-700">50.770</td>

            <td class="px-3 py-2 border-b border-gray-700">444.592</td>

            <td class="px-3 py-2 border-b border-gray-700">14.314</td>

            <td class="px-3 py-2 border-b border-gray-700">0.062</td>

            <td class="px-3 py-2 border-b border-gray-700">0.037</td>

            <td class="px-3 py-2 border-b border-gray-700">0.628</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">241921</td>

            <td class="px-3 py-2 border-b border-gray-700">431.341</td>

            <td class="px-3 py-2 border-b border-gray-700">65.539</td>

            <td class="px-3 py-2 border-b border-gray-700">629.003</td>

            <td class="px-3 py-2 border-b border-gray-700">18.426</td>

            <td class="px-3 py-2 border-b border-gray-700">0.077</td>

            <td class="px-3 py-2 border-b border-gray-700">0.043</td>

            <td class="px-3 py-2 border-b border-gray-700">0.823</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proving Key Size (KBytes)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verification Key Size (KBytes)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof size (Kbytes)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Days</td>

            <td class="px-3 py-2 border-b border-gray-700">Mgates</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">AD-PGHR</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK SK</td>

            <td class="px-3 py-2 border-b border-gray-700">ADSNARK PK</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">8641</td>

            <td class="px-3 py-2 border-b border-gray-700">17463</td>

            <td class="px-3 py-2 border-b border-gray-700">2500</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">6.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">60481</td>

            <td class="px-3 py-2 border-b border-gray-700">124274</td>

            <td class="px-3 py-2 border-b border-gray-700">17641</td>

            <td class="px-3 py-2 border-b border-gray-700">10.9</td>

            <td class="px-3 py-2 border-b border-gray-700">10.9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">42.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">120961</td>

            <td class="px-3 py-2 border-b border-gray-700">248547</td>

            <td class="px-3 py-2 border-b border-gray-700">35282</td>

            <td class="px-3 py-2 border-b border-gray-700">21.3</td>

            <td class="px-3 py-2 border-b border-gray-700">21.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">84.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">181441</td>

            <td class="px-3 py-2 border-b border-gray-700">364661</td>

            <td class="px-3 py-2 border-b border-gray-700">52923</td>

            <td class="px-3 py-2 border-b border-gray-700">31.8</td>

            <td class="px-3 py-2 border-b border-gray-700">31.8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">126.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">241921</td>

            <td class="px-3 py-2 border-b border-gray-700">497094</td>

            <td class="px-3 py-2 border-b border-gray-700">70563</td>

            <td class="px-3 py-2 border-b border-gray-700">42.2</td>

            <td class="px-3 py-2 border-b border-gray-700">42.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">168.4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We focus on the smart-metering application described in [RD11, FKDL13] where a (non-linear) cumulative price function is applied to the consumption measurements in order to determine the aggregated cost. The idea here is that the smart meter is able to authenticate the measurements, and that the client locally computes the monetary value corresponding to the measured consumption. The client can then use an AD-SNARK protocol to demonstrate to the supplier that the computation is correct and based on legitimate measurements, without divulging the details of the individual values. As a simple example of a cumulative policy [RD11], one may think of a non-linear function defined by the following list of threshold/price pairs:  <span class="math">[(0,2),(3,5),(7,8)]</span> . This policy establishes four consumption intervals and their corresponding prices, as follows:  <span class="math">[0,3] \\to 2</span> ,  <span class="math">(3,7] \\to 5</span> ,  <span class="math">(7,\\infty) \\to 8</span> . For a measured consumption of 9, the price due is  <span class="math">3 \\times 2 + 4 \\times 5 + 2 \\times 8 = 42</span> .</p>

    <p class="text-gray-300">In this application, the complexity of the price computation depends on both the number of measurements and the number of intervals prescribed by the cost function.</p>

    <p class="text-gray-300">We have implemented a generator of R1CS statements that, for a specified number of measurements and a concrete cumulative cost function, is able to construct a constraint system for an arithmetic circuit that checks the correctness of the computed cost, for any given set of measurements. The number of multiplication gates in (i.e., the number of constraints associated to) the</p>

    <p class="text-gray-300">resulting circuits is <span class="math">36 \\times \\# \\text{measurements} \\times \\# \\text{intervals} + 1</span>. For the generic construction AD-PGHR, we have again used the estimate of 1000 additional multiplications per signature verification. We set the number of thresholds to 5 (a coarse level of granularity in specifying the non-linear policy) so that we obtain a moderately sized circuit even for a month's worth of readings. We then take the indicative value of 48 measurements per day, and vary the number of days separating the price computation to be 1, 7, 14, 21, and 28 days. The policy is defined by thresholds 5, 10, 15, 20, and 25. The measurement values were sampled at random in the range 0 to 100.</p>

    <h2 id="sec-22" class="text-2xl font-bold">5.3 Performance for General Circuits</h2>

    <p class="text-gray-300">Figure 7 shows the results we obtained in terms of execution time. It is clear from the graphs the rapid degradation of the global generation and proving times in the case of AD-PGHR. This is a direct consequence of increasing the size of the circuit and corresponding increase in the size of the proving key, which for 1000 inputs in AD-PGHR approaches 320 MB, as opposed to 15 MB for ADSNARK and PGHR.¹⁹ The (relatively) small penalty paid for using public verification in ADSNARK is visible in the verification times. Furthermore, it is interesting to observe that the secret-key verification of ADSNARK is as fast as the one of AD-PGHR or the (unauthenticated) PGHR. The size of the proof is under 500 bytes for all protocols except the public verification version of AD-PGHR, where the authentication data takes an additional 128 bytes per input. Even so, for 1000 inputs, the proof size is under 126Kbytes.²⁰</p>

    <h2 id="sec-23" class="text-2xl font-bold">5.4 Performance for Smart Metering Billing</h2>

    <p class="text-gray-300">Figure 8 shows the results we obtained in terms of execution time. It is clear from the graphs that ADSNARK yields proving times that are compatible with real-world deployment: even for one month's worth of measurements, the proving time is around 18 seconds, the proof size is under 0.5 KB for secret verification and under 170 KB for public verification. The contrast to AD-PGHR is evident, where the proof size is essentially the same as ADSNARK with secret verification, but the running time of the AD-PGHR's prover goes up to over 10 minutes. Moreover, even for a month's worth of readings, ADSNARK would pay little more time for public verification (around 0.8 seconds vs. 0.08 seconds of AD-PGHR). Although this may not be very important for smart-metering, it shows, once more, that the public verification time scales very well.</p>

    <h2 id="sec-24" class="text-2xl font-bold">6 Further Related Work</h2>

    <p class="text-gray-300">As we mentioned earlier, our work extends the notion of succinct non-interactive arguments of knowledge (SNARKs) [Mic94, BCCT12], which in turn build on (succinct) interactive proofs [GMR89] and interactive arguments [Kil92, Kil95]. In particular, we focus on the so-called preprocessing model where the verifier is required to run an expensive but re-usable key generation phase. In this preprocessing model, several works [Gro10, Lip12, GGPR13, BCI⁺13] proposed efficient realizations of SNARKs, and more recent works [PGHR13, BSCG⁺13, BSCTV14] have shown efficient,</p>

    <p class="text-gray-300">¹⁹ The circuit implementation assumes that measurements and thresholds are represented as 32-bit integer values.</p>

    <p class="text-gray-300">²⁰ For PGHR and ADSNARK the variations in generation and proving times with the increasing number of inputs are barely visible due to the fact that the number of constraints in the circuit is fixed at 50K.</p>

    <p class="text-gray-300">²⁰ In our implementation each signature and public key takes 64 bytes, and the group element takes 64 bytes per input.</p>

    <p class="text-gray-300">highly-optimized, implementations that support general-purpose computations. These schemes can also support zero-knowledge proofs. It is worth mentioning that all known SNARKs are either in the random oracle model or rely on non-standard non-falsifiable assumptions <em>[x19]</em>. Assumptions from this class have been shown <em>[x13]</em> likely to be inherent for SNARKs for <span class="math">\\mathcal{NP}</span>.</p>

    <p class="text-gray-300">The notion of SNARKs is also related to <em>verifiable computation</em> <em>[x12]</em>, in which a (computationally weak) client delegates the computation of a function to a powerful server and wants to verify the result efficiently. As noted in previous work, by using SNARKs for <span class="math">\\mathcal{NP}</span>, it is possible to construct a verifiable computation scheme, and several works <em>[x12, x20, BSCG^{+}13]</em> indeed follow this approach. However, alternative approaches to realizing verifiable computation have been proposed, notably based on fully homomorphic encryption <em>[x12, x7, x2]</em> or attribute-based encryption <em>[x22]</em>.</p>

    <p class="text-gray-300">Another line of work which is closely related to ours is the one on <em>homomorphic authentication</em> (comprising both homomorphic/malleable signatures <em>[x16, x4, ABC^{+}12, x6]</em> and MACs <em>[x13, x8, x3]</em>). The main idea of homomorphic authenticators is that, given a set of messages <span class="math">(\\sigma_{1},\\ldots,\\sigma_{n})</span> authenticated using a secret key <span class="math">\\mathsf{sk}</span>, anyone can evaluate a program <span class="math">P</span> on such authenticated messages in a way that the result <span class="math">\\sigma\\leftarrow P(\\{\\sigma_{i}\\})</span> is again authenticated with respect to the same key <span class="math">\\mathsf{sk}</span> (or some public key <span class="math">\\mathsf{vk}</span> in the case of signatures). Some works in this area <em>[ABC^{+}12, x6]</em> considered various privacy notions (called context-hiding) to model that signatures on the outputs of a computation should not reveal information about the inputs. In this sense, AD-SNARKs are closely related to the notion of multi-input malleable signatures <em>[x6]</em>. However, to the best of our knowledge, none of these schemes achieves practical efficiency for arbitrary computations.</p>

    <p class="text-gray-300">The recent work <span class="math">Z\\emptyset</span> <em>[x11]</em> aimed to combine the best of different zero-knowledge proof systems by doing an efficiency cost analysis to use the best one for every application. In particular, <span class="math">Z\\emptyset</span> relies on both ZQL and Pinocchio <em>[x20]</em>. However, when using Pinocchio with authenticated data, <span class="math">Z\\emptyset</span> does not provide any guarantee on the integrity of this data, i.e., on the validity of the corresponding signatures.</p>

    <h2 id="sec-25" class="text-2xl font-bold">7 More Applications</h2>

    <p class="text-gray-300">In this section we describe three more applications that fit our three-party model.</p>

    <p class="text-gray-300">Pay-as-you-drive Insurance. Similarly to the smart-metering scenario, a trusted black-box installed in the client’s car collects information on the driving habits; the driver receives the information and needs to pay a premium to the insurance company according to the driving information (distances, speed, safety, etc.). For privacy, the driver may not want to reveal her personal driving habits to the insurance company. For integrity, the company wants to be sure that every driver pays the correct premium. The solution is similar to the one for smart-metering: the black-box plays the role of the trusted source, the driver keeps the collected information locally, sends to the company only the computed premium and uses AD-SNARK to attest its correctness.</p>

    <p class="text-gray-300">Loyalty Cards. Many large retailers use customer loyalty cards to encourage repeat visits. Typically, the customer must enroll in a loyalty program, and receive a card that can be shown to receive discounts in future visits. However, this has the great disadvantage of allowing the retailer to keep track of the purchase history of its clients. One solution <em>[x11]</em> would be to let the point of sale become the trusted source by transferring to the client’s mobile phone a signed purchase transaction. The client should then be able to compute the discount claim locally, and</p>

    <p class="text-gray-300">use AD-SNARK to prove to the retailer that this is correct and performed on legitimate purchase transactions, without revealing the exact details of its prior purchases.</p>

    <p class="text-gray-300">Health Statistics. Governments and states must periodically publish health statistics in order to inform the public of the status of healthcare systems. Obviously, the original data cannot be made public because it will contain sensitive information pertaining to the people receiving health care. However, this raw information can be authenticated by medical practitioners, who can operate as trusted sources. In this case, the general public (playing the role of a multitude of service providers) can be given the assurance that the statistics computed by the government (playing the role of the data owner) are correct and originated in legitimate medical data by using AD-SNARK.</p>

    <h2 id="sec-26" class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">This paper presents and addresses the problem of enabling privacy-preserving (aka zero-knowledge) data processing with a specific focus on the case where the input data is authenticated, and solely the authentication guarantees “percolate” to the resulting proof, without disclosing information on the original data. Current approaches to solve this problem are limited in either the class of computations that can be supported <em>[x11]</em>, or in the prover’s scalability (as we show in our experiments).</p>

    <p class="text-gray-300">In this paper, we propose a formal approach to this three-party problem via a new cryptographic primitive, AD-SNARK, of which we propose an efficient realization. Starting from our realization, we build and evaluate a nearly practical system, ADSNARK, for proving arbitrary computations over authenticated data in a privacy-preserving way.</p>

    <p class="text-gray-300">Our experimental evaluations show that ADSNARK performs essentially as well as non-authenticated state of the art solutions <em>[x30, x5]</em>, which means that it scales excellently for modest computations. Moreover, ADSNARK dramatically improves over generic solutions to the input authentication problem. Furthermore, since ADSNARK leverages the recent developments in zero-knowledge proof systems, it permits handling arbitrary computations in an easy and usable way. Indeed, any of the available compilers (e.g., <em>[x30]</em>) can be used as a front-end tool for translating from high-level languages (e.g., C++) into arithmetic circuit satisfaction problems that can later be passed to the zero-knowledge backend, in our case to ADSNARK.</p>

    <p class="text-gray-300">ADSNARK also inherits some of the limitations of existing SNARKs, such as the use of the circuit computation model. Recent work <em>[x5]</em> have shown how to move to more efficient representations such as RAM. We leave it as future work to study the extension of AD-SNARKs to more convenient and efficient computation models.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABC^{+}12] Jae Hyun Ahn, Dan Boneh, Jan Camenisch, Susan Hohenberger, abhi shelat, and Brent Waters. Computing on authenticated data. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 1–20. Springer, March 2012.</li>

      <li>[AF10] Ross Anderson and Shailendra Fuloria. On the security economics of electricity metering. In 9th Annual Workshop on the Economics of Information Security, WEIS 2010, Harvard University, Cambridge, MA, USA, June 7-8, 2010, 2010.</li>

      <li>[AIK10] Benny Applebaum, Yuval Ishai, and Eyal Kushilevitz. From secrecy to soundness: Efficient verification via secure computation. In Samson Abramsky, Cyril Gavoille, Claude Kirchner, Friedhelm Meyer auf der Heide, and Paul G. Spirakis, editors, ICALP 2010, Part I, volume 6198 of LNCS, pages 152–163. Springer, July 2010.</li>

      <li>[BB04] Dan Boneh and Xavier Boyen. Short signatures without random oracles. In Christian Cachin and Jan Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 56–73. Springer, May 2004.</li>

      <li>[BBC14] BBC. Google unveils ’smart contact lens’ to measure glucose levels. http://www.bbc.com/news/technology-25771907, 2014.</li>

      <li>[BBG05] Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based encryption with constant size ciphertext. In Ronald Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 440–456. Springer, May 2005.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Shafi Goldwasser, editor, ITCS 2012, pages 326–349. ACM, January 2012.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, March 2013.</li>

      <li>[BDL^{+}12] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. High-speed high-security signatures. J. Cryptographic Engineering, 2(2):77–89, 2012.</li>

      <li>[BF11] Dan Boneh and David Mandell Freeman. Homomorphic signatures for polynomial functions. In Kenneth G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 149–168. Springer, May 2011.</li>

      <li>[BFR13] Michael Backes, Dario Fiore, and Raphael M. Reischuk. Verifiable delegation of computation on outsourced data. In Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung, editors, ACM CCS 13, pages 863–874. ACM Press, November 2013.</li>

      <li>[Boy10] Xavier Boyen. Lattice mixing and vanishing trapdoors: A framework for fully secure short signatures and more. In Phong Q. Nguyen and David Pointcheval, editors, PKC 2010, volume 6056 of LNCS, pages 499–517. Springer, May 2010.</li>

      <li>[BSCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90–108. Springer, August 2013.</li>

      <li>[BSCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In USENIX Security, pages 781–796, 2014.</li>

      <li>[CF13] Dario Catalano and Dario Fiore. Practical homomorphic MACs for arithmetic circuits. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 336–352. Springer, May 2013.</li>

      <li>[Cha85] David Chaum. Security without identification: Transaction systems to make big brother obsolete. Commun. ACM, 28(10):1030–1044, October 1985.</li>

      <li>[CKLM14] Melissa Chase, Markulf Kohlweiss, Anna Lysyanskaya, and Sarah Meiklejohn. Malleable signatures: New definitions and delegatable anonymous credentials. In Computer Security Foundation (CSF), 2014.</li>

      <li>[CKS09] Jan Camenisch, Markulf Kohlweiss, and Claudio Soriente. An accumulator based on bilinear maps and efficient revocation for anonymous credentials. In Stanislaw Jarecki and Gene Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 481–500. Springer, March 2009.</li>

      <li>[CKV10] Kai-Min Chung, Yael Kalai, and Salil P. Vadhan. Improved delegation of computation using fully homomorphic encryption. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 483–501. Springer, August 2010.</li>

      <li>[CS99] Ronald Cramer and Victor Shoup. Signature schemes based on the strong RSA assumption. In ACM CCS 99, pages 46–51. ACM Press, November 1999.</li>

    </ul>

    <p class="text-gray-300">Dam88. Ivan Damgård. Payment systems and credential mechanisms with provable security against abuse by individuals. In Shafi Goldwasser, editor, CRYPTO’88, volume 403 of LNCS, pages 328–335. Springer, August 1988.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>FKDL13. Cédric Fournet, Markulf Kohlweiss, George Danezis, and Zhengqin Luo. ZQL: A compiler for privacy-preserving data processing. In Proceedings of the 22Nd USENIX Conference on Security, SEC’13, pages 163–178, Berkeley, CA, USA, 2013. USENIX Association.</li>

      <li>FL14. Matthew Fredrikson and Ben Livshits. ZO: An optimizing distributing zero-knowledge compiler. In USENIX Security, 2014.</li>

      <li>GGP10. Rosario Gennaro, Craig Gentry, and Bryan Parno. Non-interactive verifiable computing: Outsourcing computation to untrusted workers. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 465–482. Springer, August 2010.</li>

      <li>GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, May 2013.</li>

      <li>GMR89. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989.</li>

      <li>Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, December 2010.</li>

      <li>GW11a. Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99–108. ACM Press, June 2011.</li>

      <li>GW11b. Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In STOC ’11: Proceedings of the 43rd Annual ACM Symposium on Theory of Computing. ACM, 2011.</li>

      <li>GW13. Rosario Gennaro and Daniel Wichs. Fully homomorphic message authenticators. In Kazue Sako and Palash Sarkar, editors, ASIACRYPT 2013, Part II, volume 8270 of LNCS, pages 301–320. Springer, December 2013.</li>

      <li>JMSW02. Robert Johnson, David Molnar, Dawn Xiaodong Song, and David Wagner. Homomorphic signature schemes. In Bart Preneel, editor, CT-RSA 2002, volume 2271 of LNCS, pages 244–262. Springer, February 2002.</li>

      <li>Kil92. Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

      <li>Kil95. Joe Kilian. Improved efficient arguments (preliminary version). In Don Coppersmith, editor, CRYPTO’95, volume 963 of LNCS, pages 311–324. Springer, August 1995.</li>

      <li>Lip12. Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169–189. Springer, March 2012.</li>

      <li>LRSW99. Anna Lysyanskaya, Ronald L. Rivest, Amit Sahai, and Stefan Wolf. Pseudonym systems. In Howard M. Heys and Carlisle M. Adams, editors, SAC 1999, volume 1758 of LNCS, pages 184–199. Springer, August 1999.</li>

      <li>MEK^{+}10. Sarah Meiklejohn, C. Chris Erway, Alptekin Küpçü, Theodora Hinkle, and Anna Lysyanskaya. Zkpdl: A language-based system for efficient zero-knowledge proofs and electronic cash. In Proceedings of the 19th USENIX Conference on Security, USENIX Security’10, pages 13–13, Berkeley, CA, USA, 2010. USENIX Association.</li>

      <li>Mic94. Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, November 1994.</li>

      <li>Nao03. Moni Naor. On cryptographic assumptions and challenges (invited talk). In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS, pages 96–109. Springer, August 2003.</li>

      <li>PGHR13. Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE Symposium on Security and Privacy, Oakland, 2013. Corrected version (13 May 2013): http://eprint.iacr.org/2013/279.</li>

      <li>PRV12. Bryan Parno, Mariana Raykova, and Vinod Vaikuntanathan. How to delegate and verify in public: Verifiable computation from attribute-based encryption. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 422–439. Springer, March 2012.</li>

      <li>RD11. Alfredo Rial and George Danezis. Privacy-preserving smart metering. In Proceedings of the 10th Annual ACM Workshop on Privacy in the Electronic Society, WPES ’11, pages 49–60, New York, NY, USA, 2011. ACM.</li>

    </ul>

    <p class="text-gray-300">Vit14. Vitalconnect. Healthpatch. http://www.vitalconnect.com, 2014.</p>

    <p class="text-gray-300">Wat05. Brent R. Waters. Efficient identity-based encryption without random oracles. In Ronald Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 114-127. Springer, May 2005.</p>

    <p class="text-gray-300">In this section we discuss two extensions of AD-SNARKs. The first one is a generalization of AD-SNARKs to the setting in which one proves statements authenticated by multiple data sources. As a second extension we show how to obtain a scheme in which the verification algorithm runs in time independent of the number of authenticated inputs. This second extension supports only secret-key verification and assumes labels with a specific structure.</p>

    <p class="text-gray-300">A multi-source AD-SNARK is an AD-SNARK where: the Gen algorithms takes in a tuple of  <span class="math">k</span>  public authentication parameters; the Prove may receive inputs authenticated using different authentication keys (i.e., from multiple data sources); the Ver algorithm takes as input a set of authentication verification keys and extended labels  <span class="math">\\mathsf{L}</span>  where each  <span class="math">\\mathsf{L}_i</span>  specifies if the statement value  <span class="math">x_i</span>  is authenticated and under which key. The definition of completeness is the straightforward generalization of the one in Section 5. Adaptive proof of knowledge is similar to the one of Definition 5 except that in the multi-source setting the adversary is allowed to obtain values authenticated under all possible keys.</p>

    <p class="text-gray-300">AN EFFICIENT MULTI-SOURCE AD-SNARK scheme. We briefly show how to adapt our AD-SNARK construction of Section 4 to work in the multi-source setting.</p>

    <p class="text-gray-300">The algorithms Setup, AuthKG, Auth and AuthVer are identical. The remaining algorithms work as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Gen}(\\{\\mathsf{pap}_j\\}, C)</span>  takes as input a circuit  <span class="math">C</span>  and  <span class="math">k</span>  public authentication parameters  <span class="math">\\mathsf{pap}_1, \\ldots, \\mathsf{pap}_k</span> . It proceeds exactly as in Gen of Section 4 except that now it computes a  <span class="math">K_{\\mathsf{a}}</span>  value for each authentication key. Namely, it computes (and includes in  <span class="math">\\mathsf{EK}_C</span> )  <span class="math">K_{\\mathsf{a},j} = z(\\tau)\\rho_{\\mathsf{a}}K_{1,j}</span> , for  <span class="math">j = 1, \\ldots, k</span> .</p>

    <p class="text-gray-300">Prove(EK <span class="math">_C</span> ,  <span class="math">\\vec{x}</span> ,  <span class="math">\\vec{w}</span> ,  <span class="math">\\vec{\\sigma}</span> ): here each authentication tag  <span class="math">\\sigma_i</span>  in  <span class="math">\\vec{\\sigma}</span>  also specifies under which authentication key  <span class="math">\\mathsf{vk}_{j_i}</span>  it verifies. The set  <span class="math">I_{\\sigma}</span>  is then further partitioned in several subsets  <span class="math">I_{\\sigma,j}</span> , one for every authentication key used in the statement. Without loss of generality, assume there are  <span class="math">k</span>  of such sets. The algorithm proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\vec{s} = \\mathsf{QAPwit}(C,\\vec{x},\\vec{w})\\in \\mathbb{F}^m</span></li>

      <li>Randomly sample  <span class="math">\\delta_{\\mathsf{a}}^{(1)},\\ldots ,\\delta_{\\mathsf{a}}^{(k)},\\delta_{\\mathsf{a}}^{mid},\\delta_{\\mathsf{b}},\\delta_{\\mathsf{c}}\\gets_{\\mathcal{R}}\\mathbb{F}</span> , and set  <span class="math">\\delta_{\\mathsf{a}} = \\sum_{j = 1}^{k}\\delta_{\\mathsf{a}}^{(j)} + \\delta_{\\mathsf{a}}^{mid}</span> . Also, define the vector  <span class="math">\\vec{u} = (1,\\vec{s},\\delta_{\\mathsf{a}},\\delta_{\\mathsf{b}},\\delta_{\\mathsf{c}})\\in \\mathbb{F}^{m + 4}</span>  as before.</li>

      <li>Solve the QAP  <span class="math">Q_{C}</span>  exactly as in Prove of Section 4. Then compute  <span class="math">H = h(\\tau)\\mathcal{P}_1</span>  using the values  <span class="math">\\tau^i\\mathcal{P}_1</span>  contained in the evaluation key  <span class="math">\\mathsf{EK}_C</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j = 1</span> to <span class="math">k</span>, compute:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_{\\sigma,j} = \\langle \\vec{u}, \\vec{A} \\rangle_{I_{\\sigma,j}} + \\delta_{\\mathbf{a}}^{(j)} A_{m+1}, \\pi_{\\sigma,j}&#x27; = \\langle \\vec{u}, \\vec{A}&#x27; \\rangle_{I_{\\sigma,j}} + \\delta_{\\mathbf{a}}^{(j)} A_{m+1}&#x27;,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_{mid} = \\langle \\vec{u}, \\vec{A} \\rangle_{I_{mid}} - \\sum_{j=1}^{k} \\delta_{\\mathbf{a}}^{(j)} A_{m+1},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_{mid}&#x27; = \\langle \\vec{u}, \\vec{A}&#x27; \\rangle_{I_{\\sigma}} - \\sum_{j=1}^{k} \\delta_{\\mathbf{a}}^{(j)} A_{m+1}&#x27;.</span></div>

    <p class="text-gray-300">and then compute <span class="math">\\pi_{\\mathsf{b}}, \\pi_{\\mathsf{b}}&#x27;, \\pi_{\\mathsf{c}}, \\pi_{\\mathsf{c}}&#x27;, \\pi_{E}</span> as in Section 4.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Authenticate each value <span class="math">\\pi_{\\sigma,j}</span> by computing</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_{\\mu,j} = \\langle \\vec{\\mu}, \\vec{A} \\rangle_{I_{\\sigma,j}} + \\delta_{\\mathbf{a}}^{(j)} K_{\\mathbf{a},j}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\pi = (\\{\\pi_{\\mu,j}, \\pi_{\\sigma,j}, \\pi_{\\sigma,j}&#x27;\\}, j=1, \\pi_{mid}, \\pi_{mid}&#x27;, \\pi_{\\mathsf{b}}, \\pi_{\\mathsf{b}}&#x27;, \\pi_{\\mathsf{c}}, \\pi_{\\mathsf{c}}&#x27;, \\pi_{E}, H)</span>. To make the proof publicly verifiable, include also <span class="math">\\{\\varPhi_k, \\sigma_k&#x27;\\}_{k \\in I_\\sigma}</span> in <span class="math">\\pi</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Ver}(\\{\\mathsf{vk}_j\\}, \\mathsf{VK}_C, \\mathsf{L}, \\{x_i\\}_{\\mathsf{L}_i = \\star},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_i\\rangle)<span class="math">: it proceeds as the verification algorithm of Section 4 except that it runs the verification equations (A.1) and (A.2) for every triple </span>(\\pi_{\\mu,j}, \\pi_{\\sigma,j}, \\pi_{\\sigma,j}')$ in the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The completeness of this scheme follows from the same arguments used to argue the completeness of our AD-SNARK. The security of the multi-source AD-SNARK described above holds under the same assumptions used for ADSNARK. The difference in the security proof is that one needs to define more hybrid games as the "bad events" can now occur for either one of the <span class="math">k</span> authentication keys.</p>

    <p class="text-gray-300">As an efficiency remark, note that while the size of the proof <span class="math">\\pi</span> depends on the number <span class="math">k</span> of authentication keys used to sign the statement, in several applications one should think of <span class="math">k</span> as a rather small constant. For instance, one may think of a variation of the pay-as-you-drive insurance application in which there may be <span class="math">k = 2</span> distinct trusted devices acting as data sources, e.g., a GPS collecting geographic data and a car sensor collecting driving information.</p>

    <h2 id="sec-29" class="text-2xl font-bold">A.2 A Zero-Knowledge AD-SNARK with Constant-Time Verification.</h2>

    <p class="text-gray-300">Here we show a variant of the scheme proposed in Section 4 which allows for a verification algorithm whose efficiency does not depend on the number of authenticated values, in an amortized sense. In order to achieve this appealing property, we trade efficiency for usability in making the previous scheme only secretly verifiable.</p>

    <p class="text-gray-300">The Setup algorithm is identical. The remaining algorithms work as follows.</p>

    <p class="text-gray-300">AuthKG(pp): Run <span class="math">(S, \\mathsf{prfpp}) \\leftarrow_{\\mathcal{R}} \\mathsf{F.KG}(1^{\\lambda})</span> to obtain the seed <span class="math">S</span> and the public parameters <span class="math">\\mathsf{prfpp}</span> of a pseudorandom function <span class="math">\\mathsf{F}_S: \\{0,1\\}^* \\to \\mathbb{G}_2</span>. Choose a random value <span class="math">\\kappa \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span>. Compute <span class="math">K = e(\\mathcal{P}_1, \\mathcal{P}_2)^\\kappa \\in \\mathbb{G}_T</span>. Return the secret key <span class="math">\\mathsf{sk} = \\mathsf{vk} = (S, \\kappa)</span>, and the public authentication parameters <span class="math">\\mathsf{pap} = (\\mathsf{pp}, \\mathsf{prfpp}, K)</span>.</p>

    <p class="text-gray-300">Auth(sk, L, x): Let <span class="math">\\mathsf{sk} = (S, \\kappa)</span>. To authenticate a value <span class="math">x \\in \\mathbb{F}</span> with label <span class="math">\\mathsf{L}</span>, use the PRF to compute <span class="math">\\varPhi \\leftarrow \\mathsf{F}_S(\\mathsf{L})</span>, then compute <span class="math">\\sigma = \\varPhi + x \\kappa \\mathcal{P}_2</span> and output <span class="math">\\sigma</span>.</p>

    <p class="text-gray-300">AuthVer(vk, <span class="math">\\sigma, \\mathsf{L}, x</span>): Let <span class="math">\\mathsf{vk} = (S, \\kappa)</span> be the (secret) verification key. To verify that <span class="math">\\sigma</span> is a valid authentication tag for a value <span class="math">x \\in \\mathbb{F}</span> with respect to label <span class="math">\\mathsf{L}</span>, output <span class="math">\\top</span> if <span class="math">\\sigma = \\mathsf{F}_S(\\mathsf{L}) + x \\kappa \\mathcal{P}_2</span> and <span class="math">\\bot</span> otherwise.</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Gen}(\\mathsf{pap},C)</span>: is the same as in Section 4 except that here <span class="math">K_{\\mathsf{a}} = (K)^{z(\\tau)}\\in \\mathbb{G}_T</span>.</p>

    <p class="text-gray-300">Prove(EKC, <span class="math">\\vec{x}</span>, <span class="math">\\vec{w}</span>, <span class="math">\\vec{\\sigma}</span>): is the same as in Section 4 except that here <span class="math">\\pi_{\\mu} = [\\prod_{k\\in I_{\\sigma}}e(A_k,\\varPhi_k)]\\cdot (K_{\\mathsf{a}})^{\\delta_{\\mathsf{a}}^z}\\in \\mathbb{G}_T</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ver}(\\mathsf{vk},\\mathsf{VK}_C,\\mathsf{L},\\{x_i\\}_{\\mathsf{L}_i = \\star},\\pi)</span>: is the same as in Section 4 except for the first verification equation. Let <span class="math">\\mathsf{vk} = (S,\\kappa)</span>.</p>

    <p class="text-gray-300">(A.1) Check the authenticity of <span class="math">\\pi_{\\sigma}</span>, against labels <span class="math">\\mathsf{L}</span> by checking if the following equation is satisfied over <span class="math">\\mathbb{G}_T</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_{\\mu} = \\prod_{k \\in I_{\\sigma}} e \\left(A_{k}, \\mathsf{F}_{S} (\\mathsf{L}_{k})\\right) \\cdot e \\left(\\pi_{\\sigma}, \\kappa \\mathcal{P}_{2}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">How to Achieve Efficient Verification. By assuming a proper labeling of the data and a suitable pseudorandom function <span class="math">\\mathsf{F}</span>, the scheme described above can allow for an improved verification algorithm whose running time does not depend on the number $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{\\sigma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of authenticated values. Following the ideas in [BFR13], we assume that every input </span>x<span class="math"> is authenticated by using a multi-label </span>\\mathsf{L} = (\\varDelta,\\tau)<span class="math">, where </span>\\varDelta<span class="math"> is a data set identifier, and </span>\\tau<span class="math"> is an input identifier. As an example, the input identifiers </span>\\tau_{1},\\ldots \\tau_{n}<span class="math"> can be specific canonical information like date and time (e.g., day 05, 11:12:42), and the data set identifier </span>\\varDelta$ can be more general information describing the category (e.g., "energy consumption for March 2014").</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for the pseudorandom function, we can instantiate <span class="math">\\mathsf{F}_S</span> by using the specific ACF-efficient PRF of [BFR13] <span class="math">\\mathsf{F}_S:\\{0,1\\}^<em>\\times \\{0,1\\}^</em>\\to \\mathbb{G}_2</span> such that: <span class="math">\\mathsf{F}_S(\\varDelta,\\tau)=(a_{\\varDelta}u_{\\tau}+b_{\\varDelta}v_{\\tau})\\mathcal{P}_2</span>, where the values <span class="math">(a_{\\varDelta},b_{\\varDelta})</span> and <span class="math">(u_{\\tau},v_{\\tau})</span> are derived by applying two standard PRFs (each mapping into <span class="math">\\mathbb{F}^2</span>) to <span class="math">\\varDelta</span> and <span class="math">\\tau</span>, respectively. This function is pseudorandom under the Decision Linear assumption [BFR13]. To achieve efficient verification one proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Offline phase: precompute <span class="math">\\omega_{u} = e\\left(\\sum_{k\\in I_{\\sigma}}u_{k}A_{k},\\mathcal{P}_{2}\\right)</span> and <span class="math">\\omega_{v} = e\\left(\\sum_{k\\in I_{\\sigma}}v_{k}A_{k},\\mathcal{P}_{2}\\right)</span> where each <span class="math">(u_{k},v_{k})</span> is derived from <span class="math">\\tau_{k}</span> for all <span class="math">k\\in I_{\\sigma}</span>. Store <span class="math">(\\omega_{u},\\omega_{v})</span>.</li>

      <li>Online phase: given <span class="math">\\Delta</span>, derive <span class="math">(a_{\\Delta}, b_{\\Delta})</span> from <span class="math">\\Delta</span>, and compute <span class="math">\\Omega = (\\omega_u)^{a_\\Delta} \\cdot (\\omega_v)^{b_\\Delta} \\in \\mathbb{G}_T</span>. Finally, use <span class="math">\\Omega</span> to check the verification equation (A.1) described above, i.e., check that <span class="math">\\pi_{\\mu} = \\Omega \\cdot e(\\pi_{\\sigma}, \\kappa \\mathcal{P}_2)</span>.</li>

    </ul>

    <p class="text-gray-300">The correctness of this efficient verification follows from <span class="math">\\Omega = \\left[\\prod_{k\\in I_{\\sigma}}e(A_k,\\mathsf{F}_S(\\varDelta,\\tau_k))\\right]</span>.</p>

    <h2 id="sec-30" class="text-2xl font-bold">B Definition of Zero Knowledge SNARKs</h2>

    <p class="text-gray-300">We recall the definition of SNARKs for arithmetic circuit satisfiability [Mic94, GW11b]. A succinct non-interactive argument (SNARG) for arithmetic circuit satisfiability is a triple of algorithms <span class="math">\\Pi = (\\mathsf{Gen},\\mathsf{Prove},\\mathsf{Ver})</span> working as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given a circuit <span class="math">C</span>, the generation algorithm <span class="math">\\mathsf{Gen}(1^{\\lambda}, C)</span> generates a (public) reference string <span class="math">\\mathsf{EK}_C</span> and a corresponding verification key <span class="math">\\mathsf{VK}_C</span> for <span class="math">C</span>.</li>

      <li>Given statement <span class="math">\\vec{x}</span> and witness <span class="math">\\vec{w}</span> such that <span class="math">C(\\vec{x},\\vec{w}) = 0</span>, the prover produces a proof <span class="math">\\pi \\gets \\mathsf{Prove}(\\mathsf{EK}_C, \\vec{x}, \\vec{w})</span>.</li>

      <li>The verifier runs <span class="math">\\{\\bot, \\top\\} \\gets \\mathsf{Ver}(\\mathsf{VK}_C, \\vec{x}, \\pi)</span> to verify the validity of <span class="math">\\pi</span>.</li>

    </ul>

    <p class="text-gray-300">The following three properties need to be satisfied.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all <span class="math">(\\vec{x},\\vec{w})\\in \\mathcal{R}_C</span>, we have that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\operatorname{Ver} \\left(\\mathrm{VK}_{C}, \\vec{x}, \\pi\\right) = \\bot : \\left(\\mathrm{EK}_{C}, \\mathrm{VK}_{C}\\right) \\leftarrow \\operatorname{Gen} \\left(1^{\\lambda}, C\\right), \\right. \\\\ \\left. \\pi \\leftarrow \\operatorname{Prove} \\left(\\mathrm{EK}_{C}, \\vec{x}, \\vec{w}\\right) \\right] = \\operatorname{negl}(\\lambda) \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. (Adaptive case) For all PPT Prove*, we have</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {V e r} \\left(\\mathrm {V K} _ {C}, \\vec {x}, \\pi\\right) = \\top \\wedge \\vec {x} \\notin \\mathcal {L} _ {C}: \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {E K} _ {C}, \\mathsf {V K} _ {C}\\right) \\leftarrow \\operatorname {G e n} \\left(1 ^ {\\lambda}, C\\right), \\left(\\vec {x}, \\pi\\right) \\leftarrow \\operatorname {P r o v e} ^ {*} \\left(\\mathsf {E K} _ {C}\\right) ] = n e g l (\\lambda)</span></div>

    <p class="text-gray-300">(Non-adaptive case) For all PPT Prove*, and  <span class="math">\\vec{x} \\notin \\mathcal{L}_C</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {V e r} \\left(\\mathrm {V K} _ {C}, \\vec {x}, \\pi\\right) = \\top : \\left(\\mathrm {E K} _ {C}, \\mathrm {V K} _ {C}\\right) \\leftarrow \\operatorname {G e n} \\left(1 ^ {\\lambda}, C\\right), \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi \\leftarrow \\operatorname {P r o v e} ^ {*} \\left(\\mathrm {E K} _ {C}, \\vec {x}\\right) ] = n e g l (\\lambda)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinctness. The length of a proof  <span class="math">\\pi</span>  is given by  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda) \\mathrm{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A SNARG is called adaptive if the prover can choose the statement  <span class="math">\\vec{x}</span>  after seeing the reference string  <span class="math">\\mathsf{EK}_C</span> .</p>

    <p class="text-gray-300">A SNARG of knowledge (SNARK) is a SNARG where soundness is replaced by the following property:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive Proof of Knowledge. For all efficient Prove* there exists a polynomial-size extractor  <span class="math">E</span>  such that for every auxiliary input  <span class="math">aux \\in \\{0,1\\}^{poly(\\lambda)}</span> , and every circuit  <span class="math">C</span>  of polynomial size,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {V e r} \\left(\\mathrm {V K} _ {C}, \\vec {x}, \\pi\\right) = \\top \\wedge (\\vec {x}, \\vec {w}) \\notin \\mathcal {R} _ {C}: \\left(\\mathrm {E K} _ {C}, \\mathrm {V K} _ {C}\\right) \\leftarrow \\operatorname {G e n} \\left(1 ^ {\\lambda}, C\\right), \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\vec {x}, \\pi) \\leftarrow \\operatorname {P r o v e} ^ {*} (a u x, \\mathrm {E K} _ {C}), \\vec {w} \\leftarrow E (a u x, \\mathrm {E K} _ {C}) ] = n e g l (\\lambda)</span></div>

    <h2 id="sec-31" class="text-2xl font-bold">C The PGHR Zero-Knowledge SNARK</h2>

    <p class="text-gray-300">We review a version of the zero-knowledge SNARK scheme of Parno et al. [PGHR13] which was described in the recent work of Ben-Sasson et al. [BSCTV14].</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda})</span>: generate the public parameters consisting of a bilinear group description  <span class="math">\\mathsf{pp} = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, \\mathcal{P}_1, \\mathcal{P}_2) \\gets_{\\mathcal{R}} \\mathcal{G}(1^{\\lambda})</span> . Let  <span class="math">\\mathbb{F}</span>  be the finite field  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{EK}_C,\\mathsf{VK}_C)\\gets \\mathsf{Gen}(\\mathsf{pp},C)</span>  : Let  <span class="math">C:\\mathbb{F}^n\\times \\mathbb{F}^h\\to \\mathbb{F}^l</span>  be an arithmetic circuit.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">Q_{C} = (\\vec{a}, \\vec{b}, \\vec{c}, z) = \\mathsf{QAPInst}(C)</span>  to build a QAP  <span class="math">Q_{C}</span>  of size  <span class="math">m</span>  and degree  <span class="math">d</span>  for  <span class="math">C</span> . Extend  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  with 3 more polynomials each, by setting:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">a _ {m + 1} (X) = b _ {m + 2} (X) = c _ {m + 3} (X) = z (X),</span></div>

    <div class="my-4 text-center"><span class="math-block">a _ {m + 2} (X) = a _ {m + 3} (X) = b _ {m + 1} (X) = b _ {m + 3} (X) = c _ {m + 1} (X) = c _ {m + 2} (X) = 0.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick  <span class="math">\\rho_{\\mathbf{a}}, \\rho_{\\mathbf{b}}, \\tau, \\alpha_{\\mathbf{a}}, \\alpha_{\\mathbf{b}}, \\alpha_{\\mathbf{c}}, \\beta, \\gamma \\gets_{\\mathcal{R}} \\mathbb{F}</span> , set  <span class="math">\\rho_{\\mathbf{c}} = \\rho_{\\mathbf{a}} \\cdot \\rho_{\\mathbf{b}}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">Z = z(\\tau)\\rho_{\\mathbf{c}}\\mathcal{P}_{2}</span> , and  <span class="math">\\forall k\\in \\{0,\\dots,m + 3\\}</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A _ {k} = a _ {k} (\\tau) \\rho_ {\\mathbf {a}} \\mathcal {P} _ {1}, \\quad A _ {k} ^ {\\prime} = \\alpha_ {\\mathbf {a}} a _ {k} (\\tau) \\rho_ {\\mathbf {a}} \\mathcal {P} _ {1},</span></div>

    <div class="my-4 text-center"><span class="math-block">B _ {k} = b _ {k} (\\tau) \\rho_ {\\mathbf {b}} \\mathcal {P} _ {2}, \\quad B _ {k} ^ {\\prime} = \\alpha_ {\\mathbf {b}} b _ {k} (\\tau) \\rho_ {\\mathbf {b}} \\mathcal {P} _ {1},</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {k} = c _ {k} (\\tau) \\rho_ {\\mathbf {c}} \\mathcal {P} _ {1}, \\quad C _ {k} ^ {\\prime} = \\alpha_ {\\mathbf {c}} c _ {k} (\\tau) \\rho_ {\\mathbf {c}} \\mathcal {P} _ {1},</span></div>

    <div class="my-4 text-center"><span class="math-block">E _ {k} = \\beta \\left(a _ {k} (\\tau) \\rho_ {\\mathbf {a}} + b _ {k} (\\tau) \\rho_ {\\mathbf {b}} + c _ {k} (\\tau) \\rho_ {\\mathbf {c}}\\right) \\mathcal {P} _ {1}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the evaluation key <span class="math">\\mathsf{EK}_C</span> and the verification key <span class="math">\\mathsf{VK}_C</span> which are defined as follows:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{EK}_C = \\left(Q_C, \\vec{A}, \\vec{A}&#x27;, \\vec{B}, \\vec{B}&#x27;, \\vec{C}, \\vec{C}&#x27;, \\vec{E}, \\{\\tau^i \\mathcal{P}_1\\}_{i \\in \\{0, \\dots, d\\}}\\right) \\\\ \\mathsf{VK}_C = \\left(\\mathcal{P}_1, \\mathcal{P}_2, \\alpha_{\\mathsf{a}} \\mathcal{P}_2, \\alpha_{\\mathsf{b}} \\mathcal{P}_1, \\alpha_{\\mathsf{c}} \\mathcal{P}_2, \\gamma \\mathcal{P}_2, \\beta \\gamma \\mathcal{P}_1, \\beta \\gamma \\mathcal{P}_2, Z, \\{A_k\\}_{k=0}^n,\\right) \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}(\\mathsf{EK}_C, \\vec{x}, \\vec{w})</span>: given a statement <span class="math">\\vec{x} \\in \\mathbb{F}^n</span> and witness <span class="math">\\vec{w} \\in \\mathbb{F}^h</span>, proceed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\vec{s} = \\mathsf{QAPwit}(C, \\vec{x}, \\vec{w}) \\in \\mathbb{F}^m</span>.</li>

      <li>Randomly sample <span class="math">\\delta_{\\mathsf{a}}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}} \\gets_{\\mathcal{R}} \\mathbb{F}</span>. Also, define the vector <span class="math">\\vec{u} = (1, \\vec{s}, \\delta_{\\mathsf{a}}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}}) \\in \\mathbb{F}^{m+4}</span>.</li>

      <li>Solve the QAP <span class="math">Q_C</span> by computing the coefficients <span class="math">(h_0, \\ldots, h_d) \\in \\mathbb{F}^{d+1}</span> of <span class="math">h \\in \\mathbb{F}[X]</span> such that <span class="math">h(X)z(X) = a(X)b(X) - c(X)</span>, where <span class="math">a, b, c \\in \\mathbb{F}[X]</span> are</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} a(X) = a_0(X) + \\sum_{k \\in [m]} s_k \\cdot a_k(X) + \\delta_{\\mathsf{a}} \\cdot z(x) = \\langle \\vec{u}, \\vec{a} \\rangle \\\\ b(X) = b_0(X) + \\sum_{k \\in [m]} s_k \\cdot b_k(X) + \\delta_{\\mathsf{b}} \\cdot z(x) = \\langle \\vec{u}, \\vec{b} \\rangle \\\\ c(X) = c_0(X) + \\sum_{k \\in [m]} s_k \\cdot c_k(X) + \\delta_{\\mathsf{c}} \\cdot z(x) = \\langle \\vec{u}, \\vec{c} \\rangle \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Compute <span class="math">H = h(\\tau)\\mathcal{P}_1</span> using the values <span class="math">\\tau^i\\mathcal{P}_1</span> in <span class="math">\\mathsf{EK}_C</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use the elements in <span class="math">\\mathsf{EK}_C</span> to compute the following values:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\pi_{mid} = \\langle \\vec{u}, \\vec{A} \\rangle_{I_{mid}} + \\delta_{\\mathsf{a}} A_{m+1}, \\\\ \\pi_{mid}&#x27; = \\langle \\vec{u}, \\vec{A&#x27;} \\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}} A_{m+1}&#x27; \\\\ \\pi_{\\mathsf{b}} = \\langle \\vec{u}, \\vec{B} \\rangle, \\quad \\pi_{\\mathsf{c}} = \\langle \\vec{u}, \\vec{C} \\rangle, \\quad \\pi_E = \\langle \\vec{u}, \\vec{E} \\rangle \\\\ \\pi_{\\mathsf{b}}&#x27; = \\langle \\vec{u}, \\vec{B&#x27;} \\rangle, \\quad \\pi_{\\mathsf{c}}&#x27; = \\langle \\vec{u}, \\vec{C&#x27;} \\rangle. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\pi = (\\pi_{mid}, \\pi_{mid}&#x27;, \\pi_{\\mathsf{b}}, \\pi_{\\mathsf{b}}&#x27;, \\pi_{\\mathsf{c}}, \\pi_{\\mathsf{c}}&#x27;, \\pi_E, H)</span>.</li>

    </ol>

    <p class="text-gray-300">Verify <span class="math">(\\mathsf{VK}_C, \\vec{x}, \\pi)</span>: in order to verify a proof <span class="math">\\pi</span> (as defined above) for statement <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>, first compute <span class="math">A_x = A_0 + \\langle \\vec{x}, \\vec{A} \\rangle_{[1,n]}</span> and then perform the following steps:</p>

    <p class="text-gray-300">(P.1) Check the satisfiability of the QAP:</p>

    <div class="my-4 text-center"><span class="math-block">e(A_\\star + \\pi_{\\sigma} + \\pi_{mid}, \\pi_{\\mathsf{b}}) = e(H, Z) \\cdot e(\\pi_{\\mathsf{c}}, \\mathcal{P}_2)</span></div>

    <p class="text-gray-300">(P.2) Check the validity of knowledge commitments:</p>

    <div class="my-4 text-center"><span class="math-block">e(\\pi_{mid}&#x27;, \\mathcal{P}_2) = e(\\pi_{mid}, \\alpha_{\\mathsf{a}} \\mathcal{P}_2) \\wedge e(\\pi_{\\mathsf{b}}&#x27;, \\mathcal{P}_2) = e(\\alpha_{\\mathsf{b}} \\mathcal{P}_1, \\pi_{\\mathsf{b}}) \\wedge e(\\pi_{\\mathsf{c}}&#x27;, \\mathcal{P}_2) = e(\\pi_{\\mathsf{c}}, \\alpha_{\\mathsf{c}} \\mathcal{P}_2)</span></div>

    <p class="text-gray-300">(P.3) Check that all the QAP linear combinations use the same coefficients:</p>

    <div class="my-4 text-center"><span class="math-block">e(\\pi_E, \\gamma \\mathcal{P}_2) = e(A_\\star + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\beta \\gamma \\mathcal{P}_2) \\cdot e(\\beta \\gamma \\mathcal{P}_1, \\pi_{\\mathsf{b}})</span></div>

    <p class="text-gray-300">If all the checks above are satisfied, then return <span class="math">\\top</span>; otherwise return <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">44</p>`;
---

<BaseLayout title="ADSNARK: Nearly Practical and Privacy-Preserving Proofs on A... (2014/617)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/617
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
