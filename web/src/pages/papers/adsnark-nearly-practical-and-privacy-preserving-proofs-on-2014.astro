---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/617';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'ADSNARK: Nearly Practical and Privacy-Preserving Proofs on Authenticated Data';
const AUTHORS_HTML = 'Michael Backes, Manuel Barbosa, Dario Fiore, Raphael M.  Reischuk';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We study the problem of privacy-preserving proofs on authenticated data, where a party receives data from a trusted source and is requested to prove computations over the data to third parties in a correct and private way, i.e., the third party learns no information on the data but is still assured that the claimed proof is valid. Our work particularly focuses on the challenging requirement that the third party should be able to verify the validity with respect to the specific data authenticated by the source &mdash; even without having access to that source. This problem is motivated by various scenarios emerging from several application areas such as wearable computing, smart metering, or general business-to-business interactions. Furthermore, these applications also demand any meaningful solution to satisfy additional properties related to usability and scalability.
In this paper, we formalize the above three-party model, discuss concrete application scenarios, and then we design, build, and evaluate ADSNARK, a nearly practical system for proving arbitrary computations over authenticated data in a privacy-preserving manner. ADSNARK improves significantly over state-of-the-art solutions for this model. For instance, compared to corresponding solutions based on Pinocchio (Oakland&rsquo;13), ADSNARK achieves up to 25&times; improvement in proof computation time and a 20&times; reduction in prover storage space.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> privacy &middot; zero-knowledge &middot; proof systems</p>
    </section>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Organization</h3>

    <p class="text-gray-300">The paper is organized as follows. In Section 2, we recall common definitions and background information on QAPs. Section 3 presents our definition of AD-SNARKs, the generic construction, and a discussion on the efficiency of encoding signature verification with arithmetic circuits. We describe our ADSNARK scheme in Section 4 together with a theoretical evaluation and comparison to the generic solution. In Section 5, we present our implementation and discuss the experimental results. Section 6 discusses further related work, Section 7 provides the description of more application scenarios, and finally Section 8 concludes the paper. The appendix includes additional background and the discussion of two extensions of AD-SNARKs: handling multiple data sources, and achieving (amortized) constant-time verification.</p>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Background</h2>

    <p class="text-gray-300">In this section, we review the notation and some basic definitions that we will use in our work.</p>

    <p class="text-gray-300"><strong>Notation.</strong> We will denote with  <span class="math">\\lambda \\in \\mathbb{N}</span>  a security parameter. We say that a function  <span class="math">\\epsilon</span>  is negligible if it vanishes faster than the inverse of any polynomial. If not explicitly specified otherwise, negligible functions are negligible with respect to  <span class="math">\\lambda</span> . If S is a set,  <span class="math">x \\leftarrow_{\\mathcal{R}} S</span>  denotes the process of selecting x uniformly at random in S. If A is a probabilistic algorithm,  <span class="math">x \\leftarrow_{\\mathcal{R}} A(\\cdot)</span>  denotes the process of running A on some appropriate input and assigning its output to x. Moreover, for a positive integer n, we denote by [n] the set  <span class="math">\\{1,\\ldots,n\\}</span> . We denote by  <span class="math">\\mathbb{F}</span>  a finite field and  <span class="math">\\mathbb{F}_n</span>  is the field of size n. When n is a prime number, then elements of  <span class="math">\\mathbb{F}_n</span>  are represented as integers modulo n. Elements of  <span class="math">\\mathbb{F}</span>  are typically denoted by greek letters.  <span class="math">\\mathbb{F}[X]</span>  denotes the field of polynomials in one variable X and coefficients in  <span class="math">\\mathbb{F}</span> , while  <span class="math">\\mathbb{F}^{\\leq d}[X]</span>  is the subring of polynomials in  <span class="math">\\mathbb{F}[X]</span>  of degree at most d.</p>

    <p class="text-gray-300">    <img src="_page_8_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 3.</strong> Part (a): A bilinear gate representing the arithmetic function  <span class="math">(7 + 3s_1 - 1s_2) \\cdot (2 + s_2 - 4s_3)</span>  specified by coefficients a and b.</p>

    <p class="text-gray-300">Part (b): A QAP for an arithmetic circuit with 4 input wires, 1 output wire, 3 bilinear gates. The circuit encodes the function  <span class="math">f(s_1, s_2, s_3, s_4) = (4 + 2s_1 + s_2) \\cdot (5 + s_1 + 3s_2) \\cdot (1 + 4s_3 + 3s_4) \\cdot (3 + 2s_4)</span> . The non-zero equations for the QAP polynomials are shown on the right.</p>

    <p class="text-gray-300">Algebraic Tools. Let  <span class="math">\\mathcal{G}(1^{\\lambda})</span>  be an algorithm that, upon input of the security parameter  <span class="math">1^{\\lambda}</span> , outputs the description of (asymmetric) bilinear groups bgpp =  <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, \\mathcal{P}_1, \\mathcal{P}_2)</span>  where  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span>  are groups of the same prime order  <span class="math">p &gt; 2^{\\lambda}</span> ;  <span class="math">\\mathcal{P}_1 \\in \\mathbb{G}_1</span>  and  <span class="math">\\mathcal{P}_2 \\in \\mathbb{G}_2</span>  are the respective generators; and  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is an efficiently computable bilinear map. We call such an algorithm  <span class="math">\\mathcal{G}</span>  a bilinear group generator. Note that  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are additive groups, whereas  <span class="math">\\mathbb{G}_T</span>  is a multiplicative group. In this work we rely on specific computational assumptions in such bilinear groups: the q-DHE [CKS09], the q-BDHE [BBG05], and the q-PKE [Gro10] assumptions.</p>

    <p class="text-gray-300">Arithmetic Circuits and Quadratic Arithmetic Programs. An arithmetic circuit C over a finite field  <span class="math">\\mathbb{F}</span>  consists of addition and multiplication gates and of a set of wires between the gates. The wires carry values over  <span class="math">\\mathbb{F}</span> . As in previous work [BSCTV14], here we consider only arithmetic circuits with bilinear gates: a gate with inputs  <span class="math">\\vec{x} = (x_1, \\ldots, x_k)</span>  is bilinear if its output can be written as inner product  <span class="math">\\langle \\vec{a}, (1, x_1, \\ldots, x_k) \\rangle \\cdot \\langle \\vec{b}, (1, x_1, \\ldots, x_k) \\rangle</span>  for some  <span class="math">\\vec{a}, \\vec{b} \\in \\mathbb{F}^{k+1}</span> . Note that this definition includes addition, multiplication, and constant gates (cf. Fig. 3(a) for an example).</p>

    <p class="text-gray-300">Associated to any arithmetic circuit, we define a satisfaction problem as follows.</p>

    <p class="text-gray-300"><strong>Definition 1 (Arith. Circuit Satisfaction [BSCTV14]).</strong> The circuit satisfaction problem of a circuit  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  with bilinear gates is defined by the relation  <span class="math">\\mathcal{R}_C = \\{(\\vec{x}, \\vec{w}) \\in \\mathbb{F}^n \\times \\mathbb{F}^h : C(\\vec{x}, \\vec{w}) = 0^l\\}</span>  and its language is  <span class="math">\\mathcal{L}_C = \\{\\vec{x} \\in \\mathbb{F}^n : \\exists \\vec{w} \\in \\mathbb{F}^h, C(\\vec{x}, \\vec{w}) = 0^l\\}</span> .</p>

    <p class="text-gray-300">The state-of-the-art SNARK schemes that we build on in this paper directly operate on a different model to represent computations called <em>quadratic arithmetic programs</em> (QAPs).</p>

    <p class="text-gray-300"><strong>Definition 2 (QAP [GGPR13]).</strong> A quadratic arithmetic program Q of size m and degree d over  <span class="math">\\mathbb{F}</span>  consists of three vectors of m+1 polynomials  <span class="math">\\overrightarrow{a}</span> ,  <span class="math">\\overrightarrow{b}</span> ,  <span class="math">\\overrightarrow{c} \\in \\mathbb{F}^{\\leq d-1}[X]</span>  of degree at most d-1, and a target polynomial  <span class="math">z(X) \\in \\mathbb{F}[X]</span>  of degree exactly d.</p>

    <p class="text-gray-300">Associated to any QAP, there is a satisfaction problem defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 3 (QAP Satisfaction).</strong> The satisfaction problem of a QAP  <span class="math">Q = (\\vec{a}, \\vec{b}, \\vec{c}, z)</span>  of size m and degree d is the relation  <span class="math">\\mathcal{R}_Q</span>  of pairs  <span class="math">(\\vec{x}, \\vec{s})</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span> ,  <span class="math">\\vec{s} \\in \\mathbb{F}^m</span>  for some  <span class="math">n \\leq m</span> ;</li>
      <li>(2)  <span class="math">x_i = s_i \\text{ for } i \\in [n], i.e., \\vec{s} \\text{ extends } \\vec{x};</span></li>
      <li>(3) z(X) divides the polynomial p(X) defined as</li>
    </ul>

    <p class="text-gray-300"><span class="math">$p(X) = (a_0(X) + \\sum_{i=1}^{m} s_i a_i(X)) \\cdot (b_0(X) + \\sum_{i=1}^{m} s_i b_i(X))</span>$
<span class="math">$- (c_0(X) + \\sum_{i=1}^{m} s_i c_i(X))</span>$</p>

    <p class="text-gray-300">The following result implies that one can use any QAP-based SNARK scheme as an efficient SNARK scheme taking computations more conveniently represented as arithmetic circuits.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> (Constructing QAPs [GGPR13, BSCTV14]). There exist two polynomial time algorithms QAPInst and QAPwit such that, for any circuit  <span class="math">C : \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  with u wires and v (bilinear) gates,  <span class="math">Q_C = (\\vec{a}, \\vec{b}, \\vec{c}, z) = \\mathsf{QAPInst}(C)</span>  is a QAP of size m and degree d over  <span class="math">\\mathbb{F}</span>  satisfying the following properties:</p>

    <p class="text-gray-300">Efficiency: m = u, and d = v + l + 1.</p>

    <p class="text-gray-300">Completeness: For any  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span> , if it holds that  <span class="math">\\vec{s} = \\mathsf{QAPwit}(C, \\vec{x}, \\vec{w})</span>  then  <span class="math">(\\vec{x}, \\vec{s}) \\in \\mathcal{R}_{Q_C}</span> . Proof of Knowledge: For any  <span class="math">(\\vec{x}, \\vec{s}) \\in \\mathcal{R}_{Q_C}</span> , it holds  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span>  where  <span class="math">\\vec{w}</span>  is a prefix of  <span class="math">\\vec{s}</span> . Non-Degeneracy: the polynomials  <span class="math">a_0(X), \\ldots, a_n(X)</span>  are all nonzero and distinct.</p>

    <p class="text-gray-300">The very basic intuition for building a QAP according to Lemma 1 is to encode the inputoutput correctness for each bilinear gate in the polynomials  <span class="math">\\vec{a}</span> ,  <span class="math">\\vec{b}</span> ,  <span class="math">\\vec{c}</span> , z (see Fig. 3(b) for a simple example). Slightly more in detail, for a gate g this is done by first selecting an arbitrary value  <span class="math">r_g \\in \\mathbb{F}</span>  (a &quot;root&quot;) and then, for every left wire i going to gate g, one imposes  <span class="math">a_i(r_g) = c</span> , where c is the coefficient which multiplies the value of wire i in g's left input (note that c=0 if wire i is not a left input). A similar process is done for polynomials  <span class="math">b_i</span>  and  <span class="math">c_i</span>  w.r.t. right input and output wires respectively. Once this procedure has been iterated for every bilinear gate g (selecting distinct roots  <span class="math">r_q</span> ), one will have essentially obtained three tables of size  <span class="math">u \\cdot v</span>  with entries  <span class="math">a_i(r_i)</span> ,  <span class="math">b_i(r_i)</span> , and  <span class="math">c_i(r_i)</span> , respectively, where i=0 to u are all the wires (where the 0 wire represents constants) and j=1 to v are all the bilinear gates. The final QAP polynomials  <span class="math">\\vec{a}</span> ,  <span class="math">\\vec{b}</span> ,  <span class="math">\\vec{c}</span>  are built by extending each row i of the table into a polynomial  <span class="math">a_i(X)</span>  (resp.  <span class="math">b_i(X), c_i(X)</span> ) of degree v-1 via interpolation in  <span class="math">\\mathbb{F}</span> . The target polynomial z(X) is the degree-v polynomial defined over the roots  <span class="math">r_g</span>  of the v bilinear gates:  <span class="math">z(X) := \\prod_{g=1}^{v} (X - r_g)</span> . To see why the satisfiability of the QAP implies the satisfiability of the circuit, the key observation is that the third condition of Definition 3, i.e.,  <span class="math">z(X) \\mid p(X)</span> , means that  <span class="math">\\langle (1, \\vec{s}), \\vec{a}(r_g) \\rangle \\cdot \\langle (1, \\vec{s}), \\vec{b}(r_g) \\rangle = \\langle (1, \\vec{s}), \\vec{c}(r_g) \\rangle</span>  for all roots  <span class="math">r_g</span>  of the target polynomial z(X). In other words, given the specific construction of the polynomials, the input-output correctness of every bilinear gate g of the circuit is satisfied.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup> The case of  <span class="math">c_i</span>  is slightly different as coefficients are only 0 or 1.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup> More precisely, in construction of Lemma 1 one needs to add one &quot;artificial&quot; bilinear gate for every output wire, plus an additional constraint to guarantee non-degeneracy: from which the final degree is d = v + l + 1.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Zero-Knowledge SNARKs over Authenticated Data</h2>

    <p class="text-gray-300">In this section, we define the notion of SNARKs [Mic94, BCCT12] on authenticated data (AD-SNARKs, for short). Let  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  be an arithmetic circuit, and let  <span class="math">\\mathcal{R}_C = \\{(\\vec{x}, \\vec{w})\\} \\subseteq \\mathbb{F}^n \\times \\mathbb{F}^h</span>  be the corresponding circuit satisfaction relation, where  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  is called the <em>statement</em>, and  <span class="math">\\vec{w} \\in \\mathbb{F}^h</span>  is the <em>witness</em>.</p>

    <p class="text-gray-300">Proof systems for the circuit satisfaction of C typically consider the problem in which a prover  <span class="math">\\mathcal{P}</span>  tries to convince a verifier  <span class="math">\\mathcal{V}</span>  about the existence of a witness  <span class="math">\\overrightarrow{w}</span>  such that  <span class="math">(\\overrightarrow{x}, \\overrightarrow{w}) \\in \\mathcal{R}_C</span> . In this scenario, the statement  <span class="math">\\overrightarrow{x}</span>  is supposed to be public, i.e., it is known to both the prover and the verifier. For example,  <span class="math">\\mathcal{V}</span>  could be convinced by  <span class="math">\\mathcal{P}</span>  that 3 colors are sufficient to color a public graph  <span class="math">\\overrightarrow{x}</span>  such that no two adjacent vertices are assigned the same color. The coloring serves as witness  <span class="math">\\overrightarrow{w}</span> .</p>

    <p class="text-gray-300">In this work, we consider a variation of the above problem in setting in which (1) the statement  <span class="math">\\vec{x}</span>  (or part of it) is provided to the prover by a trusted source  <span class="math">\\mathcal{S}</span> , and (2) the portion of  <span class="math">\\vec{x}</span>  provided by  <span class="math">\\mathcal{S}</span>  is not known to  <span class="math">\\mathcal{V}</span>  (see Figure 1 for illustration). Yet,  <span class="math">\\mathcal{V}</span>  wants to be convinced by  <span class="math">\\mathcal{P}</span>  that  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span>  holds for the specific  <span class="math">\\vec{x}</span>  provided by  <span class="math">\\mathcal{S}</span> , and not for some other  <span class="math">\\vec{x}&#x27;</span>  of  <span class="math">\\mathcal{P}</span> 's choice (which can still be in the language  <span class="math">\\mathcal{L}_C</span> ). For example,  <span class="math">\\mathcal{S}</span>  might have provided a graph  <span class="math">\\vec{x}</span>  &ndash; not known to  <span class="math">\\mathcal{V}</span>  &ndash; for which  <span class="math">\\mathcal{P}</span>  proves to  <span class="math">\\mathcal{V}</span>  that  <span class="math">\\vec{x}</span>  is 3-colorable. A proof for any other graph  <span class="math">\\vec{x}&#x27;</span>  is meaningless.</p>

    <p class="text-gray-300">To formalize the idea that  <span class="math">\\mathcal{V}</span>  checks that some values unknown to  <span class="math">\\mathcal{V}</span>  have been authenticated by  <span class="math">\\mathcal{S}</span> , we adopt the concept of <em>labeling</em> used for homomorphic authenticators [GW13, BFR13]. Namely, we assume that the source  <span class="math">\\mathcal{S}</span>  authenticates a set of values  <span class="math">X_{auth} = \\{x_i, \\ldots, x_\\ell\\}</span>  against a set of (public) labels  <span class="math">\\mathsf{L} = \\{\\mathsf{L}_i, \\ldots, \\mathsf{L}_\\ell\\}</span>  by using a secret authentication key (e.g., a signing key).  <span class="math">\\mathcal{S}</span>  then sends the authenticated  <span class="math">X_{auth}</span>  to  <span class="math">\\mathcal{P}</span> . Later,  <span class="math">\\mathcal{P}</span> 's goal is to prove to  <span class="math">\\mathcal{V}</span>  that  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span>  for a statement  <span class="math">\\vec{x}</span>  in which some positions have been correctly authenticated by  <span class="math">\\mathcal{S}</span> , i.e.,  <span class="math">x_i \\in X_{auth}</span>  for some  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">For such a proof system, we define the usual properties of <em>completeness</em> and <em>soundness</em>, and in addition, to model privacy, we define a <em>zero-knowledge</em> property. Moreover, since we are interested in efficient and scalable protocols, we define <em>succinctness</em> to model that the size of the proofs (and implicitly the verifier's running time) should be independent of the witness' size  <span class="math">h = |\\vec{w}|</span> . Finally, we consider AD-SNARKs that can have either public or secret verifiability, the difference being in whether the adversary knows or not the verification key for the authentication tags produced by the data source  <span class="math">\\mathcal{S}</span> .</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 SNARKs over Authenticated Data</h3>

    <p class="text-gray-300">First, we provide the formal definition for SNARGs over authenticated data. The definition of SNARGs of knowledge (i.e., SNARKs) over authenticated data is provided later.</p>

    <p class="text-gray-300"><strong>Definition 4 (AD-SNARG).</strong> A scheme for Succinct Non-interactive Arguments over Authenticated Data (AD-SNARG, for short) for arithmetic circuit satisfiability consists of a tuple of algorithms (Setup, AuthKG, Auth, AuthVer, Gen, Prove, Ver) satisfying authentication correctness, completeness, succinctness, and adaptive soundness (as defined below):</p>

    <p class="text-gray-300">Setup( <span class="math">1^{\\lambda}</span> ): On input the security parameter  <span class="math">\\lambda</span> , output some common public parameters pp. The parameters also define the finite field  <span class="math">\\mathbb{F}</span>  over which the circuits will be defined.</p>

    <p class="text-gray-300">AuthKG(pp): given the public parameters pp, the key generation algorithm outputs a secret authentication key sk, a verification key vk, and public authentication parameters pap.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Auth(sk, L, x): the authentication algorithm takes as input the secret authentication key sk, a label  <span class="math">L \\in \\mathcal{L}</span> , and a value  <span class="math">x \\in \\mathbb{F}</span> , and it outputs an authentication tag  <span class="math">\\sigma</span> .</li>
      <li>AuthVer(vk,  <span class="math">\\sigma</span> , L, x): the authentication verification algorithm takes as input a verification key vk, a tag  <span class="math">\\sigma</span> , a label L  <span class="math">\\in \\mathcal{L}</span> , and a value  <span class="math">x \\in \\mathbb{F}</span> . It outputs  <span class="math">\\bot</span>  (reject) or  <span class="math">\\top</span>  (accept).</li>
      <li>Gen(pap, C): given the public authentication parameters pap and an arithmetic circuit  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span> , the algorithm outputs an evaluation key  <span class="math">\\mathsf{EK}_C</span>  and a verification key  <span class="math">\\mathsf{VK}_C</span> . Gen can hence be seen as a circuit encoding algorithm.</li>
      <li>Prove( <span class="math">\\mathsf{EK}_C, \\vec{x}, \\vec{w}, \\vec{\\sigma}</span> ): on input an evaluation key  <span class="math">\\mathsf{EK}_C</span> , a statement  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span> , a witness  <span class="math">\\vec{w} \\in \\mathbb{F}^h</span> , and authentication tags for the statement  <span class="math">\\vec{\\sigma} = (\\sigma_1, \\ldots, \\sigma_n)</span> , the proof algorithm outputs a proof of membership  <span class="math">\\pi</span>  for  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span> . We stress that  <span class="math">\\vec{\\sigma}</span>  does not need to contain authentication tags for all positions: in case a value at position i is not authenticated, the empty tag  <span class="math">\\sigma_i = \\star</span>  is used instead.</li>
      <li><span class="math">\\mathsf{Ver}(\\mathsf{vk},\\mathsf{VK}_C, \\overrightarrow{\\mathsf{L}}, \\{x_i\\}_{\\mathsf{L}_i=\\star}, \\pi)</span> : given the verification key  <span class="math">\\mathsf{vk}</span> , a circuit verification key  <span class="math">\\mathsf{VK}_C</span> , labels  <span class="math">\\overrightarrow{\\mathsf{L}} = (\\mathsf{L}_1, \\ldots, \\mathsf{L}_n)</span>  for the statement, unauthenticated statement components  <span class="math">x_i</span> , and a proof  <span class="math">\\pi</span> , the verification algorithm outputs  <span class="math">\\bot</span>  (reject) or  <span class="math">\\top</span>  (accept).</li>
    </ul>

    <p class="text-gray-300">AUTHENTICATION CORRECTNESS. Intuitively, an AD-SNARG scheme has authentication correctness if any tag  <span class="math">\\sigma</span>  generated by Auth(sk, L, x) authenticates x with respect to L. More formally, we say that a AD-SNARG scheme satisfies authentication correctness if for any value  <span class="math">x \\in \\mathbb{F}</span> , all keys (sk, vk, pap)  <span class="math">\\leftarrow_{\\mathcal{R}}</span>  AuthKG(1 <span class="math">^{\\lambda}</span> ), any label L  <span class="math">\\in \\mathcal{L}</span> , and any authentication tag  <span class="math">\\sigma \\leftarrow_{\\mathcal{R}}</span>  Auth(sk, L, x), we have that AuthVer(vk,  <span class="math">\\sigma</span> , L, x) =  <span class="math">\\top</span>  with probability 1.</p>

    <p class="text-gray-300">COMPLETENESS. This property aims at capturing that if the Prove algorithm produces  <span class="math">\\pi</span>  when run on  <span class="math">(\\overrightarrow{x}, \\overrightarrow{w}, \\overrightarrow{\\sigma})</span>  for some  <span class="math">(\\overrightarrow{x}, \\overrightarrow{w}) \\in \\mathcal{R}_C</span> , then verification  <span class="math">\\mathsf{Ver}(\\mathsf{vk}, \\mathsf{VK}_C, \\mathsf{L}, \\{x_i\\}_{\\mathsf{L}_i = \\star}, \\pi)</span>  must output  <span class="math">\\top</span>  with probability 1 whenever  <span class="math">\\mathsf{AuthVer}(\\mathsf{vk}, \\sigma_i, \\mathsf{L}_i, x_i) = \\top</span> . More formally, let us fix  <span class="math">(\\mathsf{sk}, \\mathsf{vk}, \\mathsf{pap}) \\leftarrow_{\\mathcal{R}} \\mathsf{AuthKG}(\\mathsf{pp})</span> , and a circuit  <span class="math">C : \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  with keys  <span class="math">(\\mathsf{EK}_C, \\mathsf{VK}_C) \\leftarrow_{\\mathcal{R}} \\mathsf{Gen}(\\mathsf{pap}, C)</span> . Let  <span class="math">(\\overrightarrow{x}, \\overrightarrow{w}) \\in \\mathcal{R}_C</span>  be given. Let  <span class="math">\\overrightarrow{\\mathsf{L}} = (\\mathsf{L}_1, \\dots, \\mathsf{L}_n) \\in (\\mathcal{L} \\cup \\{\\star\\})^n</span>  be a vector of labels, and let  <span class="math">\\overrightarrow{\\sigma} = (\\sigma_1, \\dots, \\sigma_n)</span>  be tags for the statement such that  <span class="math">\\{\\mathsf{AuthVer}(\\mathsf{vk}, \\sigma_i, \\mathsf{L}_i, x_i) = \\top\\}_{\\mathsf{L}_i \\neq \\star}</span> . Then if  <span class="math">\\pi \\leftarrow_{\\mathcal{R}} \\mathsf{Prove}(\\mathsf{EK}_C, \\overrightarrow{x}, \\overrightarrow{w}, \\overrightarrow{\\sigma})</span> , we have that  <span class="math">\\mathsf{Ver}(\\mathsf{vk}, \\mathsf{VK}_C, \\overrightarrow{\\mathsf{L}}, \\{x_i\\}_{\\mathsf{L}_i = \\star}, \\pi) = \\top</span>  with probability 1.</p>

    <p class="text-gray-300">SUCCINCTNESS. Given a circuit  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span> , the length of the proof  <span class="math">\\pi</span>  is bounded by  <span class="math">|\\pi| = \\text{poly}(\\lambda)\\text{polylog}(n, h)</span> .</p>

    <p class="text-gray-300">ADAPTIVE SOUNDNESS. Intuitively, the soundness property captures that no malicious party can produce proofs that verify correctly for a statement which is not in the language. We formalize our definition via an experiment, called  <span class="math">\\mathbf{Exp}_{\\mathcal{A}}^{\\mathsf{AD-Soundness}}</span> , which is described in Figure 4. The experiment is parametrized by an adversary  <span class="math">\\mathcal{A}</span>  who is given access to three oracles (aka procedures)  <span class="math">\\mathbf{Gen}</span> ,  <span class="math">\\mathbf{Auth}</span> , and  <span class="math">\\mathbf{Ver}</span>  that can be (concurrently) run.</p>

    <p class="text-gray-300">The three procedures <strong>Gen</strong>, <strong>Auth</strong>, and <strong>Ver</strong> essentially give to the adversary oracle access to the algorithms <strong>Gen</strong>, <strong>Auth</strong>, and <strong>Ver</strong>, respectively, with some additional bookkeeping information. In particular, it is worth noting that <strong>Ver</strong> returns the output of <strong>Ver</strong>, and additionally, checks whether a proof accepted by <strong>Ver</strong> (i.e.,  <span class="math">v = \\top</span> ) proves a false statement according to  <span class="math">\\mathcal{R}_C</span> . In this case, <strong>Ver</strong> sets <strong>GameOutput</strong>  <span class="math">\\leftarrow</span>  1.</p>

    <p class="text-gray-300">More formally, let  <span class="math">\\mathcal{C}</span>  be a class of circuits. Then for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , we define the advantage of an adversary  <span class="math">\\mathcal{A}</span>  in the experiment  <span class="math">\\mathbf{Exp}_{\\mathcal{A}}^{\\mathsf{AD-Soundness}}(\\mathcal{C}, 1^{\\lambda})</span>  against  <span class="math">\\mathsf{AD-Soundness}</span>  for  <span class="math">\\mathcal{C}</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathsf{AD-Soundness}}_{\\mathcal{A}}(\\mathcal{C},\\lambda) \\ = \\ \\Pr[\\mathbf{Exp}^{\\mathsf{AD-Soundness}}_{\\mathcal{A}}(\\mathcal{C},1^{\\lambda}) = 1].</span>$</p>

    <pre><code class="language-text">\\mathbf{Exp}_{\\mathcal{A},E}^{\\mathsf{AD-Soundness}}(1^{\\lambda}):
                                                                                      procedure Ver(C, \\overrightarrow{L}, \\{x_i\\}_{L_i=\\star}, \\pi)
                                                                                      if (C,\\cdot,\\cdot) \\notin \\mathsf{S} then Return \\perp
\\mathsf{pp} \\leftarrow_{\\mathcal{R}} \\mathsf{Set}\\overline{\\mathsf{up}(1^{\\lambda})}
                                                                                      fetch \\mathsf{VK}_C with (C,\\cdot,\\mathsf{VK}_C)\\in\\mathsf{S}
(sk, vk, pap) \\leftarrow_{\\mathcal{R}} AuthKG(pp)
                                                                                      v \\leftarrow \\mathsf{Ver}(\\mathsf{vk}, \\mathsf{VK}_C, \\overrightarrow{\\mathsf{L}}, \\{x_i\\}_{\\mathsf{L}_i = \\star}, \\pi)
\\texttt{GameOutput} \\leftarrow 0
S \\leftarrow \\emptyset, \\ \\bar{T} \\leftarrow \\{(\\star, \\star)\\}
                                                                                      if v = \\top then
\\mathcal{A}^{\\mathbf{Gen},\\mathbf{Auth},\\mathbf{Ver}}(\\mathsf{pp},\\mathsf{pap})
                                                                                         if \\exists \\, \\mathsf{L}_i \\in \\overrightarrow{\\mathsf{L}} : (\\mathsf{L}_i, \\cdot, \\cdot) \\notin \\mathsf{T} then
Return GameOutput
                                                                                           \\texttt{GameOutput} \\leftarrow 1 \\quad // \\ \\textit{Type 1}
procedure Gen(C)
                                                                                           fetch \\vec{x} = (x_1, \\dots, x_n)
(\\mathsf{EK}_C, \\mathsf{VK}_C) \\leftarrow_{\\mathcal{R}} \\mathsf{Gen}(\\mathsf{pap}, C)
                                                                                            with \\{(\\mathsf{L}_1,x_1,\\cdot),\\ldots,(\\mathsf{L}_n,x_n,\\cdot)\\}\\subseteq\\mathsf{T}
S \\leftarrow S \\cup \\{(C, \\mathsf{EK}_C, \\mathsf{VK}_C)\\}
                                                                                            for all L_i \\neq \\star
Return (\\mathsf{EK}_C, \\mathsf{VK}_C)
                                                                                           if \\overrightarrow{x} \\notin \\mathcal{L}_C then
procedure Auth(L, x)
                                                                                            \\texttt{GameOutput} \\leftarrow 1 \\quad // \\ \\textit{Type 2}
if (\\mathsf{L},\\cdot,\\cdot)\\in T Return \\perp
                                                                                      \\mathtt{Return}\\ v
\\sigma \\leftarrow_{\\mathcal{R}} \\mathsf{Auth}(\\mathsf{sk},\\mathsf{L},x)
\\mathsf{T} \\leftarrow \\mathsf{T} \\cup \\{(\\mathsf{L}, x, \\sigma)\\}\\
Return \\sigma
</code></pre>

    <p class="text-gray-300">Figure 4. Game AD-Soundness.</p>

    <p class="text-gray-300">An AD-SNARK with respect to a class of circuits  <span class="math">\\mathcal{C}</span>  is adaptive computationally sound if for any PPT  <span class="math">\\mathcal{A}</span> , it holds that  <span class="math">\\mathbf{Adv}_{\\mathcal{A}}^{\\mathsf{AD-Soundness}}(\\mathcal{C},\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Our soundness definition is inspired by the security definition for homomorphic MACs [GW13, CF13, BFR13]. The catch here is that there are essentially two ways to create a &quot;cheating proof&quot;, and thus to break the soundness of an AD-SNARG. The first way, Type 1, is to produce an accepting proof without having ever queried an authentication tag for a label  <span class="math">L_i</span> . This basically captures that, in order to create a valid proof, one needs to have all authenticated parts of the statement, each with a valid authentication tag. The second way to break the security, Type 2, is the more &quot;classical&quot; one, i.e., generating a proof that accepts for a tuple  <span class="math">(\\vec{x}, \\vec{w})</span>  which is not the correct one, i.e.,  <span class="math">\\vec{x} \\notin \\mathcal{L}_C</span> .</p>

    <p class="text-gray-300">Second, we note that the above game definition captures the setting in which the verification key vk is kept secret. The definition for the publicly verifiable setting is obtained by providing vk to the adversary.</p>

    <p class="text-gray-300"><strong>AD-SNARKs.</strong> An AD-SNARG of knowledge (AD-SNARK) is an AD-SNARG where adaptive soundness is strengthened as follows.</p>

    <p class="text-gray-300"><strong>Definition 5 (AD-SNARK).</strong> A tuple of algorithms (Setup, AuthKG, Auth, AuthVer, Gen, Prove, Ver) is an AD-SNARK if it is an AD-SNARG where adaptive soundness is replaced by the stronger property of adaptive proof of knowledge (as defined below).</p>

    <p class="text-gray-300">ADAPTIVE PROOF OF KNOWLEDGE. Consider a variation of the adaptive soundness experiment that is parametrized by an additional algorithm E called the <em>extractor</em>. Both  <span class="math">\\mathcal{A}</span>  and E run on exactly the same input and random tape, including some auxiliary input z. E is an algorithm that, for every verification query of  <span class="math">\\mathcal{A}</span>  that is accepted by the Ver algorithm, outputs a witness  <span class="math">\\overrightarrow{w}</span> . One should think of such E as  <span class="math">\\mathcal{A}</span>  itself, and the extraction capability intuitively means that if  <span class="math">\\mathcal{A}</span>  is able to produce an accepting proof, then  <span class="math">\\mathcal{A}</span>  must know the corresponding witness, and thus such witness can be extracted from  <span class="math">\\mathcal{A}</span> 's memory. A detailed description of the experiment procedures is presented in Figure 5.</p>

    <pre><code class="language-text">procedure Ver(C, \\overrightarrow{L}, \\{x_i\\}_{L_i=\\star}, \\pi)
\\mathbf{Exp}^{\\mathsf{AD}\\text{-PoK}}_{\\mathcal{A},E}(1^{\\lambda}):
                                                                                                 if (C,\\cdot,\\cdot) \\notin \\mathsf{S} then Return \\perp
\\mathsf{pp} \\leftarrow_{\\mathcal{R}} \\mathsf{Setup}(1^{\\lambda})
                                                                                                 fetch \\mathsf{VK}_C with (C,\\cdot,\\mathsf{VK}_C)\\in\\mathsf{S}
(\\mathsf{sk}, \\mathsf{vk}, \\mathsf{pap}) \\leftarrow_{\\mathcal{R}} \\mathsf{AuthKG}(\\mathsf{pp})
                                                                                                 v \\leftarrow \\mathsf{Ver}(\\mathsf{vk}, \\mathsf{VK}_C, \\overrightarrow{\\mathsf{L}}, \\{x_i\\}_{\\mathsf{L}_i = \\star}, \\pi)
GameOutput \\leftarrow 0
 \\begin{array}{l} \\mathsf{S} \\leftarrow \\emptyset, \\ \\ \\mathsf{\\bar{T}} \\leftarrow \\{(\\star, \\star)\\} \\\\ \\mathcal{A}^{\\mathbf{Gen}, \\mathbf{Auth}, \\mathbf{Ver}}(\\mathsf{pp}, \\mathsf{pap}, z) \\end{array}
                                                                                                 if v = \\top then
                                                                                                    if \\exists \\, \\mathsf{L}_i \\in \\vec{\\mathsf{L}} : (\\mathsf{L}_i, \\cdot, \\cdot) \\notin \\mathsf{T} then
                                                                                                      \\texttt{GameOutput} \\leftarrow 1 \\quad // \\ \\textit{Type 1}
Return GameOutput
procedure Gen(C)
                                                                                                      fetch \\overrightarrow{x} = (x_1, \\dots, x_n)
(\\mathsf{EK}_C, \\mathsf{VK}_C) \\leftarrow_{\\mathcal{R}} \\mathsf{Gen}(\\mathsf{pap}, C)
                                                                                                       with \\{(\\mathsf{L}_1,x_1,\\cdot),\\ldots,(\\mathsf{L}_n,x_n,\\cdot)\\}\\subseteq\\mathsf{T}
S \\leftarrow S \\cup \\{(C, \\mathsf{EK}_C, \\mathsf{VK}_C)\\}
                                                                                                       for all L_i \\neq \\star
Return (\\mathsf{EK}_C, \\mathsf{VK}_C)
                                                                                                       \\overrightarrow{w} \\leftarrow E(\\mathsf{pp}, \\mathsf{pap}, z, \\mathsf{T}, \\mathsf{S}, \\mathsf{Coins}[\\mathcal{A}])
procedure Auth(L, x)
                                                                                                       if (\\vec{x}, \\vec{w}) \\notin \\mathcal{R}_C then
\\mathtt{if}\\ (\\mathsf{L},\\overline{\\cdot,\\cdot)} \\,\\overline{\\in T\\ \\mathtt{Return}\\ \\bot}
                                                                                                        \\texttt{GameOutput} \\leftarrow 1 \\quad // \\ \\textit{Type 2}
                                                                                                \\mathtt{Return}\\ v
\\sigma \\leftarrow_{\\mathcal{R}} \\mathsf{Auth}(\\mathsf{sk},\\mathsf{L},x)
\\mathsf{T} \\leftarrow \\mathsf{T} \\cup \\{(\\mathsf{L}, x, \\sigma)\\}\\
Return \\sigma
</code></pre>

    <p class="text-gray-300">Figure 5. Experiment for the adaptive proof of knowledge definition.</p>

    <p class="text-gray-300">Then we say that a scheme ADSNARK satisfies adaptive proof of knowledge for  <span class="math">\\mathcal{C}</span>  if for any sufficiently large  <span class="math">\\lambda \\in \\mathbb{N}</span> , and for every PPT adversary  <span class="math">\\mathcal{A}</span> , there exists a PPT extractor E such that for every polynomial-size auxiliary input  <span class="math">z \\in \\{0,1\\}^{\\mathsf{poly}(\\lambda)}</span>  the probability  <span class="math">\\Pr[\\mathbf{Exp}_{\\mathcal{A},E}^{\\mathsf{AD-PoK}}(\\mathcal{C},\\lambda,z)=1]</span>  is negligible.</p>

    <p class="text-gray-300"><strong>Zero-Knowledge AD-SNARKs.</strong> Finally we extend the AD-SNARK definition with the zero-knowledge property. Loosely speaking, a zero-knowledge AD-SNARK is an AD-SNARK in which the Prove algorithm generates proofs  <span class="math">\\pi</span>  that reveal no information: neither about the witness, nor about the authenticated statements. In other words, the proofs do not reveal anything beyond what is known by the verifiers when checking a proof. A formal definition follows.</p>

    <p class="text-gray-300"><strong>Definition 6 (Zero-Knowledge AD-SNARKs).</strong> A zero-knowledge AD-SNARK is an AD-SNARK that satisfies the following additional property &quot;Zero-Knowledge&quot;. Let  <span class="math">C \\in \\mathcal{C}</span>  be an arithmetic circuit. Then there exists a simulator  <span class="math">\\mathsf{Sim} = (\\mathsf{Sim}_1, \\mathsf{Sim}_2)</span> , such that for all PPT distinguishers  <span class="math">\\mathcal{D}</span> , the following difference is negligible</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathbf{Exp}_{Real}^{\\mathcal{D},C}(1^{\\lambda}) = 1] - \\Pr[\\mathbf{Exp}_{Sim}^{\\mathcal{D},C}(1^{\\lambda}) = 1]|</span>$</p>

    <p class="text-gray-300">where the experiments Real and Sim are defined as follows:</p>

    <pre><code class="language-text">\\mathbf{Exp}^{\\mathsf{Real}}_{\\mathcal{D},C}(1^{\\lambda}):
                                                                                                                                                              \\mathbf{Exp}_{\\mathcal{D},C}^{\\mathsf{Sim}}(1^{\\lambda}):
pp \\leftarrow_{\\mathcal{R}} \\mathsf{Setup}(1^{\\lambda})
                                                                                                                                                              pp \\leftarrow_{\\mathcal{R}} \\mathsf{Setup}(1^{\\lambda})
 (\\mathsf{sk}, \\mathsf{vk}, \\mathsf{pap}) \\leftarrow_{\\mathcal{R}} \\mathcal{D}(1^{\\lambda}, \\mathsf{pp})
                                                                                                                                                              (\\mathsf{sk}, \\mathsf{vk}, \\mathsf{pap}) \\leftarrow_{\\mathcal{R}} \\mathcal{D}(1^{\\lambda}, \\mathsf{pp})
 (\\mathsf{EK}_C, \\mathsf{VK}_C) \\leftarrow_{\\mathcal{R}} \\mathsf{Gen}(\\mathsf{pap}, C)
                                                                                                                                                              (\\mathsf{EK}_C, \\mathsf{VK}_C, \\mathsf{td})
                                                                                                                                                                                    \\leftarrow_{\\mathcal{R}} \\mathsf{Sim}_1(\\mathsf{sk},\\mathsf{vk},\\mathsf{pp},\\mathsf{pap},C)
(\\vec{x}, \\vec{\\mathsf{L}}, \\vec{\\sigma}, \\vec{w}) \\leftarrow \\mathcal{D}(\\mathsf{EK}_C, \\mathsf{VK}_C)
                                                                                                                                                              (\\vec{x}, \\vec{\\mathsf{L}}, \\vec{\\sigma}, \\vec{w}) \\leftarrow \\mathcal{D}(\\mathsf{EK}_C, \\mathsf{VK}_C)
\\pi \\leftarrow_{\\mathcal{R}} \\mathsf{Prove}(\\mathsf{EK}_C, \\vec{x}, \\vec{w}, \\vec{\\sigma})
                                                                                                                                                             \\pi \\leftarrow_{\\mathcal{R}} \\mathsf{Sim}_2(\\mathsf{td},\\mathsf{L},\\{x_i\\}_{\\mathsf{L}_i=\\star})
if (\\overrightarrow{x},\\overrightarrow{w}) \\notin \\mathcal{R}_C \\vee
                                                                                                                                                             if (\\vec{x}, \\vec{w}) \\notin \\mathcal{R}_C \\vee
                                                                                                                                                                     \\exists i \\in [n],
    \\exists i \\in [n],
            AuthVer(vk, \\sigma_i, L_i, x_i) = \\bot
                                                                                                                                                                            AuthVer(vk, \\sigma_i, L_i, x_i) = \\bot
then Return 0
                                                                                                                                                              then Return 0
else Return \\mathcal{D}(\\pi)
                                                                                                                                                              else Return \\mathcal{D}(\\pi)
</code></pre>

    <p class="text-gray-300">Note that the distinguisher  <span class="math">\\mathcal{D}</span>  in the above game has a shared state that is persistent over all invocations of  <span class="math">\\mathcal{D}</span>  during an experiment.</p>

    <p class="text-gray-300">We stress that the above zero-knowledge notion aims at capturing, in the strongest possible sense, that the verifier cannot learn any useful information on the inputs, even if it knows (or chooses) the secret authentication key. Indeed, as one can see, our definition allows the distinguisher to choose the authentication key pair as well as the authentication tags.</p>

    <p class="text-gray-300">Interestingly, we note that the notion of AD-SNARKs immediately implies a corresponding notion of verifiable computation on authenticated data (similar to [BFR13]). In [BCCT12], it is discussed how to construct a verifiable computation scheme from SNARGs for  <span class="math">\\mathcal{NP}</span>  with adaptive soundness. This is simply based on the fact that the correctness of a computation can be described with an  <span class="math">\\mathcal{NP}</span>  statement. It is not hard to see that, in a very similar way, one can construct verifiable computation on authenticated data from AD-SNARKs.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 A Generic Construction of Zero-Knowledge AD-SNARKs</h3>

    <p class="text-gray-300">We show how to construct a zero-knowledge AD-SNARK scheme from SNARKs and digital signatures. A similar construction was informally sketched in [BCCT12][Appendix 10.1.2 of the full version]. Here we make it more formal with the main purpose of offering a comparison with our direct AD-SNARK construction proposed in the next section.</p>

    <p class="text-gray-300">The high-level idea of the generic construction is to embed digital signatures into SNARKs. Let therefore  <span class="math">\\Pi&#x27; = (\\mathsf{Gen&#x27;}, \\mathsf{Prove&#x27;}, \\mathsf{Ver&#x27;})</span>  be a SNARK scheme, and  <span class="math">\\Sigma = (\\Sigma.\\mathsf{KG}, \\Sigma.\\mathsf{Sign}, \\Sigma.\\mathsf{Ver})</span>  be a signature scheme.</p>

    <p class="text-gray-300">We will use the signature scheme to sign pairs consisting of a label L and an actual message m. Although labels and messages can be arbitrary binary strings, for ease of description we assume that labels can take a special value  <span class="math">\\star</span> . Also, we modify the signature scheme in such a way that  <span class="math">\\Sigma.\\text{Sign}(\\mathsf{sk},\\star|m) = \\star</span>  and  <span class="math">\\Sigma.\\text{Ver}(\\mathsf{vk},\\star|m&#x27;,\\star) = 1</span> . Basically, we let everyone (trivially) generate a valid signature on a message with label  <span class="math">\\star</span> .</p>

    <p class="text-gray-300">We define an AD-SNARK  <span class="math">\\Pi = (Setup, AuthKG, Auth, AuthVer, Prove, Ver)</span>  as follows.</p>

    <p class="text-gray-300">Setup( <span class="math">1^{\\lambda}</span> ): Output pp =  <span class="math">1^{\\lambda}</span> .</p>

    <p class="text-gray-300">AuthKG(pp): run  <span class="math">(sk&#x27;, vk&#x27;) \\leftarrow_{\\mathcal{R}} \\Sigma.KG(1^{\\lambda})</span>  to generate the key pair of the signature scheme and return sk = sk' and vk = pap = vk'.</p>

    <p class="text-gray-300">Auth(sk, L, x): compute a signature on the concatenation of the label L and the value x, i.e.,  <span class="math">\\sigma&#x27; \\leftarrow \\Sigma.\\text{Sign}(\\mathsf{sk}&#x27;,\\mathsf{L}|x)</span> . Finally, output  <span class="math">\\sigma = (\\sigma&#x27;,\\mathsf{L})</span> .</p>

    <p class="text-gray-300">AuthVer(vk,  <span class="math">\\sigma</span> , L, x): let  <span class="math">\\sigma = (\\sigma&#x27;, L&#x27;)</span> . Output the result of the signature verification algorithm  <span class="math">Ver&#x27;(vk&#x27;, L|x, \\sigma&#x27;)</span> .</p>

    <p class="text-gray-300">Gen(pap, C): for the given circuit  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  we define C' as the circuit that outputs  <span class="math">0^l</span>  on all the pairs  <span class="math">(\\overrightarrow{x}, \\overrightarrow{w})</span>  such that  <span class="math">C(\\overrightarrow{x}, \\overrightarrow{w}) = 0^l</span>  and each  <span class="math">x_i</span>  is correctly signed with respect to a set of labels and a public key. More formally, define  <span class="math">C&#x27;: \\mathbb{F}^{n&#x27;} \\times \\mathbb{F}^{h&#x27;} \\to \\mathbb{F}^l</span>  as the circuit that takes as inputs pairs  <span class="math">(\\overrightarrow{x}&#x27;, \\overrightarrow{w}&#x27;)</span>  with  <span class="math">\\overrightarrow{x}&#x27; = (y_1, \\mathsf{L}_1, \\ldots, y_n, \\mathsf{L}_n, \\mathsf{vk})</span>  and  <span class="math">\\overrightarrow{w}&#x27; = (\\overrightarrow{w}, z_1, \\sigma_1, \\ldots, z_n, \\sigma_n)</span>  such that, by setting  <span class="math">x_i = y_i</span>  if  <span class="math">\\mathsf{L}_i = \\star</span>  and  <span class="math">x_i = z_i</span>  otherwise, for all  <span class="math">i \\in [n]</span> , it holds: (i)  <span class="math">((x_1, \\ldots, x_n), \\overrightarrow{w}) \\in \\mathcal{R}_C</span> , and (ii)  <span class="math">\\Sigma.\\mathsf{Ver}(\\mathsf{vk}, \\mathsf{L}_i | x_i, \\sigma_i) = 1</span> .</p>

    <p class="text-gray-300">Finally, run  <span class="math">\\mathsf{Gen}&#x27;(1^{\\lambda}, C&#x27;)</span>  to generate  <span class="math">(\\mathsf{EK}&#x27;_{C&#x27;}, \\mathsf{VK}&#x27;_{C&#x27;})</span>  and output  <span class="math">\\mathsf{EK}_C = \\mathsf{EK}&#x27;_{C&#x27;}, \\mathsf{VK}_C = \\mathsf{VK}&#x27;_{C&#x27;}</span> .</p>

    <p class="text-gray-300">Prove( <span class="math">\\mathsf{EK}_C, \\vec{x}, \\vec{w}, \\vec{\\sigma}</span> ): Let  <span class="math">\\mathsf{EK}_C</span>  the be evaluation key as defined above,  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathbb{F}^n \\times \\mathbb{F}^h</span>  be a statement-witness pair, and  <span class="math">\\vec{\\sigma} = (\\sigma_1, \\dots, \\sigma_n)</span>  be a tuple of authentication tags for  <span class="math">\\vec{x} =</span></p>

    <p class="text-gray-300"><span class="math">(x_1,\\ldots,x_n)</span> . If all the tags verify correctly, define  <span class="math">\\overrightarrow{x}&#x27;=(y_1,\\mathsf{L}_1,\\ldots,y_n,\\mathsf{L}_n,\\mathsf{vk}), \\overrightarrow{w}&#x27;=(\\overrightarrow{w},z_1,\\sigma_1&#x27;,\\ldots,z_n,\\sigma_n&#x27;)</span>  so that for all  <span class="math">i\\in[n]</span> :  <span class="math">z_i=x_i,\\ y_i=x_i</span>  if  <span class="math">\\sigma_i=\\star</span>  and  <span class="math">y_i=0</span>  otherwise. Next, run  <span class="math">\\pi\\leftarrow_{\\mathcal{R}}\\mathsf{Prove}(\\mathsf{EK}&#x27;_{C&#x27;},\\overrightarrow{x}&#x27;,\\overrightarrow{w}&#x27;)</span>  to generate a proof for  <span class="math">(\\overrightarrow{x}&#x27;,\\overrightarrow{w}&#x27;)\\in\\mathcal{R}_{C&#x27;}</span>  and return  <span class="math">\\pi</span> .</p>

    <p class="text-gray-300">Ver(vk, VK<sub>C</sub>, L,  <span class="math">\\{x_i\\}_{L_i=\\star}</span> ,  <span class="math">\\pi</span> ): given the verification key vk, a circuit verification key VK<sub>C</sub>, statement labels  <span class="math">\\overrightarrow{L} = (L_1, \\ldots, L_n)</span> , unauthenticated statement components  <span class="math">x_i</span> , and a proof  <span class="math">\\pi</span> , the verification algorithm defines  <span class="math">\\overrightarrow{x}&#x27; = (y_1, L_1, \\ldots, y_n, L_n, \\text{vk})</span>  with  <span class="math">y_i = x_i</span>  if  <span class="math">L_i = \\star</span>  and  <span class="math">y_i = 0</span>  otherwise. Finally, it returns the output of  <span class="math">\\text{Ver}&#x27;(\\text{VK}&#x27;_{C&#x27;}, \\overrightarrow{x}&#x27;, \\pi)</span> .</p>

    <p class="text-gray-300">Note that the input size of C' is a circuit larger than C as follows:  <span class="math">n&#x27; = n + n \\cdot |\\mathsf{L}_i| + |\\mathsf{vk}|</span>  and  <span class="math">h&#x27; = h + n + n \\cdot |\\sigma|</span> , where  <span class="math">|\\mathsf{vk}|</span> ,  <span class="math">|\\mathsf{L}_i|</span> , and  <span class="math">|\\sigma|</span>  represent the size, in terms of field elements, of the public key, a label, and a signature, respectively. In terms of gates and wires, C' is at least as large as C plus the circuit size of  <span class="math">\\Sigma</span> . Ver for every signature verification, that is up to n of such circuits.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> If  <span class="math">\\Pi&#x27;</span>  is a zero-knowledge SNARK and  <span class="math">\\Sigma</span>  is a secure digital signature, then the scheme described above is a zero-knowledge AD-SNARK.</p>

    <p class="text-gray-300"><em>Proof (Sketch)</em>. We provide a proof sketch to show that the generic construction satisfies all the properties. First, it is easy to see that if the SNARK is succinct, then the AD-SNARK proofs are succinct as well. Moreover, authentication correctness and completeness immediately follow from the correctness of the signature scheme and the completeness of the SNARK respectively.</p>

    <p class="text-gray-300">Second, to see that adaptive proof of knowledge holds, note that for every adversary producing an accepting proof for statement  <span class="math">\\vec{x}&#x27;</span>  there is an extractor that returns a corresponding witness  <span class="math">\\vec{w}&#x27;</span>  (since  <span class="math">\\Pi&#x27;</span>  is an argument of knowledge) such that  <span class="math">(\\vec{x}&#x27;, \\vec{w}&#x27;) \\in \\mathcal{R}_{C&#x27;}</span>  with all but negligible probability. Such witness  <span class="math">\\vec{w}&#x27;</span> , by definition, will contain a statement-witness pair  <span class="math">\\vec{x}, \\vec{w}</span>  for  <span class="math">\\mathcal{R}_C</span>  and a collection of signatures. Moreover,  <span class="math">(\\vec{x}&#x27;, \\vec{w}&#x27;) \\in \\mathcal{R}_{C&#x27;}</span>  implies that  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span>  and all signatures are valid. Then, if for such a proof there is a message-label pair  <span class="math">\\mathsf{L}_i|x_i</span>  which was not queried to the <strong>Auth</strong> oracle, then  <span class="math">\\mathsf{L}_i|x_i</span>  and the corresponding signature  <span class="math">\\sigma_i</span>  can be used as a forgery to break the unforgeability of the signature scheme. Otherwise, if no forgery occurs, all signatures are valid for the same statement values queried to <strong>Auth</strong> (and thus stored in T). This means that in the check of <strong>Ver</strong>, it also holds  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span> , i.e., GameOutput remains 0.</p>

    <p class="text-gray-300">Third, the zero-knowledge of the AD-SNARK follows from the one of the SNARK in a straightforward way.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Signature Verification Overhead</h3>

    <p class="text-gray-300">We now discuss why the circuit C' resulting from explicitly encoding the verification algorithm of a digital signature scheme, as described in the generic construction, is bound to render the construction very inefficient. We consider various examples of signatures in both the random oracle and the standard model, and based on different algebraic problems.</p>

    <p class="text-gray-300">If one considers signature schemes in the random oracle model (which include virtually all the schemes used in practice), any such scheme uses a collision-resistant hash function (e.g., SHA-1) which is thus part of the verification algorithm computation. Unfortunately, as shown also in [PGHR13], a QAP (just) for a SHA-1 computation is terribly inefficient due to the high number of multiplication gates (roughly 24 000, for inputs of 416 bits). On the other hand, if we focus on standard model signature schemes, it does not get any better: These schemes involve specific algebraic computations, and encoding these computations into an arithmetic circuit over a field  <span class="math">\\mathbb{F}_p</span>  is</p>

    <p class="text-gray-300">costly. For instance, signatures based on pairings [BB04, Wat05] require pairing computations that amount to, roughly, 10 000 multiplications. RSA-based standard-model signatures (e.g., Cramer-Shoup [CS99]) require exponentiations over rings of large order (e.g., 3 000 bits), and simulating such computations over  <span class="math">\\mathbb{F}_p</span>  ends up with thousands of multiplication gates as well. Lattice-based signatures (in the standard model), e.g., [Boy10], can be cheaper in terms of the number of multiplications. However, such multiplications typically work over  <span class="math">\\mathbb{Z}_q</span>  for a q much smaller than our p. An option would be to implement mod-q-reductions in  <span class="math">\\mathbb{F}_p</span>  circuits, which is costly. Another option would be to let these schemes work over  <span class="math">\\mathbb{Z}_p</span> , but then one has to work with higher dimensional lattices (or polynomial rings) for security reasons, again incurring a large number of multiplications.</p>

    <p class="text-gray-300">This state of affairs suggests that a QAP encoding a signature verification circuit is likely to require at least (and this is a very optimistic estimate) one thousand multiplications for <em>every</em> signature that must be checked.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Our Construction of Zero-Knowledge AD-SNARKs</h2>

    <p class="text-gray-300">In this section we describe our construction of an AD-SNARK scheme for the satisfiability of arbitrary arithmetic circuits. The scheme can be used with either secret or public verifiability. The main difference between the two verification modes is that the size of the proof in the secretly verifiable case is a fixed constant, whereas in the publicly verifiable case, the proof grows linearly with the number of authenticated statement values. Although we loose constant-size proofs for public verifiability, we stress that: (i) proofs are linear only in the number  <span class="math">N \\leq n</span>  of authenticated values and their size does not depend on the complexity of the circuit, and (ii) the verification algorithm runs linearly in N in any case (even in the generic construction). Furthermore, when considering concrete implementations and applications, although the proof size of ADSNARK with public verifiability is not constant, it still scales very well, e.g., the size of an ADSNARK proof for a monthly electricity bill is under 170 KB vs. a constant-size proof of 0.3 KB when using the generic scheme with [BSCTV14]. In contrast, when considering the prover's performance, ADSNARK remains in the realm of practicality &ndash; 18 seconds for a monthly bill &ndash; whereas for the generic scheme the timing goes up to 10 minutes.</p>

    <p class="text-gray-300">For verifiers that know the secret authentication key (e.g., as in a smart metering/insurance application where companies install a symmetric key in the devices), ADSNARK proofs have constant size, and &ndash; crucially &ndash; the knowledge of such a secret key by the verifier does <em>not</em> compromise privacy.</p>

    <p class="text-gray-300">Our scheme is proven secure under two computational assumptions in bilinear groups, the q-Diffie-Hellman Exponent assumption (q-DHE) [CKS09] and the q-Power Knowledge of Exponent assumption (q-PKE) [Gro10]. We note that the latter one is a non-falsifiable assumption. As discussed in Section 6, this kind of assumption is likely to be inherent for SNARKs for  <span class="math">\\mathcal{NP}</span> . For privacy, we show that the scheme offers statistical zero-knowledge. We stress that this property holds even against adversaries who know (and even generate) the authentication keys.</p>

    <p class="text-gray-300">A detailed description of our scheme follows.</p>

    <p class="text-gray-300">Setup(1 <span class="math">^{\\lambda}</span> ): On input the security parameter 1 <span class="math">^{\\lambda}</span> , run  <span class="math">pp = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, \\mathcal{P}_1, \\mathcal{P}_2) \\leftarrow_{\\mathcal{R}} \\mathcal{G}(1^{\\lambda})</span>  to generate a bilinear group description, where  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span>  are groups of the same prime order  <span class="math">p &gt; 2^{\\lambda}</span> ,  <span class="math">\\mathcal{P}_1 \\in \\mathbb{G}_1</span>  and  <span class="math">\\mathcal{P}_2 \\in \\mathbb{G}_2</span>  are the respective generators, and  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is an efficiently computable bilinear map. We let the finite field  <span class="math">\\mathbb{F}</span>  be the set of integers modulo p.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>AuthKG(pp): Create a key pair  <span class="math">(\\mathsf{sk}&#x27;, \\mathsf{vk}&#x27;) \\leftarrow_{\\mathcal{R}} \\Sigma.\\mathsf{KG}(1^{\\lambda})</span>  for a regular signature scheme. Run  <span class="math">(S, \\mathsf{prfpp})</span>   <span class="math">\\leftarrow_{\\mathcal{R}} \\mathsf{F}.\\mathsf{KG}(1^{\\lambda})</span>  to obtain the seed S and the public parameters  <span class="math">\\mathsf{prfpp}</span>  of a pseudorandom function  <span class="math">\\mathsf{F}_S: \\{0,1\\}^* \\to \\mathbb{F}</span> . Choose a random value  <span class="math">\\kappa \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span>  and compute  <span class="math">K_1 = \\kappa \\mathcal{P}_1 \\in \\mathbb{G}_1, K_2 = \\kappa \\mathcal{P}_2 \\in \\mathbb{G}_2</span> . Return the secret key  <span class="math">\\mathsf{sk} = (\\mathsf{sk}&#x27;, S, \\kappa)</span> , the public verification key  <span class="math">\\mathsf{vk} = (\\mathsf{vk}&#x27;, K_2)</span> , and the public authentication parameters  <span class="math">\\mathsf{pap} = (\\mathsf{pp}, \\mathsf{prfpp}, K_1)</span> .</li>
      <li>Auth(sk, L, x): To authenticate a value  <span class="math">x \\in \\mathbb{F}</span>  with label L, generate  <span class="math">\\phi \\leftarrow \\mathsf{F}_S(\\mathsf{L})</span>  using the PRF, compute  <span class="math">\\mu = \\phi + \\kappa \\cdot x \\in \\mathbb{F}</span>  and  <span class="math">\\Phi = \\phi \\mathcal{P}_2 \\in \\mathbb{G}_2</span> . Then compute a signature  <span class="math">\\sigma&#x27; \\leftarrow_{\\mathcal{R}} \\Sigma.\\mathsf{Sign}(\\mathsf{sk}&#x27;, \\Phi | \\mathsf{L})</span> , and output the tag  <span class="math">\\sigma = (\\mu, \\Phi, \\sigma&#x27;)</span> .</li>
      <li>AuthVer(vk,  <span class="math">\\sigma</span> , L, x): Let vk = (vk',  <span class="math">K_2</span> ) be the verification key. To verify that  <span class="math">\\sigma = (\\mu, \\Phi, \\sigma&#x27;)</span>  is a valid authentication tag for a value  <span class="math">x \\in \\mathbb{F}</span>  with respect to label L, output  <span class="math">\\top</span>  if  <span class="math">\\mu \\mathcal{P}_2 = \\Phi + x K_2</span>  in  <span class="math">\\mathbb{G}_2</span> , and if  <span class="math">\\Sigma</span> .Ver(vk',  <span class="math">\\Phi</span> |L,  <span class="math">\\sigma&#x27;</span> ) = 1. Output  <span class="math">\\bot</span>  otherwise. In the secret key setting (i.e., if vk is replaced by sk), the tag  <span class="math">\\sigma</span>  can be verified by checking whether  <span class="math">\\mu = F_S(L) + \\kappa \\cdot x</span> .</li>
      <li><span class="math">\\mathsf{Gen}(\\mathsf{pap},C)</span> : Let  <span class="math">C:\\mathbb{F}^n\\times\\mathbb{F}^h\\to\\mathbb{F}^l</span>  be an arithmetic circuit. To generate the keys, proceed as follows.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">Q_C = (\\vec{a}, \\vec{b}, \\vec{c}, z) = \\mathsf{QAPInst}(C)</span>  to build a QAP of size m and degree d for C. Recall that  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  are vectors of m+1 polynomials in  <span class="math">\\mathbb{F}^{\\leq d-1}[X]</span> , while the target polynomial  <span class="math">z \\in \\mathbb{F}[X]</span>  has degree d. Extend  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  with 3 more polynomials each, by setting:</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} a_{m+1}(X) &amp;= b_{m+2}(X) = c_{m+3}(X) = z(X), \\\\ a_{m+2}(X) &amp;= a_{m+3}(X) = b_{m+1}(X) = b_{m+3}(X) = c_{m+1}(X) = c_{m+2}(X) = 0. \\end{split}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">I_x, I_{mid}</span>  be the following partitions of  <span class="math">\\{1, \\ldots, m+3\\}</span> :  <span class="math">I_x = \\{1, \\ldots, n\\}</span> ,  <span class="math">I_{mid} = \\{n+1, \\ldots, m+3\\}</span> . In other words, we partition all the circuit wires into the n statement wires  <span class="math">I_x</span> , and the remaining &quot;internal&quot; wires  <span class="math">I_{mid}</span>  (which include the h witness wires).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pick  <span class="math">\\rho_{\\mathsf{a}}, \\rho_{\\mathsf{b}}, \\tau, \\alpha_{\\mathsf{a}}, \\alpha_{\\mathsf{b}}, \\alpha_{\\mathsf{c}}, \\beta, \\gamma \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span>  uniformly at random, set  <span class="math">\\rho_{\\mathsf{c}} = \\rho_{\\mathsf{a}} \\cdot \\rho_{\\mathsf{b}}</span> , and compute the following values:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} Z &amp;= z(\\tau)\\rho_{\\text{c}}\\mathcal{P}_2, \\qquad K_{\\text{a}} = z(\\tau)\\,\\rho_{\\text{a}}\\,K_1, \\\\ \\forall k \\in \\{0,...,m+3\\}: \\quad A_k &amp;= a_k(\\tau)\\rho_{\\text{a}}\\,\\mathcal{P}_1, \\qquad A_k&#x27; = \\alpha_{\\text{a}}\\,a_k(\\tau)\\rho_{\\text{a}}\\,\\mathcal{P}_1, \\\\ B_k &amp;= b_k(\\tau)\\rho_{\\text{b}}\\,\\mathcal{P}_2, \\qquad B_k&#x27; = \\alpha_{\\text{b}}\\,b_k(\\tau)\\rho_{\\text{b}}\\,\\mathcal{P}_1, \\\\ C_k &amp;= c_k(\\tau)\\rho_{\\text{c}}\\,\\mathcal{P}_1, \\qquad C_k&#x27; = \\alpha_{\\text{c}}\\,c_k(\\tau)\\rho_{\\text{c}}\\,\\mathcal{P}_1, \\\\ E_k &amp;= \\beta(a_k(\\tau)\\rho_{\\text{a}} + b_k(\\tau)\\rho_{\\text{b}} + c_k(\\tau)\\rho_{\\text{c}})\\,\\mathcal{P}_1. \\end{split}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the evaluation key  <span class="math">\\mathsf{EK}_C</span>  and the verification key  <span class="math">\\mathsf{VK}_C</span>  defined as follows:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{EK}_C &amp;= \\Big(\\ Q_C,\\ \\overrightarrow{A},\\ \\overrightarrow{A}&#x27;,\\overrightarrow{B},\\ \\overrightarrow{B}&#x27;,\\overrightarrow{C},\\ \\overrightarrow{C}&#x27;,\\overrightarrow{E},\\ \\{\\tau^i\\,\\mathcal{P}_1\\}_{i\\in\\{0,\\dots,d\\}},K_\\mathsf{a}\\Big) \\\\ \\mathsf{VK}_C &amp;= \\Big(\\ \\mathcal{P}_1,\\ \\mathcal{P}_2,\\ \\alpha_\\mathsf{a}\\,\\mathcal{P}_2,\\ \\alpha_\\mathsf{b}\\,\\mathcal{P}_1,\\ \\alpha_\\mathsf{c}\\,\\mathcal{P}_2,\\ \\gamma\\,\\mathcal{P}_2,\\ \\beta\\,\\gamma\\,\\mathcal{P}_1,\\ \\beta\\,\\gamma\\,\\mathcal{P}_2,\\ Z,\\ \\{A_k\\}_{k=0}^n,\\Big) \\end{split}</span>$</p>

    <p class="text-gray-300">Prove( <span class="math">\\mathsf{EK}_C, \\vec{x}, \\vec{w}, \\vec{\\sigma}</span> ): Let  <span class="math">\\mathsf{EK}_C</span>  the an evaluation key defined as above,  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathbb{F}^n \\times \\mathbb{F}^h</span>  be a statement-witness pair, and  <span class="math">\\sigma = (\\sigma_1, \\dots, \\sigma_n)</span>  be a tuple of authentication tags for x such that, for any  <span class="math">i \\in [n]</span> , either  <span class="math">\\sigma_i = (\\mu_i, \\Phi_i, \\sigma_i&#x27;)</span>  or  <span class="math">\\sigma_i = \\star</span> . We define  <span class="math">I_\\sigma = \\{i \\in I_x : \\sigma_i \\neq \\star\\} \\subseteq I_x</span>  as the set of indices for which there is an authenticated statement value, and let  <span class="math">I_\\star = I_x \\setminus I_\\sigma</span>  be its complement. To produce a proof for the satisfiability of  <span class="math">C(\\vec{x}, \\vec{w}) = 0^l</span>  proceed as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\vec{s} = \\mathsf{QAPwit}(C, \\vec{x}, \\vec{w}) \\in \\mathbb{F}^m</span>  (and recall that  <span class="math">s_i = x_i</span>  for all  <span class="math">i \\in [n]</span> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample  <span class="math">\\delta_{\\mathsf{a}}^{\\sigma}</span> ,  <span class="math">\\delta_{\\mathsf{a}}^{mid}</span> ,  <span class="math">\\delta_{\\mathsf{b}}</span> ,  <span class="math">\\delta_{\\mathsf{c}} \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> , and set  <span class="math">\\delta_{\\mathsf{a}} = \\delta_{\\mathsf{a}}^{\\sigma} + \\delta_{\\mathsf{a}}^{mid}</span> . Also, define the vector  <span class="math">\\vec{u} = (1, \\vec{s}, \\delta_{\\mathsf{a}}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}}) \\in \\mathbb{F}^{m+4}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Solve the QAP  <span class="math">Q_C</span>  by computing the coefficients  <span class="math">(h_0, \\ldots, h_d) \\in \\mathbb{F}^{d+1}</span>  of the polynomial  <span class="math">h \\in \\mathbb{F}[X]</span>  such that h(X)z(X) = a(X)b(X) c(X), where  <span class="math">a, b, c \\in \\mathbb{F}[X]</span>  are</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} a(X) &amp;= a_0(X) + \\sum_{k \\in [m]} s_k \\cdot a_k(X) + \\delta_{\\mathbf{a}} \\cdot z(x) \\\\ b(X) &amp;= b_0(X) + \\sum_{k \\in [m]} s_k \\cdot b_k(X) + \\delta_{\\mathbf{b}} \\cdot z(x) \\\\ c(X) &amp;= c_0(X) + \\sum_{k \\in [m]} s_k \\cdot c_k(X) + \\delta_{\\mathbf{c}} \\cdot z(x) \\end{split}</span>$</p>

    <p class="text-gray-300">Then compute  <span class="math">H = h(\\tau) \\mathcal{P}_1</span>  using the values  <span class="math">\\tau^i \\mathcal{P}_1</span>  contained in the evaluation key  <span class="math">\\mathsf{EK}_C</span> . Note that we have  <span class="math">a(X) = \\langle \\overrightarrow{u}, \\overrightarrow{a} \\rangle, \\ b(X) = \\langle \\overrightarrow{u}, \\overrightarrow{b} \\rangle</span>  and  <span class="math">c(X) = \\langle \\overrightarrow{u}, \\overrightarrow{c} \\rangle</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the following values:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\pi_{\\mathsf{b}} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{B} \\rangle, \\quad \\pi&#x27;_{\\mathsf{b}} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{B&#x27;} \\rangle, \\\\ \\pi_{\\sigma} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\delta^{\\sigma}_{\\mathsf{a}} \\, A_{m+1}, \\\\ \\pi_{mid} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{mid}} - \\delta^{\\sigma}_{\\mathsf{a}} \\, A_{m+1}, \\\\ \\pi_{E} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{E} \\rangle. \\end{split} \\qquad \\begin{aligned} \\pi_{\\mathsf{c}} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{C} \\rangle, \\quad \\pi&#x27;_{\\mathsf{c}} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{C&#x27;} \\rangle, \\\\ \\pi&#x27;_{\\mathsf{c}} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A&#x27;} \\rangle_{I_{\\sigma}} + \\delta^{\\sigma}_{\\mathsf{a}} \\, A&#x27;_{m+1} \\\\ \\pi&#x27;_{mid} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A&#x27;} \\rangle_{I_{\\sigma}} - \\delta^{\\sigma}_{\\mathsf{a}} \\, A&#x27;_{m+1} \\\\ \\pi&#x27;_{E} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{E} \\rangle. \\end{aligned}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Authenticate the value  <span class="math">\\pi_{\\sigma}</span>  by computing</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\pi_{\\mu} = \\langle \\overrightarrow{\\mu}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma} \\, K_{\\mathsf{a}}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Construct and return proof  <span class="math">\\pi</span>  as the tuple  <span class="math">(\\pi_{\\mu}, \\pi_{\\sigma}, \\pi&#x27;_{\\sigma}, \\pi_{mid}, \\pi&#x27;_{mid}, \\pi_{\\mathsf{b}}, \\pi&#x27;_{\\mathsf{b}}, \\pi_{\\mathsf{c}}, \\pi&#x27;_{\\mathsf{c}}, \\pi_{E}, H)</span> . To make the proof publicly verifiable, include also  <span class="math">\\{\\Phi_{k}, \\sigma&#x27;_{k}\\}_{k \\in I_{\\sigma}}</span> .</li>
    </ol></li>
      <li>Ver(vk, VK<sub>C</sub>, L,  <span class="math">\\{x_i\\}_{L_i=\\star}</span> ,  <span class="math">\\pi</span> ): Let VK<sub>C</sub> be the verification key for the circuit C,  <span class="math">\\overrightarrow{L} = (L_1, \\ldots, L_n)</span>  be a vector of labels, and let  <span class="math">\\pi</span>  be a proof as defined above. In a similar way as in Prove, we define  <span class="math">I_{\\sigma} = \\{i \\in I_x : L_i \\neq \\star\\} \\subseteq I_x</span>  and  <span class="math">I_{\\star} = I_x \\setminus I_{\\sigma}</span> . The verification algorithm computes  <span class="math">A_{\\star} = A_0 + \\langle \\overrightarrow{x}, \\overrightarrow{A} \\rangle_{I_{\\star}}</span>  and proceeds as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(A.1<sup>secret</sup>) If verification is done using the secret key  <span class="math">\\mathsf{sk} = (S, \\kappa)</span> , check the authenticity of  <span class="math">\\pi_{\\sigma}</span>  against the labels  <span class="math">\\overrightarrow{\\mathsf{L}}</span>  by checking whether the following equation holds in  <span class="math">\\mathbb{G}_1</span> :<sup>8</sup></li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$|\\pi_{\\mu}| = \\langle \\mathsf{F}_{S}(\\overrightarrow{\\mathsf{L}}), \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\kappa |\\pi_{\\sigma}|</span>$</p>

    <p class="text-gray-300">(A.1<sup>public</sup>) If the verification is performed using the public verification key  <span class="math">vk = (vk&#x27;, K_2)</span> : first, check the validity of all  <span class="math">\\Phi_k</span>  by verifying that  <span class="math">\\Sigma</span> .Ver <span class="math">(vk&#x27;, \\Phi_k | L_k, \\sigma&#x27;_k) = 1</span>  for all  <span class="math">k \\in I_\\sigma</span> ; second, check the authenticity of  <span class="math">\\pi_\\sigma</span>  by verifying that the following equation is satisfied over  <span class="math">\\mathbb{G}_T</span> :</p>

    <p class="text-gray-300"><span class="math">$e(\\pi_{\\mu}, \\mathcal{P}_2) = \\prod_{k \\in I_{\\sigma}} e(A_k, \\Phi_k) \\cdot e(\\pi_{\\sigma}, K_2)</span>$</p>

    <p class="text-gray-300"><sup>8</sup> The expansion of  <span class="math">\\langle \\mathsf{F}_S(\\vec{\\mathsf{L}}), \\vec{A} \\rangle_I</span>  is defined as the component-wise application of  <span class="math">\\mathsf{F}</span> , i.e.,  <span class="math">\\sum_{i \\in I} \\mathsf{F}_S(\\mathsf{L}_i) \\cdot A_i</span> .</p>

    <p class="text-gray-300">(A.2) Check the validity of knowledge commitments for the authenticated values:</p>

    <p class="text-gray-300"><span class="math">$e(\\pi&#x27;_{\\sigma}, \\mathcal{P}_2) = e(\\pi_{\\sigma}, \\alpha_{\\mathsf{a}} \\mathcal{P}_2)</span>$</p>

    <p class="text-gray-300">(P.1) Check the satisfiability of the QAP:</p>

    <p class="text-gray-300"><span class="math">$e(A_{\\star} + |\\pi_{\\sigma}| + |\\pi_{mid}|, |\\pi_{\\mathsf{b}}|) = e(H, Z) \\cdot e(\\pi_{\\mathsf{c}}, \\mathcal{P}_2)</span>$</p>

    <p class="text-gray-300">(P.2) Check the validity of knowledge commitments:</p>

    <p class="text-gray-300"><span class="math">$e(\\ \\pi&#x27;_{mid}\\ ,\\ \\mathcal{P}_2) = e(\\ \\pi_{mid}\\ ,\\ \\alpha_{\\mathsf{a}}\\mathcal{P}_2)\\ \\wedge\\ e(\\ \\pi&#x27;_{\\mathsf{b}}\\ ,\\mathcal{P}_2) = e(\\alpha_{\\mathsf{b}}\\mathcal{P}_1,\\ \\pi_{\\mathsf{b}}\\ )\\ \\wedge\\ e(\\ \\pi&#x27;_{\\mathsf{c}}\\ ,\\ \\mathcal{P}_2) = e(\\ \\pi_{\\mathsf{c}}\\ ,\\ \\alpha_{\\mathsf{c}}\\mathcal{P}_2)</span>$</p>

    <p class="text-gray-300">(P.3) Check that all the QAP linear combinations use the same coefficients:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\pi_E \\ , \\, \\gamma \\mathcal{P}_2) &amp;= \\\\ e(A_\\star + |\\pi_\\sigma| + |\\pi_{mid}| + |\\pi_{\\mathsf{c}}|, \\, \\beta \\gamma \\mathcal{P}_2) \\cdot e(\\beta \\gamma \\mathcal{P}_1, |\\pi_{\\mathsf{b}}|) \\end{split}</span>$</p>

    <p class="text-gray-300">If all the checks above are satisfied, then return  <span class="math">\\top</span> ; otherwise return  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">ReRand(EK<sub>C</sub>, L,  <span class="math">\\{x_i\\}_{\\mathsf{L}_i=\\star}, \\pi</span> ): The scheme also allows for perfect re-randomization of an existing proof, say  <span class="math">\\pi</span>  given by tuple  <span class="math">(\\pi_{\\mu}, \\pi_{\\sigma}, \\pi&#x27;_{\\sigma}, \\pi_{mid}, \\pi&#x27;_{mid}, \\pi_{\\mathsf{b}}, \\pi&#x27;_{\\mathsf{b}}, \\pi_{\\mathsf{c}}, \\pi&#x27;_{\\mathsf{c}}, \\pi_{E}, H)</span> . If  <span class="math">\\pi</span>  verifies for a set of labels L and a set of non-authenticated values  <span class="math">\\{x_i\\}_{\\mathsf{L}_i=\\star}</span> , then  <span class="math">\\pi</span>  can be re-randomized as follows. First, choose random values  <span class="math">\\tilde{\\delta}^{\\sigma}_{\\mathsf{a}}, \\tilde{\\delta}^{mid}_{\\mathsf{a}}, \\tilde{\\delta}_{\\mathsf{b}}, \\tilde{\\delta}_{\\mathsf{c}} \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> , and set  <span class="math">\\tilde{\\delta}_{\\mathsf{a}} = \\tilde{\\delta}^{\\sigma}_{\\mathsf{a}} + \\tilde{\\delta}^{mid}_{\\mathsf{a}}</span> . Second, compute</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\tilde{\\pi}_{\\mathbf{b}} &amp;= \\pi_{\\mathbf{b}} + \\tilde{\\delta}_{\\mathbf{b}} \\, B_{m+2}, \\quad \\tilde{\\pi}_{\\mathbf{b}}&#x27; = \\pi_{\\mathbf{b}}&#x27; + \\tilde{\\delta}_{\\mathbf{b}} \\, B_{m+2}&#x27;, \\\\ \\tilde{\\pi}_{\\mathbf{c}} &amp;= \\pi_{\\mathbf{c}} + \\tilde{\\delta}_{\\mathbf{c}} \\, C_{m+3}, \\quad \\tilde{\\pi}_{\\mathbf{c}}&#x27; = \\pi_{\\mathbf{c}} + \\tilde{\\delta}_{\\mathbf{c}} \\, C_{m+3}&#x27;, \\\\ \\tilde{\\pi}_{\\sigma} &amp;= \\pi_{\\sigma} + \\tilde{\\delta}_{\\mathbf{a}}^{\\sigma} \\, A_{m+1}, \\quad \\tilde{\\pi}_{\\sigma}&#x27; = \\pi_{\\sigma}&#x27; + \\tilde{\\delta}_{\\mathbf{a}}^{\\sigma} \\, A_{m+1}&#x27;, \\\\ \\tilde{\\pi}_{mid} &amp;= \\pi_{mid} + \\tilde{\\delta}_{\\mathbf{a}}^{mid} \\, A_{m+1}, \\\\ \\tilde{\\pi}_{mid}&#x27; &amp;= \\pi_{mid}&#x27; + \\tilde{\\delta}_{\\mathbf{a}}^{mid} \\, A_{m+1}&#x27;, \\\\ \\tilde{\\pi}_{E} &amp;= \\pi_{E} + \\tilde{\\delta}_{\\mathbf{a}} \\, E_{m+1} + \\tilde{\\delta}_{\\mathbf{b}} \\, E_{m+2} + \\tilde{\\delta}_{\\mathbf{c}} \\, E_{m+3}, \\\\ \\tilde{\\pi}_{\\mu} &amp;= \\pi_{\\mu} + \\tilde{\\delta}_{\\mathbf{a}}^{\\sigma} \\, K_{\\mathbf{a}}, \\\\ \\tilde{H} &amp;= H + \\tilde{\\delta}_{\\mathbf{a}} \\pi_{\\mathbf{b}} + \\tilde{\\delta}_{\\mathbf{b}} \\pi_{\\mathbf{a}} + \\tilde{\\delta}_{\\mathbf{a}} \\tilde{\\delta}_{\\mathbf{b}} z(\\tau) \\mathcal{P}_{1} - \\tilde{\\delta}_{\\mathbf{c}} \\, \\mathcal{P}_{1}. \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">z(\\tau)\\mathcal{P}_1</span>  can be included in  <span class="math">\\mathsf{EK}_C</span> . Finally, output the re-randomised proof  <span class="math">\\tilde{\\pi}</span>  as  <span class="math">(\\tilde{\\pi}_{\\mu},\\ \\tilde{\\pi}_{\\sigma},\\tilde{\\pi}&#x27;_{\\sigma},\\ \\tilde{\\pi}_{mid},\\tilde{\\pi}&#x27;_{mid},\\ \\tilde{\\pi}_{\\mathsf{b}},\\tilde{\\pi}&#x27;_{\\mathsf{b}},\\tilde{\\pi}_{\\mathsf{c}},\\tilde{\\pi}&#x27;_{\\mathsf{c}},\\tilde{\\pi}_{E},\\tilde{H})</span> .</p>

    <p class="text-gray-300">It is not hard to check that  <span class="math">\\tilde{\\pi}</span>  is identically distributed as a fresh proof  <span class="math">\\pi</span>  generated by Prove.</p>

    <p class="text-gray-300">The following theorem shows that the scheme ADSNARK described above is a zero-knowledge AD-SNARK as in Definition 5.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> If F is a pseudorandom function, and the q-PKE [Gro10] and the q-DHE [CKS09] assumptions hold, then ADSNARK is a secretly-verifiable zero-knowledge AD-SNARK. Furthermore, if additionally  <span class="math">\\Sigma</span>  is a secure signature scheme, then ADSNARK is a publicly-verifiable zero-knowledge AD-SNARK.</p>

    <p class="text-gray-300">We prove theorem by showing separately that the properties of completeness, adaptive proof of knowledge and zero-knowledge are all satisfied. This is done in Sections 4.1, 4.2 and 4.3 respectively.</p>

    <p class="text-gray-300"><strong>Performance and Comparison.</strong> Before proving Theorem 2, we pause to discuss the performance of our scheme ADSNARK in comparison with the SNARK of Parno et al. [PGHR13] that we call PGHR (more precisely, we consider its optimization proposed by Ben-Sasson et al. [BSCTV14] that for convenience we recall in Appendix C).</p>

    <p class="text-gray-300">First, we note that the Gen algorithm is virtually the same in both schemes except that in ADSNARK we have one more exponentiation<sup>9</sup> in  <span class="math">\\mathbb{G}_1</span>  to generate  <span class="math">K_a = z(\\tau) \\rho_a K_1</span> . Also, from a bandwidth point of view, the evaluation key of  <span class="math">\\mathsf{EK}_C</span>  of ADSNARK contains only one more  <span class="math">\\mathbb{G}_1</span>  element,  <span class="math">K_a</span> , compared to the evaluation key of PGHR. The verification key instead is the same in both schemes.</p>

    <p class="text-gray-300">Second, let us focus on the differences in the Prove algorithm. ADSNARK's Prove has to compute three more  <span class="math">\\mathbb{G}_1</span>  elements:  <span class="math">\\pi_{\\sigma}</span> ,  <span class="math">\\pi&#x27;_{\\sigma}</span> , and  <span class="math">\\pi_{\\mu}</span> . Generating these elements amounts to performing three multi-exponentiations that involve  <span class="math">N = |I_{\\sigma}|</span>  terms each. When looking at the proof size, ADSNARK's proof contains such three additional elements in the group  <span class="math">\\mathbb{G}_1</span> , plus the signatures  <span class="math">\\{\\sigma_k\\}_{k\\in I_{\\sigma}}</span>  in the publicly verifiable setting.</p>

    <p class="text-gray-300">Third, we analyze the differences between ADSNARK and PGHR in the Ver algorithm. The equations (P.1), (P.2), and (P.3) are identical in both schemes and thus require the same computational effort. In PGHR one computes  <span class="math">A_x = A_0 + \\sum_{k=1}^n x_k A_k \\in \\mathbb{G}_1</span> , whereas in ADSNARK we compute a similar value  <span class="math">A_\\star = A_0 + \\sum_{k \\in I_\\star} x_k A_k \\in \\mathbb{G}_1</span>  which involves fewer terms: precisely  <span class="math">|I_\\star| = n - N</span> . Then, ADSNARK has to perform some additional computation for verifying equations (A.1) and (A.2). (A.2) costs only two pairings &ndash; a constant overhead. The first equation instead requires different computations according to whether we are in the secretly verifiable case  <span class="math">((A.1)^{secret})</span>  or in the publicly verifiable case  <span class="math">((A.1)^{public})</span> .  <span class="math">(A.1)^{secret}</span>  requires one multi-exponentiation with  <span class="math">N = |I_\\sigma|</span>  terms (plus the cost of running the PRF which is unnoticeable compared to the multi-exponentiation). Hence, considering the cost of computing  <span class="math">A_x</span>  in PGHR and the total cost of computing  <span class="math">A_{\\star}</span>  and  <span class="math">(A.1)^{secret}</span>  in ADSNARK, these are essentially the same. In other words, ADSNARK's secretly verifiable case is slightly slower than PGHR for the cost of computing two pairings in (A.2).</p>

    <p class="text-gray-300">In the publicly verifiable case, equation  <span class="math">(A.1)^{public}</span>  requires to check a total of N signatures,  <span class="math">\\{\\sigma_k\\}_{k\\in I_\\sigma}</span> , and then to compute  <span class="math">e(\\pi_\\mu, \\mathcal{P}_2)e(\\pi_\\sigma, -K_2)</span>  and  <span class="math">\\prod_{k\\in I_\\sigma}e(A_k, \\Phi_k)</span> . In general, note that the verification of such N signatures can be done by using batching techniques, and the &quot;multi pairings&quot; can also be computed efficiently. In particular, as we show in our instantiation, this cost is close to the cost of computing  <span class="math">A_x</span>  in PGHR. In other words, ADSNARK's publicly verifiable case is slightly slower than PGHR for the cost of computing the pairings in (A.1) and (A.2) and for checking the signatures.</p>

    <p class="text-gray-300">In Section 5, we give concrete comparisons resulting from our experiments, which are consistent with the analysis above. Indeed, we show based on concrete timings that ADSNARK performs almost as PGHR used <em>without</em> authenticated data. These results conclude that our technique added an important property to the SNARK at almost no cost.</p>

    <p class="text-gray-300">However, for the sake of fairness, we should also consider a comparison of the two protocols when they are used to provide equivalent guarantees, i.e., when proving statements on authenticated data. To this end, we now compare ADSNARK against the best possible instantiation of the generic construction of Section 3.2, which we take to be PGHR working with the &quot;extended&quot; circuit C'.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup> We use the term &quot;exponentiation&quot; only for 'historical' reasons, as  <span class="math">\\mathbb{G}_1</span>  is actually an additive group.</p>

    <p class="text-gray-300">We call this scheme AD-PGHR. In our analysis, we assume that the verification of every signature requires an arithmetic circuit with c multiplication gates, and also assume (very optimistically) that this is the only additional cost for the design of C'. This means that: if C yields a QAP of size m and degree d, then C' yields a QAP of, at least, size m' = m + cN and degree d' = d + cN.</p>

    <p class="text-gray-300">In AD-PGHR, the performance of Ver remains the same as the one of Ver in PGHR discussed above. On the other hand, the Prove algorithm of AD-PGHR heavily depends on the QAP size m' and degree d'. Precisely, Prove performs multi-exponentiations with m' and d' terms, and a polynomial division operation whose cost is  <span class="math">O(d&#x27; \\log^2 d&#x27;)</span> .</p>

    <p class="text-gray-300">In conclusion, if we fix a circuit C and a number N of authenticated values, and we compare ADSNARK for circuit C against AD-PGHR for the same C (i.e., PGHR with the extended circuit C'), then we obtain:</p>

    <p class="text-gray-300">For secret verification, both schemes perform almost the same, the only difference being that we need to perform two more pairings; for public verification, ADSNARK has an additional cost of one multi-pairing computation with N terms plus the signature verification. For proof generation, AD-PGHR has to perform additional operations that involve a factor at least linear in  <span class="math">c \\cdot N</span> . We recall from the discussion in Section 3.3 that such c is likely to be larger than 1000. Therefore, one can see that while our solution charges a little more to the verifier (and only in the public verification case), the costs of our scheme on the prover side can be much cheaper, at least by a factor  <span class="math">c \\cdot N</span> . We confirm the above asymptotic comparison in Section 5 by showing the experimental results obtained by running our implementation.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Completeness</h3>

    <p class="text-gray-300"><strong>Theorem 3.</strong> The scheme ADSNARK satisfies authentication correctness and completeness.</p>

    <p class="text-gray-300"><em>Proof.</em> It is straightforward to see that the scheme has authentication correctness by the correctness of the regular signature scheme and by construction. To show the completeness, we prove the satisfaction of all verification equations in the order they appear in the verification procedure.</p>

    <p class="text-gray-300"><span class="math">(A.1^{secret})</span></p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ll} \\pi_{\\mu} \\overset{\\mathsf{Prove}}{=} &amp; \\langle \\overrightarrow{\\mu}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} \\, + \\, \\delta_{\\mathsf{a}}^{\\sigma} \\, K_{\\mathsf{a}} \\\\ \\overset{\\mathsf{Gen}}{=} &amp; \\langle \\overrightarrow{\\mu}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} \\, + \\, \\delta_{\\mathsf{a}}^{\\sigma} z(\\tau) \\rho_{\\mathsf{a}} K_{1} \\\\ \\overset{\\mathsf{Auth}}{=} &amp; \\langle \\mathsf{F}_{S}(\\overrightarrow{\\mathsf{L}}) + \\kappa \\cdot \\overrightarrow{x}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} \\, + \\, \\delta_{\\mathsf{a}}^{\\sigma} z(\\tau) \\rho_{\\mathsf{a}} K_{1} \\\\ \\overset{\\mathsf{AuthKG}}{=} &amp; \\langle \\mathsf{F}_{S}(\\overrightarrow{\\mathsf{L}}), \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\kappa \\langle \\overrightarrow{x}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma} z(\\tau) \\rho_{\\mathsf{a}} \\kappa \\mathcal{P}_{1} \\\\ \\overset{\\mathsf{Gen}}{=} &amp; \\langle \\mathsf{F}_{S}(\\overrightarrow{\\mathsf{L}}), \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\kappa (\\langle \\overrightarrow{x}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma} A_{m+1}) \\\\ \\overset{\\mathsf{Prove}}{=} &amp; \\langle \\mathsf{F}_{S}(\\overrightarrow{\\mathsf{L}}), \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\kappa \\cdot \\pi_{\\sigma} \\end{array}</span>$</p>

    <p class="text-gray-300"><span class="math">(A.1^{pub})</span></p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\pi_{\\mu},\\mathcal{P}_{2}) &amp; \\stackrel{\\mathsf{Prove}}{=} &amp; e(\\langle\\overrightarrow{\\mu},\\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}K_{\\mathsf{a}},\\mathcal{P}_{2}) \\\\ &amp; \\stackrel{\\mathsf{Gen}}{=} &amp; e(\\langle\\overrightarrow{\\mu},\\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}z(\\tau)\\rho_{\\mathsf{a}}K_{1},\\mathcal{P}_{2}) \\\\ &amp; \\stackrel{\\mathsf{Auth}}{=} &amp; e(\\langle\\mathsf{F}_{S}(\\overrightarrow{\\mathsf{L}}) + \\kappa \\cdot \\overrightarrow{x}, \\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}z(\\tau)\\rho_{\\mathsf{a}}K_{1},\\mathcal{P}_{2}) \\\\ &amp; \\stackrel{\\mathsf{Auth}\\mathsf{KG}}{=} &amp; e(\\langle\\mathsf{F}_{S}(\\overrightarrow{\\mathsf{L}}), \\overrightarrow{A}\\rangle_{I_{\\sigma}}, \\mathcal{P}_{2}) \\cdot e(\\kappa\\langle\\overrightarrow{x}, \\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}z(\\tau)\\rho_{\\mathsf{a}}\\kappa\\mathcal{P}_{1}, \\mathcal{P}_{2}) \\\\ &amp; \\stackrel{\\mathsf{Gen}}{=} &amp; e(\\sum_{k\\in I_{\\sigma}}(\\mathsf{F}_{S}(\\mathsf{L}_{k})\\rho_{\\mathsf{a}}a_{k}(\\tau))\\mathcal{P}_{1}, \\mathcal{P}_{2}) \\cdot e(\\langle\\overrightarrow{x}, \\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}z(\\tau)\\rho_{\\mathsf{a}}\\mathcal{P}_{1}, \\mathcal{P}_{2})^{\\kappa} \\\\ &amp; \\stackrel{\\mathsf{Auth}\\mathsf{KG},\\mathsf{Prove}}{=} &amp; e(\\sum_{k\\in I_{\\sigma}}\\rho_{\\mathsf{a}}a_{k}(\\tau)\\mathcal{P}_{1}, \\mathsf{F}_{S}(\\mathsf{L}_{k})\\mathcal{P}_{2}) \\cdot e(\\langle\\overrightarrow{x}, \\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}A_{m+1}, K_{2}) \\\\ &amp; \\stackrel{\\mathsf{Gen},\\mathsf{Auth}}{=} &amp; \\prod_{k\\in I_{\\sigma}}e(A_{k}, \\Phi_{k}) \\cdot e(\\langle\\overrightarrow{x}, \\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}A_{m+1}, K_{2}) \\\\ &amp; \\stackrel{\\mathsf{Prove}}{=} &amp; \\prod_{k\\in I_{\\sigma}}e(A_{k}, \\Phi_{k}) \\cdot e(\\pi_{\\sigma}, K_{2}) \\\\ &amp; \\stackrel{\\mathsf{Prove}}{=} &amp; \\prod_{k\\in I_{\\sigma}}e(A_{k}, \\Phi_{k}) \\cdot e(\\pi_{\\sigma}, K_{2}) \\\\ \\end{split}</span>$</p>

    <p class="text-gray-300">(A.2)</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\pi_{\\sigma}&#x27;,\\,\\mathcal{P}_2) &amp;\\stackrel{\\mathsf{Prove}}{=} e\\big(\\langle \\overrightarrow{u},\\overrightarrow{A&#x27;}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}\\,A&#x27;_{m+1},\\,\\mathcal{P}_2\\big) \\\\ &amp;\\stackrel{\\mathsf{Gen}}{=} \\,\\,e\\big(\\alpha_{\\mathsf{a}}\\langle \\overrightarrow{u},\\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}\\,\\alpha_{\\mathsf{a}}\\,A_{m+1},\\,\\mathcal{P}_2\\big) \\\\ &amp;= \\,\\,e\\big(\\langle \\overrightarrow{u},\\overrightarrow{A}\\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}}^{\\sigma}\\,A_{m+1},\\,\\alpha_{\\mathsf{a}}\\mathcal{P}_2\\big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\big(\\pi_{\\sigma},\\,\\alpha_{\\mathsf{a}}\\mathcal{P}_2\\big) \\end{split}</span>$</p>

    <p class="text-gray-300">(P.1)</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(A_\\star + \\pi_\\sigma + \\pi_{mid}\\,\\pi_{\\mathrm{b}}) &amp; \\stackrel{\\mathsf{Prove}}{=} &amp; e\\Big(A_0 + \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_\\sigma} + \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_\\star} + \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{mid}}, \\, \\langle \\overrightarrow{u}, \\overrightarrow{B} \\rangle \\, \\Big) \\\\ &amp; \\stackrel{\\mathsf{Prove}}{=} &amp; e\\Big(\\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle, \\langle \\overrightarrow{u}, \\overrightarrow{B} \\rangle \\, \\Big) \\\\ &amp; \\stackrel{\\mathsf{Gen}}{=} &amp; e\\Big((\\sum_{k=0}^{m+4} u_k a_k(\\tau))\\rho_{\\mathrm{a}}\\mathcal{P}_1, \\, (\\sum_{k=0}^{m+4} u_k b_k(\\tau))\\rho_{\\mathrm{b}}\\mathcal{P}_2 \\big) \\\\ &amp; \\stackrel{\\mathsf{Gen}}{=} &amp; e\\Big(\\mathcal{P}_1, \\, \\mathcal{P}_2 \\Big)^{\\rho_{\\mathrm{a}}\\rho_{\\mathrm{b}}a(\\tau)b(\\tau)} \\\\ &amp; \\stackrel{\\mathsf{Gen},\\mathsf{Prove}}{=} &amp; e\\Big(\\mathcal{P}_1, \\, \\mathcal{P}_2 \\Big)^{\\rho_{\\mathrm{c}}(h(\\tau)z(\\tau)+c(\\tau))} \\\\ &amp; = &amp; e\\Big(h(\\tau)\\mathcal{P}_1, \\, \\rho_{\\mathrm{c}}z(\\tau)\\mathcal{P}_2 \\Big) \\cdot e\\Big(\\rho_{\\mathrm{c}}c(\\tau)\\mathcal{P}_1, \\, \\mathcal{P}_2 \\Big) \\\\ &amp; \\stackrel{\\mathsf{Prove}}{=} &amp; e\\Big(H, \\, Z \\Big) \\cdot e\\Big(\\rho_{\\mathrm{c}}\\langle \\overrightarrow{u}, \\overrightarrow{C} \\rangle \\, \\mathcal{P}_1, \\, \\mathcal{P}_2 \\Big) \\\\ &amp; \\stackrel{\\mathsf{Prove}}{=} &amp; e\\Big(H, \\, Z \\Big) \\cdot e\\Big(\\pi_{\\mathrm{c}}, \\, \\mathcal{P}_2 \\Big) \\end{split}</span>$</p>

    <p class="text-gray-300">(P.2) We refer to the proof of (A.2), which is very similar to the cases of  <span class="math">\\pi_{mid}</span> ,  <span class="math">\\pi_b</span> , and  <span class="math">\\pi_c</span> .</p>

    <p class="text-gray-300">(P.3)</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(\\pi_{E}, \\gamma \\, \\mathcal{P}_{2}) &amp; \\stackrel{\\mathsf{Prove}}{=} e\\Big(\\langle \\overrightarrow{u}, \\overrightarrow{E} \\rangle, \\gamma \\, \\mathcal{P}_{2}\\Big) \\stackrel{\\mathsf{Gen}}{=} e\\Big(\\beta \\langle \\overrightarrow{u}, (\\rho_{\\mathsf{a}} \\overrightarrow{a}(\\tau) + \\rho_{\\mathsf{b}} \\overrightarrow{b}(\\tau) + \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}} \\overrightarrow{c}(\\tau)) \\, \\mathcal{P}_{1} \\rangle, \\, \\gamma \\, \\mathcal{P}_{2}\\Big) \\\\ &amp;= e\\Big(\\langle \\overrightarrow{u}, (\\rho_{\\mathsf{a}} \\overrightarrow{a}(\\tau) + \\rho_{\\mathsf{b}} \\overrightarrow{b}(\\tau) + \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}} \\overrightarrow{c}(\\tau)) \\, \\mathcal{P}_{1} \\rangle, \\, \\beta \\gamma \\, \\mathcal{P}_{2}\\Big) \\\\ &amp;= e\\Big(\\langle \\overrightarrow{u}, \\rho_{\\mathsf{a}} \\overrightarrow{a}(\\tau) \\mathcal{P}_{1} \\rangle, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\langle \\overrightarrow{u}, \\rho_{\\mathsf{b}} \\overrightarrow{b}(\\tau) \\mathcal{P}_{1} \\rangle, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\langle \\overrightarrow{u}, \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}} \\overrightarrow{c}(\\tau) \\mathcal{P}_{1} \\rangle, \\, \\beta \\gamma \\, \\mathcal{P}_{2}\\Big) \\\\ &amp;= e\\Big(\\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\, \\langle \\overrightarrow{u}, \\rho_{\\mathsf{b}} \\overrightarrow{b}(\\tau) \\mathcal{P}_{2} \\rangle\\Big) \\cdot e\\Big(\\langle \\overrightarrow{u}, \\overrightarrow{C} \\rangle, \\beta \\gamma \\, \\mathcal{P}_{2}\\Big) \\\\ &amp;= e\\Big(\\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{+} \\langle \\overrightarrow{u}, \\overrightarrow{C} \\rangle, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\, \\langle \\overrightarrow{u}, \\overrightarrow{B} \\rangle\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{0} + \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{\\sigma}} + \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{\\star}} + \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{mid}} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}, \\, \\beta \\gamma \\mathcal{P}_{2}\\Big) \\cdot e\\Big(\\beta \\gamma \\mathcal{P}_{1}, \\pi_{\\mathsf{b}}\\Big) \\\\ &amp;\\stackrel{\\mathsf{Prove}}{=} e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}\\Big) \\cdot e\\Big(A_{\\star} + \\pi_{\\sigma} + \\pi_{mid} + \\pi_{\\mathsf{c}}\\Big) \\\\ &amp;\\stackrel</span>$</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Adaptive Proof of Knowledge</h3>

    <p class="text-gray-300">In the following theorem we prove that the scheme ADSNARK described in Section 4 satisfies the adaptive proof of knowledge property. For this purpose, we base (part of) the security directly on the proof of knowledge property of the SNARK of Parno et al. [PGHR13] (with the adaptation of [BSCTV14], see Appendix C), that is in turn based on the q-PKE and the q-DHE assumptions.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> If PGHR is a SNARK, F is a pseudorandom function, the q-PKE [Gro10] and the q-DHE [CKS09] assumptions hold, then ADSNARK is a secretly-verifiable AD-SNARK with adaptive proof of knowledge.</p>

    <p class="text-gray-300">Before giving the proof, we first recall the q-DHE and the q-PKE assumptions.</p>

    <p class="text-gray-300"><strong>Definition 7</strong> (q-Diffie-Hellman Exponent assumption [CKS09]). The q-DHE problem is defined as follows. Let  <span class="math">\\mathcal{G}</span>  be a bilinear group generator, and let  <span class="math">\\mathsf{bgpp} = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, \\mathcal{P}_1, \\mathcal{P}_2) \\leftarrow_{\\mathcal{R}} \\mathcal{G}(1^{\\lambda})</span> . Let  <span class="math">\\tau \\leftarrow_{\\mathcal{R}} \\mathbb{Z}_p</span>  be chosen uniformly at random. We define the advantage of an adversary  <span class="math">\\mathcal{A}</span>  in solving the q-DHE problem as</p>

    <p class="text-gray-300">
<span class="math">$\\begin{split} \\mathbf{Adv}_{\\mathcal{A}}^{q-\\mathsf{DHE}}(\\lambda) &amp;= \\Pr[\\mathcal{A}(\\mathsf{bgpp},\\tau\\,\\mathcal{P}_1,\\tau\\,\\mathcal{P}_2,\\dots,\\tau^q\\,\\mathcal{P}_1,\\\\ &amp;\\tau^q\\,\\mathcal{P}_2,\\tau^{q+2}\\,\\mathcal{P}_1,\\tau^{q+2}\\,\\mathcal{P}_2,\\dots,\\tau^{2q}\\,\\mathcal{P}_1,\\tau^{2q}\\,\\mathcal{P}_2) = \\tau^{q+1}\\,\\mathcal{P}_1]. \\end{split}</span>$</p>

    <p class="text-gray-300">We say that the q-DHE assumption holds for  <span class="math">\\mathcal G</span>  if for every PPT algorithm  <span class="math">\\mathcal A</span>  and any polynomially-bounded  <span class="math">q=\\operatorname{poly}(\\lambda)</span>  we have that  <span class="math">\\operatorname{\\mathbf{Adv}}^{q-\\mathsf{DHE}}_{\\mathcal A}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><strong>Definition 8 (q-Power Knowledge of Exponent assumption [Gro10]).</strong> Let  <span class="math">\\mathcal{G}</span>  be a bilinear group generator,  <span class="math">\\lambda</span>  be a security parameter and  <span class="math">q = \\text{poly}(\\lambda)</span> . The q-PKE assumption holds for  <span class="math">\\mathcal{G}</span>  if for every non-uniform PPT adversary  <span class="math">\\mathcal{A}</span>  there exists a non-uniform PPT extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} \\Pr[\\alpha H = \\hat{H} \\ \\land \\ H \\neq (\\sum_{i=0}^q \\tilde{v}_i \\tau^i) \\mathcal{P}_1: \\\\ (H, \\hat{H}; \\ \\tilde{v}_0, \\dots, \\tilde{v}_q) \\leftarrow (\\mathcal{A} | \\mathcal{E}_{\\mathcal{A}}) (\\mathsf{bgpp}, \\tau \\mathcal{P}_1, \\tau \\mathcal{P}_2, \\dots, \\tau^q \\mathcal{P}_1, \\tau^q \\mathcal{P}_2, \\alpha \\mathcal{P}_1, \\alpha \\tau \\mathcal{P}_1, \\dots, \\alpha \\tau^q \\mathcal{P}_1, aux)] = \\mathsf{negl}(\\lambda) \\end{array}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{bgpp} = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, \\mathcal{P}_1, \\mathcal{P}_2) \\leftarrow_{\\mathcal{R}} \\mathcal{G}(1^{\\lambda}), \\tau, \\alpha \\leftarrow_{\\mathcal{R}} \\mathbb{Z}_p</span>  are chosen uniformly at random, and aux is any auxiliary information that is generated independently of  <span class="math">\\alpha</span> . The notation  <span class="math">(H, \\hat{H}; \\tilde{v}_i) \\leftarrow (\\mathcal{A}|\\mathcal{E}_{\\mathcal{A}})(inp)</span>  means that  <span class="math">\\mathcal{A}</span>  upon input of inp returns  <span class="math">(H, \\hat{H})</span>  and  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  on the same input returns  <span class="math">\\tilde{v}_i</span> . In this case,  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  has access to  <span class="math">\\mathcal{A}</span> 's random tape.</p>

    <p class="text-gray-300">In order to prove Theorem 4, we describe a series of hybrid experiments  <span class="math">G_0 - G_4</span> , where experiment  <span class="math">G_0</span>  is identical to the real adaptive proof of knowledge experiment and the remaining experiments  <span class="math">G_1 - G_4</span>  are progressively modified in such a way that each consecutive pair is proven to be (computationally) indistinguishable. Some of the games use some flag values  <span class="math">bad_i</span>  that are initially set to false. If at the end of a game any of these values is set to true, the game simply outputs 0. For notation, we denote with  <span class="math">G_i</span>  the event that a run of  <span class="math">G_i</span>  with the adversary outputs 1, and we call  <span class="math">Bad_i</span>  the event that  <span class="math">bad_i</span>  is set to true during a run of  <span class="math">G_i</span> . Essentially, whenever an event  <span class="math">Bad_i</span>  occurs, the corresponding game may deviate its outcome.</p>

    <p class="text-gray-300"><strong>Game</strong>  <span class="math">G_0</span> : This is the adaptive proof of knowledge experiment described in Section 3 and Figure 5. <strong>Game</strong>  <span class="math">G_1</span> : This is the same as  <span class="math">G_0</span>  except that the PRF  <span class="math">F_S(\\cdot)</span>  is replaced by a truly random function  <span class="math">\\mathcal{R}: \\{0,1\\}^* \\to \\mathbb{F}</span> . By the security of the PRF,  <span class="math">G_1</span>  is computationally indistinguishable from  <span class="math">G_0</span> , i.e.,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathsf{G}_0] - \\Pr[\\mathsf{G}_1]| \\leq \\mathbf{Adv}_{\\mathcal{D},\\mathsf{F}}^{PRF}(\\lambda)</span>$</p>

    <p class="text-gray-300"><strong>Game</strong>  <span class="math">G_2</span> : This is the same as  <span class="math">G_1</span>  except that the procedure  <span class="math">\\mathbf{Ver}</span>  sets  <span class="math">\\mathsf{bad}_2 \\leftarrow \\mathsf{true}</span>  if the adversary makes verification queries that (a) verify correctly with respect to the equation  <span class="math">(A.1)^{\\mathit{secret}}</span> , and in which (b) there is a label  <span class="math">L \\notin T</span>  (i.e.,  <span class="math">\\mathcal{A}</span>  never asked to authenticate a value under label L). Clearly,  <span class="math">G_1</span>  and  <span class="math">G_2</span>  are identical until  <span class="math">\\mathsf{Bad}_2</span> , i.e.,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathsf{G}_1] - \\Pr[\\mathsf{G}_2]| \\leq \\Pr[\\mathsf{Bad}_2]</span>$</p>

    <p class="text-gray-300">We show that  <span class="math">G_2</span>  is statistically close to  <span class="math">G_1</span> , by proving in Lemma 2 that  <span class="math">\\Pr[\\mathsf{Bad}_2]</span>  is (unconditionally) negligible. Intuitively, this follows from the fact that when  <span class="math">\\mathsf{L} \\notin \\mathsf{T}</span>  the first verification check is an equation with an almost-freshly sampled element  <span class="math">\\phi_\\mathsf{L} = \\mathcal{R}(\\mathsf{L}) \\in \\mathbb{F}</span> , i.e., the equation will be satisfied only with negligible probability, which is at most 1/(p-Q) where Q is the number of verification queries made by  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Game  <span class="math">G_3</span> : This is the same as  <span class="math">G_2</span>  except for the following change in <strong>Ver</strong> when answering Type 2 verification queries, i.e., we assume every label L was previously used to authenticate a value. Let  <span class="math">\\pi_{\\mu}, \\pi_{\\sigma}</span>  be the elements in the proof  <span class="math">\\pi</span>  queried by the adversary. In  <span class="math">G_3</span>  we compute  <span class="math">\\pi_{\\sigma}^* = \\sum_{k \\in I_{\\sigma}} x_k A_k \\in \\mathbb{G}_1</span> , as well as its corresponding authentication tag  <span class="math">\\pi_{\\mu}^* = \\sum_{k \\in I_{\\sigma}} \\mu_k A_k</span> , where each  <span class="math">\\mu_k</span>  is the tag previously generated for  <span class="math">(\\mathsf{L}_k, x_k)</span>  upon the respective authentication query. Next, we replace the check of equations  <span class="math">(A.1)^{secret}</span>  with checking whether</p>

    <p class="text-gray-300">
<span class="math">$e(\\pi_{\\mu}/\\pi_{\\mu}^{*}, \\mathcal{P}_{2}) = e(\\pi_{\\sigma}/\\pi_{\\sigma}^{*}, K_{2})</span>$
(1)</p>

    <p class="text-gray-300">is satisfied. Then, if equation (A.2) is satisfied (hence  <span class="math">\\pi&#x27;_{\\sigma} = \\alpha_{\\mathsf{a}} \\pi_{\\sigma}</span> ), we can run an extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>  to obtain a polynomial  <span class="math">\\tilde{a}_{\\sigma}(X)</span>  of degree at most d. If  <span class="math">\\pi_{\\sigma} \\neq \\tilde{a}_{\\sigma}(\\tau) \\rho_{\\mathsf{a}} \\mathcal{P}_{\\mathsf{1}}</span> , then we set  <span class="math">\\mathsf{bad}_{\\mathsf{3}} \\leftarrow \\mathsf{true}</span> .</p>

    <p class="text-gray-300">First, we observe that by correctness, checking equation (1) is equivalent to checking the verification equation  <span class="math">(A.1)^{secret}</span> .</p>

    <p class="text-gray-300">Second, to see that we can run the extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> , we observe that the input received by the adversary  <span class="math">\\mathcal{A}</span>  can indeed be expressed as a pair (T, aux), where  <span class="math">T = \\{\\tau^i \\mathcal{P}_j, \\alpha \\tau^i \\mathcal{P}_j\\}_{i \\in [0,d], j=1,2}</span>  and aux is some auxiliary information independent of  <span class="math">\\alpha</span>  &ndash; as in the definition of the d-PKE assumption.</p>

    <p class="text-gray-300">Hence,  <span class="math">G_2</span>  and  <span class="math">G_3</span>  are identical up to  <span class="math">Bad_3</span> , i.e.,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathsf{G}_2] - \\Pr[\\mathsf{G}_3]| \\leq \\Pr[\\mathsf{Bad}_3]</span>$</p>

    <p class="text-gray-300">and it is easy to see that the d-PKE assumption immediately implies that the probability of  <span class="math">\\mathsf{Bad}_3</span>  (i.e., that the extractor outputs a polynomial which is not a correct one) is negligible.</p>

    <p class="text-gray-300">Game  <span class="math">G_4</span> : This game proceeds as  <span class="math">G_3</span>  except for the following change in the <strong>Ver</strong> procedure. Assume that the equation (1) is satisfied and that  <span class="math">\\mathsf{bad}_3 \\leftarrow \\mathsf{true}</span>  is not set (i.e.,  <span class="math">\\pi_\\sigma = \\tilde{a}_\\sigma(\\tau) \\rho_{\\mathsf{a}} \\mathcal{P}_1</span>  holds). Then, compute the polynomials  <span class="math">a_\\sigma^*(X) = \\sum_{k \\in I_\\sigma} x_k a_k(X)</span>  and  <span class="math">\\delta_{\\mathsf{a}}(X) = \\tilde{a}_\\sigma(X) - a_\\sigma^*(X)</span> , where  <span class="math">\\tilde{a}_\\sigma(X)</span>  is the polynomial obtained from the extractor. If  <span class="math">\\delta_{\\mathsf{a}}(X)</span>  is not divisible by z(X) then set  <span class="math">\\mathsf{bad}_4 \\leftarrow \\mathsf{true}</span> .</p>

    <p class="text-gray-300">Clearly,  <span class="math">G_3</span>  and  <span class="math">G_4</span>  are identical up to  <span class="math">Bad_4</span> , i.e.,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathsf{G}_3] - \\Pr[\\mathsf{G}_4]| \\le \\Pr[\\mathsf{Bad}_4]</span>$</p>

    <p class="text-gray-300">To show that the two games are negligibly close, we prove in Lemma 3 that  <span class="math">\\Pr[\\mathsf{Bad}_4]</span>  is negligible under the q-DHE assumption, for some q=2d+1.</p>

    <p class="text-gray-300">Finally, we observe that at this point, if  <span class="math">\\mathsf{Bad}_4</span>  does not occur, we have verified that  <span class="math">\\pi_\\sigma</span>  was computed by using the correct (i.e., authenticated) statement values. Namely, except for having a randomized element  <span class="math">\\pi_\\sigma</span> , we are almost in the same conditions for breaking the proof of knowledge of PGHR. In fact, in Lemma 4 we show that if any adversary has advantage at most  <span class="math">\\epsilon</span>  in breaking the adaptive proof of knowledge of PGHR, then  <span class="math">\\Pr[\\mathsf{G}_4] \\leq Q \\cdot \\epsilon</span> , where Q is the number of <strong>Gen</strong> queries made by the adversary.</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold">Lemma 2. <span class="math">\\Pr[\\mathsf{Bad}_2] \\leq Q/(p-Q)</span> .</h2>

    <p class="text-gray-300"><em>Proof.</em> Let Q be the number of verification queries made by the adversary in  <span class="math">G_2</span> , and let  <span class="math">B_i</span>  be the event that  <span class="math">bad_2</span>  is first set from false to true in the i-th verification query. Clearly, we have:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{Bad}_2] = \\Pr\\Big[\\bigvee_{i=1}^Q \\mathsf{B}_i\\Big] \\leq \\sum_{i=1}^Q \\Pr[\\mathsf{B}_i]</span>$</p>

    <p class="text-gray-300">To prove the lemma we will bound the probability  <span class="math">\\Pr[B_i]</span>  for any  <span class="math">1 \\leq i \\leq Q</span> , where the probability is taken over the random choices of the function  <span class="math">\\mathcal{R}(\\cdot)</span> .</p>

    <p class="text-gray-300">By definition of  <span class="math">B_i</span>  we have  <span class="math">\\Pr[B_i] = \\Pr[B_i | \\overline{B}_1 \\wedge \\cdots \\wedge \\overline{B}_{i-1}]</span> . Also, observe that  <span class="math">\\mathsf{bad}_2</span>  is set to true if  <span class="math">\\exists k \\in I_\\sigma</span>  such that  <span class="math">(\\mathsf{L}_k, \\cdot) \\notin \\mathsf{T}</span>  and the equation</p>

    <p class="text-gray-300">
<span class="math">$\\pi_{\\mu} = \\left[ \\sum_{k \\in I_{\\sigma}} \\mathcal{R}(\\mathsf{L}_{k}) A_{k} \\right] + \\kappa \\cdot \\pi_{\\sigma} \\tag{2}</span>$</p>

    <p class="text-gray-300">is satisfied.</p>

    <p class="text-gray-300">Let us fix one such index  <span class="math">\\bar{k} \\in I_{\\sigma}</span>  such that  <span class="math">(\\mathsf{L}_{\\bar{k}}, \\cdot) \\notin \\mathsf{T}</span> . If  <span class="math">\\phi_{\\bar{k}} = \\mathcal{R}(\\mathsf{L}_{\\bar{k}})</span>  is sampled uniformly at random in the <em>i</em>-th query, then the equation above will be satisfied with probability 1/p. However, the adversary might have asked  <span class="math">\\mathsf{L}_{\\bar{k}}</span>  in some previous verification query, and such a query might have leaked some information about  <span class="math">\\phi_{\\bar{k}} = \\mathcal{R}(\\mathsf{L}_{\\bar{k}})</span> . Yet, since it holds  <span class="math">\\bar{\\mathsf{B}}_1 \\wedge \\cdots \\wedge \\bar{\\mathsf{B}}_{i-1}</span> , the only information leaked to the adversary is that a bunch of equations involving  <span class="math">\\phi_{\\bar{k}}</span>  were not satisfied. For each of these unsatisfied equations, one can exclude at most one possible value of  <span class="math">\\phi_{\\bar{k}}</span> . In conclusion, we have that in the <em>i</em>-th query, the equation (2) is satisfied with probability at most  <span class="math">\\frac{1}{p-(i-1)}</span> . Hence,</p>

    <p class="text-gray-300">
<span class="math">$\\Pr[\\mathsf{Bad}_2] \\le \\sum_{i=1}^Q \\frac{1}{p - (i-1)} \\le \\frac{Q}{p - Q}.</span>$</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> If the q-DHE assumption [CKS09] holds for  <span class="math">\\mathcal{G}</span> , we have that  <span class="math">Pr[\\mathsf{Bad}_4]</span>  is negligible for any PPT adversary  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Assume that there is an adversary  <span class="math">\\mathcal{A}</span>  such that  <span class="math">\\Pr[\\mathsf{Bad}_4] \\geq \\epsilon</span>  is non-negligible. We show how to build an adversary  <span class="math">\\mathcal{B}</span>  that breaks the q-DHE assumption with probability  <span class="math">\\epsilon/DQ - 1/|\\mathbb{F}|</span>  such that: (a)  <span class="math">D = \\mathsf{poly}(\\lambda)</span>  is an upper bound on the number of multiplication gates (and thus the degree of the corresponding QAP) in the Q circuits  <span class="math">C_1, \\ldots, C_Q</span>  queried by  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathbf{Gen}</span> , and (b)  <span class="math">q = 2d^* + 1</span>  for some  <span class="math">d^* \\leq D</span> , which is the degree of the QAP in the circuit  <span class="math">C^*</span>  for which  <span class="math">\\mathsf{Bad}_4</span>  occurs.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  takes as input an instance of the q-DHE assumption (bgpp,  <span class="math">\\tau \\mathcal{P}_1, \\tau \\mathcal{P}_2, \\dots, \\tau^q \\mathcal{P}_1, \\tau^q \\mathcal{P}_2, \\tau^{q+2} \\mathcal{P}_1, \\tau^{q+2} \\mathcal{P}_2, \\dots, \\tau^{2q} \\mathcal{P}_1, \\tau^{2q} \\mathcal{P}_2)</span>  and its goal is to compute the missing element  <span class="math">\\tau^{q+1} \\mathcal{P}_1</span> . To do so,  <span class="math">\\mathcal{B}</span>  simulates  <span class="math">\\mathsf{G}_4</span>  to  <span class="math">\\mathcal{A}</span>  as described in the following. Assume that  <span class="math">\\mathsf{Bad}_4</span>  occurs for the circuit  <span class="math">C^*</span>  which is the j-th circuit queried to  <span class="math">\\mathsf{Gen}</span> .</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold">Game setup:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-\\mathcal{B}</span>  sets up the experiment for  <span class="math">\\mathcal{A}</span>  as in  <span class="math">\\mathsf{G}_4</span>  with the following modifications.</li>
      <li>It picks random  <span class="math">j^* \\leftarrow_{\\mathcal{R}} \\{1, \\dots, Q\\}, d^* \\leftarrow_{\\mathcal{R}} \\{1, \\dots, D\\}</span>  to guess the query's index of  <span class="math">C^*</span>  and its QAP's degree respectively.</li>
      <li><span class="math">\\mathcal{B}</span>  sets  <span class="math">q \\leftarrow 2d^* + 1</span> , and takes as input an instance (bgpp,  <span class="math">\\tau \\mathcal{P}_1, \\tau \\mathcal{P}_2, \\dots, \\tau^q \\mathcal{P}_1, \\tau^q \\mathcal{P}_2, \\tau^{q+2} \\mathcal{P}_1, \\tau^{q+2} \\mathcal{P}_2, \\dots, \\tau^{2q} \\mathcal{P}_1, \\tau^{2q} \\mathcal{P}_2)</span>  of the q-DHE assumption.</li>
      <li>It defines the degree- <span class="math">d^*</span>  polynomial  <span class="math">z^*(X) = \\prod_{k=1}^{d^*} (X r_k)</span>  where  <span class="math">\\{r_k\\}</span>  is a set of canonical roots used to build the QAP.<sup>10</sup></li>
      <li><span class="math">-\\mathcal{B}</span>  chooses  <span class="math">\\kappa^*(X)</span>  as a random polynomial in  <span class="math">\\mathbb{F}[X]</span>  of degree  <span class="math">d^*+1</span>  such that the polynomial  <span class="math">\\kappa^*(X) z^*(X)</span>  of degree  <span class="math">2d^*+1</span>  has a zero coefficient in front of  <span class="math">X^{d^*+1}</span> .</li>
      <li><span class="math">\\mathcal{B}</span>  simulates the secret  <span class="math">\\kappa</span>  with  <span class="math">\\kappa^*(\\tau)</span>  by computing  <span class="math">K_j = \\kappa^*(\\tau)\\mathcal{P}_j</span> , for j = 1, 2. Observe that  <span class="math">\\kappa^*(\\tau)\\mathcal{P}_j</span>  can be computed efficiently using  <span class="math">\\{\\tau^i\\mathcal{P}_j\\}_{i=0}^{d^*+1}</span>  contained in the q-DHE instance.</li>
      <li><span class="math">\\mathcal{B}</span>  generates a key pair  <span class="math">(\\mathsf{sk&#x27;}, \\mathsf{vk&#x27;}) \\leftarrow_{\\mathcal{R}} \\Sigma.\\mathsf{KG}(1^{\\lambda})</span>  for the regular signature scheme and gives to the adversary  <span class="math">\\mathsf{pap} = (\\mathsf{pp}, \\mathsf{prfpp}, K_1, K_2)</span>  and  <span class="math">\\mathsf{vk} = (\\mathsf{vk&#x27;}, K_2)</span> .</li>
    </ul>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6"><span class="math">\\mathbf{Gen}(C)</span></h4>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  proceeds as follows to simulate the <em>i</em>-th query.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[Case  <span class="math">i \\neq j^*</span> ]  <span class="math">\\mathcal{B}</span>  runs the real  <span class="math">\\mathsf{Gen}(\\mathsf{pap}, C)</span>  algorithm and returns its output.</li>
      <li>[Case  <span class="math">i = j^*</span> ] Let us call  <span class="math">C^*</span>  the queried circuit.  <span class="math">\\mathcal{B}</span>  simulates the answer to this query as follows. First, it builds the QAP for  <span class="math">C^*</span>  and if its degree d is not the  <span class="math">d^*</span>  guessed earlier, then  <span class="math">\\mathcal{B}</span>  aborts the simulation. Otherwise, we have  <span class="math">d = d^*</span>  and hence  <span class="math">z(X) = z^*(X)</span>  and  <span class="math">\\mathcal{B}</span>  can proceed as follows. For the value  <span class="math">\\tau</span> , instead of randomly choosing it,  <span class="math">\\mathcal{B}</span>  implicitly uses the same value  <span class="math">\\tau</span>  from the q-DHE assumption. Namely,  <span class="math">\\mathcal{B}</span>  implicitly sets  <span class="math">\\rho_{\\mathsf{a}} = \\rho&#x27;_{\\mathsf{a}} \\tau^{d+1}</span>  and  <span class="math">\\rho_{\\mathsf{c}} = \\rho&#x27;_{\\mathsf{a}} \\rho_{\\mathsf{b}} \\tau^{d+1} \\rho_{\\mathsf{a}} \\rho_{\\mathsf{b}}</span> , where  <span class="math">\\rho&#x27;_{\\mathsf{a}}</span> ,  <span class="math">\\rho_{\\mathsf{b}} \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> , by computing, for  <span class="math">k = 0, \\ldots, m</span> :</li>
    </ul>

    <p class="text-gray-300"><span class="math">$A_k = \\tau^{d+1} a_k(\\tau) \\rho_{\\mathsf{a}}&#x27; \\, \\mathcal{P}_1, \\quad C_k = \\tau^{d+1} c_k(\\tau) \\rho_{\\mathsf{a}}&#x27; \\rho_{\\mathsf{b}} \\, \\mathcal{P}_1, \\quad A_{m+1} = \\tau^{d+1} z(\\tau) \\rho_{\\mathsf{a}}&#x27; \\, \\mathcal{P}_1, \\quad C_{m+3} = \\tau^{d+1} z(\\tau) \\rho_{\\mathsf{a}}&#x27; \\rho_{\\mathsf{b}} \\, \\mathcal{P}_1.</span>$</p>

    <p class="text-gray-300">Notice that these values can be computed efficiently since all the polynomials  <span class="math">\\tau^{d+1} a_k(\\tau)</span>  and  <span class="math">\\tau^{d+1} c_k(\\tau)</span>  have degree at most  <span class="math">2d^* &lt; q</span> , while  <span class="math">\\tau^{d+1} z(\\tau)</span>  has degree  <span class="math">2d^* + 1 = q</span> . Similarly, all the remaining values  <span class="math">\\{B_k\\}</span>  can be simulated as the degree of the polynomials encoded in the exponent is at most  <span class="math">d^* &lt; q</span> . The simulation of the remaining elements  <span class="math">Z, A&#x27;_k, B&#x27;_k, C&#x27;_k, E_k</span>  can be done in a very similar way.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;10</sup> The roots of the QAP target polynomial can be chosen arbitrarily.</p>

    <p class="text-gray-300">Finally,  <span class="math">K_{\\mathsf{a}} = (A_{m+1})^{\\kappa}</span>  is simulated by computing  <span class="math">\\rho&#x27;_{\\mathsf{a}}(\\tau^{d+1} \\kappa^*(\\tau) z(\\tau) \\mathcal{P}_1)</span> . In particular, note that  <span class="math">(\\tau^{d+1} \\kappa^*(\\tau) z(\\tau) \\mathcal{P}_1</span>  can be computed since  <span class="math">\\tau^{d+1} \\kappa^*(\\tau) z(\\tau)</span>  has degree 3d+2 and has a zero coefficient in front of  <span class="math">\\tau^{2d+2} = \\tau^{q+1}</span> , by construction of  <span class="math">\\kappa^*(X)</span> .</p>

    <h2 id="sec-misc-4" class="text-2xl font-bold"><span class="math">\\mathbf{Auth}(\\mathsf{L},x)</span></h2>

    <p class="text-gray-300">To simulate authentication queries,  <span class="math">\\mathcal{B}</span>  samples a random  <span class="math">\\mu \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> , computes  <span class="math">\\Phi = \\mu \\mathcal{P}_2 - x K_2</span> , generates  <span class="math">\\sigma&#x27; \\leftarrow_{\\mathcal{R}} \\Sigma.\\mathsf{Sign}(\\mathsf{sk}&#x27;, \\Phi | \\mathsf{L})</span> , updates  <span class="math">\\mathsf{T} \\leftarrow \\mathsf{T} \\cup \\{(\\mathsf{L}, x)\\}</span> , and returns  <span class="math">\\sigma = (\\mu, \\Phi, \\sigma&#x27;)</span> . Observe that such  <span class="math">\\sigma</span>  is identically distributed as an authentication tag returned by <strong>Auth</strong> in  <span class="math">\\mathsf{G}_4</span> . Also, although  <span class="math">\\mathcal{B}</span>  is not explicitly generating  <span class="math">\\phi \\leftarrow \\mathcal{R}(\\mathsf{L})</span> , as one can notice, these values are no longer used to answer the verification queries.</p>

    <p class="text-gray-300">Finally, we describe how  <span class="math">\\mathcal{B}</span>  handles verification queries. First, note that for those queries that fall in the Type 1 branch,  <span class="math">\\mathcal{B}</span>  can directly answer  <span class="math">\\bot</span>  (reject), and it does not have to use the values  <span class="math">\\mathcal{R}(\\mathsf{L})</span> . Clearly, due to definition of game  <span class="math">\\mathsf{G}_4</span>  and since  <span class="math">\\mathsf{Bad}_2</span>  does not occur, answers to these queries are correctly distributed. Second, for queries in the Type 2 branch, we distinguish two cases according to whether the queried circuit C is  <span class="math">C^*</span>  or not.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">C \\neq C^*</span> , then  <span class="math">\\mathcal{B}</span>  can answer as is done in game  <span class="math">\\mathsf{G}_4</span> . In particular, note that equation  <span class="math">(A.1)^{secret}</span>  has been replaced by equation (1) that requires only public values to be checked.</li>
      <li>If  <span class="math">C = C^*</span> , then  <span class="math">\\mathcal{B}</span>  proceeds as in  <span class="math">\\mathsf{G}_4</span> . First, set  <span class="math">\\delta_{\\mathsf{a}}(X) = \\tilde{a}_{\\sigma}(X) a_{\\sigma}^*(X)</span> . Now, since we assume that  <span class="math">\\mathsf{Bad}_4</span>  occurs in the experiment, this means that  <span class="math">\\delta_{\\mathsf{a}}(X)</span>  is not divisible by  <span class="math">z^*(X)</span> , i.e.,  <span class="math">\\delta_{\\mathsf{a}} \\notin Span(z^*(X))</span> . Then  <span class="math">\\mathcal{B}</span>  checks whether  <span class="math">\\omega(X) = \\delta_{\\mathsf{a}}(X)\\kappa^*(X)</span>  is such that its coefficient  <span class="math">\\omega_{d+1}</span>  is zero. If so,  <span class="math">\\mathcal{B}</span>  aborts the simulation (however, by Lemma 10 [GGPR13], this happens with probability at most  <span class="math">1/|\\mathbb{F}|</span> ). Otherwise, if  <span class="math">\\omega_{d+1} \\neq 0</span> ,  <span class="math">\\mathcal{B}</span>  returns</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\Omega = (\\omega_{d+1} \\, \\rho_{\\mathsf{a}}&#x27;)^{-1} \\left[ \\pi_{\\mu} - \\pi_{\\mu}^* - \\sum_{k=0, k \\neq d+1}^{2d+1} \\rho_{\\mathsf{a}}&#x27; \\omega_k (\\tau^{k+d+1} \\mathcal{P}_1) \\right]</span>$</p>

    <p class="text-gray-300">Notice that  <span class="math">\\mathcal{B}</span> 's simulation to  <span class="math">\\mathcal{A}</span>  is perfect except if  <span class="math">\\mathcal{B}</span>  aborts. However,  <span class="math">\\mathcal{B}</span>  can abort only in three cases: if its guess on  <span class="math">j^*</span>  is wrong, i.e., if  <span class="math">j \\neq j^*</span>  (which happens with probability 1 - 1/Q); if its guess on  <span class="math">d^*</span>  is wrong, i.e., if  <span class="math">d \\neq d^*</span>  (which happens with probability 1 - 1/D); if  <span class="math">\\omega_{d+1} = 0</span>  (which holds unconditionally with probability at most  <span class="math">1/|\\mathbb{F}|</span> ). Also, it is not hard to see that if  <span class="math">\\mathsf{Bad}_4</span>  occurs, then  <span class="math">\\mathcal{B}</span>  returns</p>

    <p class="text-gray-300">$$\\Omega = (\\omega_{d+1} , \\rho_{\\mathsf{a}}')^{-1} \\left[ \\kappa(\\pi_{\\sigma} - \\pi_{\\sigma}^{<em>}) - \\sum_{k=0, k \\neq d+1}^{2d+1} \\rho_{\\mathsf{a}}' \\omega_{k} (\\tau^{k+d+1} \\mathcal{P}_{1}) \\right] \\
= (\\omega_{d+1} , \\rho_{\\mathsf{a}}')^{-1} \\left[ \\rho_{\\mathsf{a}}' \\tau^{d+1} \\delta_{\\mathsf{a}}(\\tau) \\kappa^{</em>}(\\tau) \\mathcal{P}<em>{1} - \\sum</em>{k=0, k \\neq d+1}^{2d+1} \\rho_{\\mathsf{a}}' \\omega_{k} (\\tau^{k+d+1} \\mathcal{P}<em>{1}) \\right] \\
= (\\omega</em>{d+1} , \\rho_{\\mathsf{a}}')^{-1} \\left[ \\rho_{\\mathsf{a}}' \\tau^{d+1} \\omega(\\tau) - \\rho_{\\mathsf{a}}' \\tau^{d+1} (\\omega(\\tau) - \\omega_{d+1} \\tau^{d+1}) \\right] \\mathcal{P}<em>{1} \\
= (\\omega</em>{d+1} , \\rho_{\\mathsf{a}}')^{-1} \\left[ \\rho_{\\mathsf{a}}' \\tau^{d+1} \\omega_{d+1} \\tau^{d+1} \\right] \\mathcal{P}<em>{1} \\
= \\tau^{2d+2} , \\mathcal{P}</em>{1}$$</p>

    <p class="text-gray-300">and breaks the q-DHE assumption, as desired.</p>

    <p class="text-gray-300">Therefore, by putting together the probability that  <span class="math">\\mathcal{B}</span>  does not abort, with our assumption that  <span class="math">\\Pr[\\mathsf{Bad}_4] \\geq \\epsilon</span> , then we obtain that  <span class="math">\\mathcal{B}</span>  breaks the q-DHE assumption with probability  <span class="math">\\geq \\epsilon/DQ-1/|\\mathbb{F}|</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> If PGHR satisfies adaptive proof of knowledge, and the q-PKE assumption holds, then for any PPT adversary  <span class="math">\\mathcal A</span>  we have that  <span class="math">\\Pr[\\mathsf G_4]</span>  is negligible.</p>

    <p class="text-gray-300"><em>Proof.</em> Assume by contradiction that there exists an adversary  <span class="math">\\mathcal{A}</span>  such that  <span class="math">\\Pr[\\mathsf{G}_4] \\geq \\epsilon</span>  is non-negligible. We show how to build an adversary  <span class="math">\\mathcal{B}</span>  that breaks the security of PGHR with probability at least  <span class="math">\\epsilon/Q_1Q_2</span> , where  <span class="math">Q_1</span>  is the number of circuits  <span class="math">C_1,\\ldots,C_{Q_1}</span>  queried by  <span class="math">\\mathcal{A}</span>  to <strong>Gen</strong> during game  <span class="math">\\mathsf{G}_4</span> , and  <span class="math">Q_2</span>  is the number of verification queries. Without loss of generality, assume that  <span class="math">\\mathcal{B}</span>  receives the parameters bgpp of the bilinear groups before choosing the circuit  <span class="math">C^*</span>  to attack.<sup>11</sup></p>

    <h2 id="sec-misc-5" class="text-2xl font-bold">Game setup:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-\\mathcal{B}</span>  picks a random  <span class="math">j^* \\leftarrow_{\\mathcal{R}} \\{1, \\dots, Q_1\\}</span>  to guess the query's index of  <span class="math">C^*</span> , the circuit for which  <span class="math">\\mathcal{A}</span>  will break the security of our ADSNARK scheme in game  <span class="math">\\mathsf{G}_4</span> .</li>
      <li><span class="math">\\mathcal{B}</span>  generates a key pair  <span class="math">(\\mathsf{sk}&#x27;, \\mathsf{vk}&#x27;) \\leftarrow_{\\mathcal{R}} \\Sigma.\\mathsf{KG}(1^{\\lambda})</span>  for the regular signature scheme, and then samples a random  <span class="math">\\kappa \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> . It gives to  <span class="math">\\mathcal{A}</span>  pap =  <span class="math">(\\mathsf{bgpp}, \\mathsf{prfpp}, K_1 = \\kappa \\mathcal{P}_1, K_2 = \\kappa \\mathcal{P}_2)</span>  and  <span class="math">\\mathsf{vk} = (\\mathsf{vk}&#x27;, K_2)</span> .</li>
    </ul>

    <h2 id="sec-misc-6" class="text-2xl font-bold"><span class="math">\\mathbf{Gen}(C)</span></h2>

    <p class="text-gray-300"><span class="math">\\overline{\\mathcal{B}}</span>  proceeds as follows to simulate the <em>i</em>-th generation query.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[Case  <span class="math">i \\neq j^*</span> ]  <span class="math">\\mathcal{B}</span>  runs the real  <span class="math">\\mathsf{Gen}(\\mathsf{pap},C)</span>  algorithm and returns its output.</li>
      <li>[Case  <span class="math">i=j^*</span> ] Let us call  <span class="math">C^*</span>  the queried circuit.  <span class="math">\\mathcal B</span>  forwards  <span class="math">C^*</span>  to its challenger and receives a pair of keys  <span class="math">(\\mathsf{VK}_P^*,\\mathsf{EK}_P^*)</span>  of the PGHR scheme.  <span class="math">\\mathcal B</span>  then uses  <span class="math">\\kappa</span>  to compute  <span class="math">K_{\\mathsf a}=\\kappa\\,A_{m+1}</span> , sets the key pair of the ADSNARK scheme to  <span class="math">(\\mathsf{VK}^*,\\mathsf{EK}^*)</span> , where  <span class="math">\\mathsf{VK}^*=\\mathsf{VK}_P^*</span>  and  <span class="math">\\mathsf{EK}^*</span>  consists of  <span class="math">\\mathsf{EK}_P^*</span>  and the additional value  <span class="math">K_{\\mathsf a}</span> .</li>
    </ul>

    <h2 id="sec-misc-7" class="text-2xl font-bold">Auth(L, x)</h2>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  runs  <span class="math">\\mathbf{Auth}</span>  as in  <span class="math">\\mathsf{G}_4</span> , i.e.,  <span class="math">\\mathcal{B}</span>  outputs  <span class="math">\\sigma = (\\mu = \\mathcal{R}(\\mathsf{L}) + \\kappa x, \\Phi = \\mathcal{R}(\\mathsf{L})\\mathcal{P}_2, \\sigma&#x27; = \\Sigma.\\mathsf{Sign}(\\mathsf{sk}&#x27;, \\Phi|\\mathsf{L}))</span> .</p>

    <p class="text-gray-300">Finally, we describe how  <span class="math">\\mathcal{B}</span>  simulates verification queries to  <span class="math">\\mathcal{A}</span> . Notice that all the equation checks require only public values. Also, observe that in  <span class="math">\\mathsf{G}_4</span>  the adversary  <span class="math">\\mathcal{A}</span>  can win only by returning a Type 2 forgery, and by returning a proof  <span class="math">\\pi</span>  containing values  <span class="math">\\pi_{\\sigma}, \\pi&#x27;_{\\sigma}</span>  of the &quot;correct form&quot;, i.e.,  <span class="math">\\pi_{\\sigma} = (a^*_{\\sigma}(\\tau) + \\delta^{\\sigma}_{\\mathsf{a}} z(\\tau))\\rho_{\\mathsf{a}} \\mathcal{P}_1</span>  and  <span class="math">\\pi&#x27;_{\\sigma} = (a^*_{\\sigma}(\\tau) + \\delta^{\\sigma}_{\\mathsf{a}} z(\\tau))\\rho_{\\mathsf{a}} \\alpha_{\\mathsf{a}} \\mathcal{P}_1 = \\alpha_{\\mathsf{a}} \\pi_{\\sigma}</span>  respectively, for some  <span class="math">\\delta^{\\sigma}_{\\mathsf{a}} \\in \\mathbb{F}</span> . So, for every verification query that passes the verification checks and that involves the circuit  <span class="math">C^*</span> ,  <span class="math">\\mathcal{B}</span>  translates the given proof  <span class="math">\\pi</span>  into a proof  <span class="math">\\pi_P</span>  as described below.</p>

    <p class="text-gray-300">Translation of  <span class="math">\\pi</span>  to  <span class="math">\\pi_P</span> . Let  <span class="math">\\pi = (\\pi_\\mu, \\pi_\\sigma, \\pi&#x27;_\\sigma, \\pi_{mid}, \\pi&#x27;_{mid}, \\pi_b, \\pi&#x27;_b, \\pi_c, \\pi&#x27;_c, \\pi_E, H)</span> . First,  <span class="math">\\mathcal{B}</span>  computes  <span class="math">\\hat{\\pi}_{mid} = \\pi_{mid} + (\\pi_\\sigma - \\pi^*_\\sigma)</span>  and  <span class="math">\\hat{\\pi}&#x27;_{mid} = \\pi&#x27;_{mid} + (\\pi&#x27;_\\sigma - \\pi&#x27;^*_\\sigma)</span> , where  <span class="math">\\pi^*_\\sigma = \\langle \\vec{x}, \\vec{A} \\rangle_{I_\\sigma}</span>  and  <span class="math">\\pi&#x27;^*_\\sigma = \\langle \\vec{x}, \\vec{A}&#x27; \\rangle_{I_\\sigma}</span> . Then,  <span class="math">\\mathcal{B}</span>  computes  <span class="math">\\hat{\\pi}_E = \\pi_E + \\delta^\\sigma_{\\mathsf{a}} E_{m+1}</span>  where  <span class="math">\\delta^\\sigma_{\\mathsf{a}} = (\\tilde{a}_\\sigma(X) - a^*_\\sigma(X))/z(X)</span> . Next,  <span class="math">\\mathcal{B}</span>  changes the (accepting) proof  <span class="math">\\pi</span>  produced by  <span class="math">\\mathcal{A}</span>  by: replacing  <span class="math">\\pi_{mid}</span> ,  <span class="math">\\pi&#x27;_{mid}</span>  and  <span class="math">\\pi_E</span>  with the values  <span class="math">\\hat{\\pi}_{mid}</span> ,  <span class="math">\\hat{\\pi}&#x27;_{mid}</span>  and  <span class="math">\\hat{\\pi}_E</span>  (as computed above) respectively; removing  <span class="math">\\pi_\\sigma</span> ,  <span class="math">\\pi&#x27;_\\sigma</span> ,  <span class="math">\\pi_\\mu</span> . Let  <span class="math">\\pi_P</span>  be such modified proof.  <span class="math">\\mathcal{B}</span>  stores the tuple  <span class="math">(\\{x_k\\}_{k\\in\\mathcal{I}_x}, \\pi_P)</span>  into a list  <span class="math">\\Omega</span> .</p>

    <p class="text-gray-300">First, observe that the proof  <span class="math">\\pi_P</span>  is identical to a proof in the scheme PGHR, and in particular it has the same distribution. Second, we claim that if  <span class="math">\\pi</span>  is accepted in  <span class="math">G_4</span>  for the circuit  <span class="math">C^*</span>  and labels</p>

    <p class="text-gray-300">We note that this reduction to the security of PGHR is done for ease of exposition. Indeed, we could have included in our simulator  <span class="math">\\mathcal{B}</span>  the same code of the simulator in the security proof of the PGHR scheme, where the parameters of the bilinear groups are received at the very beginning.</p>

    <p class="text-gray-300"><span class="math">\\{\\mathsf{L}_k\\}_{k\\in\\mathcal{I}_\\sigma}</span>  (used to authenticate  <span class="math">\\{x_k\\}_{k\\in\\mathcal{I}_\\sigma}</span> ), then  <span class="math">\\pi_P</span>  is accepted for statement  <span class="math">\\{x_k\\}_{k\\in\\mathcal{I}_x}</span>  in the given instance of the PGHR scheme for circuit  <span class="math">C^*</span> .</p>

    <p class="text-gray-300">The first claim follows by inspection and by observing that since  <span class="math">\\mathsf{Bad}_4</span>  does not occur, the value  <span class="math">(\\pi_\\sigma - \\pi_\\sigma^*)</span>  contains a multiple of  <span class="math">z(\\tau)</span> , i.e., the correct form of  <span class="math">\\pi_{mid}</span>  is preserved. In particular, the value  <span class="math">\\delta_{\\mathsf{a}}^\\sigma</span>  is a scalar value since  <span class="math">(\\tilde{a}_\\sigma(X) - a_\\sigma^*(X))</span>  is divisible by z(X) which has degree d, and  <span class="math">\\deg(\\tilde{a}_\\sigma(X)), \\deg(a_\\sigma^*(X)) \\leq d</span> .</p>

    <p class="text-gray-300">The second claim follows from the fact that the value  <span class="math">A = \\pi_{\\sigma} + A_{\\star} + \\pi_{mid}</span>  computed to verify the proof  <span class="math">\\pi</span>  in the ADSNARK scheme, and the value  <span class="math">A_P = \\langle \\overrightarrow{x}, \\overrightarrow{A} \\rangle_{[0,n]} + \\hat{\\pi}_{mid}</span>  computed to verify the proof  <span class="math">\\pi_P</span>  in PGHR are identical &ndash; as  <span class="math">\\hat{\\pi}_{mid} = \\pi_{mid} + (\\pi_{\\sigma} - \\pi_{\\sigma}^*)</span> . Since Bad<sub>4</sub> does not occur, the value  <span class="math">\\delta_{\\mathsf{a}}^{(\\sigma)}</span>  is exactly the coefficient used by  <span class="math">\\mathcal{A}</span>  for the randomization of  <span class="math">\\pi_{\\sigma}</span> .</p>

    <p class="text-gray-300">After  <span class="math">\\mathcal{A}</span>  stops running,  <span class="math">\\mathcal{B}</span>  picks a random tuple  <span class="math">(\\{x_k\\}_{k\\in\\mathcal{I}_x}, \\pi_P)</span>  from the list  <span class="math">\\Omega</span>  (which contains at most  <span class="math">Q_2</span>  elements) and returns this tuple to its challenger.</p>

    <p class="text-gray-300">To complete the proof we analyze  <span class="math">\\mathcal{B}</span> 's success probability. We claim that if  <span class="math">\\mathcal{A}</span>  breaks the security of the ADSNARK scheme in game  <span class="math">\\mathsf{G}_4</span> , then  <span class="math">\\mathcal{B}</span>  breaks the adaptive proof of knowledge property of PGHR with probability at least  <span class="math">1/Q_1Q_2</span> . It is not hard to see that  <span class="math">\\mathcal{B}</span> 's simulation has a distribution which is statistically close to the distribution of game  <span class="math">\\mathsf{G}_4</span> . Also, if  <span class="math">\\mathcal{A}</span>  breaks the scheme it means that for at least one of its verification queries that accepts, say the  <span class="math">\\ell</span> -th query, we have that  <span class="math">x \\notin \\mathcal{R}_C</span> . Assume that C was the j-th circuit queried to  <span class="math">\\mathsf{Gen}</span> , and that  <span class="math">\\mathcal{B}</span>  returns the  <span class="math">\\ell^*</span> -th tuple in the list  <span class="math">\\Omega</span> . Since the simulation does not leak any information on  <span class="math">j^*</span>  and  <span class="math">\\ell^*</span> , we have that  <span class="math">\\Pr[j^* = j \\land \\ell^* = \\ell] \\ge 1/Q_1Q_2</span> . Therefore, if  <span class="math">\\mathcal{A}</span>  breaks the security of the ADSNARK scheme in game  <span class="math">\\mathsf{G}_4</span>  with probability at least  <span class="math">\\epsilon</span> , then  <span class="math">\\mathcal{B}</span>  breaks the security of PGHR with probability  <span class="math">\\ge \\epsilon/Q_1Q_2</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300">Adaptive Proof of Knowledge with Public Verifiability. It is easy to adapt the proof of Theorem 4 in order to show that our scheme satisfies adaptive proof of knowledge even in the case where the proof is made publicly verifiable. Hence, it is possible to prove the following theorem:</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> If PGHR is a SNARK, F is a pseudorandom function,  <span class="math">\\Sigma</span>  is a secure signature scheme, the d-PKE [Gro10] and the q-DHE [CKS09] assumptions hold, then the scheme described above is a publicly-verifiable AD-SNARK with adaptive proof of knowledge.</p>

    <p class="text-gray-300">In the publicly verifiable case, since the adversary can verify the proofs on its own, we can assume that it makes a single verification query to <strong>Ver</strong>. To obtain the proof of Theorem 5, we use the same games as those for Theorem 4. The only difference is that the probability  <span class="math">\\Pr[\\mathsf{Bad}_2]</span>  is now shown to be negligible under the assumption that the regular signature scheme is secure. Such claim is rather straightforward: an adversary which returns a proof involving a statement value with label  <span class="math">\\mathsf{L}_k</span>  that had not been queried to the <strong>Auth</strong> oracle, has to show at least one signature  <span class="math">\\sigma&#x27;_k</span>  that verifies correctly for some non-queried label  <span class="math">\\mathsf{L}</span> .</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Proof of the Zero-Knowledge Property</h3>

    <p class="text-gray-300"><strong>Theorem 6.</strong> The ADSNARK scheme described in Section 4 is statistically zero-knowledge in the sense of Definition 6.</p>

    <p class="text-gray-300"><em>Proof.</em> To see that our scheme satisfies zero-knowledge, our first observation is that the group elements  <span class="math">\\pi_{\\sigma}</span> ,  <span class="math">\\pi_{mid}</span> , and  <span class="math">\\pi_{c}</span> , are statistically uniform over  <span class="math">\\mathbb{G}_{1}</span>  and the same holds for  <span class="math">\\pi_{b}</span>  over  <span class="math">\\mathbb{G}_{2}</span> . Indeed, as long as  <span class="math">z(\\tau) \\neq 0</span> , each of these elements is uniformly randomized.</p>

    <pre><code class="language-text">\\overline{\\mathsf{Sim}}_2(\\mathsf{td},\\mathsf{L},\\{x_i\\}_{\\mathsf{L}_i=\\star})
\\mathsf{Sim}_1(\\mathsf{pp}, C, \\mathsf{sk}, \\mathsf{vk}, \\mathsf{pap})
                                                                                                     let a_{\\star}(X) = a_0(X) + \\sum_{k \\in I_{\\star}} x_k a_k(X), \\{\\phi_k \\leftarrow \\mathsf{F}_S(\\mathsf{L}_k)\\}_{k \\in I_{\\sigma}}
\\overline{\\text{Run Gen}(pap, C)} to obtain
                                                                                                     Choose random a_{\\sigma}(X), a_{mid}(X) \\leftarrow_{\\mathcal{R}} \\mathbb{F}[X]
 (\\mathsf{EK}_C,\\mathsf{VK}_C) and also store
                                                                                                     a(X) \\leftarrow a_{\\sigma}(X) + a_{\\star}(X) + a_{mid}(X)
 \\mathsf{sk}, \\tau, \\beta, \\alpha_\\mathsf{a}, \\alpha_\\mathsf{b}, \\alpha_\\mathsf{c}, \\rho_\\mathsf{a}, \\rho_\\mathsf{b}, \\rho_\\mathsf{c} \\text{ in td}
                                                                                                     Choose random b(X), c(X) \\leftarrow_{\\mathcal{R}} \\mathbb{F}[X], such that z(Z) \\mid a(X)b(X) - c(X)
\\mathtt{Return}\\;(\\mathsf{EK}_C,\\mathsf{VK}_C,\\mathsf{td})
                                                                                                     h(X) \\leftarrow (a(X)b(X) - c(X))/z(X)
                                                                                                     \\pi_{\\mu} \\leftarrow \\langle \\phi, A \\rangle_{I_{\\sigma}} + \\rho_{\\mathsf{a}} a_{\\sigma}(\\tau) \\kappa \\mathcal{P}_{1}
                                                                                                                                                                                                        \\pi_{mid} \\leftarrow \\rho_{a} a_{mid}(\\tau) \\mathcal{P}_{1}, \\quad \\pi&#x27;_{mid} \\leftarrow \\alpha_{a} \\pi_{mid}
                                                                                                     \\pi_{\\sigma} \\leftarrow \\rho_{\\mathsf{a}} a_{\\sigma}(\\tau) \\mathcal{P}_1, \\ \\pi&#x27;_{\\sigma} \\leftarrow \\alpha_{\\mathsf{a}} \\pi_{\\sigma},
                                                                                                     \\pi_{\\mathsf{b}} \\leftarrow \\rho_{\\mathsf{b}} b(\\tau) \\mathcal{P}_2, \\quad \\pi&#x27;_{\\mathsf{b}} \\leftarrow \\alpha_{\\mathsf{b}} \\rho_{\\mathsf{b}} b(\\tau) \\mathcal{P}_1, \\quad \\pi_{\\mathsf{c}} \\leftarrow \\rho_{\\mathsf{c}} c(\\tau) \\mathcal{P}_1,
                                                                                                     \\pi_E \\leftarrow \\beta [\\pi_{\\sigma} + \\pi_{mid} + (\\rho_{\\mathsf{a}} a_{\\star}(\\tau) + \\rho_{\\mathsf{b}} b(\\tau)) \\mathcal{P}_1 + \\pi_{\\mathsf{c}}]
                                                                                                     H \\leftarrow h(\\tau)\\mathcal{P}_1
                                                                                                     Return \\pi = (\\pi_{\\mu}, \\pi_{\\sigma}, \\pi&#x27;_{\\sigma}, \\pi_{mid}, \\pi&#x27;_{mid}, \\pi_{b}, \\pi&#x27;_{b}, \\pi_{c}, \\pi&#x27;_{c}, \\pi_{E}, H)
</code></pre>

    <p class="text-gray-300">Figure 6. Simulator Sim.</p>

    <p class="text-gray-300">Second, we notice that once the elements  <span class="math">\\pi_{\\sigma}</span> ,  <span class="math">\\pi_{mid}</span> ,  <span class="math">\\pi_{b}</span> ,  <span class="math">\\pi_{c}</span> , are fixed, the values of all the remaining elements in  <span class="math">\\pi</span> , i.e.,  <span class="math">\\pi_{\\mu}</span> ,  <span class="math">\\pi&#x27;_{\\sigma}</span> ,  <span class="math">\\pi&#x27;_{mid}</span> ,  <span class="math">\\pi&#x27;_{b}</span> ,  <span class="math">\\pi&#x27;_{c}</span> ,  <span class="math">\\pi_{E}</span> , and H get determined according to the constraints of the verification equations (A.1), (A.2), (P.1), (P.2), (P.3).</p>

    <p class="text-gray-300">Finally, we show that there is a simulator  <span class="math">(\\mathsf{Sim}_1, \\mathsf{Sim}_2)</span> , formally described in Figure 6, that satisfies Definition 6. The simulated keys generated by  <span class="math">\\mathsf{Sim}_1</span>  are distributed as in the real experiment. Regarding  <span class="math">\\mathsf{Sim}_2</span> , it is not hard to see that the simulated values  <span class="math">\\pi_\\sigma</span> ,  <span class="math">\\pi_{mid}</span> ,  <span class="math">\\pi_{\\mathsf{b}}</span> ,  <span class="math">\\pi_{\\mathsf{c}}</span>  are statistically uniform. Also, given the trapdoor,  <span class="math">\\mathsf{Sim}_2</span>  can generate (without knowing inputs  <span class="math">\\{x_k\\}_{k\\in I_\\sigma}</span> ) all remaining elements of  <span class="math">\\pi</span>  with the correct distribution, i.e., such that verification equations (A.1), (A.2), (P.1), (P.2), (P.3) are satisfied.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Evaluation</h2>

    <p class="text-gray-300">We now describe our implementation of the ADSNARK scheme proposed in Section 4 and then present the experimental results we obtained to support the efficiency and practical applicability claims for our construction.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Implementation</h3>

    <p class="text-gray-300">We have implemented our ADSNARK scheme as an extension to the libsnark library<sup>12</sup> [BSCG<sup>+</sup>13, BSCTV14]. Our scheme extends the PGHR SNARK implementation offered by this library and supports the same class of statements expressed in the NP-complete language R1CS (rank-1 constraint systems), which is similar to arithmetic circuit satisfiability. The resulting implementation is totally generic, following the libsnark code writing policies, and can be instantiated with arbitrary digital signatures and PRF constructions (in addition to the various parameterization options already offered by the libsnark library). The source code is available upon request.</p>

    <p class="text-gray-300">The modifications to the original PGHR SNARK implementation required by our extensions were relatively small.<sup>13</sup> In the global parameter generation algorithm, the modifications were limited to one additional exponentiation. In the symmetric verification algorithm, we replaced the computations performed on the (known) inputs with (essentially equivalent) computations on the</p>

    <p class="text-gray-300"><sup>12</sup> https://github.com/scipr-lab/libsnark</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;13</sup> This would be expected from the theoretical description of our scheme, but praise should also go to the developers of the libsnark library, who produced a nice, modular and well documented implementation on which it was easy to build upon.</p>

    <p class="text-gray-300">corresponding authentication elements.<a href="#page-31-1">14</a> In the prover algorithm, the extra code comprises the three multi-exponentiations required to compute the extra authentication elements. Finally, our extensions are most visible in the public verification algorithm where, in addition to the digital signature verification operations, the number of pairings to be computed also increases linearly with the number of authenticated inputs. Our implementation strategy was to employ the optimizations available in the libsnark codebase whenever possible, taking advantage of the existing multi- and batch- exponentiation algorithms. The additional pairing computations required in public verification are performed two-by-two, exploiting the available double Miller loop optimization.</p>

    <p class="text-gray-300">For the extra cryptographic components required by our construction, i.e., the generic signature scheme and the PRF mapping labels to field elements, we have turned to the state-of-the-art implementations offered by the most recent version of the Supercop framework.<a href="#page-31-2">15</a> For the signature scheme, we have used the ed25519<a href="#page-31-3">16</a> implementation described in <a href="#page-37-13">[BDL</a>+12], which offers extremely fast batch verification that we incorporated in the ADSNARK public verification algorithm (recall that one signature per input must be verified). For the PRF implementation, we have fixed labels to be 128-bit binary strings and the PRF key to be a 256-bit string partitioned as two AES keys. The PRF construction uses one AES computation to map the input label to a 128-bit pseudorandom seed, applies an independent instance of AES in counter mode to expand the seed to 384 pseudorandom bits, and then uses modular reduction to obtain a pseudorandom 254-bit field element.<a href="#page-31-4">17</a> To select the best ed25519 and AES implementations, we have simply run Supercop on our target machine to exhaustively evaluate all available implementations, and then used the recommendations that this framework produced for the fastest implementations and corresponding compilation options.</p>

    <p class="text-gray-300">Microbenchmarks. All measurements were taken in a modest machine with two Dual-Core AMD Opteron 2218 processors clocked at 1 GHz, with 12 GB RAM. The reported values for every parameter correspond to the median of measurements computed over at least 100 runs. Following the original implementation of the libsnark library, we have equipped our implementation of the verification algorithm with the capability to perform part of the computation off-line. However, all our results pessimistically report the full verification time. The security level was set at 128-bits.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Experiments Setup</h3>

    <p class="text-gray-300">We have conducted experiments to carry out two types of performance evaluation: the first targeting general circuits, and the second focusing on a concrete application.</p>

    <p class="text-gray-300">General circuits. To obtain our first set of experimental results, we have relied on the libsnark functionality that permits generating random instances of constraint systems of arbitrary sizes. This allowed us to evaluate the performance of our protocol when dealing with proof goals corresponding to computations of growing complexity and with a varying number of inputs. Our goal here was to corroborate the theoretical analysis presented in Section <a href="#page-16-0">4,</a> by benchmarking our protocol</p>

    <p class="text-gray-300"><sup>14</sup> We deviate slightly from the original implementation in the way we store these input authentication elements. We use a simple (dense) vector representation as opposed to the more elaborate (sparse) map representation in the original. This originated a slight improvement in verification times in the experiments we conducted, but this is simply due to the fact that we did not explore more complex input handling scenarios, where our representation of inputs data might prove less adequate.</p>

    <p class="text-gray-300"><sup>15</sup> <a href="http://bench.cr.yp.to/supercop.html" target="_blank" rel="noopener noreferrer">http://bench.cr.yp.to/supercop.html</a></p>

    <p class="text-gray-300"><sup>16</sup> <a href="http://ed25519.cr.yp.to/" target="_blank" rel="noopener noreferrer">http://ed25519.cr.yp.to/</a></p>

    <p class="text-gray-300"><sup>17</sup> It is straightforward to prove that this construction yields a secure PRF, assuming that AES is itself a secure PRF.</p>

    <p class="text-gray-300">against both the original (unauthenticated) PGHR SNARK protocol and the generic AD-SNARK construction described in Section <a href="#page-14-0">3.2</a> instantiated with PGHR, that we call AD-PGHR.</p>

    <p class="text-gray-300">    <img src="_page_32_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">100 16.259</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">44.441</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16.269 19.600</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">56.349</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">19.558 0.017</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">0.017</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">0.014</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">0.073</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">250 16.312</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84.695</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.358 19.651</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">111.008</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.597 0.025</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.025</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.017</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.165</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">500 16.317</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">159.943</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.335 19.561</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">212.162</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.473 0.038</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.038</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.023</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.316</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">750 16.344</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">236.379</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.307 19.602</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">380.563</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.672 0.050</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.050</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.029</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.470</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 000 16.350</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">299.314</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.276 19.513</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">490.852</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.612 0.062</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.062</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.035</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.613</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proving Key Size (KBytes) Verification Key Size (KBytes)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proof size (Kbytes)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Proving Key Size (KBytes) Verification Key Size (KBytes)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Proof size (Kbytes)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Inputs PGHR AD-PGHR ADSNARK PGHR AD-PGHR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ADSNARK PGHR AD-PGHR ADSNARK SK ADSNARK PK</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100 15 650</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45 944</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15 657</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">250 15 640</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">91 885</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15 657</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">500 15 622</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">167 092</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15 657</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62.9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">750 15 605</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">250 459</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15 657</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 000 15 587</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">318 590</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15 657</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125.4</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 7. Experimental results showing generation, proving and verification times for random constraint systems of size 50K and varying number of inputs. For AD-PGHR, the number of multiplication gates is 50K + 1000 &times; #inputs. For ADSNARK in the public verification variant, the proof size is equal to the SNARK proof size plus the size of the authentication data, which is 128 bytes per input.</p>

    <p class="text-gray-300">We have arbitrarily fixed the complexity of the computation associated with the proof goal to involve 50K restrictions (or equivalent, roughly 50K multiplication gates), which typically corresponds to a computation of intermediate complexity according to the state of the art (see for example <a href="#page-38-4">[PGHR13]</a>). The concrete size of the computation is not important, since we will be concerned with the relative degradation of the performance of the various protocols, as we gradually increase the number of (possibly authenticated) inputs to the computation from 100 to 1000. For the generic construction AD-PGHR, we have (very optimistically) taken the penalty for including the signature verification circuit in the proof goal to be only of 1000 multiplications per signature. The fact that, in practice, the cost will probably be higher only strengthens our claims.</p>

    <p class="text-gray-300">Concrete Application. Our second set of experimental results targets a real-world scenario, where the security guarantees provided by an AD-SNARK are highly relevant: a concrete smart-metering application like the one described in the introduction. Analogous results can be obtained for similar applications such as the pay-as-you-drive insurance or the health risk assessment. Our goal here is to indeed demonstrate the practical applicability of our ADSNARK implementation and to show that the overhead incurred by the generic construction can be prohibitive in practice, as it may lead to a significant increase in the complexity of the proof goal. This is particularly true if the proof goal is reasonably simple to start with, as is the case in the application that follows.</p>

    <p class="text-gray-300">    <img src="_page_33_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Generation Time (seconds)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Proving Time (seconds)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verification Time (seconds)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Days Mgates AD-PGHR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ADSNARK AD-PGHR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ADSNARK AD-PGHR ADSNARK SK ADSNARK PK</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 641</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.929</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.262</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.760</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.622</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.013</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.013</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.042</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60 481</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">110.164</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.296</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">151.146</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.463</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.030</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.020</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.219</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14 120 961</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">214.457</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34.507</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">306.705</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.078</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.047</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.028</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.421</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21 181 441</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">213.647</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50.770</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">444.592</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.314</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.062</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.037</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.628</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28 241 921</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">431.341</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65.539</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">629.003</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.426</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.077</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.043</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.823</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Proving Key Size (KBytes) Verification Key Size (KBytes)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Proof size (Kbytes)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Days Mgates AD-PGHR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ADSNARK AD-PGHR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ADSNARK AD-PGHR ADSNARK SK ADSNARK PK</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 641</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17 463</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60 481</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">124 274</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17 641</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14 120 961</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">248 547</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35 282</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21 181 441</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">364 661</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52 923</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">126.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28 241 921</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">497 094</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">70 563</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">168.4</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 8. Experimental results showing generation, proving, and verification times for the smart metering application, with the number of measurements varying from 1 day to 28 days (with 48 measurements per day). For AD-PGHR, the number of multiplication gates is #Mgates + 1000 &times; #days &times; 48. For ADSNARK in the public verification variant, the proof size is equal that of the SNARK proof plus the size of the authentication data (128 bytes per input).</p>

    <p class="text-gray-300">We focus on the smart-metering application described in <a href="#page-38-0">[RD11,</a> <a href="#page-38-1">FKDL13]</a> where a (non-linear) cumulative price function is applied to the consumption measurements in order to determine the aggregated cost. The idea here is that the smart meter is able to authenticate the measurements, and that the client locally computes the monetary value corresponding to the measured consumption. The client can then use an AD-SNARK protocol to demonstrate to the supplier that the computation is correct and based on legitimate measurements, without divulging the details of the individual values. As a simple example of a cumulative policy <a href="#page-38-0">[RD11]</a>, one may think of a non-linear function defined by the following list of threshold/price pairs: [(0, 2),(3, 5),(7, 8)]. This policy establishes four consumption intervals and their corresponding prices, as follows: [0, 3] &rarr; 2, (3, 7] &rarr; 5, (7, &infin;) &rarr; 8. For a measured consumption of 9, the price due is 3 &times;2 + 4&times;5 + 2&times;8 = 42.</p>

    <p class="text-gray-300">In this application, the complexity of the price computation depends on both the number of measurements and the number of intervals prescribed by the cost function.</p>

    <p class="text-gray-300">We have implemented a generator of R1CS statements that, for a specified number of measurements and a concrete cumulative cost function, is able to construct a constraint system for an arithmetic circuit that checks the correctness of the computed cost, for any given set of measurements. The number of multiplication gates in (i.e., the number of constraints associated to) the resulting circuits is 36 <sup>&times;</sup> #measurements <sup>&times;</sup> #intervals + 1.<a href="#page-34-3">18</a> For the generic construction AD-PGHR, we have again used the estimate of 1000 additional multiplications per signature verification. We set the number of thresholds to 5 (a coarse level of granularity in specifying the non-linear policy) so that we obtain a moderately sized circuit even for a month's worth of readings. We then take the indicative value of 48 measurements per day, and vary the number of days separating the price computation to be 1, 7, 14, 21, and 28 days. The policy is defined by thresholds 5, 10, 15, 20, and 25. The measurement values were sampled at random in the range 0 to 100.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Performance for General Circuits</h3>

    <p class="text-gray-300"><a href="#page-32-0">Figure 7</a> shows the results we obtained in terms of execution time. It is clear from the graphs the rapid degradation of the global generation and proving times in the case of AD-PGHR. This is a direct consequence of increasing the size of the circuit and corresponding increase in the size of the proving key, which for 1000 inputs in AD-PGHR approaches 320 MB, as opposed to 15 MB for ADSNARK and PGHR. <a href="#page-34-4">19</a> The (relatively) small penalty payed for using public verification in ADSNARK is visible in the verification times. Furthermore, it is interesting to observe that the secret-key verification of ADSNARK is as fast as the one of AD-PGHR or the (unauthenticated) PGHR. The size of the proof is under 500 bytes for all protocols except the public verification version of AD-PGHR, where the authentication data takes an additional 128 bytes per input. Even so, for 1000 inputs, the proof size is under 126Kbytes.<a href="#page-34-5">20</a></p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Performance for Smart Metering Billing</h3>

    <p class="text-gray-300">Figure <a href="#page-33-0">8</a> shows the results we obtained in terms of execution time. It is clear from the graphs that ADSNARK yields proving times that are compatible with real-world deployment: even for one month's worth of measurements, the proving time is around 18 seconds, the proof size is under 0.5 KB for secret verification and under 170 KB for public verification. The contrast to AD-PGHR is evident, where the proof size is essentially the same as ADSNARK with secret verification, but the running time of the AD-PGHR's prover goes up to over 10 minutes. Moreover, even for a month's worth of readings, ADSNARK would pay little more time for public verification (around 0.8 seconds vs. 0.08 seconds of AD-PGHR). Although this may not be very important for smart-metering, it shows, once more, that the public verification time scales very well.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Further Related Work</h2>

    <p class="text-gray-300">As we mentioned earlier, our work extends the notion of succinct non-interactive arguments of knowledge (SNARKs) <a href="#page-38-8">[Mic94,</a> <a href="#page-37-9">BCCT12]</a>, which in turn build on (succinct) interactive proofs <a href="#page-38-3">[GMR89]</a> and interactive arguments <a href="#page-38-12">[Kil92,</a> <a href="#page-38-13">Kil95]</a>. In particular, we focus on the so-called preprocessing model where the verifier is required to run an expensive but re-usable key generation phase. In this preprocessing model, several works <a href="#page-38-10">[Gro10,</a> <a href="#page-38-14">Lip12,</a> <a href="#page-38-9">GGPR13,</a> <a href="#page-37-14">BCI</a>+13] proposed efficient realizations of SNARKs, and more recent works <a href="#page-38-4">[PGHR13,</a> <a href="#page-37-2">BSCG</a>+13, <a href="#page-37-3">BSCTV14]</a> have shown efficient,</p>

    <p class="text-gray-300"><sup>18</sup> The circuit implementation assumes that measurements and thresholds are represented as 32-bit integer values.</p>

    <p class="text-gray-300"><sup>19</sup> For PGHR and ADSNARK the variations in generation and proving times with the increasing number of inputs are barely visible due to the fact that the number of constraints in the circuit is fixed at 50K.</p>

    <p class="text-gray-300"><sup>20</sup> In our implementation each signature and public key takes 64 bytes, and the group element takes 64 bytes per input.</p>

    <p class="text-gray-300">highly-optimized, implementations that support general-purpose computations. These schemes can also support zero-knowledge proofs. It is worth mentioning that all known SNARKs are either in the random oracle model or rely on non-standard non-falsifiable assumptions [Nao03]. Assumptions from this class have been shown [GW11a] likely to be inherent for SNARKs for  <span class="math">\\mathcal{NP}</span> .</p>

    <p class="text-gray-300">The notion of SNARKs is also related to <em>verifiable computation</em> [GGP10], in which a (computationally weak) client delegates the computation of a function to a powerful server and wants to verify the result efficiently. As noted in previous work, by using SNARKs for  <span class="math">\\mathcal{NP}</span> , it is possible to construct a verifiable computation scheme, and several works [GGPR13, PGHR13, BSCG<sup>+</sup>13] indeed follow this approach. However, alternative approaches to realizing verifiable computation have been proposed, notably based on fully homomorphic encryption [GGP10, CKV10, AIK10] or attribute-based encryption [PRV12].</p>

    <p class="text-gray-300">Another line of work which is closely related to ours is the one on homomorphic authentication (comprising both homomorphic/malleable signatures [JMSW02, BF11, ABC+12, CKLM14] and MACs [GW13, CF13, BFR13]). The main idea of homomorphic authenticators is that, given a set of messages  <span class="math">(\\sigma_1, \\ldots, \\sigma_n)</span>  authenticated using a secret key sk, anyone can evaluate a program P on such authenticated messages in a way that the result  <span class="math">\\sigma \\leftarrow P(\\{\\sigma_i\\})</span>  is again authenticated with respect to the same key sk (or some public key vk in the case of signatures). Some works in this area [ABC+12, CKLM14] considered various privacy notions (called context-hiding) to model that signatures on the outputs of a computation should not reveal information about the inputs. In this sense, AD-SNARKs are closely related to the notion of multi-input malleable signatures [CKLM14]. However, to the best of our knowledge, none of these schemes achieves practical efficiency for arbitrary computations.</p>

    <p class="text-gray-300">The recent work  <span class="math">Z\\emptyset</span>  [FL14] aimed to combine the best of different zero-knowledge proof systems by doing an efficiency cost analysis to use the best one for every application. In particular,  <span class="math">Z\\emptyset</span>  relies on both ZQL and Pinocchio [PGHR13]. However, when using Pinocchio with authenticated data,  <span class="math">Z\\emptyset</span>  does not provide any guarantee on the integrity of this data, i.e., on the validity of the corresponding signatures.</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 More Applications</h2>

    <p class="text-gray-300">In this section we describe three more applications that fit our three-party model.</p>

    <p class="text-gray-300">Pay-as-you-drive Insurance. Similarly to the smart-metering scenario, a trusted black-box installed in the client's car collects information on the driving habits; the driver receives the information and needs to pay a premium to the insurance company according to the driving information (distances, speed, safety, etc.). For privacy, the driver may not want to reveal her personal driving habits to the insurance company. For integrity, the company wants to be sure that every driver pays the correct premium. The solution is similar to the one for smart-metering: the black-box plays the role of the trusted source, the driver keeps the collected information locally, sends to the company only the computed premium and uses AD-SNARK to attest its correctness.</p>

    <p class="text-gray-300">Loyalty Cards. Many large retailers use customer loyalty cards to encourage repeat visits. Typically, the customer must enroll in a loyalty program, and receive a card that can be shown to receive discounts in future visits. However, this has the great disadvantage of allowing the retailer to keep track of the purchase history of its clients. One solution [FL14] would be to let the point of sale become the trusted source by transferring to the client's mobile phone a signed purchase transaction. The client should then be able to compute the discount claim locally, and</p>

    <p class="text-gray-300">use AD-SNARK to prove to the retailer that this is correct and performed on legitimate purchase transactions, without revealing the exact details of its prior purchases.</p>

    <p class="text-gray-300">Health Statistics. Governments and states must periodically publish health statistics in order to inform the public of the status of healthcare systems. Obviously, the original data cannot be made public because it will contain sensitive information pertaining to the people receiving health care. However, this raw information can be authenticated by medical practitioners, who can operate as trusted sources. In this case, the general public (playing the role of a multitude of service providers) can be given the assurance that the statistics computed by the government (playing the role of the data owner) are correct and originated in legitimate medical data by using AD-SNARK.</p>

    </section>

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">This paper presents and addresses the problem of enabling privacy-preserving (aka zero-knowledge) data processing with a specific focus on the case where the input data is authenticated, and solely the authentication guarantees &quot;percolate&quot; to the resulting proof, without disclosing information on the original data. Current approaches to solve this problem are limited in either the class of computations that can be supported <a href="#page-38-1">[FKDL13]</a>, or in the prover's scalability (as we show in our experiments).</p>

    <p class="text-gray-300">In this paper, we propose a formal approach to this three-party problem via a new cryptographic primitive, AD-SNARK, of which we propose an efficient realization. Starting from our realization, we build and evaluate a nearly practical system, ADSNARK, for proving arbitrary computations over authenticated data in a privacy-preserving way.</p>

    <p class="text-gray-300">Our experimental evaluations show that ADSNARK performs essentially as well as non-authenticated state of the art solutions <a href="#page-38-4">[PGHR13,</a> <a href="#page-37-3">BSCTV14]</a>, which means that it scales excellently for modest computations. Moreover, ADSNARK dramatically improves over generic solutions to the input authentication problem. Furthermore, since ADSNARK leverages the recent developments in zeroknowledge proof systems, it permits handling arbitrary computations in an easy and usable way. Indeed, any of the available compilers (e.g., <a href="#page-38-4">[PGHR13]</a>) can be used as a front-end tool for translating from high-level languages (e.g., C++) into arithmetic circuit satisfaction problems that can later be passed to the zero-knowledge backend, in our case to ADSNARK.</p>

    <p class="text-gray-300">ADSNARK also inherits some of the limitations of existing SNARKs, such as the use of the circuit computation model. Recent work <a href="#page-37-3">[BSCTV14]</a> have shown how to move to more efficient representations such as RAM. We leave it as future work to study the extension of AD-SNARKs to more convenient and efficient computation models.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">ABC<sup>+</sup>12. Jae Hyun Ahn, Dan Boneh, Jan Camenisch, Susan Hohenberger, abhi shelat, and Brent Waters. Computing on authenticated data. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 1&ndash;20. Springer, March 2012.</p></li>
      <li><p class="text-gray-300">AF10. Ross Anderson and Shailendra Fuloria. On the security economics of electricity metering. In 9th Annual Workshop on the Economics of Information Security, WEIS 2010, Harvard University, Cambridge, MA, USA, June 7-8, 2010, 2010.</p></li>
      <li><p class="text-gray-300">AIK10. Benny Applebaum, Yuval Ishai, and Eyal Kushilevitz. From secrecy to soundness: Efficient verification via secure computation. In Samson Abramsky, Cyril Gavoille, Claude Kirchner, Friedhelm Meyer auf der Heide, and Paul G. Spirakis, editors, ICALP 2010, Part I, volume 6198 of LNCS, pages 152&ndash;163. Springer, July 2010.</p></li>
      <li><p class="text-gray-300">BB04. Dan Boneh and Xavier Boyen. Short signatures without random oracles. In Christian Cachin and Jan Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 56&ndash;73. Springer, May 2004.</p></li>
      <li><p class="text-gray-300">BBC14. BBC. Google unveils 'smart contact lens' to measure glucose levels. <a href="http://www.bbc.com/news/technology-25771907" target="_blank" rel="noopener noreferrer">http://www.bbc.com/news/</a> <a href="http://www.bbc.com/news/technology-25771907" target="_blank" rel="noopener noreferrer">technology-25771907</a>, 2014.</p></li>
      <li><p class="text-gray-300">BBG05. Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based encryption with constant size ciphertext. In Ronald Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 440&ndash;456. Springer, May 2005.</p></li>
      <li><p class="text-gray-300">BCCT12. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Shafi Goldwasser, editor, ITCS 2012, pages 326&ndash;349. ACM, January 2012.</p></li>
      <li><p class="text-gray-300">BCI<sup>+</sup>13. Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct noninteractive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315&ndash;333. Springer, March 2013.</p></li>
      <li><p class="text-gray-300">BDL<sup>+</sup>12. Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. High-speed high-security signatures. J. Cryptographic Engineering, 2(2):77&ndash;89, 2012.</p></li>
      <li><p class="text-gray-300">BF11. Dan Boneh and David Mandell Freeman. Homomorphic signatures for polynomial functions. In Kenneth G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 149&ndash;168. Springer, May 2011.</p></li>
      <li><p class="text-gray-300">BFR13. Michael Backes, Dario Fiore, and Raphael M. Reischuk. Verifiable delegation of computation on outsourced data. In Ahmad-Reza Sadeghi, Virgil D. Gligor, and Moti Yung, editors, ACM CCS 13, pages 863&ndash;874. ACM Press, November 2013.</p></li>
      <li><p class="text-gray-300">Boy10. Xavier Boyen. Lattice mixing and vanishing trapdoors: A framework for fully secure short signatures and more. In Phong Q. Nguyen and David Pointcheval, editors, PKC 2010, volume 6056 of LNCS, pages 499&ndash;517. Springer, May 2010.</p></li>
      <li><p class="text-gray-300">BSCG<sup>+</sup>13. Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90&ndash;108. Springer, August 2013.</p></li>
      <li><p class="text-gray-300">BSCTV14. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In USENIX Security, pages 781&ndash;796, 2014.</p></li>
      <li><p class="text-gray-300">CF13. Dario Catalano and Dario Fiore. Practical homomorphic MACs for arithmetic circuits. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 336&ndash;352. Springer, May 2013.</p></li>
      <li><p class="text-gray-300">Cha85. David Chaum. Security without identification: Transaction systems to make big brother obsolete. Commun. ACM, 28(10):1030&ndash;1044, October 1985.</p></li>
      <li><p class="text-gray-300">CKLM14. Melissa Chase, Markulf Kohlweiss, Anna Lysyanskaya, and Sarah Meiklejohn. Malleable signatures: New definitions and delegatable anonymous credentials. In Computer Security Foundation (CSF), 2014.</p></li>
      <li><p class="text-gray-300">CKS09. Jan Camenisch, Markulf Kohlweiss, and Claudio Soriente. An accumulator based on bilinear maps and efficient revocation for anonymous credentials. In Stanislaw Jarecki and Gene Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 481&ndash;500. Springer, March 2009.</p></li>
      <li><p class="text-gray-300">CKV10. Kai-Min Chung, Yael Kalai, and Salil P. Vadhan. Improved delegation of computation using fully homomorphic encryption. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 483&ndash;501. Springer, August 2010.</p></li>
      <li><p class="text-gray-300">CS99. Ronald Cramer and Victor Shoup. Signature schemes based on the strong RSA assumption. In ACM CCS 99, pages 46&ndash;51. ACM Press, November 1999.</p></li>
      <li><p class="text-gray-300">Dam88. Ivan Damg&#730;ard. Payment systems and credential mechanisms with provable security against abuse by individuals. In Shafi Goldwasser, editor, CRYPTO'88, volume 403 of LNCS, pages 328&ndash;335. Springer, August 1988.</p></li>
      <li><p class="text-gray-300">FKDL13. C&acute;edric Fournet, Markulf Kohlweiss, George Danezis, and Zhengqin Luo. ZQL: A compiler for privacypreserving data processing. In Proceedings of the 22Nd USENIX Conference on Security, SEC'13, pages 163&ndash;178, Berkeley, CA, USA, 2013. USENIX Association.</p></li>
      <li><p class="text-gray-300">FL14. Matthew Fredrikson and Ben Livshits. ZO: An optimizing distributing zero-knowledge compiler. In USENIX Security, 2014.</p></li>
      <li><p class="text-gray-300">GGP10. Rosario Gennaro, Craig Gentry, and Bryan Parno. Non-interactive verifiable computing: Outsourcing computation to untrusted workers. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 465&ndash;482. Springer, August 2010.</p></li>
      <li><p class="text-gray-300">GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626&ndash;645. Springer, May 2013.</p></li>
      <li><p class="text-gray-300">GMR89. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186&ndash;208, 1989.</p></li>
      <li><p class="text-gray-300">Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321&ndash;340. Springer, December 2010.</p></li>
      <li><p class="text-gray-300">GW11a. Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99&ndash;108. ACM Press, June 2011.</p></li>
      <li><p class="text-gray-300">GW11b. Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In STOC '11: Proceedings of the 43rd Annual ACM Symposium on Theory of Computing. ACM, 2011.</p></li>
      <li><p class="text-gray-300">GW13. Rosario Gennaro and Daniel Wichs. Fully homomorphic message authenticators. In Kazue Sako and Palash Sarkar, editors, ASIACRYPT 2013, Part II, volume 8270 of LNCS, pages 301&ndash;320. Springer, December 2013.</p></li>
      <li><p class="text-gray-300">JMSW02. Robert Johnson, David Molnar, Dawn Xiaodong Song, and David Wagner. Homomorphic signature schemes. In Bart Preneel, editor, CT-RSA 2002, volume 2271 of LNCS, pages 244&ndash;262. Springer, February 2002.</p></li>
      <li><p class="text-gray-300">Kil92. Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723&ndash;732. ACM Press, May 1992.</p></li>
      <li><p class="text-gray-300">Kil95. Joe Kilian. Improved efficient arguments (preliminary version). In Don Coppersmith, editor, CRYPTO'95, volume 963 of LNCS, pages 311&ndash;324. Springer, August 1995.</p></li>
      <li><p class="text-gray-300">Lip12. Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169&ndash;189. Springer, March 2012.</p></li>
      <li><p class="text-gray-300">LRSW99. Anna Lysyanskaya, Ronald L. Rivest, Amit Sahai, and Stefan Wolf. Pseudonym systems. In Howard M. Heys and Carlisle M. Adams, editors, SAC 1999, volume 1758 of LNCS, pages 184&ndash;199. Springer, August 1999.</p></li>
      <li><p class="text-gray-300">MEK<sup>+</sup>10. Sarah Meiklejohn, C. Chris Erway, Alptekin K&uml;up&cedil;c&uml;u, Theodora Hinkle, and Anna Lysyanskaya. Zkpdl: A language-based system for efficient zero-knowledge proofs and electronic cash. In Proceedings of the 19th USENIX Conference on Security, USENIX Security'10, pages 13&ndash;13, Berkeley, CA, USA, 2010. USENIX Association.</p></li>
      <li><p class="text-gray-300">Mic94. Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436&ndash;453. IEEE Computer Society Press, November 1994.</p></li>
      <li><p class="text-gray-300">Nao03. Moni Naor. On cryptographic assumptions and challenges (invited talk). In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS, pages 96&ndash;109. Springer, August 2003.</p></li>
      <li><p class="text-gray-300">PGHR13. Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE Symposium on Security and Privacy, Oakland, 2013. Corrected version (13 May 2013): <a href="http://eprint.iacr.org/2013/279" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2013/279</a>.</p></li>
      <li><p class="text-gray-300">PRV12. Bryan Parno, Mariana Raykova, and Vinod Vaikuntanathan. How to delegate and verify in public: Verifiable computation from attribute-based encryption. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 422&ndash;439. Springer, March 2012.</p></li>
      <li><p class="text-gray-300">RD11. Alfredo Rial and George Danezis. Privacy-preserving smart metering. In Proceedings of the 10th Annual ACM Workshop on Privacy in the Electronic Society, WPES '11, pages 49&ndash;60, New York, NY, USA, 2011. ACM.</p></li>
    </ul>

    <p class="text-gray-300">Vit14. Vitalconnect. Healthpatch. http://www.vitalconnect.com, 2014.</p>

    <p class="text-gray-300">Wat05. Brent R. Waters. Efficient identity-based encryption without random oracles. In Ronald Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 114&ndash;127. Springer, May 2005.</p>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A AD-SNARK Extensions</h2>

    <p class="text-gray-300">In this section we discuss two extensions of AD-SNARKs. The first one is a generalization of AD-SNARKs to the setting in which one proves statements authenticated by <em>multiple data sources</em>. As a second extension we show how to obtain a scheme in which the verification algorithm runs in time independent of the number of authenticated inputs. This second extension supports only secret-key verification and assumes labels with a specific structure.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Multi-Source AD-SNARKs</h3>

    <p class="text-gray-300">A multi-source AD-SNARK is an AD-SNARK where: the Gen algorithms takes in a tuple of k public authentication parameters; the Prove may receive inputs authenticated using different authentication keys (i.e., from multiple data sources); the Ver algorithm takes as input a set of authentication verification keys and extended labels L where each  <span class="math">L_i</span>  specifies if the statement value  <span class="math">x_i</span>  is authenticated and under which key. The definition of completeness is the straightforward generalization of the one in Section 5. Adaptive proof of knowledge is similar to the one of Definition 5 except that in the multi-source setting the adversary is allowed to obtain values authenticated under all possible keys.</p>

    <p class="text-gray-300">AN EFFICIENT MULTI-SOURCE AD-SNARK SCHEME. We briefly show how to adapt our AD-SNARK construction of Section 4 to work in the multi-source setting.</p>

    <p class="text-gray-300">The algorithms  <span class="math">\\mathsf{Setup}</span> ,  <span class="math">\\mathsf{AuthKG}</span> ,  <span class="math">\\mathsf{Auth}</span>  and  <span class="math">\\mathsf{AuthVer}</span>  are identical. The remaining algorithms work as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Gen}(\\{\\mathsf{pap}_j\\},C)</span>  takes as input a circuit C and k public authentication parameters  <span class="math">\\mathsf{pap}_1,\\ldots,\\mathsf{pap}_k</span> . It proceeds exactly as in  <span class="math">\\mathsf{Gen}</span>  of Section 4 except that now it computes a  <span class="math">K_\\mathsf{a}</span>  value for each authentication key. Namely, it computes (and includes in  <span class="math">\\mathsf{EK}_C</span> )  <span class="math">K_{\\mathsf{a},j} = z(\\tau)\\rho_\\mathsf{a}K_{1,j}</span> , for  <span class="math">j = 1,\\ldots,k</span> .</p>

    <p class="text-gray-300">Prove( <span class="math">\\mathsf{EK}_C, \\vec{x}, \\vec{w}, \\vec{\\sigma}</span> ): here each authentication tag  <span class="math">\\sigma_i</span>  in  <span class="math">\\vec{\\sigma}</span>  also specifies under which authentication key  <span class="math">\\mathsf{vk}_{j_i}</span>  it verifies. The set  <span class="math">I_\\sigma</span>  is then further partitioned in several subsets  <span class="math">I_{\\sigma,j}</span> , one for every authentication key used in the statement. Without loss of generality, assume there are k of such sets. The algorithm proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\overrightarrow{s} = \\mathsf{QAPwit}(C, \\overrightarrow{x}, \\overrightarrow{w}) \\in \\mathbb{F}^m</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample  <span class="math">\\delta_{\\mathsf{a}}^{(1)}, \\dots, \\delta_{\\mathsf{a}}^{(k)}, \\delta_{\\mathsf{a}}^{mid}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}} \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> , and set  <span class="math">\\delta_{\\mathsf{a}} = \\sum_{j=1}^{k} \\delta_{\\mathsf{a}}^{(j)} + \\delta_{\\mathsf{a}}^{mid}</span> . Also, define the vector  <span class="math">\\overrightarrow{u} = (1, \\overrightarrow{s}, \\delta_{\\mathsf{a}}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}}) \\in \\mathbb{F}^{m+4}</span>  as before.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Solve the QAP  <span class="math">Q_C</span>  exactly as in Prove of Section 4. Then compute  <span class="math">H = h(\\tau) \\mathcal{P}_1</span>  using the values  <span class="math">\\tau^i \\mathcal{P}_1</span>  contained in the evaluation key  <span class="math">\\mathsf{EK}_C</span> .</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For j = 1 to k, compute:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\pi_{\\sigma,j} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{\\sigma,j}} + \\delta_{\\mathsf{a}}^{(j)} A_{m+1}, \\ \\pi&#x27;_{\\sigma,j} = \\langle \\overrightarrow{u}, \\overrightarrow{A&#x27;} \\rangle_{I_{\\sigma,j}} + \\delta_{\\mathsf{a}}^{(j)} A&#x27;_{m+1} \\\\ \\pi_{mid} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{mid}} - \\sum_{j=1}^k \\delta_{\\mathsf{a}}^{(j)} A_{m+1}, \\\\ \\pi&#x27;_{mid} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A&#x27;} \\rangle_{I_{\\sigma}} - \\sum_{j=1}^k \\delta_{\\mathsf{a}}^{(j)} A&#x27;_{m+1} \\end{split}</span>$</p>

    <p class="text-gray-300">and then compute  <span class="math">\\pi_b, \\pi&#x27;_b, \\pi_c, \\pi&#x27;_c, \\pi_E</span>  as in Section 4.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Authenticate each value  <span class="math">\\pi_{\\sigma,j}</span>  by computing</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\pi_{\\mu,j} = \\langle \\overrightarrow{\\mu}, \\overrightarrow{A} \\rangle_{I_{\\sigma,j}} + \\delta_{\\mathsf{a}}^{(j)} K_{\\mathsf{a},j}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\pi = (\\{\\pi_{\\mu,j}, \\pi_{\\sigma,j}, \\pi&#x27;_{\\sigma,j}, \\}_{j=1}^k \\pi_{mid}, \\pi&#x27;_{mid}, \\pi_{\\mathsf{b}}, \\pi&#x27;_{\\mathsf{b}}, \\pi_{\\mathsf{c}}, \\pi&#x27;_{\\mathsf{c}}, \\pi_E, H)</span> . To make the proof publicly verifiable, include also  <span class="math">\\{\\Phi_k, \\sigma&#x27;_k\\}_{k \\in I_\\sigma}</span>  in  <span class="math">\\pi</span> .</li>
    </ol>

    <p class="text-gray-300"><span class="math">\\operatorname{\\mathsf{Ver}}(\\{\\operatorname{\\mathsf{vk}}_j\\},\\operatorname{\\mathsf{VK}}_C,\\mathsf{L},\\{x_i\\}_{\\mathsf{L}_i=\\star},\\pi)</span> : it proceeds as the verification algorithm of Section 4 except that it runs the verification equations (A.1) and (A.2) for every triple  <span class="math">(\\pi_{\\mu,j},\\pi_{\\sigma,j},\\pi&#x27;_{\\sigma,j})</span>  in the proof.</p>

    <p class="text-gray-300">The completeness of this scheme follows from the same arguments used to argue the completeness of our AD-SNARK. The security of the multi-source AD-SNARK described above holds under the same assumptions used for ADSNARK. The difference in the security proof is that one needs to define more hybrid games as the &quot;bad events&quot; can now occur for either one of the k authentication keys.</p>

    <p class="text-gray-300">As an efficiency remark, note that while the size of the proof  <span class="math">\\pi</span>  depends on the number k of authentication keys used to sign the statement, in several applications one should think of k as a rather small constant. For instance, one may think of a variation of the pay-as-you-drive insurance application in which there may be k=2 distinct trusted devices acting as data sources, e.g., a GPS collecting geographic data and a car sensor collecting driving information.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 A Zero-Knowledge AD-SNARK with Constant-Time Verification.</h3>

    <p class="text-gray-300">Here we show a variant of the scheme proposed in Section 4 which allows for a verification algorithm whose efficiency does <em>not</em> depend on the number of authenticated values, in an amortized sense. In order to achieve this appealing property, we trade efficiency for usability in making the previous scheme only secretly verifiable.</p>

    <p class="text-gray-300">The Setup algorithm is identical. The remaining algorithms work as follows.</p>

    <p class="text-gray-300">AuthKG(pp): Run  <span class="math">(S, \\mathsf{prfpp}) \\leftarrow_{\\mathcal{R}} \\mathsf{F.KG}(1^{\\lambda})</span>  to obtain the seed S and the public parameters  <span class="math">\\mathsf{prfpp}</span>  of a pseudorandom function  <span class="math">\\mathsf{F}_S : \\{0,1\\}^* \\to \\mathbb{G}_2</span> . Choose a random value  <span class="math">\\kappa \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> . Compute  <span class="math">K = e(\\mathcal{P}_1, \\mathcal{P}_2)^{\\kappa} \\in \\mathbb{G}_T</span> . Return the secret key  <span class="math">\\mathsf{sk} = \\mathsf{vk} = (S, \\kappa)</span> , and the public authentication parameters  <span class="math">\\mathsf{pap} = (\\mathsf{pp}, \\mathsf{prfpp}, K)</span> .</p>

    <p class="text-gray-300">Auth(sk, L, x): Let  <span class="math">\\mathsf{sk} = (S, \\kappa)</span> . To authenticate a value  <span class="math">x \\in \\mathbb{F}</span>  with label L, use the PRF to compute  <span class="math">\\Phi \\leftarrow \\mathsf{F}_S(\\mathsf{L})</span> , then compute  <span class="math">\\sigma = \\Phi + x \\kappa \\mathcal{P}_2</span>  and output  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">AuthVer(vk,  <span class="math">\\sigma</span> , L, x): Let vk =  <span class="math">(S, \\kappa)</span>  be the (secret) verification key. To verify that  <span class="math">\\sigma</span>  is a valid authentication tag for a value  <span class="math">x \\in \\mathbb{F}</span>  with respect to label L, output  <span class="math">\\top</span>  if  <span class="math">\\sigma = \\mathsf{F}_S(\\mathsf{L}) + x \\kappa \\mathcal{P}_2</span>  and  <span class="math">\\bot</span>  otherwise.</p>

    <p class="text-gray-300">Gen(pap, C): is the same as in Section 4 except that here  <span class="math">K_a = (K)^{z(\\tau)} \\in \\mathbb{G}_T</span> .</p>

    <p class="text-gray-300">Prove <span class="math">(\\mathsf{EK}_C, \\vec{x}, \\vec{w}, \\vec{\\sigma})</span> : is the same as in Section 4 except that here  <span class="math">\\pi_{\\mu} = [\\prod_{k \\in I_{\\sigma}} e(A_k, \\Phi_k)] \\cdot (K_{\\mathsf{a}})^{\\delta_{\\mathsf{a}}^{\\sigma}} \\in \\mathbb{G}_T</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathsf{Ver}(\\mathsf{vk},\\mathsf{VK}_C,\\mathsf{L},\\{x_i\\}_{\\mathsf{L}_i=\\star},\\pi)</span> : is the same as in Section 4 except for the first verification equation. Let  <span class="math">\\mathsf{vk}=(S,\\kappa)</span> .    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(A.1) Check the authenticity of  <span class="math">\\pi_{\\sigma}</span> , against labels L by checking if the following equation is satisfied over  <span class="math">\\mathbb{G}_T</span> :</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$|\\pi_{\\mu}| = \\prod_{k \\in I_{\\sigma}} e(A_k, \\mathsf{F}_S(\\mathsf{L}_k)) + e(|\\pi_{\\sigma}|, \\kappa \\mathcal{P}_2)</span>$</p>

    <p class="text-gray-300">How to Achieve Efficient Verification. By assuming a proper labeling of the data and a suitable pseudorandom function F, the scheme described above can allow for an improved verification algorithm whose running time does not depend on the number  <span class="math">|I_{\\sigma}|</span>  of authenticated values. Following the ideas in [BFR13], we assume that every input x is authenticated by using a multilabel  <span class="math">L = (\\Delta, \\tau)</span> , where  <span class="math">\\Delta</span>  is a data set identifier, and  <span class="math">\\tau</span>  is an input identifier. As an example, the input identifiers  <span class="math">\\tau_1, \\ldots \\tau_n</span>  can be specific canonical information like date and time (e.g., day 05, 11:12:42), and the data set identifier  <span class="math">\\Delta</span>  can be more general information describing the category (e.g., &quot;energy consumption for March 2014&quot;).</p>

    <p class="text-gray-300">As for the pseudorandom function, we can instantiate  <span class="math">F_S</span>  by using the specific ACF-efficient PRF of [BFR13]  <span class="math">F_S : \\{0,1\\}^* \\times \\{0,1\\}^* \\to \\mathbb{G}_2</span>  such that:  <span class="math">F_S(\\Delta,\\tau) = (a_\\Delta u_\\tau + b_\\Delta v_\\tau)\\mathcal{P}_2</span> , where the values  <span class="math">(a_\\Delta,b_\\Delta)</span>  and  <span class="math">(u_\\tau,v_\\tau)</span>  are derived by applying two standard PRFs (each mapping into  <span class="math">\\mathbb{F}^2</span> ) to  <span class="math">\\Delta</span>  and  <span class="math">\\tau</span> , respectively. This function is pseudorandom under the Decision Linear assumption [BFR13]. To achieve efficient verification one proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Offline phase: precompute  <span class="math">\\omega_u = e(\\sum_{k \\in I_{\\sigma}} u_k A_k, \\mathcal{P}_2)</span>  and  <span class="math">\\omega_v = e(\\sum_{k \\in I_{\\sigma}} v_k A_k, \\mathcal{P}_2)</span>  where each  <span class="math">(u_k, v_k)</span>  is derived from  <span class="math">\\tau_k</span>  for all  <span class="math">k \\in I_{\\sigma}</span> . Store  <span class="math">(\\omega_u, \\omega_v)</span> .</li>
      <li>Online phase: given  <span class="math">\\Delta</span> , derive  <span class="math">(a_{\\Delta}, b_{\\Delta})</span>  from  <span class="math">\\Delta</span> , and compute  <span class="math">\\Omega = (\\omega_u)^{a_{\\Delta}} \\cdot (\\omega_v)^{b_{\\Delta}} \\in \\mathbb{G}_T</span> . Finally, use  <span class="math">\\Omega</span>  to check the verification equation (A.1) described above, i.e., check that  <span class="math">\\pi_{\\mu} = \\Omega \\cdot e(\\tilde{\\pi}_{\\sigma}, \\kappa \\mathcal{P}_2)</span> .</li>
    </ul>

    <p class="text-gray-300">The correctness of this efficient verification follows from  <span class="math">\\Omega = \\left[\\prod_{k \\in I_{\\sigma}} e(A_k, \\mathsf{F}_S(\\Delta, \\tau_k))\\right]</span> .</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Definition of Zero Knowledge SNARKs</h2>

    <p class="text-gray-300">We recall the definition of SNARKs for arithmetic circuit satisfiability [Mic94, GW11b]. A succinct non-interactive argument (SNARG) for arithmetic circuit satisfiability is a triple of algorithms  <span class="math">\\Pi = (\\mathsf{Gen}, \\mathsf{Prove}, \\mathsf{Ver})</span>  working as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Given a circuit C, the generation algorithm  <span class="math">\\mathsf{Gen}(1^{\\lambda}, C)</span>  generates a (public) reference string  <span class="math">\\mathsf{EK}_C</span>  and a corresponding verification key  <span class="math">\\mathsf{VK}_C</span>  for C.</li>
      <li>Given statement  <span class="math">\\vec{x}</span>  and witness  <span class="math">\\vec{w}</span>  such that  <span class="math">C(\\vec{x}, \\vec{w}) = 0</span> , the prover produces a proof  <span class="math">\\pi \\leftarrow \\mathsf{Prove}(\\mathsf{EK}_C, \\vec{x}, \\vec{w})</span> .</li>
      <li>The verifier runs  <span class="math">\\{\\bot, \\top\\}</span>   <span class="math">\\leftarrow</span>   <span class="math">\\mathsf{Ver}(\\mathsf{VK}_C, \\vec{x}, \\pi)</span>  to verify the validity of  <span class="math">\\pi</span> . The following three properties need to be satisfied.</li>
      <li>Completeness. For all  <span class="math">(\\vec{x}, \\vec{w}) \\in \\mathcal{R}_C</span> , we have that</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[\\mathsf{Ver}(\\mathsf{VK}_C, \\overrightarrow{x}, \\pi) &amp;= \\bot : (\\mathsf{EK}_C, \\mathsf{VK}_C) \\leftarrow \\mathsf{Gen}(1^\\lambda, C), \\\\ \\pi &amp;\\leftarrow \\mathsf{Prove}(\\mathsf{EK}_C, \\overrightarrow{x}, \\overrightarrow{w})] = negl(\\lambda) \\end{split}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Soundness. (Adaptive case) For all PPT Prove*, we have</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Pr[\\mathsf{Ver}(\\mathsf{VK}_C, \\overrightarrow{x}, \\pi) = \\top \\wedge \\overrightarrow{x} \\not\\in \\mathcal{L}_C: \\\\ &amp;(\\mathsf{EK}_C, \\mathsf{VK}_C) \\leftarrow \\mathsf{Gen}(1^{\\lambda}, C), (\\overrightarrow{x}, \\pi) \\leftarrow \\mathsf{Prove}^*(\\mathsf{EK}_C)] = negl(\\lambda) \\end{split}</span>$</p>

    <p class="text-gray-300">(Non-adaptive case) For all PPT  <span class="math">\\mathsf{Prove}^*</span> , and  <span class="math">\\vec{x} \\not\\in \\mathcal{L}_C</span> :</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[\\mathsf{Ver}(\\mathsf{VK}_C, \\overrightarrow{x}, \\pi) = \\top : (\\mathsf{EK}_C, \\mathsf{VK}_C) \\!\\leftarrow\\! \\mathsf{Gen}(1^\\lambda, C), \\\\ \\pi \\leftarrow \\mathsf{Prove}^*(\\mathsf{EK}_C, \\overrightarrow{x})] = negl(\\lambda) \\end{split}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Succinctness. The length of a proof  <span class="math">\\pi</span>  is given by  <span class="math">|\\pi| = \\text{poly}(\\lambda)\\text{polylog}(|\\vec{x}|, |\\vec{w}|)</span> . A SNARG is called <em>adaptive</em> if the prover can choose the statement  <span class="math">\\vec{x}</span>  after seeing the reference string  <span class="math">\\mathsf{EK}_C</span> .</li>
    </ul>

    <p class="text-gray-300">A SNARG of knowledge (SNARK) is a SNARG where soundness is replaced by the following property:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Adaptive Proof of Knowledge. For all efficient Prove* there exists a polynomial-size extractor E such that for every auxiliary input  <span class="math">aux \\in \\{0,1\\}^{poly(\\lambda)}</span> , and every circuit C of polynomial size,</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{Ver}(\\mathsf{VK}_C, \\overrightarrow{x}, \\pi) = \\top \\land (\\overrightarrow{x}, \\overrightarrow{w}) \\notin \\mathcal{R}_C : (\\mathsf{EK}_C, \\mathsf{VK}_C) \\leftarrow \\mathsf{Gen}(1^\\lambda, C), \\\\ (\\overrightarrow{x}, \\pi) \\leftarrow \\mathsf{Prove}^*(aux, \\mathsf{EK}_C), \\overrightarrow{w} \\leftarrow E(aux, \\mathsf{EK}_C)] = negl(\\lambda)</span>$</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C The PGHR Zero-Knowledge SNARK</h2>

    <p class="text-gray-300">We review a version of the zero-knowledge SNARK scheme of Parno et al. [PGHR13] which was described in the recent work of Ben-Sasson et al. [BSCTV14].</p>

    <p class="text-gray-300">Setup(1<sup>\\lambda</sup>): generate the public parameters consisting of a bilinear group description  <span class="math">pp = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_1, e, \\mathcal{P}_1, \\mathcal{P}_2) \\leftarrow_{\\mathcal{R}} \\mathcal{G}(1^{\\lambda})</span> . Let  <span class="math">\\mathbb{F}</span>  be the finite field  <span class="math">\\mathbb{F}_p</span> . (EK<sub>C</sub>, VK<sub>C</sub>)  <span class="math">\\leftarrow</span>  Gen(pp, C): Let  <span class="math">C : \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  be an arithmetic circuit.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run  <span class="math">Q_C = (\\vec{a}, \\vec{b}, \\vec{c}, z) = \\mathsf{QAPInst}(C)</span>  to build a QAP  <span class="math">Q_C</span>  of size m and degree d for C. Extend  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  with 3 more polynomials each, by setting:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$a_{m+1}(X) = b_{m+2}(X) = c_{m+3}(X) = z(X),</span>$</p>

    <p class="text-gray-300"><span class="math">a_{m+2}(X) = a_{m+3}(X) = b_{m+1}(X) = b_{m+3}(X) = c_{m+1}(X) = c_{m+2}(X) = 0.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pick  <span class="math">\\rho_{\\mathsf{a}}, \\rho_{\\mathsf{b}}, \\tau, \\alpha_{\\mathsf{a}}, \\alpha_{\\mathsf{b}}, \\alpha_{\\mathsf{c}}, \\beta, \\gamma \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> , set  <span class="math">\\rho_{\\mathsf{c}} = \\rho_{\\mathsf{a}} \\cdot \\rho_{\\mathsf{b}}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">Z = z(\\tau)\\rho_{c}\\mathcal{P}_{2}</span> , and  <span class="math">\\forall k \\in \\{0,...,m+3\\}</span> :</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} A_k &amp;= a_k(\\tau) \\rho_{\\mathsf{a}} \\, \\mathcal{P}_1, \\qquad A_k&#x27; = \\alpha_{\\mathsf{a}} \\, a_k(\\tau) \\rho_{\\mathsf{a}} \\, \\mathcal{P}_1, \\\\ B_k &amp;= b_k(\\tau) \\rho_{\\mathsf{b}} \\, \\mathcal{P}_2, \\qquad B_k&#x27; = \\alpha_{\\mathsf{b}} \\, b_k(\\tau) \\rho_{\\mathsf{b}} \\, \\mathcal{P}_1, \\\\ C_k &amp;= c_k(\\tau) \\rho_{\\mathsf{c}} \\, \\mathcal{P}_1, \\qquad C_k&#x27; = \\alpha_{\\mathsf{c}} \\, c_k(\\tau) \\rho_{\\mathsf{c}} \\, \\mathcal{P}_1, \\\\ E_k &amp;= \\beta (a_k(\\tau) \\rho_{\\mathsf{a}} + b_k(\\tau) \\rho_{\\mathsf{b}} + c_k(\\tau) \\rho_{\\mathsf{c}}) \\, \\mathcal{P}_1. \\end{split}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the evaluation key  <span class="math">\\mathsf{EK}_C</span>  and the verification key  <span class="math">\\mathsf{VK}_C</span>  which are defined as follows:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathsf{EK}_C &amp;= \\left(Q_C, \\ \\overrightarrow{A}, \\ \\overrightarrow{A}&#x27;, \\overrightarrow{B}, \\ \\overrightarrow{B}&#x27;, \\overrightarrow{C}, \\ \\overrightarrow{C}&#x27;, \\overrightarrow{E}, \\ \\{\\tau^i \\, \\mathcal{P}_1\\}_{i \\in \\{0, \\dots, d\\}}\\right) \\\\ \\mathsf{VK}_C &amp;= \\left(\\mathcal{P}_1, \\, \\mathcal{P}_2, \\ \\alpha_{\\mathsf{a}} \\, \\mathcal{P}_2, \\ \\alpha_{\\mathsf{b}} \\, \\mathcal{P}_1, \\ \\alpha_{\\mathsf{c}} \\, \\mathcal{P}_2, \\ \\gamma \\, \\mathcal{P}_2, \\ \\beta \\, \\gamma \\, \\mathcal{P}_1, \\ \\beta \\, \\gamma \\, \\mathcal{P}_2, \\ Z, \\ \\{A_k\\}_{k=0}^n, \\right) \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}(\\mathsf{EK}_C, \\vec{x}, \\vec{w})</span> : given a statement  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and witness  <span class="math">\\vec{w} \\in \\mathbb{F}^h</span> , proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\vec{s} = \\mathsf{QAPwit}(C, \\vec{x}, \\vec{w}) \\in \\mathbb{F}^m</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly sample  <span class="math">\\delta_{\\mathsf{a}}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}} \\leftarrow_{\\mathcal{R}} \\mathbb{F}</span> . Also, define the vector  <span class="math">\\overrightarrow{u} = (1, \\overrightarrow{s}, \\delta_{\\mathsf{a}}, \\delta_{\\mathsf{b}}, \\delta_{\\mathsf{c}}) \\in \\mathbb{F}^{m+4}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Solve the QAP  <span class="math">Q_C</span>  by computing the coefficients  <span class="math">(h_0, \\ldots, h_d) \\in \\mathbb{F}^{d+1}</span>  of  <span class="math">h \\in \\mathbb{F}[X]</span>  such that h(X)z(X) = a(X)b(X) c(X), where  <span class="math">a, b, c \\in \\mathbb{F}[X]</span>  are</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\begin{split} a(X) &amp;= a_0(X) + \\sum_{k \\in [m]} s_k \\cdot a_k(X) \\, + \\, \\delta_{\\mathsf{a}} \\cdot z(x) = \\langle \\overrightarrow{u}, \\overrightarrow{a} \\rangle \\\\ b(X) &amp;= b_0(X) + \\sum_{k \\in [m]} s_k \\cdot b_k(X) \\, + \\, \\delta_{\\mathsf{b}} \\cdot z(x) = \\langle \\overrightarrow{u}, \\overrightarrow{b} \\rangle \\\\ c(X) &amp;= c_0(X) + \\sum_{k \\in [m]} s_k \\cdot c_k(X) \\, + \\, \\delta_{\\mathsf{c}} \\cdot z(x) = \\langle \\overrightarrow{u}, \\overrightarrow{c} \\rangle \\end{split}</span>$</p>

    <p class="text-gray-300">Compute  <span class="math">H = h(\\tau) \\mathcal{P}_1</span>  using the values  <span class="math">\\tau^i \\mathcal{P}_1</span>  in  <span class="math">\\mathsf{EK}_C</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Use the elements in  <span class="math">\\mathsf{EK}_C</span>  to compute the following values:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\pi_{mid} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A} \\rangle_{I_{mid}} + \\delta_{\\mathsf{a}} \\, A_{m+1}, \\\\ \\pi&#x27;_{mid} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{A&#x27;} \\rangle_{I_{\\sigma}} + \\delta_{\\mathsf{a}} \\, A&#x27;_{m+1} \\\\ \\pi_{\\mathsf{b}} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{B} \\rangle, \\quad \\pi_{\\mathsf{c}} \\, = \\langle \\overrightarrow{u}, \\overrightarrow{C} \\rangle, \\quad \\pi_{E} = \\langle \\overrightarrow{u}, \\overrightarrow{E} \\rangle \\\\ \\pi&#x27;_{\\mathsf{b}} &amp;= \\langle \\overrightarrow{u}, \\overrightarrow{B&#x27;} \\rangle, \\quad \\pi&#x27;_{\\mathsf{c}} \\, = \\langle \\overrightarrow{u}, \\overrightarrow{C&#x27;} \\rangle. \\end{split}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output  <span class="math">\\pi = (\\pi_{mid}, \\pi&#x27;_{mid}, \\pi_{b}, \\pi&#x27;_{b}, \\pi_{c}, \\pi&#x27;_{c}, \\pi_{E}, H)</span> .</li>
    </ol>

    <p class="text-gray-300">Verify(VK<sub>C</sub>,  <span class="math">\\vec{x}</span> ,  <span class="math">\\pi</span> ): in order to verify a proof  <span class="math">\\pi</span>  (as defined above) for statement  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span> , first compute  <span class="math">A_x = A_0 + \\langle \\vec{x}, \\vec{A} \\rangle_{[1,n]}</span>  and then perform the following steps:</p>

    <p class="text-gray-300">(P.1) Check the satisfiability of the QAP:</p>

    <p class="text-gray-300"><span class="math">$e(A_{\\star} + |\\pi_{\\sigma}| + |\\pi_{mid}|, |\\pi_{\\mathsf{b}}|) = e(|H|, Z) \\cdot e(|\\pi_{\\mathsf{c}}|, |\\mathcal{P}_{2}|)</span>$</p>

    <p class="text-gray-300">(P.2) Check the validity of knowledge commitments:</p>

    <p class="text-gray-300"><span class="math">$e(\\ \\pi&#x27;_{mid}\\ ,\\ \\mathcal{P}_2) = e(\\ \\pi_{mid}\\ ,\\ \\alpha_{\\mathsf{a}}\\mathcal{P}_2)\\ \\wedge\\ e(\\ \\pi&#x27;_{\\mathsf{b}}\\ ,\\mathcal{P}_2) = e(\\alpha_{\\mathsf{b}}\\mathcal{P}_1,\\ \\pi_{\\mathsf{b}}\\ )\\ \\wedge\\ e(\\ \\pi&#x27;_{\\mathsf{c}}\\ ,\\ \\mathcal{P}_2) = e(\\ \\pi_{\\mathsf{c}}\\ ,\\ \\alpha_{\\mathsf{c}}\\mathcal{P}_2)</span>$</p>

    <p class="text-gray-300">(P.3) Check that all the QAP linear combinations use the same coefficients:</p>

    <p class="text-gray-300"><span class="math">$e(\\mid \\pi_E\\mid,\\,\\gamma\\mathcal{P}_2) = e(A_\\star + \\mid \\pi_\\sigma\\mid + \\mid \\pi_{mid}\\mid + \\mid \\pi_\\mathsf{c}\\mid,\\,\\beta\\gamma\\mathcal{P}_2) \\cdot e(\\beta\\gamma\\mathcal{P}_1,\\mid \\pi_\\mathsf{b}\\mid)</span>$</p>

    <p class="text-gray-300">If all the checks above are satisfied, then return  <span class="math">\\top</span> ; otherwise return  <span class="math">\\bot</span> .</p>

    </section>
`;
---

<BaseLayout title="ADSNARK: Nearly Practical and Privacy-Preserving Proofs on A... (2014/617)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/617
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Detailed Contributions</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">An Intuitive Description of Our Techniques</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Organization</a></li>
          </ol>
        </li>
        <li><a href="#sec-2" class="hover:text-white">Background</a></li>
        <li>
          <a href="#sec-3" class="hover:text-white">Zero-Knowledge SNARKs over Authenticated Data</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">SNARKs over Authenticated Data</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">A Generic Construction of Zero-Knowledge AD-SNARKs</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Signature Verification Overhead</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Our Construction of Zero-Knowledge AD-SNARKs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Completeness</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Adaptive Proof of Knowledge</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Proof of the Zero-Knowledge Property</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Implementation</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Experiments Setup</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Performance for General Circuits</a></li>
            <li><a href="#sec-5.4" class="hover:text-white">Performance for Smart Metering Billing</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Further Related Work</a></li>
        <li><a href="#sec-7" class="hover:text-white">More Applications</a></li>
        <li><a href="#sec-8" class="hover:text-white">Conclusions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">AD-SNARK Extensions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Multi-Source AD-SNARKs</a></li>
            <li><a href="#app-a.2" class="hover:text-white">A Zero-Knowledge AD-SNARK with Constant-Time Verification.</a></li>
          </ol>
        </li>
        <li><a href="#app-b" class="hover:text-white">Definition of Zero Knowledge SNARKs</a></li>
        <li><a href="#app-c" class="hover:text-white">The PGHR Zero-Knowledge SNARK</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="adsnark-nearly-practical-and-privacy-preserving-proofs-on-2014" />
  </article>
</BaseLayout>
