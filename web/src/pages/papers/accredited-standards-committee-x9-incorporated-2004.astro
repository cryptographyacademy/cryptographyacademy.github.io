---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/340';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Request for Review of Key Wrap Algorithms';
const AUTHORS_HTML = 'Morris Dworkin';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">A key wrap algorithm is a secret key algorithm for the authenticated encryption of specialized data such as cryptographic keys.  Four key wrap algorithms have been proposed for the draft ASC X9 standard, ANS X9.102.  NIST is serving as the editor of ANS X9.102, and, on behalf of the X9F1 working group, NIST requests a cryptographic review of the four algorithms.  This document specifies the algorithms and suggests security models for their analysis.  Comments will be accepted until May 21, 2005.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> authenticated encryption</p>
    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Notation</h2>

    <p class="text-gray-300">The following notational conventions apply to the specifications below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Variables are italicized: a single, lower case letter represents an integer; other variables, possibly with subscripts or superscripts, represent strings.</li>
      <li><span class="math">MSB_x(\\cdot)</span>  and  <span class="math">LSB_x(\\cdot)</span>  are the functions for the most and least significant x bits.</li>
      <li>AES<sub>K</sub>(&bull;) and TDEA<sub>K</sub>(&bull;) are the (forward) AES and TDEA algorithms under the key K; AES<sub>K</sub><sup>-1</sup>(&bull;) and TDEA<sub>K</sub><sup>-1</sup>(&bull;) are the inverse algorithms.</li>
      <li>The concatenation operation is denoted ||.</li>
      <li>The bit length of a string X is denoted |X|.</li>
      <li>The bit string consisting of x '0' bits is denoted  <span class="math">0^x</span> .</li>
      <li>Given a nonnegative integer x and a positive integer y such that  <span class="math">x &lt; 2^y</span> , the representation of x as a binary string of y bits is denoted  <span class="math">[x]_y</span> .</li>
    </ul>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 AESKW</h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Overview</h3>

    <p class="text-gray-300">A link to the original specification of AESKW is available at the NIST key management home page <a href="http://csrc.nist.gov/CryptoToolkit/kms/">http://csrc.nist.gov/CryptoToolkit/kms/</a>. The specification proposed for ANS X9.102 extends the original specification, mainly in the following two ways:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A formatting function including a padding scheme is specified for encoding the key data string into a sequence of blocks, i.e., the plaintext; thus, AESKW applies to key data strings of arbitrary length (up to the specified maximum).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A cleartext header may be authenticated, essentially by duplicating the header within the formatting of the key data string into the plaintext. The header is verified within the integrity check function that corresponds to the formatting function.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In practice, the header may be a representative, or message digest, of some other, larger string. In this case, of course, the scope of the integrity assurance extends to the message digest, but not necessarily to the larger string.</p>

    <p class="text-gray-300">Below are specifications of the elements of AESKW: the data requirements, the plaintext formatting function, the integrity check function, the wrapping function, and the unwrapping function.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Data Requirements for AESKW</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The header, H, shall be an octet string whose octet length is less than 256.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The number of plaintext blocks, n, shall satisfy  <span class="math">2 \\le n \\le 2^{32}</span> . Consequently, at least one of the two input strings to the formatting function, H and KeyData, shall be nonempty.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any given key protection key, no more than 2<sup>48</sup> inputs shall be wrapped in the lifetime of the key.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><em>Prerequisites</em>:</p>

    <p class="text-gray-300">&mdash;<em>ICV</em>, integrity check value of 48 bits.</p>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li>&mdash;KeyData, key data string.</li>
    </ul>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300"><span class="math">-P_1, P_2, ...P_n</span> : plaintext, n 64 bit semiblocks.</p>

    <p class="text-gray-300">Steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">s = (64 (|H| + |KeyData|)) \\mod 64</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">PadLen = [s]_8</span> , e.g., if s = 13 then Padlen = 00001101.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let <em>Hlen</em> be the binary representation of the octet length of <em>H</em> as a string of 8 bits.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">P_1, P_2, ...P_n</span>  be the sequence of semiblocks such that  <span class="math">P_1 \\parallel P_2 \\parallel ... \\parallel P_n = ICV \\parallel PadLen \\parallel Hlen \\parallel H \\parallel KeyData \\parallel 0^s</span> .</li>
    </ol></li>
    </ul>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 AESKW Integrity Check Function</h3>

    <p class="text-gray-300">Prerequisites:</p>

    <p class="text-gray-300">&mdash;ICV, integrity check value of 48 bits.</p>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li><span class="math">-P_1, P_2, ...P_n</span> : purported plaintext, sequence of 64 bit semiblocks.</li>
    </ul>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">&mdash;either &quot;INVALID&quot; or KeyData, a key data string.</p>

    <p class="text-gray-300">Steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the header length:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If H is not an octet string of octet length LSB<sub>8</sub>( <span class="math">P_1</span> ), then return &quot;INVALID.&quot;</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the header:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If <em>H</em> is not a prefix of  <span class="math">P_2 \\parallel P_3 \\parallel ... \\parallel P_n</span> , then return &quot;INVALID.&quot;</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the integrity check value:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">MSB_{48}(P_1) \\neq ICV</span> , then return &quot;INVALID.&quot;</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the padding:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let r be the integer whose binary representation is LSB<sub>8</sub>(MSB<sub>56</sub>( <span class="math">P_1</span> )).</li>
      <li>If r &gt; 63 or LSB<sub>r</sub> <span class="math">(P_n) \\neq 0^r</span> , then return &quot;INVALID&quot;; else, return the unique string <em>KeyData</em> such that  <span class="math">H \\parallel KeyData \\parallel 0^r = P_2 \\parallel P_3 \\parallel \\dots \\parallel P_n</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><em>Prerequisites</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;K: key protection key, established among all the parties to the data;</li>
      <li>&mdash;<em>ICV</em>, integrity check value of 48 bits.</li>
    </ul>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li>&mdash;KeyData, key data string.</li>
    </ul>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300"><span class="math">-C_1, C_2, ... C_n</span> : ciphertext, n 64 bit semiblocks.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Format the plaintext:</li>
    </ol>

    <p class="text-gray-300">Apply the plaintext formatting function (Section 4.3) to H and KeyData to produce  <span class="math">P_1, P_2, \\dots P_n</span> , a sequence of n 64 bit semiblocks for some n.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Initialize variables:</li>
    </ol>

    <p class="text-gray-300">Let
<span class="math">$A^0 = P_1</span>$
.
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">R_i^0 = P_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Calculate intermediate values:</li>
    </ol>

    <p class="text-gray-300">For
<span class="math">$t = 1, ..., s</span>$
, where  <span class="math">s = 6(n-1)</span> :</p>

    <p class="text-gray-300"><span class="math">$A^{t} = \\text{MSB}_{64}(\\text{AES}_{K}(A^{t-1} || R_{2}^{t-1})) \\oplus [t]_{64};</span>$
For  <span class="math">i = 2, ..., n-1</span> ,</p>

    <p class="text-gray-300"><span class="math">$R_{i}^{t} = R_{i+1}^{t-1};</span>$</p>

    <p class="text-gray-300"><span class="math">$R_{n}^{t} = \\text{LSB}_{64}(\\text{AES}_{K}(A^{t-1} || R_{2}^{t-1})).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the results:</li>
    </ol>

    <p class="text-gray-300">Let
<span class="math">$C_1 = A^s</span>$
.
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">C_i = R_i^s</span> .</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Diagram:</h4>

    <p class="text-gray-300">The following diagram illustrates the motion of the AESKW wrapping function. The variable that indexes the iterations, t, increases from 1 to 6(n-1). The plaintext formatting function is not illustrated.</p>

    <p class="text-gray-300">    <img src="_page_8_Figure_8.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Prerequisites</strong></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;K: key protection key, established among all the parties to the data;</li>
      <li>&mdash;<em>ICV</em>, integrity check value of 48 bits.</li>
    </ul>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li><span class="math">-C_1, C_2, ...C_n</span> : the ciphertext, n 64 bit semiblocks.</li>
    </ul>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">&mdash;either &quot;INVALID&quot; or KeyData, a key data string.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Initialize variables:</li>
    </ol>

    <p class="text-gray-300">Set
<span class="math">$A^s = C_1</span>$
, where  <span class="math">s = 6(n-1)</span> .
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">R_i^s = C_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Calculate the intermediate values:</li>
    </ol>

    <p class="text-gray-300">For
<span class="math">$t = s, s-1, ..., 1</span>$
:</p>

    <p class="text-gray-300"><span class="math">$A^{t-1} = \\text{MSB}_{64}(\\text{AES}^{-1}_{K}((A^{t} \\oplus [t]_{64}) \\parallel R_{n}^{t}));</span>$</p>

    <p class="text-gray-300"><span class="math">$R_{2}^{t-1} = \\text{LSB}_{64}(\\text{AES}^{-1}_{K}((A^{t} \\oplus [t]_{64}) \\parallel R_{n}^{t}));</span>$
For  <span class="math">i = 3, ..., n,</span></p>

    <p class="text-gray-300"><span class="math">$R_{i}^{t-1} = R_{i-1}^{t}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define the purported plaintext:</li>
    </ol>

    <p class="text-gray-300">Let
<span class="math">$P_1 = A^{0}</span>$
.
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">P_i = R_i^{0}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the purported plaintext:</li>
    </ol>

    <p class="text-gray-300">Apply the integrity check function (Section 4.4) to H and  <span class="math">P_1, P_2, ... P_n</span>  and return the result.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Diagram:</h4>

    <p class="text-gray-300">The following diagram illustrates the motion of the AESKW unwrapping function. The variable that indexes the iterations, t, decreases from 6(n-1) to 1. The integrity check function is not illustrated.</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_9.jpeg" alt="" class="my-4 max-w-full" />
</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 TDKW</h2>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Overview</h3>

    <p class="text-gray-300">TDKW is the analogue of AESKW with TDEA as the underlying block cipher. Thus, a semiblock now consists of 32 bits, and two semiblocks are essentially devoted to integrity protection.</p>

    <p class="text-gray-300">Below are specifications of the elements of TDKW: the data requirements, the formatting function, the integrity check function, the wrapping function, and the unwrapping function.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Data Requirements for TDKW</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The header, H, shall be an octet string whose octet length is less than 256.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The number of plaintext blocks, n, shall satisfy  <span class="math">2 \\le n \\le 2^{16}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any given key protection key, no more than  <span class="math">2^{32}</span>  inputs shall be wrapped in the lifetime of the key.</li>
    </ol></li>
    </ul>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 TDKW Plaintext Formatting Function</h3>

    <pre><code class="language-text">Prerequisites:
</code></pre>

    <p class="text-gray-300">&mdash;<em>ICV</em>, integrity check value of 48 bits.</p>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li>-KeyData, key data string.</li>
    </ul>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300"><span class="math">-P_1, P_2, ...P_n</span> : plaintext, n 32 bit semiblocks.</p>

    <p class="text-gray-300">Steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">s = (32-(|H| + |KeyData|)) \\mod 32</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">PadLen = [s]_8</span> , e.g., if s = 13 then Padlen = 00001101.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let <em>Hlen</em> be the binary representation of the octet length of <em>H</em> as a string of 8 bits.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">P_1, P_2, ... P_n</span>  be the sequence of semiblocks such that  <span class="math">P_1 \\parallel P_2 \\parallel ... \\parallel P_n = ICV \\parallel PadLen \\parallel Hlen \\parallel H \\parallel KeyData \\parallel 0^s</span> .</li>
    </ol></li>
    </ul>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 TDKW Integrity Check Function</h3>

    <p class="text-gray-300"><em>Prerequisites</em>:</p>

    <p class="text-gray-300">&mdash;ICV, integrity check value of 51 bits.</p>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li><span class="math">-P_1, P_2, ...P_n</span> : purported plaintext, sequence of 32 bit semiblocks.</li>
    </ul>

    <p class="text-gray-300">Outputs</p>

    <p class="text-gray-300">&mdash;either &quot;INVALID&quot; or KeyData, a key data string.</p>

    <p class="text-gray-300">Steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the header length:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If H is not an octet string of octet length LSB<sub>8</sub> <span class="math">(P_2)</span> , then return &quot;INVALID.&quot;</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the header:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If <em>H</em> is not a prefix of  <span class="math">P_3 \\parallel P_4 \\parallel \\dots \\parallel P_n</span> , then return &quot;INVALID.&quot;</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the integrity check value:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">MSB_{48}(P_1 \\parallel P_2) \\neq ICV</span> , then return &quot;INVALID.&quot;</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the padding:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Let r be the integer whose binary representation is LSB<sub>8</sub>(MSB<sub>24</sub>( <span class="math">P_2</span> )).</p>

    <p class="text-gray-300">If r &gt; 31 or LSB<sub>r</sub> <span class="math">(P_n) \\neq 0^r</span> , then return &quot;INVALID&quot;; else, return the unique string <em>KeyData</em> such that  <span class="math">H \\parallel KeyData \\parallel 0^r = P_3 \\parallel P_4 \\parallel \\dots \\parallel P_n</span> .</p>

      <h3 id="sec-5.5" class="text-xl font-semibold mt-8">5.5 TDKW Wrapping</h3>

    <p class="text-gray-300"><em>Prerequisites</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;K: key protection key, established among all the parties to the data;</li>
      <li>&mdash;ICV, integrity check value of 48 bits.</li>
    </ul>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li>&mdash;KeyData, key data string.</li>
    </ul>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300"><span class="math">-C_1, C_2, ... C_n</span> : ciphertext, n 32 bit semiblocks.</p>

    <p class="text-gray-300">Steps</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Format the key data and header into plaintext:</li>
    </ol>

    <p class="text-gray-300">Apply the plaintext formatting function (Section 5.3) to H and KeyData to produce  <span class="math">P_1, P_2, ... P_n</span> , a sequence of n 32 bit semiblocks for some n.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Initialize variables:</li>
    </ol>

    <p class="text-gray-300">Let
<span class="math">$A^0 = P_1</span>$
.
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">R_i^0 = P_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Calculate intermediate values:</li>
    </ol>

    <p class="text-gray-300">For
<span class="math">$t = 1, ..., s</span>$
, where  <span class="math">s = 6(n-1)</span> :</p>

    <p class="text-gray-300"><span class="math">$A^{t} = \\text{MSB}_{32}(\\text{TDEA}_{K}(A^{t-1} || R_{2}^{t-1})) \\oplus [t]_{32};</span>$
For  <span class="math">i = 2, ..., n-1</span> ,</p>

    <p class="text-gray-300"><span class="math">$R_{i}^{t} = R_{i+1}^{t-1};</span>$</p>

    <p class="text-gray-300"><span class="math">$R_{n}^{t} = \\text{LSB}_{32}(\\text{TDEA}_{K}(A^{t-1} || R_{2}^{t-1})).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the results:</li>
    </ol>

    <p class="text-gray-300">Let
<span class="math">$C_1 = A^s</span>$
.
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">C_i = R_i^s</span> .</p>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">See the analogous diagram for the AESKW wrapping function in Section 4.5.</p>

      <h3 id="sec-5.6" class="text-xl font-semibold mt-8">5.6 TDKW Unwrapping</h3>

    <p class="text-gray-300"><strong>Prerequisites</strong></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;K: key protection key, established among all the parties to the data;</li>
      <li>&mdash;ICV, integrity check value of 51 bits.</li>
    </ul>

    <p class="text-gray-300">Inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>, header string;</li>
      <li><span class="math">-C_1, C_2, ...C_n</span> : the ciphertext, n 32 bit semiblocks.</li>
    </ul>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">&mdash;either &quot;INVALID&quot; or KeyData, a key data string.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Initialize variables:</li>
    </ol>

    <p class="text-gray-300">Set
<span class="math">$A^s = C_1</span>$
, where  <span class="math">s = 6(n-1)</span> .
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">R_i^s = C_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Calculate the intermediate values:</li>
    </ol>

    <p class="text-gray-300">For
<span class="math">$t = s, s-1, ..., 1</span>$
:</p>

    <p class="text-gray-300"><span class="math">$A^{t-1} = \\text{MSB}_{32}(\\text{TDEA}^{-1}_{K}((A^{t} \\oplus [t]_{32}) \\parallel R_{n}^{t}));</span>$</p>

    <p class="text-gray-300"><span class="math">R_{2}^{t-1} = \\text{LSB}_{32}(\\text{TDEA}^{-1}_{K}((A^{t} \\oplus [t]_{32}) \\parallel R_{n}^{t}));</span>
For  <span class="math">i = 3, ..., n,</span>
<span class="math">R_{i}^{t-1} = R_{i-1}^{t}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define the purported plaintext:</li>
    </ol>

    <p class="text-gray-300">Let
<span class="math">$P_1 = A^{0}</span>$
.
For  <span class="math">i = 2, ..., n</span> ,
<span class="math">P_i = R_i^{0}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the purported plaintext:</li>
    </ol>

    <p class="text-gray-300">Apply the integrity check function (Section 5.4) to H and  <span class="math">P_1, P_2, ...P_n</span>  and return the result.</p>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">See the analogous diagram for the AESKW unwrapping function in Section 4.6.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 <strong>AKW1</strong></h2>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Overview</h3>

    <p class="text-gray-300">AKW2 essentially employs two passes of CBC encryption: the first pass over the plaintext and a hash-based integrity check value, the second pass in reverse order over the results of the first pass. The elements of AKW1 are specified below: the data requirements, the wrapping function, and the unwrapping function. The formatting of key data into plaintext is not explicitly specified.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Data Requirements for AKW1</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The number of plaintext blocks, n, shall satisfy  <span class="math">1 \\le n \\le 2^{16}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any given key protection key, no more than  <span class="math">2^{\\frac{1}{32}}</span>  inputs shall be wrapped in the lifetime of the key.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Prerequisites</strong></p>

    <p class="text-gray-300">&mdash;<em>K</em>: key protection key, established among all the parties to the data;</p>

    <p class="text-gray-300">Inputs:</p>

    <p class="text-gray-300"><span class="math">-P_1, P_2, ...P_n</span> : the plaintext, n 64 bit blocks.</p>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">&mdash;  <span class="math">C_1, C_2, ... C_{n+1}, C_{n+2}</span> : the ciphertext, n+2 64 bit blocks.</p>

    <p class="text-gray-300">Steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Use an approved random bit generator to generate a random block of 64 bits. Call the result <em>IV</em>.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">ICV = MSB_{64}(SHA1(P_1 || P_2 || ... || P_n))</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Encrypt  <span class="math">P_1 \\parallel P_2 \\parallel \\ldots \\parallel P_n \\parallel ICV</span> , using TDEA in CBC mode under K, with IV as the initialization vector. Call the resulting ciphertext TEMPI.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">TEMP2 = IV \\parallel TEMP1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Reverse the order of the octets in <em>TEMP2</em>. That is, the most significant (first) octet is swapped with the least significant (last) octet, and so on. Call the result <em>TEMP3</em>.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Encrypt <em>TEMP3</em> using TDEA in CBC mode under <em>K</em>, with the hexadecimal string 0x4adda22c79e82105 as the initialization vector. Return the result as the ciphertext.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><em>Diagram</em>:</p>

    <p class="text-gray-300">    <img src="_page_13_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

      <h3 id="sec-6.4" class="text-xl font-semibold mt-8"><strong>6.4 AKW1 Unwrapping</strong></h3>

    <p class="text-gray-300"><em>Prerequisites</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>K</em>: key protection key, established among all the parties to the data<em>. Inputs</em>:</li>
      <li>&mdash;<em>C</em>1, <em>C</em>2, &hellip; <em>Cn</em>+1<em>, Cn</em>+2: the ciphertext, <em>n</em>+2 64 bit blocks.</li>
    </ul>

    <p class="text-gray-300"><em>Outputs</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;either &quot;INVALID&quot; or <em>P</em>1, <em>P</em>2, &hellip;<em>Pn</em>: the plaintext sequence of <em>n</em> 64 bit blocks. <em>Steps</em>:</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Decrypt the ciphertext using TDEA in CBC mode under <em>K</em>, with the hexadecimal string 0x4adda22c79e82105 as the initialization vector. Call the result TEMP3.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Reverse the order of the octets in TEMP3. That is, the most significant (first) octet is swapped with the least significant (last) octet, and so on. Call the result TEMP2.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let <em>IV</em> be the single block and TEMP1 the concatenation of <em>n</em>+1 blocks such that TEMP2 = <em>IV</em> || TEMP1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Decrypt TEMP1 using TDEA in CBC mode under <em>K</em>, with <em>IV</em> as the initialization vector. Call the result TEMP.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let <em>P</em>1, <em>P</em>2, &hellip;<em>Pn, ICV</em> be the <em>n</em>+1 blocks for which TEMP = <em>P</em>1 || <em>P</em>2|| &hellip;|| <em>Pn</em> || <em>ICV</em>.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If MSB64(SHA1(<em>P</em>1 || <em>P</em>2 || &hellip;|| <em>Pn</em>)) = <em>ICV</em>, then return <em>P</em>1, <em>P</em>2, &hellip;, <em>Pn</em> as the plaintext; else, return &quot;INVALID.&quot;</li>
    </ol></li>
    </ul>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8"><em>Diagram</em>:</h3>

    <p class="text-gray-300">The following is a diagram of the AKW1 unwrapping function; the verification of the integrity check value is not illustrated.</p>

    <p class="text-gray-300">    <img src="_page_14_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 <em>AKW</em>2</h2>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8">7.1 Overview</h3>

    <p class="text-gray-300">AKW2 is essentially CBC mode encryption followed by CBC-MAC authentication of the header and ciphertext, where the two keys are related to the key protection key, and hence to each other, by a constant exclusive-OR difference. The data requirements, the wrapping function, and the unwrapping function for AKW2 are specified in Sections 7.2., 7.3, and 7.4, respectively.</p>

    <p class="text-gray-300">The formatting of the key data string into plaintext blocks, although mandated in the data requirements and verified within the unwrapping function, is not explicitly specified.</p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8">7.2 Data Requirements for AKW2</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The number of plaintext blocks, n, shall satisfy  <span class="math">2 \\le n \\le 2^{16}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any given key protection key, no more than  <span class="math">2^{\\overline{32}}</span>  inputs shall be wrapped in the lifetime of the key.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The parameter <em>Tlen</em> shall be chosen between 32 and 64 and fixed for any given key protection key.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The function for formatting valid key data strings into plaintext shall be one-to-one, i.e., unambiguously parsible.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>One (or more) of the following conditions shall be met:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a) The parameter <em>Tlen</em> is 32.</li>
      <li>b) The formatting of the first block of the header includes an explicit encoding of the length of the string  <span class="math">H_1 \\parallel H_2 \\parallel ... \\parallel H_i \\parallel C_1 \\parallel C_2 \\parallel ... \\parallel C_n \\parallel T</span> .</li>
      <li>c) The length of the plaintext is fixed for any given header.</li>
    </ul></li>
    </ul>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8"><strong>7.3 AKW2 Wrapping</strong></h3>

    <h3 id="sec-misc-4" class="text-xl font-semibold mt-8"><em>Prerequisites</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>K</em>, key protection key, established among all the parties to the data;</li>
      <li>r parameter; &mdash;<em>Tlen</em>, an intege</li>
      <li>&mdash;plaintext formatting function.</li>
    </ul>

    <h3 id="sec-misc-5" class="text-xl font-semibold mt-8"><em>Input</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>s; &mdash;<em>H</em>1, <em>H</em>2, ... , <em>Hj</em>: <em>j</em> header block</li>
      <li>2, &hellip;<em>P</em> : formatted plaintext, a sequence of 64 bit blocks. &mdash; <em>P</em>1, <em>P <sup>n</sup></em></li>
    </ul>

    <h3 id="sec-misc-6" class="text-xl font-semibold mt-8"><em>Output</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>C</em>1, <em>C</em>2, &hellip;<em>Cn</em>: the ciphertext, a sequence of 64 bit blocks;</li>
      <li><em>Tlen.</em> &mdash;<em>T</em>, message authentication code of bit length</li>
    </ul>

    <h3 id="sec-misc-7" class="text-xl font-semibold mt-8"><em>Steps</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>K</em>', by exclusive-ORing each octet ncluding parity bits) with 0x45. Similarly, derive the TDEA authentication 1) Derive the TDEA confidentiality subkey, denoted of <em>K</em>, (i subkey, denoted <em>K</em>'', by exclusive-ORing each octet of <em>K</em> with 0x4D.</li>
      <li>key, 2) Encrypt the plaintext using the CBC mode of TDEA with the confidentiality sub K', and initialization vector <em>H</em>1 to produce <em>C</em>1, <em>C</em>2, &hellip;<em>Cn</em>, the ciphertext.</li>
      <li>AC: 3) Apply the CBC-MAC mode of TDEA with the authentication subkey, <em>K</em>'', to the header blocks concatenated with the ciphertext blocks to produce the M</li>
      <li>a) Let <em>A</em>0 = 064.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>b) For <em>i</em> = 1 to <em>j</em>, let <em>Ai</em> = TDE<em>AK</em>''(<em>Hi</em> &oplus; <em>Ai</em>-1).</li>
      <li>c) Let <em>B</em>0 = <em>Aj</em>.</li>
      <li>d) For <em>i</em> = 1 to <em>n</em>, let <em>Bi</em> = TDEA<em>K</em>''(<em>Ci</em> &oplus; <em>Bi</em>-1).</li>
      <li>(<em>B</em> ). e) Let <em>T</em> = MSB<em>Tlen <sup>n</sup></em></li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return <em>C</em>1, <em>C</em>2, ..., <em>Cn</em>, <em>T</em>.</li>
    </ol></li>
    </ul>

    <h3 id="sec-misc-8" class="text-xl font-semibold mt-8"><em>Steps</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>ntiality subkey, denoted <em>K</em>', by exclusive-ORing each octet ncluding parity bits) with 0x45. Similarly, derive the TDEA authentication 1) Derive the TDEA confide of <em>K</em>, (i subkey, denoted <em>K</em>'', by exclusive-ORing each octet of <em>K</em> with 0x4D.</li>
      <li>key, 2) Encrypt the plaintext using the CBC mode of TDEA with the confidentiality sub K', and initialization vector <em>H</em>1 to produce <em>C</em>1, <em>C</em>2, &hellip;<em>Cn</em>, the ciphertext.</li>
      <li>AC: 3) Apply the CBC-MAC mode of TDEA with the authentication subkey, <em>K</em>'', to the header blocks concatenated with the ciphertext blocks to produce the M</li>
      <li>a) Let <em>A</em>0 = 064.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>b) For <em>i</em> = 1 to <em>j</em>, let <em>Ai</em> = TDE<em>AK</em>''(<em>Hi</em> &oplus; <em>Ai</em>-1).</li>
      <li>c) Let <em>B</em>0 = <em>Aj</em>.</li>
      <li>d) For <em>i</em> = 1 to <em>n</em>, let <em>Bi</em> = TDEA<em>K</em>''(<em>Ci</em> &oplus; <em>Bi</em>-1).</li>
      <li>(<em>B</em> ). e) Let <em>T</em> = MSB<em>Tlen <sup>n</sup></em></li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return <em>C</em>1, <em>C</em>2, ..., <em>Cn</em>, <em>T</em>.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><em>Diagram</em>:</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

      <h3 id="sec-7.4" class="text-xl font-semibold mt-8"><strong>7.4 AKW2 Unwrapping</strong></h3>

    <h3 id="sec-misc-9" class="text-xl font-semibold mt-8"><em>Prerequisites</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>K</em>, key protection key, established among all the parties to the data;</li>
      <li>&mdash;<em>Tlen</em>, an integer parameter;</li>
      <li>&mdash;a plaintext formatting function.</li>
    </ul>

    <h3 id="sec-misc-10" class="text-xl font-semibold mt-8"><em>Input</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&mdash;<em>H</em>1, <em>H</em>2, ... , <em>Hj</em>: <em>j</em> header blocks;</li>
      <li>&mdash;<em>C</em>1, <em>C</em>2, &hellip;<em>Cn</em>: ciphertext, <em>n</em> 64 bit blocks;</li>
      <li>&mdash;<em>T'</em>, the purported message authentication code of bit length <em>Tlen</em>.</li>
    </ul>

    <h3 id="sec-misc-11" class="text-xl font-semibold mt-8"><em>Output</em>:</h3>

    <p class="text-gray-300">&mdash;either &quot;INVALID&quot; or <em>KeyData</em>, the key data string.</p>

    <h3 id="sec-misc-12" class="text-xl font-semibold mt-8"><em>Steps</em>:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Derive the TDEA confidentiality subkey, denoted <em>K</em>', by exclusive-ORing each octet of <em>K</em>, (including parity bits) with 0x45. Similarly, derive the TDEA authentication subkey, denoted <em>K</em>'', by exclusive-ORing each octet of <em>K</em> with 0x4D.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Apply the CBC-MAC mode of TDEA with the authentication subkey to the header blocks concatenated with the ciphertext blocks to produce the MAC:</li>
    </ol></li>
      <li>a) Let <em>A</em>0 = 064.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>b) For <em>i</em> = 1 to <em>j</em>, let <em>Ai</em> = TDEA<em>K</em>'' (<em>H</em>i&oplus; <em>Ai</em>-1).</li>
      <li>c) Let <em>B</em>0 = <em>Aj</em>.</li>
      <li>d) For <em>i</em> = 1 to <em>n</em>, let <em>Bi</em> = TDEA<em>K</em>'' (<em>Ci</em> &oplus; <em>Bi</em>-1).</li>
      <li>e) Let <em>T</em> = <em>Bn</em>.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compare the purported MAC to the MAC that was produced in Step 2: if <em>T</em> = <em>T'</em>, then continue to Step 4; else return &quot;INVALID.&quot;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Decrypt <em>C</em>1, <em>C</em>2, &hellip;<em>Cn</em> using the CBC mode of TDEA with the confidentiality subkey K' and initialization vector <em>H</em>1 to produce <em>P</em>1, <em>P</em>2, ..., <em>Pn</em>.</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify the formatting of the plaintext with respect to the header, including the applicable element of Data Requirement 5 in Section 7.2. If the plaintext is validly formatted, return  <span class="math">P_1</span> ,  <span class="math">P_2</span> , ...,  <span class="math">P_n</span> ; else return &quot;INVALID.&quot; <em>Diagram</em>:</li>
    </ol>

    <p class="text-gray-300">    <img src="_page_17_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    </section>
`;
---

<BaseLayout title="Request for Review of Key Wrap Algorithms (2004/340)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/340
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="accredited-standards-committee-x9-incorporated-2004" />
  </article>
</BaseLayout>
