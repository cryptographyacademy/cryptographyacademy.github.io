---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/353';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fully-succinct Publicly Verifiable Delegation from Constant-Size Assumptions';
const AUTHORS_HTML = 'Alonso González, Alexandros Zacharakis';

const CONTENT = `    <p class="text-gray-300">Fully-succinct Publicly Verifiable Delegation from Constant-Size Assumptions</p>

    <p class="text-gray-300">Alonso González*¹ and Alexandros Zacharakis†²</p>

    <p class="text-gray-300">¹Toposware Inc. ²Universitat Pompeu Fabra, Barcelona, Spain</p>

    <p class="text-gray-300">alonso.gonzalez@toposware.com, alexandros.zacharakis@upf.edu</p>

    <p class="text-gray-300">September 17, 2021</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">We construct a publicly verifiable, non-interactive delegation scheme for any polynomial size arithmetic circuit with proof-size and verification complexity comparable to those of pairing based zk-SNARKS. Concretely, the proof consists of <span class="math">O(1)</span> group elements and verification requires <span class="math">O(1)</span> pairings and <span class="math">n</span> group exponentiations, where <span class="math">n</span> is the size of the input. While known SNARK-based constructions rely on non-falsifiable assumptions, our construction can be proven sound under any constant size (<span class="math">k \\geq 2</span>) <span class="math">k</span>-Matrix Diffie-Hellman (<span class="math">k</span>-MDDH) assumption. However, the size of the reference string as well as the prover's complexity are quadratic in the size of the circuit. This result demonstrates that we can construct delegation from very simple and well-understood assumptions. We consider this work a first step towards achieving practical delegation from standard, falsifiable assumptions.</p>

    <p class="text-gray-300">Our main technical contributions are first, the introduction and construction of what we call "no-signaling, somewhere statistically binding commitment schemes". These commitments are extractable for any small part <span class="math">x_{S}</span> of an opening <span class="math">x</span>, where <span class="math">S \\subseteq [n]</span> is of size at most <span class="math">K</span>. Here <span class="math">n</span> is the dimension of <span class="math">x</span> and <span class="math">x_{S} = (x_{i})_{i \\in S}</span>. Importantly, for any <span class="math">S&#x27; \\subseteq S</span>, extracting <span class="math">x_{S&#x27;}</span> can be done independently of <span class="math">S \\setminus S&#x27;</span>. Second, we use these commitments to construct more efficient "quasi-arguments" with no-signaling extraction, introduced by Paneth and Rothblum (TCC 17). These arguments allow extracting parts of the witness of a statement and checking it against some local constraints without revealing which part is checked. We construct pairing-based quasi arguments for linear and quadratic constraints and combine them with the low-depth delegation result of González et. al. (Asiacrypt 19) to construct the final delegation scheme.</p>

    <p class="text-gray-300">*This work was done while the author was part of LIP laboratory at the ENS de Lyon, France †Research supported by fellowships from la Caixa Foundation (ID 100010434). The fellowship code is LCF/BQ/DI18/11660053. Funding is also from the European Unions Horizon 2020 research and innovation program under the Marie Skłodowska-Curie grant agreement No. 713673.</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Our results 2</p>

    <p class="text-gray-300">2 Technical Overview 4 2.1 No-Signaling Somewhere Statistically Binding Commitments/Hashing 4 2.1.1 SSB Commitments with Oblivious Trapdoor Generation. 5 2.1.2 Constructing Oblivious SSB Commitments. 6 2.2 Pairing-based Quasi-Arguments 8 2.2.1 Preliminaries 9 2.2.2 Oblivious Trapdoor Generation for Quasi-Arguments 11 2.2.3 Quasi-Arguments of Membership in a Linear Space 12 2.2.4 Quasi-Argument of Hadamard Products 13 2.3 From our Quasi-Arguments to Delegation. 15 2.3.1 Delegating bounded space TM/bounded width circuits 15 2.3.2 Overcoming the dependence on space/width. 18 2.4 NIZK, SNARKs and Compact NIZK 20</p>

    <p class="text-gray-300">3 Preliminaries 21 3.1 Notation 21 3.2 Cryptographic Assumptions 22 3.3 Arguments of Knowledge Transfer 23</p>

    <p class="text-gray-300">4 No-Signaling Somewhere Statistically Binding Commitments 24 4.1 Algebraic SSB Commitments. 26 4.2 Somewhere Statistically Binding Commitments with Oblivious Trapdoor Generation 27 4.3 Kronecker Product of two SSB commitments 31</p>

    <p class="text-gray-300">5 Quasi-Arguments with Preprocessing 34 5.1 Arguments with No-signaling extraction and Oblivious CRS Generation 35 5.2 Succinct Pairing Based Quasi-Arguments 38 5.2.1 Quasi Arguments of Membership in Linear Spaces 38 5.2.2 Quasi-Arguments for Hadamard Products. 55</p>

    <p class="text-gray-300">6 Delegation for Arithmetic Circuit Evaluation 62 6.1 The Scheme 62 6.2 Proof of Security 63</p>

    <p class="text-gray-300">7 Applications 66 7.1 NIZK arguments for NP. 67</p>

    <p class="text-gray-300">A Delayed proof from Section 3.3 75</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">In a delegation scheme, a verifier with limited computational resources (a mobile device for example) wishes to delegate a heavy but still polynomial computation to an untrusted prover. The prover, with more computational power but still of polynomial time, computes a proof which the verifier accepts or rejects. Given the limitations of the verifier, the proof should be as short as possible and the verification process should consume as few computational resources as possible. Additionally, the construction of the proof should not be much costlier than performing the computation itself.</p>

    <p class="text-gray-300">A delegation scheme can be easily constructed from a zero-knowledge Succinct Non-Interactive Argument of Knowledge (zk-SNARK) for NP. Schemes like <em>[x13, x15]</em> are very appealing in practice because a proof consists of only a constant number of group elements and verification requires the evaluation of a constant number of pairings. The downside is that these zk-SNARKs are based on strong and controversial assumptions such as the knowledge of exponent assumption or the generic group model.</p>

    <p class="text-gray-300">Such assumptions are called non-falsifiable because there is no way of efficiently deciding whether an adversary breaks the assumption or not. In such assumptions, the adversary is treated in a non black box way and the assumption argues about <em>how</em> an adversary performs a computation instead of <em>what</em> computation it cannot perform. Since zk-SNARKs can handle even NP computations, soundness becomes an essentially non-falsifiable property where one needs to decide whether an adversary produces a true or false statement without any witness but only with a very short proof. Gentry and Wichs <em>[x16]</em> proved that zk-SNARKs for NP are (in a broad sense) impossible to construct without resorting to non-falsifiable assumptions.</p>

    <p class="text-gray-300">While this impossibility result justifies the use of such assumptions for non-deterministic computation, this is not the case for delegation of computation which only considers deterministic computation. Indeed, in this case, soundness becomes an efficiently falsifiable statement: determining whether the adversary breaks soundness simply requires to evaluate the delegated polynomial computation on some input <span class="math">x</span> and check whether it is accepting or rejecting. Actually, getting delegation from falsifiable assumptions is easy in general: let <span class="math">\\Pi</span> be a SNARK for NP. For a binary relation <span class="math">R</span>, the assumption “<span class="math">\\Pi</span> is sound for <span class="math">R</span>” is in general non-falsifiable since checking membership in the corresponding language is hard and the SNARK proof does not help as shown by <em>[x16]</em>. On the contrary, for a relation <span class="math">R</span> in P, the assumption becomes falsifiable since one can efficiently compute <span class="math">R(x)</span>. Nevertheless, the important issue is to consider the <em>quality</em> of the assumption in place since the assumption “the proof system is sound” is tautological. Ideally, we should rely on simple and well understood assumptions <em>without</em> sacrificing other desirable properties.</p>

    <p class="text-gray-300">Almost all known constructions that base their soundness on falsifiable assumptions (or even no assumptions at all) come with some compromises: they (1) are not expressive enough to capture all polynomial time computation <em>[x20, x19, CCH+19, x11]</em> (2) are interactive <em>[x18, x30]</em>, (3) are designated verifier <em>[x21, x22, x14, BHK17, BKK+18]</em> or (4) rely on strong (yet falsifiable) assumptions related to obfuscation <em>[x7, x23, BGL+15, ACC+16, CCC+16]</em> or multi-linear maps <em>[x31]</em>.</p>

    <p class="text-gray-300">An exception to this is a construction of Kalai et al. <em>[x22]</em> of a delegation scheme for any poly-time computation based on a newly introduced <span class="math">q</span>-size assumption in bilinear groups. The size of the assumption is <span class="math">q=\\log T</span> and <span class="math">T</span> is the time needed to perform the computation. As for efficiency, the size of the proof is <span class="math">\\mathsf{polylog}(T)</span> group elements which becomes <span class="math">\\mathsf{poly}(\\kappa)</span> if <span class="math">T\\leq 2^{\\kappa}</span>.</p>

    <p class="text-gray-300">However, in spite of the recent progress, there’s still a gap in the proof size and verification with respect to the most efficient known constructions, namely those based on paring based</p>

    <p class="text-gray-300">2k-SNARKs.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Our results</h3>

    <p class="text-gray-300">In this work we consider the question <em>“what are the simplest assumptions that imply publicly verifiable, non-interactive delegation of computation”?</em> Here <em>“simple”</em> should be interpreted as falsifiable and well understood. Having practicality in mind as well, we would also want a delegation scheme that competes in efficiency with the most efficient constructions to date, namely those that are based on non-falsifiable assumptions.</p>

    <p class="text-gray-300">The main contribution of this work is the construction of a fully-succinct, non-interactive, publicly verifiable delegation scheme from any <span class="math">k</span>-Matrix Diffie-Hellman assumption (<span class="math">k</span>-MDDH) for <span class="math">k\\geq 2</span>, as for example the decisional linear assumption (DLin) <em>[x1]</em>. In the more efficient setting of asymmetric groups, soundness can be based on the natural translation of symmetric DLin where the challenge is encoded in both groups (the SDlin assumption of <em>[x13]</em>). Here by fully-succinct we mean that the proof size is linear in the security parameter and verification requires a linear number of operations (whose complexity depends only on the security parameter) in the size of the input of the computation. We achieve these goals but with the drawback that the prover computation and the size of the crs are quadratic in the size of the circuit. Our main contribution is summarized in the next (informal) theorem.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Theorem 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Informal). There exists a non-interactive, publicly verifiable delegation scheme for any polynomial size circuit <span class="math">C</span> with <span class="math">n</span>-size input that is adaptively sound under any <span class="math">k</span>-MDDH assumption for <span class="math">k\\geq 2</span> with the following efficiency properties: the crs size is $\\mathsf{poly}(\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}<span class="math">, prover complexity is </span>\\mathsf{poly}(\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}<span class="math">, proof size is </span>\\mathsf{poly}(\\kappa)<span class="math"> and verification complexity is </span>\\mathsf{poly}(\\kappa)n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our construction is also concretely efficient as far as proof size and verification complexity are concerned. The proof comprises of 10+8 group elements of an asymmetric bilinear group and verification requires <span class="math">n</span> exponentiations plus 36 evaluations of the pairing function, where <span class="math">n</span> is the size of the input. The attractive concrete efficiency is achieved due to the structure-preserving nature <em>[x1]</em> of our construction. This notion captures that all algorithms solely perform group operations, namely they are <em>algebraic</em>, and there is no need to encode cryptographic primitives such as hash functions or pairings as arithmetic circuits, a process that is very inefficient in practice.</p>

    <p class="text-gray-300">This result demonstrates two things. First, delegation of computation can be based on very simple, standard assumptions. Second, its structure preserving nature hints to the plausibility of practically efficient delegation schemes comparable in efficiency with the ones based on SNARKs, but under simple, standard assumptions. In table 1 we present a comparison of our delegation of computation construction with other pairing based schemes.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">No-Signaling SSB Commitments and Succinct Pairing-based Quasi-Arguments.</h5>

    <p class="text-gray-300">We follow and extend the ideas of Paneth and Rothblum <em>[x24]</em> and Kalai et al. <em>[x20]</em> for constructing delegation schemes for poly-time computations from what they called quasi-arguments of knowledge with no-signaling extractors. First, we formalize a similar notion for commitment schemes and show that the somewhere statistically binding (SSB) commitments of <em>[x13, x15]</em> are no-signaling when they also have what we call an “oblivious trapdoor generator”. Second, we use the no-signaling SSB commitments to construct more efficient constant-sized quasi-arguments of knowledge for linear and quadratic relations. We achieve this by combining SSB commitments with the very efficient quasi-adaptive non-interactive zero-knowledge arguments for linear <em>[x16, x18, x19, x21]</em> and quadratic relations <em>[x13, x6]</em>. To this aim, we also show that the QA-NIZK arguments can be easily modified to have no-signaling extractors under standard assumptions.</p>

    <p class="text-gray-300">Table 1: Comparison between different pairing based delegation schemes and our results.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Language</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GGPR13][Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">AC</td>

            <td class="px-3 py-2 border-b border-gray-700">ne + O(1)p</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Non Falsifiable</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[KPY19] (base case)</td>

            <td class="px-3 py-2 border-b border-gray-700">RM</td>

            <td class="px-3 py-2 border-b border-gray-700">ne + poly(log d)p</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κ log d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O((n + d)κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">log d-Assumption</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GR19]</td>

            <td class="px-3 py-2 border-b border-gray-700">AC</td>

            <td class="px-3 py-2 border-b border-gray-700">ne + O(d)p</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dκ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">s-Assumption</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">AC</td>

            <td class="px-3 py-2 border-b border-gray-700">ne + O(1)p</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">2κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">DLin/SDLin</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification is given in number exponentiations (e) and pairings (p).  <span class="math">d</span>  is the circuit depth/number of steps of a computation,  <span class="math">n</span>  the number of inputs,  <span class="math">s</span>  the circuit width/computation space and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  the circuit size. AC stands for "Arithmetic Circuit" and RM for "RAM Machine". For [KPY19] we only consider the "base case" and not the "bootstrapped" constructions, because bootstrapping adds a considerable overhead and is thus incomparable in terms of group operations. We stress out, however, that the crs size of the bootstrapped construction is sublinear in the time of the computation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applications to NIZK. Our construction can be turned into a NIZK argument for NP of size  <span class="math">n + O(1)</span>  group elements -namely  <span class="math">O(n\\kappa)</span>  proof size- under the same assumptions where  <span class="math">n</span>  is the number of public an secret inputs of the circuit. In table 2 we provide a comparison of our NIZK construction and the literature. Using standard techniques, the argument implies compact NIZK for NP with proof size  <span class="math">O(n) + \\mathrm{poly}(\\kappa)</span> . That is, the size of the proof is proportional to the size of the input and the security parameter only gives an additive overhead. In comparison, the state of the art is  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + \\mathrm{poly}(\\kappa)<span class="math">  for poly-sized boolean circuits and  </span>O(n) + \\mathrm{poly}(\\kappa)$  for log-depth boolean circuits [KNYY19; KNYY20]. We note that a similar result can be obtained by [KPY19], albeit with a stronger assumption.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Comparison between different pairing based NIZK schemes and our results.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Language</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GOS06]</td>

            <td class="px-3 py-2 border-b border-gray-700">AC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)p</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">SXDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GGPR13][Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">AC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)p</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Non Falsifiable</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GR19]</td>

            <td class="px-3 py-2 border-b border-gray-700">BC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n+d)p</td>

            <td class="px-3 py-2 border-b border-gray-700">O((n+d)κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">s-Assumption</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[KNYY20]</td>

            <td class="px-3 py-2 border-b border-gray-700">NC1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)poly(κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">npoly(κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">, κ, 2d)</td>

            <td class="px-3 py-2 border-b border-gray-700">DLin</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">BC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)p</td>

            <td class="px-3 py-2 border-b border-gray-700">nO(κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">2κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">DLin/SDLin</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification is given in number of pairings p.  <span class="math">d</span>  is the circuit depth,  <span class="math">n</span>  the number of (public and secret) inputs,  <span class="math">s</span>  the circuit width and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  the circuit size. AC stands for "Arithmetic Circuit" and BC for "Boolean Circuit".</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our argument can be also used to construct zk-SNARKs from quantitatively weaker assumptions than the state of the art. Indeed, the strongest assumption used in zk-SNARKs such as [GGPR13; Gro16] is a knowledge assumption which states that an adversary computing some elements of a bilinear group, satisfying a particular relation, must know their discrete logarithms. Such assumption is used to extract an assignment to each of the circuit wires. The "size" of such assumption is proportional to the number of extracted values, which in this case is the size of the circuit. Since our argument only requires the reduction to know the input of the circuit, we can rely on a knowledge assumption only for extracting the input. As a consequence the size of the assumption is drastically shortened. Since these assumptions are</p>

    <p class="text-gray-300">stronger as the size of the assumption increases and given that we lack good understanding of them, it is always safer to rely on shorter assumptions. Also, weaker assumptions translates to better concrete efficiency by using smaller security parameters.³</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Technical Overview</h2>

    <p class="text-gray-300">To construct the delegation scheme we follow a commit-and-prove approach, which means that we first commit to the witness (the satisfying assignment of wires in a circuit) and then show that this witness satisfies some relation. We use somewhere statistically binding (SSB) commitments as those used in [GHR15b; GR16; FLPS20] and show that they satisfy a no-signaling extraction property. Then, we do the same for the so called quasi-adaptive NIZK arguments for linear spaces [JR13; LPJY13; JR14; KW15] and for quadratic relations [GHR15b; DGP+19]. From these primitives we can construct delegation for bounded-space computations/bounded width circuits with proof-size independent of the depth of the computation by following the techniques of [PR17; KPY19]. To get a succinct proof-size, in addition to the "depth compression" we must also perform a "width compression". To this end, we use ideas from the delegation scheme for bounded depth computations of González and Råfols [GR19] and remove the necessity of a  <span class="math">q</span> -assumption to rely solely on constant size assumptions. To combine both "compressions" efficiently we exploit the fact that [GR19] is structure preserving and the verifier is a bounded width circuit. In the next sections we present these techniques.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2.1 No-Signaling Somewhere Statistically Binding Commitments/Hashing</h2>

    <p class="text-gray-300">Somewhere statistically binding (SSB) hashing/commitments⁴ were introduced by Hubacek and Wichs [HW15] and then improved by [OPWW15], and have been used for constructing efficient NIZK proofs [GHR15b; GR16] as well as ring signatures [BDH+19].</p>

    <p class="text-gray-300">An SSB commitment scheme is a generalization of dual mode commitments [GS08] where the commitment key can be sampled from many computationally indistinguishable distributions, each of which is making the commitments statistically binding for a number of  <span class="math">K</span>  coordinates of the commited value. That is, when committing to a vector  <span class="math">\\pmb{m} = (m_{1},\\dots,m_{n})</span>  with a commitment key  <span class="math">ck_{S}</span>  associated with a set  <span class="math">S\\subseteq [n]</span>  of size at most  <span class="math">K</span> , no (even computationally unbounded) adversary can compute a commitment  <span class="math">c</span>  and two valid openings  <span class="math">\\pmb{m},\\pmb{m}&#x27;</span>  such that for some  <span class="math">i\\in S</span>  it holds that  <span class="math">m_{i}\\neq m_{i}^{\\prime}</span> , except with negligible probability. Importantly, the size of the commitment  <span class="math">c</span>  should be independent of  <span class="math">n</span>  but may depend on the value  <span class="math">K</span> .</p>

    <p class="text-gray-300">Known SSB commitments constructions are also extractable, that is, there exists an efficient algorithm that has some trapdoor information associated with  <span class="math">ck_{S}</span>  and can efficiently extract from a commitment  <span class="math">c</span>  a valid opening  <span class="math">(m_{i})_{i\\in S}</span> . Note that the notion of a "valid opening" is well-defined due to the statistical binding property on the set  <span class="math">S</span> .</p>

    <p class="text-gray-300">We argue that the SSB extractor has many similarities with the no-signaling extractors of [PR17; KPY19]. First, we briefly recall what a no-signaling extractor is in the context of quasi arguments of knowledge. A quasi argument is a proof system for a relation that defines</p>

    <p class="text-gray-300">³We note, however, that in the case of non-falsifiable assumptions it not clear how an appropriate security parameter should be chosen.</p>

    <p class="text-gray-300">⁴Through this paper we will refer to "commitments" while technically they are "hashes". We do so because in the context of NIZK proofs is traditional to commit to the witness and then prove that the committed value satisfy some relation. However, since we are less interested in zero-knowledge, the randomness of such commitments is 0 (or fixed/inexistent) and we end up with hashes.</p>

    <p class="text-gray-300">⁵In the context of bilinear groups, we can consider  <span class="math">f</span> -extraction where one only extracts  <span class="math">f</span>  applied to the witness. In particular, it is usual to consider  <span class="math">f</span>  the (one-way) function that maps elements in  <span class="math">\\mathbb{Z}_p</span>  to one of the base groups  <span class="math">\\mathbb{G}_1</span>  or  <span class="math">\\mathbb{G}_2</span> . This is the notion of extractability we use in this work and is enough to obtain our results.</p>

    <p class="text-gray-300">some local constraints on the statement/witness pair. The requirement is that there exists a no signaling extractor that allows extracting a part of the witness from a verifying proof that is locally correct. Furthermore, each part of the extracted local witness can be in a sense extracted independently. This is formalized by requiring that extracting local witness <span class="math">w_{S}</span> for a set <span class="math">S</span> and restricting it to the variables <span class="math">S^{\\prime}\\subseteq S</span> is computationally indistinguishable from extracting <span class="math">w_{S^{\\prime}}</span> for the set <span class="math">S^{\\prime}</span>. As we shall see shortly, this property is extremely useful when constructing delegation schemes.</p>

    <p class="text-gray-300">In the case of SSB commitments, extractability of the local opening is just a local soundness guarantee. Additionally, indistinguishability of the commitment keys is a weaker form of the no-signaling property. Indeed, a no-signaling extractor must produce commitment keys which are indistinguishable for the various possible extractable sets. Otherwise a distinguisher for sets <span class="math">S,S^{\\prime}</span> can be used for wining in the no-signaling game even without the extracted value. Nevertheless, this alone does not satisfy the no-signaling property: some information about the positions where the crs is programmed to extract might be revealed by (parts of) the extracted local openings.</p>

    <p class="text-gray-300">We strengthen the indistinguishability property of the distributions of the commitment keys of SSB commitments to give them a no-signaling flavour. Roughly speaking, we require that the distributions of the commitment keys are computationally indistinguishable even if the adversary has access to local openings associated with a set <span class="math">S^{\\prime}</span> of committed values. These local openings trivially reveal information about the set <span class="math">S^{\\prime}</span> but we require that they do not leak information about the values outside of <span class="math">S^{\\prime}</span>. That is, for any sets <span class="math">S^{\\prime}\\subseteq S</span> of size at most <span class="math">K</span>, the commitment keys <span class="math">ck_{S},ck_{S^{\\prime}}</span> are computationally indistinguishable even if we allow the distinguisher access to local openings of <span class="math">S^{\\prime}</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Remark (Connection with PIR).</h6>

    <p class="text-gray-300">Somewhere statistically binding commitments/hashing is closely related with single server Private Information Retrieval Schemes (PIR) when the SSB commitment is also extractable. Indeed, we can think of the commitment key for an index <span class="math">i</span> of the SSB as a PIR query and the commitment/hash as the PIR answer. Then, one can decode the PIR query using the trapdoor associated with the commitment key. In our work, the SSB commitments we use are different from PIRs in three ways: (1) we do not extract the PIR answers, but we <span class="math">f</span>-extract, specifically we extract encodings of messages in a group but not their discrete logarithms, (2) we directly use SSBs with locality greater than one instead of making parallel PIR queries to improve concrete efficiency and (3) the size of the commitment key is proportional to the size of the commited values, while in PIRs the query should be small compared to the database size. Furthermore, we exploit in a non-black box way the properties as well as the algebraic structure of the SSB commitments to compose them with other protocols, such as group based quasi-adaptive non-interactive zero knowledge arguments.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">2.1.1 SSB Commitments with Oblivious Trapdoor Generation.</h4>

    <p class="text-gray-300">We define a stronger notion for SSB commitment schemes, oblivious trapdoor generation, which implies the no-signaling property. This notion is easier to work with in our particular constructions.</p>

    <p class="text-gray-300">Intuitively, this notion captures that there exists a different, oblivious key generation algorithm that can generate the commitment key for <span class="math">S</span> and a trapdoor for a subset <span class="math">S^{\\prime}\\subseteq S</span> obliviously of <span class="math">S\\setminus S^{\\prime}</span> for any subset <span class="math">S^{\\prime}</span> of the larger set <span class="math">S</span> of binding coordinates. More concretely, the oblivious key generation algorithm takes as input a commitment key <span class="math">ck_{S}</span> binding at <span class="math">S</span> and the description of a subset <span class="math">S^{\\prime}\\subseteq S</span> and outputs an identically distributed key together with a trapdoor for extracting values in the small set <span class="math">S^{\\prime}</span>. We emphasize that this algorithm does not take as input neither the description of <span class="math">S</span> nor the trapdoor associated with it. Intuitively, the key generation</p>

    <p class="text-gray-300">algorithm is oblivious of  <span class="math">S \\setminus S&#x27;</span>  (it might even be that  <span class="math">S \\setminus S&#x27; = \\emptyset</span> ) due to the indistinguishability of commitment keys associated with different sets, in this case  <span class="math">S</span>  and  <span class="math">S&#x27;</span> .</p>

    <p class="text-gray-300">This property implies no-signaling commitments. Indeed, this follows easily since (1) by the index set hiding property the commitment key itself does not reveal any information about  <span class="math">S \\setminus S&#x27;</span>  and (2) we can use the oblivious key generation algorithm to create a trapdoor for extracting the smaller set without skewing the distribution of the commitment key. The latter property means essentially that we are given an oracle to extract the smaller set (by computing the trapdoor for an identically distributed key) which is exactly what the no-signaling property captures.</p>

    <p class="text-gray-300">We next describe how to construct efficient SSB commitments with oblivious trapdoor generator. A natural way to construct oblivious SSB commitment with locality parameter  <span class="math">K</span>  is to concatenate  <span class="math">K</span>  SSB commitments with locality parameter 1. Consider a set  <span class="math">S = \\{s_1, \\ldots, s_t\\}</span>  for some  <span class="math">t \\leq K</span> . We can construct a commitment key associated with  <span class="math">S</span>  by computing  <span class="math">t</span>  commitment keys/trapdoor pairs  <span class="math">(ck_1, \\tau_1), \\ldots, (ck_t, \\tau_t)</span>  for sets  <span class="math">\\{s_1\\}, \\ldots, \\{s_t\\}</span> , complementing with  <span class="math">K - t</span>  keys for  <span class="math">\\emptyset</span>  if necessary. To commit to some  <span class="math">x \\in \\mathcal{M}^n</span> , where  <span class="math">\\mathcal{M}</span>  is the message space of the commitment, one simply computes  <span class="math">c_1 = \\operatorname{Com}_{ck_1}(x), \\ldots, c_K = \\operatorname{Com}_{ck_K}(x)</span> . Extraction of each  <span class="math">x_{s_i}</span>  is done using  <span class="math">c_{s_i}</span>  and the trapdoor  <span class="math">\\tau_{s_i}</span> , independently of the others. The oblivious extractor on input the commitment keys for some unknown  <span class="math">S</span>  and the description of  <span class="math">S&#x27; \\subseteq S</span>  just re-samples the commitment keys for  <span class="math">S&#x27;</span> . Since it doesn't matter if the trapdoors for positions  <span class="math">i \\notin S&#x27;</span>  are not known, this trivial extractor can obliviously generate the trapdoor  <span class="math">\\{\\tau_i : i \\in S&#x27;\\}</span> .</p>

    <p class="text-gray-300">While this generic construction is enough, we can construct more efficient ones if we consider specific instantiations. More specifically, as we present next, we can have more efficient instantiations (roughly half commitment size compared to the generic one) in the case of commitments derived from the Pedersen commitment scheme.</p>

    <p class="text-gray-300">Notation. We first need to introduce some notation. When  <span class="math">S \\subseteq [n]</span>  we denote with  <span class="math">\\overline{S}</span>  the set  <span class="math">[n] \\setminus S</span> . For a vector  <span class="math">x</span>  (resp. matrix  <span class="math">\\mathbf{G}</span> ) we denote  <span class="math">x_{S} = (x_{i})_{i \\in S}</span>  (resp.  <span class="math">\\mathbf{G}_{S} = (\\mathbf{g}_{i})_{i \\in S}</span>  where  <span class="math">\\mathbf{g}_{i}</span>  is the  <span class="math">i</span> -th column of  <span class="math">\\mathbf{G}</span> ). Finally, we use implicit notation for groups. That is, given a group  <span class="math">\\mathbb{G}</span>  and a fixed generator  <span class="math">\\mathcal{P}</span>  we denote with  <span class="math">[r]</span>  the element  <span class="math">r\\mathcal{P}</span> . For vectors and matrices  <span class="math">a, A</span>  respectively, we denote with  <span class="math">[a], [A]</span>  the natural embeddings of  <span class="math">a, A</span>  to  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">For vectors  <span class="math">\\mathbf{a}, \\mathbf{b}</span> , we denote  <span class="math">\\mathbf{a} \\circ \\mathbf{b} = (a_i b_i)_i</span>  the Hadamard product of them, and for matrices  <span class="math">\\mathbf{A} = (a_{i,j})_{i,j}</span> ,  <span class="math">\\mathbf{B}</span>  we denote  <span class="math">\\mathbf{A} \\otimes \\mathbf{B} = (a_{i,j} \\mathbf{B})_{i,j}</span>  their Kronecker product. We will be using the mixed-product property of kronecker products, which says that  <span class="math">(\\mathbf{A} \\otimes \\mathbf{B})(\\mathbf{C} \\otimes \\mathbf{D}) = (\\mathbf{A} \\mathbf{C}) \\otimes (\\mathbf{B} \\mathbf{D})</span>  whenever  <span class="math">\\mathbf{A}, \\mathbf{B}, \\mathbf{C}, \\mathbf{D}</span>  have the appropriate dimensions.</p>

    <p class="text-gray-300">Efficient SSB Commitments. We next present an oblivious SSB construction based on the Pedersen commitment scheme. This construction was implicit in [GHR15b] and later generalized in [FLPS20]. Later we will see that it also satisfies the stronger notion of oblivious trapdoor generation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\mathbb{G}</span>  be a group of size  <span class="math">p</span> . For message space  <span class="math">\\mathbb{Z}_p^d</span> , locality parameter  <span class="math">K \\in \\mathbb{N}</span>  and a subset  <span class="math">S \\subseteq [d]</span>  of size  <span class="math">t \\leq K</span> , the commitment key is defined as follows:  $\\mathbf{G} = (\\mathbf{G}_S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{\\overline{S}}) \\mathbf{P}$  and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {G} _ {S} \\leftarrow \\mathbb {Z} _ {p} ^ {(K + 1) \\times t}, \\qquad \\mathbf {G} _ {0} \\leftarrow \\mathbb {Z} _ {p} ^ {(K + 1) \\times (K + 1 - t)},? \\qquad \\Gamma \\leftarrow \\mathbb {Z} _ {p} ^ {(K + 1 - t) \\times (d - t)}, \\qquad \\mathbf {G} _ {\\overline {{S}}} = \\mathbf {G} _ {0} \\Gamma .</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Matrix <span class="math">\\mathbf{P} \\in \\{0,1\\}^{d \\times d}</span> is a permutation matrix associated to <span class="math">S</span> such that <span class="math">\\mathbf{P}\\mathbf{e}_{s_i} = \\mathbf{e}_i</span>, for <span class="math">i \\leq t</span> and <span class="math">\\mathbf{e}_i</span> the <span class="math">i</span>-th vector of the canonical basis. A commitment to <span class="math">\\mathbf{x} \\in \\mathbb{Z}_p^d</span> is computed as $[\\mathbf{c}] = [\\mathbf{G}]\\mathbf{x} = [\\mathbf{G}_S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{\\overline{S}}]\\mathbf{P}\\mathbf{x} = [\\mathbf{G}_S]\\mathbf{x}_S + [\\mathbf{G}_{\\overline{S}}]\\mathbf{x}_{\\overline{S}}<span class="math">. Note that the columns of </span>\\mathbf{G}_S<span class="math"> are linearly independent from the columns of </span>\\mathbf{G}_{\\overline{S}}<span class="math"> with overwhelming probability, since </span>\\mathbf{Im}(\\mathbf{G}_{\\overline{S}}) \\subseteq \\mathbf{Im}(\\mathbf{G}_0)<span class="math"> and </span>(\\mathbf{G}_S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_0)<span class="math"> is a basis of </span>\\mathbb{Z}_p^{K+1}<span class="math"> w.o.p. since this corresponds to a uniform matrix of dimensions </span>K + 1 \\times K + 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This distribution of commitment keys implies that the parts of the input indexed by <span class="math">S</span> go to the space spanned by <span class="math">\\mathbf{G}_S</span> of dimension <span class="math">t</span>, while the rest is mapped to the space spanned by <span class="math">\\mathbf{G}_0</span> of dimension <span class="math">K + 1 - t</span>. Since <span class="math">\\mathrm{rank}(\\mathbf{G}_S) = t</span> with overwhelming probability, all the information of <span class="math">\\mathbf{x}_S \\in \\mathbb{Z}_p^t</span> can be retrieved from <span class="math">\\mathbf{c}</span>. Even more, there exists an efficiently computable trapdoor <span class="math">\\mathbf{T}_S \\in \\mathbb{Z}_p^{(K + 1) \\times t}</span> such that <span class="math">\\mathbf{T}_S^\\top \\mathbf{G}_S = \\mathbf{I}_{t \\times t}</span> and <span class="math">\\mathbf{T}_S^\\top \\mathbf{G}_{\\overline{S}} = \\mathbf{0}_{t \\times (d - t)}</span>, and hence</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {T} _ {S} ^ {\\top} [ \\mathbf {c} ] = \\mathbf {T} _ {S} ^ {\\top} [ \\mathbf {G} \\mathbf {x} ] = \\mathbf {T} _ {S} ^ {\\top} [ \\mathbf {G} _ {S} \\mathbf {x} _ {S} + \\mathbf {G} _ {\\overline {{S}}} \\mathbf {x} _ {\\overline {{S}}} ] = [ \\mathbf {x} _ {S} ].</span></div>

    <p class="text-gray-300">To compute <span class="math">\\mathbf{T}_S</span>, it is enough to solve the linear system <span class="math">\\mathbf{T}_S^\\top (\\mathbf{G}_S\\mid \\mathbf{G}_0) = (\\mathbf{I}_S\\mid \\mathbf{0})</span> which admits a solution since <span class="math">(\\mathbf{G}_S\\mid \\mathbf{G}_0)</span> is a basis of <span class="math">\\mathbb{Z}_p^{K + 1}</span> with overwhelming probability.</p>

    <p class="text-gray-300">Note that this shows also that the commitment is statistically binding in <span class="math">S</span>. The indistinguishability of commitment keys can be shown with a tight reduction to the DDH assumption as in [FLPS20].</p>

    <p class="text-gray-300">Oblivious Trapdoor Generation. One of the main technical contributions of this work is an oblivious trapdoor generator for this commitment scheme, which in turns implies that it is no-signaling. Recall that the property requires that there exists an efficient algorithm, called the oblivious key generation algorithm, that receives as input the description of a set <span class="math">S&#x27;</span> of size <span class="math">t&#x27; \\leq K</span> and a commitment key <span class="math">[\\mathbf{G}]</span> sampled for being binding at some unknown <span class="math">S \\supseteq S&#x27;</span>. The algorithm computes a new commitment key <span class="math">[\\mathbf{H}]</span> with the following guarantees: (1) it is statistically close to <span class="math">[\\mathbf{G}]</span> and (2) we also obtain a trapdoor <span class="math">\\mathbf{T}_{S&#x27;}</span> that allows us to extract local openings for the small set <span class="math">S&#x27;</span>.</p>

    <p class="text-gray-300">Since we know that columns in <span class="math">S&#x27;</span> are uniformly distributed, we could attempt to sample a uniform matrix <span class="math">\\mathbf{H}_{S&#x27;} \\leftarrow \\mathbb{Z}_p^{(K+1) \\times t&#x27;}</span> and solve the equation <span class="math">\\mathbf{T}_{S&#x27;}^\\top \\mathbf{H}_{S&#x27;} = \\mathbf{I}_{t&#x27; \\times t&#x27;}</span> for some <span class="math">\\mathbf{T}_{S&#x27;}</span>. However, since we don't know the distribution of <span class="math">[\\mathbf{G}_{\\overline{S}}&#x27;]</span> the only hope seems to be to define <span class="math">[\\mathbf{H}_{\\overline{S}}&#x27;] = [\\mathbf{G}_{\\overline{S}}&#x27;]</span> and try to find some <span class="math">\\mathbf{T}_{S&#x27;}</span> such that <span class="math">\\mathbf{T}_{S&#x27;}^\\top \\mathbf{G}_{\\overline{S}}&#x27; = \\mathbf{0}_{t&#x27; \\times (d - t&#x27;)}</span>. Unfortunately, this amounts to finding elements in the kernel of <span class="math">[\\mathbf{G}_{\\overline{S}}&#x27;]^\\top</span> which is in general a computationally hard problem [MRV16].</p>

    <p class="text-gray-300">Instead we make the following observation. Regardless of the distribution of the columns in <span class="math">S \\setminus S&#x27;</span>, the <span class="math">t&#x27;</span> lower rows of <span class="math">\\mathbf{G}_{\\overline{S}}</span> can be always written as a random linear combination of the first <span class="math">K + 1 - t&#x27;</span> rows. That is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {G} _ {\\overline {{S}} ^ {\\prime}} = \\left( \\begin{array}{c} \\mathbf {A} \\\\ \\mathbf {R A} \\end{array} \\right), \\text { where } \\mathbf {A} \\in \\mathbb {Z} _ {p} ^ {K + 1 - t ^ {\\prime} \\times d - t ^ {\\prime}} \\text { and } \\mathbf {R} \\leftarrow \\mathbb {Z} _ {p} ^ {t ^ {\\prime} \\times K + 1 - t ^ {\\prime}}.</span></div>

    <p class="text-gray-300">In this case, if we know the matrix <span class="math">\\mathbf{R}</span> in the field, it is possible to compute elements in the kernel of <span class="math">\\mathbf{G}_{\\overline{S}&#x27;}</span> by setting</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {T} _ {S ^ {\\prime}} = \\left( \\begin{array}{c} - \\mathbf {R} ^ {\\top} \\mathbf {C} \\\\ \\mathbf {C} \\end{array} \\right), \\text { for any } \\mathbf {C} \\in \\mathbb {Z} _ {p} ^ {t ^ {\\prime} \\times t ^ {\\prime}}.</span></div>

    <p class="text-gray-300">If additionally, we choose some <span class="math">\\mathbf{C}</span> that satisfies <span class="math">\\mathbf{T}_{S&#x27;}^\\top \\mathbf{H}_{S&#x27;} = \\mathbf{I}_{t&#x27; \\times t&#x27;}</span> we have computed a trapdoor for <span class="math">S&#x27;</span>. This yields a way to compute the rest of the columns: discard the lower <span class="math">t&#x27;</span> rows of <span class="math">\\mathbf{G}_{\\overline{S}}</span>,</p>

    <p class="text-gray-300">some hardness assumption. Specifically, the index set hiding property reduces to the G-MDDH assumption (see Section 2.2.1 for an informal definition) where G is the distributions from which we sample G0. When working with symmetric groups, we instantiate using the DLIN assumption. For the sake of simplicity we consider the uniform case in the technical overview.</p>

    <p class="text-gray-300">sample a uniform matrix <span class="math">\\mathbf{R}</span> as above and complete the last rows with the elements <span class="math">\\mathbf{R}[\\mathbf{A}]</span>. Then, using <span class="math">\\mathbf{R}</span>, <span class="math">\\mathbf{H}_{S^{\\prime}}</span> (which are known in the field) find some <span class="math">\\mathbf{C}</span> that satisfies the linear equations and use it to define the trapdoor <span class="math">\\mathbf{T}^{\\prime}_{\\widetilde{S}}</span>.</p>

    <p class="text-gray-300">Lets see in more detail why the previous observation holds. Consider the matrix <span class="math">\\mathbf{G}_{0}\\in\\mathbb{Z}_{p}^{(K+1)\\times(K+1-t)}</span> and note that the upper part <span class="math">\\overline{\\mathbf{G}}_{0}</span> is a uniformly distributed matrix with more rows than columns; hence <span class="math">\\mathbf{R}\\overline{\\mathbf{G}}_{0}</span>, for <span class="math">\\mathbf{R}\\leftarrow\\mathbb{Z}_{p}^{t^{\\prime}\\times(K+1-t^{\\prime})}</span>, is uniformly distributed. This is also valid for all non-binding coordinates since <span class="math">\\overline{\\mathbf{G}}_{\\widetilde{S}}=\\mathbf{G}_{0}\\mathbf{\\Gamma}</span> and then the lower rows follow distribution <span class="math">\\mathbf{R}\\overline{\\mathbf{G}}_{\\widetilde{S}}</span>. Next, consider the columns corresponding to the (unknown) binding coordinates <span class="math">S\\setminus S^{\\prime}</span>. The same argument holds: for some uniform <span class="math">\\mathbf{R}^{\\prime}\\overline{\\mathbf{G}}_{S\\setminus S^{\\prime}}</span> is uniform when <span class="math">\\mathbf{R}^{\\prime}\\leftarrow\\mathbb{Z}_{p}^{t^{\\prime}\\times(K+1-t^{\\prime})}</span>. It remains to show that using the same randomness for both column sets, i.e. setting <span class="math">\\mathbf{R}=\\mathbf{R}^{\\prime}</span>, does not alter the distribution of the commitment key. Indeed, with overwhelming probability, the columns of <span class="math">\\overline{\\mathbf{G}}_{0}\\in\\mathbb{Z}_{p}^{(K+1-t^{\\prime})\\times(K+1-t)}</span> and of <span class="math">\\overline{\\mathbf{G}}_{S\\setminus S^{\\prime}}\\in\\mathbb{Z}_{p}^{(K+1-t^{\\prime})\\times(t-t^{\\prime})}</span> form a basis of <span class="math">\\mathbb{Z}_{p}^{K+1-t^{\\prime}}</span>, which means that the matrix <span class="math">\\mathbf{R}^{\\top}</span> can be decomposed into two independent components: a random element in <span class="math">\\text{Im}(\\overline{\\mathbf{G}}_{S\\setminus S^{\\prime}}^{\\perp})</span> and another in <span class="math">\\text{Im}(\\overline{\\mathbf{G}}_{0}^{\\perp})</span>. This shows that <span class="math">\\mathbf{R}\\overline{\\mathbf{G}}_{0}=\\mathbf{R}_{2}(\\mathbf{G}_{S\\setminus S^{\\prime}}^{\\perp})^{\\top}\\overline{\\mathbf{G}}_{0}</span> and <span class="math">\\mathbf{R}\\overline{\\mathbf{G}}_{S\\setminus S^{\\prime}}=\\mathbf{R}_{1}(\\mathbf{G}_{0}^{\\perp})^{\\top}\\overline{\\mathbf{G}}_{S\\setminus S^{\\prime}}</span> are independent and then \\[ \\left(\\begin{array}[]{cc}\\overline{\\mathbf{G}}_{S\\setminus S^{\\prime}}&\\overline{\\mathbf{G}}_{0}\\mathbf{\\Gamma}\\\\ \\mathbf{R}\\overline{\\mathbf{G}}_{S\\setminus S^{\\prime}}&\\mathbf{R}\\overline{\\mathbf{G}}_{0}\\mathbf{\\Gamma}\\end{array}\\right) \\] is correctly distributed.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Pairing-based Quasi-Arguments</h3>

    <p class="text-gray-300">Paneth and Rothblum <em>[x20]</em> and then Kalai et al. <em>[x18]</em> used a weakened version of an argument of knowledge called quasi-argument, as an intermediate step for obtaining a delegation scheme. Quasi arguments are defined for languages that can be expressed as a set of <em>local constraints</em>. Roughly speaking, this means that a witness <span class="math">\\bm{w}</span> for membership of a statement <span class="math">x</span> in a language can be decomposed in parts, namely <span class="math">\\bm{w}=(w_{1},\\ldots,w_{n})</span>, and for each subset <span class="math">S\\subseteq[n]</span>, the partial witness <span class="math">\\bm{w}_{S}</span> satisfies some local relations, that is, a predicate <span class="math">\\mathcal{R}(x,\\bm{w}_{S})</span> holds. For example, in the case of a CNF formula of <span class="math">n</span> variables, the witness is an accepting assignment of the formula and a local constraint with respect to some set <span class="math">S</span> captures that every clause that only has variables <span class="math">w_{i},w_{j},w_{k}</span> for <span class="math">i,j,k\\in S</span> is satisfied. Note that it can be the case that even unsatisfiable formulas can satisfy all local constraints for families of sets of small size (yet, no global satisfying assignment exists).</p>

    <p class="text-gray-300">Unlike an argument of knowledge, a quasi-argument has only local extraction, meaning that only a small part of the witness of size at most <span class="math">K</span>, the locality parameter, is extracted. This is formalized by means of an extractor which on input a set <span class="math">S\\subseteq[n]</span> of size at most <span class="math">K</span>, where <span class="math">n</span> is the size of the witness, programs a crs so that it can later extract positions of the witness defined by <span class="math">S</span>. Central to quasi-arguments is the notion of no-signaling local extraction which is aimed to capture a strong <em>local soundness</em> guarantee.</p>

    <p class="text-gray-300">Local soundness requires that the extracted local witness is consistent with the relation and doesn’t lead to a local contradiction, that is, it satisfies the local constraints associated to some set <span class="math">S</span>. The <em>no-signaling</em> requirement is defined for any two sets <span class="math">S,S^{\\prime}</span> where <span class="math">S^{\\prime}\\subseteq S</span> and of size at most <span class="math">K</span>. It states that the result of programming extraction for <span class="math">S</span> and then output only the extracted value for <span class="math">S^{\\prime}</span>, should be indistinguishable from the result of programming extraction for <span class="math">S^{\\prime}</span> and output the extracted value for <span class="math">S^{\\prime}</span>. Intuitively, this strengthens locality by requiring that the small parts of the local witness are extracted independently from rest.</p>

    <p class="text-gray-300">We next outline the construction of pairing-based quasi-arguements for two specific languages of interest, satisfiability of linear and quadratic relations on committed values. For ease of presentation we do so for symmetric bilinear groups but we streess out that we also translate these to the more efficient setting of asymetric bilinear groups. We will later rely on these quasi arguments to construct a delegation scheme for polynomial sized arithmetic</p>

    <p class="text-gray-300">circuits but we emphasize that these constructions are of independent interest; they capture a form of “succinct” aggregation of relations and -importantly- they do so under standard falsifiable assumptions. While full knowledge soundness is not achieved, the weakened notion of no-signaling extraction might be enough for some applicaitons. Thus, we choose to present them in full generality.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">2.2.1 Preliminaries</h4>

    <p class="text-gray-300">In this section we introduce some necessary preliminaries for the construction of the quasi arguments for linear and quadratic relations. First, we introduce the Matrix and Kernel Diffie-Hellman <em>[EHK+13, MRV16]</em> assumption families. Then we introduce Quasi-Adaptive NIZK <em>[JR13]</em> and sketch the QA-NIZK construction for membership in linear spaces of <em>[KW15]</em> and finally the knowledge transfer arguments introduced in <em>[GR19]</em> which allow to construct QA-NIZK under falsifiable assumptions in some more restricted setting.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Cryptographic assumptions.</h5>

    <p class="text-gray-300">We introduce informally the Matrix and Kernel Diffie-Hellman assumptions <em>[EHK+13, MRV16]</em>. These are natural generalizations of assumptions used in group based cryptography (either with pairings or not). Both assumption families are parametrized by distributions over matrices in <span class="math">\\mathbb{Z}_{p}</span>, that is, we consider distribution ensembles <span class="math">\\mathcal{D}_{\\ell,k}</span> that output matrices in <span class="math">\\mathbb{Z}_{p}^{\\ell\\times k}</span>. When <span class="math">\\ell=k+1</span> we simply write <span class="math">\\mathcal{D}_{k}</span>.</p>

    <p class="text-gray-300">The <span class="math">\\mathcal{D}_{\\ell,k}</span>-Matrix Diffie-Hellman Assumption (<span class="math">\\mathcal{D}_{\\ell,k}</span>-MDDH) states that elements in the image of a matrix <span class="math">\\mathbf{A}</span> sampled from <span class="math">\\mathcal{D}_{\\ell,k}</span> are computationally indistinguishable from uniformly random elements.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Assumption.</h6>

    <p class="text-gray-300">(Informal) <span class="math">\\mathcal{D}_{\\ell,k}</span>-MDDH holds in <span class="math">\\mathbb{G}</span> if the distributions <span class="math">\\{[\\mathbf{A}],[\\mathbf{A}w]\\}</span> and <span class="math">\\{[\\mathbf{A}],[z]\\}</span> are computationally indisthinguishable, where <span class="math">w</span>, <span class="math">z</span> are random elements of <span class="math">\\mathbb{Z}_{p}^{k}</span> and <span class="math">\\mathbb{Z}_{p}^{\\ell}</span> respectively, and <span class="math">\\mathbf{A}\\leftarrow\\mathcal{D}_{\\ell,k}</span>.</p>

    <p class="text-gray-300">Consider the uniform distribution <span class="math">\\mathcal{U}_{2,1}</span> that outputs random elements in <span class="math">\\mathbb{Z}_{p}^{2\\times 1}</span>. It is easy to assert that the <span class="math">\\mathcal{U}_{2,1}</span>-MDDH assumption is equivalent to the Decisional Diffie-Hellman assumption in <span class="math">\\mathbb{G}</span>. In the setting of symmetric bilinear groups -where the DDH assumption does not hold- we consider a slightly stronger assumption, namely the Decisional Linear assumption (DLIN) <em>[BBS04]</em>. This assumption can be stated as the <span class="math">\\mathcal{L}_{3,2}</span>-MDDH assumption, where <span class="math">\\mathcal{L}_{3,2}</span> is the distribution</p>

    <p class="text-gray-300">\\[ \\mathcal{L}_{3,2}=\\left\\{\\left(\\begin{matrix}a_{1}&0\\\\ 0&a_{2}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1&1\\end{matrix}\\right)\\;\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\;a_{1},a_{2}\\leftarrow\\mathbb{Z}_{p}\\right\\} \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The <span class="math">\\mathcal{D}_{\\ell,k}</span>-Kernel Diffie-Hellman Assumption is a natural computational analogue of the <span class="math">\\mathcal{D}_{\\ell,k}</span>-MDDH for bilinear groups. The assumption states that it is infeasible to find non-trivial elements of the co-kernel of <span class="math">\\mathbf{A}\\leftarrow\\mathcal{D}_{\\ell,k}</span> given <span class="math">[\\mathbf{A}]</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Assumption.</h6>

    <p class="text-gray-300">(Informal) <span class="math">\\mathcal{D}_{\\ell,k}</span>-MDDH holds in <span class="math">\\mathbb{G}</span> if it is computationally hard to find a non-zero element <span class="math">[z]\\in\\mathbb{G}^{\\ell}</span> such that <span class="math">[z^{\\top}\\mathbf{A}]_{T}=[\\mathbf{0}]_{T}</span> given <span class="math">[\\mathbf{A}]</span>, where <span class="math">\\mathbf{A}\\leftarrow\\mathcal{D}_{\\ell,k}</span>.</p>

    <p class="text-gray-300">Note that the assumption is efficiently falsifiable since we can check the winning condition by employing the pairing operation, that is check if <span class="math">e([z]^{\\top},[\\mathbf{A}])=[\\mathbf{0}]_{T}</span>. This assumption family abstracts and generalizes various computational assumptions in bilinear group, such as the Simultaneous Double Pairing Assumption <em>[AFG+10]</em>.</p>

    <p class="text-gray-300">It is well known that <span class="math">\\mathcal{D}_{\\ell,k}</span>-MDDH implies <span class="math">\\mathcal{D}_{\\ell,k}</span>-Kernel Diffie-Hellman assumption. Intuitively, this holds since if we can sample an element <span class="math">\\bm{r}</span> in the co-kernel of <span class="math">\\mathbf{A}</span>, it always holds that <span class="math">\\bm{r}^{\\top}\\mathbf{A}\\bm{w}=\\bm{0}</span> while for a uniformly distributed vector <span class="math">\\bm{z}</span>, with overwhelming probability <span class="math">\\bm{r}^{\\top}\\bm{z}\\neq 0</span>, which translates to an efficient distinguisher for the two distributions defined by <span class="math">\\mathcal{D}_{\\ell,k}</span>-MDDH assumption.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Quasi-Adaptive NIZK for membership in linear spaces.</h4>

    <p class="text-gray-300">Quasi-Adaptive NIZK (QA-NIZK) arguments are NIZK arguments where the CRS is allowed to depend on the specific language for which proofs have to be generated <em>[x11]</em>. We are interested in the specific language of membership in linear spaces. Specifically, given a matrix <span class="math">\\mathbf{M}</span> and a description of a group <span class="math">gk</span>, we consider the language of vectors of group elements that lie in the image of <span class="math">\\mathbf{M}</span>, that is,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{gk,\\mathbf{M}}=\\{[x]\\mid\\exists\\bm{w}\\text{ s.t. }\\bm{x}=\\mathbf{M}\\bm{w}\\}</span></p>

    <p class="text-gray-300">In the quasi-adaptive case, we allow the common reference string to depend on <span class="math">gk</span>, <span class="math">\\mathbf{M}</span> but an adversary can choose the statement <span class="math">[\\bm{x}]</span> adaptively. There are very efficient constructions in this setting. We briefly describe the construction of Kiltz and Wee <em>[x13]</em>. First we consider the designated verifier case. Let <span class="math">\\mathbf{M}</span> be an <span class="math">\\ell\\times n</span> matrix. The construction is essentially a hash proof system <em>[x5]</em>. The crs contains the projection <span class="math">[\\mathbf{B}]=[\\mathbf{M}^{\\top}\\mathbf{K}]</span> for a random secret key <span class="math">\\mathbf{K}\\in\\mathbb{Z}_{p}^{\\ell\\times k}</span>. To prove a statement <span class="math">[\\bm{x}]=[\\mathbf{M}]\\bm{w}</span>, the prover sends <span class="math">[\\bm{\\pi}]=\\bm{w}^{\\top}[\\mathbf{B}]</span> and the verifier asserts that <span class="math">[\\bm{\\pi}]=[\\bm{x}]^{\\top}\\mathbf{K}</span>. Now it is easy to see that this simple protocol is complete. Indeed</p>

    <p class="text-gray-300"><span class="math">\\bm{\\pi}=\\bm{w}^{\\top}[\\mathbf{B}]=\\bm{w}^{\\top}\\mathbf{M}^{\\top}\\mathbf{K}=\\bm{x}^{\\top}\\mathbf{K}</span></p>

    <p class="text-gray-300">For soundness, roughly speaking, the value <span class="math">\\bm{x}^{\\top}\\mathbf{K}</span> is random for <span class="math">\\bm{x}</span> that does not belong to the image of <span class="math">\\mathbf{M}</span> conditioned on <span class="math">\\mathbf{B}</span>. Thus, a cheating (even unbounded) prover has only negligible probability of producing a verifying proof for elements not in the image of <span class="math">\\mathbf{M}</span>.</p>

    <p class="text-gray-300">To make the scheme publicly verifiable, groups equipped with a bilinear map are employed. To enable the verifier to perform the test without knowing the secret <span class="math">\\mathbf{K}</span>, we also add to the crs the value <span class="math">[\\mathbf{C}]=[\\mathbf{KA}]</span>, where <span class="math">\\mathbf{A}</span> is a matrix that satisfies some hardness condition. Now, the verifier can test <span class="math">e([\\bm{\\pi}],[\\mathbf{A}])=e([\\bm{x}^{\\top}],[\\mathbf{C}])</span>. Note that this corresponds to multiplying the verification equation of the designated verifier case from the right with <span class="math">\\mathbf{A}</span>. Now, if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the designated verifier relation does not hold, namely, <span class="math">\\bm{\\pi}\\neq\\bm{x}^{\\top}\\mathbf{K}</span> and</li>

      <li>the proof verifies, namely <span class="math">\\bm{\\pi}\\mathbf{A}=\\bm{x}^{\\top}\\mathbf{KA}</span>,</li>

    </ol>

    <p class="text-gray-300">then <span class="math">[\\bm{\\pi}]-[\\bm{x}^{\\top}]\\mathbf{K}</span> is a non-trivial element in the co-kernel of <span class="math">[\\mathbf{A}]</span>. Thus, the publicly verifiable scheme is sound if we additionally assume that <span class="math">\\mathbf{A}</span> is sampled by a distributions <span class="math">\\mathcal{D}</span> such that the <span class="math">\\mathcal{D}</span>-Kernel Diffie-Hellman assumption holds.</p>

    <p class="text-gray-300">Note that if <span class="math">\\mathbf{M}</span> spans the entire linear space, then the language is trivial. In this case, only knowledge soundness is a meaningful property. However, we do not whether knowledge soundness of this construction can be proven under falsifiable assumptions or not.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Knowledge Transfer Arguments.</h4>

    <p class="text-gray-300">To achieve succinct arguments, in principle, one needs to use shrinking commitments. When trying to use such commitments with QA-NIZK such as <em>[x13]</em>, the aforementioned “triviality” problem arises and it seems like one has to resort to non-falsifiable assumptions or the generic group model. Motivated by the problem of constructing delegation schemes under falsifiable assumptions and in order to overcome the above issue, <em>[x10]</em> relax the knowledge soundness property.</p>

    <p class="text-gray-300">When considering delegation using the natural approach of (deterministically) committing to the wires of the circuit, one can observe that full knowledge soundness seems to be an unnecessarily strong requirement. Indeed, given the input <span class="math">x</span> of the circuit, one can compute (or verify) these commitments efficiently by evaluating the circuit. This means intuitively, that we already know how a “correct” opening of the commitments looks like in the soundness security reduction. <em>[x10]</em> exploits this fact and manages to relax the knowledge soundness requirement by considering statements of the form “if commitment <span class="math">[c]</span> opens to <span class="math">w</span>, then commitment <span class="math">[d]</span> opens to <span class="math">f(w)</span>” for publicly known function <span class="math">f</span>. As we shall see later, they show that this notion of soundness is enough to construct delegation for low-depth circuits. They also construct two knowledge transfer arguments for linear and quadratic relations under falsifiable assumptions. More concretely, they consider statements of the form</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>“if <span class="math">[c]</span> opens to <span class="math">\\mathbf{M}w</span>, then <span class="math">[d]</span> opens to <span class="math">\\mathbf{N}w</span> for some publicly known <span class="math">\\mathbf{M},\\mathbf{N}</span>, and</li>

      <li>“if <span class="math">[c_{1}]</span> opens to <span class="math">w_{1}</span> and <span class="math">[c_{2}]</span> opens to <span class="math">w_{2}</span>, then <span class="math">[d]</span> opens to <span class="math">w_{1}\\circ w_{2}</span> where <span class="math">\\circ</span> denotes the pairwise product of vectors.</li>

    </ul>

    <p class="text-gray-300">In the soundness definition, the adversary is required to output the valid opening along with the statement proof-pair. We emphasize that this is only part of the soundness definition and in the protocol execution the prover does not have to output the valid opening. Consider for example the first case for linear relations. An adversary wins if it manages to output a statement <span class="math">[c],[d]</span> with an accepting proof and a <span class="math">w</span> such that <span class="math">[c]=[\\mathbf{M}]w</span> but <span class="math">[d]\\neq[\\mathbf{N}]w</span>. Such statements essentially give the guarantee that some a priori knowledge about a commitment is “correctly” transferred to another commitment.</p>

    <p class="text-gray-300">For the former construction, namely linear relations, they use the <em>[x14]</em> construction where they define <span class="math">\\mathbf{M}</span> as a two block matrix where the upper part corresponds to <span class="math">[c]</span> and the lower to <span class="math">[d]</span>. Now, using <em>[x14]</em>, the prover simply needs to convince the verifier that \\[ \\begin{bmatrix}c\\\\ d\\end{bmatrix}=\\begin{bmatrix}\\mathbf{M}\\\\ \\mathbf{N}\\end{bmatrix}w \\]. They show that this construction is knowledge transfer sound if the upper matrix <span class="math">\\mathbf{M}</span> is sampled from a distribution <span class="math">\\mathcal{D}</span> for which the <span class="math">\\mathcal{D}</span>-MDDH assumption holds.</p>

    <p class="text-gray-300">For proving the quadratic relations, they do a different analysis of standard techniques used for the construction of pairing-based succinct arguments that exploit the properties of the Lagrange basis.</p>

    <p class="text-gray-300">They also modify these constructions to be compatible with the more efficient setting of asymmetric bilinear groups, under the natural modifications of the required assumption for asymmetric groups.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">2.2.2 Oblivious Trapdoor Generation for Quasi-Arguments</h4>

    <p class="text-gray-300">Similar to the case of no-signaling SSB commitments we define a stornger and easier to work with (in our context) notion that implies the no-signaling property of quasi arguments, <em>oblivious trapdoor generation</em>.</p>

    <p class="text-gray-300">We require that there exists an <em>oblivious</em> key generation algorithm that takes as input (1) a <span class="math">\\mathsf{crs}_{S}</span> that allows extraction for a set <span class="math">S</span>, and (2) the description of a subset <span class="math">S^{\\prime}\\subseteq S</span>, and generates a <span class="math">\\mathsf{crs}_{S^{\\prime}}</span> for some set <span class="math">S^{\\prime}</span> and a trapdoor for extracting local witnesses associated to the set <span class="math">S^{\\prime}</span> <em>obliviously</em> of <span class="math">S\\setminus S^{\\prime}</span>. We emphasize that the oblivious trapdoor generation algorithm knows neither the description of <span class="math">S</span> nor any information about the trapdoor associated with it. We</p>

    <p class="text-gray-300">require that the new crs is statistically close to the <span class="math">\\mathsf{crs}_{S}</span> given as input. The fact that this property implies no-signaling commitments is identical to the case of SSB commitments.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">2.2.3 Quasi-Arguments of Membership in a Linear Space</h4>

    <p class="text-gray-300">We define a quasi-argument of knowledge of some vector <span class="math">[x]\\in\\mathbb{G}^{t}</span> belonging to the image of a matrix <span class="math">[\\mathbf{U}]\\in\\mathbb{G}^{t\\times n}</span>, where <span class="math">x</span> is committed using an SSB commitment. Consider a commitment <span class="math">[c]</span> that is statistically binding on the set <span class="math">S</span>. We show that there exists a local and no-signaling extractor which, given some <span class="math">S\\subseteq[n]</span> of size <span class="math">t\\leq K</span>, extracts <span class="math">[x_{S}]\\in\\operatorname{Im}([\\mathbf{U}_{S}])</span>, where <span class="math">x_{S}\\in\\mathbb{Z}_{p}^{t}</span> is the vector whose entries are <span class="math">x_{i}</span> and <span class="math">\\mathbf{U}_{S}\\in\\mathbb{Z}_{p}^{t\\times n}</span> is the matrix whose rows are the rows of <span class="math">\\mathbf{U}</span> indexed by <span class="math">i</span>, where <span class="math">i</span> ranges over <span class="math">S</span> in some fixed order. A local constraint <span class="math">[x_{S}]</span> associated with the set <span class="math">S</span> can be interpreted as satisfying two properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[x_{S}]</span> is consistent with the commitment <span class="math">[c]</span>, namely the (uniqe) <span class="math">S</span>-opening of <span class="math">[c]</span> is <span class="math">x_{S}</span>, and</li>

      <li><span class="math">[x_{S}]</span> is in the image of <span class="math">[\\mathbf{U}_{S}]</span>.</li>

    </ol>

    <p class="text-gray-300">We use the Kiltz and Wee argument of membership in linear spaces <em>[x13]</em> to construct a quasi argument for linear relations. Details follow.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">The argument.</h5>

    <p class="text-gray-300">Our construction is Kiltz and Wee linear membership argument <em>[x13]</em> for the matrix <span class="math">[\\mathbf{G}\\mathbf{U}]</span>, where <span class="math">\\mathbf{G}</span> is an SSB commitment key with locality parameter <span class="math">K</span>. For completeness, we describe the protocol for this specific matrix. We note that we present the scheme with proof size <span class="math">k+1</span> of <em>[x13]</em>, where <span class="math">k</span> is a parameter of the scheme defined by the underlying assumption, but our construction is also sound for the more efficient instantiation of size <span class="math">k</span>. In any case, we emphasize that the parameter is a small constant (<span class="math">k=2</span>).</p>

    <p class="text-gray-300">Let’s recall the construction for the matrix <span class="math">\\mathbf{M}=\\mathbf{G}\\mathbf{U}</span>. The crs contains <span class="math">[\\mathbf{B}]=[\\mathbf{U}^{\\top}\\mathbf{G}^{\\top}\\mathbf{K}]</span> and <span class="math">[\\mathbf{C}]=[\\mathbf{K}\\mathbf{A}]</span> for some random hash key <span class="math">\\mathbf{K}</span> and <span class="math">\\mathbf{A}</span> drawn from some distribution satisfying a kernel assumption. A proof is computed as <span class="math">[\\pi]=w^{\\top}[\\mathbf{B}]</span>, and verification is done by checking if <span class="math">e([\\pi],[\\mathbf{A}])=e([c^{\\top}],[\\mathbf{C}])</span>.</p>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Local and No-Signaling extraction.</h5>

    <p class="text-gray-300">Our strategy to prove local soundness is to show that, apart from extracting <span class="math">[x_{S}]</span> from <span class="math">[c]</span>, we are also able to produce a verifying proof <span class="math">[\\pi^{\\dagger}]</span> that <span class="math">[x_{S}]\\in\\operatorname{Im}(\\mathbf{U}_{S})</span>. More concretely, on input a crs <span class="math">\\mathsf{crs}_{S}=([\\mathbf{A}^{\\dagger}],[\\mathbf{B}^{\\dagger}],[\\mathbf{C}^{\\dagger}])</span> for membership in the linear space of <span class="math">\\mathbf{U}_{S}</span>, we can construct another crs that is statistically close to the quasi argument <span class="math">\\mathsf{crs}</span> for <span class="math">\\mathbf{U}</span> and, more importantly, we can extract a local opening <span class="math">[x_{S}]</span> and a proof <span class="math">[\\pi^{\\dagger}]</span> satisfying the verification equation for <span class="math">\\mathsf{crs}_{S}</span>.</p>

    <p class="text-gray-300">We embed the public parameters <span class="math">[\\mathbf{A}^{\\dagger}],[\\mathbf{B}^{\\dagger}],[\\mathbf{C}^{\\dagger}]</span> of the local linear space argument for <span class="math">\\mathbf{U}_{S}</span> in the quasi argument parameters. Although the secret hash key <span class="math">\\mathbf{K}^{\\dagger}</span> of the local linear argument is statistically hidden, we can still pick a random hash key for all the coordinates by picking another secret key and implicitly define the full secret key as some composition of the two keys. Concretely, given the trapdoor <span class="math">\\mathbf{T}_{S}</span> for locally opening SSB commitments we implicitly define <span class="math">\\mathbf{K}=\\mathbf{T}_{S}\\mathbf{K}^{\\dagger}+\\mathbf{R}</span>, where <span class="math">\\mathbf{R}</span> is the additional key, so that the proofs for <span class="math">c=\\mathbf{G}\\mathbf{P}\\left(\\frac{x_{S}}{x_{S}^{\\top}}\\right)=\\mathbf{G}_{S}x_{S}+\\mathbf{G}_{\\overline{S}}x_{\\overline{S}}</span> are of the form <span class="math">\\pi=c^{\\top}\\mathbf{K}=(\\mathbf{G}_{S}x_{S}+\\mathbf{G}_{\\overline{S}}x_{\\overline{S}})^{\\top}(\\mathbf{T}_{S}\\mathbf{K}^{\\dagger}+\\mathbf{R})=x_{S}^{\\top}\\mathbf{K}^{\\dagger}+c^{\\top}\\mathbf{R}.</span> In this way a proof for the local argument can be retrieved as <span class="math">[\\pi^{\\dagger}]=[\\pi]-[c^{\\top}]\\mathbf{R}</span>. This equivalent way of sampling <span class="math">\\mathbf{K}</span> allows to compute the crs of the larger linear argument using only <span class="math">[\\mathbf{A}^{\\dagger}],[\\mathbf{B}^{\\dagger}],[\\mathbf{C}^{\\dagger}]</span> and <span class="math">\\mathbf{T}_{S},\\mathbf{R}</span>. Indeed, we can define <span class="math">[\\mathbf{A}]=[\\mathbf{A}^{\\dagger}],[\\mathbf{B}]=[\\mathbf{B}^{\\dagger}]+[\\mathbf{U}^{\\top}\\mathbf{G}^{\\top}]\\mathbf{R}</span> and <span class="math">[\\mathbf{C}]=\\mathbf{T}_{S}[\\mathbf{C}^{\\dagger}]+\\mathbf{R}[\\mathbf{A}^{\\dagger}]</span>.</p>

    <p class="text-gray-300">We also show that the crs is indistinguishable for different sets and that there is an oblivious trapdoor generation strategy, and hence we also have a no-signaling extraction strategy. The indistinguishability of the crs follows directly from the indistinguishability of SSB commitment</p>

    <p class="text-gray-300">keys; it is enough to note that only the commitment key depends on <span class="math">S</span> and all other values can be efficiently computed given only the commitment key. For oblivious trapdoor generation, we use the fact that we can sample an identically distributed commitment key along with a trapdoor -this follows by the oblivious key generation of the commitment scheme- and then we argue in the same way as before: given the commitment key we can sample the rest of crs honestly.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Extension to Knowledge Transfer, Bilateral Spaces and Sum Arguments.</h4>

    <p class="text-gray-300">We also construct variations of the above protocol, specifically a knowledge transfer version based on <em>[x10]</em> and two construction suitable for asymmetric bilinear groups.</p>

    <p class="text-gray-300">First we consider the knowledge transfer construction. We first describe the local constraints. Consider two matrices <span class="math">[\\mathbf{M}],[\\mathbf{N}]</span>, and two commitment keys <span class="math">[\\mathbf{G}],[\\mathbf{H}]</span> statistically binding at <span class="math">S</span>. The statement consists of two commitments <span class="math">[c],[d]</span>. For the local extraction guarantee w.r.t. set <span class="math">S</span> we require that, given an accepting proof <span class="math">\\pi</span> and an opening <span class="math">\\bm{w}</span>, we can extract values <span class="math">[x_{S}]</span>, <span class="math">[y_{S}]</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[x_{S}]</span>, <span class="math">[y_{S}]</span> are the unique <span class="math">S</span>-openings of <span class="math">[c],[d]</span> w.r.t. commitment keys <span class="math">\\mathbf{G},\\mathbf{H}</span> respectively, and</li>

      <li>if <span class="math">[x_{S}]=[\\mathbf{M}_{S}]\\bm{w}</span>, then <span class="math">[y_{S}]=[\\mathbf{N}_{S}]\\bm{w}</span>.</li>

    </ol>

    <p class="text-gray-300">The construction and the analysis are identical to the previous case. We simply use the <em>[x14]</em> construction for the matrix with upper part <span class="math">\\mathbf{GM}</span> and lower part <span class="math">\\mathbf{HN}</span>. The only difference in the analysis is on the local extraction case. We argue that we can extract an accepting proof for a crs for the language of linear knowledge transfer for the matrices <span class="math">\\mathbf{M}_{S},\\mathbf{N}_{S}</span> and, thus, we also require that the <span class="math">\\mathcal{M}_{S}^{\\top}</span>-<span class="math">\\mathsf{MDDH}</span> assumption holds for every <span class="math">S</span>, where <span class="math">\\mathcal{M}_{S}</span> is the distribution from which we sample <span class="math">\\mathbf{M}_{S}</span>.</p>

    <p class="text-gray-300">Finally, we also consider constructions in asymmetric bilinear groups. A variant of the linear subspace QA-NIZK argument given in <em>[x13]</em>, and extended to knowledge transfer arguments in <em>[x10]</em>, considers the statement as well as the matrix split between the two groups. We call this argument a linear argument for bilateral spaces. We also consider a particular type of argument for bilateral linear spaces defined in <em>[x13]</em> and called “sum in subspace argument”. In this case, the statement is <span class="math">[x]_{1},[y]_{2}</span> and soundness captures that <span class="math">\\bm{x}+\\bm{y}\\in\\mathrm{Im}(\\mathbf{M}+\\mathbf{N})</span> given <span class="math">[\\mathbf{M}]_{1},[\\mathbf{N}]_{2}</span> in the two different source groups. We construct quasi arguments for all these variants with knowledge transfer soundness. Luckily, the constructions as well as the security proofs are minor modifications of the original argument.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">2.2.4 Quasi-Argument of Hadamard Products</h4>

    <p class="text-gray-300">The next quasi arguement construction shows that some vector <span class="math">\\bm{c}</span> is the Hadamard product of two vectors <span class="math">\\bm{a},\\bm{b}</span>, namely <span class="math">\\bm{c}=\\bm{a}\\circ\\bm{b}</span>. We can naturally define the local constraints here as <span class="math">\\bm{c}_{S}=\\bm{a}_{S}\\circ\\bm{b}_{S}</span> for every set <span class="math">S\\subseteq[n]</span>, where <span class="math">n</span> is the dimension of the vectors. As in the linear case, we care about committed values, that is, the vectors <span class="math">\\bm{a},\\bm{b},\\bm{c}</span> are committed and we claim that the openings satisfy the claimed relation.</p>

    <p class="text-gray-300">Our starting point is the “bit-string” argument of <em>[x13]</em>. We observe that it is implicitly a quasi-argument with locality parameter <span class="math">K=1</span> for the set of equations <span class="math">b_{i}(b_{i}-1)=0</span> for all <span class="math">i\\in[n]</span>. Next we describe this construction and after that we show it indeed satisfies the</p>

    <p class="text-gray-300">no-signaling local soundness property. It will be convenient to directly work with equations of the form <span class="math">x_{i}y_{i}=z_{i}</span> instead of the bit-string argument equations.</p>

    <p class="text-gray-300">The common reference string in <em>[x13]</em> contains what we interpret as three SSB commitment keys <span class="math">[\\mathbf{G}],[\\mathbf{H}],[\\mathbf{F}]</span> with locality parameter <span class="math">K=1</span>. It additionally includes the product <span class="math">[\\mathbf{G}\\otimes\\mathbf{H}]</span>. The prover gives three commitments <span class="math">[a],[b],[c]</span> w.r.t. <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span> and claims that the openings satisfy the Hadamard relation. We first note that it is easy to construct an arguement for a related language. Consider the elements <span class="math">\\mathbf{G}\\otimes\\mathbf{H}</span> as a commitment key. The prover can give a commitment to the Kronecker product <span class="math">z=a\\otimes b</span> by computing <span class="math">[t]=[\\mathbf{G}\\otimes\\mathbf{H}]z</span>. The verifier can then use the pairing to verify the Kronecker product relation, namely it tests that <span class="math">e([c],[d])=e([t],[1])</span> where <span class="math">[c]=[\\mathbf{G}]a,[d]=[\\mathbf{H}]b</span> are commitment to some vectors and are part of the statement. Some simple calculations show that</p>

    <p class="text-gray-300"><span class="math">cd=c\\otimes d=\\mathbf{G}a\\otimes\\mathbf{H}b=(\\mathbf{G}\\otimes\\mathbf{H})(a\\otimes b)=t</span></p>

    <p class="text-gray-300">The Kronecker product commitment <span class="math">t</span> is included as part of the proof. Now, from this simple Kronecker product argument, it is easy to prove the Hadamard product. It is enough to note that the Hadamard product is a linear funciton of the Kronecker product, thus, the prover and verifier can use the protocol for linear relations of the previous section.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Local and No-Signaling Extraction.</h4>

    <p class="text-gray-300">The crucial observation to prove local extraction is that if <span class="math">\\mathbf{G},\\mathbf{H}</span> are extractable in one position, say <span class="math">i,j</span> respectively, then <span class="math">\\mathbf{G}\\otimes\\mathbf{H}</span> is extractable at position <span class="math">n(i-1)+j</span>. More concretely, lettting <span class="math">\\mathbf{T}_{\\mathbf{G}},\\mathbf{T}_{\\mathbf{H}}</span> be the trapdoors for <span class="math">\\mathbf{G},\\mathbf{H}</span> respectively, the trapdoor for the commitment key <span class="math">\\mathbf{G}\\otimes\\mathbf{H}</span> is simply <span class="math">\\mathbf{T}_{\\mathbf{G}}\\otimes\\mathbf{T}_{\\mathbf{H}}</span>. Some straightforward calculations reveal that applying this trapdoor to a commitment with the key <span class="math">\\mathbf{G}\\otimes\\mathbf{H}</span> indeed yields the <span class="math">n(i-1)+j</span>-th coordinate of the committed value, which is uniquely defined. In fact, we generalize this for larger locality parameters and we also show that, for some distributions of commitment keys, the no-signaling/oblivious trapdoor generation properties hold if they hold for <span class="math">\\mathbf{G},\\mathbf{H}</span>.</p>

    <p class="text-gray-300">Consider the simple case of <span class="math">K=1</span> and let all three commitments <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span> be extractable at the same position <span class="math">i</span>. We show that we can extract local openings <span class="math">[x_{i}]=\\mathbf{T}_{\\mathbf{G}}[a],[y_{i}]=\\mathbf{T}_{\\mathbf{H}}[b],[z_{i}]=\\mathbf{T}_{\\mathbf{F}}[c]</span> as well as <span class="math">[w_{i}]=\\mathbf{T}_{\\mathbf{G}\\otimes\\mathbf{H}}[t]</span> such that <span class="math">z_{i}=x_{i}y_{i}</span>. Assume for the sake of a contradiction that <span class="math">z_{i}\\neq z_{i}^{\\prime}=a_{i}b_{i}</span>. Since the columns <span class="math">g_{i},h_{i},f_{i}</span> are linearly independent from the other columns in <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span>, respectively, if the commitments <span class="math">[c],[d],[t]</span> satisfies <span class="math">[c]\\otimes[d]=e([t],[1])</span>, then the unique openings at coordinate <span class="math">i</span> satisfy <span class="math">z_{i}=x_{i}y_{i}</span>. Now, if <span class="math">z_{i}\\neq z_{i}^{\\prime}</span>, the linear relation does not hold and we can break the underlying QA-NIZK for membership in linear spaces.</p>

    <p class="text-gray-300">For oblivious trapdoor generation, it is enough to note that if the commitment key satisfies this property, so does the above constructions. Indeed, note that using the commitment key, it is enough to produce a crs for membership in subspace language to create the full crs of the protocol.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Extension to Knowledge Transfer Arguments.</h4>

    <p class="text-gray-300">We extend the quasi-argument local soundness to offer a “knowledge transfer” guarantee. In this case, we essentially commit to commitments. That is, we use an SSB commitment key to commit to multiple commitments and the local openings are commitments themselves. Namely we extract values <span class="math">[x_{i}],[y_{i}],[z_{i}]</span> which are interpreted as commitments w.r.t. some (not necessarily SSB) commitments keys <span class="math">\\mathbf{U},\\mathbf{V},\\mathbf{W}</span>. We require that no PPT adversary can produce openings <span class="math">a,b</span> such that <span class="math">x_{i}=\\mathbf{U}_{i}a,y_{i}=\\mathbf{V}_{i}b</span> but <span class="math">z_{i}\\neq\\mathbf{W}_{i}a\\circ b</span>. The constraint language for a set <span class="math">S</span> is parametrized by SSB commitments <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span> binding at <span class="math">S</span> as well as some matrices <span class="math">\\mathbf{U},\\mathbf{V},\\mathbf{W}</span>. We require that given an accepting proof <span class="math">\\pi</span> for a statement <span class="math">[c],[d],[f]</span> and openings <span class="math">a,b</span>, we can extract values <span class="math">[x_{S}],[y_{S}],[z_{S}]</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[x_{S}],[y_{S}],[z_{S}]</span> are the unique <span class="math">S</span>-openings of <span class="math">[c],[d],[f]</span> w.r.t. commitment keys <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span> respectively, and</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">[x_{S}]=[\\mathbf{U}_{S}]\\bm{a}</span> and <span class="math">[\\bm{y}_{S}]=[\\mathbf{V}_{S}]\\bm{b}</span>, then <span class="math">[z_{S}]=[\\mathbf{W}_{S}]\\bm{a}\\circ\\bm{b}</span>.</li>

    </ol>

    <p class="text-gray-300">One might wonder at this point how we commit to commitments which naturally requires multiplication of group elements which is assumed computationally hard. To achieve that, we simply include in the crs the products <span class="math">[\\mathbf{GU}],[\\mathbf{HV}],[\\mathbf{FW}]</span>. Now, we can commit to the <span class="math">n</span> commitments <span class="math">\\mathbf{U}_{i}\\bm{a}</span> as <span class="math">[\\mathbf{GU}]\\bm{a}</span> and similarly for the other keys.</p>

    <p class="text-gray-300">The knowledge transfer version is essentially the same as in the previous case. The only difference is that we also need to include some additional elements in the crs to allow to the prover to compute the Kronecker product, namely the values <span class="math">[\\mathbf{Q}]=[(\\mathbf{G\\otimes H})(\\mathbf{U\\otimes V})]</span>. As in the previous case, we can then exploit the linear relation between the Hadamard product and the Kronecker product. From a correct commitment <span class="math"><a href="\\bm{a\\otimes b}">\\mathbf{Q}</a></span>, we can use the linear knowledge transfer to get a commitment to the Hadamard products w.r.t. the third commitment key, namely <span class="math"><a href="\\bm{a}\\circ\\bm{b}">\\mathbf{FW}</a></span>. To show this, we first show that the <span class="math">\\mathcal{G}\\otimes\\mathcal{H}</span>-MDDH assumption holds if <span class="math">\\mathcal{G}</span>-MDDH and <span class="math">\\mathcal{H}</span>-MDDH hold, where <span class="math">\\mathcal{G},\\mathcal{H}</span> are the distributions of <span class="math">\\mathbf{G},\\mathbf{H}</span> respectively.</p>

    <p class="text-gray-300">We are also able to extend these techniques to work in asymmetric bilinear groups as well. The construction is somewhat technical, but the core idea is to construct SSB commitments suitable for asymmetric groups, where we “split” the commitments between the two groups, and use the bilateral variants of the linear quasi-arguments discussed in the previous sections.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">2.3 From our Quasi-Arguments to Delegation.</h3>

    <p class="text-gray-300">Using the ideas of <em>[x20, x13]</em>, we can derive delegation of computation from quasi arguments for languages encoding the computation. The local constraints capture that each step of the computation was done correctly. First, we present the high level idea for the delegation construction from quasi-arguments. We first show how to delegate low-space TMs/low-width circuits and then we show how to overcome the dependence on space/width.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">2.3.1 Delegating bounded space TM/bounded width circuits</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first recall the high-level ideas to construct a delegation scheme from quasi arguments of <em>[x20, x13]</em> in the simpler case of bounded space computation. Consider some polynomial time sequential computation which on input <span class="math">x</span> outputs <span class="math">y</span>, for example a Turing Machine or an arithmetic circuit. The computation goes through a sequence of states <span class="math">\\texttt{st}_{0},\\texttt{st}_{1},\\ldots,\\texttt{st}_{d}</span> such that <span class="math">\\texttt{st}_{0}</span> is consistent with the input, state <span class="math">\\texttt{st}_{d}</span> contains the output <span class="math">y</span>, and there’s a functional relation between states <span class="math">\\texttt{st}_{i},\\texttt{st}_{i+1}</span> where <span class="math">\\texttt{st}_{i+1}=f(\\texttt{st}_{i})</span> and <span class="math">f</span> is determined by the description of the computation. We first consider the case of bound space computation and discuss later how to remove this constraint. Consider a quasi arguement of locality $K=2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> where local constraints require that </span>\\texttt{st}_{i},\\texttt{st}_{i+1}<span class="math"> are consistent w.r.t. </span>f<span class="math">. The goal is to show that an adversary that makes the quasi-argument verifier accept must (w.o.p) sample </span>x<span class="math">, </span>y<span class="math"> such that </span>y<span class="math"> is the result of the computation on input </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can first “program” the local extractor extractor to extract <span class="math">\\texttt{st}_{0},\\texttt{st}_{1}</span>, i.e. use locality parameter $K=2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a bound on the size of the states (i.e. space of the TM or width of the circuit). Local soundness asserts that state </span>\\texttt{st}_{0}<span class="math"> is consistent with </span>x<span class="math">. Local soundness also implies that </span>\\texttt{st}_{1}<span class="math"> is consistent with </span>\\texttt{st}_{0}<span class="math"> and hence with </span>x<span class="math"> (note that the statement </span>\\texttt{st}_{1}=f(\\texttt{st}_{0})<span class="math"> depends only on local variables). Now, to show that </span>\\texttt{st}_{2}<span class="math"> is also consistent, we jump to another game where first the extractor computes only </span>\\texttt{st}_{1}<span class="math">, and in the next game the extractor computes </span>\\texttt{st}_{1},\\texttt{st}_{2}<span class="math">. The crucial observation is that </span>\\texttt{st}_{1}<span class="math"> should be still consistent with </span>x<span class="math"> in both games. Otherwise, we can distinguish between the common output of extractors for </span>\\texttt{st}_{0},\\texttt{st}_{1}<span class="math"> and </span>\\texttt{st}_{1}<span class="math"> or between </span>\\texttt{st}_{1}<span class="math"> and </span>\\texttt{st}_{1}<span class="math">, </span>\\texttt{st}_{2}<span class="math">, which contradicts the no-signaling property. Importantly, we can efficiently compute the “correct” state </span>\\texttt{st}_{1}$ since the computation is deterministic, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">thus the no-signaling distinguisher discribed is indeed efficient. Similarly, consistency of <span class="math">\\mathtt{st}_{1}</span> and local soundness imply that <span class="math">\\mathtt{st}_{2}</span> is also consistent. Now, we can inductively continue until we reach the last state, <span class="math">\\mathtt{st}_{d}</span>, which corresponds to the output of the computatiaon.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Small width circuit delegation from DLIN.</h4>

    <p class="text-gray-300">Let <span class="math">C</span> be an arithmetic circuit with width <span class="math">w</span> and depth <span class="math">d</span>. We consider the input to correspond to level <span class="math">0</span>. Without loss of generality, assume that the circuit has <span class="math">w</span> input and <span class="math">w</span> output wires. In this section we consider the width <span class="math">w</span> to be small, or alternatively, efficiency will depend on <span class="math">w</span>.</p>

    <p class="text-gray-300">We follow the circuit arithmetization of <em>[x13]</em>. The multiplication gates are partitioned in <span class="math">d</span> levels. Each level groups the gates at the same distance from the inputs, without counting linear gates. In this way, the inputs of level <span class="math">i+1</span> are linear combinations of outputs of the <span class="math">i</span> previous levels. We can then express this as constraints describing the computation as</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{i}\\circ\\bm{b}_{i}</span> <span class="math">=\\bm{c}_{i}</span> <span class="math">\\text{for }i=1\\text{ to }d,</span> (1) <span class="math">\\binom{\\bm{a}_{i+1}}{\\bm{b}_{i+1}}</span> <span class="math">=\\sum_{0\\leq j\\leq i}\\binom{\\mathbf{D}_{i,j}}{\\mathbf{E}_{i,j}}\\bm{c}_{j}=\\begin{pmatrix}\\mathbf{D}_{i}&amp;\\mathbf{0}\\cr\\mathbf{E}_{i}&amp;\\mathbf{0}\\end{pmatrix}\\bm{c}</span> <span class="math">\\text{for }i=0\\text{ to }d-1,</span> (2) <span class="math">\\bm{c}_{0}</span> <span class="math">=\\bm{x}\\in\\mathbb{Z}_{p}^{w}\\text{ and }\\bm{c}_{d}=\\bm{y}\\in\\mathbb{Z}_{p}^{w}.</span> (3)</p>

    <p class="text-gray-300">Vectors <span class="math">\\bm{a}_{i},\\bm{b}_{i},\\bm{c}_{i}</span> denote respectively the left, right and output wires of multiplication gates in level <span class="math">i</span>. Matrices <span class="math">\\mathbf{D}_{i,j},\\mathbf{E}_{i,j}</span> can be naturally derived from the circuit’s linear gates. Equation (1) states the relation between output wires and the input wires of a level of multiplication gates.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now consider a symmetric bilinear group described by <span class="math">gk</span> and consider three SSB commitments <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span> with locality $K=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for committing to </span>wd$-dimensional vectors. We publish in the crs the commitment keys and we we also compute two quasi argument crs:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for membership in linear space crs for the matrix \\[ [\\mathbf{M}_{1}]=\\begin{bmatrix}\\mathbf{F}\\\\</li>

    </ol>

    <p class="text-gray-300">\\mathbf{G}\\mathbf{D}\\\\ \\mathbf{H}\\mathbf{E}\\end{bmatrix} \\]. Here, <span class="math">\\mathbf{D}</span>, <span class="math">\\mathbf{E}</span> are the matrices for the linear relations as a whole (note per level). That is, for left and output wires it should hold <span class="math">\\bm{a}=\\mathbf{D}\\bm{c}</span>, and similarly for right wires.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for hadamard relation for <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span>. Note that, essentially, this corresponds to yet another quasi argument for membership in linear spaces for \\[ [\\mathbf{M}_{2}]=\\begin{bmatrix}(\\mathbf{G}\\otimes\\mathbf{H})\\\\</li>

    </ol>

    <p class="text-gray-300">\\mathbf{F}\\bm{\\Delta}\\end{bmatrix} \\] where <span class="math">\\bm{\\Delta}</span> captures the linear relation between the Kronecker and Hadamard product, that is <span class="math">(\\bm{a}\\circ\\bm{b})=\\bm{\\Delta}(\\bm{a}\\otimes\\bm{b})</span>.</p>

    <p class="text-gray-300">The prover gives the commitments to the left, right, output wires, namely <span class="math">[\\bm{L}]=[\\mathbf{G}]\\bm{a},[\\bm{R}]=[\\mathbf{H}]\\bm{b},[\\bm{O}]=[\\mathbf{F}]\\bm{c}</span>. Note that these commitments are of size <span class="math">\\mathcal{O}(\\mathsf{poly}(\\kappa)w)</span> but independent of <span class="math">d</span>. Next, it proves that <span class="math">[\\mathbf{O}],[\\mathbf{L}],[\\mathbf{R}]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>lie in the image of <span class="math">[\\mathbf{M}_{1}]</span> using the witness <span class="math">\\bm{c}</span>.</li>

      <li>satisfy the Hadamard relations. To do so, it computes a commitment <span class="math">[\\bm{Z}]=<a href="\\bm{a}\\otimes\\bm{b}">(\\mathbf{G}\\otimes\\mathbf{H})</a></span> and shows using the linear argument that the vector \\[ \\begin{bmatrix}\\binom{\\bm{Z}}{\\bm{O}}\\end{bmatrix} \\] lies in the image of <span class="math">\\mathbf{M}_{2}</span> using the witness <span class="math">\\bm{a}\\otimes\\bm{b}</span>.</li>

    </ul>

    <p class="text-gray-300">The verifier checks that (1) the linear proofs verify and (2) that <span class="math">e([\\bm{L}],[\\bm{R}])=e([\\bm{Z}],[1])</span>. It also does some additional input/output consistency check which we omit for now and describe next.</p>

    <p class="text-gray-300">Now, let’s see the core of the extraction argument. The inductive claim goes as follows: If we set <span class="math">[\\mathbf{F}]</span> extractable for the <span class="math">i</span>-th level, namely we the set <span class="math">S_{i}=\\{iw+1,\\ldots,(i+1)w\\}</span>, then -conditioned on an accepting proof- extracting the level <span class="math">i</span>-th level wires corresponds to the correct values <span class="math">[{\\bm{c}}_{i}]</span> w.r.t. the input <span class="math">{\\bm{c}}_{0}</span>. We will handle the base case later when we discuss input/output consistency. For the inductive step, assume the statement is true for <span class="math">i</span>. We show that it is true for <span class="math">i+1</span>. We proceed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We first set <span class="math">\\mathbf{G},\\mathbf{H}</span> extractable at set <span class="math">S_{i+1}</span> corresponding to the <span class="math">i+1</span>-th level in addition to the <span class="math">\\mathbf{F}</span> extractable at <span class="math">S_{i}</span>. By the no-signaling guarantees the value <span class="math">[{\\bm{c}}_{i}]</span> extracted by <span class="math">[{\\bm{O}}]</span> is still correct.</li>

      <li>By the local soundness of the linear quasi argument, the extracted values <span class="math">[{\\bm{c}}_{i}],[{\\bm{a}}_{i+1}],[{\\bm{b}}_{i+1}]</span> must lie in the image of the submatrix of <span class="math">\\mathbf{M}_{1}</span> corresponding to these values. This matrix contains the blocks <span class="math">\\mathbf{I},\\mathbf{D}_{i+1},\\mathbf{E}_{i+1}</span>. Hence the values extracted correspond to the correct values <span class="math">[{\\bm{a}}_{i+1}],[{\\bm{b}}_{i+1}]</span> w.r.t the input <span class="math">{\\bm{c}}_{0}</span>.</li>

      <li>We only set <span class="math">\\mathbf{G},\\mathbf{H}</span> extractable at set <span class="math">S_{i+1}</span> and leave <span class="math">\\mathbf{F}</span> extractable at the empty set. By the no-signaling guarantees the extracted wires for left and right values <span class="math">[{\\bm{a}}_{i+1}],[{\\bm{b}}_{i+1}]</span> are still correct.</li>

      <li>In addition to <span class="math">\\mathbf{G},\\mathbf{H}</span> extractable at set <span class="math">S_{i+1}</span>, we set <span class="math">\\mathbf{F}</span> extractable at <span class="math">S_{i+1}</span>. Now we argue about local constraint of the Hadamard product. We proceed in two steps:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By the pairing test <span class="math">e([{\\bm{L}}],[{\\bm{R}}])=e([{\\bm{Z}}],[1])</span> and the assumption that <span class="math">[{\\bm{a}}_{i+1}],[{\\bm{b}}_{i+1}]</span> are correct we get that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{T}_{\\mathbf{G}}{\\bm{L}}\\otimes\\mathbf{T}_{\\mathbf{H}}{\\bm{R}}=(\\mathbf{T}_{\\mathbf{G}}\\otimes\\mathbf{T}_{\\mathbf{H}})({\\bm{L}}\\otimes{\\bm{R}})=(\\mathbf{T}_{\\mathbf{G}}\\otimes\\mathbf{T}_{\\mathbf{H}}){\\bm{Z}}=\\mathbf{T}_{\\mathbf{G}\\otimes\\mathbf{H}}{\\bm{Z}}</span></p>

    <p class="text-gray-300">which implies that <span class="math">{\\bm{z}}_{i+1}={\\bm{a}}_{i+1}\\otimes{\\bm{b}}_{i+1}</span>. This means that the extracted value of the Kronecker commitment corresponds to the Kronecker product <span class="math">{\\bm{a}}_{i+1}\\otimes{\\bm{b}}_{i+1}</span> of left and right wires in level <span class="math">i+1</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Working similarly to the step (2), we get that the extracted values <span class="math">{\\bm{Z}}_{i+1},{\\bm{O}}_{i+1}</span> live in the image of <span class="math">\\mathbf{M}_{2}</span>. It should then be the case that we extract <span class="math">[{\\bm{c}}_{i+1}]</span> which is the Hadamard product <span class="math">{\\bm{a}}_{i+1}\\circ{\\bm{b}}_{i+1}</span>. This correspond to the correct assignment of output wires in level <span class="math">i+1</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, we only set <span class="math">\\mathbf{F}</span> extractable at set <span class="math">S_{i+1}</span> and leave <span class="math">\\mathbf{G},\\mathbf{H}</span> extractable at the empty set. By the no-signaling guarantees the extracted value <span class="math">[{\\bm{c}}_{i+1}]</span> is still correct.</li>

    </ol>

    <p class="text-gray-300">We note that proving this is technically more involved. We need to show that the quasi arguments can be composed well, and they still satisfy the no-signaling properties despite the fact that they share commitment keys. Equivalently one could define and analyze a unified quasi argument to directly work with the circuit “transition funciton”. In any case, we omit these details from these technical overview.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Input/Output Consistency.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We modify the commitment <span class="math">\\mathbf{F}</span> by making it trivially extractable at the input/output levels <span class="math">0,d</span> always, regardless of the extraction set. That is, we “use” the identity matrix <span class="math">\\mathbf{I}_{w}</span> for committing to the output wires at the first and last level. This corresponds to augmenting <span class="math">\\mathbf{F}</span> with some identity rows. Thus, the verifier can always trivially check the consistency with input/output. Note that the final commitment size grows by $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, the size of input and output, but these values are part of the statement and don’t need to be included in the proof. We stress out the “trivial” identity commitment satisfies the properties needed to be used in our quasi-arguments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Assumptions.</p>

    <p class="text-gray-300">We next discuss the assumptions we use. For the specific matrices used in the reduction, one can prove soundness of the QA-NIZK argument under falsifiable assumptions since the <span class="math">S</span>-submatrices <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2}</span> produce a non-trivial subspace. This means that we rely on the kernel assumption we use for instantiating the QA-NIZK. Noting that <span class="math">\\mathsf{MDDH}</span> assumptions implies the corresponding kernel assumptions, we can instantiate the quasi argument using the DLIN assumption. Furthermore, the no-signaling property of the commitment keys (the only computational property we use) reduces to an <span class="math">\\mathsf{MDDH}</span> which we chose on instantiation. Noting that DDH does not hold in symmetric groups we resort to the DLIN assumption which makes the commitments larger by 1 group element. Thus, soundness of the above delegation scheme reduces to the DLIN assumption.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">2.3.2 Overcoming the dependence on space/width.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The issue with the above construction is that setting $K=O(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{st}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> yields a proof whose size is linear in the space of the computation. To achieve succinctness in the general case, we need to also perform some “compressing” of the state/width. Kalai et. al. overcome this by considering delegation of RAM computation <em>[x13]</em> using collision-resistant hash function to compress the width. They use a notion similar to the knowledge transfer notion, namely that no PPT adversary can produce digests </span>\\mathsf{h},\\mathsf{h}^{\\prime}<span class="math"> and state </span>\\mathsf{st}<span class="math"> such that </span>\\mathsf{h}=\\mathsf{Hash}(\\mathsf{st})<span class="math"> but </span>\\mathsf{h}^{\\prime}\\neq\\mathsf{Hash}(f(\\mathsf{st}))<span class="math">. Now, a quasi argument for the local constraints </span>\\mathsf{h}_{i}=\\mathsf{Hash}(f(\\mathsf{st}_{i}))<span class="math"> and </span>\\mathsf{h}_{i+1}=\\mathsf{Hash}(f(\\mathsf{st}_{i}))$ is enough for delegation in the general case.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">While previous works achieve this by essentially encoding the computation of generic hash functions in the computation, we use hash functions that are based on Pedersen commitments and have nice algebraic structure and properties. This allows to avoid the concrete cost of encoding arbitrary hash functions in the arithmetic circuit. To this end, we use techniques from <em>[x10]</em> to derive a structure preserving construction. We present next the basic ideas of their (low depth) delegation construction.</p>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Structure Preserving Delegation for Bounded-Depth Circuits.</h5>

    <p class="text-gray-300">González and Ràfols <em>[x10]</em> constructed a delegation scheme with proof-size <span class="math">O(d\\kappa)</span> and verification requiring <span class="math">n</span> plus <span class="math">O(d)</span> cryptographic operations, where <span class="math">n</span> is the size of the input, <span class="math">d</span> the depth of the circuit and <span class="math">\\kappa</span> a security parameter. Interestingly, the verification procedure of <em>[x10]</em> can be described completely as a set of pairing product equations. As shown by Abe et al.<em>[x1]</em>, cryptographic primitives whose correctness can be stated as equations over bilinear groups are more suited for practically efficient arguments without resorting to generic reductions to a circuit or a 3CNF formula.</p>

    <p class="text-gray-300">In the heart of the delegation scheme of <em>[x10]</em> lie the two knowledge transfer arguments for linear and quadratic relations described before. To delegate the computation of an arithmetic circuit, the multiplication gates are partitioned in <span class="math">d</span> levels. Each level groups the gates at the same distance from the inputs, without counting linear gates. In this way, the inputs of level <span class="math">i+1</span> are linear combinations of outputs of the <span class="math">i</span> previous levels. A prover commits to the left, right, and output wires of each level as <span class="math">L_{i},R_{i},O_{i}</span>. In the first <span class="math">d</span> arguments <span class="math">f</span> is a linear function and the argument handles the linear relations between the input wires (the openings of <span class="math">L_{i},R_{i}</span>) of level <span class="math">i</span> and the output wires of all previous levels (the openings of <span class="math">O_{1},\\ldots,O_{i-1}</span>). In the next <span class="math">d</span> arguments <span class="math">f</span> is the hadamard product so that the opening of <span class="math">O_{i}</span> is the the hadamard product of the openings of <span class="math">L_{i}</span> and <span class="math">R_{i}</span>. The fact that the verifier can check the commitment to the first level using the public input and a simple inductive argument over the levels shows that the output must be correct.</p>

    <p class="text-gray-300">More concretely, starting from a correct commitment <span class="math">O_{0}</span> (directly checked for consistency</p>

    <p class="text-gray-300">with input <span class="math">x</span> from the verifier) we conclude that <span class="math">L_{1},R_{1}</span> by the knowledge transfer guarantee of the linear argument. Since <span class="math">L_{1},R_{1}</span> are correct w.r.t. <span class="math">x</span>, <span class="math">O_{1}</span> is also correct w.r.t. <span class="math">x</span> by the knowledge transfer guarantee of the quadratic arguement. We continue this way and we conclude that <span class="math">O_{d}</span> is a correct commitment to the output of the computation. Now, we simply need to check that the claimed output <span class="math">y</span> is a correct opening for that latter commitment.</p>

    <p class="text-gray-300">As for soundness, the quadratic knowledge transfer arguement requires a specific (not uniform) distribution for the commitment keys where each row of the matrix of the commitment key is the result of evaluating Lagrange polynomials at a different random point. Thus, soundness relies on a width-size assumption, namely “<span class="math">\\mathcal{R}</span>-Rational Strong Diffie Hellman” assumption <em>[x10]</em> which is proven secure in the Generic Group Model. We stress out that we modify the construction of <em>[x10]</em> to overcome the need for a <span class="math">q</span>-size assumption and rely only on a constnt-size one, albeit at the cost of having a quadratic crs and prover computation.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Succinct Publicly Verifiable Delegation for polynomial size circuits.</h5>

    <p class="text-gray-300">We use the technique of <em>[x10]</em> to overcome the width dependency in the above construction. The problem with this construction is that we need to rely on simple soundness of the underlying Kiltz and Wee QA-NIZK. However if we try to “shrink” the per-level information to eliminate the width dependence, the subspaces used become trivial and knowledge soundness seems to be needed.</p>

    <p class="text-gray-300">We overcome this by relying on the knowledge transfer analysis of Kiltz and Wee used in <em>[x10]</em>. To exploit this to construct delegation, we proceed as follows: we keep the same skeleton of the small-width circuit protocol, but instead of directly committing to the left, right and output wires, we commit to commitments of them. That is, for each level we compute three shrinking commitments -with size independent of the width- corresponding to left, right and output wires for that level, and we commit to these commitments (by including appropriate group elements in the crs). Furthermore, we use the knowledge transfer variants of the quasi arguements.</p>

    <p class="text-gray-300">Now, our no-signaling extractor works as in the small-width case, but instead of the wires for some level, it outputs the commitments for the wires in this level. By the knowledge transfer guarantees, we establish that the extracted values for each level satisfy:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">O_{i}</span> is a commitment to <span class="math">\\bm{c}_{i}</span> then <span class="math">L_{i+1}</span> and <span class="math">R_{i+1}</span> are commitments to <span class="math">\\bm{a}_{i+1},\\bm{b}_{i+1}</span>,</li>

      <li>if <span class="math">L_{i+1}</span> and <span class="math">R_{i+1}</span> are commitments to <span class="math">\\bm{a}_{i+1}</span> and <span class="math">\\bm{b}_{i+1}</span> respectively, then <span class="math">O_{i+1}</span> is a commitment to <span class="math">\\bm{c}_{i+1}</span></li>

    </ol>

    <p class="text-gray-300">Extracting these values in a no-signaling way, as in the bounded space case, yields soundness for the delegation scheme. The analysis is almost the same and the only difference is that the knowledge transfer guarantee implies some hardness assumption (MDDH) on the distribution of matrices used as parameters, in this case, the width commitment keys. To satisfy this using constant size assumptions, we use a simple variation of Pedersen commitments where the commitment keys satisfy the DLIN assumption.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Remark (Uniform vs Non-Uniform Computation).</h6>

    <p class="text-gray-300">Our construction can be used for any non-uniform computation, namely polynomial size arithmetic circuits, while previous works such as <em>[x20, x14]</em> focus on delegating uniform computations: Turing or RAM machines. While this is a stronger result, we achieve it using a long (quadratic in the size/time of computation) crs while the work of <em>[x14]</em> achieves a short (i.e. sublinear) crs. One motivation for working directly with poly-size circuits is for practical efficiency: we utilize the rich SNARK toolbox without the need to encode expensive cryptographic operations as arithmetic circuits, namely, we focus on structure preserving constructions. While we have an inefficient (quadratic) prover, in all other aspects we achieve optimal efficiency comparable with SNARGs from non-falsifiable</p>

    <p class="text-gray-300">assumptions. We believe that this is a promising direction and an interesting open problem is to improve the prover to quasi-linear using these techniques. This would yield a delegation scheme for poly-size circuits that directly competes with the aforementioned non-falsifiable based constructions in all aspects, effectively making the use of non-falsifiable assumptions unjustifiable in the context of deterministic computation. We also leave as future work exploring to what extend our techniques can be applied for delegating uniform computations and if this would give some improvement over existing constructions.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Remark (On bootstrapping and proof composition).</h6>

    <p class="text-gray-300">To improve efficiency (crs size), <em>[x13]</em> use the bootstrapping technique which involves proof composition. Our techniques seem to be incompatible with the bootstrapping technique. This is because the crs of our construction depends on the circuit and we cannot directly reuse a crs for different computations. We leave as future work to examine if we can modify our techniques to be able to apply the bootstrapping technique. We also stress out that this might prove to be an interesting direction for improvements in practical efficiency as well due to some recent results in proof-composition techniques <em>[x1, x2]</em>.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">2.4 NIZK, SNARKs and Compact NIZK</h3>

    <p class="text-gray-300">We can use standard techniques to turn our delegation scheme into a NIZK argument. Essentially, the prover needs to prove knowledge of (additional) secret input wires <span class="math">w</span> and proof that <span class="math">C(x,w)=y</span> for some secret input <span class="math">w</span>. Given the “structure preserving” properties of our delegation scheme, we can directly apply the Groth Sahai proof system <em>[x10]</em> on the set of verification equations. In general, all we need to achieve knowledge soundness is an extractable (and hiding) commitment for extracting the witness <span class="math">w</span>. Depending on the properties of the extractable commitment scheme we get different NIZK flavors.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the commitments to the inputs are succinct, the construction yields a SNARK for NP. Such commitments are widely employed in SNARKs, but their security relies on non-standard assumptions: either knowledge type assumptions such as <span class="math">q</span>-Knowledge of Exponents assumption <em>[x9]</em> or the generic group model <em>[x11]</em>. If we take for example the zk-SNARK from <em>[x12]</em>, the size of <span class="math">q</span> is the number of field elements extracted from a valid proof. Indeed, the proof of soundness requires the extraction of all the circuit wires, which are later used to break some falsifiable <span class="math">q</span>-assumption. Consequently, the knowledge assumption is of size $q=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. By reducing the number of extracted values from </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we reduce the size of the underlying knowledge assumption to </span>q=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we use the “bit-string” argument of <em>[x14]</em> to show knowledge of <span class="math">\\bm{b}\\in\\{0,1\\}^{n}</span>, we get extractable commitments of size <span class="math">n+O(1)</span> group elements based on a constant-size falsifiable assumption. Combining this extractable commitment with our delegation scheme yields a NIZK argument for circuit satisfiability with proof size <span class="math">n+O(1)</span> groups elements, or equivalently of size <span class="math">O(n\\kappa)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we can then use the techniques of Katsumata et al. <em>[x15, x16]</em> to construct a compact NIZK. The construction of Katsumata et al. is based on a non-compact NIZK argument for <span class="math">\\text{NC}^{1}</span> plus a symmetric key encryption scheme <span class="math">(\\mathsf{K},\\mathsf{E},\\mathsf{D})</span> where the size of <span class="math">\\mathsf{E}(K,m)</span> is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{poly}(\\kappa)<span class="math">. Instead of committing to the input </span>\\bm{x}<span class="math"> of a circuit </span>C<span class="math">, we need to compute </span>K\\leftarrow\\mathsf{K}(1^{\\kappa})<span class="math"> to obtain </span>ct\\leftarrow\\mathsf{E}(K,\\bm{x})<span class="math"> and give a NIZK argument of knowledge of some </span>K\\in\\{0,1\\}^{\\mathsf{poly}(\\kappa)}<span class="math"> such that </span>C(\\mathsf{D}(K,ct))=1$ . We note that we can straightforward use this idea to construct compact NIZK for any circuit by simply plugging our NIZK argument based on the commitments of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>[x15]</em>. The final proof is of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ct</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{poly}(\\kappa)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n+\\mathsf{poly}(\\kappa)$ and is sound for any polynomial size circuit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-35" class="text-2xl font-bold">3 Preliminaries</h2>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">3.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">n\\in\\mathbb{N}</span>, let <span class="math">[n]</span> be the set <span class="math">\\{1,\\ldots,n\\}</span>. For vectors <span class="math">\\bm{a}=(a_{i})_{i\\in[n]}</span>, <span class="math">\\bm{b}=(b_{i})_{i\\in[n]}\\in\\mathbb{Z}_{p}^{n}</span>, we denote <span class="math">\\bm{a}\\circ\\bm{b}=(a_{i}b_{i})_{i\\in[n]}</span> the Hadamard product of them, and for matrices <span class="math">\\mathbf{A}=(a_{i,j})_{i\\in[n_{1}],j\\in[m_{1}]}\\in\\mathbb{Z}_{p}^{n_{1}\\times m_{1}}</span>, <span class="math">\\mathbf{B}\\in\\mathbb{Z}_{p}^{n_{2}\\times m_{2}}</span> we denote <span class="math">\\mathbf{A}\\otimes\\mathbf{B}=(a_{i,j}\\mathbf{B})_{i\\in[n_{1}],j\\in[m_{1}]}\\in\\mathbb{Z}_{p}^{n_{1}n_{2}\\times m_{1}m_{2}}</span> their Kronecker product. We will be using the mixed-product property of kronecker products, which says that <span class="math">(\\mathbf{A}\\otimes\\mathbf{B})(\\mathbf{C}\\otimes\\mathbf{D})=(\\mathbf{A}\\mathbf{C})\\otimes(\\mathbf{B}\\mathbf{D})</span> whenever <span class="math">\\mathbf{A},\\mathbf{B},\\mathbf{C},\\mathbf{D}</span> have the appropriate dimensions. When <span class="math">n_{1}=n_{2}</span> we denote by $\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B}\\in\\mathbb{Z}_{p}^{n_{1}\\times m_{1}+m_{2}}<span class="math"> their vertical concatenation. For </span>\\bm{x},\\bm{y}\\in\\mathbb{Z}_{p}^{n}<span class="math"> we write </span>\\bm{x}\\leq\\bm{y}<span class="math"> if and only if </span>x_{i}\\leq y_{i}<span class="math"> for all </span>i\\in[n]<span class="math">. We consider vectors of sets </span>\\bm{S}=(S_{1},\\ldots,S_{\\ell})<span class="math">, where </span>S_{i}\\subseteq[n_{i}]<span class="math"> for </span>i\\in[\\ell]<span class="math"> and </span>n_{i}\\in\\mathbb{N}<span class="math">, and extend set operations entry-wise. That is </span>\\bm{S}^{\\prime}\\subseteq\\bm{S}<span class="math"> if and only if </span>S_{i}^{\\prime}\\subseteq S_{i}<span class="math"> for all </span>i\\in[\\ell]<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. For </span>\\bm{n}\\in\\mathbb{N}^{\\ell}<span class="math">, </span>[\\bm{n}]=([n_{1}],\\ldots,[n_{2}])$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We use implicit group notation. Let <span class="math">gk=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,\\mathcal{P}_{1},\\mathcal{P}_{2})\\leftarrow\\mathcal{G}(1^{\\kappa})</span> be the description of an asymmetric bilinear group of size <span class="math">p=O(2^{\\kappa})</span> equipped with an efficient bilinear map <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span>, where <span class="math">\\mathcal{P}_{\\mu}</span> is a generator of <span class="math">\\mathbb{G}_{\\mu}</span>, <span class="math">\\mu\\in\\{1,2\\}</span>. We assume all our algorithms receive as input <span class="math">gk</span> sampled from <span class="math">\\mathcal{G}(1^{\\lambda})</span>, although in some abstract definitions is not necessarily the description of a bilinear group. For <span class="math">r\\in\\mathbb{Z}_{p}</span> we denote <span class="math">[r]_{\\mu}=r\\mathcal{P}_{\\mu}</span> for <span class="math">\\mu\\in\\{1,2,T\\}</span> and <span class="math">\\mathcal{P}_{T}=e(\\mathcal{P}_{1},\\mathcal{P}_{2})</span>. For a vector <span class="math">a\\in\\mathbb{Z}_{p}^{n}</span> and matrix <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{p}^{n\\times m}</span> we denote with <span class="math">[\\bm{a}]_{\\mu}</span>, <span class="math">[\\mathbf{A}]_{\\mu}</span> the natural embedding of <span class="math">\\bm{a}</span>, <span class="math">\\mathbf{A}</span> in <span class="math">\\mathbb{G}_{\\mu}</span>, respectively.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Sub-vectors and Sub-matrices.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">S=\\{s_{1},\\ldots,s_{t}\\}\\subseteq[n]</span> and <span class="math">\\overline{S}=\\{\\overline{s}_{1},\\ldots,\\overline{s}_{n-t}\\}</span> the set <span class="math">[n]\\setminus S</span>. We use an algebraic notation for the sub-vector <span class="math">\\bm{x}_{S}</span> and sub-matrix <span class="math">\\mathbf{G}_{S}</span> of some <span class="math">\\bm{x}\\in\\mathbb{Z}_{p}^{n}</span> and <span class="math">\\mathbf{G}\\in\\mathbb{Z}_{p}^{m\\times n}</span> respectively. Let <span class="math">\\mathbf{P}_{S}\\in\\{0,1\\}^{n\\times n}</span> the permutation matrix defining the ordering <span class="math">s_{1},\\ldots,s_{t},\\overline{s}_{1},\\ldots,\\overline{s}_{n-t}</span>. That is, <span class="math">\\mathbf{P}_{S}\\bm{e}_{s_{i}}=\\bm{e}_{i}</span> and <span class="math">\\mathbf{P}_{\\overline{S}}\\bm{e}_{\\overline{s}_{i}}=\\bm{e}_{i+t}</span>, where <span class="math">\\bm{e}_{i}</span> is the <span class="math">i</span>-th unitary vector of size <span class="math">n</span>. We may simply write <span class="math">\\mathbf{P}</span> when <span class="math">n</span>, <span class="math">S</span> are clear from the context. We also define the matrix $\\bm{\\Sigma}_{S}=(\\mathbf{I}_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{0}_{t\\times n-t})$. We may omit the subscript when the values are clear from the context.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote by <span class="math">\\bm{x}_{S}\\in\\mathbb{Z}_{p}^{t}</span>, <span class="math">\\mathbf{G}_{S}\\in\\mathbb{Z}_{p}^{k\\times t}</span> the sub-vector and sub-matrix containing the elements or columns with indices in <span class="math">S\\subseteq[n]</span> of <span class="math">\\bm{x}\\in\\mathbb{Z}_{p}^{n}</span> and <span class="math">\\mathbf{G}\\in\\mathbb{Z}_{p}^{k\\times n}</span>, respectively.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Fact 1.</h6>

    <p class="text-gray-300">For any <span class="math">\\bm{x}\\in\\mathbb{Z}_{p}^{n}</span> and any <span class="math">S^{\\prime}\\subseteq S\\subseteq[n]</span> it holds that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\mathbf{P}_{S}\\bm{x}=\\left(\\frac{\\bm{x}_{S}}{\\bm{x}_{\\overline{S}}}\\right)</span> and $\\mathbf{G}\\mathbf{P}_{S}^{\\top}=(\\mathbf{G}_{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{\\overline{S}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bm{x}_{S}=\\bm{\\Sigma}_{S}\\mathbf{P}_{S}\\bm{x}</span> and <span class="math">\\mathbf{G}_{S}=\\mathbf{G}\\mathbf{P}_{S}^{\\top}\\bm{\\Sigma}_{S}^{\\top}</span>.</li>

      <li><span class="math">\\mathbf{G}\\bm{x}=\\mathbf{G}_{S}\\bm{x}_{S}+\\mathbf{G}_{\\overline{S}}\\bm{x}_{\\overline{S}}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Let $\\bm{x}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}=\\bm{\\Sigma}_{S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}}\\mathbf{P}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}\\bm{x}_{S}<span class="math">, where </span>\\mathbf{P}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}<span class="math"> is some permutation matrix such that </span>\\mathbf{P}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}\\bm{x}_{S}=\\left(\\frac{\\bm{x}_{S^{\\prime}}}{{\\bm{x}}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}}}\\right)<span class="math"> and </span>\\bm{\\Sigma}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}=(\\mathbf{I}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{0}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times t-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">. </span>\\bm{x}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}=\\bm{x}_{S^{\\prime}}<span class="math"> and </span>\\mathbf{G}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}=\\mathbf{G}_{S^{\\prime}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When <span class="math">\\bm{x}=\\mathbf{U}\\bm{w}</span>, for some matrix <span class="math">\\mathbf{U}\\in\\mathbb{Z}_{p}^{n\\times m}</span> and <span class="math">\\bm{w}\\in m</span>, we abuse of notation and also write <span class="math">\\mathbf{U}_{S}</span> for <span class="math">\\bm{\\Sigma}_{S}\\mathbf{P}_{S}\\mathbf{U}</span> so that <span class="math">\\bm{x}_{S}=\\mathbf{U}_{S}\\bm{w}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We extend this notation to two sets <span class="math">S_{1}\\subseteq[n_{1}]</span>, <span class="math">S_{2}\\subseteq[n_{2}]</span> and for <span class="math">\\bm{x}\\in\\mathbb{Z}_{p}^{n_{1}n_{2}}</span> define $\\bm{x}_{S_{1},S_{2}}\\in\\mathbb{Z}_{p}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> as </span>\\bm{x}_{S_{1},S_{2}}=(\\bm{x}_{(i-1)n_{2}+j}:i\\in S_{1}<span class="math"> and </span>j\\in S_{2})<span class="math"> in some fixed order. For matrices instead we define </span>\\mathbf{G}_{S_{1},S_{2}}=(q_{\\ell,(i-1)n_{2}+j}:\\ell\\in[k],i\\in S_{1}<span class="math"> and </span>j\\in S_{2})\\in\\mathbb{Z}_{p}^{k\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, where </span>k<span class="math"> is the number of columns of </span>\\mathbf{G}$. Similarly as before, the following holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fact 2. For any <span class="math">x \\in \\mathbb{Z}_p^{n_1 n_2}</span> and any <span class="math">S_1&#x27; \\subseteq S_1 \\subseteq [n_1], S_2&#x27; \\subseteq S_2 \\subseteq [n_2]</span> it holds that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i. For some permutation matrix <span class="math">\\Pi \\in \\mathbb{Z}_p^{n_1n_2\\times n_1n_2}</span>, <span class="math">(\\mathbf{P}_{S_1}\\otimes \\mathbf{P}_{S_2})x = \\Pi \\left( \\begin{array}{l}x_{S_1,S_2}\\\\ x_{S_1,S_2}^{\\top}\\\\ x_{S_1,S_2}^{\\top} \\end{array} \\right)</span> and $\\mathbf{G}(\\mathbf{P}_{S_1}^\\top \\otimes \\mathbf{P}_{S_2}^\\top) = (\\mathbf{G}_{S_1,S_2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{S_1,\\widetilde{S}_2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{\\widetilde{S}_1,S_2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{\\widetilde{S}_1,\\widetilde{S}_2})\\Pi^\\top$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">ii. <span class="math">x_{S_1,S_2} = (\\Sigma_{S_1}\\otimes \\Sigma_{S_2})(\\mathbf{P}_{S_1}\\otimes \\mathbf{P}_{S_2})x</span> and <span class="math">\\mathbf{G}_{S_1,S_2} = \\mathbf{G}(\\mathbf{P}_{S_1}^\\top \\otimes \\mathbf{P}_{S_2}^\\top)(\\Sigma_{S_1}^\\top \\otimes \\Sigma_{S_2}^\\top)</span>.</p>

    <p class="text-gray-300">iii. <span class="math">\\mathbf{G}x = \\mathbf{G}_{S_1,S_2}x_{S_1,S_2} + \\mathbf{G}_{S_1,\\widetilde{S}_2}x_{S_1,\\widetilde{S}_2} + \\mathbf{G}_{\\widetilde{S}_1,S_2}x_{\\widetilde{S}_1,S_2} + \\mathbf{G}_{\\widetilde{S}_1,\\widetilde{S}_2}x_{\\widetilde{S}_1,\\widetilde{S}_2}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">iv. Let $x_{S_1',S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1,S_2} = (\\Sigma_{S_1'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1}^\\top \\otimes \\Sigma_{S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2}^\\top)(\\mathbf{P}_{S_1'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1}\\otimes \\mathbf{P}_{S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2})x_{S_1,S_2}<span class="math"> and </span>\\mathbf{G}_{S_1',S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1,S_2} = \\mathbf{G}(\\mathbf{P}_{S_1'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1}^\\top \\otimes \\mathbf{P}_{S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2}^\\top)(\\Sigma_{S_1'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1}^\\top \\otimes \\Sigma_{S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2}^\\top)<span class="math">. Then </span>x_{S_1',S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1,S_2} = x_{S_1',S_2'}<span class="math"> and </span>\\mathbf{G}_{S_1',S_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1,S_2} = \\mathbf{G}_{S_1',S_2'}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-39" class="text-2xl font-bold">3.2 Cryptographic Assumptions</h2>

    <p class="text-gray-300">Definition 1. Let <span class="math">k, \\ell \\in \\mathbb{N}</span>. We call <span class="math">\\mathcal{D}_{\\ell,k}</span> (resp. <span class="math">\\mathcal{D}_k</span>) a matrix distribution if it outputs in PPT time, with overwhelming probability matrices in <span class="math">\\mathbb{Z}_p^{\\ell \\times k}</span> (resp. in <span class="math">\\mathbb{Z}_p^{(k+1)\\times k}</span>). For a matrix distribution <span class="math">\\mathcal{D}_k</span>, we denote as <span class="math">\\overline{\\mathcal{D}}_k</span> the distribution of the first <span class="math">k</span> rows of the matrices sampled according to <span class="math">\\mathcal{D}_k</span>.</p>

    <p class="text-gray-300">Assumption 1. Let <span class="math">\\mathcal{D}_{\\ell,k}</span> be a matrix distribution. For all non-uniform PPT adversaries <span class="math">\\mathcal{A}</span> and relative to <span class="math">gk \\gets \\mathcal{G}(1^{\\kappa})</span>, <span class="math">\\mathbf{A} \\gets \\mathcal{D}_{\\ell,k}</span> and the coin tosses of adversary <span class="math">\\mathcal{A}</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the Kernel Matrix Diffie-Hellman Assumption holds in <span class="math">\\mathbb{G}_{\\gamma}</span> [MRV16] if</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ [ \\boldsymbol {r} ] _ {3 - \\gamma} \\leftarrow \\mathcal {A} (g k, [ \\mathbf {A} ] _ {\\gamma}): \\boldsymbol {r} ^ {\\top} \\mathbf {A} = 0 \\right] = \\operatorname {n e g l} (\\kappa),</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the Split Kernel Matrix Diffie-Hellman Assumption [GHR15b] holds if</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ [ \\boldsymbol {r} ] _ {1}, [ \\boldsymbol {s} ] _ {2} \\leftarrow \\mathcal {A} (g k, [ \\mathbf {A} ] _ {1}, [ \\mathbf {A} ] _ {2}): \\boldsymbol {r} \\neq \\boldsymbol {s} \\wedge \\boldsymbol {r} ^ {\\top} \\mathbf {A} = \\boldsymbol {s} ^ {\\top} \\mathbf {A} \\right] = \\operatorname {n e g l} (\\kappa).</span></div>

    <p class="text-gray-300">Assumption 2. Let <span class="math">\\mathcal{D}_{\\ell,k}</span> be a matrix distribution and <span class="math">gk \\gets \\mathcal{G}(1^{\\kappa})</span>. For all non-uniform PPT adversaries <span class="math">\\mathcal{A}</span> and relative to <span class="math">gk \\gets \\mathcal{G}(1^{\\kappa})</span>, <span class="math">\\mathbf{A} \\gets \\mathcal{D}_{\\ell,k}, \\mathbf{w} \\gets \\mathbb{Z}_p^k, [z]_{\\gamma} \\gets \\mathbb{G}_{\\gamma}^{\\ell}</span> and the coin tosses of adversary <span class="math">\\mathcal{A}</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the Matrix Decisional Diffie-Hellman Assumption in <span class="math">\\mathbb{G}_{\\gamma}</span> (<span class="math">\\mathcal{D}_k</span>-MDDH<span class="math">_{\\gamma}</span>) holds if</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\mathcal {A} (g k, [ \\mathbf {A} ] _ {\\gamma}, [ \\mathbf {A} w ] _ {\\gamma}) = 1 ] - \\Pr [ \\mathcal {A} (g k, [ \\mathbf {A} ] _ {\\gamma}, [ z ] _ {\\gamma}) = 1 ] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\kappa),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the Split Matrix Decisional Diffie-Hellman Assumption in <span class="math">\\mathbb{G}_{\\gamma}</span> (<span class="math">\\mathcal{D}_k</span>-SMDDH<span class="math">_{\\gamma}</span>) holds if</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\mathcal {A} (g k, [ \\mathbf {A} ] _ {1, 2}, [ \\mathbf {A} w ] _ {\\gamma}) = 1 ] - \\Pr [ \\mathcal {A} (g k, [ \\mathbf {A} ] _ {1, 2}, [ z ] _ {\\gamma}) = 1 ] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\kappa).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Assumption 3. Let <span class="math">(\\mathcal{D}_{\\ell,k}^1, \\mathcal{D}_{\\ell,k}^2)</span> be (possibly correlated) matrix distributions and <span class="math">gk \\gets \\mathcal{G}(1^\\kappa)</span>. For all non-uniform PPT adversaries <span class="math">\\mathcal{A}</span> and relative to <span class="math">gk \\gets \\mathcal{G}(1^\\kappa)</span>, <span class="math">(\\mathbf{A}, \\mathbf{B}) \\gets (\\mathcal{D}_{\\ell,k}^1, \\mathcal{D}_{\\ell,k}^2)</span>, <span class="math">\\mathbf{w} \\gets \\mathbb{Z}_p^k, [z]_\\gamma \\gets \\mathbb{G}_\\gamma^\\ell</span> and the coin tosses of adversary <span class="math">\\mathcal{A}</span>, the <span class="math">(\\mathcal{D}_{\\ell,k}^1, \\mathcal{D}_{\\ell,k}^2)</span>-Split Matrix Decisional Diffie-Hellman Assumption <span class="math">((\\mathcal{D}_{\\ell,k}^1, \\mathcal{D}_{\\ell,k}^2)</span>-MDDH<span class="math">_\\gamma</span>) holds if</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\mathcal {A} (g k, [ \\mathbf {A} ] _ {1}, [ \\mathbf {B} ] _ {2}, [ \\mathbf {A} w ] _ {1}, [ \\mathbf {B} w ] _ {2}) = 1 ] - \\Pr [ \\mathcal {A} (g k, [ \\mathbf {A} ] _ {1}, [ \\mathbf {B} ] _ {2}, [ s ] _ {1}, [ t ] _ {2}) = 1 ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\kappa).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We also consider stronger versions of these definitions, denoted <span class="math">(\\mathcal{D}_{\\ell,k}, h)</span>-MDDH, <span class="math">(\\mathcal{D}_{\\ell,k}, h)</span>-SMDDH, <span class="math">(\\mathcal{D}_{\\ell,k}^1, \\mathcal{D}_{\\ell,k}^2, h)</span>-MDDH, where the adversary is also given <span class="math">h(\\mathbf{A})</span> (<span class="math">h(\\mathbf{A}, \\mathbf{B})</span> in the latter) for some (possibly probabilistic) function <span class="math">h</span>.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300"><span class="math">\\mathsf{K}(gk,[\\mathbf{M}]_1,[\\mathbf{N}]_2,[\\mathbf{P}]_1,[\\mathbf{Q}]_2)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{K}_1\\gets \\mathbb{Z}_p^{\\ell_1\\times \\widetilde{k}};\\mathbf{K}_2\\gets \\mathbb{Z}_p^{\\ell_2\\times \\widetilde{k}};\\mathbf{K}_3\\gets \\mathbb{Z}_p^{\\ell_3\\times \\widetilde{k}};\\mathbf{K}_4\\gets \\mathbb{Z}_p^{\\ell_4\\times \\widetilde{k}}.</span></li>

      <li>Sample  <span class="math">\\mathbf{A} \\gets \\mathcal{D}_k</span> ;  <span class="math">\\Gamma \\gets \\mathbb{Z}_p^{n \\times \\widetilde{k}}</span> .</li>

      <li><span class="math">[\\mathbf{B}]_1 = [\\mathbf{M}^\\top \\mathbf{K}_1 + \\mathbf{N}^\\top \\mathbf{K}_2 + \\Gamma]_1</span> ;  <span class="math">[\\mathbf{D}]_2 = [\\mathbf{P}^\\top \\mathbf{K}_3 + \\mathbf{Q}^\\top \\mathbf{K}_4 - \\Gamma]_2</span> .</li>

      <li><span class="math">\\mathbf{C}_1 = \\mathbf{K}_1\\mathbf{A}</span> ;  <span class="math">\\mathbf{C}_2 = \\mathbf{K}_2\\mathbf{A}</span> ;  <span class="math">\\mathbf{C}_3 = \\mathbf{K}_3\\mathbf{A}</span> ;  <span class="math">\\mathbf{C}_4 = \\mathbf{K}_4\\mathbf{A}</span> .</li>

      <li>Output  <span class="math">\\operatorname{crs} = (gk, [\\mathbf{A}]_{1,2}, [\\mathbf{B}]_1, [\\mathbf{D}]_2, [\\mathbf{C}_1]_2, [\\mathbf{C}_2]_1, [\\mathbf{C}_3]_2, [\\mathbf{C}_4]_1)</span> .</li>

    </ul>

    <p class="text-gray-300">Prove(crs,  <span class="math">([c_1]_1,[c_2]_2,[d_1]_1,[d_2]_2),w)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\rho \\gets \\mathbb{Z}_p^{\\widetilde{k}}; [\\pi]_1 := w^\\top[\\mathbf{B}]_1 + [\\rho]_1; [\\theta]_2 := w^\\top[\\mathbf{D}]_2 - [\\rho]_2</span> .</li>

    </ul>

    <p class="text-gray-300">Output  <span class="math">([\\pi ]_1,[\\theta ]_2)</span></p>

    <p class="text-gray-300">Verify(crs,  <span class="math">([c_1]_1,[c_2]_2,[d_1]_1,[d_2]_2),([\\pi ]_1,[\\theta ]_2))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output 1 iff  <span class="math">e([\\pi]_1, [\\mathbf{A}]_2) + e([\\theta]_2, [\\mathbf{A}]_1) - e([c_1^\\top]_1, [\\mathbf{C}_1]_2) - e([c_2^\\top]_2, [\\mathbf{C}_2]_1) - e([d_1^\\top]_1, [\\mathbf{C}_3]_2) - e([d_2^\\top]_2, [\\mathbf{C}_4]_1)</span> ;</li>

    </ul>

    <p class="text-gray-300">Figure 1: Construction  <span class="math">\\Pi_{\\mathrm{kl - lin}}</span>  for  <span class="math">\\mathcal{L}_{\\mathrm{lin}}^{\\mathrm{yes}},\\mathcal{L}_{\\mathrm{lin}}^{\\mathrm{no}}</span> . For  <span class="math">\\ell_1 = \\ell_2</span> , construction  <span class="math">\\Pi_{\\mathrm{kl - sum}}</span>  for  <span class="math">\\mathcal{L}_{\\mathrm{sum}}^{\\mathrm{yes}},\\mathcal{L}_{\\mathrm{sum}}^{\\mathrm{no}}</span>  is identical with the only difference that  <span class="math">\\mathbf{K}_2 = \\mathbf{K}_1</span> .</p>

    <p class="text-gray-300">In this section we recall arguments of knowledge transfer for membership in linear spaces as defined in [GR19] which in turn is just an instantiation of [KW15]. We also slightly modify the construction to turn it into an argument of knowledge transfer for the sum language, which we will use in later constructions.</p>

    <p class="text-gray-300">Let  <span class="math">gk</span>  be a bilinear group of order  <span class="math">p</span>  and  <span class="math">\\mathcal{M}, \\mathcal{N}, \\mathcal{P}, \\mathcal{Q}</span>  be matrix distributions outputting matrices  <span class="math">[\\mathbf{M}]_1 \\in \\mathbb{G}_1^{\\ell_1 \\times n}</span> ,  <span class="math">[\\mathbf{N}]_2 \\in \\mathbb{G}_2^{\\ell_2 \\times n}[\\mathbf{P}]_1 \\in \\mathbb{G}_1^{\\ell_3 \\times n}[\\mathbf{Q}]_2 \\in \\mathbb{G}_2^{\\ell_4 \\times n}</span>  respectively. In Fig. 1, we present two arguments of knowledge transfer for (1) the linear membership language</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathrm{lin}}^{\\mathrm{yes}} = \\{([c_1]_1,[c_2]_2,[d_1]_1,[d_2]_2)\\mid \\exists w\\text{s.t} (\\binom{c_1}{c_2}) = (\\binom{\\mathbf{M}}{\\mathbf{N}}w\\text{and} (\\binom{d_1}{d_2}) = (\\binom{\\mathbf{P}}{\\mathbf{Q}}w)</span> <span class="math">\\mathcal{L}_{\\mathrm{lin}}^{\\mathrm{no}} = \\{([c_1]_1,[c_2]_2,[d_1]_1,[d_2]_2,w)\\mid (\\binom{c_1}{c_2}) = (\\binom{\\mathbf{M}}{\\mathbf{N}}w\\text{and} (\\binom{d_1}{d_2})\\neq (\\binom{\\mathbf{P}}{\\mathbf{Q}}w),</span></p>

    <p class="text-gray-300">and (2) the sum knowledge transfer language</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathrm{sum}}^{\\mathrm{yes}} = \\{([c_1]_1,[c_2]_2,[d_1]_1,[d_2]_2)\\mid \\exists w\\text{s.t} c_1 + c_2 = (\\mathbf{M} + \\mathbf{N})w\\text{and} \\binom{d_1}{d_2} = \\binom{\\mathbf{P}}{\\mathbf{Q}}w\\}</span> <span class="math">\\mathcal{L}_{\\mathrm{sum}}^{\\mathrm{no}} = \\{([c_1]_1,[c_2]_2,[d_1]_1,[d_2]_2,w)\\mid c_1 + c_2 = (\\mathbf{M} + \\mathbf{N})w\\text{and}\\binom {d_1}{d_2}\\neq \\binom {\\mathbf{P}}{\\mathbf{Q}}w\\} .</span></p>

    <p class="text-gray-300">A knowledge transfer argument is just an argument for the promise problem defined by  <span class="math">\\mathcal{L}^{\\mathrm{yes}}</span>  and  <span class="math">\\mathcal{L}^{\\mathrm{no}}</span> . Completeness means that an honest proof is accepting for any statement in  <span class="math">\\mathcal{L}^{\\mathrm{yes}}</span> . Soundness that any proof for a statement in  <span class="math">\\mathcal{L}^{\\mathrm{no}}</span> , which comes with an "advice"  <span class="math">w</span> , is accepting only with negligible probability.</p>

    <p class="text-gray-300">We use this construction with (1)  <span class="math">\\mathbf{Q} = \\mathbf{0}</span>  for the case of linear knowledge transfer and (2)  <span class="math">\\mathbf{N} = \\mathbf{0}</span>  for the case of sum knowledge transfer so we prove only these two cases. We stress out that the proofs are easily extended to accommodate for the more general cases. We also strengthen the security requirements by allowing the adversary to get some extra information</p>

    <p class="text-gray-300">about the language parameters through some (possibly probabilistic) function <span class="math">h</span>. We call this property <span class="math">h</span>-strong soundness.</p>

    <p class="text-gray-300">For the case of <span class="math">\\Pi_{\\mathrm{ld-lin}}</span>, when setting <span class="math">\\mathbf{Q}=\\mathbf{0}</span>, the security is shown in <em>[x13]</em>. The only modification is that we allow the adversary <span class="math">\\mathcal{A}</span> to get the discrete logarithms <span class="math">\\mathbf{N},\\mathbf{P}</span> and the <span class="math">h</span> information of the <span class="math">\\mathsf{MDDH}</span> challenge, which does not affect the result of <em>[x13]</em>. We extend the results of <em>[x13]</em> to the sum argument. The security proof is essentially identical to the one for the bilateral case of <em>[x13]</em>. For completeness we give the full proof in Appendix A.</p>

    <h2 id="sec-41" class="text-2xl font-bold">4 No-Signaling Somewhere Statistically Binding Commitments</h2>

    <p class="text-gray-300">In this section we recall Somewhere Statistically Binding (SSB) commitments and then define two additional notions for SSB commitments: no-signaling extraction and oblivious key generation. The former is a natural adaptation of the definitions of no-signaling extractors from previous works <em>[x23, x15]</em>. We show that the latter implies the former, and we give an efficient instantiation based on any <span class="math">\\mathcal{D}_{k}</span>-<span class="math">\\mathsf{MDDH}</span> assumption. Finally, we consider the kronecker product of two of these commitments.</p>

    <p class="text-gray-300">We now define somewhere Statistically Binding (SSB) commitment schemes <em>[x12, x11]</em>. An SSB commitment scheme, as the name suggests, is statistically binding only w.r.t. some variables which are determined during key generation. The commitment key computationally hides any information about this set, meaning that for all “modes” the commitment keys are computationally indistinguishable. Furthermore, the <span class="math">\\mathsf{KeyGen}</span> outputs a trapdoor which allows to extract (a function of) the values in this set.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It will be useful to consider SSB commitments where committed vectors live in <span class="math">\\mathcal{M}^{n_{1}n_{2}}</span> and can be indexed by <span class="math">i_{1}\\in[n_{1}],i_{2}\\in[n_{2}]</span>. We consider also 2 locality parameters <span class="math">\\bm{K}=(K_{1},K_{2})</span> with <span class="math">\\bm{K}_{i}\\leq n_{i}</span>, and extraction sets are of the form <span class="math">\\bm{S}=(S_{1},S_{2})</span> where <span class="math">S_{i}\\subseteq[n_{i}]</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K_{i}<span class="math">, for </span>i\\in\\{1,2\\}<span class="math">. We put forward a stronger variant of the index set hiding property, where the distinguisher is also given </span>h(sk)<span class="math"> for some function </span>h<span class="math">. In this case we will say the SSB commitment is </span>h$-strong ISH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">Let <span class="math">[\\cdot]:\\mathcal{M}\\to G</span> be a function, where <span class="math">\\mathcal{M}</span> is the message space and <span class="math">G</span> some set. Syntactically, a Somewhere Statistically Binding Commitment Scheme <span class="math">\\mathsf{CS}</span> is a tuple of algorithms <span class="math">\\mathsf{CS}=(\\mathsf{KeyGen},\\mathsf{Com},\\mathsf{Extract})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">(ck,sk)\\leftarrow\\mathsf{KeyGen}(gk,\\bm{n},\\bm{K},\\bm{S})</span>: <span class="math">\\mathsf{KeyGen}</span> takes as input the parameters <span class="math">gk</span>, <span class="math">\\bm{n}\\in\\mathbb{N}^{t}</span>, locality parameters <span class="math">\\bm{K}\\in[\\bm{n}]</span> and the sets $\\bm{S}\\subseteq[\\bm{n}],</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\bm{K}<span class="math">. It outputs a commitment key </span>ck<span class="math">, which may also contain some auxiliary information </span>\\mathsf{aux}<span class="math">, a secret key </span>sk<span class="math">, containing a trapdoor </span>\\tau<span class="math"> and possibly the random coins used by </span>\\mathsf{KeyGen}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c\\leftarrow\\mathsf{Com}(ck,\\bm{x})</span>: <span class="math">\\mathsf{Com}</span> takes as input the commitment key <span class="math">ck</span> and a vector <span class="math">\\bm{x}\\in\\mathcal{M}^{n_{1}\\cdot n_{2}}</span> and outputs a commitment <span class="math">c</span>,</li>

      <li><span class="math">\\bm{y}\\leftarrow\\mathsf{Extract}(\\tau,c)</span>: <span class="math">\\mathsf{Extract}</span> takes as input the trapdoor <span class="math">\\tau</span> and a commitment <span class="math">c</span>, and outputs the value <span class="math">\\bm{y}\\in G</span> allegedly equaling <span class="math">[\\bm{x}_{S}]</span>, where <span class="math">\\bm{x}</span> is a valid opening for <span class="math">c</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For all <span class="math">\\kappa\\in\\mathbb{N},\\bm{n}\\in\\mathbb{N}^{2},\\bm{K}\\in[\\bm{n}],\\bm{S}_{0},\\bm{S}_{1}\\subseteq[\\bm{n}]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{S}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{S}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\bm{K}<span class="math">, </span>\\mathsf{CS}$ must satisfy the following properties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h</span>-Strong Index Set Hiding: for all PPT <span class="math">\\mathcal{D}</span></li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr_{gk\\leftarrow\\mathcal{G}(1^{\\kappa})}\\left[\\begin{array}[]{c}\\mathcal{D}(ck,h(sk))=b\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ck,sk\\end{array}\\right.\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}b\\leftarrow\\{0,1\\}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(ck,sk)\\leftarrow\\mathsf{KeyGen}(gk,\\bm{n},\\bm{K},\\bm{S}_{b})\\end{array}\\right.\\right]\\leq\\frac{1}{2}+\\mathsf{negl}(\\kappa). \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere Statistically Binding: for all all, even unbounded  <span class="math">\\mathcal{A}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c c} \\operatorname {C o m} (c k, \\boldsymbol {x}) = \\operatorname {C o m} (c k, \\boldsymbol {x} ^ {\\prime}) &amp;amp; (c k, s k) \\leftarrow \\operatorname {K e y G e n} (g k, \\boldsymbol {n}, \\boldsymbol {K}, \\boldsymbol {S}); \\\\ \\text {a n d} \\boldsymbol {x} _ {S} \\neq \\boldsymbol {x} _ {S} ^ {\\prime} &amp;amp; (\\boldsymbol {x}, \\boldsymbol {x} ^ {\\prime}) \\leftarrow \\mathcal {A} (c k); \\end{array} \\right] \\leq \\operatorname {n e g l} (\\kappa).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G</span> -Extractability: for all, even unbounded  <span class="math">\\mathcal{A}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c c} \\exists x \\text {s . t .} c = \\operatorname {C o m} (c k, x) &amp;amp; (c k, s k) \\leftarrow \\operatorname {K e y G e n} (g k, n, K, S); c \\leftarrow \\mathcal {A} (c k); \\\\ \\text {a n d} y \\neq [ x _ {S} ] &amp;amp; y \\leftarrow \\operatorname {E x t r a c t} (\\tau , c), \\text {w h e r e} s k = (\\tau , r); \\end{array} \\right] \\leq \\operatorname {n e g l} (\\kappa)</span></div>

    <p class="text-gray-300">Note that an SSB commitment is also "everywhere" computationally binding. This is the case since a breach in binding, namely the ability to produce  <span class="math">c</span>  that opens to both  <span class="math">x \\neq x&#x27;</span> , implies the ability to distinguish where the commitment is not statistically binding contradicting the index set hiding property.</p>

    <p class="text-gray-300">We next present an extra property for an SSB commitment scheme which we call  <span class="math">h</span> -strong no-signaling extraction and is a natural adaptation of the definitions in [PR17; KPY19].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 3. We say the extractor of an SSB commitment scheme  <span class="math">\\mathsf{CS} = (\\mathsf{Setup},\\mathsf{KeyGen},\\mathsf{Com},</span>  Extract) with commitment space  <span class="math">C^{13}</span>  is  <span class="math">h</span>  -strong no-signaling if for any  <span class="math">S^{\\prime}\\subseteq S\\subseteq [n]</span> , where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math"> , and any PPT adversary  </span>\\mathcal{D} = (\\mathcal{D}_1,\\mathcal{D}_2)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} _ {2} \\left(c k _ {S ^ {\\prime}}, h \\left(s k _ {S ^ {\\prime}}\\right)\\right), c, \\boldsymbol {y} ^ {\\prime}\\right) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\left(c k _ {S ^ {\\prime}}, s k _ {S ^ {\\prime}}\\right) \\leftarrow \\operatorname {K e y G e n} (g k, \\boldsymbol {n}, \\boldsymbol {K}, \\boldsymbol {S} ^ {\\prime}) \\\\ c \\leftarrow \\mathcal {D} _ {1} \\left(c k _ {S ^ {\\prime}}, h \\left(s k _ {S ^ {\\prime}}\\right)\\right); \\text {i f} c \\notin C: c \\leftarrow \\bot \\\\ \\boldsymbol {y} ^ {\\prime} \\leftarrow \\operatorname {E x t r a c t} (\\tau , c), \\text {w h e r e} s k _ {S ^ {\\prime}} = (\\tau , r). \\end{array} \\right. \\right. \\right. \\\\ \\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} _ {2} (c k _ {S}, h (s k _ {S})), c, \\boldsymbol {y} _ {S ^ {\\prime}}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (c k _ {S}, s k _ {S}) \\leftarrow \\operatorname {K e y G e n} (g k, \\boldsymbol {n}, \\boldsymbol {K}, \\boldsymbol {S}) \\\\ c \\leftarrow \\mathcal {D} _ {1} (c k _ {S}, h (s k _ {S})); \\text {i f} c \\notin C: c \\leftarrow \\bot \\\\ \\boldsymbol {y} \\leftarrow \\operatorname {E x t r a c t} (\\tau , c), \\text {w h e r e} s k = (\\tau , r). \\end{array} \\right. \\right] \\leq \\operatorname {n e g l} (\\kappa). \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We define also oblivious trapdoor generation. This property states that there exists an oblivious key generation algorithm, that takes a commitment key  <span class="math">ck</span>  that allows extraction in  <span class="math">S</span>  and a set  <span class="math">S&#x27; \\subseteq S</span> , and can produce a fresh commitment key  <span class="math">ck&#x27;</span>  and a trapdoor to extract  <span class="math">S&#x27;</span> . The distribution of the new key  <span class="math">ck&#x27;</span>  is statistically close to that of  <span class="math">ck</span>  and - importantly - the oblivious key generation algorithm does not get as input the original extraction set  <span class="math">S</span> . In other words, given a commitment key  <span class="math">ck</span>  that we know allows extraction for some superset of  <span class="math">S</span> , we can create a new key with a trapdoor for  <span class="math">S&#x27;</span>  without skewing the distribution of  <span class="math">ck</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 4. An SSB commitment scheme has oblivious trapdoor generation if there exists a PPT algorithm OblKeyGen such that for all  <span class="math">\\kappa \\in \\mathbb{N}, n \\in \\mathbb{N}^2, K \\in [n], S \\subseteq [n]</span> , with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math"> , and any  </span>S'<span class="math">  such that  </span>S' \\subseteq S<span class="math"> , and for all, even unbounded  </span>\\mathcal{D} = (\\mathcal{D}_1, \\mathcal{D}_2)$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} _ {2} \\left(c k ^ {\\prime}, c, \\boldsymbol {y} ^ {\\prime}\\right) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (c k, s k) \\leftarrow \\operatorname {K e y G e n} (g k, \\boldsymbol {n}, \\boldsymbol {K}, \\boldsymbol {S}); \\\\ (c k ^ {\\prime}, \\tau^ {\\prime}) \\leftarrow \\operatorname {O b l K e y G e n} (g k, \\boldsymbol {n}, \\boldsymbol {K}, \\boldsymbol {S} ^ {\\prime}, c k); \\\\ c \\leftarrow \\mathcal {D} _ {1} \\left(c k ^ {\\prime}\\right); \\boldsymbol {y} ^ {\\prime} \\leftarrow \\operatorname {E x t r a c t} (\\tau^ {\\prime}, c), \\text {w h e r e} s k = (\\tau , r) \\end{array} \\right. \\right. \\right. \\right. \\\\ \\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} _ {2} (c k, c, \\boldsymbol {y} _ {S ^ {\\prime}}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (c k, s k) \\leftarrow \\operatorname {K e y G e n} (g k, \\boldsymbol {n}, \\boldsymbol {K}, \\boldsymbol {S}); \\\\ c \\leftarrow \\mathcal {D} _ {1} (c k); \\boldsymbol {y} \\leftarrow \\operatorname {E x t r a c t} (\\tau , c), \\text {w h e r e} s k = (\\tau , r) \\end{array} \\right. \\right] \\right] \\leq \\operatorname {n e g l} (\\kappa) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Next, we show that an SSB commitment scheme with oblivious trapdoor generation is also no-signaling. We leave as an open problem to prove or disprove the opposite implication.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{CS}=(\\mathsf{Setup},\\mathsf{KeyGen},\\mathsf{OblKeyGen},\\mathsf{Com},\\mathsf{Extract})</span> be an SSB commitment scheme with oblivious trapdoor generation and <span class="math">h</span>-strong ISH. Then, <span class="math">\\mathsf{CS}</span> is also <span class="math">h</span>-strong no-signaling.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix any <span class="math">\\bm{S}^{\\prime}\\subseteq\\bm{S}\\subseteq[\\bm{n}]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\bm{K}<span class="math">, and let </span>\\mathcal{D}=(\\mathcal{D}_{1},\\mathcal{D}_{2})$ be a distinguisher against no signaling extraction for these values. We show by a sequence of games that its success probability is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Game}^{\\mathcal{D}}_{0}(1^{\\kappa})</span>: In this game, we execute <span class="math">(ck,sk)\\leftarrow\\mathsf{KeyGen}(gk,\\bm{n},\\bm{K},\\bm{S})</span>. We then get <span class="math">c\\leftarrow\\mathcal{D}_{1}(ck,h_{ns}(\\mathsf{sk}))</span>, change it to <span class="math">\\bot</span> if <span class="math">c\\notin\\mathcal{C}</span>, and compute <span class="math">\\bm{y}\\leftarrow\\mathsf{Extract}(\\tau,c)</span> for <span class="math">sk=(\\tau,r)</span>. The output is <span class="math">\\mathcal{D}_{2}(ck,c,\\bm{y}_{\\bm{S}^{\\prime}})</span>.</li>

      <li><span class="math">\\mathsf{Game}^{\\mathcal{D}}_{1}(1^{\\kappa})</span>: In this game, we execute <span class="math">(ck,sk)\\leftarrow\\mathsf{KeyGen}(gk,\\bm{n},\\bm{K},\\bm{S})</span> and <span class="math">(ck_{\\mathsf{obl}},\\tau_{\\mathsf{obl}})\\leftarrow\\mathsf{OblKeyGen}(gk,\\bm{n},\\bm{K},\\bm{S}^{\\prime},ck)</span>. We then compute <span class="math">h(sk_{\\mathsf{obl}})</span> corresponding to <span class="math">ck_{\\mathsf{obl}}</span> and get <span class="math">c\\leftarrow\\mathcal{D}_{1}(ck_{\\mathsf{obl}},h(sk_{\\mathsf{obl}}))</span>, change it to <span class="math">\\bot</span> if <span class="math">c\\notin\\mathcal{C}</span>, and compute <span class="math">\\bm{y}^{\\prime}\\leftarrow\\mathsf{Extract}(\\tau_{\\mathsf{obl}},c)</span>. The output is <span class="math">\\mathcal{D}_{2}(ck_{\\mathsf{obl}},c,\\bm{y}^{\\prime})</span>.</li>

      <li><span class="math">\\mathsf{Game}^{\\mathcal{D}}_{2}(1^{\\kappa})</span>: In this game, we execute <span class="math">(ck,sk)\\leftarrow\\mathsf{KeyGen}(gk,\\bm{n},\\bm{K},\\bm{S}^{\\prime})</span> and <span class="math">(ck_{\\mathsf{obl}},\\tau_{\\mathsf{obl}})\\leftarrow\\mathsf{OblKeyGen}(gk,\\bm{n},\\bm{K},\\bm{S}^{\\prime},ck)</span>. We then compute <span class="math">h(sk_{\\mathsf{obl}})</span> corresponding to <span class="math">ck_{\\mathsf{obl}}</span> and get <span class="math">c\\leftarrow\\mathcal{D}_{1}(ck_{\\mathsf{obl}},h(sk_{\\mathsf{obl}}))</span>, change it to <span class="math">\\bot</span> if <span class="math">c\\notin\\mathcal{C}</span>, and compute <span class="math">\\bm{y}^{\\prime}\\leftarrow\\mathsf{Extract}(\\tau_{\\mathsf{obl}},c)</span>. The output is <span class="math">\\mathcal{D}_{2}(ck_{\\mathsf{obl}},c,\\bm{y}^{\\prime})</span>.</li>

      <li><span class="math">\\mathsf{Game}^{\\mathcal{D}}_{3}(1^{\\kappa})</span>: In this game, we execute <span class="math">(ck^{\\prime},sk^{\\prime})\\leftarrow\\mathsf{KeyGen}(gk,\\bm{n},\\bm{K},\\bm{S}^{\\prime})</span>. We then get <span class="math">c\\leftarrow\\mathcal{D}_{1}(ck^{\\prime},h_{ns}(sk^{\\prime}))</span>, change it to <span class="math">\\bot</span> if <span class="math">c\\notin\\mathcal{C}</span>, and compute <span class="math">\\bm{y}\\leftarrow\\mathsf{Extract}(\\tau^{\\prime},c)</span> for <span class="math">sk=(\\tau,r)</span>. The output is <span class="math">\\mathcal{D}_{2}(ck,c,\\bm{y}^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">Now we show the output of games <span class="math">i</span> and <span class="math">i+1</span> is indistinguishable for <span class="math">i=0</span> to <span class="math">2</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Cases <span class="math">i=0</span>, <span class="math">i=2</span>.</em> For <span class="math">i=0</span>, the two games are distributed identically to the two cases of the oblivious trapdoor generation definition for <span class="math">\\bm{S}^{\\prime}\\subseteq\\bm{S}</span>. Thus, the outputs of the games are statistically close. For <span class="math">i=2</span>, the same argument holds for <span class="math">\\bm{S}=\\bm{S}^{\\prime}</span>. Note that in both cases, the oblivious trapdoor generation distinguisher is unbounded so it can compute <span class="math">sk_{\\mathsf{obl}}</span>.</li>

      <li><em>Case <span class="math">i=1</span>.</em> The difference in the two games is how we sample the <span class="math">(ck,sk)</span> pair, either programmed to extract <span class="math">\\bm{S}</span> or <span class="math">\\bm{S}^{\\prime}</span>. By the <span class="math">h</span>-index set hiding property the outputs of the two games are computationally indistinguishable.</li>

    </ul>

    <p class="text-gray-300">Finally, noting that <span class="math">\\mathsf{Game}^{\\mathcal{D}}_{0}</span>, <span class="math">\\mathsf{Game}^{\\mathcal{D}}_{3}</span> correspond to the two cases of no signaling extraction, the result follows.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">4.1 Algebraic SSB Commitments.</h3>

    <p class="text-gray-300">In this section, we define algebraic SSB commitments following the definition of algebraic commitment schemes of <em>[x20]</em> and extend them to what we call <em>split</em> algebraic SSB commitments.</p>

    <p class="text-gray-300">Informally, an algebraic SSB commitment scheme is a commitment scheme where the commitment key is a matrix <span class="math">[\\mathbf{G}]</span> of group elements such that (1) committing to a vector <span class="math">\\bm{x}</span> is done by multiplying on the left with <span class="math">[\\mathbf{G}]</span>, that is <span class="math">[\\bm{c}]=[\\mathbf{G}]\\bm{x}</span> and (2) the trapdoor is a matrix of field elements <span class="math">\\mathbf{T}</span> and local extraction is done by multiplying the commitment on the left with <span class="math">\\mathbf{T}^{\\top}</span>, that is <span class="math">[\\bm{x}_{S}]=\\mathbf{T}^{\\top}[\\bm{c}]</span>. We also allow the commitment key to output some public auxiliary information which is not used in committing nor extraction.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An SSB commitment scheme <span class="math">\\mathsf{CS}=(\\mathsf{KeyGen},\\mathsf{Com},\\mathsf{Extract})</span> is <em>algebraic</em> if, given <span class="math">gk\\leftarrow\\mathcal{G}(1^{\\kappa})</span>, <span class="math">\\mathsf{KeyGen}(gk,n,\\bm{K},\\bm{S})</span> outputs <span class="math">ck=[\\mathbf{G}]\\in\\mathbb{G}^{\\overline{\\bm{K}}\\times n}</span> and $sk=(\\mathbf{T}\\in\\mathbb{Z}_{p}^{\\overline{\\bm{K}}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\mathbf{G})<span class="math"> where </span>\\overline{\\bm{K}}\\geq\\bm{K}<span class="math">, </span>\\mathsf{Com}([\\mathbf{G}],\\bm{x})=[\\mathbf{G}]\\bm{x}<span class="math"> and </span>\\mathbf{T}^{\\top}\\mathbf{G}=\\bm{\\Sigma}_{S}\\mathbf{P}_{S}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also define a subtype of algebraic commitments which are specific to asymmetric groups, where the commitment key is “split” between the two groups.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An SSB commitment scheme <span class="math">\\mathsf{CS}=(\\mathsf{KeyGen},\\mathsf{Com},\\mathsf{Extract})</span> is <em>split algebraic</em> if <span class="math">\\mathsf{KeyGen}(gk,n,\\bm{K},\\bm{S})</span> outputs <span class="math">ck=([\\mathbf{G}]_{1}\\in\\mathbb{G}_{1}^{\\overline{\\bm{K}}\\times n},[\\mathbf{H}]_{2}\\in\\mathbb{G}_{2}^{\\overline{\\bm{K}}\\times n})</span> and $sk=(\\mathbf{T}\\in\\mathbb{Z}_{p}^{\\overline{\\bm{K}}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(\\mathbf{G},\\mathbf{H}))<span class="math">, for </span>\\overline{\\bm{K}}\\geq\\bm{K}<span class="math">, </span>\\mathsf{Com}([\\mathbf{G}]_{1},[\\mathbf{H}]_{2},\\bm{x})=([\\mathbf{G}]_{1}\\bm{x},[\\mathbf{H}]_{2}\\bm{x})<span class="math"> and </span>\\mathbf{T}^{\\top}\\mathbf{G}+\\mathbf{T}^{\\top}\\mathbf{H}=\\bm{\\Sigma}_{S}\\mathbf{P}_{S}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">All SSB commitment schemes in this work are algebraic or split-algebraic. Note that all (split-)SSB commitments only differ on the key generation algorithm. For that reason we sometimes refer to a commitment key distribution as the commitment scheme itself.</p>

    <p class="text-gray-300">In the case of non-split algebraic SSB commitments, we can <span class="math">\\mathbb{G}</span>-extract by computing</p>

    <p class="text-gray-300"><span class="math">\\mathbf{T}^{\\top}[\\bm{c}]=\\mathbf{T}^{\\top}[\\mathbf{G}\\bm{x}]=[\\bm{\\Sigma}_{S}\\mathbf{P}_{S}\\bm{x}]=[\\bm{x}_{S}],</span></p>

    <p class="text-gray-300">while in the case of split-algebraic commitments, we can only <span class="math">\\mathbb{G}_{T}</span> extract. That is, we can compute values <span class="math">[\\bm{u}_{S}]_{1},[\\bm{v}_{S}]_{2}</span> such that <span class="math">e([\\bm{u}_{S}]_{1},[1]_{2})+e([1]_{1},[\\bm{v}_{S}]_{2})=[\\bm{x}_{S}]_{T}</span>. Indeed, if <span class="math">[\\bm{c}]_{1}=[\\mathbf{G}]_{1}\\bm{x}</span> and <span class="math">[\\bm{d}]_{2}=[\\mathbf{H}]_{2}\\bm{x}</span> then we can compute <span class="math">[\\bm{u}_{S}]_{1}=\\mathbf{T}[\\bm{c}]_{1}</span> and <span class="math">[\\bm{v}_{S}]_{2}=\\mathbf{T}[\\bm{d}]_{2}</span> and it holds that</p>

    <p class="text-gray-300"><span class="math">\\bm{u}_{S}+\\bm{v}_{S}=\\mathbf{T}^{\\top}\\bm{c}+\\mathbf{T}^{\\top}\\bm{d}=\\mathbf{T}^{\\top}\\mathbf{G}\\bm{x}+\\mathbf{T}^{\\top}\\mathbf{H}\\bm{x}=(\\mathbf{T}^{\\top}\\mathbf{G}+\\mathbf{T}^{\\top}\\mathbf{H})\\bm{x}=\\bm{\\Sigma}_{S}\\mathbf{P}_{S}\\bm{x}=\\bm{x}_{S}.</span></p>

    <p class="text-gray-300">Note that by definition, if the commitment key generation does not fail, the commitments are perfectly binding/extractable at <span class="math">S</span>. This will be the case for commitment schemes with perfect completeness. We will utilize this fact in our constructions to simplify some of the arguments.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">4.2 Somewhere Statistically Binding Commitments with Oblivious Trapdoor Generation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We present in Fig. 2 a simple construction of an SSB with Oblivious Key Generation from plain SSB commitments with locality parameter 1. The setup algorithm instantiates <span class="math">K</span> different commitment keys and, given a set <span class="math">S</span>, each of the first $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> commitment keys is extractable in a different position </span>s\\in S<span class="math">. The last </span>K-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are binding for the empty set. To commit to a value </span>\\bm{x}<span class="math">, one gives </span>K$ commitments to this value with each of the commitment keys. To verify an opening, one verifies each individual opening and that all the openings are the same.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the ordering of the elements in <span class="math">S</span> is arbitrary and, in some sense, there’s no unique key generation algorithm for a set <span class="math">S</span>. Indeed, it is only necessary that the commitment key contains <span class="math">K</span> commitment keys for locality 1 such that $ck_{i_{1}},\\ldots,ck_{i_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math"> are binding at </span>s_{1},\\ldots,s_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> respectively. Note that there are </span>\\binom{K}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> different choices of </span>i_{1},\\ldots,i_{n}<span class="math">. For this reason, if the input of the oblivious generator is just </span>S^{\\prime}<span class="math">, it is impossible to know which commitment keys are the ones corresponding to </span>S^{\\prime}<span class="math">. To alleviate this, the oblivious key generator receives as advice the indices where </span>S^{\\prime}<span class="math"> “appears” in </span>S<span class="math"> that is, </span>i_{1},\\ldots,i_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> such that </span>s_{i_{1}}=s^{\\prime}_{1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this case we need to change a little the proof that oblivious trapdoor generation implies no-signaling. We add a game <span class="math">\\mathsf{Game}^{\\mathcal{D}}_{1/2}(1^{\\kappa})</span>, between games 0 and 1, which is identical to <span class="math">\\mathsf{Game}^{\\mathcal{D}}_{0}(1^{\\kappa})</span> but <span class="math">\\mathcal{E}_{1}</span> samples <span class="math">ck_{i}</span> binding at <span class="math">\\{s_{i}\\}</span> if <span class="math">s_{i}\\in S^{\\prime}</span> and at <span class="math">\\emptyset</span> if not. By the index-set hiding property of <span class="math">ck_{1},\\ldots,ck_{K}</span> the output of both games is indistinguishable. <span class="math">\\mathsf{Game}^{\\mathcal{D}}_{1}(1^{\\kappa})</span> is as before but the oblivious key generator receives also the advise. The rest of the proof is exactly as before</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Oblivious SSB commitment scheme from  <span class="math">K</span>  SSB commitments with locality parameter 1.</p>

    <p class="text-gray-300">Theorem 3. Let CS be an SSB commitment with locality parameter  <span class="math">K = 1</span> . Then construction CS' of Fig. 2 is an SSB commitment with Oblivious Trapdoor Generation.</p>

    <p class="text-gray-300">Proof. First, we show that  <span class="math">\\mathsf{CS}&#x27;</span>  is an SSB commitment. For index-hiding we can use a standard hybrid argument to show that the concatenation of  <span class="math">K</span>  commitment keys are indeed indistinguishable. Somewhere Statistical Binding and  <span class="math">G</span> -extractability of  <span class="math">\\mathsf{CS}&#x27;</span>  follow from the respective properties of CS. Indeed, for the former, note that each individual commitment is statistically binding in one coordinate, and for a commitment-opening to verify, all commitments are checked w.r.t. to the same opening; thus, effectively the commitment is statistically binding in the set S. For the latter, we use the same argument and the fact that the extractor of CS can  <span class="math">G</span> -extract each value independently.</p>

    <p class="text-gray-300">For oblivious trapdoor generation, note that the crs output by OblKeyGen follow exactly the same distribution as the one output by KeyGen as well as a valid trapdoor for  <span class="math">S&#x27;</span> .</p>

    <p class="text-gray-300">Next, we present a more efficient SSB commitment scheme with oblivious trapdoor generation. The scheme is parameterized by a group description  <span class="math">gk</span> , the message space is  <span class="math">\\mathbb{Z}_p^n</span>  and we extract  <span class="math">[x_S]_\\mu</span> . The construction is essentially the one given in [FLPS20], which in turn is a generalization of the so called Multi-Pedersen commitments from [GHR15b], with a minor change in the key generation algorithm.</p>

    <p class="text-gray-300">KeyGen  <span class="math">(g k,n,K,S)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let  <span class="math">\\mathbf{A} \\gets \\mathcal{D}_k</span> ,  $\\mathbf{B} \\gets \\mathbb{Z}_p^{K + k \\times K -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ,  </span>\\mathbf{W} \\gets \\mathbb{Z}_p^{K - 1 \\times k + 1}<span class="math">  and define  </span>\\mathbf{G}_0 = \\left( \\begin{array}{cc} \\mathbf{A} &amp; \\mathbf{A} \\\\ &amp; \\mathbf{W A} \\end{array} \\right)$ .</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Let  $\\mathbf{T}_S \\in \\mathbb{Z}_p^{K + k \\times</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}<span class="math">  s.t.  </span>\\mathbf{T}_S^\\top \\mathbf{G}_S = \\mathbf{I}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}<span class="math">  and  </span>\\mathbf{T}_S^\\top \\mathbf{G}_0 = \\mathbf{0}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">\\times K + k -</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}$ . Abort if such a matrix does not exist.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Let  $\\mathbf{G} = (\\mathbf{G}_S</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbf{G}_0\\Gamma)\\mathbf{P}_S<span class="math"> . Output  </span>(ck,sk) = ([\\mathbf{G}]_\\mu, (\\mathbf{T}_S,\\mathbf{G}))$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">OblKeyGen  <span class="math">(g k,n,K,S^{\\prime},ck = [\\mathbf{G}]_{\\mu})</span>  ..  <span class="math">IIS^{\\prime}\\subseteq S</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Sample  $\\mathbf{G}_1 \\gets \\mathbb{Z}_p^{K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ,  </span>\\mathbf{G}_2 \\gets \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ,  </span>\\mathbf{R} \\gets \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Denote by  <span class="math">[\\overline{\\mathbf{G}}_{\\overline{S}^{\\prime}}]_{\\mu}</span>  the matrix containing the first  $K + k -</td>

            <td class="px-3 py-2 border-b border-gray-700">S^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">  rows of  </span>[\\mathbf{G}_{\\overline{S}^{\\prime}}]_{\\mu}$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Output  <span class="math">ck_{\\mathrm{ob}} = [\\mathbf{G}^{<em>}]_{\\mu} = \\left( \\begin{array}{cc}[\\mathbf{G}_{1}]_{\\mu} &amp;amp; [\\overline{\\mathbf{G}}_{S^{\\prime}}]_{\\mu}\\\\ [\\mathbf{G}_{2}]_{\\mu} &amp;amp; \\mathbf{R}[\\overline{\\mathbf{G}}_{S^{\\prime}}]_{\\mu} \\end{array} \\right)\\mathbf{P}_{S^{\\prime}}</span>  and  <span class="math">\\tau_{\\mathrm{ob}} = \\mathbf{T}^{</em>} = \\left( \\begin{array}{c}\\mathbf{R}^{\\top}\\mathbf{T}\\\\ -\\mathbf{T} \\end{array} \\right)</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname{Com}(ck, x)</span> : Parse  <span class="math">ck = [\\mathbf{G}]_{\\mu}</span>  and output  <span class="math">[c]_{\\mu} = [\\mathbf{G}]_{\\mu}x</span> .</p>

    <p class="text-gray-300">Extract  <span class="math">(\\tau, [c]_{\\mu})</span> : Output  <span class="math">[x_S]_{\\mu} = \\mathbf{T}_S^\\top [c]_{\\mu}</span> .</p>

    <p class="text-gray-300">Figure 3: SSB commitment scheme with oblivious trapdoor generation parametrized by the matrix distribution  <span class="math">\\mathcal{D}_k</span> .</p>

    <p class="text-gray-300">For simplicity, we describe the oblivious key generation algorithm in terms of the permutation  <span class="math">\\mathbf{P}_S</span>  while it is not really needed. Indeed, it only needs to randomly sample itself the columns corresponding to  <span class="math">S&#x27;</span>  and sample the lower rows as a random combination of upper rows or columns in  <span class="math">\\overline{S}&#x27;</span> .</p>

    <p class="text-gray-300">In [FLPS20] it is shown that the Index Set Hiding property can be reduced to DDH with a security lost of  <span class="math">2\\log K</span>  when  <span class="math">\\mathbf{G}_0</span>  is uniform using the results of [Vil12]. In our case  <span class="math">\\mathbf{G}_0</span>  it is not completely uniform as some part depends on  <span class="math">\\mathcal{D}_k</span> . Although it seems still possible to use [Vil12], for simplicity we use a naive hybrid argument at the cost of a less tight reduction. Although the security lost is  <span class="math">2K</span>  instead of  <span class="math">2\\log K</span> , in general  <span class="math">K</span>  is small (constant in our instantiations) and hence it doesn't make much difference. We give a proof of the following theorem.</p>

    <p class="text-gray-300">Theorem 4. Construction CS of Fig. 3 is an SSB commitment scheme. It is somewhere statistically binding and  <span class="math">\\mathbb{G}</span> -Extractable with probability at least  <span class="math">1 - \\frac{K}{p}</span>  and Index Set Hiding with probability at least  <span class="math">1 - 2K \\cdot \\mathrm{Adv}_{\\mathrm{MDDH}} \\cdot \\mathcal{D}_k(\\mathcal{D})</span> , where  <span class="math">\\mathcal{D}</span>  is a PPT adversary against the  <span class="math">\\mathcal{D}_k</span> -MDDH assumption.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We first show that CS.KeyGen aborts only with probability  <span class="math">\\frac{K}{p}</span> . Let  <span class="math">\\mathbf{G}_0^\\perp</span>  be a matrix whose columns are a basis of the kernel of  <span class="math">\\mathbf{G}_0^\\top</span> . Since  <span class="math">\\mathbf{G}_0</span>  is uniformly distributed, by the Schwartz-Zippel lemma,  <span class="math">\\mathbf{G}_0</span>  has rank  $K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  with probability at least  </span>1 - \\frac{K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p}<span class="math"> . Now, consider the matrix  </span>\\mathbf{G}_S^\\top \\mathbf{G}_0^\\perp<span class="math"> . Again, by the Schwartz-Zippel lemma and the fact that  </span>\\mathbf{G}_S<span class="math">  is uniformly distributed, this matrix has rank  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  with probability at least  </span>1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p}<span class="math"> , and thus, it is invertible. Let  </span>\\mathbf{T}<span class="math">  be its inverse. This matrix exists except with probability  </span>\\frac{K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p} = \\frac{K + k}{p}<span class="math"> . Now, set  </span>\\mathbf{T}_S = \\mathbf{G}_0^\\perp \\mathbf{T}<span class="math"> . We have that  </span>\\mathbf{G}_S^\\top \\mathbf{T}_S = \\mathbf{G}_S^\\top \\mathbf{G}_0^\\perp \\mathbf{T}' = \\mathbf{I}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  and  </span>\\mathbf{G}_0^\\top \\mathbf{T}_S = \\mathbf{G}_0^\\top \\mathbf{G}_0^\\perp \\mathbf{T}' = \\mathbf{0}_{K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ , which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Index Set Hiding. Consider the following sequence of hybrid games.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Game <span class="math">_0^{\\mathcal{D}}</span> : In this game we sample  <span class="math">(ck, sk) \\gets \\text{KeyGen}(1^{\\lambda}, gk, n, K, S_0)</span>  and output  <span class="math">\\mathcal{D}(ck)</span> .</li>

      <li>Game <span class="math">_1^{\\mathcal{D}}</span> : In this game we sample  <span class="math">(ck, sk) \\gets \\text{KeyGen}(1^{\\lambda}, gk, n, K, \\emptyset)</span>  and output  <span class="math">\\mathcal{D}(ck)</span> .</li>

      <li>Game <span class="math">_2^{\\mathcal{D}}</span> : In this game we sample  <span class="math">(ck, sk) \\gets \\text{KeyGen}(1^{\\lambda}, gk, n, K, S_1)</span>  and output  <span class="math">\\mathcal{D}(ck)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Noting that in  <span class="math">\\mathsf{Game}_0</span>  and in  <span class="math">\\mathsf{Game}_1</span>  the difference in the distributions of  <span class="math">ck</span>  is that in the former  <span class="math">\\mathbf{G}_{S_0}</span>  is uniform, while in the later  <span class="math">\\mathbf{G}_{S_0} = \\mathbf{G}_0\\Gamma_{S_0}</span> , where  $\\Gamma_{S_0} \\in \\mathbb{Z}_p^{K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Using a standard hybrid argument, we can bound the advantage of distinguishing these games by  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math">  times the advantage of breaking the  </span>\\mathbf{G}_0<span class="math"> -MDDH assumption. It is not hard to see that the  </span>\\mathbf{G}_0<span class="math"> -MDDH can be reduced (without security lost) to the  </span>\\mathcal{D}_k<span class="math"> -MDDH assumption. We conclude that the advantage of distinguishing  </span>\\mathsf{Game}_0<span class="math">  and  </span>\\mathsf{Game}_1<span class="math">  can be bounded by  </span>K \\cdot \\mathsf{Adv}_{\\mathcal{D}_k\\text{-MDDH}}<span class="math"> . The same argument applies to  </span>\\mathsf{Game}_1<span class="math">  and in  </span>\\mathsf{Game}_2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Somewhere Statistically Binding. Finally we show the somewhere statistically binding and extractability property. Let  <span class="math">\\mathbf{G}_S, \\mathbf{G}_0, \\Gamma</span> , implicitly defined by  <span class="math">(ck, sk) \\gets \\mathsf{CS.KeyGen}(gk, n, K, S)</span> . Conditioned on CS.KeyGen not failing, which only happens with probability at most  <span class="math">1 - \\frac{K}{p}</span> , the matrix  $\\mathbf{T}_S \\in \\mathbb{Z}_p^{K + k \\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  satisfies  </span>\\mathbf{T}_S^\\top \\mathbf{G} = \\boldsymbol{\\Sigma}_S \\mathbf{P}_S$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now let  <span class="math">x, x&#x27; \\in \\mathbb{Z}^n</span> . For extractability, note that  <span class="math">\\mathbf{T}^\\top \\mathsf{CS.Com}([G]_\\mu, x) = \\mathbf{T}^\\top [G]_\\mu x = [\\Sigma_S \\mathbf{P}_S]_\\mu x = [x_S]_\\mu</span> . Additionally, if  <span class="math">\\mathsf{CS.com}([G]_\\mu, x) = \\mathsf{CS.com}([G]_\\mu, x&#x27;)</span>  and we multiply by  <span class="math">\\mathbf{T}^\\top</span>  on both sides, we get that  <span class="math">x_S = x_S&#x27;</span> .</p>

    <p class="text-gray-300">In the next Theorem we assume  <span class="math">\\mathcal{D}_k</span>  outputs full rank matrices with overwhelming probability. Note that this is true for most matrix distributions such as the uniform and the linear family.</p>

    <p class="text-gray-300">Theorem 5. Construction CS of Fig. 3 satisfies Oblivious Trapdoor Generation. Furthermore, for all even unbounded  <span class="math">\\mathcal{D} = (\\mathcal{D}_1,\\mathcal{D}_2)</span> , against oblivious trapdoor generation,  <span class="math">\\mathrm{Adv}_{\\mathrm{Oblv}}^{\\mathrm{CS}}(\\mathcal{D})\\leq \\frac{K}{p}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  <span class="math">K \\leq n</span>  and  <span class="math">S&#x27; \\subseteq S \\subseteq [n]</span> . We first show that the oblivious key follows exactly the same distribution as the original key. Let  <span class="math">ck := [\\mathbf{G}]_{\\mu}</span>  be the output of  <span class="math">\\text{KeyGen}(gk, n, K, S)</span>  and  <span class="math">ck_{\\text{ob}} = [\\mathbf{G}^*]_{\\mu}</span>  be the output of  <span class="math">\\text{OblKeyGen}(gk, n, K, S&#x27;, [\\mathbf{G}])</span> . We can write  <span class="math">ck</span>  as  $\\mathbf{G} = ((\\mathbf{G}_{S'}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}) \\mathbf{P}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_0 \\mathbf{T}) \\mathbf{P}_S$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  $\\overline{\\mathbf{G}}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} \\in \\mathbb{Z}_p^{K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times K -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ,  </span>\\underline{\\mathbf{G}}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times K -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ,  </span>\\overline{\\mathbf{G}}_0 \\in \\mathbb{Z}_p^{K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k}<span class="math"> ,  </span>\\underline{\\mathbf{G}}_0 \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k}<span class="math"> , such that  </span>\\mathbf{G}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} = \\begin{pmatrix} \\overline{\\mathbf{G}}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} \\\\ \\underline{\\mathbf{G}}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} \\end{pmatrix}<span class="math"> ,  </span>\\mathbf{G}_0 = \\begin{pmatrix} \\overline{\\mathbf{G}}_0 \\\\ \\underline{\\mathbf{G}}_0 \\end{pmatrix}<span class="math"> . We claim that there exists a matrix  </span>\\mathbf{R} \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times K + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , uniformly distributed, such that  </span>\\left(\\underline{\\mathbf{G}}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underline{\\mathbf{G}}_0\\right) = \\mathbf{R}\\left(\\overline{\\mathbf{G}}_{S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbf{G}}_0\\right)<span class="math">  as in the output of OblKeyGen. If this is the case, the distributions of  </span>ck<span class="math">  output by KeyGen and  </span>ck_{\\mathrm{ob}}$  output by OblKeyGen are identical, since we can write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathbf {G} = \\left( \\begin{array}{c c c} \\mathbf {G} _ {S ^ {\\prime}} &amp; \\left(\\left( \\begin{array}{c c} \\overline {{\\mathbf {G}}} _ {S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} &amp; \\overline {{\\mathbf {G}}} _ {0} \\\\ \\underline {{\\mathbf {G}}} _ {S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} &amp; \\underline {{\\mathbf {G}}} _ {0} \\end{array} \\right) &amp; \\left( \\begin{array}{c c} \\mathbf {I} &amp; \\mathbf {0} \\\\ \\mathbf {0} &amp; \\mathbf {I} \\end{array} \\right)\\right) \\mathbf {P} _ {S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}\\right) \\mathbf {P} _ {S} \\\\ = \\left( \\begin{array}{c c c} \\mathbf {G} _ {S ^ {\\prime}} &amp; \\left(\\left( \\begin{array}{c c} \\overline {{\\mathbf {G}}} _ {S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} &amp; \\overline {{\\mathbf {G}}} _ {0} \\\\ \\mathbf {R} \\left(\\overline {{\\mathbf {G}}} _ {S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S} &amp; \\overline {{\\mathbf {G}}} _ {0}\\right) \\end{array} \\right) &amp; \\left( \\begin{array}{c c} \\mathbf {I} &amp; \\mathbf {0} \\\\ \\mathbf {0} &amp; \\mathbf {I} \\end{array} \\right)\\right) \\mathbf {P} _ {S ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}\\right) \\mathbf {P} _ {S} \\end{array} \\right) \\\\ = \\left( \\begin{array}{c c} \\mathbf {G} _ {S ^ {\\prime}} &amp; \\frac {\\overline {{\\mathbf {G}}} _ {\\overline {{S}}}}{\\mathbf {R} \\overline {{\\mathbf {G}}} _ {\\overline {{S}}}} \\end{array} \\right) \\mathbf {P} _ {S}. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First we show that the matrix $(\\overline{\\mathbf{G}}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbf{G}}_{0})<span class="math"> is full rank with overwhelming probability. Indeed, </span>\\overline{\\mathbf{G}}_{0}=\\left(\\frac{\\mathbf{A}}{\\mathbf{W}\\mathbf{A}}\\right)<span class="math">, where </span>\\mathbf{A}\\leftarrow\\mathcal{D}_{k},\\overline{\\mathbf{W}}\\leftarrow\\mathbb{Z}_{p}^{K-1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k+1}<span class="math">, and it has rank </span>k<span class="math">. By the fact that </span>\\overline{\\mathbf{G}}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}<span class="math"> is uniform, using the Schwartz-Zippel lemma we get that </span>(\\overline{\\mathbf{G}}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbf{G}}_{0})<span class="math"> has rank </span>K+k-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> except with probability </span>\\frac{K-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p}<span class="math">. This means that the matrix is invertible and we can set </span>\\mathbf{R}=(\\underline{\\mathbf{G}}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underline{\\mathbf{G}}_{0})(\\overline{\\mathbf{G}}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{\\mathbf{G}}_{0})^{-1}<span class="math">. Furthermore, both </span>\\underline{\\mathbf{G}}_{S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S}<span class="math"> and </span>\\underline{\\mathbf{G}}_{0}=\\underline{\\mathbf{W}}\\mathbf{A}<span class="math"> are uniform, the latter since </span>\\underline{\\mathbf{W}}\\in\\mathbb{Z}_{p}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k+1}<span class="math"> is uniformly distributed and </span>\\mathbf{A}$ is full rank, and the former by construction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To conclude the proof, we to show that the trapdoor output by <span class="math">\\mathsf{OblKeyGen}(gk,n,K,S^{\\prime},[\\mathbf{G}])</span> is correct w.r.t <span class="math">ck_{\\mathsf{ob}}</span>, that is <span class="math">\\mathbf{T}^{<em>\\top}\\mathbf{G}^{</em>}=\\mathbf{\\Sigma}_{S^{\\prime}}</span>. By a simple calculation,</p>

    <p class="text-gray-300">\\[ \\mathbf{T}^{<em>\\top}\\mathbf{G}^{</em>}=\\begin{pmatrix}\\mathbf{T}^{\\top}\\mathbf{R}&-\\mathbf{T}\\end{pmatrix}\\begin{pmatrix}\\mathbf{G}_{1}&\\overline{\\mathbf{G}}_{S^{\\prime}}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}_{2}&\\mathbf{R}\\overline{\\mathbf{G}}_{S^{\\prime}}\\end{pmatrix}=\\begin{pmatrix}\\mathbf{T}^{\\top}(\\mathbf{R}\\mathbf{G}_{1}-\\mathbf{G}_{2})&\\mathbf{T}^{\\top}\\mathbf{R}\\overline{\\mathbf{G}}_{\\overline{S}^{*}}-\\mathbf{T}^{\\top}\\mathbf{R}\\overline{\\mathbf{G}}_{\\overline{S}^{\\prime}}\\end{pmatrix}=\\begin{pmatrix}\\mathbf{I}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}&\\mathbf{0}\\end{pmatrix}=\\mathbf{\\Sigma}_{S^{\\prime}} \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathbf{T}^{\\top}(\\mathbf{R}\\mathbf{G}_{1}-\\mathbf{G}_{2})=\\mathbf{I}_{S^{\\prime}}</span> by construction. ∎</p>

    <p class="text-gray-300">In the next sections we assume that <span class="math">\\mathsf{KeyGen}</span> and <span class="math">\\mathsf{OblKeyGen}</span> do not abort. This is w.l.o.g. since we can always re-sample values when an abort happens. Note that in this case, the keys of both <span class="math">\\mathsf{KeyGen}</span> and <span class="math">\\mathsf{OblKeyGen}</span> are “somewhere perfectly binding”.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">4.3 Kronecker Product of two SSB commitments</h3>

    <p class="text-gray-300">Let <span class="math">\\mathsf{CS}</span> be an algebraic commitment scheme and let <span class="math">[\\mathbf{G}]_{1}\\in\\mathbb{G}_{1}^{f_{1}\\times n_{1}}</span> and <span class="math">[\\mathbf{H}]_{2}\\in\\mathbb{G}_{2}^{f_{2}\\times n_{2}}</span> commitment keys. We note there’s the following key and input homomorphism</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CS.Com}([\\mathbf{G}]_{1},\\bm{x})\\otimes\\mathsf{CS.Com}([\\mathbf{H}]_{2},\\bm{y})=\\mathsf{CS.Com}([\\mathbf{G}\\otimes\\mathbf{H}]_{T},\\bm{x}\\otimes\\bm{y}),</span></p>

    <p class="text-gray-300">where <span class="math">\\otimes</span> is the Kronecker product and is naturally defined w.r.t. the pairing function when the operands are group elements. To get a structure preserving primitive, so that we can later efficiently show that committed values satisfy some relation, it is better to consider all keys defined over one of the base groups <em>[x1]</em>. However, as noted in <em>[x11]</em>, in asymmetric groups it is not clear whether <span class="math">[\\mathbf{G}\\otimes\\mathbf{H}]_{1}</span> (or <span class="math">[\\mathbf{G}\\otimes\\mathbf{H}]_{2}</span>) defines an SSB commitment. Indeed, if we use the ISH of <span class="math">\\mathsf{CS}_{2}</span> to prove that <span class="math">[\\mathbf{G}\\otimes\\mathbf{H}]_{1}</span> is ISH, it turns out that we only know <span class="math">[\\mathbf{H}]_{2}</span> in group <span class="math">\\mathbb{G}_{2}</span> and hence we can only compute <span class="math">\\mathbf{G}\\otimes[\\mathbf{H}]_{2}</span> which is trivially distinguishable from the original key. To overcome this problem, the authors in <em>[x11]</em> used the split key <span class="math">[\\mathbf{Q}_{1}]_{1}=[\\mathbf{G}\\otimes\\mathbf{H}+\\mathbf{Z}]_{1}\\in\\mathbb{G}_{1}^{f_{1}f_{2}\\times n_{1}n_{2}},[\\mathbf{Q}_{2}]_{2}=[-\\mathbf{Z}]\\in\\mathbb{G}_{2}^{f_{1}f_{2}\\times n_{1}n_{2}}</span> , for <span class="math">\\mathbf{Z}\\leftarrow\\mathbb{Z}_{p}^{f_{1}f_{2}\\times n_{1}n_{2}}</span>. In this case we can write the homomorphism as follows</p>

    <p class="text-gray-300">\\[ \\begin{split}&\\mathsf{CS.Com}([\\mathbf{G}]_{1},\\bm{x})\\otimes\\mathsf{CS.Com}([\\mathbf{H}]_{2},\\bm{y})=\\\\ &\\qquad\\qquad\\qquad e(\\mathsf{CS.Com}([\\mathbf{Q}_{1}]_{1},\\bm{x}\\otimes\\bm{y}),[1]_{2})+e([1]_{1},\\mathsf{CS.Com}([\\mathbf{Q}_{2}]_{2},\\bm{x}\\otimes\\bm{y}).\\end{split} \\] (4)</p>

    <p class="text-gray-300">If additionally <span class="math">\\mathsf{CS}</span> is an instance of the scheme defined in figure 3, the following theorem holds.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">n_{i}\\in\\mathbb{N},K_{i}\\leq n_{i},S_{i}\\subseteq[n_{i}]</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K_{i}<span class="math">, let </span>\\mathsf{CS}_{1}<span class="math"> and </span>\\mathsf{CS}_{2}<span class="math"> be two instances of the SSB commitment of figure 3 such that </span>(ck_{i},sk_{i})\\leftarrow\\mathsf{CS}_{i}.\\mathsf{KGen}(gk_{i},m_{i},K_{i},S_{i})<span class="math"> outputs a key over </span>\\mathbb{G}_{i}<span class="math">, where </span>i\\in\\{1,2\\}<span class="math">. Then the commitment scheme </span>\\mathsf{kCS}<span class="math">, where </span>\\mathsf{kCS}.\\mathsf{KGen}(gk,(n_{1},n_{2}),(K_{1},K_{2}),(S_{1},S_{2}))$ is defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{kCS}.\\mathsf{KGen}(gk,ck_{1},ck_{2},sk_{1},sk_{2})\\mathbin{:}\\hbox{</span>I<span class="math">}(ck_{i},sk_{i})\\leftarrow\\mathsf{CS}_{1}.\\mathsf{KGen}(gk,m_{i},K_{i},S_{i})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">sk_{1}</span> as <span class="math">(\\mathbf{G},\\mathbf{T}_{\\mathbf{G}})</span> and <span class="math">sk_{2}</span> as <span class="math">(\\mathbf{H},\\mathbf{T}_{\\mathbf{H}})</span>.</li>

      <li>Let <span class="math">\\mathbf{Q}_{1}=\\mathbf{G}\\otimes\\mathbf{H}+\\mathbf{Z}</span> and <span class="math">\\mathbf{Q}_{2}=-\\mathbf{Z}</span>, where <span class="math">\\mathbf{Z}\\leftarrow\\mathbb{Z}_{p}^{\\overline{K}_{1}\\overline{K}_{2}\\times n_{1}n_{2}}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{T_{Q}}=\\mathbf{T_{G}}\\otimes\\mathbf{T_{H}}</span> and <span class="math">\\mathsf{aux}=(ck_{1},ck_{2})</span>.</li>

      <li>output <span class="math">ck=([\\mathbf{Q}_{1}]_{1},[\\mathbf{Q}_{2}]_{2},\\mathsf{aux})</span> and <span class="math">sk=(\\mathbf{T_{Q}},\\mathbf{Q}_{1},\\mathbf{Q}_{2},\\mathbf{G},\\mathbf{H})</span>.</li>

    </ol>

    <p class="text-gray-300">is a split algebraic oblivious SSB commitment scheme.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Index Set Hiding. Let <span class="math">S_{1},S_{1}^{\\prime}\\subseteq[n_{1}],[S_{1}],[S_{1}^{\\prime}]\\leq K_{1}</span> and <span class="math">S_{2}</span>. The result follows from the indistinguishability of the following distributions (this is essentially part of the proof in <em>[x12, Theorem 6]</em>). For simplicity we write <span class="math">\\mathbf{X}\\leftarrow\\mathsf{CS.KGen}</span>, where <span class="math">\\mathbf{X}</span> is some part of <span class="math">(ck,sk)</span>, meaning that after running <span class="math">\\mathsf{KGen}</span> we discard everything but <span class="math">\\mathbf{X}</span>. Recall that <span class="math">\\mathsf{aux}=([\\mathbf{G}]_{1},[\\mathbf{H}]_{2})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{aux},[\\mathbf{G}\\otimes\\mathbf{H}+\\mathbf{Z}]_{1},[-\\mathbf{Z}]_{2},\\quad\\mathbf{G}\\leftarrow\\mathsf{CS.Setup}(gk,n_{1},K_{1},S_{1}),\\mathbf{H}\\leftarrow\\mathsf{CS.Setup}(gk,n_{2},K_{2},S_{2})</span>,</li>

      <li><span class="math">\\mathsf{aux},[\\mathbf{G}]_{1}\\otimes\\mathbf{H}+[\\mathbf{Z}]_{1},[-\\mathbf{Z}]_{2}</span>, <span class="math">\\mathbf{G}\\leftarrow\\mathsf{CS.Setup}(gk,n_{1},K_{1},S_{1})</span>, <span class="math">\\mathbf{H}\\leftarrow\\mathsf{CS.Setup}(gk,n_{2},K_{2},S_{2})</span>,</li>

      <li><span class="math">\\mathsf{aux},[\\mathbf{G}]_{1}\\otimes\\mathbf{H}+[\\mathbf{Z}]_{1},[-\\mathbf{Z}]_{2}</span>, <span class="math">\\mathbf{G}\\leftarrow\\mathsf{CS.Setup}(gk,n_{1},K_{1},S_{1}^{\\prime})</span>, <span class="math">\\mathbf{H}\\leftarrow\\mathsf{CS.Setup}(gk,n_{2},K_{2},S_{2})</span>,</li>

      <li><span class="math">\\mathsf{aux},[\\mathbf{Z}]_{1}</span>, <span class="math">\\mathbf{G}\\otimes[\\mathbf{H}]_{2}-[\\mathbf{Z}]_{2}</span>, <span class="math">\\mathbf{G}\\leftarrow\\mathsf{CS.Setup}(gk,n_{1},K_{1},S_{1}^{\\prime})</span>, <span class="math">\\mathbf{H}\\leftarrow\\mathsf{CS.Setup}(gk,n_{2},K_{2},S_{2})</span>,</li>

      <li><span class="math">\\mathsf{aux},[\\mathbf{Z}]_{1}</span>, <span class="math">\\mathbf{G}\\otimes[\\mathbf{H}]_{2}-[\\mathbf{Z}]_{2}</span>, <span class="math">\\mathbf{G}\\leftarrow\\mathsf{CS.Setup}(gk,n_{1},K_{1},S_{1}^{\\prime})</span>, <span class="math">\\mathbf{H}\\leftarrow\\mathsf{CS.Setup}(gk,n_{2},K_{2},S_{2}^{\\prime})</span>,</li>

      <li><span class="math">\\mathsf{aux},[\\mathbf{G}\\otimes\\mathbf{H}+\\mathbf{Z}]_{1},[-\\mathbf{Z}]_{2}</span>, <span class="math">\\mathbf{G}\\leftarrow\\mathsf{CS.Setup}(gk,n_{1},K_{1},S_{1}^{\\prime})</span>, <span class="math">\\mathbf{H}\\leftarrow\\mathsf{CS.Setup}(gk,n_{2},K_{2},S_{2}^{\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">Perfect indistinguishability between distributions 1-2, 3-4 and 5-6 follows from the fact that always both distributions are uniformly distributed conditioned on their sum being equal to <span class="math">\\mathbf{G}\\otimes\\mathbf{H}</span>. On the other hand, computational indistinguishability of distributions 2-3 and 4-5 follows from the <span class="math">\\mathsf{ISH}</span> of <span class="math">\\mathsf{CS}_{1}</span> and <span class="math">\\mathsf{CS}_{2}</span> respectively.</p>

    <p class="text-gray-300">Somewhere Statistically Binding and <span class="math">G</span>-Extractability. Let <span class="math">\\boldsymbol{z},\\boldsymbol{z}^{\\prime}\\in\\mathbb{Z}_{p}^{n_{1}n_{2}}</span> such that <span class="math">\\mathsf{kCS.Com}(ck,\\boldsymbol{z})=\\mathsf{kCS.Com}(ck,\\boldsymbol{z}^{\\prime})</span>. Let <span class="math">\\mathbf{T_{G}}</span> and <span class="math">\\mathbf{T_{H}}</span> the trapdoors associated to <span class="math">[\\mathbf{G}]_{1}</span> and <span class="math">[\\mathbf{H}]_{2}</span>, respectively, then</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=(\\mathbf{T_{G}}\\otimes\\mathbf{T_{H}})(\\mathbf{G}\\otimes\\mathbf{H}+\\mathbf{Z})(\\boldsymbol{z}-\\boldsymbol{z}^{\\prime})-(\\mathbf{T_{G}}\\otimes\\mathbf{T_{H}})\\mathbf{Z}(\\boldsymbol{z}-\\boldsymbol{z}^{\\prime})</span> <span class="math">=(\\mathbf{T_{G}}\\otimes\\mathbf{T_{H}})(\\mathbf{G}\\otimes\\mathbf{H})(\\boldsymbol{z}-\\boldsymbol{z}^{\\prime})</span> <span class="math">=(\\mathbf{T_{G}}\\mathbf{G})\\otimes(\\mathbf{T_{H}}\\mathbf{H})(\\boldsymbol{z}-\\boldsymbol{z}^{\\prime})</span> <span class="math">=(\\boldsymbol{\\Sigma}_{S_{1}}\\mathbf{P}_{S_{1}})\\otimes(\\boldsymbol{\\Sigma}_{S_{2}}\\mathbf{P}_{S_{2}})(\\boldsymbol{z}-\\boldsymbol{z}^{\\prime})</span> <span class="math">=(\\boldsymbol{\\Sigma}_{S_{1}}\\otimes\\boldsymbol{\\Sigma}_{S_{2}})(\\mathbf{P}_{S_{1}}\\otimes\\mathbf{P}_{S_{2}})(\\boldsymbol{z}-\\boldsymbol{z}^{\\prime})</span> <span class="math">=\\boldsymbol{z}_{S_{1},S_{2}}-\\boldsymbol{z}_{S_{1},S_{2}}^{\\prime},</span></p>

    <p class="text-gray-300">Note that this also shows that the trapdoors correctly extracts <span class="math">[\\boldsymbol{z}_{S_{1},S_{2}}]_{T}</span> from <span class="math">\\mathsf{kCS.Com}(ck,\\boldsymbol{z})</span>.</p>

    <p class="text-gray-300">Oblivious Trapdoor Generation. We first recall the following commutative property of kronecker products.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Fact 3.</h6>

    <p class="text-gray-300">For every <span class="math">m_{1},m_{2},n_{1},n_{2}\\in\\mathbb{N}</span> there exists permutation matrices <span class="math">\\boldsymbol{\\Pi}_{1}\\in\\{0,1\\}^{m_{1}n_{1}\\times m_{1}n_{1}},\\boldsymbol{\\Pi}_{2}\\in\\{0,1\\}^{m_{2}n_{2}\\times m_{2}n_{2}}</span> such that for any pair of matrices <span class="math">\\mathbf{M}\\in\\mathbb{Z}_{p}^{m_{1}\\times m_{2}},\\mathbf{N}\\in\\mathbb{Z}_{p}^{n_{1}\\times n_{2}}</span> it holds that <span class="math">\\mathbf{M}\\otimes\\mathbf{N}=\\boldsymbol{\\Pi}_{1}(\\mathbf{N}\\otimes\\mathbf{M})\\boldsymbol{\\Pi}_{2}</span>. Note that <span class="math">\\boldsymbol{\\Pi}_{1}</span> and <span class="math">\\boldsymbol{\\Pi}_{2}</span> depend only on the size of <span class="math">\\mathbf{M}</span> and <span class="math">\\mathbf{N}</span> but not the values of their entries.</p>

    <p class="text-gray-300">We construct an oblivious key generation algorithm as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{kCS.OblKeyGen}(gk,(n_{1},n_{2}),(K_{1},K_{2}),(S_{1},S_{2}),ck):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">ck</span> as <span class="math">[\\mathbf{Q}_{1}]_{1},[\\mathbf{Q}_{2}]_{2}</span> and <span class="math">\\mathsf{aux}=([\\mathbf{G}]_{1},[\\mathbf{H}]_{2})</span>.</li>

    </ol>

    <p class="text-gray-300">###</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left[ \\mathbf {G} ^ {\\star} \\right], \\mathbf {T} _ {1}\\right) \\leftarrow \\mathrm {C S} _ {1}. \\text {O b l K e y G e n} (g k, n _ {1}, K _ {1}, S _ {1}, \\left[ \\mathbf {G} \\right] _ {1})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left[ \\mathbf {H} ^ {\\star} \\right] _ {2}, \\mathbf {T} _ {2}\\right) \\leftarrow \\mathrm {C S} _ {2}. \\text {O b l K e y G e n} (g k, m _ {2}, K _ {2}, S _ {2}, \\left[ \\mathbf {H} \\right] _ {2})</span></div>

    <p class="text-gray-300">and use the random coins of OblKeyGen to retrieve  <span class="math">\\mathbf{G}_{S_1}^<em></span> ,  <span class="math">\\mathbf{R}_1</span>  and  <span class="math">\\mathbf{H}_{S_1}^</em></span> ,  <span class="math">\\mathbf{R}_2</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {G} ^ {\\star} ] _ {1} = \\left( \\begin{array}{c c} [ \\mathbf {G} _ {S _ {1}} ^ {*} ] _ {1} &amp;amp; \\frac {[ \\overline {{\\mathbf {G}}} _ {\\overline {{S}} _ {1}} ] _ {1}}{\\mathbf {R} _ {1} [ \\overline {{\\mathbf {G}}} _ {\\overline {{S}} _ {1}} ] _ {1}} \\end{array} \\right) \\mathbf {P} _ {S _ {1}} \\text { and } \\mathbf {H} ^ {\\star} = \\left( \\begin{array}{c c} [ \\mathbf {H} _ {S _ {2}} ^ {*} ] _ {2} &amp;amp; \\frac {[ \\overline {{\\mathbf {H}}} _ {\\overline {{S}} _ {2}} ] _ {2}}{\\mathbf {R} _ {2} [ \\overline {{\\mathbf {H}}} _ {\\overline {{S}} _ {2}} ] _ {2}} \\end{array} \\right) \\mathbf {P} _ {S _ {2}},</span></div>

    <p class="text-gray-300">as defined in Fig. 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Let  <span class="math">[\\mathbf{A}_1]_1, [\\mathbf{A}_2]_2</span>  be the matrices containing the first  $(K_1 + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(K_2 + k)<span class="math">  rows of  </span>[(Q_1)_{\\overline{S}_1,\\overline{S}_2}]_1<span class="math">  and  </span>[(Q_2)_{\\overline{S}_1,\\overline{S}_2}]_2$ , respectively.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5. Define  <span class="math">[\\mathbf{B}_1]_1</span>  and  <span class="math">[\\mathbf{B}_2]_2</span>  be the matrices of the first  $(K_{1} + k -</td>

            <td class="px-3 py-2 border-b border-gray-700">S_{1}</td>

            <td class="px-3 py-2 border-b border-gray-700">)(K_{2} + k -</td>

            <td class="px-3 py-2 border-b border-gray-700">S_{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math">  columns of  </span>\\Pi_1^\\top [\\mathbf{A}_1]_1\\Pi_2^\\top<span class="math">  and  </span>\\Pi_1^\\top [\\mathbf{A}_2]_2\\Pi_2^\\top$ , respectively.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6. Let  $[\\mathbf{A}_1^\\star ]_1 = \\Pi_1\\left(\\frac{[\\mathbf{B}_1]_1}{(\\mathbf{R}_2\\otimes\\mathbf{I}_{K_1 + k -</td>

            <td class="px-3 py-2 border-b border-gray-700">S_1</td>

            <td class="px-3 py-2 border-b border-gray-700">})[\\mathbf{B}_1]_1}\\right)\\Pi_2<span class="math">  and  </span>[\\mathbf{A}_2^\\star ]_2 = \\Pi_1\\left(\\frac{[\\mathbf{B}_2]_2}{(\\mathbf{R}_2\\otimes\\mathbf{I}_{K_1 + k -</td>

            <td class="px-3 py-2 border-b border-gray-700">S_1</td>

            <td class="px-3 py-2 border-b border-gray-700">})[\\mathbf{B}_2]_2}\\right)\\Pi_2.$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick  <span class="math">\\mathbf{Z} \\gets \\mathbb{Z}_p^{(K_1 + k)(K_2 + k) \\times n_1n_2}</span>  and let</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ \\mathbf {Q} _ {1} ^ {\\star} ] _ {1} = \\left([ \\mathbf {Z} _ {S _ {1}, [ n _ {2} ]} ] _ {1} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ \\mathbf {G} _ {\\overline {{S}} _ {1}} ^ {\\star} ] _ {1} \\otimes \\mathbf {H} _ {S _ {2}} ^ {\\star} + [ \\mathbf {Z} _ {\\overline {{S}} _ {1}, S _ {2}} ] _ {1} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\frac {[ \\mathbf {A} _ {1} ^ {\\star} ] _ {1}}{(\\mathbf {R} _ {1} \\otimes \\mathbf {I} _ {K _ {2} + k}) [ \\mathbf {A} _ {1} ^ {\\star} ] _ {1}}\\right) + [ \\mathbf {Z} _ {\\overline {{S}} _ {1}, \\overline {{S}} _ {2}} ] _ {1}\\right) (\\mathbf {P} _ {S _ {1}} \\otimes \\mathbf {P} _ {S _ {2}})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ \\mathbf {Q} _ {2} ^ {\\star} ] _ {2} = \\left(\\mathbf {G} _ {S _ {1}} ^ {\\star} \\otimes [ \\mathbf {H} ^ {\\star} ] _ {2} - [ \\mathbf {Z} _ {S _ {1}, [ n _ {2} ]} ] _ {1} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- [ \\mathbf {Z} _ {\\overline {{S}} _ {1}, S _ {2}} ] _ {2} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\frac {[ \\mathbf {A} _ {2} ^ {\\star} ] _ {2}}{(\\mathbf {R} _ {1} \\otimes \\mathbf {I} _ {K _ {2} + k}) [ \\mathbf {A} _ {2} ^ {\\star} ] _ {2}}\\right) - [ \\mathbf {Z} _ {\\overline {{S}} _ {1}, \\overline {{S}} _ {2}} ] _ {2}\\right) (\\mathbf {P} _ {S _ {1}} \\otimes \\mathbf {P} _ {S _ {2}})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\mathbf{aux} = ([\\mathbf{G}^{\\star}]_1, [\\mathbf{H}^{\\star}]_2)</span>  and  <span class="math">\\mathbf{T} = \\mathbf{T}_1 \\otimes \\mathbf{T}_2</span> .</li>

      <li>Return  <span class="math">(ck = ([\\mathbf{Q}_1^\\star ]_1,[\\mathbf{Q}_2^\\star ]_2,\\mathbf{aux}),\\tau = \\mathbf{T})</span></li>

    </ol>

    <p class="text-gray-300">Now we show that  <span class="math">ck</span>  is correctly distributed. Since  <span class="math">\\mathsf{CS}_1</span>  and  <span class="math">\\mathsf{CS}_2</span>  are both oblivious SSB commitments, it holds that  <span class="math">\\mathsf{aux} = [\\mathbf{G}^{\\star}]_1, [\\mathbf{H}^{\\star}]</span>  follows the same distribution as the honest aux. It is enough to show that  <span class="math">\\mathbf{Q}^{\\star} = \\mathbf{Q}_1^{\\star} + \\mathbf{Q}_2^{\\star} = \\mathbf{G}^{\\star} \\otimes \\mathbf{H}^{\\star}</span> . This is the case since if this holds, the commitment key  <span class="math">[\\mathbf{Q}_1^{\\star}]_1, [\\mathbf{Q}_2^{\\star}]_2</span>  consists of two uniform matrices, conditioned on their sum equaling  <span class="math">\\mathbf{G}^{\\star} \\otimes \\mathbf{H}^{\\star}</span> , and this is the distribution of the honest key as well.</p>

    <p class="text-gray-300">It is clear that this is the case for  <span class="math">\\mathbf{Q}_{S_1,[n_2]}^{\\star}</span>  and  <span class="math">\\mathbf{Q}_{\\overline{S}_1,S_2}^{\\star}</span> , so we show it is also the case for  <span class="math">\\mathbf{Q}_{\\overline{S}_1,\\overline{S}_2}^{\\star}</span> .</p>

    <p class="text-gray-300">First, note that  <span class="math">\\mathbf{Q}_{\\overline{S}_1,\\overline{S}_2} = (\\mathbf{Q}_1 + \\mathbf{Q}_2)_{\\overline{S}_1,\\overline{S}_2} = \\left( \\begin{array}{c}\\overline{\\mathbf{G}}_{\\overline{S}_1}\\otimes \\mathbf{H}_{\\overline{S}_2}\\\\ \\underline{\\mathbf{G}}_{\\overline{S}_1}\\otimes \\mathbf{H}_{\\overline{S}_2} \\end{array} \\right)</span>  and then  <span class="math">\\mathbf{A} = \\mathbf{A}_1 + \\mathbf{A}_2 = \\overline{\\mathbf{G}}_{\\overline{S}_1}\\otimes \\mathbf{H}_{\\overline{S}_2}</span> . It follows that  <span class="math">\\Pi_1^\\top \\mathbf{A}\\Pi_2^\\top = \\Pi_1^\\top \\Pi_1\\mathbf{H}_{\\overline{S}_2}\\otimes \\overline{\\mathbf{G}}_{\\overline{S}_1}\\Pi_2\\Pi_2^\\top = \\left( \\begin{array}{c}\\overline{\\mathbf{H}}_{\\overline{S}_2}\\otimes \\overline{\\mathbf{G}}_{\\overline{S}_1}\\\\ \\underline{\\mathbf{H}}_{\\overline{S}_2}\\otimes \\overline{\\mathbf{G}}_{\\overline{S}_1} \\end{array} \\right)</span>  and hence  <span class="math">\\mathbf{B} = \\mathbf{B}_1 + \\mathbf{B}_2 = \\overline{\\mathbf{H}}_{\\overline{S}_2}\\otimes \\overline{\\mathbf{G}}_{\\overline{S}_1}</span> .</p>

    <p class="text-gray-300">Finally we have that</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {Q} _ {\\overline {{S}} _ {1}, \\overline {{S}} _ {2}} ^ {<em>} = \\left( \\begin{array}{c} \\mathbf {A} _ {1} ^ {</em>} + \\mathbf {A} _ {2} ^ {<em>} \\\\ (\\mathbf {R} _ {1} \\otimes \\mathbf {I} _ {K _ {2} + k}) (\\mathbf {A} _ {1} ^ {</em>} + \\mathbf {A} _ {2} ^ {*}) \\end{array} \\right) = \\left( \\begin{array}{c} \\Pi_ {1} \\left( \\begin{array}{c} \\mathbf {B} _ {1} + \\mathbf {B} _ {2} \\\\ (\\mathbf {R} _ {2} \\otimes \\mathbf {I} _ {K _ {1} + k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) (\\mathbf {B} _ {1} + \\mathbf {B} _ {2}) \\end{array} \\right) \\Pi_ {2} \\\\ (\\mathbf {R} _ {1} \\otimes \\mathbf {I} _ {K _ {2} + k}) (\\mathbf {A} _ {1} ^ {<em>} + \\mathbf {A} _ {2} ^ {</em>}) \\end{array} \\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= \\left( \\begin{array}{c} \\Pi_ {1} \\mathbf {H} _ {\\overline {{S}} _ {2}} ^ {<em>} \\otimes \\overline {{\\mathbf {G}}} _ {\\overline {{S}} _ {1}} \\Pi_ {2} \\\\ (\\mathbf {R} _ {1} \\otimes \\mathbf {I} _ {K _ {2} + k}) (\\mathbf {A} _ {1} ^ {</em>} + \\mathbf {A} _ {2} ^ {<em>}) \\end{array} \\right) = \\left( \\begin{array}{c} \\overline {{\\mathbf {G}}} _ {\\overline {{S}} _ {1}} \\otimes \\mathbf {H} _ {\\overline {{S}} _ {2}} ^ {</em>} \\\\ (\\mathbf {R} _ {1} \\otimes \\mathbf {I} _ {K _ {2} + k}) (\\overline {{\\mathbf {G}}} _ {\\overline {{S}} _ {1}} \\otimes \\mathbf {H} _ {\\overline {{S}} _ {2}} ^ {<em>}) \\end{array} \\right) \\\\ = \\mathbf {G} _ {\\overline {{S}} _ {1}} ^ {</em>} \\otimes \\mathbf {H} _ {\\overline {{S}} _ {2}} ^ {*}. \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For finishing the proof it suffices to show that the rest of the input given to the distinguisher is correctly distributed. Note that, following definition 4 and fact 2,  $[y_{S_1', S_2'}]_T = (\\text{Extract}(\\mathbf{T}_{S_1, S_2}, [c]_1, [d]_2))_{S_1', S_2'} = [z_{S_1', S_2'}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1', S_2']_T = [z_{S_1', S_2'}]_T = \\text{Extract}(\\mathbf{T}_{S_1', S_2'}, [c]_1, [d]_2)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Corollary 1. Construction from fig. 3 instantiated in  <span class="math">\\mathbb{G}_1</span>  is ISH even when the adversary is given  <span class="math">h(sk) = ([\\mathbf{H}]_2, [\\mathbf{G} \\otimes \\mathbf{H} + \\mathbf{Z}]_1, [-\\mathbf{Z}]_2)</span> . Similarly, it is also ISH when instantiated in  <span class="math">\\mathbb{G}_2</span>  when the adversary is given  <span class="math">h(sk) = ([\\mathbf{G}]_1, [\\mathbf{G} \\otimes \\mathbf{H} + \\mathbf{Z}]_1, [-\\mathbf{Z}]_2)</span> .</p>

    <p class="text-gray-300">Proof. Follows directly from the ISH of the kronecker SSB commitment of Theorem 6. Specifically, ISH for  <span class="math">\\mathbb{G}_1</span>  follows from the indistinguishability of distributions 1 to 3 from Theorem 6, and ISH for  <span class="math">\\mathbb{G}_2</span>  follows from the indistinguishability of distributions 3 to 6.</p>

    <p class="text-gray-300">In this section we introduce an extension of Quasi Arguments as defined in [KPY19] which adds support for language dependent crs or preprocessing such as the so called QA-NIZK arguments [JR13]. Additionally we use different languages for completeness and local soundness, i.e. promise problems, to incorporate the "knowledge transfer" soundness of [GR19].</p>

    <p class="text-gray-300">Following [JR13], languages are parametrized by  <span class="math">\\rho \\in \\mathcal{L}_{\\mathrm{par}}</span>  and  <span class="math">\\rho</span>  sampled from some distribution  <span class="math">\\mathcal{D}_{\\mathrm{par}}</span> . We say  <span class="math">\\mathrm{tat} \\mathcal{D}_{\\mathrm{par}}</span>  is witness sampleable if  <span class="math">\\rho</span>  can be efficiently sampled together with a witness  <span class="math">\\theta</span>  for  <span class="math">\\rho \\in \\mathcal{L}_{\\mathrm{par}}</span> . We simply write  <span class="math">(\\theta, \\rho) \\gets \\mathcal{D}_{\\mathrm{par}}</span> . Each  <span class="math">\\rho \\in \\mathcal{L}_{\\mathrm{par}}</span>  defines a language  <span class="math">\\mathcal{L}_{\\rho}</span>  with the corresponding relations  <span class="math">\\mathcal{R}_{\\rho}^{\\mathrm{yes}}</span> , that is  <span class="math">\\mathcal{L}_{\\rho} = \\{x \\mid \\exists w \\text{ s.t. } (x, w) \\in \\mathcal{R}_{\\rho}^{\\mathrm{yes}}\\}</span> . After the language is fixed there is a (language dependent) prepossessing stage where a common reference string is generated. Going a step forward, we would like our statements to be commitments and that  <span class="math">\\mathcal{R}_{\\rho}^{\\mathrm{yes}}</span>  puts some restriction on the commitment opening. Since we will be using SSB commitments, the language parameter must contain the SSB commitment key. Therefore, we assume distribution  <span class="math">\\mathcal{D}_{\\mathrm{par}}</span>  receives as input  <span class="math">d \\in \\mathbb{N}</span>  (the size of the opening), a locality parameter  <span class="math">K \\leq d</span>  and a set  <span class="math">S \\subseteq [d]</span> . It will be useful to define  <span class="math">\\mathcal{L}_{\\rho}^{\\mathrm{yes}} = \\mathcal{L}_{\\rho}</span>  and  <span class="math">\\mathcal{L}_{\\rho}^{\\mathrm{no}}</span>  the complement of  <span class="math">\\mathcal{L}_{\\rho}^{\\mathrm{yes}}</span> , and similarly define  <span class="math">\\mathcal{R}_{\\rho}^{\\mathrm{yes}}</span>  and  <span class="math">\\mathcal{R}_{\\rho}^{\\mathrm{no}}</span> . Traditional arguments of knowledge require that from any accepting statement and proof pair one can extract a witness  <span class="math">w</span>  such that  <span class="math">(x, w) \\in \\mathcal{R}_{\\rho}^{\\mathrm{no}}</span>  only with negligible probability. In a quasi-argument of knowledge only a small part of the witness  <span class="math">w_{S}</span>  is extracted and  <span class="math">(x, w_{S}) \\in \\mathcal{R}_{\\rho, S}^{\\mathrm{yes}}</span>  with overwhelming probability, where  <span class="math">\\mathcal{R}_{\\rho, S}^{\\mathrm{yes}}</span>  is a "local version" of  <span class="math">\\mathcal{R}_{\\rho}^{\\mathrm{yes}}</span> .</p>

    <p class="text-gray-300">Our final addition is support for arguments of knowledge transfer (AoKT) <em>[x10]</em>. In a nutshell, an AoKT enables to “succinctly reuse” an AoK of the opening of some commitment <span class="math">C</span> for constructing another AoK for commitment <span class="math">D</span>. That is, given an opening <span class="math">w</span> for <span class="math">C</span>, it enables to give a succinct proof that <span class="math">D</span> opens to <span class="math">g(w)</span>. Importantly, AoKTs can be based on falsifiable assumptions. Following <em>[x10]</em>, <span class="math">\\rho\\in\\mathcal{L}_{\\text{par}}</span> defines languages <span class="math">\\mathcal{L}^{\\text{yes}}_{\\rho}</span> and <span class="math">\\mathcal{L}^{\\text{no}}_{\\rho}</span>, with <span class="math">\\mathcal{L}^{\\text{no}}_{\\rho}</span> not necessarily the complement of <span class="math">\\mathcal{L}^{\\text{yes}}_{\\rho}</span> (i.e. a promise problem), with their corresponding relations <span class="math">\\mathcal{R}^{\\text{yes}}_{\\rho}</span> and <span class="math">\\mathcal{R}^{\\text{no}}_{\\rho}</span>. For no instances, the adversary provides a promise <span class="math">w^{<em>}</span> for <span class="math">x</span>. In </em>[x10]<em> <span class="math">x=(C,D)</span> and <span class="math">(C,D,w^{</em>})\\in\\mathcal{L}^{\\text{no}}_{\\rho}</span> if <span class="math">w^{<em>}</span> is an opening for <span class="math">C</span> but <span class="math">g(w^{</em>})</span> is not an opening for <span class="math">D</span>. In our instantiations <span class="math">x</span> will be two SSB commitments to <span class="math">C_{1},\\ldots,C_{d}</span> and <span class="math">D_{1},\\ldots,D_{d}</span> such that <span class="math">C_{i}</span> opens to <span class="math">w</span> and <span class="math">D_{i}</span> to <span class="math">g_{i}(w)</span>. From the two SSB commitments we can extract <span class="math">C_{S}</span> and <span class="math">D_{S}</span>. Furthermore, <span class="math">C_{i}</span> and <span class="math">D_{i}</span> might not be extractable (actually, they will be Pedersen commitments) an hence the extractor can only compute <span class="math">f(w,S)=\\{\\textsf{Com}(ck_{i},w):i\\in S\\}</span>.</p>

    <p class="text-gray-300">We define the yes and no languages as</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}^{\\text{yes}}_{\\rho}=\\{x\\mid\\exists w\\text{ s.t. }(x,w)\\in\\mathcal{R}^{\\text{yes}}_{\\rho,S}\\},\\qquad\\mathcal{L}^{\\text{no}}_{\\rho}=\\{(x,w^{<em>})\\mid\\exists y\\text{ s.t. }(x,y,w^{</em>})\\in\\mathcal{R}^{\\text{no}}_{\\rho,S}\\},</span></p>

    <p class="text-gray-300">where <span class="math">w^{*}</span> is the promise of the adversary and <span class="math">y</span> is the local <span class="math">f</span>-witness that we can extract from the adversary. Intuitively, the two witnesses of the languages are different kind of objects. Witness <span class="math">y</span> is the value we extract from the adversary, which can’t be equal to <span class="math">f(w,S)</span> for successful adversaries, but should lie the image of <span class="math">f</span> anyway. On the other hand <span class="math">w</span> is a “proper” witness from which an <span class="math">y</span> can be computed and hence belongs to the preimage of <span class="math">f</span>.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">5.1 Arguments with No-signaling extraction and Oblivious CRS Generation</h3>

    <p class="text-gray-300">Similarly to the way we treated commitment schemes, we don’t directly prove the existence of no-signaling extractors but first show the existence of an Oblivious CRS Generation algorithm. We then show the latter notion implies the former. For convenience, we start defining a quasi argument without no-signaling extraction but only local soundness. For local soundness, we use a weaker variant of the strong Quasi-Adaptive soundness of <em>[x20]</em> where the adversary chooses <span class="math">(\\rho,\\theta)\\in\\mathcal{L}_{\\text{par}}</span>. Instead, we honestly sample parameter <span class="math">\\rho</span> and reveal part of the witness <span class="math">h_{ls}(\\theta)</span> to the adversary, for some function <span class="math">h_{ls}</span>. When we don’t require computational assumptions on <span class="math">\\rho</span>, as in quasi arguments of membership in a linear space, <span class="math">h_{ls}</span> might be the identity function and then our definition becomes strong soundness as defined in <em>[x20]</em>. In knowledge transfer arguments, soundness holds provided the hardness of some computational assumption defined by <span class="math">\\rho</span>. For this reason <span class="math">h_{ls}</span> can’t be the identity and some part of <span class="math">\\theta</span> must remain hidden.</p>

    <p class="text-gray-300">In practice <span class="math">h_{ls}</span> models correlated information leaked by another protocol, typically as a result of sharing the commitment keys. If local knowledge soundness holds even when the adversary is given <span class="math">h_{ls}(\\theta)</span>, it means that any other protocol for which the crs can be derived from <span class="math">h_{ls}(\\theta)</span> can be safely executed with a “correlated crs”.</p>

    <p class="text-gray-300">It will be useful to consider vectors of sets of size <span class="math">t</span>. Namely <span class="math">\\bm{S}=(\\bm{S}_{1},\\ldots,\\bm{S}_{t})</span>, for some <span class="math">t\\in\\mathbb{N}</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">An <span class="math">h_{ls}</span>-strong locally extractable proof system <span class="math">\\Pi</span> for the parameter language <span class="math">\\mathcal{L}_{\\text{par}}</span> and relations <span class="math">\\mathcal{R}^{\\text{yes}}_{\\rho},\\mathcal{R}^{\\text{no}}_{\\rho,\\bm{S}}</span> is a tuple of PPT algorithms <span class="math">\\Pi=(\\textsf{K},\\textsf{Prove},\\textsf{Verify},\\textsf{Extract})</span> where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">(\\rho,\\theta)\\leftarrow\\mathcal{D}_{\\text{par}}(gk,d,\\bm{K},\\bm{S})</span>: Parameter generation <span class="math">\\mathcal{D}_{\\text{par}}</span> takes as input a group key <span class="math">gk</span>, the locality parameter <span class="math">\\bm{K}</span> and a set <span class="math">\\bm{S}\\subseteq([d],\\ldots,[d])</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\bm{K}<span class="math">; it outputs an instance witness pair </span>(\\rho,\\theta)<span class="math"> of </span>\\mathcal{L}_{\\text{par}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{crs}, \\tau) \\gets \\mathsf{K}(\\rho, \\theta)</span> :  <span class="math">\\mathsf{K}</span>  takes as input an instance-witness pair  <span class="math">(\\rho, \\theta)</span>  of  <span class="math">\\mathcal{L}_{\\mathrm{par}}</span> ; it outputs a common reference string  <span class="math">\\mathsf{crs}</span>  and an extraction trapdoor  <span class="math">\\tau</span> .</li>

      <li><span class="math">\\pi \\gets \\text{Prove}(\\text{crs}, x, w)</span> : Prove takes as input crs and a statement-witness pair  <span class="math">(x, w)</span>  of  <span class="math">\\mathcal{L}_{\\rho}^{\\text{yes}}</span> ; it outputs a proof  <span class="math">\\pi</span> .</li>

      <li><span class="math">b \\gets \\text{Verify}(\\text{crs}, x, \\pi)</span> : Verify takes as input crs, a statement  <span class="math">x</span>  and a proof  <span class="math">\\pi</span> ; it outputs a bit  <span class="math">b</span>  indicating if the proof  <span class="math">\\pi</span>  is a valid proof.</li>

      <li><span class="math">y \\gets \\operatorname{Extract}(\\tau, x, \\pi)</span> : Extract takes as input the extraction trapdoor  <span class="math">\\tau</span> , a statement  <span class="math">x</span>  and a proof  <span class="math">\\pi</span> , and outputs a local witness  <span class="math">y</span>  for the set  <span class="math">S</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For all  <span class="math">\\kappa \\in \\mathbb{N}^t, K \\leq (d, \\ldots, d) \\in \\mathbb{N}^t, S \\subseteq ([d], \\ldots, [d])</span> , with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math"> ,  </span>\\Pi$  satisfies the following properties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For all  <span class="math">(\\rho, \\theta) \\in \\mathcal{L}_{\\mathrm{par}}</span>  and  <span class="math">x, w \\in \\{0,1\\}^*</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c c} \\text {V e r i f y} (\\mathsf {c r s}, x, \\pi) = 1 &amp;amp; (\\mathsf {c r s}, \\tau) \\leftarrow \\mathsf {K} (\\rho , \\theta); \\\\ \\vee (x, w) \\notin \\mathcal {R} _ {\\rho , S} ^ {\\mathsf {y e s}} &amp;amp; \\pi \\leftarrow \\mathsf {P r o v e} (\\mathsf {c r s}, x, w) \\end{array} \\right] \\geq 1 - \\mathsf {n e g l} (\\kappa)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_{ls}</span> -Strong Local Knowledge Soundness: For all PPT  <span class="math">\\mathcal{A}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\begin{array}{c c} \\text {V e r i f y} (\\mathsf {c r s}, x, \\pi) = 0 &amp;amp; (\\rho , \\theta) \\leftarrow \\mathcal {D} _ {\\mathsf {p a r}} (g k, d, K, S); \\\\ \\vee (x, y, w ^ {*}) \\notin \\mathcal {R} _ {\\rho , S} ^ {\\mathsf {n o}} &amp;amp; (c r s, \\tau) \\leftarrow K (\\rho , \\theta); \\\\ (x, w ^ {*}, \\pi) \\leftarrow \\mathcal {A} (\\rho , h _ {l s} (\\theta), \\mathsf {c r s}); \\\\ y \\leftarrow \\mathsf {E x t r a c t} (\\tau , x, \\pi) \\end{array} \\right] \\geq 1 - \\mathsf {n e g l} (\\kappa)</span></div>

    <p class="text-gray-300">Next, we define the no-signaling property of quasi-arguments. Similarly as with strong knowledge soundness, we consider a stronger definition where the adversary is given some function of  <span class="math">\\theta</span> , namely  <span class="math">h_{ns}(\\theta)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 8. An  <span class="math">h_{ls}</span> -strong locally extractable proof system  <span class="math">\\Pi</span>  for the parameter language  <span class="math">\\mathcal{L}_{\\mathrm{par}}</span>  and relations  <span class="math">\\mathcal{R}_{\\rho, S}^{\\mathrm{yes}}, \\mathcal{R}_{\\rho, S}^{\\mathrm{no}}</span>  is an  <span class="math">(h_{ls}, h_{ns})</span> -quasi argument if it satisfies  <span class="math">h_{ns}</span> -strong no-signaling extraction. That is, for all  <span class="math">\\kappa \\in \\mathbb{N}, K \\leq d \\in \\mathbb{N}^t, S&#x27; \\subseteq S \\subseteq ([d], \\ldots, [d])</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math"> , and all PPT  </span>\\mathcal{A}<span class="math">  and PPT  </span>\\mathcal{D}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} (\\operatorname {c r s}, x, \\pi , y _ {S ^ {\\prime}}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\rho , \\theta) \\leftarrow \\mathcal {D} _ {\\operatorname {p a r}} (g k, d, K, S); \\\\ (\\operatorname {c r s}, \\tau) \\leftarrow K (\\rho , \\theta); \\\\ (x, \\pi) \\leftarrow \\mathcal {A} (\\rho , h _ {n s} (\\theta), \\operatorname {c r s}); \\\\ \\text {i f V e r i f y} (\\operatorname {c r s}, x, \\pi) = 0: \\text {s e t} x = \\bot ; \\\\ y \\leftarrow \\operatorname {E x t r a c t} (\\tau , x, \\pi) \\end{array} \\right. \\right. - \\right. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} (\\operatorname {c r s}, x, \\pi , y ^ {\\prime}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\rho , \\theta) \\leftarrow \\mathcal {D} _ {\\operatorname {p a r}} (g k, d, K, S ^ {\\prime}); \\\\ (\\operatorname {c r s}, \\tau) \\leftarrow K (\\rho , \\theta); \\\\ (x, \\pi) \\leftarrow \\mathcal {A} (\\rho , h _ {n s} (\\theta), \\operatorname {c r s}); \\\\ \\text {i f V e r i f y} (\\operatorname {c r s}, x, \\pi) = 0: \\text {s e t} x = \\bot ; \\\\ y ^ {\\prime} \\leftarrow \\operatorname {E x t r a c t} (\\tau , x, \\pi) \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\kappa) \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Finally, we define the notion of oblivious locally extractable proof systems. The requirements are that (1) the crs alone does not help PPT adversaries gain information about the extraction set used to sample the parameters  <span class="math">\\rho</span> ; (2) there exists a PPT algorithm OblSetup that on input a set  <span class="math">S&#x27; \\subseteq S</span>  and  <span class="math">(\\rho, \\mathrm{crs})</span> , sampled for extraction on the superset of  <span class="math">S</span> , outputs new</p>

    <p class="text-gray-300">values  <span class="math">(\\rho&#x27;, \\mathsf{crs}&#x27;)</span>  that are statistically close to  <span class="math">(\\rho, \\mathsf{crs})</span>  and additionally, it outputs a trapdoor  <span class="math">\\tau&#x27;</span>  for  <span class="math">S&#x27;</span>  that outputs indistinguishable witnesses to the ones output for  <span class="math">S</span>  and restricted to  <span class="math">S&#x27;</span> .</p>

    <p class="text-gray-300">We consider also a "hns-strong" variant of (1). Note that (2) holds against unbounded adversaries which can compute  <span class="math">\\theta</span>  by themselves.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 9. A locally extractable proof system  <span class="math">\\Pi</span>  for the parameter language  <span class="math">\\mathcal{L}_{\\mathrm{par}}</span>  and relations  <span class="math">\\mathcal{R}_{\\rho}^{\\mathrm{yes}}, \\mathcal{R}_{\\rho, S}^{\\mathrm{no}}</span>  is  <span class="math">h_{ns}</span> -Strong Oblivious if there exist a PPT algorithm OblSetup such that, for all  <span class="math">\\kappa \\in \\mathbb{N}, K \\leq (d, \\ldots, d) \\in \\mathbb{N}&#x27;, S&#x27;, S \\subseteq ([d], \\ldots, [d])</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_{ns}</span> -Strong Index Set Hiding: for all PPT  <span class="math">\\mathcal{D}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} (\\rho , \\operatorname {c r s}, h _ {n s} (\\theta)) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\rho , \\theta) \\leftarrow \\mathcal {D} _ {\\text {p a r}} (g k, d, K, S) \\\\ (\\operatorname {c r s}, \\tau) \\leftarrow K (\\rho , \\theta) \\end{array} \\right. \\right] - \\right. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left. \\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} (\\rho , \\operatorname {c r s}, h _ {n s} (\\theta)) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\rho , \\theta) \\leftarrow \\mathcal {D} _ {\\text {p a r}} (g k, d, K, S ^ {\\prime}) \\\\ (\\operatorname {c r s}, \\tau) \\leftarrow K (\\rho , \\theta) \\end{array} \\right] \\right] \\leq \\operatorname {n e g l} (\\kappa) \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Oblivious trapdoor Generation: if  <span class="math">S&#x27; \\subseteq S</span>  then for all, (even unbounded) adversaries  <span class="math">\\mathcal{A}</span>  and distinguishers  <span class="math">\\mathcal{D}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} (\\rho^ {\\prime}, \\operatorname {c r s} ^ {\\prime}, y ^ {\\prime}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\rho , \\theta) \\leftarrow \\mathcal {D} _ {\\text {p a r}} (g k, d, K, S); (\\operatorname {c r s}, \\tau) \\leftarrow K (\\rho , \\theta) \\\\ (\\rho^ {\\prime}, \\operatorname {c r s} ^ {\\prime}, \\tau^ {\\prime}) \\leftarrow \\operatorname {O b l S e t u p} (\\rho , \\operatorname {c r s}, S ^ {\\prime}) \\\\ (x, \\pi) \\leftarrow \\mathcal {A} (\\rho , \\operatorname {c r s} ^ {\\prime}) \\\\ \\text {i f V e r i f y} (\\operatorname {c r s}, x, \\pi) = 0: \\operatorname {s e t} x = \\bot ; \\\\ y ^ {\\prime} \\leftarrow \\operatorname {E x t r a c t} (\\tau^ {\\prime}, x, \\pi) \\end{array} \\right. \\right] - \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {g k \\leftarrow \\mathcal {G} (1 ^ {\\kappa})} \\left[ \\mathcal {D} (\\rho , \\operatorname {c r s}, y _ {S ^ {\\prime}}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\rho , \\theta) \\leftarrow \\mathcal {D} _ {\\text {p a r}} (g k, d, K, S); (\\operatorname {c r s}, \\tau) \\leftarrow K (\\rho , \\theta) \\\\ (x, \\pi) \\leftarrow \\mathcal {A} (\\rho , \\operatorname {c r s}) \\\\ \\text {i f V e r i f y} (\\operatorname {c r s}, x, \\pi) = 0: \\operatorname {s e t} x = \\bot ; \\\\ y \\leftarrow \\operatorname {E x t r a c t} (\\tau , x, \\pi) \\end{array} \\right] \\right] \\leq \\operatorname {n e g l} (\\kappa) \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Next, we present a proof that if a locally extractable proof system satisfies oblivious crs generation, then it is no-signaling. The proof is similar to the proof of Thm. 2.</p>

    <p class="text-gray-300">Theorem 7. Let  <span class="math">\\Pi = (\\mathsf{K},\\mathsf{Prove},\\mathsf{Verify},\\mathsf{Extract},\\mathsf{OblSetup})</span>  be an  <span class="math">h_{ns}</span> -strong Locally Extractable Proof System for the parameter language  <span class="math">\\mathcal{L}_{\\mathrm{par}}</span>  and relations  <span class="math">\\mathcal{R}_{\\rho}^{\\mathrm{yes}},\\mathcal{R}_{\\rho ,S}^{\\mathrm{no}}</span> . Then,  <span class="math">\\Pi</span>  has  <span class="math">h_{ns}</span> -strong no signaling extraction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Fix any  <span class="math">S&#x27; \\subseteq S \\subseteq ([d], \\ldots, [d])</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math"> , and let  </span>\\mathcal{D}<span class="math">  be a PPT distinguisher against no signaling extraction for these values, on instance-proof pairs output by a PPT  </span>\\mathcal{A}$ . We show by a sequence of games that its success probability is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_0^{\\mathcal{D},\\mathcal{A}}(1^\\kappa)</span> : We execute  <span class="math">(\\rho, \\theta) \\gets \\mathcal{D}_{\\mathrm{par}}(gk, d, K, S)</span> ;  <span class="math">(\\mathsf{crs}, \\tau) \\gets K(\\rho, \\theta)</span> ; we then get  <span class="math">(x, \\pi) \\gets \\mathcal{A}(\\rho, \\mathsf{crs}, h_{ns}(\\theta))</span>  and change  <span class="math">x</span>  to  <span class="math">\\bot</span>  if  <span class="math">\\mathsf{Verify}(\\mathsf{crs}, x, \\pi) = 0</span> ; we compute  <span class="math">y \\gets \\mathsf{Extract}(\\tau, x, \\pi)</span> . The output is  <span class="math">\\mathcal{D}(\\mathsf{crs}, x, \\pi, y_{S&#x27;})</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_1^{\\mathcal{D},\\mathcal{A}}(1^\\kappa)</span> : We execute  <span class="math">(\\rho, \\theta) \\gets \\mathcal{D}_{\\mathrm{par}}(gk, d, K, S)</span> ;  <span class="math">(\\mathsf{crs}, \\tau) \\gets K(\\rho, \\theta)</span> ; we use the oblivious extractor to get  <span class="math">(\\rho&#x27;, \\mathsf{crs}&#x27;, \\tau&#x27;) \\gets \\mathsf{OblSetup}(\\rho, \\mathsf{crs}, S&#x27;)</span> ; we then get  <span class="math">(x, \\pi) \\gets \\mathcal{A}(\\rho&#x27;, \\mathsf{crs}&#x27;, h_{ns}(\\theta))</span>  and change  <span class="math">x</span>  to  <span class="math">\\bot</span>  if  <span class="math">\\mathsf{Verify}(\\mathsf{crs}, x, \\pi) = 0</span> ; we compute  <span class="math">y&#x27; \\gets \\mathsf{Extract}(\\tau&#x27;, x, \\pi)</span> . The output is  <span class="math">\\mathcal{D}(\\mathsf{crs}, x, \\pi, y&#x27;)</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_2^{\\mathcal{D},\\mathcal{A}}(1^\\kappa)</span>: This is the same as <span class="math">\\mathsf{Game}_1^{\\mathcal{D},\\mathcal{A}}</span> but in the first step we sample parameters for <span class="math">S&#x27;</span>, that is we execute <span class="math">(\\rho, \\theta) \\leftarrow \\mathcal{D}_{\\mathrm{par}}(gk, d, K, S&#x27;)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_5^{\\mathcal{D},\\mathcal{A}}(1^\\kappa)</span>: We execute <span class="math">(\\rho, \\theta) \\leftarrow \\mathcal{D}_{\\mathrm{par}}(gk, d, K, S&#x27;)</span>; <span class="math">(\\mathsf{crs}, \\tau) \\leftarrow \\mathsf{K}(\\rho, \\theta)</span>; we then get <span class="math">(x, \\pi) \\leftarrow \\mathcal{A}(\\rho, \\mathsf{crs}, h_{ns}(\\theta))</span> and change <span class="math">x</span> to <span class="math">\\perp</span> if <span class="math">\\mathsf{Verify}(\\mathsf{crs}, x, \\pi) = 0</span>; we compute <span class="math">y&#x27; \\leftarrow \\mathsf{Extract}(\\tau, x, \\pi)</span>. The output is <span class="math">\\mathcal{D}(\\mathsf{crs}, x, \\pi, y&#x27;)</span>.</p>

    <p class="text-gray-300">We next show that for all <span class="math">1 \\leq i \\leq 3</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\operatorname {G a m e} _ {i} ^ {\\mathcal {D}, \\mathcal {A}} \\left(1 ^ {\\kappa}\\right) = 1 \\right] - \\Pr \\left[ \\operatorname {G a m e} _ {i - 1} ^ {\\mathcal {D}, \\mathcal {A}} \\left(1 ^ {\\kappa}\\right) = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\kappa). \\tag {5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case <span class="math">i = 1</span>, <span class="math">i = 3</span>. Note that for <span class="math">i = 1</span>, the difference in the two games is exactly as in the two cases of the oblivious trapdoor generation property for <span class="math">S&#x27; \\subseteq S</span>, so the outputs of games are statistically close. For case 3, we use the same argument for <span class="math">S&#x27; \\subseteq S&#x27;</span>.</li>

      <li>Case <span class="math">i = 2</span> The only difference in the games is how we setup the initial crs, either by sampling for <span class="math">S&#x27;</span> or for <span class="math">S</span>. The output of the two games are computationally indistinguishable by the index set hiding property, even when the adversary is given <span class="math">h_{ns}(\\theta)</span>.</li>

    </ul>

    <p class="text-gray-300">By a standard argument we get that, for all PPT <span class="math">\\mathcal{D},\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\operatorname {G a m e} _ {0} ^ {\\mathcal {D}, \\mathcal {A}} \\left(1 ^ {\\kappa}\\right) = 1 \\right] - \\Pr \\left[ \\operatorname {G a m e} _ {5} ^ {\\mathcal {D}, \\mathcal {A}} \\left(1 ^ {\\kappa}\\right) = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\kappa).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Finally, noting that <span class="math">\\mathsf{Game}_0^{\\mathcal{D},\\mathcal{A}}</span>, <span class="math">\\mathsf{Game}_3^{\\mathcal{D},\\mathcal{A}}</span> correspond to the two cases of no signaling extraction, we conclude the proof.</p>

    <h2 id="sec-56" class="text-2xl font-bold">5.2 Succinct Pairing Based Quasi-Arguments</h2>

    <p class="text-gray-300">In this section we present quasi arguments for various languages using SSB commitments with oblivious trapdoor generation. We first present the simpler case, membership in linear spaces, and then we present some extension of it, specifically a knowledge transfer version, and a knowledge transfer version for statements split in the two groups. Finally, we use the latter to build a quasi argument of knowledge transfer for hadamard products.</p>

    <h2 id="sec-57" class="text-2xl font-bold">5.2.1 Quasi Arguments of Membership in Linear Spaces</h2>

    <p class="text-gray-300">Let <span class="math">\\mathcal{U}</span> be a witness sampleable distributions sampling <span class="math">([\\mathbf{U}]_1, \\mathbf{U})</span>, where <span class="math">\\mathbf{U} \\in \\mathbb{Z}_p^{d \\times n}</span>. We assume that for any <span class="math">S \\subseteq [d]</span>, given only <span class="math">[\\mathbf{U}_S]_1</span> such that <span class="math">\\mathbf{U} = \\mathbf{P}_S^\\top \\left( \\begin{array}{c} \\mathbf{U}_S \\\\ \\mathbf{U}_S \\end{array} \\right)</span> there is an efficient way of sampling <span class="math">[\\mathbf{U}_S]</span>. Also, let CS be an algebraic SSB commitment key. The parameter language is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {L} _ {\\text {p a r}} = \\left\\{\\left[ \\mathbf {U} \\right] _ {1}, \\left[ \\mathbf {G} \\right] _ {1} \\mid \\exists \\mathbf {U}, \\mathbf {G} \\text {s.t. } \\left(\\left[ \\mathbf {U} \\right] _ {1}, \\mathbf {U}\\right) \\in \\operatorname {S u p} (\\mathcal {U}) \\text { and} \\right. \\\\ \\left(\\left[ \\mathbf {G} \\right] _ {1}, \\mathbf {G}, \\mathbf {T}\\right) \\in \\operatorname {S u p} (\\text {CS.KeyGen} (g k, d, K, S)) \\} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We assume that the corresponding relation is efficiently verifiable<span class="math">^{17}</span>. The parameters <span class="math">\\rho = ([\\mathbf{U}]_1, [\\mathbf{G}]_1) \\leftarrow (\\mathcal{U}, \\text{CS.KeyGen}(gk, d, K, S))</span> define the following relations:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {R L} _ {\\rho} ^ {\\text {y e s}} = \\left\\{\\left(\\left[ c \\right] _ {1}, w\\right): c = \\mathbf {G U} w \\right\\}, \\\\ \\mathcal {R L} _ {\\rho , S} ^ {\\mathrm {n o}} = \\left\\{\\left(\\left[ c \\right] _ {1}, \\left[ y \\right] _ {1}\\right): y \\text { is a valid } S \\text {- opening of } c \\text { and } y \\notin \\operatorname {I m} \\left(\\mathbf {U} _ {S}\\right) \\right\\} \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">^{16}</span>We will instantiate the argument with <span class="math">\\mathbf{U}</span> a block lower triangular matrix where each row is of the form <span class="math">(\\mathbf{U}_1, \\mathbf{U}_2, \\ldots, \\mathbf{U}_i, \\mathbf{0}, \\ldots, \\mathbf{0})</span> where <span class="math">\\{\\mathbf{U}_i\\}_i</span> are independent random variables. Then is clear that from <span class="math">[\\mathbf{U}_S]_1</span> we know <span class="math">[\\mathbf{U}_i]_1</span> up to <span class="math">i = \\max S</span>, and the rest <span class="math">\\{\\mathbf{U}_j : j \\notin S\\}</span> can be sampled independently.</p>

    <p class="text-gray-300"><span class="math">^{17}</span>This is w.l.o.g. since one can extend the witness to include the randomness used to sample the parameters.</p>

    <p class="text-gray-300">The advice is the empty string while the extractor should retrieve  <span class="math">f(\\boldsymbol{w}, S) = [\\mathbf{U}_S]_1 \\boldsymbol{w}</span>  from any accepting statement and proof pair. We present the construction QALin in Fig. 4. The construction is essentially the quasi adaptive construction of membership in linear space of [KW15] for the matrix  <span class="math">\\mathbf{GU}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}_{\\mathrm{par}}(gk,d,K,S)</span>  ..</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([\\mathbf{U}]_1, \\mathbf{U}) \\gets \\mathcal{U}; (pk, sk) \\gets \\text{CS.KeyGen}(gk, d, K, S)</span></li>

      <li>Output  <span class="math">(\\rho, \\theta)</span>  where  <span class="math">\\rho = (gk, pk, [\\mathbf{U}]_1)</span> ,  <span class="math">\\theta = (sk, \\mathbf{U})</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{K}(\\rho = (gk,[\\mathbf{G}]_1,[\\mathbf{U}]_1),\\theta = (\\mathbf{G},\\mathbf{T},\\mathbf{U}))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\mathbf{K} \\gets \\mathbb{Z}_p^{\\overline{K} \\times k}</span> ,  <span class="math">\\mathbf{A} \\gets \\mathcal{D}_k</span> , and redefine  <span class="math">\\mathbf{A}</span>  as its first  <span class="math">k</span>  columns.</li>

      <li>Compute  <span class="math">[\\mathbf{B}]_1 = [\\mathbf{U}^\\top]_1\\mathbf{G}^\\top \\mathbf{K}, \\mathbf{C} = \\mathbf{K}\\mathbf{A}</span> .</li>

      <li>Output (crs,  <span class="math">\\tau</span> ) where  <span class="math">\\mathsf{crs} = ([\\mathbf{A}]_2, [\\mathbf{B}]_1, [\\mathbf{C}]_2)</span> ,  <span class="math">\\tau = \\mathbf{T}</span> .</li>

    </ul>

    <p class="text-gray-300">Prove(crs = ([A]2, [B]1, [C]2), [c]1, w): Output [π]1 ← wT[B]1.</p>

    <p class="text-gray-300">Verify  <span class="math">(\\mathsf{crs} = ([\\mathbf{A}]_2, [\\mathbf{B}]_1, [\\mathbf{C}]_2), [c]_1, [\\pi]_1)</span> : Output 1 if  <span class="math">e([\\pi]_1, [\\mathbf{A}]_2) = e([c^\\top]_1, [\\mathbf{C}]_2)</span>  and 0 otherwise.</p>

    <p class="text-gray-300">Extract  <span class="math">(\\tau = \\mathbf{T},[c]_1,[\\pi ]_1)</span>  : Output  <span class="math">[y]_1\\gets \\mathbf{T}^\\top [c_S]_1</span>  , otherwise output  <span class="math">\\perp</span></p>

    <p class="text-gray-300">Figure 4: Construction QALin for membership in linear spaces. Note that this is just the argument of [KW15] for matrix  <span class="math">[\\mathbf{GU}]_1</span> .</p>

    <p class="text-gray-300">Theorem 8. Let  <span class="math">\\mathcal{U}</span>  be a witness sampleable distribution,  <span class="math">\\mathcal{D}_k</span>  be a matrix distribution and CS an algebraic SSB commitment. Then, construction QALin of Fig. 4 is a locally extractable proof system with  <span class="math">h_{\\mathrm{ls}}</span> -strong local knowledge soundness where  <span class="math">h_{\\mathrm{ls}}(\\theta) = \\theta</span> . Furthermore, completeness holds with probability 1 and  <span class="math">h_{\\mathrm{ls}}</span> -strong local knowledge soundness holds with probability at least  <span class="math">1 - \\operatorname{Adv}_{\\mathrm{snd}}^{\\Pi_{\\mathrm{lin}}}(\\mathcal{B})</span> , where  <span class="math">\\mathcal{B}</span>  is a PPT adversary against the strong soundness of  <span class="math">\\Pi_{\\mathrm{lin}}</span>  of [KW15].</p>

    <p class="text-gray-300">Proof. For completeness, we have that if  <span class="math">c = \\mathbf{GU}w</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {c} ^ {\\top} \\mathbf {C} = (\\mathbf {G U} w) ^ {\\top} \\mathbf {C} = \\boldsymbol {w} ^ {\\top} \\mathbf {U} ^ {\\top} \\mathbf {G} ^ {\\top} \\mathbf {C} = \\boldsymbol {w} ^ {\\top} \\mathbf {U} ^ {\\top} \\mathbf {G} ^ {\\top} \\mathbf {K A} = \\boldsymbol {w} ^ {\\top} \\mathbf {B A} = \\pi \\mathbf {A}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Local knowledge soundness is guaranteed by the local extractability of the SSB commitment scheme and soundness of Kiltz and Wee proof system. Note that the extractor always outputs a valid partial opening of  <span class="math">[c]_1</span>  given an accepting proof  <span class="math">[\\pi]_1</span> , by the local extractability property of the SSB commitments. We claim that this opening must lie in  <span class="math">\\mathrm{Im}([\\mathbf{U}_S]_1)</span> . Assume otherwise, and let  <span class="math">\\mathcal{A}</span>  be a PPT adversary that makes the extraction fail. We construct a PPT adversary  <span class="math">\\mathcal{B}_S</span>  that breaks strong soundness of Kiltz and Wee for the matrix  <span class="math">\\mathbf{U}_S</span> , conditioned on  <span class="math">\\mathcal{A}</span>  giving a valid proof.  <span class="math">\\mathcal{B}_S</span>  works as follows: it takes input  <span class="math">\\mathrm{crs}_S</span>  containing  $[\\mathbf{U}_S]_1 \\in \\mathbb{G}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times d}<span class="math"> ,  </span>[\\mathbf{A}]_2 \\in \\mathbb{G}_2^{k \\times k}<span class="math"> ,  </span>[\\mathbf{B}^\\dagger]_1 \\in \\mathbb{G}^{d \\times k}<span class="math"> ,  </span>[\\mathbf{C}^\\dagger]_2 \\in \\mathbb{G}_2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k}<span class="math">  and the discrete logarithms of matrix  </span>\\mathbf{U}_S$  and does the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It samples  <span class="math">\\left([\\mathbf{U}_{\\overline{S}}]_{1}, \\mathbf{U}_{\\overline{S}}\\right)</span>  s.t.  <span class="math">\\mathbf{U} = \\mathbf{P}_S^\\top (\\mathbf{U}_S / \\mathbf{U}_{\\overline{S}})</span> .</li>

      <li>It samples  <span class="math">([\\mathbf{G}]_1, \\mathbf{G}, \\mathbf{T}) \\gets \\text{CS.KeyGen}(gk, n, d, K, S)</span>  and a random matrix  <span class="math">\\mathbf{R} \\gets \\mathbb{Z}_p^{K + k \\times k}</span> .</li>

      <li>It computes  <span class="math">[\\mathbf{B}]_1 = [\\mathbf{B}^\\dagger]_1 + [\\mathbf{U}]^\\top \\mathbf{G}^\\top \\mathbf{R}, [\\mathbf{C}]_2 = \\mathbf{T}[\\mathbf{C}^\\dagger]_2 + \\mathbf{R}[\\mathbf{A}]_2</span> .</li>

      <li>It sets  <span class="math">\\rho := (gk, [\\mathbf{G}]_1, [\\mathbf{U}]_1)</span> ,  <span class="math">\\theta := (\\mathbf{G}, \\mathbf{U}, \\mathbf{T})</span>  and  <span class="math">\\operatorname{crs} := ([\\mathbf{A}]_2, [\\mathbf{B}]_1, [\\mathbf{C}]_2)</span> .</li>

    </ul>

    <p class="text-gray-300">It then executes <span class="math">\\mathcal{A}(\\rho,\\theta,\\mathsf{crs})</span> until it outputs <span class="math">[c]_{1},[\\pi]_{1}</span>. If this is an accepting proof pair, <span class="math">\\mathcal{B}_{S}</span> sets <span class="math">[x^{\\dagger}]:=T[c]</span> and <span class="math">[\\pi^{\\dagger}]:=[\\pi]_{1}-[c]_{1}^{\\top}R</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we claim that the values <span class="math">\\rho,\\theta,\\mathsf{crs}</span> given as input to <span class="math">\\mathcal{A}</span> are identically distributed to honestly created ones and thus do not skew the probability that <span class="math">\\mathcal{A}</span> outputs a valid proof. This is immediate for <span class="math">\\rho,\\theta</span> since they are sampled honestly. We show that this is true for <span class="math">\\mathsf{crs}</span> as well. Let $K^{\\dagger}\\in\\mathbb{Z}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k}<span class="math"> be the implicit matrix in </span>\\mathsf{crs}_{S}<span class="math">, that is it satisfies </span>B^{\\dagger}=U_{S}^{\\top}K^{\\dagger}<span class="math"> and </span>C^{\\dagger}=K^{\\dagger}A<span class="math">. Consider the matrix </span>K=TK^{\\dagger}+R<span class="math">, and note that this matrix is uniformly distributed since </span>R<span class="math"> is uniformly distributed. Thus </span>K<span class="math"> is distributed identically to an honestly generated </span>K^{\\prime}<span class="math"> for generating a </span>\\mathsf{crs}<span class="math">. We claim that the </span>\\mathsf{crs}<span class="math"> </span>\\mathsf{crs}<span class="math"> output by </span>\\mathcal{B}_{S}$ is identically distributed to sampling this matrix and computing the other values honestly. Indeed we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">C</span> <span class="math">=TC^{\\dagger}+RA\\quad\\quad\\text{and}\\quad B=B^{\\dagger}+U^{\\top}G^{\\top}R=U_{S}^{\\top}K^{\\dagger}+U^{\\top}G^{\\top}R</span> <span class="math">=TK^{\\dagger}A+RA\\quad\\quad\\quad\\quad\\quad=U^{\\top}G^{\\top}TK^{\\dagger}+U^{\\top}G^{\\top}R</span> <span class="math">=(TK^{\\dagger}+R)A\\quad\\quad\\quad\\quad\\quad=U^{\\top}G^{\\top}(TK^{\\dagger}+R)=(GU)^{\\top}K</span> <span class="math">=KA</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the second equality for <span class="math">B</span> follows since by the properties of algebraic SSB commitments we have $T^{\\top}G=(\\mathbf{I}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\mathbf{0})P_{S}$ which gives</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$U^{\\top}G^{\\top}T=U^{\\top}P_{S}^{\\top}\\begin{pmatrix}\\mathbf{I}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cr\\mathbf{0}\\end{pmatrix}=U_{S}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So, the outputted <span class="math">\\mathsf{crs}</span> <span class="math">\\mathsf{crs}^{\\prime}</span> is indeed identically distributed with an honest one.</p>

    <p class="text-gray-300">Finally, we show that if <span class="math">\\mathcal{A}</span> outputs a valid proof <span class="math">[\\pi]_{1}</span>, then <span class="math">\\mathcal{B}_{S}</span> outputs a valid statement-proof pair w.r.t. to <span class="math">\\mathsf{crs}_{S}</span>. Indeed, by the local extractability property of the commitment scheme, <span class="math">\\mathcal{B}_{S}</span> always outputs some <span class="math">[x^{\\dagger}]_{1}</span> consistent with <span class="math">[c]_{1}</span>, and also the proof verifies, since we have</p>

    <p class="text-gray-300"><span class="math">\\pi A=c^{\\top}C=c^{\\top}KA=c^{\\top}(TK^{\\dagger}+R)A=(x^{\\dagger})^{\\top}K^{\\dagger}A+c^{\\top}RA</span></p>

    <p class="text-gray-300">which gives <span class="math">\\pi^{\\dagger}A=\\pi A-c^{\\top}RA=(x^{\\dagger})^{\\top}K^{\\dagger}A=(x^{\\dagger})C^{\\dagger}</span>. We conclude that <span class="math">[\\pi^{\\dagger}]_{1}</span> is a valid proof for <span class="math">[x^{\\dagger}]_{1}\\notin\\text{Im}([U_{S}]_{1})</span> and <span class="math">\\mathcal{B}_{S}</span> breaks soundness of Kiltz and Wee construction. ∎</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">Consider construction from Fig. 4 with a statement of the form \\[ \\begin{pmatrix}[x]_{1}\\\\ [y]_{1}\\end{pmatrix} \\], matrix \\[ \\begin{pmatrix}U\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V\\end{pmatrix} \\], locality parameter <span class="math">L\\leq(d,d)\\in\\mathbb{N}^{2}</span> and extraction set $S=(S_{1},S_{2})\\subseteq([d],[d]),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L<span class="math">, such that the </span>(U_{S_{1}}^{\\top},h)<span class="math">-MDDH assumption is hard for some function </span>h<span class="math">. Assume also </span>K\\leftarrow\\mathbb{Z}_{p}^{L_{1}+L_{2}+2k\\times k}<span class="math">, </span>G=\\begin{pmatrix}G_{1}&0\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">0&G_{2}\\end{pmatrix}<span class="math">, where </span>G_{i}\\leftarrow\\text{\\tt CS.KeyGen}(gk,d,L_{i},S_{i})<span class="math">, and </span>A\\leftarrow\\mathbb{Z}_{p}^{k\\times k},k\\geq 2<span class="math">. Then construction from Fig. 4 is also a quasi argument for the relations </span>\\mathcal{KL}_{\\rho}^{\\text{\\tt yes}}=\\mathcal{KL}_{\\rho}^{\\text{\\tt yes}}<span class="math"> and </span>\\mathcal{KL}_{\\rho}^{\\text{\\tt no}}=\\{[c]_{1},[d]_{1},[x^{<em>}]_{1},[y^{</em>}]_{1},w^{<em>}:\\quad(\\begin{smallmatrix}c\\\\ d\\end{smallmatrix})\\ \\text{\\tt S-open to}\\ \\begin{pmatrix}x^{</em>}\\\\ y^{<em>}\\end{pmatrix}\\ \\text{and}\\ x^{</em>}=U_{S_{1}}w^{<em>}\\ \\text{but}\\ y^{</em>}\\neq V_{S_{2}}w^{*}\\}<span class="math">, with </span>h_{\\text{\\tt is}}<span class="math">-strong local soundness where </span>h_{\\text{\\tt is}}(\\theta)=(h(U_{S_{1}}^{\\top}),G,U_{S_{2}}^{\\top})$.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In <em>[x12]</em> it is shown that Kiltz and Wee argument is also a knowledge transfer argument whenever the <span class="math">U^{\\top}</span>-MDDH assumption (<span class="math">U_{S_{1}}^{\\top}</span>-MDDH in this case) holds and <span class="math">A</span> is not full rank. Of course, this is still true if the stronger <span class="math">(U_{S}^{\\top},h)</span>-MDDH assumption holds. However in construction of fig. 4 <span class="math">A</span> is full rank with overwhelming probability. Nevertheless, if <span class="math">A</span> is uniform and <span class="math">k\\geq 2</span> we can jump to a game (relying on the DDH assumption) where <span class="math">A\\in\\mathbb{Z}_{p}^{k\\times k}</span> is not full rank. Then the reduction of Thm. 8 yields also a reduction to the knowledge transfer of <em>[x15]</em> (taking <span class="math">\\begin{pmatrix}T_{1}\\\\ T_{2}\\end{pmatrix}</span> as trapdoor, where <span class="math">T_{i}</span> is the trapdoor for <span class="math">G_{i}</span>). ∎</p>

    <p class="text-gray-300">The proof that QALin is oblivious essentially follows from the oblivious trapdoor generation and index set hiding of SSB commitments. Before proving oblivious trapdoor generation we present a lemma stating that we can also compute <span class="math">\\rho</span>, crs knowing only the commitment key <span class="math">[\\mathbf{G}]_{1}</span> and <span class="math">\\mathbf{U}</span>, in both simple and knowledge transfer schemes.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">There exists a modified crs generation algorithm <span class="math">\\mathsf{K}^{\\prime}</span> that on input <span class="math">(\\rho,\\theta^{\\prime})</span>, where <span class="math">\\theta^{\\prime}</span> contains only <span class="math">\\mathbf{U}</span> (resp. <span class="math">\\mathbf{U},\\mathbf{V}</span>) outputs a crs such that <span class="math">(\\rho,\\mathsf{crs})</span> are identically distributed to the honest algorithm.</p>

    <p class="text-gray-300">The lemma follows directly by noting that <span class="math">[\\mathbf{B}]_{1}=[\\mathbf{U}^{\\top}]_{1}\\mathbf{G}\\mathbf{K}=\\mathbf{U}^{\\top}[\\mathbf{G}]_{1}\\mathbf{K}</span>. (resp. <span class="math">[\\mathbf{B}]_{1}=[\\mathbf{U}^{\\top}\\mid\\mathbf{V}^{\\top}]_{1}\\mathbf{G}\\mathbf{K}=(\\mathbf{U}^{\\top}\\mid\\mathbf{V}^{\\top})[\\mathbf{G}]_{1}\\mathbf{K}</span>. Given that this result holds, we slightly abuse notation and refer to <span class="math">\\mathsf{K}^{\\prime}(\\rho,\\theta^{\\prime})</span> as <span class="math">\\mathsf{K}(\\rho,\\theta^{\\prime})</span>, that is we use the same name for the honest and the simulated algorithm.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{U}</span> (resp. <span class="math">\\mathcal{U},\\mathcal{V}</span> for the knowledge transfer case) be a witness samplable distribution, and <span class="math">\\mathsf{CS}</span> be an algebraic SSB commitment scheme with perfect completeness, <span class="math">h</span>-strong index set hiding and oblivious trapdoor generation. Then Construction QALin of Fig. 4 (resp. construction <span class="math">\\Pi</span> of corollary 2) is <span class="math">h_{\\mathsf{ns}}</span>-strong oblivious where <span class="math">h_{\\mathsf{ns}}=(h(sk),\\mathbf{U})</span> (resp. <span class="math">h_{\\mathsf{ns}}=(h(sk),\\mathbf{U},\\mathbf{V})</span>). Furthermore,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every PPT <span class="math">\\mathcal{A}</span> against <span class="math">h_{\\mathsf{ns}}</span>-strong index set hiding of <span class="math">\\Pi</span>, there exists an adversary <span class="math">\\mathcal{B}</span> against <span class="math">h</span>-strong index set hiding property of <span class="math">\\mathsf{CS}</span>, such that <span class="math">\\mathsf{Adv}^{\\Pi}_{\\mathsf{ISH}}(\\mathcal{A})\\leq\\mathsf{Adv}^{\\mathsf{CS}}_{\\mathsf{ISH}}(\\mathcal{B})</span> where <span class="math">h_{\\mathsf{ns}}(\\theta)=(h(sk),\\mathbf{U})</span>.</li>

      <li>For every <span class="math">\\mathcal{A}</span> against oblivious trapdoor generation of <span class="math">\\Pi</span>, there exists an adversary <span class="math">\\mathcal{B}</span> against oblivious trapdoor generation of <span class="math">\\mathsf{CS}</span>, such that <span class="math">\\mathsf{Adv}^{\\Pi}_{\\mathsf{oblv}}(\\mathcal{A})\\leq\\mathsf{Adv}^{\\mathsf{CS}}_{\\mathsf{oblv}}(\\mathcal{B})</span>.</li>

    </ol>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For index set hiding, it is enough to notice that in both cases, the crs of <span class="math">\\Pi</span> can be efficiently computed given only <span class="math">ck=([\\mathbf{G}]_{1},h(\\mathbf{G}))</span>. Indeed by sampling <span class="math">[\\mathbf{U}]_{1},\\mathbf{U}\\leftarrow\\mathcal{U}</span> (resp. <span class="math">[\\mathbf{U}]_{1},\\mathbf{U}\\leftarrow\\mathcal{U}</span>; <span class="math">[\\mathbf{V}]_{1},\\mathbf{V}\\leftarrow\\mathcal{V}</span>) all values of crs are efficiently computable, as noted in the previous lemma. Additionally, since we assume <span class="math">\\mathsf{CS}</span> is <span class="math">h</span>-strong <span class="math">\\mathsf{ISH}</span>, <span class="math">\\mathcal{A}</span> can be also given <span class="math">h_{\\mathsf{ns}}(\\theta)=(h(sk),\\mathbf{U})</span> (resp. <span class="math">h_{\\mathsf{ns}}(\\theta)=(h(sk),\\mathbf{U},\\mathbf{V})</span>). Thus, a distinguishing advantage in index set hiding of <span class="math">\\Pi</span> immediately implies equal advantage on the respective property of <span class="math">\\mathsf{CS}</span>.</p>

    <p class="text-gray-300">For oblivious trapdoor generation we first describe the OblSetup algorithm. Let <span class="math">S^{\\prime}\\subseteq S</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{OblSetup}(\\rho=([\\mathbf{G}]_{1},[\\mathbf{U}]_{1}),\\mathsf{crs})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([\\mathbf{G}^{\\prime}]_{1},\\mathbf{T}^{\\prime})\\leftarrow\\mathsf{CS.OblSetup}(gk,d,K,S,ck=[\\mathbf{G}]_{1})</span>.</li>

      <li><span class="math">([\\mathbf{U}]_{1},\\mathbf{U})\\leftarrow\\mathcal{U}</span> (resp. <span class="math">([\\mathbf{U}]_{1},\\mathbf{U})\\leftarrow\\mathcal{U}</span>; <span class="math">([\\mathbf{V}]_{1},\\mathbf{V})\\leftarrow\\mathcal{U}</span>).</li>

      <li><span class="math">(\\mathsf{crs},\\tau)\\leftarrow\\Pi.\\mathsf{K}(\\rho,\\theta^{\\prime}=\\mathbf{U})</span> (resp. <span class="math">(\\mathsf{crs},\\tau)\\leftarrow\\Pi.\\mathsf{K}(\\rho,\\theta^{\\prime}=(\\mathbf{U},\\mathbf{V}))</span>).</li>

    </ul>

    <p class="text-gray-300">Note that the only difference in sampling with <span class="math">S</span> and with <span class="math">S^{\\prime}</span> is how we sample the commitment key <span class="math">\\mathbf{G}</span>. The crs part <span class="math">\\mathsf{crs}</span> is identically distributed to an honest one by Lemma 1. Finally, by the statistically binding property of the commitment key the extracted witness for <span class="math">S</span> and <span class="math">S^{\\prime}</span> are unique and thus do not help the (unbounded) distinguisher, who can compute them on its own.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Corollary 3.</h6>

    <p class="text-gray-300">When <span class="math">\\mathsf{CS}</span> is the one from fig. 3, then <span class="math">\\Pi</span> from fig. 4 (resp. corollary 2) is <span class="math">h_{\\mathsf{ns}}</span>-strong no-signaling where <span class="math">h_{\\mathsf{ns}}(\\theta)=(h(sk),\\mathbf{U})</span> (resp. <span class="math">h_{\\mathsf{ns}}(\\theta)=(h(sk),\\mathbf{U},\\mathbf{V})</span>).</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows directly from Theorem 7 and the <span class="math">h_{\\mathsf{ns}}</span>-strong <span class="math">\\mathsf{ISH}</span> of QALin, which in turn follows from Theorem 9. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Extensions.</p>

    <p class="text-gray-300">We consider several extensions of QALin such as bilateral linear spaces <em>[x13]</em>, where the statement as well as the generating matrix have components in both groups. We also consider a sum argument <em>[x13]</em> which is akin to a bilateral language but one shows that the sum of the discrete logs of two vectors in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> belong to the image of the sum of two matrices in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span>. Finally, we extend local soundness to consider knowledge transfer arguments. The security of all this extensions is almost verbatim of theorems 8 and 9.</p>

    <h4 id="sec-65" class="text-lg font-semibold mt-6">Quasi Argument for Bilateral Linear Knowledge Transfer.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathcal{M},\\mathcal{N}_{1},\\mathcal{N}_{2}</span> be <span class="math">3</span> witness samplable distribution over matrices in <span class="math">\\mathbb{G}_{1}^{d\\times n}</span>, <span class="math">\\mathbb{G}_{1}^{d\\times n}</span> and <span class="math">\\mathbb{G}_{2}^{d\\times n}</span>, respectively, for <span class="math">n,d\\in\\mathbb{N}</span>. Let <span class="math">\\bm{K}\\leq d</span> where <span class="math">\\bm{K}=(K_{1},K_{2})</span> and <span class="math">\\bm{S}\\subseteq([d],[d])</span> where <span class="math">S=S_{1}\\cup S_{2}</span> and <span class="math">\\bm{S}\\leq\\bm{K}</span> Let CS be an algebraic SSB commitment schemes with commitment space <span class="math">\\mathbb{G}_{\\mu}^{\\overline{K}}</span>, where <span class="math">\\mathbb{G}_{\\mu}</span> is defined by the input <span class="math">gk</span>. The parameter language is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\text{par}}=\\left\\{[\\mathbf{M}]_{1},[\\mathbf{N}_{1}]_{1},[\\mathbf{N}_{2}]_{2},[\\mathbf{G}]_{1},[\\mathbf{H}]_{1},[\\mathbf{F}]_{2}\\mid\\exists\\mathbf{M},\\mathbf{N}_{1},\\mathbf{N}_{2},\\mathbf{G},\\mathbf{H},\\mathbf{F}\\text{ s.t.}\\right.</span> <span class="math">\\left.([\\mathbf{M}]_{1},\\mathbf{M}),([\\mathbf{N}_{1}]_{1},\\mathbf{N}_{2}),([\\mathbf{N}_{2}]_{2},\\mathbf{N}_{2})\\in\\text{Sup}(\\mathcal{M},\\mathcal{N}_{1},\\mathcal{N}_{2}),\\right.</span> <span class="math">\\left.([\\mathbf{G}]_{1},\\mathbf{G},\\mathbf{T}_{\\mathbf{G}})\\in\\text{Sup}(\\text{CS.KeyGen}(gk_{1},d,K_{1},S_{1})),\\right.</span> <span class="math">\\left.([\\mathbf{H}]_{1},\\mathbf{H},\\mathbf{T}_{\\mathbf{H}})\\in\\text{Sup}(\\text{CS.KeyGen}(gk_{1},d,K_{2},S_{2})),\\right.</span> <span class="math">\\left.([\\mathbf{F}]_{2},\\mathbf{F},\\mathbf{T}_{\\mathbf{F}})\\in\\text{Sup}(\\text{CS.KeyGen}(gk_{2},d,K_{2},S_{2}))\\right\\}</span></p>

    <p class="text-gray-300">We assume w.l.o.g. that the corresponding relation is efficiently verifiable.The parameters <span class="math">\\rho=([\\mathbf{M}]_{1},[\\mathbf{N}_{1}]_{1},[\\mathbf{N}_{2}]_{2},[\\mathbf{G}]_{1},[\\mathbf{H}]_{1},[\\mathbf{F}]_{2})</span>, define the following relations:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\rho}^{\\text{yes}}=\\left\\{\\ \\ [\\bm{c}]_{1},[\\bm{d}_{1}]_{1},[\\bm{d}_{2}]_{2},\\bm{w}\\ \\ \\ \\left(\\ \\ \\ \\bm{c}\\atop\\bm{d}_{1}\\atop\\bm{d}_{2}\\right)=\\left(\\ \\ \\ \\mathbf{GM}\\atop\\bm{HN_{1}}\\atop\\bm{FN_{2}}\\right)\\bm{w}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\right\\},</span> $\\mathcal{R}_{\\rho,S}^{\\text{no}}=\\left\\{\\ \\ \\left([\\bm{c}]_{1},[\\bm{d}_{1}]_{1},[\\bm{d}_{2}]_{2}),\\bm{w},\\right.\\ \\ \\ \\left.\\ \\ \\ \\left(\\ \\ \\bm{c}\\atop\\bm{d}_{1}\\atop\\bm{d}_{2}\\right)\\right.\\ \\ \\ \\left.\\ \\ \\ \\left(\\ \\ \\bm{c},\\bm{d}_{1},\\bm{d}_{2}\\text{ w.r.t. }\\mathbf{G},\\mathbf{H},\\mathbf{F}\\text{ respectively and }\\right.\\right.\\ \\ \\ \\left.\\ \\ \\ \\left.\\ \\ \\ \\left.\\bm{x}_{1}=\\mathbf{M}_{S_{1}}\\bm{w}\\text{ but }\\bm{y}_{1}\\neq\\mathbf{N}_{1,S_{2}}\\bm{w}\\text{ or }\\bm{y}_{2}\\neq\\mathbf{N}_{2,S_{2}}\\bm{w}\\right.\\right.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\ \\right.\\</p>

    <p class="text-gray-300">Proof. For completeness, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\boldsymbol{c}^{\\top} \\mid \\boldsymbol{d}_{1}^{\\top}\\right) \\mathbf{C}_{1} + \\boldsymbol{d}_{2}^{\\top} \\mathbf{C}_{2} = \\left(\\boldsymbol{c}^{\\top} \\mid \\boldsymbol{d}_{1}^{\\top}\\right) \\binom{\\mathbf{K}_{1}}{\\mathbf{K}_{2}} \\mathbf{A} + \\boldsymbol{d}_{2}^{\\top} \\mathbf{K}_{2} \\mathbf{A} \\\\ = \\left(\\boldsymbol{c}^{\\top} \\mathbf{K}_{1} + \\boldsymbol{d}_{1}^{\\top} \\mathbf{K}_{2} + \\boldsymbol{d}_{2}^{\\top} \\mathbf{K}_{2}\\right) \\mathbf{A} \\\\ = \\left(\\boldsymbol{w}^{\\top} \\mathbf{M}^{\\top} \\mathbf{G}^{\\top} \\mathbf{K}_{1} + \\boldsymbol{w}^{\\top} \\mathbf{N}_{1}^{\\top} \\mathbf{H}^{\\top} \\mathbf{K}_{2} + \\boldsymbol{w}^{\\top} \\mathbf{N}_{2}^{\\top} \\mathbf{F}^{\\top} \\mathbf{K}_{2}\\right) \\mathbf{A} \\\\ = \\left(\\boldsymbol{w}^{\\top} \\left(\\mathbf{M}^{\\top} \\mathbf{G}^{\\top} \\mathbf{K}_{1} + \\mathbf{N}_{1}^{\\top} \\mathbf{H}^{\\top} \\mathbf{K}_{2}\\right) + \\boldsymbol{w}^{\\top} \\mathbf{N}_{2}^{\\top} \\mathbf{F}^{\\top} \\mathbf{K}_{2}\\right) \\mathbf{A} \\\\ = \\boldsymbol{w}^{\\top} \\mathbf{B} \\mathbf{A} + \\boldsymbol{w}^{\\top} \\mathbf{D} \\mathbf{A} \\\\ = \\pi \\mathbf{A} + \\theta \\mathbf{A} \\end{array}</span></div>

    <p class="text-gray-300">Local Extractability follows using almost an identical argument to Thm. 8 and reducing to knowledge transfer of linear KTA Argument of [GR19] presented in Fig. 1. Given an adversary <span class="math">\\mathcal{A}</span> breaking <span class="math">h_{\\mathrm{ls}}</span>-Strong local knowledge soundness of QABlin we construct another adversary <span class="math">\\mathcal{B}_S</span> that breaks <span class="math">h</span>-strong soundness of the argument <span class="math">\\Pi_{\\mathrm{ld - lin}}</span> for matrices <span class="math">[\\mathbf{M}_{S_1}]_1, [\\mathbf{N}_{1,S_2}]_1</span> and <span class="math">[\\mathbf{N}_{2,S_2}]_2</span>. <span class="math">\\mathcal{B}_S</span> works as follows: it takes input <span class="math">(\\rho^{\\dagger}, h(\\theta^{\\dagger}), \\mathrm{crs}^{\\dagger})</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\rho^{\\dagger} := \\left(g k, \\left[ \\mathbf{M}_{S_{1}} \\right]_{1}, \\left[ \\mathbf{N}_{1,S_{2}} \\right]_{1}, \\left[ \\mathbf{N}_{2,S_{2}} \\right]_{2}\\right), \\quad h \\left(\\theta^{\\dagger}\\right) := \\left(\\mathbf{N}_{1,S_{2}}, \\mathbf{N}_{2,S_{2}}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{crs}^{\\dagger} := \\left(\\left[ \\mathbf{B}^{\\dagger} \\right]_{1}, \\left[ \\mathbf{D}^{\\dagger} \\right]_{2}, \\left[ \\mathbf{A} \\right]_{1,2}, \\left[ \\mathbf{C}_{1}^{\\dagger} \\right]_{2}, \\left[ \\mathbf{C}_{2}^{\\dagger} \\right]_{1}\\right)</span></div>

    <p class="text-gray-300">and does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\left([ \\mathbf{G} ]_{1}, \\mathbf{G}, \\mathbf{T}_{\\mathbf{G}}\\right) \\leftarrow \\text{CS.KGen}(g k_{1}, d, K_{1}, S_{1})</span>.</li>

      <li><span class="math">\\left([ \\mathbf{H} ]_{1}, \\mathbf{H}, \\mathbf{T}_{\\mathbf{H}}\\right) \\leftarrow \\text{CS.KGen}(g k_{1}, d, K_{2}, S_{2})</span>.</li>

      <li><span class="math">\\left([ \\mathbf{F} ]_{2}, \\mathbf{F}, \\mathbf{T}_{\\mathbf{F}}\\right) \\leftarrow \\text{CS.KGen}(g k_{2}, d, K_{2}, S_{2})</span>.</li>

      <li>It samples <span class="math">\\mathbf{M}_{\\widetilde{S}_1}, \\mathbf{N}_{1,\\widetilde{S}_2}, \\mathbf{N}_{2,\\widetilde{S}_2}</span>, such that <span class="math">\\mathbf{M} = \\mathbf{P}_{S_1} \\begin{pmatrix} \\mathbf{M}_{S_1} \\\\ \\mathbf{M}_{\\widetilde{S}_1} \\end{pmatrix}, \\mathbf{N}_1 = \\mathbf{P}_{S_2} \\begin{pmatrix} \\mathbf{N}_{1,S_2} \\\\ \\mathbf{N}_{1,\\widetilde{S}_2} \\end{pmatrix}, \\mathbf{N}_2 = \\mathbf{P}_{S_2} \\begin{pmatrix} \\mathbf{N}_{2,S_2} \\\\ \\mathbf{N}_{2,\\widetilde{S}_2} \\end{pmatrix}</span>.</li>

      <li><span class="math">\\mathbf{R}_0 \\leftarrow \\mathbb{Z}_p^{\\widetilde{K}_0 \\times k}; \\mathbf{R}_1 \\leftarrow \\mathbb{Z}_p^{\\widetilde{K}_1 \\times k}; \\mathbf{R}_2 \\leftarrow \\mathbb{Z}_p^{\\widetilde{K}_2 \\times k}</span>.</li>

      <li>It computes <span class="math">[\\mathbf{B}]_1 := [\\mathbf{B}^\\dagger]_1 + [\\mathbf{M}]_1^\\top \\mathbf{G}^\\top \\mathbf{R}_0 + [\\mathbf{N}_1]_1^\\top \\mathbf{H}^\\top \\mathbf{R}_1</span> and <span class="math">[\\mathbf{D}]_2 := [\\mathbf{D}^\\dagger]_2 + [\\mathbf{N}_2]_2^\\top \\mathbf{F}^\\top \\mathbf{R}_2</span>.</li>

      <li>It computes <span class="math">[\\mathbf{C}_1]_2 := \\begin{pmatrix} \\mathbf{T}_{\\mathbf{G}} &amp;amp; \\mathbf{0} \\\\ \\mathbf{0} &amp;amp; \\mathbf{T}_{\\mathbf{H}} \\end{pmatrix} [\\mathbf{C}_1^\\dagger]_2 + \\begin{pmatrix} \\mathbf{R}_0 \\\\ \\mathbf{R}_1 \\end{pmatrix} [\\mathbf{A}]_2</span> and <span class="math">[\\mathbf{C}_2]_1 := \\mathbf{T}_{\\mathbf{F}} [\\mathbf{C}_2^\\dagger]_1 + \\mathbf{R}_2 [\\mathbf{A}]_1</span>.</li>

      <li>It sets</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\rho := \\left([ \\mathbf{G} ]_{1}, [ \\mathbf{H} ]_{1}, [ \\mathbf{F} ]_{2}, [ \\mathbf{M} ]_{1}, [ \\mathbf{N}_{1} ]_{1}, [ \\mathbf{N}_{2} ]_{2}\\right), \\quad h_{\\mathrm{ls}}(\\theta) := (\\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{N}_{1}, \\mathbf{N}_{2})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{crs} := \\left([ \\mathbf{B} ]_{1}, [ \\mathbf{D} ]_{2}, [ \\mathbf{A} ]_{1,2}, [ \\mathbf{C}_{1} ]_{2}, [ \\mathbf{C}_{2} ]_{1}\\right)</span></div>

    <p class="text-gray-300">It then executes <span class="math">\\mathcal{A}(\\rho, h_{\\mathrm{ls}}(\\theta), \\mathrm{crs})</span> until it outputs a statement <span class="math">([c]_1, [d_1]_1, [d_2]_2, w)</span> together with an accepting proof <span class="math">[\\pi]_1, [\\theta]_2</span>. Given an accepting proof <span class="math">\\mathcal{B}_S</span> sets <span class="math">[x^\\dagger]_1 = \\mathbf{T}_{\\mathbf{G}}[c]_1, [y_1^\\dagger]_1 = \\mathbf{T}_{\\mathbf{H}}[d_1]_1, [y_2^\\dagger]_2 = \\mathbf{T}_{\\mathbf{F}}[d_2]_2, [\\pi^\\dagger]_1 = [\\pi]_1 - [c]_1^\\top \\mathbf{R}_0 - [d_1]_1^\\top \\mathbf{R}_1</span> and <span class="math">[\\theta^\\dagger]_2 = [\\theta]_1 - [d_2]_2^\\top \\mathbf{R}_2</span>. It outputs <span class="math">\\left(([x^\\dagger]_1, [y_1^\\dagger]_1, [y_2^\\dagger]_2\\right), w, ([\\pi^\\dagger]_1, [\\theta^\\dagger]_2)</span>.</p>

    <p class="text-gray-300">Note that the commitment keys are perfectly binding at <span class="math">S</span>. First, we claim that in this case the values <span class="math">\\rho, h_{\\mathrm{ls}}(\\theta)</span>, <span class="math">\\mathrm{crs}</span> output by <span class="math">\\mathcal{B}_S</span> are identically distributed to honestly computed ones and thus do not skew the probability that <span class="math">\\mathcal{A}</span> outputs a valid proof. For <span class="math">\\rho, h_{\\mathrm{ls}}(\\theta)</span>, this is immediate by the witness samplability of the distributions <span class="math">\\mathcal{M}, \\mathcal{N}_1, \\mathcal{N}_2</span>. We show that this holds for <span class="math">\\mathrm{crs}</span> as well.</p>

    <p class="text-gray-300">43</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\mathbf{K}_0^\\dagger \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k},\\mathbf{K}_1^\\dagger \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k},\\mathbf{K}_2^\\dagger \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k}<span class="math"> be the implicit values used to compute </span>\\mathsf{crs}^\\dagger$, that is, they satisfy</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} ^ {\\dagger} = \\mathbf {M} _ {S} ^ {\\top} \\mathbf {K} _ {0} ^ {\\dagger} + \\mathbf {N} _ {1, S} ^ {\\top} \\mathbf {K} _ {1} ^ {\\dagger}, \\mathbf {D} ^ {\\dagger} = \\mathbf {N} _ {2, S} ^ {\\top} \\mathbf {K} _ {2} ^ {\\dagger}, \\mathbf {C} _ {1} ^ {\\dagger} = \\left( \\begin{array}{c} \\mathbf {K} _ {0} ^ {\\dagger} \\\\ \\mathbf {K} _ {1} ^ {\\dagger} \\end{array} \\right) \\mathbf {A} \\text{ and } \\mathbf {C} _ {2} ^ {\\dagger} = \\mathbf {K} _ {2} ^ {\\dagger} \\mathbf {A}.</span></div>

    <p class="text-gray-300">Now <span class="math">\\mathcal{B}_S</span> implicitly defines <span class="math">\\mathbf{K}_2 = \\mathbf{T}_{\\mathbf{G}}\\mathbf{K}_0^\\dagger + \\mathbf{R}_0</span>, <span class="math">\\mathbf{K}_2 = \\mathbf{T}_{\\mathbf{H}}\\mathbf{K}_1^\\dagger + \\mathbf{R}_1</span>, <span class="math">\\mathbf{K}_2 = \\mathbf{T}_{\\mathbf{F}}\\mathbf{K}_2^\\dagger + \\mathbf{R}_2</span>. First, note that these matrices are uniformly distributed since <span class="math">\\mathbf{R}_0, \\mathbf{R}_1, \\mathbf{R}_2</span> are uniformly distributed. Thus <span class="math">\\mathbf{K}_1, \\mathbf{K}_2, \\mathbf{K}_2</span> are distributed identically to honestly generated values for generating a crs. We claim that the crs output by <span class="math">\\mathcal{A}</span> is identically distributed to sampling this matrix and computing the other values honestly. Indeed we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {B} = \\mathbf {B} ^ {\\dagger} + \\mathbf {M} ^ {\\top} \\mathbf {G} ^ {\\top} \\mathbf {R} _ {0} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {R} _ {1} \\\\ = \\mathbf {M} _ {S _ {1}} ^ {\\top} \\mathbf {K} _ {1} ^ {\\dagger} + \\mathbf {N} _ {1, S _ {2}} ^ {\\top} \\mathbf {K} _ {2} ^ {\\dagger} + \\mathbf {M} ^ {\\top} \\mathbf {G} ^ {\\top} \\mathbf {R} _ {0} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {R} _ {1} \\\\ = \\mathbf {M} ^ {\\top} \\mathbf {G} ^ {\\top} \\mathbf {T} _ {\\mathbf {G}} \\mathbf {K} _ {1} ^ {\\dagger} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {T} _ {\\mathbf {H}} ^ {\\top} \\mathbf {K} _ {2} ^ {\\dagger} + \\mathbf {M} ^ {\\top} \\mathbf {G} ^ {\\top} \\mathbf {R} _ {0} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {R} _ {1} \\\\ = \\mathbf {M} ^ {\\top} \\mathbf {G} ^ {\\top} \\left(\\mathbf {T} _ {\\mathbf {G}} \\mathbf {K} _ {1} ^ {\\dagger} + \\mathbf {R} _ {0}\\right) + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\left(\\mathbf {T} _ {\\mathbf {H}} ^ {\\top} \\mathbf {K} _ {2} ^ {\\dagger} + \\mathbf {R} _ {1}\\right) \\\\ = \\mathbf {M} ^ {\\top} \\mathbf {G} ^ {\\top} \\mathbf {K} _ {1} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {K} _ {2} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where the third equality follows since by the local extractability of the SSBs we have that <span class="math">\\mathbf{T}_{\\mathbf{G}}^{\\top}\\mathbf{G}\\mathbf{M} = \\mathbf{M}_{S_1}</span>, <span class="math">\\mathbf{T}_{\\mathbf{H}}^{\\top}\\mathbf{H}\\mathbf{N}_1 = \\mathbf{N}_{1,S_2}</span>. Similarly, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {D} = \\mathbf {D} ^ {\\dagger} + \\mathbf {N} _ {2} ^ {\\top} \\mathbf {F} ^ {\\top} \\mathbf {R} _ {2} \\\\ = \\mathbf {N} _ {2, S _ {2}} ^ {\\top} \\mathbf {K} _ {3} ^ {\\dagger} + \\mathbf {N} _ {2} ^ {\\top} \\mathbf {F} ^ {\\top} \\mathbf {R} _ {2} \\\\ = \\mathbf {N} _ {2} ^ {\\top} \\mathbf {F} ^ {\\top} \\mathbf {T} _ {\\mathbf {F}} \\mathbf {K} _ {2} ^ {\\dagger} + \\mathbf {N} _ {2} ^ {\\top} \\mathbf {F} ^ {\\top} \\mathbf {R} _ {2} \\\\ = \\mathbf {N} _ {2} ^ {\\top} \\mathbf {F} ^ {\\top} \\left(\\mathbf {T} _ {\\mathbf {F}} \\mathbf {K} _ {2} ^ {\\dagger} + \\mathbf {R} _ {2}\\right) \\\\ = \\mathbf {N} _ {2} ^ {\\top} \\mathbf {F} ^ {\\top} \\mathbf {K} _ {2} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Also, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {C} _ {1} = \\left( \\begin{array}{c c} \\mathbf {T} _ {\\mathbf {G}} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {T} _ {\\mathbf {H}} \\end{array} \\right) \\mathbf {C} _ {1} ^ {\\dagger} + \\left( \\begin{array}{c} \\mathbf {R} _ {0} \\\\ \\mathbf {R} _ {1} \\end{array} \\right) \\mathbf {A} = \\left( \\begin{array}{c c} \\mathbf {T} _ {\\mathbf {G}} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {T} _ {\\mathbf {H}} \\end{array} \\right) \\left( \\begin{array}{c} \\mathbf {K} _ {1} ^ {\\dagger} \\\\ \\mathbf {K} _ {2} ^ {\\dagger} \\end{array} \\right) \\mathbf {A} + \\left( \\begin{array}{c} \\mathbf {R} _ {0} \\\\ \\mathbf {R} _ {1} \\end{array} \\right) \\mathbf {A} = \\left( \\begin{array}{c} \\mathbf {T} _ {\\mathbf {G}} \\mathbf {K} _ {1} ^ {\\dagger} + \\mathbf {R} _ {0} \\\\ \\mathbf {T} _ {\\mathbf {H}} \\mathbf {K} _ {2} ^ {\\dagger} + \\mathbf {R} _ {1} \\end{array} \\right) \\mathbf {A} = \\left( \\begin{array}{c} \\mathbf {K} _ {1} \\\\ \\mathbf {K} _ {2} \\end{array} \\right) \\mathbf {A} \\\\ \\mathbf {C} _ {2} = \\mathbf {T} _ {\\mathbf {F}} \\mathbf {C} _ {2} ^ {\\dagger} + \\mathbf {R} _ {2} \\mathbf {A} = \\mathbf {T} _ {\\mathbf {F}} \\mathbf {K} _ {2} ^ {\\dagger} \\mathbf {A} + \\mathbf {R} _ {2} \\mathbf {A} = (\\mathbf {T} _ {\\mathbf {F}} \\mathbf {K} _ {2} ^ {\\dagger} + \\mathbf {R} _ {2}) \\mathbf {A} = \\mathbf {K} _ {2} \\mathbf {A} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">so the outputted crs is indeed identically distributed to an honest one.</p>

    <p class="text-gray-300">Then, we show that <span class="math">\\mathcal{B}</span> outputs a valid statement-proof pair w.r.t. to <span class="math">\\mathsf{crs}^{\\dagger}</span>. Since the commitment keys are extractable and perfectly binding at <span class="math">S</span>, we have that <span class="math">\\boldsymbol{x}^{\\dagger}</span>, <span class="math">\\boldsymbol{y}_1^{\\dagger}</span> and <span class="math">\\boldsymbol{y}_2^{\\dagger}</span> are valid openings for the commitments given. Assuming <span class="math">\\mathcal{A}</span> produces a valid statement for <span class="math">\\mathcal{R}_{p,S}^{\\infty}</span>, for the extracted values it holds that <span class="math">\\boldsymbol{x}^{\\dagger} = \\mathbf{M}_{S_1}\\boldsymbol{w}</span> and either <span class="math">\\boldsymbol{y}_1^{\\dagger} \\neq \\mathbf{N}_{1,S_2}\\boldsymbol{w}</span> or <span class="math">\\boldsymbol{y}_2^{\\dagger} \\neq \\mathbf{N}_{2,S_2}\\boldsymbol{w}</span>. Thus, <span class="math">\\mathcal{B}_S</span> outputs a valid statement and it suffices to show that <span class="math">[\\pi^{\\dagger}]_1, [\\theta^{\\dagger}]_2</span> is a valid proof. Indeed, we</p>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">have that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\mathbf{0} = \\pi \\mathbf{A} + \\theta \\mathbf{A} - \\left(\\boldsymbol{c}^{\\top} \\mid \\boldsymbol{d}_{1}^{\\top}\\right) \\mathbf{C}_{1} - \\boldsymbol{d}_{2}^{\\top} \\mathbf{C}_{2} \\\\ = (\\pi^{\\dagger} + \\boldsymbol{c}^{\\top} \\mathbf{R}_{0} + \\boldsymbol{d}_{1}^{\\top} \\mathbf{R}_{1}) \\mathbf{A} + (\\theta^{\\dagger} + \\boldsymbol{d}_{2}^{\\top} \\mathbf{R}_{2}) \\mathbf{A} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left(\\boldsymbol{c}^{\\top} \\mid \\boldsymbol{d}_{1}^{\\top}\\right) \\left( \\left( \\begin{array}{cc} \\mathbf{T}_{\\mathbf{G}} &amp; \\mathbf{0} \\\\ \\mathbf{0} &amp; \\mathbf{T}_{\\mathbf{H}} \\end{array} \\right) \\mathbf{C}_{1}^{\\dagger} + \\left( \\begin{array}{c} \\mathbf{R}_{0} \\\\ \\mathbf{R}_{1} \\end{array} \\right) \\mathbf{A} \\right) \\\\</li>

      <li>\\boldsymbol{d}_{2}^{\\top} \\left(\\mathbf{T}_{\\mathbf{F}} \\mathbf{C}_{2}^{\\dagger} + \\mathbf{R}_{2} \\mathbf{A} \\right) \\\\</li>

    </ul>

    <p class="text-gray-300">= (\\pi^{\\dagger} + \\boldsymbol{c}^{\\top} \\mathbf{R}_{0} + \\boldsymbol{d}_{1}^{\\top} \\mathbf{R}_{2}) \\mathbf{A} + (\\theta^{\\dagger} + \\boldsymbol{d}_{2}^{\\top} \\mathbf{R}_{2}) \\mathbf{A} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left(\\boldsymbol{c}^{\\top} \\mathbf{T}_{\\mathbf{G}} \\mid \\boldsymbol{d}_{1}^{\\top} \\mathbf{T}_{\\mathbf{H}}\\right) \\mathbf{C}_{1}^{\\dagger} - \\left(\\boldsymbol{c}^{\\top} \\mathbf{R}_{0} - \\boldsymbol{d}_{1}^{\\top} \\mathbf{R}_{1}\\right) \\mathbf{A} \\\\</li>

      <li>\\boldsymbol{d}_{2}^{\\top} \\mathbf{T}_{\\mathbf{F}} \\mathbf{C}_{2}^{\\dagger} - \\boldsymbol{d}_{2}^{\\top} \\mathbf{R}_{2} \\mathbf{A} \\\\</li>

    </ul>

    <p class="text-gray-300">= \\pi^{\\dagger} \\mathbf{A} + \\theta^{\\dagger} \\mathbf{A} - \\left(\\boldsymbol{c}^{\\top} \\mathbf{T}_{\\mathbf{G}} \\mid \\boldsymbol{d}_{1}^{\\top} \\mathbf{T}_{\\mathbf{H}}\\right) \\mathbf{C}_{1}^{\\dagger} - \\boldsymbol{d}_{2}^{\\top} \\mathbf{T}_{\\mathbf{F}} \\mathbf{C}_{2}^{\\dagger} \\\\ = \\pi^{\\dagger} \\mathbf{A} + \\theta^{\\dagger} \\mathbf{A} - \\left(\\boldsymbol{x}^{\\dagger}^{\\top} \\mid \\boldsymbol{y}_{1}^{\\dagger}^{\\top}\\right) \\mathbf{C}_{1}^{\\dagger} - \\boldsymbol{y}_{2}^{\\dagger}^{\\top} \\mathbf{C}_{2}^{\\dagger} \\end{array} $$</p>

    <p class="text-gray-300">and the last equation is the verification equation for the knowledge transfer argument for <span class="math">\\mathsf{crs}^{\\dagger}</span>.</p>

    <p class="text-gray-300">We next show that when the distribution <span class="math">\\mathcal{M}, \\mathcal{N}_1, \\mathcal{N}_2</span> guarantee that the linear knowledge transfer argument is secure w.r.t. all possible sets <span class="math">S</span>, construction QABlin has <span class="math">h_{\\mathrm{ls}}</span>-strong local knowledge soundness where <span class="math">h_{\\mathrm{ls}}</span> includes <span class="math">\\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{N}_1, \\mathbf{N}_2</span>, and some extra information about the matrix <span class="math">\\mathbf{M}</span>.</p>

    <p class="text-gray-300"><strong>Corollary 4.</strong> Let <span class="math">\\mathcal{D}_k</span> be a matrix distribution for which <span class="math">\\mathcal{D}_k</span>-SKerMDH. Denote <span class="math">\\mathcal{M}_S</span> (resp. <span class="math">\\mathcal{N}_{1,S}, \\mathcal{N}_{2,S}</span>) the distributions that sample matrices from <span class="math">\\mathcal{M}</span> (res. <span class="math">\\mathcal{N}_1, \\mathcal{N}_1</span>), and restricts them to rows corresponding to <span class="math">S</span>. Then</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If for all <span class="math">S_{1} \\subseteq [d]</span> with <span class="math">S_{1} \\leq K_{1}</span>, <span class="math">(\\mathcal{M}_{S_{1}}^{\\top}, h)</span>-MDDH holds, QABlin is an <span class="math">h_{\\mathrm{ls}}</span>-strong local knowledge sound proof system, where <span class="math">h_{\\mathrm{ls}}(\\theta) = (h(\\mathbf{M}_S), \\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{N}_1, \\mathbf{N}_2)</span>.</li>

      <li>If for all <span class="math">S_{1}, S_{2} \\subseteq [d]</span> with <span class="math">S_{1} \\leq K_{1}</span>, <span class="math">S_{2} \\leq K_{2}</span> the distributions <span class="math">\\mathcal{M}_{S_1}, \\mathcal{N}_{S_2}, \\mathcal{N}_{S_2}</span> output matrices with the last <span class="math">n&#x27;</span> columns being <span class="math">\\mathbf{0}</span>, and <span class="math">(\\mathcal{M}_{S_1}^{\\prime \\top}, h)</span>-MDDH holds, with <span class="math">\\mathcal{M}_{S_1}^{\\prime}</span> being <span class="math">\\mathcal{M}_{S_1}</span> where we delete the trailing zero columns, then QABlin is an <span class="math">h_{\\mathrm{ls}}</span>-strong local knowledge sound proof system, where <span class="math">h_{\\mathrm{ls}}(\\theta) = (h(\\mathbf{M}_S), \\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{N}_1, \\mathbf{N}_2)</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Proof.</strong> The proof is an immediate consequence of Thm. 10 and Thm. 19.1 for case 1 and Thm. 19.2 for case 2.</p>

    <p class="text-gray-300">The proof of oblivious trapdoor generation follows from the oblivious trapdoor generation and index set hiding of SSB commitments. We follow essentially the same proof as in the unilateral case.</p>

    <p class="text-gray-300">First we show that we construct an indistinguishable crs given only the commitment keys and the matrices <span class="math">\\mathbf{M}, \\mathbf{N}_1, \\mathbf{N}_2</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> There exists a modified crs generation algorithm <span class="math">K&#x27;</span> that on input <span class="math">(\\rho, \\theta&#x27;)</span>, where <span class="math">\\theta&#x27;</span> contains only either <span class="math">\\mathbf{M}, \\mathbf{N}_1, \\mathbf{N}_2</span> or <span class="math">\\mathbf{G}, \\mathbf{H}, \\mathbf{F}</span> outputs a crs such that <span class="math">(\\rho, \\mathrm{crs})</span> are identically distributed to the honest algorithm.</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">The lemma follows directly by noting that <span class="math">[\\mathbf{B}]_{1},[\\mathbf{D}]_{2}</span> are efficiently computable given the commitment keys and the discrete logarithms of matrices <span class="math">\\mathbf{M},\\mathbf{N}_{1},\\mathbf{N}_{2}</span> (equivalently <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span>). As in the unilateral case, we abuse notation and refer to <span class="math">\\mathsf{K}^{\\prime}(\\rho,\\theta^{\\prime})</span> as <span class="math">\\mathsf{K}(\\rho,\\theta^{\\prime})</span>.</p>

    <p class="text-gray-300">In the next theorem we consider the three keys issued as a single key. It is easy to verify that the properties of the commitment keys still hold. Essentially, we want to capture the condition that the keys preserve oblivious key generation even if we consider a function <span class="math">h</span> that outputs information that depends on all commitment keys. In our delegation construction this will correspond to <span class="math">h(\\mathbf{G},\\mathbf{H},\\mathbf{F}) = ([\\mathbf{G}]_{1},[\\mathbf{H}]_{2},[\\mathbf{F}]_{2},[\\mathbf{H}\\otimes \\mathbf{F} - \\mathbf{Z}]_{1},[\\mathbf{Z}]_{2})</span>, for a uniform <span class="math">\\mathbf{Z}</span>, namely the information needed to obliviously create a <span class="math">\\mathsf{crs}</span> for the kronecker composition of the last two keys.</p>

    <p class="text-gray-300">Theorem 11. Let <span class="math">\\mathcal{M}</span>, <span class="math">\\mathcal{N}_1</span>, <span class="math">\\mathcal{N}_2</span> be witness samplable distributions, and <span class="math">\\mathsf{CS}</span> be an algebraic SSB commitment scheme and let <span class="math">\\mathsf{CS}&#x27;</span> be the concatenation of three instances of <span class="math">\\mathsf{CS}</span>, that is it outputs <span class="math">\\mathbf{G}&#x27; = \\begin{pmatrix} [\\mathbf{G}0]_1 &amp;amp; \\mathbf{0} &amp;amp; \\mathbf{0} \\\\ \\mathbf{0} &amp;amp; [\\mathbf{G}_1]_1 &amp;amp; \\mathbf{0} \\\\ \\mathbf{0} &amp;amp; \\mathbf{0} &amp;amp; [\\mathbf{G}_2]_2 \\end{pmatrix}</span> with <span class="math">\\mathbf{G}_i \\gets \\mathsf{CS.KeyGen}(gk, n, d, K_i, S_i)</span>. If <span class="math">\\mathsf{CS}&#x27;</span> has <span class="math">h</span>-strong oblivious trapdoor generation, then construction QABlin of Fig. 5 is <span class="math">h_{ns}</span>-strong oblivious where <span class="math">h_{ns} = (h(sk), \\mathbf{M}_1, \\mathbf{N}_1, \\mathbf{N}_2)</span>. Furthermore,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every PPT <span class="math">\\mathcal{A}</span> against <span class="math">h_{ns}</span>-strong index set hiding of QABlin, there exists an adversary <span class="math">\\mathcal{B}</span> against <span class="math">h</span>-index set hiding property of <span class="math">\\mathsf{CS}</span>, such that <span class="math">\\mathsf{Adv}_{\\mathsf{ISH}}^{\\mathsf{QABlin}}(\\mathcal{A}) \\leq 3\\mathsf{Adv}_{\\mathsf{ISH}}^{\\mathsf{CS}}(\\mathcal{B})</span>.</li>

      <li>For every <span class="math">\\mathcal{A}</span> against oblivious trapdoor generation of QABlin, there exists an adversary <span class="math">\\mathcal{B}</span> against oblivious trapdoor of <span class="math">\\mathsf{CS}</span>, such that <span class="math">\\mathsf{Adv}_{\\mathsf{oblv}}^{\\mathsf{QABlin}}(\\mathcal{A}) \\leq 3\\mathsf{Adv}_{\\mathsf{oblv}}^{\\mathsf{CS}}(\\mathcal{B})</span>.</li>

    </ol>

    <p class="text-gray-300">Proof. Since the commitment key is perfectly binding at the extraction set, it is enough to show that <span class="math">h_{ns}</span>-strong index set hiding holds and that we can sample a tuple <span class="math">(\\rho, \\mathsf{crs})</span> indistinguishable from the one we are given, along with a valid trapdoor.</p>

    <p class="text-gray-300">For index set hiding, it is enough to notice that the crs of QABlin can be efficiently computed given only <span class="math">[\\mathbf{G}]_1, [\\mathbf{H}]_1, [\\mathbf{F}]_2</span>. Indeed by sampling <span class="math">[\\mathbf{M}]_1, \\mathbf{M} \\gets \\mathcal{M}, [\\mathbf{N}_1]_1, \\mathbf{N}_1 \\gets \\mathcal{N}_1, [\\mathbf{N}_2]_2, \\mathbf{N}_2 \\gets \\mathcal{N}_2</span> all values of crs are efficiently computable as noted in Lemma 2. Thus, a distinguishing advantage in index set hiding of QABlin immediately implies equal advantage on the respective property of CS.</p>

    <p class="text-gray-300">For oblivious crs generation we first describe the OblSetup algorithm. Let <span class="math">S&#x27; \\subseteq S</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {OblSetup}(\\rho := ([\\mathbf{G}]_{1}, [\\mathbf{H}]_{1}, [\\mathbf{F}]_{2}, [\\mathbf{M}]_{1}, [\\mathbf{N}_{1}]_{1}, [\\mathbf{N}_{2}]_{2}), \\mathsf{crs}):</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([\\mathbf{G}^{\\prime}]_{1},\\mathbf{T}_{\\mathbf{G}}^{\\prime})\\gets \\mathsf{CS.OblSetup}(gk,d,K_{0},S_{0},[\\mathbf{G}]_{1}).</span></li>

      <li><span class="math">([\\mathbf{H}^{\\prime}]_{1},\\mathbf{T}_{\\mathbf{H}}^{\\prime})\\gets \\mathsf{CS.OblSetup}(gk,d,K_{1},S_{1},[\\mathbf{H}]_{1}).</span></li>

      <li><span class="math">([\\mathbf{F}^{\\prime}]_{2},\\mathbf{T}_{\\mathbf{F}}^{\\prime})\\gets \\mathsf{CS.OblSetup}(gk,d,K_{2},S_{2},[\\mathbf{F}]_{2}).</span></li>

      <li>Sample <span class="math">([\\mathbf{M}^{\\prime}]_{1},\\mathbf{M}^{\\prime})\\gets \\mathcal{M};([\\mathbf{N}_{1}^{\\prime}]_{1},\\mathbf{N}_{1}^{\\prime})\\gets \\mathcal{N}_{2};([\\mathbf{N}_{2}^{\\prime}]_{2},\\mathbf{N}_{2}^{\\prime})\\gets \\mathcal{N}_{2};</span></li>

      <li>Set <span class="math">\\tau&#x27; = (\\mathbf{T}_{\\mathbf{G}}&#x27;, \\mathbf{T}_{\\mathbf{H}}&#x27;, \\mathbf{T}_{\\mathbf{F}}&#x27;)</span> and compute <span class="math">\\mathsf{crs} \\gets \\mathsf{QABlin.K}(\\rho, \\theta&#x27; = (\\mathbf{M}, \\mathbf{N}_1, \\mathbf{N}_2))</span>.</li>

    </ul>

    <p class="text-gray-300">Note that the only difference in sampling with <span class="math">S</span> and with <span class="math">S&#x27;</span> is how we sample the commitment keys <span class="math">\\mathbf{G}, \\mathbf{H}, \\mathbf{F}</span>; <span class="math">\\mathsf{crs}</span> is identically distributed to an honest one since we sample <span class="math">\\mathbf{M}, \\mathbf{N}_1, \\mathbf{N}_2</span> in the same way that <span class="math">\\mathcal{D}_{\\mathrm{par}}</span> does. Also, by oblivious key generation of CS, the trapdoor <span class="math">\\tau&#x27;</span> is a valid one w.r.t. <span class="math">\\mathbf{G}&#x27;, \\mathbf{H}&#x27;, \\mathbf{F}&#x27;</span> and set <span class="math">S&#x27;</span>, so it extracts valid witnesses which, by perfect binding in <span class="math">S&#x27;</span> are unique and do not assist the distinguisher which can compute them itself.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Finally, we get the following corollary.</p>

    <p class="text-gray-300">Corollary 5. When <span class="math">\\mathsf{CS}</span> is the one from fig. 3 and <span class="math">\\mathsf{CS}&#x27;</span> is the concatenation of the three keys as described in Thm. 11 for and <span class="math">h(\\mathbf{G},\\mathbf{H},\\mathbf{F}) = ([\\mathbf{H}\\otimes \\mathbf{F} - \\mathbf{Z}]_1,[\\mathbf{Z}]_2)</span> for uniform <span class="math">\\mathbf{Z}</span>, then QABlin from fig. 5 is <span class="math">h_{ns}</span>-strong no-signaling where <span class="math">h_{ns}(\\theta) = (h(\\mathbf{G},\\mathbf{H},\\mathbf{F}),\\mathbf{M},\\mathbf{N}_1,\\mathbf{N}_2)</span>.</p>

    <p class="text-gray-300">Proof. Follows directly from Thm. 7, the <span class="math">h_{ns}</span>-strong ISH of the QALin which we show on Thm. 11 and the properties of the kronecker key operator (Thm. 6). <span class="math">\\square</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 5: Quasi argument QABlin for knowledge transfer of membership in linear space.</p>

    <p class="text-gray-300">Quasi Argument for Sum Knowledge Transfer. Let  <span class="math">(\\mathcal{M}_1, \\mathcal{M}_1)</span>  be some (possibly correlated) witness sample distributions outputting matrices in  <span class="math">\\mathbb{G}_1^{d \\times n} \\times \\mathbb{G}_2^{d \\times n}</span>  and  <span class="math">\\mathcal{N}</span>  be witness sample distributions outputting matrices in  <span class="math">\\mathbb{G}_1^{d \\times n}</span>  for  <span class="math">n, d \\in \\mathbb{N}</span> . Let  <span class="math">K \\leq d</span>  where  <span class="math">K = (K_0, K_1)</span>  and  <span class="math">S \\subseteq ([d], [d])</span>  where  <span class="math">S = S_1 \\cup S_2</span>  and  <span class="math">S \\leq K</span> . Let CS be an algebraic SSB commitment scheme and CS' be a split algebraic commitment key with commitment space  <span class="math">\\mathbb{G}_1^{\\widetilde{K}}, \\mathbb{G}_1^{\\widetilde{K}} \\times \\mathbb{G}_2^{\\widetilde{K}}</span>  respectively. The parameter language is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {L} _ {\\text {p a r}} = \\left\\{\\left[ \\mathbf {M} _ {1} \\right] _ {1}, \\left[ \\mathbf {M} _ {2} \\right] _ {2}, \\left[ \\mathbf {N} \\right] _ {1}, \\left[ \\mathbf {Q} _ {1} \\right] _ {1}, \\left[ \\mathbf {Q} _ {2} \\right] _ {1}, \\left[ \\mathbf {F} \\right] _ {2} \\mid \\exists \\mathbf {M} _ {1}, \\mathbf {M} _ {2}, \\mathbf {N} _ {1}, \\mathbf {Q} _ {1}, \\mathbf {Q} _ {2}, \\mathbf {F} \\text {s . t .} \\right. \\\\ \\left(\\left[ \\mathbf {M} _ {1} \\right] _ {1}, \\left[ \\mathbf {M} _ {2} \\right] _ {2}, \\mathbf {M} _ {1}, \\mathbf {M} _ {2}\\right) \\in \\operatorname {S u p} \\left(\\mathcal {M} _ {1}, \\mathcal {M} _ {2}\\right), \\left(\\left[ \\mathbf {N} \\right] _ {1}, \\mathbf {N}\\right) \\in \\operatorname {S u p} (\\mathcal {N}), \\\\ \\left(\\left[ \\mathbf {Q} _ {1} \\right] _ {1}, \\left[ \\mathbf {Q} _ {2} \\right] _ {2}, \\mathbf {Q} _ {1}, \\mathbf {Q} _ {2}, \\mathbf {T} _ {\\mathbf {Q}}\\right) \\in \\operatorname {S u p} \\left(\\mathrm {C S} ^ {\\prime}. \\text {K e y G e n} (g k, n, K _ {0}, S _ {1})\\right), \\\\ \\left(\\left[ \\mathbf {F} \\right] _ {1}, \\mathbf {F}, \\mathbf {T} _ {\\mathbf {F}}\\right) \\in \\operatorname {S u p} (\\mathrm {C S}. \\text {K e y G e n} (g k _ {1}, n, K _ {1}, S _ {2})) \\} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We assume w.l.o.g. that the corresponding relation is efficiently verifiable. The parameters  <span class="math">\\rho = ([\\mathbf{M}]_1, [\\mathbf{N}_1]_1, [\\mathbf{N}_2]_2, [\\mathbf{Q}_1]_1, [\\mathbf{Q}_2]_1, [\\mathbf{F}]_2)</span>  define the following relations <span class="math">^{18}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathcal {R} _ {\\rho} ^ {\\mathrm {y e s}} = \\left\\{\\left[ c _ {1} \\right] _ {1}, \\left[ c _ {2} \\right] _ {2}, [ d ] _ {2}, w \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left( \\begin{array}{c} c _ {1} + c _ {2} \\\\ d \\end{array} \\right) = \\left( \\begin{array}{c} (\\mathbf {Q} _ {1} + \\mathbf {Q} _ {2}) (\\mathbf {M} _ {1} + \\mathbf {M} _ {2}) \\\\ \\mathbf {F N} \\end{array} \\right) w \\right. \\right\\}, \\\\ \\mathcal {R} _ {\\rho , S} ^ {n o} = \\left\\{ \\begin{array}{l l} ([ c _ {1} ] _ {1}, [ c _ {2} ] _ {2}, [ d ] _ {1}), w, &amp; x _ {1} + x _ {2}, y \\text {a r e v a l i d} S _ {0}, S _ {1} \\text {o p e n i n g s o f} \\\\ ([ x _ {1} ] _ {1}, [ x _ {2} ] _ {2}, [ y ] _ {1}) &amp; c _ {1} + c _ {2}, d _ {2} \\text {w . r . t .} Q _ {1} + Q _ {2}, F \\text {r e s p e c t i v e l y a n d} \\\\ &amp; x _ {1} + x _ {2} = (M _ {1, S _ {0}} + M _ {2, S _ {0}}) w \\text {b u t} y \\neq N _ {S _ {2}} w \\end{array} \\right\\}, \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">that is the partial witness for  <span class="math">S</span>  is some valid local openings  <span class="math">[x_1]_1, [x_2]_2, [y]_1</span>  w.r.t. to  <span class="math">\\mathbf{G}, \\mathbf{H}, \\mathbf{F}</span>  respectively that satisfy the following: if  <span class="math">x_1 + x_2 = (\\mathbf{M}_{1,S_1} + \\mathbf{M}_{2,S_1})w</span>  then it should be the case that  <span class="math">y = \\mathbf{N}_{S_2}w</span>  where  <span class="math">w</span>  is the promise of the adversary. Note that if  <span class="math">S_1</span>  is the empty set the latter relations trivially hold.</p>

    <p class="text-gray-300">We present the protocol in Fig 6.</p>

    <p class="text-gray-300">Theorem 12. Let  <span class="math">\\mathcal{M}_1, \\mathcal{M}_2</span>  be (possibly correlated) witness sample distribution,  <span class="math">\\mathcal{N}</span>  be a witness sample distribution,  <span class="math">\\mathcal{D}_k</span>  a matrix distribution and  <span class="math">\\mathrm{CS}, \\mathrm{CS}&#x27;</span>  an algebraic and split algebraic SSB commitment respectively with perfect completeness. Also, let  <span class="math">\\mathcal{A}</span>  be an adversary against  <span class="math">h_{ls}</span> -strong local soundness of construction QASum where  <span class="math">h_{ls} = (\\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{F}, \\mathbf{N})</span> . Then, QAsum has perfect completeness and  <span class="math">h_{ls}</span> -strong local knowledge soundness holds with probability at least  <span class="math">1 - \\mathrm{Adv}_{\\mathrm{snd}}^{\\Pi_{kt-sum}}(\\mathcal{B}_S)</span> , where  <span class="math">\\mathcal{B}_S</span>  is any PPT adversary against soundness of  <span class="math">\\Pi_{kt-sum}</span> .</p>

    <p class="text-gray-300">Proof. For completeness, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\boldsymbol {c} _ {1} ^ {\\top} \\mid \\boldsymbol {d} ^ {\\top}\\right) \\mathbf {C} _ {1} + \\boldsymbol {c} _ {2} ^ {\\top} \\mathbf {C} _ {2} = \\left(\\boldsymbol {c} _ {1} ^ {\\top} \\mid \\boldsymbol {d} ^ {\\top}\\right) \\left( \\begin{array}{c} \\mathbf {K} _ {0} \\\\ \\mathbf {K} _ {1} \\end{array} \\right) \\mathbf {A} + \\boldsymbol {c} _ {2} ^ {\\top} \\mathbf {K} _ {0} \\mathbf {A} \\\\ = \\left(c _ {1} ^ {\\top} \\mathbf {K} _ {0} + d ^ {\\top} \\mathbf {K} _ {1} + c _ {2} ^ {\\top} \\mathbf {K} _ {0}\\right) \\mathbf {A} \\\\ = \\left(\\left(c _ {1} ^ {\\top} + c _ {2} ^ {\\top}\\right) \\mathbf {K} _ {0} + d ^ {\\top} \\mathbf {K} _ {1}\\right) \\mathbf {A} \\\\ = \\left(w ^ {\\top} \\left(M _ {1} ^ {\\top} + M _ {2} ^ {\\top}\\right) \\left(Q _ {1} ^ {\\top} + Q _ {2} ^ {\\top}\\right) K _ {0} + w ^ {\\top} N ^ {\\top} F ^ {\\top} K _ {1}\\right) A \\\\ = w ^ {\\top} \\left(\\left(M _ {1} ^ {\\top} + M _ {2} ^ {\\top}\\right) Q ^ {\\top} K _ {0} + N ^ {\\top} F ^ {\\top} K _ {1}\\right) A \\\\ = w ^ {\\top} \\left(\\left(M _ {1} ^ {\\top} Q ^ {\\top} K _ {0} + N ^ {\\top} F ^ {\\top} K _ {1} + Z\\right) + \\left(M _ {2} ^ {\\top} Q ^ {\\top} K _ {0} - Z\\right)\\right) A \\\\ = w ^ {\\top} (\\mathbf {B} + \\mathbf {D}) \\mathbf {A} \\\\ = w ^ {\\top} \\mathbf {B} \\mathbf {A} + w ^ {\\top} \\mathbf {D} \\mathbf {A} \\\\ = \\pi \\mathbf {A} + \\theta \\mathbf {A} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">18We allow both the distributions <span class="math">\\mathcal{M}_1, \\mathcal{M}_2, \\mathcal{N}</span>  and the commitment keys to include some auxiliary information with its associated witness which are included in <span class="math">\\rho</span>, <span class="math">\\theta</span> respectively. This auxiliary information is not used in the protocol, but is public when the protocol is used inside other protocols. We omit it here to simplify the presentation but we consider it whenever needed.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}_{\\mathrm{par}}(gk,d,K,S = (S_0,S_1))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([\\mathbf{M}_1]_1, [\\mathbf{M}_2]_2, \\mathbf{M}_1, \\mathbf{M}_2) \\gets (\\mathcal{M}_1, \\mathcal{M}_2)</span> ;  <span class="math">([\\mathbf{N}]_1, \\mathbf{N}) \\gets \\mathcal{N}</span> ;</li>

      <li><span class="math">([\\mathbf{Q}_1]_1, [\\mathbf{Q}_2]_2, \\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{T}_{\\mathbf{Q}}) \\gets \\mathsf{CS}&#x27;</span> . KeyGen  <span class="math">(gk, n, d, K_0, S_0)</span> ;</li>

    </ul>

    <p class="text-gray-300"><span class="math">([\\mathbf{F}]_1,\\mathbf{F},\\mathbf{T}_{\\mathbf{F}})\\gets \\mathsf{CS}.\\mathsf{KeyGen}(gk_1,n,d,K_1,S_1)</span></p>

    <p class="text-gray-300">Output  <span class="math">(\\rho, \\theta)</span>  where</p>

    <p class="text-gray-300"><span class="math">\\rho = (gk, [\\mathbf{Q}_1]_1, [\\mathbf{Q}_2]_1, [\\mathbf{F}]_2, [\\mathbf{M}_1]_1, [\\mathbf{M}_2]_2, [\\mathbf{N}]_1),</span></p>

    <p class="text-gray-300"><span class="math">\\theta = (\\mathbf{Q}_1,\\mathbf{Q}_2,\\mathbf{F},\\mathbf{T}_{\\mathbf{Q}},\\mathbf{T}_{\\mathbf{F}},\\mathbf{M}_1,\\mathbf{M}_2,\\mathbf{N}).</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{K}(\\rho ,\\theta)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\rho = (gk, [\\mathbf{Q}_1]_1, [\\mathbf{Q}_2]_1, [\\mathbf{F}]_2, [\\mathbf{M}_1]_1, [\\mathbf{M}_2]_2, [\\mathbf{N}]_1), \\quad \\theta = (\\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{F}, \\mathbf{T}_{\\mathbf{Q}}, \\mathbf{T}_{\\mathbf{F}}, \\mathbf{M}_1, \\mathbf{M}_2, \\mathbf{N})</span> .</li>

      <li>Set  <span class="math">\\mathbf{Q} = \\mathbf{Q}_1 + \\mathbf{Q}_2</span>  and sample  <span class="math">\\mathbf{K}_0 \\gets \\mathbb{Z}_p^{\\overline{\\mathbf{K}}_0 \\times k}</span> ;  <span class="math">\\mathbf{K}_1 \\gets \\mathbb{Z}_p^{\\overline{\\mathbf{K}}_1 \\times k}</span> ;  <span class="math">\\mathbf{Z} \\gets \\mathbb{Z}_p^{n \\times k}</span> ;  <span class="math">\\mathbf{A} \\gets \\mathcal{D}_k</span>  and redefine  <span class="math">\\mathbf{A}</span>  as its first  <span class="math">k</span>  columns.</li>

      <li>Compute  <span class="math">[\\mathbf{B}]_1 = [\\mathbf{M}_1^\\top]_1\\mathbf{Q}^\\top \\mathbf{K}_0 + [\\mathbf{N}^\\top]_1\\mathbf{F}^\\top \\mathbf{K}_1 + [\\mathbf{Z}]_1</span>  and  <span class="math">[\\mathbf{D}]_2 = [\\mathbf{M}_2^\\top]_2\\mathbf{Q}^\\top \\mathbf{K}_0 - [\\mathbf{Z}]_2</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{C}_1 = \\left( \\begin{array}{c}\\mathbf{K}_0\\\\ \\mathbf{K}_1 \\end{array} \\right)\\mathbf{A}</span>  and  <span class="math">\\mathbf{C}_2 = \\mathbf{K}_0\\mathbf{A};</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output (crs,  <span class="math">\\tau</span> ) where  <span class="math">\\mathrm{crs} = ([\\mathbf{B}]_1, [\\mathbf{D}]_2, [\\mathbf{A}]_{1,2}, [\\mathbf{C}_1]_2, [\\mathbf{C}_2]_1)</span>  and  <span class="math">\\tau = (\\mathbf{T}_{\\mathbf{Q}}, \\mathbf{T}_{\\mathbf{F}})</span> .</li>

    </ul>

    <p class="text-gray-300">Prove(crs = ([B]1, [D]2, [A]1,2, [C1]2, [C2]1), [c1]1, [c2]2, [d]1, w):</p>

    <p class="text-gray-300">Sample  <span class="math">z \\gets \\mathbb{Z}_p^k</span>  and output  <span class="math">([\\pi]_1, [\\theta]_2) \\gets (w^\\top[\\mathbf{B}]_1 - [z^\\top]_1, w^\\top[\\mathbf{D}]_2 + [z^\\top]_2)</span> .</p>

    <p class="text-gray-300">Verify (crs,  <span class="math">[c_1]_1, [c_2]_2, [d]_1, [\\pi]_1, [\\theta]_2</span> ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output 1 iff  <span class="math">e([\\pi]_1, [\\mathbf{A}]_2) + e([\\theta]_2, [\\mathbf{A}]_1) = e([c_1^\\top \\mid d^\\top]_1, [\\mathbf{C}_1]_2) + e([c_2^\\top]_2, [\\mathbf{C}_2]_1)</span> .</li>

    </ul>

    <p class="text-gray-300">Extract  <span class="math">(\\tau, [c_1]_1, [c_2]_2, [d]_1, [\\pi]_1, [\\theta]_2)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\tau</span>  as  <span class="math">(\\mathbf{T}_{\\mathbf{Q}},\\mathbf{T}_{\\mathbf{F}})</span>  and output  <span class="math">[x_1]_1 = \\mathbf{T}_{\\mathbf{Q}}^\\top [c_1]_1,[x_2]_2 = \\mathbf{T}_{\\mathbf{Q}}^\\top [c_2]_1,[y]_1 = \\mathbf{T}_{\\mathbf{F}}^\\top [d]_1.</span></li>

    </ul>

    <p class="text-gray-300">Figure 6: Quasi argument QASum for knowledge transfer of sum membership in linear space.</p>

    <p class="text-gray-300">Local knowledge soundness follows using almost an identical argument to Thm. 10 and reducing to knowledge transfer of KTA Sum Argument  <span class="math">\\Pi_{\\mathrm{kt-sum}}</span>  of Fig. 1. Given an adversary  <span class="math">\\mathcal{A}</span>  breaking Knowledge Transfer of the quasi-argument of Fig. 6, we construct another adversary  <span class="math">\\mathcal{B}_S</span>  that breaks Knowledge Transfer of the argument  <span class="math">\\Pi_{\\mathrm{kt-sum}}</span>  for matrices  <span class="math">[\\mathbf{M}_{1,S_0}]_1, [\\mathbf{M}_{2,S_0}]_2</span>  and  <span class="math">[\\mathbf{N}_{S_1}]_1</span> .  <span class="math">\\mathcal{B}_S</span>  works as follows: it takes input  <span class="math">(\\rho^{\\dagger}, h_{kt}(\\theta^{\\dagger}), \\mathsf{crs}^{\\dagger})</span>  where</p>

    <p class="text-gray-300"><span class="math">\\rho^{\\dagger} := (gk, [\\mathbf{M}_{1,S_0}]_1, [\\mathbf{M}_{2,S_0}]_2, [\\mathbf{N}_{S_1}]_1), \\quad h_{kt}(\\theta^{\\dagger}) := \\mathbf{N}_{S_1}, \\quad \\mathsf{crs}^{\\dagger} := ([\\mathbf{B}^{\\dagger}]_1, [\\mathbf{D}^{\\dagger}]_2, [\\mathbf{A}]_{1,2}, [\\mathbf{C}_1^{\\dagger}]_2, [\\mathbf{C}_2^{\\dagger}]_1)</span></p>

    <p class="text-gray-300">and does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It samples  <span class="math">([\\mathbf{Q}_1]_1, [\\mathbf{Q}_2]_2, \\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{T}_{\\mathbf{Q}}) \\gets \\mathsf{CS}&#x27;</span> . KGen  <span class="math">(gk, d, K, S_1)</span>  and sets  <span class="math">\\mathbf{Q} := \\mathbf{Q}_1 + \\mathbf{Q}_2</span> .</li>

      <li>It samples  <span class="math">([\\mathbf{F}]_1, \\mathbf{F}, \\mathbf{T}_{\\mathbf{F}}) \\gets \\mathsf{CS}.\\mathsf{KGen}(gk, d, K, S_2)</span> .</li>

      <li>It samples  <span class="math">\\mathbf{M}_{1,\\overline{S}_1},\\mathbf{M}_{2,\\overline{S}_1},\\mathbf{N}_{\\overline{S}_2}</span> , such that  <span class="math">\\mathbf{M}_1 = \\mathbf{P}_{S_1}\\left( \\begin{array}{c}\\mathbf{M}_{1,S_1}\\\\ \\mathbf{M}_{1,\\overline{S}_1} \\end{array} \\right),\\mathbf{M}_2 = \\mathbf{P}_{S_1}\\left( \\begin{array}{c}\\mathbf{M}_{2,S_1}\\\\ \\mathbf{M}_{2,\\overline{S}_1} \\end{array} \\right),\\mathbf{N} = \\mathbf{P}_{S_2}\\left( \\begin{array}{c}\\mathbf{N}_{S_2}\\\\ \\mathbf{N}_{\\overline{S}_2} \\end{array} \\right).</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It samples <span class="math">\\mathbf{R}_0 \\gets \\mathbb{Z}_p^{\\overline{K}_0 \\times k}</span>; <span class="math">\\mathbf{R}_1 \\gets \\mathbb{Z}_p^{\\overline{K}_1 \\times k}</span></li>

      <li>It computes <span class="math">[\\mathbf{B}]_1 := [\\mathbf{B}^\\dagger]_1 + [\\mathbf{M}_1]_1^\\top \\mathbf{Q}^\\top \\mathbf{R}_0 + [\\mathbf{N}]_1^\\top \\mathbf{F}^\\top \\mathbf{R}_1</span> and <span class="math">[\\mathbf{D}]_2 := [\\mathbf{D}^\\dagger]_2 + [\\mathbf{M}_2]_2^\\top \\mathbf{Q}^\\top \\mathbf{R}_0</span></li>

      <li>It computes <span class="math">[\\mathbf{C}_1]_2 := \\begin{pmatrix} \\mathbf{T}_{\\mathbf{Q}} &amp;amp; \\mathbf{0} \\\\ \\mathbf{0} &amp;amp; \\mathbf{T}_{\\mathbf{F}} \\end{pmatrix} [\\mathbf{C}_1^\\dagger]_2 + \\begin{pmatrix} \\mathbf{R}_0 \\\\ \\mathbf{R}_1 \\end{pmatrix} [\\mathbf{A}]_2</span> and <span class="math">[\\mathbf{C}_2]_1 := \\mathbf{T}_{\\mathbf{Q}}[\\mathbf{C}_2^\\dagger]_1 + \\mathbf{R}_0[\\mathbf{A}]_1.</span></li>

      <li>It sets</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\rho := \\left(\\left[ \\mathbf {Q} _ {1} \\right] _ {1}, \\left[ \\mathbf {Q} _ {2} \\right] _ {1}, \\left[ \\mathbf {F} \\right] _ {2}, \\left[ \\mathbf {M} _ {1} \\right] _ {1}, \\left[ \\mathbf {M} _ {2} \\right] _ {2}, \\left[ \\mathbf {N} \\right] _ {1}\\right), \\quad h _ {l s} (\\theta) := \\left(\\mathbf {Q} _ {1}, \\mathbf {Q} _ {2}, \\mathbf {F}, \\mathbf {N}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r s} := \\left(\\left[ \\mathbf {B} \\right] _ {1}, \\left[ \\mathbf {D} \\right] _ {2}, \\left[ \\mathbf {A} \\right] _ {1, 2}, \\left[ \\mathbf {C} _ {1} \\right] _ {2}, \\left[ \\mathbf {C} _ {2} \\right] _ {1}\\right)</span></div>

    <p class="text-gray-300">It then executes <span class="math">\\mathcal{A}(\\rho, h_{ls}(\\theta), \\mathrm{crs})</span> until it outputs a statement <span class="math">([c_1]_1, [c_2]_2, [d]_1, w)</span> together with an accepting proof <span class="math">[\\pi]_1, [\\theta]_2</span>. Given an accepting proof <span class="math">\\mathcal{B}</span> sets <span class="math">[x_1^\\dagger]_1 = \\mathbf{T}_{\\mathbf{Q}}[c_1]_1, [x_2^\\dagger]_2 = \\mathbf{T}_{\\mathbf{Q}}[c_2]_2, [y^\\dagger]_1 = \\mathbf{T}_{\\mathbf{F}}[d]_1, [\\pi^\\dagger]_1 = [\\pi]_1 - [c_1]_1^\\top \\mathbf{R}_1 - [d]_1^\\top \\mathbf{R}_2</span> and <span class="math">[\\theta^\\dagger]_2 = [\\theta]_1 - [c_2]_2^\\top \\mathbf{R}_1</span>. It outputs <span class="math">(([x_1^\\dagger]_1, [x_2^\\dagger]_2, [y^\\dagger]_1), w, ([\\pi^\\dagger]_1, [\\theta^\\dagger]_2))</span>.</p>

    <p class="text-gray-300">Note that by perfect completeness of the commitment scheme, the commitment keys are extractable and perfectly binding at <span class="math">S</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we claim that in this case the values <span class="math">\\rho, h_{ls}(\\theta), \\mathrm{crs}</span> output by <span class="math">\\mathcal{B}_S</span> are identically distributed to honestly computed ones and thus do not skew the probability that <span class="math">\\mathcal{A}</span> outputs a valid proof. For <span class="math">\\rho, h_{ls}(\\theta)</span>, this is immediate by the witness samplability of the distributions <span class="math">\\mathcal{M}_1, \\mathcal{M}_2, \\mathcal{N}</span>. We show that this holds for <span class="math">\\mathrm{crs}</span> as well. Let $\\mathbf{K}_0^\\dagger \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k}, \\mathbf{K}_1^\\dagger \\in \\mathbb{Z}_p^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times k}, \\mathbf{Z}^\\dagger \\in \\mathbb{Z}_p^{n \\times k}$ matrices satisfying:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} ^ {\\dagger} = \\mathbf {M} _ {1, S _ {1}} ^ {\\top} \\mathbf {K} _ {0} ^ {\\dagger} + \\mathbf {N} _ {S} ^ {\\top} \\mathbf {K} _ {1} ^ {\\dagger} + \\mathbf {Z} ^ {\\dagger}, \\mathbf {D} ^ {\\dagger} = \\mathbf {M} _ {2, S _ {1}} ^ {\\top} \\mathbf {K} _ {0} ^ {\\dagger} - \\mathbf {Z} ^ {\\dagger}, \\mathbf {C} _ {1} ^ {\\dagger} = \\left( \\begin{array}{c} \\mathbf {K} _ {1} ^ {\\dagger} \\\\ \\mathbf {K} _ {1} ^ {\\dagger} \\end{array} \\right) \\mathbf {A} \\text{ and } \\mathbf {C} _ {2} ^ {\\dagger} = \\mathbf {K} _ {0} ^ {\\dagger} \\mathbf {A}.</span></div>

    <p class="text-gray-300">Now <span class="math">\\mathcal{B}_S</span> implicitly defines <span class="math">\\mathbf{K}_0 = \\mathbf{T}_{\\mathbf{Q}}\\mathbf{K}_0^\\dagger + \\mathbf{R}_0</span>, <span class="math">\\mathbf{K}_1 = \\mathbf{T}_{\\mathbf{F}}\\mathbf{K}_1^\\dagger + \\mathbf{R}_1</span>, and note that these matrices are uniformly distributed since <span class="math">\\mathbf{R}_0, \\mathbf{R}_1</span> are uniformly distributed. Thus <span class="math">\\mathbf{K}_0, \\mathbf{K}_1</span> are distributed identically to honestly generated values for generating a crs. We claim that the crs output by <span class="math">\\mathcal{A}</span> is identically distributed to sampling this matrix and computing the other values honestly. Indeed we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {B} = \\mathbf {B} ^ {\\dagger} + \\mathbf {M} _ {1} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {R} _ {1} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {R} _ {1} \\\\ = \\mathbf {M} _ {1, S _ {1}} ^ {\\top} \\mathbf {K} _ {0} ^ {\\dagger} + \\mathbf {N} _ {S _ {2}} ^ {\\top} \\mathbf {K} _ {1} + \\mathbf {Z} ^ {\\dagger} + \\mathbf {M} _ {1} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {R} _ {0} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {R} _ {1} \\\\ = \\mathbf {M} _ {1} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {T} _ {\\mathbf {Q}} \\mathbf {K} _ {0} ^ {\\dagger} + \\mathbf {N} ^ {\\top} \\mathbf {F} ^ {\\top} \\mathbf {T} _ {\\mathbf {F}} ^ {\\top} \\mathbf {K} _ {1} + \\mathbf {Z} ^ {\\dagger} + \\mathbf {M} _ {1} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {R} _ {0} + \\mathbf {N} _ {1} ^ {\\top} \\mathbf {H} ^ {\\top} \\mathbf {R} _ {1} \\\\ = \\mathbf {M} _ {1} ^ {\\top} \\mathbf {Q} ^ {\\top} \\left(\\mathbf {T} _ {\\mathbf {Q}} \\mathbf {K} _ {0} ^ {\\dagger} + \\mathbf {R} _ {0}\\right) + \\mathbf {N} ^ {\\top} \\mathbf {F} ^ {\\top} \\left(\\mathbf {T} _ {\\mathbf {F}} ^ {\\top} \\mathbf {K} _ {1} + \\mathbf {R} _ {1}\\right) + \\mathbf {Z} ^ {\\dagger} \\\\ = \\mathbf {M} _ {1} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {K} _ {0} + \\mathbf {N} ^ {\\top} \\mathbf {F} ^ {\\top} \\mathbf {K} _ {1} + \\mathbf {Z} ^ {\\dagger} \\end{array}</span></div>

    <p class="text-gray-300">where the third equality follows since by the local extractability of the SSBs (1) <span class="math">\\mathbf{T}_{\\mathbf{Q}}^{\\top}\\mathbf{Q}\\mathbf{M}_{1} = \\mathbf{M}_{1,S}</span> and (2) <span class="math">\\mathbf{T}_{\\mathbf{F}}^{\\top}\\mathbf{F}\\mathbf{N} = \\mathbf{N}_{S}</span>. Similarly, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {D} = \\mathbf {D} ^ {\\dagger} + \\mathbf {M} _ {2} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {R} _ {0} \\\\ = \\mathbf {M} _ {2, S _ {1}} ^ {\\top} \\mathbf {K} _ {0} ^ {\\dagger} - \\mathbf {Z} ^ {\\dagger} + \\mathbf {M} _ {2} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {R} _ {0} \\\\ = \\mathbf {M} _ {2} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {T} _ {\\mathbf {Q}} \\mathbf {K} _ {0} ^ {\\dagger} - \\mathbf {Z} ^ {\\dagger} + \\mathbf {M} _ {2} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {R} _ {0} \\\\ = \\mathbf {M} _ {2} ^ {\\top} \\mathbf {Q} ^ {\\top} \\left(\\mathbf {T} _ {\\mathbf {Q}} \\mathbf {K} _ {0} ^ {\\dagger} + \\mathbf {R} _ {0}\\right) - \\mathbf {Z} ^ {\\dagger} \\\\ = \\mathbf {M} _ {2} ^ {\\top} \\mathbf {Q} ^ {\\top} \\mathbf {K} _ {0} - \\mathbf {Z} ^ {\\dagger} \\end{array}</span></div>

    <p class="text-gray-300">Also, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{C}_{1}</span> <span class="math">=\\begin{pmatrix}\\mathbf{T_{Q}}&amp;\\mathbf{0}\\cr\\mathbf{0}&amp;\\mathbf{T_{F}}\\end{pmatrix}\\mathbf{C}_{1}^{\\dagger}+\\begin{pmatrix}\\mathbf{R}_{0}\\cr\\mathbf{R}_{1}\\end{pmatrix}\\mathbf{A}=\\begin{pmatrix}\\mathbf{T_{Q}}&amp;\\mathbf{0}\\cr\\mathbf{0}&amp;\\mathbf{T_{F}}\\end{pmatrix}\\begin{pmatrix}\\mathbf{K}_{1}^{\\dagger}\\cr\\mathbf{K}_{1}^{\\dagger}\\end{pmatrix}\\mathbf{A}+\\begin{pmatrix}\\mathbf{R}_{0}\\cr\\mathbf{R}_{1}\\end{pmatrix}\\mathbf{A}=i\\begin{pmatrix}\\mathbf{T_{Q}}\\mathbf{K}_{0}^{\\dagger}+\\mathbf{R}_{0}\\cr\\mathbf{T_{F}}\\mathbf{K}_{1}^{\\dagger}+\\mathbf{R}_{1}\\end{pmatrix}\\mathbf{A}=\\begin{pmatrix}\\mathbf{K}_{0}\\cr\\mathbf{K}_{1}\\end{pmatrix}\\mathbf{A}</span> <span class="math">\\mathbf{C}_{2}</span> <span class="math">=\\mathbf{T_{Q}}\\mathbf{C}_{2}^{\\dagger}+\\mathbf{R}_{0}\\mathbf{A}=\\mathbf{T_{Q}}\\mathbf{K}_{0}^{\\dagger}\\mathbf{A}+\\mathbf{R}_{0}\\mathbf{A}=(\\mathbf{T_{Q}}\\mathbf{K}_{0}^{\\dagger}+\\mathbf{R}_{0})\\mathbf{A}=\\mathbf{K}_{0}\\mathbf{A}</span></p>

    <p class="text-gray-300">so the outputted <span class="math">\\mathsf{crs}</span> is indeed identically distributed to an honest one.</p>

    <p class="text-gray-300">Then, we show that <span class="math">\\mathcal{B}</span> outputs a valid statement-proof pair w.r.t. to <span class="math">\\mathsf{crs}^{\\dagger}</span>. Since the commitment keys are extractable and perfectly binding, we have that <span class="math">(x_{1}^{\\dagger},x_{2}^{\\dagger})</span> and <span class="math">y^{\\dagger}</span> are valid openings for the commitments <span class="math">(c_{1},c_{2})</span> and <span class="math">d</span> respectively. Assuming <span class="math">\\mathcal{A}</span> produces a valid statement for <span class="math">\\mathcal{P}_{p,S}^{no}</span>, for the extracted values it holds that <span class="math">x_{1}^{\\dagger}+x_{2}^{\\dagger}=(\\mathbf{M}_{1,S_{1}}+\\mathbf{M}_{2,S_{1}})w</span> and <span class="math">y^{\\dagger}\\neq\\mathbf{N}_{S_{2}}w</span>. Thus <span class="math">\\mathcal{B}_{S}</span> outputs a valid statement and it suffices to show that <span class="math">(\\pi^{\\dagger},\\theta^{\\dagger})</span> is a valid proof. Indeed, we have</p>

    <p class="text-gray-300"><span class="math">\\mathbf{0}</span> <span class="math">=\\pi\\mathbf{A}+\\theta\\mathbf{A}-(c_{1}^{\\top}\\mid\\ d^{\\top})\\mathbf{C}_{1}-c_{2}^{\\top}\\mathbf{C}_{2}</span> <span class="math">=(\\pi^{\\dagger}+c_{1}^{\\top}\\mathbf{R}_{0}+d^{\\top}\\mathbf{R}_{1})\\mathbf{A}+(\\theta^{\\dagger}+c_{2}^{\\top}\\mathbf{R}_{0})\\mathbf{A}</span> \\[ \\qquad-(c_{1}^{\\top}\\mid\\ d^{\\top})\\left(\\begin{pmatrix}\\mathbf{T_{Q}}&\\mathbf{0}\\\\ \\mathbf{0}&\\mathbf{T_{F}}\\end{pmatrix}\\mathbf{C}_{1}^{\\dagger}+\\begin{pmatrix}\\mathbf{R}_{0}\\\\ \\mathbf{R}_{1}\\end{pmatrix}\\mathbf{A}\\right)\\\\ -c_{2}^{\\top}\\left(\\mathbf{T_{Q}}\\mathbf{C}_{2}^{\\dagger}+\\mathbf{R}_{0}\\mathbf{A}\\right)\\\\ =(\\pi^{\\dagger}+c_{1}^{\\top}\\mathbf{R}_{0}+d^{\\top}\\mathbf{R}_{1})\\mathbf{A}+(\\theta^{\\dagger}+c_{2}^{\\top}\\mathbf{R}_{0})\\mathbf{A}\\\\ -(c_{1}^{\\top}\\mathbf{T_{Q}}\\mid\\ d^{\\top}\\mathbf{T_{F}})\\mathbf{C}_{1}^{\\dagger}-(c_{1}^{\\top}\\mathbf{R}_{0}-d^{\\top}\\mathbf{R}_{1})\\mathbf{A}\\\\ -c_{2}^{\\top}\\mathbf{T_{Q}}\\mathbf{C}_{2}^{\\dagger}-c_{2}^{\\top}\\mathbf{R}_{0}\\mathbf{A}\\\\ =\\pi^{\\dagger}\\mathbf{A}+\\theta^{\\dagger}\\mathbf{A}-(c_{1}^{\\top}\\mathbf{T_{Q}}\\mid\\ d^{\\top}\\mathbf{T_{F}})\\mathbf{C}_{1}^{\\dagger}-c_{2}^{\\top}\\mathbf{T_{Q}}\\mathbf{C}_{2}^{\\dagger}\\\\ =\\pi^{\\dagger}\\mathbf{A}+\\theta^{\\dagger}\\mathbf{A}-(x_{1}^{\\dagger^{\\top}}\\mid\\ y^{\\dagger^{\\top}})\\mathbf{C}_{1}^{\\dagger}-x_{2}^{\\dagger^{\\top}}\\mathbf{C}_{2}^{\\dagger} \\]</p>

    <p class="text-gray-300">and the last equation is the verifying equation for the knowledge transfer argument for <span class="math">\\mathsf{crs}^{\\dagger}</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We next show that when the distributions <span class="math">(\\mathcal{M}_{1}\\mathcal{M}_{2}),\\mathcal{N}</span> guarantee that the sum knowledge transfer argument is secure w.r.t. all possible sets <span class="math">S</span>, construction <span class="math">\\mathsf{QASum}</span> has <span class="math">h_{ls}</span>-strong local knowledge soundness where <span class="math">h_{ls}</span> includes <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F},[\\mathbf{M}]_{2},[\\mathbf{N}_{1}\\otimes\\mathbf{N}_{2}-\\mathbf{R}]_{1},[-\\mathbf{R}]_{2})</span>, for a uniform <span class="math">\\mathbf{R}</span> and some extra information about the matrix <span class="math">\\mathbf{M}</span>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Corollary 6.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{D}_{k}</span> be a matrix distribution for which <span class="math">\\mathcal{D}_{k}</span>-SKerMDH. Denote <span class="math">\\mathcal{M}_{1,S}</span> (resp. <span class="math">\\mathcal{M}_{2,S}</span>, <span class="math">\\mathcal{N}_{S}</span>) the distributions that sample matrices from <span class="math">\\mathcal{M}_{1}</span> (res. <span class="math">\\mathcal{M}_{2}</span>, <span class="math">\\mathcal{N}</span>), and restricts them to rows corresponding to <span class="math">S</span>. Then</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If for all <span class="math">S_{0}\\subseteq[d]</span> with <span class="math">S_{0}\\leq K_{0}</span>, <span class="math">(\\mathcal{M}_{1,S_{0}}^{\\top},\\mathcal{M}_{2,S_{0}}^{\\top},h)</span>-MDDH holds, <span class="math">\\mathsf{QASum}</span> is an <span class="math">h_{ls}</span>-strong local knowledge sound proof system, where <span class="math">h_{ls}(\\theta)=(h(\\mathbf{M}_{1,S},\\mathbf{M}_{2,S})</span>, <span class="math">\\mathbf{G}</span>, <span class="math">\\mathbf{H}</span>, <span class="math">\\mathbf{F}</span>, <span class="math">\\mathbf{N}</span>).</li>

      <li>If for all <span class="math">S_{0},S_{1}\\subseteq[d]</span> with <span class="math">S_{0}\\leq K_{0}</span>, <span class="math">S_{1}\\leq K_{1}</span> the distributions <span class="math">\\mathcal{M}_{1,S_{0}}</span>, <span class="math">\\mathcal{M}_{2,S_{0}}</span>, <span class="math">\\mathcal{N}_{S_{1}}</span> output matrices with the last <span class="math">n^{\\prime}</span> columns being <span class="math">\\mathbf{0}</span>, and <span class="math">(\\mathcal{M}_{1,S_{0}}^{\\prime},\\mathcal{M}_{2,S_{0}}^{\\prime},h)</span>-MDDH holds, with <span class="math">\\mathcal{M}_{b,S_{0}}^{\\prime}</span> being <span class="math">\\mathcal{M}_{b,S_{0}}</span> where we delete the trailing zero columns, then <span class="math">\\mathsf{QASum}</span> is an <span class="math">h_{ls}</span>-strong local knowledge sound proof system, where <span class="math">h_{ls}(\\theta)=(h(\\mathbf{M}_{1,S_{0}},\\mathbf{M}_{2,S_{0}})</span>, <span class="math">\\mathbf{G}</span>, <span class="math">\\mathbf{H}</span>, <span class="math">\\mathbf{F}</span>, <span class="math">\\mathbf{N}</span>).</li>

    </ol>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is an immediate consequence of Thm. 12 and Thm. 19.1 for case 1 and Thm. 19.2 for case 2.</p>

    <p class="text-gray-300">The proof that QASum is oblivious follows from the oblivious trapdoor generation and index set hiding of SSB commitments. We follow essentially the same proof as in the QABlin case.</p>

    <p class="text-gray-300">First we show the corresponding lemma to Lemma 2, that is, we construct an indistinguishable crs given only the commitment keys and the matrices <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2},\\mathbf{N}</span>.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">There exists a modified crs generation algorithm <span class="math">\\mathsf{K}^{\\prime}</span> that on input <span class="math">(\\rho,\\theta^{\\prime})</span>, where <span class="math">\\theta^{\\prime}</span> contains only either <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2},\\mathbf{N}</span> or <span class="math">\\mathbf{Q}_{1},\\mathbf{Q}_{2},\\mathbf{F}</span> and outputs a crs such that <span class="math">(\\rho,\\mathsf{crs})</span> are identically distributed to the honest algorithm.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Given these values we can compute the crs using a simple trick. Instead of computing</p>

    <p class="text-gray-300"><span class="math">[\\mathbf{B}]_{1}=[\\mathbf{M}_{1}^{\\top}]_{1}\\mathbf{Q}^{\\top}\\mathbf{K}_{0}+[\\mathbf{N}^{\\top}]_{1}\\mathbf{F}^{\\top}\\mathbf{K}_{1}+[\\mathbf{Z}]_{1}</span> <span class="math">[\\mathbf{D}]_{2}=[\\mathbf{M}_{2}^{\\top}]_{2}\\mathbf{Q}^{\\top}\\mathbf{K}_{0}-[\\mathbf{Z}]_{2},</span></p>

    <p class="text-gray-300">we compute</p>

    <p class="text-gray-300"><span class="math">[\\mathbf{B}]_{1}=(\\mathbf{M}_{1}^{\\top}+\\mathbf{M}_{2}^{\\top})[\\mathbf{Q}_{1}^{\\top}]_{1}\\mathbf{K}_{0}+[\\mathbf{N}^{\\top}]_{1}\\mathbf{F}^{\\top}\\mathbf{K}_{1}+[\\mathbf{Z}]_{1}</span> <span class="math">[\\mathbf{D}]_{2}=(\\mathbf{M}_{2}^{\\top}+\\mathbf{M}_{2}^{\\top})[\\mathbf{Q}_{2}^{\\top}]_{2}\\mathbf{K}_{0}-[\\mathbf{Z}]_{2},</span></p>

    <p class="text-gray-300">Noting that in both cases the elements computed are uniformly distributed conditioned on <span class="math">\\mathbf{B}+\\mathbf{D}=(\\mathbf{M}_{1}^{\\top}+\\mathbf{M}_{2}^{\\top})(\\mathbf{Q}_{1}^{\\top}+\\mathbf{Q}_{2}^{\\top})\\mathbf{K}_{0}+\\mathbf{N}^{\\top}\\mathbf{F}^{\\top}\\mathbf{K}_{1}</span> we see that these values are computed as in the honest setup.</p>

    <p class="text-gray-300">In the case where <span class="math">\\theta=(\\mathbf{Q}_{1},\\mathbf{Q}_{2},\\mathbf{F})</span> we can directly compute the crs by noting that <span class="math">\\mathbf{Q}=\\mathbf{Q}_{1}+\\mathbf{Q}_{2}</span> and the group elements in <span class="math">\\rho</span> are enough to compute all values of crs. ∎</p>

    <p class="text-gray-300">As in the previous cases, we abuse notation and refer to <span class="math">\\mathsf{K}^{\\prime}(\\rho,\\theta^{\\prime})</span> as <span class="math">\\mathsf{K}(\\rho,\\theta^{\\prime})</span>.</p>

    <p class="text-gray-300">The proof of oblivious extraction essentially follows from the oblivious key generation and index set hiding of the SSB commitments and is similar to the proof of Thm. 11.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Theorem 13.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{M}_{1},\\mathcal{M}_{2}</span> be (possibly correlated) witness samplable distribution, <span class="math">\\mathcal{N}</span> be a witness samplable distribution, and <span class="math">\\mathsf{CS}</span>, <span class="math">\\mathsf{CS}^{\\prime}</span> be an algebraic and a split algebraic SSB commitment scheme respectively with perfect completeness, oblivious trapdoor generation and <span class="math">h,h^{\\prime}</span>-index set hiding respectively. Then Construction QASum of Fig. 6 is <span class="math">h_{ns}</span>-strong oblivious, where <span class="math">h_{ns}(\\theta)=(h(sk),h^{\\prime}(sk^{\\prime}),\\mathbf{M}_{1},\\mathbf{M}_{2},\\mathbf{N})</span>. Furthermore,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every PPT <span class="math">\\mathcal{A}</span> against index set hiding of QASum, there exist adversaries <span class="math">\\mathcal{B}_{0},\\mathcal{B}_{1}</span> against index set hiding property of <span class="math">\\mathsf{CS}^{\\prime}</span>, <span class="math">\\mathsf{CS}</span> respectively, such that <span class="math">\\mathsf{Adv}_{\\mathsf{ISH}}^{\\mathsf{QASum}}(\\mathcal{A})\\leq\\mathsf{Adv}_{\\mathsf{ISH}}^{\\mathsf{CS}^{\\prime}}(\\mathcal{B}_{0})+\\mathsf{Adv}_{\\mathsf{ISH}}^{\\mathsf{CS}}(\\mathcal{B}_{1})</span>.</li>

      <li>For every <span class="math">\\mathcal{A}</span> against oblivious crs generation of QASum, there exist an adversaries <span class="math">\\mathcal{B}_{0},\\mathcal{B}_{1}</span> against oblivious key generation of <span class="math">\\mathsf{CS}^{\\prime}</span>, <span class="math">\\mathsf{CS}</span> respectively, such that <span class="math">\\mathsf{Adv}_{\\mathsf{oblv}}^{\\mathsf{QASum}}(\\mathcal{A})\\leq\\mathsf{Adv}_{\\mathsf{oblv}}^{\\mathsf{CS}^{\\prime}}(\\mathcal{B}_{0})+\\mathsf{Adv}_{\\mathsf{oblv}}^{\\mathsf{CS}}(\\mathcal{B}_{1})</span>.</li>

    </ol>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It is enough to show that <span class="math">h_{ns}</span>-strong index set hiding holds and that we can sample a tuple <span class="math">(\\rho,\\mathsf{crs})</span> indistinguishable from the one we are given, along with a valid trapdoor. This is the case because the commitment keys are perfectly binding in <span class="math">S^{\\prime}</span>, which means that the witnesses are unique and do not help the (unbounded) distinguisher who can compute them on its own.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Index Set Hidning.</h6>

    <p class="text-gray-300">Assume there exist sets <span class="math">\\mathbf{S},\\mathbf{S}^{\\prime}</span> of size at most <span class="math">\\mathbf{K}</span> and an adversary <span class="math">\\mathcal{A}</span> which distinguishes <span class="math">(\\rho,\\mathsf{crs})</span> sampled for <span class="math">\\mathbf{S}</span> from <span class="math">(\\rho,\\mathsf{crs})</span> sampled for <span class="math">\\mathbf{S}^{\\prime}</span> with some probability <span class="math">\\alpha</span>. We construct adversaries <span class="math">\\mathcal{B}_{0}</span> distinguishing <span class="math">ck_{0}</span> sampled for <span class="math">S_{1}</span> from <span class="math">ck_{0}</span> sampled for <span class="math">S_{1}^{\\prime}</span> with probability <span class="math">\\alpha_{0}</span> and an adversary <span class="math">\\mathcal{B}_{1}</span> distinguishing <span class="math">ck_{1}</span> sampled for <span class="math">S_{2}</span> from <span class="math">ck_{1}</span> sampled for <span class="math">S_{2}^{\\prime}</span> with probability <span class="math">\\alpha_{1}</span> such that <span class="math">\\alpha\\leq\\frac{\\alpha_{0}+\\alpha_{1}}{2}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{0}</span> takes as input some <span class="math">ck_{0}</span> and <span class="math">h^{\\prime}(\\mathsf{sk}_{0})</span> sampled either for <span class="math">S_{0}</span> or <span class="math">S_{0}^{\\prime}</span> and parses <span class="math">ck_{0}</span> as <span class="math">[\\mathbf{Q}]_{1},[\\mathbf{Q}]_{2},\\mathsf{aux}</span>. It then honestly computes the <span class="math">\\mathsf{crs}</span> by sampling <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2},\\mathbf{N}</span> and following the <span class="math">\\mathsf{K}</span> described in Lemma 3 except that <span class="math">ck_{1}</span> is computed as follows: it samples <span class="math">b\\leftarrow\\{0,1\\}</span> and if <span class="math">b=0</span> it sets <span class="math">(ck_{1},sk_{1})\\leftarrow\\mathsf{CS.KeyGen}(gk_{1},d,K,S_{1})</span> otherwise it sets <span class="math">(ck_{1},sk_{1})\\leftarrow\\mathsf{CS.KeyGen}(gk_{1},d,K,S_{1}^{\\prime})</span>.Note that, with probability <span class="math">1/2</span>, the crs computed by <span class="math">\\mathcal{B}</span> follows exactly the original distribution. This is the case since <span class="math">\\mathbf{B},\\mathbf{D}</span> are uniform matrices conditioned on their sum being equal to <span class="math">(\\mathbf{M}_{1}^{\\top}+\\mathbf{M}_{2}^{\\top})(\\mathbf{Q}_{1}^{\\top}+\\mathbf{Q}_{2}^{\\top})\\mathbf{K}_{1}+\\mathbf{N}^{\\top}\\mathbf{F}^{\\top}\\mathbf{K}_{2}</span> for uniform <span class="math">\\mathbf{K}_{1},\\mathbf{K}_{2}</span>, exactly as in the honest crs generation. Finally <span class="math">\\mathcal{B}_{0}</span> runs <span class="math">\\mathcal{A}(\\rho,\\mathsf{crs},h_{ns}(\\theta)=(h^{\\prime}(\\mathsf{sk}_{0}),h^{\\prime}(\\mathsf{sk}_{1}),\\mathbf{M}_{1},\\mathbf{M}_{2},\\mathbf{N}))</span> and output whatever it outputs.</p>

    <p class="text-gray-300">Similarly, on input <span class="math">ck_{1}</span>, <span class="math">h(\\mathsf{sk}_{1})</span> sampled either for <span class="math">S_{1}</span> or <span class="math">S_{1}^{\\prime}</span>, <span class="math">\\mathcal{B}_{1}</span> samples <span class="math">b\\leftarrow\\{0,1\\}</span> and if <span class="math">b=0</span> it sets <span class="math">(ck_{0},sk_{0})\\leftarrow\\mathsf{CS.KeyGen}(gk,d,K,S_{0})</span> otherwise it sets <span class="math">(ck_{0},sk_{0})\\leftarrow\\mathsf{CS.KeyGen}(gk,d,K,S_{0}^{\\prime})</span> and honestly computes the crs as in the previous case. A simple case analysis shows that <span class="math">\\rho\\leq\\frac{\\rho_{1}+\\rho_{2}}{2}</span>.</p>

    <h5 id="sec-73" class="text-base font-semibold mt-4">Oblivious trapdoor generation</h5>

    <p class="text-gray-300">We show how to obliviously sample a trapdoor given black box access to <span class="math">\\mathsf{CS.OblKeyGen}</span> and <span class="math">\\mathsf{CS^{\\prime}.OblKeyGen}</span>. For oblivious trapdoor generation, given a pair <span class="math">\\rho</span>, <span class="math">\\mathsf{crs}</span> for the quasi argument and set <span class="math">\\mathbf{S^{\\prime}}</span> the oblivious setup <span class="math">\\mathsf{QASum.OblKeyGen}</span> does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(ck_{0}^{\\prime},\\tau_{0}^{\\prime})\\leftarrow\\mathsf{CS.OblKeyGen}(ck_{0},S_{0}^{\\prime})</span> and <span class="math">(ck_{1}^{\\prime},\\tau_{1}^{\\prime})\\leftarrow\\mathsf{CS.OblKeyGen}(ck_{1},S_{1}^{\\prime})</span>.</li>

      <li>Sample <span class="math">([\\mathbf{M}_{1}]_{1},[\\mathbf{M}_{2}]_{2},\\mathbf{M}_{1},\\mathbf{M}_{2})\\leftarrow\\mathcal{M}</span>, <span class="math">([\\mathbf{N}]_{1},\\mathbf{N})\\leftarrow\\mathcal{N}</span>.</li>

      <li>Compute the rest of the <span class="math">\\mathsf{crs}</span> by <span class="math">\\mathsf{K}(ck_{0}^{\\prime},ck_{1}^{\\prime},\\mathbf{M}_{1},\\mathbf{M}_{2},\\mathbf{N})</span>.</li>

    </ul>

    <p class="text-gray-300">Arguing as in the index set hiding proof, the only difference in the oblivious and an honest crs is how the commitment keys are sampled. We can thus use a standard hybrid argument to reduce the property to the oblivious trapdoor generation of the commitment schemes <span class="math">\\mathsf{CS},\\mathsf{CS^{\\prime}}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Corollary 7.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{CS}</span> is the one from fig. 3, and <span class="math">\\mathsf{CS}</span> is the construction of <span class="math">\\mathsf{kCS}</span> of Thm. 6, then <span class="math">\\mathsf{QASum}</span> from fig. 6 is <span class="math">h_{ns}</span>-strong no-signaling where <span class="math">h_{ns}(\\theta)=(\\mathbf{M},\\mathbf{N}_{1},\\mathbf{N}_{2})</span>.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows directly from Theorem 7 and the <span class="math">h_{ns}</span>-strong oblivious property of <span class="math">\\mathsf{QASum}</span>, which in turn follows from applying Theorems 2, 6 to Theorem 13.</p>

    <p class="text-gray-300">5.2.2 Quasi-Arguments for Hadamard Products.</p>

    <p class="text-gray-300">The main result of <em>[x11]</em> was implicitly a quasi-argument for the set of equations <span class="math">b_{i}(b_{i}-1)=0</span>, for all <span class="math">i\\in[d]</span>. We extend their results to equations of the form <span class="math">x_{i}y_{i}=z_{i}</span>, that is <span class="math">\\bm{x}\\circ\\bm{y}=\\bm{z}</span> where <span class="math">\\circ</span> denotes the hadamard product. Let <span class="math">\\mathcal{U},\\mathcal{V},\\mathcal{W}</span> be witness samplable distributions over matrices in <span class="math">\\mathbb{G}_{1}^{d\\times n}</span>, <span class="math">\\mathbb{G}_{2}^{d\\times n}</span> and <span class="math">\\mathbb{G}_{1}^{d\\times n}</span>, respectively, for <span class="math">n,d\\in\\mathbb{N}</span>. Let <span class="math">\\bm{K}=(K,K)</span> with <span class="math">K\\leq d</span> and <span class="math">\\bm{S}=(S,S)</span> with <span class="math">S\\subseteq[d]</span> and <span class="math">S\\leq K</span>. Also let <span class="math">\\mathsf{CS}</span> be an algebraic SSB commitment scheme with commitment space <span class="math">\\mathbb{G}_{\\mu}^{\\overline{K}}</span>. The parameter language is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\text{par}}=\\left\\{[\\mathbf{U}]_{1},[\\mathbf{V}]_{2},[\\mathbf{W}]_{1},[\\mathbf{G}]_{1},[\\mathbf{H}]_{2},[\\mathbf{F}]_{1}\\mid\\exists\\mathbf{U},\\mathbf{V},\\mathbf{W},\\mathbf{G},\\mathbf{H},\\mathbf{F}\\text{ s.t.}\\right.</span> <span class="math">\\left.([\\mathbf{U}]_{1},\\mathbf{U})\\in\\mathsf{Sup}(\\mathcal{U}),([\\mathbf{V}]_{2},\\mathbf{V})\\in\\mathsf{Sup}(\\mathcal{V}),([\\mathbf{W}]_{1},\\mathbf{W})\\in\\mathsf{Sup}(\\mathcal{W}),\\right.</span> <span class="math">\\left.([\\mathbf{G}]_{1},\\mathbf{G},\\mathbf{T}_{\\mathbf{G}})\\in\\mathsf{Sup}(\\mathsf{CS.KeyGen}(gk_{1},n,K,S))\\right.</span> <span class="math">\\left.([\\mathbf{H}]_{2},\\mathbf{H},\\mathbf{T}_{\\mathbf{H}})\\in\\mathsf{Sup}(\\mathsf{CS.KeyGen}(gk_{2},n,K,S))\\right)</span> <span class="math">\\left.([\\mathbf{F}]_{1},\\mathbf{F},\\mathbf{T}_{\\mathbf{F}})\\in\\mathsf{Sup}(\\mathsf{CS.KeyGen}(gk_{1},n,K,S))\\right\\}</span></p>

    <p class="text-gray-300">We assume w.l.o.g. that the corresponding relation is efficiently verifiable. The parameters <span class="math">\\rho=([\\mathbf{U}]_{1},[\\mathbf{V}]_{2},[\\mathbf{W}]_{1},[\\mathbf{G}]_{1},[\\mathbf{H}]_{2},[\\mathbf{F}]_{1})</span>define the following relations:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\rho}^{\\text{yes}}=\\left\\{\\begin{array}[]{l}[u]_{1},[v]_{2},[w]_{2},a,b\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\end{array}\\right\\},</span> <span class="math">\\mathcal{R}_{\\rho,S}^{\\text{no}}=\\left\\{\\begin{array}[]{l}([v]_{1},[u]_{2},[w]_{1}),a,b\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\end{aligned}\\right\\}.</span></p>

    <p class="text-gray-300">That is the partial witness for <span class="math">S</span> is some valid local openings <span class="math">[\\bm{x}_{1}]_{1},[\\bm{x}_{2}]_{2},[\\bm{y}]_{1}</span> w.r.t. to <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span> respectively that satisfy the following: if <span class="math">\\bm{x}_{1}=\\mathbf{U}_{S}\\bm{a}</span> and <span class="math">\\bm{x}_{2}=\\mathbf{V}_{S}\\bm{b}</span> and then it should be the case that <span class="math">\\bm{y}=\\mathbf{W}_{S}\\bm{c}</span> where <span class="math">\\bm{c}=\\bm{a}\\circ\\bm{b}</span>. Here <span class="math">\\bm{a},\\bm{b}</span> is the promise of the adversary. We present the protocol in Fig 7. Essentially, we first have the prover commit to the kronecker product <span class="math">\\bm{a}\\otimes\\bm{b}</span> using a commitment scheme defined by the <span class="math">\\otimes</span> operation of <span class="math">\\mathsf{CS}</span> to itself, and then show that if the split opening of this commitment is <span class="math">\\bm{w}=\\bm{a}\\otimes\\bm{b}</span>, then the opening of <span class="math">\\bm{d}</span> is <span class="math">\\mathbf{D}\\bm{w}</span> where <span class="math">\\mathbf{D}</span> is the linear operation that outputs <span class="math">\\bm{a}\\circ\\bm{b}</span> on input <span class="math">\\bm{a}\\otimes\\bm{b}</span>. The former “promise”, regarding the kronecker product, is verified by the pairing operation, while for the latter construction <span class="math">\\mathsf{QASum}</span> is used.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Theorem 14.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{U},\\mathcal{V},\\mathcal{W}</span> be witness samplable distributions, <span class="math">\\mathcal{D}_{k}</span> be a matrix distribution and <span class="math">\\mathsf{CS}</span> an algebraic SSB commitment scheme with perfect completeness. Also, let <span class="math">\\mathcal{A}</span> be an adversary against <span class="math">h_{ls}</span>-strong local knowledge soundness of <span class="math">\\mathsf{QAHad}</span> where <span class="math">h_{ls}(\\theta)=(\\mathbf{G},\\mathbf{H},\\mathbf{F},\\mathbf{W},[\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2})</span> for a uniformly distributed <span class="math">\\mathbf{R}</span>. Then completeness holds with probability <span class="math">1</span> and for <span class="math">h_{ls}</span>-strong local soundness it holds that <span class="math">\\mathsf{Adv}_{\\text{and}}^{\\mathsf{QAHad}}(\\mathcal{A})\\leq\\mathsf{Adv}_{\\text{and}}^{\\mathsf{QASum}}(\\mathcal{B})</span> where <span class="math">\\mathcal{B}</span> is an adversary against <span class="math">h_{ls\\text{-sum}}</span>-strong local soundness of <span class="math">\\mathsf{QASum}</span> for <span class="math">\\rho_{sum}</span> as computed in Fig. 7 and <span class="math">h_{ls\\text{-sum}}(\\theta_{sum})</span> outputs <span class="math">\\theta_{sum}</span> except the matrices <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2}</span>.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For completeness, we have that</p>

    <p class="text-gray-300"><span class="math">\\bm{u}\\otimes\\bm{v}</span> <span class="math">=\\mathbf{G}\\mathbf{U}\\bm{a}\\otimes\\mathbf{G}\\mathbf{U}\\bm{b}=(\\mathbf{G}\\otimes\\mathbf{H})(\\mathbf{U}\\otimes\\mathbf{V})(\\bm{a}\\otimes\\bm{b})=</span> <span class="math">=(\\mathbf{G}\\otimes\\mathbf{H}-\\mathbf{Z}+\\mathbf{Z})(\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}+\\mathbf{R})(\\bm{a}\\otimes\\bm{b})=</span> <span class="math">=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})(\\mathbf{M}_{1}+\\mathbf{M}_{2})(\\bm{a}\\otimes\\bm{b})</span></p>

    <p class="text-gray-300">and also <span class="math">\\bm{c}_{1}+\\bm{c}_{2}=(\\mathbf{E}_{1}+\\mathbf{E}_{2})(\\bm{a}\\otimes\\bm{b})=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})(\\mathbf{U}\\otimes\\mathbf{V})(\\bm{a}\\otimes\\bm{b})=\\bm{u}\\otimes\\bm{v}</span>, so the pairing test is successful. Finally, noting that <span class="math">\\bm{w}=\\bm{d}=\\mathbf{F}\\mathbf{W}(\\bm{a}\\circ\\bm{b})=\\mathbf{F}\\mathbf{W}\\mathbf{D}(\\bm{a}\\otimes\\bm{b})=\\mathbf{F}\\mathbf{N}(\\bm{a}\\otimes\\bm{b})</span>, we see that</p>

    <p class="text-gray-300">the statement/witness pair <span class="math">([c_{1}]_{1},[c_{2}]_{2},[d]_{1}),\\ a\\otimes b</span> is a yes instance of the sum language for parameters <span class="math">\\rho_{\\mathrm{sum}}</span> and the second condition for verification follows by the completeness of the QASum.</p>

    <p class="text-gray-300">For local knowledge soundness, it is enough to note that the Kronecker part of the knowledge transfer holds unconditionally, that is, if for some promise <span class="math">\\ a,b</span> it holds that <span class="math">\\ u=\\mathbf{G}\\mathbf{U}a</span> and <span class="math">\\ v=\\mathbf{H}\\mathbf{V}b</span>, then by the verification of the pairing condition, <span class="math">\\ c_{1}+\\ c_{2}=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})(\\mathbf{M}_{1}+\\mathbf{M}_{2})(\\ a\\otimes b)</span>, so we efficiently construct a promise for the sum language. Also, the value <span class="math">h_{\\mathrm{ls-sum}}(\\theta_{\\mathrm{sum}})</span> can be computed given <span class="math">h_{ls}(\\theta)</span>. Now, an accepting proof for the hadamard language contains an accepting proof for the sum language and we use that to break <span class="math">q</span>-strong local soundness of QASum. Details follow.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adversary against <span class="math">h_{ls}</span>-strong local knowledge soundness of QAHad. We construct an adversary <span class="math">\\mathcal{B}</span> against <span class="math">h_{\\mathrm{ls-sum}}</span>-strong local knowledge soundness of QASum. <span class="math">\\mathcal{B}</span> takes as input <span class="math">(\\rho_{\\mathrm{sum}},h_{\\mathrm{ls-sum}}(\\theta_{\\mathrm{sum}}),\\ \\mathsf{crs}_{\\mathrm{sum}})</span> and works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\rho_{\\mathrm{sum}}=(gk,[\\mathbf{Q}_{1}]_{1},[\\mathbf{Q}_{2}]_{2},[\\mathbf{F}]_{1},[\\mathbf{M}_{1}]_{1},[\\mathbf{M}_{2}]_{2},[\\mathbf{N}]_{1},\\mathsf{aux}_{\\mathsf{CS}}=(\\mathbf{G},\\mathbf{H}),\\mathsf{aux}_{\\mathcal{M}}=([\\mathbf{U}]_{1},[\\mathbf{V}]_{2}),</span> <span class="math">\\theta_{q_{\\mathrm{sum}}}=(\\mathbf{Q}_{1},\\mathbf{Q}_{2},\\mathbf{G},\\mathbf{H},\\mathbf{F},\\mathbf{N})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\rho=(gk,[\\mathbf{G}]_{1},[\\mathbf{H}]_{2},[\\mathbf{F}]_{2},[\\mathbf{U}]_{1},[\\mathbf{V}]_{2},[\\mathbf{N}]_{1})</span>, <span class="math">h_{ls}(\\theta)=(\\mathbf{G},\\mathbf{H},\\mathbf{F},\\mathbf{N},[\\mathbf{M}_{1}]_{1},[\\mathbf{M}_{2}]_{2})</span>.</li>

      <li>It samples <span class="math">\\mathbf{R}^{\\prime}\\leftarrow\\widetilde{\\mathcal{Z}_{p}^{\\mathcal{K}}}\\times n^{2}</span> and sets <span class="math">[\\mathbf{E}_{1}]_{1}=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})[\\mathbf{M}_{1}]_{1}+[\\mathbf{R}^{\\prime}]_{1},[\\mathbf{E}_{2}]_{2}=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})[\\mathbf{M}_{2}]_{2}-[\\mathbf{R}^{\\prime}]_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">It then executes <span class="math">\\mathcal{A}(\\rho,h_{ls}(\\theta),\\mathsf{crs}=([\\mathbf{E}_{1}]_{1},[\\mathbf{E}_{2}]_{2},\\mathsf{crs}_{\\mathrm{sum}}))</span> until it outputs a statement <span class="math">([\\ u]_{1},[v]_{2},[\\ w]_{1},\\ a,\\ b)</span> together with an accepting proof <span class="math">([c_{1}]_{1},[c_{2}]_{2},\\pi_{\\mathrm{sum}})</span>. It outputs the statement/advice/proof tuple</p>

    <p class="text-gray-300"><span class="math">(([c_{1}]_{1},[c_{2}]_{2},[w]_{1}),\\ a\\otimes b,\\pi_{\\mathrm{sum}}).</span></p>

    <p class="text-gray-300">The <span class="math">\\mathsf{crs}</span> is identically distributed to an honestly computed one. Indeed the only thing computed differently are the values <span class="math">[\\mathbf{E}_{1}]_{1},[\\mathbf{E}_{2}]_{2}</span>, but note that in the reduction they are distributed uniformly conditioned on <span class="math">\\mathbf{E}_{1}+\\mathbf{E}_{2}=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})(\\mathbf{M}_{1}+\\mathbf{M}_{2})=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})(\\mathbf{U}\\otimes\\mathbf{V})</span>, as in the honest <span class="math">\\mathsf{crs}</span> generation.</p>

    <p class="text-gray-300">Now, assuming an accepting proof, and a correct promise <span class="math">\\ a,\\ b</span> given from <span class="math">\\mathcal{A}</span> means that the promise of <span class="math">\\mathcal{B}</span> is also correct. Indeed, we have</p>

    <p class="text-gray-300"><span class="math">c_{1}+c_{2}</span> <span class="math">=\\ u\\otimes v=\\mathbf{G}\\mathbf{U}a\\otimes\\mathbf{H}\\mathbf{V}b=(\\mathbf{G}\\otimes\\mathbf{H})(\\mathbf{U}\\otimes\\mathbf{V})(a\\otimes b)=</span> <span class="math">=(\\mathbf{G}\\otimes\\mathbf{H}-\\mathbf{Z}+\\mathbf{Z})(\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}+\\mathbf{R})(a\\otimes b)=</span> <span class="math">=(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})(\\mathbf{M}_{1}+\\mathbf{M}_{2})(a\\otimes b).</span></p>

    <p class="text-gray-300">Now let <span class="math">\\ x_{1}=\\mathbf{T}_{\\mathbf{Q}}c_{1}</span>, <span class="math">\\ x_{2}=\\mathbf{T}_{\\mathbf{Q}}c_{2}</span>, <span class="math">\\ y=\\mathbf{T}_{\\mathbf{F}}w</span> be the extracted values. We have that</p>

    <p class="text-gray-300"><span class="math">x_{1}+x_{2}</span> <span class="math">=\\mathbf{T}_{\\mathbf{Q}}(c_{1}+c_{2})=\\mathbf{T}_{\\mathbf{Q}}(\\mathbf{Q}_{1}+\\mathbf{Q}_{2})(\\mathbf{M}_{1}+\\mathbf{M}_{2})(a\\otimes b)</span> <span class="math">=(\\mathbf{M}_{S,1}+\\mathbf{M}_{S,2})(a\\otimes b).</span></p>

    <p class="text-gray-300">so indeed the promise is correct. Also assuming that the statement/advice given from <span class="math">\\mathcal{A}</span> is a no-instance for the hadamard language w.r.t. to the set <span class="math">S</span>, then the statement/advice given from <span class="math">\\mathcal{B}</span> is a no-instance for the sum language w.r.t. the same set <span class="math">S</span>. Indeed, we have</p>

    <p class="text-gray-300"><span class="math">\\ y\\neq\\mathbf{W}_{S}(a\\circ b)=\\mathbf{W}_{S}\\mathbf{D}(a\\otimes b)=\\mathbf{N}_{S}(a\\otimes b).</span></p>

    <p class="text-gray-300">So, conditioned on a successful <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{B}</span> outputs an instance/advice such that (1) the extractor gets values that satisfy <span class="math">\\mathcal{R}_{\\rho_{\\mathrm{sum}},S}^{\\mathsf{no}}</span> for <span class="math">\\rho_{\\mathrm{sum}}</span> and (2) a proof that verifies w.r.t. the instance.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We next show that when the distributions <span class="math">\\mathcal{U},\\mathcal{V},\\mathcal{W}</span> guarantee that the sum knowledge transfer argument is secure w.r.t. all possible sets <span class="math">\\mathcal{S}</span>, construction QAHad has <span class="math">h_{ls}</span>-strong local knowledge soundness where <span class="math">h_{ls}</span> includes <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F},\\mathbf{W},[\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2}</span> for a uniform <span class="math">\\mathbf{R}</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Corollary 8.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{D}_{k}</span> be a matrix distribution for which <span class="math">\\mathcal{D}_{k}</span>-SKerMDH and let DDH hold in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span>. Denote <span class="math">\\mathcal{U}_{S}</span> (resp. <span class="math">\\mathcal{V}_{S}</span>, <span class="math">\\mathcal{W}_{S}</span>) the distributions that sample matrices from <span class="math">\\mathcal{U}</span> (res. <span class="math">\\mathcal{V}_{2}</span>, <span class="math">\\mathcal{W}</span>), and restricts them to rows corresponding to <span class="math">S</span>. Then</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If for all <span class="math">S\\subseteq[d]</span> with <span class="math">S\\leq K_{0}</span>, <span class="math">\\mathcal{U}_{S}^{\\top}</span>-MDDH and <span class="math">\\mathcal{V}_{S}^{\\top}</span>-MDDH hold, QAHad is an <span class="math">h_{ls}</span>-strong local knowledge sound proof system, where <span class="math">h_{ls}(\\theta)=(\\mathbf{G},\\mathbf{H},\\mathbf{F},\\mathbf{N},[\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2})</span> for a uniform <span class="math">\\mathbf{R}</span>.</li>

      <li>If for all <span class="math">S,S\\subseteq[d]</span> with <span class="math">S\\leq K</span> the distributions <span class="math">\\mathcal{U}_{S},\\mathcal{V}_{S},\\mathcal{W}_{S}</span> output matrices with the last <span class="math">n^{\\prime}</span> columns being <span class="math">\\mathbf{0}</span>, and <span class="math">\\mathcal{U}_{S}^{\\prime\\top}</span>-MDDH and <span class="math">\\mathcal{V}_{S}^{\\prime\\top}</span>-MDDH hold, with <span class="math">\\mathcal{U}^{\\prime}_{S}</span>, (resp. <span class="math">\\mathcal{V}^{\\prime}_{S}</span>) being <span class="math">\\mathcal{U}_{S}</span> (resp. <span class="math">\\mathcal{V}_{S}</span>) where we delete the trailing zero columns, then QAHad is an <span class="math">h_{ls}</span>-strong local knowledge sound proof system, where <span class="math">h_{ls}(\\theta)=(\\mathbf{G},\\mathbf{H},\\mathbf{F},\\mathbf{W},[\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2})</span>.</li>

    </ol>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By Thm. 14 it is enough to show that QASum is secure for such distribution. This in turn hold when the sum knowledge transfer argument is sound (Thm. 12) which is true if <span class="math">\\mathcal{D}_{k}</span>-SKerMDH holds and <span class="math">(\\mathcal{U}_{S},\\mathcal{V}_{S},h)-</span> MDDH assumption holds (similar in the second case for the distributions we remove the zeros) by Thm. 19. It remains to show that for these distribution the latter condition holds when we are given the extra information <span class="math">h(\\mathbf{U},\\mathbf{V})=([\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2})</span> for a uniform <span class="math">\\mathbf{R}</span>. We show that this is the case if, additionally, DDH hold. That is we need to show that for all <span class="math">S</span> the <span class="math">(\\mathcal{U}_{S},\\mathcal{V}_{S},h)</span>-MDDH holds or equivalently the distributions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $[\\mathbf{U}^{\\top}]_{1},[\\mathbf{V}^{\\top}]_{2},[\\mathbf{U}^{\\top}\\otimes\\mathbf{V}^{\\top}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2},[(\\mathbf{U}\\otimes\\mathbf{V})^{\\top}k-r]_{1},[r]_{2}:k\\leftarrow\\mathbb{Z}_{q}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}};r\\leftarrow\\mathbb{Z}_{q}^{n^{2}};k\\leftarrow\\mathbb{Z}_{q}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[\\mathbf{U}^{\\top}]_{1},[\\mathbf{V}^{\\top}]_{2},[\\mathbf{U}^{\\top}\\otimes\\mathbf{V}^{\\top}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2},[s]_{1},[t]_{2}:s,t\\leftarrow\\mathbb{Z}_{q}^{n^{2}}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\mathbf{U}\\leftarrow\\mathcal{U}_{S};\\mathbf{V}\\leftarrow\\mathcal{V}_{S};\\mathbf{R}\\leftarrow\\mathbb{Z}_{q}^{n^{2}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}$ are computationally indistinguishable.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">S\\subseteq[d]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math">. We show the indistinguishability of these distributions by showing indistinguishability of a sequence of hybrid distributions. In what follows denote </span>\\alpha=([\\mathbf{U}^{\\top}]_{1},[\\mathbf{V}^{\\top}]_{2},[\\mathbf{U}^{\\top}\\otimes\\mathbf{V}^{\\top}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2})<span class="math"> where </span>\\mathbf{U}\\leftarrow\\mathcal{U}_{S},\\mathbf{V}\\leftarrow\\mathcal{V}_{S},\\mathbf{R}\\leftarrow\\mathbb{Z}_{q}^{n^{2}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">0.\\ \\alpha,[(\\mathbf{U}\\otimes\\mathbf{V})^{\\top}k-r]_{1},[r]_{2}:</span> <span class="math">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ r\\leftarrow\\mathbb{Z}_{q}^{n^{2}},\\ k\\leftarrow\\mathbb{Z}_{q}^{n^{2}}</span> <span class="math">1.\\ \\alpha,[(\\mathbf{U}\\otimes\\mathbf{V})^{\\top}(k_{1}\\otimes k_{2})-r]_{1},[r]_{2}:</span> <span class="math">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ r\\leftarrow\\mathbb{Z}_{q}^{n^{2}},\\ \\ \\ \\ k_{1},k_{2}\\leftarrow\\mathbb{Z}_{q}^{n}</span> <span class="math">2.\\ \\alpha,[(\\mathbf{U}^{\\top}k_{1})\\otimes(\\mathbf{V}^{\\top}k_{2})-r]_{1},[r]_{2}:</span> <span class="math">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0\\ \\left.\\ \\alpha,\\left[\\mathbf{u}\\otimes(\\mathbf{V}^{\\top}k_{2})-r\\right]_{1},[r]_{2}:</span> <span class="math">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 1\\ \\left.\\ \\alpha,\\left[r\\right]_{1},[\\mathbf{u}\\otimes(\\mathbf{V}^{\\top}k_{2})-r]_{2}:</span> <span class="math">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0\\ \\left.\\ \\alpha,\\left[r\\right]_{1},[\\mathbf{u}\\otimes v-r]_{2}:</span> <span class="math">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0\\ \\left.\\ \\right.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0\\ \\end{aligned}\\right.</span> <span class="math">6.\\ \\alpha,[s]_{1},[t]_{2}:</span> <span class="math">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ s,t\\leftarrow\\mathbb{Z}_{q}^{n^{2}}</span></p>

    <p class="text-gray-300">We next show that for all <span class="math">1\\leq i\\leq 5</span> the distributions <span class="math">i-1,i</span> are computationally indistinguishable.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case <span class="math">i=1</span>. We show that distinguishing these two distributions reduces to the rank problem in <span class="math">\\mathbb{G}_{1}</span> introduced in <em>[x20]</em>, namely, distinguishing <span class="math">[\\mathbf{A}]_{1}\\in\\mathbb{G}_{1}^{n\\times n}</span> sampled uniformly over all matrices in <span class="math">\\mathbb{G}_{1}^{n\\times n}</span> of rank <span class="math">1</span>, from <span class="math">[\\mathbf{A}]_{1}\\in\\mathbb{G}_{1}^{n\\times n}</span> sampled uniformly over all matrices in <span class="math">\\mathbb{G}_{1}^{n\\times n}</span> of rank <span class="math">n</span>. Now, assume there exists a distinguisher <span class="math">\\mathcal{A}</span> for distributions <span class="math">0</span> and <span class="math">1</span>. We construct a distinguisher <span class="math">\\mathcal{B}</span> against the rank problem. The distinguisher works as follows: on input <span class="math">[\\mathbf{A}]_{1}</span>, it samples $\\mathbf{U}\\leftarrow\\mathcal{U}_{S},\\mathbf{V}\\leftarrow\\mathcal{V}_{S},\\mathbf{R}\\leftarrow\\mathbb{Z}_{q}^{n^{2}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}},\\bm{r}\\leftarrow\\mathbb{Z}_{q}^{n^{2}}<span class="math">. It computes </span>\\mathbf{M}=\\mathbf{U}^{\\top}[\\mathbf{A}]_{1}\\mathbf{V}<span class="math"> and vectorizes it; denote the vectorization as </span>[\\bm{m}]_{1}<span class="math">. it then executes </span>\\mathcal{A}([\\mathbf{U}^{\\top}]_{1},[\\mathbf{V}^{\\top}]_{2},[\\mathbf{U}^{\\top}\\otimes\\mathbf{V}^{\\top}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2},[\\bm{m}]_{1}-[\\bm{r}]_{1},[\\bm{r}]_{2})<span class="math"> and outputs whatever </span>\\mathcal{A}<span class="math"> outputs. Now, note the vectorization </span>[\\bm{m}]_{1}<span class="math"> corresponds to the value </span>[(\\mathbf{U}\\otimes\\mathbf{V})\\bm{m}]_{1}<span class="math">. If </span>[\\mathbf{A}]<span class="math"> is of rank </span>1<span class="math">, then we can write </span>\\mathbf{A}=\\bm{k}_{1}\\bm{k}_{2}^{\\top}<span class="math"> and we have </span>\\mathbf{M}=\\mathbf{U}^{\\top}\\bm{k}_{1}\\bm{k}_{2}^{\\top}\\mathbf{V}=\\mathbf{U}^{\\top}\\bm{k}_{1}(\\mathbf{V}^{\\top}\\bm{k}_{2})^{\\top}<span class="math"> and the vectorization corresponds to </span>(\\mathbf{U}^{\\top}\\bm{k}_{1})\\otimes(\\mathbf{V}^{\\top}\\bm{k}_{2})<span class="math">, namely the case </span>i=0<span class="math">. Otherwise, </span>[\\mathbf{A}]<span class="math"> is of rank </span>n<span class="math">, and we can write its vectorization as </span>\\bm{k}<span class="math">. Then, </span>\\bm{m}<span class="math"> correspond to </span>(\\mathbf{U}^{\\top}\\otimes\\mathbf{V}^{\\top})\\bm{k})<span class="math">, namely the case </span>i=1<span class="math">. As shown in <em>[x20]</em>, the rank problem reduces to </span>\\mathsf{DDH}<span class="math"> with a security loss of </span>\\log n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case <span class="math">i=2</span>. Distributions <span class="math">1,2</span> are perfectly indistinguishability since the only difference is that the latter is computed as <span class="math">[(\\mathbf{U}^{\\top}\\bm{k}_{1})\\otimes(\\mathbf{V}^{\\top}\\bm{k}_{2})-\\bm{r}]_{1}</span>, which equals to <span class="math">[(\\mathbf{U}^{\\top}\\otimes\\mathbf{V}^{\\top})(\\bm{k}_{1}\\otimes\\bm{k}_{2})-\\bm{r}]_{1}</span>, which is the corresponding value of distribution <span class="math">1</span>.</li>

      <li>Case <span class="math">i=3</span>. This case reduces to the <span class="math">\\mathcal{U}_{S}^{\\top}</span>-<span class="math">\\mathsf{MDDH}_{1}</span> assumption. The only difference is that in the forth distribution, we replace <span class="math">\\mathbf{U}^{\\top}\\bm{k}_{1}</span> with a uniform element <span class="math">\\bm{u}</span>. It is enough to show that we can compute the rest of the values given <span class="math">[\\mathbf{U}]_{1},[\\bm{u}]_{1}</span> where <span class="math">[\\bm{u}]</span> is either <span class="math">\\mathbf{U}^{\\top}\\bm{k}_{1}</span> or uniform. We can compute the values as</li>

    </ul>

    <p class="text-gray-300"><span class="math">[\\mathbf{U}^{\\top}]_{1},[\\mathbf{V}^{\\top}]_{2},[\\mathbf{U}^{\\top}]_{1}\\otimes\\mathbf{V}^{\\top}-[\\mathbf{R}]_{1},[\\mathbf{R}]_{2},[\\bm{u}]_{1}\\otimes(\\mathbf{V}^{\\top}\\bm{k}_{2})-[\\bm{r}]_{1},[\\bm{r}]_{2}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we sample <span class="math">\\mathbf{V}\\leftarrow\\mathcal{V}_{S}</span>, $\\mathbf{R}\\leftarrow\\mathbb{Z}_{q}^{n^{2}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}<span class="math">, </span>\\bm{r}\\leftarrow\\mathbb{Z}_{q}^{n^{2}}<span class="math">, </span>\\bm{k}_{2}\\leftarrow\\mathbb{Z}_{q}^{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case <span class="math">i=4</span>. The distributions <span class="math">4</span> and <span class="math">5</span> are perfectly indistinguishable. It is enough to note that in both, the last two elements are uniformly distributed conditioned on their sum of discrete logarithms being equal to <span class="math">\\bm{u}\\otimes(\\mathbf{V}^{\\top}\\bm{k}_{2})</span>.</li>

      <li>Case <span class="math">i=5</span>. This is the same as the case <span class="math">i=3</span> for the value <span class="math">[v]_{2}</span>. This case reduces to the <span class="math">\\mathcal{V}_{S}^{\\top}</span>-<span class="math">\\mathsf{MDDH}_{2}</span> assumption. The only difference is that in the last distribution, we replace <span class="math">\\mathbf{V}^{\\top}\\bm{k}_{2}</span> with a uniform element <span class="math">\\bm{v}</span>. It is enough to show that we can compute the rest of the values given <span class="math">[\\mathbf{V}]_{2},[v]_{2}</span> where <span class="math">\\bm{v}</span> is either <span class="math">\\mathbf{V}^{\\top}\\bm{k}_{2}</span> or uniform. We can compute the values as</li>

    </ul>

    <p class="text-gray-300"><span class="math">[\\mathbf{U}^{\\top}]_{1},[\\mathbf{V}^{\\top}]_{2},[\\mathbf{R}]_{1},\\mathbf{U}^{\\top}\\otimes[\\mathbf{V}^{\\top}]_{2}-[\\mathbf{R}]_{2},[\\bm{r}]_{1},\\bm{u}\\otimes[v]_{2}-[\\bm{r}]_{2},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we sample <span class="math">\\mathbf{U}\\leftarrow\\mathcal{U}_{S}</span>, $\\mathbf{R}\\leftarrow\\mathbb{Z}_{q}^{n^{2}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}<span class="math">, </span>\\bm{r}\\leftarrow\\mathbb{Z}_{q}^{n^{2}}<span class="math">, </span>\\bm{u}\\leftarrow\\mathbb{Z}_{q}^{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case <span class="math">i=6</span>. This again reduces to the rank problem in <span class="math">\\mathcal{G}_{2}</span>. The only difference in the two distributions is that in distribution <span class="math">5</span> the sum of the last two elements, namely <span class="math">\\bm{u}\\otimes\\bm{v}</span> is a vectorized matrix of rank <span class="math">1</span>, namely <span class="math">\\bm{u}\\bm{v}^{\\top}</span>, while in distribution <span class="math">6</span> is a uniformly distributed matrix of rank <span class="math">n</span> (except w.n.p). Given <span class="math">[\\mathbf{A}]_{2}\\in\\mathbb{G}_{2}^{n\\times n}</span> either uniform of rank <span class="math">1</span> or uniform of rank <span class="math">n</span> we can compute all the other values efficiently as follows. Let <span class="math">\\bm{a}</span> be the vectorization of <span class="math">\\mathbf{T}</span>. We compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">[\\mathbf{U}^{\\top}]_{1},[\\mathbf{V}^{\\top}]_{2},[\\mathbf{U}^{\\top}\\otimes\\mathbf{V}^{\\top}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2},[\\bm{r}]_{1},[\\bm{a}]_{2}-[\\bm{r}]_{2},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\mathbf{U}\\leftarrow\\mathcal{U}_{S},\\mathbf{V}\\leftarrow\\mathcal{V}_{S},\\mathbf{R}\\leftarrow\\mathbb{Z}_{q}^{n^{2}\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}},\\bm{r}\\leftarrow\\mathbb{Z}_{q}^{n^{2}}<span class="math">. This implies that distinguishing distributions </span>5,6<span class="math"> reduces to the rank problem, which in turn reduces to </span>\\mathsf{DDH}<span class="math"> in </span>\\mathbb{G}_{2}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <p class="text-gray-300">The proof of oblivious trapdoor generation essentially follows from the oblivious trapdoor generation and index set hiding of the SSB commitments and is similar to the corresponding proofs for the other constructions.</p>

    <p class="text-gray-300">First we show the corresponding lemma to Lemma 3, that is, we construct an indistinguishable crs given only the commitment keys and the matrices <span class="math">\\mathbf{U},\\mathbf{V},\\mathbf{W}</span>.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">There exists a modified crs generation algorithm <span class="math">\\mathsf{K}^{\\prime}</span> that on input <span class="math">(\\rho,\\theta^{\\prime})</span>, where either <span class="math">\\theta^{\\prime}=(\\mathbf{U},\\mathbf{V},\\mathbf{W},[\\mathbf{G}\\otimes\\mathbf{H}-\\mathbf{Z}]_{1},[\\mathbf{Z}]_{2})</span> or <span class="math">\\theta^{\\prime}=(\\mathbf{G},\\mathbf{H},\\mathbf{F},[\\mathbf{U}\\otimes\\mathbf{V}-\\mathbf{R}]_{1},[\\mathbf{R}]_{2})</span> and outputs a crs such that <span class="math">(\\rho,\\mathsf{crs})</span> are identically distributed to the honest algorithm.</p>

    <p class="text-gray-300">The lemma follows by inspection an by noting that with the given values we can compute the crs for the sum as explained in Lemma 3. Again, w.l.o.g. we use the same name for the two algorithms, namely <span class="math">\\mathsf{K}</span> and differentiate them by their input.</p>

    <p class="text-gray-300">We next show that the construction satisfies oblivious extractability.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Theorem 15.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{U},\\mathcal{V},\\mathcal{W}</span> be witness samplable distributions, and <span class="math">\\mathsf{CS}</span> be the algebraic commitment scheme of Fig. 3 for which <span class="math">\\mathsf{CS}\\otimes\\mathsf{CS}</span> is obliviously extractable. Then Construction QAHad of Fig. 7 is <span class="math">h_{ns}</span>-strong oblivious where <span class="math">h_{ns}=([\\mathbf{G}\\otimes\\mathbf{H}-\\mathbf{Z}]_{1},[\\mathbf{Z}]_{2})</span>. Furthermore,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every PPT <span class="math">\\mathcal{A}</span> against index set hiding of QAHad, there exist an adversary <span class="math">\\mathcal{B}</span> against <span class="math">h_{ns}</span>-strong index set hiding property of <span class="math">\\mathsf{CS}</span> such that <span class="math">\\mathsf{Adv}_{\\mathsf{ISH}}^{\\mathsf{QAHad}}(\\mathcal{A})\\leq 3\\mathsf{Adv}_{\\mathsf{ISH}}^{\\mathsf{CS}}(\\mathcal{B})</span>.</li>

      <li>For every <span class="math">\\mathcal{A}</span> against oblivious crs generation of QAHad, there exist an adversary <span class="math">\\mathcal{B}</span> against oblivious crs generation of QASum such that <span class="math">\\mathsf{Adv}_{\\mathsf{oblv}}^{\\mathsf{QAHad}}(\\mathcal{A})\\leq\\mathsf{Adv}_{\\mathsf{oblv}}^{\\mathsf{QASum}}(\\mathcal{B})</span>.</li>

    </ol>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It is enough to show that index set hiding holds and that we can sample a tuple <span class="math">(\\rho,\\mathsf{crs})</span> indistinguishable from the one we are given, along with a valid trapdoor. This is the case because the commitment keys are perfectly binding in <span class="math">S^{\\prime}</span>, which means that the witnesses are unique and do not help the (unbounded) distinguisher who can compute them on its own.</p>

    <p class="text-gray-300"><span class="math">h_{ns}</span>-Strong Index Set Hidning. Assume there exist sets <span class="math">S</span>, <span class="math">S^{\\prime}</span> of size at most <span class="math">K</span> and an adversary <span class="math">\\mathcal{A}</span> which distinguishes <span class="math">(\\rho,\\mathsf{crs},h_{ns}(\\theta))</span> sampled for <span class="math">S</span> from <span class="math">(\\rho,\\mathsf{crs},h_{ns}(\\theta))</span> sampled for <span class="math">S^{\\prime}</span> with some probability <span class="math">\\alpha</span>. We construct adversaries <span class="math">\\mathcal{B}</span> distinguishing <span class="math">ck</span> sampled for <span class="math">S</span> from <span class="math">ck</span> sampled for <span class="math">S</span> with probability <span class="math">\\beta</span> such that <span class="math">\\alpha\\leq 2\\beta</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> takes as input some <span class="math">ck</span> sampled either for <span class="math">S</span> or <span class="math">S^{\\prime}</span> which is parsed as <span class="math">[\\mathbf{G}]_{1}</span> and honestly computes the crs following <span class="math">\\mathsf{K}</span> of Lemma 4 using the values <span class="math">[\\mathbf{G}\\otimes\\mathbf{H}-\\mathbf{Z}]_{1},[\\mathbf{Z}]_{2}</span> which are included in <span class="math">h_{ns}</span> except that <span class="math">[\\mathbf{H}]_{2},\\mathbf{H},\\mathbf{T}_{\\mathbf{H}},[\\mathbf{F}]_{1},\\mathbf{F},\\mathbf{T}_{\\mathbf{F}}</span> are computed as follows: it samples <span class="math">b\\leftarrow\\{0,1\\}</span> and if <span class="math">b=0</span> it sets</p>

    <p class="text-gray-300"><span class="math">([\\mathbf{H}]_{2},\\mathbf{H},\\mathbf{T}_{\\mathbf{H}})\\leftarrow\\mathsf{CS.KeyGen}(gk_{2},d,K,S),\\quad([\\mathbf{F}]_{1},\\mathbf{F},\\mathbf{T}_{\\mathbf{F}})\\leftarrow\\mathsf{CS.KeyGen}(gk_{1},d,K,S)</span></p>

    <p class="text-gray-300">otherwise it sets</p>

    <p class="text-gray-300"><span class="math">([\\mathbf{H}]_{2},\\mathbf{H},\\mathbf{T}_{\\mathbf{H}})\\leftarrow\\mathsf{CS.KeyGen}(gk_{2},d,K,S^{\\prime}),\\quad([\\mathbf{F}]_{1},\\mathbf{F},\\mathbf{T}_{\\mathbf{F}})\\leftarrow\\mathsf{CS.KeyGen}(gk_{1},d,K,S^{\\prime})</span></p>

    <p class="text-gray-300">If the guess <span class="math">b</span> is correct, by witness samplability of <span class="math">\\mathbf{U},\\mathbf{V},\\mathbf{W}</span> the distribution of <span class="math">\\rho</span> is not changed, and since the <span class="math">\\mathsf{crs}</span> is computed as an honest one conditioned on <span class="math">\\rho</span>, index set hiding follows holds with probability <span class="math">\\frac{\\alpha}{2}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Oblivious trapdoor generation: Here, we can simply use the oblivious trapdoor generation of protocol QASum. The conditions of corollary 5 are satisfied since we include the values <span class="math">[\\mathbf{G}\\otimes\\mathbf{H-Z}]_{1},[\\mathbf{Z}]_{2}</span> in <span class="math">h_{ns}</span> and by Thm 6 the commitment key for the sum has oblivious trapdoor generation. It is enough to show that we can compute the crs for the QAHad given a crs for QASum. But this is easy since when given a pair <span class="math">(\\rho_{\\text{sum}},\\text{crs}_{\\text{sum}})</span> we execute the oblivious crs algorithm QASum.OblKeyGen(<span class="math">\\rho</span>, crs, <span class="math">\\mathbf{S}=(S,S)</span>) as in Lemma 4.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Corollary 9.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{CS}</span> is the one from fig. 3, then QAHad from fig. 7 is <span class="math">h_{ns}</span>-strong no-signaling where <span class="math">h_{ns}=([\\mathbf{G}\\otimes\\mathbf{H-Z}]_{1},[\\mathbf{Z}]_{2},\\mathbf{U},\\mathbf{V},\\mathbf{W})</span> .</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows directly from Theorem 7 and the <span class="math">h_{ns}</span>-strong oblivious trapdoor generation of QAHad which is shown in Thm. 15. ∎</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}_{\\mathrm{par}}(gk,d,K,S)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([\\mathbf{U}]_1, \\mathbf{U}) \\gets \\mathcal{U}</span> ;  <span class="math">([\\mathbf{V}]_2, \\mathbf{V}) \\gets \\mathcal{V}</span> .  <span class="math">([\\mathbf{W}]_1, \\mathbf{W}) \\gets \\mathcal{W}</span> ;</li>

      <li><span class="math">([\\mathbf{G}]_1, \\mathbf{G}, \\mathbf{T}_{\\mathbf{G}}) \\gets \\text{CS.KeyGen}(gk_1, n, d, K, S)</span> ;</li>

      <li><span class="math">([\\mathbf{H}]_2, \\mathbf{H}, \\mathbf{T}_{\\mathbf{H}}) \\gets \\text{CS.KeyGen}(gk_2, n, d, K, S)</span> ;</li>

      <li><span class="math">([\\mathbf{F}]_1, \\mathbf{F}, \\mathbf{T}_{\\mathbf{F}}) \\gets \\text{CS.KeyGen}(gk_1, n, d, K, S)</span> ;</li>

      <li>Output  <span class="math">(\\rho, \\theta)</span>  where  <span class="math">\\rho := (gk, [\\mathbf{G}]_1, [\\mathbf{H}]_2, [\\mathbf{F}]_1, [\\mathbf{U}]_1, [\\mathbf{V}]_2, [\\mathbf{W}]_1)</span> , and  <span class="math">\\theta := (\\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{T}_{\\mathbf{G}}, \\mathbf{T}_{\\mathbf{H}}, \\mathbf{T}_{\\mathbf{F}}, \\mathbf{U}, \\mathbf{V}, \\mathbf{W})</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{K}(\\rho ,\\theta)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\rho = (gk, [\\mathbf{G}]_1, [\\mathbf{H}]_2, [\\mathbf{F}]_1, [\\mathbf{U}]_1, [\\mathbf{V}]_2, [\\mathbf{W}]_1)</span> ,  <span class="math">\\theta = (\\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{T}_{\\mathbf{G}}, \\mathbf{T}_{\\mathbf{H}}, \\mathbf{T}_{\\mathbf{F}}, \\mathbf{U}, \\mathbf{V}, \\mathbf{W})</span> .</li>

      <li><span class="math">(ck, sk) \\gets kCS.KeyGen(gk, [\\mathbf{G}]_1, [\\mathbf{H}]_2, \\mathbf{G}, \\mathbf{H})</span>  and parse  <span class="math">ck</span>  as  <span class="math">[\\mathbf{Q}_1]_1, [\\mathbf{Q}_2]_2</span> , aux and  <span class="math">sk</span>  as  <span class="math">\\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{T}_{\\mathbf{Q}}</span> .</li>

      <li>Sample  <span class="math">\\mathbf{R} \\in \\mathbb{Z}_q^{d^2 \\times n^2}</span>  and set  <span class="math">\\mathbf{M}_1 = \\mathbf{U} \\otimes \\mathbf{V} - \\mathbf{R}</span>  and  <span class="math">\\mathbf{M}_2 = \\mathbf{R}</span> . Set  <span class="math">\\mathbf{N} = \\mathbf{W}\\mathbf{D}</span> .</li>

      <li>Set  <span class="math">\\rho_{\\mathrm{sum}} := (gk, [\\mathbf{Q}_1]_1, [\\mathbf{Q}_2]_1, [\\mathbf{F}]_2, [\\mathbf{M}_1]_1, [\\mathbf{M}_2]_2, [\\mathbf{N}]_1)</span> ,  <span class="math">\\theta_{\\mathrm{sum}} := (\\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{F}, \\mathbf{T}_{\\mathbf{Q}}, \\mathbf{T}_{\\mathbf{F}}, \\mathbf{M}_1, \\mathbf{M}_2, \\mathbf{N})</span> .</li>

      <li>Set  <span class="math">(\\mathrm{crs}_{\\mathrm{sum}}, \\tau_{\\mathrm{sum}}) \\gets \\mathrm{QASum}(\\rho_{\\mathrm{sum}}, \\theta_{\\mathrm{sum}})</span> .</li>

      <li>Sample  <span class="math">\\mathbf{R}&#x27; \\gets \\mathbb{Z}_p^{\\overline{K}^2 \\times n^2}</span>  and set  <span class="math">[\\mathbf{E}_1]_1 = [\\mathbf{Q}_1(\\mathbf{U} \\otimes \\mathbf{V}) - \\mathbf{R}&#x27;)]_1</span> ,  <span class="math">[\\mathbf{E}_2]_2 = [\\mathbf{Q}_2(\\mathbf{U} \\otimes \\mathbf{V}) + \\mathbf{R}&#x27;]_2</span> .</li>

      <li>Output  <span class="math">\\mathrm{crs} = ([\\mathbf{E}_1]_1, [\\mathbf{E}_2]_2, \\mathrm{crs}_{\\mathrm{sum}})</span> ,  <span class="math">\\tau = (\\mathbf{T}_{\\mathbf{G}}, \\mathbf{T}_{\\mathbf{H}}, \\mathbf{T}_{\\mathbf{F}})</span> .</li>

    </ul>

    <p class="text-gray-300">Prove(crs,  <span class="math">[x]_1, [y]_2, [w]_1, a, b)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathrm{crs} = ([\\mathbf{E}_1]_1, [\\mathbf{E}_2]_2, \\mathrm{crs}_{\\mathrm{sum}})</span> .</li>

      <li>Set  <span class="math">[c_1]_1 = [\\mathbf{E}_1]_1(a \\otimes b), [c_2]_2 = [\\mathbf{E}_2]_2(a \\otimes b), [d]_1 = [w]_1</span> .</li>

      <li><span class="math">\\pi_{\\mathrm{sum}} = \\mathrm{QASum.Prove}(\\mathrm{crs}_{\\mathrm{sum}}, [c_1]_1, [c_2]_1, [d]_1, a \\otimes b)</span> .</li>

      <li>Output  <span class="math">\\pi := ([c_1]_1, [c_2]_1, \\pi_{\\mathrm{sum}})</span> .</li>

    </ul>

    <p class="text-gray-300">Verify  <span class="math">(\\mathrm{crs},[u]_1,[v]_2,[w]_1,\\pi)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathrm{crs} = ([\\mathbf{E}_1]_1, [\\mathbf{E}_2]_2, \\mathrm{crs}_{\\mathrm{sum}})</span> ,  <span class="math">\\pi := ([c_1]_1, [c_2]_1, \\pi_{\\mathrm{sum}})</span> .</li>

      <li>Compute  <span class="math">[u \\otimes v]_T</span>  using the pairing operation and output 1 iff</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>QASum.Verify  <span class="math">(\\mathrm{crs}_{\\mathrm{sum}}, [c_1]_1, [c_2]_2, [w]_1) = 1</span>  and</li>

      <li><span class="math">[u\\otimes v]_T = e([c_1]_1,[1]_2) + e([1]_1,[c_2]_2)</span></li>

    </ol>

    <p class="text-gray-300">Extract  <span class="math">(\\tau, [u]_1, [v]_2, [w]_1, \\pi)</span> : Parse  <span class="math">\\tau</span>  as  <span class="math">(\\mathbf{T}_{\\mathbf{G}}, \\mathbf{T}_{\\mathbf{H}}, \\mathbf{T}_{\\mathbf{F}})</span>  and output  <span class="math">[x_1]_1 := \\mathbf{T}_{\\mathbf{G}}^\\top [u]_1, [x_2]_2 := \\mathbf{T}_{\\mathbf{H}}^\\top [v]_1, [y]_1 := \\mathbf{T}_{\\mathbf{F}}^\\top [w]_1</span> .</p>

    <p class="text-gray-300">Figure 7: Quasi argument QAHad for knowledge transfer of hadammard product. Here  <span class="math">\\mathbf{D} \\in \\mathbb{Z}_q^{n \\times n^2}</span>  is the matrix such that  <span class="math">\\mathbf{D}(a \\otimes b) = a \\circ b</span></p>

    <p class="text-gray-300">6 Delegation for Arithmetic Circuit Evaluation</p>

    <p class="text-gray-300">Formally, we define a delegation scheme as follows.</p>

    <p class="text-gray-300">Definition 10. A triplet of algorithms <span class="math">\\mathsf{Del} = (\\mathsf{Setup}, \\mathsf{Prove}, \\mathsf{Verify})</span> is a delegation scheme for circuit evaluation with preprocessing if for any circuit <span class="math">C: \\mathbb{Z}_p^{n_0} \\to \\mathbb{Z}_p^{n_d}</span>:</p>

    <p class="text-gray-300">Completeness: For any <span class="math">x, y</span> such that <span class="math">y = C(x)</span> it holds</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{g k \\leftarrow \\mathcal{G} (1 ^ {*})} \\left[ \\text{Verify}(\\operatorname{crs}, x, y, \\pi) = 1 \\mid \\operatorname{crs} \\leftarrow \\text{Setup}(g k, C), \\pi \\leftarrow \\text{Prove}(\\operatorname{crs}, x, y) \\right] \\geq 1 - \\operatorname{negl}(\\kappa),</span></div>

    <p class="text-gray-300">Soundness: For any adversary <span class="math">\\mathcal{A}</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{g k \\leftarrow \\mathcal{G} (1 ^ {*})} \\left[ \\text{Verify}(\\operatorname{crs}, x, y, \\pi) = 1 \\text{ and } y \\neq C (x) \\mid \\operatorname{crs} \\leftarrow \\text{Setup}(g k, C), (x, y, \\pi) \\leftarrow \\mathcal{A}(\\operatorname{crs}) \\right] \\leq \\operatorname{negl}(\\kappa),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency: The setup algorithm and the prover run in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\kappa)<span class="math">. The size of each proof is </span>O(\\kappa)<span class="math"> and verification time </span>n\\mathrm{poly}(\\kappa) + \\mathrm{poly}(\\kappa)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6.1 The Scheme</p>

    <p class="text-gray-300">In the delegation scheme from [GR19] the prover, gives <span class="math">3d</span> commitments <span class="math">[L_1]_1, \\ldots, [L_d]_1</span>, <span class="math">[R_1]_2, \\ldots, [R_d]_2</span>, <span class="math">[O_1]_1, \\ldots, [O_d]_1</span> to, respectively, the left, right and output wires of each level of the circuit. Then, it gives a linear and quadratic knowledge transfer arguments to "transfer" knowledge of the opening from the input level, which is known to the verifier, to the next levels. Finally, the verifier checks that the commitment to the output opens to <span class="math">y</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We give a "compressed" version of [GR19] where the <span class="math">3d</span> commitments are shrunken into 3 no-signaling SSB commitments, and the <span class="math">2d</span> knowledge transfer arguments are shrunk into 2 quasi arguments. From the SSB commitments we can extract <span class="math">[L_i]_1[R_i]_2, [O_j]_1</span> for <span class="math">j = i - 1</span> or <span class="math">j = i</span>. Local knowledge soundness of the quasi arguments imply that knowledge is "transferred" from <span class="math">[O_{i-1}]_1</span> to <span class="math">[L_i]_1, [R_i]_2</span> or from <span class="math">[L_i]_1, [R_i]_2</span> to <span class="math">[O_i]_1</span>. One important technical problem with this approach is that the linear knowledge transfer argument is between the next level and all previous levels. That is, the knowledge is transferred from commitments to the output in all previous levels <span class="math">[O_1]_1, \\ldots, [O_i]_1</span>, to commitments to the left and right wires in the next level <span class="math">[L_{i+1}]_1, [R_{i+1}]_2</span>. This means the quasi-argument must extract <span class="math">O(d)</span> values and hence is not succinct. We solve this issue by computing <span class="math">L_i, R_i, O_i</span> as commitments also to the respective wires of all previous levels. Consider an arithmetic circuit <span class="math">C: \\mathbb{Z}_p^{n_0} \\to \\mathbb{Z}_p^{n_d}</span>. The circuit can be naturally sliced into <span class="math">d + 1</span> levels, where level 0 contains the input and level <span class="math">i</span> is formed by a set of <span class="math">n_i</span> multiplication gates, the inputs of which depends on a linear transformation of outputs of previous levels.¹⁹ Let <span class="math">N_i = \\sum_{j=0}^i</span> and <span class="math">N = N_d</span>. Denote by <span class="math">\\pmb{a}_i, \\pmb{b}_i, \\pmb{c}_i \\in \\mathbb{Z}_p^{N_i}</span> the left, right and output wires of level 1, ..., <span class="math">i</span> respectively. That is <span class="math">\\pmb{a}_i = \\left( \\begin{array}{c} \\pmb{a}_{i-1} \\\\ \\mathbf{D}_i \\pmb{c}_{i-1} \\end{array} \\right)</span> and <span class="math">\\pmb{b}_i = \\left( \\begin{array}{c} \\pmb{b}_{i-1} \\\\ \\mathbf{E}_i \\pmb{c}_{i-1} \\end{array} \\right)</span>, where <span class="math">\\mathbf{D}_i, \\mathbf{E}_i \\in \\mathbb{Z}_p^{n_i \\times N_{i-1}}</span> are defined by the circuit's linear gates, <span class="math">\\pmb{a}_0, \\pmb{b}_0</span> are of size 0 and <span class="math">\\pmb{c}_0 = \\pmb{x}</span> is the input. Let <span class="math">\\mathbf{D} \\in \\mathbb{Z}_p^{N-n_0 \\times N}</span> (resp. <span class="math">\\mathbf{E}</span>) be the matrix such that the <span class="math">i</span>-th row of <span class="math">\\mathbf{D}</span> is $(\\mathbf{D}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{0}_{n_i \\times N-N_{i-1}})<span class="math">. Note that matrices </span>\\mathbf{D}, \\mathbf{E}<span class="math"> are lower triangular. For the outputs we have </span>\\pmb{c}_i = \\pmb{a}_i \\circ \\pmb{b}_i$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Denote <span class="math">\\pmb{a} = \\pmb{a}_d</span>, <span class="math">\\pmb{b} = \\pmb{b}_d</span> and <span class="math">\\pmb{c} = \\pmb{c}_{d-1}</span>. The evaluation of the circuit is correct if <span class="math">\\left( \\begin{array}{l} \\pmb{a} \\\\ \\pmb{b} \\end{array} \\right) = \\left( \\begin{array}{l} \\mathbf{D} \\\\ \\mathbf{E} \\end{array} \\right) \\pmb{c}</span> and <span class="math">\\pmb{c} = \\pmb{a} \\circ \\pmb{b}</span>. Next, consider Pedersen commitment keys <span class="math">\\mathbf{U}_i^<em> \\gets \\mathbb{Z}_p^{1 \\times n_i}</span>, <span class="math">\\mathbf{V}_i^</em> \\gets \\mathbb{Z}_p^{1 \\times n_i}</span> and <span class="math">\\mathbf{W}_i^<em> \\gets \\mathbb{Z}_p^{1 \\times n_i}</span> and define <span class="math">\\mathbf{U}_i = (\\mathbf{U}_1^</em>, \\ldots, \\mathbf{U}_i^<em>)</span>, <span class="math">\\mathbf{V}_i = (\\mathbf{V}_1^</em>, \\ldots, \\mathbf{V}_i^<em>)</span>, for <span class="math">i \\in [d]</span>, <span class="math">\\mathbf{W}_i = (\\mathbf{W}_1^</em>, \\ldots, \\mathbf{W}_i^*)</span>,</p>

    <p class="text-gray-300">¹⁹We consider w.l.o.g. only linear transformations since if we can handle affine ones by including a wire with the value 1 in the input.</p>

    <p class="text-gray-300">for <span class="math">i \\in [d - 1]</span>. Consider commitments (represented in <span class="math">\\mathbb{Z}_p</span>) to left, right and output wires as <span class="math">O_i = \\mathbf{W}_i \\mathbf{c}_i</span>, <span class="math">\\mathbf{O} = \\mathbf{W} \\mathbf{c}</span>, <span class="math">L_i = \\mathbf{U}_i \\mathbf{a}_i = \\mathbf{U} \\mathbf{a}</span>, <span class="math">R_i = \\mathbf{V}_i \\mathbf{b}_i</span>, <span class="math">\\mathbf{R} = \\mathbf{V} \\mathbf{b}</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {U} = \\left( \\begin{array}{c c c} \\mathbf {U} _ {1} ^ {*} &amp;amp; &amp;amp; \\mathbf {0} \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\\\ \\mathbf {U} _ {1} ^ {*} &amp;amp; \\dots &amp;amp; \\mathbf {U} _ {d} ^ {*} \\end{array} \\right), \\mathbf {V} = \\left( \\begin{array}{c c c} \\mathbf {V} _ {1} ^ {*} &amp;amp; &amp;amp; \\mathbf {0} \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\\\ \\mathbf {V} _ {1} ^ {*} &amp;amp; \\dots &amp;amp; \\mathbf {V} _ {d} ^ {*} \\end{array} \\right), \\mathbf {W} = \\left( \\begin{array}{c c c} \\mathbf {W} _ {1} ^ {*} &amp;amp; &amp;amp; \\mathbf {0} \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\\\ \\mathbf {W} _ {1} ^ {*} &amp;amp; \\dots &amp;amp; \\mathbf {W} _ {d - 1} ^ {*} \\end{array} \\right), \\tag {6}</span></div>

    <p class="text-gray-300"><span class="math">O = (O_{1},\\ldots ,O_{d - 1})^{\\top},L = (L_{1},\\ldots ,L_{d})^{\\top},R = (R_{1},\\ldots ,R_{d})^{\\top}.</span></p>

    <p class="text-gray-300">We additionally pick <span class="math">\\mathbf{G},\\mathbf{H},\\mathbf{F}</span> for computing SSB commitments to vectors of size <span class="math">d</span> and publish <span class="math">[\\mathbf{GU}]_1, [\\mathbf{HV}]_2, [\\mathbf{FW}]_2</span>. The prover computes <span class="math">[\\hat{L}]_1 = [\\mathbf{GU}]_1\\mathbf{a}, [\\hat{R}]_2 = [\\mathbf{HV}]_2\\mathbf{b}, [\\hat{O}]_1 = [\\mathbf{FW}]_1\\mathbf{c}</span> and gives a quasi-argument of linear knowledge transfer from <span class="math">\\mathbf{x}, [\\mathbf{O}]_1, \\mathbf{y}</span> to <span class="math">[\\mathbf{L}]_1, [\\mathbf{R}]_2</span> with the following structure</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c} x \\\\ O \\\\ y \\\\ L \\\\ R \\end{array} \\right) = \\left( \\begin{array}{c c c} \\hline \\text{input} &amp;amp; \\text{mid-wires} &amp;amp; \\text{output} \\\\ \\hline \\mathbf {I} _ {n _ {0}} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {0} \\\\ \\hline \\mathbf {0} &amp;amp; \\mathbf {W} &amp;amp; 0 \\\\ \\hline \\mathbf {0} &amp;amp; \\mathbf {0} &amp;amp; \\mathbf {I} _ {n _ {d}} \\\\ \\hline \\boxed {\\mathbf {U D}} &amp;amp; &amp;amp; \\mathbf {0} \\\\ \\hline \\mathbf {V E} &amp;amp; &amp;amp; \\mathbf {0} \\end{array} \\right) \\left( \\begin{array}{c} x \\\\ c \\\\ y \\end{array} \\right). \\tag {7}</span></div>

    <p class="text-gray-300">That is, we can extract <span class="math">[L_i]_1, [R_i]_2, [O_{i-1}]_1</span> and, if we are additionally given <span class="math">c_{i-1}</span> such that <span class="math">O_{i-1} = W_{i-1}c_{i-1}</span>, then <span class="math">L_i = \\mathbf{U}_i\\mathbf{D}_ic_i, R_i = \\mathbf{V}_i\\mathbf{E}_ic_i</span>. We also use a quasi-argument of knowledge transfer of the hadamard product from <span class="math">[L]_1, [R]_2</span> to <span class="math">[O]_1</span>. In this case we extract <span class="math">[L_i]_1, [R_i]_2, [O_i]_1</span> and, if we are additionally given <span class="math">a_i, b_i</span> such that <span class="math">L_i = \\mathbf{U}_ia_i</span> and <span class="math">R_i = \\mathbf{V}_ib_i</span>, then <span class="math">O_i = W_i(a_i \\circ b_i)</span>.</p>

    <p class="text-gray-300">We need to make one last change that will allow us to take into account the input <span class="math">x</span> and the claimed output <span class="math">y</span>. Essentially, we make the first and last commitment key (trivially) perfectly binding by using as a commitment key the identity matrix. The security properties still hold in a trivial way (the <span class="math">\\mathbf{I}_{n_0}</span>-MDDH assumption is perfectly secure). We change accordingly the SSB commitment key, that is we set <span class="math">\\mathbf{F}&#x27; = \\begin{pmatrix} \\mathbf{I}_{n_0} &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; \\mathbf{F} &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; \\mathbf{I}_{n_d} \\end{pmatrix}</span>. Note that the extraction trapdoor remains the same, but the extractor can trivially extract the values corresponding to <span class="math">x, y</span> regardless of <span class="math">\\mathbf{F}&#x27;</span> distribution. In other words, our commitment key is always perfectly binding in the first <span class="math">n_0</span> and <span class="math">n_d</span> coordinates. We denote with <span class="math">\\mathbf{W}&#x27;</span> the modified matrix where we change the first and last rows with <span class="math">(\\mathbf{I}_{n_0} \\mid \\mathbf{0})</span> and <span class="math">(\\mathbf{0} \\mid \\mathbf{I}_{n_d})</span> respectively. Therefore, if <span class="math">\\mathbf{O} = \\mathbf{W}&#x27;\\mathbf{c}</span>, we get that <span class="math">O_0 = x</span> and <span class="math">O_d = y</span>.</p>

    <h2 id="sec-85" class="text-2xl font-bold">6.2 Proof of Security</h2>

    <p class="text-gray-300">Theorem 16. Let <span class="math">\\mathcal{A}</span> be an adversary against Adaptive Soundness of the delegation scheme of Fig. 8, that outputs an input/output pair <span class="math">x, y^<em></span> and a valid proof <span class="math">\\pi := \\left([ \\hat{L} ]_1, [ \\hat{R} ]_2, [ \\hat{O} ]_1, \\pi_{\\mathrm{had}}, \\pi_{\\mathrm{blin}}\\right)</span> but <span class="math">y^</em> \\neq C(x)</span>. Then there exists a distinguisher <span class="math">\\mathcal{D}_{\\mathrm{blin}}</span>, <span class="math">\\mathcal{D}_{\\mathrm{had}}</span> and adversaries <span class="math">\\mathcal{B}_{\\mathrm{blin}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{had}}</span> against the no-signaling property of QABlin and QAHad, respectively, and adversaries <span class="math">\\mathcal{A}_{\\mathrm{blin}}</span>, <span class="math">\\mathcal{A}_{\\mathrm{had}}</span> against local knowledge soundness of QABlin and local knowledge soundness QAHad, respectively, such that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{Adv}_{\\mathrm{Del}}(\\mathcal{A}) \\leq 2 (d + 1) \\left(\\operatorname{Adv}_{\\mathrm{NS}}^{\\mathrm{QAHad}} (\\mathcal{D}_{\\mathrm{had}}, \\mathcal{B}_{\\mathrm{had}}) + \\operatorname{Adv}_{\\mathrm{NS}}^{\\mathrm{QAHad}} (\\mathcal{D}_{\\mathrm{had}}, \\mathcal{B}_{\\mathrm{had}})\\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(d + 1) \\left(\\operatorname{Adv}_{\\mathrm{snd}}^{\\mathrm{QAHad}} (\\mathcal{A}_{\\mathrm{had}}) + \\operatorname{Adv}_{\\mathrm{snd}}^{\\mathrm{QABLin}} (\\mathcal{A}_{\\mathrm{blin}})\\right).</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Proof. Let <span class="math">\\mathrm{Game}_0</span> be the soundness game:</p>

    <p class="text-gray-300">From the linear gates of  <span class="math">C</span>  compute matrices  <span class="math">\\mathbf{D},\\mathbf{E}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">([\\mathbf{F}]_1, \\mathbf{F}, \\mathbf{T}_{\\mathbf{F}}) \\gets \\text{CS.KeyGen}(gk, d - 1, 1, \\emptyset)</span> ,</li>

    </ul>

    <p class="text-gray-300"><span class="math">([\\mathbf{G}]_1,\\mathbf{G},\\mathbf{T}_{\\mathbf{G}})\\gets \\mathrm{CS.KeyGen}(gk,d,1,\\emptyset),([\\mathbf{H}]_1,\\mathbf{H},\\mathbf{T}_{\\mathbf{H}})\\gets \\mathrm{CS.KeyGen}(gk,d,1,\\emptyset);</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\mathbf{U}, \\mathbf{V}, \\mathbf{W}</span>  as in equation 6. Define  <span class="math">\\mathbf{W}&#x27;</span>  as the matrix  <span class="math">\\mathbf{W}</span>  augmented with  <span class="math">(\\mathbf{I}_{n_0} \\mid \\mathbf{0})</span>  and  <span class="math">(\\mathbf{0} \\mid \\mathbf{I}_{n_d})</span>  as its first and last row.</li>

      <li>Let  <span class="math">\\rho_{\\mathrm{bln}} = (gk, [\\mathbf{F}&#x27;]_1, [\\mathbf{G}]_1, [\\mathbf{H}]_2, [\\mathbf{W}&#x27;]_1, [\\mathbf{UD}]_1, [\\mathbf{VE}]_2)</span>  and  <span class="math">\\theta_{\\mathrm{bln}} = (\\mathbf{F}, \\mathbf{G}, \\mathbf{H}, \\mathbf{T}_{\\mathbf{F}}, \\mathbf{T}_{\\mathbf{G}}, \\mathbf{T}_{\\mathbf{H}}, \\mathbf{U}&#x27;, \\mathbf{UD}, \\mathbf{VE})</span> , where  <span class="math">\\mathbf{F}&#x27;</span>  contains rows  <span class="math">(\\mathbf{I}_n \\mid \\mathbf{0} \\mid \\mathbf{0})</span> ,  <span class="math">(\\mathbf{0} \\mid \\mathbf{F} \\mid \\mathbf{0})</span> ,  <span class="math">(\\mathbf{0} \\mid \\mathbf{0} \\mid \\mathbf{I}_{n_d})</span> .</li>

      <li>Let  <span class="math">\\rho_{\\mathrm{had}} = (gk, [\\mathbf{G}]_1, [\\mathbf{H}]_2, [\\mathbf{F}&#x27;]_1, [\\mathbf{U}]_1, [\\mathbf{V}]_2, [\\mathbf{U}]_1)</span>  and  <span class="math">\\theta_{\\mathrm{had}} = (\\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{T}_{\\mathbf{G}}, \\mathbf{T}_{\\mathbf{H}}, \\mathbf{T}_{\\mathbf{F}}, \\mathbf{U}, \\mathbf{V}, \\mathbf{W})</span> , where  <span class="math">\\mathbf{F}&#x27;&#x27;</span>  contains the rows  <span class="math">(\\mathbf{F} \\mid \\mathbf{0})</span> ,  <span class="math">(\\mathbf{0} \\mid \\mathbf{I}_{n_d})</span> .</li>

      <li>Sample  <span class="math">\\mathrm{crs}_{\\mathrm{blin}} \\gets \\mathrm{QABlin.K}(\\rho_{\\mathrm{blin}}, \\theta_{\\mathrm{blin}})</span>  and  <span class="math">\\mathrm{crs}_{\\mathrm{had}} \\gets \\mathrm{QAHad.K}(\\rho_{\\mathrm{had}}, \\theta_{\\mathrm{had}})</span></li>

      <li>output crs := ([GU]1, [HV]2, [FW]1, crslin, crshad)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Evaluate the circuit on input  <span class="math">x</span>  to obtain values for the wires  <span class="math">a, b, c</span> .</li>

      <li>Compute  <span class="math">[\\hat{L}]_1 = [\\mathbf{G}\\mathbf{U}]_1a, [\\hat{R}]_2 = [\\mathbf{H}\\mathbf{V}]_2b, [\\hat{O}]_1 = [\\mathbf{F}\\mathbf{W}]_1c.</span></li>

      <li><span class="math">\\pi_{\\mathrm{blin}} \\gets \\mathrm{QABlin.Prove}(\\mathrm{crs}_{\\mathrm{blin}}, \\binom{\\bar{x}}{y}, [\\hat{L}]_1, [\\hat{R}]_2), (x, c, y))</span> .</li>

      <li><span class="math">\\pi_{\\mathrm{had}} \\gets \\mathrm{QAHad.Prove}(\\mathrm{crs}_{\\mathrm{had}}, [\\hat{L}]_1, [\\hat{R}]_2, \\binom{[\\hat{O}]_1}{y}, a, b)</span> .</li>

      <li>Return  <span class="math">\\pi = ([\\hat{O}]_1, [\\hat{L}]_1, [\\hat{R}]_2, \\pi_{\\mathrm{blin}}, \\pi_{\\mathrm{had}})</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\pi := ([\\hat{O}]_1, [\\hat{L}]_1, [\\hat{R}]_2, \\pi_{\\mathrm{blin}}, \\pi_{\\mathrm{had}})</span> .</li>

      <li>Output 1 if the following tests are successful and 0 otherwise:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>QABlin.Verify(crsblin,  <span class="math">\\binom{[\\hat{O}]_1}{y}</span> ,  <span class="math">[\\hat{L}]_1, [\\hat{R}]_2</span> ,  <span class="math">\\pi_{\\mathrm{blin}}) = 1</span>  and</li>

      <li>QAHad.Verify(crshad,  <span class="math">[\\hat{L}]_1, [\\hat{R}]_2, \\binom{[\\hat{O}]_1}{y}</span> ,  <span class="math">\\pi_{\\mathrm{had}}) = 0</span></li>

    </ul>

    <p class="text-gray-300">Figure 8: Delegation scheme for an arithmetic circuit.</p>

    <p class="text-gray-300">Game0: This is the soundness game. The output of Game0 is 1 iff on input crs  <span class="math">\\leftarrow</span>  Setup(gk, C), the adversary outputs  <span class="math">x, y, \\pi \\gets \\mathcal{A}(\\mathrm{crs})</span>  such that  <span class="math">C(x) \\neq y</span>  and the proof verifies, namely Verify(crs,  <span class="math">x, y, \\pi) = 1</span> .</p>

    <p class="text-gray-300">In what follows we use the fact that the commitment keys corresponding to  <span class="math">[O]_0</span>  and  <span class="math">[O]_d</span>  are the identity matrices. Therefore are trivially extractable; thus the bilateral knowledge argument is sound since it satisfies the soundness conditions (MDDH is trivially hard for the identity matrix). This is used in the same way as [GR19].</p>

    <p class="text-gray-300">For  <span class="math">i \\in [d]</span> ,  <span class="math">j \\in [0, d]</span>  and  <span class="math">S_1, S_2</span>  sets of sizes at most 1, consider the following games:</p>

    <p class="text-gray-300">BadO <span class="math">_{j,S_1,S_2}</span> : As Game0 with the following difference: we sample commitment keys that make crshad extractable at  <span class="math">S = (S_1, S_2)</span>  and a corresponding trapdoor  <span class="math">\\tau</span> . The output of BadO <span class="math">_{j,S_1,S_2}</span>  is 1 iff either  <span class="math">S_2 \\neq \\{j\\}</span>  or  <span class="math">[O_j]_1 \\neq [\\mathbf{W}_j^*]_1 c_j</span> , where  <span class="math">c_j</span>  is computed by honestly executing  <span class="math">C(x)</span>  and  <span class="math">[O_j]_1 \\gets \\text{QAHad.Extract}(\\tau, [\\hat{L}]_1, [\\hat{R}]_2, [\\hat{O}]_1, \\pi_{\\text{had}})</span>  is extracted from the adversary's</p>

    <p class="text-gray-300">proof <span class="math">\\pi = ([\\hat{O}]_1, [\\hat{L}]_1, [\\hat{R}]_2, \\pi_{\\mathrm{blin}}, \\pi_{\\mathrm{had}})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{BadLR}_{i,S_1,S_2}</span>: As <span class="math">\\mathsf{Game}_0</span> with the difference: we sample commitment keys that make <span class="math">\\mathsf{crs}_{\\mathrm{lin}}</span> extractable at <span class="math">S = (S_1, S_2)</span> and a corresponding trapdoor <span class="math">\\tau</span>. The output of <span class="math">\\mathsf{BadLR}_{\\mathsf{LS}_\\tau, S_2}</span> is 1 iff either <span class="math">S_1 \\neq \\{i\\}</span> or <span class="math">[L_i]_1 \\neq [\\mathbf{U}_i^<em>]_1 \\mathbf{a}_i</span> or <span class="math">[R_i]_1 \\neq [\\mathbf{V}_i^</em>]_1 \\mathbf{b}_i</span>, where <span class="math">\\mathbf{a}_i, \\mathbf{b}_i</span> are computed by honestly executing <span class="math">C(\\mathbf{x})</span> and <span class="math">([L_i]_1, [R_i]_1) \\gets \\mathsf{QAHad.Extract}(\\tau, [\\hat{L}]_1, [\\hat{R}]_2, [\\hat{O}]_1, \\pi_{\\mathrm{blin}})</span> is extracted from the adversary's proof <span class="math">\\pi = ([\\hat{O}]_1, [\\hat{L}]_1, [\\hat{R}]_2, \\pi_{\\mathrm{blin}}, \\pi_{\\mathrm{had}})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now for any game, let <span class="math">E</span> be the event where the output <span class="math">(\\mathbf{x}, \\mathbf{y}, \\pi) \\gets \\mathcal{A}(\\mathrm{crs})</span> satisfies <span class="math">\\text{Verify}(\\mathrm{crs}, \\mathbf{x}, \\mathbf{y}, \\pi) = 1</span>. We define <span class="math">O_d = \\mathbf{y}</span> and $\\mathbf{W}_d = (\\mathbf{0}_{n_d \\times N - n_d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_{n_d})<span class="math"> so that </span>\\text{Game}_0 = \\text{BadO}_{d,\\emptyset, \\{d\\}} \\wedge E<span class="math">. We also define </span>\\text{BadO}_i = \\text{BadO}_{i,\\emptyset, \\{i\\}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adversary against adaptive soundness of the delegation scheme and for each <span class="math">i</span> define <span class="math">\\operatorname*{Pr}[\\mathsf{BadO}_i^{\\mathcal{A}}(gk) = 1 \\mid E] = p_i</span>. We claim that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname*{Pr}[\\text{BadO}_{i+1}^{\\mathcal{A}}(gk) = 1 \\mid E] &amp;amp;\\leq p_i + \\operatorname{Adv}_{\\text{snd}}^{\\text{QABlin}}(\\mathcal{A}_{\\text{blin}}) + \\operatorname{Adv}_{\\text{snd}}^{\\text{QAHad}}(\\mathcal{A}_{\\text{had}}) \\\\ &amp;amp;\\quad + 2 \\operatorname{Adv}_{\\text{ns}}^{\\text{QABlin}}(\\mathcal{D}_{\\text{blin}}, \\mathcal{B}_{\\text{blin}}) + 2 \\operatorname{Adv}_{\\text{ns}}^{\\text{QAHad}}(\\mathcal{D}_{\\text{had}}, \\mathcal{B}_{\\text{had}}) \\end{aligned}</span></div>

    <p class="text-gray-300">The proof of the claim is by induction over <span class="math">i</span>. In the inductive case we show that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname*{Pr}[\\text{BadO}_i^{\\mathcal{A}} = 1 \\mid E] &amp;amp;\\approx \\operatorname*{Pr}[\\text{BadO}_{i,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\mid E] \\approx \\operatorname*{Pr}[\\text{BadLR}_{i,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\mid E] \\\\ &amp;amp;\\approx \\operatorname*{Pr}[\\text{BadLR}_{i,(\\{i+1\\},\\{i+1\\})}^{\\mathcal{A}} = 1 \\mid E] \\end{aligned}</span></div>

    <p class="text-gray-300">and <span class="math">\\operatorname<em>{Pr}[\\text{BadLR}_{i,(\\{i+1\\},\\{i+1\\})}^{\\mathcal{A}} = 1 \\mid E] \\approx \\operatorname</em>{Pr}[\\text{BadO}_{i+1,(\\{i+1\\},\\{i+1\\})}^{\\mathcal{A}} = 1 \\mid E] \\approx \\operatorname*{Pr}[\\text{BadO}_{i+1}^{\\mathcal{A}} = 1 \\mid E]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">p_1 \\approx p_2</span> is defined as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_1 - p_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathrm{negl}(\\kappa)<span class="math">. Now we show that each </span>\\approx<span class="math"> is indeed negligible. Note that </span>\\rho_{\\mathrm{had}}<span class="math"> can be computed from </span>\\rho_{\\mathrm{blin}}$ and vice-versa.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{BadO}_i, \\mathsf{BadO}_{i,(\\{i+1\\},\\{i\\})}</span>: Consider the sets <span class="math">S_1 = (\\emptyset, \\{i\\})</span> and <span class="math">S_2 = (\\{i+1\\}, \\{i\\})</span>. We show that the output of the games relative to <span class="math">\\mathcal{A}</span> are computationally indistinguishable by reducing to the no-signaling property of QABlin.</p>

    <p class="text-gray-300">We construct adversaries <span class="math">\\mathcal{D}_{\\mathrm{blin}}, \\mathcal{B}_{\\mathrm{blin}}</span> against no-signaling extraction of QABlin. By Corollary 5, the no-signaling property holds even when <span class="math">\\mathcal{B}_{\\mathrm{blin}}</span> is given <span class="math">\\rho_{\\mathrm{blin}}, \\mathrm{crs}_{\\mathrm{blin}}</span> and additionally <span class="math">h_{\\mathrm{ns}}(\\theta_{\\mathrm{blin}}) = (\\mathbf{U}, \\mathbf{V}, \\mathbf{W}, [\\mathbf{G} \\otimes \\mathbf{H} + \\mathbf{Z}]_1, [-\\mathbf{Z}]_2)</span>. Using this additional help, <span class="math">\\mathcal{B}_{\\mathrm{blin}}</span> computes <span class="math">\\mathrm{crs}_{\\mathrm{had}} \\gets \\mathrm{QAHad.K}(\\rho_{\\mathrm{had}}, \\theta&#x27; = h_{\\mathrm{ns}}(\\theta_{\\mathrm{blin}}))</span> as in Lemma 4. It then runs <span class="math">\\mathcal{A}(\\mathrm{crs})</span> until it outputs <span class="math">(\\mathbf{x}, \\mathbf{y}^<em>, [\\hat{\\mathbf{O}}]_1, [\\hat{\\mathbf{L}}]_1, [\\hat{\\mathbf{R}}]_2, \\pi_{\\mathrm{blin}}, \\pi_{\\mathrm{had}})</span>, and then <span class="math">\\mathcal{B}_{\\mathrm{blin}}</span> outputs <span class="math">\\left(\\left[\\frac{\\hat{\\mathbf{S}}}{\\mathbf{y}^</em>}\\right]_1, [\\hat{\\mathbf{L}}]_1, [\\hat{\\mathbf{R}}]_2\\right)</span> and <span class="math">\\pi_{\\mathrm{blin}}</span>. It gets the extracted value for the intersection of the two sets <span class="math">(\\emptyset, \\{i\\})</span>, namely <span class="math">[O_i]_1</span>. If all conditions of <span class="math">\\mathsf{BadO}_i</span> and <span class="math">E</span> hold (Verify <span class="math">(\\mathrm{crs}, \\mathbf{x}^<em>, \\mathbf{y}^</em>, \\pi) = 1</span> and <span class="math">[O_i] \\neq \\mathbf{W}_i^* \\mathbf{c}_i</span>) <span class="math">\\mathcal{D}_{\\mathrm{blin}}</span> outputs 1 and otherwise 0.</p>

    <p class="text-gray-300">Then we can bound <span class="math">\\operatorname*{Pr}[\\mathsf{BadO}_{i,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\mid E] \\leq p_i + \\mathsf{Adv}_{\\mathsf{NS}}^{\\mathsf{QABlin}}(\\mathcal{D}_{\\mathsf{blin}}, \\mathcal{B}_{\\mathsf{blin}}) = p_{i,1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{BadO}_{i,(\\{i+1\\},\\{i\\})}</span>, <span class="math">\\mathsf{BadLR}_{i+1,(\\{i+1\\},\\{i\\})}</span>: We build an adversary <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> against the <span class="math">h</span>-strong knowledge soundness of QABlin. On input <span class="math">\\mathsf{crs}_{\\mathrm{blin}}</span> and <span class="math">h_{\\mathrm{ls}}(\\theta_{\\mathrm{blin}}) = (\\mathbf{G}, \\mathbf{H}, \\mathbf{F}, \\mathbf{U}, \\mathbf{V})</span> computes <span class="math">\\mathsf{crs}_{\\mathrm{had}} \\gets \\mathsf{QAHad.K}(\\rho_{\\mathrm{had}}, h_{\\mathrm{ls}}(\\theta_{\\mathrm{blin}}))</span>, as in Lemma 4. Then runs <span class="math">\\mathcal{A}(\\mathrm{crs})</span> until it outputs <span class="math">\\mathbf{x}, \\mathbf{y}^<em>, \\pi</span> and then <span class="math">\\mathcal{A}_{\\mathrm{blin}}</span> outputs <span class="math">\\left(\\left[\\frac{\\hat{\\mathbf{S}}}{\\mathbf{y}^</em>}\\right]_1, [\\mathbf{L}]_1, [\\mathbf{R}]_2\\right)</span> and <span class="math">\\pi_{\\mathrm{blin}}</span>. Now by definition, conditioned on <span class="math">E</span>, if the events <span class="math">\\neg \\mathsf{BadO}_{i+1,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}}</span> and <span class="math">\\mathsf{BadLR}_{i+1,(\\{i\\},\\{i\\})}^{\\mathcal{A}}</span> happen, it holds that (1) <span class="math">\\pi_{\\mathrm{blin}}</span> verifies, (2) <span class="math">[O_i]_1 = \\mathbf{W}_i \\mathbf{c}_i</span> and (3) <span class="math">[L_{i+1}]_1 \\neq \\mathbf{U}_{i+1} \\mathbf{a}_{i+1}</span> or <span class="math">[R_{i+1}]_1 \\neq \\mathbf{V}_{i+1} \\mathbf{b}_{i+1}</span>. Then we can bound</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname*{Pr}[\\text{BadLR}_{i+1,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\mid E] &amp;amp;\\leq \\operatorname*{Pr}[\\text{BadLR}_{i+1,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\wedge \\text{BadO}_{i,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\mid E] \\\\ &amp;amp;\\quad + \\operatorname*{Pr}[\\text{BadLR}_{i+1,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\wedge \\neg \\text{BadO}_{i,(\\{i+1\\},\\{i\\})}^{\\mathcal{A}} = 1 \\mid E] \\\\ &amp;amp;\\leq p_{i,1} + \\operatorname{Adv}_{\\text{snd}}^{\\text{QABLin}}(\\mathcal{A}_{\\text{blin}}) = p_{i,2} \\end{aligned}</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{BadLR}_{i+1,(\\{i+1\\},\\{i\\})}</span>, <span class="math">\\mathsf{BadLR}_{i+1,(\\{i+1\\},\\{i+1\\})}</span>: Similarly as the case <span class="math">\\mathsf{BadO}_{i},\\mathsf{BadO}_{i,(\\{i+1\\},\\{i\\})}</span>, but we need to transition between sets <span class="math">(\\{i\\},\\{i+1\\})\\to(\\emptyset,\\{i+1\\})\\to(\\{i+1\\},\\{i+1\\})</span>. We use twice the no-signaling property of QAHad and exploit the fact that we can build <span class="math">\\mathsf{crs}_{\\mathsf{blin}}</span> using <span class="math">h_{ns}(\\theta_{\\mathsf{had}})</span>. Therefore, <span class="math">\\Pr[\\mathsf{BadLR}_{i,(\\{i+1\\},\\{i+1\\})}=1\\mid E]\\leq p_{i,2}+\\mathsf{2Adv}^{\\mathsf{QAHad}}_{\\mathsf{NS}}(\\mathcal{D}_{\\mathsf{had}},\\mathcal{B}_{\\mathsf{had}})=p_{i,3}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{BadLR}_{i,(\\{i+1\\},\\{i+1\\})}</span>, <span class="math">\\mathsf{BadO}_{i+1,(\\{i+1\\},\\{i+1\\})}</span>: We build an adversary <span class="math">\\mathcal{A}_{\\mathsf{had}}</span> against the <span class="math">h</span>-strong knowledge soundness of QAHad. On input <span class="math">\\mathsf{crs}_{\\mathsf{had}}</span> and <span class="math">h_{\\mathsf{ls}}(\\theta_{\\mathsf{had}})=(\\mathbf{G},\\mathbf{H},\\mathbf{F},\\mathbf{W})</span> computes <span class="math">\\mathsf{crs}_{\\mathsf{blin}}\\leftarrow\\mathsf{QABlin}.\\mathsf{K}(\\rho_{\\mathsf{blin}},h_{\\mathsf{ls}}(\\theta_{\\mathsf{had}}))</span>, as in Lemma 2. Then runs <span class="math">\\mathcal{A}(\\mathsf{crs})</span> until it outputs <span class="math">\\bm{x},\\bm{y}^{<em>},\\pi</span> and then <span class="math">\\mathcal{A}_{\\mathsf{blin}}</span> outputs <span class="math">([\\mathbf{L}]_{1},[\\mathbf{R}]_{2},\\left[\\begin{smallmatrix}\\hat{\\mathsf{O}}\\\\y^{</em>}\\end{smallmatrix}\\right]_{1})</span> and <span class="math">\\pi_{\\mathsf{had}}</span>. Now by definition, conditioned on <span class="math">E</span>, if the events <span class="math">\\neg\\mathsf{BadLR}^{\\mathcal{A}}_{i+1,(\\{i+1\\},\\{i+1\\})}</span> and <span class="math">\\mathsf{BadO}^{\\mathcal{A}}_{i+1,(\\{i+1\\},\\{i+1\\})}</span> happen, it holds that (1) <span class="math">\\pi_{\\mathsf{had}}</span> verifies, (2) <span class="math">[L_{i+1}]_{1}=\\mathbf{U}_{i+1}\\bm{a}_{i+1}</span> and <span class="math">[R_{i+1}]_{1}=\\mathbf{V}_{i+1}\\bm{b}_{i+1}</span> and (3) <span class="math">[O_{i+1}]_{1}\\neq\\mathbf{W}_{i+1}\\bm{c}_{i+1}</span>. Then we can bound</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{BadO}^{\\mathcal{A}}_{i+1,(\\{i+1\\},\\{i+1\\})}=1\\mid E]</span> <span class="math">\\leq\\Pr[\\mathsf{BadO}^{\\mathcal{A}}_{i+1,(\\{i+1\\},\\{i+1\\})}=1\\wedge\\mathsf{BadLR}^{\\mathcal{A}}_{i+1,(\\{i+1\\},\\{i+1\\})}=1\\mid E]</span> <span class="math">+\\Pr[\\mathsf{BadO}^{\\mathcal{A}}_{i+1,(\\{i+1\\},\\{i+1\\})}=1\\wedge\\neg\\mathsf{BadLR}^{\\mathcal{A}}_{i+1,(\\{i+1\\},\\{i+1\\})}=1\\mid E]</span> <span class="math">\\leq p_{i,3}+\\mathsf{Adv}^{\\mathsf{QAHad}}_{\\mathsf{snd}}(\\mathcal{A}_{\\mathsf{had}})=p_{i,4}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{BadO}_{i+1,(\\{i+1\\},\\{i+1\\})}</span>, <span class="math">\\mathsf{BadO}_{i+1}</span>: Similarly as the case <span class="math">\\mathsf{BadO}_{i},\\mathsf{BadO}_{i,(\\{i+1\\},\\{i\\})}</span> we can bound</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{BadO}^{\\mathcal{A}}_{i+1}=1\\mid E]\\leq p_{i,4}+\\mathsf{Adv}^{\\mathsf{QABlin}}_{\\mathsf{NS}}(\\mathcal{D}_{\\mathsf{blin}},\\mathcal{B}_{\\mathsf{blin}}).</span></p>

    <p class="text-gray-300">and we conclude the claim.</p>

    <p class="text-gray-300">Now, <span class="math">\\Pr[\\mathsf{BadO}^{\\mathcal{A}}_{i+1}(gk)=1\\mid E]=\\Pr[\\mathsf{BadO}^{\\mathcal{A}}_{i}(gk)=1]+p_{i}</span>. We have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{BadO}^{\\mathcal{A}}_{d}(gk)=1\\mid E]=\\Pr[\\mathsf{Game}_{0}^{\\mathcal{A}}(gk)=1]=\\sum_{i=0}^{d}p_{i}</span></p>

    <p class="text-gray-300">which concludes the proof.</p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-89" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">The size of the crs is <span class="math">(6N^{2}+6N+24)\\mathbb{G}_{1}</span> elements and <span class="math">(6N^{2}+4N+36)\\mathbb{G}_{2}</span> elements and computing it is dominated by the same number of group exponentiations in <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span> respectively; the prover is dominated by <span class="math">6N^{2}+6N</span> exponentiations in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">6N^{2}+2N</span> exponentiations in <span class="math">\\mathbb{G}_{2}</span> and produces a proof of size <span class="math">12\\mathbb{G}_{1}+10\\mathbb{G}_{2}</span> group elements; verifying a proof requires 36 pairing operations. The size of the proof can be reduced to <span class="math">10\\mathbb{G}_{1}+8\\mathbb{G}_{2}</span> combining the linear argument with the one used by the hadamard quasi argument.</p>

    <h2 id="sec-90" class="text-2xl font-bold">7 Applications</h2>

    <p class="text-gray-300">In this section we show how to use our delegation scheme to (1) get a NIZK argument for NP in the preprocessing model where the size of the proof is linear in the size of the NP witness and independent of the computation size, in spite of most NIZK constructions under standard assumptions; (2) a zk-SNARK with quantitatively weaker assumptions and (3) compact NIZK for NP with proof size proportional to the witness.</p>

    <p class="text-gray-300">We will use Groth-Sahai proofs <em>[x10]</em> and, for completeness, we give a high level overview.</p>

    <p class="text-gray-300">###</p>

    <h4 id="sec-91" class="text-lg font-semibold mt-6">Groth-Sahai Proofs</h4>

    <p class="text-gray-300">The Groth Sahai (GS) proof system is a non-interactive witness indistinguishable proof system (and in some cases also zero-knowledge) for the language of quadratic equations over a bilinear group. The admissible equation types must be in the following form:</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=1}^{m_{y}}f(\\alpha_{j},\\mathsf{y}_{j})+\\sum_{i=1}^{m_{x}}f(\\mathsf{x}_{i},\\beta_{i})+\\sum_{i=1}^{m_{e}}\\sum_{j=1}^{m_{y}}f(\\mathsf{x}_{i},\\gamma_{i,j}\\mathsf{y}_{j})=t,</span> (8)</p>

    <p class="text-gray-300">where <span class="math">\\bm{\\alpha}\\in\\mathbb{M}_{1}^{m_{y}}</span>, <span class="math">\\bm{\\beta}\\in\\mathbb{M}_{2}^{m_{y}}</span>, <span class="math">\\bm{\\Gamma}=(\\gamma_{i,j})\\in\\mathbb{Z}_{q}^{m_{x}\\times m_{y}}</span>, <span class="math">t\\in\\mathbb{M}_{T}</span>, and <span class="math">\\mathbb{M}_{1},\\mathbb{M}_{2},\\mathbb{M}_{T}\\in\\{\\mathbb{Z}_{q},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}\\}</span> are equipped with some bilinear map <span class="math">f:\\mathbb{M}_{1}\\times\\mathbb{M}_{2}\\to\\mathbb{M}_{T}</span>. The proof system is also zero-knowledge whenever <span class="math">\\mathbb{M}_{1}\\neq\\mathbb{G}_{1}</span> or <span class="math">\\mathbb{M}_{2}\\neq\\mathbb{G}_{2}</span> or <span class="math">t=0</span> <em>[x11]</em>. We will use only equations for which <span class="math">t=0</span>.</p>

    <p class="text-gray-300">The GS proof system is a <em>commit-and-prove</em> proof system. That is, the prover first commits to solutions of equation 8 using Groth-Sahai commitments, and then computes a proof that the committed values satisfies equation 8. We denote an instance of the Groth-Sahai proof system by <span class="math">\\mathsf{GS}=(\\mathsf{Setup}_{\\mathsf{pb}},\\mathsf{Setup}_{\\mathsf{ph}},\\mathsf{P},\\mathsf{V})</span>.</p>

    <p class="text-gray-300">GS proofs are perfectly sound when the CRS is sampled from the perfectly binding distribution, i.e <span class="math">\\mathsf{crs}_{\\mathsf{GS}}\\leftarrow\\mathsf{GS.Setup}_{\\mathsf{pb}}(gk)</span>. This means that any <span class="math">\\pi</span> such that <span class="math">\\mathsf{GS.V}(\\mathsf{crs}_{\\mathsf{GS}}</span>, equation 8, <span class="math">\\pi)=1</span> contains commitments from which one can extract solutions to equation 8 with probability 1. Proofs are perfectly witness-indistinguishable when sampled from the perfectly hiding distribution, i.e. <span class="math">\\mathsf{crs}_{\\mathsf{GS}}\\leftarrow\\mathsf{GS.Setup}_{\\mathsf{ph}}(gk)</span>. That is, for any two solution to equation 8 the proofs follow exactly the same distribution, Computational indistinguishability of <span class="math">\\mathsf{GS.Setup}_{\\mathsf{pb}}</span> and <span class="math">\\mathsf{GS.Setup}_{\\mathsf{ph}}</span> implies that either the proof system is perfectly sound and computationally witness indistinguishable or computationally sound and perfect witness-indistinguishable.</p>

    <h3 id="sec-92" class="text-xl font-semibold mt-8">7.1 NIZK arguments for NP.</h3>

    <p class="text-gray-300">Let <span class="math">\\mathsf{CS}_{E}</span> an be algebraic commitment scheme –namely compatible with the Groth-Sahai proof system <em>[x14]</em>– which is hiding and extractable. Also note that we can express the verification algorithm Del.Verify as a set of pairing product equation. The idea to construct a NIZK is the following: let <span class="math">C</span> be an arithmetic circuit that takes public input <span class="math">\\bm{x}</span> and secret input <span class="math">\\bm{w}</span> the secret input, and let <span class="math">\\mathsf{crs}_{\\mathsf{Del}}</span> be a crs for the delegation of computation of <span class="math">C</span>. The prover commits to <span class="math">\\bm{w}</span> and the group elements defining the proof of the delegation using the extractable commitment and gives a Groth-Sahai proof that the set of verification equations are satisfied w.r.t. the opening of the commitment. Now, if <span class="math">\\mathsf{CS}_{E}</span> is extractable, we can extract the witness <span class="math">\\bm{w}</span>, and if the circuit is not satisfied w.r.t. <span class="math">\\bm{x},\\bm{w}</span> we can break adaptive soundness of delegation scheme Del. We present the scheme.</p>

    <p class="text-gray-300">Setup  <span class="math">(gk,C)</span> : Let  <span class="math">C</span>  an arithmetic circuit which on public input  <span class="math">x</span>  size  <span class="math">n_x</span>  and secret input  <span class="math">w</span>  size  <span class="math">n_w</span>  outputs  <span class="math">y</span>  of size  <span class="math">n_d</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">ck_{w} \\gets \\mathsf{CS}_{E}(gk, n_{w})</span> ;  <span class="math">\\mathsf{crs}_{\\mathsf{Del}} \\gets \\mathsf{Del}. \\mathsf{Setup}(gk, C)</span> .</li>

      <li><span class="math">\\operatorname{crs}_{\\mathrm{GS}} \\gets \\operatorname{GS}.\\operatorname{Setup}_{\\mathrm{pb}}(gk)</span> .</li>

    </ul>

    <p class="text-gray-300">Output  <span class="math">\\operatorname{crs} = (ck_w, \\operatorname{crs}_{\\mathsf{Del}}, \\operatorname{crs}_{\\mathsf{GS}})</span> .</p>

    <p class="text-gray-300">Prove(crs,  <span class="math">w,x,y</span>  ..</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\operatorname{crs} = (ck_w, \\operatorname{crs}_{\\mathsf{Del}}, \\operatorname{crs}_{\\mathsf{GS}})</span> .</li>

      <li>Compute  <span class="math">\\pi \\gets \\mathsf{Del}(\\mathsf{crs}_{\\mathsf{Del}}, (x, w), y)</span>  and  <span class="math">c_w = \\mathsf{CS}_E.\\mathsf{Com}(w; r)</span> .</li>

      <li>Denote  <span class="math">\\phi_{\\mathrm{GS}}</span>  the system of pairing product equations that contain</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The equations defined by Del.V(crs,  <span class="math">(x,w),y,\\pi) = 1</span> , where the unknowns are  <span class="math">w</span>  and  <span class="math">\\pi</span> .</li>

      <li>The equations defined by  <span class="math">c_w = \\mathsf{CS}_E</span> .  <span class="math">\\mathsf{Com}(ck_w, w; r)</span> , where the unknowns are  <span class="math">w</span>  and  <span class="math">r</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_{\\mathrm{GS}} \\gets \\mathrm{GS.P}(\\mathrm{crs}_{\\mathrm{GS}}, \\phi_{\\mathrm{GS}}, (w, r))</span></li>

    </ul>

    <p class="text-gray-300">Output  <span class="math">\\pi \\gets (c_w,\\pi_{\\mathrm{GS}})</span></p>

    <p class="text-gray-300">Verify(crs,  <span class="math">(x,y),\\pi)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\operatorname{crs} = (ck_w, \\operatorname{crs}_{\\mathsf{Del}}, \\operatorname{crs}_{\\mathsf{GS}})</span> . and  <span class="math">\\pi = (c_w, \\pi_{\\mathsf{GS}})</span> .</li>

    </ul>

    <p class="text-gray-300">Output 1 iff GS.V(crsGS,  <span class="math">\\phi_{\\mathrm{GS}},\\pi_{\\mathrm{GS}}) = 1</span></p>

    <p class="text-gray-300">Figure 9: NIZK argument of NP.  <span class="math">\\mathsf{CS}_E</span>  is an algebraic commitment, GS is the Groth-Sahai proof system of [GS08] and Del the delegation scheme of Fig. 8.</p>

    <p class="text-gray-300">Theorem 17. Let  <span class="math">\\mathsf{CS}_E</span>  be an algebraic commitment scheme that is hiding and extractable, GS the Groth-Sahai proof system of [GS08] and Del the delegation scheme of Fig. 8. Then, construction of Fig. 9 is a NIZK argument of knowledge. Furthermore, for every adversary  <span class="math">\\mathcal{A}</span>  against knowledge soundness there exist adversaries  <span class="math">\\mathcal{B}_1, \\mathcal{B}_2</span>  against extractability of  <span class="math">\\mathsf{CS}_E</span>  and against soundness of Del respectively such that  <span class="math">\\mathsf{Adv}(\\mathcal{A}) \\leq \\mathsf{Adv}_{\\text{ext}}^{\\mathsf{CS}_E}(\\mathcal{B}_1) + \\mathsf{Adv}_{\\text{snd}}^{\\mathsf{Del}}(\\mathcal{B}_2)</span> .</p>

    <p class="text-gray-300">Proof. Completeness follows by the correctness of  <span class="math">\\mathsf{CS}_E</span> , and completeness of GS, Del. Computational zero knowledge follows from the computational zero-knowledge of GS and the hiding property of  <span class="math">\\mathsf{CS}_E</span> . For knowledge soundness, we show how we can extract a valid witness given an accepting proof. In what follows, let  <span class="math">\\mathcal{E}_{\\mathsf{CS}}</span>  be the extractors for  <span class="math">\\mathsf{CS}_E</span> . The NIZK extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}(\\mathsf{crs}, x, y, \\pi = (c_w, \\pi_{\\mathsf{GS}}))</span>  simply outputs  <span class="math">(w, \\pi) \\gets \\mathcal{E}_{\\mathsf{CS}}(ck_w, c_w)</span> . Now, we claim that this a valid witness except with negligible probability. It is enough to note that if it is not, there are three possible cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The extractor  <span class="math">\\mathcal{E}_{\\mathrm{CS}}</span>  failed which contradicts extractability of  <span class="math">\\mathsf{CS}_E</span> .</li>

      <li>The extracted solutions  <span class="math">w, \\pi, r</span>  are not solutions to  <span class="math">\\phi_{\\mathrm{GS}}</span> , contradicting perfect soundness of GS since the proof verifies.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  $y \\neq C(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math"> . We can extract the solution  </span>w, \\pi, r$  and it must hold that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Del.Verify(crs,  <span class="math">(x,w),y,\\pi) = 1</span></p>

    <p class="text-gray-300">contradicting adaptive soundness of Del.</p>

    <p class="text-gray-300">As for efficiency, and specifically proof size, noting that the Groth-Sahai proof gives only a constant, multiplicative overhead to the proof –which is constant –, its size is dominated by the size of <span class="math">\\mathsf{CS}_{E}</span>. Depending on the choice of <span class="math">\\mathsf{CS}_{E}</span> we can get qualitatively different constructions. We discuss the following cases:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For a NIZK argument of knowledge under falsifiable assumptions, we can extend our result to apply to boolean circuits instead of arithmetic ones by arithmetizing the different types of gates e.g. as in<em>[x11]</em>. We can then use commitments for boolean vectors that are extractable in the field under falsifiable assumptions such as Groth-Sahai commitments or using methods of <em>[x13]</em>. The proof size in this case is $\\mathcal{O}(\\lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> where </span>\\bm{w}$ is the secret input. Since fully succinct algebraic extractable commitments that allow extraction in the field are unknown to exist under falsifiable assumptions, we cannot achieve a (concretely more efficient) NIZK AoK for arithmetic circuits.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. To construct a compact NIZK where the proof size is $O(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bm{w}</td>

            <td class="px-3 py-2 border-b border-gray-700">)+\\mathsf{poly}(\\kappa)<span class="math"> we follow essentially the ideas of <em>[x23, x24]</em>. We use a secret key symmetric encryption scheme </span>\\mathsf{SE}=(\\mathsf{KGen},\\mathsf{Enc},\\mathsf{Dec})<span class="math"> with additive overhead in the cyphertexts. That is, </span></td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{SE}.\\mathsf{Enc}(sk,\\bm{w})</td>

            <td class="px-3 py-2 border-b border-gray-700">=O(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bm{w}</td>

            <td class="px-3 py-2 border-b border-gray-700">)+\\mathsf{poly}(\\kappa)<span class="math">. We use the NIZK from figure 9, instantiated with the commitment scheme from (i), for showing knowledge of some </span>K\\in\\mathsf{Im}(\\mathsf{SE}.\\mathsf{KGen})<span class="math"> such that </span>C^{\\prime}(K,D)=1<span class="math">, where </span>K<span class="math"> is the secret input, </span>D<span class="math"> the public input, and </span>C^{\\prime}(K,D)=C(\\mathsf{SE}.\\mathsf{Dec}(K,D))<span class="math">. To prove that </span>C(\\bm{w})=1<span class="math"> the prover picks </span>K\\leftarrow\\mathsf{SE}.\\mathsf{KGen}(1^{\\kappa})<span class="math"> and computes </span>D\\leftarrow\\mathsf{SE}.\\mathsf{Enc}(K,\\bm{w})<span class="math"> together with a proof </span>\\pi<span class="math"> that </span>C^{\\prime}(K,D)=1<span class="math">. The verifier on input </span>\\mathsf{crs}<span class="math">, </span>D<span class="math"> and </span>\\pi<span class="math"> ouputs </span>1<span class="math"> if </span>\\pi<span class="math"> is a valid proof for </span>D<span class="math">. In spite of <em>[x23, x24]</em> and by the nature of the underlying non-compact NIZK scheme we use, we don’t require </span>\\mathsf{SE}.\\mathsf{Dec}<span class="math"> to be in </span>\\mathsf{NC}^{1}$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h2 id="sec-93" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Carla Ráfols for various discussions and comments on this work. We also thank the anonymous reviewers of TCC 21 for their useful comments.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACC+16] Prabhanjan Ananth, Yu-Chi Chen, Kai-Min Chung, Huijia Lin, and Wei-Kai Lin. “Delegating RAM Computations with Adaptive Soundness and Privacy”. In: TCC 2016-B, Part II. Ed. by Martin Hirt and Adam D. Smith. Vol. 9986. LNCS. Springer, Heidelberg, Oct. 2016, pp. 3–30. doi: 10.1007/978-3-662-53644-5_1.</li>

      <li>[AFG+10] Masayuki Abe, Georg Fuchsbauer, Jens Groth, Kristiyan Haralambiev, and Miyako Ohkubo. “Structure-Preserving Signatures and Commitments to Group Elements”. In: CRYPTO 2010. Ed. by Tal Rabin. Vol. 6223. LNCS. Springer, Heidelberg, Aug. 2010, pp. 209–236. doi: 10.1007/978-3-642-14623-7_12.</li>

      <li>[AFG+16] Masayuki Abe, Georg Fuchsbauer, Jens Groth, Kristiyan Haralambiev, and Miyako Ohkubo. “Structure-Preserving Signatures and Commitments to Group Elements”. In: Journal of Cryptology 29.2 (Apr. 2016), pp. 363–421. doi: 10.1007/s00145-014-9196-7.</li>

      <li>[BBS04] Dan Boneh, Xavier Boyen, and Hovav Shacham. “Short Group Signatures”. In: CRYPTO 2004. Ed. by Matthew Franklin. Vol. 3152. LNCS. Springer, Heidelberg, Aug. 2004, pp. 41–55. doi: 10.1007/978-3-540-28628-8_3.</li>

      <li>[BCL+21] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. “Proof-Carrying Data Without Succinct Arguments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 681–710. doi: 10.1007/978-3-030-84242-0_24.</li>

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. “Recursive Proof Composition from Accumulation Schemes”. In: TCC 2020, Part II. Ed. by Rafael Pass and Krzysztof Pietrzak. Vol. 12551. LNCS. Springer, Heidelberg, Nov. 2020, pp. 1–18. doi: 10.1007/978-3-030-64378-2_1.</li>

      <li>[BDH+19] Michael Backes, Nico Döttling, Lucjan Hanzlik, Kamil Kluczniak, and Jonas Schneider. “Ring Signatures: Logarithmic-Size, No Setup - from Standard Assumptions”. In: EUROCRYPT 2019, Part III. Ed. by Yuval Ishai and Vincent Rijmen. Vol. 11478. LNCS. Springer, Heidelberg, May 2019, pp. 281–311. doi: 10.1007/978-3-030-17659-4_10.</li>

      <li>[BGL+15] Nir Bitansky, Sanjam Garg, Huijia Lin, Rafael Pass, and Sidharth Telang. Succinct Randomized Encodings and their Applications. Cryptology ePrint Archive, Report 2015/356. https://eprint.iacr.org/2015/356. 2015.</li>

      <li>[BHK17] Zvika Brakerski, Justin Holmgren, and Yael Tauman Kalai. “Non-interactive delegation and batch NP verification from standard computational assumptions”. In: 49th ACM STOC. Ed. by Hamed Hatami, Pierre McKenzie, and Valerie King. ACM Press, June 2017, pp. 474–482. doi: 10.1145/3055399.3055497.</li>

      <li>[BKK+18] Saikrishna Badrinarayanan, Yael Tauman Kalai, Dakshita Khurana, Amit Sahai, and Daniel Wichs. “Succinct delegation for low-space non-deterministic computation”. In: 50th ACM STOC. Ed. by Ilias Diakonikolas, David Kempe, and Monika Henzinger. ACM Press, June 2018, pp. 709–721. doi: 10.1145/3188745.3188924.</li>

      <li>[CCC+16] Yu-Chi Chen, Sherman S. M. Chow, Kai-Min Chung, Russell W. F. Lai, Wei-Kai Lin, and Hong-Sheng Zhou. “Cryptography for Parallel RAM from Indistinguishability Obfuscation”. In: ITCS 2016. Ed. by Madhu Sudan. ACM, Jan. 2016, pp. 179–190. doi: 10.1145/2840728.2840769.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[CCH+19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. “Fiat-Shamir: from practice to theory”. In: 51st ACM STOC. Ed. by Moses Charikar and Edith Cohen. ACM Press, June 2019, pp. 1082–1090. doi: 10.1145/3313276.3316380.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CHJV15] Ran Canetti, Justin Holmgren, Abhishek Jain, and Vinod Vaikuntanathan. “Succinct Garbling and Indistinguishability Obfuscation for RAM Programs”. In: 47th ACM STOC. Ed. by Rocco A. Servedio and Ronitt Rubinfeld. ACM Press, June 2015, pp. 429–437. doi: 10.1145/2746539.2746621.</li>

      <li>[CS02] Ronald Cramer and Victor Shoup. “Universal Hash Proofs and a Paradigm for Adaptive Chosen Ciphertext Secure Public-Key Encryption”. In: EUROCRYPT 2002. Ed. by Lars R. Knudsen. Vol. 2332. LNCS. Springer, Heidelberg, Apr. 2002, pp. 45–64. doi: 10.1007/3-540-46035-7_4.</li>

      <li>[DFGK14] George Danezis, Cédric Fournet, Jens Groth, and Markulf Kohlweiss. “Square Span Programs with Applications to Succinct NIZK Arguments”. In: ASIACRYPT 2014, Part I. Ed. by Palash Sarkar and Tetsu Iwata. Vol. 8873. LNCS. Springer, Heidelberg, Dec. 2014, pp. 532–550. doi: 10.1007/978-3-662-45611-8_28.</li>

      <li>[DGP+19] Vanesa Daza, Alonso González, Zaira Pindado, Carla Ràfols, and Javier Silva. “Shorter Quadratic QA-NIZK Proofs”. In: PKC 2019, Part I. Ed. by Dongdai Lin and Kazue Sako. Vol. 11442. LNCS. Springer, Heidelberg, Apr. 2019, pp. 314–343. doi: 10.1007/978-3-030-17253-4_11.</li>

      <li>[EG14] Alex Escala and Jens Groth. “Fine-Tuning Groth-Sahai Proofs”. In: PKC 2014. Ed. by Hugo Krawczyk. Vol. 8383. LNCS. Springer, Heidelberg, Mar. 2014, pp. 630–649. doi: 10.1007/978-3-642-54631-0_36.</li>

      <li>[EHK+13] Alex Escala, Gottfried Herold, Eike Kiltz, Carla Ràfols, and Jorge Villar. “An Algebraic Framework for Diffie-Hellman Assumptions”. In: CRYPTO 2013, Part II. Ed. by Ran Canetti and Juan A. Garay. Vol. 8043. LNCS. Springer, Heidelberg, Aug. 2013, pp. 129–147. doi: 10.1007/978-3-642-40084-1_8.</li>

      <li>[FLPS20] Prastudy Fauzi, Helger Lipmaa, Zaira Pindado, and Janno Siim. Somewhere Statistically Binding Commitment Schemes with Applications. Cryptology ePrint Archive, Report 2020/652. https://eprint.iacr.org/2020/652. 2020.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: EUROCRYPT 2013. Ed. by Thomas Johansson and Phong Q. Nguyen. Vol. 7881. LNCS. Springer, Heidelberg, May 2013, pp. 626–645. doi: 10.1007/978-3-642-38348-9_37.</li>

      <li>[GHR15a] Alonso González, Alejandro Hevia, and Carla Ràfols. QA-NIZK Arguments in Asymmetric Groups: New Tools and New Constructions. Cryptology ePrint Archive, Report 2015/910. https://eprint.iacr.org/2015/910. 2015.</li>

      <li>[GHR15b] Alonso González, Alejandro Hevia, and Carla Ràfols. “QA-NIZK Arguments in Asymmetric Groups: New Tools and New Constructions”. In: ASIACRYPT 2015, Part I. Ed. by Tetsu Iwata and Jung Hee Cheon. Vol. 9452. LNCS. Springer, Heidelberg, Nov. 2015, pp. 605–629. doi: 10.1007/978-3-662-48797-6_25.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating computation: interactive proofs for muggles”. In: 40th ACM STOC. Ed. by Richard E. Ladner and Cynthia Dwork. ACM Press, May 2008, pp. 113–122. doi: 10.1145/1374376.1374396.</li>

    </ul>

    <p class="text-gray-300">[GOS06] Jens Groth, Rafail Ostrovsky, and Amit Sahai. “Perfect Non-interactive Zero Knowledge for NP”. In: EUROCRYPT 2006. Ed. by Serge Vaudenay. Vol. 4004. LNCS. Springer, Heidelberg, May 2006, pp. 339–358. doi: 10.1007/11761679_21.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GR16] Alonso González and Carla Ràfols. “New Techniques for Non-interactive Shuffle and Range Arguments”. In: ACNS 16. Ed. by Mark Manulis, Ahmad-Reza Sadeghi, and Steve Schneider. Vol. 9696. LNCS. Springer, Heidelberg, June 2016, pp. 427–444. doi: 10.1007/978-3-319-39555-5_23.</li>

      <li>[GR19] Alonso González and Carla Ràfols. “Shorter Pairing-Based Arguments Under Standard Assumptions”. In: ASIACRYPT 2019, Part III. Ed. by Steven D. Galbraith and Shiho Moriai. Vol. 11923. LNCS. Springer, Heidelberg, Dec. 2019, pp. 728–757. doi: 10.1007/978-3-030-34618-8_25.</li>

      <li>[Gro16] Jens Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: EUROCRYPT 2016, Part II. Ed. by Marc Fischlin and Jean-Sébastien Coron. Vol. 9666. LNCS. Springer, Heidelberg, May 2016, pp. 305–326. doi: 10.1007/978-3-662-49896-5_11.</li>

      <li>[GS08] Jens Groth and Amit Sahai. “Efficient Non-interactive Proof Systems for Bilinear Groups”. In: EUROCRYPT 2008. Ed. by Nigel P. Smart. Vol. 4965. LNCS. Springer, Heidelberg, Apr. 2008, pp. 415–432. doi: 10.1007/978-3-540-78967-3_24.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. “Separating succinct non-interactive arguments from all falsifiable assumptions”. In: 43rd ACM STOC. Ed. by Lance Fortnow and Salil P. Vadhan. ACM Press, June 2011, pp. 99–108. doi: 10.1145/1993636.1993651.</li>

      <li>[HW15] Pavel Hubacek and Daniel Wichs. “On the Communication Complexity of Secure Function Evaluation with Long Output”. In: ITCS 2015. Ed. by Tim Roughgarden. ACM, Jan. 2015, pp. 163–172. doi: 10.1145/2688073.2688105.</li>

      <li>[JKKZ20] Ruta Jawale, Yael Tauman Kalai, Dakshita Khurana, and Rachel Zhang. SNARGs for Bounded Depth Computations and PPAD Hardness from Sub-Exponential LWE. Cryptology ePrint Archive, Report 2020/980. https://eprint.iacr.org/2020/980. 2020.</li>

      <li>[JR13] Charanjit S. Jutla and Arnab Roy. “Shorter Quasi-Adaptive NIZK Proofs for Linear Subspaces”. In: ASIACRYPT 2013, Part I. Ed. by Kazue Sako and Palash Sarkar. Vol. 8269. LNCS. Springer, Heidelberg, Dec. 2013, pp. 1–20. doi: 10.1007/978-3-642-42033-7_1.</li>

      <li>[JR14] Charanjit S. Jutla and Arnab Roy. “Switching Lemma for Bilinear Tests and Constant-Size NIZK Proofs for Linear Subspaces”. In: CRYPTO 2014, Part II. Ed. by Juan A. Garay and Rosario Gennaro. Vol. 8617. LNCS. Springer, Heidelberg, Aug. 2014, pp. 295–312. doi: 10.1007/978-3-662-44381-1_17.</li>

      <li>[KLW15] Venkata Koppula, Allison Bishop Lewko, and Brent Waters. “Indistinguishability Obfuscation for Turing Machines with Unbounded Memory”. In: 47th ACM STOC. Ed. by Rocco A. Servedio and Ronitt Rubinfeld. ACM Press, June 2015, pp. 419–428. doi: 10.1145/2746539.2746614.</li>

      <li>[KNYY19] Shuichi Katsumata, Ryo Nishimaki, Shota Yamada, and Takashi Yamakawa. “Exploring Constructions of Compact NIZKs from Various Assumptions”. In: CRYPTO 2019, Part III. Ed. by Alexandra Boldyreva and Daniele Micciancio. Vol. 11694. LNCS. Springer, Heidelberg, Aug. 2019, pp. 639–669. doi: 10.1007/978-3-030-26954-8_21.</li>

    </ul>

    <p class="text-gray-300">[KNYY20] Shuichi Katsumata, Ryo Nishimaki, Shota Yamada, and Takashi Yamakawa. “Compact NIZKs from Standard Assumptions on Bilinear Maps”. In: EUROCRYPT 2020, Part III. Ed. by Anne Canteaut and Yuval Ishai. Vol. 12107. LNCS. Springer, Heidelberg, May 2020, pp. 379–409. doi: 10.1007/978-3-030-45727-3_13.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KP16] Yael Tauman Kalai and Omer Paneth. “Delegating RAM Computations”. In: TCC 2016-B, Part II. Ed. by Martin Hirt and Adam D. Smith. Vol. 9986. LNCS. Springer, Heidelberg, Oct. 2016, pp. 91–118. doi: 10.1007/978-3-662-53644-5_4.</li>

      <li>[KPY18] Yael Kalai, Omer Paneth, and Lisa Yang. On Publicly Verifiable Delegation From Standard Assumptions. Cryptology ePrint Archive, Report 2018/776. https://eprint.iacr.org/2018/776. 2018.</li>

      <li>[KPY19] Yael Tauman Kalai, Omer Paneth, and Lisa Yang. “How to delegate computations publicly”. In: 51st ACM STOC. Ed. by Moses Charikar and Edith Cohen. ACM Press, June 2019, pp. 1115–1124. doi: 10.1145/3313276.3316411.</li>

      <li>[KRR13] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. “Delegation for bounded space”. In: 45th ACM STOC. Ed. by Dan Boneh, Tim Roughgarden, and Joan Feigenbaum. ACM Press, June 2013, pp. 565–574. doi: 10.1145/2488608.2488679.</li>

      <li>[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. “How to delegate computations: the power of no-signaling proofs”. In: 46th ACM STOC. Ed. by David B. Shmoys. ACM Press, May 2014, pp. 485–494. doi: 10.1145/2591796.2591809.</li>

      <li>[KW15] Eike Kiltz and Hoeteck Wee. “Quasi-Adaptive NIZK for Linear Subspaces Revisited”. In: EUROCRYPT 2015, Part II. Ed. by Elisabeth Oswald and Marc Fischlin. Vol. 9057. LNCS. Springer, Heidelberg, Apr. 2015, pp. 101–128. doi: 10.1007/978-3-662-46803-6_4.</li>

      <li>[LPJY13] Benoît Libert, Thomas Peters, Marc Joye, and Moti Yung. “Linearly Homomorphic Structure-Preserving Signatures and Their Applications”. In: CRYPTO 2013, Part II. Ed. by Ran Canetti and Juan A. Garay. Vol. 8043. LNCS. Springer, Heidelberg, Aug. 2013, pp. 289–307. doi: 10.1007/978-3-642-40084-1_17.</li>

      <li>[LPJY14] Benoît Libert, Thomas Peters, Marc Joye, and Moti Yung. “Non-malleability from Malleability: Simulation-Sound Quasi-Adaptive NIZK Proofs and CCA2-Secure Encryption from Homomorphic Signatures”. In: EUROCRYPT 2014. Ed. by Phong Q. Nguyen and Elisabeth Oswald. Vol. 8441. LNCS. Springer, Heidelberg, May 2014, pp. 514–532. doi: 10.1007/978-3-642-55220-5_29.</li>

      <li>[MRV16] Paz Morillo, Carla Ràfols, and Jorge Luis Villar. “The Kernel Matrix Diffie-Hellman Assumption”. In: ASIACRYPT 2016, Part I. Ed. by Jung Hee Cheon and Tsuyoshi Takagi. Vol. 10031. LNCS. Springer, Heidelberg, Dec. 2016, pp. 729–758. doi: 10.1007/978-3-662-53887-6_27.</li>

      <li>[OPWW15] Tatsuaki Okamoto, Krzysztof Pietrzak, Brent Waters, and Daniel Wichs. “New Realizations of Somewhere Statistically Binding Hashing and Positional Accumulators”. In: ASIACRYPT 2015, Part I. Ed. by Tetsu Iwata and Jung Hee Cheon. Vol. 9452. LNCS. Springer, Heidelberg, Nov. 2015, pp. 121–145. doi: 10.1007/978-3-662-48797-6_6.</li>

    </ul>

    <p class="text-gray-300">[PR17] Omer Paneth and Guy N. Rothblum. “On Zero-Testable Homomorphic Encryption and Publicly Verifiable Non-interactive Arguments”. In: TCC 2017, Part II. Ed. by Yael Kalai and Leonid Reyzin. Vol. 10678. LNCS. Springer, Heidelberg, Nov. 2017, pp. 283–315. doi: 10.1007/978-3-319-70503-3_9.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. “Constant-round interactive proofs for delegating computation”. In: 48th ACM STOC. Ed. by Daniel Wichs and Yishay Mansour. ACM Press, June 2016, pp. 49–62. doi: 10.1145/2897518.2897652.</li>

      <li>[RS20] Carla Ràfols and Javier Silva. QA-NIZK Arguments of Same Opening for Bilateral Commitments. Cryptology ePrint Archive, Report 2020/569. https://eprint.iacr.org/2020/569. 2020.</li>

      <li>[Vil12] Jorge Luis Villar. “Optimal Reductions of Some Decisional Problems to the Rank Problem”. In: ASIACRYPT 2012. Ed. by Xiaoyun Wang and Kazue Sako. Vol. 7658. LNCS. Springer, Heidelberg, Dec. 2012, pp. 80–97. doi: 10.1007/978-3-642-34961-4_7.</li>

    </ul>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 10: Modified crs generation algorithm used in Lemma 5.</p>

    <p class="text-gray-300">We use the following lemmas.</p>

    <p class="text-gray-300">Lemma 5. For any adversary  <span class="math">\\mathcal{A}</span>  and for any  <span class="math">\\mathbf{P} \\in \\mathbb{Z}_p^{t_3 \\times n}</span> , let</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon_ {\\mathcal {A}} = \\Pr \\left[ \\begin{array}{c c} \\boldsymbol {d} \\neq 0 &amp;amp; (\\mathbf {M}, \\mathbf {N}) \\leftarrow (\\mathcal {M}, \\mathcal {N}); \\mathsf {c r s} \\leftarrow \\mathsf {K} (g k, [ \\mathbf {M} ] _ {1}, [ \\mathbf {N} ] _ {2}, [ \\mathbf {P} ] _ {1}); \\\\ \\boldsymbol {\\pi} + \\boldsymbol {\\theta} = \\boldsymbol {d} ^ {\\top} \\mathbf {K} _ {3} &amp;amp; ([ \\boldsymbol {d} ] _ {1}, [ \\boldsymbol {\\pi} ] _ {1}, [ \\boldsymbol {\\theta} ] _ {2}) \\leftarrow \\mathcal {A} (\\mathsf {c r s}, [ \\mathbf {M} ] _ {1}, [ \\mathbf {N} ] _ {2}, h (\\mathbf {M}, \\mathbf {N}), \\mathbf {P}) \\end{array} \\right].</span></div>

    <p class="text-gray-300">Then, there exists a PPT adversary  <span class="math">\\mathcal{B}</span>  such that  <span class="math">\\epsilon_{\\mathcal{A}} \\leq \\mathrm{Adv}_{(\\mathcal{M}^{\\top},h)\\text{-MDDH}}(\\mathcal{B}) + 1/p</span> , where  <span class="math">\\mathcal{M}^{\\top}</span>  is the distribution which results from sampling matrices from  <span class="math">\\mathcal{M}</span>  and transposing them.</p>

    <p class="text-gray-300">Proof. (Lemma 5)</p>

    <p class="text-gray-300">We show this by a sequence of games.</p>

    <p class="text-gray-300">Game0: This game runs the adversary as in Lemma 5.</p>

    <p class="text-gray-300">Game1: This game is exactly as  <span class="math">\\mathsf{Game}_0</span>  but the crs is computed using algorithm  <span class="math">\\mathsf{K}^*</span> , as defined in Fig. 10, and the winning condition is  <span class="math">d \\neq 0</span>  and  <span class="math">\\pi = (d^{\\top}(\\mathbf{C}_3 - \\mathbf{K}_{3,2}\\underline{\\mathbf{A}})\\overline{\\mathbf{A}}^{-1}, d^{\\top}\\mathbf{K}_{3,2})</span> ,</p>

    <p class="text-gray-300">Game2: This game is exactly as  <span class="math">\\mathsf{Game}_1</span>  but  <span class="math">s, t \\gets \\mathbb{Z}_p^n</span> .</p>

    <p class="text-gray-300">We now prove some Lemmas which show that the games are indistinguishable. Lemmas 6 and 7 show that the adversary has essentially the same advantage of winning in any game. Lemma 8 says that the adversary has negligible probability of winning in  <span class="math">\\mathsf{Game}_2</span> . Lemma 5 follows from the composition of lemmas 6, 7 and 8.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Lemma 6. For any (unbounded) algorithm  <span class="math">\\mathcal{A}</span>  we have  <span class="math">\\operatorname<em>{Pr}[\\mathsf{Game}_1(\\mathcal{A}) = 1] = \\operatorname</em>{Pr}[\\mathsf{Game}_0(\\mathcal{A}) = 1]</span> .</p>

    <p class="text-gray-300">Proof. If we define  <span class="math">\\mathbf{K}_{1,1} = (\\mathbf{C}_1 - \\mathbf{K}_{1,2}\\underline{\\mathbf{A}})\\overline{\\mathbf{A}}^{-1}</span>  and  <span class="math">\\mathbf{K} = \\begin{pmatrix} \\mathbf{K}_1 \\\\ \\mathbf{K}_3 \\end{pmatrix} = \\begin{pmatrix} \\mathbf{K}_{1,1} &amp;amp; \\mathbf{K}_{1,2} \\\\ \\mathbf{K}_{3,1} &amp;amp; \\mathbf{K}_{3,2} \\end{pmatrix}</span> , we observe that the output of  <span class="math">\\mathsf{K}^*</span>  is well formed and the winning condition is the same as in the previous game,</p>

    <p class="text-gray-300">since <span class="math">\\mathbf{B},\\mathbf{D}</span> are uniform conditioned on their sum being equal to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {B} + \\mathbf {D} = \\left(\\left(\\mathbf {M} ^ {\\top} + \\mathbf {N} ^ {\\top}\\right) \\mathbf {K} _ {1, 1} + \\mathbf {P} ^ {\\top} \\mathbf {K} _ {3, 1}, s + \\mathbf {P} ^ {\\top} \\mathbf {K} _ {3, 2}\\right) + \\left(\\mathbf {R} ^ {\\top} \\mathbf {K} _ {1, 1}, t\\right) + \\boldsymbol {\\Gamma} - \\boldsymbol {\\Gamma} \\\\ = \\left((\\mathbf {M} ^ {\\top} + \\mathbf {N} ^ {\\top}) \\mathbf {K} _ {1, 1} + \\mathbf {P} ^ {\\top} \\mathbf {K} _ {3, 1}, (\\mathbf {M} ^ {\\top} + \\mathbf {N} ^ {\\top}) \\mathbf {K} _ {1, 2} + \\mathbf {P} ^ {\\top} \\mathbf {K} _ {3, 2}\\right) \\\\ = (\\mathbf {M} ^ {\\top} + \\mathbf {N} ^ {\\top}) \\left( \\begin{array}{l} \\mathbf {K} _ {1, 1} \\\\ \\mathbf {K} _ {1, 2} \\end{array} \\right) + \\mathbf {P} ^ {\\top} \\left( \\begin{array}{l} \\mathbf {K} _ {3, 1} \\\\ \\mathbf {K} _ {3, 2} \\end{array} \\right) = (\\mathbf {M} ^ {\\top} + \\mathbf {N} ^ {\\top} \\mid \\mathbf {P} ^ {\\top}) \\mathbf {K}, \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {K A} = \\left( \\begin{array}{l l} (\\mathbf {C} _ {1} - \\mathbf {K} _ {1, 2} \\underline {{\\mathbf {A}}}) \\overline {{\\mathbf {A}}} ^ {- 1} &amp;amp; \\mathbf {K} _ {1, 2} \\\\ (\\mathbf {C} _ {3} - \\mathbf {K} _ {3, 2} \\underline {{\\mathbf {A}}}) \\overline {{\\mathbf {A}}} ^ {- 1} &amp;amp; \\mathbf {K} _ {3, 2} \\end{array} \\right) \\left( \\begin{array}{l} \\overline {{\\mathbf {A}}} \\\\ \\underline {{\\mathbf {A}}} \\end{array} \\right) = \\left( \\begin{array}{l} \\mathbf {C} _ {1} - \\mathbf {K} _ {1, 2} \\underline {{\\mathbf {A}}} + \\mathbf {K} _ {1, 2} \\underline {{\\mathbf {A}}} \\\\ \\mathbf {C} _ {3} - \\mathbf {K} _ {3, 1} \\underline {{\\mathbf {A}}} + \\mathbf {K} _ {3, 2} \\underline {{\\mathbf {A}}} \\end{array} \\right) = \\mathbf {C},</span></div>

    <p class="text-gray-300">and by definition <span class="math">\\pi + \\theta = (d^{\\top}(\\mathbf{C}_3 - \\mathbf{K}_{3,2}\\underline{\\mathbf{A}})\\overline{\\mathbf{A}}^{-1}, d^{\\top}\\mathbf{K}_{3,2}) = (d^{\\top}\\mathbf{K}_{3,1}, d^{\\top}\\mathbf{K}_{3,2}) = d^{\\top}\\mathbf{K}_3</span>.</p>

    <p class="text-gray-300">Therefore we just need to argue that the distribution of <span class="math">\\mathbf{K}</span> is the same in both games. But this is an immediate consequence of the fact that for every value of <span class="math">(\\mathbf{C}, \\mathbf{K}_{1,1}, \\mathbf{K}_{3,1})</span> there exists a unique value of <span class="math">(\\mathbf{K}_{1,2}, \\mathbf{K}_{3,2})</span> which is compatible with <span class="math">\\mathbf{C} = \\mathbf{KA}</span>. Indeed, <span class="math">\\mathbf{C} = \\mathbf{KA} \\Longleftrightarrow \\mathbf{C}_i = \\mathbf{K}_{i,1} \\overline{\\mathbf{A}} + \\mathbf{K}_{i,2} \\underline{\\mathbf{A}}</span>, <span class="math">i = 1, 3 \\Longleftrightarrow (\\mathbf{C}_i - \\mathbf{K}_{i,2} \\underline{\\mathbf{A}}) \\overline{\\mathbf{A}}^{-1} = \\mathbf{K}_{i,1}</span>, <span class="math">i = 1, 3</span>.</p>

    <p class="text-gray-300">Lemma 7. For any PPT algorithm <span class="math">\\mathcal{A}</span> there exists a PPT algorithm <span class="math">\\mathcal{B}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\Pi_ {k t - s u m, k ^ {\\prime}}} (\\mathcal {A}) \\leq \\operatorname {A d v} _ {(M ^ {\\top}, N ^ {\\top}, h) \\sim \\mathrm {M D D H}} (\\mathcal {B}).</span></div>

    <p class="text-gray-300">Proof. We construct an adversary <span class="math">\\mathcal{B}</span> that receives the challenge <span class="math">([\\mathbf{M}^{\\top}]_1, [\\mathbf{N}^{\\top}]_2, [s^<em>]_1, [t^</em>]_2, h([\\mathbf{M}^{\\top}, \\mathbf{N}^{\\top}])</span>, where <span class="math">s^<em> + t^</em> = (\\mathbf{M}^{\\top} + \\mathbf{N}^{\\top})w</span>, <span class="math">w \\gets \\mathbb{Z}_p^{\\ell_1}</span>, or <span class="math">s^<em>, t^</em> \\gets \\mathbb{Z}_p^n</span>. <span class="math">\\mathcal{B}</span> computes the crs running <span class="math">\\mathsf{K}^<em>(gk, [\\mathbf{M}]_1, [\\mathbf{N}]_2, [\\mathbf{P}]_1)</span> but replaces <span class="math">[s]_1, [t]_2</span> with <span class="math">[s^</em>]_1, [t^*]_2</span> respectively, and then runs <span class="math">\\mathcal{A}</span> as in game <span class="math">\\mathsf{Game}_1</span>. Since <span class="math">\\mathsf{Game}_1</span> corresponds to the first case and <span class="math">\\mathsf{Game}_2</span> to the second, the lemma follows.</p>

    <p class="text-gray-300">Lemma 8. For any (unbounded) algorithm <span class="math">\\mathcal{A}</span>, <span class="math">\\operatorname*{Pr}[\\mathsf{Game}_2(\\mathcal{A}) = 1] \\leq 1/p</span>.</p>

    <p class="text-gray-300">Proof. We will show that, conditioned on <span class="math">\\mathbf{A},\\mathbf{C},\\mathbf{B} + \\mathbf{D},\\mathbf{M} + \\mathbf{N},\\mathbf{P}</span>, the matrix <span class="math">\\mathbf{K}_{3,2}</span> is uniformly distributed. Since it holds that <span class="math">(\\mathbf{B} + \\mathbf{D})\\mathbf{A} = (\\mathbf{M}^{\\top} + \\mathbf{N}^{\\top} \\mid \\mathbf{P}^{\\top})\\mathbf{C}</span>, we get that the first <span class="math">k</span> columns of <span class="math">\\mathbf{B} + \\mathbf{D}</span>, namely <span class="math">\\mathbf{B}_1 + \\mathbf{D}_1</span>, are completely determined by the last columns <span class="math">\\mathbf{B}_2 + \\mathbf{D}_2</span>. Indeed</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {B} _ {1} + \\mathbf {D} _ {1}, \\mathbf {B} _ {2} + \\mathbf {D} _ {2}\\right) \\mathbf {A} = \\left(\\mathbf {M} ^ {\\top} + \\mathbf {N} ^ {\\top} \\mid \\mathbf {P} ^ {\\top}\\right) \\mathbf {C} \\Longleftrightarrow \\mathbf {B} _ {1} + \\mathbf {D} _ {1} = \\left(\\left(\\mathbf {M} ^ {\\top} + \\mathbf {N} ^ {\\top} \\mid \\mathbf {P} ^ {\\top}\\right) \\mathbf {C} - \\left(\\mathbf {B} _ {2} + \\mathbf {D} _ {2}\\right) \\underline {{\\mathbf {A}}}\\right) \\overline {{\\mathbf {A}}} ^ {- 1}.</span></div>

    <p class="text-gray-300">Hence, conditioning in <span class="math">\\mathbf{A},\\mathbf{C},\\mathbf{B}_1 + \\mathbf{D}_1,\\mathbf{M} + \\mathbf{N},\\mathbf{P}</span> doesn't alter the probability. We have that <span class="math">\\mathbf{B}_2 + \\mathbf{D}_2 = (s + t) + \\mathbf{P}^\\top \\mathbf{K}_{3,2}</span>, which consists of <span class="math">n</span> equations on <span class="math">n + \\ell_2</span> variables. It follows that there are <span class="math">\\ell_2</span> free variables. Then <span class="math">\\mathbf{K}_{3,2}</span> is uniformly distributed and hence completely hidden to the adversary.</p>

    <p class="text-gray-300">Note that</p>

    <div class="my-4 text-center"><span class="math-block">\\pi + \\theta = d ^ {\\top} \\mathbf {K} _ {3} \\Longrightarrow \\pi_ {2} + \\theta_ {2} = d ^ {\\top} \\mathbf {K} _ {3, 2},</span></div>

    <p class="text-gray-300">where <span class="math">\\pi_2, \\theta_2</span> are the last element of <span class="math">\\pi</span>, <span class="math">\\theta</span> respectively. Given that <span class="math">d \\neq 0</span>, the last equation only holds with probability <span class="math">1/p</span> and so <span class="math">\\mathcal{A}</span>'s probability of winning.</p>

    <p class="text-gray-300">The knowledge transfer property is a direct consequence of Lemma 5. We present the proof next.</p>

    <p class="text-gray-300">Theorem 18. For any adversary <span class="math">\\mathcal{A}</span> against the soundness of <span class="math">\\Pi_{\\mathrm{kt - sum}}</span> with respect to <span class="math">\\mathcal{L}_{\\mathrm{sum}}^{\\infty}</span>, there exist adversaries <span class="math">\\mathcal{B}_1</span> and <span class="math">\\mathcal{B}_2</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathrm {k t - s u m}} (\\mathcal {A}) \\leq \\operatorname {A d v} _ {\\mathcal {D} _ {k} \\sim \\text {S K e r M D H}} (\\mathcal {B} _ {1}) + \\operatorname {A d v} _ {(M ^ {\\top}, N ^ {\\top}, h) \\sim \\text {M D D H}} + 1 / p.</span></div>

    <p class="text-gray-300">Proof. Given an adversary that produces a valid proof for a statement in  <span class="math">\\mathcal{L}_{\\mathrm{sum}}^{\\mathrm{no}}</span> , successful attacks can be divided in two categories.</p>

    <p class="text-gray-300">Type I: In this attack  <span class="math">\\pi +\\theta \\neq (c_1^\\top +c_2^\\top)\\mathbf{K}_1 + d^\\top \\mathbf{K}_3</span></p>

    <p class="text-gray-300">Type II: In this type of attack  <span class="math">\\pi +\\theta = (c_1^\\top +c_2^\\top)\\mathbf{K}_1 + d^\\top \\mathbf{K}_3</span></p>

    <p class="text-gray-300">Type I attacks are computationally infeasible when  <span class="math">\\overline{k} = k + 1</span> , as they can be used to construct an adversary  <span class="math">\\mathcal{B}_1</span>  against the  <span class="math">\\mathcal{D}_k</span> -SKerMDH assumption.[21] Adversary  <span class="math">\\mathcal{B}_1</span>  receives a challenge  <span class="math">[\\mathbf{A}]_{1,2}</span>  and then runs the soundness experiment for  <span class="math">\\mathcal{A}</span> . When  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">([c_1]_1, [c_2]_2, [d]_1, [\\pi]_1, [\\theta]_2)</span> ,  <span class="math">\\mathcal{B}_1</span>  outputs  <span class="math">[\\pi^\\dagger]_1 = [\\pi]_1 - [c_1^\\top]_1\\mathbf{K}_1 - [d^\\top]_1\\mathbf{K}_3</span> ,  <span class="math">[\\theta^\\dagger]_2 = [\\theta]_1 - [c_2^\\top]_1\\mathbf{K}_1</span>  where it holds that  <span class="math">\\pi + \\theta \\neq (c_1^\\top + c_2^\\top)\\mathbf{K}_1 + d^\\top\\mathbf{K}_3</span> . Since  <span class="math">[\\pi]_1, [\\theta]_2</span>  is accepted by the verifier we get that  <span class="math">e([\\pi]_1, [\\mathbf{A}]_2) + e([\\theta]_2, [\\mathbf{A}]_1) = e([c_1^\\top]_1, [\\mathbf{C}_1]_2) + e([c_2^\\top]_2, [\\mathbf{C}_1]_1) + e([d^\\top]_1, [\\mathbf{C}_3]_2)</span>  and then  <span class="math">(\\pi^\\dagger + \\theta^\\dagger)\\mathbf{A} = (\\pi + \\theta)\\mathbf{A} - (c_1^\\top + c_2^\\top)\\mathbf{K}_1\\mathbf{A} - d^\\top\\mathbf{K}_3\\mathbf{A} = (\\pi + \\theta)\\mathbf{A} - (c_1 + c_2)^\\top\\mathbf{C}_1 - d^\\top\\mathbf{C}_3 = 0</span> . We conclude that the success probability of a type I attack is bounded by  <span class="math">\\mathrm{Adv}_{\\mathcal{D}_k\\text{-SKerMDH}}(\\mathcal{B}_1)</span> .</p>

    <p class="text-gray-300">For type II attacks, since  <span class="math">[\\pi]_1 = [c_1^\\top]_1\\mathbf{K}_1 + [d^\\top]_1\\mathbf{K}_3</span> ,  <span class="math">[\\theta]_2 = [c_2^\\top]_2\\mathbf{K}_1</span>  is a valid proof for  <span class="math">\\left( \\begin{array}{c}[c_1]_1 \\\\ [c_2]_2 \\\\ [d]_1 \\end{array} \\right)</span> , then, by linearity of the verification equations  <span class="math">\\pi^\\dagger = \\pi - w^\\top \\mathbf{B}</span>  and  <span class="math">\\theta^\\dagger = \\theta - w^\\top \\mathbf{B}</span>  is a valid proof for  <span class="math">\\left( \\begin{array}{c}0 \\\\ 0 \\\\ [d^\\dagger]_1 \\end{array} \\right) = \\left( \\begin{array}{c}[c_1]_1 - [\\mathbf{M}]_1w \\\\ [c_2]_2 - [\\mathbf{N}]_2w \\\\ [d]_1 - [\\mathbf{P}]_1w \\end{array} \\right)</span> . Since  <span class="math">d \\neq \\mathbf{N}w</span> , we conclude that an attacker of type II can be turned into an attacker  <span class="math">\\mathcal{B}_2</span>  for Lemma 5.</p>

    <p class="text-gray-300">We next note that the argument of knowledge transfer remains secure even for matrix distribution that also include some zero columns.</p>

    <p class="text-gray-300">Theorem 19. Let  <span class="math">\\mathcal{M}&#x27;,\\mathcal{N}&#x27;,\\mathcal{P}&#x27;,\\mathcal{Q}&#x27;</span>  be matrix distributions that sample  <span class="math">(\\mathbf{M}\\mid \\mathbf{0}_{\\ell_1\\times n&#x27;})</span> <span class="math">(\\mathbf{N}\\mid \\mathbf{0}_{\\ell_2\\times n&#x27;})</span> <span class="math">(\\mathbf{P}\\mid \\mathbf{0}_{\\ell_3\\times n&#x27;})</span> <span class="math">(\\mathbf{Q}\\mid \\mathbf{0}_{\\ell_4\\times n&#x27;})</span>  where  <span class="math">\\mathbf{M}\\gets \\mathcal{M},\\mathbf{N}\\gets \\mathcal{N},\\mathbf{P}\\gets \\mathcal{P},\\mathbf{Q}\\gets \\mathcal{Q}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any adversary  <span class="math">\\mathcal{A}</span>  against the  <span class="math">h</span> -strong soundness of  <span class="math">\\Pi_{kt-lin}</span>  there exist adversaries  <span class="math">\\mathcal{B}_1</span>  and  <span class="math">\\mathcal{B}_2</span>  such that  <span class="math">\\mathrm{Adv}_{\\Pi_{kt-lin},h&#x27;}(\\mathcal{A}) \\leq \\mathrm{Adv}_{\\mathcal{D}_k\\text{-SKerMDH}}(\\mathcal{B}_1) + \\mathrm{Adv}_{(\\mathcal{M}^\\top, h)\\text{-MDDH}}(\\mathcal{B}_2) + 1/p</span> , where  <span class="math">h&#x27;([\\mathbf{M}]_1, [\\mathbf{N}]_2, [\\mathbf{P}]_1, [\\mathbf{Q}]_2) = (h(\\mathbf{M}), \\mathbf{N}, \\mathbf{P}, \\mathbf{Q})</span> .</li>

      <li>When  <span class="math">\\ell_1 = \\ell_2</span> , for any adversary  <span class="math">\\mathcal{A}</span>  against the  <span class="math">h</span> -strong soundness of  <span class="math">\\Pi_{kt-sum}</span>  there exist adversaries  <span class="math">\\mathcal{B}_1</span>  and  <span class="math">\\mathcal{B}_2</span>  such that  <span class="math">\\mathrm{Adv}_{\\Pi_{kt-sum},h&#x27;}(\\mathcal{A}) \\leq \\mathrm{Adv}_{\\mathcal{D}_k\\text{-SKerMDH}}(\\mathcal{B}_1) + \\mathrm{Adv}_{(\\mathcal{M}^\\top, \\mathcal{N}^\\top, h)\\text{-MDDH}}(\\mathcal{B}_2) + 1/p</span> , where  <span class="math">h&#x27;([\\mathbf{M}]_1, [\\mathbf{N}]_2, [\\mathbf{P}]_1, [\\mathbf{Q}]_2) = (h(\\mathbf{M}, \\mathbf{N}), \\mathbf{P}, \\mathbf{Q})</span> .</li>

    </ol>

    <p class="text-gray-300">The proof is implicitly shown in [GR19, Lemma 15]. Essentially one can reduce to the knowledge transfer argument where we delete the zero columns of the matrix and rely on the linearity properties of the proofs of construction of Fig. 1.</p>`;
---

<BaseLayout title="Fully-succinct Publicly Verifiable Delegation from Constant-... (2021/353)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/353
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
