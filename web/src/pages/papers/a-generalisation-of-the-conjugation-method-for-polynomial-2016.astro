---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/537';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'A Generalisation of the Conjugation Method for Polynomial Selection for the Extended Tower Number Field Sieve Algorithm';
const AUTHORS_HTML = 'Palash Sarkar and Shashank Singh';

const CONTENT = `    <p class="text-gray-300">Palash Sarkar and Shashank Singh</p>

    <p class="text-gray-300">Applied Statistics Unit Indian Statistical Institute palash@isical.ac.in, sha2nk.singh@gmail.com</p>

    <p class="text-gray-300">Abstract. In a recent work, Kim and Barbulescu showed how to combine previous polynomial selection methods with the extended tower number field sieve algorithm to obtain improved complexity for the discrete logarithm problem on finite fields Fp&lt;sup&gt;n&lt;/sup&gt; for the medium prime case and where n is composite and not a prime-power. A follow up work by Sarkar and Singh presented a general polynomial selection method and showed how to lower the complexity in the medium prime case even when n is composite and a prime-power. This complexity, though, was higher than what was reported for the case of n composite and not a prime-power. By suitably combining the Conjugation method of polynomial selection proposed earlier by Barbulescu et al. with the extended tower number field sieve algorithm, Jeong and Kim showed that the same asymptotic complexity is achieved for any composite n. The present work generalises the polynomial selection method of Jeong and Kim for all composite n. Though the best complexity that can be achieved is not lowered, there is a significant range of finite fields for which the new algorithm achieves complexity which is lower than all previously proposed methods.</p>

    <p class="text-gray-300">Keywords: finite fields, discrete logarithm, tower number field sieve.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">1 Introduction</h4>

    <p class="text-gray-300">One of the important problems in cryptography is to compute discrete logarithms over the multiplicative group of a finite field. There are two known general approaches to this problem which lead to sub-exponential run-time. These are the function field sieve (FFS) [1, 2, 15, 17] and the number field sieve (NFS) [9, 16, 18] algorithms.</p>

    <p class="text-gray-300">Let p be a prime, n ≥ 1 be an integer and Q = p &lt;sup&gt;n&lt;/sup&gt;. Suppose that p = LQ(a, cp) where</p>

    <p class="text-gray-300"><span class="math">$L_Q(a, c_p) = \\exp((c_p + o(1))(\\ln Q)^a (\\ln \\ln Q)^{1-a}).</span>$</p>

    <p class="text-gray-300">Depending on the value of a, fields F&lt;sup&gt;Q&lt;/sup&gt; are classified into the following types: small characteristic, if a ≤ 1/3; medium characteristic, if 1/3 &lt; a &lt; 2/3; boundary, if a = 2/3; and large characteristic, if a &gt; 2/3.</p>

    <p class="text-gray-300">There has been tremendous progress in the FFS algorithm leading to a quasipolynomial time algorithm [5] for the small characteristic case. Using algorithms given in [14, 5], a record computation of discrete log in the binary extension field F2 &lt;sup&gt;9234&lt;/sup&gt; was reported by Granger et al [10]. The FFS algorithm also applies to the medium prime case and this has been reported in [17, 13, 23].</p>

    <p class="text-gray-300">The NFS algorithm is generally considered to be the state-of-the-art for medium to large characteristic finite fields. The application of NFS to compute discrete logarithms over finite fields was first proposed by Gordon [9] for prime order fields, i.e., for n = 1. Application to composite order fields, i.e., for n &gt; 1, was shown by Schirokauer [27]. Important improvements to the NFS for prime order fields were given by Joux and Lercier [16]. Joux, Lercier, Smart and Vercauteren [18] showed that the NFS algorithm is applicable to all finite fields. When the prime p is of a special form, Joux and Pierrot [19] showed the application of the special number field sieve algorithm to obtain improved complexity.</p>

    <p class="text-gray-300">The basic structure of the NFS algorithm is to construct two polynomials f(x) and g(x) over the integers which have a common factor ϕ(x) of degree n modulo p. The polynomial ϕ(x) defines the field Fp&lt;sup&gt;n&lt;/sup&gt; while the polynomials f(x) and g(x) define two number fields. The efficiency of the NFS algorithm is crucially dependent on the properties of the polynomials f(x) and g(x) used to construct the number fields. Consequently, polynomial selection is an important step in the NFS algorithm and is an active area of research.</p>

    <p class="text-gray-300">Sequence of recent works on NFS: Starting with the work of Barbulescu et al. [4], there have been several recent works which continuously improve polynomial selection algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Barbulescu et al. [4] introduced two new methods for polynomial selection, namely, the generalised Joux-Lercier (GJL) and the Conjugation method. For the boundary case, the best complexity obtained was LQ(1/3,(48/9)1/&lt;sup&gt;3&lt;/sup&gt; ). The best complexities for the medium and the large prime cases were respectively LQ(1/3,(96/9)1/&lt;sup&gt;3&lt;/sup&gt; ) and LQ(1/3,(64/9)1/&lt;sup&gt;3&lt;/sup&gt; ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pierrot [22] worked out the asymptotic complexity of the multiple NFS (MNFS) for the GJL and the Conjugation methods and in all cases obtained lower values of the second term in the corresponding sub-exponential expressions.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Barbulescu et al. [6] provided a detailed analysis of the tower number field sieve (TNFS) variant which had earlier been proposed by Schirokauer [27].</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sarkar and Singh [25] provided a method (called Algorithm-A) for polynomial selection which both generalised and subsumed the GJL and the Conjugation methods. Asymptotic complexity for NFS and MNFS were worked out. The best reported complexities in [4] and [22] are obtained for one particular value of cp. While the new method of [25] could not lower these complexities, it was shown that there are significant ranges for the values of cp, where in comparison to [4, 22], lower asymptotic complexities are obtained.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Gaudry et al. [8] discussed practical issues in relation collection and the consequences of polynomial selection to this phase.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Kim and Barbulescu [21] (which is a merge of [20] and [3]) combined previous polynomial selection methods with the extended TNFS (exTNFS) algorithm to obtain improved complexities for the medium prime case when the extension degree n is composite and not a prime-power. The complexity they achieved is LQ(1/3,(48/9)1/&lt;sup&gt;3&lt;/sup&gt; ) using classical NFS. An improvement of the second term of the sub-exponential expression was obtained using MNFS. The paper also reported improved complexities for special number field sieve algorithm.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sarkar and Singh [26] provided an extension of Algorithm-A to provide a general method (called Algorithm-B) for polynomial selection for the case considered in [21], i.e., for composite n which is not a prime power. It was shown that in this setting, the GJL and the Conjugation method are special cases of Algorithm-B.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sarkar and Singh [24] provided an extension of Algorithm-B called Algorithm-C which covered all composite n. When n is composite and a power of 2, the best complexity in the medium prime case using NFS was obtained to be LQ(1/3,(64/9)1/&lt;sup&gt;3&lt;/sup&gt; ). Progressively higher best complexities were reported for other prime-power values of n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Guillevic et al. [11] reported a computation of discrete logarithm on an 170 bit MNT curve. They used the Conjugation method for selecting polynomials.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Jeong and Kim [12] showed how to combine the Conjugation method with exTNFS to cover all composite extension degrees. In particular, they showed that using classical NFS, the best complexity obtained for composite n (irrespective of whether it is a prime-power or not) in the medium prime case is LQ(1/3,(48/9)1/&lt;sup&gt;3&lt;/sup&gt; ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The present paper provides a new general polynomial selection method, called Algorithm-D. This algorithm works for all composite values of n and has the Conjugation method as a special case in the exTNFS setting. The best complexity achieved for the medium prime case is LQ(1/3,(48/9)1/&lt;sup&gt;3&lt;/sup&gt; ) for all composite n. This complexity is the same as that reported by Jeong and Kim [12]. On the other hand, for the medium prime case, there is a significant range of finite fields for which lower complexity is achieved. Suppose that n = ηκ and that η can be written as η = cη(ln Q/ln ln Q) &lt;sup&gt;2&lt;/sup&gt;/3−&lt;sup&gt;a&lt;/sup&gt; and let c&lt;sup&gt;θ&lt;/sup&gt; = cpcη. For c&lt;sup&gt;θ&lt;/sup&gt; ∈ [3.39, 20.91], the complexity of exTNFS-D is lower than the complexities of all previous algorithms whether classical or MTNFS. For c&lt;sup&gt;θ&lt;/sup&gt; ∈ (0, 1.12) ∪ [1.45, 3.15], the complexity of MexTNFS-D is the same as that of MexTNFS-Conj and for c&lt;sup&gt;θ&lt;/sup&gt; ∈/ (0, 1.12) ∪ [1.45, 3.15], the complexity of MexTNFS-D is lower than that of all previous methods.</p>

    <p class="text-gray-300">We note that Algorithm-D does not subsume ether Algorithm-B or Algorithm-C. Though the asymptotic complexity obtained by Algorithm-D is lower than that of Algorithm-C, there are certain trade-offs in the norm bound that are achieved using Algorithm-C but, not using Algorithm-D.</p>

    <p class="text-gray-300">There is a mis-conception appearing in several works that the Sarkar-Singh method from [25] (i.e., Algorithm-A) is applicable only when n is composite. We have noted that such comments appear in [21,11]. By extension, there may be a mis-conception that for composite  <span class="math">n = \\eta \\kappa</span> , Algorithms- <span class="math">\\mathcal{B}</span> ,  <span class="math">\\mathcal{C}</span>  (from [26] and [24]) and  <span class="math">\\mathcal{D}</span>  appearing here are applicable only when  <span class="math">\\kappa</span>  is prime. We would like to clear this confusion.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Algorithm- <span class="math">\\mathcal{A}</span>  from [25] applies for all values of n. The algorithm has two parameters, namely a divisor d of n and a positive integer r such that  <span class="math">r \\geq n/d</span> . For d=1, Algorithm- <span class="math">\\mathcal{A}</span>  reduces to the GJL method. For d=n, Algorithm- <span class="math">\\mathcal{A}</span>  provides a generalisation of the Conugation method; the conjugation method is obtained by choosing r=1; for certain ranges of  <span class="math">c_p</span> , it is possible to choose r&gt;1 to obtain asymptotic complexity which is lower than the Conjugation method. The cases of d=1 and d=n apply irrespective of whether n is prime or composite. If further, n is composite, then it is possible to choose 1 &lt; d &lt; n to obtain new trade-offs on the norm bounds. We note that the work [8] correctly describes this set-up.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For Algorithms- <span class="math">\\mathcal{B}</span>  and  <span class="math">\\mathcal{C}</span>  the above statements apply with n replaced by  <span class="math">\\kappa</span> . For Algorithm- <span class="math">\\mathcal{B}</span> , the condition  <span class="math">\\gcd(\\eta, \\kappa) = 1</span>  is required while no such condition is required for Algorithm- <span class="math">\\mathcal{C}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Algorithm- <span class="math">\\mathcal{D}</span>  has the parameters r and d with the condition that  <span class="math">\\gcd(\\eta, \\kappa/d) = 1</span> . By suitably choosing d (for example choosing  <span class="math">d = \\kappa</span> ), Algorithm- <span class="math">\\mathcal{D}</span>  can be made to work for all composite n. Choosing  <span class="math">d = \\kappa</span>  and r = 1 provides the Conjugation method in the exTNFS setting. Choosing r &gt; 1 (or  <span class="math">d &lt; \\kappa</span> , if appropriate) provides a generalisation of the Conjugation method.</li>
    </ol></li>
    </ul>

    <h2 id="sec-2" class="text-2xl font-bold">2 The Set-Up of the Tower Number Field Sieve Algorithm</h2>

    <p class="text-gray-300">The target is to compute discrete logarithm in the field  <span class="math">\\mathbb{F}_{p^n}</span>  where n is composite. Suppose that  <span class="math">n = \\eta \\kappa</span>  is a non-trivial factorisation of n.</p>

    <p class="text-gray-300">Let h(z) be a monic polynomial of degree  <span class="math">\\eta</span>  which is irreducible over both  <span class="math">\\mathbb{Z}</span>  and  <span class="math">\\mathbb{F}_p</span> . Let  <span class="math">R = \\mathbb{Z}[z]/(h(z))</span> . Also, note that  <span class="math">\\mathbb{F}_{p^{\\eta}} = \\mathbb{F}_p[z]/(h(z))</span> .</p>

    <p class="text-gray-300">Let f(x) and g(x) be polynomials in R[x] whose leading coefficients are from  <span class="math">\\mathbb{Z}</span> . The other coefficients of f and g are polynomials in z of degrees at most  <span class="math">\\eta-1</span> . In particular, f and g can be viewed as bi-variate polynomials in x and z with coefficients in  <span class="math">\\mathbb{Z}</span> . The following properties are required.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Both f(x) and g(x) are irreducible over R.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> , f(x) and g(x) have a common factor  <span class="math">\\varphi(x)</span>  of degree  <span class="math">\\kappa</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The field  <span class="math">\\mathbb{F}_{p^n}</span>  is realised as  <span class="math">\\mathbb{F}_{p^n}[x]/(\\varphi(x)) = (R/pR)[x]/(\\varphi(x))</span> .</p>

    <p class="text-gray-300">Let  <span class="math">K_f</span>  and  <span class="math">K_g</span>  be the number fields associated with the polynomials f and g respectively. The above set-up provides two different decompositions of a homomorphism from R[x] to  <span class="math">\\mathbb{F}_{p^n}</span> . One of these goes through R[x]/(f(x)) and the other goes through R[x]/(g(x)).</p>

    <p class="text-gray-300">With this set-up, it is possible to set up a factor base and perform the three main steps (relation collection, linear algebra and descent) of the NFS algorithm. For details we refer to [6, 21]. In this work, we will need only the following facts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The factor base consists of B elements for some value B which determines the overall complexity of the algorithm.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A polynomial  <span class="math">\\phi(x) \\in R[x]</span>  generates a relation if both the norms  <span class="math">N(\\phi, f)</span>  and  <span class="math">N(\\phi, g)</span>  are B-smooth, where</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$N(\\phi, f) := \\operatorname{Res}_{z}(\\operatorname{Res}_{x}(\\phi(x), f(x)), h(z));</span>$</p>

    <p class="text-gray-300"><span class="math">$N(\\phi, g) := \\operatorname{Res}_{z}(\\operatorname{Res}_{x}(\\phi(x), g(x)), h(z)).</span>$</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2.1 Bounds on Resultants</h4>

    <p class="text-gray-300">Let f(z,x) be a bivariate polynomial with integer coefficients where  <span class="math">f_{i,j}</span>  is the coefficient of  <span class="math">x^iz^j</span> . Then</p>

    <p class="text-gray-300"><span class="math">$||f||_{\\infty} = \\max|f_{i,j}|.</span>$</p>

    <p class="text-gray-300">Bounds on resultants of univariate and bivariate polynomials were given in [7]. In the following, we summarise these bounds.</p>

    <p class="text-gray-300">Univariate polynomials: Let a(u) and b(u) be two polynomials with integer coefficients. From [7], we have</p>

    <p class="text-gray-300"><span class="math">$|\\operatorname{Res}_{u}(a(u), b(u))| \\le (\\deg(a) + 1)^{\\deg(b)/2} (\\deg(b) + 1)^{\\deg(a)/2} ||a||_{\\infty}^{\\deg(b)} \\times ||b||_{\\infty}^{\\deg(a)}.</span>$
(1)</p>

    <p class="text-gray-300"><strong>Bivariate polynomials:</strong> Let a(u, v) and b(u, v) be two polynomials with integer coefficients. Let  <span class="math">c(u) = \\text{Res}_v(a(u, v), b(u, v))</span> . Then</p>

    <p class="text-gray-300"><span class="math">$||c||_{\\infty}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq (\\deg_{v}(a) + \\deg_{v}(b))! (\\max(\\deg_{u}(a), \\deg_{u}(b)) + 1)^{\\deg_{v}(a) + \\deg_{v}(b) + 1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\times ||a||_{\\infty}^{\\deg_{v}(b)} \\times ||b||_{\\infty}^{\\deg_{v}(a)}. \\tag{2}</span>$</p>

    <p class="text-gray-300">The bounds given by (1) and (2) combine to provide bounds on  <span class="math">N(\\phi, f)</span> . Let  <span class="math">\\phi(x, z)</span>  and f(x, z) be two polynomials and</p>

    <p class="text-gray-300"><span class="math">$\\rho(z) = \\operatorname{Res}_x(\\phi(x,z), f(x,z)).</span>$</p>

    <p class="text-gray-300">Further, suppose  <span class="math">\\deg_x \\phi \\leq t-1</span>  and  <span class="math">\\deg_z \\phi \\leq \\eta-1</span> . For  <span class="math">\\|\\phi\\|_{\\infty} = E^{2/(t\\eta)}</span> , the number of possible  <span class="math">\\phi(x,z)</span> 's is  <span class="math">E^2</span> . Assuming that  <span class="math">t,\\eta,\\deg_x f</span>  and  <span class="math">\\deg_z f</span>  are small in comparison to E, using (2) we have</p>

    <p class="text-gray-300"><span class="math">$\\|\\rho\\|_{\\infty} = O\\left(E^{2\\deg_x(f)/(t\\eta)} \\cdot \\|f\\|_{\\infty}^{t-1}\\right).</span>$</p>

    <p class="text-gray-300">Suppose h(z) is a polynomial of degree  <span class="math">\\eta</span>  with  <span class="math">||h||_{\\infty} = H</span> . Let</p>

    <p class="text-gray-300"><span class="math">$\\Gamma = \\operatorname{Res}_z \\left( \\operatorname{Res}_x(\\phi(x), f(x)), h(z) \\right).</span>$</p>

    <p class="text-gray-300">Assuming that H is negligible in comparison to E, using (1) we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} |\\Gamma| &amp;= O\\left(\\left(\\|\\rho\\|_{\\infty}^{\\eta} \\cdot \\|h\\|_{\\infty}^{\\deg(\\rho)}\\right)\\right) \\\\ &amp;= O\\left(E^{2\\deg_x f/t} \\cdot \\|f\\|_{\\infty}^{\\eta(t-1)}\\right). \\end{split}</span>$</p>

    <p class="text-gray-300">Note that in the TNFS set-up described above  <span class="math">N(\\phi, f) = \\Gamma</span> .</p>

    <p class="text-gray-300">Sieving polynomials: Sieving is done using polynomials  <span class="math">\\phi(x) \\in R[x]</span>  of degrees at most t-1 with  <span class="math">\\|\\phi\\|_{\\infty} = E^{2/\\eta t}</span> . Then the number of sieving polynomials is  <span class="math">E^2</span> .</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">3 A New Polynomial Selection Method for exTNFS</h3>

    <p class="text-gray-300">The work [4] provides two methods for selecting polynomials for the classical NFS algorithm. These are called the generalised Joux-Lercier (GJL) and the Conjugation method. The GJL method is based on an earlier method due to Joux and Lercier [16] and uses the LLL algorithm to select polynomials.</p>

    <p class="text-gray-300">The GJL matrix: Given a monic polynomial  <span class="math">\\varphi(x) = \\varphi_0 + \\varphi_1 x + \\dots + \\varphi_{k-1} x^{k-1} + x^k</span>  with integer coefficients and  <span class="math">r \\geq k</span> , define an  <span class="math">(r+1) \\times (r+1)</span>  matrix in the following manner.</p>

    <p class="text-gray-300"><span class="math">$M_{\\varphi,r} = \\begin{bmatrix} p &amp; &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; &amp; \\\\ &amp; &amp; \\ddots &amp; &amp; \\\\ &amp; &amp; p &amp; &amp; \\\\ \\varphi_0 &amp; \\varphi_1 &amp; \\cdots &amp; \\varphi_{n-1} &amp; 1 &amp; &amp; \\\\ &amp; &amp; \\ddots &amp; \\ddots &amp; &amp; \\ddots &amp; \\\\ &amp; &amp; \\varphi_0 &amp; \\varphi_1 &amp; \\cdots &amp; \\varphi_{n-1} &amp; 1 \\end{bmatrix}</span>$
(3)</p>

    <p class="text-gray-300">Apply the LLL algorithm to  <span class="math">M_{\\varphi,r}</span>  and let the first row of the resulting LLL-reduced matrix be  <span class="math">[\\psi_0, \\dots, \\psi_r]</span> . This vector is taken to represent a polynomial  <span class="math">\\psi(x) = \\psi_0 + \\psi_1 x + \\dots + \\psi_r x^r</span>  and we write</p>

    <p class="text-gray-300"><span class="math">$LLL(M_{\\varphi,r}) = \\psi(x) = \\psi_0 + \\psi_1 x + \\dots + \\psi_r x^r</span>$
(4)</p>

    <p class="text-gray-300">to denote the polynomial  <span class="math">\\psi(x)</span> . The determinant of  <span class="math">M_{\\varphi,r}</span>  is  <span class="math">p^k</span>  and so by the LLL-reduced property,  <span class="math">\\|\\varphi\\|_{\\infty} = O(p^{k/(r+1)})</span> . If  <span class="math">Q = p^n</span> , then  <span class="math">\\|\\varphi\\|_{\\infty} = O(Q^{k/(n(r+1))})</span> .</p>

    <p class="text-gray-300">Algorithm  <span class="math">\\mathcal{D}</span>  describes the polynomial selection method for the extended TNFS. It has the condition  <span class="math">\\gcd(\\eta,k)=1</span> , where  <span class="math">k=\\kappa/d</span> . The reason is the following. The polynomial  <span class="math">A_1(x)</span>  has integer entries and we wish to factorise  <span class="math">A_1(x)</span>  over  <span class="math">\\mathbb{F}_p</span>  to obtain a factor  <span class="math">A_2(x)</span>  of degree k. This  <span class="math">A_2(x)</span>  is later used to define the polynomial  <span class="math">\\varphi(x)</span>  which is required to be irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . A necessary condition is that  <span class="math">A_2(x)</span>  must itself be irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . Since  <span class="math">A_2(x)</span>  is a polynomial of degree k with coefficients from  <span class="math">\\mathbb{F}_p</span>  which is required to be irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> , it is necessary that  <span class="math">\\gcd(\\eta,k)=1</span> . This condition, however, does not restrict applicability. One can always choose  <span class="math">d=\\kappa</span>  to obtain k=1 and so  <span class="math">\\gcd(\\eta,k)=1</span> . Other values of d may also be appropriate, eg., if  <span class="math">\\eta=3</span>  and  <span class="math">\\kappa=4</span> , then one can choose d=2.</p>

    <p class="text-gray-300">If  <span class="math">d = \\kappa</span>  and r = 1, then we obtain exactly the polynomial selection method proposed by Jeong and Kim [12] which is essentially the Conjugation method</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Algorithm: D: Polynomial selection for TNFS. Input: p, n = ηκ, d (such that d|κ and gcd(η, d/κ) = 1) and r ≥ d/κ. Output: h(z), f(x), g(x) and ϕ(x). Choose h(z) to be a monic polynomial of degree η with small integer coefficients such that h(z) is irreducible over Fp; let k = κ/d; let R = Z[z]/(h(z)); let Fp&lt;sup&gt;η&lt;/sup&gt; = Fp[z]/(h(z)); repeat randomly choose a monic polynomial A1(x) ∈ Z[x] having the following properties: deg A1(x) = r + 1; A1(x) is irreducible over Z; A1(x) has coefficients of size O(ln(p)); over Fp, A1(x) has a factor A2(x) of degree k such that A2(x) is irreducible over Fp&lt;sup&gt;η&lt;/sup&gt; . randomly choose monic polynomials C0(x) and C1(x) in R such that kCik&lt;sup&gt;∞&lt;/sup&gt; is small for i = 0, 1; deg C0(x) = d and deg C1(x) &lt; d; define f(x) = Res&lt;sup&gt;y&lt;/sup&gt; (A1(y), C0(x) + y C1(x)) ; ϕ(x) = Res&lt;sup&gt;y&lt;/sup&gt; (A2(y), C0(x) + y C1(x)) mod p; ψ(x) = LLL(M&lt;sup&gt;A&lt;/sup&gt;2,r); g(x) = Res&lt;sup&gt;y&lt;/sup&gt; (ψ(y), C0(x) + y C1(x)).</h4>

    <p class="text-gray-300">in the exTNFS setting. Allowing r &gt; 1 (or d &lt; κ) provides a generalisation and leads to lower asymptotic complexity for certain ranges of finite fields.</p>

    <p class="text-gray-300">until f(x) and g(x) are irreducible over Q[z]/(h(z)) (and hence over R) and</p>

    <p class="text-gray-300">The following result states the basic properties of Algorithm D. Bounds on the norms are obtained from the bounds on resultants given in [7] (see Section 2.1).</p>

    <p class="text-gray-300">Proposition 1. The outputs f(x), g(x) and ϕ(x) of Algorithm D satisfy the following.</p>

    <pre><code class="language-text">1. deg(f) = d(r + 1); deg(g) = rd and deg(ϕ) = κ;
2. over Fpn , both f(x) and g(x) have ϕ(x) as a factor;
3. kfk∞ = O(ln(p)) and kgk∞ = O(Qk/(n(r+1))).
</code></pre>

    <p class="text-gray-300">ϕ(x) is irreducible over Fp&lt;sup&gt;η&lt;/sup&gt; = Fp[z]/(h(z)).</p>

    <p class="text-gray-300">return h(z), f(x), g(x) and ϕ(x).</p>

    <p class="text-gray-300">Consequently, if  <span class="math">\\phi</span>  is a sieving polynomial, then</p>

    <p class="text-gray-300"><span class="math">$N(\\phi, f) = E^{2d(r+1)/t} \\times L_Q(2/3, o(1)); \\tag{5}</span>$</p>

    <p class="text-gray-300"><span class="math">$N(\\phi,g) = E^{2dr/t} \\times Q^{\\frac{(t-1)k}{\\kappa(r+1)}} \\times L_Q(2/3,o(1))</span>$</p>

    <p class="text-gray-300"><span class="math">$= E^{2\\kappa r/t} \\times Q^{\\frac{t-1}{d(r+1)}} \\times L_Q(2/3, o(1)); \\tag{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$N(\\phi, f) \\times N(\\phi, g) = E^{(2d(2r+1))/t} \\times Q^{\\frac{t-1}{d(r+1)}} L_Q(2/3, o(1)).</span>$
(7)</p>

    <p class="text-gray-300">We explain the main differences between Algorithm- <span class="math">\\mathcal{D}</span>  and Algorithms- <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{B}</span>  described in [26] and [24] respectively.</p>

    <p class="text-gray-300"><strong>Differences in Algorithm-</strong> <span class="math">\\mathcal{D}</span>  and Algorithm- <span class="math">\\mathcal{B}</span> : Following [21], Algorithm- <span class="math">\\mathcal{B}</span>  requires the condition  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> . On the other hand, Algorithm- <span class="math">\\mathcal{D}</span>  has the condition  <span class="math">\\gcd(\\eta, k) = 1</span> . The two conditions are not equivalent and neither do one follow from the other. Further, in Algorithm- <span class="math">\\mathcal{B}</span> , the polynomials  <span class="math">C_0(x)</span>  and  <span class="math">C_1(x)</span>  are restricted to have integer coefficients, while in Algorithm- <span class="math">\\mathcal{D}</span>  these polynomials have coefficients from R.</p>

    <p class="text-gray-300"><strong>Differences in Algorithm-</strong> <span class="math">\\mathcal{D}</span>  and <strong>Algorithm-</strong> <span class="math">\\mathcal{B}</span> : In Algorithm- <span class="math">\\mathcal{C}</span> , the polynomials  <span class="math">A_1(x)</span>  and  <span class="math">A_2(x)</span>  were allowed to have coefficients from  <span class="math">\\mathbb{F}_{p^{\\eta}}</span>  while the polynomials  <span class="math">C_0(x)</span>  and  <span class="math">C_1(x)</span>  were restricted to have coefficients in  <span class="math">\\mathbb{Z}</span> . On the other hand, Algorithm- <span class="math">\\mathcal{D}</span>  restricts  <span class="math">A_1(x)</span>  and  <span class="math">A_2(x)</span>  to have coefficients in  <span class="math">\\mathbb{Z}</span>  whereas polynomials  <span class="math">C_0(x)</span>  and  <span class="math">C_1(x)</span>  are allowed to have coefficients from  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> .</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">4 Examples</h3>

    <p class="text-gray-300">We provide examples of polynomials obtained using Algorithm- <span class="math">\\mathcal{D}</span> .</p>

    <p class="text-gray-300">Example 1. Let p be a 201-bit prime given below</p>

    <p class="text-gray-300"><span class="math">$p = 1606938044258990275541962092341162602522202993782792835301611</span>$
(8)</p>

    <p class="text-gray-300">and n=18. Let  <span class="math">\\eta=3, \\ \\kappa=6</span> . If we take d=3, we have  <span class="math">k=\\kappa/d=2</span>  and so the condition  <span class="math">\\gcd(\\eta,k)=1</span>  is satisfied. Taking r=k, we get the following polynomials.</p>

    <p class="text-gray-300"><span class="math">$h(z) = z^3 + 15z^2 + 10z + 11</span>$</p>

    <p class="text-gray-300"><span class="math">$f(x) = x^9 + (12z^2 + 18z + 9)x^8 + (8355z^2 + 5364z + 6372)x^7</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (2081986z^2 + 1338976z + 1595132)x^6</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (7693226z^2 + 4947849z + 5894445)x^5</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (15696735z^2 + 10095449z + 12026805)x^4</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (19245585z^2 + 12378042z + 14746018)x^3</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (15661935z^2 + 10073185z + 12000266)x^2</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (7649910z^2 + 4920112z + 5861422)x + 2055692z^2 + 1322108z + 1575062</span>$</p>

    <pre><code class="language-text">g(x) = 1253481697694142518890648051413304251003x
                                                         6
              + (10027853581553140151125184411306434008024z
                                                             2
                          + 15041780372329710226687776616959651012036z
                         + 7520890186164855113343888308479825506018)x
                                                                       5
              + (3497213936566657627704908063443118860298370z
                                                               2
                        + 2251253129058679963927603900338294434801388z
                      + 2666155570995441137680408405356098141883381)x
                                                                       4
              + (8646516750694195095307690258648972723418694z
                                                               2
                        + 5535375177017333363421101795041151572429248z
                      + 6601193205447400271614585729228052887147128)x
                                                                       3
              + (12351989508940569307175287612517657590593879z
                                                                2
                        + 7922902360069561179688603579794225770279937z
                      + 9419737232643924188353628729776346246132532)x
                                                                       2
              + (8675886274993695066405449968208028923767410z
                                                               2
                        + 5583369201254688631192629848776772136387996z
                       + 6609431266413656661000795798507718115383806)x
              + 3516197021894558691515109498105275925273732z
                                                              2
              + 2278474275352837417124015404280116728013428z
              + 2686420920194049198847046634636431608274369
φ(x)
     6 + (8z
           2 + 12z + 6)x
                       5 + (2790z
                                 2 + 1796z + 2127)x
                                                   4 + (6898z
                                                            2 + 4416z
    +1539114311133374769092067983630802456647141242065219672273746)x
                                                                       3
                                                                       2
</code></pre>

    <p class="text-gray-300">= x + (1335643111756528249742385657499722019021955986912500183178940z + 1199995645505297236842597440079001727271832483477353857109144z +1403466844882143756192279766210082164897017738630073346209732)x 2 + (1267819378630912743292491548789361873146894235194927020142876z 2 + 1064348179254066223942809222658281435521708980042207531041015z + 1403466844882143756192279766210082164897017738630073346207490)x + 1335643111756528249742385657499722019021955986912500183171891z 2 + 1199995645505297236842597440079001727271832483477353857104641z + 80450031359825478498910474719960420915595056784930981621164 (9)</p>

    <p class="text-gray-300">Note that we have kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 &lt;sup&gt;143&lt;/sup&gt;. If we take d = 6(i.e., k = 1 and so gcd(η, k) = 1) and r = k, we get the following polynomials.</p>

    <p class="text-gray-300"><span class="math">$h(z) = z^3 + 14z^2 + 11z + 9</span>$</p>

    <p class="text-gray-300"><span class="math">$f(x) = x^{12} + (4z^2 + 16z + 14)x^{11} + (396z^2 + 354z + 279)x^{10}</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (2942z^2 + 2338z + 2018)x^9 + (9119z^2 + 7144z + 6221)x^8</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (15438z^2 + 12050z + 10504)x^7 + (19707z^2 + 15345z + 13383)x^6</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (27596z^2 + 21546z + 18809)x^5 + (32861z^2 + 25651z + 22383)x^4</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (24795z^2 + 19352z + 16890)x^3 + (18601z^2 + 14519z + 12667)x^2</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (16288z^2 + 12733z + 11085)x + 6394z^2 + 4978z + 4349</span>$</p>

    <pre><code class="language-text">g(x) = −856642525227914948330703783790x
                                        6
      + (−1713285050455829896661407567580z
                                            2
                       − 6853140201823319586645630270320z
                     − 5996497676595404638314926486530)x
                                                          5
      + (−5139855151367489689984222702740z
                                            2
                       − 5996497676595404638314926486530z
                     − 5996497676595404638314926486530)x
                                                          4
      + (−5996497676595404638314926486530z
                                            2
                       − 5139855151367489689984222702740z
                     − 5139855151367489689984222702740)x
                                                          3
      + (−3426570100911659793322815135160z
                                            2
                       − 2569927575683744844992111351370z
                     − 1713285050455829896661407567580)x
                                                          2
      + (−6853140201823319586645630270320z
                                            2
                       − 5996497676595404638314926486530z
                      − 2569927575683744844992111351370)x
      − 5139855151367489689984222702740z
                                          2
      − 1713285050455829896661407567580z
      − 6300317563233813341455730238701
</code></pre>

    <p class="text-gray-300"><span class="math">$\\phi(x) = x^6 + (2z^2 + 8z + 7)x^5 + (6z^2 + 7z + 7)x^4 + (7z^2 + 6z + 6)x^3 + (4z^2 + 3z + 2)x^2 + (8z^2 + 7z + 3)x + 6z^2 + 2z + 160925807199202358283751469410514542803176784794567058060684</span>$</p>

    <p class="text-gray-300">We note that kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 . Taking d = κ and r &gt; k, we get the following polynomials which are not obtained by Conjugation method.</p>

    <p class="text-gray-300"><span class="math">$h(z) = z^3 + 19z^2 + 12z + 20</span>$</p>

    <pre><code class="language-text">f(x) = x
        18 + (24z
                 2 + 15z + 6)x
                             17 + (62625z
                                         2 + 37131z + 68196)x
                                                              16
       + (54727718z
                    2 + 32447633z + 59463133)x
                                              15
       + (37282287z
                    2 + 22104906z + 40509642)x
                                              14
       + (149160537z
                     2 + 88436031z + 162067191)x
                                                 13
       + (166343264z
                     2 + 98624459z + 180739748)x
                                                 12
       + (276943888z
                     2 + 164198071z + 300908938)x
                                                  11
       + (290533998z
                     2 + 172256569z + 315676422)x
                                                  10
       + (335619487z
                     2 + 198986295z + 364663865)x
                                                  9
       + (321699136z
                     2 + 190734514z + 349537809)x
                                                  8
       + (283120090z
                     2 + 167859584z + 307621251)x
                                                  7
       + (220526020z
                     2 + 130748936z + 239609783)x
                                                  6
       + (152665575z
                     2 + 90514923z + 165877425)x
                                                 5
       + (95525536z
                    2 + 56636128z + 103791992)x
                                                4
       + (49105732z
                    2 + 29114769z + 53355671)x
                                              3
       + (19530669z
                    2 + 11579565z + 21220837)x
                                              2
       + (5146409z
                  2 + 3051304z + 5591790)x + 611432z
                                                     2 + 362490z + 664458
g(x) = −40473748126610473965x
                               12 + (−647579970025767583440z
                                                              2
                   − 404737481266104739650z − 161894992506441895860)x
                                                                         11
       + (−844970439639246864967305z
                                       2 − 501145949303690888634630z
         − 920373032399122177964100)x
                                       10 + (−383205447262747967500620z
                                                                          2
             − 225438777065220339985050z − 412751283395173613495070)x
                                                                          9
       + (−1491821882198735459875935z
                                        2 − 884351396566438856135250z
        − 1624130564824625099267520)x
                                       8 + (−1377078806259794766185160z
                                                                          2
            − 815303182262441387550960z − 1492752778405647500777130)x
                                                                          7
       + (−1918131871216323582149280z
                                        2 − 1136745689883981771780990z
        − 2084874106187870207374193)x
                                       6 + (−1518498171229716763079704z
                                                                          2
            − 897700170645904285463230z − 1648476546576667549572676)x
                                                                          5
       + (−1319951133032970332398771z
                                        2 − 783968938410128853621580z
         − 1433584247660087988701134)x
                                        4 + (−983242459565381772403466z
                                                                          2
            − 581257193171886544983086z − 1066899652435313121658704)x
                                                                          3
       + (−568162913399041806440200z
                                       2 − 336945997661804696189042z
                                           − 617045593825898731479033)x
                                                                          2
       + (−238220918670913222677520z
                                       2 − 141103137787225140183294z
              − 258781582719231343451740)x − 42680589653396995011301z
                                                                          2
       − 25329003524942129621620z − 45734925053230840890464
φ(x) = x
        6 + (8z
               2 + 5z + 2)x
                          5 + (2z
                                 2 + 5z + 8)x
                                             4 + (7z
                                                   2 + 7z + 3)x
                                                               3
       + (5z
            2 + 4z + 6)x
                        2 + (5z
                              2 + 3z + 5)x + 2z
                                               2 + 5z
       + 767869984178104009596895403201206240913024003192382360193243
</code></pre>

    <p class="text-gray-300">Note that kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 80 .</p>

    <p class="text-gray-300">Example 2. Consider n = 4 and p given in the equation (8). Taking η = κ = d = 2 and r = 1, we get the following set of polynomials.</p>

    <p class="text-gray-300"><span class="math">$h(z) = z^2 + 10z + 4</span>$</p>

    <p class="text-gray-300"><span class="math">$f(x) = x^4 + (12z + 2)x^3 + (-334z - 141)x^2 + (-814z - 334)x - 476z - 189</span>$</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} g(x) &amp;= -715200327398308039994565525361x^2 \\\\ &amp;\\quad + (-4291201964389848239967393152166z \\\\ &amp;\\quad - 715200327398308039994565525361)x \\end{split}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>− 5006402291788156279961958677527z</li>
      <li>− 1095735527680881755438067740325</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\phi(x) = x^2 + (6z + 1)x + 7z + 436504189383491355398355525988746242042734043988487290063285</span>$</p>

    <p class="text-gray-300">Note that we have kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 &lt;sup&gt;101&lt;/sup&gt;. Taking, in addition, r = 2, we get the following.</p>

    <p class="text-gray-300"><span class="math">$h(z) = z^2 + 9z + 12</span>$</p>

    <p class="text-gray-300"><span class="math">$f(x) = x^6 + (6z + 18)x^5 + (-24z - 20)x^4 + (-104z - 168)x^3 + (656z + 1032)x^2 + (2640z + 4272)x + 2400z + 3895</span>$</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} g(x) &amp;= -50949855279956892174x^4 \\\\ &amp;+ (-203799421119827568696z - 611398263359482706088)x^3 \\\\ &amp;+ (203799421119827568696z - 118077227605609660905)x^2 \\\\ &amp;+ (3432235124945676914718z + 5405519267961169095450)x \\\\ &amp;+ 4418877196453423005084z + 7212668194946536537940 \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi(x) = x^2 + (2z + 6)x + 4z + 137087365995105203648510808728833596484775436658713484246590</span>$</p>

    <p class="text-gray-300">Note that kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 72 .</p>

    <p class="text-gray-300">&lt;sup&gt;6&lt;/sup&gt; + (18z</p>

    <p class="text-gray-300">f(x) = x</p>

    <p class="text-gray-300">Example 3. Consider n = 12 and p as above. Take η = 3 and κ = 4 and d = 2, r = k = 2. h(z) = z &lt;sup&gt;3&lt;/sup&gt; + 11z &lt;sup&gt;2&lt;/sup&gt; + 15z + 3</p>

    <p class="text-gray-300"><span class="math">$x^{6} + (18z^{2} + 9z + 3)x^{5} + (10341z^{2} + 15912z + 3239)x^{4} + (1770504z^{2} + 2751672z + 562214)x^{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$+ (4945296z^2 + 7686900z + 1570620)x^2 + (4638000z^2 + 7209540z + 1473100)x + 1452552z^2 + 2257944z + 461359</span>$</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300"><span class="math">$g(x) = -2590185369923851726963189986530447004677x^4 \\\\ + (-31082224439086220723558279838365364056124z^2 \\\\ - 15541112219543110361779139919182682028062z \\\\ - 5180370739847703453926379973060894009354)x^3 \\\\ + (-8943910082347060013203895023489633507149681z^2 \\\\ - 13753884314295652670174538828476673594834870z \\\\ - 2798849538935544762656115377660476093397307)x^2 \\\\ + (-16808638345832811686298471405882039242411904z^2 \\\\ - 26043481542097836103768559511213363723056322z \\\\ - 5313919533131604789537372854581540134938674)x \\\\ - 7919122156254152559360803372109545122360440z^2 \\\\ - 12301715802165309681382520829319061454273924z \\\\ - 2503815420625589839572203514700699220768970</span>$</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\phi(x) \\\\ &amp;= x^4 + (12z^2 + 6z + 2)x^3 + (3453z^2 + 5310z \\\\ &amp;+ 1315331713618185406528953724242137493097570276948578321744414)x^2 \\\\ &amp;+ (1464238104673151337005873976088174548496609686560298589260046z^2 \\\\ &amp;+ 732119052336575668502936988044087274248304843280149294636833z \\\\ &amp;+ 1315331713618185406528953724242137493097570276948578321745385)x \\\\ &amp;+ 1464238104673151337005873976088174548496609686560298589256614z^2 \\\\ &amp;+ 1464238104673151337005873976088174548496609686560298589258306z \\\\ &amp;+ 322228932000664690046916185828988637220258086337079350758475 \\end{split}</span>$</p>

    <p class="text-gray-300">Note that we have kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 &lt;sup&gt;144&lt;/sup&gt;. If we take η = 2, κ = 6 and d = 2. Taking r = k, we get the following polynomials.</p>

    <p class="text-gray-300"><span class="math">$h(z) = z^2 + 8z + 8</span>$</p>

    <p class="text-gray-300"><span class="math">$f(x) = x^8 + (4z + 12)x^7 + (-4z + 32)x^6 + (2z + 118)x^5 + (180z + 482)x^4 + (196z + 672)x^3 + (-446z - 38)x^2 + (-853z - 683)x - 402z - 479</span>$</p>

    <pre><code class="language-text">g(x) = 214663917737897766700082569221192487083470187x
                                                            6
            + (643991753213693300100247707663577461250410561z
                   + 1931975259641079900300743122990732383751231683)x
                                                                      5
            + 6073509755711768401355621385527818450390423402x
                                                               4
            + (340504035839159634206701463890050111189986519z
                  + 16047986349170322571625884237153624429412872647)x
                                                                      3
            + (12147019511423536802711242771055636900780846804z
                  + 49742108153186859242573891728738575241919126521)x
                                                                      2
            + (18153174512080024529042751074527429510031408668z
                   + 62231874886318877199823229687139684905922619888)x
            + 11050039368017364524102069421187191066472460224z
            + 52873044996489967312005407670014308454664366784
φ(x)
 = x
     6 + (3z + 9)x
                5
   + 1330637839946222153453245513400690382027118201408777173688835x
                                                                      4
   + (1054337635633454031364528934460218161532033409034761512076004z
    +1556074862641371818551624711039491882073897233321491700926471)x
                                                                      3
   + (1054337635633454031364528934460218161532033409034761512076059z
    +1166952413861877438683137190060418390120028255410623190154664)x
                                                                      2
</code></pre>

    <p class="text-gray-300">Note that kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 155 .</p>

    <p class="text-gray-300">The norm bounds given by Proposition 1 are the same as those obtained in [25]. Consequently, the calculations for the asymptotic complexity follows almost verbatim from the calculations in [25] and leads to the following result for the classical NFS.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(541504527394046900378336978445684610427996920133780742816963z + 315860038460594384818795094368482067510428549060075044498849)x + 479545464544939099588903417708754059417518495058229028032985z + 461243242085699950300079186153386681206871949929904822860464</li>
    </ul>

    <p class="text-gray-300">Theorem 1. Let n = ηκ; d is a divisor of κ such that k = κ/d is co-prime to η; r ≥ k; t ≥ 2; p = LQ(a, cp) with 1/3 &lt; a ≤ 2/3; and η = cη(ln Q/ln ln Q) 2/3−a . It is possible to ensure that the runtime of the exTNFS algorithm with polynomials chosen by Algorithm D is LQ(1/3, 2cb) where</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{2r+1}{3c_\\theta kt} + \\sqrt{\\left(\\frac{2r+1}{3c_\\theta kt}\\right)^2 + \\frac{(t-1)kc_\\theta}{3(r+1)}}</span>$
and (10)</p>

    <p class="text-gray-300"><span class="math">$c_{\\theta} = c_p c_{\\eta}. \\tag{11}</span>$</p>

    <p class="text-gray-300">The best complexity of LQ(1/3,(48/9)1/&lt;sup&gt;3&lt;/sup&gt; ) is achieved for c&lt;sup&gt;θ&lt;/sup&gt; = 121/&lt;sup&gt;3&lt;/sup&gt; , r = k = 1 and t = 2. The choice of r = k = 1 and t = 2 are not necessarily the best possible choices for other values of cθ.</p>

    <p class="text-gray-300">For the case of multiple NFS we obtain a similar result.</p>

    <p class="text-gray-300">Theorem 2. Let n = ηκ; d is a divisor of κ such that k = κ/d is co-prime to η; r ≥ k; t ≥ 2; p = LQ(a, cp) with 1/3 &lt; a ≤ 2/3; and η = cη(ln Q/ln ln Q) 2/3−a . It is possible to ensure that the runtime of the exTNFS algorithm with polynomials chosen by Algorithm D is LQ(1/3, 2cb) where</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{4r+2}{6kc_\\theta t} + \\sqrt{\\frac{r(3r+2)}{(3kc_\\theta t)^2} + \\frac{(t-1)kc_\\theta}{3(r+1)}}</span>$
and (12)</p>

    <p class="text-gray-300"><span class="math">$c_{\\theta} = c_p c_{\\eta}. \\tag{13}</span>$</p>

    <p class="text-gray-300">From Theorem 2, the entire analysis carried out in Sections 8.1 and 8.2 of [25] apply with the constant c&lt;sup&gt;p&lt;/sup&gt; replaced by cθ. This leads to the new asymptotic complexity results for the medium prime case that has been mentioned in the introduction.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">6 Conclusion</h4>

    <p class="text-gray-300">In this paper, we have presented a new polynomial selection method for the exTNFS algorithm. This method provides a generalisation of the Conjugation method in the setting of exTNFS proposed by Jeong and Kim [12]. For certain ranges of finite fields, the new method provides lower asymptotic complexity than the Conjugation method of Jeong and Kim.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">References</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Leonard M. Adleman. The function field sieve. In Leonard M. Adleman and Ming-Deh A. Huang, editors, ANTS, volume 877 of Lecture Notes in Computer Science, pages 108–121. Springer, 1994.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Leonard M. Adleman and Ming-Deh A. Huang. Function field sieve method for discrete logarithms over finite fields. Inf. Comput., 151(1-2):5–16, 1999.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Razvan Barbulescu. An appendix for a recent paper of kim. IACR Cryptology ePrint Archive, 2015:1076, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and Fran¸cois Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology – EURO-CRYPT 2015, volume 9056 of Lecture Notes in Computer Science, pages 129–155. Springer Berlin Heidelberg, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thom´e. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Phong Q. Nguyen and Elisabeth Oswald, editors, Advances in Cryptology - EUROCRYPT 2014 - 33rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Copenhagen, Denmark, May 11-15, 2014. Proceedings, volume 8441 of Lecture Notes in Computer Science, pages 1–16. Springer, 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung. The tower number field sieve. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part II, volume 9453 of Lecture Notes in Computer Science, pages 31–55. Springer, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Yuval Bistritz and Alexander Lifshitz. Bounds for resultants of univariate and bivariate polynomials. Linear Algebra and its Applications, 432(8):1995 – 2005, 2010. Special issue devoted to the 15th ILAS Conference at Cancun, Mexico, June 16-20, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pierrick Gaudry, Laurent Gr´emy, and Marion Videau. Collecting relations for the number field sieve in gf(p 6 ). Cryptology ePrint Archive, Report 2016/124, 2016. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Daniel M. Gordon. Discrete logarithms in GF(p) using the number field sieve. SIAM J. Discrete Math., 6(1):124–138, 1993.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Robert Granger, Thorsten Kleinjung, and Jens Zumbr¨agel. Discrete logarithms in GF(2&lt;sup&gt;9234&lt;/sup&gt;). NMBRTHRY list, January 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Aurore Guillevic, Franois Morain, and Emmanuel Thom´e. Solving discrete logarithms on a 170-bit mnt curve by pairing reduction. Cryptology ePrint Archive, Report 2016/507, 2016. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Jinhyuck Jeong and Taechan Kim. Extended tower number field sieve with application to finite fields of arbitrary composite extension degree. Cryptology ePrint Archive, Report 2016/526, 2016. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. Faster index calculus for the medium prime case: Application to 1175-bit and 1425-bit finite fields. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT, volume 7881 of Lecture Notes in Computer Science, pages 177–193. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. A new index calculus algorithm with complexity L(1/4 + o(1)) in small characteristic. In Tanja Lange, Kristin E. Lauter, and Petr Lisonek, editors, Selected Areas in Cryptography - SAC 2013 - 20th International Conference, Burnaby, BC, Canada, August 14-16, 2013, Revised Selected Papers, volume 8282 of Lecture Notes in Computer Science, pages 355–379. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux and Reynald Lercier. The function field sieve is quite special. In Claus Fieker and David R. Kohel, editors, ANTS, volume 2369 of Lecture Notes in Computer Science, pages 431–445. Springer, 2002.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux and Reynald Lercier. Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the gaussian integer method. Math. Comput., 72(242):953–967, 2003.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux and Reynald Lercier. The function field sieve in the medium prime case. In Serge Vaudenay, editor, EUROCRYPT, volume 4004 of Lecture Notes in Computer Science, pages 254–270. Springer, 2006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux, Reynald Lercier, Nigel P. Smart, and Frederik Vercauteren. The number field sieve in the medium prime case. In Cynthia Dwork, editor, Advances in Cryptology - CRYPTO 2006, 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006, Proceedings, volume 4117 of Lecture Notes in Computer Science, pages 326–344. Springer Berlin Heidelberg, 2006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux and C´ecile Pierrot. The special number field sieve in Fp&lt;sup&gt;n&lt;/sup&gt; Application to pairing-friendly constructions. In Zhenfu Cao and Fangguo Zhang, editors, Pairing-Based Cryptography - Pairing 2013 - 6th International Conference,</li>
    </ol></li>
      <li><p class="text-gray-300">Beijing, China, November 22-24, 2013, Revised Selected Papers, volume 8365 of Lecture Notes in Computer Science, pages 45–61. Springer, 2013.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Taechan Kim. Extended tower number field sieve: A new complexity for medium prime case. IACR Cryptology ePrint Archive, 2015:1027, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Taechan Kim and Razvan Barbulescu. Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, Report 2015/1027, 2015. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C´ecile Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 156–170. Springer Berlin Heidelberg, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Palash Sarkar and Shashank Singh. Fine tuning the function field sieve algorithm for the medium prime case. IEEE Transactions on Information Theory, 62(4):2233–2253, April 2016. http://ieeexplore.ieee.org/xpl/ articleDetails.jsp?reload=true&amp;arnumber=7405328.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Palash Sarkar and Shashank Singh. A general polynomial selection method and new asymptotic complexities for the tower number field sieve algorithm. Cryptology ePrint Archive, Report 2016/485, 2016. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Palash Sarkar and Shashank Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In Marc Fischlin and Jean-S´ebastien Coron, editors, Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part I, volume 9665 of Lecture Notes in Computer Science, pages 429–458. Springer, 2016.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Palash Sarkar and Shashank Singh. Tower number field sieve variant of a recent polynomial selection method. Cryptology ePrint Archive, Report 2016/401, 2016. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Oliver Schirokauer. Using number fields to compute logarithms in finite fields. Math. Comp., 69(231):1267–1283, 2000.</li>
    </ol></li>
    </ul>

`;
---

<BaseLayout title="A Generalisation of the Conjugation Method for Polynomial Se... (2016/537)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/537
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-generalisation-of-the-conjugation-method-for-polynomial-2016" />
  </article>
</BaseLayout>
