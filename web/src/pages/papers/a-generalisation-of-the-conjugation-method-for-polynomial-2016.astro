---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/537';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Generalisation of the Conjugation Method for Polynomial Selection for the Extended Tower Number Field Sieve Algorithm';
const AUTHORS_HTML = 'Palash Sarkar, Shashank Singh';

const CONTENT = `    <p class="text-gray-300">Palash Sarkar and Shashank Singh</p>

    <p class="text-gray-300">Applied Statistics Unit Indian Statistical Institute palash@isical.ac.in, sha2nk.singh@gmail.com</p>

    <p class="text-gray-300">Abstract. In a recent work, Kim and Barbulescu showed how to combine previous polynomial selection methods with the extended tower number field sieve algorithm to obtain improved complexity for the discrete logarithm problem on finite fields <span class="math">\\mathbb{F}_{p^n}</span> for the medium prime case and where <span class="math">n</span> is composite and not a prime-power. A follow up work by Sarkar and Singh presented a general polynomial selection method and showed how to lower the complexity in the medium prime case even when <span class="math">n</span> is composite and a prime-power. This complexity, though, was higher than what was reported for the case of <span class="math">n</span> composite and not a prime-power. By suitably combining the Conjugation method of polynomial selection proposed earlier by Barbulescu et al. with the extended tower number field sieve algorithm, Jeong and Kim showed that the same asymptotic complexity is achieved for any composite <span class="math">n</span>. The present work generalises the polynomial selection method of Jeong and Kim for all composite <span class="math">n</span>. Though the best complexity that can be achieved is not lowered, there is a significant range of finite fields for which the new algorithm achieves complexity which is lower than all previously proposed methods.</p>

    <p class="text-gray-300">Keywords: finite fields, discrete logarithm, tower number field sieve.</p>

    <p class="text-gray-300">One of the important problems in cryptography is to compute discrete logarithms over the multiplicative group of a finite field. There are two known general approaches to this problem which lead to sub-exponential run-time. These are the function field sieve (FFS) [1, 2, 15, 17] and the number field sieve (NFS) [9, 16, 18] algorithms.</p>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime, <span class="math">n \\geq 1</span> be an integer and <span class="math">Q = p^n</span>. Suppose that <span class="math">p = L_{Q}(a, c_p)</span> where</p>

    <div class="my-4 text-center"><span class="math-block">L _ {Q} (a, c _ {p}) = \\exp \\left((c _ {p} + o (1)) (\\ln Q) ^ {a} (\\ln \\ln Q) ^ {1 - a}\\right).</span></div>

    <p class="text-gray-300">Depending on the value of <span class="math">a</span>, fields <span class="math">\\mathbb{F}_Q</span> are classified into the following types: small characteristic, if <span class="math">a \\leq 1/3</span>; medium characteristic, if <span class="math">1/3 &amp;lt; a &amp;lt; 2/3</span>; boundary, if <span class="math">a = 2/3</span>; and large characteristic, if <span class="math">a &amp;gt; 2/3</span>.</p>

    <p class="text-gray-300">There has been tremendous progress in the FFS algorithm leading to a quasi-polynomial time algorithm <em>[5]</em> for the small characteristic case. Using algorithms given in <em>[14, 5]</em>, a record computation of discrete log in the binary extension field <span class="math">\\mathbb{F}_{2^{9234}}</span> was reported by Granger et al <em>[10]</em>. The FFS algorithm also applies to the medium prime case and this has been reported in <em>[17, 13, 23]</em>.</p>

    <p class="text-gray-300">The NFS algorithm is generally considered to be the state-of-the-art for medium to large characteristic finite fields. The application of NFS to compute discrete logarithms over finite fields was first proposed by Gordon <em>[9]</em> for prime order fields, i.e., for <span class="math">n=1</span>. Application to composite order fields, i.e., for <span class="math">n&gt;1</span>, was shown by Schirokauer <em>[27]</em>. Important improvements to the NFS for prime order fields were given by Joux and Lercier <em>[16]</em>. Joux, Lercier, Smart and Vercauteren <em>[18]</em> showed that the NFS algorithm is applicable to all finite fields. When the prime <span class="math">p</span> is of a special form, Joux and Pierrot <em>[19]</em> showed the application of the special number field sieve algorithm to obtain improved complexity.</p>

    <p class="text-gray-300">The basic structure of the NFS algorithm is to construct two polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> over the integers which have a common factor <span class="math">\\varphi(x)</span> of degree <span class="math">n</span> modulo <span class="math">p</span>. The polynomial <span class="math">\\varphi(x)</span> defines the field <span class="math">\\mathbb{F}_{p^{n}}</span> while the polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> define two number fields. The efficiency of the NFS algorithm is crucially dependent on the properties of the polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> used to construct the number fields. Consequently, polynomial selection is an important step in the NFS algorithm and is an active area of research.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Sequence of recent works on NFS:</h4>

    <p class="text-gray-300">Starting with the work of Barbulescu et al. <em>[4]</em>, there have been several recent works which continuously improve polynomial selection algorithms.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Barbulescu et al. <em>[4]</em> introduced two new methods for polynomial selection, namely, the generalised Joux-Lercier (GJL) and the Conjugation method. For the boundary case, the best complexity obtained was <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span>. The best complexities for the medium and the large prime cases were respectively <span class="math">L_{Q}(1/3,(96/9)^{1/3})</span> and <span class="math">L_{Q}(1/3,(64/9)^{1/3})</span>.</li>

      <li>Pierrot <em>[22]</em> worked out the asymptotic complexity of the multiple NFS (MNFS) for the GJL and the Conjugation methods and in all cases obtained lower values of the second term in the corresponding sub-exponential expressions.</li>

      <li>Barbulescu et al. <em>[6]</em> provided a detailed analysis of the tower number field sieve (TNFS) variant which had earlier been proposed by Schirokauer <em>[27]</em>.</li>

      <li>Sarkar and Singh <em>[25]</em> provided a method (called Algorithm-<span class="math">\\mathcal{A}</span>) for polynomial selection which both generalised and subsumed the GJL and the Conjugation methods. Asymptotic complexity for NFS and MNFS were worked out. The best reported complexities in <em>[4]</em> and <em>[22]</em> are obtained for one particular value of <span class="math">c_{p}</span>. While the new method of <em>[25]</em> could not lower these complexities, it was shown that there are significant ranges for the values of <span class="math">c_{p}</span>, where in comparison to <em>[4, 22]</em>, lower asymptotic complexities are obtained.</li>

      <li>Gaudry et al. <em>[8]</em> discussed practical issues in relation collection and the consequences of polynomial selection to this phase.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Kim and Barbulescu <em>[21]</em> (which is a merge of <em>[20]</em> and <em>[3]</em>) combined previous polynomial selection methods with the extended TNFS (exTNFS) algorithm to obtain improved complexities for the medium prime case when the extension degree <span class="math">n</span> is composite and not a prime-power. The complexity they achieved is <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span> using classical NFS. An improvement of the second term of the sub-exponential expression was obtained using MNFS. The paper also reported improved complexities for special number field sieve algorithm.</li>

      <li>Sarkar and Singh <em>[26]</em> provided an extension of Algorithm-<span class="math">\\mathcal{A}</span> to provide a general method (called Algorithm-<span class="math">\\mathcal{B}</span>) for polynomial selection for the case considered in <em>[21]</em>, i.e., for composite <span class="math">n</span> which is not a prime power. It was shown that in this setting, the GJL and the Conjugation method are special cases of Algorithm-<span class="math">\\mathcal{B}</span>.</li>

      <li>Sarkar and Singh <em>[24]</em> provided an extension of Algorithm-<span class="math">\\mathcal{B}</span> called Algorithm-<span class="math">\\mathcal{C}</span> which covered all composite <span class="math">n</span>. When <span class="math">n</span> is composite and a power of <span class="math">2</span>, the best complexity in the medium prime case using NFS was obtained to be <span class="math">L_{Q}(1/3,(64/9)^{1/3})</span>. Progressively higher best complexities were reported for other prime-power values of <span class="math">n</span>.</li>

      <li>Guillevic et al. <em>[11]</em> reported a computation of discrete logarithm on an 170-bit MNT curve. They used the Conjugation method for selecting polynomials.</li>

      <li>Jeong and Kim <em>[12]</em> showed how to combine the Conjugation method with exTNFS to cover all composite extension degrees. In particular, they showed that using classical NFS, the best complexity obtained for composite <span class="math">n</span> (irrespective of whether it is a prime-power or not) in the medium prime case is <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span>.</li>

    </ol>

    <p class="text-gray-300">The present paper provides a new general polynomial selection method, called Algorithm-<span class="math">\\mathcal{D}</span>. This algorithm works for all composite values of <span class="math">n</span> and has the Conjugation method as a special case in the exTNFS setting. The best complexity achieved for the medium prime case is <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span> for all composite <span class="math">n</span>. This complexity is the same as that reported by Jeong and Kim <em>[12]</em>. On the other hand, for the medium prime case, there is a significant range of finite fields for which lower complexity is achieved. Suppose that <span class="math">n=\\eta\\kappa</span> and that <span class="math">\\eta</span> can be written as <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln\\ln Q)^{2/3-a}</span> and let <span class="math">c_{\\theta}=c_{p}c_{\\eta}</span>. For <span class="math">c_{\\theta}\\in[3.39,20.91]</span>, the complexity of exTNFS-<span class="math">\\mathcal{D}</span> is lower than the complexities of all previous algorithms whether classical or MTNFS. For <span class="math">c_{\\theta}\\in(0,1.12)\\cup[1.45,3.15]</span>, the complexity of MexTNFS-<span class="math">\\mathcal{D}</span> is the same as that of MexTNFS-Conj and for <span class="math">c_{\\theta}\\notin(0,1.12)\\cup[1.45,3.15]</span>, the complexity of MexTNFS-<span class="math">\\mathcal{D}</span> is lower than that of all previous methods.</p>

    <p class="text-gray-300">We note that Algorithm-<span class="math">\\mathcal{D}</span> does not subsume ether Algorithm-<span class="math">\\mathcal{B}</span> or Algorithm-<span class="math">\\mathcal{C}</span>. Though the asymptotic complexity obtained by Algorithm-<span class="math">\\mathcal{D}</span> is lower than that of Algorithm-<span class="math">\\mathcal{C}</span>, there are certain trade-offs in the norm bound that are achieved using Algorithm-<span class="math">\\mathcal{C}</span> but, not using Algorithm-<span class="math">\\mathcal{D}</span>.</p>

    <p class="text-gray-300">There is a mis-conception appearing in several works that the Sarkar-Singh method from <em>[25]</em> (i.e., Algorithm-<span class="math">\\mathcal{A}</span>) is applicable only when <span class="math">n</span> is composite. We</p>

    <p class="text-gray-300">have noted that such comments appear in <em>[21, 11]</em>. By extension, there may be a mis-conception that for composite <span class="math">n=\\eta\\kappa</span>, Algorithms-<span class="math">\\mathcal{B}</span>, <span class="math">\\mathcal{C}</span> (from <em>[26]</em> and <em>[24]</em>) and <span class="math">\\mathcal{D}</span> appearing here are applicable only when <span class="math">\\kappa</span> is prime. We would like to clear this confusion.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm-<span class="math">\\mathcal{A}</span> from <em>[25]</em> applies for all values of <span class="math">n</span>. The algorithm has two parameters, namely a divisor <span class="math">d</span> of <span class="math">n</span> and a positive integer <span class="math">r</span> such that <span class="math">r\\geq n/d</span>. For <span class="math">d=1</span>, Algorithm-<span class="math">\\mathcal{A}</span> reduces to the GJL method. For <span class="math">d=n</span>, Algorithm-<span class="math">\\mathcal{A}</span> provides a generalisation of the Conugation method; the conjugation method is obtained by choosing <span class="math">r=1</span>; for certain ranges of <span class="math">c_{p}</span>, it is possible to choose <span class="math">r&gt;1</span> to obtain asymptotic complexity which is lower than the Conjugation method. The cases of <span class="math">d=1</span> and <span class="math">d=n</span> apply irrespective of whether <span class="math">n</span> is prime or composite. If further, <span class="math">n</span> is composite, then it is possible to choose <span class="math">1&lt;d&lt;n</span> to obtain new trade-offs on the norm bounds. We note that the work <em>[8]</em> correctly describes this set-up.</li>

      <li>For Algorithms-<span class="math">\\mathcal{B}</span> and <span class="math">\\mathcal{C}</span> the above statements apply with <span class="math">n</span> replaced by <span class="math">\\kappa</span>. For Algorithm-<span class="math">\\mathcal{B}</span>, the condition <span class="math">\\gcd(\\eta,\\kappa)=1</span> is required while no such condition is required for Algorithm-<span class="math">\\mathcal{C}</span>.</li>

      <li>Algorithm-<span class="math">\\mathcal{D}</span> has the parameters <span class="math">r</span> and <span class="math">d</span> with the condition that <span class="math">\\gcd(\\eta,\\kappa/d)=1</span>. By suitably choosing <span class="math">d</span> (for example choosing <span class="math">d=\\kappa</span>), Algorithm-<span class="math">\\mathcal{D}</span> can be made to work for all composite <span class="math">n</span>. Choosing <span class="math">d=\\kappa</span> and <span class="math">r=1</span> provides the Conjugation method in the exTNFS setting. Choosing <span class="math">r&gt;1</span> (or <span class="math">d&lt;\\kappa</span>, if appropriate) provides a generalisation of the Conjugation method.</li>

    </ol>

    <h2 id="sec-4" class="text-2xl font-bold">2 The Set-Up of the Tower Number Field Sieve Algorithm</h2>

    <p class="text-gray-300">The target is to compute discrete logarithm in the field <span class="math">\\mathbb{F}_{p^{n}}</span> where <span class="math">n</span> is composite. Suppose that <span class="math">n=\\eta\\kappa</span> is a non-trivial factorisation of <span class="math">n</span>.</p>

    <p class="text-gray-300">Let <span class="math">h(z)</span> be a monic polynomial of degree <span class="math">\\eta</span> which is irreducible over both <span class="math">\\mathbb{Z}</span> and <span class="math">\\mathbb{F}_{p}</span>. Let <span class="math">R=\\mathbb{Z}[z]/(h(z))</span>. Also, note that <span class="math">\\mathbb{F}_{p^{n}}=\\mathbb{F}_{p}[z]/(h(z))</span>.</p>

    <p class="text-gray-300">Let <span class="math">f(x)</span> and <span class="math">g(x)</span> be polynomials in <span class="math">R[x]</span> whose leading coefficients are from <span class="math">\\mathbb{Z}</span>. The other coefficients of <span class="math">f</span> and <span class="math">g</span> are polynomials in <span class="math">z</span> of degrees at most <span class="math">\\eta-1</span>. In particular, <span class="math">f</span> and <span class="math">g</span> can be viewed as bi-variate polynomials in <span class="math">x</span> and <span class="math">z</span> with coefficients in <span class="math">\\mathbb{Z}</span>. The following properties are required.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both <span class="math">f(x)</span> and <span class="math">g(x)</span> are irreducible over <span class="math">R</span>.</li>

      <li>Over <span class="math">\\mathbb{F}_{p^{n}}</span>, <span class="math">f(x)</span> and <span class="math">g(x)</span> have a common factor <span class="math">\\varphi(x)</span> of degree <span class="math">\\kappa</span>.</li>

    </ol>

    <p class="text-gray-300">The field <span class="math">\\mathbb{F}_{p^{n}}</span> is realised as <span class="math">\\mathbb{F}_{p^{n}}[x]/(\\varphi(x))=(R/pR)[x]/(\\varphi(x))</span>.</p>

    <p class="text-gray-300">Let <span class="math">K_{f}</span> and <span class="math">K_{g}</span> be the number fields associated with the polynomials <span class="math">f</span> and <span class="math">g</span> respectively. The above set-up provides two different decompositions of a homomorphism from <span class="math">R[x]</span> to <span class="math">\\mathbb{F}_{p^{n}}</span>. One of these goes through <span class="math">R[x]/(f(x))</span> and the other goes through <span class="math">R[x]/(g(x))</span>.</p>

    <p class="text-gray-300">With this set-up, it is possible to set up a factor base and perform the three main steps (relation collection, linear algebra and descent) of the NFS algorithm. For details we refer to <em>[6, 21]</em>. In this work, we will need only the following facts.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The factor base consists of <span class="math">B</span> elements for some value <span class="math">B</span> which determines the overall complexity of the algorithm.</li>

      <li>A polynomial <span class="math">\\phi(x) \\in R[x]</span> generates a relation if both the norms <span class="math">N(\\phi, f)</span> and <span class="math">N(\\phi, g)</span> are <span class="math">B</span>-smooth, where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} N(\\phi, f) := \\operatorname{Res}_z(\\operatorname{Res}_x(\\phi(x), f(x)), h(z)); \\\\ N(\\phi, g) := \\operatorname{Res}_z(\\operatorname{Res}_x(\\phi(x), g(x)), h(z)). \\end{array}</span></div>

    <h2 id="sec-5" class="text-2xl font-bold">2.1 Bounds on Resultants</h2>

    <p class="text-gray-300">Let <span class="math">f(z, x)</span> be a bivariate polynomial with integer coefficients where <span class="math">f_{i,j}</span> is the coefficient of <span class="math">x^i z^j</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = \\max</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Bounds on resultants of univariate and bivariate polynomials were given in [7]. In the following, we summarise these bounds.</p>

    <p class="text-gray-300"><strong>Univariate polynomials:</strong> Let <span class="math">a(u)</span> and <span class="math">b(u)</span> be two polynomials with integer coefficients. From [7], we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}_u(a(u), b(u))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><strong>Bivariate polynomials:</strong> Let <span class="math">a(u, v)</span> and <span class="math">b(u, v)</span> be two polynomials with integer coefficients. Let <span class="math">c(u) = \\operatorname{Res}_v(a(u, v), b(u, v))</span>. Then</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq (\\deg_v(a) + \\deg_v(b))! (\\max(\\deg_u(a), \\deg_u(b)) + 1)^{\\deg_v(a) + \\deg_v(b) + 1} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg_v(b)} \\times \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg_v(a)}. \\tag{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">The bounds given by (1) and (2) combine to provide bounds on <span class="math">N(\\phi, f)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\phi(x, z)</span> and <span class="math">f(x, z)</span> be two polynomials and</p>

    <div class="my-4 text-center"><span class="math-block">\\rho(z) = \\operatorname{Res}_x(\\phi(x, z), f(x, z)).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further, suppose <span class="math">\\deg_x\\phi \\leq t - 1</span> and <span class="math">\\deg_z\\phi \\leq \\eta - 1</span>. For $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = E^{2/(t\\eta)}<span class="math">, the number of possible </span>\\phi(x,z)<span class="math">&#x27;s is </span>E^2<span class="math">. Assuming that </span>t,\\eta,\\deg_xf<span class="math"> and </span>\\deg_zf<span class="math"> are small in comparison to </span>E$, using (2) we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O\\left(E^{2\\deg_x(f)/(t\\eta)} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{t-1}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose <span class="math">h(z)</span> is a polynomial of degree <span class="math">\\eta</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = H$. Let</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Gamma = \\operatorname{Res}_z\\left(\\operatorname{Res}_x(\\phi(x), f(x)), h(z)\\right).</span></div>

    <p class="text-gray-300">Assuming that <span class="math">H</span> is negligible in comparison to <span class="math">E</span>, using (1) we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O\\left(\\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\eta} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg(\\rho)}\\right)\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Note that in the TNFS set-up described above <span class="math">N(\\phi, f) = \\Gamma</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sieving polynomials: Sieving is done using polynomials <span class="math">\\phi(x) \\in R[x]</span> of degrees at most <span class="math">t - 1</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = E^{2/\\eta t}<span class="math">. Then the number of sieving polynomials is </span>E^2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The work [4] provides two methods for selecting polynomials for the classical NFS algorithm. These are called the generalised Joux-Lercier (GJL) and the Conjugation method. The GJL method is based on an earlier method due to Joux and Lercier [16] and uses the LLL algorithm to select polynomials.</p>

    <p class="text-gray-300">The GJL matrix: Given a monic polynomial <span class="math">\\varphi(x) = \\varphi_0 + \\varphi_1 x + \\ldots + \\varphi_{k-1} x^{k-1} + x^k</span> with integer coefficients and <span class="math">r \\geq k</span>, define an <span class="math">(r+1) \\times (r+1)</span> matrix in the following manner.</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\varphi , r} = \\left[ \\begin{array}{c c c c c c} p &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; p &amp;amp; &amp;amp; \\\\ \\varphi_ {0} &amp;amp; \\varphi_ {1} &amp;amp; \\dots &amp;amp; \\varphi_ {n - 1} &amp;amp; 1 &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; \\varphi_ {0} &amp;amp; \\varphi_ {1} &amp;amp; \\dots &amp;amp; \\varphi_ {n - 1} &amp;amp; 1 \\end{array} \\right] \\tag {3}</span></div>

    <p class="text-gray-300">Apply the LLL algorithm to <span class="math">M_{\\varphi, r}</span> and let the first row of the resulting LLL-reduced matrix be <span class="math">[\\psi_0, \\ldots, \\psi_r]</span>. This vector is taken to represent a polynomial <span class="math">\\psi(x) = \\psi_0 + \\psi_1 x + \\dots + \\psi_r x^r</span> and we write</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {L L L} \\left(M _ {\\varphi , r}\\right) = \\psi (x) = \\psi_ {0} + \\psi_ {1} x + \\dots + \\psi_ {r} x ^ {r} \\tag {4}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">to denote the polynomial <span class="math">\\psi(x)</span>. The determinant of <span class="math">M_{\\varphi, r}</span> is <span class="math">p^k</span> and so by the LLL-reduced property, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(p^{k/(r+1)})<span class="math">. If </span>Q = p^n<span class="math">, then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(Q^{k/(n(r+1))})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm <span class="math">\\mathcal{D}</span> describes the polynomial selection method for the extended TNFS. It has the condition <span class="math">\\gcd(\\eta, k) = 1</span>, where <span class="math">k = \\kappa / d</span>. The reason is the following. The polynomial <span class="math">A_{1}(x)</span> has integer entries and we wish to factorise <span class="math">A_{1}(x)</span> over <span class="math">\\mathbb{F}_{p}</span> to obtain a factor <span class="math">A_{2}(x)</span> of degree <span class="math">k</span>. This <span class="math">A_{2}(x)</span> is later used to define the polynomial <span class="math">\\varphi(x)</span> which is required to be irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>. A necessary condition is that <span class="math">A_{2}(x)</span> must itself be irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>. Since <span class="math">A_{2}(x)</span> is a polynomial of degree <span class="math">k</span> with coefficients from <span class="math">\\mathbb{F}_{p}</span> which is required to be irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>, it is necessary that <span class="math">\\gcd(\\eta, k) = 1</span>. This condition, however, does not restrict applicability. One can always choose <span class="math">d = \\kappa</span> to obtain <span class="math">k = 1</span> and so <span class="math">\\gcd(\\eta, k) = 1</span>. Other values of <span class="math">d</span> may also be appropriate, eg., if <span class="math">\\eta = 3</span> and <span class="math">\\kappa = 4</span>, then one can choose <span class="math">d = 2</span>.</p>

    <p class="text-gray-300">If <span class="math">d = \\kappa</span> and <span class="math">r = 1</span>, then we obtain exactly the polynomial selection method proposed by Jeong and Kim [12] which is essentially the Conjugation method</p>

    <p class="text-gray-300">|  Algorithm: D: Polynomial selection for TNFS.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Output: h(z), f(x), g(x) and φ(x).  |   |</p>

    <p class="text-gray-300">|  Choose h(z) to be a monic polynomial of degree η with small integer coefficients such that h(z) is irreducible over Fp;  |   |</p>

    <p class="text-gray-300">|  let k = κ/d;  |   |</p>

    <p class="text-gray-300">|  let R = Z[z]/(h(z));  |   |</p>

    <p class="text-gray-300">|  let Fpη = Fp[z]/(h(z));  |   |</p>

    <p class="text-gray-300">|  repeat  |   |</p>

    <p class="text-gray-300">|  randomly choose a monic polynomial A1(x) ∈ Z[x] having the following properties:  |   |</p>

    <p class="text-gray-300">|  deg A1(x) = r + 1;  |   |</p>

    <p class="text-gray-300">|  A1(x) is irreducible over Z;  |   |</p>

    <p class="text-gray-300">|  A1(x) has coefficients of size O(ln(p));  |   |</p>

    <p class="text-gray-300">|  over Fp, A1(x) has a factor A2(x) of degree k such that A2(x) is irreducible over Fpη.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">randomly choose monic polynomials C0(x) and C1(x) in R such that</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞ is small for i = 0,1; deg C0(x) = d and deg C1(x) < d;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  define  |   |</p>

    <p class="text-gray-300">|  f(x) = Resy(A1(y), C0(x) + yC1(x));  |   |</p>

    <p class="text-gray-300">|  φ(x) = Resy(A2(y), C0(x) + yC1(x)) mod p;  |   |</p>

    <p class="text-gray-300">|  ψ(x) = LLL(MA2,r);  |   |</p>

    <p class="text-gray-300">|  g(x) = Resy(ψ(y), C0(x) + yC1(x)).  |   |</p>

    <p class="text-gray-300">|  until f(x) and g(x) are irreducible over Q[z]/(h(z)) (and hence over R) and φ(x) is irreducible over Fpη = Fp[z]/(h(z)).  |   |</p>

    <p class="text-gray-300">|  return h(z), f(x), g(x) and φ(x).  |   |</p>

    <p class="text-gray-300">in the exTNFS setting. Allowing  <span class="math">r &amp;gt; 1</span>  (or  <span class="math">d &amp;lt; \\kappa</span> ) provides a generalisation and leads to lower asymptotic complexity for certain ranges of finite fields.</p>

    <p class="text-gray-300">The following result states the basic properties of Algorithm  <span class="math">\\mathcal{D}</span> . Bounds on the norms are obtained from the bounds on resultants given in [7] (see Section 2.1).</p>

    <p class="text-gray-300">Proposition 1. The outputs  <span class="math">f(x)</span> ,  <span class="math">g(x)</span>  and  <span class="math">\\varphi(x)</span>  of Algorithm  <span class="math">\\mathcal{D}</span>  satisfy the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg (f) = d(r + 1)</span> ;  <span class="math">\\deg (g) = rd</span>  and  <span class="math">\\deg (\\varphi) = \\kappa</span> ;</li>

      <li>over  <span class="math">\\mathbb{F}_{p^n}</span> , both  <span class="math">f(x)</span>  and  <span class="math">g(x)</span>  have  <span class="math">\\varphi(x)</span>  as a factor;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(\\ln (p))<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(Q^{k / (n(r + 1))})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently, if <span class="math">\\phi</span> is a sieving polynomial, then</p>

    <p class="text-gray-300"><span class="math">N(\\phi,f)</span> <span class="math">=E^{2d(r+1)/t}\\times L_{Q}(2/3,o(1));</span> (5) <span class="math">N(\\phi,g)</span> <span class="math">=E^{2dr/t}\\times Q^{\\frac{(t-1)k}{\\kappa(r+1)}}\\times L_{Q}(2/3,o(1))</span> <span class="math">=E^{2\\kappa r/t}\\times Q^{\\frac{t-1}{d(r+1)}}\\times L_{Q}(2/3,o(1));</span> (6) <span class="math">N(\\phi,f)\\times N(\\phi,g)</span> <span class="math">=E^{(2d(2r+1))/t}\\times Q^{\\frac{t-1}{d(r+1)}}L_{Q}(2/3,o(1)).</span> (7)</p>

    <p class="text-gray-300">We explain the main differences between Algorithm-<span class="math">\\mathcal{D}</span> and Algorithms-<span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{B}</span> described in <em>[26]</em> and <em>[24]</em> respectively.</p>

    <p class="text-gray-300">Differences in Algorithm-<span class="math">\\mathcal{D}</span> and Algorithm-<span class="math">\\mathcal{B}</span>: Following <em>[21]</em>, Algorithm-<span class="math">\\mathcal{B}</span> requires the condition <span class="math">\\gcd(\\eta,\\kappa)=1</span>. On the other hand, Algorithm-<span class="math">\\mathcal{D}</span> has the condition <span class="math">\\gcd(\\eta,k)=1</span>. The two conditions are not equivalent and neither do one follow from the other. Further, in Algorithm-<span class="math">\\mathcal{B}</span>, the polynomials <span class="math">C_{0}(x)</span> and <span class="math">C_{1}(x)</span> are restricted to have integer coefficients, while in Algorithm-<span class="math">\\mathcal{D}</span> these polynomials have coefficients from <span class="math">R</span>.</p>

    <p class="text-gray-300">Differences in Algorithm-<span class="math">\\mathcal{D}</span> and Algorithm-<span class="math">\\mathcal{B}</span>: In Algorithm-<span class="math">\\mathcal{C}</span>, the polynomials <span class="math">A_{1}(x)</span> and <span class="math">A_{2}(x)</span> were allowed to have coefficients from <span class="math">\\mathbb{F}_{p^{\\eta}}</span> while the polynomials <span class="math">C_{0}(x)</span> and <span class="math">C_{1}(x)</span> were restricted to have coefficients in <span class="math">\\mathbb{Z}</span>. On the other hand, Algorithm-<span class="math">\\mathcal{D}</span> restricts <span class="math">A_{1}(x)</span> and <span class="math">A_{2}(x)</span> to have coefficients in <span class="math">\\mathbb{Z}</span> whereas polynomials <span class="math">C_{0}(x)</span> and <span class="math">C_{1}(x)</span> are allowed to have coefficients from <span class="math">\\mathbb{F}_{p^{\\eta}}</span>.</p>

    <h2 id="sec-7" class="text-2xl font-bold">4 Examples</h2>

    <p class="text-gray-300">We provide examples of polynomials obtained using Algorithm-<span class="math">\\mathcal{D}</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Example 1</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be a 201-bit prime given below</p>

    <p class="text-gray-300"><span class="math">p=1606938044258990275541962092341162602522202993782792835301611</span> (8)</p>

    <p class="text-gray-300">and <span class="math">n=18</span>. Let <span class="math">\\eta=3</span>, <span class="math">\\kappa=6</span>. If we take <span class="math">d=3</span>, we have <span class="math">k=\\kappa/d=2</span> and so the condition <span class="math">\\gcd(\\eta,k)=1</span> is satisfied. Taking <span class="math">r=k</span>, we get the following polynomials.</p>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+15z^{2}+10z+11</span> <span class="math">f(x)</span> <span class="math">=x^{9}+(12z^{2}+18z+9)x^{8}+(8355z^{2}+5364z+6372)x^{7}</span> <span class="math">+(2081986z^{2}+1338976z+1595132)x^{6}</span> <span class="math">+(7693226z^{2}+4947849z+5894445)x^{5}</span> <span class="math">+(15696735z^{2}+10095449z+12026805)x^{4}</span> <span class="math">+(19245585z^{2}+12378042z+14746018)x^{3}</span> <span class="math">+(15661935z^{2}+10073185z+12000266)x^{2}</span> <span class="math">+(7649910z^{2}+4920112z+5861422)x+2055692z^{2}+1322108z+1575062</span></p>

    <p class="text-gray-300"><span class="math">g(x)=1253481697694142518890648051413304251003x^{6}</span> <span class="math">+(10027853581553140151125184411306434008024z^{2}</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~~~{}~{}~{}~{}~</span> (3497213936566657627704908063443118860298370<span class="math">z^{2}</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+2251253129058679963927603900338294434801388z</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+2666155570995441137680408405356098141883381)x^{4}</span> <span class="math">+(8646516750694195095307690258648972723418694z^{2}</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+5535375177017333363421101795041151572429248z</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+6601193205447400271614585729228052887147128)x^{3}</span> <span class="math">+(12351989508940569307175287612517657590593879z^{2}</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+7922902360069561179688603579794225770279937z</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+9419737232643924188353628729776346246132532)x^{2}</span> <span class="math">+(8675886274993695066405449968208028923767410z^{2}</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+5583369201254688631192629848776772136387996z</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+6609431266413656661000795798507718115383806)x</span> <span class="math">+3516197021894558691515109498105275925273732z^{2}</span> <span class="math">+2278474275352837417124015404280116728013428z</span> <span class="math">+2686420920194049198847046634636431608274369</span></p>

    <p class="text-gray-300"><span class="math">\\phi(x)</span> <span class="math">=x^{6}+(8z^{2}+12z+6)x^{5}+(2790z^{2}+1796z+2127)x^{4}+(6898z^{2}+4416z</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+1539114311133374769092067983630802456647141242065219672273746)x^{3}</span> <span class="math">+(1335643111756528249742385657499722019021955986912500183178940z^{2}</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+1199995645505297236842597440079001727271832483477353857109144z</span> <span class="math">+1403466844882143756192279766210082164897017738630073346209732)x^{2}</span> <span class="math">+(1267819378630912743292491548789361873146894235194927020142876z^{2}</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+1064348179254066223942809222658281435521708980042207531041015z</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">+1403466844882143756192279766210082164897017738630073346207490)x</span> <span class="math">+1335643111756528249742385657499722019021955986912500183171891z^{2}</span> <span class="math">+1199995645505297236842597440079001727271832483477353857104641z</span> <span class="math">+80450031359825478498910474719960420915595056784930981621164</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{143}<span class="math">. If we take </span>d=6<span class="math">(i.e., </span>k=1<span class="math"> and so </span>\\gcd(\\eta,k)=1<span class="math">) and </span>r=k$, we get the following polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+14z^{2}+11z+9</span></p>

    <p class="text-gray-300"><span class="math">f(x)=x^{12}+(4z^{2}+16z+14)x^{11}+(396z^{2}+354z+279)x^{10}</span> <span class="math">+(2942z^{2}+2338z+2018)x^{9}+(9119z^{2}+7144z+6221)x^{8}</span> <span class="math">+(15438z^{2}+12050z+10504)x^{7}+(19707z^{2}+15345z+13383)x^{6}</span> <span class="math">+(27596z^{2}+21546z+18809)x^{5}+(32861z^{2}+25651z+22383)x^{4}</span> <span class="math">+(24795z^{2}+19352z+16890)x^{3}+(18601z^{2}+14519z+12667)x^{2}</span> <span class="math">+(16288z^{2}+12733z+11085)x+6394z^{2}+4978z+4349</span></p>

    <p class="text-gray-300"><span class="math">g(x)=-856642525227914948330703783790x^{6}</span> <span class="math">+(-1713285050455829896661407567580z^{2}</span> <span class="math">-6853140201823319586645630270320z</span> <span class="math">-5996497676595404638314926486530)x^{5}</span> <span class="math">+(-5139855151367489689984222702740z^{2}</span> <span class="math">-5996497676595404638314926486530z</span> <span class="math">-5996497676595404638314926486530)x^{4}</span> <span class="math">+(-5996497676595404638314926486530z^{2}</span> <span class="math">-5139855151367489689984222702740z</span> <span class="math">-5139855151367489689984222702740)x^{3}</span> <span class="math">+(-3426570100911659793322815135160z^{2}</span> <span class="math">-2569927575683744844992111351370z</span> <span class="math">-1713285050455829896661407567580)x^{2}</span> <span class="math">+(-6853140201823319586645630270320z^{2}</span> <span class="math">-5996497676595404638314926486530z</span> <span class="math">-2569927575683744844992111351370)x</span> <span class="math">-5139855151367489689984222702740z^{2}</span> <span class="math">-1713285050455829896661407567580z</span> <span class="math">-6300317563233813341455730238701</span></p>

    <p class="text-gray-300"><span class="math">\\phi(x)=x^{6}+(2z^{2}+8z+7)x^{5}+(6z^{2}+7z+7)x^{4}+(7z^{2}+6z+6)x^{3}</span> <span class="math">+(4z^{2}+3z+2)x^{2}+(8z^{2}+7z+3)x+6z^{2}+2z</span> <span class="math">+160925807199202358283751469410514542803176784794567058060684</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{102}<span class="math">. Taking </span>d=\\kappa<span class="math"> and </span>r>k$, we get the following polynomials which are not obtained by Conjugation method.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+19z^{2}+12z+20</span></p>

    <p class="text-gray-300"><span class="math">f(x)=x^{18}+(24z^{2}+15z+6)x^{17}+(62625z^{2}+37131z+68196)x^{16}</span></p>

    <p class="text-gray-300"><span class="math">+(54727718z^{2}+32447633z+59463133)x^{15}</span></p>

    <p class="text-gray-300"><span class="math">+(37282287z^{2}+22104906z+40509642)x^{14}</span></p>

    <p class="text-gray-300"><span class="math">+(149160537z^{2}+88436031z+162067191)x^{13}</span></p>

    <p class="text-gray-300"><span class="math">+(166343264z^{2}+98624459z+180739748)x^{12}</span></p>

    <p class="text-gray-300"><span class="math">+(276943888z^{2}+164198071z+300908938)x^{11}</span></p>

    <p class="text-gray-300"><span class="math">+(290533998z^{2}+172256569z+315676422)x^{10}</span></p>

    <p class="text-gray-300"><span class="math">+(335619487z^{2}+198986295z+364663865)x^{9}</span></p>

    <p class="text-gray-300"><span class="math">+(321699136z^{2}+190734514z+349537809)x^{8}</span></p>

    <p class="text-gray-300"><span class="math">+(283120090z^{2}+167859584z+307621251)x^{7}</span></p>

    <p class="text-gray-300"><span class="math">+(220526020z^{2}+130748936z+239609783)x^{6}</span></p>

    <p class="text-gray-300"><span class="math">+(152665575z^{2}+90514923z+165877425)x^{5}</span></p>

    <p class="text-gray-300"><span class="math">+(95525536z^{2}+56636128z+103791992)x^{4}</span></p>

    <p class="text-gray-300"><span class="math">+(49105732z^{2}+29114769z+53355671)x^{3}</span></p>

    <p class="text-gray-300"><span class="math">+(19530669z^{2}+11579565z+21220837)x^{2}</span></p>

    <p class="text-gray-300"><span class="math">+(5146409z^{2}+3051304z+5591790)x+611432z^{2}+362490z+664458</span></p>

    <p class="text-gray-300"><span class="math">g(x)=-40473748126610473965x^{12}+(-647579970025767583440z^{2}</span> <span class="math">-404737481266104739650z-161894992506441895860)x^{11}</span> <span class="math">+(-844970439639246864967305z^{2}-501145949303690888634630z</span> <span class="math">-920373032399122177964100)x^{10}+(-383205447262747967500620z^{2}</span> <span class="math">-225438777065220339985050z-412751283395173613495070)x^{9}</span> <span class="math">+(-1491821882198735459875935z^{2}-884351396566438856135250z</span> <span class="math">-1624130564824625099267520)x^{8}+(-1377078806259794766185160z^{2}</span> <span class="math">-815303182262441387550960z-1492752778405647500777130)x^{7}</span> <span class="math">+(-1918131871216323582149280z^{2}-1136745689883981771780990z</span> <span class="math">-2084874106187870207374193)x^{6}+(-1518498171229716763079704z^{2}</span> <span class="math">-897700170645904285463230z-1648476546576667549572676)x^{5}</span> <span class="math">+(-1319951133032970332398771z^{2}-783968938410128853621580z</span> <span class="math">-1433584247660087988701134)x^{4}+(-983242459565381772403466z^{2}</span> <span class="math">-581257193171886544983086z-1066899652435313121658704)x^{3}</span> <span class="math">+(-568162913399041806440200z^{2}-336945997661804696189042z</span> <span class="math">-617045593825898731479033)x^{2}</span> <span class="math">+(-238220918670913222677520z^{2}-141103137787225140183294z</span> <span class="math">-258781582719231343451740)x-42680589653396995011301z^{2}</span> <span class="math">-25329003524942129621620z-45734925053230840890464</span></p>

    <p class="text-gray-300"><span class="math">\\phi(x)=x^{6}+(8z^{2}+5z+2)x^{5}+(2z^{2}+5z+8)x^{4}+(7z^{2}+7z+3)x^{3}</span> <span class="math">+(5z^{2}+4z+6)x^{2}+(5z^{2}+3z+5)x+2z^{2}+5z</span> <span class="math">+767869984178104009596895403201206240913024003192382360193243</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{80}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-9" class="text-base font-medium mt-4">Example 2</h6>

    <p class="text-gray-300">Consider <span class="math">n=4</span> and <span class="math">p</span> given in the equation (8). Taking <span class="math">\\eta=\\kappa=d=2</span> and <span class="math">r=1</span>, we get the following set of polynomials.</p>

    <p class="text-gray-300"><span class="math">h(z)=z^{2}+10z+4</span> <span class="math">f(x)=x^{4}+(12z+2)x^{3}+(-334z-141)x^{2}+(-814z-334)x-476z-189</span> <span class="math">g(x)=-715200327398308039994565525361x^{2}</span> <span class="math">+(-4291201964389848239967393152166z</span> <span class="math">-715200327398308039994565525361)x</span> <span class="math">-5006402291788156279961958677527z</span> <span class="math">-1095735527680881755438067740325</span> <span class="math">\\phi(x)=x^{2}+(6z+1)x+7z</span> <span class="math">+436504189383491355398355525988746242042734043988487290063285</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{101}<span class="math">. Taking, in addition, </span>r=2$, we get the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(z)=z^{2}+9z+12</span> <span class="math">f(x)=x^{6}+(6z+18)x^{5}+(-24z-20)x^{4}+(-104z-168)x^{3}</span> <span class="math">+(656z+1032)x^{2}+(2640z+4272)x+2400z+3895</span> <span class="math">g(x)=-50949855279956892174x^{4}</span> <span class="math">+(-203799421119827568696z-611398263359482706088)x^{3}</span> <span class="math">+(203799421119827568696z-118077227605609660905)x^{2}</span> <span class="math">+(3432235124945676914718z+5405519267961169095450)x</span> <span class="math">+4418877196453423005084z+7212668194946536537940</span> <span class="math">\\phi(x)=x^{2}+(2z+6)x+4z</span> <span class="math">+137087365995105203648510808728833596484775436658713484246590</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{72}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-10" class="text-base font-medium mt-4">Example 3</h6>

    <p class="text-gray-300">Consider <span class="math">n=12</span> and <span class="math">p</span> as above. Take <span class="math">\\eta=3</span> and <span class="math">\\kappa=4</span> and <span class="math">d=2</span>, <span class="math">r=k=2</span>.</p>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+11z^{2}+15z+3</span> <span class="math">f(x)=x^{6}+(18z^{2}+9z+3)x^{5}+(10341z^{2}+15912z+3239)x^{4}</span> <span class="math">+(1770504z^{2}+2751672z+562214)x^{3}</span> <span class="math">+(4945296z^{2}+7686900z+1570620)x^{2}</span> <span class="math">+(4638000z^{2}+7209540z+1473100)x+1452552z^{2}+2257944z+461359</span></p>

    <p class="text-gray-300"><span class="math">g(x)=-2590185369923851726963189986530447004677x^{4}</span> <span class="math">+(-31082224439086220723558279838365364056124z^{2}</span> <span class="math">-15541112219543110361779139919182682028062z</span> <span class="math">-5180370739847703453926379973060894009354)x^{3}</span> <span class="math">+(-8943910082347060013203895023489633507149681z^{2}</span> <span class="math">-13753884314295652670174538828476673594834870z</span> <span class="math">-2798849538935544762656115377660476093397307)x^{2}</span> <span class="math">+(-16808638345832811686298471405882039242411904z^{2}</span> <span class="math">-26043481542097836103768559511213363723056322z</span> <span class="math">-5313919533131604789537372854581540134938674)x</span> <span class="math">-7919122156254152559360803372109545122360440z^{2}</span> <span class="math">-12301715802165309681382520829319061454273924z</span> <span class="math">-2503815420625589839572203514700699220768970</span></p>

    <p class="text-gray-300"><span class="math">\\phi(x)</span> <span class="math">=x^{4}+(12z^{2}+6z+2)x^{3}+(3453z^{2}+5310z</span> <span class="math">+1315331713618185406528953724242137493097570276948578321744414)x^{2}</span> <span class="math">+(1464238104673151337005873976088174548496609686560298589260046z^{2}</span> <span class="math">+732119052336575668502936988044087274248304843280149294636833z</span> <span class="math">+1315331713618185406528953724242137493097570276948578321745385)x</span> <span class="math">+1464238104673151337005873976088174548496609686560298589256614z^{2}</span> <span class="math">+1464238104673151337005873976088174548496609686560298589258306z</span> <span class="math">+322228932000664690046916185828988637220258086337079350758475</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{144}<span class="math">. If we take </span>\\eta=2<span class="math">, </span>\\kappa=6<span class="math"> and </span>d=2<span class="math">. Taking </span>r=k$, we get the following polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(z)=z^{2}+8z+8</span> <span class="math">f(x)=x^{8}+(4z+12)x^{7}+(-4z+32)x^{6}+(2z+118)x^{5}+(180z+482)x^{4}</span> <span class="math">+(196z+672)x^{3}+(-446z-38)x^{2}+(-853z-683)x-402z-479</span></p>

    <p class="text-gray-300"><span class="math">g(x)=214663917737897766700082569221192487083470187x^{6}</span> <span class="math">+</span> <span class="math">(643991753213693300100247707663577461250410561z</span> <span class="math">+</span> <span class="math">1931975259641079900300743122990732383751231683)x^{5}</span> <span class="math">+</span> <span class="math">6073509755711768401355621385527818450390423402x^{4}</span> <span class="math">+</span> <span class="math">(340504035839159634206701463890050111189986519z</span> <span class="math">+</span> <span class="math">16047986349170322571625884237153624429412872647)x^{3}</span> <span class="math">+</span> <span class="math">(12147019511423536802711242771055636900780846804z</span> <span class="math">+</span> <span class="math">49742108153186859242573891728738575241919126521)x^{2}</span> <span class="math">+</span> <span class="math">(18153174512080024529042751074527429510031408668z</span> <span class="math">+</span> <span class="math">62231874886318877199823229687139684905922619888)x</span> <span class="math">+</span> <span class="math">11050039368017364524102069421187191066472460224z</span> <span class="math">+</span> <span class="math">52873044996489967312005407670014308454664366784</span></p>

    <p class="text-gray-300"><span class="math">\\phi(x)</span> <span class="math">=x^{6}+(3z+9)x^{5}</span> <span class="math">+</span> <span class="math">1330637839946222153453245513400690382027118201408777173688835x^{4}</span> <span class="math">+</span> <span class="math">(1054337635633454031364528934460218161532033409034761512076004z</span> <span class="math">+</span> <span class="math">1556074862641371818551624711039491882073897233321491700926471)x^{3}</span> <span class="math">+</span> <span class="math">(1054337635633454031364528934460218161532033409034761512076059z</span> <span class="math">+</span> <span class="math">1166952413861877438683137190060418390120028255410623190154664)x^{2}</span> <span class="math">+</span> <span class="math">(541504527394046900378336978445684610427996920133780742816963z</span> <span class="math">+</span> <span class="math">315860038460594384818795094368482067510428549060075044498849)x</span> <span class="math">+</span> <span class="math">479545464544939099588903417708754059417518495058229028032985z</span> <span class="math">+</span> <span class="math">461243242085699950300079186153386681206871949929904822860464</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{155}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-11" class="text-2xl font-bold">5 Asymptotic Run Times for the Medium Prime Case</h2>

    <p class="text-gray-300">The norm bounds given by Proposition 1 are the same as those obtained in <em>[25]</em>. Consequently, the calculations for the asymptotic complexity follows almost verbatim from the calculations in <em>[25]</em> and leads to the following result for the classical NFS.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">n=\\eta\\kappa</span>; <span class="math">d</span> is a divisor of <span class="math">\\kappa</span> such that <span class="math">k=\\kappa/d</span> is co-prime to <span class="math">\\eta</span>; <span class="math">r\\geq k</span>; <span class="math">t\\geq 2</span>; <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3&lt;a\\leq 2/3</span>; and <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln\\ln Q)^{2/3-a}</span>. It is possible to ensure that the runtime of the exTNFS algorithm with polynomials chosen by Algorithm <span class="math">\\mathcal{D}</span> is <span class="math">L_{Q}(1/3,2c_{b})</span> where</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2r+1}{3c_{\\theta}kt}+\\sqrt{\\left(\\frac{2r+1}{3c_{\\theta}kt}\\right)^{2}+\\frac{(t-1)kc_{\\theta}}{3(r+1)}}\\;\\text{ and }</span> (10) <span class="math">c_{\\theta}=c_{p}c_{\\eta}.</span> (11)</p>

    <p class="text-gray-300">The best complexity of <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span> is achieved for <span class="math">c_{\\theta}=12^{1/3}</span>, <span class="math">r=k=1</span> and <span class="math">t=2</span>. The choice of <span class="math">r=k=1</span> and <span class="math">t=2</span> are not necessarily the best possible choices for other values of <span class="math">c_{\\theta}</span>.</p>

    <p class="text-gray-300">For the case of multiple NFS we obtain a similar result.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">n=\\eta\\kappa</span>; <span class="math">d</span> is a divisor of <span class="math">\\kappa</span> such that <span class="math">k=\\kappa/d</span> is co-prime to <span class="math">\\eta</span>; <span class="math">r\\geq k</span>; <span class="math">t\\geq 2</span>; <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3&lt;a\\leq 2/3</span>; and <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln\\ln Q)^{2/3-a}</span>. It is possible to ensure that the runtime of the exTNFS algorithm with polynomials chosen by Algorithm <span class="math">\\mathcal{D}</span> is <span class="math">L_{Q}(1/3,2c_{b})</span> where</p>

    <p class="text-gray-300"><span class="math">c_{b}</span> <span class="math">=\\frac{4r+2}{6kc_{\\theta}t}+\\sqrt{\\frac{r(3r+2)}{(3kc_{\\theta}t)^{2}}+\\frac{(t-1)kc_{\\theta}}{3(r+1)}}\\text{ and}</span> (12) <span class="math">c_{\\theta}</span> <span class="math">=c_{p}c_{\\eta}.</span> (13)</p>

    <p class="text-gray-300">From Theorem 2, the entire analysis carried out in Sections 8.1 and 8.2 of <em>[25]</em> apply with the constant <span class="math">c_{p}</span> replaced by <span class="math">c_{\\theta}</span>. This leads to the new asymptotic complexity results for the medium prime case that has been mentioned in the introduction.</p>

    <h2 id="sec-14" class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">In this paper, we have presented a new polynomial selection method for the exTNFS algorithm. This method provides a generalisation of the Conjugation method in the setting of exTNFS proposed by Jeong and Kim <em>[12]</em>. For certain ranges of finite fields, the new method provides lower asymptotic complexity than the Conjugation method of Jeong and Kim.</p>

    <h2 id="sec-15" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Leonard M. Adleman. The function field sieve. In Leonard M. Adleman and Ming-Deh A. Huang, editors, ANTS, volume 877 of Lecture Notes in Computer Science, pages 108–121. Springer, 1994.</li>

      <li>[2] Leonard M. Adleman and Ming-Deh A. Huang. Function field sieve method for discrete logarithms over finite fields. Inf. Comput., 151(1-2):5–16, 1999.</li>

      <li>[3] Razvan Barbulescu. An appendix for a recent paper of kim. IACR Cryptology ePrint Archive, 2015:1076, 2015.</li>

      <li>[4] Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and François Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology – EUROCRYPT 2015, volume 9056 of Lecture Notes in Computer Science, pages 129–155. Springer Berlin Heidelberg, 2015.</li>

      <li>[5] Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Phong Q. Nguyen and Elisabeth Oswald, editors, Advances in Cryptology - EUROCRYPT 2014 - 33rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Copenhagen, Denmark, May 11-15, 2014. Proceedings, volume 8441 of Lecture Notes in Computer Science, pages 1–16. Springer, 2014.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[6] Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung. The tower number field sieve. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part II, volume 9453 of Lecture Notes in Computer Science, pages 31–55. Springer, 2015.</li>

      <li>[7] Yuval Bistritz and Alexander Lifshitz. Bounds for resultants of univariate and bivariate polynomials. Linear Algebra and its Applications, 432(8):1995 – 2005, 2010. Special issue devoted to the 15th ILAS Conference at Cancun, Mexico, June 16-20, 2008.</li>

      <li>[8] Pierrick Gaudry, Laurent Grémy, and Marion Videau. Collecting relations for the number field sieve in <span class="math">gf(p^{6})</span>. Cryptology ePrint Archive, Report 2016/124, 2016. http://eprint.iacr.org/.</li>

      <li>[9] Daniel M. Gordon. Discrete logarithms in GF(p) using the number field sieve. SIAM J. Discrete Math., 6(1):124–138, 1993.</li>

      <li>[10] Robert Granger, Thorsten Kleinjung, and Jens Zumbrägel. Discrete logarithms in GF(2^{9234}). NMBRTHRY list, January 2014.</li>

      <li>[11] Aurore Guillevic, Franois Morain, and Emmanuel Thomé. Solving discrete logarithms on a 170-bit mnt curve by pairing reduction. Cryptology ePrint Archive, Report 2016/507, 2016. http://eprint.iacr.org/.</li>

      <li>[12] Jinhyuck Jeong and Taechan Kim. Extended tower number field sieve with application to finite fields of arbitrary composite extension degree. Cryptology ePrint Archive, Report 2016/526, 2016. http://eprint.iacr.org/.</li>

      <li>[13] Antoine Joux. Faster index calculus for the medium prime case: Application to 1175-bit and 1425-bit finite fields. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT, volume 7881 of Lecture Notes in Computer Science, pages 177–193. Springer, 2013.</li>

      <li>[14] Antoine Joux. A new index calculus algorithm with complexity <span class="math">L(1/4+o(1))</span> in small characteristic. In Tanja Lange, Kristin E. Lauter, and Petr Lisonek, editors, Selected Areas in Cryptography - SAC 2013 - 20th International Conference, Burnaby, BC, Canada, August 14-16, 2013, Revised Selected Papers, volume 8282 of Lecture Notes in Computer Science, pages 355–379. Springer, 2013.</li>

      <li>[15] Antoine Joux and Reynald Lercier. The function field sieve is quite special. In Claus Fieker and David R. Kohel, editors, ANTS, volume 2369 of Lecture Notes in Computer Science, pages 431–445. Springer, 2002.</li>

      <li>[16] Antoine Joux and Reynald Lercier. Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the gaussian integer method. Math. Comput., 72(242):953–967, 2003.</li>

      <li>[17] Antoine Joux and Reynald Lercier. The function field sieve in the medium prime case. In Serge Vaudenay, editor, EUROCRYPT, volume 4004 of Lecture Notes in Computer Science, pages 254–270. Springer, 2006.</li>

      <li>[18] Antoine Joux, Reynald Lercier, Nigel P. Smart, and Frederik Vercauteren. The number field sieve in the medium prime case. In Cynthia Dwork, editor, Advances in Cryptology - CRYPTO 2006, 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006, Proceedings, volume 4117 of Lecture Notes in Computer Science, pages 326–344. Springer Berlin Heidelberg, 2006.</li>

      <li>[19] Antoine Joux and Cécile Pierrot. The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> - Application to pairing-friendly constructions. In Zhenfu Cao and Fangguo Zhang, editors, Pairing-Based Cryptography - Pairing 2013 - 6th International Conference,</li>

    </ul>

    <p class="text-gray-300">Beijing, China, November 22-24, 2013, Revised Selected Papers, volume 8365 of Lecture Notes in Computer Science, pages 45–61. Springer, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] Taechan Kim. Extended tower number field sieve: A new complexity for medium prime case. IACR Cryptology ePrint Archive, 2015:1027, 2015.</li>

      <li>[21] Taechan Kim and Razvan Barbulescu. Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, Report 2015/1027, 2015. http://eprint.iacr.org/.</li>

      <li>[22] Cécile Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 156–170. Springer Berlin Heidelberg, 2015.</li>

      <li>[23] Palash Sarkar and Shashank Singh. Fine tuning the function field sieve algorithm for the medium prime case. IEEE Transactions on Information Theory, 62(4):2233–2253, April 2016. http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&arnumber=7405328.</li>

      <li>[24] Palash Sarkar and Shashank Singh. A general polynomial selection method and new asymptotic complexities for the tower number field sieve algorithm. Cryptology ePrint Archive, Report 2016/485, 2016. http://eprint.iacr.org/.</li>

      <li>[25] Palash Sarkar and Shashank Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In Marc Fischlin and Jean-Sébastien Coron, editors, Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part I, volume 9665 of Lecture Notes in Computer Science, pages 429–458. Springer, 2016.</li>

      <li>[26] Palash Sarkar and Shashank Singh. Tower number field sieve variant of a recent polynomial selection method. Cryptology ePrint Archive, Report 2016/401, 2016. http://eprint.iacr.org/.</li>

      <li>[27] Oliver Schirokauer. Using number fields to compute logarithms in finite fields. Math. Comp., 69(231):1267–1283, 2000.</li>

    </ul>`;
---

<BaseLayout title="A Generalisation of the Conjugation Method for Polynomial Se... (2016/537)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/537
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
