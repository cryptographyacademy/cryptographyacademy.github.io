---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1019';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Speed-Security Tradeoffs in Blockchain Protocols';
const AUTHORS_HTML = 'Aggelos Kiayias, Giorgos Panagiotakos';

const CONTENT = `    <p class="text-gray-300">Aggelos Kiayias* School of Informatics, University of Edinburgh akiayias@inf.ed.ac.uk</p>

    <p class="text-gray-300">Giorgos Panagiotakos* School of Informatics, University of Edinburgh giorgos.pan@ed.ac.uk</p>

    <p class="text-gray-300">October 13, 2016</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">Transaction processing speed is one of the major considerations in cryptocurrencies that are based on proof of work (POW) such as Bitcoin. At an intuitive level it is widely understood that processing speed is at odds with the security aspects of the underlying POW based consensus mechanism of such protocols, nevertheless the tradeoff between the two properties is still not well understood.</p>

    <p class="text-gray-300">In this work, motivated by recent work [8] in the formal analysis of the Bitcoin backbone protocol, we investigate the tradeoff between provable security and transaction processing speed viewing the latter as a function of the block generation rate. We introduce a new formal property of blockchain protocols, called chain growth, and we show it is fundamental for arguing the security of a robust transaction ledger. We strengthen the results of [8] in the following ways: we show how the properties of persistence and liveness of the ledger reduce in a black-box fashion in the underlying properties of the backbone protocol, namely common prefix, chain quality and chain growth, and we improve the security bounds showing that the robustness of the ledger holds for even the faster (than Bitcoin’s) block generation rates which have been adopted by other “alt-coins.” We also present a theoretical attack against bitcoin which we validate in simulation that works when blockchain rate is highly accelerated. This presents a natural upper bound in the context of the speed-security tradeoff. By combining our positive and negative results we map the speed/security domain for blockchain protocols and list open problems for future work.</p>

    <p class="text-gray-300">*Work performed while at the National and Kapodistrian University of Athens, supported by ERC project CO-DAMODA #25915.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 2  Preliminaries  6 2.1  Model  6 2.2  Backbone Protocols  7 2.3  Security properties  7 3  Bitcoin's Persistence  7 3.1  A better bound for the common prefix property  7 3.2  The strong common-prefix property  10 4  Chain Growth  11 5  Common-prefix Attack  13 6  Conclusion  15 A  Properties summary  16 B  Probability of uniquely successful rounds  17 C  Proofs  17 C.1  Lemma 8  17 C.2  Theorem 9  18</p>

    <p class="text-gray-300">The capability for fast transaction processing is a major consideration in any payment system and a litmus test for its potential to scale at a global level. For “blockchain” based protocols such as bitcoin <em>[14]</em> the current picture is rather grim: some reported current rates for Bitcoin processing speed is 7 transactions per second (tps) while Paypal handles an average of 115 tps and the VISA network has a peak capacity of 47,000 tps (though it currently needs 2000-4000 tps). It goes without saying that improving transaction processing of cryptocurrencies is one of the major considerations in the research of payment systems like Bitcoin, cf. <em>[3]</em>.</p>

    <p class="text-gray-300">Bitcoin relies on the distributed maintenance of a data structure called the blockchain by a set of entities called miners that are anonymous and potentially dynamically changing. The protocol that maintains the blockchain relies on proofs of work (POW) for ensuring that miners converge to a unique view of this data structure. The blockchain can be parsed as a ledger of transactions and assuming that the adversarial parties collectively constitute less than half of the network’s computational power (also referred to as hashing power since the main computational operation is hashing) it is ensured that all parties have the same view of the ledger. The transactions in the blockchain are organized in blocks and each block is associated with a POW. The number of transactions that fit inside each block is bounded (and is currently restricted by a 1MB cap).</p>

    <p class="text-gray-300">Beyond the obvious engineering factors that affect transaction processing speed of blockchain protocols (such as network speed and computational power needed to verify transactions) the two main factors are the size of blocks and the rate that blocks are generated. The current 1MB cap on transactions is heavily debated and proposals for a 20-fold increase have been made. Regarding the block generation rate recall that the original parameter setting for Bitcoin attempts to stabilize it at 1 block per 10 minutes. This is achieved by suitably calibrating the hardness of the POW instances that are solved by the miners. At an intuitive level, the POW difficulty is an intrinsic feature for security as it prohibits the adversary from flooding the network with messages and gives the opportunity to the honest parties to converge to a unified view.</p>

    <p class="text-gray-300">A useful unit of time to measure the block generation rate is a round of full information propagation. Indeed, the effect that the speed of information propagation may have on security is widely understood at least informally and the effect of the former on the latter was predicted by <em>[6]</em>. In <em>[8]</em> a formal relation between the two was proven: it was observed that security can be formally shown if the parameter <span class="math">f</span>, expressing the expected number of POW solutions per complete round of information propagation, is sufficiently small. In that work it was shown that as <span class="math">f</span> gets closer to 0 the maximum adversarial hashing power that the protocol can withstand approximates 50%, Bitcoin’s claimed theoretical limit; on the other hand, as <span class="math">f</span> gets larger the security bound gets worse and it completely vanishes when <span class="math">f=1</span>, i.e., the rate of expected 1 block per round.</p>

    <p class="text-gray-300">In <em>[6]</em> it is argued that for blocks of reasonable sizes (including those currently used), the block size is linearly dependent in the time it takes for a full communication round to be completed. From this one can argue that round duration is linearly related to block size. Furthermore, transaction processing speed is proportional to block size and also proportional to block generation rate per unit of time (say seconds). Given that we measure time in rounds of full communication we can express the following intuitive relation for transaction processing speed (measured in Kb/sec):</p>

    <p class="text-gray-300"><span class="math">\\text{transaction processing speed}\\propto\\frac{\\text{block size}\\times f}{\\text{round duration}}</span></p>

    <p class="text-gray-300">As a result, since scaling the block size is expected to scale the round duration by the same</p>

    <p class="text-gray-300">See https://en.bitcoin.it/wiki/Scalability</p>

    <p class="text-gray-300">See e.g., [5, 18, 16] and http://gavintech.blogspot.gr/2015/01/twenty-megabytes-testing-results.</p>

    <p class="text-gray-300">constant, if we keep the same value of  <span class="math">f</span> , the transaction processing speed will be unaffected. Hence, the dominant factor for improving transaction processing speed, would not be the block-size, but rather the block generation rate (per round) represented by  <span class="math">f</span> . It follows that, given the security critical nature of this parameter, it is important to understand how large it can be selected while maintaining the security of the system.</p>

    <p class="text-gray-300">Interestingly, a number of alternative cryptocurrencies (alt-coins) that are based on Bitcoin have tinkered with the block generation rate of Bitcoin (see Figure 1) to achieve faster processing without however providing any formal arguments about the security implications of such choices.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cryptocurrency</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">block gen. rate (sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f (blocks/round)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1/f</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bitcoin</td>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

            <td class="px-3 py-2 border-b border-gray-700">0.021</td>

            <td class="px-3 py-2 border-b border-gray-700">47.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Litecoin</td>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

            <td class="px-3 py-2 border-b border-gray-700">0.084</td>

            <td class="px-3 py-2 border-b border-gray-700">11.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dogecoin</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">0.21</td>

            <td class="px-3 py-2 border-b border-gray-700">4.76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Flashcoin</td>

            <td class="px-3 py-2 border-b border-gray-700">6 – 60</td>

            <td class="px-3 py-2 border-b border-gray-700">0.21-2.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.476-4.76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fastcoin</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">1.05</td>

            <td class="px-3 py-2 border-b border-gray-700">0.95</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ethereum3</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">1.05</td>

            <td class="px-3 py-2 border-b border-gray-700">0.95</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: A list of the different block generation rates various altcoins have chosen and the corresponding  <span class="math">f, 1/f</span>  values assuming one full communication round takes 12.6 seconds (this is the average block propagation time as measured in [6]). Notice Bitcoin's conservative choice. The value  <span class="math">f</span>  is the expected number of POW's per communication round. The value  <span class="math">1/f</span>  is also given which is roughly the expectation of rounds required to obtain a POW.</p>

    <p class="text-gray-300">Given the above motivation the fundamental question we seek to answer is the following:</p>

    <p class="text-gray-300">For a given block generation rate expressed as the expected number of blocks per round (parameter  <span class="math">f</span> ), what is the maximum adversarial hashing power that can be provably tolerated by a population of honest miners?</p>

    <p class="text-gray-300">The above question may be posed for the core of the Bitcoin transaction ledger protocol (the Bitcoin "backbone" protocol as defined in [8]) but also for other similar protocols that attempt to use POW's to maintain a blockchain distributively notably the GHOST rule suggested by Sompolinsky and Zohar [17].</p>

    <p class="text-gray-300">Our Results. In this work, we investigate speed-security tradeoffs in blockchain protocols as a relationship between block generation rate  <span class="math">f</span>  and the bound on the hashing power of the adversary. Specifically, our results are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We introduce a new property for blockchain protocols, called chain growth that is cast in the model of [8] and complements the two properties suggested there (common prefix and chain quality). In addition, we introduce a strengthened version of the common-prefix property. We argue that chain growth is a fundamental property of backbone protocols independent of the other two. We illustrate this by showing that a backbone protocol satisfying all three properties implements a "robust transaction ledger" in a black-box fashion (something that we observe to be not true if one relies on just common prefix and chain quality — the two properties by themselves are insufficient to imply a robust transaction ledger <span class="math">^4</span> ). Furthermore,</li>

    </ul>

    <p class="text-gray-300">chain growth is a property of interest from an attacker’s point of view as it is fundamentally linked to the transaction processing speed and can constitute an adversarial goal in its own right: it captures the class of adversaries that are interested in slowing down the growth of the chain and thus also the transaction processing time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We substantially improve the level of security for higher rates and in this way we prove security for bounds close to 50% for alternative cryptocurrencies (including e.g., Litecoin) that have opted for much faster block creation rates compared to Bitcoin. See Figures 2 and 3 for graphs showing our improved security analysis.</li>

      <li>We finally present simulation results and an attack against the Bitcoin backbone protocol that presents a natural upper barrier in the speed-security domain. The attack focuses on the common prefix property and shows how the view of two honest parties can be divergent when the block generation rate becomes too high.</li>

      <li>We reformulate the properties of persistence and liveness of <em>[8]</em> to better reflect the separation between “safety” and “liveness” properties in distributed systems, cf. <em>[11]</em>. Specifically, our persistence property is slightly weaker than the corresponding property of <em>[8]</em>, while the liveness property is significantly strengthened in the sense that an existential quantifier is substituted by a universal quantifier.</li>

    </ul>

    <p class="text-gray-300">Ethereum. Ethereum has attracted considerable attention from investors as well as from the media for the past 3 years. As explained in <em>[9]</em>, Ethereum uses a variant of the Bitcoin protocol where tie-breaking between chains of the same length is resolved randomly. In the model we consider, the adversary is rushing which means that any attack against randomized chain selection can be simulated (we can suitably restrict the behavior of our adversary so that tie-breaking is resolved randomly by the honest parties). Moreover, the attack we present in Section 5 is also applicable against Ethereum with insignificant changes. In this way, our work can also contribute in the ongoing dialog regarding the security related choices that are made when designing new alt-cryptocurrencies, from a provable security perspective.</p>

    <p class="text-gray-300">Concurrent and subsequent work. Pass et. al in <em>[15]</em> consider the security of the Bitcoin backbone in a partially synchronous setting. Towards this end, a similar definitional framework to that of <em>[8]</em> is presented suited for partially synchronous executions. The chain growth property we introduce, as well as the liveness black-box reduction we show, proved also helpful in their domain as well. It is worth pointing out that the chain growth property, as defined in <em>[15]</em>, is stronger than our formulation. As we will see, cf. Section 4, the stronger version cannot be satisfied by some well-known, other than bitcoin, blockchain protocols that have been proposed. Moreover, <em>[15]</em> show how to black-box reduce persistence to chain growth and a property called consistency which is more general than the property of common prefix of <em>[8]</em> (in which work, a non-black-box proof for persistence was given). The strong common prefix property we present here is equivalent to the property of consistency of <em>[15]</em>, and directly generalizes the common prefix property of <em>[8]</em>.</p>

    <p class="text-gray-300">Limitations and directions for future research. Our analysis is in the standard cryptographic model where parties fall into two categories, those that are honest (and follow the protocol) and those that are dishonest that may deviate in an arbitrary (and coordinated) fashion as dictated by the adversary. It is an interesting direction for future work to consider speed-security tradeoffs in the rational setting where all parties wish to optimize a certain utility function. Designing suitable incentive mechanisms is a related important consideration, for instance see <em>[12]</em> for a suggestion related to the GHOST protocol. The analysis we provide is in the static setting, i.e., we do not take</p>

    <p class="text-gray-300">into account the fact that parties change dynamically and that the protocol calibrates the difficulty of the POW instances to account for that; we note that this may open the possibility for additional attacks, <em>[1]</em>, and hence it is an important point for consideration and future work. Our notion of round (borrowed from <em>[8]</em>) assumes complete information propagation between all honest parties; in practice information propagation is a random variable that depends on the peer to peer network topology and some parties learn faster than others the messages communicated; depending on the properties of the random variable this can be accounted in our model by including the tail of the distribution as part of the adversary. Finally, the positive and negative results we present between speed and security still have a gray area in which it is unknown whether the protocols are secure or there is an attack that breaks security. While the above four points are limitations (and suggest interesting directions for further research in the area) our model and analysis can be extended to account for such stronger settings and hence our results may serve as the basis for further exploring the tradeoff between transaction processing speed and provable security. Another important aspect is privacy in the transaction ledger (cf. <em>[2, 13]</em>) which our analysis, being at a “lower” level in the blockchain protocol does not interact with directly.</p>

    <p class="text-gray-300">Organization. In section 2 we overview the model that we use for expressing the protocols and the security properties. In section 3 we present our improved analysis for the Bitcoin backbone protocol. In section 4 we introduce the chain growth property as well as a black-box proof for Liveness. Finally, in section 5 we present our attack against the common prefix property for Bitcoin.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 Model</h3>

    <p class="text-gray-300">For our model we adopt the abstraction proposed in <em>[8]</em>. Specifically, in their setting, called the <span class="math">q</span>-bounded setting, synchronous communication is assumed and each party is allowed <span class="math">q</span> queries to a random oracle. The network supports an anonymous message diffusion mechanism that is guaranteed to deliver messages of all honest parties in each round. The adversary is rushing and adaptive. Rushing here means that in any given round he gets to see all honest players’ messages before deciding his own strategy. However, after seeing the messages he is not allowed to query the hashing oracle again in this round. In addition, he has complete control of the order that messages arrive to each player. The model is “flat” in terms of computational power in the sense that all honest parties are assumed to have the same computational power while the adversary has computational power proportional to the number of players that it controls.</p>

    <p class="text-gray-300">The total number of parties is <span class="math">n</span> and the adversary is assumed to control <span class="math">t</span> of them (honest parties don’t know any of these parameters). Obtaining a new block is achieved by finding a hash value that is smaller than a difficulty parameter <span class="math">D</span>. The success probability that a single hashing query produces a solution is <span class="math">p=\\frac{D}{2^{\\kappa}}</span> where <span class="math">\\kappa</span> is the length of the hash. The total hashing power of the honest players is <span class="math">\\alpha=pq(n-t)</span>, the hashing power of the adversary is <span class="math">\\beta=pqt</span> and the total hashing power is <span class="math">f=\\alpha+\\beta</span>. A number of definitions that will be used extensively are listed below.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A round is called:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>successful if at least one honest player computes a solution in this round.</li>

      <li>uniquely successful if exactly one honest player computes a solution in this round.</li>

    </ul>

    <p class="text-gray-300">We will denote by <span class="math">X_{i}</span> (resp. <span class="math">Y_{i}</span>) the random variable which is equal to <span class="math">1</span> if <span class="math">i</span> is a successful round (resp. uniquely successful) and <span class="math">0</span> otherwise.</p>

    <p class="text-gray-300">Definition 2. In an execution blocks are called:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>honest, if mined by an honest party.</li>

      <li>adversarial, if mined by the adversary.</li>

    </ul>

    <p class="text-gray-300">Definition 3. (chain extension) We will say that a chain <span class="math">\\mathcal{C}&#x27;</span> extends another chain <span class="math">\\mathcal{C}</span> if a prefix of <span class="math">\\mathcal{C}&#x27;</span> is a suffix of <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">In [8], a lower bound to the probabilities of two events, that a round is successful or that is uniquely successful (defined bellow), was established and denoted by <span class="math">\\gamma_{\\mathfrak{u}} = \\alpha - \\alpha^2</span>. While this bound is sufficient for the setting of small <span class="math">f</span>, here we will need to use a better lower bound to the probability of those events, denoted by <span class="math">\\gamma</span>, and with value approximately <span class="math">\\alpha e^{-\\alpha}</span> (see Appendix). Observe that <span class="math">\\gamma &amp;gt; \\gamma_{\\mathfrak{u}}</span>.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 Backbone Protocols</h2>

    <p class="text-gray-300">In order to study the properties of the core Bitcoin protocol, the term Backbone Protocol was introduced in [8]. On this level of abstraction we are only interested on properties of the blockchain, independently from the data stored inside the blocks. In the same work the Bitcoin backbone protocol is described in a quite abstract and detailed way. The main idea is that honest players, at every round, receive new chains from the network and pick the longest valid one to mine. Then, if they mine a block, they broadcast their chain at the end of the round. For more details we refer to [8, Subsection 3.1].</p>

    <h2 id="sec-9" class="text-2xl font-bold">2.3 Security properties</h2>

    <p class="text-gray-300">Two crucial security properties of the Bitcoin Backbone protocol were considered in previous works: the common prefix and the chain quality property. The common prefix property ensures that two honest players have the same view of the blockchain, if they prune a small number of blocks from the tail of their respective chains. On the other hand, the chain quality property ensures that honest players chains' do not contain long sequences of adversarial blocks. These two properties were shown to hold for the Bitcoin Backbone protocol.</p>

    <p class="text-gray-300">Also in the same work, the robust public transaction ledger primitive was described. This primitive captures the notion of a book, in which transactions are recorded, and was used to implement Byzantine Agreement in the honest majority setting. The primitive satisfies two properties: persistence and liveness. Persistence ensures that, if a transaction is seen in a block deep enough in the chain, it will stay there. And liveness ensures that if a transaction is given as input to all honest players, it will eventually be inserted in a block, deep enough in the chain, of an honest player. The Bitcoin Backbone was shown to be sufficient to construct this kind of ledger. More details about the security properties and the primitive are given in Appendix A.</p>

    <h2 id="sec-10" class="text-2xl font-bold">3 Bitcoin's Persistence</h2>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 A better bound for the common prefix property</h3>

    <p class="text-gray-300">In this section we present a better security bound than the one in [8] regarding the common prefix and persistence properties of the Bitcoin backbone protocol. The bound of [8] is derived by the observation that the adversary should produce a block for all rounds that are silent and uniquely successful. With this, it is shown that <span class="math">\\gamma_{\\mathfrak{u}} \\geq \\frac{f + \\sqrt{f^2 + 4}}{2}\\beta</span> is sufficient for security; observe that in</p>

    <p class="text-gray-300">general the coefficient  <span class="math">\\frac{f + \\sqrt{f^2 + 4}}{2} &amp;gt; 1</span>  for any  <span class="math">f &amp;gt; 0</span> . Here we show that  <span class="math">\\gamma \\geq \\beta</span>  is sufficient thus we eliminate entirely the dependence on  <span class="math">f</span>  in the coefficient of  <span class="math">\\beta</span>  (also recall  <span class="math">\\gamma \\geq \\gamma_u</span> ). This improvement in the bound has a significant impact in terms of provable security as shown in Figures 2,3.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: The level of provable security comparing the results of [8] and our improved results for Bitcoin. Under the curves the common prefix property provably holds. The respective block-rate values chosen for two altcoins are depicted on the graph.</p>

    <p class="text-gray-300">Our main tool to derive this is a proof that all uniquely successful rounds have to be compensated by the adversary (and not just those that are silent). To show this we have to perform a more delicate analysis that requires some additional terminology. Next we introduce the notion of an  <span class="math">m</span> -Uniform round as well as that of the base of a round.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 4. (m-Uniform rounds) We call a round  <span class="math">m</span> -Uniform if, at that round,  <span class="math">m</span>  is the minimum value such that for all chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  that any two honest parties adopt at this round, it holds that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 5. (base  <span class="math">(r)</span> ) Let base  <span class="math">(r)</span>  denote the length of the shortest chain than an honest party adopts at round  <span class="math">r</span> .</p>

    <p class="text-gray-300">By definition, if some round  <span class="math">r</span>  is  <span class="math">m</span> -uniform, then it follows that on the next round, honest parties will mine chains of size at least  <span class="math">\\text{base}(r) + m</span> . Moreover, it holds that if some round  <span class="math">r</span>  is uniquely successful then  <span class="math">\\text{base}(r + 1)</span>  will be greater or equal to  <span class="math">\\text{base}(r) + Y_r</span> , since the solution mined by the honest party will be known to all parties by round  <span class="math">r + 1</span>  and he is mining a chain of length at least  <span class="math">\\text{base}(r)</span> . More compactly:</p>

    <p class="text-gray-300">Observation 6. For every  <span class="math">m</span> -uniform round  <span class="math">r</span>  it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {b a s e} (r) + \\max  \\left\\{Y _ {r}, m \\right\\} \\leq \\operatorname {b a s e} (r + 1)</span></div>

    <p class="text-gray-300">As it was discussed earlier, uniquely successful rounds are "bad" for the adversary, because they help honest parties consent on a single blockchain in the following round. On the other hand,  <span class="math">m</span> -Uniform rounds are "good", since some honest parties may mine on shorter chains and thus waste their hash queries. Unfortunately for the adversary, this type of rounds does not happen naturally</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: Similar to figure 2 but for larger values of  <span class="math">1/f</span> . Under the curves the common prefix property provably holds. The respective block-rate values chosen for two popular altcoins are depicted on the graph. Bitcoin is in the far right (recall from table 1 that for Bitcoin it holds  <span class="math">1/f \\approx 47</span> ).</p>

    <p class="text-gray-300">in the system and he must mine and broadcast blocks of his own to make a round non-uniform ( <span class="math">m</span> -uniform with  <span class="math">m &amp;gt; 0</span> ). The adversary must still compensate for all uniquely successful rounds independently of uniformity as shown in the next lemma.</p>

    <p class="text-gray-300">Lemma 7. Suppose  <span class="math">\\mathcal{C}_1</span>  is the chain that some honest party  <span class="math">P_1</span>  has adopted at round  <span class="math">r</span>  and there exists chain  <span class="math">\\mathcal{C}_2</span>  of length at least base  <span class="math">(r - 1) + Y_{r - 1}</span>  that has been mined until round  <span class="math">r</span>  and diverges from  <span class="math">\\mathcal{C}_1</span>  at round  <span class="math">s \\leq r</span> . Then, for  <span class="math">t = \\sum_{i=s}^{r-1} Y_i</span> , the adversary must have mined and broadcast blocks  <span class="math">b_1&#x27;, \\ldots, b_t&#x27;</span>  in chains  <span class="math">\\mathcal{C}_1&#x27;, \\ldots, \\mathcal{C}_t&#x27;</span>  until round  <span class="math">r</span>  where for  <span class="math">i \\in \\{1, \\ldots, t\\}</span> ,  <span class="math">\\mathcal{C}_i&#x27;</span>  has a suffix that contains only adversarial blocks, including  <span class="math">b_i&#x27;</span> , and some honest party has adopted this chain at some round in  <span class="math">[s, r - 1]</span> .</p>

    <p class="text-gray-300">Proof. Suppose round  <span class="math">r_i</span>  is  <span class="math">m_i</span> -uniform for  <span class="math">i \\in \\{1,..,t\\}</span> . We prove that the adversary must have broadcast at least  <span class="math">t</span>  blocks in specific positions in the chains, in order for the fork to be maintained.</p>

    <p class="text-gray-300">Claim 1. Let  <span class="math">r</span>  be a uniquely successful round that is  <span class="math">m</span> -uniform, with  <span class="math">s \\leq r</span> , then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">m \\geq 1</span> , there exists a chain  <span class="math">\\mathcal{C}</span>  such that blocks at positions</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {b a s e} (r) + 1, \\dots , \\operatorname {b a s e} (r) + m</span></div>

    <p class="text-gray-300">are mined by the adversary.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">m = 0</span> , at the end of round  <span class="math">r</span>  and onwards and for all pairs of honest parties' chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  that diverge at round  <span class="math">s</span> , there exists an adversarial block in one of the two chains, in position  <span class="math">\\text{base}(r) + 1</span> .</li>

    </ol>

    <p class="text-gray-300">Proof of Claim. The first point follows from the fact that all honest parties mine a chain of size at least  <span class="math">\\mathrm{base}(r)</span> . So for the round to be  <span class="math">m</span> -Uniform a chain of size at least  <span class="math">\\mathrm{base}(r) + m</span>  must exist. But honest parties, at the start of round  <span class="math">r</span> , have mined blocks on chains of at most size  <span class="math">\\mathrm{base}(r)</span> .</p>

    <p class="text-gray-300">Otherwise, no honest party would choose to mine a chain with length <span class="math">\\operatorname{base}(r)</span>. Therefore, blocks at positions <span class="math">\\operatorname{base}(r) + 1,.., \\operatorname{base}(r) + m</span> of the aforementioned chain must have been mined by the adversary.</p>

    <p class="text-gray-300">The second point follows from [8, Lemma 7]. Consider the chains <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span> of two honest parties' at the end of round <span class="math">r</span> and onwards that diverge at round <span class="math">s</span>. For the sake of contradiction, assume that both chains have an honest block at position <span class="math">base(r) + 1</span>. In this case, from [8, Lemma 7] this block must have been produced at round <span class="math">r</span> and thus <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span> do not diverge at round <span class="math">s</span>. This concludes the proof of the claim.</p>

    <p class="text-gray-300">Notice that, for both cases in the previous claim the adversarial blocks belong to the suffix of some chain which has a purely adversarial suffix and has been adopted by some honest player at least at the same round.</p>

    <p class="text-gray-300">It remains to show that the blocks that the adversary must broadcast for every different uniquely successful round must be in distinct positions, and thus different. If <span class="math">m_i \\geq 1</span>, from the previous claim, item 1, the adversary has broadcast a chain where he has mined blocks at positions <span class="math">base(i) + 1,.., base(i) + m</span>. On the other hand, if <span class="math">m_i = 0</span>, then, since <span class="math">\\mathcal{C}_1</span> and <span class="math">\\mathcal{C}_2</span> diverge at round <span class="math">s</span>, and they have size greater or equal than <span class="math">base(i) + 1</span>, the blocks at positions <span class="math">base(i) + 1</span> of the two chains cannot be both mined by honest parties (due to the claim above, item 2). Thus, in at least one of the two chains, the block at position <span class="math">base(i) + 1</span> has been mined by the adversary. Finally, from Observation 6 it holds that <span class="math">base(i) + \\max(\\{Y_{r_i}, m_i\\} \\leq base(i + 1)</span>, and therefore all these blocks are on distinct positions on the chains they belong. Thus the lemma follows.</p>

    <p class="text-gray-300">Given the above core lemma we can now easily prove the improved bound for the common-prefix property following the same proof strategy as in [8]. Namely, it can be shown that the adversary cannot use very old solutions to compensate for recent uniquely successful rounds, and thus by suitably limiting his power he will be unable to produce enough solutions to compensate for every uniquely successful round, as it is required by the core lemma (proof in the Appendix).</p>

    <p class="text-gray-300"><strong>Lemma 8.</strong> Assume <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span>, for some real <span class="math">\\delta \\in (0,1)</span>. Suppose <span class="math">\\mathcal{C}_1</span> is the chain that honest party <span class="math">P_1</span> adopts at round <span class="math">r</span> and <span class="math">\\mathcal{C}_2</span> is the chain that some honest party <span class="math">P_2</span> adopts or has at the same round. Then, for any <span class="math">s \\leq r</span>, the probability that <span class="math">\\mathcal{C}_1</span> and <span class="math">\\mathcal{C}_2</span> diverge at round <span class="math">r - s</span> is at most <span class="math">e^{-\\Omega (\\delta^3 s)}</span>.</p>

    <p class="text-gray-300"><strong>Theorem 9.</strong> Assume <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span>, for some real <span class="math">\\delta \\in (0,1)</span>. Let <span class="math">S</span> be the set of the chains that honest parties have at the beginning or have adopted at a given round of the backbone protocol. Then the probability that <span class="math">S</span> does not satisfy the common-prefix property with parameter <span class="math">k</span> is at most <span class="math">e^{-\\Omega (\\delta^3 k)}</span>.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3.2 The strong common-prefix property</h2>

    <p class="text-gray-300">Unfortunately, the common-prefix property as it was originally described in [8] is not sufficient in order to proof Persistence in a black-box fashion. We will show that a stronger variant of the common prefix holds for the Bitcoin Backbone and is sufficient. The proof of the stronger common prefix property is implicitly given in [8]. Our contribution lies on identifying a version of the common-prefix property that is sufficient for a black-box derivation of the persistence property.</p>

    <p class="text-gray-300"><strong>Definition 10 (Strong Common-Prefix).</strong> The strong common prefix property <span class="math">Q_{\\mathsf{cp}}</span> with parameter <span class="math">k \\in \\mathbb{N}</span> states that the chains <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span> reported by two, not necessarily distinct honest parties <span class="math">P_1, P_2</span>, at rounds <span class="math">r_1, r_2</span> with <span class="math">r_1 \\leq r_2</span> are such that <span class="math">\\mathcal{C}_1^{\\top k} \\preceq \\mathcal{C}_2</span>.</p>

    <p class="text-gray-300">10</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">Assume <span class="math">\\gamma\\geq(1+\\delta)\\beta</span>, for some real <span class="math">\\delta\\in(0,1)</span>. Let <span class="math">S</span> be the set of the chains of the honest parties from a given round and onwards of the backbone protocol. Then the probability that <span class="math">S</span> does not satisfy the strong common-prefix property with parameter <span class="math">k</span> is at most <span class="math">e^{-\\Omega(\\delta^{3}k)}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">C_{1},C_{2}</span> be the chains of some honest players <span class="math">P_{1},P_{2}</span> at rounds <span class="math">r_{1},r_{2}</span>. Let <span class="math">E(r_{2})</span> be the event where player <span class="math">P_{2}</span> has chain <span class="math">C_{2}</span> at round <span class="math">r_{2}</span> such that <span class="math">\\mathcal{C}_{1}^{\\lceil k\\rfloor}\\not\\preceq\\mathcal{C}_{2}</span>. We are going to show that the probability of this event is at most <span class="math">e^{-\\Omega(\\delta^{3}k)}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">r_{1}=r_{2}</span>, the strong common-prefix property collapses to the original common-prefix property (see Theorem 9). Otherwise, w.l.o.g. it holds that <span class="math">r_{1}&lt;r_{2}</span>. <span class="math">\\mathcal{C}_{3}^{\\lceil=&quot;&quot; </span>\\mathcal{c}_{3}^{\\lceil="" <span class="math">c_{3}</span>="" <span class="math">c_{1}</span>.="" <span class="math">c_{1}\\rceil</span>="" <span class="math">e(r_{2})</span>="" <span class="math">e(r_{2})</span>,="" <span class="math">e^{-{\\Omega(\\delta^{3}k)}}</span>.="" <span class="math">r_{2}</span>,="" <span class="math">r_{2}</span>,="" <span class="math">r_{2}</span>,="" <span class="math">r_{2}</span>,="" <span class="math">r_{1}</span>.="" $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=""</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{1}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; a=&quot;&quot; again=&quot;&quot; an=&quot;&quot; analysis=&quot;&quot; and=&quot;&quot; applies.=&quot;&quot; after=&quot;&quot; again=&quot;&quot; applies.=&quot;&quot; as=&quot;&quot; at=&quot;&quot; be=&quot;&quot; before=&quot;&quot; but=&quot;&quot; case,=&quot;&quot; case.=&quot;&quot; chain=&quot;&quot; chains=&quot;&quot; common-prefix=&quot;&quot; common-prefix property=&quot;&quot; dopted=&quot;&quot; does=&quot;&quot; each=&quot;&quot; even=&quot;&quot; events=&quot;&quot; follows=&quot;&quot; for=&quot;&quot; from=&quot;&quot; has=&quot;&quot; if=&quot;&quot; implied=&quot;&quot; implies=&quot;&quot; in=&quot;&quot; is=&quot;&quot; it=&quot;&quot; known=&quot;&quot; l.o.g.=&quot;&quot; make=&quot;&quot; most=&quot;&quot; not=&quot;&quot; of=&quot;&quot; or=&quot;&quot; original=&quot;&quot; other=&quot;&quot; otherwise,=&quot;&quot; or}</span>="" original="" p_{1}$="" previous="" probability="" random="" round="" round.="" second="" same="" second.="" second.="" show="" since="" some="" suppose="" suppose="" suppose.="" that="" the="" theorem="" this="" to="" two="" we="" which="" with=""></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> this implies that </span>\\mathcal{C}_{1}^{\\lceil k\\rfloor}\\not\\preceq\\mathcal{C}_{3}<span class="math">, which happens with probability at most </span>e^{-\\Omega(\\delta^{3}k)}<span class="math"> from Theorem 9, since chains </span>C_{1}<span class="math"> and </span>C_{3}<span class="math"> coexist in the same round. Thus with overwhelming probability it holds that </span>\\mathcal{C}_{1}^{\\lceil k\\rfloor}\\preceq\\mathcal{C}_{3}<span class="math">. Assuming </span>E(r_{2})<span class="math"> in this case implies again that the original common-prefix property does not hold for the two chains at round </span>r_{2}<span class="math">, which happens with probability at most </span>e^{-\\Omega(\\delta^{3}k)}<span class="math">. It follows that the probability of </span>E(r_{2})<span class="math"> in this case is also at most </span>e^{-\\Omega(\\delta^{3}k)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By applying the union bound for all events <span class="math">E(r_{2})</span>, where <span class="math">r_{2}\\geq r_{1}</span>, the theorem follows with probability at most <span class="math">e^{-\\Omega(\\delta^{3}k)}</span>. ∎</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 12 (Black-Box Persistence).</h6>

    <p class="text-gray-300">Let <span class="math">S</span> be the set of the chains of the honest parties from a given round and onwards for some protocol <span class="math">\\Pi</span>, that satisfy the strong common-prefix property property with overwhelming probability on parameter <span class="math">k</span>. Then protocol <span class="math">\\Pi</span> satisfies Persistence with overwhelming probability in <span class="math">k</span>, where <span class="math">k</span> is the depth parameter.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">C_{1}</span> be the chain of some honest player <span class="math">P_{1}</span> at round <span class="math">r_{1}</span>. We show that if a transaction <span class="math">tx</span> is included in <span class="math">C_{1}^{\\lceil k}</span> at round <span class="math">r_{1}</span>, then this transaction will be always included in every honest player’s chain with overwhelming probability. For the sake of contradiction, suppose that persistence does not hold. Then, there exists some player <span class="math">P_{2}</span> that at round <span class="math">r_{2}&amp;gt;r_{1}</span> adopts some chain <span class="math">C_{2}</span> such that <span class="math">C_{2}</span> does not contain <span class="math">tx</span> in exactly the same position. If <span class="math">\\mathcal{C}_{1}^{\\lceil k\\rfloor}\\preceq\\mathcal{C}_{2}</span>, then <span class="math">C_{2}</span> would contain <span class="math">tx</span> in the same position as <span class="math">C_{1}</span>. Thus, from our assumption it follows that <span class="math">\\mathcal{C}_{1}^{\\lceil k\\rfloor}\\not\\preceq\\mathcal{C}_{2}</span> which violates the strong common-prefix property. The probability that the strong common-prefix property is violated is at most <span class="math">e^{-\\Omega(\\delta^{3}k)}</span> and the theorem follows. ∎</p>

    <h2 id="sec-17" class="text-2xl font-bold">4 Chain Growth</h2>

    <p class="text-gray-300">In addition to the two security properties of the Bitcoin backbone protocol mentioned in Section 2.3 we define a new property called <em>chain growth</em>. This property aims at expressing the minimum rate at which the chains of honest parties grow. It is motivated by an attacker that has objective to slow down the overall transaction processing time of the blockchain system. The common prefix and chain quality properties do not explicitly address this issue, and this can be seen from the fact that both properties can hold even if honest parties’ chains do not grow at all.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 13.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Chain Growth Property) The chain growth property <span class="math">Q_{cg}</span> with parameters <span class="math">\\tau\\in\\mathcal{R}</span> (the “chain speed” coefficient) and <span class="math">s\\in\\mathbb{N}</span> states that for any round <span class="math">r&amp;gt;s</span>, where honest party <span class="math">P</span> has chain <span class="math">\\mathcal{C}_{1}</span> at round <span class="math">r</span> and chain <span class="math">\\mathcal{C}_{2}</span> at round <span class="math">r-s</span> in view<span class="math">{}^{H(\\cdot)}_{\\Pi,\\mathcal{A},\\mathcal{Z}}(\\kappa,q,z)</span>, it holds that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\tau\\cdot s<span class="math">.&lt;/r_{2}</span>.></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Bitcoin. For the Bitcoin backbone protocol this property is satisfied with parameter <span class="math">\\tau</span> equal to <span class="math">\\gamma</span> and with overwhelming probability in <span class="math">s</span>. Since all honest parties choose the longest chain they see, and successful rounds happen with rate <span class="math">\\gamma</span>, their chains will grow at least at this rate. The worst the adversary can do is not participate, so this is a tight bound.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 14.</h6>

    <p class="text-gray-300">The Bitcoin protocol satisfies the chain growth property with speed coefficient <span class="math">(1-\\delta)\\gamma</span> and probability at least <span class="math">1-e^{-\\Omega(\\delta^{2}s)}</span>, for <span class="math">\\delta\\in(0,1)</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In Lemma 6 of <em>[8]</em> it was proved that if at some round <span class="math">r</span> an honest party has a chain of length <span class="math">\\ell</span>, then, by round <span class="math">r+s\\geq r</span>, every honest party will have received a chain of length at least <span class="math">\\ell+\\sum_{i=r}^{r+s-1}X_{i}</span>.</p>

    <p class="text-gray-300">Remember that <span class="math">\\gamma</span> is a lower bound on the probability of a round being successful. From the Chernoff bound at least <span class="math">(1-\\delta)\\gamma s</span> such rounds will occur between rounds <span class="math">r</span> and <span class="math">r+s</span> with probability <span class="math">1-e^{-\\Omega(\\delta^{2}s)}</span>. Thus, by the aforementioned lemma, the chain of any honest party will grow by <span class="math">(1-\\delta)\\gamma s</span> blocks with probability <span class="math">1-e^{-\\Omega(\\delta^{2}s)}</span> and the chain growth property holds with parameter <span class="math">\\tau</span> equal to <span class="math">(1-\\delta)\\gamma</span>. ∎</p>

    <p class="text-gray-300">The importance of chain growth as a fundamental property of the backbone protocol that is of the same caliber as common prefix and chain quality can be seen in the fact that the liveness of the ledger essentially depends on it. We elaborate: in <em>[8, Lemma 16]</em> the liveness property was not proved in a black box manner given the chain quality and common prefix properties. Interestingly, by introducing the chain growth property as a prerequisite together with the other two, a simple black box proof can be derived. As expected, the confirmation time parameter <span class="math">u</span> of the liveness property is tightly connected to the chain speed coefficient <span class="math">\\tau</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 15 (Black-Box Liveness).</h6>

    <p class="text-gray-300">Let protocol <span class="math">\\Pi</span> satisfy the chain quality, chain growth and strong common-prefix properties with overwhelming probability on <span class="math">l,s,k</span> and parameters <span class="math">\\mu(&lt;1),\\tau</span>. Further, assume oracle Txgen is unambiguous. Then protocol <span class="math">\\Pi</span> satisfies Liveness with wait time <span class="math">u=\\frac{3}{\\tau}\\cdot\\max(k,\\frac{1}{1-\\mu})</span> rounds and depth parameter <span class="math">k</span> with overwhelming probability in <span class="math">k</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C_{1}</span> be the chain of some honest party <span class="math">P_{1}</span> at round <span class="math">r</span> and <span class="math">C_{2}</span> be his chain at round <span class="math">r+u</span>. Suppose that all three properties hold. We are going to show that <span class="math">tx</span> must be in some block in <span class="math">C_{2}^{\\lceil k}</span>. From the chain growth property, after <span class="math">u</span> rounds the chain of <span class="math">P_{1}</span> has grown by at least <span class="math">\\tau u(\\geq 3k)</span> blocks. Hence, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 3k<span class="math">. Next, observe that from the chain quality property at the last </span>\\frac{\\tau u}{3}<span class="math"> blocks of </span>C_{2}^{\\lceil k}<span class="math"> there exists at least </span>\\frac{\\tau u}{3}(1-\\mu)\\geq 1<span class="math"> honest block. For the sake of contradiction, suppose that this honest block was mined up to round </span>r<span class="math">, and thus it does not contain </span>tx<span class="math">. Notice that this block is at a height in the chain greater than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\frac{\\tau u}{3}\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+k<span class="math">. It follows that some honest party had some chain </span>C_{3}<span class="math"> of length greater than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+k<span class="math"> at some point until round </span>r<span class="math">. This implies that </span>C_{3}^{\\lceil k}\\not\\leq C_{1}<span class="math">, which violates the strong common-prefix property and is a contradiction. Therefore, there exists an honest block in </span>C_{2}^{\\lceil k}<span class="math"> that was mined after round </span>r<span class="math"> and thus contains </span>tx<span class="math">. Finally, due to the union bound, and since </span>s,l<span class="math"> are of order </span>\\Omega(k)<span class="math">, it follows that all three properties hold with overwhelming probability in </span>k$. The lemma follows. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By liveness we are guaranteed that new transactions will be confirmed by at least one honest party after a predetermined amount of rounds, where confirm here means that some party has some transaction at least <span class="math">k</span> blocks deep in its chain. Moreover, by persistence we get that if a transaction is confirmed by some honest party, all other honest parties will see the same transaction in the same position in their chain. Unfortunately, the ledger properties as defined in <em>[8]</em> do not ensure that all parties will eventually confirm a transaction. This is a property that we would expect from a public</p>

    <p class="text-gray-300">transaction ledger. The following stronger definition of liveness provides us with a bound regarding confirmation time by all parties.</p>

    <p class="text-gray-300"><strong>Definition 16. (Strong) Liveness:</strong> Parameterized by <span class="math">u, k \\in \\mathbb{N}</span> (the "wait time" and "depth" parameters, resp.), provided that a transaction is either (i) issued by Txgen, or neutral and is given as input to all honest players continuously for <span class="math">u</span> consecutive rounds, (ii) reported by one honest-party more than <span class="math">k</span> blocks deep from the end of the ledger at least <span class="math">u</span> rounds before the current round, then all honest parties will report this transaction at a block more than <span class="math">k</span> blocks from the end of the ledger.</p>

    <p class="text-gray-300">We next show that strong Liveness can be also derived in a black-box fashion from the three backbone-level properties.</p>

    <p class="text-gray-300"><strong>Theorem 17 (Black-Box (Strong) Liveness).</strong> Let protocol <span class="math">\\Pi</span> satisfy the chain quality, chain growth and strong common-prefix properties with overwhelming probability on <span class="math">l, s, k</span> and parameters <span class="math">\\mu (&amp;lt; 1), \\tau</span>. Further, assume oracle Txgen is unambiguous. Then protocol <span class="math">\\Pi</span> satisfies Strong Liveness with wait time <span class="math">u = \\frac{3}{\\tau} \\cdot \\max(k, \\frac{1}{1 - \\mu})</span> rounds and depth parameter <span class="math">k</span> with overwhelming probability in <span class="math">k</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Let <span class="math">P_{1}</span> be some honest player that has chain <span class="math">C_{1}</span> at round <span class="math">r_{1}</span> and <span class="math">P_{2}</span> be some honest player that has chain <span class="math">C_{2}</span> at round <span class="math">r_{2} \\geq r_{1} + u</span>. We only have to show that if a transaction is in some block in <span class="math">C_{1}^{[k]}</span> then it will also be at the same block in <span class="math">C_{2}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. All other properties of strong liveness follow from the black-box derivation of the &quot;old&quot; liveness property. Assume the common-prefix property and the chain growth property hold. From the Persistence property proof we have that if a transaction </span>tx<span class="math"> is included in </span>C_{1}^{[k]}<span class="math"> at round </span>r_{1}<span class="math">, then this transaction will be always included in every honest party&#x27;s chain. Now, let </span>C_{2}'<span class="math"> be the chain that </span>P_{2}<span class="math"> has at round </span>r_{1}<span class="math">. We are going to show that </span>P_{2}<span class="math"> will have confirmed transaction </span>tx<span class="math"> at round </span>r_{2}<span class="math">. Since, </span>P_{2}<span class="math"> has </span>tx<span class="math"> at exactly the same position as </span>P_{1}<span class="math"> at round </span>r_{1}<span class="math">, it follows that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{2}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- k<span class="math">. Moreover, from the chain growth property it holds that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{2}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\tau \\cdot u \\geq k<span class="math">. Therefore, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>P_{2}<span class="math"> will have confirmed </span>tx<span class="math"> at round </span>r_{2}<span class="math">. Since </span>s<span class="math"> is of order </span>\\Omega(k)<span class="math">, by the union bound we get that both common-prefix and chain growth hold with overwhelming probability on </span>k$ and thus the lemma follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In a subsequent work, Pass et al. [15] provide a stronger definition for chain growth. The definition is stronger, since it requires that at every round the length of some honest party's chain is at least equal to the length of the chain that any honest party had in the previous round. We observe that this monotonicity property is not true for well known alternative chain selection rules, e.g. the GHOST or uncle-GHOST selection rule [17, 4]. Our definition is less stringent and can be shown to be satisfied by such other protocols [10], nevertheless we can still prove that it can be used to achieve strong liveness.</p>

    <p class="text-gray-300">In [7] an attack (selfish mining) against the chain quality property of Bitcoin was demonstrated. In [8] it was shown that (for the case of a rushing adversary<span class="math">^{5}</span>) it is optimal since it matches the bounds of the security theorem for chain quality. However little is known regarding optimal attacks on the common prefix and chain growth properties. For instance, it is known that a “51% attacker” can break the common prefix with an arbitrarily long fork. However long forks have been predicted to be feasible even for attackers with below 50% of the hashing power in case <span class="math">f</span> is large. In this section, we explore attacks on common prefix in an experimental way (through computer simulations) providing</p>

    <p class="text-gray-300"><span class="math">^{5}</span>As argued in [7] this is a plausible attack strategy, we refer to their paper for more details.</p>

    <p class="text-gray-300">some interesting insights on the optimality of the theoretical results that we have proven. The attack targets security when <span class="math">f</span> is large, and thus prohibit the increase of the block generation rate in order to increase the transaction speed.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 4: The level of insecurity in terms of the hashing power of the adversary as a function of <span class="math">1/f</span>. Above the curve, our attack breaks common prefix with a fork that is 100 blocks deep with probability of success at least 1%. The respective block-rate values chosen for two altcoins are depicted on the graph.</p>

    <p class="text-gray-300">The idea of the attacks is the following: when a fork of depth 1 naturally happens, the adversary splits its hashing power, as well as the honest parties’ power, on the two branches. In our model this is possible because we consider the adversary to be rushing. Then, when an honest party in one of the two branches publishes a new solution, the adversary also publishes one of its solutions (if he has any) on the other branch. If honest parties extend both branches by the same length in the same round, then the adversary just reschedules the messages so again parties are split in half. Otherwise, if possible, the adversary lengthens the chain that is behind by the same amount of blocks, to keep the fork running. Additionally, even if parties modified the backbone protocol by randomly resolving ties, cf. <em>[7]</em>, they would have 50% probability to go in one of the two branches. Therefore, <em>randomly resolving ties</em> does not seem to help against this attack.</p>

    <p class="text-gray-300">As our theoretical results have predicted, the protocol seems quite robust against our attack when <span class="math">f&amp;lt;1</span>. However, its security deteriorates as <span class="math">f</span> grows bigger and taking advantage of this attack an adversary can effectively cause deep forks to appear. Graphs on how various cryptocurrencies’ (that use different parameterization than the Bitcoin protocol) fare in terms of the attacks are also presented. It is interesting to point out that for the choice made in Ethereum (<span class="math">f\\approx 1</span>) our provable security bound is around 35% while for Dogecoin and Litecoin our improved analysis brings the provable security bound to a relatively satisfactory level of over 47%. Extreme choices such as Flashcoin cannot be supported at all by the security analysis, while Bitcoin on the other end of the spectrum opts for the safest choice that enables a near optimal provable security bound of about 49%.</p>

    <p class="text-gray-300">In this paper we substantially improved the security bounds of the Bitcoin backbone <em>[8]</em>. With our chain growth definition we introduced a measure of speed, called the chain speed coefficient, and we showed that the chain growth property (with a non-zero coefficient) is a fundamental security property of a robust transaction ledger. Moreover, we identified a stronger version of the common-prefix property, that, along with the chain quality and chain growth properties, is sufficient for proving that a protocol implements a robust public transaction ledger in a black-box manner.</p>

    <h2 id="sec-25" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] L. Bahack. Theoretical bitcoin attacks with less than half of the computational power (draft). Cryptology ePrint Archive, Report 2013/868, 2013. http://eprint.iacr.org/.</li>

      <li>[2] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from bitcoin. Cryptology ePrint Archive, Report 2014/349, 2014. http://eprint.iacr.org/.</li>

      <li>[3] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and E. W. Felten. Research Perspectives and Challenges for Bitcoin and Cryptocurrencies. In 2015 IEEE Symposium on Security and Privacy, May 2015.</li>

      <li>[4] V. Buterin. Toward a 12-second block time, July 2014. [Online; Posted: July 11th, 2014.].</li>

      <li>[5] G. Caffyn. What is the bitcoin block size debate and why does it matter?, August 2015. [Online; posted 21 August 2015].</li>

      <li>[6] C. Decker and R. Wattenhofer. Information propagation in the bitcoin network. In P2P, pages 1–10. IEEE, 2013.</li>

      <li>[7] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Financial Cryptography, 2014.</li>

      <li>[8] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II, pages 281–310, 2015.</li>

      <li>[9] A. Gervais, G. O. Karame, K. Wüst, V. Glykantzis, H. Ritzdorf, and S. Capkun. On the security and performance of proof of work blockchains. Cryptology ePrint Archive, Report 2016/555, 2016. http://eprint.iacr.org/2016/555.</li>

      <li>[10] A. Kiayias and G. Panagiotakos. On trees, chains and fast transactions in the blockchain. Cryptology ePrint Archive, Report 2016/545, 2016. http://eprint.iacr.org/2016/545.</li>

      <li>[11] L. Lamport. Proving the correctness of multiprocess programs. IEEE transactions on software engineering, (2):125–143, 1977.</li>

      <li>[12] S. D. Lerner. Even faster block-chains with the decor protocol. Cryptology ePrint Archive, Report 2013/881, May 2014. https://bitslog.wordpress.com/2014/05/02/decor/.</li>

    </ul>

    <p class="text-gray-300">[13] S. Meiklejohn, M. Pomarole, G. Jordan, K. Levchenko, D. McCoy, G. M. Voelker, and S. Savage. A fistful of bitcoins: characterizing payments among men with no names. In Proceedings of the 2013 Internet Measurement Conference, IMC 2013, Barcelona, Spain, October 23-25, 2013, pages 127–140, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[14] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>[15] R. Pass, L. Seeman, and abhi shelat. Analysis of the blockchain protocol in asynchronous networks. Cryptology ePrint Archive, Report 2016/454, 2016. http://eprint.iacr.org/2016/454.</li>

      <li>[16] Y. B. Perez. Bitcoin in the headlines: Fork-load of drama, August 2015. [Online; posted 21 August 2015].</li>

      <li>[17] Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in bitcoin. Financial Cryptography and Data Security, 2015.</li>

      <li>[18] B. Wiki. Block size limit controversy, August 2015. [Online; Accessed: 24 August 2015].</li>

    </ul>

    <h2 id="sec-26" class="text-2xl font-bold">Appendix A Properties summary</h2>

    <p class="text-gray-300">Here, we give a summary of all security definitions that were considered in this paper.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 18 (Common Prefix Property).</h6>

    <p class="text-gray-300">The common prefix property <span class="math">Q_{\\mathsf{cp}}</span> with parameter <span class="math">k\\in\\mathbb{N}</span> states that for any pair of honest players <span class="math">P_{1},P_{2}</span> maintaining the chains <span class="math">\\mathcal{C}_{1},\\mathcal{C}_{2}</span> in <span class="math">\\textsc{view}^{H(\\cdot)}_{\\Pi,\\mathcal{A},\\mathcal{Z}}(\\kappa,q,z)</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{1}^{\\lceil k}\\preceq\\mathcal{C}_{2}\\text{ and }\\mathcal{C}_{2}^{\\lceil k}\\preceq\\mathcal{C}_{1}.</span></p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 19 (Chain Quality Property).</h6>

    <p class="text-gray-300">The chain quality property <span class="math">Q_{\\mathsf{cq}}</span> with parameters <span class="math">\\mu\\in\\mathbb{R}</span> and <span class="math">\\ell\\in\\mathbb{N}</span> states that for any honest party <span class="math">P</span> with chain <span class="math">\\mathcal{C}</span> in <span class="math">\\textsc{view}^{H(\\cdot)}_{\\Pi,\\mathcal{A},\\mathcal{Z}}(\\kappa,q,z)</span>, it holds that for any <span class="math">\\ell</span> consecutive blocks of <span class="math">\\mathcal{C}</span> the ratio of adversarial blocks is at most <span class="math">\\mu</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 20 (Chain Growth Property).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The chain growth property <span class="math">Q_{cg}</span> with parameters <span class="math">\\tau\\in\\mathcal{R}</span> (the “chain speed” coefficient) and <span class="math">s\\in\\mathbb{N}</span> states that for any round <span class="math">r&gt;s</span>, where honest party <span class="math">P</span> has chain <span class="math">\\mathcal{C}_{1}</span> at round <span class="math">r</span> and chain <span class="math">\\mathcal{C}_{2}</span> at round <span class="math">r-s</span> in <span class="math">\\textsc{view}^{H(\\cdot)}_{\\Pi,\\mathcal{A},\\mathcal{Z}}(\\kappa,q,z)</span>, it holds that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\tau\\cdot s$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 21 (Strong Common-Prefix Property).</h6>

    <p class="text-gray-300">The strong common prefix property <span class="math">Q_{\\mathsf{cp}}</span> with parameter <span class="math">k\\in\\mathbb{N}</span> states that the chains <span class="math">\\mathcal{C}_{1},\\mathcal{C}_{2}</span> reported by two, not necessarily distinct honest parties <span class="math">P_{1},P_{2}</span>, at rounds <span class="math">r_{1},r_{2}</span> with <span class="math">r_{1}\\leq r_{2}</span> are such that <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\preceq\\mathcal{C}_{2}</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 22.</h6>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> implements a robust public transaction ledger in the <span class="math">q</span>-bounded synchronous setting if it satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Persistence: Parameterized by <span class="math">k\\in\\mathbb{N}</span> (the “depth” parameter), if in a certain round an honest player <span class="math">P</span> reports a ledger that contains a transaction tx in a block more than <span class="math">k</span> blocks away from the end of the ledger, then from this round on, tx, if reported at all by any honest player, will be reported in the same position in the ledger as the position reported by <span class="math">P</span>.</li>

      <li>Liveness: Parameterized by <span class="math">u,k\\in\\mathbb{N}</span> (the “wait time” and “depth” parameters, resp.), provided that a transaction either (i) issued by Txgen, or (ii) is neutral, is given as input to all honest players continuously for <span class="math">u</span> consecutive rounds, then there exists an honest party who will report this transaction at a block more than <span class="math">k</span> blocks from the end of the ledger.</li>

    </ul>

    <p class="text-gray-300">B Probability of uniquely successful rounds</p>

    <p class="text-gray-300">In this section we demonstrate a new lower bound on the probability of uniquely successful rounds. This bound allows us to argue about the security of Bitcoin even when <span class="math">f</span> is larger than 1.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Lemma 23.</h6>

    <p class="text-gray-300">For <span class="math">p&lt;0.1</span> and <span class="math">a\\in(p,2k):e^{-a-kp}\\leq(1-p)^{\\frac{a}{p}-k}\\leq e^{-a+kp}</span></p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The second inequality is well studied and holds for <span class="math">p&gt;0</span>. For the first inequality by solving for <span class="math">a</span> we get <span class="math">a\\leq k\\frac{\\ln(1-p)}{1+\\frac{\\ln(1-p)}{p}}</span> which holds for <span class="math">p&lt;0.1</span> and <span class="math">a\\in(p,2k)</span>. ∎</p>

    <p class="text-gray-300">Let <span class="math">\\gamma</span> be a lower bound on the probability of a uniquely successful round (a round where only one block is found). From the event where <span class="math">(n-t)</span> players throw <span class="math">q</span> coins each and exactly one coin toss comes head, the probability of a uniquely successful rounds is at least:</p>

    <p class="text-gray-300"><span class="math">(n-t)qp(1-p)^{q(n-t)-1}\\geq\\alpha e^{-\\alpha-kp}</span></p>

    <p class="text-gray-300">We set <span class="math">\\gamma=ae^{-a-kp}</span>, for the minimum <span class="math">k</span> that satisfies the relation <span class="math">\\alpha\\in(p,2k)</span>. This is a substantially better bound that <span class="math">\\gamma_{u}</span> and is also a lower bound for the event that at a round is successful.</p>

    <h2 id="sec-34" class="text-2xl font-bold">Appendix C Proofs</h2>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">C.1 Lemma 8</h3>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows the idea of the proof in the analogous lemma in <em>[8]</em>. We will first study the case where both <span class="math">C_{1}</span> and <span class="math">C_{2}</span> are adopted by the respective honest players. We define three bad events, <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span>, which we show to hold with probability exponentially small in <span class="math">s</span>. We conclude the proof by showing that if none of these bad events happens, then there cannot exist <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> diverging at round <span class="math">r-s</span>.</p>

    <p class="text-gray-300">The bad event <span class="math">A</span> occurs if, at some round <span class="math">r^{\\prime}\\geq r-s</span>, the adversary broadcasts a chain <span class="math">\\mathcal{C}</span> with the following properties. (1) <span class="math">\\mathcal{C}</span> is returned by the function maxvalid of an honest party; (2) the block head(<span class="math">\\mathcal{C}</span>) was computed by the adversary before round <span class="math">r-(1+\\frac{\\delta}{8})s</span>.</p>

    <p class="text-gray-300">We now give an upper bound on the probability that event <span class="math">A</span> occurs. Let <span class="math">r^{<em>}\\leq r-(1+\\frac{\\delta}{8})s</span> be the latest round at which a block of <span class="math">\\mathcal{C}</span> was computed by an honest party (if none exists, then <span class="math">r^{</em>}=0</span>), and let <span class="math">\\ell</span> denote the length of the chain up to that block. If any other block computed by an honest party exists among the blocks from length <span class="math">\\ell</span> up to <span class="math">\\text{len}(\\mathcal{C})</span>, then such block was computed in rounds <span class="math">r-(1+\\frac{\\delta}{8})s</span> up to <span class="math">r^{\\prime}</span>, and it follows that the probability that the adversary’s block can extend it at round <span class="math">r^{\\prime}</span> is negligible in <span class="math">(\\kappa-\\log D)</span>. Therefore, we infer that with overwhelming probability the adversary has computed all the blocks from length <span class="math">\\ell</span> to <span class="math">\\text{len}(\\mathcal{C})</span>, and done so during the rounds <span class="math">r^{<em>}</span> to <span class="math">r^{\\prime}</span>. Let <span class="math">Z</span> denote the total number of solutions the adversary obtained in <span class="math">r^{\\prime}-r^{</em>}</span> rounds. Let also <span class="math">X</span> denote the total number of successful rounds for the honest parties in <span class="math">r^{\\prime}-r^{*}</span> rounds. We have</p>

    <p class="text-gray-300"><span class="math">Z\\geq\\text{len}(\\mathcal{C})-\\ell\\geq X.</span></p>

    <p class="text-gray-300">The first inequality was argued above and the second one follows from <em>[8, Lemma 5]</em>. Finally, note that, by Lemma <em>[8, Lemma 6]</em>, the event <span class="math">Z\\geq X</span> has measure exponentially small in the number of rounds <span class="math">r^{\\prime}-r^{<em>}</span>. Since that number satisfies <span class="math">r^{\\prime}-r^{</em>}\\geq\\delta s/8</span>, we conclude that <span class="math">\\Pr[A]\\leq e^{-\\Omega(\\delta^{3}s)}</span>.</p>

    <p class="text-gray-300">The second bad event occurs if the adversary has obtained a large number of solutions during <span class="math">(1+\\frac{\\delta}{8})s</span> rounds. Specifically, let <span class="math">Z</span> denote the number of successful calls to the oracle by the</p>

    <p class="text-gray-300">adversary, for a total of <span class="math">(1+\\frac{\\delta}{8})s</span> rounds. Define <span class="math">B</span> to be the event <span class="math">Z\\geq(1+\\frac{\\delta}{9})(1+\\frac{\\delta}{8})\\beta s</span>. An application of Chernoff bounds gives</p>

    <p class="text-gray-300"><span class="math">\\Pr[Z\\geq(1+\\frac{\\delta}{9})(1+\\frac{\\delta}{8})\\beta s]\\leq e^{-\\Omega(\\beta\\delta^{2}s)}.</span></p>

    <p class="text-gray-300">The third bad event occurs when not enough uniquely successful rounds occur. Consider any number, say, <span class="math">s^{\\prime}</span> of rounds, and denote by <span class="math">X^{\\prime}</span> the number of them that were uniquely successful. We have</p>

    <p class="text-gray-300"><span class="math">\\Pr[X^{\\prime}\\leq(1-\\frac{\\delta}{4})\\gamma s^{\\prime}]\\leq e^{-\\Omega(\\gamma\\delta^{2}s^{\\prime})}.</span></p>

    <p class="text-gray-300">From now on we assume that none of the events <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span> occurs. Since a round is uniquely successful with probability <span class="math">\\gamma</span>, from the negation of the third bad event we expect at least <span class="math">(1-\\frac{\\delta}{4})\\gamma s</span> such rounds. Note that, since <span class="math">A</span> does not occur, the adversary may not use solutions computed before round <span class="math">r-(1+\\frac{\\delta}{8})s</span> with probability at least <span class="math">1-e^{-\\Omega(\\delta^{3}s)}</span>. The negation of the second bad event bounds the number of solutions the adversary can obtain. Moreover, for any <span class="math">\\delta\\in(0,1)</span> it holds that</p>

    <p class="text-gray-300"><span class="math">X^{\\prime}&gt;(1-\\frac{\\delta}{4})\\gamma s\\geq(1+\\frac{\\delta}{9})(1+\\frac{\\delta}{8})\\beta s&gt;Z</span></p>

    <p class="text-gray-300">From Lemma 7 this is a contradiction, since the adversary must have mined at least <span class="math">X^{\\prime}</span> solutions in order to maintain the fork.</p>

    <p class="text-gray-300">We conclude that if <span class="math">A\\cup B\\cup C</span> does not occur, then <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> cannot diverge at round <span class="math">r-s</span>. Finally, an application of the union bound on <span class="math">A\\cup B\\cup C</span> implies that the adversary can successfully maintain such <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> with probability at most exponentially small in <span class="math">s</span> and the statement of the lemma follows.</p>

    <p class="text-gray-300">The only of the remaining cases that is interesting, is when block <span class="math">head(\\mathcal{C}_{1})</span> is the block mined in the uniquely successful round <span class="math">r-1</span> and <span class="math">P_{2}</span> has chain <span class="math">\\mathcal{C}_{2}</span> at the beginning of round <span class="math">r</span>. It is implied that at round <span class="math">r-1</span> some honest player mines the chain ending in the parent of <span class="math">head(\\mathcal{C}_{1})</span> and <span class="math">P_{2}</span> adopts <span class="math">\\mathcal{C}_{2}</span>. Notice, that the two chains diverge at round <span class="math">r-s</span> and thus by the same argument as before, this happens with probability at most <span class="math">e^{-\\Omega(\\delta^{3}(s-1))}=e^{-\\Omega(\\delta^{3}s)}</span>, and the lemma follows. All other cases, can be reduced easily to the first argument. ∎</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">C.2 Theorem 9</h3>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If there is only one chain in <span class="math">\\mathcal{S}</span> then the property is satisfied trivially. First, consider two chains <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> in <span class="math">\\mathcal{S}</span> that honest parties have adopted at round <span class="math">r</span> and the least integer <span class="math">k^{*}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{1}^{\\lceil k^{<em>}\\rceil}\\preceq\\mathcal{C}_{2}\\ \\ \\text{and}\\ \\ \\mathcal{C}_{2}^{\\lceil k^{</em>}\\rceil}\\preceq\\mathcal{C}_{1}.</span> (1)</p>

    <p class="text-gray-300">We need to show that the event <span class="math">k^{*}\\geq k</span> happens with probability exponentially small in <span class="math">k</span>.</p>

    <p class="text-gray-300">Let <span class="math">r</span> be the current round and let <span class="math">r-s</span> be the round at which the last common block of <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> was computed. The length of the chains cannot be greater than the number of solutions <span class="math">Y</span> obtained from the oracle in <span class="math">s</span> rounds. By the Chernoff bound,</p>

    <p class="text-gray-300"><span class="math">\\Pr[Y\\geq(1+\\delta)fs]\\leq e^{-\\delta^{2}fs/3}.</span></p>

    <p class="text-gray-300">It follows that, with probability <span class="math">1-e^{-\\delta^{2}fs/3}</span>, <span class="math">s&gt;k^{<em>}/((1+\\delta)f)</span>. Thus, if <span class="math">k^{</em>}\\geq k</span>, we have a sequence of <span class="math">s=\\Omega(k)</span> consecutive rounds with chains <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> diverging at round <span class="math">s</span>, and the theorem follows from Lemma 8.</p>

    <p class="text-gray-300">Otherwise, suppose that without loss of generality <span class="math">C_{1}</span> is the chain that some honest player had (at the beginning of the round) at round <span class="math">r</span>, while <span class="math">C_{2}</span> has been adopted by some honest player at the same round. Then the analysis we did previously holds, since we can apply Lemma 8 for the</p>

    <p class="text-gray-300">two chains. Finally, suppose that both <span class="math">C_1</span> and <span class="math">C_2</span> are chains that honest player had at round <span class="math">r</span>. Then, both chains were adopted by some honest players at round <span class="math">r - 1</span>, which is the case we proved initially, and the theorem follows. <span class="math">\\square</span></p>

    <p class="text-gray-300">19</p>`;
---

<BaseLayout title="Speed-Security Tradeoffs in Blockchain Protocols (2015/1019)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1019
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
