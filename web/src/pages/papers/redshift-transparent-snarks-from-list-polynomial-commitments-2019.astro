---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1400';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'RedShift: Transparent SNARKs from List Polynomial Commitments';
const AUTHORS_HTML = 'Assimakis Kattis, Konstantin Panarin, Alexander Vlasov';

const CONTENT = `    <p class="text-gray-300">Assimakis A. Kattis</p>

    <p class="text-gray-300">New York University</p>

    <p class="text-gray-300">New York, New York, USA</p>

    <p class="text-gray-300">kattis@cs.nyu.edu</p>

    <p class="text-gray-300">Konstantin Panarin</p>

    <p class="text-gray-300">Matter Labs</p>

    <p class="text-gray-300">Berlin, Germany</p>

    <p class="text-gray-300">kp@matterlabs.dev</p>

    <p class="text-gray-300">Alexander Vlasov</p>

    <p class="text-gray-300">Matter Labs</p>

    <p class="text-gray-300">Berlin, Germany</p>

    <p class="text-gray-300">av@matterlabs.dev</p>

    <p class="text-gray-300">We introduce an efficient transformation from univariate polynomial commitment based zk-SNARKs to their transparent counterparts. The transformation is achieved with the help of a new IOP primitive which we call a list polynomial commitment. This primitive is applicable for preprocessing zk-SNARKs over both prime and binary fields. We present the primitive itself along with a soundness analysis of the transformation and instantiate it with an existing universal proof system. We also present benchmarks for a proof of concept implementation alongside a comparison with the current non-transparent state-of-the-art. Our results show competitive efficiency both in terms of proof size and generation times. At the 80-bit security level, our benchmarks provide proof generation times of about a minute and proof sizes of around 515 KB for a circuit with one million gates.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Theory of computation  <span class="math">\\rightarrow</span>  Interactive proof systems.</li>

    </ul>

    <p class="text-gray-300">interactive proof systems, polynomial commitments, zk-SNARKs</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov. 2022. REDSHIFT: Transparent SNARKs from List Polynomial Commitments. In Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security (CCS '22), November 7-11, 2022, Los Angeles, CA, USA. ACM, New York, NY, USA, 19 pages. https://doi.org/10.1145/548606.3560657</p>

    <p class="text-gray-300">Zero-knowledge proofs [27] have recently received increased amounts of attention for providing efficient verification while maintaining small proof sizes, even in the case of complex predicates. Initially limited to theoretical considerations, such proof systems have lately come to encompass the underlying technology in a wide variety of practical and industrial applications with delicate trade-offs between privacy and system security [11] [17] [36]. In this work, we are interested in applications for which there is limited space availability in the underlying system, and thus for which minimal proof size is an important property. Moreover, we ideally want to focus on applications for which there exist no trusted parties at</p>

    <p class="text-gray-300">Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses, contact the owner/author(s).</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">© 2022 Copyright held by the owner/author(s).</p>

    <p class="text-gray-300">ACM ISBN 978-1-4503-9450-5/22/11.</p>

    <p class="text-gray-300">https://doi.org/10.1145/548606.3560657</p>

    <p class="text-gray-300">any point of the computation, and thus hope to achieve proof size minimization without compromising the trust model of the system.</p>

    <p class="text-gray-300">The trade-off above is most closely associated with applications of zero-knowledge proofs to cryptocurrency systems, such as Ethereum [40] or ZCash [34], in which participants have to verify state (or transaction) validity to ensure system soundness but for which there is limited space available in which to do so. Bridging the gap between these two requirements will allow for not only efficient but also trustless verification of state transition in such systems. This has the potential for scaling improvements, such as increased transaction throughput or better privacy guarantees.</p>

    <p class="text-gray-300">The most widely used proof systems for such an application are preprocessing Succinct Non-interactive ARguments of Knowledge (zk-SNARKs) [28] [33] [25], for which proof size and verification time are polylogarithmic in the size of the circuit being verified. 'Pre-processing' here denotes that such systems rely on a one-time (often expensive) setup procedure to produce a proving/verification key-pair  <span class="math">(pk, pk)</span>  (known as a Structured Reference String or SRS) that is used in all subsequent computation. The most efficient such construction is due to Groth [28] and achieves constant proof size consisting of 3 group elements, with state-of-the-art proving time. However, this design (along with most in the literature, see [24], [37], [8]) relies on a trusted setup, or a trusted third-party actor to generate certain parameters (known as the 'toxic waste') that should be destroyed in order for the system to retain its security guarantees.</p>

    <p class="text-gray-300">Such a security lapse would be grave for all aforementioned applications. For example, in a cryptocurrency system such as ZCash an adversary possessing such waste would be able to spend nonexistent tokens without being found. An adopted approach to mitigating this issue involves Multi-Party Computation, in which a single participant needs to destroy their parameters for security to hold [13]. However, scaling such an approach to many participants comes with its own challenges, and can never reach the completely trustless threat model desired by such systems.</p>

    <p class="text-gray-300">The trust issue inherent in the above approach stems from the requirements for the generation of the SRS of the proof at the preprocessing stage. This is done once at the beginning of the protocol, encoding information that is used in the subsequent proof generation of any input arguments. More specifically, in most pairing-based SNARKs (such as [32]) the trusted part of SRS generation stems from the usage of a polynomial commitment scheme that needs to sample (secret) randomness in order to provide commitments to some low-degree polynomial that in turn encodes the circuit in question. That information is then used by the prover to efficiently convince the verifier that a given value is indeed the evaluation of this polynomial, thus proving knowledge of the statement. Such systems use the polynomial commitment scheme of</p>

    <p class="text-gray-300">[31]*, from which the above trust model is derived. This will be further discussed in the following sections.</p>

    <p class="text-gray-300">In attempting to retain a trustless (or ‘transparent’) threat model, the main design challenge lies in the efficiency of the underlying protocol. Various threads of work in this domain have achieved different efficiency trade-offs. The work of <em>(26)</em> produces proofs with size scaling as <span class="math">O(d\\log T)</span>, while the proofs in <em>(39)</em> scale with <span class="math">O(d\\log G)</span> where <span class="math">T</span>, <span class="math">d</span> and <span class="math">G</span> the size, depth and width of the circuit respectively. Succinct Transparent ARguments of Knowledge (zk-STARKs) <em>(4)</em> achieve <span class="math">O(\\log^{2}T)</span> proof sizes for uniform (layered) circuits. However, in the context of universal SNARKs (arbitrary circuits), existing proof systems suffer from performance overheads with respect to pre-processing SNARKs such as <em>(28)</em>. Some also require non-trivial circuit designs, similar to what is described in <em>(21)</em>. Nevertheless, we should note that for the class of problems that can be efficiently expressed as layered circuits, these proof systems may be more optimal than universal ones. Since we are also interested in verifier succinctness, transparent approaches such as <em>(14)</em> do not suffice here due to the linear dependence between verification time and predicate size.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Below we informally describe the properties that an ‘ideal’ proof system should possess for satisfiability of a given circuit <span class="math">C</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ denotes its size. The first three properties define what is known as a ‘fully succinct’ zk-SNARK:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinctness: Verifier time is polylogarithmic in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$,</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Proof Succinctness: Proof size is poly-logarithmic in $</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">$,</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Transparent: No trust assumptions are required,</li>

      <li>Plausibly Quantum Resistant: Not based on assumptions known to be false in the quantum setting.</li>

    </ul>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.1. Prior & Concurrent Work</h3>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.1.1. Polynomial Commitment Schemes</h4>

    <p class="text-gray-300">Polynomial commitment schemes (PCS) allow for the efficient verification of the evaluations of <span class="math">f</span> at an arbitrary point in its domain. A transparent and efficiently computable PCS would yield transparent SNARK constructions that could satisfy all of the requirements of a fully succinct, transparent and plausibly quantum resistant zk-SNARK. Since the introduction of PCS in <em>(31)</em>, the first transparent such scheme was introduced in <em>(39)</em> for multivariate polynomials, with <span class="math">O(\\sqrt{d})</span> commitment size and verification complexity. Subsequent work in <em>(15)</em> introduces a scheme with <span class="math">O(\\mu\\log d)</span> size and verification complexity, where <span class="math">\\mu</span> the number of variables of the polynomial in question and <span class="math">d</span> the polynomial’s degree. Although the asymptotics of the approach in <em>(15)</em> suffice for the above motivation, the practical implementation of their system relies on cryptographic operations that are substantially more resource-heavy than previous approaches. This stems from the reliance of their system’s security on class groups of unknown order. Although the proof sizes achieved are sufficiently succinct, this dependence could make practical deployment difficult at reasonable security levels when proof generation time needs to also be substantially efficient. Moreover, the assumptions on which their construction rests are not quantum-resistant.</p>

    <p class="text-gray-300">The DEEP-ALI protocol <em>(9)</em> uses a similar construction in their STARK <em>(4)</em> proof system. In this case, all the setup polynomials, constraints and checked relations are known to the verifier and are checked naively during the verification procedure. We expect that our scheme can also be adapted for this case and allow one to express more complex STARK circuits. Finally, our contribution extends the approach described in <em>(38)</em>, which comes at the cost of larger proof sizes.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.1.2. Universal zk-SNARKs</h4>

    <p class="text-gray-300">A new approach to the above problem relies on creating a ‘universal’ SRS at the preprocessing phase, which can then be used in tandem with any possible predicate (or circuit). This has been the focus of many recent contributions (see <em>(32)</em>, <em>(41)</em>, <em>(35)</em>, <em>(23)</em>) that are also fully succinct zk-SNARKs in the above sense. The approach in such schemes relies on two main ingredients: (1) encoding the circuit satisfaction problem of the predicate in question as a property of some (low-degree) polynomial <span class="math">f</span>, and then (2) committing to <span class="math">f</span> using a PCS. In all the above approaches, the PCS in <em>(31)</em> is used due to its constant size complexity and efficient implementation. However, this is the only part in the protocol that introduces the trusted setup, as the setup phase in the scheme requires a trusted actor to create (and then destroy) a secret value that is only used in generating commitments.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">1.1.3. zk-SNARK Compilation Frameworks</h4>

    <p class="text-gray-300">Recent work has also explored general frameworks for converting Interactive Oracle Proofs (IOPs) <em>(7)</em> into preprocessing SNARKs. This approach was introduced in <em>(18)</em>, with an equivalent formalization appearing in <em>(15)</em>. At a high level, both of these contributions formalize the idea that preprocessing zk-SNARKs can be constructed from IOPs through oracle access to a low-degree polynomial.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.2. Our Contributions</h3>

    <p class="text-gray-300">In this work, we provide the following contributions:</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">1.2.1. List Polynomial Commitments</h4>

    <p class="text-gray-300">The works of <em>(3)</em> and <em>(9)</em> introduce the Fast Reed Solomon IOP of Proximity (FRI IOPP) - a novel protocol for efficient proximity testing, or checking if a given function is close to any low degree polynomial. Such a proximity tester may be naively turned into a transparent PCS, which provides commitments of size <span class="math">O(\\log^{2}d)</span> for polynomials of degree <span class="math">d</span>. However, the soundness error of such a commitment scheme is rather large, and the protocol should be iterated many times to reach a sufficient security level. This results in large proof sizes and computational burden. The reason for the large soundness error hides in the low sensitivity of FRI: when the Hamming distance between two different polynomials is smaller than some predefined constant, it is impossible for FRI to efficiently distinguish them.</p>

    <p class="text-gray-300">In this work, we generalize the PCS in the sense that we construct a commitment to a list of proximate polynomials. We introduce a new cryptographic primitive for fast verification of polynomial evaluations we call a list polynomial commitment (LPC). At a high level, this scheme retains the necessary security guarantees that are required for polynomial-based proof systems such as <em>(23)</em> and <em>(32)</em> to compile into zk-SNARKs. In the language of IOP formalization, this primitive can be thought of as an alternative compiler for public-coin IOP protocols.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">1.2.2. Compilation of IOPs with LPCs</h4>

    <p class="text-gray-300">The above contribution implicitly provides a general framework that demonstrates how the</p>

    <p class="text-gray-300">list polynomial commitment can be used to compile any polynomial IOP into a preprocessing zk-SNARK. As previously mentioned, this follows the approach in <em>(18)</em> and <em>(15)</em> with the main difference being that we do not require a PCS in their (more restrictive) sense.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">1.2.3. RedShift</h4>

    <p class="text-gray-300">We demonstrate the security and practicality of this approach by compiling <em>(23)</em> using the framework above. By fitting an implementation of the list polynomial commitment on <em>(23)</em> with suitable adaptations and optimizations, we remove all trusted computation while retaining efficiency in both proof size and generation time. We call this new proof system RedShift, and provide:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>formal proofs of correctness and security,</li>

      <li>a proof-of-concept implementation, along with benchmarks establishing feasibility.</li>

    </ol>

    <p class="text-gray-300">At an 80-bit security level and for circuits of size <span class="math">2^{20}</span>, RedShift provides proofs of size <span class="math">\\sim 515</span> KB with a proof generation time of about half a minute. Overall, RedShift is an efficient instantiation of a potentially quantum-resistant transparent preprocessing zk-SNARK suitable for practical deployments at high security.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">1.3. Transparent zk-SNARKs</h3>

    <p class="text-gray-300">Prior work on transparent zk-SNARKs has explored a variety of trade-offs and different design choices in order to achieve efficiency gains. We briefly discuss concurrent and previous efforts in building efficient and transparent proof systems and compare with our approach. The works of <em>(6)</em> and <em>(20)</em> design IOPs for the Rank-1 Constraint System (R1CS) arithmetization, providing a compilation framework equivalent to our methods. They require a holographic lincheck argument/IOP of Proximity respectively in order to construct their IOP for R1CS, which our approach avoids by using a suitable transformation of the proof system in <em>(23)</em> instead. The works of <em>(42)</em> (and <em>(41)</em>, although not transparent) use a similar approach but with the IOP from <em>(27)</em>. This makes our approach easier to formalize.</p>

    <p class="text-gray-300">The authors of <em>(4)</em> and <em>(3)</em> use FRI implicitly as a PCS and design the ALI-IOP for compilation. Our results are directly applicable and generalize their approach. In <em>(12)</em>, the authors define a restricted version of PCS that are ‘additive’ (with homomorphic properties), benchmarking with Bulletproofs <em>(14)</em> for fast recursion. While an additive PCS is too restrictive to include FRI, batching efficiency gains are possible if this definition is relaxed. The batch evaluation problem in Section 4 of <em>(12)</em> is equivalent to a multivariate commitment, and the LCS is a relaxation of that notion that we selectively apply to proof witnesses. By relaxing the binding property of PCS, our LCS replaces <em>(31)</em> for transparent multivariate commitments to witness polynomials more generally.</p>

    <p class="text-gray-300">Subsequent work <em>(1)</em> has built on these ideas, looking at how two modular modifications to the proof system affect performance by using a smaller field for faster modular operations and implementing a leaner PLONK-derived IOP called turboPLONK <em>(22)</em> instead. The authors explore an additional avenue for optimization of proof efficiency by counterbalancing any soundness loss due to the smaller field by applying the tight parallel repetition theorem to the IOP in order to boost soundness and performing FRI in a suitable extension field. This is then shown to lend itself to efficient recursive proving times, providing a promising avenue for transparent recursive proof computations at scale.</p>

    <h2 id="sec-16" class="text-2xl font-bold">2. Overview</h2>

    <p class="text-gray-300">The proof system in <em>(23)</em> (known as PLONK) is based on polynomial commitments: the prover’s (secret) witness is encoded as a set of univariate polynomials, while the verifier wishes to ensure this encoding satisfies some polynomial relations. The prover commits to her witness polynomials and later the verifier queries their values at a set of randomly selected points, checking if all relations are indeed satisfied. As the points were randomly sampled, it is highly likely that the given polynomial relations hold identically.</p>

    <p class="text-gray-300">The state-of-the-art PCS used in the construction of zk-SNARKs is the Kate commitment <em>(31)</em>, which is based on pairings of points of elliptic curves. The security of this scheme reduces to the Discrete Logarithm assumption, while in the case of a perfectly hiding commitment the <span class="math">t</span>-Strong Diffie Hellman assumption is required. The main drawback of Kate commitments is that some secret value is sampled during the parameter generation process. For security to hold, this value should never be revealed to the prover and verifier. Such a requirement is very strong, as it means that every proof system using Kate will require a ‘trusted’ setup process. We denote proof systems without this requirement as <em>transparent</em>. In fact, the only reason PLONK requires a trusted setup is due to Kate. In this work we aim to investigate a suitable replacement for Kate, turning PLONK (and similar systems) into zero-knowledge Succinct Transparent ARguments of Knowledge, i.e. zk-STARKs.</p>

    <p class="text-gray-300">We utilize the FRI protocol, which is a key component of STARKs such as <em>(4)</em> and <em>(6)</em>. FRI is focused on solving the following <em>proximity</em> problem: the verifier is given oracle access to an evaluation of some function <span class="math">f</span> on a fixed domain <span class="math">D\\subset\\mathbb{P}</span>. The prover wants to convince the verifier that this function <span class="math">f</span> is close (in some metric) to a polynomial of (predefined) degree <span class="math">d</span>. If the verifier queries <span class="math">f</span> on all of <span class="math">D</span> and then computes the interpolation polynomial herself, she can verify the degree bound <span class="math">d</span>. However, this requires <span class="math">O(d)</span> complexity. FRI solves this problem by requiring only a polylogarithmic number of queries in <span class="math">d</span>.</p>

    <p class="text-gray-300">We now describe a naive way to design a PCS using FRI:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover commits to <span class="math">f</span>, providing an oracle to all evaluations of <span class="math">f</span> on some predefined domain <span class="math">D</span>.</li>

      <li>The prover and verifier engage in FRI for <span class="math">f</span> with respect to some degree <span class="math">d</span>. If the prover passes the check, the verifier is convinced with high probability that <span class="math">f</span> is close to a polynomial of degree less than <span class="math">d</span>.</li>

      <li>The verifier wants to retrieve the value of <span class="math">f</span> at point <span class="math">i\\notin D</span>. The prover sends the corresponding opening <span class="math">z=f(i)</span> and both parties then conduct another instance of FRI, this time with respect to a quotient function <span class="math">q(X)=(f(X)-z)/(X-i)</span> and degree <span class="math">d-1</span>. Note that the verifier has oracle access to <span class="math">q</span> via oracle access to <span class="math">f</span> and also knows <span class="math">i</span> and <span class="math">z</span>. If the prover passes the last instance of FRI then <span class="math">q(X)</span> is in fact a polynomial function of degree less than <span class="math">d-1</span>.</li>

      <li>This implies that <span class="math">f(i)=z</span> which follows from Bezout’s theorem stating that <span class="math">h(X)</span> has value <span class="math">y</span> at point <span class="math">t</span> iff <span class="math">h(X)-y</span> is divisible by <span class="math">X-t</span> in the ring <span class="math">\\mathbb{P}[X]</span>.</li>

    </ol>

    <p class="text-gray-300">In reality, this simplified protocol doesn’t suffice. There are several reasons for that, among which are the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>FRI has a sensitivity bound: it is incapable of distinguishing between precise polynomials and functions sufficiently close to them in some predefined metric (which in our case is the relative Hamming distance).</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For implementation coherency, we want the same domain for both FRI instances. However, FRI has an interdependence between the degree <span class="math">d</span> and the size of the domain $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> measured in terms of its rate </span>\\rho=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The structure of FRI requires the rate to be “2-adic”, i.e. of the form </span>2^{-R}<span class="math"> for some </span>R\\in\\mathbb{N}<span class="math">. However, this property cannot simultaneously hold for two adjacent degrees </span>d<span class="math"> and </span>d-1$ without protocol modification.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first problem means that the scheme needs to correctly process the case when the function is not a polynomial, but close to one; a property not naturally supported by existing commitment schemes. Even more so, allowing the oracle <span class="math">f</span> to not be strictly polynomial and to take as the prover’s commitment the polynomial <span class="math">f^{\\prime}</span> lying in a small <span class="math">\\delta</span>-ball around <span class="math">f</span> (where <span class="math">\\delta</span> is taken according to the sensitivity of FRI) then we cannot guarantee a priori that this polynomial <span class="math">f^{\\prime}</span> is unique in the chosen neighborhood of <span class="math">f</span>. The set of polynomials <span class="math">\\{f^{\\prime}_{1},f^{\\prime}_{2},\\ldots,f^{\\prime}_{n}\\}</span> lying in the <span class="math">\\delta</span>-neighborhood of <span class="math">f</span> is the <span class="math">\\delta</span>-list of <span class="math">f</span>, which we denote by <span class="math">L_{\\delta}:=L_{\\delta}(f)</span>. For small values of <span class="math">\\delta</span>, the list <span class="math">L_{\\delta}</span> contains only one polynomial: <span class="math">\\delta</span> lies in the unique-decoding radius. Unfortunately such values of <span class="math">\\delta</span> require larger proof sizes for the same soundness guarantees. Thus, increasing <span class="math">\\delta</span> to reduce proof sizes would lead to the size <span class="math">L_{\\delta}</span> being greater than <span class="math">1</span>.</p>

    <p class="text-gray-300">To solve this, we consider a relaxed treatment of commitment schemes, where the commitment opens to a polynomial in the <span class="math">\\delta</span>-list <span class="math">L_{\\delta}</span>. When the prover is asked for an evaluation at point <span class="math">i</span>, they respond with some value <span class="math">f^{\\prime}(i)</span>, where <span class="math">f^{\\prime}\\in L_{\\delta}</span>. In subsequent sections we show that this scheme is sufficient for the compilation of holographic IOPs. During the execution of PLONK, the prover and verifier need to evaluate a set of initial ‘constraint’ (or setup) polynomials <span class="math">c(X)</span> encoding the constraint system itself. In order to achieve succinctness, the verifier never calculates the value <span class="math">c(i)</span> at point <span class="math">i</span> by herself. PLONK instead relies on Kate: the prover and verifier run Kate with the commitment to <span class="math">c</span> and value <span class="math">i</span> as inputs. By its binding property, the verifier is convinced that the prover actually sends the evaluation <span class="math">c(i)</span> of the polynomial <span class="math">c(X)</span> in question. Since our relaxation commits to a whole neighborhood <span class="math">L_{\\delta}(c)</span> of <span class="math">c(X)</span> instead of only <span class="math">c(X)</span> itself, we lose uniqueness. This means we can’t use such a ‘relaxed’ scheme as is. However, we show that with minor changes our LPC can be turned into a PCS. We call this construction a polynomial evaluation scheme and it constitutes the second key sub-protocol of the paper.</p>

    <p class="text-gray-300">With the list polynomial commitments and polynomial evaluation schemes, we can modify PLONK to achieve full transparency. We call the modified version RedShift and prove its correctness in the IOP model. A large portion of our approach remains the same as in <em>(23)</em>: our modification doesn’t modify the completeness property of the system. However, the FRI-based protocol doesn’t possess the hiding capabilities of Kate. This means that we need to take additional measures to achieve zero-knowledge for our system. We also need to change the security model as the original PLONK protocol was proven secure in the Algebraic Group Model (AGM). The dependence of our scheme on FRI means that we need to conduct our security analysis in the IOP model, affecting the soundness proof as well as the proof of knowledge approaches.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3. Definitions</h2>

    <p class="text-gray-300">In this section, we lay out the building blocks that are necessary to describe our constructions.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1. Notation</h3>

    <p class="text-gray-300">Through this paper we use the following notations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}_{q}</span> is a prime field with modulus <span class="math">q</span></li>

      <li><span class="math">D\\subset\\mathbb{F}</span> evaluation domain for Reed Solomon codes</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math"> is a restriction of function </span>f<span class="math"> to domain </span>D$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For function pair <span class="math">f,g</span>, the relative Hamming distance with respect to some domain <span class="math">D</span> is given by:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(f,g)=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in D:f(x)\\neq g(x)\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.2. Preliminaries on Reed-Solomon codes</h3>

    <p class="text-gray-300">Most of the information covered in this section can be found in most standard on algebraic codes (e.g. <em>(30)</em>).</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 1 (Reed-Solomon Codes).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a subset of some field <span class="math">D\\subseteq\\mathbb{F}</span> and a rate parameter <span class="math">\\rho\\in(0,1]</span>, we denote by <span class="math">\\operatorname{RS}[\\mathbb{F},D,\\rho]</span> the set of all functions <span class="math">f:D\\to\\mathbb{F}</span> for which there exists $\\hat{f}\\in\\mathbb{F}_{<\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]<span class="math"> agreeing with </span>f<span class="math"> on </span>D<span class="math">. A prime field RS code family is a code family </span>\\operatorname{RS}[\\mathbb{F},D,\\rho]<span class="math"> for which </span>\\mathbb{F}=\\mathbb{F}_{q}<span class="math"> for </span>q<span class="math"> prime. In this case, </span>D<span class="math"> is a multiplicative subgroup of </span>\\mathbb{F}_{q}^{*}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 2 (List Decoding).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">V=\\operatorname{RS}[\\mathbb{F},D,\\rho]\\subset\\mathbb{F}^{D}</span> be an RS code family. Set a distance parameter <span class="math">\\delta\\in[0,1]</span>. For <span class="math">u\\in\\mathbb{F}^{D}</span>, we define <span class="math">L(u,V,\\delta)</span> to be the set of elements in <span class="math">V</span> that are at most <span class="math">\\delta</span>-far from <span class="math">u</span> in relative Hamming distance. The code <span class="math">V</span> is said to be <span class="math">(\\delta,N)</span>-list-decodable if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L(u,V,\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N<span class="math"> for all </span>u\\in\\mathbb{F}_{q}^{D}<span class="math">. Let </span>L_{\\delta}^{\\max}=L(\\mathbb{F},D,d,\\delta)<span class="math"> be the maximum size of </span>L(u,V,\\delta)<span class="math"> taken over all </span>u\\in\\mathbb{F}^{D}<span class="math"> for </span>V=\\operatorname{RS}[\\mathbb{F},D,\\rho=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 1 (Johnson Bound).</h6>

    <p class="text-gray-300">For every <span class="math">\\rho&gt;0</span>, there exists a constant <span class="math">C_{\\rho}</span> such that the code family <span class="math">\\operatorname{RS}[\\mathbb{F},D,\\rho]</span> is list-decodable from a <span class="math">1-\\sqrt{\\rho}-\\epsilon</span> fraction of errors with the following list size:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$L(\\mathbb{F},D,\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,1-\\sqrt{\\rho}-\\epsilon)\\leq\\frac{C_{\\rho}}{\\epsilon\\sqrt{\\rho}}:=J_{\\rho,\\epsilon},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for every <span class="math">\\epsilon\\in(0,1-\\sqrt{\\rho})</span>.</p>

    <p class="text-gray-300">We also provide a (strong) conjecture that substantially improves on the above bound, which appears in <em>(9)</em>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Conjecture 1 (List Decodability up to Capacity).</h6>

    <p class="text-gray-300">For every <span class="math">\\rho&gt;0</span>, there exists a constant <span class="math">C_{\\rho}</span> such that the code family <span class="math">\\operatorname{RS}[\\mathbb{F},D,\\rho]</span> is list-decodable from a <span class="math">1-\\rho-\\epsilon</span> fraction of errors with the following list size:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$L(\\mathbb{F},D,\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,1-\\rho-\\epsilon)\\leq\\left(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\epsilon}\\right)^{C_{\\rho}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for every <span class="math">\\epsilon\\in(0,1-\\rho)</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">REDSHIFT: Transparent SNARKs from List Polynomial Commitments</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">We now look at which distance parameters <span class="math">\\delta</span> provide unique decodability. To this end, we provide some standard results on the unique decodability of RS codes.</p>

    <p class="text-gray-300"><strong>DEFINITION 3.</strong> We call <span class="math">\\delta_0</span> the unique decoding radius (UDR) for code family <span class="math">C</span> if it is the maximum <span class="math">\\delta_0</span> for which <span class="math">t_{\\delta_0}^{\\max} \\leq 1</span>. We denote all <span class="math">\\delta &amp;lt; \\delta_0</span> as being within the unique decoding radius.</p>

    <p class="text-gray-300"><strong>THEOREM 2.</strong> The UDR for RS[<span class="math">\\mathbb{F}, D, \\rho</span>] is <span class="math">\\delta_0 = (1 - \\rho)/2</span>.</p>

    <p class="text-gray-300">The decoding problem for the Reed-Solomon code <span class="math">V = \\mathrm{RS}[\\mathbb{F}, D, \\rho]</span> is the problem of finding a codeword <span class="math">u \\in V</span> that is within distance <span class="math">\\delta</span> (with respect to Hamming distance) of a given word <span class="math">v \\in \\mathbb{F}^D</span>. There exists a standard polynomial-time solution known as the Guruswami-Sudan [29] algorithm. Its output includes all codewords lying in the <span class="math">\\delta</span>-ball of <span class="math">v</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>THEOREM 3 (GURUSWAMI-SUDAN).</strong> For all <span class="math">\\delta \\leq 1 - \\sqrt{\\rho}</span>, the code <span class="math">V = \\mathrm{RS}[\\mathbb{F}, D, \\rho]</span> can be list-decoded in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{15})<span class="math">. If </span>\\delta &lt; 1 - \\sqrt{\\rho}<span class="math">, this reduces to </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-24" class="text-2xl font-bold">3.3 Interactive Oracle Proofs and IOPs of Proximity</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given some relation <span class="math">\\mathcal{R} \\subseteq S \\times T</span>, we denote by <span class="math">\\mathcal{L}(\\mathcal{R}) \\subseteq S</span> the set of <span class="math">s \\in S</span> such that there exists <span class="math">t \\in T</span> with <span class="math">(s, t) \\in \\mathcal{R}</span> (also known as the language defined by <span class="math">\\mathcal{R}</span>). We also denote by $\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_s \\subseteq T<span class="math"> the set </span>\\{t \\in T : (s, t) \\in \\mathcal{R}\\}<span class="math">. For pairs </span>(x, w) \\in \\mathcal{R}<span class="math">, we call </span>x<span class="math"> the instance and </span>w$ the witness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The security analysis in this section will be conducted in the Interactive Oracle Proof (IOP) model [7] which is a generalization of Interactive Proofs and Probabilistically Checkable Proofs. More specifically, we will be looking at holographic IOPs, or IOPs in which (preprocessed) indices are provided to the participating parties through oracles. The model consists of a prover/verifier tuple <span class="math">(P,V)</span> of two probabilistic interactive algorithms. The number of interactive rounds, denoted <span class="math">k = r(x)</span>, is called the round complexity of the system. During a single round, the prover <span class="math">P</span> sends a message <span class="math">a_{i}</span> (which may depend on prior interaction) to which the verifier <span class="math">V</span> provides some response <span class="math">m_{i}</span>. The final output of <span class="math">V</span> after interacting with <span class="math">P</span> is either accept or reject. We denote the result of this interaction by <span class="math">\\langle P(x,w)\\leftrightarrow V(x)\\rangle</span>, where the input to <span class="math">V</span> is <span class="math">x\\in S</span> and the input to <span class="math">P</span> is <span class="math">(x,w)\\in S\\times T</span>. The proof length is the sum of lengths of all messages sent by the prover, herein denoted <span class="math">l(x) = \\sum_{i = 1}^{k}a_{i}</span>. The query complexity of the protocol, denoted <span class="math">q(x)</span>, is the total number of entries read by <span class="math">V</span>.</p>

    <p class="text-gray-300"><strong>DEFINITION 4.</strong> A pair of interactive PPT algorithms <span class="math">(P,V)</span> is an interactive oracle proof system for some language <span class="math">\\mathcal{R} \\subseteq S \\times T</span> with <span class="math">\\epsilon : \\{0,1\\}^<em> \\to [0,1]</span> soundness and <span class="math">k : \\{0,1\\}^</em> \\to \\mathbb{N}</span> rounds of interaction if it satisfies the following properties:</p>

    <p class="text-gray-300">(1) <strong>Completeness:</strong></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle P (x, w) \\leftrightarrow V (x) \\rangle = \\operatorname{acc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x, w) \\in \\mathcal {R} \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(2) <strong>Soundness:</strong> For all computationally unbounded malicious provers <span class="math">P^{*}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle P ^ {*} (x, w) \\leftrightarrow V (x) \\rangle = \\operatorname{acc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x, w) \\notin \\mathcal {R} \\right] \\leq \\epsilon (x).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Probabilities are over the randomness of <span class="math">P</span> and <span class="math">V</span>, which engage in at most <span class="math">k(x)</span> rounds of (adaptive) interaction.</p>

    <p class="text-gray-300"><strong>DEFINITION 5.</strong> Let <span class="math">A, B</span> be PPT algorithms, <span class="math">x, y \\in \\{0,1\\}^*</span> and <span class="math">\\mathrm{View}(B(x,y), A(x))</span> the view (or transcript) of <span class="math">A(x)</span> in an IOP with <span class="math">B(x,y)</span>. This is the random variable <span class="math">(x,r, \\{a_i, m_i\\}_{i=1}^n)</span> where <span class="math">x, r</span> are <span class="math">A</span>'s input and randomness and <span class="math">a_i</span> is <span class="math">B</span>'s (i-th) answer to <span class="math">A</span>'s query <span class="math">m_i</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>State-Restoration Knowledge Soundness</strong> Strengthening the notion of soundness, we say the IOP has knowledge soundness <span class="math">\\epsilon : \\{0,1\\}^<em> \\to [0,1]</span> if every prover <span class="math">P^</em></span> who is capable of convincing the verifier that <span class="math">x \\in \\mathcal{L}(\\mathcal{R})</span> actually knows some witness $w \\in \\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x<span class="math">. Put differently, the IOP is knowledge sound if for all adversaries </span>\\mathcal{A}<span class="math"> there exists a (non-uniform) PPT extractor </span>\\mathcal{E}^{\\mathcal{A}}(x)<span class="math"> which gets full access to the adversary&#x27;s transcript at any stage. However, this does not include </span>\\mathcal{A}<span class="math">&#x27;s random coins, auxiliary inputs and internal code. We say that </span>(P,V)<span class="math"> has proof of knowledge </span>\\epsilon<span class="math"> if there exists </span>\\mathcal{E}<span class="math"> s.t. for every </span>x \\in S<span class="math"> and PPT </span>\\mathcal{A}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ (x, \\mathcal {E} ^ {\\mathcal {A}} (x)) \\in \\mathcal {R} \\right] \\geq \\Pr \\left[ (\\mathcal {A}, V) = 1 \\right] - \\epsilon (x).</span></div>

    <p class="text-gray-300">Since we are ultimately interested in compiling the IOP into a non-interactive proof, the stronger notion of state-restoration IOP soundness error <span class="math">\\epsilon_{\\mathrm{sr}}(r)</span>, where <span class="math">r</span> the maximal number of rounds, is needed. This is because the protocol should be robust against state-restoration attacks, in which the prover has the ability to move to a previous state of the protocol up to <span class="math">r</span> times. It was shown in [7] that this notion suffices in compiling proofs using Fiat-Shamir in the random oracle model, while [16] show this for correlation-intractable hash functions as well. In order to prove state-restoration bounds, the idea of round-by-round soundness error <span class="math">\\epsilon_{\\mathrm{rbr}}</span> is leveraged. It can be shown that <span class="math">\\epsilon_{\\mathrm{sr}} \\leq r \\cdot \\epsilon_{\\mathrm{rbr}}</span>, which is sufficient for security if <span class="math">r</span> is a polynomial number of rewinds/rounds. This analysis holds since we can apply the round-by-round extractor to every partial transcript that comprises <span class="math">\\mathrm{tr}_{\\mathrm{sr}}</span> and output the first valid witness. Since the empty transcript is rejecting and <span class="math">\\mathrm{tr}_{\\mathrm{sr}}</span> accepts, then some partial transcript moves from rejecting to accepting. Since the round-by-round extractor fails with probability <span class="math">\\epsilon_{\\mathrm{rbr}}</span>, the result follows by a union bound. We follow the approach in [16],[20] and provide the required definitions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>DEFINITION 6 (ROUND-BY-ROUND SOUNDNESS).</strong> An IOP <span class="math">(P,V)</span> for language <span class="math">\\mathcal{L}(\\mathcal{R})</span> has round-by-round knowledge soundness <span class="math">\\epsilon_{\\mathrm{rbr}}</span> if there exists a function State from the set of transcripts to <span class="math">\\{0,1\\}</span> and a polynomial-time extractor <span class="math">\\mathcal{E}</span> such that for all <span class="math">(x,\\mathrm{tr})</span> for which <span class="math">\\mathrm{State}(x,\\mathrm{tr}) = 0</span>, and all messages a received from the prover, if $\\operatorname*{Pr}_m[\\mathrm{State}(x,\\mathrm{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m) = 1] &gt; \\epsilon_{\\mathrm{rbr}}<span class="math"> then </span>(x,\\mathcal{E}(x,\\mathrm{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{a})) \\in \\mathcal{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>DEFINITION 7 (STATE-RESTORATION SOUNDNESS).</strong> An IOP <span class="math">(P,V)</span> for language <span class="math">\\mathcal{L}(\\mathcal{R})</span> has state-restoration knowledge soundness <span class="math">\\epsilon_{\\mathrm{sr}}</span> if there exists a polynomial time extractor <span class="math">\\mathcal{E}</span> such that for all <span class="math">x</span> and every state-restoration prover <span class="math">P^{*}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( \\begin{array}{c c} \\operatorname{tr}_{\\mathrm{sr}} \\text{ accepts} &amp;amp; \\operatorname{tr}_{\\mathrm{sr}} \\leftarrow \\operatorname{View}(P^{*}(x), V(x)) \\\\ (x, w) \\notin \\mathcal{R} &amp;amp; w \\leftarrow \\mathcal{E}(x, \\operatorname{tr}_{\\mathrm{sr}}) \\end{array} \\right) \\leq \\epsilon_{\\mathrm{sr}}.</span></div>

    <p class="text-gray-300"><strong>DEFINITION 8 (ZERO KNOWLEDGE).</strong> For a given relation <span class="math">\\mathcal{R}</span> and some <span class="math">z: \\{0,1\\}^* \\to [0,1]</span>, <span class="math">\\langle P,V\\rangle</span> has <span class="math">z</span>-statistical honest-verifier zero knowledge if there exists a PPT algorithm <span class="math">S</span> (the simulator) s.t. <span class="math">\\forall (\\phi ,w)\\in \\mathcal{R}, S(x,\\phi)</span> and <span class="math">\\mathrm{View}(P(\\phi ,w),V(\\phi))</span> are <span class="math">z(x)</span>-close.</p>

    <p class="text-gray-300">An important subclass of IOP protocols is given below.</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IOPP. An Interactive Oracle Proof of Proximity (IOPP) is an <span class="math">r</span>-round interactive IOP system for the following problem. Given a field <span class="math">\\mathbb{F}</span>, degree <span class="math">d \\in \\mathbb{N}</span>, proximity parameter <span class="math">\\delta &amp;gt; 0</span> and domain <span class="math">D \\subset \\mathbb{F}</span>, the prover is provided with the representation of some function <span class="math">f</span> and the verifier is given oracle access to its evaluation on domain <span class="math">D</span> (i.e. an oracle <span class="math">\\hat{f}(x)</span> to $f(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D<span class="math">). The prover then needs to convince the verifier that </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D<span class="math"> is the evaluation of some degree </span>d<span class="math"> polynomial on this domain. Namely, that </span>f \\in \\mathrm{RS}[\\mathbb{F}, D, \\rho = d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$. We follow the formalization in [3]:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">DEFINITION 9 (IOPP). A <span class="math">k</span>-round IOP of Proximity <span class="math">(P, V)</span> is a <span class="math">k + 1</span>-round IOP. <span class="math">(P, V)</span> is an IOPP for the error-correcting code <span class="math">C = \\{f : S \\to \\Sigma\\}</span> and soundness <span class="math">\\epsilon : [0,1] \\to [0,1]</span> with respect to some metric <span class="math">\\Delta</span> if the following hold:</p>

    <p class="text-gray-300">(1) First message format: the first prover message is a purported code-word, i.e. <span class="math">f^0 \\in C</span>, (2) Completeness:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\left\\langle P \\left(f ^ {0}, C\\right) \\leftrightarrow V (C) \\right\\rangle = a c c \\mid \\Delta \\left(f ^ {0}, C\\right) = 0 \\right] = 1,</span></div>

    <p class="text-gray-300">(3) Soundness: For any <span class="math">P^*</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\left\\langle P ^ {*} \\left(f ^ {0}, C\\right) \\leftrightarrow V (C) \\right\\rangle = r e j \\mid \\Delta (f, C) = \\delta \\right] \\geq \\epsilon (\\delta).</span></div>

    <p class="text-gray-300">We note that the notions of proof and query complexity of IOPs translate naturally to the context of IOPPs. In the rest of the sections, we use <span class="math">\\mathrm{IOPP}(f^0,C)\\to \\{0,1\\}</span> to denote an IOPP protocol IOPP with purported code-word <span class="math">f^0\\in C</span> and <span class="math">C</span> error-correcting code family.</p>

    <h2 id="sec-25" class="text-2xl font-bold">3.4 Fast Reed-Solomon IOPP</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our construction, we opt for using FRI [3], [10]. We provide an overview of its relevant properties below. For a given RS code family <span class="math">\\mathrm{RS}[\\mathbb{F},D,\\rho ]</span> for which $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n = 2^{k}<span class="math"> and rate </span>\\rho = 2^{-R}<span class="math"> for </span>k,R\\in \\mathbb{N}<span class="math">. This implies that the degree bound </span>d<span class="math"> is </span>2^{k - R}<span class="math">. Fix </span>r\\in [1,\\log d = k - R]<span class="math"> to be the number of rounds in the protocol. For every </span>\\eta \\in (0,1]<span class="math">, let </span>J_{\\eta}:[0,1]\\to [0,1]<span class="math"> be the Johnson function </span>J_{\\eta}(x) = 1 - \\sqrt{1 - x(1 - \\eta)}<span class="math">. Given this parameter choice, FRI has the following properties, where the asymptotics are given in terms of field operations over </span>\\mathbb{F}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(1) Prover Complexity: <span class="math">O(n)</span> (2) Verifier Complexity: <span class="math">O(\\log n)</span> (3) Completeness: If <span class="math">f \\in \\mathrm{RS}[\\mathbb{F}, D, \\rho]</span> and the prover is honest, then the verifier always accepts. (4) Soundness: If <span class="math">\\Delta(f, \\mathrm{RS}) = \\delta</span> and <span class="math">\\delta \\in (0, J_{\\eta}^{[3/2]}(1 - \\rho))</span>, then <span class="math">\\forall \\eta \\in (0, 1]</span> the soundness error <span class="math">\\epsilon(\\delta)</span> is bounded above by:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {2 \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\eta^ {3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\left(1 - \\min  \\left\\{\\delta_ {0}, \\delta \\right\\} + \\eta \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) ^ {l},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">l</span> the number of queries the verifier performs.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 LIST POLYNOMIAL COMMITMENT</h2>

    <p class="text-gray-300">We start with the basic requirement for a commitment scheme to commit to elements of a given polynomial. This will be provided as an oracle to the underlying gadget, and we assume it's binding i.e. that the adversary will be able to fake commitments with negligible probability over the schemes security. A commitment scheme <span class="math">\\Sigma = (\\mathrm{Gen}, \\mathrm{Com}, \\mathrm{Open})</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Gen}(1^{\\lambda}) \\to \\mathrm{pp}</span> generates public parameters,</li>

      <li><span class="math">\\operatorname{Com}:\\mathbb{P}_{&amp;lt;d}[X]\\to \\mathcal{C}</span> commitment <span class="math">c</span> to some <span class="math">f</span>,</li>

      <li><span class="math">\\operatorname{Open}:\\mathcal{C} \\times \\mathbb{F}_{&amp;lt;d}[X] \\to \\{0,1\\}</span> checks validity of some commitment <span class="math">c</span> with access to <span class="math">f</span>.</li>

    </ul>

    <p class="text-gray-300">We say that the tuple <span class="math">(\\mathrm{Gen}, \\mathrm{Com})</span> is <span class="math">\\epsilon</span>-binding if there exists an Open function for which:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\operatorname {O p e n} (\\operatorname {C o m} (f)) = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {p p} \\leftarrow \\operatorname {G e n} (1 ^ {\\lambda}) \\right] = 1,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and for all PPT adversaries <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} f \\neq g, \\operatorname {O p e n} (c, f) = 1 &amp;amp; (f, g, c) \\leftarrow \\mathcal {A} (\\mathrm {p p}) \\\\ \\operatorname {O p e n} (c, g) = 1 &amp;amp; \\mathrm {p p} \\leftarrow \\operatorname {G e n} (1 ^ {\\lambda}) \\end{array} \\right] \\leq \\epsilon (\\lambda).</span></div>

    <p class="text-gray-300">We are now ready to introduce the main ingredient underlying the transparency of our proving system, which we call a List Polynomial Commitment (LPC) scheme. This cryptographic primitive most resembles a polynomial commitment scheme, with the main difference arising from the need to show that <span class="math">g(z) = y</span> where <span class="math">g</span> is a polynomial in a <span class="math">\\delta</span> neighborhood around <span class="math">f</span> (in a predefined metric <span class="math">\\Delta</span>), rather than requiring the evaluation of <span class="math">f</span> itself. As before, we denote <span class="math">L_{\\delta}(f)</span> as the <span class="math">\\delta</span>-list of <span class="math">f</span> or the set of all <span class="math">g \\in \\mathrm{RS}[\\mathbb{F}, D, \\rho]</span> such that <span class="math">\\Delta(f, g) &amp;lt; \\delta</span>.</p>

    <h2 id="sec-27" class="text-2xl font-bold">4.1 Specification</h2>

    <p class="text-gray-300">Here we define the generic primitive that formalizes the notion of a list commitment scheme. We will build on this construction later to show that it admits (1) an efficient implementation, and (2) modifications that provide stronger proof-of-knowledge guarantees.</p>

    <p class="text-gray-300">DEFINITION 10. An <span class="math">(\\epsilon, k)</span>-list polynomial commitment scheme for some metric <span class="math">\\Delta: \\mathbb{F}[X] \\times \\mathbb{F}[X] \\to [0,1]</span> and all <span class="math">\\delta &amp;gt; 0</span> consists of the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Gen}(1^{\\lambda}) \\to \\mathrm{pp}</span> generates public parameters,</li>

      <li><span class="math">\\operatorname{Com}:\\mathbb{F}_{&amp;lt;d}[X]\\to \\mathcal{C}</span> commitment <span class="math">c</span> to some <span class="math">f</span>,</li>

      <li>An IOP system <span class="math">(P, V)</span> with <span class="math">\\epsilon(\\delta)</span> soundness and <span class="math">k(\\delta)</span> rounds of interaction for the relation <span class="math">\\mathcal{R}^{\\delta}(\\mathrm{pp}) :=</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\langle (d, N, \\{z _ {i}, y _ {i} \\} _ {i = 1} ^ {N}, c); f \\rangle \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\exists g \\in \\mathbb {F} _ {&lt;   d} [ X ], \\Delta (f, g) &lt;   \\delta , \\\\ \\forall i \\in [ N ], g (z _ {i}) = y _ {i}, \\operatorname {C o m} (g) = c \\end{array} \\right.\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for which <span class="math">(P,V)</span> are both provided with degree bound <span class="math">d</span>, and a set of point-evaluation pairs <span class="math">\\{(z_i,y_i)\\}_{i = 1}^N</span> and commitment <span class="math">c\\in \\mathcal{C}</span>, while <span class="math">P</span> is also provided with a representation of <span class="math">f\\in \\mathbb{F}[X]</span>. Both <span class="math">P</span> and <span class="math">V</span> have access to an oracle for <span class="math">\\mathrm{Com}(\\cdot)</span>.</p>

    <h2 id="sec-28" class="text-2xl font-bold">4.2 Instantiation</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assume existence of an IOPP protocol FRI in the sense of Definition 9, and specify the LPC routine below. More specifically, since we are concerned with polynomial commitment schemes, we present the scheme based on the existence of FRI (Theorem 2 in [3]) for the prime field RS code family <span class="math">C = \\mathrm{RS}[\\mathbb{F},D,\\rho ]</span>, where <span class="math">\\rho = 2^{-\\mathcal{R}}</span> for some <span class="math">\\mathcal{R}\\in \\mathbb{N}</span>, <span class="math">\\mathcal{R} &amp;gt; 2</span> and $\\rho \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; 16<span class="math">. Note that we model the Com function as an oracle, so we do not deal with its security here. In this case, we set the public parameters to be </span>\\mathrm{pp} = (\\mathbb{F},D)$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The oracle provided here is to $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math">, which allows both parties to simulate FRI over the coset domain </span>D<span class="math"> by calculating the values of </span>q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math">. This is since both parties explicitly construct the interpolation polynomials and have access to </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math">. Hence, the verifier is above to check that </span>c = \\operatorname{Com}(q)<span class="math"> using oracle calls to </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math"> in order to simulate </span>q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}$. That the above satisfies the definition of an LPC scheme is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">REOSHIFT: Transparent SNARKs from List Polynomial Commitments</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Algorithm 1 LPC Routine 1: procedure LPC(pp,  <span class="math">d,N,\\{z_i,y_i\\}_{i = 1}^N,c;f)</span> 2: P and V define the interpolation polynomial  <span class="math">U(X)</span>  s.t.  <span class="math">\\forall i\\in [N],U(z_i) = y_i</span> 3: P and V define the quotient polynomial  <span class="math">q(X) = \\frac{f(X) - U(X)}{\\Pi_{i = 1}^{N}(X - z_{i})}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4: P and V return FRI(q, RS(  $\\mathbb{F},D,(d - N) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5: end procedure</p>

    <p class="text-gray-300">immediate from the security properties of FRI. This is illustrated in the theorem below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">THEOREM 4. The prime field  <span class="math">\\mathrm{RS}[\\mathbb{F},D,\\rho ]</span>  code family with rate  <span class="math">\\rho = 2^{-\\mathcal{R}},\\mathcal{R}\\geq 2,\\mathcal{R}\\in \\mathbb{N}</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math">  has an  </span>(\\epsilon ,k)<span class="math"> -LPC over the Hamming distance  </span>\\Delta<span class="math">  with  </span>\\epsilon = \\epsilon_{\\mathrm{FRI}}(\\delta)<span class="math">  soundness and  </span>k = k_{\\mathrm{FRI}}(\\delta)<span class="math">  rounds of interaction for all  </span>\\nu \\in (0,1 - \\sqrt{\\rho}),\\delta \\in (0,j_v^{[3 / 2]}(1 - \\rho)),N,d\\in \\mathbb{N}<span class="math">  for which  </span>\\log (n) - \\mathcal{R} = \\log (d - N)<span class="math">  and  </span>d - N &gt; 16<span class="math"> . The LPC IOP admits inputs of size  </span>n$  for which:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover Complexity:  <span class="math">p_{\\mathrm{FRI}}(n) + O(N \\log^3 N)</span> ,</li>

      <li>Verifier Complexity:  <span class="math">v_{\\mathrm{FRI}}(n) + O(N \\log^3 N)</span> ,</li>

    </ul>

    <p class="text-gray-300">where  <span class="math">p_{\\mathrm{FRI}}(n), v_{\\mathrm{FRI}}(n)</span>  the FRI prover and verifier complexities on input size  <span class="math">n</span> .</p>

    <p class="text-gray-300">Remark 1: We note that the above scheme retains verifier succinctness when  <span class="math">N = O(\\log d)</span> .</p>

    <p class="text-gray-300">The scheme introduced above works fine when dealing with "witness" polynomials  <span class="math">w(X)</span>  within our proof system, since we only require the existence (and not uniqueness) of such a polynomial. However, extra care should be taken outside of this regime, when working with "setup" polynomials  <span class="math">c(X)</span>  encoding the constraint system itself. In this case, we want to ensure that the openings provided by the prover are indeed the evaluations of the polynomial  <span class="math">c(X)</span>  itself and not of some polynomial  <span class="math">g \\in L_{\\delta}(c)</span> . The verifier can evaluate setup polynomial values themselves. However, this doesn't retain succinctness as evaluations require  <span class="math">O(d)</span>  computations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We leverage the fact that for a given setup polynomial  <span class="math">c(X)</span>  the list  <span class="math">L_{\\delta}(c)</span>  is computable by both the prover and verifier. They can hence find a distinguishing point  <span class="math">i</span>  at which  <span class="math">c(i)</span>  differs from the evaluations of all other polynomials  <span class="math">g \\in L_{\\delta}(c)</span> . This is naively achieved by using a list-decoding algorithm at the beginning to find all  <span class="math">g \\in L_{\\delta}(c)</span>  and then pick  <span class="math">i \\in \\mathbb{F}</span>  at random until  <span class="math">c(i) \\neq g(i) \\forall g \\in L_{\\delta}(c)</span> . This, however, has overhead polynomial in  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The key to our approach is that the procedure of enumerating all such elements and picking a suitable candidate is (1) fully transparent, and (2) executed and verified only once for every circuit. We thus add an offline phase that is performed only once at the beginning of the protocol. The task of the offline phase is to search for such a distinguishing point  <span class="math">i</span> . This allows us to strengthen the proof of knowledge guarantee for the LPC to imply that all evaluations come from the specific polynomial  <span class="math">c(X)</span> . Note that this is equivalent to the general proof of knowledge guarantee provided by polynomial commitment schemes. This preprocess phase is analogous to the work of the indexer in [19].</p>

    <p class="text-gray-300">DEFINITION 11. A PPT algorithm  <span class="math">\\mathcal{D}:\\mathbb{F}[X]\\to (\\mathbb{F}\\times \\mathbb{F})^{\\mu}</span>  is called a  <span class="math">\\mu</span> -dimensional  <span class="math">\\epsilon</span> -list distinguisher for some metric  <span class="math">\\Delta :\\mathbb{F}[X]\\times \\mathbb{F}[X]\\to [0,1]</span>  if  <span class="math">\\forall f\\in \\mathbb{F}[X],\\delta &amp;gt;0</span>  the following hold with probability  <span class="math">1 - \\epsilon (\\delta)</span>  over the randomness of  <span class="math">\\mathcal{D}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\exists i \\in [ \\mu ], \\forall g \\in L _ {\\delta} (f) \\backslash \\{f \\}, f (\\mathcal {D} (f) _ {i, 1}) \\neq g (\\mathcal {D} (f) _ {i, 1}), \\\\ \\forall i \\in [ \\mu ], f (\\mathcal {D} (f) _ {i, 1}) = \\mathcal {D} (f) _ {i, 2}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{D}(f)_{i,j}</span>  the  <span class="math">(i,j)</span> -th output element,  <span class="math">i\\in [\\mu ],j\\in \\{1,2\\}</span> .</p>

    <p class="text-gray-300">DEFINITION 12. An  <span class="math">(\\epsilon, k, \\eta)</span> -polynomial evaluation scheme for some metric  <span class="math">\\Delta</span>  is a tuple  <span class="math">\\Pi = (\\mathcal{D}, \\Sigma)</span>  where  <span class="math">\\Sigma = (P, V)</span>  an  <span class="math">(\\epsilon, k)</span> -LPC scheme and  <span class="math">\\mathcal{D}</span>  an  <span class="math">\\eta</span> -list distinguisher.</p>

    <p class="text-gray-300">THEOREM 5. For every  <span class="math">\\delta &amp;gt;0</span> , an  <span class="math">(\\epsilon ,k,\\eta)</span> -polynomial evaluation scheme admits an IOP with soundness  <span class="math">\\epsilon (\\delta) + \\eta (\\delta)</span>  and  <span class="math">k(\\delta)</span>  rounds of interaction for the relation  <span class="math">\\mathcal{R} :=</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\left(\\left(d, N, \\left\\{z _ {i}, y _ {i} \\right\\} _ {i = 1} ^ {N}\\right), c; f\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\forall i \\in [ N ], f \\left(z _ {i}\\right) = y _ {i}, \\operatorname {C o m} (f) = c \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The above theorem relies on a simple observation: if we have access to some distinguishing point-evaluation pair  <span class="math">(x, f(x))</span>  such that  <span class="math">f(x) \\neq g(x)</span>  for all  <span class="math">g \\in L_{\\delta} \\backslash \\{f\\}</span> , then adding  <span class="math">(x, f(x))</span>  to the openings performed by the LPC means that only  <span class="math">f</span>  is a valid witness. This process is done once during the setup of the LPC scheme and each instantiation of an LPC that requires binding security can then retrieve these points from the proving key.</p>

    <p class="text-gray-300">4.3.1 Instantiation. We now provide two instantiations of the PES based on different list distinguisher choices, and discuss the trade-offs between the two.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">List Decodability: The most obvious way to construct a distinguisher  <span class="math">\\mathcal{D}</span>  is by using a list-decoding algorithm for the given code to enumerate all  <span class="math">g\\in L_{\\delta}(f)</span> . By sampling random values  <span class="math">r\\in \\mathbb{F}</span>  and checking the required relation, this algorithm can be used to construct  <span class="math">\\mathcal{D}</span>  with no soundness error but high time complexity. Indeed, for  $\\delta &lt; 1 - (d - N - \\mu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  the algorithm takes  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3)<span class="math">  time, while in the case of equality between the two this can go up to  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{15})!$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Random Sampling: Due to the above efficiency considerations, we opt to add some soundness error to the distinguisher in exchange for a large increase in the efficiency of the protocol. We construct the distinguisher by sampling  <span class="math">\\mu</span>  random points and simply returning them along with their evaluations. Due to the Schwartz-Zippel lemma, there is a high chance that the random points will indeed separate  <span class="math">f</span>  from its corresponding  <span class="math">\\delta</span> -list. This takes time  <span class="math">O(\\mu \\cdot d)</span>  which, although linear with respect to  <span class="math">d</span> , is substantially faster than list-decoding when  $d \\sim</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">CLAIM 1. The random sampling algorithm defines an  <span class="math">\\eta</span> -list distinguisher  <span class="math">\\mathcal{D}</span>  taking time  <span class="math">O(\\mu \\cdot d)</span>  with soundness error:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\eta (\\delta) = \\left(\\frac {d \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L _ {\\delta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {\\mu}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We can use the LPC scheme constructed in the previous section along with the distinguisher defined above to put everything together in the following theorem.</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">THEOREM 6. The prime field  <span class="math">\\mathrm{RS}[\\mathbb{F},D,\\rho ]</span>  code family with rate  <span class="math">\\rho = 2^{-\\mathcal{R}},\\mathcal{R}\\geq 2,\\mathcal{R}\\in \\mathbb{N}</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math">  has an  </span>(\\epsilon ,k,\\eta)<span class="math"> -PES  </span>\\Pi = (\\mathcal{D},\\Sigma)<span class="math">  over the Hamming distance  </span>\\Delta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Sigma</span>  is an  <span class="math">(\\epsilon, k)</span> -LPC scheme with  <span class="math">\\epsilon = \\epsilon_{\\mathrm{FRI}}(\\delta)</span>  soundness and  <span class="math">k = k_{\\mathrm{FRI}}(\\delta)</span>  rounds of interaction for  <span class="math">\\nu \\in (0, 1 - \\sqrt{\\rho})</span> ,  <span class="math">\\delta \\in (0, J_{\\nu}^{[3/2]}(1 - \\rho))</span> ,  <span class="math">N, d, \\mu \\in \\mathbb{N}</span>  for which  <span class="math">\\log(n) - \\mathcal{R} = \\log(d - N - \\mu)</span>  and  <span class="math">d - N - \\mu &amp;gt; 16</span> .  <span class="math">\\Sigma</span>  also admits inputs of size  <span class="math">n</span>  for which:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover Complexity:  <span class="math">p_{\\mathrm{FRI}}(n) + O((N + \\mu)\\log^3 (N + \\mu))</span></li>

      <li>Verifier Complexity:  <span class="math">v_{\\mathrm{FRI}}(n) + O((N + \\mu)\\log^3 (N + \\mu))</span></li>

    </ul>

    <p class="text-gray-300">where  <span class="math">p_{\\mathrm{FRI}}(n), v_{\\mathrm{FRI}}(n)</span>  the FRI prover and verifier complexities on input size  <span class="math">n</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}</span>  is a  <span class="math">\\mu</span> -dimensional  <span class="math">\\eta</span> -list distinguiser for the RS  <span class="math">[\\mathbb{F}, D, \\rho]</span>  code family taking  <span class="math">O(\\mu \\cdot d)</span>  and soundness error:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\eta (\\delta) = \\left(\\frac {d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot (J _ {\\rho , \\nu} - 1)\\right) ^ {\\mu}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This provides the proof of knowledge guarantees needed for setup polynomials through direct application of Theorem 5.</p>

    <p class="text-gray-300">We follow the language and notation of PLONK [23].</p>

    <p class="text-gray-300">DEFINITION 13 (PLONK CONSTRAINT SYSTEM).  <span class="math">\\mathcal{L} = (\\mathcal{V},\\mathcal{Q})</span>  is a constraint system with  <span class="math">n</span>  gates and  <span class="math">m</span>  wires for which  <span class="math">n\\leq m\\leq 2n</span>  and where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  is of the form  <span class="math">\\mathcal{V} = (\\mathbf{a},\\mathbf{b},\\mathbf{c})</span> , where  <span class="math">\\mathbf{a},\\mathbf{b},\\mathbf{c}\\in [m]^n</span></li>

      <li><span class="math">Q</span>  is of the form</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {Q} = \\left(\\mathbf {q} _ {\\mathrm {L}}, \\mathbf {q} _ {\\mathrm {R}}, \\mathbf {q} _ {\\mathrm {O}}, \\mathbf {q} _ {\\mathrm {M}}, \\mathbf {q} _ {\\mathrm {C}}\\right) \\in \\left(\\mathbb {F} ^ {n}\\right) ^ {5},</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{q}_{\\mathbf{L}}, \\mathbf{q}_{\\mathbf{R}}, \\mathbf{q}_{\\mathbf{O}}, \\mathbf{q}_{\\mathbf{M}}, \\mathbf{q}_{\\mathbf{C}}</span>  are the "selector" vectors.</p>

    <p class="text-gray-300">Moreover,  <span class="math">\\mathbf{x} \\in \\mathbb{F}^m</span>  is said to satisfy  <span class="math">\\mathcal{L}</span>  if  <span class="math">\\forall i \\in [n]</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\mathbf {q} _ {\\mathrm {L}}\\right) _ {i} \\cdot \\mathbf {x} _ {\\mathrm {a} i} + \\left(\\mathbf {q} _ {\\mathrm {R}}\\right) _ {i} \\cdot \\mathbf {x} _ {\\mathrm {b} i} + \\left(\\mathbf {q} _ {\\mathrm {O}}\\right) _ {i} \\cdot \\mathbf {x} _ {\\mathrm {c} i} + \\\\ + \\left(\\mathbf {q} _ {\\mathbf {M}}\\right) _ {i} \\cdot \\left(\\mathbf {x} _ {\\mathbf {a} i} \\cdot \\mathbf {x} _ {\\mathbf {b} i}\\right) + \\left(\\mathbf {q} _ {\\mathbf {C}}\\right) _ {i} = 0. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">To define a relation based on  <span class="math">\\mathcal{L}</span> , we extend it to include a positive integer  <span class="math">l \\leq m</span> , and subset  <span class="math">I = [I] \\subseteq [m]</span>  of "public inputs". We can naturally set  <span class="math">\\mathcal{R}_{\\mathcal{L}}</span>  as the set of pairs  <span class="math">(x, \\omega)</span>  with  <span class="math">x \\in \\mathbb{F}^l</span> ,  <span class="math">\\omega \\in \\mathbb{F}^{m - l}</span>  such that  <span class="math">\\mathbf{x} := (x, \\omega)</span>  satisfies  <span class="math">\\mathcal{L}</span> . We say  <span class="math">\\mathcal{L}</span>  is 'prepared' for  <span class="math">l</span>  public inputs if  <span class="math">\\forall i \\in [l]</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} _ {\\mathrm {i}} = i, \\left(\\mathbf {q} _ {\\mathrm {L}}\\right) _ {i} = 1, \\left(\\mathbf {q} _ {\\mathrm {M}}\\right) _ {i} = \\left(\\mathbf {q} _ {\\mathrm {R}}\\right) _ {i} = \\left(\\mathbf {q} _ {\\mathrm {O}}\\right) _ {i} = \\left(\\mathbf {q} _ {\\mathrm {C}}\\right) _ {i} = 0.</span></div>

    <p class="text-gray-300">From here on, we will assume that the constraint system is given in prepared form.</p>

    <p class="text-gray-300">In order to reformulate this constraint system in polynomial terms, we require some additional ingredients. Let  <span class="math">g \\in \\mathbb{F}^<em></span>  be an element of order  <span class="math">n + 1</span> ,  <span class="math">D = \\langle g \\rangle \\subseteq \\mathbb{F}^</em></span>  the cyclic subgroup generated by  <span class="math">g</span> , and  <span class="math">D^<em> := D / \\{e\\}</span>  where  <span class="math">e = g^0</span>  the identity. For  <span class="math">i \\in [n + 1]</span> , denote by  <span class="math">L_i(X)</span>  the element of  <span class="math">\\mathbb{F}_{\\leq n}[X]</span>  with  <span class="math">L_i(g^i) = 1</span>  and  <span class="math">L_i(a) = 0</span>  for all  <span class="math">a \\in D</span>  different to  <span class="math">g^i</span> . By construction,  <span class="math">\\{L_i(X)\\}_{i=1}^{n+1}</span>  form a Lagrange basis for  <span class="math">D</span> . Finally, we set  <span class="math">Z(X) := \\prod_{a \\in D^</em>} (X - a) \\in \\mathbb{F}_{\\leq n}[X]</span>  to be a domain polynomial for  <span class="math">D^<em></span> , i.e. zero only on  <span class="math">D^</em></span> .</p>

    <p class="text-gray-300">DEFINITION 14 (DOMAIN PERMUTATIONS). For sets of  <span class="math">k</span>  polynomials  <span class="math">\\{f_i\\}_{i=1}^k, \\{h_i\\}_{i=1}^k</span>  for which  <span class="math">h_i, f_i \\in \\mathbb{F}[X]</span>  and permutation  <span class="math">\\sigma: [kn] \\to [kn]</span> , we say that the set  <span class="math">(h_1, \\dots, h_k) = \\sigma(f_1, \\dots, f_k)</span>  if, for</p>

    <p class="text-gray-300">all  <span class="math">l \\in [kn]</span> , the sequences  <span class="math">\\left(f_{(1)}, \\ldots, f_{(kn)}\\right), \\left(h_{(1)}, \\ldots, h_{(kn)}\\right) \\in \\mathbb{F}^{kn}</span> , defined as:</p>

    <div class="my-4 text-center"><span class="math-block">f _ {((j - 1) \\cdot n + i)} := f _ {j} (g ^ {i}), h _ {((j - 1) \\cdot n + i)} := h _ {j} (g ^ {i}),</span></div>

    <p class="text-gray-300">for each  <span class="math">j \\in [k], i \\in [n]</span> , satisfy  <span class="math">h_{(I)} = f_{(\\sigma(I))}</span> .</p>

    <p class="text-gray-300">DEFINITION 15. Let  <span class="math">\\mathcal{T} = \\{T_i\\}_{i=1}^s</span>  be a partition of  <span class="math">[kn]</span>  into  <span class="math">s</span>  disjoint blocks, where  <span class="math">k, n, s \\in \\mathbb{N}</span> . We say that  <span class="math">\\{f_i\\}_{i=1}^k \\in \\mathbb{F}[X]</span>  copy-satisfies  <span class="math">\\mathcal{T}</span>  if, when defining  <span class="math">(f_{(1)}, \\ldots, f_{(kn)}) \\in \\mathbb{F}^{kn}</span>  as above, we have  <span class="math">f_{(l)} = f_{(l&#x27;)}</span>  whenever  <span class="math">\\exists i</span>  s.t.  <span class="math">l, l&#x27; \\in T_i</span> .</p>

    <p class="text-gray-300">We define a permutation  <span class="math">\\sigma(\\mathcal{T})</span>  on  <span class="math">[kn]</span>  such that for each block  <span class="math">T_i</span>  of  <span class="math">\\mathcal{T}</span> ,  <span class="math">\\sigma(\\mathcal{T})</span>  contains a cycle only going over all the elements of  <span class="math">T_i</span> . Many possibilities exist: for example, we can rearrange elements in the cycles corresponding to  <span class="math">T_i</span> , or  <span class="math">\\sigma(\\mathcal{T})</span>  can be chosen arbitrarily from the set of all valid permutations. It is simple to check that  <span class="math">(f_1, \\ldots, f_k)</span>  copy-satisfies  <span class="math">\\mathcal{T}</span>  if and only if  <span class="math">(f_1, \\ldots, f_k) = \\sigma(f_1, \\ldots, f_k)</span> . We can thus equivalently say that  <span class="math">(f_1, \\ldots, f_k)</span>  copy-satisfy  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">DEFINITION 16. Fix domain  <span class="math">D^{*}</span>  and size parameter  <span class="math">n \\in \\mathbb{N}</span> . The constraint system  <span class="math">\\mathcal{L}&#x27;</span>  is defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {L} ^ {\\prime} := \\left(\\mathbf {q} _ {\\mathrm {L}}, \\mathbf {q} _ {\\mathrm {R}}, \\mathbf {q} _ {\\mathrm {O}}, \\mathbf {q} _ {\\mathrm {M}}, \\mathbf {q} _ {\\mathrm {C}}, \\sigma , n\\right),</span></div>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{q}_{\\mathbf{L}}, \\mathbf{q}_{\\mathbf{R}}, \\mathbf{q}_{\\mathbf{O}}, \\mathbf{q}_{\\mathbf{M}}, \\mathbf{q}_{\\mathbf{C}} \\in \\mathbb{F}[X]</span>  the selector polynomials,</li>

      <li><span class="math">\\sigma : [3n] \\to [3n]</span>  a permutation over  <span class="math">3n</span>  elements.</li>

    </ul>

    <p class="text-gray-300">The relation  <span class="math">\\mathcal{R}_{\\mathcal{L}&#x27;}</span>  for  <span class="math">\\mathcal{L}&#x27;</span>  is defined as the set</p>

    <div class="my-4 text-center"><span class="math-block">(x, \\omega) := (\\mathbf {P I} (X), \\langle \\mathbf {f} _ {\\mathbf {L}} (X), \\mathbf {f} _ {\\mathbf {R}} (X), \\mathbf {f} _ {\\mathbf {O}} (X) \\rangle) \\in \\mathbb {F} [ X ] \\times (\\mathbb {F} [ X ]) ^ {3},</span></div>

    <p class="text-gray-300">with the following properties:</p>

    <p class="text-gray-300">(1)  <span class="math">\\mathbf{f}_{\\mathbf{L}}(X),\\mathbf{f}_{\\mathbf{R}}(X),\\mathbf{f}_{\\mathbf{O}}(X)</span>  copy-satisfy  <span class="math">\\sigma</span> (2)  <span class="math">\\forall a\\in D^{*}</span>  it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {q} _ {\\mathbf {L}} \\cdot \\mathbf {f} _ {\\mathbf {L}} + \\mathbf {q} _ {\\mathbf {R}} \\cdot \\mathbf {f} _ {\\mathbf {R}} + \\mathbf {q} _ {\\mathbf {O}} \\cdot \\mathbf {f} _ {\\mathbf {O}} + \\mathbf {q} _ {\\mathbf {M}} \\cdot \\mathbf {f} _ {\\mathbf {L}} \\cdot \\mathbf {f} _ {\\mathbf {R}} + (\\mathbf {q} _ {\\mathbf {C}} + \\mathbf {P I}) = 0.</span></div>

    <p class="text-gray-300">For completeness we also provide a formal statement of the equivalence between the two constraint systems, whose proof can be found in the appendix.  <span class="math">\\mathbf{PI}(X)</span>  is the public input polynomial and encodes public data that is used to define the predicate of choice, while  <span class="math">\\mathbf{f}_{\\mathbf{L}}(X),\\mathbf{f}_{\\mathbf{R}}(X),\\mathbf{f}_{\\mathbf{O}}(X)</span>  are the left, right and output wire polynomials respectively and encode prover-only private data.</p>

    <p class="text-gray-300">LEMMA 1. The constraint systems proposed in Definition 13 and Definition 16 are equivalent.</p>

    <p class="text-gray-300">Remark: Note that the degrees of  <span class="math">\\mathbf{f}_{\\mathbf{L}}, \\mathbf{f}_{\\mathbf{R}}, \\mathbf{f}_{\\mathbf{C}}</span>  are  <span class="math">n - 1</span> , where  <span class="math">n</span>  is the size of  <span class="math">\\mathcal{L}</span> . However in REDSHIFT this is relaxed to some degree  <span class="math">k &amp;gt; n</span>  to attain zero-knowledge.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{L}&#x27; = (\\mathbf{q}_{\\mathbf{L}}, \\mathbf{q}_{\\mathbf{R}}, \\mathbf{q}_{\\mathbf{O}}, \\mathbf{q}_{\\mathbf{M}}, \\mathbf{q}_{\\mathbf{C}}, \\sigma, n)</span>  be the constraint system in question. Define  <span class="math">k_{1}, k_{2}, k_{3} \\in \\mathbb{F}^{<em>}</span>  to be representations of different cosets in  <span class="math">\\mathbb{F}^{</em>} \\backslash D</span> , with  <span class="math">k_{1} = e</span>  set as the identity. Let  <span class="math">\\tau</span>  be the bijection between the sets  <span class="math">P_{1} = [3n]</span>  and  <span class="math">P_{2} = D^{<em>} \\cup k_{2}D^{</em>} \\cup k_{3}D^{*}</span>  defined by:</p>

    <div class="my-4 text-center"><span class="math-block">\\tau [ n \\cdot (j - 1) + i ] = k _ {j} g ^ {i}, i \\in [ n ], j \\in [ 3 ].</span></div>

    <p class="text-gray-300">Since  <span class="math">\\sigma</span>  is a permutation on  <span class="math">P_{1}</span> ,  <span class="math">\\sigma&#x27; = \\tau \\circ \\sigma \\circ \\tau^{-1}</span>  is a permutation on  <span class="math">P_{2}</span> . Define  <span class="math">\\{S_{i d_{i}}(X)\\}_{i=1}^{3}, \\{S_{\\sigma_{j}}(X)\\}_{j=1}^{3}</span>  each of degree at most  <span class="math">n</span>  as the set of permutation polynomials as follows:</p>

    <p class="text-gray-300">REDSHIFT: Transparent SNARKs from List Polynomial Commitments</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">(1)  <span class="math">S_{id_j}(X) = k_jX</span>  for  <span class="math">j\\in [3]</span> (2)  <span class="math">S_{\\sigma_j}(g^i) = \\sigma &#x27;(k_jg^i)</span>  for  <span class="math">i\\in [n],j\\in [3]</span></p>

    <p class="text-gray-300">These will be used as part of the setup polynomials to define the problem instance.</p>

    <p class="text-gray-300">Setup &amp; Witness Polynomials: We can now draw the link between the "setup" and "witness" polynomials of the previous sections with their concrete definitions in the instantiation of REDSHIFT. The selector polynomials  <span class="math">\\mathbf{q_L}, \\mathbf{q_R}, \\mathbf{q_O}, \\mathbf{q_M}, \\mathbf{q_C}</span> , permutation polynomials  <span class="math">\\{S_{id_j}\\}_{i \\in [3]}</span> ,  <span class="math">\\{S_{\\sigma_j}\\}_{j \\in [3]}</span>  and Lagrange-basis polynomials  <span class="math">\\{L_i\\}_{i \\in [n+1]}</span>  play the role of "setup" polynomials. Moreover, the wire polynomials  <span class="math">\\mathbf{f_L}, \\mathbf{f_R}, \\mathbf{f_O}</span>  form the set of "witness" polynomials. This choice makes intuitive sense: the former fully specify the relation in question and hence need to be unique in order to prevent malleability in the proof of knowledge guarantees. The latter (which tend to be much larger in most practical deployments) however, do not require uniqueness guarantees.</p>

    <p class="text-gray-300">We are now ready to specify the REDSHIFT protocol. At the interactive level, it is most similar to the DEEP-ALI protocol, but for the PLONK constraint system. We instantiate the distinguisher oracle  <span class="math">\\mathcal{O}^{\\mathcal{D}}</span>  queries as evaluations by an indexer algorithm  <span class="math">\\mathcal{I}</span>  that receives a low-degree polynomial input  <span class="math">f</span>  and outputs  <span class="math">\\mu</span>  separation points along with their evaluations  <span class="math">\\{x_i, f(x_i)\\}_{i=1}^\\mu</span> . We can implement the random sampling distinguisher in the non-interactive setting using  <span class="math">n_c \\cdot \\mu \\cdot n</span>  queries (where  <span class="math">n_c</span>  the number of constraint polynomials), and provide the set of points as input to the IOP for the PLONK proof system (c.f. Section 7 in [23]).</p>

    <p class="text-gray-300">In the interests of modularity and ease of exposition, we make use of an  <span class="math">(\\epsilon, k)</span> -list polynomial commitment scheme  <span class="math">LPC</span>  while simulating an  <span class="math">(\\epsilon, k, \\eta)</span> -polynomial evaluation scheme  <span class="math">PES = (\\mathcal{D}, LPC)</span>  with access to a  <span class="math">\\mu</span> -dimensional  <span class="math">\\eta</span> -distinguisher  <span class="math">\\mathcal{D}</span> . The idea is to replace all instances of commitment to some low-degree polynomial, which is required for the knowledge soundness guarantees of the proof system, to commitment using the LPC and PES schemes above. These will be implemented using the FRI protocol, but at the maximal levels of  <span class="math">\\delta</span>  in order to achieve improvements in proof size. We identify two types of polynomials with differing knowledge guarantee requirements. These are the witness and setup polynomials mentioned above. In the first, we only require the existence of some low degree polynomial to exist, while in the latter the prover needs to know the specific polynomial they are providing commitments to.</p>

    <p class="text-gray-300">In the construction below, we assume that  <span class="math">\\{S_{id_j}\\}_{i\\in [3]},\\{S_{\\sigma_j}\\}_{j\\in [3]}</span> <span class="math">\\{L_i\\}_{i\\in [n + 1]}</span> ,  <span class="math">\\mathbf{q_L},\\mathbf{q_R},\\mathbf{q_O},\\mathbf{q_M},\\mathbf{q_C}\\in \\mathrm{pp}</span> , have been precomputed over  <span class="math">D^{*}</span>  and can be instantaneously accessed through commitments provided by an oracle along with a representation of the public input polynomial  <span class="math">\\mathbf{PI}(X)</span>  given to the verifier. To highlight the above difference, we explicitly instantiate the commitments that need to be sent at each step and show how these are used in the PES and LPC schemes. In the IOP formalism, this is equivalent to sending the respective polynomials to a trusted intermediary  <span class="math">\\mathcal{I}</span> .</p>

    <p class="text-gray-300">Completeness holds because for honest provers the  <span class="math">F_{i}</span>  are identically zero on domain  <span class="math">D^{*}</span> , which means that all the  <span class="math">F_{i}(X)</span>  are divisible by  <span class="math">Z(X)</span>  in the ring  <span class="math">\\mathbb{P}[X]</span> , hence so is their linear combination  <span class="math">F(X) = \\sum_{i=1}^{6} a_{i} F_{i}(X)</span> . Note that the  <span class="math">\\{F_{i}\\}_{i \\in [5]}</span>  are responsible</p>

    <p class="text-gray-300">Algorithm 2 RedShift Routine 1: procedure RedShift(pp, PI, n, k, N; fL, fR, fO) 2: P chooses masking polynomials h1, h2, h3 ∈R ⊂ K[X]. 3: P defines masking witness polynomials: f1(X) := fL(X) + h1(X)Z(X), f2(X) := fR(X) + h2(X)Z(X), f3(X) := fO(X) + h3(X)Z(X), and sends commitments cm_i, i ∈ [3] for them to V. 4: V sends random β, γ ∈ P to P. 5: For j ∈ [3], P computes p_j := fj + β · Si_dj + γ and q_j = fj + β · S_σ_j + γ. P then defines p'(X) and q'(X) by: p'(X) = ∏j∈[3] p_j(X), q'(X) = ∏j∈[3] q_j(X). 6: P computes P, Q ∈ P&lt;n+1[X] such that P(g) = Q(g) = 1 and for i ∈ [n+1] \\ {1}: P(g^i) = ∏1≤j&lt;i p'(g^j), Q(g^i) = ∏1≤j&lt;i q'(g^j), and sends commitments cm_4, cm_5 of P and Q to V. 7: V sends random a_1, ..., a_6 ∈ P to P. 8: P defines the following polynomials: · F1(X) = L1(X)(P(X) - 1) · F2(X) = L1(X)(Q(X) - 1) · F3(X) = P(X)p'(X) - P(X · g) · F4(X) = Q(X)q'(X) - Q(X · g) · F5(X) = L_n(X)(P(X · g) - Q(X · g)) · F6(X) = qL(X)f_L(X) + qR(X)f_R(X) + qO(X)f_O(X) + qM(X)f_L(X)f_R(X) + (qC(X) + PI(X)) 9: P defines F = ∑i=16^6 a_i F_i and computes T(X) = F(X)/Z(X), sending V a commitment cm_6 to T. 10: V sends P a random evaluation point y_m ∈ P\\D, m ∈ [N]. 11: P responds with N sets of points, where m ∈ [N]: T(y_m), P(y_m), Q(y_m), {f_i(y_m)}_i=1^3, {S_id_i(y_m)}_i=1^3, {S_σ_i(y_m)}_i=1^3, and q_i(y_m) for j ∈ {L, R, O, M, C} := J. 12: P and V engage in sub-protocols, outputting 0 if any fail: PES(pp, n+1, N, {(y_m, q_i(y_m))}_m∈[N], cm_q_i; q_i), j ∈ J, PES(pp, n+1, N, {(y_m, S_id_j(y_m))}_m∈[N], cm_id_j; S_id_j), j ∈ [3], PES(pp, n+1, N, {(y_m, S_σ_j(y_m))}_l∈[N], cm_σ_j; S_σ_j), j ∈ [3], LPC(pp, n+1, N, {(y_m, f_i(y_m))}_m∈[N], cm_i; f_i), i ∈ [3], LPC(pp, n+1, 2N, {(y_m, P(y_m)), (y_m · g, P(y_m · g))}_m∈[N], cm_4; P), LPC(pp, n+1, 2N, {(y_m, Q(y_m)), (y_m · g, Q(y_m · g))}_m∈[N], cm_5; Q), LPC(pp, 3n+1, N, {(y_m, T(y_m))}_m∈[N], cm_6; T). 13: Using the queried values above, Vm ∈ [N] V computes {F_i(y_m)}_i∈[6], outputting 1 if the following holds: ∑i=1^6 a_i F_i(y_m) = Z(y_m)T(y_m). 14: end procedure</p>

    <p class="text-gray-300">for checking the copy-satisfiability of the witness polynomials. This is directly equivalent to the completeness argument in PLONK.</p>

    <p class="text-gray-300">We also briefly explain the intuition behind the  <span class="math">S_{id_j}</span>  and  <span class="math">S_{\\sigma_j}</span>  polynomials:  <span class="math">S_{id_j}</span>  is only required to map  <span class="math">D</span>  to the disjoint sets  <span class="math">P_1, P_2, P_3</span> .  <span class="math">S_{\\sigma_j}</span>  should then map to the same set  <span class="math">P = P_1 \\cup P_2 \\cup P_3</span>  but in a "permuted" fashion. We construct a map  <span class="math">\\tau</span>  for permutation  <span class="math">\\sigma</span></p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov</p>

    <p class="text-gray-300">from domain  <span class="math">[n]</span>  to  <span class="math">P</span> . The simplest way to define  <span class="math">S_{id_k}</span>  is to map  <span class="math">[n]</span>  to  <span class="math">[1, \\dots, n]</span> ,  <span class="math">[n + 1, \\dots, 2n]</span> ,  <span class="math">[2n + 1, \\dots, 3n]</span>  respectively, in this case there is no need to apply the map  <span class="math">\\tau</span>  as then there is no need for domain translation ( <span class="math">P = [n]</span> ). The problem is that all of the  <span class="math">S_{id_j}</span>  polynomials will be of degree  <span class="math">n</span>  in general. We construct  <span class="math">S_{id_j}</span>  so as to be of minimal possible degree 1, so it is easy for the verifier to calculate evaluations of those polynomials by themselves without requiring the usage of the (more expensive) evaluation procedures. This optimization is taken from [23].</p>

    <p class="text-gray-300">We opt for sampling  <span class="math">y</span>  outside of the domain  <span class="math">D</span>  in order to achieve perfect-zero knowledge guarantees instead of statistical.  <span class="math">N</span>  here denotes the number of random challenge points sampled and is set to  <span class="math">N = 1</span>  for our implementation. Finally, due to the restrictions on the degree it may be necessary to split  <span class="math">T</span>  into separate polynomials  <span class="math">\\{T_0, T_1, T_2\\}</span>  and commit to them independently. This and other optimizations are further discussed in the appendix, as is the formal analysis of the security and zero-knowledge properties of the protocol. We end with a formal statement capturing the security properties of REDSHIFT.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">THEOREM 7. The prime field RS  <span class="math">[\\mathbb{F},D,\\rho]</span>  code family with rate  <span class="math">\\rho = 2^{-\\mathcal{R}},\\mathcal{R}\\geq 2,\\mathcal{R}\\in \\mathbb{N}</span>  and  $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n + 1<span class="math">  admits an IOP for the constraint system  </span>S<span class="math">  described in Definition 13, where  </span>n<span class="math">  the size of the instance in  </span>S<span class="math">  and  </span>N<span class="math">  a repetition parameter. This IOP achieves perfect completeness, perfect zero-knowledge, and  </span>\\forall \\nu \\in (0,1 - \\sqrt{\\rho}),\\delta \\in (0,J_{\\nu}^{[3 / 2]}(1 - \\rho))$  has round-by-round knowledge soundness:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\pi}(\\delta)\\leq \\max \\left(\\epsilon_{\\mathrm{FRI}}(\\delta),\\epsilon_{\\mathrm{IOP}}^{N},\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)<span class="math">  where  </span>\\epsilon_{\\mathrm{IOP}}\\coloneqq (J_{\\rho ,\\nu})^6\\cdot \\frac{4n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\backslash D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above IOP is instantiated as a Non-Interactive Random Oracle Proof (NIROP) using the "CS-proof" technique to compile the oracles to the constraint functions. More specifically, this assumes the existence of a Random Oracle (RO) for the hash function  <span class="math">\\mathcal{H}:\\mathbb{F}\\times \\mathbb{F}\\to \\mathbb{F}</span>  [7] and constructs  <span class="math">\\mathrm{Com}(f)</span>  as the root  <span class="math">c</span>  of a Merkle tree where the leaves form the evaluations of  <span class="math">f</span>  on  <span class="math">D</span> . The RO is not required, as correlation-intractable hash functions have been shown to suffice (see [16]). In the non-interactive setting, the prover will provide the verifier with a Merkle authentication path to some  <span class="math">f(i)</span>  upon a query for  <span class="math">i\\in D</span>  to the oracle for  <span class="math">f</span> . Note that this adds  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  overhead to the protocol for each query.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The various components of REDSHIFT can now be put together in order to arrive at security guarantees of a functional implementation. By modularity of the above approach, it is possible to analyze the security guarantees of the system based on different choices for the rate, distinguisher, and LPC scheme. The starting point for this is the soundness bound of Theorem 7. Since this depends on the list decodability of the RS codes, the analysis can be split into two axes: based on Theorem 1 and on Conjecture 1, each of which gives different bounds on protocol soundness. We analyze the above based on a changing rate parameter  <span class="math">\\rho</span>  at a given security level, and look the total number of queries that need to be executed by the FRI protocol to achieve this. In the analysis below, we work with a field of size  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 256<span class="math">  bits and aim for 80 bit security. First we focus on the contribution from the list-decoding bound:  </span>J_{\\rho,\\nu}^{\\mathrm{g}}\\frac{4n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}/D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> : note the exponent of 8 instead of 6 due to splitting  </span>T$  into 3 smaller</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomials. In the syntax of Theorem 1, a choice of  $\\nu =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1 / 20}<span class="math">  provides a list size of  </span>\\frac{1}{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1 / 20}\\rho^{-1 / 2}<span class="math"> . For our choice of field size, this yields an error contribution on the order of  </span>2^{-128}<span class="math"> . Now we focus on how such a choice of  </span>\\nu \\neq 0<span class="math">  will affect the soundness of FRI. By picking  </span>\\rho = 1 / 16<span class="math">  we get the following contribution to the FRI soundness error for  </span>\\delta &lt; J_{\\nu}^{[3 / 2]}(1 - \\rho)$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p(\\nu ,\\rho) = \\Bigl (1 - \\min \\left\\{\\delta_0,J_\\nu^{[3 / 2]}(1 - \\rho)\\right\\} +\\nu \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Bigr).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A smaller such value allows for fewer queries for a given level of soundness, shrinking proof size in the non-interactive setting. In the case of  <span class="math">\\nu = 0</span> , we have  <span class="math">p(0,1/16) = 1/2</span> . For domain size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{32}<span class="math">  (which equates to a degree bound  </span>d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n + 1 = 2^{28}<span class="math"> ) we have that  </span>p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/20}, 1/16) \\sim 0.504<span class="math"> . For comparison purposes, if we instead use  </span>\\rho = 1/32<span class="math">  we get  </span>p(0,1/32) \\sim 0.421<span class="math">  and  </span>p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1/20}, 1/32) \\sim 0.425$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are now ready to look at the effect of changing  <span class="math">\\delta</span>  on the total number of queries required to achieve a constant security level for the overall protocol. We fix a rate of  <span class="math">\\rho = 1/64</span>  with  <span class="math">\\nu = 0</span>  for simplicity and provide the total query number required to achieve an 80 bit security level for three regimes for  <span class="math">\\delta</span> : (1) unique decoding radius  <span class="math">\\delta = \\delta_0</span> , (2)  <span class="math">\\delta</span>  within the 'one-and-a-half' Johnson bound (used in FRI [10]), and (3)  <span class="math">\\delta</span>  within the Johnson bound (used in DEEP-FRI [9]). Note that (1) denotes the worst-case error and is provided as a reference for the relative efficiency of the two LPC instantiations. We note a  <span class="math">51\\%</span>  reduction in the query number at this security level in using FRI, while DEEP-FRI achieves a  <span class="math">67\\%</span>  reduction at rate  <span class="math">\\rho = 1/64</span> . As rate increases, this improvement is less pronounced; however, we still get a  <span class="math">32\\%</span>  and  <span class="math">55\\%</span>  improvement in query complexity for the two respective instantiations even at  <span class="math">\\rho = 1/16</span> . This demonstrates concrete efficiency improvements to the underlying proof even with small rate deviations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Subsequent work [5] has demonstrated that for FRI instances over large fields we can do strictly better. If  $q &gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2<span class="math"> , the maximal  </span>\\delta<span class="math">  for which FRI is sound is actually equal to the Johnson bound  </span>J_{\\nu}(1 - \\rho)<span class="math">  instead of  </span>J_{\\nu}^{[3/2]}(1 - \\rho)<span class="math"> . In practice, this gives us the same soundness error for FRI and DEEP-FRI since the number of queries performed dominates the error contribution. Finally, by assuming Conjecture 1 we can do even better:  </span>\\delta<span class="math">  is pushed beyond the Johnson bound to  </span>1 - \\rho$  and, due to the constant list size assumption, the soundness of FRI and DEEP-FRI persists in this larger range. Note, however, that going beyond the Johnson bound comes with a loss of knowledge security: we cannot use the Sudan list-decoding algorithm to extract a witness, so any knowledge claim would have to be non-extractable in this setting.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: LPC Instantiation Comparisons.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">δ Bound</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p Bound (ν = 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Query Number</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1/64</td>

            <td class="px-3 py-2 border-b border-gray-700">1/32</td>

            <td class="px-3 py-2 border-b border-gray-700">1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Unique Decoding</td>

            <td class="px-3 py-2 border-b border-gray-700">(1 - ρ)/2</td>

            <td class="px-3 py-2 border-b border-gray-700">(1 + ρ)/2</td>

            <td class="px-3 py-2 border-b border-gray-700">82</td>

            <td class="px-3 py-2 border-b border-gray-700">84</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FRI [10]</td>

            <td class="px-3 py-2 border-b border-gray-700">Jν[3/2] (1 - ρ)</td>

            <td class="px-3 py-2 border-b border-gray-700">√ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FRI with q ></td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">2 [5]</td>

            <td class="px-3 py-2 border-b border-gray-700">Jν(1 - ρ)</td>

            <td class="px-3 py-2 border-b border-gray-700">√ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DEEP-FRI [9]</td>

            <td class="px-3 py-2 border-b border-gray-700">Jν(1 - ρ)</td>

            <td class="px-3 py-2 border-b border-gray-700">√ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FRI with Conjecture 1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 - ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">REDSHIFT: Transparent SNARKs from List Polynomial Commitments</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">We instantiate REDSHIFT with  <span class="math">r = 576460752303423505</span> ,  <span class="math">q = r \\cdot 2^{192} + 1</span>  which is a Proth prime and use  <span class="math">\\rho = 1/16</span> . Oracles were instantiated as Merkle trees using the Blake2s hashing algorithm. The PES was instantiated using the random sampling approach, where a random point was sampled using Fiat-Shamir: i.e. by placing all individual root hashes of the oracles to the setup polynomials into the transcript. Circuit sizes were chosen so as to set  <span class="math">n + 1 = 2^k</span>  which, in the case of REDSHIFT, implies a degree bound  <span class="math">d = n + 1</span>  for FRI. All implementations use a certain degree of precomputation: we precompute the low degree extensions of setup polynomials and the Merkle trees of the setup polynomial oracles.</p>

    <p class="text-gray-300">The soundness error due to FRI depends on the total number of queries performed. This does not change the proof generation time and only affects proof size and verification. We follow the approach in Section 6 in order to set these parameters, targeting an 80-bit security level. We note that the final soundness error is dominated by the FRI error, while the size contribution is dominated by the total number of queries performed. We used an Apple MacBook Pro 18.2 with an M1 Max 10-core processor and 64 GB RAM to record proof generation times, verification times and proof sizes for different predicate sizes presented in Fig. 1</p>

    <p class="text-gray-300">The verification times and proof sizes provided rely on Conjecture 1. If we remove this assumption, we need to double the proof sizes (and verification times) but the proof generation times would remain unchanged. This is because FRI operates over a large enough field that soundness holds for  <span class="math">\\delta \\leq J_{\\nu}(1 - \\rho)</span> . Table 2 includes calculations for projected proof sizes at different security levels and rates. We present expected numbers for three different scenarios: (1) the current implementation, (2) the implementation after optimization (see Appendix F), and (3) the optimized proof system assuming Conjecture 1 also holds.</p>

    <p class="text-gray-300">Our empirical results cannot be directly compared to other transparent proof systems such as [19], [20], [6], [41],[42], as the underlying constraint systems differ (all use R1CS, except [42]) and thus predicate sizes (number of gates) don't exactly capture the same complexity across prototypes. Unlike all other approaches, the PLONK constraint system also allows for 'custom' gates, which means that it can be further modified to be more efficient at expressing specific types of circuits by using fewer circuit-specific gates. This makes a precise comparison between approaches difficult.</p>

    <p class="text-gray-300">Even so, certain comparative observations can be made. Firstly, proof generation times are competitive with state-of-the-art systems, such as AURORA and FRACTAL that achieve a performance of  <span class="math">\\sim 200</span>  seconds on predicates of size  <span class="math">2^{20}</span>  at 128-bit security. Note that for us proof generation is only influenced by the rate parameter  <span class="math">\\rho</span> , which we fix at  <span class="math">\\rho = 1/16</span>  in Fig. 1 for all considered security levels to achieve 35 second proving time for size  <span class="math">2^{20}</span>  circuits. Our results are most comparable with VIRGO [42] at  <span class="math">\\sim 10</span>  seconds.</p>

    <p class="text-gray-300">Verification times for 80-bit security stay at around  <span class="math">3 - 6\\mathrm{ms}</span>  for circuit sizes up to  <span class="math">2^{20}</span> , clearly outperforming AURORA ( <span class="math">\\sim 4</span>  seconds for the same). At 128-bit security, a linear scaling of verification time (due to the linear increase in the number of queries) gives around  <span class="math">\\sim 9\\mathrm{ms}</span> . This matches the performance of FRACTAL ( <span class="math">&amp;lt; 10\\mathrm{ms}</span>  at 128-bit security) and VIRGO ( <span class="math">\\sim 12\\mathrm{ms}</span>  at 100-bit security). Note that verification time is directly connected to proof size through the</p>

    <p class="text-gray-300">number of queries verified, so any corresponding improvements to proof sizes will affect verification proportionately.</p>

    <p class="text-gray-300">The data clearly shows a logarithmic relationship between proof and predicate sizes, which is the biggest drawback of the current scheme. To this end, we propose optimizations (specified in Appendix F) of how the Merkle tree represents data and query calls to decrease proof size (and verification times) by about two orders of magnitude  <span class="math">(\\sim 4\\times)</span> . In this case, projected proof sizes are still larger  <span class="math">(\\sim 300\\mathrm{kB})</span>  than those of both AURORA and FRACTAL  <span class="math">(\\sim 150\\mathrm{kB})</span>  for a circuit of  <span class="math">2^{20}</span>  gates at 128-bit security but comparable to VIRGO  <span class="math">(\\sim 200\\mathrm{kB})</span>  at 100-bit security. Note that this issue is specific to transparent systems: trusted proof systems like [28] have size  <span class="math">&amp;lt; 1\\mathrm{kB}</span>  proofs for all circuits.</p>

    <p class="text-gray-300">Table 2: Projected Proof Sizes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security (Bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rate (-log ρ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Circuit Size (log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Unoptimized</td>

            <td class="px-3 py-2 border-b border-gray-700">Optimized</td>

            <td class="px-3 py-2 border-b border-gray-700">Conjectured</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">597</td>

            <td class="px-3 py-2 border-b border-gray-700">151</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">1052</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">1634</td>

            <td class="px-3 py-2 border-b border-gray-700">410</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">1308</td>

            <td class="px-3 py-2 border-b border-gray-700">328</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1090</td>

            <td class="px-3 py-2 border-b border-gray-700">274</td>

            <td class="px-3 py-2 border-b border-gray-700">138</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">934</td>

            <td class="px-3 py-2 border-b border-gray-700">235</td>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">818</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">894</td>

            <td class="px-3 py-2 border-b border-gray-700">225</td>

            <td class="px-3 py-2 border-b border-gray-700">114</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">1576</td>

            <td class="px-3 py-2 border-b border-gray-700">396</td>

            <td class="px-3 py-2 border-b border-gray-700">199</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">2450</td>

            <td class="px-3 py-2 border-b border-gray-700">614</td>

            <td class="px-3 py-2 border-b border-gray-700">308</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Polynomial commitments and evaluations in REDSHIFT reduce to the following check: whether particular functions  <span class="math">f_{1}, \\ldots, f_{k}</span>  represented as oracles are close to the space of degree  <span class="math">d</span>  polynomials. The batching approach is to replace all those separate and independent FRI queries by exactly one instance of FRI w.r.t a linear combination of functions  <span class="math">f_{i}</span> , where the coefficients of linear dependence are provided by the verifier. This can be done, with details in Appendix G.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that PLONK is restricted to prime fields only. This is because [31] requires embedding a field  <span class="math">\\mathbb{F}</span>  into a group of points on some pairing-friendly elliptic curve. [3] provides a version of the FRI protocol for binary fields which exploits additive and vector space structure of the underlying field. The rest of PLONK is field agnostic and only the permutation argument would require modification. This means that REDSHIFT can be instantiated for binary as well as prime fields and all constructions and proofs follow through by replacing the multiplicative domain  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  by an affine subspace. The binary variant of PLONK is especially effective for computations that require a lot of bit manipulations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 1: Benchmark for REDSHIFT with  <span class="math">\\rho = 1 / 16</span> . Top: Proof Generation Time (seconds). Center: Verification Time (ms). Bottom: Proof Size (kB).</p>

    <p class="text-gray-300">REDSHIFT verification subroutines can be expressed as circuits, where the dominating operation will be the verification of Merkle paths or inclusion proofs in some other cryptographic accumulator. All remaining arithmetic operations are performed over the same</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field that the original circuit (for which the verifier is expressed) is defined, so there is no requirement for cycles over pairing-friendly elliptic curves as in previous work. A hybrid approach exists that performs the last step of recursion using a 'pairing-based' PLONK, e.g. the BLS12-381 curve has a main subgroup of order  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  such that  </span>2^{32} \\mid (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)$ . This allows for instantiating REDSHIFT. Table 2 shows that in the case of recursive constructions one could use a higher rate for the "inner" and a lower one for the "outer" level of recursion that verify the nested proofs, since a smaller inner circuit is much cheaper to verify. This has been subsequently explored as an avenue to practical recursion in [1].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The LPC and PES primitives can be applied to proof systems such as SONIC [32] and Marlin [19] that use univariate polynomial commitments. Of interest here are the proximity testing parameters e.g. testing inclusion in RS  $[\\mathbb{F}_q, D, (d - 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> , where (in the case of Marlin)  </span>d = 2^k$ . [6] contains a description of such a subroutine.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">[1] [n. d.]. Plonky2: Fast Recursive Arguments with PLONK and FRI. https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf. Accessed: 2022-08-09. [2] [n. d.]. StarkDEX: Bringing STARKs to Ethereum. https://blog.0xproject.com/ starkdex-bringing-starks-to-ethereum-6a03fffc0eb7. Accessed: 2022-08-09. [3] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. 2018. Fast Reed-Solomon interactive oracle proofs of proximity. In 45th International Colloquium on Automata, Languages, and Programming (ICALP 2018). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik. [4] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. 2019. Scalable zero knowledge with no trusted setup. In Annual International Cryptology Conference. Springer, 701-732. [5] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. 2020. Proximity Gaps for Reed-Solomon Codes. In 2020 IEEE 61st Annual Symposium on Foundations of Computer Science (FOCS). IEEE, 900-909. [6] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. 2018. Aurora: Transparent Succinct Arguments for R1CS. Cryptology ePrint Archive, Report 2018/828. https://eprint.iacr.org/2018/828. [7] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. 2016. Interactive oracle proofs. In Theory of Cryptography Conference. Springer, 31-60. [8] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. 2014. Succinct non-interactive zero knowledge for a von Neumann architecture. In 23rd {USENIX} Security Symposium ( {USENIX} Security 14). 781-796. [9] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. 2019. DEEP-FRI: Sampling outside the box improves soundness. arXiv preprint arXiv:1903.12243 (2019). [10] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. 2018. Worst-case to Average Case Reductions for the Distance to a Code. In Proceedings of the 33rd Computational Complexity Conference (San Diego, California) (CCC '18). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, Germany, Article 24, 23 pages. https://doi.org/10.4230/LIPlcs.CCC.2018.24 [11] Dan Boneh, Joseph Bonneau, Benedikt Bunz, and Ben Fisch. 2018. Verifiable delay functions. In Annual International Cryptology Conference. Springer, 757-788. [12] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. 2020. Halo infinite: Recursive zk-snarks from any additive polynomial commitment scheme. Cryptology ePrint Archive (2020). [13] Sean Bewe, Ariel Gabizon, and Ian Miers. 2017. Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model. IACR Cryptology ePrint Archive 2017 (2017), 1050. [14] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. 2018. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 315-334. [15] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. 2019. Transparent SNARKs from DARK Compilers. Cryptology ePrint Archive, Report 2019/1229. https://eprint.iacr.org/2019/1229. [16] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N Rothblum, and Ron D Rothblum. 2018. Fiat-Shamir from simpler assumptions. Cryptology ePrint Archive (2018).</p>

    <p class="text-gray-300">REISBIERT: Transparent SNARKs from List Polynomial Commitments</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">[17] Pyrros Chaidos, Véronique Cortier, Georg Fuchsbauer, and David Galindo. 2016. Beleniosrf: A non-interactive receipt-free electronic voting scheme. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM, 1614-1625. [18] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. 2019. Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS. Cryptology ePrint Archive, Report 2019/1047. https://eprint.iacr.org/2019/1047. [19] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. 2019. Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS. Cryptology ePrint Archive, Report 2019/1047. https://eprint.iacr.org/2019/1047. [20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. 2019. Fractal: Post-Quantum and Transparent Recursive Proofs from Holography. Cryptology ePrint Archive, Report 2019/1076. https://eprint.iacr.org/2019/1076. [21] Pergament Evgenya. 2017. Algebraic RAM. Master's thesis. Technion. [22] Ariel Gabizon and Zachary J. Williamson. [n. d.]. Proposal: The Turbo-PLONK program syntax for specifying SNARK programs. https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf. Accessed: 2022-08-09. [23] Ariel Gabizon, Zachary J Williamson, and Oana Ciobotaru. 2019. PLONK: Permutations over Lagrange-bases for Occumenical Noninteractive arguments of Knowledge. Technical Report. Cryptology ePrint Archive, Report 2019/953. [24] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. 2013. Quadratic span programs and succinct NIZKs without PCPs. In Annual International Conference on the Theory and Applications of Cryptographic Techniques. Springer, 626-645. [25] Craig Gentry and Daniel Wichs. 2011. Separating succinct non-interactive arguments from all falsifiable assumptions. In Proceedings of the forty-third annual ACM symposium on Theory of computing. ACM, 99–108. [26] Shafi Goldwasser, Yael Tauman Kalai, and Guy N Rothblum. 2015. Delegating computation: interactive proofs for muggles. Journal of the ACM (JACM) 62, 4 (2015), 1-64. [27] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. 1989. The knowledge complexity of interactive proof systems. SIAM Journal on computing 18, 1 (1989), 186-208. [28] Jens Groth. 2016. On the size of pairing-based non-interactive arguments. In Annual International Conference on the Theory and Applications of Cryptographic Techniques. Springer, 305–326. [29] V. Guruswami and M. Sudan. 1999. Improved decoding of Reed-Solomon and algebraic-geometry codes. IEEE Transactions on Information Theory 45, 6 (1999), 1757-1767. https://doi.org/10.1109/18.782097 [30] W Cary Huffman and Vera Pless. 2003. Fundamentals of error-correcting codes. Cambridge Univ. Press, Cambridge. https://cds.cern.ch/record/1139892 [31] Aniket Kate, Gregory M Zaverucha, and Ian Goldberg. 2010. Constant-size commitments to polynomials and their applications. In International Conference on the Theory and Application of Cryptology and Information Security. Springer, 177-194. [32] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. 2019. Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updateable Structured Reference Strings. IACR Cryptology ePrint Archive 2019 (2019), 99. [33] Silvio Micali. 2000. Computationally sound proofs. SIAM J. Comput. 30, 4 (2000), 1253-1298. [34] Ian Miers, Christina Garman, Matthew Green, and Aviel D Rubin. 2013. Zerocoin: Anonymous distributed e-cash from bitcoin. In 2013 IEEE Symposium on Security and Privacy. IEEE, 397-411. [35] Srinath Setty. [n.d.]. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. ([n.d.]). [36] Srinath Setty, Sebastian Angel, Trinabh Gupta, and Jonathan Lee. 2018. Proving the correct execution of concurrent services in zero-knowledge. In 13th {USENIX} Symposium on Operating Systems Design and Implementation ( {OSDI} 18). 339-356. [37] Srinath Setty, Benjamin Braun, Victor Vu, Andrew J Blumberg, Bryan Parno, and Michael Walfish. 2013. Resolving the conflict between generality and plausibility in verified computation. In Proceedings of the 8th ACM European Conference on Computer Systems. ACM, 71-84. [38] Alexander Vlasov and Konstantin Panarin. 2019. Transparent Polynomial Commitment Scheme with Polylogarithmic Communication Complexity. Cryptology ePrint Archive, Report 2019/1020. https://eprint.iacr.org/2019/1020. [39] Riad S Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. 2018. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 926-943. [40] Gavin Wood et al. 2014. Ethereum: A secure decentralised generalised transaction ledger. <em>Ethereum project yellow paper</em> 151, 2014 (2014), 1-32. [41] Tiacheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. 2019. Libra: Succinct zero-knowledge proofs with optimal prover computation. In Annual International Cryptology Conference. Springer, 733-764.</p>

    <p class="text-gray-300">[42] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. 2020. Transparent polynomial delegation and its applications to zero knowledge proof. In 2020 IEEE Symposium on Security and Privacy (SP). IEEE, 859-876.</p>

    <p class="text-gray-300">Proof. Suffices to show a polynomial time transition between the two constraint systems.</p>

    <p class="text-gray-300">Suppose  <span class="math">\\mathcal{V} = (\\mathbf{a},\\mathbf{b},\\mathbf{c})</span> ; think of  <span class="math">\\mathcal{V}</span>  as a vector in  <span class="math">[m]^{3n}</span> . For  <span class="math">i\\in [m]</span> , let  <span class="math">T_{i}\\subset [3n]</span>  be the set of indices  <span class="math">j\\in [3n]</span>  such that  <span class="math">\\mathcal{V}_j = i</span> . Now define  <span class="math">T_{\\mathcal{L}}\\coloneqq \\{T_i\\}_{i\\in [m]}</span>  - partition of  <span class="math">[3n]</span>  into non-intersecting chunks. Define a permutation  <span class="math">\\sigma (T_{\\mathcal{L}})</span>  on  <span class="math">[3n]</span>  in the following way: for each block  <span class="math">T_{i}</span>  of  <span class="math">T_{\\mathcal{L}}</span> ,  <span class="math">\\sigma (T_{\\mathcal{L}})</span>  contains a cycle going over all elements of  <span class="math">T_{i}</span> . For simplicity we write  <span class="math">\\sigma = \\sigma (T_{\\mathcal{L}})</span></p>

    <p class="text-gray-300">Overloading notation, set the selector polynomials  <span class="math">\\mathbf{q_L}</span> ,  <span class="math">\\mathbf{q_R}</span> ,  <span class="math">\\mathbf{q_O}</span> ,  <span class="math">\\mathbf{q_M}</span> ,  <span class="math">\\mathbf{q_C} \\in \\mathbb{F}[X]</span>  defined for each  <span class="math">i \\in [n]</span>  by</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {q} _ {\\mathrm {L}} (g ^ {i}) := (\\mathbf {q} _ {\\mathrm {L}}) _ {i}, \\mathbf {q} _ {\\mathrm {R}} (g ^ {i}) := (\\mathbf {q} _ {\\mathrm {R}}) _ {i}, \\mathbf {q} _ {\\mathrm {O}} (g ^ {i}) := (\\mathbf {q} _ {\\mathrm {O}}) _ {i}, \\\\ \\mathbf {q} _ {\\mathbf {M}} (g ^ {i}) := (\\mathbf {q} _ {\\mathbf {M}}) _ {i}, \\mathbf {q} _ {\\mathrm {C}} (g ^ {i}) := (\\mathbf {q} _ {\\mathrm {C}}) _ {i}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If  <span class="math">(x,\\omega)</span>  is a relation  <span class="math">\\mathcal{L}</span>  prepared for  <span class="math">I</span>  public inputs, then  <span class="math">(x^{\\prime}\\omega^{\\prime})</span>  is a relation for  <span class="math">\\mathcal{L}^{\\prime}</span>  computed in the following way:</p>

    <p class="text-gray-300">(1)  <span class="math">\\mathbf{PI}(\\mathbf{X})\\coloneqq \\sum_{i\\in [I]} - x_i\\cdot L_i(X)</span> (2)  <span class="math">\\mathbf{f}_{\\mathbf{L}}, \\mathbf{f}_{\\mathbf{R}}, \\mathbf{f}_{\\mathbf{O}} \\in \\mathbb{F}[X]</span>  are defined by the following condition:  <span class="math">\\forall i \\in [n]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {f} _ {\\mathbf {L}} (i) = \\mathbf {x} _ {\\mathbf {a} i}, \\mathbf {f} _ {\\mathbf {R}} (i) = \\mathbf {x} _ {\\mathbf {b} i}, \\mathbf {f} _ {\\mathbf {O}} (i) = \\mathbf {x} _ {\\mathbf {c} i}.</span></div>

    <p class="text-gray-300">It is easy to check that such a transition can be reversed, which yields the proof.</p>

    <p class="text-gray-300">Remark 1: Note that calculation of  <span class="math">x&#x27;</span>  requires only the access to statement  <span class="math">x</span>  and no access to secret witness  <span class="math">\\omega</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 2: Note that permutation  <span class="math">\\sigma</span>  was chosen in such a way that  <span class="math">\\omega</span>  is a valid witness for  $\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_x<span class="math">  iff  </span>\\mathbf{f}_{\\mathbf{L}}, \\mathbf{f}_{\\mathbf{R}}, \\mathbf{f}_{\\mathbf{O}}<span class="math">  constructed as described before from a valid witness for  </span>\\mathcal{L}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x'}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DEFINITION 17. For a function  <span class="math">f: S \\to \\mathbb{F}</span> , let interpolant <span class="math">^f</span>  be the unique degree  $&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  polynomial that satisfies interpolant </span>^f<span class="math">  ( </span>s = f(s)<span class="math">  for all  </span>s \\in S$ ). This polynomial can be constructed by Lagrange interpolation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Setup phase. In the setup phase, the prover and verifier agree on the following parameters</p>

    <p class="text-gray-300"><span class="math">\\circ</span>  A prime field  <span class="math">\\mathbb{F}</span> <span class="math">\\circ</span>  A positive integer  <span class="math">R \\in \\mathbb{Z}_{&amp;gt;0}</span>  and the rate  <span class="math">\\rho = 2^{-R}</span> . <span class="math">\\circ</span>  A multiplicative domain  <span class="math">D = D^{(0)} = \\{\\omega, \\omega^2, \\dots, \\omega^n\\}</span>  generated by an element  <span class="math">\\omega = \\omega_0 \\in \\mathbb{F}^*</span>  of order  <span class="math">n = 2^k</span>  for some  <span class="math">k \\in \\mathbb{N}</span> . For chosen  <span class="math">\\rho = 2^{-R}</span>  and  <span class="math">n = 2^k</span>  the protocol will check if  <span class="math">f</span>  is of degree  <span class="math">&amp;lt; \\rho n = 2^{k - R}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\circ</span>  The prover and verifier agree on a number of rounds  <span class="math">r &amp;lt; k - R \\in \\mathbb{N}</span>  and a sequence of sub-domains  <span class="math">D^{(0)}, D^{(1)}, D^{(2)}, \\ldots, D^{(r)}</span> , constructed inductively as follows: suppose  <span class="math">D^{(i)}</span>  was already defined and generated (as a cyclic group) by  <span class="math">\\omega_{i}</span> . Let  <span class="math">q(X): \\mathbb{F} \\to \\mathbb{F}</span>  be the map defined by the rule:  <span class="math">q(X) = X^2</span> . Then define  <span class="math">D^{(i + 1)} = q(D^{(i)})</span> . Note that  <span class="math">D^{(i + 1)}</span>  is cyclic subgroup of  <span class="math">\\mathbb{F}^*</span>  generated by  <span class="math">\\omega_{i + 1} = \\omega_i^2</span> . Note that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2^i<span class="math">  and that  </span>\\forall i \\in \\{0, 1, \\dots, r - 1\\}<span class="math"> ,  </span>D^{(i)}$  can be split</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">into cosets <span class="math">\\bigcup_{j}s_{ij}H^{(i)}</span> where <span class="math">H^{(i)}</span> is the kernel of the homomorphism $q(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D^{(i)}}:D^{(i)}\\to D^{(i + 1)}.<span class="math"> Note that all cosets have equal size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{(i + 1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2<span class="math"> and the number of cosets </span>j =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2^{i + 1}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When we say that prover commits to function <span class="math">f</span> on domain <span class="math">D</span> this means prover sends an oracle containing $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math"> i.e. all evaluations of function </span>f<span class="math"> on domain </span>D$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Commit phase.</strong> In the commitment phase, the prover inductively constructs and commits to a sequence of functions <span class="math">f^{(0)}, \\ldots, f^{(r-1)}</span> and a sequence of coefficients <span class="math">a_0, \\ldots, a_d</span> with which the verifier will construct the final function <span class="math">f^{(r)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: a purported low degree polynomial <span class="math">f^{(0)} \\coloneqq f \\in \\mathrm{RS}[\\mathbb{F}, D^{(0)}, \\rho]</span>. The prover commits to <span class="math">f^{(0)}</span> on <span class="math">D^{(0)}</span>.</li>

      <li>For <span class="math">0 \\leq i &amp;lt; r</span>, given that <span class="math">f^{(i)}</span> was already defined (and committed to), the prover constructs <span class="math">f^{(i+1)}: D^{(i+1)} \\to \\mathbb{F}</span> in the following way:</li>

      <li>The verifier sends a random <span class="math">x^{(i)} \\in \\mathbb{F}</span>.</li>

      <li>For <span class="math">y \\in D^{(i+1)}</span>, let <span class="math">S_y = \\{x \\in D^{(i)} : q(x) = y\\}</span> be the coset of <span class="math">D^{(i)}</span> mapped to <span class="math">y</span>.</li>

      <li>Using interpolation, the prover constructs the polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p _ {y} ^ {(i)} (X) := \\operatorname {i n t e r p o l a n t} ^ {f ^ {(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {S _ {y}} (X)},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and defines</p>

    <div class="my-4 text-center"><span class="math-block">f ^ {(i + 1)} (y) := p _ {y} ^ {(i)} \\left(x ^ {(i)}\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">i &amp;lt; r - 1</span>, the prover commits to the values of <span class="math">f^{(i + 1)}</span> on <span class="math">D^{(i + 1)}</span>. If <span class="math">i = r - 1</span> then <span class="math">f^{(r)}</span> is a purported polynomial of degree $&lt; \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{(r)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, in which case the prover commits to its coefficients </span>a_0, \\ldots, a_d$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Query phase.</strong> In the query phase, the verifier (probabilistically) validates the proof sent by the prover.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: a sequence of oracles <span class="math">f^{(0)}, \\ldots, f^{(r-1)}</span>, and coefficients <span class="math">a_0, \\ldots, a_d</span>, with which the verifier constructs <span class="math">f^{(r)}</span>, by</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f ^ {(r)} (X) := \\sum_ {k = 0} ^ {d} a _ {k} X ^ {k} \\in \\mathrm {R S} [ \\mathbb {F}, D ^ {(r)}, \\rho ].</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier generates a random <span class="math">s^{(0)} \\in D^{(0)}</span> and for all <span class="math">0 \\leq i &amp;lt; r</span> lets</li>

    </ul>

    <p class="text-gray-300">(1) <span class="math">s^{(i + 1)}\\coloneqq q(s^{(i)})</span> (2) <span class="math">S^{(i)}</span> be the coset of <span class="math">H^{(i)}</span> in <span class="math">D^{(i)}</span> containing <span class="math">s^{(i)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">0 \\leq i &amp;lt; r - 1</span> the verifier checks that given <span class="math">f^{(i)}</span>, the function <span class="math">f^{(i + 1)}</span> was constructed according to the protocol:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>She queries <span class="math">f^{(i)}</span> on all of <span class="math">S^{(i)}</span>, and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- computes $p^{(i)} = \\text{interpolant}^{f^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S^{(i)}}}$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>performs a "round consistency" check:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f ^ {(i + 1)} \\left(s ^ {(i + 1)}\\right) = p ^ {(i)} \\left(x ^ {(i)}\\right).</span></div>

    <p class="text-gray-300">Note that in the last check, the function considered is <span class="math">f^{(r)}</span> which is in <span class="math">\\mathrm{RS}[\\mathbb{F},D^{(r)},\\rho]</span> by construction. If all tests pass, the verifier accepts the proof. Otherwise, she rejects.</p>

    <p class="text-gray-300"><strong>Remark:</strong> Instead of taking a family of nested sub-domains to be multiplicative subgroups it is also possible to take the cosets of them. To be more precise, consider any shift <span class="math">g \\in \\mathbb{F}^* \\backslash D</span>. There</p>

    <p class="text-gray-300">is a modification to the FRI protocol operating over the domains <span class="math">D^{(0)&#x27;} = gD^{(0)}, D^{(1)&#x27;} = gD^{(1)}, \\ldots, D^{(r)&#x27;} = gD^{(r)}</span>. The function mapping <span class="math">D^{(i)&#x27;}</span> to <span class="math">D^{(i+1)&#x27;}</span> is <span class="math">q&#x27;(X) = q^{-1}X^2</span>. The modified version of FRI has the same security guarantees as the original one.</p>

    <p class="text-gray-300"><strong>Proof of Theorem 4.</strong> It is immediate from the completeness of the FRI protocol that Algorithm 1 satisfies the completeness property for the given relation, which is verified directly by inspection. We also assume the existence of a (Gen, Com) binding commitment tuple and model it as an oracle to the IOP on domain <span class="math">D</span>.</p>

    <p class="text-gray-300">For the soundness bound, it suffices to show that the only source of soundness error comes from the FRI protocol. We concern ourselves with the situation when <span class="math">q(X)</span> passes the FRI check and the verifier is convinced that <span class="math">q(X)</span> is <span class="math">\\delta</span>-close to some polynomial <span class="math">h(X)</span> with <span class="math">\\deg (h) &amp;lt; d - N</span>. This implies that, except at a <span class="math">\\delta</span>-fraction of points on domain <span class="math">D</span>, the following relation holds:</p>

    <div class="my-4 text-center"><span class="math-block">f (X) = U (X) + h (X) \\prod_ {i = 1} ^ {N} (X - z _ {i}).</span></div>

    <p class="text-gray-300">Note that <span class="math">t(X) = U(X) + h(X)\\prod_{i = 1}^{N}(X - z_i)</span> is a polynomial of degree less than <span class="math">d</span>. From the second equation we get that this polynomial is <span class="math">\\delta</span>-close to <span class="math">f(X)</span> or that <span class="math">\\Delta (f,t) &amp;lt; \\delta</span>. Moreover, we have that <span class="math">\\forall i\\in [N],t(z_i) = U(z_i) = y_i</span> by the definition of <span class="math">U(X)</span>. This means <span class="math">t(X)</span> satisfies all the requirements for the candidate polynomial <span class="math">g</span> in the definition of <span class="math">\\mathcal{R}^{\\delta}(\\mathrm{pp})</span>. Prover and verifier complexity results follow immediately by inspection of the IOP and the fact that the construction of an interpolation polynomial of degree <span class="math">N</span> can be achieved with <span class="math">O(N\\log^3 N)</span> field operations.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300"><strong>Proof of Theorem 5.</strong> We construct the given IOP by using the LPC scheme equipped with an additional oracle <span class="math">\\mathcal{O}^{\\mathcal{D}}</span> providing access to <span class="math">\\mathcal{D}</span> for both parties. Initially, the prover <span class="math">\\mathrm{P}</span> queries <span class="math">\\mathcal{O}^{\\mathcal{D}}(f)</span> and appends the output <span class="math">\\{x_i, w_i\\}_{i=1}^{\\mu}</span> to its initial message to the verifier V. Subsequently, <span class="math">\\mathrm{P}</span> and <span class="math">\\mathrm{V}</span> simulate the LPC IOP for the input set <span class="math">S = \\{x_i, w_i\\}_{i=1}^{\\mu} \\cup \\{z_i, y_i\\}_{i=1}^{N}</span> of <span class="math">\\mu + N</span> pairs. This is possible as both parties have access to <span class="math">S</span> as the <span class="math">\\{z_i, y_i\\}_{i=1}^{N}</span> were provided as public input. By the security properties of the LPC scheme, except with probability <span class="math">\\epsilon(\\delta)</span> the prover can convince the verifier of the existence of some <span class="math">g</span> for which <span class="math">\\deg(g) &amp;lt; d</span>, <span class="math">\\Delta(f, g) &amp;lt; \\delta</span> and <span class="math">\\forall i \\in [N], j \\in [\\mu]</span> we have that <span class="math">g(z_i) = y_i</span> and <span class="math">g(x_j) = w_j</span>.</p>

    <p class="text-gray-300">Suffices to argue that <span class="math">f = g</span>. We know by the properties of the distinguisher that with probability <span class="math">1 - \\eta(\\delta)</span>, <span class="math">\\exists k \\in [\\mu]</span> for which <span class="math">\\forall g \\in L_{\\delta}(f) \\backslash \\{f\\}</span>, <span class="math">g(x_k) \\neq f(x_k)</span>. However, from the knowledge claim above we know that <span class="math">\\forall j \\in [\\mu], g(x_j) = w_j</span> where <span class="math">w_j = f(x_j)</span> (since it was an oracle query response). This means that <span class="math">g(x_k) = f(x_k)</span> and, since <span class="math">\\Delta(f, g) &amp;lt; \\delta</span>, we have that <span class="math">f = g</span>.</p>

    <p class="text-gray-300"><strong>Proof of Claim 1.</strong> We begin with the case that <span class="math">\\mu = 1</span>. If at the setup step the choice of <span class="math">x \\in \\mathbb{F}</span> was random, by the Schwartz-Zippel lemma the probability that any degree <span class="math">d</span> polynomial <span class="math">g \\in L_{\\delta}(f)</span> satisfies <span class="math">g(x) = f(x)</span> is:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_ {x} [ g (x) - f (x) = 0 ] \\leq \\frac {\\deg (g (X) - f (X))}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac {d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">REDSHIFT: Transparent SNARKs from List Polynomial Commitments</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Enumerating over all <span class="math">g_j \\in L_{\\delta}(f) \\setminus \\{f\\}</span> with a union bound:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{x} \\left[ \\bigcup_{j \\in</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{\\delta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} g_{j}(x) - f(x) = 0 \\right] \\leq \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{\\delta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For <span class="math">\\mu &amp;gt; 1</span>, the distinguisher needs to find at least one such point out of <span class="math">\\mu</span> i.i.d random samples. This will only fail if all <span class="math">\\mu</span> random samples are not separation points. The result follows from the independence of the random samples, while the time complexity bound follows as evaluation of <span class="math">f</span> takes <span class="math">O(d)</span> time.</p>

    <p class="text-gray-300">PROOF OF THEOREM 6. The random sampling distinguisher alongside the FRI LPC define a PES satisfying the claim. The statement follows directly from Theorem 4 and Claim 1, while the upper bound on the soundness of <span class="math">\\eta</span> is obtained using Theorem 1.</p>

    <p class="text-gray-300">Below we provide a proof of Theorem 7. For clarity, we consider the completeness and knowledge soundness cases separately. More specifically, the protocol satisfying the theorem statement is:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{RedShift}(\\mathrm{pp}, \\mathbf{PI}, n, \\bot, N; \\mathbf{f}_{\\mathbf{L}}, \\mathbf{f}_{\\mathbf{R}}, \\mathbf{f}_{\\mathbf{O}}).</span></div>

    <p class="text-gray-300">For simplicity, we assume that any polynomial that uses the IOPP schemes can be decomposed into parts that each have at most degree <span class="math">n</span>, thus allowing us to only require one RS code family for <span class="math">n</span>. Note that here we ignore the mask polynomials by setting a null value for <span class="math">k</span>.</p>

    <p class="text-gray-300">Assume <span class="math">\\mathrm{P}</span> possesses a valid witness consisting of polynomials <span class="math">\\mathbf{f}_{\\mathbf{L}}, \\mathbf{f}_{\\mathbf{R}}, \\mathbf{f}_{\\mathbf{O}}</span>. Which copy-satisfy <span class="math">\\sigma</span>. Note that the addition of masking polynomials doesn't change the values of <span class="math">\\mathbf{f}_{\\mathbf{L}}, \\mathbf{f}_{\\mathbf{R}}, \\mathbf{f}_{\\mathbf{O}}</span> on <span class="math">D</span>. It is straightforward to check that <span class="math">F_{6}(X)</span> is identically zero on <span class="math">D^{<em>}</span> by the definition of witness polynomials, <span class="math">F_{1}(X), F_{2}(X), F_{3}(X), F_{4}(X)</span> will be zero on <span class="math">D^{</em>}</span> by construction of <span class="math">P(X)</span> and <span class="math">Q(X)</span>. To prove completeness of the protocol it is then enough to check that <span class="math">F_{5}(X)</span> is identically zero on <span class="math">D^{*}</span>. Using the properties of the Lagrange basis, this is equivalent for <span class="math">P(g^{n + 1}) = Q(g^{n + 1})</span>.</p>

    <p class="text-gray-300">By definition of <span class="math">P(X)</span> and <span class="math">Q(X)</span>, the above becomes:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\prod_{i = 1}^{n} \\prod_{j = 1}^{3} \\left(f_{j}(g^{i}) + \\beta \\cdot k_{j} g^{i} + \\gamma\\right) = \\\\ = \\prod_{i = 1}^{n} \\prod_{j = 1}^{3} \\left(f_{j}(g^{i}) + \\beta \\cdot \\sigma^{\\prime}(k_{j} g^{i}) + \\gamma\\right). \\end{array}</span></div>

    <p class="text-gray-300">Since <span class="math">\\sigma&#x27; = \\tau \\circ \\sigma \\circ \\tau^{-1}</span>, we rewrite this as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\prod_{i = 1}^{n} \\prod_{j = 1}^{3} \\left(f_{(j - 1)n + i} + \\beta \\cdot \\tau \\big((j - 1)n + i\\big) + \\gamma\\right) \\\\ = \\prod_{i = 1}^{n} \\prod_{j = 1}^{3} \\left(f_{(j - 1)n + i} + \\beta \\cdot \\tau \\circ \\sigma \\big((j - 1)n + i\\big) + \\gamma\\right) \\end{array}</span></div>

    <p class="text-gray-300">Now we use the fact that <span class="math">f_{1}, f_{2}, f_{3}</span> copy-satisfy <span class="math">\\sigma</span>:</p>

    <div class="my-4 text-center"><span class="math-block">f_{(j - 1)n + i} = f_{\\sigma \\left((j - 1)n + i\\right)}.</span></div>

    <p class="text-gray-300">Enumerating products on both sides proves equality, and hence completeness.</p>

    <p class="text-gray-300">We require two auxiliary lemmas, proved in [23].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LEMMA 2. Let <span class="math">k \\in \\mathbb{N}</span>. Fix <span class="math">F_{1}, \\ldots, F_{k} \\in \\mathbb{F}[X]</span> and <span class="math">Z \\in \\mathbb{F}[X]</span>. Suppose that for some <span class="math">i \\in [k]</span>, <span class="math">Z \\nmid F_{i}</span>. Then, except with probability $\\frac{i}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> over uniformly random </span>a_{1}, \\ldots, a_{k} \\in \\mathbb{F}<span class="math">, </span>Z \\nmid F<span class="math">, where </span>F := \\sum_{i=1}^{k} a_{i} F_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LEMMA 3. Let <span class="math">n \\in \\mathbb{N}</span>. Fix a permutation <span class="math">\\sigma</span> of <span class="math">[n]</span>, and <span class="math">a_1, \\ldots, a_n, b_1, \\ldots, b_n \\in \\mathbb{F}</span>. Suppose that for some <span class="math">i \\in [n]</span> <span class="math">b_i \\neq a_{\\sigma(i)}</span>. Then except with probability $\\frac{n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> over random </span>\\beta, \\gamma \\in \\mathbb{P}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i = 1}^{n} \\left(a_{i} + \\beta i + \\gamma\\right) = \\prod_{i = 1}^{n} \\left(b_{i} + \\beta \\sigma(i) + \\gamma\\right).</span></div>

    <p class="text-gray-300">Let <span class="math">t_1</span> and <span class="math">t_2</span> denote the number of PES and LPC instances.</p>

    <p class="text-gray-300">(1) The PES is used on <span class="math">S_{\\sigma_1}, S_{\\sigma_2}, S_{\\sigma_3}, \\mathbf{q_L}, \\mathbf{q_R}, \\mathbf{q_M}, \\mathbf{q_O}, \\mathbf{q_C}</span> at point <span class="math">y \\in \\mathbb{F} \\backslash D</span> sent by V, hence <span class="math">t_1 = 8</span>. Although technically required, we do not evaluate the PES on <span class="math">L_1, L_n, Z, S_{id_1}, S_{id_2}, S_{id_3}</span> as these polynomials are in reduced form and can be evaluated by V without any help from P. More precisely, polynomials <span class="math">S_{id_j}</span> for <span class="math">j \\in [3]</span> are linear, <span class="math">L_i(X)</span> for <span class="math">i \\in [n + 1]</span> are of the form:</p>

    <div class="my-4 text-center"><span class="math-block">L_{(X)} = \\frac{c_{i} (X^{n + 1} - 1)}{X - g^{i}}</span></div>

    <p class="text-gray-300">for some constant <span class="math">c_{i}</span> and <span class="math">Z(X)</span> is of the form:</p>

    <div class="my-4 text-center"><span class="math-block">Z(X) = \\prod_{a \\in H^{+}} (X - a) = \\frac{X^{n} - 1}{X - 1}.</span></div>

    <p class="text-gray-300">(2) LPC instances for witness polynomials <span class="math">f_{1}(X) = \\mathbf{f}_{\\mathbf{L}}(X), f_{2}(X) = \\mathbf{f}_{\\mathbf{R}}(X), f_{3}(X) = \\mathbf{f}_{\\mathbf{O}}(X), T_{0}(X), T_{1}(X), T_{2}(X)</span> (for <span class="math">T = T_{0} + X^{n}T_{1} + X^{2n}T_{2}</span>) are evaluated at point <span class="math">y</span>. For polynomials <span class="math">P(X)</span> and <span class="math">Q(X)</span> they are evaluated at points <span class="math">y</span> and <span class="math">y \\cdot g</span> (within one instance), giving <span class="math">t_{2} = 8</span>. Note that <span class="math">t_{2} = 6</span> if we have <span class="math">T</span> instead of the optimized <span class="math">T_{0}, T_{1}, T_{2}</span>.</p>

    <p class="text-gray-300">We begin by showing round-by-round soundness error. Suffices to construct a State function using the transcript of the proof, which is of the following form:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{tr} := \\left(f_{1}, f_{2}, f_{3}, \\beta, \\gamma, P, Q, \\mathbf{a}, T, \\mathbf{y}, \\mathbf{g} \\cdot \\mathbf{y}, w, \\operatorname{tr}_{LPC}\\right)</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{a} = (a_{1},\\dots,a_{6})</span> and <span class="math">\\mathbf{y},\\mathbf{g}\\cdot \\mathbf{y}\\in \\mathbb{F}^{N}</span> while for <span class="math">j\\in [3]</span>, <span class="math">w\\coloneqq</span></p>

    <div class="my-4 text-center"><span class="math-block">T(\\mathbf{y}), P(\\mathbf{y}), P(\\mathbf{g} \\cdot \\mathbf{y}), Q(\\mathbf{y}), Q(\\mathbf{g} \\cdot \\mathbf{y}), f_{j}(\\mathbf{y}), S_{id_{j}}(\\mathbf{y}), S_{\\sigma_{j}}(\\mathbf{y})</span></div>

    <p class="text-gray-300">the openings of each evaluated polynomial at <span class="math">\\mathbf{y},\\mathbf{g}\\cdot \\mathbf{y}</span> and <span class="math">\\mathrm{tr}_{LPC} = (\\mathrm{tr}_{LPC}^1,\\dots,\\mathrm{tr}_{LPC}^{t_1 + t_2})</span> the transcript of the LPC evaluation routines, where <span class="math">\\mathrm{tr}_{LPC}^i</span> the transcript of the <span class="math">i</span>-th LPC routine. Note that the LPC routines have round-by-round soundness error <span class="math">\\epsilon_{\\mathrm{FRI}}</span> and therefore admit a set of functions <span class="math">\\mathrm{State}_{LPC}^i</span> for <span class="math">i\\in [t_1 + t_2]</span>.</p>

    <p class="text-gray-300">State <span class="math">(pp, \\mathbf{PI}, n, \\bot, N, \\mathrm{tr})</span></p>

    <p class="text-gray-300">(1) If <span class="math">f_{1}, f_{2}, f_{3}, P, Q, T</span> <span class="math">\\delta</span>-close to codewords <span class="math">\\hat{f}_{1}, \\hat{f}_{2}, \\hat{f}_{3}, \\hat{P}, \\hat{Q}, \\hat{T}</span>:</p>

    <p class="text-gray-300">(a) If <span class="math">\\hat{f}_1, \\hat{f}_2, \\hat{f}_3</span> copy-satisfy <span class="math">\\sigma</span> and <span class="math">q_{\\mathbf{C}} + \\mathbf{PI} + q_{\\mathbf{L}} \\hat{f}_1 + q_{\\mathbf{R}} \\hat{f}_2 + q_{\\mathbf{O}} \\hat{f}_3 + q_{\\mathbf{M}} \\hat{f}_1 \\hat{f}_2&#x27; = 0</span>, accept</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) If $Z(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{F}_i(X)<span class="math"> for all </span>i \\in [6]$, accept</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c) If any element of <span class="math">\\mathbf{a}</span> is empty, reject</p>

    <p class="text-gray-300">(d) If <span class="math">Z(X) \\mid \\sum_{i=1}^{h} a_i \\hat{F}_i(X)</span>, accept</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov</p>

    <p class="text-gray-300">(e) If any element of <span class="math">\\mathbf{y}</span> is empty, reject (f) If <span class="math">\\forall m\\in [N],\\sum_{i = 1}^{6}a_{i}\\hat{F}_{i}(y_{m}) = \\hat{T} (y_{m})\\cdot Z(y_{m})</span>, accept (g) Reject (2) If <span class="math">\\mathrm{tr}_{LPC}^{i} = \\bot</span> for some <span class="math">i\\in [t_1 + t_2]</span>, reject. (3) Return <span class="math">\\cap_{i=1}^{t_1+t_2} \\mathrm{State}_{LPC}^i(pp, \\mathbf{PI}, n, N, \\mathrm{tr}_{LPC}^i)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">\\mathrm{tr} = \\bot</span>, <span class="math">\\mathrm{State}(pp, \\mathbf{PI}, n, \\bot, N, \\bot) = 0</span>. We begin with Step 1, when the (partial) transcript provided contains a set of functions <span class="math">\\delta</span>-close to codewords. Suppose that we have a non-satisfying assignment. By definition of the constraint system argument, this is a set of codewords <span class="math">\\hat{f}_1, \\hat{f}_2, \\hat{f}_3</span> that either (1) don't copy-satisfy <span class="math">\\sigma</span>, or (2) don't satisfy the equality <span class="math">q_{\\mathrm{C}} + \\mathbf{PI} + q_{\\mathrm{L}} \\hat{f}_1 + q_{\\mathrm{R}} \\hat{f}_2 + q_{\\mathrm{O}} \\hat{f}_3 + q_{\\mathrm{M}} \\hat{f}_1 \\hat{f}_2&#x27; = 0</span> on <span class="math">D^*</span>. In this case, part (a) never holds. Part (b) outputs accept if <span class="math">Z(X)</span> divides all of the provided <span class="math">\\hat{F}_i</span>, which can be inferred from the transcript using <span class="math">\\hat{f}_1, \\hat{f}_2, \\hat{f}_3, \\beta, \\gamma, \\hat{P}, \\hat{Q}</span>. This however means that it divides <span class="math">\\hat{F}_6</span>, and therefore that the second condition in part (a) is satisfied. Thus the only way for part (b) to output success is if the <span class="math">\\hat{f}_1, \\hat{f}_2, \\hat{f}_3</span> don't copy-satisfy <span class="math">\\sigma</span> and all <span class="math">\\hat{F}_i</span> are divisible by <span class="math">Z</span>. This happens with probability at most $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. This is because by the proof of completeness property:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i = 1}^{q} \\prod_{j = 1}^{3} \\left(\\hat{f}_{(j - 1) q + i} + \\beta \\cdot \\tau ((j - 1) q + i) + \\gamma\\right) =</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i = 1}^{q} \\prod_{j = 1}^{3} \\left(\\hat{f}_{(j - 1) q + i} + \\beta \\cdot \\tau \\circ \\sigma ((j - 1) q + i) + \\gamma\\right). \\tag{●}</span></div>

    <p class="text-gray-300">However, <span class="math">\\mathrm{P}</span> doesn't possess a valid witness (else part (a) would succeed) and, since <span class="math">q = 1</span> here, lemma 3 gives:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(e q. (\\bullet) \\text{ holds } \\mid \\hat{f}_1, \\hat{f}_2, \\hat{f}_3 \\text{ don't copy-satisfy } \\sigma\\right) \\leq \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The probability of moving to accept in (d) is also upper bounded by $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, since </span>\\mathbf{a}<span class="math"> is randomly distributed (and some </span>\\hat{F}_i<span class="math"> is not divisible by </span>Z<span class="math">, else (b) would accept); the result follows from Lemma 2. Part (f) moves to accept only in the case where no </span>\\hat{T}<span class="math"> exists for which the given equality holds identically, else part (d) would have accepted. Since the evaluations are at a random point </span>\\mathbf{y} \\in \\mathbb{P}<span class="math">, the probability that they coincide for two different polynomials is bounded above as </span>4n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, since the degrees of </span>\\sum_{i=1}^{6} a_i \\hat{F}_i<span class="math">, </span>\\hat{T} \\cdot Z<span class="math"> are at most </span>4n<span class="math"> and thus the polynomials can only agree on up to </span>4n<span class="math"> points without being identically equal. Using the Schwartz-Zippel lemma and taking a union bound over all possible tuples (note that the Johnson bound </span>J_{\\rho, \\nu}<span class="math"> upper bounds the list size) yields an error term of </span>\\epsilon_{\\mathrm{IOP}} := J_{\\rho, \\nu}^t \\cdot 4n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. To succeed for </span>N<span class="math"> independently random points, this yields an error term of </span>\\epsilon_{\\mathrm{IOP}}^N<span class="math">. This gives a round-by-round error-contribution term of </span>\\epsilon_1 = \\max \\left(1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\epsilon_{\\mathrm{IOP}}^N\\right)<span class="math"> in the case when the input polynomials are </span>\\delta$-close to codewords.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If the transcript terminates within the first step, then we have that the error is at most <span class="math">\\epsilon_{1}</span> by the above analysis. In the case that the transcript ends after this, it must hold that there exists at least one of the prover provided oracles that is not <span class="math">\\delta</span>-close to a codeword. We evaluate <span class="math">\\mathrm{State}_{LPC}^{i} \\forall i \\in [t_{1} + t_{2}]</span> and an accepting output happens only if all transcripts <span class="math">\\mathrm{tr}_{LPC}^{i}</span> for <span class="math">i \\leq t_{1} + t_{2}</span> lead to accepting states. However, at least one function is not <span class="math">\\delta</span>-close to a codeword, which would add <span class="math">\\epsilon_{\\mathrm{FRI}}</span> soundness error. Let the corresponding transcript</p>

    <p class="text-gray-300">of this function be <span class="math">\\mathrm{tr}_{LPC}^{i}</span>, and notice that by the soundness of the LPC scheme, <span class="math">\\operatorname{Pr}(\\mathrm{State}_{LPC}^{i}(pp,\\mathbf{PI},n,N,\\mathrm{tr}_{LPC}^{i}) = 1) \\leq \\epsilon_{\\mathrm{FRI}}</span>. By the Frechet inequality, the probability over a conjunction of events is upper bounded by the minimum of the probabilities of the individual events. We thus get that Step 3 has round-by-round soundness upper bounded by <span class="math">\\epsilon_{\\mathrm{FRI}}</span>.</p>

    <p class="text-gray-300">Remains to show that if State outputs 0, then so will the verifier. There are two situations in which State rejects a full transcript: if none of parts (a), (b), (d), (f) accept, or if some <span class="math">\\mathrm{State}_{LPC}^{i}</span> rejects. In the former, the verifier will output 0 since the final step in verification will fail as otherwise step (f) would have passed. In the latter, rejection by <span class="math">\\mathrm{State}_{LPC}^{i}</span> means that the verifier for the LPC will also fail. However, this means that the verifier for the whole IOP fails, as the second last step in verification is to check that all LPC/PES instances verify.</p>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}(pp, \\mathbf{PI}, n, \\bot, N, \\mathrm{tr})</span> with access to the first three functions as the transcript runs the Guruswami-Sudan list-decoding algorithm and returns the codewords <span class="math">\\hat{f}_1, \\hat{f}_2, \\hat{f}_3</span> <span class="math">\\delta</span>-close to <span class="math">f_1, f_2, f_3</span>. If State moves to accept with probability greater than <span class="math">\\max (\\epsilon_1, \\epsilon_{\\mathrm{FRI}})</span>, then <span class="math">\\hat{f}_1, \\hat{f}_2, \\hat{f}_3</span> all copy-satisfy <span class="math">\\sigma</span> and identically satisfy <span class="math">q_{\\mathrm{C}} + \\mathbf{PI} + q_{\\mathrm{L}} \\hat{f}_1 + q_{\\mathrm{R}} \\hat{f}_2 + q_{\\mathrm{O}} \\hat{f}_3 + q_{\\mathrm{M}} \\hat{f}_1 \\hat{f}_2&#x27; = 0</span>, as part (a) has to accept in step 1 of State. This is by the round-by-round soundness analysis above, which bounds the probability of moving to an accepting state from an invalid starting witness to less than <span class="math">\\max (\\epsilon_1, \\epsilon_{\\mathrm{FRI}})</span>.</p>

    <h2 id="sec-46" class="text-2xl font-bold">D.3 Zero-Knowledge</h2>

    <p class="text-gray-300">Suffices to show that there exists a simulator <span class="math">S</span> not possessing a valid witness for <span class="math">\\mathcal{L}</span> such that <span class="math">S</span> is able to generate a transcript <span class="math">\\langle S\\rangle</span> which is indistinguishable from the view of an honest prover-verifier interaction up to <span class="math">z</span>. Since we need perfect zero knowledge, we will show that <span class="math">z = 0</span>. For simplicity we denote the transcript in this context as the random variables <span class="math">\\langle a_1,a_2,\\ldots ,a_n\\rangle</span>, where <span class="math">a_{i}</span> represents either the verifier's messages/queries or the prover's responses to the corresponding queries. Note that the transcript doesn't capture any information about the oracles themselves: we treat all oracles as ideal and hence as exposing no data except for the elements sent in response to the verifier's queries (which are encoded inside <span class="math">a_{i}</span>). This is a public-coin protocol in which all of the verifier's queries are randomly distributed field elements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We are going to construct the simulator <span class="math">S</span> and transcript <span class="math">\\langle S\\rangle</span> in the following way: we will set as many variables of the transcript as possible to be uniformly and randomly distributed. All remaining values will be uniquely fixed by the choice of the previous random variables. We will then show that such an approach finally results in the requirement for the witness polynomials <span class="math">f_{i}</span> to have uniformly and randomly distributed values over some domains <span class="math">K_{i}</span> (<span class="math">K_{i}</span> are in general different for each witness polynomial). Then we will show that adding to each witness polynomial a masking polynomial <span class="math">H_{i}(X)</span> of degree at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is enough to achieve the required uniform distribution of values over </span>K_{i}<span class="math">, which suffices for the proof. More specifically, to retain soundness we will add masking polynomials of the form </span>Z(X)H_{i}(X)<span class="math">, as we don&#x27;t want to change the values of </span>f_{i}(X)<span class="math"> on the domain </span>D = H^{*}<span class="math"> defined by </span>Z(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can rewrite the transcript of RedShift in the following form:</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\beta , \\gamma , z, \\mathcal{T} \\langle f _ {1} \\rangle , \\mathcal{T} \\langle f _ {2} \\rangle , \\mathcal{T} \\langle f _ {3} \\rangle , \\mathcal{T} \\langle T \\rangle , \\mathcal{T} \\langle P \\rangle , \\mathcal{T} \\langle Q \\rangle \\rangle ,</span></div>

    <p class="text-gray-300">REOSHIFT: Transparent SNARKs from List Polynomial Commitments</p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">where <span class="math">\\mathcal{T}\\langle f\\rangle</span> denotes the part of the transcript corresponding to the LPC with respect to the witness oracle <span class="math">f</span>. Note that we do not list the transcripts corresponding to the instances of the elements that are precomputed as part of the public parameters.</p>

    <p class="text-gray-300">Let <span class="math">\\beta, y</span> to be uniformly randomly distributed over <span class="math">\\mathbb{F}</span> and <span class="math">y</span> to be uniformly and randomly distributed over <span class="math">\\mathbb{F}\\backslash H</span>. As those values are also taken at random on exactly the same domains by a honest verifier during the actual interaction with the prover, this part of the transcript in <span class="math">\\langle S\\rangle</span> and <span class="math">\\langle P,V\\rangle</span> is equidistributed. For <span class="math">\\langle S\\rangle</span> we also take the openings of each witness function except for <span class="math">T(X),P(X),Q(X)</span> to be uniformly randomly distributed over <span class="math">\\mathbb{F}</span>. The evaluation of <span class="math">T(X)</span> at <span class="math">y</span> is uniquely determined for any true transcript <span class="math">\\langle P,V\\rangle</span> and hence the same relation between variables should hold for the simulator’s transcript <span class="math">\\langle S\\rangle</span> for them to be indistinguishable. Note, we have used the fact that <span class="math">y\\notin H</span> here: in this case <span class="math">Z(y)\\neq 0</span> and so we can obtain a unique value for the RHS of (1) that will satisfy (1) for any random choice of evaluations on LHS. Similarly for the values of <span class="math">P(X)</span> and <span class="math">Q(X)</span>: by construction, these values are uniquely specified based on <span class="math">f_{1},f_{2},f_{3}</span>. At any point when we sample a random element for the value of a witness polynomial <span class="math">f_{i}(g^{j})</span> for <span class="math">g^{j}\\in H^{*}</span> (which we have not sampled before), we make sure that the values of <span class="math">T(g^{j}),P(g^{j}),Q(g^{j})</span> are updated so as to satisfy the above constraints. Note that this means we also need to sample <span class="math">f_{k}(g^{j}),k\\in[3]\\backslash\\{i\\}</span> as this is needed for <span class="math">P,Q,T</span>. We keep track of all such oracle calls and return the provided value in the case of repeated queries, retaining consistency. In the analysis below, we implicitly do this check (and update) whenever it is stated that we randomly sample a new element as the evaluation of some function of a witness polynomial.</p>

    <p class="text-gray-300">We now analyze the transcript <span class="math">\\mathcal{T}(f)</span> for a given witness polynomial where the LPC is instantiated with FRI. In the actual interaction between the prover and verifier the transcript <span class="math">\\mathcal{T}\\langle f\\rangle</span> is of the following form:</p>

    <p class="text-gray-300"><span class="math">i_{1},i_{2},\\ldots,i_{k}</span> <span class="math">z_{1},z_{2},\\ldots,z_{k}</span> <span class="math">x^{(0)},x^{(1)},\\ldots,x^{(r-1)}</span> <span class="math">a_{0},s^{(0)}</span> <span class="math">q^{(0)}(s^{(0)}),\\;q^{(0)}(t^{(0)}),\\;\\ldots,\\;q^{(r-1)}(s^{(r-1)}),\\;q^{(r-1)}(t^{(r-1)})</span></p>

    <p class="text-gray-300">where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">i_{1},i_{2},\\ldots,i_{k}\\in\\mathbb{F}</span> are the points at which the verifier asks to open oracle <span class="math">f</span>. <span class="math">k=1</span> for a single-point evaluation (conducted for witness polynomials <span class="math">f_{1},f_{2},f_{3},T</span> at <span class="math">y</span>) and <span class="math">k=2</span> for double evaluation (conducted for <span class="math">P</span> and <span class="math">Q</span> at the points <span class="math">y</span> and <span class="math">g\\cdot y</span>).</li>

      <li><span class="math">z_{1},z_{2},\\ldots,z_{k}</span> are the corresponding prover-sent openings.</li>

      <li><span class="math">x^{(0)},x^{(1)},\\ldots,x^{(r-1)}</span> are random elements of <span class="math">\\mathbb{F}</span> sent by the verifier during the FRI COMMIT phase, which is conducted with respect to the quotient function:</li>

    </ol>

    <p class="text-gray-300"><span class="math">q(X)=q^{(0)}(X)=\\frac{f(X)-U(X)}{\\prod_{l=1}^{k}(X-i_{l})}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a_{0}</span> is the coefficient of <span class="math">f^{(r)}\\in\\mathbb{F}</span> sent by the prover at the end of the FRI COMMIT phase. Note that according to the remark at the end of the FRI section we assume all our instantiations of FRI are fully unrolled and hence that <span class="math">f^{(r)}(x)</span> is constant. The proof for the general case <span class="math">\\deg(f^{(r)})&amp;gt;0</span> is only a little more involved and is handled in a similar fashion.</li>

      <li><span class="math">s^{(0)}\\in D</span> is the value chosen by the verifier at the beginning of the FRI QUERY phase.</li>

      <li>Every <span class="math">s^{(i+1)}=q(s^{(i)})</span> (for the definition of <span class="math">q(x)</span> refer to FRI section). <span class="math">s^{(i)},t^{(i)}</span> is the coset of <span class="math">s^{(i+1)}</span>.</li>

    </ol>

    <p class="text-gray-300">The simulated transcript <span class="math">\\langle S\\rangle</span> of FRI on <span class="math">f</span> is constructed in the following way:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The point <span class="math">i</span> (or two points <span class="math">(i_{1},i_{2})</span>) are already fixed by the previous history of <span class="math">\\langle S\\rangle</span>: i.e. <span class="math">i=y</span> or <span class="math">(i_{1},i_{2})=(y,g\\cdot y)</span>.</li>

      <li>Similarly for the corresponding evaluations <span class="math">z_{1}</span> (or <span class="math">(z_{1},z_{2})</span>): recall that they are either chosen at random (for witness polynomials <span class="math">f_{1},f_{2},f_{3}</span>) or defined uniquely by all the previous values (for <span class="math">T,Q,P</span>).</li>

      <li>The values <span class="math">x^{(i)}</span> are distributed uniformly over <span class="math">\\mathbb{F}</span> for an honest verifier <span class="math">V</span>. We take the same approach in the simulator <span class="math">S</span>: in <span class="math">\\langle S\\rangle</span> every <span class="math">x^{(i)}</span> is chosen uniformly at random from <span class="math">\\mathbb{F}</span>.</li>

      <li>For <span class="math">\\langle S\\rangle</span> we take <span class="math">s^{(0)}</span> to be uniformly random over <span class="math">D=D^{(0)}</span>.</li>

      <li>In <span class="math">\\langle S\\rangle</span> the values of <span class="math">q^{(0)}(s^{0})</span> and <span class="math">q^{(0)}(t^{(0)})</span> are also taken uniformly at random over <span class="math">\\mathbb{F}</span>.</li>

      <li>Recall that in the FRI protocol we have:</li>

    </ol>

    <p class="text-gray-300"><span class="math">q^{(i+1)}(s^{(i+1)})=p_{q^{(i+1)}}^{(i)}(x^{(i)})</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300"><span class="math">p_{q^{(i)}}^{(i)}(X):=\\text{interpolant}^{q^{(i)}\\lfloor s^{(i)},t^{(i)}\\rfloor}(X),</span></p>

    <p class="text-gray-300">hence the value of every <span class="math">q^{(i+1)}(s^{(i)})</span> is uniquely determined by the values of <span class="math">q^{(i)}(s^{(i)})</span> and <span class="math">q^{(i)}(t^{(i)})</span> that were chosen at the previous iteration. In the simulator transcript, this relation between <span class="math">q^{(i)}(s^{(i)}),q^{(i)}(t^{(i)}),q^{(i+1)}(s^{(i+1)})</span> should remain unchanged. Since we have fixed the values of <span class="math">q^{(0)}(s^{(0)})</span>, <span class="math">q^{(0)}(t^{(0)})</span> above, <span class="math">q^{(1)}(s^{(1)})</span> in <span class="math">\\langle S\\rangle</span> is then uniquely determined.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We proceed by induction: to fix the value <span class="math">q^{(i)}(s^{(i)})</span> we choose the value <span class="math">q^{(i)}(t^{(i)})</span> to be uniformly randomly distributed over <span class="math">\\mathbb{F}</span> and compute <span class="math">q^{(i+1)}(s^{(i+1)})</span> for <span class="math">i\\in[r-2]\\backslash\\{1\\}</span>.</li>

      <li>Compute <span class="math">a_{0}</span> based on <span class="math">q^{(r-1)}(s^{(r-1)})</span> and <span class="math">q^{(r-1)}(t^{(r-1)})</span>.</li>

    </ol>

    <p class="text-gray-300">Remains to show that this achieves the same distribution for transcripts in the honest prover-verifier interaction <span class="math">\\langle P,V\\rangle</span>. First, for all witness polynomials (except for <span class="math">T,P,Q</span>) we want their values at <span class="math">y</span> to look like randomly distributed values over <span class="math">\\mathbb{F}</span>. Moreover, due to our construction of <span class="math">\\langle S\\rangle</span> we want the values</p>

    <p class="text-gray-300"><span class="math">q^{(0)}(s^{(0)}),q^{(0)}(t^{(0)}),q^{(1)}(t^{(1)}),q^{(2)}(t^{(2)}),\\ldots,q^{(r-1)}(t^{(r-1)})</span></p>

    <p class="text-gray-300">to look uniformly random. In order to show this we need the following lemma:</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">f(X)</span> denote the interpolation polynomial of <span class="math">Z=\\{z_{1},z_{2},\\ldots,z_{n}\\}</span> over domain <span class="math">I=\\{i_{1},\\ldots,i_{n}\\}</span>. Let <span class="math">x\\in\\mathbb{F}</span> be different from all <span class="math">i_{2},\\ldots i_{n}</span>. If <span class="math">z_{1}</span> is uniformly random over <span class="math">\\mathbb{F}</span> then <span class="math">f(x)</span> is also uniformly random over <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall the Lagrange interpolation polynomial:</p>

    <p class="text-gray-300"><span class="math">f(X)=\\sum_{j=1}^{n}\\prod_{k\\neq j}\\frac{X-i_{k}}{i_{j}-i_{k}}z_{j}.</span></p>

    <p class="text-gray-300">CCS '22, November 7-11, 2022, Los Angeles, CA, USA.</p>

    <p class="text-gray-300">Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 2: FRI Transcript. Bold lines separate the adjacent levels of FRI, green blocks illustrate the values that are taken uniformly at random, yellow blocks represent the values that are uniquely determined by the coset of the previous layer, while red blocks have no impact on the construction of  <span class="math">\\langle S\\rangle</span> .</p>

    <p class="text-gray-300">Fix  <span class="math">x, i_1, \\ldots, i_n</span>  and  <span class="math">z_1, \\ldots, z_n</span> ,  <span class="math">f(x)</span>  as a function of  <span class="math">z_1</span>  equals:</p>

    <div class="my-4 text-center"><span class="math-block">f (x) = a z _ {1} + b.</span></div>

    <p class="text-gray-300">where  <span class="math">a, b</span>  - constants  <span class="math">\\in \\mathbb{F}</span> . Note that:</p>

    <div class="my-4 text-center"><span class="math-block">a = \\prod_ {k \\neq 1} \\frac {x - i _ {k}}{i _ {1} - i _ {k}} \\neq 0,</span></div>

    <p class="text-gray-300">provided  <span class="math">x</span>  being different from all of  <span class="math">i_2, \\ldots, i_n</span> . For a linear function, the claim follows by the randomness of  <span class="math">z_1</span> .</p>

    <p class="text-gray-300">Consider  <span class="math">s^{(01)}</span>  and  <span class="math">t^{(01)}</span>  (the coset of  <span class="math">t^{(1)}</span> ). Indeed, at least one of  <span class="math">s^{(01)}</span>  or  <span class="math">t^{(01)}</span>  is unequal to  <span class="math">x^{(0)}</span> . Without loss of generality assume  <span class="math">t^{(01)} \\neq x^{(0)}</span> . We use lemma 4 for  <span class="math">I = \\{s^{(01)}, t^{(01)}\\}</span> ,  <span class="math">Z = \\{q^{(0)}(s^{(01)}), q^{(0)}(t^{(01)})\\}</span>  and  <span class="math">x = x^{(0)}</span>  which implies that a uniform distribution of  <span class="math">q^{(0)}(t^{(01)})</span>  results in a uniform distribution for  <span class="math">q^{(1)}(t^{(1)})</span> , independent of the value of  <span class="math">q^{(0)}(s^{(01)})</span> .</p>

    <p class="text-gray-300">We proceed by induction through repeated use of lemma 4. To achieve a uniformly random distribution for  <span class="math">q^{(2)}(t^{(2)})</span>  we need a uniformly random distribution for one of the values from the previous level:  <span class="math">q^{(1)}(s^{(12)})</span>  or  <span class="math">q^{(1)}(t^{(12)})</span> . Assume that  <span class="math">s^{(12)} \\neq x^{(1)}</span>  (hence satisfying the conditions of lemma 4). The uniform distribution of  <span class="math">q^{(2)}(t^{(2)})</span>  then follows from the uniformly random distribution of one of  <span class="math">q^{(1)}(s^{(12)})</span>  which in turn follows from the uniform distribution of  <span class="math">q^{(0)}(s^{(02)})</span> . The same logic is then applied for all downstream layers of FRI. This is illustrated in fig. 2.</p>

    <p class="text-gray-300">Finally, to achieve the same distribution of variables in transcripts  <span class="math">\\langle P,V\\rangle</span>  and  <span class="math">\\langle S\\rangle</span>  we need to add more "degrees of freedom" for each witness polynomial  <span class="math">f_{i},i\\in [3]</span> . More precisely, we want the evaluation:</p>

    <div class="my-4 text-center"><span class="math-block">q ^ {(0)} (s ^ {(0)}), q ^ {(0)} (t ^ {(0)}), q ^ {(0)} (t ^ {(0 1)}),</span></div>

    <div class="my-4 text-center"><span class="math-block">q ^ {(0)} \\left(s ^ {(0 2)}\\right), \\dots \\left(r _ {i} + 1 \\text {v a l u e s i n t o t a l}\\right)</span></div>

    <p class="text-gray-300">over the set  <span class="math">K_{i}^{\\prime} = \\{s^{(0)}, t^{(0)}, t^{(01)}, s^{(02)}, \\ldots \\}</span>  on the top level of FRI to be uniformly random for each  <span class="math">i \\in [3]</span> . Now, recall that:</p>

    <div class="my-4 text-center"><span class="math-block">q ^ {(0)} (X) = q (X) = \\frac {f (X) - U (X)}{\\prod_ {i = 1} ^ {k} (X - i _ {i})}. \\quad (* *)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case the sets  <span class="math">\\{i_1, \\ldots, i_k\\}</span>  and  <span class="math">D</span>  are disjoint. This in turn means that a uniformly random distribution of values of  <span class="math">q^{(0)}(X)</span>  over  <span class="math">K_i&#x27;</span>  is exactly the same as the uniformly random distribution of values of  <span class="math">f_i</span>  over the same domain (as all other terms in  <span class="math">(\\ast\\ast)</span>  are now fixed by previous considerations). Plugging in the requirement for  <span class="math">f_i(y)</span>  to be also uniformly randomly distributed we arrive at the set  <span class="math">K_i = K_i&#x27; \\cup y</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= r_i + 2<span class="math">  at which the values of  </span>f_i<span class="math">  should look like random elements in  </span>\\mathbb{P}<span class="math">  for  </span>i \\in [3]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since  <span class="math">T, P, Q</span>  are each fully specified by  <span class="math">f_1, f_2, f_3</span>  on  <span class="math">D</span> , we need to add to  <span class="math">K_i</span>  any potential oracle queries in the FRI instances for  <span class="math">T, P, Q</span>  that sampled values for which the  <span class="math">f_i</span>  were not already queried. Denote the number of these new calls by  <span class="math">r_T, r_P, r_Q</span> . Since for all of  <span class="math">T, P, Q</span>  queried at a point  <span class="math">g \\in D</span>  the values of  <span class="math">f_i(g)</span>  have to also be queried if they were not queried already, any potential extra queries due to these variables are added to the respective degrees of all three witness polynomials  <span class="math">f_i</span> . To achieve this property, it is enough to replace  <span class="math">f_i(X)</span>  by  <span class="math">f_i&#x27;(X) = f(X) + H_i(X)Z(X)</span>  where  <span class="math">H_i(x)</span>  is a random polynomial of degree  <span class="math">r_i + r_T + r_P + r_Q + 1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As described in the main text of the paper and in particular in Section 6, one has the freedom to pick FRI parameters that also affect contributions into the soundness error of RedShift due to the list size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In general, smaller list sizes will lead to a smaller  </span>\\delta<span class="math">  parameter (this is intuitively expected, as a larger list size requires less sensitivity) that in turn reduces FRI soundness for a chosen domain  </span>D<span class="math"> , parameter  </span>\\rho$  and number of queries. Alternatively, one can pick another limit in the FRI soundness formula</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p (\\rho , \\nu) = \\left(1 - \\min  \\left\\{\\delta_ {0}, J _ {\\nu} (J _ {\\nu} (1 - \\rho)) \\right\\} + \\nu \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and set  <span class="math">\\delta_0 = (1 - \\rho) / 2</span>  to be in the unique decoding radius. In this case list size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> , but FRI has smaller soundness for the same number of queries. This means that one has to pay particular attention to the final system soundness as described in Section 7: for in the case where the sum  </span>A_{1} + \\epsilon_{FRI}\\sim A_{1}<span class="math">  one should also consider the case of the limit  </span>\\delta_0 = (1 - \\rho) / 2<span class="math">  in the FRI soundness term and can recalculate  </span>A_{1}$  and thus a final soundness in case of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">list size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$. Such checks are also important if one would want to reduce the field size for a corresponding reduction in proof size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-50" class="text-2xl font-bold">Appendix F Proof Size Optimizations</h2>

    <p class="text-gray-300">There are various options that can reduce the proof size. Some of the are described in detail in <em>(20)</em>. There are two essential parts to check satisfiability at the random point <span class="math">y</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency between polynomial openings at <span class="math">y</span>. The prover sends the purported evaluations to the verifier and these values are used for two subroutines:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check the equations from Section 5 at <span class="math">y</span>.</li>

      <li>Simulate oracles to the quotient function <span class="math">q(y)</span>.</li>

      <li>Proximity testing performed by the invocation of FRI.</li>

    </ol>

    <p class="text-gray-300">Merging Oracles: As described in <em>(20)</em>, the prover can join the evaluations of the different polynomials over the domain <span class="math">D</span> into a single oracle by placing the corresponding values into the same leaf of the Merkle tree. This reduces the total number of Merkle paths required for authentication, which is a bottleneck for proof size. We can perform such a joining operation for the following sets of polynomials:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint polynomials: selectors <span class="math">q_{L},q_{R},q_{O},q_{M},q_{C}</span> and permutation polynomials <span class="math">S_{id_{i}},S_{\\sigma_{i}},S_{\\sigma_{i}},S_{\\sigma_{i}}</span>, as all those are independent and prepared at setup.</li>

      <li>Witness polynomials: <span class="math">f_{L},f_{R},f_{O}</span>.</li>

      <li>Grand product polynomials: <span class="math">P,Q</span>.</li>

      <li>Polynomials <span class="math">T_{0},T_{1},T_{2}</span> for which</li>

    </ol>

    <p class="text-gray-300"><span class="math">T(X)=X^{2n}T_{2}(X)+X^{n}T_{1}(X)+T_{0}.</span></p>

    <p class="text-gray-300">While we initially have to provide 17 independent Merkle paths for the authentication of various oracle values, this optimization reduces their number to 4, directly reducing proof size and verification time. This is due to the smaller number of prover-provided Merkle paths which imply a smaller number of hash function invocations, which are the current verification time bottleneck. Such an argument universally applies to all the optimization described below that also reduce proof sizes.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Bitreversed Domain Element Enumeration as Merkle Tree Leaves:</h4>

    <p class="text-gray-300">Another important optimizations for FRI is to use “bitreverse” enumeration when placing the claimed LDE values into the Merkle tree. In this case, values that form the coset required for the FRI “folding” step are always adjacent and can thus be placed in the same leaf (combined with the optimization below), sharing a single Merkle path per FRI intermediate oracle query step. We do not use this optimization in the prototype implementation.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Concatenating Merkle Tree Leaves:</h4>

    <p class="text-gray-300">We can place more values into the leaves of every Merkle tree used to instantiate the oracles. This optimization allows us to use a larger ‘localization parameter’ for FRI and thus reduce the number of intermediate oracles. In practice implementations follow an adaptive strategy where the localization parameter is large (usually 8) for the initial FRI stages when the Merkle path is “long” and decreases it when the tree becomes more shallow.</p>

    <p class="text-gray-300">Other optimizations exist: e.g. performing proof-of-work on top of challenge values obtained from the transcript to reduce the number of required FRI queries (as used in <em>(2)</em>) and other estimates for the number of required queries. To the best of our knowledge, there is no public analysis for such optimizations and we thus do not use them in our analysis.</p>

    <p class="text-gray-300">For completeness we should also mention that for a substantial number of queries of Merkle path elements that are close to the root are often duplicate between queries and thus it may be beneficial to send them once, only later sending the values that are missing to complete the path to the leafs. One can also perform a smaller number of FRI “folding” steps and output not just a single coefficient of the claimed low degree polynomial, but settle on a larger degree based on the expected number of queries.</p>

    <h2 id="sec-53" class="text-2xl font-bold">Appendix G Batched FRI</h2>

    <p class="text-gray-300">Consider the following theorem found in <em>(3)</em>. We define <span class="math">J_{v}^{[k]}(\\lambda)=J_{v}(J_{v}(\\cdots(J_{v}(\\lambda))))</span>, where there are <span class="math">k</span> iterations of the function <span class="math">J_{v}</span>. We also denote the <em>relative hamming distance</em> of set <span class="math">S\\subseteq\\mathbb{F}^{n}</span> as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(S)=\\min\\{\\Delta(w,w_{0})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w,w_{0}\\in S,w\\neq w_{0}\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">Let <span class="math">V\\subseteq\\mathbb{F}^{n}</span> be a linear space over a finite field <span class="math">\\mathbb{F}</span> with <span class="math">\\Delta(V)=\\lambda</span>. Let <span class="math">u^{*}\\in\\mathbb{F}^{n}</span> and <span class="math">\\epsilon&gt;0</span> satisfy <span class="math">\\delta&lt;J_{\\epsilon}^{[I+1]}(\\lambda)</span>. For <span class="math">u_{1},u_{2},\\ldots,u_{I}\\in\\mathbb{F}^{n}</span> define</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$A=\\left\\{\\alpha\\in\\mathbb{F}^{*}\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u^{*}+\\sum_{i=1}^{I}\\alpha^{i}u_{i},V)<\\delta\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>l\\cdot(2/\\epsilon)^{I+2}<span class="math">, then </span>\\forall j\\in[l],\\exists v^{*},v_{j}\\in V$ such that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{i\\;\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\;(u_{i}^{<em>}=v_{i}^{</em>})\\wedge\\left(\\bigwedge_{j=1}^{L}(u_{j})_{i}=(v^{l})_{i}\\right)\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta-\\epsilon)n, \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">(u_{j})_{i}</span> denotes the <span class="math">i</span>-th coordinate of <span class="math">u_{j}</span> and <span class="math">i\\in[n]</span>.</p>

    <p class="text-gray-300">In particular, <span class="math">\\Delta(u^{<em>},v^{</em>})\\leq\\delta+\\epsilon</span> and <span class="math">\\forall i\\in[l]</span> :</p>

    <p class="text-gray-300"><span class="math">\\Delta(u_{i},v_{i})\\leq\\delta+\\epsilon.</span></p>

    <p class="text-gray-300">Specifying this theorem for <span class="math">V=\\text{RS}[\\mathbb{F},D,\\rho]</span> (for which <span class="math">\\lambda=\\Delta(V)=1-\\rho</span>), the contrapositive yields the following corollary:</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">V=\\text{RS}[\\mathbb{F},D,\\rho]</span> be the family of RS-codes. Let <span class="math">\\epsilon\\in(0,1),\\delta&gt;0</span> satisfy <span class="math">\\delta&lt;J_{\\epsilon}^{[I]}(1-\\rho)</span>. Let <span class="math">l\\geq 2\\in\\mathbb{N}</span> and <span class="math">u_{1},u_{2},\\ldots,u_{I}\\in\\mathbb{F}^{n}</span>, such that there exists <span class="math">i\\in[l]</span> for which <span class="math">\\Delta(u_{i},V)&gt;\\delta+\\epsilon</span>. Then it holds that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(l-1)\\left(\\frac{2}{\\epsilon}\\right)^{l+1}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We sketch a batched FRI protocol, the correctness of which is a trivial consequence of the previous corollary.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Batched FRI protocol:</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P publishes oracles to <span class="math">f_{1},\\ldots,f_{k}</span>.</li>

      <li>V selects random <span class="math">\\alpha\\in\\mathbb{F}^{*}</span> and sends it to P.</li>

      <li>P and V perform FRI w.r.t <span class="math">f=\\sum_{i=1}^{k}\\alpha^{i-1}f_{i}</span>.</li>

      <li>V accepts if the previous step accepts.</li>

    </ol>`;
---

<BaseLayout title="RedShift: Transparent SNARKs from List Polynomial Commitment... (2019/1400)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1400
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
