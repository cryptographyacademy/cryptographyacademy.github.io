---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/525';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Torus-based compression by factor 4 and 6';
const AUTHORS_HTML = 'Koray Karabina';

const CONTENT = `    <p class="text-gray-300">KORAY KARABINA</p>

    <p class="text-gray-300">ABSTRACT. We extend the torus-based compression technique for cyclotomic subgroups and show how the elements of certain subgroups in characteristic two and three fields can be compressed by a factor of 4 and 6, respectively. Our compression and decompression functions can be computed at a negligible cost. In particular, our techniques lead to very efficient exponentiation algorithms that work with the compressed representations of elements and can be easily incorporated into pairing-based protocols that require exponentiations or products of pairings.</p>

    <p class="text-gray-300">It has been an attractive objective in cryptography to reduce bandwidth requirements while not forfeiting security and efficiency. For example, Montgomery's [11] scalar multiplication algorithm for a certain class of elliptic curves defined over odd characteristic fields only involves the <span class="math">x</span>-coordinate of the input point <span class="math">P = (x,y)</span>. In addition to its advantage of being able to discard the <span class="math">y</span>-coordinate of <span class="math">P</span>, the algorithm can be implemented based on Lucas chains and provides a built-in resistance against certain side-channel attacks. Later on, Montgomery's idea was improved and generalized to any elliptic curve defined over odd characteristic fields and also to elliptic curves defined over binary fields (see for example [1, 10]). Similarly, there have been several proposals to compress the elements of certain subgroups of the multiplicative groups of certain finite fields, and to compute with the compressed representation of elements [16, 4, 2, 9, 3, 12, 20, 19, 15, 8]. The most notable of these proposals is the XTR cryptosystem [9] which compresses the elements of the order- <span class="math">(p^2 - p + 1)</span> subgroup <span class="math">G</span> of <span class="math">\\mathbb{F}_{p^0}^*</span> by a factor of three, and at the same time achieves faster exponentiation in <span class="math">G</span> compared to the previous algorithms that work with the natural representation of elements in <span class="math">\\mathbb{F}_{p^0}</span>.</p>

    <p class="text-gray-300">The compression methods in the finite field setting fall into two category. They either use a rational parameterization of an algebraic torus [12, 20, 19], or use the trace representation of elements [16, 4, 2, 9, 3, 15, 8]. Even though there is a close relationship between these two methods (see [12]), they have different properties. While the rational parametrization of a torus enjoys the full functionality of the group structure, the trace function is not multiplicative and hence novel techniques are required to adapt fast exponentiation algorithms to work with the trace representation of elements (see for example [17, 7]).</p>

    <p class="text-gray-300">Having briefly mentioned the two different compression approaches in finite fields it is natural to ask the following two questions. First, what is the best possible compression ratio for the elements of a subgroup <span class="math">G</span> of the multiplicative group <span class="math">\\mathbb{F}^<em></span> of a finite field <span class="math">\\mathbb{F}</span>, where <span class="math">\\mathbb{F}</span> is the minimal field with <span class="math">G \\subset \\mathbb{F}^</em></span>? One should of course require the corresponding compression and decompression functions to be efficiently computable, and the decompression of an element to be unique or almost unique. Second, how does the tori-compression method compare to the trace-compression method?</p>

    <p class="text-gray-300">The first question was partially answered in [13] for cyclotomic subgroups of finite fields. More precisely, Rubin and Silverberg observed that for a positive integer <span class="math">k</span> and a prime power <span class="math">q</span></p>

    <p class="text-gray-300">Key words and phrases. Cyclotomic subgroups, torus-based compression, exponentiation, pairing-based cryptography.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">there is an algebraic torus <span class="math">\\mathbb{T}_{q,k}</span>, a <span class="math">\\varphi(k)</span>-dimensional algebraic variety over <span class="math">\\mathbb{F}_{q}</span>, and its group <span class="math">\\mathbb{T}_{q,k}(\\mathbb{F}_{q})</span> of <span class="math">\\mathbb{F}_{q}</span>-rational points is isomorphic to the order-<span class="math">\\Phi_{k}(q)</span> (cyclotomic) subgroup of <span class="math">\\mathbb{F}_{q^{k}}^{<em>}</span>. Here, <span class="math">\\Phi_{k}(q)</span> is the <span class="math">k</span>th-cyclotomic polynomial evaluated at <span class="math">q</span>, and <span class="math">\\varphi</span> is Eulerâ€™s totient function. Consequently, one would hope to use only <span class="math">\\varphi(k)</span> <span class="math">\\mathbb{F}_{q}</span>-elements in order to (uniquely) represent elements of <span class="math">\\mathbb{T}_{q,k}(\\mathbb{F}_{q})</span>. For example, when <span class="math">k=4</span> and <span class="math">k=6</span>, the elements of the order-<span class="math">(q^{2}+1)</span> subgroup <span class="math">G_{q,4}</span> of <span class="math">\\mathbb{F}_{q^{4}}^{</em>}</span> and the elements of the order-<span class="math">(q^{2}-q+1)</span> subgroup <span class="math">G_{q,6}</span> of <span class="math">\\mathbb{F}_{q^{6}}^{<em>}</span> can efficiently be compressed and decompressed by a factor <span class="math">2</span> and <span class="math">3</span>, respectively, attaining the best possible compression ratio <span class="math">k/\\varphi(k)</span> (see </em>[12, 13]<em>). Recently, it was shown in </em>[15, 8]* that it is possible to further compress (and decompress) the elements of certain proper subgroups <span class="math">G_{\\ell}</span> of <span class="math">G_{q,4}</span> in characteristic-two fields, and <span class="math">G_{q,6}</span> in characteristic-three fields by an additional factor <span class="math">2</span>, thereby obtaining compression factors <span class="math">4</span> and <span class="math">6</span>, respectively. These seem to be the optimal compression factors as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q\\pm\\sqrt{2q}+1<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q\\pm\\sqrt{3q}+1<span class="math"> in characteristic two and three, respectively, whereby </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx q<span class="math">. In general, it would be desirable to compress the elements of any order-</span>\\ell<span class="math"> subgroup </span>G_{\\ell}\\subsetneq G_{q,k}\\subset\\mathbb{F}_{q^{k}}^{*}<span class="math"> by a factor </span>(k\\log q)/\\log\\ell$ in any characteristic.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this paper, we look for answers to these questions. Our arguments suggest that, the <em>torus-compression</em> techniques cannot, in general, be extended to achieve compression factor <span class="math">(k\\log q)/\\log\\ell</span> for proper subgroups <span class="math">G_{\\ell}</span> of <span class="math">G_{q,k}</span>. At first glance our arguments might appear to contradict the aforementioned compression factors <span class="math">4</span> and <span class="math">6</span> achieved in the case of <span class="math">G_{q\\pm\\sqrt{2q}+1}\\subsetneq G_{q,4}</span> where <span class="math">q</span> is a power of <span class="math">2</span>, and <span class="math">G_{q\\pm\\sqrt{3q}+1}\\subsetneq G_{q,6}</span> where <span class="math">q</span> is a power of <span class="math">3</span>. However, we explain why this discrepancy occurs, and how it helps to work in characteristic two and three fields to compress the elements of certain subgroups <span class="math">G_{\\ell}</span> by a factor <span class="math">k\\approx(k\\log q)/\\log\\ell</span>, when <span class="math">\\ell\\approx q</span>. In particular, we present torus-based compression methods in characteristic two and three fields that achieve factor-<span class="math">4</span> and <span class="math">6</span> compression, respectively. We should emphasize that previously the only method known to compress by a factor-<span class="math">4</span> and <span class="math">6</span> was to use the trace representation of elements <em>[15, 8]</em>. Our new approach gives us the opportunity to compare the two compression methods and, in fact, has the advantage that computing the decompression functions is essentially free. This yields more efficient exponentiation algorithms compared to the trace-based exponentiation algorithms where decompression is quite costly.</p>

    <p class="text-gray-300">The remainder of this paper is organized as follows. In Section 2, we recall some of the results in the literature and set the notation for the paper. In Section 3, we construct our argument to support the difficulty of obtaining the <em>optimal</em> compression factor <span class="math">k</span> for the elements of <span class="math">G_{\\ell}\\subsetneq G_{q,k}\\subset\\mathbb{F}_{q^{k}}</span>, where <span class="math">\\ell\\approx q</span>. We analyze two particular cases in Sections 4 and 5 and show that, in contrast to our pessimistic arguments in Section 3, one can obtain factor-<span class="math">4</span> and factor-<span class="math">6</span> compression using torus-based techniques. In Sections 6 and 7 we describe several exponentiation algorithms based on our compression and decompression techniques. In Section 8 we give a comparison of exponentiation algorithms and conclude in Section 9.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2. A review of torus-based compression</h2>

    <p class="text-gray-300">Let <span class="math">q</span> be a prime power and <span class="math">\\mathbb{F}_{q}</span> denote the finite field of order <span class="math">q</span>. We denote the trace function <span class="math">\\operatorname{Tr}_{\\mathbb{F}_{q^{i}}/\\mathbb{F}_{q^{j}}}:~{}\\mathbb{F}_{q^{i}}\\to\\mathbb{F}_{q^{j}}</span> by <span class="math">\\operatorname{Tr}_{q^{i},q^{j}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\ell</span> be a positive integer such that <span class="math">\\gcd(\\ell,q)=1</span>, and let <span class="math">k</span> be the smallest positive integer such that <span class="math">q^{k}\\equiv 1\\pmod{\\ell}</span>. Then the order-<span class="math">\\ell</span> group <span class="math">G_{\\ell}</span> is a subgroup of the cyclotomic subgroup <span class="math">G_{q,k}\\subset\\mathbb{F}_{q^{k}}^{*}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{q,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Phi_{k}(q)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Rubin and Silverberg proved that <span class="math">G_{q,k}</span> is isomorphic to the <span class="math">\\mathbb{F}_{q}</span>-rational points of an algebraic torus <span class="math">\\mathbb{T}_{q,k}</span> of dimension <span class="math">\\varphi(k)</span> over <span class="math">\\mathbb{F}_{q}</span>. In particular, for <span class="math">k=2</span> and <span class="math">k=6</span> they presented explicit compression and decompression algorithms for the elements of <span class="math">\\mathbb{T}_{q,k}(\\mathbb{F}_{q})</span> achieving compression factors <span class="math">2/\\varphi(2)=2</span> and <span class="math">3=6/\\varphi(6)</span>. The compression and decompression maps that correspond</p>

    <p class="text-gray-300">to the case <span class="math">k=2</span> will be the building blocks in our arguments, so we explicitly state them here for future reference (see <em>[12, 13]</em> for more details).</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q^{2}}=\\mathbb{F}_{q}[\\sigma]/(f(\\sigma))</span>. If <span class="math">q</span> is even, we set <span class="math">f(\\sigma)=\\sigma^{2}+\\sigma+c</span> with <span class="math">c\\in\\mathbb{F}_{q}</span> and <span class="math">\\mathrm{Tr}_{q^{2},2}(c)=1</span>. If <span class="math">q</span> is odd, we set <span class="math">f(\\sigma)=\\sigma^{2}-c</span> where <span class="math">c\\in\\mathbb{F}_{q}</span> is a quadratic non-residue. Then</p>

    <p class="text-gray-300">(2.1) <span class="math">\\mathcal{C}:</span> <span class="math">\\quad G_{q,2}\\setminus\\{\\pm 1\\}\\quad\\to\\mathbb{F}_{q}</span> <span class="math">\\quad g_{0}+g_{1}\\sigma\\quad\\ \\mapsto\\frac{g_{0}+1}{g_{1}},</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">(2.2) <span class="math">\\mathcal{D}:</span> <span class="math">\\quad\\mathbb{F}_{q}\\quad\\to G_{q,2}</span> <span class="math">\\quad\\alpha\\quad\\mapsto\\left\\{\\begin{array}[]{ll}\\frac{\\alpha+\\sigma}{\\alpha+1+\\sigma}&amp;\\text{if </span>q<span class="math"> is even,}\\cr\\frac{\\alpha+\\sigma}{\\alpha-\\sigma}&amp;\\text{if </span>q<span class="math"> is odd,}\\end{array}\\right.</span></p>

    <p class="text-gray-300">define the compression and the decompression maps, respectively <em>[13]</em>. After observing that</p>

    <p class="text-gray-300"><span class="math">G_{q,2}</span> <span class="math">=\\{g_{0}+g_{1}\\sigma:\\ g_{0},g_{1}\\in\\mathbb{F}_{q}\\text{ and }(g_{0}+g_{1}\\sigma)^{q+1}=1\\}</span> <span class="math">=\\left\\{\\{g_{0}+g_{1}\\sigma:\\ g_{0},g_{1}\\in\\mathbb{F}_{q}\\text{ and }g_{0}^{2}+cg_{1}^{2}+g_{0}g_{1}=1\\quad\\text{if </span>q<span class="math"> is even;}\\right.</span> <span class="math">\\left\\{g_{0}+g_{1}\\sigma:\\ g_{0},g_{1}\\in\\mathbb{F}_{q}\\text{ and }g_{0}^{2}-cg_{1}^{2}=1\\quad\\quad\\quad\\text{if </span>q<span class="math"> is odd,}\\right.</span></p>

    <p class="text-gray-300">one can check that <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{D}</span> are inverses of each other when they are defined, and that</p>

    <p class="text-gray-300">(2.3) <span class="math">\\mathcal{D}(\\alpha)\\mathcal{D}(\\beta)</span> <span class="math">=</span> <span class="math">\\mathcal{D}\\left(\\frac{\\alpha\\beta+c}{\\alpha+\\beta+1}\\right)\\quad\\text{if </span>q<span class="math"> is even,}</span> (2.4) <span class="math">\\mathcal{D}(\\alpha)\\mathcal{D}(\\beta)</span> <span class="math">=</span> <span class="math">\\mathcal{D}\\left(\\frac{\\alpha\\beta+c}{\\alpha+\\beta}\\right)\\quad\\text{if </span>q<span class="math"> is odd.}</span></p>

    <p class="text-gray-300">We note that formulas (2.3) and (2.4) can be used to perform multiplication and exponentiation in <span class="math">G_{q,2}\\setminus\\{\\pm 1\\}</span> when working with the compressed representation of elements in <span class="math">\\mathbb{F}_{q}</span>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3. On the (im)possibility of optimal compression</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Section 2 we saw that one can at best hope to compress the elements of <span class="math">G_{q,k}\\subset\\mathbb{F}_{q^{k}}^{*}</span> by a factor <span class="math">k/\\varphi(k)</span> which seems to be the optimal compression factor as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{q,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx q^{\\varphi(k)}<span class="math">. However, it is also known that for </span>k=4<span class="math"> and </span>k=6<span class="math">, one can compress further by a factor of </span>2<span class="math"> and obtain compression factor </span>2k/\\varphi(k)=k<span class="math"> for the elements of certain proper subgroups </span>G_{\\ell}<span class="math"> of </span>G_{q,k}<span class="math"> <em>[15, 8]</em>. In particular, for </span>k=4<span class="math"> we have </span>q=2^{m}<span class="math"> and </span>\\ell=q\\pm\\sqrt{2q}+1<span class="math">, and for </span>k=6<span class="math"> we have </span>q=3^{m}<span class="math"> and </span>\\ell=q\\pm\\sqrt{3q}+1<span class="math">; in both cases, </span>m<span class="math"> is odd. Note that, in both cases, </span>G_{\\ell}\\approx q<span class="math"> and so </span>k<span class="math"> is the optimal compression factor. In general, it would be desirable to compress the elements of any order-</span>\\ell<span class="math"> subgroup </span>G_{\\ell}\\subsetneq G_{q,k}\\subseteq\\mathbb{F}_{q^{k}}^{<em>}<span class="math"> by an </em>optimal* factor </span>(k\\log q)/\\log\\ell$ in any characteristic.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We first recall some details on how to achieve compression factor <span class="math">k=4</span> in characteristic-two fields using the trace representation of elements, and explain why this compression technique does not seem to generalize to fields with characteristic different from two.</p>

    <p class="text-gray-300">Let <span class="math">q=2^{m},t=\\sqrt{2q}</span> and <span class="math">\\ell=q\\pm t+1</span>, where <span class="math">m</span> is odd. We note that <span class="math">\\Phi_{4}(q)=q^{2}+1=(q+t-1)(q-t+1)</span> and <span class="math">G_{\\ell}\\subset G_{q,4}\\subset\\mathbb{F}_{q^{4}}^{<em>}</span> has embedding degree <span class="math">k=4</span> with respect to <span class="math">q</span>. In </em>[8]*, it was shown that if <span class="math">g\\in G_{\\ell}</span> then the minimal polynomial <span class="math">f_{g}</span> of <span class="math">g</span> over <span class="math">\\mathbb{F}_{q}</span> is</p>

    <p class="text-gray-300"><span class="math">f_{g}(x)=x^{4}-\\mathrm{Tr}_{q^{4},q}(g)x^{3}+\\mathrm{Tr}_{q^{4},q}(g)^{t}x^{2}-\\mathrm{Tr}_{q^{4},q}(g)x+1.</span></p>

    <p class="text-gray-300">One readily deduces that <span class="math">g</span> can be uniquely identified up to conjugation over <span class="math">\\mathbb{F}_{q}</span> from <span class="math">\\mathrm{Tr}_{q^{4},q}(g)</span>, thereby achieving factor-<span class="math">4</span> compression. A natural extension is to try to represent the elements of <span class="math">G_{\\ell}</span> with embedding degree <span class="math">4</span> using their traces over <span class="math">\\mathbb{F}_{q}</span>, where <span class="math">q</span> is not even. We fix parameters <span class="math">(q,\\ell)</span> such that <span class="math">q</span> is a prime power, <span class="math">\\gcd(q,\\ell)=1</span>, <span class="math">q^{2}+1\\equiv 0\\pmod{\\ell}</span>, and <span class="math">q^{i}\\not\\equiv 1\\pmod{\\ell}</span></p>

    <p class="text-gray-300"><span class="math">1\\leq i&lt;4</span>. It is shown in <em>[8]</em> that the minimal polynomial <span class="math">f_{g}</span> of <span class="math">g\\in G_{\\ell}</span> over <span class="math">\\mathbb{F}_{q}</span> can be computed as</p>

    <p class="text-gray-300"><span class="math">f_{g}(x)=x^{4}-\\operatorname{Tr}_{q^{4},q}(g)x^{3}+(\\operatorname{Tr}_{q^{4},q}(g^{q+1})+2)x^{2}-\\operatorname{Tr}_{q^{4},q}(g)x+1.</span></p>

    <p class="text-gray-300">Therefore, two <span class="math">\\mathbb{F}_{q}</span>-elements (as opposed to only one) are generally required to identify <span class="math">g</span> uniquely up to its conjugates over <span class="math">\\mathbb{F}_{q}</span>, unless one of <span class="math">\\operatorname{Tr}_{q^{4},q}(g)</span> or <span class="math">\\operatorname{Tr}_{q^{4},q}(g^{q+1})</span> can be obtained from the other. In fact, one can find parameters <span class="math">(q,\\ell)</span>, and elements <span class="math">g_{1},g_{2}\\in G_{\\ell}\\subsetneq G_{q,4}</span> such that <span class="math">g_{1}</span> and <span class="math">g_{2}</span> are not conjugates over <span class="math">\\mathbb{F}_{q}</span> but <span class="math">\\operatorname{Tr}_{q^{4},q}(g_{1})=\\operatorname{Tr}_{q^{4},q}(g_{2})</span>.</p>

    <p class="text-gray-300">Next, we provide some evidence that, in general, compressing the elements of <span class="math">G_{\\ell}\\subsetneq G_{q,k}\\subseteq\\mathbb{F}_{q^{k}}^{<em>}</span> by an optimal factor <span class="math">(k\\log q)/\\log\\ell</span> might not be possible using </em>tori-like<em> techniques. Again, we consider the case <span class="math">k=4</span> and <span class="math">\\ell\\approx q</span>. Note that <span class="math">(k\\log q)/\\log\\ell\\approx 4</span>. Let <span class="math">\\mathbb{F}_{q^{2}}=\\mathbb{F}_{q}[w]/(g(w))</span> and <span class="math">\\mathbb{F}_{q^{4}}=\\mathbb{F}_{q^{2}}[\\sigma]/(f(\\sigma))</span> for some suitable <span class="math">f</span> and <span class="math">g</span>. Let <span class="math">g=g_{0}+g_{1}\\sigma\\in G_{\\ell}</span> and recall from Section 2 that if <span class="math">g\\neq\\pm 1</span> then it can be uniquely identified with an element <span class="math">\\alpha\\in\\mathbb{F}_{q^{2}}</span> if <span class="math">f(\\sigma)</span> is of the form <span class="math">\\sigma^{2}-c</span> or <span class="math">\\sigma^{2}+\\sigma+c</span>; see (2.1) and (2.2). More precisely, if <span class="math">g=g_{0}+g_{1}\\sigma</span> then <span class="math">\\alpha=(g_{0}+1)/g_{1}</span> and <span class="math">g=\\mathcal{D}(\\alpha)</span>, where <span class="math">\\mathcal{D}(\\alpha)=(\\alpha+\\sigma)/(\\alpha-\\sigma)</span> if <span class="math">q</span> is even, and <span class="math">\\mathcal{D}(\\alpha)=(\\alpha+\\sigma)/(\\alpha+1+\\sigma)</span> if <span class="math">q</span> is odd. Let <span class="math">\\alpha=a+bw</span> for some <span class="math">a,b\\in\\mathbb{F}_{q}</span>. Note that the compression of <span class="math">g</span> into <span class="math">(a,b)</span> does not utilize the fact that <span class="math">g</span> lies in a proper subgroup <span class="math">G_{\\ell}</span> of <span class="math">G_{q,4}</span>. Therefore, one might try to compress <span class="math">g</span> further into <span class="math">b</span> (or <span class="math">a</span>), by using the relation <span class="math">g^{\\ell}=1</span> to obtain an expression for one of <span class="math">a</span> and <span class="math">b</span> in terms of the other. For example, the most naive way would be to use the relation <span class="math">g^{\\ell}=1</span> and obtain a polynomial <span class="math">P(x,y)\\in\\mathbb{F}_{q}[x,y]</span> such that <span class="math">P(a,b)=0</span>. Then we would hope to find <span class="math">a</span> among the roots of <span class="math">P(x,b)=0</span>. Since we also want the corresponding decompression function to be efficiently computable and </em>almost* one-to-one we might ask the following question.</p>

    <p class="text-gray-300">Question: What is the minimum expected degree and sparsity of a polynomial <span class="math">P(x,y)\\in\\bar{\\mathbb{F}}_{q}[x,y]</span> such that (i) for (<em>almost</em>) all <span class="math">b\\in\\mathbb{F}_{q}</span> there exists an (<em>almost</em>) unique solution <span class="math">a\\in\\mathbb{F}_{q}</span> to <span class="math">P(x,b)=0</span>; and (ii) for <span class="math">\\alpha=a+bw</span> we have <span class="math">\\mathcal{D}(\\alpha)\\in G_{\\ell}</span>.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Remark 3.1.</h6>

    <p class="text-gray-300">Given <span class="math">\\binom{n+m}{n}</span> pairs <span class="math">(X_{i},z_{i})\\in\\mathbb{F}_{q}^{m}\\times\\mathbb{F}_{q}</span>, an <span class="math">n</span>th degree polynomial <span class="math">P</span> in <span class="math">m</span> variables can be constructed such that <span class="math">P(X_{i})=z_{i}</span>. Note that <span class="math">\\binom{n+m}{n}</span> is the number of ways of choosing <span class="math">n</span> elements from a set of <span class="math">m+1</span> elements with repetitions allowed, which is therefore the maximum number of monomials in <span class="math">P</span>. Hence, when <span class="math">m=2</span> we would expect <span class="math">\\deg(P(x,y))\\leq\\sqrt{\\ell}\\approx\\sqrt{q}</span>. We would even expect, in general, that <span class="math">\\deg(P(x,y))\\approx\\sqrt{q}</span> unless the relation <span class="math">g^{\\ell}=1</span> can be manipulated towards obtaining a polynomial <span class="math">P(x,y)</span> of a rather special form. This shows that tori-like techniques described above will likely fail to produce efficient compression and decompression functions.</p>

    <h2 id="sec-6" class="text-2xl font-bold">4. Factor-4 compression in characteristic two</h2>

    <p class="text-gray-300">Let <span class="math">q=2^{m}</span>, <span class="math">m</span> odd, <span class="math">t=\\sqrt{2q}</span>, <span class="math">\\ell=q+1-t</span> and <span class="math">\\bar{\\ell}=q+1+t</span>. Then</p>

    <p class="text-gray-300"><span class="math">q^{4}-1</span> <span class="math">=</span> <span class="math">(q^{2}-1)(q^{2}+1)</span> <span class="math">=</span> <span class="math">(q^{2}-1)(q+1-t)(q+1+t).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">G_{\\ell}\\subset G_{q,4}\\subset\\mathbb{F}_{q^{4}}^{<em>}</span> and <span class="math">G_{\\bar{\\ell}}\\subset G_{q,4}\\subset\\mathbb{F}_{q^{4}}^{</em>}</span> be subgroups such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{q,4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q^{2}+1<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\bar{\\ell}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\bar{\\ell}<span class="math">. In this section, we set </span>\\mathbb{F}_{q^{2}}=\\mathbb{F}_{q}[w]/(w^{2}+w+c_{0})<span class="math"> and </span>\\mathbb{F}_{q^{4}}=\\mathbb{F}_{q^{2}}[\\sigma]/(\\sigma^{2}+\\sigma+c_{1})<span class="math">. We must have </span>\\operatorname{Tr}_{q,2}(c_{0})=\\operatorname{Tr}_{q^{2},2}(c_{1})=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-7" class="text-base font-medium mt-4">Lemma 4.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q^{2}}=\\mathbb{F}_{q}[w]/(w^{2}+w+c_{0})</span> and <span class="math">\\mathbb{F}_{q^{4}}=\\mathbb{F}_{q^{2}}[\\sigma]/(\\sigma^{2}+\\sigma+c_{1})</span> with <span class="math">\\operatorname{Tr}_{q,2}(c_{0})=\\operatorname{Tr}_{q^{2},2}(c_{1})=1</span>. Then</p>

    <p class="text-gray-300">(4.1) <span class="math">\\sigma^{q}+\\sigma</span> <span class="math">=</span> <span class="math">\\sum_{i=0}^{m-1}c_{1}^{2^{i}}=u_{0}+u_{1}w,</span></p>

    <p class="text-gray-300">TORUS-BASED COMPRESSION BY FACTOR 4 AND 6</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma^ {t} + \\sigma = \\sum_ {i = 0} ^ {(m - 1) / 2} c _ {1} ^ {2 ^ {i}} = u _ {2} + u _ {3} w, \\tag {4.2}</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {q} + w = 1, \\tag {4.3}</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {t} + w = \\sum_ {i = 0} ^ {(m - 1) / 2} c _ {0} ^ {2 ^ {i}} = u _ {4}, \\tag {4.4}</span></div>

    <p class="text-gray-300">for some  <span class="math">u_{i}\\in \\mathbb{F}_{q}</span> . In particular,  <span class="math">u_{1} = 1</span> .</p>

    <p class="text-gray-300">Proof. The equalities can be proven by repeatedly squaring the equations  <span class="math">\\sigma^2 + \\sigma = c_1</span>  and  <span class="math">w^2 + w = c_0</span> . We have  <span class="math">u_1 = 1</span>  since</p>

    <div class="my-4 text-center"><span class="math-block">1 = \\operatorname {T r} _ {q ^ {2}, 2} (c _ {1}) = (\\sigma + \\sigma^ {q}) + (\\sigma + \\sigma^ {q}) ^ {q} = u _ {1} (w + w ^ {q}) = u _ {1}.</span></div>

    <p class="text-gray-300">We furthermore assume throughout this section that  <span class="math">\\sigma^2 +\\sigma = c_1 = u_5 + u_6w</span>  , where  <span class="math">u_{5},u_{6}\\in \\mathbb{F}_{q}</span></p>

    <p class="text-gray-300">Let  <span class="math">g = g_{0} + g_{1}\\sigma \\in G_{q,4}</span> . We already know from Section 2 that if  <span class="math">g \\neq 1</span>  then  <span class="math">g</span>  can be compressed to an element  <span class="math">\\alpha = (g_0 + 1) / g_1 \\in \\mathbb{F}_{q^2}</span> , and that a compressed element  <span class="math">\\alpha \\in \\mathbb{F}_{q^2}</span>  can be decompressed to obtain  <span class="math">g = (\\alpha + \\sigma) / (\\alpha + 1 + \\sigma) \\in G_{q,4} \\setminus \\{1\\}</span> . Our objective is to show that  <span class="math">g \\in \\{G_{\\ell}, G_{\\bar{\\ell}}\\} \\setminus \\{1\\}</span>  can further be compressed to  <span class="math">b \\in \\mathbb{F}_q</span> , and that a compressed  <span class="math">b \\in \\mathbb{F}_q</span>  can be decompressed to obtain  <span class="math">g \\in \\{G_{\\ell}, G_{\\bar{\\ell}}\\} \\setminus \\{1\\}</span> . The following theorem plays a key role.</p>

    <p class="text-gray-300">Theorem 4.2. Let  <span class="math">g = (\\alpha + \\sigma) / (\\alpha + 1 + \\sigma) \\in G_{q,4} \\setminus \\{1\\}</span>  where  <span class="math">\\alpha = a + bw \\in \\mathbb{F}_{q^2}</span>  for some  <span class="math">a, b \\in \\mathbb{F}_q</span> . If  <span class="math">g \\in G_{\\ell}</span>  then  <span class="math">a</span>  is a root of the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">P _ {1} (x, b) = x ^ {t} + x + b ^ {t + 1} + (u _ {0} + u _ {4}) b ^ {t} + (u _ {0} + u _ {3} + 1) b + (u _ {0} u _ {3} + u _ {2} + u _ {6}),</span></div>

    <p class="text-gray-300">where the  <span class="math">u_{i}</span> 's are as specified in Lemma 4.1. If  <span class="math">g \\in G_{\\bar{\\ell}}</span>  then  <span class="math">a</span>  is a root of the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">P _ {1} (x, b) = x ^ {t} + x + b ^ {t + 1} + (u _ {0} + u _ {4}) b ^ {t} + (u _ {0} + u _ {3} + 1) b + (u _ {0} u _ {3} + u _ {2} + u _ {6} + 1).</span></div>

    <p class="text-gray-300">Proof. Let  <span class="math">g = (\\alpha + \\sigma) / (\\alpha + 1 + \\sigma) \\in G_{\\ell} \\setminus \\{1\\}</span> . After expanding and simplifying  <span class="math">g^{q+1-t} = 1</span> , we find that  <span class="math">\\alpha + \\sigma</span>  is a root of</p>

    <div class="my-4 text-center"><span class="math-block">P (x) = x ^ {q + t} + x ^ {q + 1} + x ^ {t + 1} + x ^ {t}.</span></div>

    <p class="text-gray-300">Now, writing  <span class="math">\\alpha = a + bw</span>  for some  <span class="math">a,b\\in \\mathbb{F}_q</span>  and simplifying  <span class="math">P(\\alpha +\\sigma) = 0</span>  gives us</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P (\\alpha) = a ^ {2} + a b + (\\sigma^ {q} + \\sigma) a + (w ^ {2} + w) b ^ {2} + b a ^ {t} + w ^ {t} b ^ {t + 1} \\\\ + (w (\\sigma^ {q} + \\sigma) + \\sigma^ {t} + \\sigma) b + (\\sigma^ {q} + \\sigma + 1) a ^ {t} \\\\ + (w ^ {t} (\\sigma^ {q} + \\sigma + 1)) b ^ {t} + (\\sigma^ {q} (\\sigma^ {t} + \\sigma) + \\sigma^ {t} (\\sigma + 1)) \\\\ = a ^ {2} + a b + (u _ {0} + w) a + c _ {0} b ^ {2} + b a ^ {t} + (u _ {4} + w) b ^ {t + 1} \\\\ + \\left(\\left(u _ {0} + u _ {3} + 1\\right) w + \\left(c _ {0} + u _ {2}\\right)\\right) b + \\left(u _ {0} + 1 + w\\right) a ^ {t} \\\\ + \\left(\\left(u _ {0} + u _ {4}\\right) w + \\left(c _ {0} + u _ {0} u _ {4} + u _ {4}\\right)\\right) b ^ {t} + \\left(u _ {0} u _ {3} + u _ {2} + u _ {6}\\right) w \\\\ + \\left(c _ {0} u _ {3} + u _ {0} u _ {2} + u _ {2} + u _ {5}\\right) \\\\ = P _ {0} (a, b) + P _ {1} (a, b) w = 0, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P _ {0} (a, b) = a ^ {t} b + (u _ {0} + 1) a ^ {t} + a ^ {2} + a b + u _ {0} a + u _ {4} b ^ {t + 1} \\\\ + (c _ {0} + u _ {0} u _ {4} + u _ {4}) b ^ {t} + c _ {0} b ^ {2} + (c _ {0} + u _ {2}) b \\\\ + \\left(c _ {0} u _ {3} + u _ {0} u _ {2} + u _ {2} + u _ {5}\\right), \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P _ {1} (a, b) = a ^ {t} + a + b ^ {t + 1} + (u _ {0} + u _ {4}) b ^ {t} + (u _ {0} + u _ {3} + 1) b \\\\ + \\left(u _ {0} u _ {3} + u _ {2} + u _ {6}\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">KORAY KARABINA</p>

    <p class="text-gray-300">Hence, if <span class="math">g = \\frac{\\alpha + \\sigma}{\\alpha + 1 + \\sigma} \\in G_{\\ell}</span> for some <span class="math">\\alpha = a + bw \\in \\mathbb{F}_{q^2}</span> with <span class="math">a, b \\in \\mathbb{F}_q</span>, we must have <span class="math">P_0(a, b) = P_1(a, b) = 0</span>. In particular, <span class="math">a</span> must be a root of the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">P _ {1} (x) = P _ {1} (x, b) = x ^ {t} + x + b ^ {t + 1} + (u _ {0} + u _ {4}) b ^ {t} + (u _ {0} + u _ {3} + 1) b + (u _ {0} u _ {3} + u _ {2} + u _ {6}).</span></div>

    <p class="text-gray-300">The case when <span class="math">g \\in G_{\\bar{\\ell}} \\setminus \\{1\\}</span> can be proved similarly.</p>

    <p class="text-gray-300">Lemma 4.3. Let <span class="math">P_{1}(x) = x^{t} + x + u \\in \\mathbb{F}_{q}[x]</span>. Then <span class="math">P_{1}(x) = 0</span> has a solution in <span class="math">\\mathbb{F}_q</span> if and only if <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span>. If <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span> then <span class="math">P_{1}(x) = 0</span> has exactly two solutions <span class="math">a_0, a_1</span> in <span class="math">\\mathbb{F}_q</span>, and <span class="math">a_1 = a_0 + 1</span>.</p>

    <p class="text-gray-300">Proof. We first prove that <span class="math">P_{1}(x) = 0</span> has a solution in <span class="math">\\mathbb{F}_q</span> if and only if <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span>. Suppose that <span class="math">P_{1}(x) = x^{t} + x + u = 0</span> has a solution, say <span class="math">a \\in \\mathbb{F}_q</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {T r} _ {q, 2} (u) = \\operatorname {T r} _ {q, 2} \\left(a ^ {t} + a\\right) = \\operatorname {T r} _ {q, 2} (a) ^ {t} + \\operatorname {T r} _ {q, 2} (a) = 0. \\tag {4.5}</span></div>

    <p class="text-gray-300">Now, define a half-trace function <span class="math">H: \\mathbb{F}_q \\to \\mathbb{F}_q</span> as follows</p>

    <div class="my-4 text-center"><span class="math-block">H (u) = \\sum_ {i = 0} ^ {(m - 1) / 2} u ^ {2 ^ {i}}. \\tag {4.6}</span></div>

    <p class="text-gray-300">Then <span class="math">H(u)^t + H(u) = u + \\mathrm{Tr}_{q,2}(u)</span>, and so <span class="math">H(u) \\in \\mathbb{F}_q</span> is a solution to <span class="math">P_1(x) = 0</span> when <span class="math">\\mathrm{Tr}_{q,2}(u) = 0</span>.</p>

    <p class="text-gray-300">Next we prove that if <span class="math">\\operatorname{Tr}_{q,2}(u) = 0</span> then <span class="math">P_{1}(x) = 0</span> has exactly two solutions, namely <span class="math">H(u)</span> and <span class="math">H(u) + 1</span>. We first consider the case <span class="math">m = 4i + 3</span>. Note that <span class="math">q = 2^{m}</span> and <span class="math">t = \\sqrt{2q} = 2^{2i + 2}</span>. Let us fix a normal basis to represent <span class="math">\\mathbb{F}_q</span> as an <span class="math">m</span>-dimensional vector space over <span class="math">\\mathbb{F}_2</span>. In this representation, we may set</p>

    <div class="my-4 text-center"><span class="math-block">x = \\left(x _ {0}, x _ {1}, \\dots , x _ {2 i}, x _ {2 i + 1}, x _ {2 i + 2}, x _ {2 i + 3}, \\dots , x _ {4 i + 1}, x _ {4 i + 2}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">x ^ {t} = \\left(x _ {2 i + 1}, x _ {2 i + 2}, \\dots , x _ {4 i + 1}, x _ {4 i + 2}, x _ {0}, x _ {1}, \\dots , x _ {2 i - 1}, x _ {2 i}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">u = \\left(u _ {0}, u _ {1}, \\dots , u _ {2 i}, u _ {2 i + 1}, u _ {2 i + 2}, u _ {2 i + 3}, \\dots , u _ {4 i + 1}, u _ {4 i + 2}\\right).</span></div>

    <p class="text-gray-300">Then <span class="math">P_{1}(x) = 0</span> has a solution if and only if the linear system of equations determined by</p>

    <div class="my-4 text-center"><span class="math-block">x _ {j} + x _ {2 i + 2 + j} = u _ {2 i + 2 + j}, 0 \\leq j \\leq 2 i, \\tag {4.7}</span></div>

    <div class="my-4 text-center"><span class="math-block">x _ {2 i + 1 + j} + x _ {j} = u _ {j}, 1 \\leq j \\leq 2 i + 1, \\tag {4.8}</span></div>

    <div class="my-4 text-center"><span class="math-block">x _ {2 i + 2} + x _ {0} = u _ {0} \\tag {4.9}</span></div>

    <p class="text-gray-300">has a solution <span class="math">X = (x_0, x_1, \\ldots, x_{4i+2}) \\in \\mathbb{F}_2^m</span>. We can see from (4.7) and (4.8) that a choice of <span class="math">x_0 \\in \\{0, 1\\}</span> fixes <span class="math">x_j</span> for all <span class="math">1 \\leq j \\leq 4i + 2</span>, and hence fixes two vectors <span class="math">X_0</span> and <span class="math">X_1</span> in <span class="math">\\mathbb{F}_2^m</span>. Now, it follows from (4.9) that <span class="math">P_1(x) = 0</span> has a solution if and only if <span class="math">x_0 + x_{2i+1} = u_0</span>. Therefore, <span class="math">P_1(x) = 0</span> has at most two solutions in <span class="math">\\mathbb{F}_q</span>. In particular, when <span class="math">P_1(x) = 0</span> has a solution <span class="math">a_0</span> then there are exactly two solutions and the other solution is <span class="math">a_1 = a_0 + 1</span> since</p>

    <div class="my-4 text-center"><span class="math-block">P _ {1} (a _ {0} + 1) = (a _ {0} + 1) ^ {t} + (a _ {0} + 1) + u = a _ {0} ^ {t} + a _ {0} + u = 0.</span></div>

    <p class="text-gray-300">The case <span class="math">m = 4i + 1</span> can be similarly proven.</p>

    <p class="text-gray-300">Now, we are ready to describe our compression/decompression maps that achieve factor <span class="math">(4\\log q / (1 + \\log q))</span> compression.</p>

    <p class="text-gray-300">Theorem 4.4. For some fixed representation of <span class="math">\\mathbb{F}_q</span> as an <span class="math">m</span>-dimensional vector space over <span class="math">\\mathbb{F}_2</span>, let <span class="math">j</span> be a coordinate position such that the vector representations of <span class="math">\\beta</span> and <span class="math">\\beta + 1</span> differ in the <span class="math">j</span>th coordinate position for all <span class="math">\\beta \\in \\mathbb{F}_q</span>. Let <span class="math">G \\in \\{G_{\\ell}, G_{\\bar{\\ell}}\\}</span>. Define a compression map</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C}: G \\setminus \\{1 \\} \\rightarrow \\{0, 1 \\} \\times \\mathbb {F} _ {q} \\tag {4.10}</span></div>

    <div class="my-4 text-center"><span class="math-block">g \\mapsto (i, b),</span></div>

    <p class="text-gray-300">1The definition is similar to the one in [6, Section 3.6.2]</p>

    <p class="text-gray-300">TORUS-BASED COMPRESSION BY FACTOR 4 AND 6</p>

    <p class="text-gray-300">where  <span class="math">g = g_0 + g_1\\sigma</span> ,  <span class="math">(g_0 + 1) / g_1 = a + bw</span> , and  <span class="math">i</span>  is the  <span class="math">j</span> th bit in the vector representation of  <span class="math">a</span> . And define a decompression map</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {D}: \\{0, 1 \\} \\times \\mathbb {F} _ {q} \\rightarrow G \\backslash \\{1 \\} \\tag {4.11} \\\\ (i, b) \\quad \\mapsto \\quad (\\alpha + \\sigma) / (\\alpha + 1 + \\sigma), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha = a + bw</span> , and  <span class="math">a</span>  is one of the two roots of  <span class="math">P_{1}(x,b)</span>  (see Theorem 4.2) whose  <span class="math">j</span> th bit when represented as a vector over  <span class="math">\\mathbb{F}_2</span>  is equal to  <span class="math">i</span> . Then  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{D}</span>  are inverses of each other when they are defined. Moreover, if  <span class="math">\\mathcal{D}(0,b) \\in G</span>  then  <span class="math">\\mathcal{D}(1,b) \\in G</span>  and  <span class="math">\\mathcal{D}(0,b)\\mathcal{D}(1,b) = 1</span> .</p>

    <p class="text-gray-300">Proof. It follows from Theorem 4.2 and Lemma 4.3 that  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{D}</span>  are inverses of each other when they are defined. Now, by Lemma 4.3,  <span class="math">P_{1}(x,b)</span>  has exactly 2 solutions  <span class="math">a_0</span>  and  <span class="math">a_1</span>  in  <span class="math">\\mathbb{F}_q</span> , and  <span class="math">a_1 = a_0 + 1</span> . Note that since  <span class="math">g = \\frac{\\alpha + \\sigma}{\\alpha + 1 + \\sigma} \\in G</span>  with  <span class="math">\\alpha = a + bw</span>  corresponding to  <span class="math">(a_0,b)</span> , the element  <span class="math">h = \\frac{\\alpha + 1 + \\sigma}{\\alpha + \\sigma}</span>  corresponds to  <span class="math">(a_1,b)</span>  and is in fact the multiplicative inverse of  <span class="math">g</span> . It follows that  <span class="math">\\mathcal{D}(0,b)\\mathcal{D}(1,b) = 1</span> .</p>

    <p class="text-gray-300">Remark 4.5. The polynomials  <span class="math">P_0(x,y)</span>  and  <span class="math">P_1(x,y)</span>  are both of degree  <span class="math">(t + 1) \\approx \\sqrt{q}</span>  which is in accordance with Remark 3.1. However,  <span class="math">P_1(x,b)</span>  is very sparse and moreover it is easy to find a root  <span class="math">a \\in \\mathbb{F}_q</span> , in contrast to what one would expect in general for high-degree polynomials.</p>

    <p class="text-gray-300">Let  <span class="math">q = 3^m</span> ,  <span class="math">m \\equiv 5 \\pmod{12}</span> ,  <span class="math">t = \\sqrt{3q}</span>  and  <span class="math">\\ell = q + 1 - t</span> . Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} q ^ {6} - 1 = (q ^ {3} - 1) (q ^ {3} + 1) \\\\ = (q ^ {3} - 1) (q + 1) (q ^ {2} - q + 1) \\\\ = (q ^ {3} - 1) (q + 1) (q + 1 - t) (q + 1 + t). \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">G_{\\ell} \\subset G_{q,6} \\subset \\mathbb{F}_{q^6}^*</span>  be subgroups such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{q,6}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q^2 - q + 1<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell<span class="math"> . Since  </span>f(w) = w^3 - w - 1<span class="math">  has splitting field  </span>\\mathbb{F}_{3^3}<span class="math">  and  </span>\\gcd(3,m) = 1<span class="math"> ,  </span>f<span class="math">  is irreducible over  </span>\\mathbb{F}_q<span class="math">  and we set  </span>\\mathbb{F}_{q^3} = \\mathbb{F}_q[w] / (w^3 - w - 1)<span class="math"> . We also let  </span>c_0 \\in \\mathbb{F}_{q^3}<span class="math">  be a quadratic non-residue and set  </span>\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma] / (\\sigma^2 - c_0)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 5.1. Let  <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[w] / (w^3 - w - 1)</span>  and  <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma] / (\\sigma^2 - c_0)</span>  where  <span class="math">c_0 \\in \\mathbb{F}_{q^3}</span>  is a quadratic non-residue. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma^ {t} = c _ {1} \\sigma ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma^ {q} = c _ {2} \\sigma ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma^ {q ^ {2}} = c _ {3} \\sigma ,</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {t} = w,</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {2 t} = w ^ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {q} = w + 2,</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {2 q} = w ^ {2} + w + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {q ^ {2}} = w + 1,</span></div>

    <p class="text-gray-300">for some  <span class="math">c_{1},c_{2},c_{3}\\in \\mathbb{F}_{q^{3}}</span></p>

    <p class="text-gray-300">Proof. The equalities can be proven by using the defining equations of  <span class="math">\\sigma</span>  and  <span class="math">w</span> , and noting that  <span class="math">w^{3^{2k}} = w + 2k</span>  and  <span class="math">w^{3^{2k+1}} = w + 1 + 2k</span> .</p>

    <p class="text-gray-300">KORAY KARABINA</p>

    <p class="text-gray-300">We furthermore assume throughout this section that  <span class="math">c_{i} = u_{3i} + u_{3i + 1}w + u_{3i + 2}w^{2}</span>  for  <span class="math">i = 0,1,2,3</span> , where  <span class="math">u_{j}\\in \\mathbb{F}_{q}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">g = g_{0} + g_{1}\\sigma \\in G_{q,6}</span> . We already know from Section 2 that if  <span class="math">g \\neq \\pm 1</span>  then  <span class="math">g</span>  can be compressed to an element  <span class="math">\\alpha = (g_{0} + 1) / g_{1} \\in \\mathbb{F}_{q^{3}}</span> , and that a compressed  <span class="math">\\alpha \\in \\mathbb{F}_{q^{3}}</span>  can be decompressed to obtain  <span class="math">g = (\\alpha + \\sigma) / (\\alpha - \\sigma) \\in G_{q,6} \\setminus \\{\\pm 1\\}</span> . Our objective is to show that  <span class="math">g \\in G_{\\ell}</span>  can be compressed to  <span class="math">c \\in \\mathbb{F}_{q}</span> , and that a compressed  <span class="math">c \\in \\mathbb{F}_{q}</span>  can be decompressed to obtain  <span class="math">g \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span> . The following theorem plays a key role.</p>

    <p class="text-gray-300">Theorem 5.2. Let  <span class="math">g = (\\alpha + \\sigma) / (\\alpha - \\sigma) \\in G_{\\ell} \\backslash \\{\\pm 1\\}</span>  where  <span class="math">\\alpha = a + bw + cw^2</span>  for some  <span class="math">a, b, c \\in \\mathbb{F}_q</span> . Then  <span class="math">(x_1, x_2, x_3, x_4, x_5, x_6) = (a, a^t, b, b^t, c, c^t)</span>  is a root of each  <span class="math">f_i</span>  and  <span class="math">g_i</span>  for  <span class="math">i = 0, 1, 2</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {0} = u _ {0} u _ {3} u _ {6} + u _ {0} u _ {4} u _ {8} + u _ {0} u _ {5} u _ {7} + u _ {1} u _ {3} u _ {8} + u _ {1} u _ {4} u _ {7} + u _ {1} u _ {5} u _ {6} \\\\ + u _ {1} u _ {5} u _ {8} + u _ {2} u _ {3} u _ {7} + u _ {2} u _ {4} u _ {6} + u _ {2} u _ {4} u _ {8} + u _ {2} u _ {5} u _ {7} + u _ {2} u _ {5} u _ {8} \\\\ + u _ {3} x _ {1} ^ {2} + (u _ {4} + 2 u _ {5}) x _ {3} ^ {2} + (u _ {3} + 2 u _ {4} + 2 u _ {5}) x _ {5} ^ {2} + (2 u _ {6} + 2) x _ {1} x _ {2} \\\\ + (2 u _ {7} + 2 u _ {8} + 2) x _ {5} x _ {6} + (2 u _ {6} + 2 u _ {8} + 2) x _ {3} x _ {6} + (2 u _ {8} + 1) x _ {2} x _ {3} \\\\ + (2 u _ {7} + 2) x _ {2} x _ {5} + (2 u _ {6} + 2 u _ {8} + 2) x _ {4} x _ {5} + (2 u _ {3} + 2 u _ {5}) x _ {1} x _ {3} \\\\ + (u _ {3} + 2 u _ {4} + u _ {5}) x _ {1} x _ {5} + 2 u _ {3} x _ {3} x _ {5} + 2 u _ {7} x _ {3} x _ {4} + 2 u _ {7} x _ {1} x _ {6} \\\\ + 2 u _ {8} x _ {1} x _ {4}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {1} = u _ {0} u _ {3} u _ {7} + u _ {0} u _ {4} u _ {6} + u _ {0} u _ {4} u _ {8} + u _ {0} u _ {5} u _ {7} + u _ {0} u _ {5} u _ {8} + u _ {1} u _ {3} u _ {6} \\\\ + u _ {1} u _ {3} u _ {8} + u _ {1} u _ {4} u _ {7} + u _ {1} u _ {4} u _ {8} + u _ {1} u _ {5} u _ {6} + u _ {1} u _ {5} u _ {7} + u _ {1} u _ {5} u _ {8} \\\\ + u _ {2} u _ {3} u _ {7} + u _ {2} u _ {3} u _ {8} + u _ {2} u _ {4} u _ {6} + u _ {2} u _ {4} u _ {7} + u _ {2} u _ {4} u _ {8} + u _ {2} u _ {5} u _ {6} \\\\ + u _ {2} u _ {5} u _ {7} + 2 u _ {2} u _ {5} u _ {8} + u _ {4} x _ {1} ^ {2} + (2 u _ {3} + u _ {4}) x _ {3} ^ {2} + (2 u _ {3} + u _ {5}) x _ {5} ^ {2} \\\\ + (2 u _ {6} + 2 u _ {7} + u _ {8} + 1) x _ {5} x _ {6} + (2 u _ {7} + 2 u _ {8} + 1) x _ {3} x _ {4} \\\\ + (2 u _ {6} + 2 u _ {7} + 2 u _ {8} + 2) x _ {3} x _ {6} + (2 u _ {6} + 2 u _ {8} + 2) x _ {2} x _ {3} \\\\ + (2 u _ {7} + 2 u _ {8} + 2) x _ {2} x _ {5} + (2 u _ {6} + 2 u _ {7} + 2 u _ {8} + 1) x _ {4} x _ {5} \\\\ + (2 u _ {7} + 2 u _ {8}) x _ {1} x _ {6} + (2 u _ {6} + 2 u _ {8} + 2) x _ {1} x _ {4} + u _ {3} x _ {1} x _ {5} \\\\ + (2 u _ {3} + 2 u _ {4} + 2 u _ {5}) x _ {1} x _ {3} + 2 u _ {4} x _ {3} x _ {5} + 2 u _ {7} x _ {1} x _ {2}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {2} = u _ {0} u _ {3} u _ {8} + u _ {0} u _ {4} u _ {7} + u _ {0} u _ {5} u _ {6} + u _ {0} u _ {5} u _ {8} + u _ {1} u _ {3} u _ {7} + u _ {1} u _ {4} u _ {6} \\\\ + u _ {1} u _ {4} u _ {8} + u _ {1} u _ {5} u _ {7} + u _ {1} u _ {5} u _ {8} + u _ {2} u _ {3} u _ {6} + u _ {2} u _ {3} u _ {8} + u _ {2} u _ {4} u _ {7} \\\\ + u _ {2} u _ {4} u _ {8} + u _ {2} u _ {5} u _ {6} + u _ {2} u _ {5} u _ {7} + u _ {2} u _ {5} u _ {8} + 2 u _ {7} x _ {2} x _ {3} + u _ {5} x _ {1} ^ {2} \\\\ + (u _ {3} + 2 u _ {4} + u _ {5}) x _ {3} ^ {2} + (2 u _ {3} + 2 u _ {4}) x _ {5} ^ {2} + (2 u _ {4} + 2 u _ {5}) x _ {1} x _ {3} \\\\ + (2 u _ {3} + u _ {4}) x _ {1} x _ {5} + 2 u _ {8} x _ {1} x _ {2} + 2 u _ {5} x _ {3} x _ {5} + 2 u _ {7} x _ {1} x _ {4} \\\\ + (2 u _ {6} + 2 u _ {7} + 2 u _ {8} + 1) x _ {5} x _ {6} + (2 u _ {6} + 2 u _ {8} + 2) x _ {3} x _ {4} \\\\ + (2 u _ {7} + 2 u _ {8} + 1) x _ {3} x _ {6} + (2 u _ {6} + 2 u _ {8} + 2) x _ {2} x _ {5} \\\\ + (2 u _ {7} + 2 u _ {8} + 2) x _ {4} x _ {5} + (2 u _ {6} + 2 u _ {8} + 2) x _ {1} x _ {6}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} g _ {0} = u _ {2} u _ {7} u _ {1 1} + u _ {2} u _ {8} u _ {1 0} + u _ {2} u _ {8} u _ {1 1} + u _ {0} u _ {6} u _ {9} + u _ {1} u _ {7} u _ {1 0} + u _ {0} u _ {7} u _ {1 1} \\\\ + u _ {0} u _ {8} u _ {1 0} + u _ {1} u _ {6} u _ {1 1} + u _ {2} u _ {7} u _ {9} + u _ {1} u _ {8} u _ {9} + u _ {1} u _ {8} u _ {1 1} + u _ {2} u _ {6} u _ {1 0} \\\\ + (2 u _ {9} + 2 + u _ {6}) x _ {1} ^ {2} + (u _ {9} + u _ {6} + 2 u _ {8} + u _ {1 1}) x _ {3} x _ {1} \\\\ + (2 u _ {9} + 1 + 2 u _ {8} + u _ {1 0} + 2 u _ {1 1} + 2 u _ {7} + u _ {6}) x _ {1} x _ {5} \\\\ + (u _ {7} + u _ {8} + 2 u _ {1 0} + u _ {1 1} + 1) x _ {3} ^ {2} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">TORUS-BASED COMPRESSION BY FACTOR 4 AND 6</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(2 u _ {6} + 2 u _ {7} + 2 u _ {9} + u _ {1 0} + u _ {1 1} + 2) x _ {5} ^ {2} + (2 u _ {6} + u _ {9} + 1) x _ {3} x _ {5}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} g _ {1} = u _ {0} u _ {6} u _ {1 0} + u _ {0} u _ {7} u _ {9} + u _ {0} u _ {7} u _ {1 1} + u _ {0} u _ {8} u _ {1 0} + u _ {0} u _ {8} u _ {1 1} + u _ {1} u _ {6} u _ {9} \\\\ + u _ {1} u _ {6} u _ {1 1} + u _ {1} u _ {7} u _ {1 0} + u _ {1} u _ {7} u _ {1 1} + u _ {1} u _ {8} u _ {9} + u _ {1} u _ {8} u _ {1 0} + u _ {1} u _ {8} u _ {1 1} \\\\ + u _ {2} u _ {6} u _ {1 0} + u _ {2} u _ {6} u _ {1 1} + u _ {2} u _ {7} u _ {9} + u _ {2} u _ {7} u _ {1 0} + u _ {2} u _ {7} u _ {1 1} + u _ {2} u _ {8} u _ {9} \\\\ + u _ {2} u _ {8} u _ {1 0} + 2 u _ {2} u _ {8} u _ {1 1} + (u _ {7} + 2 u _ {1 0}) x _ {1} ^ {2} \\\\ + (u _ {6} + u _ {7} + 2 u _ {8} + u _ {9} + 2 u _ {1 0}) x _ {3} ^ {2} \\\\ + (u _ {7} + 2 u _ {8} + u _ {9} + 2 u _ {1 1} + 2) x _ {5} ^ {2} \\\\ + (2 u _ {6} + u _ {7} + 2 u _ {8} + u _ {9} + u _ {1 0} + u _ {1 1} + 1) x _ {1} x _ {3} \\\\ + (2 u _ {6} + u _ {8} + 2 u _ {9}) x _ {1} x _ {5} + (2 u _ {7} + u _ {1 0}) x _ {3} x _ {5}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} g _ {2} = u _ {1} u _ {6} u _ {1 0} + u _ {1} u _ {7} u _ {9} + u _ {1} u _ {7} u _ {1 1} + u _ {1} u _ {8} u _ {1 0} + u _ {1} u _ {8} u _ {1 1} + u _ {2} u _ {6} u _ {9} \\\\ + u _ {2} u _ {6} u _ {1 1} + u _ {2} u _ {7} u _ {1 0} + u _ {2} u _ {7} u _ {1 1} + u _ {0} u _ {6} u _ {1 1} + u _ {0} u _ {7} u _ {1 0} + u _ {0} u _ {8} u _ {9} \\\\ + u _ {0} u _ {8} u _ {1 1} + u _ {2} u _ {8} u _ {9} + u _ {2} u _ {8} u _ {1 0} + u _ {2} u _ {8} u _ {1 1} + (u _ {8} + 2 u _ {1 1}) x _ {1} ^ {2} \\\\ + (2 u _ {7} + u _ {8} + u _ {1 0} + u _ {1 1}) x _ {1} x _ {3} \\\\ + (2 u _ {6} + 2 u _ {7} + u _ {9} + 2 u _ {1 0} + 1) x _ {1} x _ {5} \\\\ + (u _ {6} + u _ {7} + u _ {8} + 2 u _ {9} + u _ {1 0} + 2 u _ {1 1} + 2) x _ {3} ^ {2} \\\\ + (2 u _ {6} + u _ {8} + u _ {9} + u _ {1 0} + 1) x _ {5} ^ {2} + (2 u _ {8} + u _ {1 1}) x _ {3} x _ {5}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and where  <span class="math">c_{i} = u_{3i} + u_{3i + 1}w + u_{3i + 2}w^{2}</span> , for  <span class="math">i = 0,1,2,3</span> , are as specified in Lemma 5.1.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">g = (\\alpha + \\sigma) / (\\alpha - \\sigma) \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span> . Expanding the equations  <span class="math">g^{q^2 - q + 1} = 1</span>  and  <span class="math">g^{q + 1 - t} = 1</span>  and simplifying using Lemma 5.1 yields the polynomials  <span class="math">f_i, g_i \\in \\mathbb{F}_q[x_1, x_2, \\ldots, x_6]</span>  for  <span class="math">i = 0, 1, 2</span>  such that  <span class="math">(x_1, x_2, x_3, x_4, x_5, x_6) = (a, a^t, b, b^t, c, c^t)</span>  is a root of each  <span class="math">f_i</span>  and  <span class="math">g_i</span> , as required.</p>

    <p class="text-gray-300">Theorem 5.2 suggests that one can compress an element  <span class="math">g \\in G_{\\ell} \\setminus \\{\\pm 1\\}</span>  to an element  <span class="math">c \\in \\mathbb{F}_q</span> . Given a compressed representation  <span class="math">c</span>  of an element  <span class="math">g</span> , one might reconstruct  <span class="math">g</span>  by finding a common root  <span class="math">(a, a^t, b, b^t, c, c^t)</span>  of the  <span class="math">f_i</span>  and  <span class="math">g_i</span> . This may be achieved by constructing a Groebner basis of the ideal in  <span class="math">\\mathbb{F}_q[x_1, x_2, \\ldots, x_6]</span>  generated by  <span class="math">f_i</span>  and  <span class="math">g_i</span>  evaluated at  <span class="math">x_5 = c</span> ,  <span class="math">x_6 = c^t</span>  for  <span class="math">i = 0, 1, 2</span> . The next corollary shows that this is indeed possible in the case that  <span class="math">c_0 = -1</span> .</p>

    <p class="text-gray-300">Corollary 5.3. Let  <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[w] / (w^3 - w - 1)</span>  and  <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma] / (\\sigma^2 + 1)</span> . Let  <span class="math">f_i, g_i</span>  be as in Theorem 5.2. Then a Groebner basis of the ideal  <span class="math">\\langle f_0, f_1, f_2, g_0, g_1, g_2 \\rangle</span>  in  <span class="math">\\mathbb{F}_q[x_1, x_2, \\ldots, x_6]</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">P _ {1} = x _ {1} + 2 x _ {3} ^ {2} x _ {4} + 2 x _ {3} x _ {4} x _ {5} + x _ {3} + x _ {5} ^ {2} x _ {6} + 2 x _ {5},</span></div>

    <div class="my-4 text-center"><span class="math-block">P _ {2} = x _ {2} + 2 x _ {3} ^ {3} x _ {4} ^ {2} + 2 x _ {4} ^ {2} x _ {5} ^ {3} + x _ {4} x _ {5} ^ {3} x _ {6} + x _ {5} ^ {3} x _ {6} ^ {2} + 2 x _ {6},</span></div>

    <div class="my-4 text-center"><span class="math-block">P _ {3} = x _ {3} ^ {2} x _ {4} x _ {5} + 2 x _ {3} ^ {2} + x _ {3} x _ {4} x _ {5} ^ {2} + 2 x _ {3} x _ {5} + 2 x _ {5} ^ {3} x _ {6} + 2 x _ {5} ^ {2} + 2,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P _ {4} = x _ {3} x _ {4} ^ {2} x _ {5} ^ {2} + x _ {3} x _ {4} x _ {5} + x _ {3} + 2 x _ {4} ^ {2} x _ {5} ^ {3} + 2 x _ {4} x _ {5} ^ {3} x _ {6} + 2 x _ {4} x _ {5} ^ {2} \\\\ + 2 x _ {5} ^ {3} x _ {6} ^ {2} + 2 x _ {5} + 2 x _ {6}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">P _ {5} = x _ {3} x _ {6} + 2 x _ {4} x _ {5} + 2 x _ {5} x _ {6} + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">P _ {6} = x _ {4} ^ {3} x _ {5} ^ {3} + 2 x _ {4} x _ {5} ^ {3} x _ {6} ^ {2} + 2 x _ {5} ^ {3} x _ {6} ^ {3} + 2 x _ {6} ^ {2} + 2.</span></div>

    <p class="text-gray-300">Proof. If one sets  <span class="math">c_0 = -1</span>  in Theorem 5.2 then  <span class="math">g_1 = g_2 = 0</span> , and the polynomials  <span class="math">f_i</span>  and  <span class="math">g_0</span>  simplify to</p>

    <div class="my-4 text-center"><span class="math-block">f _ {0} = 2 x _ {1} ^ {2} + x _ {1} x _ {3} + 2 x _ {1} x _ {5} + x _ {2} x _ {3} + 2 x _ {2} x _ {5} + x _ {3} x _ {5} + 2 x _ {5} ^ {2} + 2 x _ {5} x _ {6} + 2,</span></div>

    <p class="text-gray-300"><span class="math">f_{1}</span> <span class="math">=</span> <span class="math">x_{1}x_{3}+2x_{1}x_{5}+2x_{2}x_{5}+x_{3}^{2}+x_{3}x_{4}+2x_{4}x_{5}+x_{5}^{2}+2x_{5}x_{6},</span> <span class="math">f_{2}</span> <span class="math">=</span> <span class="math">x_{1}x_{5}+2x_{3}^{2}+x_{3}x_{6}+2x_{4}x_{5}+x_{5}^{2}+2x_{5}x_{6},</span> <span class="math">g_{0}</span> <span class="math">=</span> <span class="math">2x_{1}x_{5}+x_{3}^{2}+2x_{5}^{2}+1.</span></p>

    <p class="text-gray-300">It can be verified using Magma with the commands</p>

    <p class="text-gray-300"><span class="math">\\mathrm{R}&lt;x1,x2,x3,x4,x5,x6&gt;:=</span> <span class="math">\\mathrm{PolynomialRing}(\\mathrm{FiniteField}(3),6);</span> <span class="math">\\mathrm{B}:=</span> <span class="math">[\\mathrm{R!}f_{0},\\mathrm{R!}f_{1},\\mathrm{R!}f_{2},\\mathrm{R!}g_{0}];</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathrm{I}:=</span> $\\mathrm{ideal}<\\mathrm{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{B}>;$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{GroebnerBasis(I);}</span></p>

    <p class="text-gray-300">that a Groebner basis of the ideal <span class="math">\\langle f_{0},f_{1},f_{2},g_{0}\\rangle</span> in <span class="math">\\mathbb{F}_{q}[x_{1},x_{2},\\ldots,x_{6}]</span> is determined by the <span class="math">P_{i}</span>â€™s, as required. âˆŽ</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">5.1. Decompression procedure</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q^{3}}=\\mathbb{F}_{q}[w]/(w^{3}-w-1)</span> and <span class="math">\\mathbb{F}_{q^{6}}=\\mathbb{F}_{q^{3}}[\\sigma]/(\\sigma^{2}+1)</span>. Let <span class="math">g=(\\alpha+\\sigma)/(\\alpha-\\sigma)\\in G_{\\ell}\\setminus\\{\\pm 1\\}</span> where <span class="math">\\alpha=a+bw+cw^{2}</span> for some <span class="math">a,b,c\\in\\mathbb{F}_{q}</span>. By Theorem 5.2 and Corollary 5.3, <span class="math">b^{t}</span> must be a root of</p>

    <p class="text-gray-300">(5.1) <span class="math">P_{6}(x_{4})=c^{3}x_{4}^{3}+2c^{2t+3}x_{4}+2(c^{3(t+1)}+c^{2t}+1).</span></p>

    <p class="text-gray-300">In fact, there are exactly three roots of <span class="math">P_{6}(x_{4})</span> in <span class="math">\\mathbb{F}_{q}</span>, and if <span class="math">r</span> is a root then the other two roots are given by <span class="math">r\\pm c^{t}</span>. Therefore, if <span class="math">c</span> is given, <span class="math">b^{t}</span> can be determined uniquely up to 3 elements, that is, <span class="math">b^{t}\\in\\{r,r-c^{t},r+c^{t}\\}</span>. Once <span class="math">b^{t}</span> is fixed, one can solve for <span class="math">b</span> uniquely by using <span class="math">P_{5}(x_{3})=0</span>, where <span class="math">P_{5}(x_{3})</span> is obtained by evaluating <span class="math">P_{5}</span> at <span class="math">x_{4}=b^{t}</span>, <span class="math">x_{5}=c</span>, <span class="math">x_{6}=c^{t}</span> (see Corollary 5.3), or by using the fact that <span class="math">b\\mapsto b^{t}</span> is a Frobenius map. Having determined <span class="math">b</span>, <span class="math">b^{t}</span>, <span class="math">c</span> and <span class="math">c^{t}</span> we can use <span class="math">P_{2}(x_{2})=0</span>, where <span class="math">P_{2}(x_{2})</span> is obtained by evaluating <span class="math">P_{2}</span> at <span class="math">x_{3}=b</span>, <span class="math">x_{4}=b^{t}</span>, <span class="math">x_{5}=c</span>, <span class="math">x_{6}=c^{t}</span> (see Corollary 5.3), to solve for <span class="math">a^{t}</span> uniquely. Finally, <span class="math">a</span> can be determined either by using <span class="math">P_{1}(x_{1})=0</span>, where <span class="math">P_{1}(x_{1})</span> is obtained by evaluating <span class="math">P_{1}</span> at <span class="math">x_{3}=b</span>, <span class="math">x_{4}=b^{t}</span>, <span class="math">x_{5}=c</span>, <span class="math">x_{6}=c^{t}</span> (see Corollary 5.3), or by using the fact that <span class="math">a\\mapsto a^{t}</span> is a Frobenius map.</p>

    <p class="text-gray-300">To summarize, suppose that <span class="math">g\\in G_{\\ell}\\setminus\\{\\pm 1\\}</span> and <span class="math">g=(\\alpha+\\sigma)/(\\alpha-\\sigma)</span> with <span class="math">\\alpha=a+bw+cw^{2}</span>. If <span class="math">c</span> is given, then the three pairs <span class="math">(x_{1h},x_{3h})</span>, <span class="math">h=1,2,3</span> can be efficiently determined such that <span class="math">(a,b,c)\\in\\{(x_{1h},x_{3h},c):\\ h=1,2,3\\}</span>. In fact, one can check that <span class="math">c\\neq 0</span> and</p>

    <p class="text-gray-300"><span class="math">\\{(x_{1h},x_{3h},c):\\ h=1,2,3\\}=\\{(a,b,c),(a-b+c,b+c,c),(a+b+c,b-c,c)\\}.</span></p>

    <p class="text-gray-300">Suppose now that we have fixed some representation of <span class="math">\\mathbb{F}_{q}</span> as an <span class="math">m</span>-dimensional vector space over <span class="math">\\mathbb{F}_{3}</span>. Then there must exist a smallest index <span class="math">j</span> such that exactly one of <span class="math">x_{3h}</span>â€™s <span class="math">j</span>â€™th trit is equal to <span class="math">b</span>â€™s <span class="math">j</span>â€™th trit, say <span class="math">i\\in\\{0,1,2\\}</span>, when they are represented as vectors over <span class="math">\\mathbb{F}_{3}</span>. This yields one-to-one compression/decompression maps that achieve factor-<span class="math">(6\\log q)/(2+\\log q)</span> compression.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 5.4.</h6>

    <p class="text-gray-300">Define a compression map</p>

    <p class="text-gray-300">(5.2) <span class="math">\\mathcal{C}:G_{\\ell}\\setminus\\{\\pm 1\\}</span> <span class="math">\\to</span> <span class="math">\\{0,1,2\\}\\times\\mathbb{F}_{q}</span> <span class="math">g</span> <span class="math">\\mapsto</span> <span class="math">(i,c),</span></p>

    <p class="text-gray-300">where <span class="math">g=g_{0}+g_{1}\\sigma</span>, <span class="math">(g_{0}+1)/g_{1}=a+bw+cw^{2}</span>, and <span class="math">i</span> is defined above. Define a decompression map</p>

    <p class="text-gray-300">(5.3) <span class="math">\\mathcal{D}:\\{0,1,2\\}\\times\\mathbb{F}_{q}</span> <span class="math">\\to</span> <span class="math">G_{\\ell}\\setminus\\{\\pm 1\\}</span> <span class="math">(i,c)</span> <span class="math">\\mapsto</span> <span class="math">(\\alpha+\\sigma)/(\\alpha-\\sigma),</span></p>

    <p class="text-gray-300">where <span class="math">\\alpha=a+bw+cw^{2}</span>, and <span class="math">a,b</span> can be constructed as described above. Then <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{D}</span> are inverses of each other when they are defined. Moreover, if <span class="math">\\mathcal{D}(0,c)\\in G_{\\ell}\\setminus\\{\\pm 1\\}</span> then <span class="math">\\mathcal{D}(i,b)\\in G_{\\ell}\\setminus\\{\\pm 1\\}</span> for <span class="math">i=1,2</span>, and <span class="math">\\mathcal{D}(0,c)\\mathcal{D}(1,c)\\mathcal{D}(2,c)=1</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It is clear from our arguments above that <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{D}</span> are inverses of each other when they are defined. Now, let <span class="math">c\\in\\mathbb{F}_{q}^{*}</span> be such that <span class="math">g=(\\alpha+\\sigma)/(\\alpha-\\sigma)\\in G_{\\ell}\\setminus\\{\\pm 1\\}</span>, where <span class="math">\\alpha=a+bw+cw^{2}</span>. Let <span class="math">i_{1}</span> be the <span class="math">j</span>th trit of <span class="math">b</span>, where <span class="math">j</span> is the smallest index such that if <span class="math">(b+c)</span>â€™s <span class="math">j</span>â€™th trit is <span class="math">i_{2}</span> and <span class="math">(b-c)</span>â€™s <span class="math">j</span>â€™th trit is <span class="math">i_{3}</span>, then <span class="math">i_{1},i_{2},i_{3}</span> are pairwise different. It follows from our arguments above that the decompression function satisfies <span class="math">\\mathcal{D}(i_{h},c)=g_{h}</span>, where <span class="math">g_{h}=(\\alpha_{h}-\\sigma)/(\\alpha_{h}+\\sigma)</span>, and <span class="math">\\alpha_{1}=a+bw+cw^{2},\\alpha_{2}=(a-b+c)+(b+c)w+cw^{2},\\alpha_{3}=(a+b+c)+(b-c)w+cw^{2}</span>. Moreover, one can check that <span class="math">g_{1}=g,g_{2}=g^{-q}=g^{q^{4}}</span>, and <span class="math">g_{3}=g^{q^{2}}</span>, that is <span class="math">g_{1}g_{2}g_{3}=1</span>, as required. âˆŽ</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Remark 5.5.</h6>

    <p class="text-gray-300">It would be interesting to prove similar results for <span class="math">q=3^{m}</span> where <span class="math">m\\not\\equiv 5</span> (mod 12), and for any quadratic non-residue <span class="math">c_{0}\\in\\mathbb{F}_{q^{3}}</span>, <span class="math">c_{0}\\neq-1</span>. The main difficulty when <span class="math">c_{0}\\neq-1</span> seems to be that the polynomials <span class="math">f_{i}</span>, <span class="math">g_{i}</span> are defined strictly over <span class="math">\\mathbb{F}_{q}</span> rather than over <span class="math">\\mathbb{F}_{3}</span> which is the case when <span class="math">c_{0}=-1</span>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">6. Factor-4 compression and exponentiation algorithms</h2>

    <p class="text-gray-300">In this section, we analyze the efficiency of the compression and decompression methods proposed in Section 4. The efficiency of these methods matters because given a compressed representation of an element, one can consider a variety of exponentiation algorithms that can work directly with that compressed representation, or with partially or fully decompressed representations of the element.</p>

    <p class="text-gray-300">We first show that compression and decompression can be achieved at a negligible cost. Then we describe two exponentiation algorithms and provide a performance comparison.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">6.1. Compression/decompression costs</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">q=2^{m}</span>, <span class="math">m</span> odd, <span class="math">t=\\sqrt{2q}</span> and <span class="math">\\ell=q+1-t</span>. Let <span class="math">G_{\\ell}\\subset\\mathbb{F}_{q^{4}}^{*}</span> be the subgroup with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell<span class="math">. Let </span>\\mathbb{F}_{q^{2}}=\\mathbb{F}_{q}[w]/(w^{2}+w+c_{0})<span class="math"> and </span>\\mathbb{F}_{q^{4}}=\\mathbb{F}_{q^{2}}[\\sigma]/(\\sigma^{2}+\\sigma+c_{1})<span class="math">, where </span>\\mathrm{Tr}_{q,2}(c_{0})=\\mathrm{Tr}_{q^{2},2}(c_{1})=1<span class="math">. We further assume that </span>\\mathbb{F}_{q}<span class="math"> is represented as an </span>m<span class="math">-dimensional vector space over </span>\\mathbb{F}_{2}<span class="math"> via a polynomial basis </span>\\{1,z,\\ldots,z^{m-1}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We first show that the compression and decompression maps described in Theorem 4.4 are very efficiently computable.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Lemma 6.1.</h6>

    <p class="text-gray-300">Let <span class="math">P_{1}(x)=x^{t}+x+u\\in\\mathbb{F}_{q}[x]</span>. If <span class="math">P_{1}(x)=0</span> has a solution in <span class="math">\\mathbb{F}_{q}</span> then it can be computed at a cost of <span class="math">(m-1)/2</span> squarings and <span class="math">(m-1)/2</span> additions in <span class="math">\\mathbb{F}_{q}</span>. If storage for <span class="math">m</span> <span class="math">\\mathbb{F}_{q}</span>-elements is available then finding the <span class="math">\\mathbb{F}_{q}</span>-solutions of <span class="math">P_{1}(x)=0</span> in <span class="math">\\mathbb{F}_{q}</span> requires on average <span class="math">m/2</span> additions in <span class="math">\\mathbb{F}_{q}</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">u=\\sum_{i=0}^{m-1}u_{i}z^{i}</span> and suppose that <span class="math">P_{1}(x)=x^{t}+x+u=0</span> has a solution in <span class="math">\\mathbb{F}_{q}</span>. It follows from Lemma 4.3 that the solutions in <span class="math">\\mathbb{F}_{q}</span> are given by <span class="math">H(u)</span> and <span class="math">H(u)+1</span>, where <span class="math">H(u)=\\sum_{i=0}^{(m-1)/2}u^{2^{i}}</span>, which can be computed at a cost of <span class="math">(m-1)/2</span> squarings and <span class="math">(m-1)/2</span> additions in <span class="math">\\mathbb{F}_{q}</span>. If one can store <span class="math">H(z^{i})</span> for <span class="math">0\\leq i&lt;m</span> then</p>

    <p class="text-gray-300"><span class="math">H(u)=\\sum_{i=0}^{m-1}u_{i}H(z^{i})</span></p>

    <p class="text-gray-300">can be computed at a cost of <span class="math">m/2</span> additions on average. âˆŽ</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 6.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{D}</span> be compression and decompression maps, respectively, as described in Theorem 4.4. Then compression via <span class="math">\\mathcal{C}</span> requires <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q^{2}}</span> and decompression via <span class="math">\\mathcal{D}</span> requires <span class="math">(m-1)/2</span> squarings and <span class="math">(m-1)/2</span> additions in <span class="math">\\mathbb{F}_{q}</span>, and <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q^{4}}</span>. If storage for <span class="math">m</span> <span class="math">\\mathbb{F}_{q}</span>-elements is available then decompression requires on average <span class="math">m/2</span> additions in <span class="math">\\mathbb{F}_{q}</span> and <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q^{4}}</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows from Theorem 4.4 and Lemma 6.1. âˆŽ</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">6.2. Exponentiation algorithms</h3>

    <p class="text-gray-300">Recall that in our compression method, given <span class="math">g=g_{0}+g_{1}\\sigma\\in G_{\\ell}\\setminus\\{1\\}</span>, we first compress <span class="math">g</span> to <span class="math">\\alpha=(g_{0}+1)/g_{1}=a+bw</span>, and then compress <span class="math">\\alpha</span> to <span class="math">(i,b)</span> where <span class="math">i\\in\\{0,1\\}</span>. By Theorem 6.2, compressing <span class="math">g</span> to <span class="math">(i,b)</span> and decompressing <span class="math">(i,b)</span> to <span class="math">\\alpha</span> (and to <span class="math">g</span>) can be achieved at a negligible cost. In this context, we call <span class="math">\\alpha</span> a <em>half-compressed</em> element.</p>

    <p class="text-gray-300">We present two exponentiation algorithms to compute <span class="math">g^{e}</span> given <span class="math">\\mathcal{C}(g)=(i,b)</span> and <span class="math">e\\in\\mathbb{Z}</span>. The first exponentiation algorithm, which we call <em>HCTBE</em> (Half-Compressed Torus-Based Exponentiation), partially decompresses <span class="math">(i,b)</span> to <span class="math">\\alpha</span> and then uses a multiplication formula for half-compressed elements. The output is then compressed to obtain <span class="math">\\mathcal{C}(g^{e})</span>. The second algorithm, which we call <em>FDDE</em> (Fully-Decompressed Direct Exponentiation Algorithm), fully decompresses <span class="math">(i,b)</span> to <span class="math">g</span> and uses a conventional square-and-multiply exponentiation algorithm in <span class="math">\\mathbb{F}_{q^{4}}</span>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">6.2.1. The HCTBE algorithm</h4>

    <p class="text-gray-300">The algorithm makes use of the multiplication formula (2.3) to compute <span class="math">\\mathcal{C}(g^{e})</span>. The formula requires an inversion in <span class="math">\\mathbb{F}_{q^{2}}</span> that makes the exponentiation algorithm quite costly if one tries to use (2.3) directly. However, the problem can be overcome as follows. If <span class="math">g=g_{0}+g_{1}\\sigma</span>, <span class="math">h=h_{0}+h_{1}\\sigma\\in G_{\\ell}\\setminus\\{1\\}</span> are represented by <span class="math">\\alpha=(g_{0}+1)/g_{1}</span>, <span class="math">\\beta=(h_{0}+1)/h_{1}\\in\\mathbb{F}_{q^{2}}</span>, respectively, then we have</p>

    <p class="text-gray-300"><span class="math">g\\cdot h</span> <span class="math">=</span> <span class="math">\\left(\\frac{\\alpha+\\sigma}{\\alpha+1+\\sigma}\\right)\\left(\\frac{\\beta+\\sigma}{\\beta+1+\\sigma}\\right)</span> <span class="math">=</span> <span class="math">\\frac{\\alpha\\beta+c_{1}+(\\alpha+\\beta+1)\\sigma}{\\alpha\\beta+c_{1}+\\alpha+\\beta+1+(\\alpha+\\beta+1)\\sigma}.</span></p>

    <p class="text-gray-300">In other words, if the product of any two elements in <span class="math">G_{\\ell}</span> is computed by this formula then the result will be of the form</p>

    <p class="text-gray-300">(6.1) <span class="math">\\frac{x+y\\sigma}{x+y+y\\sigma},\\text{ for some }x,y\\in\\mathbb{F}_{q^{2}}.</span></p>

    <p class="text-gray-300">In particular, given <span class="math">\\mathcal{C}(g)=(i,b)</span> and <span class="math">e\\in\\mathbb{Z}</span>, one can first decompress <span class="math">(i,b)</span> to <span class="math">\\alpha</span>, and then perform an exponentiation to compute <span class="math">\\mathcal{C}(g^{e})</span> by using the formulas</p>

    <p class="text-gray-300"><span class="math">\\left(\\frac{x+y\\sigma}{x+y+y\\sigma}\\right)^{2}</span> <span class="math">=</span> <span class="math">\\frac{x^{2}+y^{2}c_{1}+y^{2}\\sigma}{x^{2}+y^{2}c_{1}+y^{2}+y^{2}\\sigma},</span> <span class="math">\\left(\\frac{\\alpha+\\sigma}{\\alpha+1+\\sigma}\\right)\\left(\\frac{x+y\\sigma}{x+y+y\\sigma}\\right)</span> <span class="math">=</span> <span class="math">\\frac{\\alpha x+yc_{1}+(\\alpha y+x+y)\\sigma}{\\alpha x+yc_{1}+\\alpha y+x+y+(\\alpha y+x+y)\\sigma},</span></p>

    <p class="text-gray-300">in the <em>square</em> and <em>multiply</em> steps of the exponentiation algorithm. Note that by (6.1) it suffices to only keep track of the numerator during the computations, and to do a single division in <span class="math">\\mathbb{F}_{q^{4}}</span> to obtain <span class="math">g^{e}</span> and finally its compressed value <span class="math">\\mathcal{C}(g^{e})</span>. Our discussion yields Algorithm 1.</p>

    <p class="text-gray-300">Assuming that <span class="math">c_{1}\\in\\mathbb{F}_{q^{2}}</span> is chosen so that the cost of multiplying an element by <span class="math">c_{1}</span> is negligible, the cost of the squaring step (step 5), and the cost of the multiplication step (step 7) in Algorithm 1 is approximately 2 squarings in <span class="math">\\mathbb{F}_{q^{2}}</span> and 2 multiplications in <span class="math">\\mathbb{F}_{q^{2}}</span>, respectively.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">6.2.2. The FDDE algorithm</h4>

    <p class="text-gray-300">After decompressing <span class="math">\\mathcal{C}(g)=(i,b)</span> to <span class="math">g=g_{0}+g_{1}\\sigma</span>, we use a conventional square-and-multiply exponentiation algorithm as described in Algorithm 2. Since</p>

    <p class="text-gray-300"><span class="math">(x+y\\sigma)^{2}</span> <span class="math">=</span> <span class="math">x^{2}+y^{2}c+y^{2}\\sigma,</span> <span class="math">(g_{0}+g_{1}\\sigma)(x+y\\sigma)</span> <span class="math">=</span> <span class="math">g_{0}x+g_{1}yc+(g_{0}y+g_{1}x+g_{1}yc)\\sigma,</span></p>

    <p class="text-gray-300">each squaring step (step 5) in Algorithm 2 requires 2 squarings in <span class="math">\\mathbb{F}_{q^{2}}</span>. Using Karatsubaâ€™s technique, each multiplication step (steps 7-8) requires 3 multiplications in <span class="math">\\mathbb{F}_{q^{2}}</span>. We assume that <span class="math">c_{1}\\in\\mathbb{F}_{q^{2}}</span> is chosen appropriately so that the cost of multiplying an element by <span class="math">c_{1}</span> is negligible.</p>

    <p class="text-gray-300">TORUS-BASED COMPRESSION BY FACTOR 4 AND 6</p>

    <p class="text-gray-300">|  Algorithm 1 The HCTBE exponentiation algorithm Input: C(g) and e Output: C(ge)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: Write e = âˆ‘i=0s-1bi2i where bi âˆˆ {0,1} and bs-1 = 1  |   |</p>

    <p class="text-gray-300">|  2: Decompress C(g) to Î± by using Theorem 4.4  |   |</p>

    <p class="text-gray-300">|  3: x â† Î±, y â† 1  |   |</p>

    <p class="text-gray-300">|  4: for i from s-2 down to 0 do  |   |</p>

    <p class="text-gray-300">|  5: y' â† y2, x' â† x2 + y'c1  |   |</p>

    <p class="text-gray-300">|  6: if bi = 1 then  |   |</p>

    <p class="text-gray-300">|  7: x' â† Î±x + yc1, y' â† Î±y + x + y  |   |</p>

    <p class="text-gray-300">|  8: end if  |   |</p>

    <p class="text-gray-300">|  9: x â† x', y â† y'  |   |</p>

    <p class="text-gray-300">|  10: end for  |   |</p>

    <p class="text-gray-300">|  11: g' â† (x + yÏƒ)/(x + y + yÏƒ)  |   |</p>

    <p class="text-gray-300">|  12: Compress (g') to C(g') = (i', b'), by using Theorem 4.4  |   |</p>

    <p class="text-gray-300">|  13: Output (i', b')  |   |</p>

    <p class="text-gray-300">|  Algorithm 2 The FDDE exponentiation algorithm Input: C(g) and e Output: C(ge)  |   |</p>

    <p class="text-gray-300">|  1: Write e = âˆ‘i=0s-1bi2i where bi âˆˆ {0,1} and bs-1 = 1  |   |</p>

    <p class="text-gray-300">|  2: Decompress C(g) to g = g0 + g1Ïƒ by using Theorem 4.4  |   |</p>

    <p class="text-gray-300">|  3: x â† g0, y â† g1  |   |</p>

    <p class="text-gray-300">|  4: for i from s-2 down to 0 do  |   |</p>

    <p class="text-gray-300">|  5: y' â† y2, x' â† x2 + y'c1  |   |</p>

    <p class="text-gray-300">|  6: if bi = 1 then  |   |</p>

    <p class="text-gray-300">|  7: u0 â† (g0 + g1)(x' + y'), u1 â† g0x', u2 â† g1y', u3 â† u2c1  |   |</p>

    <p class="text-gray-300">|  8: x' â† u1 + u3, y' â† x' + u0 + u2  |   |</p>

    <p class="text-gray-300">|  9: end if  |   |</p>

    <p class="text-gray-300">|  10: x â† x', y â† y'  |   |</p>

    <p class="text-gray-300">|  11: end for  |   |</p>

    <p class="text-gray-300">|  12: g' â† (x + yÏƒ)  |   |</p>

    <p class="text-gray-300">|  13: Compress (g') to C(g') = (i', b'), by using Theorem 4.4  |   |</p>

    <p class="text-gray-300">|  14: Output (i', b')  |   |</p>

    <p class="text-gray-300">6.2.3. A comparison with trace-based exponentiation. In [8], it was shown that it is possible to compress elements of  <span class="math">G_{\\ell}</span>  by a factor 4 by identifying an element  <span class="math">g \\in G_{\\ell}</span>  with its trace  <span class="math">\\mathrm{Tr}_{q^4,q}(g)</span> . Given  <span class="math">\\mathrm{Tr}_{q^4,q}(g)</span>  and an integer  <span class="math">e</span> , five exponentiation algorithms were proposed and analyzed in [8] to compute  <span class="math">\\mathrm{Tr}_{q^4,q}(g^e)</span> . The algorithms are based on the following ideas:</p>

    <p class="text-gray-300">(1) Use  <span class="math">\\mathrm{Tr}_{q^4,q}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_q</span>  (Algorithm 1 in [8]). (2) First decompress  <span class="math">\\mathrm{Tr}_{q^4,q}(g)</span>  to  <span class="math">\\mathrm{Tr}_{q^4,q^2}(g)</span> . Then use  <span class="math">\\mathrm{Tr}_{q^4,q^2}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^2}</span>  (Algorithm 2 in [8]). (3) First decompress  <span class="math">\\mathrm{Tr}_{q^4,q}(g)</span>  to  <span class="math">g</span>  and perform computations in  <span class="math">\\mathbb{F}_{q^4}</span>  (Algorithm DDE in [8]). (4) First decompress  <span class="math">\\mathrm{Tr}_{q^4,q}(g)</span>  to  <span class="math">\\mathrm{Tr}_{q^4,q^2}(g)</span> . Then use  <span class="math">\\mathrm{Tr}_{q^4,q^2}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^4}</span>  based on the minimal polynomial of  <span class="math">g</span>  over  <span class="math">\\mathbb{F}_{q^2}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^4}</span>  (Algorithm BPV-I in [8]). (5) Use  <span class="math">\\mathrm{Tr}_{q^4,q}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^4}</span>  based on the minimal polynomial of  <span class="math">g</span>  over  <span class="math">\\mathbb{F}_q</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^4}</span>  (Algorithm BPV-II in [8]).</p>

    <p class="text-gray-300">If a decompression is performed then it is the most expensive step in these algorithms. Therefore, the algorithms based on (1) and (5) are overall faster than the algorithms based on (2), (3) and (4). In particular, Algorithm 1 in <em>[8]</em> was reported to be the fastest exponentiation algorithm in the case of using a general base <span class="math">\\mathrm{Tr}_{q^{4},q}(g)</span>, and its performance was further improved in <em>[7]</em> (see Algorithm 3 in <em>[7]</em>). However, once decompression can be performed in advance, such as in the case of using a fixed base <span class="math">\\mathrm{Tr}_{q^{4},q}(g)</span>, then the algorithm based on (3) is the fastest.</p>

    <p class="text-gray-300">Note that by Theorem 6.2, given <span class="math">\\mathcal{C}(g)</span> for some <span class="math">g\\in G_{\\ell}\\setminus\\{1\\}</span>, one can recover <span class="math">g</span> (and also <span class="math">\\mathrm{Tr}_{q^{4},q}(g)</span> and <span class="math">\\mathrm{Tr}_{q^{4},q^{2}}(g)</span>) at a negligible cost. Hence, it is more advantageous to use <span class="math">\\mathcal{C}(g)</span> instead of <span class="math">\\mathrm{Tr}_{q^{4},q}(g)</span>. For example, using <span class="math">\\mathcal{C}(g)</span>, we can obtain faster exponentiation algorithms than the trace-based exponentiation algorithms in the case of a general base by simply computing <span class="math">\\mathrm{Tr}_{q^{4},q}(g)</span> from <span class="math">\\mathcal{C}(g)</span> and adapting an algorithm based on (3).</p>

    <h2 id="sec-22" class="text-2xl font-bold">7. Factor-6 compression and exponentiation algorithms</h2>

    <p class="text-gray-300">This section is analogous to Section 6. We analyze the efficiency of the compression and decompression methods proposed in Section 5. We first show that compression and decompression can be achieved at a negligible cost, and then describe two exponentiation algorithms and provide a performance comparison.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">7.1. Compression/decompression costs</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">q=3^{m}</span>, <span class="math">m</span> odd, <span class="math">t=\\sqrt{3q}</span> and <span class="math">\\ell=q+1-t</span>. Let <span class="math">G_{\\ell}\\subset\\mathbb{F}_{q^{6}}^{*}</span> be the subgroup with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell<span class="math">. Let </span>\\mathbb{F}_{q^{3}}=\\mathbb{F}_{q}[w]/(w^{3}-w-1)<span class="math"> and </span>\\mathbb{F}_{q^{6}}=\\mathbb{F}_{q^{3}}[\\sigma]/(\\sigma^{2}-c_{0})<span class="math"> where </span>c_{0}<span class="math"> is a quadratic non-residue in </span>\\mathbb{F}_{q^{3}}<span class="math">. We further assume that </span>\\mathbb{F}_{q}<span class="math"> is represented as an </span>m<span class="math">-dimensional vector space over </span>\\mathbb{F}_{3}<span class="math"> via a polynomial basis </span>\\{1,z,\\ldots,z^{m-1}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-24" class="text-base font-medium mt-4">Lemma 7.1.</h6>

    <p class="text-gray-300">Let <span class="math">P_{6}(x)=c^{3}x^{3}+2c^{2t+3}x+2(c^{3(t+1)}+c^{2t}+1)\\in\\mathbb{F}_{q}[x]</span> for some <span class="math">c\\in\\mathbb{F}_{q}</span>. If <span class="math">P_{6}(x)=0</span> has a solution in <span class="math">\\mathbb{F}_{q}</span> and storage of <span class="math">m</span> <span class="math">\\mathbb{F}_{q}</span>-elements is available, then finding the <span class="math">\\mathbb{F}_{q}</span>-solutions requires on average <span class="math">2m/3</span> additions, <span class="math">2</span> multiplications, <span class="math">1</span> squaring and <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q}</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First observe that if <span class="math">B\\in\\mathbb{F}_{q}</span> is a quadratic non-residue and <span class="math">x^{3}+Bx+C=0</span> has a solution in <span class="math">\\mathbb{F}_{q}</span> then all solutions are given by</p>

    <p class="text-gray-300"><span class="math">\\{r_{1},r_{2},r_{3}\\}=\\{(-B)^{1/2}R(D),(-B)^{1/2}(R(D)+1),(-B)^{1/2}(R(D)+2)\\},</span></p>

    <p class="text-gray-300">where <span class="math">D=C/(-B)^{3/2}</span> and <span class="math">R(D)</span> is a root of</p>

    <p class="text-gray-300"><span class="math">x^{3}-x+D.</span></p>

    <p class="text-gray-300">Clearly, if <span class="math">x^{3}-x+D=0</span> has a solution <span class="math">R(D)\\in\\mathbb{F}_{q}</span> then it can be found trit-wise when a normal basis <span class="math">\\{\\theta,\\theta^{3},\\ldots,\\theta^{3^{m-1}}\\}</span> is used to represent <span class="math">\\mathbb{F}_{q}</span> as an <span class="math">m</span>-dimensional vector space over <span class="math">\\mathbb{F}_{3}</span>. Let us suppose that <span class="math">R(D)=\\sum_{i=0}^{m-1}R_{i}\\theta^{3^{i}}</span> and the <span class="math">m</span> <span class="math">\\mathbb{F}_{q}</span>-elements</p>

    <p class="text-gray-300"><span class="math">\\theta^{3^{i}}=\\sum_{j=0}^{m-1}\\theta_{ij}z^{j},\\ 0\\leq i&lt;m</span></p>

    <p class="text-gray-300">are precomputed and stored. Then a solution</p>

    <p class="text-gray-300"><span class="math">R(D)=\\sum_{i=0}^{m-1}R_{i}\\sum_{j=0}^{m-1}\\theta_{ij}z^{j}</span></p>

    <p class="text-gray-300">to <span class="math">x^{3}-x+D=0</span> is obtained in <span class="math">\\mathbb{F}_{q}</span>, at an average cost of <span class="math">2m/3</span> additions in <span class="math">\\mathbb{F}_{q}</span>.</p>

    <p class="text-gray-300">Now, in order to find a solution of <span class="math">P_{6}(x)=c^{3}x^{3}+2c^{2t+3}x+2(c^{3(t+1)}+c^{2t}+1)=0</span> in <span class="math">\\mathbb{F}_{q}</span>, we first compute <span class="math">B=2c^{2t+3}/c^{3}=2c^{2t}</span> and <span class="math">C=2(c^{3(t+1)}+c^{2t}+1)/c^{3}</span>. Then</p>

    <p class="text-gray-300"><span class="math">D=C/(-B)^{3/2}=(2(c^{3(t+1)}+c^{2t}+1)/c^{3t+3})</span></p>

    <p class="text-gray-300">can be computed at a cost of <span class="math">1</span> multiplication, <span class="math">1</span> squaring and <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q}</span> (we ignore the cost of addition in <span class="math">\\mathbb{F}_{q}</span> and Frobenius operations). From our argument above we can find a solution of <span class="math">x^{3}-x+D=0</span> in <span class="math">\\mathbb{F}_{q}</span> at an average cost of <span class="math">2m/3</span> additions in <span class="math">\\mathbb{F}_{q}</span>. Hence, the solutions of <span class="math">P_{0}(x)=0</span> are given by</p>

    <p class="text-gray-300"><span class="math">\\{r_{1},r_{2},r_{3}\\}=\\{c^{t}R(D),c^{t}(R(D)+1),c^{t}(R(D)+2)\\},</span></p>

    <p class="text-gray-300">and can be obtained at an average cost of <span class="math">2m/3</span> additions, <span class="math">2</span> multiplications, <span class="math">1</span> squaring and <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q}</span>. âˆŽ</p>

    <p class="text-gray-300">From now on, we shall assume that <span class="math">m\\equiv 5\\pmod{12}</span> and <span class="math">c_{0}=-1</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 7.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{D}</span> be compression and decompression maps, respectively, as described in Theorem 5.4. Then compression via <span class="math">\\mathcal{C}</span> requires <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q^{3}}</span> and decompression via <span class="math">\\mathcal{D}</span> requires on average <span class="math">2m/3</span> additions, <span class="math">2</span> multiplications, <span class="math">1</span> squaring, <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q}</span>, and <span class="math">1</span> division in <span class="math">\\mathbb{F}_{q^{6}}</span>, with a storage of <span class="math">m</span> <span class="math">\\mathbb{F}_{q}</span>-elements.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows from Theorem 5.4 and Lemma 7.1. âˆŽ</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">7.2. Exponentiation algorithms</h3>

    <p class="text-gray-300">Recall that in our compression method, given <span class="math">g=g_{0}+g_{1}\\sigma\\in G_{\\ell}\\setminus\\{\\pm 1\\}</span>, we first compress <span class="math">g</span> to <span class="math">\\alpha=(g_{0}+1/g_{1})=a+bw+cw^{2}</span>, by a factor <span class="math">2</span>, and then compress <span class="math">\\alpha</span> to <span class="math">(i,c)</span>, <span class="math">i\\in\\{0,1,2\\}</span> by a factor of <span class="math">3</span>. By Theorem 7.2, compressing <span class="math">g</span> to <span class="math">(i,c)</span>, and decompressing <span class="math">(i,c)</span> to <span class="math">\\alpha</span> (and to <span class="math">g</span>) can be achieved at a negligible cost. In this context, we call <span class="math">\\alpha</span> a <em>half-compressed</em> element.</p>

    <p class="text-gray-300">We present two exponentiation algorithms to compute <span class="math">g^{e}</span> given <span class="math">\\mathcal{C}(g)=(i,c)</span> and <span class="math">e\\in\\mathbb{Z}</span>. The first exponentiation algorithm, which we call <em>HCTBE</em> (Half-Compressed Torus-Based Exponentiation), partially decompresses <span class="math">(i,c)</span> to <span class="math">\\alpha</span> and uses a multiplication formula for half-compressed elements. The output is then compressed to obtain <span class="math">\\mathcal{C}(g^{e})</span>. The second algorithm, which we call <em>FDDE</em> (Fully-Decompressed Direct Exponentiation Algorithm), fully decompresses <span class="math">(i,c)</span> to <span class="math">g</span> and uses a conventional cube-and-multiply exponentiation algorithm in <span class="math">\\mathbb{F}_{q^{6}}</span>.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">7.2.1. The HCTBE algorithm</h4>

    <p class="text-gray-300">The algorithm makes use of the multiplication formula (2.4) to compute <span class="math">\\mathcal{C}(g^{e})</span>. If <span class="math">g=g_{0}+g_{1}\\sigma,\\ h=h_{0}+h_{1}\\sigma\\in G_{\\ell}\\setminus\\{\\pm 1\\}</span> are represented by <span class="math">\\alpha=(g_{0}+1)/g_{1},\\ \\beta=(h_{0}+1)/h_{1}\\in\\mathbb{F}_{q^{3}}</span>, respectively, then we have</p>

    <p class="text-gray-300"><span class="math">g\\cdot h</span> <span class="math">=</span> <span class="math">\\left(\\frac{\\alpha+\\sigma}{\\alpha-\\sigma}\\right)\\left(\\frac{\\beta+\\sigma}{\\beta-\\sigma}\\right)</span> <span class="math">=</span> <span class="math">\\frac{\\alpha\\beta+c_{0}+(\\alpha+\\beta)\\sigma}{\\alpha\\beta+c_{0}-(\\alpha+\\beta)\\sigma}.</span></p>

    <p class="text-gray-300">In other words, if the product of any two elements in <span class="math">G_{\\ell}</span> is computed by this formula then the result will be of the form</p>

    <p class="text-gray-300">(7.1) <span class="math">\\frac{x+y\\sigma}{x-y\\sigma},\\ \\text{for some}\\ x,y\\in\\mathbb{F}_{q^{3}}.</span></p>

    <p class="text-gray-300">In particular, given <span class="math">\\mathcal{C}(g)=(i,c)</span> and <span class="math">e\\in\\mathbb{Z}</span>, one can first decompress <span class="math">(i,c)</span> to <span class="math">\\alpha</span>, and then perform an exponentiation to compute <span class="math">\\mathcal{C}(g^{e})</span> by using the formulas</p>

    <p class="text-gray-300"><span class="math">\\left(\\frac{x+y\\sigma}{x-y\\sigma}\\right)^{3}</span> <span class="math">=</span> <span class="math">\\frac{x^{3}+y^{3}c_{0}\\sigma}{x^{3}-y^{3}c_{0}\\sigma},</span> <span class="math">\\left(\\frac{\\alpha+\\sigma}{\\alpha-\\sigma}\\right)\\left(\\frac{x+y\\sigma}{x-y\\sigma}\\right)</span> <span class="math">=</span> <span class="math">\\frac{\\alpha x+yc_{0}+(\\alpha y+x)\\sigma}{\\alpha x+yc_{0}-(\\alpha y+x)\\sigma},</span> <span class="math">\\left(\\frac{\\alpha-\\sigma}{\\alpha+\\sigma}\\right)\\left(\\frac{x+y\\sigma}{x-y\\sigma}\\right)</span> <span class="math">=</span> <span class="math">\\frac{\\alpha x-yc_{0}+(\\alpha y-x)\\sigma}{\\alpha x-yc_{0}-(\\alpha y-x)\\sigma}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">in the cube and multiply steps of the exponentiation algorithm. Note that by (7.1) it suffices to only keep track of the numerator during the computations, and to do a single division in <span class="math">\\mathbb{F}_{q^{6}}</span> to obtain <span class="math">g^{e}</span> and finally its compressed value <span class="math">\\mathcal{C}(g^{e})</span>. Our discussion yields Algorithm 3.</p>

    <p class="text-gray-300">Algorithm 3 The HCTBE exponentiation algorithm Input: <span class="math">\\mathcal{C}(g)</span> and <span class="math">e</span> Output: <span class="math">\\mathcal{C}(g^{e})</span> 1:Write <span class="math">e=\\sum_{i=0}^{s-1}b_{i}3^{i}</span> where <span class="math">b_{i}\\in\\{-1,0,1\\}</span> and <span class="math">b_{s-1}=1</span> 2:Decompress <span class="math">\\mathcal{C}(g)</span> to <span class="math">\\alpha</span> by using Theorem 5.4 3:<span class="math">x\\leftarrow\\alpha</span>, <span class="math">y\\leftarrow 1</span> 4:for <span class="math">i</span> from <span class="math">s-2</span> down to <span class="math">0</span> do 5: <span class="math">x^{\\prime}\\leftarrow x^{3},\\;y^{\\prime}\\leftarrow y^{3}c_{0}</span> 6: if <span class="math">b_{i}=1</span> then 7: <span class="math">x^{\\prime}\\leftarrow\\alpha x+yc_{0},\\;y^{\\prime}\\leftarrow(\\alpha y+x)</span> 8: else if <span class="math">b_{i}=-1</span> then 9: <span class="math">x^{\\prime}\\leftarrow\\alpha x-yc_{0},\\;y^{\\prime}\\leftarrow(\\alpha y-x)</span> 10: end if 11: <span class="math">x\\leftarrow x^{\\prime},\\;y\\leftarrow y^{\\prime}</span> 12:end for 13:<span class="math">g^{\\prime}\\leftarrow(x+y\\sigma)/(x-y\\sigma)</span> 14:Compress <span class="math">(g^{\\prime})</span> to <span class="math">\\mathcal{C}(g^{\\prime})=(i^{\\prime},c^{\\prime})</span>, by using Theorem 5.4 15:Output <span class="math">(i^{\\prime},c^{\\prime})</span></p>

    <p class="text-gray-300">Since <span class="math">c_{0}=-1</span>, the cost of the cubing step (step 5) and the cost of the multiplication step (step 7 or step 9) in Algorithm 3 is approximately 2 cubings in <span class="math">\\mathbb{F}_{q^{3}}</span> and 2 multiplications in <span class="math">\\mathbb{F}_{q^{3}}</span>, respectively.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Remark 7.3.</h6>

    <p class="text-gray-300">Granger, Page and Stam <em>[5, Section 3.2]</em> proposed an exponentiation algorithm that works in the quotient group <span class="math">\\mathbb{F}_{q^{6}}^{<em>}/\\mathbb{F}_{q^{3}}^{</em>}</span> where <span class="math">q=3^{m}</span>, <span class="math">m</span> is odd, and mimics the mixed addition method for point multiplication on elliptic curves. Algorithm 1 can be seen as analogous to their algorithm. The main difference is that they identify <span class="math">g=g_{0}+g_{1}\\sigma</span> with <span class="math">\\alpha=g_{0}/g_{1}</span> instead of <span class="math">\\alpha=(g_{0}+1)/g_{1}</span> and therefore their method cannot be directly adapted to obtain a fast exponentiation algorithm in <span class="math">G_{\\ell}\\subset\\mathbb{F}_{q^{6}}^{<em>}</span>. In particular, it was reported in </em>[5, Table 3]<em> that exponentiation in <span class="math">\\mathbb{F}_{q^{6}}^{</em>}/\\mathbb{F}_{q^{3}}^{<em>}</span> is more efficient than exponentiation in <span class="math">G_{\\ell}</span>. The HCTBE algorithm equalizes the efficiency of exponentiation algorithms in <span class="math">G_{\\ell}</span> and <span class="math">\\mathbb{F}_{q^{6}}^{</em>}/\\mathbb{F}_{q^{3}}^{*}</span>.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">7.2.2. The FDDE algorithm</h4>

    <p class="text-gray-300">After decompressing <span class="math">\\mathcal{C}(g)=(i,b)</span> to <span class="math">g=g_{0}+g_{1}\\sigma</span>, we use a conventional cube-and-multiply exponentiation algorithm as described in Algorithm 4. Since</p>

    <p class="text-gray-300"><span class="math">(x+y\\sigma)^{3}</span> <span class="math">=</span> <span class="math">x^{3}+y^{3}c_{0}\\sigma,</span> <span class="math">(g_{0}+g_{1}\\sigma)(x+y\\sigma)</span> <span class="math">=</span> <span class="math">g_{0}x+g_{1}yc_{0}+(g_{0}y+g_{1}x)\\sigma,</span> <span class="math">(g_{0}-g_{1}\\sigma)(x+y\\sigma)</span> <span class="math">=</span> <span class="math">g_{0}x-g_{1}yc_{0}+(g_{0}y-g_{1}x)\\sigma,</span></p>

    <p class="text-gray-300">each cubing step (step 5) in Algorithm 4 requires 2 cubings in <span class="math">\\mathbb{F}_{q^{3}}</span>. Using Karatsubaâ€™s technique, each multiplication step (steps 7-8 or steps 10-11) requires 3 multiplications in <span class="math">\\mathbb{F}_{q^{3}}</span> (note that <span class="math">c_{0}=-1</span>).</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">7.2.3. A comparison with trace-based exponentiation</h4>

    <p class="text-gray-300">In <em>[15]</em>, it was shown that it is possible to compress elements of <span class="math">G_{\\ell}</span> by a factor 6 by identifying an element <span class="math">g\\in G_{\\ell}</span> with its trace <span class="math">\\mathrm{Tr}_{q^{6},q}(g)</span>. Given <span class="math">\\mathrm{Tr}_{q^{6},q}(g)</span> and an integer <span class="math">e</span>, six exponentiation algorithms were proposed and analyzed in <em>[8]</em> to compute <span class="math">\\mathrm{Tr}_{q^{6},q}(g^{e})</span>. The performance of these six algorithms were also compared with a previously-known exponentiation algorithm <span class="math">\\mathrm{XTR}_{3}</span> in <em>[15]</em>. The algorithms are based on the following ideas:</p>

    <p class="text-gray-300">TORUS-BASED COMPRESSION BY FACTOR 4 AND 6</p>

    <p class="text-gray-300">|  Algorithm 4 The FDDE exponentiation algorithm  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: C(g) and e  |   |</p>

    <p class="text-gray-300">|  Output: C(g^e)  |   |</p>

    <p class="text-gray-300">|  1: Write e = âˆ‘i=0s-1bi3^i where bi âˆˆ {âˆ’1,0,1} and bs-1 = 1  |   |</p>

    <p class="text-gray-300">|  2: Decompress C(g) to g = g0 + g1Ïƒ by using Theorem 5.4  |   |</p>

    <p class="text-gray-300">|  3: x â† g0, y â† g1  |   |</p>

    <p class="text-gray-300">|  4: for i from s - 2 down to 0 do  |   |</p>

    <p class="text-gray-300">|  5: x' â† x^3, y' â† y^3c0  |   |</p>

    <p class="text-gray-300">|  6: if bi = 1 then  |   |</p>

    <p class="text-gray-300">|  7: u0 â† (g0 + g1)(x' + y'), u1 â† g0x', u2 â† g1y', u3 â† u2c0  |   |</p>

    <p class="text-gray-300">|  8: x' â† u1 + u3, y' â† u0 - (u1 + u2)  |   |</p>

    <p class="text-gray-300">|  9: else if bi = -1 then  |   |</p>

    <p class="text-gray-300">|  10: u0 â† (g0 - g1)(x' + y'), u1 â† g0x', u2 â† -g1y', u3 â† u2c0  |   |</p>

    <p class="text-gray-300">|  11: x' â† u1 + u3, y' â† u0 - (u1 + u2)  |   |</p>

    <p class="text-gray-300">|  12: end if  |   |</p>

    <p class="text-gray-300">|  13: x â† x', y â† y'  |   |</p>

    <p class="text-gray-300">|  14: end for  |   |</p>

    <p class="text-gray-300">|  15: g' â† (x + yÏƒ)  |   |</p>

    <p class="text-gray-300">|  16: Compress (g') to C(g') = (i', c'), by using Theorem 5.4  |   |</p>

    <p class="text-gray-300">|  17: Output (i', c')  |   |</p>

    <p class="text-gray-300">(1) Use  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_q</span>  (Algorithm 3 in [8]). (2) First decompress  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\mathrm{Tr}_{q^6,q^3}(g)</span> . Then use  <span class="math">\\mathrm{Tr}_{q^6,q^3}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^3}</span>  (Algorithm 4 in [8]). (3) First decompress  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  to  <span class="math">g</span>  and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm DDE in [8]). (4) First decompress  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\mathrm{Tr}_{q^6,q^2}(g)</span> . Then use  <span class="math">\\mathrm{Tr}_{q^6,q^2}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of  <span class="math">g</span>  over  <span class="math">\\mathbb{F}_{q^2}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-I in [8]). (5) First decompress  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\mathrm{Tr}_{q^6,q^3}(g)</span> . Then use  <span class="math">\\mathrm{Tr}_{q^6,q^3}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of  <span class="math">g</span>  over  <span class="math">\\mathbb{F}_{q^3}</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-II in [8]). (6) Use  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  to construct a copy of  <span class="math">\\mathbb{F}_{q^6}</span>  based on the minimal polynomial of  <span class="math">g</span>  over  <span class="math">\\mathbb{F}_q</span> , and perform computations in  <span class="math">\\mathbb{F}_{q^6}</span>  (Algorithm BPV-III in [8]). (7) First decompress  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  to  <span class="math">\\mathrm{Tr}_{q^6,q^2}(g)</span> . Then use  <span class="math">\\mathrm{Tr}_{q^6,q^2}(g)</span>  directly and perform computations in  <span class="math">\\mathbb{F}_{q^2}</span>  (Algorithm XTR <span class="math">_3</span>  in [15]).</p>

    <p class="text-gray-300">The algorithms based on (1), (4), (6) and (7) are overall faster than the algorithms based on (2), (3) and (5) because of the expensive decompression operations required in the latter algorithms. In particular, it was reported in [8] that  <span class="math">\\mathrm{XTR}_3</span>  in [15] can be further sped up and it is the fastest exponentiation algorithm for general bases. However, if decompression can be precomputed, for example when the base is fixed, then the algorithm based on (3) is the fastest.</p>

    <p class="text-gray-300">Note that by Theorem 7.2, given  <span class="math">\\mathcal{C}(g)</span>  for some  <span class="math">g\\in G_{\\ell}\\setminus \\{\\pm 1\\}</span> , one can recover  <span class="math">g</span>  (and also  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span> ,  <span class="math">\\mathrm{Tr}_{q^6,q^2}(g)</span>  and  <span class="math">\\mathrm{Tr}_{q^6,q^3}(g)</span> ) at a negligible cost. Hence, it is more advantageous to use  <span class="math">\\mathcal{C}(g)</span>  instead of  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span> . For example, using  <span class="math">\\mathcal{C}(g)</span> , we can obtain faster exponentiation algorithms than the trace-based exponentiation algorithms in the case of a general base  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span> , by simply computing  <span class="math">\\mathrm{Tr}_{q^6,q}(g)</span>  from  <span class="math">\\mathcal{C}(g)</span>  and adapting an algorithm based on (3).</p>

    <p class="text-gray-300">KORAY KARABINA</p>

    <p class="text-gray-300">In this section, we estimate the running times of the exponentiation algorithms discussed in Sections 6.2 and 7.2, and compare them with the fastest previously-known exponentiation algorithms. We consider the case of a general base,  <span class="math">\\mathcal{C}(g)</span>  or  <span class="math">\\mathrm{Tr}_{q^k,q}(g)</span> , which is the most interesting case because when the base is fixed we may ignore the cost of obtaining one of  <span class="math">\\mathcal{C}(g)</span>  and  <span class="math">\\mathrm{Tr}_{q^k,q}(g)</span>  from the other, and hence obtain an equivalent performance in torus-based and trace-based exponentiation algorithms.</p>

    <p class="text-gray-300">We denote by  <span class="math">C_i, M_i</span> , and  <span class="math">S_i</span>  the operations of cubing, multiplication, and squaring in  <span class="math">\\mathbb{F}_{q^i}</span>  for  <span class="math">i = 1,2,3</span> . We assume that  <span class="math">S_2 = 2S_1</span>  for characteristic two,  <span class="math">C_3 = 3C_1</span>  for characteristic three, and also assume, using Karatsuba's technique, that  <span class="math">M_2 = 3M_1</span>  and  <span class="math">M_3 = 6M_1</span> .</p>

    <p class="text-gray-300">Note that the HCTBE and FDDE algorithms can easily be modified to work with window NAF techniques. In particular, we assume that the width- <span class="math">w</span>  radix-2 and radix-3 NAF representation of the exponent  <span class="math">e</span>  are used in for the characteristic-two and the characteristic-three cases, respectively. Note that width- <span class="math">w</span>  radix-2 and radix-3 NAF representations of  <span class="math">e</span>  contain on average  <span class="math">\\log_2 e / (w + 1)</span>  and  <span class="math">2\\log_3 e / (2w + 1)</span>  nonzero digits, respectively; see for example [18].</p>

    <p class="text-gray-300">The estimated costs of the exponentiation algorithms are presented in Table 1. In our analysis, we ignore the compression/decompression costs and also the precomputation costs required for window NAF methods as they are negligible comparing to the overall cost of algorithms.</p>

    <p class="text-gray-300">TABLE 1. Comparison of exponentiation algorithms for factor-4 and factor-6 compression in the case of a general base. The exponent is  <span class="math">e</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Main Loop</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Characteristic-two fields  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 3 in [7]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(3.19M1) log2e</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HCTBE</td>

            <td class="px-3 py-2 border-b border-gray-700">(4S1 + 6/w+1)M1) log2e</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Characteristic-three fields  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">XTR3 in [15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(3M1) log2e</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HCTBE</td>

            <td class="px-3 py-2 border-b border-gray-700">(6C1 + 24/(2w+1)M1) log3e</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Assuming that  <span class="math">S_{1}</span>  and  <span class="math">C_{1}</span>  are essentially free in characteristic-two and characteristic-three fields, respectively, and setting  <span class="math">w = 3</span> , we can estimate the cost of FDDE as  <span class="math">(2.25M_{1})\\log_{2}e</span>  and the cost of HCTBE as  <span class="math">(1.5M_{1})\\log_{2}e</span>  in characteristic-two fields. Similarly, the cost of FDDE and HCTBE in characteristic-three fields can be approximated as  <span class="math">(3.24M_{1})\\log_{2}e</span>  and  <span class="math">(2.16M_{1})\\log_{2}e</span> , respectively.</p>

    <p class="text-gray-300">Therefore, if we require that the input to an exponentiation algorithm and the output of the algorithm are the compressed representation of  <span class="math">g</span>  and  <span class="math">g^{e}</span> , it seems best to compress  <span class="math">g</span>  to  <span class="math">\\mathcal{C}(g)</span>  by a factor of 4 or 6, and to use the HCTBE algorithms to compute the factor-4 or factor-6 compressed representation  <span class="math">\\mathcal{C}(g^{e})</span>  of  <span class="math">g^{e}</span> . It also seems that the HCTBE algorithms outperform the fastest previously-known exponentiation algorithms in  <span class="math">G_{\\ell}</span> . The reason is that compression/decompression costs in the HCTBE algorithms are negligible and that each multiplication step in the HCTBE algorithm in characteristic-two requires  <span class="math">6M_{1}</span>  whereas it would require  <span class="math">9M_{1}</span>  in a conventional exponentiation algorithm adapting Karatsuba's method. Similarly, each multiplication step in the HCTBE algorithm in characteristic-three requires  <span class="math">12M_{1}</span>  whereas it would require  <span class="math">18M_{1}</span>  in a conventional exponentiation algorithm adapting Karatsuba's method (see also Remark 7.3).</p>

    <p class="text-gray-300">TORUS-BASED COMPRESSION BY FACTOR 4 AND 6</p>

    <p class="text-gray-300">To be more concrete, we list the expected running times of the six exponentiation algorithms in a particular setting in Table 2 based on the estimates given in Table 1. For the 128-bit security level, in the characteristic-two case we let  <span class="math">q = 2^{1223}</span>  and  <span class="math">t = 2^{612}</span> . Then  <span class="math">q + 1 + t = 5\\ell</span>  where  <span class="math">\\ell</span>  is a 1221-bit prime. We will ignore the cost  <span class="math">S_{1}</span> . In the characteristic-three case, we let  <span class="math">q = 3^{509}</span>  and  <span class="math">t = 3^{255}</span> . Then  <span class="math">q + 1 - t = 7\\ell</span>  where  <span class="math">\\ell</span>  is an 804-bit prime. We will ignore the cost  <span class="math">C_{1}</span> . In both cases, we choose  <span class="math">w = 3</span> .</p>

    <p class="text-gray-300">TABLE 2. Comparison of exponentiation algorithms for factor-4 and factor-6 compression in the case of a general base at the 128-bit security level. The exponent is an 1221-bit integer in the characteristic-two case, and an 804-bit integer in the characteristic-three case.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Main Loop</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  A characteristic-two field  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 3 in [7]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3895M1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HCTBE</td>

            <td class="px-3 py-2 border-b border-gray-700">1831M1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  A characteristic-three field  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">XTR3in [15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2412M1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HCTBE</td>

            <td class="px-3 py-2 border-b border-gray-700">1739M1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We showed that by building on torus-based compression techniques, it is possible to compress elements in  <span class="math">G_{\\ell}</span>  by a factor of 4 when  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell = q + 1 \\pm t<span class="math"> ,  </span>q = 2^{m}<span class="math">  and  </span>t = \\sqrt{2q}<span class="math"> ; and by a factor of 6 when  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell = q + 1 - t<span class="math"> ,  </span>q = 3^{m}<span class="math">  and  </span>t = \\sqrt{3q}<span class="math"> . Our methods achieve the best possible compression ratio in  </span>G_{\\ell}$ , and moreover have the feature that the compression and decompression maps are computable at a negligible cost. We discussed several exponentiation algorithms and, in particular, showed that HCTBE outperforms the fastest exponentiation algorithms in both the characteristic-two and the characteristic-three cases.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that the pairing values of bilinear pairings derived from supersingular elliptic curves of embedding degrees 4 and 6 over finite fields of characteristic two and three, and derived from supersingular hyperelliptic curves of embedding degrees 12 over finite fields of characteristic two, lie in  <span class="math">G_{\\ell}</span>  for a suitable choice of parameters. Therefore, our techniques can be easily incorporated into pairing-based protocols that require exponentiations or products of pairings; examples of such protocols include Scott's identity-based key agreement protocol [14] and Waters signature scheme [21].</p>

    <p class="text-gray-300">Our compression method compresses  <span class="math">g \\in G_{\\ell}</span>  to an element  <span class="math">\\mathcal{C}(g)</span>  in  <span class="math">\\mathbb{F}_q</span> . However, given  <span class="math">\\mathcal{C}(g)</span>  and  <span class="math">e \\in \\mathbb{Z}</span> , all the exponentiation algorithms to compute  <span class="math">\\mathcal{C}(g^e)</span>  first decompresses  <span class="math">\\mathcal{C}(g)</span>  (at least partially), and then exponentiate. It is natural to ask if one can devise a multiplication formula for  <span class="math">g, h \\in G_{\\ell}</span>  which computes  <span class="math">\\mathcal{C}(g) * \\mathcal{C}(h) = \\mathcal{C}(gh)</span>  directly in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">The author would like to thank Alfred Menezes for his careful reading of the earlier drafts of this paper and for his corrections and suggestions.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Ã‰. Brier and M. Joye. WeirstraÃŸ elliptic curves and side channel attacks. Public Key Cryptography â€“ PKC 2002, Lecture Notes In Computer Science, 2274:335â€“345, 2002.</li>

      <li>[2] A. Brouwer, R. Pellikaan, and E. Verheul. Doing more with fewer bits. Advances in Cryptology â€“ ASIACRYPT â€™99, Lecture Notes in Computer Science, 1716:321â€“332, 1999.</li>

      <li>[3] K. Giuliani and G. Gong. Analogues to the Gong-Harn and XTR cryptosystems. Technical Report CORR 2003-34, University of Waterloo, 2003. Available at http://www.cacr.math.uwaterloo.ca/techreports/2003/corr2003-34.ps.</li>

      <li>[4] G. Gong and L. Harn. Public-key cryptosystems based on cubic finite field extensions. IEEE Transactions on Information Theory, 45:2601â€“2605, 1999.</li>

      <li>[5] R. Granger, D. Page, and M. Stam. On small characteristic algebraic tori in pairing-based cryptography. LMS Journal of Computation and Mathematics, 9:64â€“85, 2004.</li>

      <li>[6] D. Hankerson, A. Menezes, and S. Vanstone. Guide to elliptic curve cryptography. Springer-Verlag, New York, USA, 2004.</li>

      <li>[7] K. Karabina. Double-exponentiation in factor-4 groups and its applications. Twelfth IMA International Conference on Cryptography and Coding, Lecture Notes in Computer Science, 5921:336â€“350, 2009.</li>

      <li>[8] K. Karabina. Factor-4 and 6 compression of cyclotomic subgroups of <span class="math">\\mathbb{F}_{2^{4m}}^{\\ast}</span> and <span class="math">\\mathbb{F}_{3^{6m}}^{\\ast}</span>. Journal of Mathematical Cryptology, 4:1â€“42, 2010.</li>

      <li>[9] A. Lenstra and E. Verheul. The XTR public key system. Advances in Cryptology â€“ CRYPTO 2000, Lecture Notes in Computer Science, 1880:1â€“19, 2000.</li>

      <li>[10] J. LÃ³pez and R. Dahab. Fast multiplication on elliptic curves over <span class="math">GF(2^{m})</span> without precomputation. Cryptographic Hardware and Embedded Systems, Lecture Notes In Computer Science, 1717:316â€“327, 1999.</li>

      <li>[11] P. Montgomery. Speeding the Pollard and elliptic curve methods of factorization. Mathematics of Computation, 48:243â€“264, 1987.</li>

      <li>[12] K. Rubin and A. Silverberg. Torus-based cryptography. Advances in Cryptology â€“ CRYPTO 2003, Lecture Notes in Computer Science, 2729:349â€“365, 2003.</li>

      <li>[13] K. Rubin and A. Silverberg. Compression in finite fields and torus-based cryptography. SIAM Journal on Computing, 37:1401â€“1428, 2008.</li>

      <li>[14] M. Scott. Authenticated ID-based key exchange and remote log-in with simple token and PIN number. Cryptology ePrint Archive, Report 2002/164, 2002. http://eprint.iacr.org/2002/164.</li>

      <li>[15] M. Shirase, D. Han, Y. Hibin, H. Kim, and T. Takagi. A more compact representation of XTR cryptosystem. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, E91-A:2843â€“2850, 2008.</li>

      <li>[16] P. Smith and C. Skinner. A public-key cryptosystem and a digital signature system based on the Lucas function analogue to discrete logarithms. Advances in Cryptology â€“ ASIACRYPT â€™94, Lecture Notes In Computer Science, 917:357â€“364, 1994.</li>

      <li>[17] M. Stam and A. Lenstra. Speeding up XTR. Advances in Cryptology â€“ ASIACRYPT 2001, Lecture Notes in Computer Science, 2248:125â€“143, 2001.</li>

      <li>[18] T. Takagi, S. Yen, and B. Wu. Radix-r non-adjacent form. Information Security â€“ ISC 2004, Lecture Notes In Computer Science, 3225:99â€“110, 2004.</li>

      <li>[19] M. van Dijk, R. Granger, D. Page, K. Rubin, A. Silverberg, M. Stam, and D. Woodruff. Practical cryptography in high dimensional tori. Advances in Cryptology â€“ EUROCRYPT 2005, Lecture Notes in Computer Science, 3494:234â€“250, 2005.</li>

      <li>[20] M. van Dijk and D. Woodruff. Asymptotically optimal communication for torus-based cryptography. Advances in Cryptology â€“ CRYPTO 2004, Lecture Notes in Computer Science, 3152:151â€“178, 2004.</li>

      <li>[21] B. Waters. Efficient identity-based encryption without random oracles. Advances in Cryptology â€“ EUROCRYPT 2005, Lecture Notes in Computer Science, 3494:114â€“127, 2005.</li>

    </ul>`;
---

<BaseLayout title="Torus-based compression by factor 4 and 6 (2010/525)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/525
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
