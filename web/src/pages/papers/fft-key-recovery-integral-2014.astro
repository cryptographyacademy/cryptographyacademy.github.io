---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/187';
const CRAWLER = 'marker';
---

<BaseLayout title="FFT-Based Key Recovery for Integral Attack (2014/187)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        FFT-Based Key Recovery for the Integral Attack
      </h1>
      <p class="text-gray-400 mb-2">
        Yosuke Todo
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; Full Version &middot; eprint 2014/187
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Our Contributions</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Integral Attack</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                Integral Distinguisher</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Key Recovery</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">FFT Technique</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Previous Works about FFT</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Evaluation of the Complexity</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">
                How to Apply FFT to the Integral Attack</a>
            </li>
            <li>
              <a href="#sec-3.4"
                class="hover:text-white">
                Application to AES</a>
            </li>
            <li>
              <a href="#sec-3.5"
                class="hover:text-white">
                Application to CLEFIA</a>
            </li>
            <li>
              <a href="#sec-3.6"
                class="hover:text-white">
                Comparison between FFT Technique and
                Partial-sum Technique</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Conclusion</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        The integral attack is one of the most powerful attacks against
        block ciphers. In this paper, we propose two new techniques for
        the integral attack, the FFT technique and the key concealment
        technique. The FFT technique is useful for the integral attack
        with enormous chosen plaintexts. As the previous result using
        FFT, Collard et al. showed a new technique which reduces the
        complexity for the linear attack. In this paper, we review the
        result of Collard et al. to estimate the complexity in detail,
        and we show the complexity can be estimated from the number of
        times using the addition of integers. Moreover, we show that
        attacks using FFT can be applied to the integral attack. As
        applications, we show integral attacks against AES and CLEFIA.
        For AES, we show that 6-round AES can be attacked with about
        <span class="math">2^&#123;51.7&#125;</span> additions. For
        CLEFIA, we show that 12-round CLEFIA can be attacked with about
        <span class="math">2^&#123;86.9&#125;</span> additions.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> Block cipher, Integral attack, Fast
        Fourier Transform, AES, CLEFIA
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1 INTRODUCTION                                               -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>
      <p class="text-gray-300">
        Block ciphers have round functions which are key-dependent
        nonlinear bijective functions, and block ciphers are constructed
        by performing round functions iteratively. The integral attack is
        one of the most powerful attacks against block ciphers, and it
        was firstly proposed by Daemen et al. to evaluate the security
        of Square [DKR97]. Thereafter, Knudsen and Wagner formulated the
        attack of Daemen et al. as the integral attack [KW02]. The integral
        attack consists of the distinguisher and the key recovery. For
        the distinguisher, we prepare
        <span class="math">N</span> chosen plaintexts, and get
        <span class="math">N</span> corresponding
        <span class="math">R</span>-round intermediate texts which are
        calculated from plaintexts by encrypting
        <span class="math">R</span> rounds. When the block cipher has
        the <span class="math">R</span>-round integral distinguisher,
        we can distinguish the XOR of
        <span class="math">N</span> intermediate texts from that of
        <span class="math">N</span> random texts. In order to create
        the distinguisher, we often use three integral properties, the
        All(<span class="math">\mathcal&#123;A&#125;</span>)-property,
        the Balance(<span class="math">\mathcal&#123;B&#125;</span>)-property
        and the Constant(<span class="math">\mathcal&#123;C&#125;</span>)-property.
        We attack
        <span class="math">R + r</span>-round block ciphers by using
        the <span class="math">R</span>-round integral distinguisher.
        We first prepare chosen plaintexts for the integral
        distinguisher, and get corresponding ciphertexts. Next we
        recover <span class="math">R</span>-round intermediate texts by
        guessing round keys used in the last
        <span class="math">r</span> rounds. If the guessing key is
        wrong, intermediate texts behave as random texts. On the other
        hand, if the guessing key is correct, intermediate texts have
        the integral property. Then we can recover the correct round key.
      </p>
      <p class="text-gray-300">
        Several improving techniques for the integral attack have been
        proposed. In particular, there exist improving techniques for the
        key recovery, e.g., the partial-sum technique [FKL+00] and the
        meet-in-the-middle (MITM) technique [SW12b]. The partial-sum
        technique was proposed by Ferguson et al. in 2000. Generally,
        the integral attack uses enormous chosen plaintexts. For
        instance, when the integral attack uses
        <span class="math">2^n</span> chosen plaintexts and recovers
        the <span class="math">k</span>-bit key, it needs
        <span class="math">2^&#123;k+n&#125;</span> time complexity. We
        can reduce the complexity by using the partial-sum technique in
        which we partially compute the sum by guessing each key one
        after another. Ferguson et al. applied the technique to AES
        [NIST01], and showed that 6-round AES is attacked with
        <span class="math">6 \times 2^&#123;50&#125;</span> S-box
        lookups. The MITM technique was proposed by Sasaki et al. in
        2012. By using this technique, we can reduce the complexity of
        the integral attack against several Feistel ciphers. Now we
        evaluate
        <span class="math">L(x \oplus y) = 0</span>, where
        <span class="math">x</span> and <span class="math">y</span>
        are calculated from ciphertexts by guessing keys. In the MITM
        technique, we first calculate
        <span class="math">Lx</span> and
        <span class="math">y</span> independently, and search keys
        satisfying
        <span class="math">Lx = Ly</span> by using the analysis such
        as the MITM attack [DH77]. As a result, Sasaki et al. improved
        integral attacks against LBlock [WZ11], HIGHT [HSH+06] and CLEFIA [SSA+07].
      </p>

      <!-- Table 1 -->
      <div class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 1:</strong> The comparison of attack results.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700 text-left">
              <th class="px-3 py-2 text-gray-300">Target</th>
              <th class="px-3 py-2 text-gray-300"># Rounds</th>
              <th class="px-3 py-2 text-gray-300">Data</th>
              <th class="px-3 py-2 text-gray-300">Time</th>
              <th class="px-3 py-2 text-gray-300">Techniques</th>
              <th class="px-3 py-2 text-gray-300">Ref.</th>
            </tr>
          </thead>
          <tbody class="text-gray-400">
            <tr class="border-b border-gray-800">
              <td class="px-3 py-2">AES</td>
              <td class="px-3 py-2">6</td>
              <td class="px-3 py-2">
                <span class="math">2^&#123;32&#125;</span> CP
              </td>
              <td class="px-3 py-2">
                <span class="math">6 \times 2^&#123;50&#125;</span>
                S-box lookups
              </td>
              <td class="px-3 py-2">
                Integral (Partial-sum)
              </td>
              <td class="px-3 py-2">[FKL+00]</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="px-3 py-2">AES</td>
              <td class="px-3 py-2">6</td>
              <td class="px-3 py-2">
                <span class="math">2^&#123;32&#125;</span> CP
              </td>
              <td class="px-3 py-2">
                <span class="math">6 \times 2^&#123;51.7&#125;</span>
                additions
              </td>
              <td class="px-3 py-2">
                Integral (FFT)
              </td>
              <td class="px-3 py-2">Sect. 3.4</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="px-3 py-2">CLEFIA</td>
              <td class="px-3 py-2">12</td>
              <td class="px-3 py-2">
                <span class="math">2^&#123;112&#125;</span> CP
              </td>
              <td class="px-3 py-2">
                <span class="math">13 \times 2^&#123;106&#125;</span>
                S-box lookups
              </td>
              <td class="px-3 py-2">
                Integral (MITM, Partial-sum)
              </td>
              <td class="px-3 py-2">[SW12b]</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="px-3 py-2">CLEFIA</td>
              <td class="px-3 py-2">12</td>
              <td class="px-3 py-2">
                <span class="math">2^&#123;112&#125;</span> CP
              </td>
              <td class="px-3 py-2">
                <span class="math">5 \times 2^&#123;86.9&#125;</span>
                additions
              </td>
              <td class="px-3 py-2">
                Integral (MITM, FFT)
              </td>
              <td class="px-3 py-2">Sect. 3.5</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">
        1.1 Our Contributions
      </h3>
      <p class="text-gray-300">
        In this paper, we propose new improving techniques for the
        integral attack, the FFT technique. By using this technique, we
        improve integral attacks against AES and CLEFIA. Table 1 shows
        the comparison of previous and our attacks.
      </p>
      <p class="text-gray-300">
        The FFT technique is useful for the integral attack with
        enormous chosen plaintexts, then the reason to introduce this
        technique is similar to the reason to introduce the partial-sum
        technique. However applications of two techniques are a little
        different, and we discuss the difference in Sect. 3.6. As
        previous attacks using FFT, there exist two results. First
        Collard et al. proposed the linear attack using FFT in 2007 [CSQ07].
        Next Bogdanov et al. proposed the zero correlation attack using
        FFT in 2013 [BGW+13]. In this paper, we review the result of Collard
        et al. to estimate the complexity in detail. First we use the
        Fast Walsh-Hadamard Transform instead of FFT. As a result, we
        show that the complexity can be estimated from the number of
        times using the addition of integers. The bit length of the
        addition is at most a double key length, e.g., the bit length
        of the addition is 256-bit when the bit length of the guessing
        key is 128-bit. We assume that the complexity of one addition is
        almost the same as that of one S-box lookup. Moreover, we show
        that FFT can be applied to the integral attack.
      </p>
      <p class="text-gray-300">
        As the application, we first show the integral attack against
        AES. When we use the FFT technique, 6-round AES can be attacked
        with about <span class="math">2^&#123;51.7&#125;</span>
        additions. We next show the integral attack against 12-round
        CLEFIA. When we use both the FFT technique and the MITM
        technique, 12-round CLEFIA can be attacked with about
        <span class="math">2^&#123;86.9&#125;</span> additions. Then we
        improve integral attacks against 6-round AES and 12-round
        CLEFIA.
      </p>
      <p class="text-gray-300 text-sm mt-4">
        <em>Note:</em> In [FKL+00], Ferguson et al. showed the integral
        attack against 7-round AES. The complexity of the attack is
        derived from the preparation of adaptive chosen plaintexts. Then
        there is no change in the complexity of the integral attack
        against 7-round AES even if we use the FFT technique.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2 INTEGRAL ATTACK                                            -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Integral Attack</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">
        2.1 Integral Distinguisher
      </h3>
      <p class="text-gray-300">
        We define three major integral properties as follows:
      </p>
      <ul class="list-disc list-inside text-gray-300 my-4 space-y-2">
        <li>
          <span class="math">\mathcal&#123;A&#125;</span>-property: all
          values appear exactly the same number in the set of texts.
        </li>
        <li>
          <span class="math">\mathcal&#123;B&#125;</span>-property: the
          XOR of all texts in the set is 0.
        </li>
        <li>
          <span class="math">\mathcal&#123;C&#125;</span>-property: the
          value is fixed to a constant for all texts in the set.
        </li>
      </ul>
      <p class="text-gray-300">
        We construct the integral distinguisher by using integral
        properties. For instance, the 4-round integral distinguisher of
        AES is shown in Fig. 1 of the original paper. In the 1st round,
        four values have
        <span class="math">\mathcal&#123;A&#125;_1</span>-property,
        where the concatenation of their four values also has
        <span class="math">\mathcal&#123;A&#125;</span>-property. In
        the distinguisher, we use
        <span class="math">2^&#123;32&#125;</span> chosen plaintexts,
        and each byte after encrypting 4 rounds has
        <span class="math">\mathcal&#123;B&#125;</span>-property.
      </p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">
        2.2 Key Recovery
      </h3>
      <p class="text-gray-300">
        We can recover the key by using the integral distinguisher. For
        instance, the key recovery of the integral attack against
        6-round AES is shown in Fig. 2 of the original paper. Now we
        have <span class="math">2^&#123;32&#125;</span> ciphertexts of
        6-round AES, and we know that the value
        <span class="math">y</span> has
        <span class="math">\mathcal&#123;B&#125;</span>-property. Let
        <span class="math">c[j]</span> be byte data in ciphertexts,
        and <span class="math">c_n</span> denotes the
        <span class="math">n</span>-th ciphertext. Then the XOR of
        <span class="math">y</span> is calculated from
        <span class="math">2^&#123;32&#125;</span> ciphertexts as
        follows:
      </p>
      <div class="math-block">
        \bigoplus_&#123;n=1&#125;^&#123;2^&#123;32&#125;&#125;
        S_5 \left(
          S_1(c_n[The07] \oplus k_1) \oplus
          S_2(c_n[Bog+13] \oplus k_2) \oplus
          S_3(c_n[ColStaQui07] \oplus k_3) \oplus
          S_4(c_n[DaeKnuRij97] \oplus k_4) \oplus k_5
        \right) = 0
        \tag&#123;1&#125;
      </div>
      <p class="text-gray-300">
        where <span class="math">S_1, S_2, \ldots, S_5</span> are
        S-boxes, each of which consists of an inverse AES S-box and a
        multiplication by a field element from the inverse AES MDS
        matrix. Moreover
        <span class="math">k_1, k_2, k_3</span> and
        <span class="math">k_4</span> are calculated from
        <span class="math">RK_6</span> and
        <span class="math">k_5</span> is calculated from
        <span class="math">RK_5</span>, then the bit length of
        guessing key is 40-bit. The analysis takes about
        <span class="math">2^&#123;32+40&#125; = 2^&#123;70&#125;</span>
        time complexity with the straightforward method. However we can
        reduce the complexity by using the partial-sum technique. In the
        partial-sum technique, we partially compute the sum by guessing
        each key one after another. Ferguson <em>et al.</em> showed that
        the analysis takes only
        <span class="math">2^&#123;50&#125;</span> S-box lookups.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3 FFT TECHNIQUE                                              -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 FFT Technique</h2>
      <p class="text-gray-300">
        In this section, we show a new technique for the integral
        attack, the FFT technique. In Sect. 3.1, we show the previous
        attack using FFT which was proposed by Collard et al. in 2007.
        Their attack can reduce the complexity of the linear attack, but
        the complexity of their attack is different from that of
        classical attacks. In classical attacks, we estimate the
        complexity from the number of times using S-box lookups or
        encryptions. However, in the attack using FFT, we estimate the
        complexity from the computational complexity of FFT. Then we
        cannot compare classical attacks and attacks using FFT simply.
        In Sect. 3.2, we review the result of Collard et al. to
        estimate the complexity in detail. As a result, we show how to
        compare two attacks. In Sect. 3.3, we show that attacks using
        FFT can be applied to the integral attack. As applications, we
        show integral attacks against AES and CLEFIA in Sect. 3.4 and
        Sect. 3.5, respectively. Finally we compare the FFT technique
        and the partial-sum technique in Sect. 3.6.
      </p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">
        3.1 Previous Works about FFT
      </h3>
      <p class="text-gray-300">
        As the previous attack using FFT, Collard <em>et al.</em> showed
        a linear attack using FFT in 2007. In the key recovery of the
        linear attack [Mat93], for any <span class="math">k</span>-bit key
        <span class="math">rk</span>, we often evaluate the following
        equation:
      </p>
      <div class="math-block">
        \sum_&#123;n=1&#125;^&#123;N&#125; f(c_n \oplus rk)
        \tag&#123;2&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">f: \mathbb&#123;F&#125;_2^k \to \mathbb&#123;F&#125;_2</span>
        is a boolean function. We have
        <span class="math">N</span> ciphertexts
        <span class="math">c_1, c_2, \ldots, c_N</span>, and the
        boolean function <span class="math">f</span> is generated from
        the linear approximate equation. The evaluation of Eq. (2)
        takes <span class="math">N 2^k</span> time complexity with the
        straightforward method, and the size of
        <span class="math">N</span> is generally enormous (i.e.
        <span class="math">N > 2^k</span>). Collard <em>et al.</em>
        showed that the evaluation of Eq. (2) takes about
        <span class="math">3k 2^k</span> time complexity by using FFT.
      </p>
      <p class="text-gray-300">
        First we create two <span class="math">k</span>-dimensional
        vectors <span class="math">\mathbf&#123;v&#125;</span> and
        <span class="math">\mathbf&#123;w&#125;</span>, where
        <span class="math">\mathbf&#123;v&#125;</span> is generated
        from the boolean function <span class="math">f</span> and
        <span class="math">\mathbf&#123;w&#125;</span> is generated
        from the set of ciphertexts as follows:
      </p>
      <div class="math-block">
        v_i = f(i)
      </div>
      <div class="math-block">
        w_i = \#\&#123;1 \le n \le N \mid c_n = i\&#125;
      </div>
      <p class="text-gray-300">
        Next we calculate a <span class="math">k</span>-dimensional
        vector <span class="math">\mathbf&#123;u&#125;</span> from
        <span class="math">\mathbf&#123;v&#125;</span> and
        <span class="math">\mathbf&#123;w&#125;</span> as follows:
      </p>
      <div class="math-block">
        \begin&#123;bmatrix&#125;
        u_0 \\ u_1 \\ u_2 \\ \vdots \\ u_&#123;2^k - 1&#125;
        \end&#123;bmatrix&#125;
        =
        \begin&#123;bmatrix&#125;
        v_0 &amp; v_1 &amp; v_2 &amp; \cdots &amp; v_&#123;2^k - 1&#125; \\
        v_1 &amp; v_0 &amp; v_3 &amp; \cdots &amp; v_&#123;2^k - 2&#125; \\
        v_2 &amp; v_3 &amp; v_0 &amp; \cdots &amp; v_&#123;2^k - 3&#125; \\
        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        v_&#123;2^k - 1&#125; &amp; v_&#123;2^k - 2&#125; &amp;
        v_&#123;2^k - 3&#125; &amp; \cdots &amp; v_0
        \end&#123;bmatrix&#125;
        \begin&#123;bmatrix&#125;
        w_0 \\ w_1 \\ w_2 \\ \vdots \\ w_&#123;2^k - 1&#125;
        \end&#123;bmatrix&#125;
        \tag&#123;3&#125;
      </div>
      <p class="text-gray-300">
        Then <span class="math">u_&#123;rk&#125;</span> is the same as
        the result of Eq. (2). Now we want to calculate Eq. (3) fast,
        then Collard et al. paid attention to the structure of the
        matrix and showed that Eq. (3) can be calculated fast by using
        FFT. We first calculate <span class="math">k</span>-dimensional
        vectors
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>
        from <span class="math">\mathbf&#123;v&#125;</span> and
        <span class="math">\mathbf&#123;w&#125;</span> by using FFT,
        respectively. Next we calculate a
        <span class="math">k</span>-dimensional vector
        <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;</span>
        where
        <span class="math">\hat&#123;u&#125;_i</span> is calculated
        from
        <span class="math">\hat&#123;v&#125;_i \times \hat&#123;w&#125;_i</span>.
        Finally we calculate a <span class="math">k</span>-dimensional
        vector <span class="math">\mathbf&#123;u&#125;</span> from
        <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;</span>
        by using the inverse FFT (IFFT). Each complexity of FFT and
        IFFT is <span class="math">k 2^k</span>. We calculate two FFTs
        and one IFFT to calculate
        <span class="math">\mathbf&#123;u&#125;</span>. Then the total
        complexity is <span class="math">3k 2^k</span>.
      </p>

      <!-- ---------------------------------------------------------- -->
      <!-- 3.2 Evaluation of the Complexity                           -->
      <!-- ---------------------------------------------------------- -->

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">
        3.2 Evaluation of the Complexity
      </h3>
      <p class="text-gray-300">
        We review the result of Collard <em>et al.</em> to estimate the
        complexity in detail. As a result, we show that the complexity
        can be estimated from the number of times using the addition of
        integers when we use the Fast Walsh-Hadamard Transform (FWHT)
        instead of FFT. Now we express Eq. (3) as
        <span class="math">\mathbf&#123;u&#125; = \mathbf&#123;V&#125; \times \mathbf&#123;w&#125;</span>
        simply. First we create four
        <span class="math">2^&#123;k-1&#125;</span>-dimensional block
        matrices
        <span class="math">\mathbf&#123;V&#125;_&#123;1,1&#125;</span>,
        <span class="math">\mathbf&#123;V&#125;_&#123;1,2&#125;</span>,
        <span class="math">\mathbf&#123;V&#125;_&#123;2,1&#125;</span>
        and
        <span class="math">\mathbf&#123;V&#125;_&#123;2,2&#125;</span>
        as follows:
      </p>
      <div class="math-block">
        \mathbf&#123;V&#125; =
        \begin&#123;bmatrix&#125;
        \mathbf&#123;V&#125;_&#123;1,1&#125; &amp;
        \mathbf&#123;V&#125;_&#123;1,2&#125; \\
        \mathbf&#123;V&#125;_&#123;2,1&#125; &amp;
        \mathbf&#123;V&#125;_&#123;2,2&#125;
        \end&#123;bmatrix&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\mathbf&#123;V&#125;_&#123;1,1&#125; = \mathbf&#123;V&#125;_&#123;2,2&#125;</span>
        and
        <span class="math">\mathbf&#123;V&#125;_&#123;1,2&#125; = \mathbf&#123;V&#125;_&#123;2,1&#125;</span>
        are satisfied. From the diagonalization of
        <span class="math">\mathbf&#123;V&#125;</span>, we have
      </p>
      <div class="math-block">
        \mathbf&#123;V&#125; =
        \begin&#123;bmatrix&#125;
        \mathbf&#123;V&#125;_&#123;1,1&#125; &amp;
        \mathbf&#123;V&#125;_&#123;1,2&#125; \\
        \mathbf&#123;V&#125;_&#123;1,2&#125; &amp;
        \mathbf&#123;V&#125;_&#123;1,1&#125;
        \end&#123;bmatrix&#125;
        = \frac&#123;1&#125;&#123;2&#125;
        \begin&#123;bmatrix&#125;
        \mathbf&#123;I&#125; &amp; \mathbf&#123;I&#125; \\
        \mathbf&#123;I&#125; &amp; -\mathbf&#123;I&#125;
        \end&#123;bmatrix&#125;
        \begin&#123;bmatrix&#125;
        \mathbf&#123;V&#125;_&#123;1,1&#125; +
        \mathbf&#123;V&#125;_&#123;1,2&#125; &amp;
        \mathbf&#123;0&#125; \\
        \mathbf&#123;0&#125; &amp;
        \mathbf&#123;V&#125;_&#123;1,1&#125; -
        \mathbf&#123;V&#125;_&#123;1,2&#125;
        \end&#123;bmatrix&#125;
        \begin&#123;bmatrix&#125;
        \mathbf&#123;I&#125; &amp; \mathbf&#123;I&#125; \\
        \mathbf&#123;I&#125; &amp; -\mathbf&#123;I&#125;
        \end&#123;bmatrix&#125;
      </div>
      <p class="text-gray-300">
        Since structures of
        <span class="math">\mathbf&#123;V&#125;_&#123;1,1&#125; + \mathbf&#123;V&#125;_&#123;1,2&#125;</span>
        and
        <span class="math">\mathbf&#123;V&#125;_&#123;1,1&#125; - \mathbf&#123;V&#125;_&#123;1,2&#125;</span>
        are the same as that of
        <span class="math">\mathbf&#123;V&#125;</span>, we can get the
        following equation:
      </p>
      <div class="math-block">
        \mathbf&#123;V&#125; = \frac&#123;1&#125;&#123;2^k&#125;
        \times \mathbf&#123;H&#125;_&#123;2^k&#125;
        \times \operatorname&#123;diag&#125;(
        \mathbf&#123;H&#125;_&#123;2^k&#125; \mathbf&#123;v&#125;)
        \times \mathbf&#123;H&#125;_&#123;2^k&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\mathbf&#123;H&#125;_&#123;2^k&#125;</span>
        is the <span class="math">2^k</span>-dimensional Walsh matrix.
        Then we can express Eq. (3) as follows:
      </p>
      <div class="math-block">
        \mathbf&#123;u&#125; = \mathbf&#123;V&#125; \times
        \mathbf&#123;w&#125; = \frac&#123;1&#125;&#123;2^k&#125;
        \mathbf&#123;H&#125;_&#123;2^k&#125; \times
        \operatorname&#123;diag&#125;(
        \mathbf&#123;H&#125;_&#123;2^k&#125; \mathbf&#123;v&#125;)
        \times \mathbf&#123;H&#125;_&#123;2^k&#125; \mathbf&#123;w&#125;
      </div>
      <p class="text-gray-300">
        Then the procedure to calculate
        <span class="math">\mathbf&#123;u&#125;</span> is as follows:
      </p>
      <ol class="list-decimal list-inside text-gray-300 my-4
        space-y-3">
        <li>
          We calculate
          <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125; = \mathbf&#123;H&#125;_&#123;2^k&#125; \mathbf&#123;v&#125;</span>.
          Then we can express Eq. (3) as
          <span class="math">\mathbf&#123;u&#125; = \frac&#123;1&#125;&#123;2^k&#125; \mathbf&#123;H&#125;_&#123;2^k&#125; \times \operatorname&#123;diag&#125;(\hat&#123;\mathbf&#123;v&#125;&#125;) \times \mathbf&#123;H&#125;_&#123;2^k&#125; \mathbf&#123;w&#125;</span>.
        </li>
        <li>
          We calculate
          <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125; = \mathbf&#123;H&#125;_&#123;2^k&#125; \mathbf&#123;w&#125;</span>.
          Then we can express Eq. (3) as
          <span class="math">\mathbf&#123;u&#125; = \frac&#123;1&#125;&#123;2^k&#125; \mathbf&#123;H&#125;_&#123;2^k&#125; \times \operatorname&#123;diag&#125;(\hat&#123;\mathbf&#123;v&#125;&#125;) \hat&#123;\mathbf&#123;w&#125;&#125;</span>.
        </li>
        <li>
          We calculate
          <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;</span>
          where <span class="math">\hat&#123;u&#125;_i</span> is
          calculated from
          <span class="math">\hat&#123;v&#125;_i \times \hat&#123;w&#125;_i</span>.
          Then we can express Eq. (3) as
          <span class="math">\mathbf&#123;u&#125; = \frac&#123;1&#125;&#123;2^k&#125; \mathbf&#123;H&#125;_&#123;2^k&#125; \hat&#123;\mathbf&#123;u&#125;&#125;</span>.
        </li>
        <li>
          We calculate
          <span class="math">\mathbf&#123;u&#125; = \frac&#123;1&#125;&#123;2^k&#125; \mathbf&#123;H&#125;_&#123;2^k&#125; \hat&#123;\mathbf&#123;u&#125;&#125;</span>.
        </li>
      </ol>
      <p class="text-gray-300">
        In the 1st, 2nd and 3rd steps, we calculate the multiplication
        of the Walsh matrix using FWHT. We can calculate FWHT with
        <span class="math">k 2^k</span> additions. Moreover we can
        calculate the division of a power of 2 fast. Then each
        complexity of the 1st, 2nd and 4th step is
        <span class="math">k 2^k</span> additions. In the 3rd step, we
        calculate <span class="math">2^k</span> multiplications of
        <span class="math">k</span>-bit integers, and we think that the
        complexity is equal to the complexity of
        <span class="math">k</span> additions. Then the complexity of
        the 3rd step is <span class="math">k 2^k</span> additions.
        Therefore the detailed complexity for the attack using FFT is
        <span class="math">4k 2^k</span> additions. It is difficult to
        compare the complexity of one addition and that of one S-box
        lookup simply. However, the bit length of the addition is at
        most a double key length, then we assume that the complexity of
        one addition is almost the same as that of one S-box lookup.
        Hereafter we do not distinguish FFT with FWHT, and FFT
        represents FWHT.
      </p>

      <!-- ---------------------------------------------------------- -->
      <!-- 3.3 How to Apply FFT to the Integral Attack                -->
      <!-- ---------------------------------------------------------- -->

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">
        3.3 How to Apply FFT to the Integral Attack
      </h3>
      <p class="text-gray-300">
        We can apply FFT to other attacks. Bogdanov et al. showed a
        zero correlation attack using FFT in 2013 [BGW+13]. In this paper,
        we show that FFT can be applied to the integral attack. We
        assume the key recovery using
        <span class="math">\mathcal&#123;B&#125;</span>-property,
        namely, the key recovery can be expressed in the following
        equation:
      </p>
      <div class="math-block">
        \bigoplus_&#123;n=1&#125;^&#123;N&#125;
        F_&#123;rk_2&#125;(F(c_n \oplus rk_1)) = 0
      </div>
      <p class="text-gray-300">
        where <span class="math">F</span> is a function from
        <span class="math">\mathbb&#123;F&#125;_2^&#123;k_1&#125;</span>
        to
        <span class="math">\mathbb&#123;F&#125;_2^&#123;k_1&#125;</span>,
        <span class="math">F_&#123;rk_2&#125;</span> is a function from
        <span class="math">\mathbb&#123;F&#125;_2^&#123;k_1&#125;</span>
        to
        <span class="math">\mathbb&#123;F&#125;_2^\ell</span>
        depending on <span class="math">rk_2</span>.
        <span class="math">rk_1</span> denotes the
        <span class="math">k_1</span>-bit key and
        <span class="math">rk_2</span> denotes the
        <span class="math">k_2</span>-bit key. This equation is always
        satisfied when <span class="math">rk_1</span> and
        <span class="math">rk_2</span> are correct. However the
        probability satisfying this equation is
        <span class="math">2^&#123;-\ell&#125;</span> when
        <span class="math">rk_1</span> and
        <span class="math">rk_2</span> are wrong.
      </p>
      <p class="text-gray-300">
        To apply FFT, the summation must be calculated on integers.
        Then we have the following equation:
      </p>
      <div class="math-block">
        \left( \sum_&#123;n=1&#125;^&#123;N&#125;
        F_&#123;rk_2&#125;^&#123;(j)&#125;(F(c_n \oplus rk_1))
        \right) = 0 \mod 2
        \tag&#123;4&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">F_&#123;rk_2&#125;^&#123;(j)&#125;</span>
        is a boolean function whose output is the
        <span class="math">j</span>-th bit of
        <span class="math">F_&#123;rk_2&#125;</span>. The probability
        satisfying this equation is
        <span class="math">2^&#123;-1&#125;</span> when
        <span class="math">rk_1</span> and
        <span class="math">rk_2</span> are wrong. We evaluate Eq. (4)
        by using FFT. Our analysis consists of 3 steps, the circuit
        evaluation step, the ciphertexts evaluation step and the key
        recovery step.
      </p>
      <ul class="list-disc list-inside text-gray-300 my-4 space-y-3">
        <li>
          <strong>The circuit evaluation step.</strong> We evaluate the
          circuit, namely, we create
          <span class="math">\mathbf&#123;v&#125;</span> and calculate
          <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;</span>
          using FFT. This step does not depend on sets of ciphertexts
          and the key, then we can execute this step in advance.
        </li>
        <li>
          <strong>The ciphertexts evaluation step.</strong> We evaluate
          sets of ciphertexts, namely, we create
          <span class="math">\mathbf&#123;w&#125;</span> and calculate
          <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>
          using FFT.
        </li>
        <li>
          <strong>The key recovery step.</strong> We calculate
          <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;</span>
          from
          <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;</span>
          and
          <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>,
          and calculate
          <span class="math">\mathbf&#123;u&#125;</span> using FFT.
          Finally we recover the key from
          <span class="math">\mathbf&#123;u&#125;</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        Roughly, we can estimate that the complexity to execute the FFT
        technique is
        <span class="math">\ell \times k_1 \times 2^&#123;k_1 + k_2&#125;</span>,
        but the estimation of the detailed complexity is complicated.
        For integral attacks against AES and CLEFIA, we estimate the
        detailed complexity in Sect. 3.4 and Sect. 3.5.
      </p>

      <!-- ---------------------------------------------------------- -->
      <!-- 3.4 Application to AES                                     -->
      <!-- ---------------------------------------------------------- -->

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">
        3.4 Application to AES
      </h3>
      <p class="text-gray-300">
        <strong>Apply the FFT Technique.</strong> We apply the FFT
        technique to the key recovery of 6-round AES. Since the
        summation must be calculated on integers, we transform Eq. (1)
        to the following equation:
      </p>
      <div class="math-block">
        \sum_&#123;n=1&#125;^&#123;2^&#123;32&#125;&#125;
        S_5^&#123;(i)&#125; \left(
          S_1(c_n[The07] \oplus k_1) \oplus
          S_2(c_n[Bog+13] \oplus k_2) \oplus
          S_3(c_n[ColStaQui07] \oplus k_3) \oplus
          S_4(c_n[DaeKnuRij97] \oplus k_4) \oplus k_5
        \right)
      </div>
      <div class="math-block">
        = \sum_&#123;n=1&#125;^&#123;2^&#123;32&#125;&#125;
        F_&#123;k_5&#125;^&#123;(i)&#125; \left(
          F(c_n \oplus k_1 \| k_2 \| k_3 \| k_4)
        \right)
      </div>
      <p class="text-gray-300">
        where <span class="math">F</span> is a function from
        <span class="math">\mathbb&#123;F&#125;_2^&#123;32&#125;</span>
        to
        <span class="math">\mathbb&#123;F&#125;_2^&#123;32&#125;</span>,
        and
        <span class="math">F_&#123;k_5&#125;</span> is a function from
        <span class="math">\mathbb&#123;F&#125;_2^&#123;32&#125;</span>
        to
        <span class="math">\mathbb&#123;F&#125;_2^8</span> depending on
        <span class="math">k_5</span>. Since the output of
        <span class="math">F_&#123;k_5&#125;</span> is an 8-bit,
        <span class="math">i</span> is chosen from
        <span class="math">1, 2, \ldots, 8</span>.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The circuit evaluation step.</strong> We first create a
        <span class="math">2^8 \times 2^&#123;32&#125;</span>-dimensional
        vector <span class="math">\mathbf&#123;T&#125;</span>. For any
        <span class="math">k_5</span>,
        <span class="math">\mathbf&#123;T&#125;_&#123;k_5&#125;</span>
        is created as follows:
      </p>
      <div class="math-block">
        \mathbf&#123;T&#125;_&#123;k_5&#125; =
        [F_&#123;k_5&#125;(F(0)),\;
         F_&#123;k_5&#125;(F(1)),\; \dots,\;
         F_&#123;k_5&#125;(F(2^&#123;32&#125; - 1))]
      </div>
      <p class="text-gray-300">
        Moreover, we create
        <span class="math">2^&#123;32&#125;</span>-dimensional vectors
        <span class="math">\mathbf&#123;v&#125;^&#123;(i)&#125;</span>
        from
        <span class="math">\mathbf&#123;T&#125;_&#123;k_5&#125;</span>
        as follows:
      </p>
      <div class="math-block">
        \mathbf&#123;v&#125;_&#123;k_5&#125;^&#123;(i)&#125; =
        [T_&#123;k_5,0&#125;^&#123;(i)&#125;,\;
         T_&#123;k_5,1&#125;^&#123;(i)&#125;,\; \dots,\;
         T_&#123;k_5,2^&#123;32&#125;-1&#125;^&#123;(i)&#125;]
      </div>
      <p class="text-gray-300">
        where
        <span class="math">T_&#123;k_5,j&#125;^&#123;(i)&#125;</span>
        denotes <span class="math">i</span>-th bit of
        <span class="math">T_&#123;k_5,j&#125;</span>. Finally we
        calculate
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;_&#123;k_5&#125;^&#123;(i)&#125;</span>
        for any <span class="math">k_5</span> and any
        <span class="math">i</span> by using FFT. The dominant
        complexity of this step is a calculation of FFT. Since
        <span class="math">k_5</span> is an 8-bit and
        <span class="math">i</span> is chosen from
        <span class="math">1, 2, \ldots, 8</span>, the complexity is
        <span class="math">2^8 \times 8 \times 32 \times 2^&#123;32&#125; = 2^&#123;48&#125;</span>
        additions.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The ciphertexts evaluation step.</strong> We count how
        many times each value of 4-byte
        <span class="math">c</span> appears, and create a
        <span class="math">2^&#123;32&#125;</span>-dimensional vector
        <span class="math">\mathbf&#123;w&#125;</span>. When the number
        of <span class="math">c</span> satisfying
        <span class="math">c = j</span> is even,
        <span class="math">w_j</span> is 0. When the number of
        <span class="math">c</span> satisfying
        <span class="math">c = j</span> is odd,
        <span class="math">w_j</span> is 1. Next we calculate
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>
        by using FFT. The complexity of this step is
        <span class="math">32 \times 2^&#123;32&#125; = 2^&#123;37&#125;</span>
        additions, and it is negligible.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The key recovery step.</strong> We calculate
        <span class="math">2^&#123;32&#125;</span>-dimensional vectors
        <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;_&#123;k_5&#125;^&#123;(i)&#125;</span>
        from
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;_&#123;k_5&#125;^&#123;(i)&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>.
        Next we calculate
        <span class="math">\mathbf&#123;u&#125;_&#123;k_5&#125;^&#123;(i)&#125;</span>
        by using FFT. When <span class="math">k_5</span> is correct,
        <span class="math">u_&#123;k_5&#125;^&#123;(i)&#125;[k_1 \| k_2 \| k_3 \| k_4] = 0 \mod 2</span>
        holds for all <span class="math">i</span>. Since
        <span class="math">k_5</span> is an 8-bit key and
        <span class="math">i</span> is chosen from
        <span class="math">1, 2, \ldots, 8</span>, the complexity to
        calculate
        <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;</span>
        is
        <span class="math">2^8 \times 8 \times 2^&#123;32&#125;</span>
        32-bit multiplications
        (<span class="math">= 2^&#123;48&#125;</span> additions).
        Moreover the complexity to calculate
        <span class="math">\mathbf&#123;u&#125;</span> is
        <span class="math">2^8 \times 8 \times 32 \times 2^&#123;32&#125; = 2^&#123;48&#125;</span>
        additions. Then the complexity of this step is
        <span class="math">2^&#123;49&#125;</span> additions.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The total complexity.</strong> Ferguson <em>et al.</em>
        used 6 sets to recover 5 keys. We also use 6 sets. Since the
        circuit evaluation step does not depend on sets of ciphertexts
        and the key, we repeat the ciphertexts evaluation step and the
        key recovery step 6 times. Then the total complexity is about
        <span class="math">2^&#123;48&#125; + 6 \times 2^&#123;49&#125; \approx 2^&#123;51.7&#125;</span>
        additions.
      </p>

      <!-- ---------------------------------------------------------- -->
      <!-- 3.5 Application to CLEFIA                                  -->
      <!-- ---------------------------------------------------------- -->

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">
        3.5 Application to CLEFIA
      </h3>
      <p class="text-gray-300">
        <strong>CLEFIA.</strong> CLEFIA is a 128-bit block cipher which
        was proposed by Shirai <em>et al.</em> in 2007, and it has the
        4-branch generalized Feistel network. CLEFIA is adopted as an
        ISO standard. The round function is defined as Fig. 3 of the
        original paper, and an
        <span class="math">i</span>-round intermediate text is
        calculated from an
        <span class="math">(i-1)</span>-round intermediate text,
        <span class="math">RK_&#123;2i-2&#125;</span> and
        <span class="math">RK_&#123;2i-1&#125;</span>. For the 128-bit
        security version, the number of rounds is 18.
      </p>
      <p class="text-gray-300">
        In the proposal of CLEFIA, Shirai et al. showed that CLEFIA has
        an 8-round integral distinguisher [CLF07]. Next, Li et al. showed
        that CLEFIA has a 9-round integral distinguisher [LWZ11] which needs
        <span class="math">2^&#123;112&#125;</span> chosen plaintexts.
        Moreover they showed that the integral attack can attack
        12-round CLEFIA. Sasaki and Wang showed the MITM technique and
        improved the complexity for the attack against 12-round CLEFIA
        to
        <span class="math">13 \times 2^&#123;106&#125;</span> S-box
        lookups.
      </p>
      <p class="text-gray-300">
        <strong>Apply the FFT Technique.</strong> We show the integral
        attack using FFT against 12-round CLEFIA. First we define
        several values and functions. Let
        <span class="math">C_1, C_2, C_3</span> and
        <span class="math">C_4</span> be ciphertexts and each value is
        a 32-bit (see Fig. 4 of the original paper). For any 32-bit
        data <span class="math">X</span>,
        <span class="math">X[i]</span> denotes the
        <span class="math">i</span>-th byte of
        <span class="math">X</span>, namely,
        <span class="math">X = X[The07] \| X[Bog+13] \| X[ColStaQui07] \| X[DaeKnuRij97]</span>.
        We define functions
        <span class="math">f_i : \mathbb&#123;F&#125;_2^&#123;32&#125; \to \mathbb&#123;F&#125;_2^8</span>
        and
        <span class="math">m_i : \mathbb&#123;F&#125;_2^&#123;32&#125; \to \mathbb&#123;F&#125;_2^8</span>
        as follows:
      </p>
      <div class="math-block">
        F_1(X) = f_1(X) \| f_2(X) \| f_3(X) \| f_4(X)
      </div>
      <div class="math-block">
        M_0^&#123;-1&#125;(X) = m_1(X) \| m_2(X) \| m_3(X) \| m_4(X)
      </div>
      <p class="text-gray-300">
        For any function <span class="math">f</span>, we define a
        boolean function
        <span class="math">f^&#123;(i)&#125;(X)</span> whose output is
        calculated from the <span class="math">i</span>-th bit of
        <span class="math">f(X)</span>. For any data
        <span class="math">x</span>,
        <span class="math">x^&#123;(i)&#125;</span> denotes the
        <span class="math">i</span>-th bit of
        <span class="math">x</span>.
      </p>
      <p class="text-gray-300">
        Our attack uses the 9-round integral distinguisher where the
        2nd branch of the 9-round intermediate text has
        <span class="math">\mathcal&#123;B&#125;</span>-property. First
        we apply the MITM technique. We move the position of
        <span class="math">M_0</span> in 10-round
        <span class="math">F_0</span> as Fig. 4 of the original paper.
        From the distinguisher, we have
        <span class="math">\bigoplus Y = \bigoplus Z</span>, and each
        1st byte is calculated as follows:
      </p>
      <div class="math-block">
        \bigoplus Y[The07] = \bigoplus S_0(f_1(F_0(C_0 \oplus RK_&#123;22&#125;)
        \oplus C_1 \oplus RK_&#123;21&#125; \oplus WK_2)
        \oplus C_2[The07] \oplus RK_&#123;18&#125;[The07])
      </div>
      <div class="math-block">
        \bigoplus Z[The07] = \bigoplus m_1(F_1(C_2 \oplus RK_&#123;23&#125;)
        \oplus C_3)
      </div>
      <p class="text-gray-300">
        <span class="math">\bigoplus Y[The07] = \bigoplus Z[The07]</span> is
        satisfied for correct
        <span class="math">RK_&#123;18&#125;</span>,
        <span class="math">RK_&#123;21&#125; \oplus WK_2</span>,
        <span class="math">RK_&#123;22&#125;</span> and
        <span class="math">RK_&#123;23&#125;</span>. The probability
        satisfying
        <span class="math">\bigoplus Y[The07] = \bigoplus Z[The07]</span> is
        <span class="math">2^&#123;-8&#125;</span> for wrong keys, and
        we can discard wrong keys fast by using the MITM technique.
      </p>
      <p class="text-gray-300">
        In order to apply the FFT technique, we transform the above
        equation to the following equation:
      </p>
      <div class="math-block">
        \sum Y[The07]^&#123;(i)&#125; = \sum S_0^&#123;(i)&#125;(
        f_1(F_0(C_0 \oplus RK_&#123;22&#125;) \oplus C_1 \oplus
        RK_&#123;21&#125; \oplus WK_2) \oplus C_2[The07] \oplus
        RK_&#123;18&#125;[The07])
      </div>
      <div class="math-block">
        \sum Z[The07]^&#123;(i)&#125; = \sum m_1^&#123;(i)&#125;(
        F_1(C_2 \oplus RK_&#123;23&#125;) \oplus C_3)
      </div>
      <p class="text-gray-300">
        For correct
        <span class="math">RK_&#123;18&#125;</span>,
        <span class="math">RK_&#123;21&#125; \oplus WK_2</span>,
        <span class="math">RK_&#123;22&#125;</span> and
        <span class="math">RK_&#123;23&#125;</span>,
        <span class="math">\sum Y[The07]^&#123;(i)&#125; = \sum Z[The07]^&#123;(i)&#125; \pmod&#123;2&#125;</span>
        is satisfied for all <span class="math">i</span>. The
        probability satisfying
        <span class="math">\sum Y[The07]^&#123;(i)&#125; = \sum Z[The07]^&#123;(i)&#125; \pmod&#123;2&#125;</span>
        is <span class="math">2^&#123;-1&#125;</span> for wrong keys,
        and we can discard wrong keys fast by using the MITM technique.
        Similarly we can discard wrong keys by using equations which are
        created from
        <span class="math">(Y[Bog+13], Z[Bog+13])</span>,
        <span class="math">(Y[ColStaQui07], Z[ColStaQui07])</span> and
        <span class="math">(Y[DaeKnuRij97], Z[DaeKnuRij97])</span>.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The circuit evaluation step.</strong> We first create a
        <span class="math">2^&#123;72&#125;</span>-dimensional vector
        <span class="math">\mathbf&#123;T&#125;</span> and a
        <span class="math">2^&#123;32&#125;</span>-dimensional vector
        <span class="math">\mathbf&#123;T&#125;'</span> as follows:
      </p>
      <div class="math-block">
        \mathbf&#123;T&#125; = [S_0(f_1(F_0(0) \oplus 0) \oplus 0),\;
        S_0(f_1(F_0(0) \oplus 0) \oplus 1),\; \dots,\;
        S_0(f_1(F_0(2^&#123;32&#125; - 1) \oplus 2^&#123;32&#125; - 1)
        \oplus 2^8 - 1)]
      </div>
      <div class="math-block">
        \mathbf&#123;T&#125;' = [F_1(0),\; F_1(1),\; \dots,\;
        F_1(2^&#123;32&#125; - 1)]
      </div>
      <p class="text-gray-300">
        Next we create
        <span class="math">2^&#123;72&#125;</span>-dimensional vectors
        <span class="math">\mathbf&#123;v&#125;^&#123;(i)&#125;</span>
        and
        <span class="math">2^&#123;32&#125;</span>-dimensional vectors
        <span class="math">\mathbf&#123;v&#125;'^&#123;(i)&#125;</span>
        as follows:
      </p>
      <div class="math-block">
        \mathbf&#123;v&#125;^&#123;(i)&#125; =
        [T_0^&#123;(i)&#125;,\; T_1^&#123;(i)&#125;,\; \dots,\;
        T_&#123;2^&#123;72&#125;-1&#125;^&#123;(i)&#125;],
        \quad
        \mathbf&#123;v&#125;'^&#123;(i)&#125; =
        [T_0'^&#123;(i)&#125;,\; T_1'^&#123;(i)&#125;,\; \dots,\;
        T_&#123;2^&#123;32&#125;-1&#125;'^&#123;(i)&#125;]
      </div>
      <p class="text-gray-300">
        Finally we calculate
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;^&#123;(i)&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;'^&#123;(i)&#125;</span>
        by using FFT. The complexity to calculate
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;^&#123;(i)&#125;</span>
        is
        <span class="math">8 \times 72 \times 2^&#123;72&#125; \approx 2^&#123;81.2&#125;</span>
        additions because <span class="math">i</span> is chosen from
        <span class="math">1, 2, \ldots, 8</span>. The complexity to
        calculate
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;'^&#123;(i)&#125;</span>
        is
        <span class="math">8 \times 32 \times 2^&#123;32&#125;</span>
        additions, and it is negligible. Similarly we calculate
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;^&#123;(i)&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;'^&#123;(i)&#125;</span>
        which are created from
        <span class="math">(Y[Bog+13], Z[Bog+13])</span>,
        <span class="math">(Y[ColStaQui07], Z[ColStaQui07])</span> and
        <span class="math">(Y[DaeKnuRij97], Z[DaeKnuRij97])</span>, then the total
        complexity is
        <span class="math">4 \times 2^&#123;81.2&#125; = 2^&#123;83.2&#125;</span>
        additions.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The ciphertexts evaluation step.</strong> We count how
        many times each value of 9-byte tuple
        <span class="math">(C_0, C_1, C_2[The07])</span> appears, and
        create a
        <span class="math">2^&#123;72&#125;</span>-dimensional vector
        <span class="math">\mathbf&#123;w&#125;</span>. Similarly we
        count how many times each value of 4-byte
        <span class="math">C_2</span> appears, and create a
        <span class="math">2^&#123;32&#125;</span>-dimensional vector
        <span class="math">\mathbf&#123;w&#125;'</span>. Moreover we
        calculate
        <span class="math">\bigoplus m_1(C_3)</span>. Next we calculate
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;'</span>
        by using FFT. The complexity to calculate
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>
        is
        <span class="math">72 \times 2^&#123;72&#125; \approx 2^&#123;78.2&#125;</span>
        additions. The complexity to calculate
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;'</span>
        is
        <span class="math">32 \times 2^&#123;32&#125;</span> additions,
        and it is negligible. Similarly we calculate
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;'</span>
        which are created from
        <span class="math">(Y[Bog+13], Z[Bog+13])</span>,
        <span class="math">(Y[ColStaQui07], Z[ColStaQui07])</span> and
        <span class="math">(Y[DaeKnuRij97], Z[DaeKnuRij97])</span>, then the total
        complexity is
        <span class="math">4 \times 2^&#123;78.2&#125; = 2^&#123;80.2&#125;</span>
        additions.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The key recovery step.</strong> We calculate
        <span class="math">2^&#123;72&#125;</span>-dimensional vectors
        <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;^&#123;(i)&#125;</span>
        from
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;^&#123;(i)&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;</span>,
        and calculate
        <span class="math">\mathbf&#123;u&#125;^&#123;(i)&#125;</span>
        by using FFT. Next we calculate
        <span class="math">2^&#123;32&#125;</span>-dimensional vectors
        <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;'^&#123;(i)&#125;</span>
        from
        <span class="math">\hat&#123;\mathbf&#123;v&#125;&#125;'^&#123;(i)&#125;</span>
        and
        <span class="math">\hat&#123;\mathbf&#123;w&#125;&#125;'</span>,
        and calculate
        <span class="math">\mathbf&#123;u&#125;'^&#123;(i)&#125;</span>
        by using FFT. For the correct
        <span class="math">RK_&#123;18&#125;</span>,
        <span class="math">RK_&#123;21&#125;</span>,
        <span class="math">RK_&#123;22&#125;</span> and
        <span class="math">RK_&#123;23&#125;</span>,
      </p>
      <div class="math-block">
        u^&#123;(i)&#125;[RK_&#123;22&#125; \| RK_&#123;21&#125; \|
        RK_&#123;18&#125;[The07]] =
        u'^&#123;(i)&#125;[RK_&#123;23&#125;] +
        \bigoplus m_1^&#123;(i)&#125;(C_3)
        \mod 2
        \tag&#123;5&#125;
      </div>
      <p class="text-gray-300">
        is satisfied for all <span class="math">i</span>. However for
        wrong keys, the probability satisfying Eq. (5) is
        <span class="math">2^&#123;-1&#125;</span>. Since
        <span class="math">i</span> is chosen from
        <span class="math">1, 2, \ldots, 8</span>, the complexity to
        calculate
        <span class="math">\hat&#123;\mathbf&#123;u&#125;&#125;^&#123;(i)&#125;</span>
        is
        <span class="math">8 \times 2^&#123;72&#125;</span> 72-bit
        multiplications
        (<span class="math">\approx 2^&#123;81.2&#125;</span>
        additions). The complexity to calculate
        <span class="math">\mathbf&#123;u&#125;^&#123;(i)&#125;</span>
        is
        <span class="math">8 \times 72 \times 2^&#123;72&#125; \approx 2^&#123;81.2&#125;</span>
        additions. Since the complexity for other operations is
        negligible, the complexity to evaluate Eq. (5) is about
        <span class="math">2^&#123;82.2&#125;</span> additions.
        Similarly we discard wrong keys by evaluating Eq. (5) which is
        created from
        <span class="math">(Y[Bog+13], Z[Bog+13])</span>,
        <span class="math">(Y[ColStaQui07], Z[ColStaQui07])</span> and
        <span class="math">(Y[DaeKnuRij97], Z[DaeKnuRij97])</span>. Then the total
        complexity is
        <span class="math">4 \times 2^&#123;82.2&#125; = 2^&#123;84.4&#125;</span>
        additions.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>The total complexity.</strong> By using one set, the
        probability that wrong keys remain is
        <span class="math">2^&#123;-32&#125;</span> because
        <span class="math">Y</span> and <span class="math">Z</span>
        are a 32-bit. In order to recover the 128-bit key
        <span class="math">RK_&#123;18&#125;</span>,
        <span class="math">RK_&#123;21&#125; \oplus WK_2</span>,
        <span class="math">RK_&#123;22&#125;</span> and
        <span class="math">RK_&#123;23&#125;</span>, we use 5 sets.
        Since the circuit evaluation step does not depend on sets of
        ciphertexts and the key, we repeat the ciphertexts evaluation
        step and the key recovery step 5 times. Then the total
        complexity is about
        <span class="math">2^&#123;83.2&#125; + 5(2^&#123;80.2&#125; + 2^&#123;84.4&#125;) \approx 2^&#123;86.9&#125;</span>
        additions.
      </p>

      <!-- ---------------------------------------------------------- -->
      <!-- 3.6 Comparison                                             -->
      <!-- ---------------------------------------------------------- -->

      <h3 id="sec-3.6" class="text-xl font-semibold mt-8">
        3.6 Comparison between FFT Technique and Partial-sum
        Technique
      </h3>
      <p class="text-gray-300">
        We compare the partial-sum technique and the FFT technique. In
        the partial-sum technique, we estimate the complexity from the
        number of times using S-box lookups, and we must access random
        access memories. On the other hand, in the FFT technique, we
        estimate the complexity from the number of additions, and we
        access mainly sequential access memories. Since the access to
        sequential access memories is more efficient than that to random
        access memories, we think that the FFT technique is more
        efficient than the partial-sum technique if the complexity is
        the same.
      </p>
      <p class="text-gray-300">
        However we have an open problem about the FFT technique. Since
        round keys of block ciphers are calculated from the secret key,
        we can know some bits of round keys when we guess some bits of
        the secret key. In the partial-sum technique, attackers can
        exploit the property and reduce the complexity efficiently. For
        instance, the integral attack against 22-round LBlock exploits
        this property [SW12a]. On the other hand, in the FFT technique, we
        do not know how to exploit this property.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4 CONCLUSION                                                 -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Conclusion</h2>
      <p class="text-gray-300">
        In this paper, we show new techniques for the integral attack,
        the FFT technique. This technique is useful for the integral
        attack with enormous chosen texts. In order to estimate the
        complexity of the FFT technique, we review the Collard's paper.
        Then we show the complexity can be estimated from the number of
        times using the addition of integers. As applications, we show
        that 6-round AES can be attacked with
        <span class="math">2^&#123;51.7&#125;</span> additions, and
        12-round CLEFIA can be attacked with
        <span class="math">2^&#123;86.9&#125;</span> additions.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-2 text-gray-400 text-sm list-none">
        <li>
          <span class="text-gray-500">[CLF07]</span>
          The 128-bit Blockcipher CLEFIA Security and Performance
          Evaluations. Sony Corporation (2007)
        </li>
        <li>
          <span class="text-gray-500">[BGW+13]</span>
          Bogdanov, A., Geng, H., Wang, M., Wen, L., Collard, B.:
          Zero-Correlation Linear Cryptanalysis with FFT and Improved
          Attacks on ISO Standards Camellia and CLEFIA. In: SAC (2013)
        </li>
        <li>
          <span class="text-gray-500">[CSQ07]</span>
          Collard, B., Standaert, F.X., Quisquater, J.J.: Improving the
          Time Complexity of Matsui&rsquo;s Linear Cryptanalysis. In:
          ICISC. LNCS, vol. 4817, pp. 77&ndash;88 (2007)
        </li>
        <li>
          <span class="text-gray-500">[DKR97]</span>
          Daemen, J., Knudsen, L.R., Rijmen, V.: The Block Cipher
          Square. In: FSE. LNCS, vol. 1267, pp. 149&ndash;165 (1997)
        </li>
        <li>
          <span class="text-gray-500">[DH77]</span>
          Diffie, W., Hellman, M.E.: Exhaustive Cryptanalysis of the NBS
          Data Encryption Standard. Computer 10, 74&ndash;84 (1977)
        </li>
        <li>
          <span class="text-gray-500">[FKL+00]</span>
          Ferguson, N., Kelsey, J., Lucks, S., Schneier, B., Stay, M.,
          Wagner, D., Whiting, D.: Improved Cryptanalysis of Rijndael.
          In: FSE. LNCS, vol. 1978, pp. 213&ndash;230 (2000)
        </li>
        <li>
          <span class="text-gray-500">[HSH+06]</span>
          Hong, D., Sung, J., Hong, S., Lim, J., Lee, S., Koo, B.,
          Lee, C., Chang, D., Lee, J., Jeong, K., Kim, H., Kim, J.,
          Chee, S.: HIGHT: A New Block Cipher Suitable for Low-Resource
          Device. In: CHES. LNCS, vol. 4249, pp. 46&ndash;59 (2006)
        </li>
        <li>
          <span class="text-gray-500">[KW02]</span>
          Knudsen, L.R., Wagner, D.: Integral Cryptanalysis. In: FSE.
          LNCS, vol. 2365, pp. 112&ndash;127 (2002)
        </li>
        <li>
          <span class="text-gray-500">[LWZ11]</span>
          Li, Y., Wu, W., Zhang, L.: Improved Integral Attacks on
          Reduced-Round CLEFIA Block Cipher. In: WISA. LNCS, vol. 7115,
          pp. 28&ndash;39 (2011)
        </li>
        <li>
          <span class="text-gray-500">[Mat93]</span>
          Matsui, M.: Linear Cryptanalysis Method for DES Cipher. In:
          EUROCRYPT. LNCS, vol. 765, pp. 386&ndash;397 (1993)
        </li>
        <li>
          <span class="text-gray-500">[NIST01]</span>
          National Institute of Standards and Technology: Specification
          for the ADVANCED ENCRYPTION STANDARD (AES). Federal Information
          Processing Standards Publication 197 (2001)
        </li>
        <li>
          <span class="text-gray-500">[SW12a]</span>
          Sasaki, Y., Wang, L.: Comprehensive Study of Integral Analysis
          on 22-Round LBlock. In: ICISC. LNCS, vol. 7839,
          pp. 156&ndash;169 (2012)
        </li>
        <li>
          <span class="text-gray-500">[SW12b]</span>
          Sasaki, Y., Wang, L.: Meet-in-the-Middle Technique for
          Integral Attacks against Feistel Ciphers. In: SAC. LNCS,
          vol. 7707, pp. 234&ndash;251 (2012)
        </li>
        <li>
          <span class="text-gray-500">[SSA+07]</span>
          Shirai, T., Shibutani, K., Akishita, T., Moriai, S.,
          Iwata, T.: The 128-Bit Blockcipher CLEFIA (Extended Abstract).
          In: FSE. LNCS, vol. 4593, pp. 181&ndash;195 (2007)
        </li>
        <li>
          <span class="text-gray-500">[WZ11]</span>
          Wu, W., Zhang, L.: LBlock: A Lightweight Block Cipher. In:
          ACNS. LNCS, vol. 6715, pp. 327&ndash;344 (2011)
        </li>
      </ul>
    </section>
  </article>
</BaseLayout>
