---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/280';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Simple Single Slot Finality Protocol For Ethereum';
const AUTHORS_HTML = 'Francesco D&#x27;Amato, Luca Zanolini';

const CONTENT = `    <p class="text-gray-300">Francesco D’Amato Ethereum Foundation francesco.damato@ethereum.org Luca Zanolini Ethereum Foundation luca.zanolini@ethereum.org</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Currently, Gasper, the implemented consensus protocol of Ethereum, takes between 64 and 95 slots to finalize blocks. Because of that, a significant portion of the chain is susceptible to reorgs. The possibility to capture MEV (Maximum Extractable Value) through such reorgs can then disincentivize honestly following the protocol, breaking the desired correspondence of honest and rational behavior. Moreover, the relatively long time to finality forces users to choose between economic security and faster transaction confirmation. This motivates the study of the so-called single slot finality protocols: consensus protocols that finalize a block in each slot and, more importantly, that finalize the block proposed at a given slot within such slot.</p>

    <p class="text-gray-300">In this work we propose a <em>simple, non-blackbox</em> protocol that combines a synchronous dynamically available protocol with a partially synchronous finality gadget, resulting in a consensus protocol that can finalize one block per slot, paving the way to <em>single slot finality</em> within Ethereum. Importantly, the protocol we present can finalize the block proposed in a slot, within such slot.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Traditional Byzantine consensus protocols, such as PBFT <em>[5]</em>, are devised in a partial synchronous network model <em>[8]</em>, in the sense that they always guarantee safety, but they guarantee liveness only after GST. In this setting, however, participants in the protocol are fixed, known in advance, and without possibility to go <em>offline</em>.</p>

    <p class="text-gray-300">Dynamic participation (among systems’ participants) has lately become an essential prerequisite for developing permissionless consensus protocols. This concept, initially formalized by Pass and Shi via their <em>sleepy model</em>, <em>[16]</em> encapsulates the ability of a system to handle participants joining or leaving during a protocol execution. In particular, a consensus protocol that preserves safety and liveness while allowing dynamic participation is called <em>dynamically available</em>.</p>

    <p class="text-gray-300">One problem of such protocols, as a result of the CAP theorem <em>[9]<strong>[11]</em>, is that they do not tolerate network partitions; no consensus protocols can both satisfy liveness (under dynamic participation) and safety (under temporary network partitions). Simply put, a consensus protocol (for state-machine replication) cannot produce a single chain that concurrently offers dynamic availability and guarantees transaction finality in case of asynchronous periods or network partitions. Because of that, dynamically available protocols studied so far are focused on a synchronous model <em>[6]</strong>[12]**[13]</em>.</p>

    <p class="text-gray-300">To overcome this impossibility result, Neu <em>at al.</em> <em>[15]</em> introduce a family of protocols, referred to as <em>ebb-and-flow</em> protocols, which operate under two confirmation rules, and outputting two chains, one a prefix of the other. The first confirmation rule defines what is known as the <em>available chain</em>, which provides liveness under dynamic participation (and synchrony). The second confirmation rule defines the <em>finalized chain</em>, and provides safety even under network partitions. Interestingly, such family of protocols also captures the nature of the Ethereum consensus protocol, Gasper <em>[4]</em>, in which the available chain is output by (the confirmation rule of) LMD-GHOST <em>[18]</em>, and the finalized chain by the (confirmation rule of the) <em>finality gadget</em> Casper FFG <em>[3]</em>. However, the (original version of) LMD-GHOST is actually not secure <em>[15]</em> even in a context of full-participation.</p>

    <p class="text-gray-300">Motivated by finding a (more secure) alternative to LMD-GHOST, and following the ebb-and-flow approach, D’Amato <em>et al.</em> <em>[6]</em> devise a synchronous dynamically available consensus protocol, Goldfish, that,</p>

    <p class="text-gray-300">combined with a generic (partially synchronous) finality gadget, implements an ebb-and-flow protocol. Moreover, Goldfish is reorg resilient: blocks proposed by honest validators are guaranteed inclusion in the chain. However, Goldfish is brittle to temporary asynchrony <em>[7]</em>, in the sense that even a single violation of the bound of network delay can lead to a catastrophic failure, jeopardizing the safety of <em>any</em> previously confirmed block, resulting in a protocol that is not practically viable to replace LMD-GHOST in Ethereum. In other words, Goldfish is not <em>asynchrony resilient</em>.</p>

    <p class="text-gray-300">To cope with the problem of Goldfish, D’Amato and Zanolini <em>[7]</em> propose RLMD-GHOST, a provably secure synchronous protocol that does not lose safety during <em>bounded</em> periods of asynchrony and which tolerates a weaker form of dynamic participation, offering a trade-off between dynamic availability and asynchrony resilience. Their protocol results appealing for practical systems, where strict synchrony assumptions might not always hold, contrary to what is generally assumed with standard synchronous protocols.</p>

    <p class="text-gray-300">In this work we build upon the work of D’Amato and Zanolini <em>[7]</em>, and we devise a protocol that combines RLMD-GHOST with a partially synchronous finality gadget. In particular, we give the following contributions. We devise a secure and reorg-resilient ebb-and-flow protocol <em>[15]</em> as a potential substitute for the current Ethereum consensus protocol, Gasper <em>[4]</em>, which can finalize (at most) one block per slot. In particular, our protocol can finalize the block proposed in the current slot, within such slot, paving the way to <em>single slot finality</em> <em>[2]</em> protocols for practical use within Ethereum. Finally, we expand upon the <em>generalized sleepy model</em> <em>[7]</em> introduced by D’Amato and Zanolini<em>[7]</em>, adjusting it to accommodate a partially synchronous setting. We refer to the resulting model as the <em>generalized partially synchronous sleepy model</em>. This enhanced model not only extends the original sleepy model, first presented by Pass and Shi <em>[16]</em>, but it also introduces stronger and more generalized constraints related to the corruption and sleepiness power of the adversary. Furthermore, our model integrates the concept of partial synchrony, setting it apart from the model proposed by D’Amato and Zanolini <em>[7]</em>. Our security results will be proven within this extended model. The remainder of this work is structured as it follows. In Section 3 we present our system model. Prerequisites for this work are presented in Section 4; we recall RLMD-GHOST as originally presented by D’Amato and Zanolini <em>[7]</em>, state its properties, and show a class of protocols, called <em>propose-vote-merge</em> protocols, that groups together (a variant of) LMD-GHOST, (a variant of) Goldfish, and RLMD-GHOST under an unique framework. Protocol specifications are described in Section 5. In particular, we show how to slightly modify RLMD-GHOST to interact with a finality gadget, and then present the full protocol. In Section 6 we formally prove the properties that our protocol satisfy. Finally, in Section 7 we enable our protocol to finalize the block proposed in the current slot through <em>acknowledgments</em>, messages sent by participants in the consensus protocol, but only relevant to external observers. Conclusions are drawn in Section 8.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Related works</h2>

    <p class="text-gray-300">Pass and Shi <em>[16]</em> introduced the <em>sleepy model of consensus</em>, which models a distributed system where the participants can be either online or offline, meaning their participation is dynamic. This differs from the standard models in the literature that assume honest participants are always online and execute the assigned protocol. Dynamic participation became a key requirement to devise consensus protocols, as it adds a more robustness to systems that allow participants to go offline, while preserving safety and liveness of such <em>dynamically available</em> protocols.</p>

    <p class="text-gray-300">Neu et al <em>[15]</em> introduce the <em>partially synchronous sleepy model</em> and define the objectives of the Ethereum consensus protocol, Gasper <em>[4]</em>, through the concept of an <em>ebb-and-flow protocol</em>. A secure ebb-and-flow protocol produces both a dynamically available ledger and a finalized ledger, that is always safe and live after <span class="math">\\max\\{\\mathsf{GST},\\mathsf{GAT}\\}</span>. In the context of Gasper, the dynamically available ledger is defined by LMD-GHOST <em>[18]</em> and the finalized ledger by Casper <em>[3]</em>.</p>

    <p class="text-gray-300">However, under a deeper analysis, Neu <em>et al</em> <em>[15]</em> show that LMD-GHOST is not dynamically available, by presenting an attack to its liveness. D’Amato <em>et al</em>. <em>[6]</em> introduce Goldfish, a simplified variant of LMD-GHOST, aiming at solving some problems related to LMD-GHOST <em>[15, 14]</em>, that results in a synchronous dynamically available protocol in the partially synchronous sleepy model that, composed with a generic finality gadget, implements an ebb-and-flow protocol. Goldfish however is brittle to temporary asynchrony, in the sense that even a single violation of the bound of network delay can lead to a catastrophic failure, jeopardizing the safety of <em>any</em> previously confirmed block.</p>

    <p class="text-gray-300">D’Amato and Zanolini <em>[7]</em> introduce the <em>generalized sleepy model</em>. This model takes up from the original</p>

    <p class="text-gray-300">sleepy model presented by Pass and Shi <em>[16]</em> and extends it with more generalized and stronger constraints in the corruption and sleepiness power of the adversary. This allow to explore a broad space of dynamic participation regimes which fall between complete dynamic participation and no dynamic participation. Moreover, they introduce RLMD-GHOST, a generalization of (variants of) Goldfish and LMD-GHOST, that offers a trade-off between resilience to temporary asynchrony and dynamic availability. RLMD-GHOST represents a middle ground between LMD-GHOST, an asynchrony resilient but not dynamically available protocol, and Goldfish, a dynamically available but not asynchrony resilient protocol. RLMD-GHOST is resilient to bounded asynchrony <em>up to a vote expiry period</em>, and satisfies an appropriate notion of dynamic availability in the generalized sleepy model.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3 Model and Preliminary Notions</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 System model</h3>

    <p class="text-gray-300">We consider a set of <span class="math">n</span> <em>validators</em> <span class="math">v_{1},\\ldots,v_{n}</span> that communicate with each other through exchanging messages. Every validator is identified by a unique cryptographic identity and the public keys are common knowledge. Validators are assigned a protocol to follow, consisting of a collection of programs with instructions for all validators. A validator that follows its protocol during an execution is called <em>honest</em>. Each validator has a <em>stake</em>, which we assume to be the same for every validator. If a validator <span class="math">v_{i}</span> fails to serve the role assigned to it or tries to deliberately deviate from the protocol, i.e., <span class="math">v_{i}</span> is <em>Byzantine</em>, and a proof of this misbehavior is given, it loses a part of its stake proportional to the severity of the fault (<span class="math">v_{i}</span> gets <em>slashed</em>). We assume the existence of a probabilistic poly-time adversary <span class="math">\\mathcal{A}</span> that can choose up to <span class="math">f</span> validators to corrupt over an entire protocol execution. Corrupted validators stay corrupted for the remaining duration of the protocol execution, and are thereafter called <em>adversarial</em>. The adversary <span class="math">\\mathcal{A}</span> knows the the internal state of adversarial validators. The adversary is <em>adaptive</em>: it chooses the corruption schedule dynamically, during the protocol execution.</p>

    <p class="text-gray-300">We assume that a best-effort gossip primitive that will reach all validators is available. In a protocol, this primitive is accessed through the events “sending a message through gossip” and “receiving a gossiped message.” Moreover, we assume that messages from honest validator to honest validator are eventually received and cannot be forged. This includes messages sent by Byzantine validators, once they have been received by some honest validator <span class="math">v_{i}</span> and gossiped around by <span class="math">v_{i}</span>.</p>

    <p class="text-gray-300">Time is divided into discrete <em>rounds</em>. We consider a partially synchronous model in which validators have synchronized clocks but there is no a priori bound on message delays. However, there is a time (not known by the validators), called <em>global stabilization time</em> (GST), after which message delays are bounded by <span class="math">\\Delta</span> rounds. Moreover, we define the notion of <em>slot</em> as a collection of <span class="math">4\\Delta</span> rounds. The adversary <span class="math">\\mathcal{A}</span> can decide for each round which honest validator is <em>awake</em> or <em>asleep</em> at that round <em>[16]</em>. Asleep validators do not execute the protocol and messages for that round are queued and delivered in the first round in which the validator is awake again. Honest validators that become awake at round <span class="math">r</span>, before starting to participate in the protocol, must first execute (and terminate) a <em>joining protocol</em> (Section 4), after which they become <em>active</em>. All adversarial validators are always awake, and are not prescribed to follow any protocol. Therefore, we always use active, awake, and asleep to refer to honest validators. As for corruptions, the adversary is adaptive also for sleepiness, <em>i.e.</em>, the sleepiness schedule is also chosen dynamically by the adversary. Moreover, there is a time (not known by the validators), called <em>global awake time</em> (GAT), after which all validators are always awake.</p>

    <p class="text-gray-300">We assume that every message has an <em>expiration period</em> <span class="math">\\eta</span> <em>[6]**[7]</em>. More specifically, for a given slot <span class="math">t</span> and a constant <span class="math">\\eta\\in\\mathbb{N}</span> greater than or equal to <span class="math">0</span>, the <em>expiration period</em> for slot <span class="math">t</span> is the interval <span class="math">[t-\\eta,t-1]</span>. Only messages sent within this time frame influence the behavior of the protocol at slot <span class="math">t</span>. Furthermore, during each protocol execution slot, only the most recent messages sent by validators are considered.</p>

    <p class="text-gray-300">We require that, for some fixed parameter <span class="math">1\\leq\\tau\\leq\\infty</span>, the following condition, referred by D’Amato and Zanolini <em>[7]</em> as <em><span class="math">\\tau</span>-sleepiness at slot <span class="math">t</span></em>, holds for any slot <span class="math">t</span> <em>after</em> GST:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{t-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{t}\\cup(H_{t-\\tau,t-2}\\setminus H_{t-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with <span class="math">H_{t}</span>, <span class="math">A_{t}</span>, and <span class="math">H_{s,t}</span> are the set of active validators at round <span class="math">4\\Delta t+\\Delta</span>, the set of adversarial validators at round <span class="math">4\\Delta t+\\Delta</span>, and the set of validators that are active <em>at some point</em> in slots <span class="math">[s,t]</span>, <em>i.e.</em>, <span class="math">H_{s,t}=\\bigcup_{i=s}^{t}H_{i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(if <span class="math">i &amp;lt; 0</span> then <span class="math">H_{i} \\coloneqq \\emptyset</span>), respectively. Note that $f = \\lim_{t \\to \\infty}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In other words, we require the number of active validators at round </span>4\\Delta(t - 1) + \\Delta<span class="math"> to be greater than the number of adversarial validators at round </span>4\\Delta t + \\Delta<span class="math">, together with the number of validators that were active at some point between rounds </span>4\\Delta(t - \\tau) + \\Delta<span class="math"> and </span>4\\Delta(t - 2) + \\Delta<span class="math">, but not at round </span>4\\Delta(t - 1) + \\Delta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Intuitively, this condition is designed to work with a protocol that applies expiration to its messages, with the period set as <span class="math">\\eta = \\tau</span>. The messages taken into consideration at slot <span class="math">t</span> originate from slots <span class="math">[t - \\tau, t - 1]</span>. Among these, the only messages sent by honest validators that can be relied upon come from <span class="math">H_{t-1}</span>. However, unexpired messages from honest validators, who were inactive in slot <span class="math">t-1</span>, could potentially aid the adversary.</p>

    <p class="text-gray-300">Note that our approach diverges from the generalized sleepy model proposed by D'Amato and Zanolini [7]. Specifically, we require that Equation 1 only holds after GST and we refer to this model as the generalized partially synchronous <span class="math">\\tau</span>-sleepy model (or wlog, when the context is clear, as the <span class="math">\\tau</span>-sleepy model for short). Finally, we say that an execution in the generalized partially synchronous sleepy model is <span class="math">\\tau</span>-compliant if it satisfies <span class="math">\\tau</span>-sleepiness (Equation 1).</p>

    <h2 id="sec-7" class="text-2xl font-bold">3.2 Validator internals</h2>

    <p class="text-gray-300"><strong>View.</strong> A view (at a given round <span class="math">r</span>), denoted by <span class="math">\\mathcal{V}</span>, is a subset of all the messages that a validator has received until <span class="math">r</span>. The notion of view is local for the validators. For this reason, when we want to focus the attention on a specific view of a validator <span class="math">v_{i}</span>, we denote with <span class="math">\\mathcal{V}_{i}</span> the view of <span class="math">v_{i}</span> (at a round <span class="math">r</span>).</p>

    <p class="text-gray-300"><strong>Blocks and chains.</strong> Let's consider two chains, <span class="math">\\mathsf{ch}_1</span> and <span class="math">\\mathsf{ch}_2</span>. We denote <span class="math">\\mathsf{ch}_1 \\prec \\mathsf{ch}_2</span> if <span class="math">\\mathsf{ch}_1</span> acts as a prefix to <span class="math">\\mathsf{ch}_2</span>. When block <span class="math">B</span> is at the end of chain <span class="math">\\mathsf{ch}</span>, we refer to it as the head of <span class="math">\\mathsf{ch}</span>, and we equate the entire chain with <span class="math">B</span>. Therefore, if <span class="math">\\mathsf{ch}&#x27; \\prec \\mathsf{ch}</span> and <span class="math">A</span> is the head of <span class="math">\\mathsf{ch}&#x27;</span>, we also express this as <span class="math">\\mathsf{ch}&#x27; \\prec B</span> and <span class="math">A \\prec B</span>.</p>

    <p class="text-gray-300"><strong>Fork-choice functions.</strong> A fork-choice function is a deterministic function, denoted as <span class="math">\\mathsf{FC}</span>. This function, when given a view <span class="math">\\mathcal{V}</span> and a slot <span class="math">t</span> as inputs, produces a block <span class="math">B</span>. If <span class="math">B</span> is a block extending <span class="math">\\mathsf{FC}(\\mathcal{V}, t)</span>, then <span class="math">\\mathsf{FC}(\\mathcal{V} \\cup B, t)</span> equals <span class="math">B</span>. The result of <span class="math">\\mathsf{FC}</span> is referred to as the head of the canonical chain in <span class="math">\\mathcal{V}</span>, and the chain with <span class="math">B</span> as its head is referred to as the canonical chain in <span class="math">\\mathcal{V}</span>. Every validator keeps track of its canonical chain and updates it using <span class="math">\\mathsf{FC}</span>, according to its local view. The canonical chain for validator <span class="math">v_i</span> at round <span class="math">r</span> is represented as <span class="math">\\mathsf{ch}_i^r</span>. In this work we will focus our attention on a specific class of fork-choice functions based on GHOST [17]. D'Amato and Zanolini [7] characterize a GHOST-based fork-choice function by a view filter <span class="math">\\mathsf{FIL}</span>, which takes as input a view <span class="math">\\mathcal{V}</span> and a slot <span class="math">t</span>, and outputs <span class="math">(\\mathcal{V}&#x27;, t)</span>, where <span class="math">\\mathcal{V}&#x27;</span> is another view such that <span class="math">\\mathcal{V}&#x27; \\subseteq \\mathcal{V}</span>. Then, <span class="math">\\mathsf{FC}(\\mathcal{V}, t) := \\mathrm{GHOST}(\\mathsf{FIL}(\\mathcal{V}, t))</span>, i.e., <span class="math">\\mathsf{FC} := \\mathrm{GHOST} \\circ \\mathsf{FIL}</span>.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3.3 Security</h2>

    <p class="text-gray-300"><strong>Security Parameters.</strong> In this work we treat <span class="math">\\lambda</span> and <span class="math">\\kappa</span> as the security parameters related to the cryptographic components utilized by the protocol and the protocol's own security parameter, respectively. We also account for a finite time horizon, represented as <span class="math">T_{\\mathrm{hor}}</span>, which is polynomial in relation to <span class="math">\\kappa</span>. An event is said to occur with overwhelming probability if it happens except with probability which is <span class="math">\\mathrm{negl}(\\kappa) + \\mathrm{negl}(\\lambda)</span>. The properties of cryptographic primitives hold true with a probability of <span class="math">\\mathrm{negl}(\\lambda)</span>, signifying an overwhelming probability, although we will not explicitly mention this in the subsequent sections of this work.</p>

    <p class="text-gray-300"><strong>Confirmed chain.</strong> The protocols we consider always specify a confirmation rule, with whom validators can identify a confirmed prefix of the canonical chain. Alongside the canonical chain, validators then also keep track of a confirmed chain. We refer to the confirmed chain of validator <span class="math">v_{i}</span> at round <span class="math">r</span> as <span class="math">\\mathsf{Ch}_i^r</span> (cf. <span class="math">\\mathsf{ch}_i^r</span> for the canonical chain).</p>

    <p class="text-gray-300"><strong>Definition 1 (Secure protocol [6]).</strong> We say that a protocol outputting a confirmed chain <span class="math">\\mathsf{Ch}</span> is secure after time <span class="math">T_{\\mathrm{sec}}</span>, and has confirmation time <span class="math">T_{\\mathrm{conf}}^1</span>, if <span class="math">\\mathsf{Ch}</span> satisfies:</p>

    <p class="text-gray-300">4</p>

    <p class="text-gray-300">For any two rounds <span class="math">r, r&#x27; \\geq T_{\\mathrm{sec}}</span>, and any two honest validators <span class="math">v_i</span> and <span class="math">v_j</span> (possibly <span class="math">i = j</span>) at rounds <span class="math">r</span> and <span class="math">r&#x27;</span> respectively, either <span class="math">\\mathsf{Ch}_i^r \\prec \\mathsf{Ch}_j^{r&#x27;}</span> or <span class="math">\\mathsf{Ch}_j^{r&#x27;} \\prec \\mathsf{Ch}_i^r</span>.</p>

    <p class="text-gray-300">For any rounds <span class="math">r \\geq T_{\\mathrm{sec}}</span> and <span class="math">r&#x27; \\geq r + T_{\\mathrm{conf}}</span>, and any honest validator <span class="math">v_i</span> active at round <span class="math">r&#x27;</span>, <span class="math">\\mathsf{Ch}_i^{r&#x27;}</span> contains a block proposed by an honest validator at a round <span class="math">&amp;gt; r</span>.</p>

    <p class="text-gray-300">A protocol satisfies <span class="math">\\tau</span>-safety and <span class="math">\\tau</span>-liveness if it satisfies safety and liveness, respectively, in the <span class="math">\\tau</span>-sleepy model, i.e., in <span class="math">\\tau</span>-compliant executions. A protocol satisfies <span class="math">\\tau</span>-security if it satisfies <span class="math">\\tau</span>-safety and <span class="math">\\tau</span>-liveness.</p>

    <p class="text-gray-300">We now recall the definitions of dynamic availability and reorg resilience from [7]. We consider them only under network synchrony, i.e., for GST = 0, as this is the only setting in which we utilize them. Note that it is customary to only analyze dynamic availability with GST = 0, when analyzing the behavior of ebb-and-flow protocols.</p>

    <p class="text-gray-300"><strong>Definition 2 (Dynamic availability).</strong> We say that a protocol is <span class="math">\\tau</span>-dynamically-available if and only if it satisfies <span class="math">\\tau</span>-security with confirmation time <span class="math">T_{\\mathrm{conf}} = O(\\kappa)</span> when GST = 0. Moreover, we say that a protocol is dynamically available if it is 1-dynamically-available, as this corresponds to the usual notion of dynamic availability.</p>

    <p class="text-gray-300"><strong>Definition 3 (Reorg resilience).</strong> An execution with GST = 0 satisfies reorg resilience if any honest proposal <span class="math">B</span> from a slot <span class="math">t</span> is always in the canonical chain of all active validators at rounds <span class="math">\\geq 4\\Delta t + \\Delta</span>. A protocol is <span class="math">\\tau</span>-reorg-resilient if all <span class="math">\\tau</span>-compliant executions with GST = 0 satisfy reorg resilience.</p>

    <p class="text-gray-300"><strong>Definition 4 (Accountable safety).</strong> We say that a protocol has accountable safety with resilience <span class="math">f &amp;gt; 0</span> if, upon a safety violation, it is possible to identify at least <span class="math">f</span> responsible participants. In particular, it is possible to collect evidence from sufficiently many honest participants and generate a cryptographic proof that identifies <span class="math">f</span> adversarial participants as protocol violators. Such proof cannot falsely accuse any honest participant that followed the protocol correctly. Finally, we also say that a chain is <span class="math">f</span>-accountable if the protocol outputting it has accountable safety with resilience <span class="math">f</span>. If a protocol <span class="math">\\Pi</span> outputs multiple chains <span class="math">\\mathsf{Ch}_1, \\ldots, \\mathsf{Ch}_k</span>, we say that <span class="math">\\mathsf{Ch}_i</span> is <span class="math">f</span>-accountable if <span class="math">\\Pi_i</span> is, where <span class="math">\\Pi_i</span> is the protocol which runs <span class="math">\\Pi</span> and outputs only <span class="math">\\mathsf{Ch}_i</span>.</p>

    <p class="text-gray-300"><strong>Ebb-and-flow protocols.</strong> Neu et al. [15] propose a protocol with two confirmation rules that outputs two chains, one that provides liveness under dynamic participation (and synchrony), and one that provides accountable safety even under network partitions. This protocol is called <em>ebb-and-flow</em> protocol. We present a generalization of it, in the <span class="math">\\tau</span>-sleepy model.</p>

    <p class="text-gray-300"><strong>Definition 5 (<span class="math">\\tau</span>-secure ebb-and-flow protocol).</strong> A <span class="math">\\tau</span>-secure ebb-and-flow protocol outputs an available chain chAva that is <span class="math">\\tau</span>-dynamically-available if GST = 0, and a finalized (and accountable) chain chFin that, if <span class="math">f &amp;lt; \\frac{n}{3}</span>, is always safe and is live after <span class="math">\\max\\{\\mathsf{GST}, \\mathsf{GAT}\\}</span>. Moreover, for each honest validator <span class="math">v_i</span> and for every round <span class="math">r</span>, chFin<span class="math">_i^r</span> is a prefix of chAva<span class="math">_i^r</span>.</p>

    <p class="text-gray-300">The aim of this work is to present a secure ebb-and-flow [15] protocol that can finalize (at most) one block per slot and, in particular, that can finalize within slot <span class="math">t</span> the block proposed in <span class="math">t</span>. This is achieved by revisiting the propose-vote-merge protocol RLMD-GHOST introduced by D'Amato and Zanolini [7] as the basis for our protocol implementation. Propose-vote-merge protocols proceed in slots consisting of <span class="math">k</span> rounds², each having a proposer <span class="math">v_p</span>, chosen through a proposer selection mechanism among the set of validators. In particular, at the beginning of each slot <span class="math">t</span>, the proposer <span class="math">v_p</span> proposes a block <span class="math">B</span>. Then, all active validators (also referred as voters) vote after <span class="math">\\Delta</span> rounds. Every validator <span class="math">v_i</span> has a buffer <span class="math">\\mathcal{B}_i</span>, a collection of messages received from other</p>

    <p class="text-gray-300">²D'Amato and Zanolini [7] implement RLMD-GHOST with fast confirmation with <span class="math">k = 3\\Delta</span> (Appendix B [7]). However, we will consider <span class="math">k = 4\\Delta</span>, following the approach taken by D'Amato et al. [6] when presenting Goldfish with fast confirmation. We will show how RLMD-GHOST with fast confirmation can be changed into its variant with <span class="math">k = 4\\Delta</span> in Section 5 while presenting our protocol.</p>

    <p class="text-gray-300">validators, and a view <span class="math">\\mathcal{V}_i</span>, used to make consensus decisions, which admits messages from the buffer only at specific points in time.</p>

    <p class="text-gray-300">Propose-vote-merge protocols are defined through a deterministic fork-choice function FC, which is used by honest proposers and voters to decide how to propose and vote, respectively, based on their view at the round in which they are performing those actions. It is moreover used as the basis of a confirmation rule (Section 5.2), which defines the output of the protocol, and thus with respect to which the security of the protocol is defined. In the case of RLMD-GHOST, its fork-choice function RLMD-GHOST considers the last (non equivocating) messages sent by validators that are not older than <span class="math">t - \\eta</span> slots (for an expiration period <span class="math">\\eta</span>), in order to make protocol's decisions. In particular, the filter function <span class="math">\\mathsf{FIL}_{\\mathrm{rlmd}}(\\mathcal{V},t)</span> removes all but the latest messages within the expiry period <span class="math">[t - \\eta ,t)</span> for slot <span class="math">t</span>, from non-equivocating validators, i.e., <span class="math">\\mathsf{FIL}_{\\mathrm{rlmd}} = \\mathsf{FIL}_{\\mathrm{lmd}}\\circ \\mathsf{FIL}_{\\eta \\text{-exp}}\\circ \\mathsf{FIL}_{eq}</span>. Here, <span class="math">\\mathsf{FIL}_{\\mathrm{lmd}}(\\mathcal{V},t)</span> removes all but the latest votes of every validator (possibly more than one) from <span class="math">\\mathcal{V}</span> and outputs the resulting view, i.e., it implements the latest message (LMD) rule, <span class="math">\\mathsf{FIL}_{\\eta \\text{-exp}}(\\mathcal{V},t)</span> removes all votes from slots <span class="math">&amp;lt; t - \\eta</span> from <span class="math">\\mathcal{V}</span> and outputs the resulting view, and <span class="math">\\mathsf{FIL}_{eq}(\\mathcal{V},t)</span> removes all votes by equivocating validators in <span class="math">\\mathcal{V}</span> [1], i.e., validators for which <span class="math">\\mathcal{V}</span> contains multiple, equivocating, votes for some slot <span class="math">t</span>.</p>

    <p class="text-gray-300">A propose-vote-merge protocol proceeds in three phases:</p>

    <p class="text-gray-300">PROPOSE: In this phase, which starts at the beginning of a slot, the proposer <span class="math">v_{p}</span> merges its view <span class="math">\\mathcal{V}_{p}</span> with its buffer <span class="math">\\mathcal{B}_{p}</span>, i.e., <span class="math">\\mathcal{V}_{p} \\gets \\mathcal{V}_{p} \\cup \\mathcal{B}_{p}</span>, and sets <span class="math">\\mathcal{B}_{p} \\gets \\emptyset</span>. Then, <span class="math">v_{p}</span> runs the fork-choice function FC with inputs its view <span class="math">\\mathcal{V}_{p}</span> and slot <span class="math">t</span>, obtaining the head of the chain <span class="math">B&#x27; = \\mathsf{FC}(\\mathcal{V}_{p}, t)</span>. Proposer <span class="math">v_{p}</span> extends <span class="math">B&#x27;</span> with a new block <span class="math">B</span>, and updates its canonical chain accordingly, setting <span class="math">\\mathsf{ch}_p \\gets B</span>. Finally, it broadcasts the message [PROPOSE, <span class="math">B, \\mathcal{V}_p \\cup \\{B\\}, t, v_p</span>].</p>

    <p class="text-gray-300">VOTE: Here, every validator <span class="math">v_{i}</span> that receives a proposal message [PROPOSE, <span class="math">B, \\mathcal{V}, t, v_{p}</span>] from <span class="math">v_{p}</span> merges its view with the proposed view <span class="math">\\mathcal{V}</span>, by setting <span class="math">\\mathcal{V}_{i} \\gets \\mathcal{V}_{i} \\cup \\mathcal{V}</span>. Then, it broadcasts votes for some blocks based on its view. We omit, for the moment, for which blocks a validator <span class="math">v_{i}</span> votes: it will become clear once we present the full protocol.</p>

    <p class="text-gray-300">MERGE: In this phase, every validator <span class="math">v_{i}</span> merges its view with its buffer, i.e., <span class="math">\\mathcal{V}_{i} \\gets \\mathcal{V}_{i} \\cup \\mathcal{B}_{i}</span>, and sets <span class="math">\\mathcal{B}_{i} \\gets \\emptyset</span>.</p>

    <p class="text-gray-300">The MERGE phase, along with all other operations involving views and buffers discussed in the previous section, are implemented using the view-merge technique [6][7][10]. The idea behind the view-merge technique involves synchronizing the views of all honest validators with the view <span class="math">\\mathcal{V}_p</span> of the proposer for a specific slot before the validators broadcast their votes in that slot.</p>

    <p class="text-gray-300">D'Amato et al. [6] introduce the notion of active validators: awake validators that have terminated a joining protocol at a round <span class="math">r</span>, described as it follows. Assuming a propose-vote-merge protocol proceeding in slots of <span class="math">k = 4\\Delta</span> rounds, when an honest validator <span class="math">v_{i}</span> wakes up at some round <span class="math">r \\in (4\\Delta(t - 1) + 3\\Delta, 4\\Delta t + 3\\Delta]</span>, it immediately receives all the messages that were sent while it was asleep, and it adds them into its buffer <span class="math">\\mathcal{B}_i</span>, without actively participating in the protocol yet. All new messages which are received are also added to the buffer <span class="math">\\mathcal{B}_i</span>. Validator <span class="math">v_{i}</span> then waits for the next view-merge opportunity, at round <span class="math">4\\Delta t + 3\\Delta</span>, in order to merge its buffer <span class="math">B_i</span> into its view <span class="math">\\mathcal{V}_i</span>. At this point, <span class="math">v_{i}</span> starts executing the protocol. From this point on, validator <span class="math">v_{i}</span> becomes active, until either corrupted or put to sleep by the adversary. We consider such a joining protocol when describing our propose-vote-merge protocol.</p>

    <h2 id="sec-11" class="text-2xl font-bold">5.1 Data structures</h2>

    <p class="text-gray-300">We consider five message types: PROPOSE, BLOCK, CHECKPOINT, HEAD-VOTE, and FFP-VOTE. We make no distinctions between network-level representation of blocks and votes, and their representation in a validator's view, i.e., there is no difference between BLOCK and *-VOTE messages and blocks and votes, and we usually just refer to the latter. We describe the objects as tuples (DATA-TYPE, ...) with their data type as a tag, but in practice mostly refer to them without the tag. We use dot notation to refer to the fields. For the tag, we do so simply with .tag, for the other fields we use the generic names specified in the object descriptions</p>

    <p class="text-gray-300">6</p>

    <p class="text-gray-300">below, to access the different fields, e.g., <span class="math">B.t</span> is the slot of block <span class="math">B</span>. In the following, <span class="math">t</span> is a slot and <span class="math">v_i</span> a validator.</p>

    <p class="text-gray-300"><strong>Blocks and checkpoints.</strong> A block is a tuple <span class="math">B = (\\mathrm{block}, b, t, v_i)</span>, where <span class="math">b</span> is a block body, i.e., the protocol-specific content of the block<span class="math">^4</span>. A checkpoint is a tuple <span class="math">\\mathcal{C} = (\\mathrm{checkpoint}, B, t)</span>, where <span class="math">B</span> is a block and <span class="math">\\mathcal{C}.t \\geq B.t</span>.</p>

    <p class="text-gray-300"><strong>Votes.</strong> A head vote is a tuple [HEAD-VOTE, <span class="math">B, t, v_i</span>], where <span class="math">B</span> is a block. An FFG vote is a tuple [FFG-VOTE, <span class="math">\\mathcal{C}_1, \\mathcal{C}_2, v_i</span>], where <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span> are checkpoints, <span class="math">\\mathcal{C}_1.t &amp;lt; \\mathcal{C}_2.t</span>, and <span class="math">\\mathcal{C}_1.B \\prec \\mathcal{C}_2.B</span>. We refer to the two checkpoints as source and target, respectively, and to FFG votes as links between source and target. When <span class="math">v_i</span> is clear from context, we also write <span class="math">\\mathcal{C}_1 \\to \\mathcal{C}_2</span> for the whole vote, e.g., we say that <span class="math">v_i</span> casts a <span class="math">\\mathcal{C}_1 \\to \\mathcal{C}_2</span> vote.</p>

    <p class="text-gray-300"><strong>Proposals.</strong> A proposal is a tuple [PROPOSE, <span class="math">B</span>, <span class="math">\\mathcal{V}</span>, <span class="math">t</span>, <span class="math">v_i</span>] where <span class="math">B</span> is a block and <span class="math">\\mathcal{V}</span> a view. We refer to <span class="math">\\mathcal{V}</span> as a proposed view.</p>

    <p class="text-gray-300"><strong>Gossip behavior.</strong> Votes and blocks are gossiped at any time, regardless of whether they are received directly or as part of another message. For example, a validator receiving a vote also gossips the block that it contains, and a validator receiving a proposal also gossips the blocks and votes contained in the proposed view. Finally, a proposal from slot <span class="math">t</span> is gossiped only during the first <span class="math">\\Delta</span> rounds of slot <span class="math">t</span>.</p>

    <h2 id="sec-12" class="text-2xl font-bold">5.2 Confirmation rule</h2>

    <p class="text-gray-300">A confirmation rule allows validators to identify a <em>confirmed prefix</em> of the canonical chain, for which safety properties hold, and which is therefore used to define the output of the protocol. Since the protocol we are going to present outputs two chains, the available chain chAva and the finalized chain chFin, we have two confirmation rules. One is <em>finality</em>, which we introduce in Section 5.3, and defines chFin. The other confirmation rule, defining chAva, is the one adopted by RLMD-GHOST, in its variant supporting fast confirmation<span class="math">^5</span>. It is itself essentially split in two rules, a <em>slow</em> <span class="math">\\kappa</span>-deep confirmation rule, which is live also under dynamic participation, and a <em>fast optimistic rule</em>, requiring <span class="math">\\frac{2}{3}n</span> honest validators to be awake, i.e., a stronger assumption than just <span class="math">\\tau</span>-compliance. Both rules are employed at round <span class="math">4\\Delta t + 2\\Delta</span>, and chAva is updated to the highest block confirmed by either one, so that liveness of chAva only necessitates liveness of one of the two rules. In particular, <span class="math">\\tau</span>-compliance is sufficient for liveness. On the other end, safety of chAva requires both rules to be safe.</p>

    <h2 id="sec-13" class="text-2xl font-bold">5.3 FFG component</h2>

    <p class="text-gray-300">As mentioned above, a propose-vote-merge protocol is characterized by a fork-choice function that identifies for every slot the current head of the canonical chain for a given validator. Moreover, we described two kind of votes that a validator <span class="math">v_i</span> executes in the VOTE phase: a HEAD-VOTE, used to vote for the head of the canonical chain, i.e., the output of the fork-choice function evaluated at the current slot, and an FFG-VOTE, used by the FFG-component of our protocol<span class="math">^6</span>.</p>

    <p class="text-gray-300">The FFG component of our protocol aims at finalizing one block per slot by counting FFG-votes cast at a given slot.</p>

    <p class="text-gray-300"><strong>Justification.</strong> We say that a set of <span class="math">\\frac{2}{3}n</span> distinct FFG votes <span class="math">\\mathcal{C}_1 \\to \\mathcal{C}_2</span> is a <em>supermajority link</em> between <span class="math">\\mathcal{C}_1</span> and <span class="math">\\mathcal{C}_2</span>. We say that a checkpoint <span class="math">C</span> is <em>justified</em> if there is a chain of <span class="math">k \\geq 0</span> supermajority links (<span class="math">B_{\\mathrm{genesis}}</span>, <span class="math">0) \\to \\mathcal{C}_1 \\cdots \\to \\mathcal{C}_{k-1} \\to C</span>. In particular, (<span class="math">B_{\\mathrm{genesis}}, 0</span>) is justified. Finally, we say that a block <span class="math">B</span> is <em>justified</em> if there exists a justified checkpoint <span class="math">\\mathcal{C}</span> with <span class="math">\\mathcal{C}.B = B</span>.</p>

    <p class="text-gray-300"><span class="math">^4</span>For simplicity, we omit a reference to the parent block.</p>

    <p class="text-gray-300"><span class="math">^5</span>With some minor changes, as RLMD-GHOST still has <span class="math">3\\Delta</span> rounds per slots, by requiring an optimistic assumption on network latency in order for fast confirmations to be live.</p>

    <p class="text-gray-300"><span class="math">^6</span>The component of our protocol that outputs chFin is almost identical to Casper [3], the <em>friendly</em> finality gadget (FFG) adopted by the Ethereum consensus protocol Gasper [4]. This is the reason why we decided to use the FFG terminology already accepted within the Ethereum ecosystem.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Slashing.</h5>

    <p class="text-gray-300">The slashing rules are the same as in Casper FFG. Validator <span class="math">v_{i}</span> is slashable (see Section 3) for two <em>distinct</em> FFG votes <span class="math">(\\mathcal{C}_{1},\\mathcal{C}_{2},v_{i})</span> and <span class="math">(\\mathcal{C}_{3},\\,\\mathcal{C}_{4},v_{i})</span> if either: <span class="math">\\mathbf{E_{1}}</span> (Equivocation) <span class="math">\\mathcal{C}_{2}.t=\\mathcal{C}_{4}.t</span> or <span class="math">\\mathbf{E_{2}}</span> (Surround voting) <span class="math">\\mathcal{C}_{3}.t&lt;\\mathcal{C}_{1}.t&lt;\\mathcal{C}_{2}.t&lt;\\mathcal{C}_{4}.t</span>.</p>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Latest justified checkpoint and block.</h5>

    <p class="text-gray-300">A checkpoint is justified in a view <span class="math">\\mathcal{V}</span> if <span class="math">\\mathcal{V}</span> contains the chain of supermajority links justifying it. We refer to the justified checkpoint <span class="math">\\mathcal{C}</span> of highest slot <span class="math">\\mathcal{C}.t</span> in <span class="math">\\mathcal{V}</span> as the <em>latest justified checkpoint</em> in <span class="math">\\mathcal{V}</span>, or <span class="math">\\mathcal{LJ}(\\mathcal{V})</span>, and to <span class="math">\\mathcal{LJ}(\\mathcal{V}).B</span> as the <em>latest justified block</em> in <span class="math">\\mathcal{V}</span>, or <span class="math">LJ(\\mathcal{V})</span>. Ties are broken arbitrarily (the occurrence of a tie implies that <span class="math">\\frac{n}{3}</span> validators are slashable for equivocation). For brevity, we also use <span class="math">\\mathcal{LJ}_{i}</span> to refer to <span class="math">\\mathcal{LJ}(\\mathcal{V}_{i})</span>, the latest justified checkpoint in the view <span class="math">\\mathcal{V}_{i}</span> of validator <span class="math">v_{i}</span>.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Finality.</h5>

    <p class="text-gray-300">A checkpoint <span class="math">\\mathcal{C}</span> is <em>finalized</em> if it is justified and there exists a supermajority link <span class="math">\\mathcal{C}\\to\\mathcal{C}^{\\prime}</span> with <span class="math">\\mathcal{C}^{\\prime}.t=\\mathcal{C}.t+1</span>. A block <span class="math">B</span> is finalized if there exists a finalized checkpoint <span class="math">\\mathcal{C}</span> with <span class="math">B=\\mathcal{C}.B</span>.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.4 Voting</h3>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Fork-choice.</h5>

    <p class="text-gray-300">Similarly to Gasper <em>[4]</em>, we adopt an hybrid <em>justification-respecting</em> fork-choice, namely HFC, building upon RLMD-GHOST <em>[7]</em> fork-choice function. <span class="math">\\mathrm{HFC}(\\mathcal{V},t)</span> starts from <span class="math">LJ(\\mathcal{V})</span>, the <em>latest justified block</em> in <span class="math">\\mathcal{V}</span>, instead of <span class="math">B_{\\mathrm{genesis}}</span>, and then proceeds as RLMD-GHOST, <em>i.e.</em>, it runs GHOST using the view filtered by <span class="math">\\mathsf{FIL}_{\\mathrm{rlmd}}</span>. Formally, we can define it by using another view filter, <span class="math">\\mathsf{FIL}_{\\mathrm{FFG}}</span>, <em>i.e.</em>, <span class="math">\\mathrm{HFC}=\\mathrm{RLMD-GHOST}\\circ\\mathsf{FIL}_{\\mathrm{FFG}}</span>. <span class="math">\\mathsf{FIL}_{\\mathrm{FFG}}(\\mathcal{V},t)</span> outputs <span class="math">(\\mathcal{V}^{\\prime},t)</span>, where <span class="math">\\mathcal{V}^{\\prime}</span> filters out blocks in <span class="math">\\mathcal{V}</span> that conflict with <span class="math">LJ(\\mathcal{V})</span>. In other words, it filters out <em>branches which do not contain <span class="math">LJ(\\mathcal{V})</span></em>, so <span class="math">LJ(\\mathcal{V})</span> is guaranteed to be canonical.</p>

    <p class="text-gray-300">Algorithm 1 HFC, the justification-respecting fork-choice function 1: function HFC(<span class="math">\\mathcal{V},t</span>) 2: return RLMD-GHOST(<span class="math">\\mathsf{FIL}_{\\mathrm{FFG}}(\\mathcal{V},t)</span>) 3: function <span class="math">\\mathsf{FIL}_{\\mathrm{FFG}}(\\mathcal{V},t)</span> 4: <span class="math">\\mathcal{V}^{\\prime}\\leftarrow\\mathcal{V}\\setminus\\{B\\in\\mathcal{V},B.\\mathrm{tag}=\\textsc{block}:LJ(\\mathcal{V})\\not\\prec B\\wedge B\\not\\prec LJ(\\mathcal{V})\\}</span> 5: return <span class="math">(\\mathcal{V}^{\\prime},t)</span></p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Voting rules.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a validator <span class="math">v_{i}</span> voting at slot <span class="math">t</span>. Head votes work exactly as in RLMD-GHOST, or any propose-vote-merge protocol, <em>i.e.</em>, validators vote for the output of their fork-choice: when it is time to vote, validator <span class="math">v_{i}</span> casts vote [head-vote, HFC<span class="math">(\\mathcal{V}_{i},t),t,v_{i}</span>]. FFG votes always use the <em>latest justified checkpoint as source</em>. The target block is the <em>highest confirmed descendant of the latest justified block, or the latest justified block itself if there is none</em>. The target checkpoint is then $\\mathcal{C}_{\\mathrm{target}}=(\\arg\\max_{B\\in\\{LJ_{i},\\mathsf{chAva}\\}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t)<span class="math">, with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> being the height of block </span>B<span class="math">, and the FFG vote of </span>v_{i}<span class="math"> is [ffg-vote, </span>\\mathcal{LJ}_{i},\\mathcal{C}_{\\mathrm{target}},v_{i}<span class="math">], voting for the link </span>\\mathcal{LJ}_{i}\\to\\mathcal{C}_{\\mathrm{target}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.5 Protocol execution</h3>

    <p class="text-gray-300">Our protocol is implemented in Algorithm 2 and it works as it follows. Note that the Propose and Head-vote phases are <em>exactly</em> as in a generic propose-vote-merge protocol (see Section 4). Moreover, a slot <span class="math">t</span> in our protocol begins at round <span class="math">4\\Delta t</span>. At any time, the finalized chain <span class="math">\\mathsf{chFin}_{i}</span> of validator <span class="math">v_{i}</span> just consists of the finalized blocks according to its view <span class="math">\\mathcal{V}_{i}</span>, so we omit explicit updates to <span class="math">\\mathsf{chFin}</span> in the following.</p>

    <p class="text-gray-300">Propose: At round <span class="math">4\\Delta t</span>, proposer <span class="math">v_{p}</span> merges its view <span class="math">\\mathcal{V}_{p}</span> with its buffer <span class="math">\\mathcal{B}_{p}</span>, <em>i.e.</em>, <span class="math">\\mathcal{V}_{p}\\leftarrow\\mathcal{V}_{p}\\cup\\mathcal{B}_{p}</span>, and sets <span class="math">\\mathcal{B}_{p}\\leftarrow\\emptyset</span>. Then, <span class="math">v_{p}</span> runs the fork-choice function HFC with inputs its view <span class="math">\\mathcal{V}_{p}</span> and slot <span class="math">t</span>, obtaining the head of the chain <span class="math">B^{\\prime}=\\mathrm{HFC}(\\mathcal{V}_{p},t)</span>. Proposer <span class="math">v_{p}</span> extends <span class="math">B^{\\prime}</span> with a new block <span class="math">B</span>, and updates its canonical chain accordingly, by setting <span class="math">\\mathsf{ch}_{p}\\leftarrow B</span>. Finally, it broadcasts the proposal [propose, <span class="math">B</span>, <span class="math">\\mathcal{V}_{p}\\,\\cup\\{B\\}</span>, <span class="math">t</span>, <span class="math">v_{p}</span>].</p>

    <p class="text-gray-300">Head-vote: In rounds <span class="math">[4\\Delta t,4\\Delta t+\\Delta]</span>, a validator <span class="math">v_{i}</span>, upon receiving a proposal message (propose, <span class="math">B</span>, <span class="math">\\mathcal{V}</span>, <span class="math">t</span>, <span class="math">v_{p}</span>) from <span class="math">v_{p}</span>, merges its view with the proposed view <span class="math">\\mathcal{V}</span> by setting <span class="math">\\mathcal{V}_{i}\\leftarrow\\mathcal{V}_{i}\\cup\\mathcal{V}</span>. At round <span class="math">4\\Delta t+\\Delta</span>, even if no proposal is received, validator <span class="math">v_{i}</span> updates its canonical chain by setting <span class="math">\\mathsf{ch}_{i}\\leftarrow\\mathrm{HFC}(\\mathcal{V}_{i},t)</span>, and casts the head vote (head-vote, HFC<span class="math">(\\mathcal{V}_{i},t)</span>, <span class="math">t</span>, <span class="math">v_{i}</span>).</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Algorithm 2 Single slot finality protocol - code for validator  <span class="math">v_{i}</span> 1: State 2:  <span class="math">\\mathcal{V}_i\\gets \\{\\mathcal{B}_{\\mathrm{genesis}}\\}</span>  : view of validator  <span class="math">v_{i}</span> 3:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span>  : buffer of validator  <span class="math">v_{i}</span> 4:  <span class="math">\\mathsf{ch}_i\\gets B_{\\mathrm{genesis}}</span>  : canonical chain of validator  <span class="math">v_{i}</span> 5:  <span class="math">t\\gets 0</span>  : the current slot 6:  <span class="math">r\\gets 0</span>  : the current round PROPOSE 7: at  <span class="math">r = 4\\Delta t</span>  do 8: if  <span class="math">v_{i} = v_{p}^{t}</span>  then 9:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{B}_i,\\mathcal{B}_i\\gets \\emptyset ,B&#x27;\\gets \\mathrm{HFC}(\\mathcal{V}_i,t)</span> 10:  <span class="math">B\\gets \\mathrm{NewBlock}(B&#x27;),\\mathsf{ch}_i\\gets B</span> 11: send message [PROPOSE,  <span class="math">B,\\mathcal{V}_i\\cup \\{B\\} ,t,v_i]</span>  through gossip HEAD-VOTE 12: at  <span class="math">r = 4\\Delta t + \\Delta</span>  do 13:  <span class="math">\\mathsf{ch}_i\\gets \\mathrm{HFC}(\\mathcal{V}_i,t)</span> 14: send message [HEAD-VOTE, HFC( <span class="math">\\mathcal{V}_i,t</span> ),  <span class="math">t,v_i]</span>  through gossip CONFIRM AND FFG-VOTE 15: at  <span class="math">r = 4\\Delta t + 2\\Delta</span>  do 16:  <span class="math">B_{\\mathrm{fast}}\\gets B_{\\mathrm{genesis}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">17:  $S_{\\mathrm{fast}}\\gets \\{B\\prec \\mathsf{ch}_i:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{v_j:\\exists B'\\succ B:[\\mathrm{HEAD - VOTE},B',t,v_j]\\in \\mathcal{B}_i\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\frac{2}{3} n\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">18: if  <span class="math">S_{\\mathrm{fast}}\\neq \\emptyset</span>  then:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19:  $B_{\\mathrm{fast}}\\gets \\arg \\max_{S_{\\mathrm{fast}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">20: if  <span class="math">\\neg (B_{\\mathrm{fast}}\\prec \\mathsf{chAva}_i\\land \\mathsf{ch}_i^{\\lceil \\kappa}\\prec \\mathsf{chAva}_i)</span>  then:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">21:  $\\mathsf{chAva}_i\\gets \\arg \\max_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ch}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathsf{ch}\\in \\{\\mathsf{ch}_i^{\\lceil \\kappa},B_{\\mathrm{fast}}\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">23: send message [FFG-VOTE,  <span class="math">\\mathcal{L}\\mathcal{J}_i,\\mathcal{C}_{\\mathrm{target}},v_i]</span>  through gossip MERGE 24: at  <span class="math">r = 4\\Delta t + 3\\Delta</span>  do 25:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{B}_i</span> 26:  <span class="math">\\mathcal{B}_i\\gets \\emptyset</span> 27: upon receiving a gossiped message [PROPOSE,  <span class="math">B,\\mathcal{V},t,v_p^t ]</span>  do 28:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{B\\}</span> 29: if  <span class="math">r\\in [4\\Delta t,4\\Delta t + \\Delta ]</span>  then 30:  <span class="math">\\mathcal{V}_i\\gets \\mathcal{V}_i\\cup \\mathcal{V}</span> 31: upon receiving a gossiped BLOCK  <span class="math">B</span>  or a gossiped \\*VOTE  <span class="math">V</span>  from  <span class="math">v_j</span>  do 32:  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{B\\}</span>  or  <span class="math">\\mathcal{B}_i\\gets \\mathcal{B}_i\\cup \\{V\\}</span></p>

    <p class="text-gray-300">CONFIRM: At round  <span class="math">4\\Delta t + 2\\Delta</span> , a validator  <span class="math">v_{i}</span>  selects for fast confirmation the highest canonical block  <span class="math">B_{\\mathrm{fast}} \\prec \\mathsf{ch}_i</span>  such that  <span class="math">\\mathcal{B}_i</span>  contains  <span class="math">\\geq \\frac{2}{3} n</span>  votes from slot  <span class="math">t</span>  for descendants of  <span class="math">B_{\\mathrm{fast}}</span> , from distinct validators. It then updates its confirmed chain  <span class="math">\\mathsf{chAva}_i</span>  to the highest between  <span class="math">B_{\\mathrm{fast}}</span>  and  <span class="math">\\mathsf{ch}_i^{\\lceil \\kappa \\rceil}</span> , the  <span class="math">\\kappa</span> -deep prefix of its canonical chain, as long as this does not result in updating  <span class="math">\\mathsf{chAva}_i</span>  to some prefix of it (we do not needlessly revert confirmations).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FFG-VOTE: At round  <span class="math">4\\Delta t + 2\\Delta</span> , after updating  <span class="math">\\mathsf{chAva}_i</span> , a validator  <span class="math">v_i</span>  casts the FFG vote (FFG-VOTE,  <span class="math">\\mathcal{L}\\mathcal{J}_i</span> ,  <span class="math">\\mathcal{C}_{\\mathrm{target}}</span> ,  <span class="math">v_i</span> ), where  $\\mathcal{C}_{\\mathrm{target}} = (\\arg \\max_{B \\in \\{LJ_i, \\mathsf{chAva}_i\\}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, t)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">MERGE: At round  <span class="math">4\\Delta t + 3\\Delta</span> , every validator  <span class="math">v_{i}</span>  merges its view with its buffer, i.e.,  <span class="math">\\mathcal{V}_i \\gets \\mathcal{V}_i \\cup \\mathcal{B}_i</span> , and sets  <span class="math">\\mathcal{B}_i \\gets \\emptyset</span> .</p>

    <p class="text-gray-300">Algorithm 2 works in the generalized partially synchronous sleepy model, and is in particular a  <span class="math">\\tau</span> -secure ebb-and-flow protocol, if we strengthen  <span class="math">\\tau</span> -compliance to require that less than  <span class="math">\\frac{n}{3}</span>  validators are ever slashable</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Slot  <span class="math">t</span>  of our protocol, with its four phases.</p>

    <p class="text-gray-300">for equivocation, for reasons that will be explained shortly. For  <span class="math">\\mathsf{GST} = 0</span> , we show in Section 6.1 that, if the execution is  <span class="math">\\tau</span> -compliant in this stronger sense, then all the properties of RLMD-GHOST [7] keep holding. In Section 6.2 we show that the finalized chain chFin is  <span class="math">\\frac{n}{3}</span> -accountable, and thus always safe if  <span class="math">f &amp;lt; \\frac{n}{3}</span> . Moreover, if  <span class="math">f &amp;lt; \\frac{n}{3}</span> , chFin is live after max{GST, GAT}.</p>

    <p class="text-gray-300">Before proceeding with the analysis under synchrony and partial synchrony, we state without proof the view-merge property, which follows from the usage of the view-merge technique, since it enables proposers to synchronize the view of honest voters with theirs. It corresponds to Lemma 2 as presented by D'Amato and Zanolini [7], with an addition regarding synchronization of the latest justified checkpoint.</p>

    <p class="text-gray-300">Lemma 1. Suppose that  <span class="math">t</span>  is a slot with an (honest) active proposer and that network synchrony holds in rounds  <span class="math">[4\\Delta t - \\Delta, 4\\Delta t + \\Delta]</span> . Say the proposed block is  <span class="math">B</span> , and the latest justified checkpoint in the view of the proposer is  <span class="math">\\mathcal{L}\\mathcal{I}_p</span> . Then, at round  <span class="math">4\\Delta t + \\Delta</span> , all active validators broadcast a HEAD-VOTE for the honest proposal  <span class="math">B</span>  of slot  <span class="math">t</span> . Moreover,  <span class="math">\\mathcal{L}\\mathcal{I}_i = \\mathcal{L}\\mathcal{I}_p</span>  for any such active validator  <span class="math">v_i</span> .</p>

    <p class="text-gray-300">Throughout this part of the analysis, we assume that  <span class="math">\\mathsf{GST} = 0</span> , and that  <span class="math">&amp;lt; \\frac{n}{3}</span>  validators are ever slashable for equivocation, by which here we mean signing multiple HEAD-VOTES for a single slot, rather than violating  <span class="math">\\mathbf{E_1}</span> . In other words, we are not concerned about equivocation with FFG-VOTES, but rather with HEAD-VOTES, which can similarly be declared a slashable offense. Observe that, in RLMD-GHOST with fast confirmations (Appendix B [7]), this assumption is strictly needed for safety (and only for clients which use fast confirmations), but for example not for reorg resilience or liveness, because fast confirmations do not affect the canonical chain. On the other hand, the protocol we present here utilizes confirmations as a prerequisite for justification, and justification does affect the canonical chain, since HFC filters out branches conflicting with the latest justified block. Therefore, we require that  <span class="math">&amp;lt; \\frac{n}{3}</span>  validators are ever slashable for equivocation for all of the properties which we are going to prove. As already mentioned, to avoid stating it repeatedly, we further restrict  <span class="math">\\eta</span> -compliant executions to those executions in which the assumption holds.</p>

    <p class="text-gray-300">Our single slot finality protocol implemented in Algorithm 2 uses the HFC fork-choice function, dealing with checkpoints and justifications. However, one could implement it using also different fork-choice functions. In particular, we show that by substituting HFC with RLMD-GHOST (with equal expiration period  <span class="math">\\eta</span> ), i.e., if we ignore justifications and consider the vanilla fork-choice function introduced by D'Amato and Zanolini [7], then the resulting protocol is equivalent to the RLMD-GHOST protocol with fast confirmation (Appendix B [7]). This because FFG votes have no effect at all, and as such it is  <span class="math">\\eta</span> -reorg-resilient, and  <span class="math">\\eta</span> -dynamically-available. Moreover, the following two results about fast confirmations (Appendix B [7]) also apply.</p>

    <p class="text-gray-300">Theorem 1 (Reorg resilience of fast confirmations). Let us consider an  <span class="math">\\eta</span> -compliant execution with  <span class="math">\\mathsf{GST} = 0</span> . A block fast confirmed by an honest validator at a slot  <span class="math">t</span>  is always in the canonical chain of all active validators at rounds  <span class="math">\\geq 4\\Delta(t + 1) + \\Delta</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2 (Liveness of fast confirmations). An honest proposal  <span class="math">B</span>  from a slot  <span class="math">t</span>  in which  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\frac{2}{3} n<span class="math">  is fast confirmed by all active validators at round  </span>4\\Delta t + \\Delta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We show that, under synchrony, i.e., with  <span class="math">\\mathsf{GST} = 0</span> , these properties are preserved by our justification-respecting protocol, which uses HFC instead. To do so, we show that for every  <span class="math">\\eta</span> -compliant execution,</p>

    <p class="text-gray-300">Algorithm 2 using FC = RLMD-GHOST and Algorithm 2 using FC = HFC are <em>equivalent</em>, i.e., the sequence of outputs of Algorithm 2 is the same regardless of which fork-choice function is used. All properties of Algorithm 2 with FC = RLMD-GHOST in such <span class="math">\\eta</span>-compliant executions then also apply to Algorithm 2 with FC = HFC. In particular, it is also <span class="math">\\eta</span>-reorg-resilient and <span class="math">\\eta</span>-dynamically-available, and it also satisfies reorg resilience and liveness of fast confirmations, <em>i.e.</em>, Theorems 1 and Theorem 2 hold.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 3 (Execution equivalence).</h6>

    <p class="text-gray-300">Let us consider an <span class="math">\\eta</span>-compliant execution with GST = 0 and with Algorithm 2 using FC = HFC. Furthermore, let us consider the same execution, with the same adversarial strategy and randomness, with Algorithm 2 using FC = RLMD-GHOST. The sequence of outputs of the two algorithms correspond exactly.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since the only difference between the two protocols is the fork-choice function FC, the sequences of outputs correspond as long as the outputs of HFC and RLMD-GHOST obtained by active validators are always the same in the two executions. FC is used only twice in Algorithm 2, in Line 9 for proposing, and in Lines 13-14, with the same input, for broadcasting a head-vote. We are going to prove by induction that the canonical chain of an active validator <em>at any voting round</em> is the same in both executions. Since Line 13 sets <span class="math">\\mathsf{ch}_{i}\\leftarrow\\mathsf{FC}(V_{i},t)</span>, and this value is the same as in Line 14, we only need to show that the fork-choice output in Line 9 coincides in the two executions as well. In Line 14, an honest validator uses the fork-choice output to construct their head-votes, so head-votes correspond in both executions. Moreover, the view-merge property applies in both executions, so honestly proposed blocks correspond to the honest head-votes from their slot. Therefore, head-votes coinciding in the two executions implies that honestly proposed blocks coincide as well. Since honestly proposed blocks extend the output of the fork-choice at Line 9, this output is then also the same in both executions, completing the proof. We now carry out the induction.</p>

    <p class="text-gray-300">Induction hypothesis: At any slot <span class="math">t^{\\prime}\\leq t</span> and for <span class="math">r=4\\Delta t^{\\prime}+\\Delta</span>, <span class="math">\\mathsf{ch}_{i}^{r}</span> coincides in both executions, for any active validator <span class="math">i</span>.</p>

    <p class="text-gray-300">Base case: In rounds <span class="math">[0,\\Delta]</span>, the two executions are exactly the same, because the only justified checkpoint is <span class="math">B_{\\text{genesis}}</span>, so <span class="math">\\text{HFC}=\\text{RLMD-GHOST}</span>. Therefore, the statement holds for <span class="math">t=0</span>.</p>

    <p class="text-gray-300">Inductive step: Suppose now that the statement holds for <span class="math">t</span>, and consider round <span class="math">r=4\\Delta(t+1)+\\Delta</span>. Consider an active validator <span class="math">v_{i}</span> with view <span class="math">\\mathcal{V}_{i}</span> at round <span class="math">r</span>, and latest justified block <span class="math">B=LJ(\\mathcal{V}_{i})</span>. Let <span class="math">t^{\\prime}</span> be minimal such that there exists a justified checkpoint <span class="math">\\mathcal{C}=(B,t^{\\prime})</span>, <em>i.e.</em>, slot <span class="math">t^{\\prime}</span> is the first slot in which block <span class="math">B</span> was justified. The supermajority link with target <span class="math">\\mathcal{C}</span> contains at least one FFG vote from an honest validator <span class="math">v_{k}</span>. By minimality of <span class="math">t^{\\prime}</span>, <span class="math">B</span> could not have been already justified in the view of <span class="math">v_{k}</span> when broadcasting an FFG vote at slot <span class="math">t^{\\prime}</span>. Therefore, by Lines 22-23 of Algorithm 2, it must be the case that <span class="math">B\\prec\\mathsf{chAva}_{k}</span> at round <span class="math">4\\Delta t^{\\prime}+2\\Delta</span>, <em>i.e.</em>, that it had been confirmed by <span class="math">v_{k}</span>. If it was fast confirmed at a slot <span class="math">\\leq t^{\\prime}</span>, then, in the execution with FC = RLMD-GHOST, Theorem 1 implies that <span class="math">B\\prec\\mathsf{ch}_{j}^{r^{\\prime}}</span> for all active validators <span class="math">v_{j}</span> at any round <span class="math">r^{\\prime}\\geq 4\\Delta(t^{\\prime}+1)+\\Delta</span>, and so in particular that <span class="math">B\\prec\\mathsf{ch}_{i}^{r}</span>, since <span class="math">t&gt;t^{\\prime}</span>. If instead <span class="math">B\\prec\\mathsf{ch}_{k}^{\\lceil\\kappa}</span> at round <span class="math">4\\Delta t^{\\prime}+2\\Delta</span>, <em>i.e.</em>, <span class="math">B</span> is confirmed by <span class="math">v_{k}</span> due to being <span class="math">\\kappa</span>-deep in its canonical chain, then with overwhelming probability there exists a pivot slot <span class="math">t^{\\prime\\prime}\\in[t^{\\prime}-\\kappa,t^{\\prime})</span> (Lemma 3 <em>[7]</em>), with proposed block <span class="math">B^{\\prime}</span>. In the execution with FC = RLMD-GHOST, <span class="math">\\eta</span>-reorg-resilience then implies that <span class="math">B^{\\prime}\\prec\\mathsf{ch}_{j}^{r^{\\prime}}</span> for all active validators <span class="math">v_{j}</span> at any round <span class="math">r^{\\prime}\\geq 4\\Delta t^{\\prime\\prime}+\\Delta</span>. In particular, <span class="math">B^{\\prime}\\prec\\mathsf{ch}_{k}^{r^{\\prime}}</span> at round <span class="math">r^{\\prime}=4\\Delta t^{\\prime}+2\\Delta</span>, and <span class="math">B^{\\prime}\\prec\\mathsf{ch}_{i}^{r}</span>. The former implies <span class="math">B\\prec B^{\\prime}</span>, since <span class="math">B.t\\leq t^{\\prime}-\\kappa\\leq B^{\\prime}.t</span>, and we then have <span class="math">B\\prec B^{\\prime}\\prec\\mathsf{ch}_{i}^{r}</span>.</p>

    <p class="text-gray-300">Anyway, regardless of how <span class="math">B</span> has been confirmed by <span class="math">v_{k}</span>, we have <span class="math">B\\prec\\mathsf{ch}_{i}^{r}</span>. Therefore, <span class="math">LJ(\\mathcal{V}_{i})=B\\prec\\mathsf{RLMD-GHOST}(\\mathcal{V}_{i},t+1)</span>, which in turn implies <span class="math">\\mathsf{RLMD-GHOST}(\\mathcal{V}_{i},t+1)=\\mathsf{RLMD-GHOST}\\circ\\mathsf{FIL}_{\\text{FFG}}(\\mathcal{V}_{i},t+1)=\\text{HFC}(\\mathcal{V}_{i},t+1)</span>. Therefore, after <span class="math">v_{i}</span> updates its canonical chain <span class="math">\\mathsf{ch}_{i}</span> at round <span class="math">r</span> by setting <span class="math">\\mathsf{ch}_{i}\\leftarrow\\mathsf{FC}(\\mathcal{V},t+1)</span>, with FC dependent on the execution, <span class="math">\\mathsf{ch}_{i}</span> is the same in both executions. ∎</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">6.2 Partial synchrony</h3>

    <p class="text-gray-300">Throughout this section we assume that <span class="math">f&lt;\\frac{n}{3}</span>. First, we prove that the finalized chain is accountably safe, exactly as done in Casper <em>[3]</em>. Then, we show that honest proposals made after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})+\\Delta</span> are justified within their proposal slot, which implies liveness of the finalized chain.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 4 (Accountable safety).</h6>

    <p class="text-gray-300">The finalized chain <span class="math">\\mathsf{chFin}</span> is accountably safe, <em>i.e.</em>, two conflicting finalized blocks imply that at least <span class="math">\\frac{n}{3}</span> adversarial validators can be detected to have violated either <span class="math">\\mathbf{E_{1}}</span> or <span class="math">\\mathbf{E_{2}}</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We assume throughout that there are no double justifications, i.e., there are no checkpoints <span class="math">\\mathcal{C}\\neq\\mathcal{C}^{\\prime}</span> with <span class="math">\\mathcal{C}.t=\\mathcal{C}^{\\prime}.t</span>, and we refer to this as the non-equivocation assumption. If that’s not the case, clearly <span class="math">\\geq\\frac{n}{3}</span> validators are slashable for violating <span class="math">\\mathbf{E_{1}}</span>. Consider two conflicting finalized blocks <span class="math">B</span> and <span class="math">B^{\\prime}</span>. By definition, there are also finalized checkpoints <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span> with <span class="math">B=\\mathcal{C}.B</span>, <span class="math">B^{\\prime}=\\mathcal{C}^{\\prime}.B</span>. Say <span class="math">\\mathcal{C}</span> is finalized by the chain of supermajority links <span class="math">(B_{\\text{genesis}}</span>, <span class="math">0)\\to\\mathcal{C}_{1}\\cdots\\to\\mathcal{C}_{k}=\\mathcal{C}\\to\\mathcal{C}_{k+1}</span>, with <span class="math">\\mathcal{C}_{k+1}.t=\\mathcal{C}.t+1</span>, and <span class="math">\\mathcal{C}^{\\prime}</span> by the chain <span class="math">(B_{\\text{genesis}}</span>, <span class="math">0)\\to\\mathcal{C}_{1}^{\\prime}\\cdots\\to\\mathcal{C}_{k^{\\prime}}^{\\prime}=\\mathcal{C}^{\\prime}\\to\\mathcal{C}_{k^{\\prime}+1}^{\\prime}</span>, with <span class="math">\\mathcal{C}_{k^{\\prime}+1}^{\\prime}.t=\\mathcal{C}^{\\prime}.t+1</span>. Let <span class="math">t_{i}=\\mathcal{C}_{i}.t</span>, and <span class="math">t_{i}^{\\prime}=\\mathcal{C}_{i}^{\\prime}.t</span>. By the non-equivocation assumption, <span class="math">t_{k}\\neq t_{k}^{\\prime}</span>, and without loss of generality we take <span class="math">t_{k}&lt;t_{k}^{\\prime}</span>. Let <span class="math">j=\\min\\{i\\leq k^{\\prime}\\colon t_{k}&lt;t_{i}^{\\prime}\\}</span>, so <span class="math">t_{k}&lt;t_{j}^{\\prime}\\leq t_{k^{\\prime}}^{\\prime}</span>, and <span class="math">t_{j-1}^{\\prime}\\leq t_{k}</span> by minimality of <span class="math">t_{j}^{\\prime}</span>. By the non-equivocation assumption, <span class="math">t_{j}^{\\prime}=t_{k+1}</span> implies that <span class="math">\\mathcal{C}_{k+1}=\\mathcal{C}_{j}^{\\prime}</span>. We then have <span class="math">B=\\mathcal{C}.B\\prec\\mathcal{C}_{k+1}.B=\\mathcal{C}_{j}^{\\prime}.B\\prec\\mathcal{C}^{\\prime}.B=B^{\\prime}</span>, contradicting that <span class="math">B</span> and <span class="math">B^{\\prime}</span> are conflicting. Therefore, <span class="math">t_{j}^{\\prime}&gt;t_{k}+1=t_{k+1}</span> as well. Similarly, <span class="math">t_{j-1}^{\\prime}&lt;t_{k}</span>. Therefore, we have <span class="math">t_{j-1}^{\\prime}&lt;t_{k}&lt;t_{k+1}&lt;t_{k}^{\\prime}</span>, i.e., <span class="math">\\mathcal{C}_{j-1}^{\\prime}.t&lt;\\mathcal{C}_{k}.t&lt;\\mathcal{C}_{k+1}.t&lt;\\mathcal{C}_{j}^{\\prime}.t</span>. The intersection of the two sets of voters of the supermajority links <span class="math">\\mathcal{C}_{k}\\to\\mathcal{C}_{k+1}</span> and <span class="math">\\mathcal{C}_{j-1}^{\\prime}\\to\\mathcal{C}_{j}^{\\prime}</span> contains at least <span class="math">\\frac{n}{3}</span> validators, which are then slashable for violating <span class="math">\\mathbf{E_{2}}</span>. ∎</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">If an honest proposer <span class="math">v_{p}</span> proposes a block <span class="math">B</span> at a slot <span class="math">t</span> after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})+\\Delta</span>, and the latest justified checkpoint in the view of the proposer is <span class="math">\\mathcal{LJ}_{p}</span>, then the checkpoint <span class="math">(B,t)</span> is justified in all honest views at round <span class="math">4\\Delta t+3\\Delta</span>, by supermajority link <span class="math">\\mathcal{LJ}_{p}\\to(B,t)</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since <span class="math">t</span> is after <span class="math">\\mathsf{GAT}+\\Delta</span>, all <span class="math">&gt;\\frac{2}{3}n</span> honest validators are awake since at least round <span class="math">4\\Delta t-\\Delta</span>, so at slot <span class="math">t</span> they have completed the joining protocol and are active. Moreover, the view-merge property (Lemma 1) applies to all of them. Consider now an honest validator <span class="math">v_{i}</span>. By the view-merge property, validator <span class="math">v_{i}</span> broadcasts a head-vote for <span class="math">B</span> at round <span class="math">4\\Delta t+\\Delta</span>. Also by the view-merge property, <span class="math">\\mathcal{LJ}_{i}=\\mathcal{LJ}_{p}</span> at round <span class="math">4\\Delta t+\\Delta</span>, but <span class="math">\\mathcal{LJ}_{i}</span> does not change until round <span class="math">4\\Delta t+3\\Delta</span>, since <span class="math">\\mathcal{V}_{i}</span> does not. Therefore, <span class="math">\\mathcal{LJ}_{i}=\\mathcal{LJ}_{p}</span> at round <span class="math">4\\Delta+2\\Delta</span>. By that round, all <span class="math">\\geq\\frac{2}{3}</span> honest head-votes for <span class="math">B</span> are received by all honest validators, including <span class="math">v_{i}</span>. Since also <span class="math">B\\prec\\mathsf{ch}_{i}</span>, <span class="math">v_{i}</span> fast confirms <span class="math">B</span>, and thus broadcasts an FFG vote <span class="math">\\mathcal{LJ}_{i}\\to(B,t)=\\mathcal{LJ}_{p}\\to(B,t)</span>. All honest validators receive such votes by round <span class="math">4\\Delta t+3\\Delta</span>, and merge them into their view then. Therefore, checkpoint <span class="math">(B,t)</span> is justified in all honest views at that round. ∎</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 5 (Liveness).</h6>

    <p class="text-gray-300">Consider two consecutive slots <span class="math">t</span> and <span class="math">t+1</span> with honest proposers after <span class="math">\\max(\\mathsf{GST},\\mathsf{GAT})+4\\Delta</span>. The block <span class="math">B</span> proposed at slot <span class="math">t</span> is finalized at the end of slot <span class="math">t+1</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By Lemma 2, checkpoint <span class="math">(B,t)</span> is justified in all honest views at round <span class="math">4\\Delta t+3\\Delta</span>. Since at the beginning of slot <span class="math">t+1</span> there cannot be any justified checkpoint with slot <span class="math">&gt;t</span>, and there cannot be any other justified checkpoint with slot <span class="math">t</span>, <span class="math">(B,t)</span> is therefore the latest justified block in the view of the proposer of slot <span class="math">t+1</span>. <span class="math">B</span> is then canonical in its view, and it proposes a block <span class="math">B^{\\prime}</span> which extends <span class="math">B</span>. Again by Lemma 2, <span class="math">(B^{\\prime},t+1)</span> is justified in all honest views at round <span class="math">4\\Delta(t+1)+\\Delta</span>, by the supermajority link <span class="math">(B,t)\\to(B^{\\prime},t+1)</span>. Therefore, <span class="math">B</span> is finalized in all honest views. ∎</p>

    <h2 id="sec-32" class="text-2xl font-bold">7 Single slot finality</h2>

    <p class="text-gray-300">The protocol implemented in Algorithm 2 is a an <span class="math">\\eta</span>-secure ebb-and-flow protocol which (at best) finalizes a block in every slot, but it does not achieve <em>single slot finality</em>, i.e., it cannot finalize a proposal <em>within its proposal slot</em>. At best, it lags behind by one slot, finalizing a proposal from slot <span class="math">t</span> at the end of slot <span class="math">t+1</span>. A straightforward extension of our protocol which achieves single slot finality is one with <span class="math">5\\Delta</span> rounds per slot, allowing for an additional FFG voting phase. This would be very costly in Ethereum, for two reasons. First, it would in practice significantly increase the slot time, because each voting round requires aggregating hundreds of thousands (if not millions) of BLS signatures, likely requiring a lengthier multi-step aggregation process. Moreover, it would be expensive in terms of bandwidth consumption and computation, because such votes would have to all be gossiped and verified by each validator, costly even if already aggregated. For these reasons, we describe here an alternative way to enhance to protocol for the purpose of achieving single slot finality, without suffering from the drawbacks just described. We introduce a new type of message, <em>acknowledgment</em>, and a new slashing condition alongside it. Acknowledgments do not influence the protocol in any way, except in case of slashing, and are mainly intended to be consumed by external observers which want to have the earliest possible finality guarantees. Therefore, they do not need to be gossiped to and verified by all validators. They can then simply be gossiped in smaller sub-networks (similar to the *attestation subne</p>

    <p class="text-gray-300">which Ethereum employs today), requiring limited bandwidth and verification resources. If an observer wants to have faster finality guarantees than they could have by simply following the chain or listening to the global gossip, they can opt to participate in all such sub-networks, and collect all acknowledgments. As doing so is permissionless, it can also be expected that aggregate acknowledgments, or equivalent proofs, might become available through some other channels.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Acknowledgment.</h4>

    <p class="text-gray-300">An <em>acknowledgment</em> is a tuple <span class="math">[\\textsc{Ack},\\mathcal{C},t,v]</span>, where <span class="math">\\mathcal{C}</span> is a checkpoint with <span class="math">\\mathcal{C}.t=t</span>. We also refer to this as an acknowledgment <em>of</em> <span class="math">\\mathcal{C}</span>. A <em>supermajority acknowledgment</em> <em>of</em> <span class="math">\\mathcal{C}</span> is a set of <span class="math">\\geq\\frac{2}{3}n</span> distinct acknowledgments of <span class="math">\\mathcal{C}</span>. At round <span class="math">4\\Delta t+3\\Delta</span>, after merging the buffer <span class="math">\\mathcal{B}_{i}</span>, validator <span class="math">v_{i}</span> broadcasts the acknowledgment <span class="math">[\\textsc{Ack},\\mathcal{L}\\mathcal{J}_{i},t,v_{i}]</span> <em>if</em> <span class="math">\\mathcal{L}\\mathcal{J}_{i}.t=t</span>, <em>i.e.</em>, if <span class="math">\\mathcal{L}\\mathcal{J}_{i}</span> has been justified in the current slot. An observer which receives a supermajority acknowledgment of a <em>justified</em> checkpoint <span class="math">\\mathcal{C}</span> <em>may</em> consider <span class="math">\\mathcal{C}</span> to be finalized.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Slashing rule for finality voting.</h4>

    <p class="text-gray-300">When validator <span class="math">v_{i}</span> broadcasts an acknowledgment of <span class="math">(\\mathcal{C},t)</span>, it <em>acknowledges</em> that, at the end of slot <span class="math">t</span>, it knows about <span class="math">\\mathcal{C}</span> being justified. Since the FFG voting rules prescribe that the source of an FFG vote should be the latest known justified checkpoint, subsequent FFG votes with a source whose slot is <span class="math">&lt;t</span> constitute a provable violation, which is analogous to surround voting. Accordingly, we formulate a third slashing rule, which ensures that finality via a supermajority acknowledgment is accountably safe. In particular, validator <span class="math">v_{i}</span> is slashable for an FFG vote <span class="math">(\\mathcal{C}_{1},\\mathcal{C}_{2})</span> and an acknowledgment <span class="math">(\\mathcal{C},t)</span>, if they satisfy <span class="math">\\mathbf{E_{3}}</span>, <em>i.e.</em>, <span class="math">\\mathcal{C}_{1}.t&lt;\\mathcal{C}.t&lt;\\mathcal{C}_{2}.t</span>. In other words, the link <span class="math">\\mathcal{C}_{1}\\to\\mathcal{C}_{2}</span> <em>surrounds</em> the acknowledged checkpoint.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 6 (Accountable safety with acknowledgments).</h6>

    <p class="text-gray-300">The finalized chain is accountably safe even when it is updated via acknowledgments as well<em>, i.e.</em>, two conflicting finalized checkpoints imply that more than <span class="math">\\frac{n}{3}</span> adversarial validators can be detected to have violated <span class="math">\\mathbf{E_{1}}</span>, <span class="math">\\mathbf{E_{2}}</span>, or <span class="math">\\mathbf{E_{3}}</span>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof largely follows that of Theorem 4. We again consider two conflicting finalized blocks <span class="math">B</span> and <span class="math">B^{\\prime}</span>, and corresponding finalized checkpoints <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span>. Regardless of whether finalization is through a supermajority link or a supermajority acknowledgment, <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{C}^{\\prime}</span> have to be justified, by chains of supermajority links <span class="math">(B_{\\text{genesis}},0)\\to\\mathcal{C}_{1}\\cdots\\to\\mathcal{C}_{k}=\\mathcal{C}</span> and <span class="math">(B_{\\text{genesis}},0)\\to\\mathcal{C}_{1}^{\\prime}\\cdots\\to\\mathcal{C}_{k^{\\prime}}^{\\prime}=\\mathcal{C}^{\\prime}</span>. Let <span class="math">t_{i}=\\mathcal{C}_{i}.t</span>, and <span class="math">t_{i}^{\\prime}=\\mathcal{C}_{i}^{\\prime}.t</span>. By the non-equivocation assumption considered in Theorem 4, we again have <span class="math">t_{k}\\neq t_{k}^{\\prime}</span>, and without loss of generality we take <span class="math">t_{k}&lt;t_{k}^{\\prime}</span>. As before, we let <span class="math">j=\\min\\{i\\leq k^{\\prime}\\colon t_{k}&lt;t_{i}^{\\prime}\\}</span>, so <span class="math">t_{k}&lt;t_{j}^{\\prime}\\leq t_{k^{\\prime}}^{\\prime}</span>, and <span class="math">t_{j-1}^{\\prime}\\leq t_{k}</span> by minimality of <span class="math">t_{j}^{\\prime}</span>. Moreover, also by the non-equivocation assumption, <span class="math">t_{j-1}^{\\prime}&lt;t_{k}</span>. If <span class="math">\\mathcal{C}</span> is finalized through a supermajority link, the proof of Theorem 4 already shows that at least <span class="math">\\frac{n}{3}</span> validators must have violated <span class="math">\\mathbf{E_{2}}</span>, and it is still applicable here because it does not use the last supermajority link in the chain finalizing <span class="math">\\mathcal{C}^{\\prime}</span> (which may or may not exist here). If instead <span class="math">\\mathcal{C}</span> is finalized through a supermajority acknowledgment, <em>i.e.</em>, there are <span class="math">\\frac{2}{3}n</span> acknowledgments of <span class="math">\\mathcal{C}</span>, then at least <span class="math">\\frac{n}{3}</span> validators have violated <span class="math">\\mathbf{E_{3}}</span>, because <span class="math">\\mathcal{C}_{j-1}^{\\prime}.t&lt;\\mathcal{C}.t&lt;\\mathcal{C}_{j}^{\\prime}.t</span>. ∎</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 7 (Single Slot Finality).</h6>

    <p class="text-gray-300">An honest proposal from a slot <span class="math">t</span> after <span class="math">\\max(\\textsf{GST},\\textsf{GAT})+4\\Delta</span> is finalized in round <span class="math">4\\Delta(t+1)</span> by a supermajority acknowledgment.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Say the honestly proposed block is <span class="math">B</span>. By Lemma 2, checkpoint <span class="math">\\mathcal{C}=(B,t)</span> is justified in all honest views at round <span class="math">4\\Delta t+3\\Delta</span>. Therefore, all honest validators broadcast an acknowledgment of <span class="math">\\mathcal{C}</span>. Any observer which listens for acknowledgments would receive all such messages by rounds <span class="math">4\\Delta(t+1)</span>, and thus possesses a supermajority acknowledgment of <span class="math">\\mathcal{C}</span>. Such observer may then consider <span class="math">\\mathcal{C}</span>, and thus also <span class="math">B</span>, to be finalized. ∎</p>

    <h2 id="sec-39" class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">In this work, we have made significant strides towards realizing a secure and reorg-resilient ebb-and-flow protocol that has the potential to replace Ethereum’s current consensus protocol, Gasper. We have provided a comprehensive analysis and modifications to D’Amato and Zanolini’s RLMD-GHOST protocol, integrating it with a partially synchronous finality gadget. In particular, our protocol introduces a novel approach for achieving single slot finality.</p>

    <p class="text-gray-300">Another significant contribution of our work lies in the expansion of the generalized sleepy model introduced by D’Amato and Zanolini. Our generalized partially synchronous sleepy model introduces stronger constraints related to the adversary’s corruption and sleepiness power and incorporates the concept of partial</p>

    <p class="text-gray-300">synchrony. This extension not only enhances the original model but also provides a generalized framework suitable for a wider array of practical scenarios.</p>

    <p class="text-gray-300">However, despite the security guarantees of our protocol, we acknowledge that it is not (yet) practical for real-world implementation. This challenge is due to the current structure of Ethereum, which employs a large pool of validators. Requiring every validator to vote at each slot would necessitate extensive message exchanges – a process that is far from optimal given the scale of Ethereum’s network. Therefore, while our current findings represent a crucial stride towards an improved consensus protocol, they also highlight the need for additional research. Specifically, we need to focus on how we can refine the voting mechanism to better manage and aggregate the messages involved in this process.</p>

    <h2 id="sec-40" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Aditya Asgaonkar. Remove equivocating validators from fork choice consideration. URL: https://github.com/ethereum/consensus-specs/pull/2845.</li>

      <li>[2] Vitalik Buterin. Paths toward single-slot finality, 2023. URL: https://notes.ethereum.org/@vbuterin/single_slot_finality.</li>

      <li>[3] Vitalik Buterin and Virgil Griffith. Casper the friendly finality gadget. CoRR, abs/1710.09437, 2017. URL: http://arxiv.org/abs/1710.09437, arXiv:1710.09437.</li>

      <li>[4] Vitalik Buterin, Diego Hernandez, Thor Kamphefner, Khiem Pham, Zhi Qiao, Danny Ryan, Juhyeok Sin, Ying Wang, and Yan X Zhang. Combining GHOST and Casper. 2020.</li>

      <li>[5] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In Margo I. Seltzer and Paul J. Leach, editors, Proceedings of the Third USENIX Symposium on Operating Systems Design and Implementation (OSDI), New Orleans, Louisiana, USA, February 22-25, 1999, pages 173–186. USENIX Association, 1999.</li>

      <li>[6] Francesco D’Amato, Joachim Neu, Ertem Nusret Tas, and David Tse. No more attacks on proof-of-stake ethereum? CoRR, abs/2209.03255, 2022. URL: https://doi.org/10.48550/arXiv.2209.03255.</li>

      <li>[7] Francesco D’Amato and Luca Zanolini. Recent latest message driven ghost: Balancing dynamic availability with asynchrony resilience, 2023. URL: https://arxiv.org/abs/2302.11326.</li>

      <li>[8] Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288–323, 1988.</li>

      <li>[9] Seth Gilbert and Nancy A. Lynch. Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant web services. SIGACT News, 33(2):51–59, 2002.</li>

      <li>[10] Daniel Kane, Andreas Fackler, Adam Gagol, and Damian Straszak. Highway: Efficient consensus with flexible finality. CoRR, abs/2101.02159, 2021. URL: https://arxiv.org/abs/2101.02159, arXiv:2101.02159.</li>

      <li>[11] Andrew Lewis-Pye and Tim Roughgarden. Resource pools and the CAP theorem. CoRR, abs/2006.10698, 2020. URL: https://arxiv.org/abs/2006.10698.</li>

      <li>[12] Dahlia Malkhi, Atsuki Momose, and Ling Ren. Byzantine consensus under fully fluctuating participation. IACR Cryptol. ePrint Arch., page 1448, 2022.</li>

      <li>[13] Atsuki Momose and Ling Ren. Constant latency in sleepy consensus. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, CCS 2022, Los Angeles, CA, USA, November 7-11, 2022, pages 2295–2308. ACM, 2022.</li>

      <li>[14] Joachim Neu, Ertem Nusret Tas, and David Tse. A balancing attack on Gasper, the current candidate for Eth2’s beacon chain. URL: https://ethresear.ch/t/a-balancing-attack-on-gasper-the-current-candidate-for-eth2s-beacon-chain/8079.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[15] Joachim Neu, Ertem Nusret Tas, and David Tse. Ebb-and-flow protocols: A resolution of the availability-finality dilemma. In 42nd IEEE Symposium on Security and Privacy, SP 2021, San Francisco, CA, USA, 24-27 May 2021, pages 446–465. IEEE, 2021.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[16] Rafael Pass and Elaine Shi. The sleepy model of consensus. In ASIACRYPT (2), volume 10625 of Lecture Notes in Computer Science, pages 380–409. Springer, 2017.</li>

      <li>[17] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in Bitcoin. In International Conference on Financial Cryptography and Data Security, pages 507–527. Springer, 2015.</li>

      <li>[18] Vlad Zamfir. Casper the friendly ghost. a correct-by-construction blockchain consensus protocol. URL: https://github.com/ethereum/research/blob/master/papers/cbc-consensus/AbstractCBC.pdf.</li>

    </ul>`;
---

<BaseLayout title="A Simple Single Slot Finality Protocol For Ethereum (2023/280)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/280
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
