---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1963';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proof of Time: A Method for Verifiable Temporal Commitments Without Timestamp Disclosure';
const AUTHORS_HTML = 'Alexander John Lee';

const CONTENT = `    <p class="text-gray-300">Alexander John Lee</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">This paper introduces a cryptographic method that enables users to prove that an event occurred in the past and that a specified amount of time has since elapsed, without disclosing the exact timestamp of the event. The method leverages zero-knowledge proofs and an on-chain Incremental Merkle Tree to store hash commitments. By utilizing the Poseidon hash function and implementing zero-knowledge circuits in Noir, this approach ensures both the integrity and confidentiality of temporal information. A working demo is provided; the code repository is available at https://github.com/partylikeits1983/proof-of-time.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Proving that an amount of time has elapsed since an event occurred without revealing the exact timestamp of when it occurred has significant applications in privacy-preserving protocols. Traditional methods either expose the timestamp or fail to provide verifiable proof of elapsed time. This paper bridges that gap by allowing users to commit to an event and later prove that a predefined duration has passed since the commitment.</p>

    <p class="text-gray-300">The process consists of two main phases, each employing a zero-knowledge (zk) circuit:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commitment Phase: The user commits to an event by creating a hash that includes a secret, a nullifier (nonce), and a Unix timestamp. A zero-knowledge proof ensures that the hash added to the Incremental Merkle Tree includes the Unix timestamp as one of the inputs to the hash. This hash is then stored on-chain in the Incremental Merkle Tree (IMT) as a leaf.</li>

      <li>Proving Phase: After the required time has elapsed, the user generates another zero-knowledge proof to demonstrate knowledge of the hash preimage of the leaf in the IMT, without revealing the path to the leaf. The smart contract verifies that the proof is valid, with two of the public inputs to the proof being a recent Merkle root of the IMT, and the required elapsed time the user wishes to prove. This ensures that a certain amount of time has passed from the initial commitment phase, without revealing the exact timestamp of when the commitment phase occurred.</li>

    </ol>

    <p class="text-gray-300">A working demo using the Poseidon hash function and the Noir programming language has been implemented. The code is available at the provided GitHub repository in the references section.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 Hash Functions</h3>

    <p class="text-gray-300">This method uses the Poseidon hash function, a cryptographic hash optimized for zero-knowledge proofs. Poseidon operates over finite fields, offering collision resistance and efficiency within zk-SNARK circuits <em>[2]</em>.</p>

    <p class="text-gray-300">Let <span class="math">H:F^{*}\\rightarrow F</span> represent the Poseidon hash function over a finite field <span class="math">F</span>. Its design ensures compatibility with zk-SNARKs and efficient cryptographic operations, making it suitable for succinct proofs in zero-knowledge settings.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Incremental Merkle Trees</h3>

    <p class="text-gray-300">An Incremental Merkle Tree (IMT) is a specialized version of the traditional Merkle tree, tailored for efficient and dynamic updates in datasets that grow over time. Similar to standard Merkle trees, IMTs consist of leaf nodes containing data blocks and non-leaf nodes holding the hashes of their child nodes <em>[6]</em>. However, IMTs are optimized to allow new leaves to be added with minimal recomputation, eliminating the need to reconstruct the entire tree structure. This efficiency is particularly advantageous for on-chain storage, where computational resources and gas costs are critical considerations.</p>

    <p class="text-gray-300">In this method, the IMT is utilized to securely store commitments on-chain, facilitating the incremental addition of hash commitments as users submit commitments. This approach ensures scalability and maintains the integrity of the tree without incurring excessive computational overhead. Inspired by techniques used in Tornado Cash <em>[1]</em>, the method employs a way to prove knowledge of a leaf’s hash preimage without disclosing the path to that leaf. This enables efficient verification of commitments while preserving the privacy of the underlying data, making the IMT well-suited for decentralized applications that require both security and scalability.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Zero-Knowledge Proofs and Noir</h3>

    <p class="text-gray-300">Zero-knowledge proofs enable a prover to demonstrate the truth of a statement to a verifier without revealing additional information <em>[5]</em>. The zero-knowledge circuits in this method are implemented using Noir <em>[3]</em>, a domain-specific language designed for efficient zk-proof development. Noir simplifies the creation of zk-SNARK circuits by providing high-level abstractions.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Methodology</h2>

    <p class="text-gray-300">The method involves two zero-knowledge circuits corresponding to the two phases.</p>

    <p class="text-gray-300">3.1 Commitment Phase</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">3.1.1 Commitment Hash Computation</h4>

    <p class="text-gray-300">A hash <span class="math">h</span> is computed using the following inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Secret <span class="math">s</span>: A private random number known only to the user (private input).</li>

      <li>Nullifier <span class="math">n</span>: A nonce to prevent replay attacks and ensure uniqueness (private input).</li>

      <li>Unix Timestamp <span class="math">t</span>: Commitment timestamp</li>

    </ul>

    <p class="text-gray-300">The hash is computed by first hashing <span class="math">s</span> and <span class="math">n</span>, followed by hashing this intermediate result with <span class="math">t</span>, utilizing the two-input Poseidon hash function in both Noir and Solidity implementations for simplicity in the demonstration. This sequential hashing approach not only ensures compatibility across on-chain and off-chain components but also facilitates the potential addition of further input parameters to the hash in future extensions. As a result, the final leaf hash comprehensively incorporates <span class="math">s</span>, <span class="math">n</span>, and <span class="math">t</span>.</p>

    <p class="text-gray-300">The hash is computed as:</p>

    <p class="text-gray-300"><span class="math">h=H\\big{(}H(s,n),t\\big{)}</span> (1)</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.1.2 Commitment Circuit Inputs and Verification</h4>

    <p class="text-gray-300">The zero-knowledge circuit <span class="math">\\mathcal{C}_{\\mathrm{commit}}</span> takes the following inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Private Inputs: <span class="math">s</span>, <span class="math">n</span></li>

      <li>Public Inputs: <span class="math">t</span>, <span class="math">h</span></li>

    </ul>

    <p class="text-gray-300">The circuit verifies that the hash <span class="math">h</span> is correctly computed:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{\\mathrm{commit}}(s,n,t,h):\\quad\\text{Verify that }h=H\\big{(}H(s,n),t\\big{)}</span> (2)</p>

    <p class="text-gray-300">The zero-knowledge proof ensures that <span class="math">h</span> is correctly computed for a given <span class="math">s</span> and <span class="math">n</span>. When submitting the commitment proof, the smart contract checks if the commitment timestamp <span class="math">t</span> is greater than or equal to the current Unix timestamp in the smart contract <span class="math">T_{\\mathrm{current}}</span>. If the proof is valid and <span class="math">T_{\\mathrm{current}}\\leq t</span>, then the hash <span class="math">h</span> is added as a leaf into the IMT within the smart contract.</p>

    <p class="text-gray-300">This condition can be formally expressed as:</p>

    <p class="text-gray-300"><span class="math">\\text{If }\\mathcal{C}_{\\mathrm{commit}}(s,n,t,h)=\\text{valid}\\quad\\text{and}\\quad T_{\\mathrm{current}}\\leq t,\\quad\\text{then}\\quad h\\in\\text{IMT}</span> (3)</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.2 Proving Phase</h3>

    <p class="text-gray-300">In this phase, the protocol demonstrates that the commitment timestamp <span class="math">t</span> satisfies the elapsed time condition, ensuring that sufficient time has elapsed since the original commitment without revealing the exact timestamp.</p>

    <p class="text-gray-300">3.2.1 Proving Circuit Inputs and Verification</p>

    <p class="text-gray-300">The zero-knowledge circuit <span class="math">\\mathcal{C}_{\\mathrm{prove}}</span> takes the following inputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public Inputs:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{\\mathrm{proof}}</span>: Timestamp at the time of proof generation</li>

      <li><span class="math">T</span>: Required elapsed time since the commitment</li>

      <li><span class="math">R</span>: Root of the IMT</li>

      <li><span class="math">h_{n}</span>: Nullifier hash</li>

      <li>Private Inputs:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t</span>: Commitment timestamp</li>

      <li><span class="math">s</span>: Secret</li>

      <li><span class="math">n</span>: Nullifier</li>

      <li>proof_siblings = <span class="math">[s_{0},s_{1},\\ldots,s_{d-1}]</span>: Merkle proof siblings (for a tree of depth <span class="math">d</span>)</li>

      <li>proof_path_indices = <span class="math">[p_{0},p_{1},\\ldots,p_{d-1}]</span>: Merkle proof path indices</li>

    </ul>

    <p class="text-gray-300">The circuit <span class="math">\\mathcal{C}_{\\mathrm{prove}}</span> verifies the following conditions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Elapsed Time Condition:</li>

    </ol>

    <p class="text-gray-300"><span class="math">t\\leq T_{\\mathrm{proof}}-T</span> (4)</p>

    <p class="text-gray-300">This condition ensures that the commitment was made at least <span class="math">T</span> time units before the proof generation time <span class="math">T_{\\mathrm{proof}}</span>, indicating that sufficient time has elapsed since the commitment. Alternatively, this can be expressed as:</p>

    <p class="text-gray-300"><span class="math">t+T\\leq T_{\\mathrm{proof}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hash Verification:</li>

    </ol>

    <p class="text-gray-300"><span class="math">h=H\\big{(}H(s,n),t\\big{)}</span> (5)</p>

    <p class="text-gray-300">The circuit verifies that the hash <span class="math">h</span> was correctly computed using the secret <span class="math">s</span>, the nullifier <span class="math">n</span>, and the commitment timestamp <span class="math">t</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Nullifier Hash Verification:</li>

    </ol>

    <p class="text-gray-300"><span class="math">h_{n}=H(n)</span> (6)</p>

    <p class="text-gray-300">This ensures that the public nullifier hash <span class="math">h_{n}</span> corresponds to the private nullifier <span class="math">n</span>, preventing double-spending by ensuring <span class="math">n</span> is unique and has not been used before.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Merkle Proof Verification:</li>

    </ol>

    <p class="text-gray-300">The circuit reconstructs the IMT root <span class="math">R</span> from the leaf <span class="math">h</span> using the provided Merkle proof elements. It verifies that <span class="math">h</span> is a valid leaf node within the IMT of root <span class="math">R</span>:</p>

    <p class="text-gray-300"><span class="math">\\text{Verify Merkle Proof}\\ \\big{(}h,R,\\text{proof_siblings},\\text{proof\\_path\\_indices}\\big{)}</span> (7)</p>

    <p class="text-gray-300">This step confirms that the commitment <span class="math">h</span> exists within the on-chain IMT without revealing the path to <span class="math">h</span>.</p>

    <p class="text-gray-300">Upon generating the zero-knowledge proof, the user submits it to the smart contract. The smart contract performs several verifications to ensure the integrity and validity of the proof:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It verifies that the Merkle root <span class="math">R</span> provided in the proof corresponds to one of the recent Merkle roots stored in the smart contract’s state. This can be efficiently managed by maintaining a list or mapping of valid Merkle roots.</li>

      <li>It checks that the proof’s timestamp <span class="math">T_{\\text{proof}}</span> (used as a public input in the proof) is less than or equal to the current blockchain time <span class="math">T_{\\text{now}}</span>. This ensures that the proof was generated prior to the current time and prevents future-dated proofs.</li>

      <li>It ensures that the nullifier hash <span class="math">h_{n}</span> has not been previously used. To prevent duplicate use, the smart contract adds <span class="math">h_{n}</span> to a hash map upon successful verification of the proof. This mechanism effectively tracks used nullifiers and prevents them from being reused in future proofs.</li>

    </ul>

    <p class="text-gray-300">If all these verifications pass, the smart contract accepts the proof, thereby confirming that an event associated with the commitment occurred at least <span class="math">T</span> time units prior to the proof generation time <span class="math">T_{\\text{proof}}</span>, without revealing the exact timestamp <span class="math">t</span> of the commitment. This process maintains both the integrity and confidentiality of the protocol.</p>

    <p class="text-gray-300">These steps collectively ensure that the prover possesses knowledge of the preimage <span class="math">(s,n,t)</span> corresponding to a leaf <span class="math">h</span> in the IMT, that at least <span class="math">T</span> time units have elapsed since the commitment timestamp <span class="math">t</span>, and that the nullifier <span class="math">n</span> has not been previously used. This upholds the protocol’s security guarantees while preserving the privacy of sensitive information.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4 Security Analysis</h2>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.1 Zero-Knowledge Property</h3>

    <p class="text-gray-300">The zero-knowledge proofs ensure that the verifier learns nothing about <span class="math">s</span>, <span class="math">n</span>, or <span class="math">t</span> beyond the validity of the commitment and elapsed time condition. This preserves the confidentiality of the user’s secret and the exact timestamp.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.2 Soundness</h3>

    <p class="text-gray-300">The use of the Poseidon hash function and Merkle proofs guarantees that no adversary can forge a valid proof without knowing the correct inputs. Collision resistance and preimage resistance of</p>

    <p class="text-gray-300">the Poseidon hash function are critical to preventing adversaries from finding different inputs that produce the same hash output, thereby ensuring the uniqueness and integrity of each commitment. Additionally, the integrity of the IMT structure underpins the soundness of the protocol by ensuring that only valid and committed hashes are included. Therefore, the security of the protocol is inherently dependent on the robust cryptographic properties of the Poseidon hash function, which is designed to be secure against known cryptographic attacks while being efficient for zero-knowledge proof systems.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.3 Timestamp Confidentiality</h3>

    <p class="text-gray-300">The protocol ensures that <span class="math">t</span> remains undisclosed by proving only the elapsed time condition relative to <span class="math">T_{\\text{proof}}</span>. This prevents any leakage of the exact time when the event occurred.</p>

    <h2 id="sec-16" class="text-2xl font-bold">5 Applications</h2>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.1 Use Cases</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Delayed Transactions: Prove that sufficient time has passed before executing a transaction, enhancing security measures like withdrawal delays.</li>

      <li>Timelocked Commitments: Verify that a deposit was held for a specified duration without revealing the holding period’s exact start time.</li>

      <li>Anonymous Credentials: Enable users to prove they have held a credential for a certain period without disclosing when it was obtained.</li>

    </ul>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.2 Example Flowchart</h3>

    <p class="text-gray-300">In this example, at time <span class="math">t_{0}</span>, the user deposits liquidity into a contract and commits to the event using the commitment phase. After the minimum deposit time <span class="math">T</span> has passed, the user, likely from a different address, proves that their deposit has existed for the required duration without revealing the exact time of the deposit. To illustrate the process, consider the following flowchart where time flows from left to right:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Flow of Deposit and Proof Process</p>

    <p class="text-gray-300">This paper presents a cryptographic method for proving that an event occurred in the past and that a specified amount of time has elapsed, without revealing the exact timestamp of when the event occurred. By combining Poseidon hash functions, IMTs, and zero-knowledge proofs implemented in Noir, the protocol provides a secure, privacy-preserving solution suitable for decentralized applications. A working demo validates the approach, with code available at [4].</p>

    <p class="text-gray-300">The author thanks the open-source community for providing tools and resources that made this work possible.</p>

    <p class="text-gray-300">[1] Pertsev, A., Semenov, R., &amp; Storm, R. (2019). Tornado Cash: Non-Custodial Anonymous Transactions on Ethereum. Whitepaper. [2] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., &amp; Schofnegger, M. (2020). Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In 26th International Conference on the Theory and Application of Cryptology and Information Security (pp. 69-98). Paper. [3] Noir Programming Language. GitHub Repository. [4] Lee, A. J. (2024). Proof of Time Implementation. GitHub Repository. [5] Goldreich, O. (2001). Foundations of Cryptography: Volume 1. Cambridge University Press. [6] Merkle, R. C. (1987). A Digital Signature Based on a Conventional Encryption Function. In Advances in Cryptology — CRYPTO '87 (pp. 369-378).</p>

    <p class="text-gray-300">[7] Schnorr, C. P. (1991). Efficient Signature Generation by Smart Cards. Journal of Cryptology, 4(3), 161–174.</p>`;
---

<BaseLayout title="Proof of Time: A Method for Verifiable Temporal Commitments ... (2024/1963)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1963
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
