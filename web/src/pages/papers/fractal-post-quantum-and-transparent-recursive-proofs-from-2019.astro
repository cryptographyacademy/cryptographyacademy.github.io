---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1076';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fractal: Post-Quantum and Transparent Recursive Proofs from Holography';
const AUTHORS_HTML = 'Alessandro Chiesa, Dev Ojha, Nicholas Spooner';

const CONTENT = `    <p class="text-gray-300">Alessandro Chiesa alexch@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Dev Ojha dojha@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Nicholas Spooner nick.spooner@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">July 15, 2020</p>

    <p class="text-gray-300">We present a new methodology to efficiently realize recursive composition of succinct non-interactive arguments of knowledge (SNARKs). Prior to this work, the only known methodology relied on pairing-based SNARKs instantiated on cycles of pairing-friendly elliptic curves, an expensive algebraic object. Our methodology does not rely on any special algebraic objects and, moreover, achieves new desirable properties: it is post-quantum and it is transparent (the setup is public coin).</p>

    <p class="text-gray-300">We exploit the fact that recursive composition is simpler for SNARKs with preprocessing, and the core of our work is obtaining a preprocessing zkSNARK for rank-1 constraint satisfiability (R1CS) that is post-quantum and transparent. We obtain this latter by establishing a connection between holography and preprocessing in the random oracle model, and then constructing a holographic proof for R1CS.</p>

    <p class="text-gray-300">We experimentally validate our methodology, demonstrating feasibility in practice.</p>

    <p class="text-gray-300">Keywords: succinct arguments; holographic proofs; recursive proof composition; post-quantum cryptography</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Our results 2 1.2 Comparison with prior work 4</p>

    <p class="text-gray-300">2 Techniques 8 2.1 The role of preprocessing SNARKs in recursive composition 8 2.2 From holographic proofs to preprocessing with random oracles 10 2.3 An efficient holographic proof for constraint systems 11 2.4 Post-quantum and transparent preprocessing 14 2.5 Post-quantum and transparent recursive composition 14 2.6 The verifier as a constraint system 16</p>

    <p class="text-gray-300">3 Preliminaries 18 3.1 Sparse representations of matrices 18 3.2 Indexed relations 18 3.3 Algebra 18</p>

    <p class="text-gray-300">4 Definition of holographic IOPs 21 4.1 Reed-Solomon encoded holographic IOPs 22 4.2 Stronger notions of soundness 23</p>

    <p class="text-gray-300">5 Sumcheck for rational functions 25</p>

    <p class="text-gray-300">6 Holographic lincheck 27 6.1 Holographic proof for sparse matrix arithmetization 27 6.2 The protocol 29</p>

    <p class="text-gray-300">7 RS-encoded holographic IOP for R1CS 32</p>

    <p class="text-gray-300">8 Holographic IOP for R1CS 36</p>

    <p class="text-gray-300">9 Definition of preprocessing non-interactive arguments in the ROM 38</p>

    <p class="text-gray-300">10 From holographic IOPs to preprocessing arguments 40 10.1 Construction 40 10.2 Completeness, efficiency, and non-adaptive zero knowledge 41 10.3 Non-adaptive soundness and knowledge 42 10.4 Classical adaptive knowledge from state restoration knowledge 43 10.5 Adaptive knowledge from round-by-round knowledge 46 10.6 Adaptive zero knowledge 48</p>

    <p class="text-gray-300">11 Recursive composition in the URS model 49 11.1 Preprocessing non-interactive arguments (of knowledge) in the URS model 49 11.2 Preprocessing PCD in the URS model 50 11.3 Theorem statement 51 11.4 Construction and its efficiency 51 11.5 Security reduction 53</p>

    <p class="text-gray-300">12 Implementation of recursive composition 56 12.1 The preprocessing zkSNARK 56 12.2 Designing the verifier's constraint system 56</p>

    <p class="text-gray-300">13 Evaluation 65 13.1 Performance of the preprocessing zkSNARK 65 13.2 Performance of recursive composition 67</p>

    <p class="text-gray-300">Acknowledgments 70</p>

    <p class="text-gray-300">References 70</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Succinct non-interactive arguments (SNARGs) are cryptographic proofs for non-deterministic languages that are small and easy to verify. In the last few years, researchers from across multiple communities have investigated many aspects of SNARGs, including constructions under different cryptographic assumptions, improvements in asymptotic efficiency, concrete performance of implementations, and real-world applications. The focus of this paper is <em>recursive composition</em>, a notion that we motivate next.</p>

    <p class="text-gray-300">Recursive composition. The time to validate a SNARG can be exponentially faster than the time to run the non-deterministic computation that it attests to, a property known as succinct verification. This exponential speedup raises an interesting prospect: could one produce a SNARG about a computation that involves validating prior SNARGs? Thanks to succinct verification, the time to run this (non-deterministic) computation would be essentially independent of the time of the prior computations. This <em>recursive composition</em> of SNARGs enables <em>incrementally verifiable computation</em> <em>[x19]</em> and <em>proof-carrying data</em> <em>[x10, x3]</em>. A critical technicality here is that, for recursive composition to work, the SNARG must be an <em>argument of knowledge</em>, i.e., a SNARK. This is because the security of a SNARG holds only against efficient adversaries, and the knowledge property ensures that prior SNARGs must have been efficiently produced, and so we can rely in turn on their security. A formal treatment of this can be found in <em>[x3]</em>, which discusses how the “strength” of a SNARG’s knowledge property relates to how many recursions the SNARG supports.</p>

    <p class="text-gray-300">Efficient recursion. Theory tells us that <em>any</em> succinct-verifier SNARK is recursively composable <em>[x3]</em>. In practice, however, recursive composition is exceedingly difficult to realize efficiently. The reason is that, even if we have a SNARK that is concretely efficient when used “standalone”, it is often prohibitively expensive to express the SNARK verifier’s computation through the language supported by the SNARK. Indeed, while by now there are numerous SNARK constructions with remarkable concrete efficiency, <em>to date there is only a single efficient approach to recursion</em>. The approach, due to <em>[x2]</em>, uses pairing-based SNARKs with a special algebraic property discussed below. This has enabled real-world applications such as Coda <em>[x8]</em>, a cryptocurrency that uses recursive composition to achieve strong scalability properties.</p>

    <p class="text-gray-300">Limitations. The above efficient approach to recursion suffers from significant limitations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is pre-quantum. Pairing-based SNARKs rely (at least) on the hardness of extracting discrete logarithms, and so are insecure against quantum attacks. Hence the approach of <em>[x2]</em> is also insecure against quantum attacks. Devising an efficient <em>post-quantum</em> approach to recursion is an open problem.</li>

      <li>It introduces toxic waste. All known pairing-based SNARKs that can be used in the approach of <em>[x2]</em> rely on a structured reference string (SRS). Sampling the SRS involves secret values (the “toxic waste”) that must remain secret for security. Ensuring that this is the case in practice is difficult: the SRS must be sampled by some trusted party or via a cryptographic ceremony <em>[x4, x5, x1, x1]</em>. Devising an efficient <em>transparent</em> (toxic-waste free) approach to recursion is an open problem.</li>

      <li>It uses expensive algebra. The approach of <em>[x2]</em> uses pairing-based SNARKs instantiated via <em>pairing-friendly cycles of elliptic curves</em>. Only a <em>single</em> cycle construction is known, <em>MNT cycles</em>; it consists of two prime-order elliptic curves, with embedding degrees 4 and 6 respectively. Curves in an MNT cycle must be much bigger than usual in order to compensate for the loss of security caused by the small embedding degrees. Moreover the fields that arise from MNT cycles are <em>imposed on applications</em> rather than being chosen depending on the needs of applications, causing additional performance overheads. Attempts to find “better” cycles, without these limitations, have resulted in some negative results <em>[x9]</em>. Indeed, finding <em>any other</em> cycles beyond MNT cycles is a challenging open problem.</li>

    </ul>

    <p class="text-gray-300">1.1 Our results</p>

    <p class="text-gray-300">We present a new methodology for recursive composition that simultaneously overcomes all of the limitations discussed above. We experimentally validate our methodology, demonstrating feasibility in practice.</p>

    <p class="text-gray-300">The starting point of our work is the observation that recursive composition is simpler when applied to a SNARG (of knowledge) that supports preprocessing, as we explain in Section 2.1. This property of a SNARG means that in an offline phase one can produce a short summary for a given circuit and then, in an online phase, one may use this short summary to verify SNARGs that attest to the satisfiability of the circuit with different partial assignments to its inputs. The online phase can be as fast as reading the SNARG (and the partial assignment), and in particular sublinear in the circuit size even for arbitrary circuits. Throughout, by “preprocessing SNARG” we mean a SNARG whose verifier runs in time polylogarithmic in the circuit size.</p>

    <p class="text-gray-300">Our methodology has three parts: (1) a transformation that maps any “holographic proof” into a preprocessing SNARG in the random oracle model; (2) a holographic proof for (rank-1) constraint systems, which leads to a corresponding preprocessing SNARG; (3) a transformation that recurses any preprocessing SNARK (once the random oracle is heuristically instantiated via a cryptographic hash function).</p>

    <p class="text-gray-300">We now summarize our contributions for each of these parts.</p>

    <p class="text-gray-300">(1) From holographic proofs to preprocessing SNARGs. A probabilistic proof is holographic if the verifier does not receive the circuit description as an input but, rather, makes a small number of queries to an encoding of the circuit <em>[x1]</em>. Recent work <em>[x10]</em> has established a connection between holography and preprocessing (which we review in Section 1.2). The theorem below adds to this connection, by showing that interactive oracle proofs (IOPs) <em>[x5, x24]</em> that are holographic can be compiled into preprocessing SNARGs that are secure in the quantum random oracle model <em>[x1, x11]</em>.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">There is an efficient transformation that compiles any holographic IOP for a relation <span class="math">\\mathcal{R}</span> into a preprocessing SNARG for <span class="math">\\mathcal{R}</span> that is unconditionally secure in the random oracle model. If the IOP is a (honest-verifier) zero knowledge proof of knowledge then the transformation produces a zero knowledge SNARG of knowledge (zkSNARK). This extends to hold in the quantum random oracle model.</p>

    <p class="text-gray-300">By applying Theorem 1 to known holographic proofs for non-deterministic computations (such as the PCP in <em>[x1]</em> or the IPCP in <em>[x12]</em>), we obtain the first transparent preprocessing SNARG and the first post-quantum preprocessing SNARG. Unfortunately, known holographic proofs are too expensive for practical use, because encoding the circuit is costly (as explained in Section 1.2.1). In this paper we address this problem by constructing an efficient holographic proof, discussed below.</p>

    <p class="text-gray-300">We note that holographic proofs involve relations <span class="math">\\mathcal{R}</span> that consist of triples rather than pairs because the statement being checked has two parts. One part is called the index, which is encoded in an offline phase by the indexer and this encoding is provided as an oracle to the verifier. The other part is called the instance, which is provided as an explicit input to the verifier. For example, the index may be a circuit description and the instance a partial assignment to its inputs. We refer to this notion as indexed relations (see Section 3.2).</p>

    <p class="text-gray-300">(2) Efficient protocols for R1CS. We present a holographic IOP for rank-1 constraint satisfiability (R1CS), a standard generalization of arithmetic circuits where the “circuit description” is given by coefficient matrices. We describe the corresponding indexed relation.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 1 (informal).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> is the set of triples <span class="math">(\\texttt{i},\\texttt{x},\\texttt{w})=\\big{(}(\\mathbb{F},n,m,A,B,C),x,w\\big{)}</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">A,B,C</span> are <span class="math">n\\times n</span> matrices over <span class="math">\\mathbb{F}</span>, each containing at most <span class="math">m</span> non-zero entries, and <span class="math">z:=(x,w)</span> is a vector in <span class="math">\\mathbb{F}^{n}</span> such that <span class="math">Az\\circ Bz=Cz</span>. (Here “<span class="math">\\circ</span>” denotes the entry-wise product.)</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 2 (informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a public-coin holographic IOP for the indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> that is a zero knowledge proof of knowledge with the following efficiency features. In the offline phase, the encoding of an index is computable in <span class="math">O(m\\log m)</span> field operations and consists of <span class="math">O(m)</span> field elements. In the online phase, the protocol has <span class="math">O(\\log m)</span> rounds, with the prover using <span class="math">O(m\\log m)</span> field operations and the verifier using $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log m)<span class="math"> field operations. Proof length is </span>O(m)<span class="math"> field elements and query complexity is </span>O(\\log m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above theorem improves, in the holographic setting, on prior IOPs for R1CS (see Fig. 1): it offers an exponential improvement in verification time compared to the linear-time verification of <em>[x1]</em>, and it offers succinct verification for all coefficient matrices compared to only structured ones as in <em>[x2]</em>.</p>

    <p class="text-gray-300">Armed with an efficient holographic IOP, we use our compiler to construct an efficient preprocessing SNARG in the random oracle model. The following theorem is obtained by applying Theorem 1 to Theorem 2.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 3 (informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a preprocessing zkSNARK for R1CS that is unconditionally secure in the random oracle model (and the quantum random oracle model) with the following efficiency features. In the offline phase, anyone can publicly preprocess an index in time <span class="math">O_{\\lambda}(m\\log m)</span>, obtaining a corresponding verification key of size <span class="math">O_{\\lambda}(1)</span>. In the online phase, the SNARG prover runs in time <span class="math">O_{\\lambda}(m\\log m)</span> and the SNARG verifier runs in time $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log^{2}m)<span class="math">; argument size is </span>O_{\\lambda}(\\log^{2}m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have implemented the protocol underlying Theorem 3, obtaining the first efficient realization of a post-quantum transparent preprocessing zkSNARK.</p>

    <p class="text-gray-300">For example, for a security level of 128 bits over a <span class="math">181</span>-bit prime field, arguments range from <span class="math">80\\,\\mathrm{kB}</span> to <span class="math">160\\,\\mathrm{kB}</span> for instances of up to millions of constraints. These argument sizes are two orders of magnitude bigger than pre-quantum non-transparent preprocessing zkSNARKs (see Section 1.2.2), and are <span class="math">2\\times</span> bigger that the state of the art in post-quantum transparent non-preprocessing zkSNARKs <em>[x1]</em>. Our proving and verification times are comparable to prior work: proving takes several minutes, while verification takes several milliseconds regardless of the constraint system. (See Section 13.1 for performance details.)</p>

    <p class="text-gray-300">Besides its application to post-quantum transparent recursion, our preprocessing zkSNARK provides attractive benefits over prior constructions, as we discuss in Section 1.2.2.</p>

    <p class="text-gray-300">Note that, when the random oracle in the construction is heuristically instantiated via an efficient cryptographic hash function (as in our implementation), the resulting preprocessing zkSNARK is in the uniform reference string (URS) model, which means that the system parameters consist of a uniformly random string of fixed size. The term “transparent” refers to a construction in the URS model.</p>

    <p class="text-gray-300">(3) Post-quantum transparent recursion. We obtain the first efficient realization of post-quantum transparent recursive composition for SNARKs. The cryptographic primitive that formally captures this capability is known as proof carrying data (PCD) <em>[x10, x7]</em>, and so this is what we construct.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 4 (informal).</h6>

    <p class="text-gray-300">There is an efficient transformation that compiles any preprocessing SNARK in the URS model into a preprocessing PCD scheme in the URS model. Moreover, if the preprocessing SNARK is post-quantum secure then so is the preprocessing PCD scheme.</p>

    <p class="text-gray-300">The above transformation, which preserves the “transparent” property and post-quantum security, is where recursive composition occurs. For details, including the notion of PCD, see Section 11.</p>

    <p class="text-gray-300">Moreover, we provide an efficient implementation of the transformation in Theorem 4 applied to our implementation of the preprocessing zkSNARK from Theorem 3. The main challenge is to express the SNARK verifier’s computation in as few constraints as possible, and in particular to design a constraint</p>

    <p class="text-gray-300">system for the SNARK verifier that on relatively small instances is smaller than the constraint system that it checks (thereby permitting arbitrary recursion depth). Via a combination of computer-assisted design and recent advances in algebraic hash functions, we achieve this threshold for all computations of at least 2 million constraints. Specifically, we can express a SNARK verifier checking 2 million constraints using only 1.1 million constraints, and this gap grows quickly with the computation size. This is the first demonstration of post-quantum transparent recursive composition in practice. (See Section 13.2 for performance details.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R1CS instances</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">holographic?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">indexer time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCRSVW19]</td>

            <td class="px-3 py-2 border-b border-gray-700">arbitrary</td>

            <td class="px-3 py-2 border-b border-gray-700">NO</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCGGRS19] †</td>

            <td class="px-3 py-2 border-b border-gray-700">semi-succinct</td>

            <td class="px-3 py-2 border-b border-gray-700">NO</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">arbitrary</td>

            <td class="px-3 py-2 border-b border-gray-700">YES</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log m)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Comparison of IOPs for R1CS: two prior non-holographic IOPs, and our holographic IOP. Here  <span class="math">n</span>  denotes the number of variables and  <span class="math">m</span>  the number of non-zero coefficients in the matrices. †: The parameters stated for [BCGGRS19] reflect replacing the constant-query low-degree test in the construction with a concretely-efficient logarithmic-query low-degree test such as [BBHR18], to simplify comparison.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Diagram of our methodology to recursive composition that is post-quantum and transparent.</p>

    <p class="text-gray-300">We provide a comparison with prior work in the three areas to which we contribute: holographic proofs (Section 1.2.1); preprocessing SNARGs (Section 1.2.2); and recursive composition of SNARKs (Section 1.2.3). We omit a general discussion of the now ample literature on SNARGs, and in particular do not discuss non-preprocessing SNARGs for structured computations (e.g., [XZZPS19], [BBHR19], and many others).</p>

    <p class="text-gray-300">The verifier in a proof system cannot run in time that is sublinear in its input, because it must at a minimum read the input in order to know the statement being checked. Holographic proofs [BFLS91] avoid this limitation by considering a setting where the verifier does not receive its input explicitly but, instead, has query access to an encoding of it. The goal is then to verify the statement in time sublinear in its size; note that such algorithms are necessarily probabilistic. <span class="math">^4</span></p>

    <p class="text-gray-300">In Fig. 3 we compare the efficiency of prior holographic proofs and our holographic proof for the case of circuit satisfiability, where the input to the verifier is the description of an arbitrary circuit. There are two main prior holographic proofs in the literature. One is the PCP construction in [BFLS91], where it suffices for the verifier to query a few locations of a low-degree extension of the circuit description. Another one is the "bare bones" protocol in [GKR15], which is a holographic IP for circuit evaluation that can be re-cast as a holographic IPCP for circuit satisfaction; the verifier relies on the low-degree extensions of functions that describe each layer of the circuit. The constructions in [BFLS91] and [GKR15] are unfit for practical use as holographic proofs in Theorem 1, because encoding the circuit incurs a polynomial blowup due to the use of multivariate low-degree extensions (which yield encodings with inverse polynomial rate).</p>

    <p class="text-gray-300">In the table we exclude the "algebraic holographic proof" of Marlin [CHMMVW20], because the soundness guarantee of such a proof is incompatible with Theorem 1.</p>

    <p class="text-gray-300">Comparison with this work. Our holographic proof is the first to achieve efficient asymptotics not only for the prover and verifier, but also for the indexer, which is responsible for producing the encoding of the circuit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">indexer time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BFLS91]</td>

            <td class="px-3 py-2 border-b border-gray-700">PCP</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log(N))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GKR15]</td>

            <td class="px-3 py-2 border-b border-gray-700">IPCP</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">) + O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ D log W)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">IOP</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3: Comparison of holographic proofs for arithmetic circuit satisfiability. Here  <span class="math">\\mathbf{x}</span>  denotes the known inputs,  <span class="math">\\mathbf{w}</span>  the unknown inputs, and  <span class="math">N</span>  the total number of gates; if the circuit is layered,  <span class="math">D</span>  denotes circuit depth and  <span class="math">W</span>  circuit width. Our Theorem 1 can be used to compile any of these holographic proofs into a preprocessing SNARG. (For better comparison with other works, [GKR15] is stated as an IPCP for circuit satisfiability rather than as an IP for circuit evaluation; in the latter case, the prover time would be  <span class="math">O(N)</span> . The prover times for [GKR15] incorporate the techniques for linear-time sumcheck and others introduced in [Tha13; XZZPS19].)</p>

    <p class="text-gray-300">Prior works construct preprocessing SNARs in a model where a trusted party samples, in a parameter setup phase, a structured reference string (SRS) that is proportional to circuit size. We summarize the main features of these constructions, distinguishing between the case of circuit-specific SRS and universal SRS.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Circuit-specific SRS: a circuit is given as input to the setup algorithm, which samples a (long) proving key and a (short) verification key that can be used to produce and validate arguments for the circuit. Preprocessing SNARs with circuit-specific SRS originate in [Gro10; Lip12; GGPR13; BCIOP13], and have been studied in an influential line of work that has led to highly-efficient constructions (e.g., [Gro16]) and large-scale deployments (e.g., [Zc14]). They are obtained by combining linear interactive proofs and linear-only encodings. The argument sizes achievable in this setting are very small: less than 200 bytes.</li>

      <li>Universal SRS: a size bound is given as input to the setup algorithm, which samples a (long) proving key and a (short) verification key that can be used to produce and validate arguments for circuits within this bound. A public procedure can then be used to specialize both keys for arguments relative to the desired circuit. Preprocessing SNARs with universal (and updatable) SRS were introduced in [GKMMM18], and led</li>

    </ul>

    <p class="text-gray-300">to efficient constructions in <em>[x11, x10, x12]</em>. They are obtained by combining “algebraic” holographic proofs (see below) and polynomial commitment schemes. The argument sizes currently achievable with universal SRS are bigger than with circuit-specific SRS: less than <span class="math">1000</span> bytes.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Comparison with this work.</h4>

    <p class="text-gray-300">Theorem 1 provides a methodology to obtain preprocessing SNARGs in the (quantum) random oracle model, which heuristically implies (by suitably instantiating the random oracle) preprocessing SNARGs that are post-quantum and transparent. Neither of these properties is achieved by prior preprocessing SNARGs. Theorem 1 also develops the connection between holography and preprocessing discovered in <em>[x10]</em>, which considers the case of holographic proofs where the completeness and soundness properties are restricted to “algebraic provers” (which output polynomials of prescribed degrees). We consider the case of general holographic proofs, where completeness and soundness are not restricted.</p>

    <p class="text-gray-300">Moreover, our holographic proof (Theorem 2) leads to a preprocessing SNARG (Theorem 3) that, as supported by our implementation, provides attractive benefits over prior preprocessing SNARGs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prior preprocessing SNARGs require cryptographic ceremonies to securely sample the long SRS, which makes deployments difficult and expensive. This has restricted the use of preprocessing SNARGs to proving relatively small computations, due to the prohibitive cost of securely sampling SRSs for large computations. This is unfortunate because preprocessing SNARGs could be useful for “scalability applications”, which leverage succinct verification to efficiently check large computations (e.g., verifying the correctness of large batches of trades executed at a non-custodial exchange <em>[x18, x13]</em>).</li>

    </ul>

    <p class="text-gray-300">The transparent property of our preprocessing SNARG means that the long SRS is replaced with a fixed-size URS (uniform reference string). This simplifies deployments and enables scalability applications.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prior preprocessing SNARGs are limited to express computations over the prime fields that arise as the scalar fields of pairing-friendly elliptic curves. Such fields are imposed by parametrized curve families that offer little flexibility for optimizations or applications. (Alternatively one can use the Cocks–Pinch method <em>[x12]</em> to construct an elliptic curve with a desired scalar field, but the resulting curve is inefficient.)</li>

    </ul>

    <p class="text-gray-300">In contrast, our preprocessing SNARG is easily configurable across a range of security levels, and supports most large prime fields and all large binary fields, which offers greater flexibility in terms of performance optimizations and customization for applications.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Remark 1.1 (weaker forms of preprocessing).</h6>

    <p class="text-gray-300">Prior work proved recursive composition only for non-interactive arguments of knowledge with succinct verifiers <em>[x3]</em>; this is the case for our definition of preprocessing SNARGs. In this paper we show that recursive composition is possible even when the verifier is merely <em>sublinear</em> in the circuit size (see Section 11), though the cost of each recursion is much steeper than in the polylogarithmic case. This provides additional motivation to the study of preprocessing with sublinear verifiers (e.g., <em>[x2, x16]</em>).</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">1.2.3 Recursion for pairing-based SNARKs</h4>

    <p class="text-gray-300">The approach to recursive composition of <em>[x2]</em> uses pairing-based (preprocessing) SNARKs based on pairing-friendly cycles of elliptic curves. This approach applies to constructions with circuit-specific SRS (e.g. <em>[x11]</em>) <em>and</em> to those with universal SRS (e.g. <em>[x11, x12, x13]</em>).</p>

    <p class="text-gray-300">Informally, pairing-based SNARKs support languages that involve the satisfiability of constraint systems over a field that is <em>different</em> from the field used to compute the SNARK verifier — this restriction arises from the mathematics of the underlying pairing-friendly elliptic curve used to instantiate the pairing. This</p>

    <p class="text-gray-300">seemingly mundane fact has the regrettable consequence that expressing the SNARK verifier’s computation in the language supported by the SNARK (to realize recursive composition) is unreasonably expensive due to this “field mismatch”. To circumvent this barrier, prior work leveraged <em>two</em> pairing-based SNARKs where the field to compute one SNARK verifier equals the field of the language supported by the other SNARK, and vice versa. This condition enables each SNARK to efficiently verify the other SNARK’s proofs.</p>

    <p class="text-gray-300">These special SNARKs rely on pairing-friendly cycles of elliptic curves, which are pairs of pairing-friendly elliptic curves where the base field of one curve equals the scalar field of the other curve and vice versa. The only known construction is <em>MNT cycles</em>, which consist of two prime-order elliptic curves with embedding degrees 4 and 6 respectively. An MNT cycle must be much bigger than usual in order to compensate for the low security caused by the small embedding degrees. For example, for a security level of 128 bits, curves in an MNT cycle must be defined over a prime field with roughly 800 bits; this is over <em>three times</em> the 256 bits that suffice for curves with larger embedding degrees. These performance overheads can be significant in practice, e.g., Coda <em>[x10]</em> is a project that has deployed MNT cycles in a product, and has organized a community challenge to speed up the proof generation for pairing-based SNARKs <em>[x23]</em>. A natural approach to mitigate this problem would be to find “high-security” cycles (i.e., with higher embedding degrees) but to date little is known about pairing-friendly cycles beyond a few negative results <em>[x9]</em>.</p>

    <p class="text-gray-300">Comparison with this work. The approach to recursion that we present in this paper is <em>not tied</em> to constructions of pairing-friendly cycles of elliptic curves. In particular, our approach scales gracefully across different security levels, and also offers more flexibility when choosing the desired field for an application. In addition, our approach is post-quantum and, moreover, uses a transparent (i.e., public-coin) setup.</p>

    <p class="text-gray-300">On the other hand, our approach has two disadvantages. First, argument size is about 100 times bigger than the argument size achievable by cycle-based recursion. Second, the number of constraints needed to express the verifier’s computation is about 40 times bigger than those needed in the case of cycle-based recursion (e.g., the verifier of <em>[x14]</em> can be expressed in about 40,000 constraints). The vast majority of these constraints come from the many hash function invocations required to verify the argument.</p>

    <p class="text-gray-300">Both of the above limitations are somewhat orthogonal to our approach and arguably temporary: the large proof size and many hash invocations come from the many queries required from current constructions of low-degree tests <em>[x3, x5]</em>. As the state of the art in low-degree testing progresses (e.g., to high-soundness constructions over large alphabets), both argument size and verifier size will also improve.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We discuss the main ideas behind our results. In Section 2.1 we explain how preprocessing simplifies recursive composition. In Section 2.2 we describe our compiler from holographic IOPs to preprocessing SNARGs (Theorem 1). In Section 2.3 we describe our efficient holographic IOP (Theorem 2), and then in Section 2.4 we discuss the corresponding preprocessing SNARG (Theorem 3). In Section 2.5 we describe how to obtain post-quantum and transparent PCD (Theorem 4). In Section 2.6 we discuss our verifier circuit.</p>

    <p class="text-gray-300">Recall that indexed relations consist of triples <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> where <span class="math">\\mathfrak{i}</span> is the index, <span class="math">\\mathtt{x}</span> is the instance, and <span class="math">\\mathtt{w}</span> is the witness (see Section 3.2). We use these relations because the statements being checked have two parts, the index <span class="math">\\mathfrak{i}</span> (e.g., a circuit description) given in an offline phase and the instance <span class="math">\\mathtt{x}</span> (e.g., a partial input assignment) given in an online phase.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.1 The role of preprocessing SNARKs in recursive composition</h3>

    <p class="text-gray-300">We explain why preprocessing simplifies recursive composition of SNARKs. For concreteness we consider the problem of incrementally proving the iterated application of a circuit <span class="math">F\\colon\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> to an initial input <span class="math">z_{0}\\in\\{0,1\\}^{n}</span>. We are thus interested in proving statements of the form “given <span class="math">z_{T}</span> there exists <span class="math">z_{0}</span> such that <span class="math">z_{T}=F^{T}(z_{0})</span>”, but wish to avoid having the SNARK prover check the correctness of all <span class="math">T</span> invocations at once. Instead, we break the desired statement into <span class="math">T</span> smaller statements {“<span class="math">z_{i}=F(z_{i-1})</span>”}<span class="math">\\}_{i=1}^{T}</span> and then inductively prove them. Informally, for <span class="math">i=1,\\ldots,T</span>, we produce a SNARK proof <span class="math">\\pi_{i}</span> for this statement:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“Given a counter <span class="math">i</span> and claimed output <span class="math">z_{i}</span>, there exists a prior output <span class="math">z_{i-1}</span> such that <span class="math">z_{i}=F(z_{i-1})</span> and, if <span class="math">i&gt;1</span>, there exists a SNARK proof <span class="math">\\pi_{i-1}</span> that attests to the correctness of <span class="math">z_{i-1}</span>.”</p>
    </blockquote>

    <p class="text-gray-300">Formalizing this idea requires care, and in particular depends on how the SNARK achieves succinct verification (a prerequisite for recursive composition). There are two methods to achieve succinct verification.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non-preprocessing SNARKs for structured computations. The SNARK supports non-deterministic computations expressed as programs, i.e., it can be used to prove/verify statements of the form “given a program <span class="math">M</span>, primary input <span class="math">\\mathtt{x}</span>, and time bound <span class="math">t</span>, there exists an auxiliary input <span class="math">\\mathtt{w}</span> such that <span class="math">M</span> accepts <span class="math">(\\mathtt{x},\\mathtt{w})</span> in <span class="math">t</span> steps”. (More generally, the SNARK could support any computation model for which the description of a computation can be significantly smaller than the size of the described computation.)</li>

      <li>Preprocessing SNARKs for arbitrary computations. The SNARK supports circuit satisfiability, i.e., it can be used to prove/verify statements of the form “given a circuit <span class="math">C</span> and primary input <span class="math">\\mathtt{x}</span>, there exists an auxiliary input <span class="math">\\mathtt{w}</span> such that <span class="math">C(\\mathtt{x},\\mathtt{w})=0</span>”. Preprocessing enables the circuit <span class="math">C</span> to be summarized into a short verification key <span class="math">\\mathsf{ivk}_{C}</span> that can be used for succinct verification regardless of the structure of <span class="math">C</span>. (More generally, the SNARK could support any computation model as long as preprocessing is possible.)</li>

    </ol>

    <p class="text-gray-300">We compare the costs of recursive composition in these two cases, showing why the preprocessing case is cheaper. Throughout we consider SNARKs in the uniform reference string model, i.e., parameter setup consists of sampling a fully random string <span class="math">\\mathsf{urs}</span> of size <span class="math">\\mathsf{poly}(\\lambda)</span> that suffices for proving/verifying any statement.</p>

    <p class="text-gray-300">(1) Recursion without preprocessing. Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a non-preprocessing SNARK for non-deterministic program computations. In this case we follow <em>[x1]</em>: recursion is realized via a program <span class="math">R</span>, which depends on <span class="math">\\mathsf{urs}</span> and <span class="math">F</span>, that checks one invocation of the circuit <span class="math">F</span> and the validity of a prior SNARK proof relative to the reference string <span class="math">\\mathsf{urs}</span>. The program <span class="math">R</span> is defined as follows:</p>

    <p class="text-gray-300">Primary input: a tuple  <span class="math">\\mathbf{x} = (M, i, z_i)</span>  consisting of the description of a program  <span class="math">M</span> , counter  <span class="math">i</span> , and claimed output  <span class="math">z_i</span> . (We later set  <span class="math">M := R</span>  to achieve recursion, as explained shortly.)</p>

    <p class="text-gray-300">Auxiliary input: a tuple  <span class="math">\\mathbf{w} = (z_{i-1}, \\pi_{i-1})</span>  consisting of a previous output  <span class="math">z_{i-1}</span>  and corresponding SNARK proof  <span class="math">\\pi_{i-1}</span>  that attests to its correctness.</p>

    <p class="text-gray-300">Code:  <span class="math">R(\\mathbf{x}, \\mathbf{w})</span>  accepts if  <span class="math">z_i = F(z_{i-1})</span>  and, if  <span class="math">i &amp;gt; 1</span> ,  <span class="math">\\mathcal{V}(\\mathrm{urs}, M, \\mathbf{x}_{i-1}, t, \\pi_{i-1}) = 1</span>  where  <span class="math">\\mathbf{x}_{i-1} := (M, i-1, z_{i-1})</span>  and  <span class="math">t</span>  is a suitably chosen time bound.</p>

    <p class="text-gray-300">The program  <span class="math">R</span>  can be used to incrementally prove the iterated application of the circuit  <span class="math">F</span> . Given a tuple  <span class="math">(i - 1, z_{i-1}, \\pi_{i-1})</span>  consisting of the current counter, output, and proof, one can use the SNARK prover to obtain the next tuple  <span class="math">(i, z_i, \\pi_i)</span>  by setting  <span class="math">z_i := F(z_{i-1})</span>  and computing the proof  <span class="math">\\pi_i := \\mathcal{P}(\\mathrm{urs}, R, \\mathbf{x}_i, t, \\mathbf{w}_i)</span>  for the instance  <span class="math">\\mathbf{x}_i := (R, i, z_i)</span>  and witness  <span class="math">\\mathbf{w}_i := (z_{i-1}, \\pi_{i-1})</span>  (and a certain time bound  <span class="math">t</span> ). Note that we have set  <span class="math">M := R</span> , so that (the description of)  <span class="math">R</span>  is part of the primary input to  <span class="math">R</span> . A tuple  <span class="math">(i, z_i, \\pi_i)</span>  can then be verified by running the SNARK verifier, as  <span class="math">\\mathcal{V}(\\mathrm{urs}, R, \\mathbf{x}_i, t, \\pi_i)</span>  for  <span class="math">\\mathbf{x}_i := (R, i, z_i)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We refer the reader to [BCCT13] for details on how to prove the above construction secure. The aspect that we are interested to raise here is that the program  <span class="math">R</span>  is tasked to simulate itself, essentially working as a universal machine. This means that every elementary operation of  <span class="math">R</span> , and in particular of  <span class="math">F</span> , needs to be simulated by  <span class="math">R</span>  in its execution. This essentially means that the computation time of  <span class="math">R</span> , which dictates the cost of each proof composition, is at least a constant  <span class="math">c &amp;gt; 1</span>  times the size of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . This multiplicative overhead on the size of the circuit  </span>F$ , while asymptotically irrelevant, is a significant overhead in concrete efficiency.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(2) Recursion with preprocessing. We describe how to leverage preprocessing in order to avoid universal simulation, and in particular to avoid any multiplicative performance overheads in recursive composition. Intuitively, preprocessing provides a "cryptographic simplification" to the requisite recursion, by enabling us to replace the description of the computation with a succinct cryptographic commitment to it.</p>

    <p class="text-gray-300">Let  <span class="math">(\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  be a preprocessing SNARK for circuits. Recursion is realized via a circuit  <span class="math">R</span>  that depends on  <span class="math">\\mathsf{urs}</span>  and  <span class="math">F</span> , and checks one invocation of  <span class="math">F</span>  and a prior proof. The circuit  <span class="math">R</span>  is defined as follows:</p>

    <p class="text-gray-300">Primary input: a tuple  <span class="math">\\mathbf{x} = (\\mathrm{i}\\mathbf{v}\\mathbf{k},i,z_{i})</span>  consisting of an index verification key  <span class="math">\\mathrm{i}\\mathbf{v}\\mathbf{k}</span> , counter  <span class="math">i</span> , and claimed output  <span class="math">z_{i}</span> . (We later set  <span class="math">\\mathrm{i}\\mathbf{v}\\mathbf{k} := \\mathrm{i}\\mathbf{v}\\mathbf{k}_{R}</span>  to achieve recursion.)</p>

    <p class="text-gray-300">Auxiliary input: a tuple  <span class="math">\\mathbf{w} = (z_{i-1}, \\pi_{i-1})</span>  consisting of a previous output  <span class="math">z_{i-1}</span>  and corresponding SNARK proof  <span class="math">\\pi_{i-1}</span>  that attests to its correctness.</p>

    <p class="text-gray-300">Code:  <span class="math">R(\\mathbf{x}, \\mathbf{w})</span>  accepts if  <span class="math">z_i = F(z_{i-1})</span>  and, if  <span class="math">i &amp;gt; 1</span> ,  <span class="math">\\mathcal{V}(\\mathrm{urs}, \\mathrm{ivk}, \\mathbf{x}_{i-1}, \\pi_{i-1}) = 1</span>  where  <span class="math">\\mathbf{x}_{i-1} := (\\mathrm{ivk}, i-1, z_{i-1})</span> .</p>

    <p class="text-gray-300">The circuit  <span class="math">R</span>  can be used for recursive composition as follows. In the offline phase, we run the indexer  <span class="math">\\mathcal{I}</span>  on the circuit  <span class="math">R</span> , obtaining a long index proving key  <span class="math">\\mathrm{ipk}_R</span>  and a short index verification key  <span class="math">\\mathrm{ivk}_R</span>  that can be used to produce and validate SNARKs with respect to the circuit  <span class="math">R</span> . Subsequently, in the online phase, one can use the prover  <span class="math">\\mathcal{P}</span>  to go from a tuple  <span class="math">(i - 1, z_{i-1}, \\pi_{i-1})</span>  to a new tuple  <span class="math">(i, z_i, \\pi_i)</span>  by letting  <span class="math">z_i := F(z_{i-1})</span>  and  <span class="math">\\pi_i := \\mathcal{P}(\\mathrm{urs}, \\mathrm{ipk}_R, \\mathbf{x}_i, \\mathbf{w}_i)</span>  for the instance  <span class="math">\\mathbf{x}_i := (\\mathrm{ivk}_R, i, z_i)</span>  and witness  <span class="math">\\mathbf{w}_i := (z_{i-1}, \\pi_{i-1})</span> . Note that we have set  <span class="math">\\mathrm{ivk} := \\mathrm{ivk}_R</span> , so that the verification key  <span class="math">\\mathrm{ivk}_R</span>  is part of the primary input to the circuit  <span class="math">R</span> . A tuple  <span class="math">(i, z_i, \\pi_i)</span>  can then be verified by running the SNARK verifier, as  <span class="math">\\mathcal{V}(\\mathrm{urs}, \\mathrm{ivk}_R, \\mathbf{x}_i, \\pi_i)</span>  for  <span class="math">\\mathbf{x}_i := (\\mathrm{ivk}_R, i, z_i)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Crucially, the circuit  <span class="math">R</span>  does not perform any universal simulation involving the circuit  <span class="math">F</span> , and in particular does not incur multiplicative overheads. Indeed,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . This was enabled by preprocessing, which let us provide the index verification key  </span>\\mathrm{ivk}_R<span class="math">  as input to the circuit  </span>R$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In fact, preprocessing is <em>already</em> part of the efficient approach to recursive composition in <em>[x1]</em>. There the preprocessing SNARK uses a structured, rather than uniform, reference string but the benefits of preprocessing are analogous (even when the reference string depends on the circuit or a bound on it).</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">In summary:</h4>

    <p class="text-gray-300">preprocessing SNARKs play an important role in efficient recursive composition. Our first milestone is post-quantum and transparent preprocessing SNARKs, which we then use to achieve post-quantum and transparent recursive composition.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.2 From holographic proofs to preprocessing with random oracles</h3>

    <p class="text-gray-300">We describe the main ideas behind Theorem 1, which provides a transformation that compiles any holographic IOP for an indexed relation <span class="math">\\mathcal{R}</span> into a corresponding preprocessing SNARG for <span class="math">\\mathcal{R}</span>. See Section 10 for details.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Warmup: holographic PCPs.</h4>

    <p class="text-gray-300">We first consider the case of PCPs, a special case of IOPs. Recall that the Micali transformation <em>[x23]</em> compiles a (non-holographic) PCP into a (non-preprocessing) SNARG. We modify this transformation to compile a <em>holographic</em> PCP into a <em>preprocessing</em> SNARG, by using the fact that the SNARG verifier output by the Micali transformation invokes the PCP verifier as a black box.</p>

    <p class="text-gray-300">In more detail, the main feature of a holographic PCP is that the PCP verifier does not receive the index as an explicit input but, rather, makes a small number of queries to an encoding of the index given as an oracle. If we apply the Micali transformation to the holographic PCP, we obtain a SNARG verifier that must answer queries by the PCP verifier to the encoded index. If we simply provided the index as an input to the SNARG verifier, then we cannot achieve succinct verification and so would not obtain a preprocessing SNARG. Instead, we let the SNARG indexer compute the encoded index, compute a Merkle tree over it, and output the corresponding root as an <em>index verification key</em> for the SNARG verifier. We can then have the SNARG prover extend the SNARG proof with answers to queries to the encoded index, certified by authentication paths relative to the index verification key. In this way the SNARG verifier can use the answers in the SNARG proof to answer the queries to the encoded index by the underlying PCP verifier.</p>

    <p class="text-gray-300">This straightforward modification to the Micali transformation works: one can prove that if the soundness error of the holographic PCP is <span class="math">\\epsilon</span> then the soundness error of the preprocessing SNARG is <span class="math">t\\epsilon+O(t^{2}\\cdot 2^{-\\lambda})</span> against <span class="math">t</span>-query adversaries in the random oracle model. (A similar expression holds for quantum adversaries.)</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">General case: holographic IOPs.</h4>

    <p class="text-gray-300">While efficient constructions of holographic PCPs are not known, in this paper we show how to construct an efficient holographic IOP (see Section 2.3). Hence we are actually interested in compiling holographic IOPs. In this case our starting point is the BCS transformation <em>[x5]</em>, which compiles a (non-holographic) IOP into a (non-prepreprocessing) SNARG. We adopt a similar strategy as above: we modify the BCS transformation to compile a <em>holographic</em> IOP into a <em>preprocessing</em> SNARG, using the fact that the SNARG verifier output by the BCS transformation invokes the IOP verifier as a black box. Indeed, the main feature of a holographic IOP is the fact that the IOP verifier makes a small number of queries to an encoding of the index given as an oracle. Therefore the SNARG indexer can output the Merkle root of the encoded index as an index verification key, which subsequently the SNARG verifier can use to authenticate answers about the encoded index claimed by the SNARG prover.</p>

    <p class="text-gray-300">An important technical difference here is the fact that the soundness error of the resulting preprocessing SNARG is not related to the soundness error of the holographic IOP but, instead, to its <em>state-restoration</em> (SR) soundness error, a stronger notion of soundness introduced in <em>[x5]</em>. Namely, we prove that if the SR soundness error of the holographic PCP is <span class="math">\\epsilon_{\\mathrm{sr}}(t)</span> then the soundness error of the preprocessing SNARG is <span class="math">\\epsilon_{\\mathrm{sr}}(t)+O(t^{2}\\cdot 2^{-\\lambda})</span>. This phenomenon is inherited from the (unmodified) BCS transformation.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Proof of knowledge.</h4>

    <p class="text-gray-300">All known constructions of PCD from SNARGs require that the SNARG is an <em>argument of knowledge</em> (i.e., it is a SNARK). We show that if the holographic IOP is a (state-restoration)</p>

    <p class="text-gray-300">proof of knowledge (PoK), our transformation yields a preprocessing SNARK. In the simple non-adaptive setting this can be shown straightforwardly from known properties of the BCS transformation. However, in order to provide the strongest possible evidence for the existence of SNARKs satisfying the requirements for our IVC/PCD construction (see Section 2.5), we prove a stronger <em>adaptive</em> knowledge soundness property, which is not known to hold for the standard BCS transformation. We show that a standard modification of the BCS transformation achieves this stronger notion for a wide class of holographic IOPs.</p>

    <p class="text-gray-300">Post-quantum security. A primary contribution of this work is to construct post-quantum preprocessing SNARKs (and to show that these yield post-quantum PCD). Using techniques developed in <em>[x21, x13]</em>, we show that our transformation yields a preprocessing SNARG in the QROM. Here the relevant soundness notion of the holographic IOP is the <em>round-by-round</em> (RBR) soundness error, defined in <em>[x7]</em>.</p>

    <p class="text-gray-300">Moreover, if the holographic IOP is <em>round-by-round knowledge sound</em>, as defined in <em>[x13]</em>, our transformation yields a preprocessing SNARK in the QROM; this establishes, for the first time, the existence of adaptively-secure SNARKs in the QROM. We prove security by exhibiting a universal quantum extractor. As in the classical case, we prove a strong adaptive knowledge soundness property that is a close analogue for the property required in our IVC/PCD construction.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.3 An efficient holographic proof for constraint systems</h3>

    <p class="text-gray-300">We describe the main ideas behind Theorem 2, which provides an efficient construction of a holographic IOP for rank-1 constraint satisfiability (R1CS). See Definition 1 for the indexed relation representing this problem.</p>

    <p class="text-gray-300">Our starting point: Marlin. Our construction borrows ideas from the <em>algebraic holographic proof</em> (AHP) underlying Marlin, a pairing-based zkSNARK due to <em>[x10]</em>. An AHP is similar to a holographic IOP, except that the indexer and the prover (both honest and malicious) send <em>low-degree univariate polynomials</em> rather than evaluations of functions. The verifier may evaluate these polynomials at any point in the field.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To understand how AHPs and holographic IOPs differ, it is instructive to consider how one might construct a holographic IOP from an AHP. A natural approach is to construct the indexer and prover for the hIOP as follows: run the indexer/prover of the AHP, and whenever the indexer/prover outputs a polynomial, evaluate it and send this evaluation as the oracle. There are several issues with this approach. First, hIOPs require a stronger soundness guarantee: soundness must hold against malicious provers that send <em>arbitrary</em> oracles. Second, evaluating the polynomial requires selecting a set <span class="math">L\\subseteq\\mathbb{F}</span> over which to evaluate it. In general, since the verifier in the AHP may query any point in <span class="math">\\mathbb{F}</span>, we would need to take <span class="math">L:=\\mathbb{F}</span>, which is prohibitively expensive for the indexer and prover if <span class="math">\\mathbb{F}</span> is much larger than the instance size (as it often is, for both soundness and application reasons). Third, assuming that one manages to decouple <span class="math">L</span> and <span class="math">\\mathbb{F}</span>, the soundness error of one invocation of the AHP will (at best) decrease with $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> instead of </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which requires somehow reducing the soundness error of the AHP to, say, </span>1/2^{\\lambda}<span class="math">, and simply re-running in parallel the AHP for </span>\\lambda-\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ would be expensive in all relevant parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first issue could be resolved by composing the resulting protocol with a low-degree test. This introduces technicalities because we cannot hope to check that the oracle is exactly low-degree (as required in an AHP) — we can only check that the oracle is <em>close</em> to low-degree. The best way to resolve the second issue depends on the AHP itself, and would likely involve out-of-domain sampling <em>[x3]</em>. Finally, resolving the third issue may not be possible in general (in fact, we do not see how resolve it for the AHP in Marlin).</p>

    <p class="text-gray-300">These above issues show that, despite some similarities, there are markedly <em>different</em> design considerations on hIOPs versus AHPs. For this reason, while we will follow some of the ideas outlined above, we do not take the Marlin AHP as a black box. Instead, we will draw on the ideas underlying the Marlin AHP in order to build a suitable hIOP for this paper. Along the way, we also show how to reduce the round complexity of</p>

    <p class="text-gray-300">the Marlin AHP from 3 to 2, an ideas that we use to significantly improve the efficiency of our construction.</p>

    <p class="text-gray-300">Aurora. The structure of our holographic IOP, like the Marlin AHP, follows the one of Aurora <em>[x1]</em>, an IOP for R1CS that we now briefly recall. Given an R1CS instance <span class="math">(A,B,C)</span>, the prover sends to the verifier <span class="math">f_{z}</span>, the RS-encoding of a vector <span class="math">z</span>, and three oracles <span class="math">f_{A},f_{B},f_{C}</span> which are purportedly the RS-encodings of the three vectors <span class="math">Az,Bz,Cz</span> respectively. The prover and verifier then engage in subprotocols to prove that (i) <span class="math">f_{A},f_{B},f_{C}</span> are indeed encodings of <span class="math">Az,Bz,Cz</span>, and (ii) <span class="math">f_{A}\\cdot f_{B}-f_{C}</span> is an encoding of the zero vector.</p>

    <p class="text-gray-300">Together these checks ensure that <span class="math">(A,B,C)</span> is a satisfiable instance of R1CS. Testing (ii) is a straightforward application of known probabilistic checking techniques, and can be achieved with a logarithmic-time verifier. The primary challenge in the Aurora protocol (and protocols based on it) is testing (i).</p>

    <p class="text-gray-300">In the Aurora protocol this is achieved via a reduction to univariate sumcheck, a univariate analogue of the sumcheck protocol in <em>[x11]</em>. Univariate sumcheck also has a logarithmic verifier, but the reduction itself runs in time linear in the number of nonzero entries in the matrices <span class="math">A,B,C</span>. A key technical contribution of the Marlin AHP is showing how to shift most of the cost of the reduction to the indexer in order to reduce the online cost of verification to logarithmic, as we now explain.</p>

    <p class="text-gray-300">Challenges. We describe the original lincheck protocol of <em>[x1]</em>, and explain why it is not holographic. The lincheck protocol, on input a matrix <span class="math">M\\in\\mathbb{F}^{k\\times k}</span> and RS-encodings of vectors <span class="math">\\vec{x},\\vec{y}\\in\\mathbb{F}^{k}</span>, checks whether <span class="math">\\vec{x}=M\\vec{y}</span>. It makes use of the following two facts: (i) for a vector of linearly-independent polynomials <span class="math">\\vec{u}\\in\\mathbb{F}[X]^{k}</span> and any vectors <span class="math">\\vec{x},\\vec{y}\\in\\mathbb{F}^{k}</span>, if <span class="math">\\vec{x}\\neq\\vec{y}</span> then the polynomials <span class="math">\\langle\\vec{u},\\vec{x}\\rangle</span> and <span class="math">\\langle\\vec{u},\\vec{y}\\rangle</span> are distinct, and so differ with high probability at a random <span class="math">\\alpha\\in\\mathbb{F}</span>, and (ii) for any matrix <span class="math">M\\in\\mathbb{F}^{k\\times k}</span>, <span class="math">\\langle\\vec{u},M\\vec{y}\\rangle=\\langle\\vec{u}M,\\vec{y}\\rangle</span>. The lincheck verifier sends a random <span class="math">\\alpha\\in\\mathbb{F}</span> to the prover, and the prover then convinces the verifier that <span class="math">\\langle\\vec{u}M,\\vec{y}\\rangle(\\alpha)-\\langle\\vec{u},\\vec{x}\\rangle(\\alpha)=0</span> using the univariate sumcheck protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This requires the verifier to evaluate the low-degree extensions of <span class="math">\\vec{u}_{\\alpha}</span> and <span class="math">\\vec{u}_{\\alpha}M</span> at a point <span class="math">\\beta\\in\\mathbb{F}</span>, where <span class="math">\\vec{u}_{\\alpha}\\in\\mathbb{F}^{k}</span> is obtained by evaluating each entry of <span class="math">\\vec{u}</span> at <span class="math">\\alpha</span>. This is equivalent to evaluating the bivariate polynomials <span class="math">u(X,Y),u_{M}(X,Y)\\in\\mathbb{F}[X,Y]</span>, obtained respectively by extending <span class="math">\\vec{u},\\vec{u}M</span> over <span class="math">Y</span>, at a random point in <span class="math">(\\alpha,\\beta)\\in\\mathbb{F}^{2}</span>. By choosing <span class="math">\\vec{u}</span> appropriately, we can ensure that <span class="math">u(X,Y)</span> can be evaluated in logarithmic time <em>[x2]</em>. But, without help from an indexer, evaluating <span class="math">u_{M}(\\alpha,\\beta)</span> requires time $\\Omega(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A natural suggestion in the holographic setting is to have the indexer evaluate <span class="math">u_{M}</span> over some domain <span class="math">S\\subseteq\\mathbb{F}\\times\\mathbb{F}</span>, and make this evaluation part of the encoded index. This does achieve the goal of logarithmic verification time. Unfortunately, the degree of <span class="math">u_{M}</span> in each variable is about <span class="math">k</span>, and so even writing down the coefficients of <span class="math">u_{M}</span> requires time <span class="math">\\Omega(k^{2})</span>, which for sparse <span class="math">M</span> is quadratic in $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the Marlin lincheck the indexer instead computes a certain <em>linear-size</em> (polynomial) encoding of <span class="math">M</span>, which the verifier then uses in a multi-round protocol with the prover to evaluate <span class="math">u_{M}</span> at its chosen point. Our holographic lincheck improves upon this protocol, reducing the number of rounds by one; we describe it next.</p>

    <p class="text-gray-300">Our holographic lincheck. Recall from above that the lincheck verifier needs to check that <span class="math">\\langle\\vec{u},\\vec{x}\\rangle</span> and <span class="math">\\langle\\vec{u}M,\\vec{y}\\rangle</span> are equal as polynomials in <span class="math">X</span>. To do this, it will choose a random <span class="math">\\alpha\\in\\mathbb{F}</span> and send it to the prover, then engage in the univariate sumcheck protocol to show that <span class="math">\\sum_{h}u(\\alpha,h)\\hat{x}(h)-u_{M}(\\alpha,h)\\hat{y}(h)=0</span>, where <span class="math">\\hat{x},\\hat{y}</span> are low-degree extensions of <span class="math">x</span> and <span class="math">y</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To verify the above sum, the verifier must compute <span class="math">u(\\alpha,\\beta)</span> and <span class="math">u_{M}(\\alpha,\\beta)</span> for some <span class="math">\\beta\\in\\mathbb{F}</span>. The former can be computed by the verifier in logarithmic time as discussed; for the latter, we ask the prover to help. Specifically, we show that <span class="math">u_{M}\\equiv\\hat{M}^{<em>}</span>, the unique bivariate low-degree extension of a matrix <span class="math">M^{</em>}</span> which can be computed in quasilinear time from <span class="math">M</span> (and in particular has $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). Hence to show that </span>u_{M}(\\alpha,\\beta)=\\gamma<span class="math"> the prover and verifier can engage in a holographic <em>matrix arithmetization</em> protocol for </span>M^{<em>}<span class="math"> to show that </span>\\hat{M}^{</em>}(\\alpha,\\beta)=\\gamma<span class="math">. Marlin makes use of a similar matrix arithmetization protocol, but for </span>M<span class="math"> itself, with a subprotocol to compute </span>u_{M}<span class="math"> from </span>\\hat{M}$, which is a cost that we completely eliminate. Another improvement is that for our matrix arithmetization protocol we can efficiently reduce soundness error even</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">when using a low-degree test, due to its non-recursive use of the sumcheck protocol.</p>

    <p class="text-gray-300">Matrix arithmetization. Our matrix arithmetization protocol is a holographic IOP for computing the low-degree extension of a matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span> (provided in the index). It is useful here to view <span class="math">M</span> in its sparse representation as a map <span class="math">\\langle M\\rangle\\colon K\\to H\\times H\\times\\mathbb{F}</span> for some <span class="math">K\\subseteq\\mathbb{F}</span>, where if <span class="math">\\langle M\\rangle(k)=(a,b,\\gamma)</span> for some <span class="math">k\\in K</span> then <span class="math">M_{a,b}=\\gamma</span>, and <span class="math">M_{a,b}=0</span> otherwise.</p>

    <p class="text-gray-300">The indexer computes <span class="math">\\mathsf{row},\\mathsf{col},\\mathsf{val}</span> which are the unique low-degree extensions of the functions <span class="math">K\\to\\mathbb{F}</span> induced by restricting <span class="math">\\langle M\\rangle</span> to its first, second, and third coordinates respectively, and outputs their evaluations over <span class="math">L</span>. It is not hard to verify that</p>

    <p class="text-gray-300"><span class="math">\\hat{M}(\\alpha,\\beta)=\\sum_{k\\in K}L_{H,\\mathsf{row}(k)}(\\alpha)L_{H,\\mathsf{col}(k)}(\\beta)\\hat{\\mathsf{val}}(k)\\enspace,</span></p>

    <p class="text-gray-300">for any <span class="math">\\alpha,\\beta\\in\\mathbb{F}</span>, where <span class="math">L_{H,a}</span> is the polynomial of minimal degree which is <span class="math">1</span> on <span class="math">a</span> and <span class="math">0</span> on <span class="math">H\\setminus\\{a\\}</span>. In order to check this equation using the sumcheck protocol we must modify the right-hand side: the summand must be a polynomial which can be efficiently evaluated. To this end, we make use of the “unnormalized Lagrange” polynomial <span class="math">u_{H}(X,Y):=(v_{H}(X)-v_{H}(Y))/(X-Y)</span> from <em>[x1]</em>. This polynomial has the property that for every <span class="math">a,b\\in H</span>, <span class="math">u_{H}(a,b)</span> is <span class="math">0</span> if <span class="math">a\\neq b</span> and nonzero if <span class="math">a=b</span>; and it is easy to evaluate at every point in <span class="math">\\mathbb{F}</span>. By having the indexer renormalize <span class="math">\\hat{\\mathsf{val}}</span> appropriately, we obtain</p>

    <p class="text-gray-300"><span class="math">\\hat{M}(X,Y)\\equiv\\sum_{k\\in K}u_{H}(\\mathsf{row}(k),\\alpha)u_{H}(\\hat{\\mathsf{col}}(k),\\beta)\\hat{\\mathsf{val}}(k)\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have made progress, but now the summand has quadratic degree: $\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> because we <em>compose</em> the polynomials </span>u_{H}<span class="math"> and </span>\\mathsf{row},\\hat{\\mathsf{col}}$. Next we show how to avoid this composition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that since the image of <span class="math">K</span> under <span class="math">\\mathsf{row},\\hat{\\mathsf{col}}</span> is contained in <span class="math">H</span>, <span class="math">v_{H}(\\mathsf{row}(k))=v_{H}(\\hat{\\mathsf{col}}(k))=0</span>. Hence the rational function</p>

    <p class="text-gray-300"><span class="math">\\frac{v_{H}(\\alpha)}{(\\alpha-\\mathsf{row}_{\\langle M\\rangle}(X))}\\cdot\\frac{v_{H}(\\beta)}{(\\beta-\\hat{\\mathsf{col}}_{\\langle M\\rangle}(X))}\\cdot\\hat{\\mathsf{val}}_{\\langle M\\rangle}(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">agrees with the summand on <span class="math">K</span>; it is a rational extension of the summands. Moreover, the degrees of the numerator and denominator of the function are both $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Now it remains to design a protocol to check the sum of a univariate rational function.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rational sumcheck. Suppose that we want to check that <span class="math">\\sum_{k\\in K}p(k)/q(k)=\\gamma</span>, where <span class="math">p,q</span> are low-degree polynomials. First, we have the prover send the (evaluation of the) unique polynomial <span class="math">f</span> of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> which agrees with </span>p/q<span class="math"> on </span>K<span class="math">; that is, the unique low-degree extension of </span>p/q<span class="math"> viewed as a function from </span>K<span class="math"> to </span>\\mathbb{F}<span class="math">. We can use the <em>standard</em> univariate sumcheck protocol from <em>[x2]</em> to test that </span>\\sum_{k\\in K}f(k)=\\gamma$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It then remains to check that <span class="math">f</span> does indeed agree with <span class="math">p/q</span> on <span class="math">K</span>. This is achieved using standard techniques: if <span class="math">p(k)/q(k)=f(k)</span> for all <span class="math">k\\in K</span>, then <span class="math">p(k)=q(k)\\cdot f(k)</span> for all <span class="math">k\\in K</span> (at least if <span class="math">q</span> does not vanish on <span class="math">K</span>). Then <span class="math">p-q\\cdot f</span> is a polynomial vanishing on <span class="math">K</span>, and so is divisible by <span class="math">v_{K}</span>. This can be checked using low-degree testing; for more details, see Section 5. Moreover, the degree of this equation is $\\max(\\deg(p),\\deg(q)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; in the matrix arithmetization protocol, this is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of knowledge and zero knowledge. Our full protocol for R1CS is a proof of knowledge, because when the verifier accepts with high enough probability it is possible to decode <span class="math">f_{z}</span> into a satisfying assignment. We further achieve zero knowledge via techniques inherited from <em>[x1]</em>. (Note that zero knowledge is not relevant for the matrix arithmetization protocol because the constraint matrices <span class="math">A,B,C</span> are public.)</p>

    <p class="text-gray-300">2.4 Post-quantum and transparent preprocessing</p>

    <p class="text-gray-300">If we apply the compiler described in Section 2.2 (as captured in Theorem 1) to the efficient holographic proof for R1CS described in Section 2.3 (as captured in Theorem 2) then we obtain an efficient preprocessing zkSNARK for R1CS that is unconditionally secure in the (quantum) random oracle model (as captured in Theorem 3). We refer to the resulting construction as Fractal.</p>

    <p class="text-gray-300">Implementation. We have implemented Fractal by extending the libiop library to support generic compilation of holographic proofs into preprocessing SNARGs, and then writing in code our holographic proof for R1CS. Our implementation supports a range of security levels and fields. (The only requirement on the field is that it contains certain smooth subgroups.) See Section 12.1 for more details on the implementation.</p>

    <p class="text-gray-300">Clearly, the security of our implementation relies on the random oracle methodology applied to preprocessing SNARGs produced by our compiler, namely, we assume that if we replace every call to the random oracle with a call to a cryptographic hash function then the resulting construction, which formally is in the URS model, inherits the relevant security properties that we proved in the (quantum) random oracle model.</p>

    <p class="text-gray-300">Evaluation. We have evaluated Fractal, and its measured performance is consistent with asymptotic predictions. In particular, the polylogarithmic argument size and verification time quickly become smaller than native witness size and native execution time as the size of the checked computation increases.</p>

    <p class="text-gray-300">We additionally compare the costs of Fractal to prior preprocessing SNARGs, finding that (a) our prover and verifier times are comparable to prior constructions; (b) argument sizes are larger than prior constructions (that have an SRS). The larger argument sizes of Fractal are nonetheless comparable with other post-quantum transparent <em>non</em>-preprocessing SNARGs. See Section 13.1 for more details on evaluation.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">2.5 Post-quantum and transparent recursive composition</h3>

    <p class="text-gray-300">We summarize the ideas behind our contributions to recursive composition of SNARKs.</p>

    <p class="text-gray-300">Proof-carrying data. Recursive composition is captured by a cryptographic primitive called <em>proof-carrying data</em> (PCD) <em>[x10, x7]</em>, which will be our goal. Consider a network of nodes, where each node receives messages from other nodes, performs some local computation, and sends the result on. PCD is a primitive that allows us to check the correctness of such distributed computations by recursively producing proofs of correctness for each message. Here “correctness” is locally specified by a <em>compliance predicate</em> <span class="math">\\Phi</span>, which takes as input the messages received by a node and the message sent by that node (and possibly some auxiliary local data). A distributed computation is then considered <span class="math">\\Phi</span>-<em>compliant</em> if, for each node, the predicate <span class="math">\\Phi</span> accepts the node’s messages (and auxiliary local data).</p>

    <p class="text-gray-300">PCD captures proving the iterated application of a circuit as in Section 2.1, in which case the distributed computation evolves along a path. PCD also captures more complex topologies, which is useful for supporting distributed computations on long paths (via “depth-reduction” techniques <em>[x29, x7]</em>) and for expressing dynamic distributed computations (such as MapReduce computations <em>[x11]</em>).</p>

    <p class="text-gray-300">From random oracle model to the URS model. While we have so far discussed constructions that are unconditionally secure in the (quantum) random oracle model, for recursion we now leave this model (by heuristically instantiating the random oracle with a cryptographic hash function) and start from preprocessing SNARKs in the URS model. The reason for this is far from mundane (and not motivated by implementation), as we now explain. The verifiers from Theorem 1 make calls to the random oracle, and therefore proving that the verifier has accepted would require using a SNARK that can prove the correctness of computations <em>in a relativized world where the oracle is a random function</em>. There is substantial evidence from complexity theory that such SNARKs do not exist (e.g., probabilistic proofs do not relativize with respect to a random</p>

    <p class="text-gray-300">oracle [CCRR92; For94; CL20]). By instantiating the random oracle, all oracle calls can be “unrolled” into computations that do not involve oracle gates, and thus we can prove the correctness of the resulting computation. We stress that random oracles cannot be securely instantiated in the general case [CGH04], and so we will assume that there is a secure instantiation of the random oracle for the preprocessing SNARKs produced via Theorem 1 (which, in particular, preserves proof of knowledge).</p>

    <p class="text-gray-300">From SNARK to PCD. We prove that any preprocessing SNARK in the URS model can be transformed into a preprocessing PCD scheme in the URS model (Theorem 11.5). The construction, described in Section 11, realizes recursive composition by following the template given in Section 2.1, except that the compliance predicate  <span class="math">\\Phi</span>  may expect multiple input messages. This construction simplifies that of [BCCT13] for preprocessing SNARKs in the SRS model: we do not need to rely on collision-resistant hash functions to shrink the verification key ivk because we require it to be succinct, as captured in Lemma 11.8.</p>

    <p class="text-gray-300">Security against quantum adversaries. A key feature of our result (Theorem 11.5) is that we prove that if the SNARK is secure (i.e., is a proof of knowledge) against quantum adversaries then so is the resulting PCD scheme (i.e., it is also a proof of knowledge). Therefore, if we assume that FRACTAL achieves proof of knowledge against quantum adversaries when the random oracle is suitably instantiated, then by applying our result to FRACTAL we obtain a post-quantum preprocessing PCD scheme in the URS model.</p>

    <p class="text-gray-300">For this result we require a suitable definition of adaptive proof of knowledge in the quantum setting. Our definition was chosen to achieve the following two goals: it must be strong enough to imply security for our PCD construction, and it must have a (Q)ROM analogue that is fulfilled by FRACTAL.</p>

    <p class="text-gray-300">We highlight below two important issues that arose in finding this definition.</p>

    <p class="text-gray-300">The proof of [BCCT13] uses the fact that, in the classical case, we may assume that the adversary is deterministic by selecting its randomness. This is not the case for quantum adversaries, as a quantum circuit can create its own randomness (e.g. by measuring a qubit in superposition). This means that we must be careful in defining the proof-of-knowledge property we require of the underlying SNARK. In particular, we must ensure that when we recursively extract proofs, these proofs are consistent with previously extracted proofs. For deterministic adversaries, this is implied by the proof of knowledge definition in [BCCT13]; for quantum adversaries, it is not.</p>

    <p class="text-gray-300">A further complication arises when defining proof of knowledge in the QROM. In the classical (non-programmable) ROM, we can view the extractor and verifier as machines interacting with the same "real" oracle; in particular, the extractor simply passes the adversary's queries to the real oracle and notes the answers. Hence we can ask for an extraction guarantee of the type: "whenever the verifier accepts, the extractor succeeds" (this is the definition in [BCCT13]). In the QROM, no-cloning precludes this view: the extractor cannot act as an intermediary between the adversary and an external random oracle but must instead simulate the oracle itself.</p>

    <p class="text-gray-300">Given these issues, we arrive at the following knowledge soundness definition. We observe that the function of the strong extraction guarantee in [BCCT13] is to ensure closeness in distribution between the outputs of the prover and the extractor. (This is similar to the witness-extended emulation property introduced by [Lin03].) To emulate this in the QROM, we simply impose the closeness-in-distribution requirement</p>

    <p class="text-gray-300">explicitly. In particular, we require that if the prover outputs some auxiliary information, the joint distribution of that auxiliary information and the adaptively-chosen instance is maintained in the output of the extractor. We show that this is both achievable in the QROM and sufficient for PCD in the standard model.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.6 The verifier as a constraint system</h3>

    <p class="text-gray-300">In order to recursively compose Fractal (the preprocessing zkSNARK discussed in Section 2.4), we need to express Fractal’s verifier as a constraint system. The size of this constraint system is crucial because this determines the threshold at which recursive composition becomes possible. Towards this goal, we design and implement a constraint system that applies to a general class of verifiers, as outlined below. Fractal’s verifier is obtained as an instantiation within this class. See Section 12.2 for details.</p>

    <p class="text-gray-300">Hash computations introduced by the compiler. Our compiler (Theorem 1) transforms any holographic IOP into a corresponding preprocessing SNARG, while preserving relevant zero knowledge or proof of knowledge properties. The preprocessing SNARG verifier makes a black-box use of the holographic IOP verifier, which means that we can design a single (parametrized) constraint system representing the transformation that works for any holographic IOP. All additional computations introduced by the compiler involve cryptographic hash functions (which heuristically instantiate the random oracle). In particular, there are two types of hash computations: (1) a hash chain computation used to derive the randomness for each round of the holographic IOP verifier, based on the Merkle roots provided by the preprocessing SNARG prover; and (2) verification of Merkle tree authentication paths in order to ensure the validity of the query answers provided by the preprocessing SNARG prover. We design generic constraint systems for both of these tasks. Since we are designing constraint systems it is more efficient to consider multiple hash functions specialized to work in different roles: a hash function to absorb inputs or squeeze outputs in the hash chain; a hash function to hash leaves of the Merkle tree; a many-to-one hash function for the internal nodes of the Merkle tree; and others.</p>

    <p class="text-gray-300">Choice of hash function. While our implementation is generic with respect to the aforementioned hash functions (replacing any one of them with another is straightforward), the choice of hash function is nonetheless critical for concrete efficiency as we now explain. Expressing standard cryptographic hash functions, such as from the SHA or Blake family, as a constraint system requires more than 20,000 constraints. While this is acceptable for certain applications, these costs are prohibitive for hash-intensive computations, as is the case for the verifiers output by our compiler. Fortunately, the last few years have seen exciting progress in the design of algebraic hash functions <em>[x1, x2, x3, x4, x5, x11]</em>, which by design can be expressed via a small number of arithmetic constraints over large finite fields. While this is an active research front, and in particular no standards have been agreed upon, many of the proposed functions are significantly cheaper than prior ones, and their security analyses are promising. In this work we decide to use one of these as our choice of hash function (Poseidon <em>[x5]</em>). We do not claim that this is the “best” choice among the currently proposed ones. (In fact, we know how to achieve better results via a combination of different choices.) We merely make one choice that we believe to be reasonable, and in particular suffices to demonstrate the feasibility of our methodology in practice.</p>

    <p class="text-gray-300">Holographic IOP computations. The constraint system that represents the holographic IOP verifier will, naturally, depend on the specific protocol that is provided as input to the compiler.</p>

    <p class="text-gray-300">That said, all known efficient IOPs, holographic or otherwise, are obtained as the combination of two ingredients: (1) a low-degree test for the Reed–Solomon (RS) code; and (2) an RS-encoded IOP, which is a protocol where the verifier outputs a set of algebraic claims, known as rational constraints, about the prover’s messages. Examples of IOPs that fall in this category include our holographic IOP for R1CS, as well as</p>

    <p class="text-gray-300">protocols for R1CS in <em>[x1, x2]</em> and for AIR in <em>[x3]</em>.</p>

    <p class="text-gray-300">We thus provide two constraint systems that target these two components. First, we provide a constraint system that realizes the FRI low-degree test <em>[x3]</em>, which is used in many efficient IOPs, including in our holographic IOP for R1CS. Second, we provide infrastructure to write constraint systems that express a desired RS-encoded IOP. This essentially entails specifying how many random elements the verifier should send in each round of the protocol, and then specifying constraints that express the rational constraints output by the verifier at the end of the RS-encoded IOP.</p>

    <p class="text-gray-300">We then use the foregoing infrastructure to express the verifier of our holographic IOP for R1CS as a constraint system. We note that the very same generic infrastructure would make it straightforward to express the verifiers of other protocols with the same structure <em>[x1, x3, x2]</em> and <em>[x2]</em>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 2.1 (succinct languages).</h6>

    <p class="text-gray-300">Our work in writing constraints for the verifier is restricted to non-uniform computation models such as R1CS (i.e., we are not concerned about the global structure of the constraint system). We do not claim to have an efficient way to express the same verifier via succinct languages such as AIR <em>[x3]</em> or Succinct-R1CS <em>[x2]</em>. Doing so remains an open problem that, if addressed, may lead to additional opportunities in recursive composition (through <em>non</em>-preprocessing SNARKs).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <p class="text-gray-300">We state time costs in terms of basic operations over a given field <span class="math">\\mathbb{F}</span>, and size costs in terms of field elements in <span class="math">\\mathbb{F}</span>. We use the “big-oh” notation <span class="math">O_{\\mathbb{F}}</span> to remind the reader that <span class="math">\\mathbb{F}</span>-operations and <span class="math">\\mathbb{F}</span>-elements have unit cost.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.1 Sparse representations of matrices</h3>

    <p class="text-gray-300">Our protocols leverage sparse representations of matrices for efficiency, following the definition below. The definition is primarily for convenience in the sense that any reasonable sparse representation of a matrix can be transformed, in linear time, into one that follows the definition that we use.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">Let <span class="math">H,K\\subseteq\\mathbb{F}</span>. A sparse representation of a matrix is a function <span class="math">\\langle M\\rangle\\colon K\\to H\\times H\\times\\mathbb{F}</span> that is injective when its output is restricted to <span class="math">H\\times H</span>. The matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span> is obtained from <span class="math">\\langle M\\rangle</span> by setting, for <span class="math">a,b\\in H</span>, <span class="math">M_{a,b}:=\\gamma</span> if there exists <span class="math">k\\in K</span> such that <span class="math">\\langle M\\rangle(k)=(a,b,\\gamma)</span> and <span class="math">M_{a,b}:=0</span> otherwise.</p>

    <p class="text-gray-300">Note that a matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span> has many possible sparse representations. In particular, we may choose any large enough <span class="math">K</span> and any injection from <span class="math">K</span> to <span class="math">H\\times H</span> that “covers” the nonzero entries of <span class="math">M</span>.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.2 Indexed relations</h3>

    <p class="text-gray-300">An <em>indexed relation</em> <span class="math">\\mathcal{R}</span> is a set of triples <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})</span> where <span class="math">\\mathbb{i}</span> is the index, <span class="math">\\mathbb{x}</span> the instance, and <span class="math">\\mathbb{w}</span> the witness; the corresponding <em>indexed language</em> <span class="math">\\mathcal{L}(\\mathcal{R})</span> is the set of pairs <span class="math">(\\mathbb{i},\\mathbb{x})</span> for which there exists a witness <span class="math">\\mathbb{w}</span> such that <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})\\in\\mathcal{R}</span>. For example, the indexed relation of satisfiable boolean circuits consists of triples where <span class="math">\\mathbb{i}</span> is the description of a boolean circuit, <span class="math">\\mathbb{x}</span> is an assignment some of the input wires, and <span class="math">\\mathbb{w}</span> is an assignment to the remaining input wires that makes the circuit output 0.</p>

    <p class="text-gray-300">In this paper we build protocols for the indexed relation that represents <em>rank-1 constraint satisfiability</em> (R1CS), a generalization of arithmetic circuits where the “circuit description” is given by coefficient matrices.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 3.2 (R1CS indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})=\\big{(}(\\mathbb{F},H,K,\\langle A\\rangle,\\langle B\\rangle,\\langle C\\rangle),(I,x),w\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">H,K</span> are subsets of <span class="math">\\mathbb{F}</span>, <span class="math">\\langle A\\rangle,\\langle B\\rangle,\\langle C\\rangle\\colon K\\to H\\times H\\times\\mathbb{F}</span> are sparse representations of <span class="math">H\\times H</span> matrices over <span class="math">\\mathbb{F}</span>, <span class="math">I</span> is a subset of <span class="math">H</span>, <span class="math">x\\in\\mathbb{F}^{I}</span>, <span class="math">w\\in\\mathbb{F}^{H\\setminus I}</span>, and <span class="math">z:=(x,w)\\in\\mathbb{F}^{H}</span> is a vector such that <span class="math">Az\\circ Bz=Cz</span>. (Here “<span class="math">\\circ</span>” denotes the entry-wise product between two vectors.)</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Remark 3.3.</h6>

    <p class="text-gray-300">The above definition can be generalized to the case where the matrices are <em>non-square</em>, namely, the matrices are in <span class="math">\\mathbb{F}^{H_{1}\\times H_{2}}</span> for possibly distinct domains <span class="math">H_{1},H_{2}\\subseteq\\mathbb{F}</span> <em>[x1]</em>. All results stated in this paper extend to this non-square case. Our focus on the square case is only for simplicity of exposition.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">3.3 Algebra</h3>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Polynomial encodings.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a finite field <span class="math">\\mathbb{F}</span>, subset <span class="math">S\\subseteq\\mathbb{F}</span>, and function <span class="math">f\\colon S\\to\\mathbb{F}</span> we denote by <span class="math">\\hat{f}</span> the (unique) univariate polynomial over <span class="math">\\mathbb{F}</span> with degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>\\hat{f}(a)=f(a)<span class="math"> for every </span>a\\in S<span class="math">. More explicitly, </span>\\hat{f}(X):=\\sum_{a\\in S}f(a)L_{a,S}(X)<span class="math">, where </span>L_{a,S}<span class="math"> (for </span>a\\in S<span class="math">) is the unique (Lagrange) polynomial of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>L_{a,S}(a)=1<span class="math"> and </span>L_{a,S}(b)=0<span class="math"> for all </span>b\\in S\\setminus\\{a\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">19</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reed–Solomon code. Given a subset <span class="math">L</span> of a field <span class="math">\\mathbb{F}</span> and degree bound $d &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we denote by </span>\\mathrm{RS}[L,d] \\subseteq \\mathbb{F}^L<span class="math"> all evaluations over </span>L<span class="math"> of univariate polynomials of degree at most </span>d$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {R S} [ L, d ] := \\left\\{f \\colon L \\to \\mathbb {F} \\text { s . t .} \\exists \\hat {f} \\in \\mathbb {F} [ X ] \\text { with } \\deg (\\hat {f}) \\leq d \\text { and } \\hat {f} (L) = f \\right\\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Whenever a polynomial <span class="math">\\hat{f}</span> as above exists, then <span class="math">\\hat{f}</span> is unique. The rate of <span class="math">\\mathrm{RS}[L,d]</span> is $\\rho \\coloneqq (d + 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in (0,1)<span class="math">, and its distance is </span>1 - \\rho<span class="math">. The message encoded by </span>f \\in \\mathrm{RS}[L,d]<span class="math"> is the restriction of </span>\\hat{f}<span class="math"> to a distinguished subset </span>H \\subseteq \\mathbb{F}<span class="math"> of size </span>d + 1<span class="math">. (Note that </span>H<span class="math"> need not be a subset of </span>L<span class="math">.) Observe that for every polynomial </span>\\hat{f} \\in \\mathbb{F}[X]<span class="math"> with degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> it holds that the word </span>f_{L} \\coloneqq \\hat{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}<span class="math"> is in </span>\\mathrm{RS}[L,\\deg (\\hat{f})]<span class="math"> (we will drop the subscript when the choice of domain </span>L<span class="math"> is clear from context). This means that there is a bijection between words in </span>\\mathrm{RS}[L,d]<span class="math"> and polynomials in </span>\\mathbb{F}[X]<span class="math"> of degree at most </span>d$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We frequently move between univariate polynomials over <span class="math">\\mathbb{F}</span> and their evaluations on domains <span class="math">L \\subseteq \\mathbb{F}</span>. We use plain letters like <span class="math">f, g, h</span> to denote functions from <span class="math">L</span> to <span class="math">\\mathbb{F}</span>, and "hatted letters" <span class="math">\\hat{f}, \\hat{g}, \\hat{h}</span> to denote the polynomials of minimal degree that agree with the corresponding functions on <span class="math">L</span>. Conversely, if we "drop the hat" from a polynomial, then we consider its evaluation over <span class="math">L</span> (which will always be larger than the degree).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Domains with subgroup structure. For a finite field <span class="math">\\mathbb{F}</span>, by "subgroup of <span class="math">\\mathbb{F}</span>" we mean either a subgroup of the additive group of <span class="math">\\mathbb{F}</span> or a subgroup of <span class="math">\\mathbb{F}^*</span>. By "coset of <span class="math">\\mathbb{F}</span>" we mean a coset of a subgroup of <span class="math">\\mathbb{F}</span> (additive or multiplicative). Throughout the paper we assume that the domain <span class="math">L</span> for the Reed–Solomon code has "smooth" subgroup structure, meaning that it factors as a direct product of small (i.e., constant-size) subgroups. Under this assumption we can encode a message using the Reed–Solomon code in time $O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. This assumption is also required by the low-degree test that we use [BBHR18; BGKS19].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vanishing polynomials. For a finite field <span class="math">\\mathbb{F}</span> and subset <span class="math">S \\subseteq \\mathbb{F}</span>, we denote by <span class="math">v_{S}</span> the unique non-zero monic polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero on </span>S<span class="math">; </span>v_{S}<span class="math"> is called the vanishing polynomial of </span>S<span class="math">. If </span>S<span class="math"> is a coset in </span>\\mathbb{F}<span class="math"> then the coefficients of </span>v_{S}<span class="math"> can be found in time </span>O_{\\mathbb{F}}(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and subsequently </span>v_{S}<span class="math"> can be evaluated at any point in time </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In the holographic setting we can have the indexer find </span>v_{S}<span class="math"> for any </span>S<span class="math"> of interest, so that the verifier can evaluate </span>v_{S}<span class="math"> in time </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In this paper we assume that this is the case, so that for any coset </span>S<span class="math"> in </span>\\mathbb{F}<span class="math"> we can evaluate its vanishing polynomial at any point in time </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Derivative of vanishing polynomials. We rely on various properties of the bivariate polynomial <span class="math">u_{S}</span> related to the formal derivative of <span class="math">v_{S}</span>, first exploited to obtain efficient probabilistic proofs in [BCGGRS19]. For a finite field <span class="math">\\mathbb{F}</span> and subset <span class="math">S \\subseteq \\mathbb{F}</span>, we define</p>

    <div class="my-4 text-center"><span class="math-block">u _ {S} (X, Y) := \\frac {v _ {S} (X) - v _ {S} (Y)}{X - Y} ,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is a polynomial of individual degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> because </span>X - Y<span class="math"> divides </span>X^i - Y^i<span class="math"> for any positive integer </span>i<span class="math">. Note that </span>u_S(X, X)<span class="math"> is the formal derivative of the vanishing polynomial </span>v_S(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The bivariate polynomial <span class="math">u_{S}(X,Y)</span> satisfies two useful algebraic properties. First, it is strongly related to the Lagrange polynomials <span class="math">L_{a,S}</span> for <span class="math">a \\in S</span>. Specifically, <span class="math">u_{S}(X,a) \\equiv u_{S}(a,X) \\equiv L_{a,S}(X) \\cdot u_{S}(a,a)</span> for all <span class="math">a \\in S</span>. In particular, this implies that the polynomials <span class="math">(u_{S}(X,a))_{a \\in S}</span> are linearly independent. Second, the (unique) low-degree extension (in <span class="math">Y</span>) of the vector <span class="math">(u_{S}(X,a))_{a \\in S} \\in \\mathbb{F}[X]^{S}</span> is precisely <span class="math">u_{S}(X,Y)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">S</span> is a coset in <span class="math">\\mathbb{F}</span>, an expression for <span class="math">u_{S}(X,Y)</span> can be found in time $O_{\\mathbb{F}}(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and subsequently one can use this expression to evaluate </span>u_{S}(X,Y)<span class="math"> at any point </span>(\\alpha, \\beta) \\in \\mathbb{F}^2<span class="math"> in time </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Univariate sumcheck for cosets.</strong> For <span class="math">S \\subseteq \\mathbb{F}, \\hat{g} \\in \\mathbb{F}[X], \\sigma \\in \\mathbb{F}</span>, define the polynomial:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma_ {S} (\\hat {g}, \\sigma) := \\left\\{ \\begin{array}{l l} X \\hat {g} (X) + \\sigma /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\text{if } S \\text{ is a multiplicative coset of } \\mathbb {F} \\\\ \\hat {g} (X) + \\sigma X ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} / \\sum_ {\\alpha \\in S} \\alpha^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} &amp; \\text{if } S \\text{ is an additive coset of } \\mathbb {F} \\end{array} \\right..</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Note that <span class="math">\\Sigma_S(\\cdot, \\cdot)</span> may be viewed as an arithmetic circuit. We will use the following lemma from [BCRSVW19], which leads to a univariate analogue of the multivariate sumcheck protocol [LFKN92].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.4 ([BCRSVW19]).</strong> Let <span class="math">S</span> be a coset of <span class="math">\\mathbb{F}</span>, and let <span class="math">\\hat{f} \\in \\mathbb{F}[X]</span> be such that $\\deg(\\hat{f}) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then </span>\\sum_{\\alpha \\in S} \\hat{f}(\\alpha) = \\sigma<span class="math"> if and only if there exists </span>\\hat{g}<span class="math"> with </span>\\deg(\\hat{g}) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> such that </span>\\hat{f} \\equiv \\Sigma_S(\\hat{g}, \\sigma)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">4 Definition of holographic IOPs</p>

    <p class="text-gray-300">A holographic IOP for an indexed relation <span class="math">\\mathcal{R}</span> is specified by a tuple <span class="math">\\mathsf{HOL}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>, where <span class="math">\\mathbf{I}</span> is the <em>indexer</em>, <span class="math">\\mathbf{P}</span> the <em>prover</em>, and <span class="math">\\mathbf{V}</span> the <em>verifier</em>. The indexer is a deterministic polynomial-time algorithm, while the prover and verifier are probabilistic polynomial-time interactive algorithms. In an offline phase, given an index <span class="math">\\dot{\\mathfrak{s}}</span>, the indexer <span class="math">\\mathbf{I}</span> computes an encoding of <span class="math">\\dot{\\mathfrak{s}}</span>, denoted <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span>. Subsequently, in an online phase, the prover <span class="math">\\mathbf{P}</span> receives as input a triple <span class="math">(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}},\\mathbf{\\mathbbm{w}})</span>, while the verifier <span class="math">\\mathbf{V}</span> receives as input <span class="math">\\mathbf{\\mathbbm{x}}</span> and is granted oracle access to the encoded index <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span>. The online phase consists of multiple rounds, and in each round the verifier <span class="math">\\mathbf{V}</span> sends a message <span class="math">\\rho_{i}</span> and the prover <span class="math">\\mathbf{P}</span> replies with a proof string <span class="math">\\Pi_{i}</span>, which the verifier can query at any location. At the end of the interaction, the verifier <span class="math">\\mathbf{V}</span> accepts or rejects.</p>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{HOL}</span> has perfect completeness and soundness error <span class="math">\\epsilon</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every index-instance-witness triple <span class="math">(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}},\\mathbf{\\mathbbm{w}})\\in\\mathcal{R}</span>, the probability that <span class="math">\\mathbf{P}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}},\\mathbf{\\mathbbm{w}})</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathbf{\\mathbbm{x}})</span> to accept in the interactive oracle protocol is <span class="math">1</span>.</li>

      <li>Soundness. For every index-instance pair <span class="math">(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}})\\notin\\mathcal{L}(\\mathcal{R})</span> and prover <span class="math">\\tilde{\\mathbf{P}}</span>, the probability that <span class="math">\\tilde{\\mathbf{P}}</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathbf{\\mathbbm{x}})</span> to accept in the interactive oracle protocol is at most <span class="math">\\epsilon</span>.</li>

    </ul>

    <p class="text-gray-300">The <em>round complexity</em> <span class="math">\\mathsf{k}</span> is the number of back-and-forth message exchanges between the verifier and the prover. The <em>proof length</em> <span class="math">\\mathsf{L}</span> is the sum of the length of the encoded index plus the lengths of all proof strings sent by the prover. The <em>query complexity</em> <span class="math">\\mathsf{q}</span> is the total number of queries made by the verifier; this includes queries to the encoded index and to the oracles sent by the prover.</p>

    <p class="text-gray-300">The holographic IOPs that we construct achieve the stronger property of <em>knowledge soundness</em> and optionally also <em>zero knowledge</em>. We define both of these properties below.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Knowledge soundness.</h4>

    <p class="text-gray-300"><span class="math">\\mathsf{HOL}</span> has knowledge error <span class="math">\\kappa</span> if there exists a probabilistic polynomial-time extractor <span class="math">\\mathbf{E}</span> such that for every instance <span class="math">\\dot{\\mathfrak{s}}</span>, witness <span class="math">\\mathbf{\\mathbbm{x}}</span>, and unbounded prover <span class="math">\\tilde{\\mathbf{P}}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\Big{[}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}},\\mathbf{\\mathbbm{w}})\\not\\in\\mathcal{R}\\ \\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\mathbf{\\mathbbm{w}}\\leftarrow\\mathbf{E}^{\\tilde{\\mathbf{P}}}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}})\\Big{]}\\geq\\Pr\\Big{[}\\langle\\tilde{\\mathbf{P}},\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathbf{\\mathbbm{x}})\\rangle=1\\Big{]}-\\kappa\\ \\ ,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathbf{E}^{\\tilde{\\mathbf{P}}}</span> means that we give the extractor <em>black-box</em> access to <span class="math">\\tilde{\\mathbf{P}}</span>. We provide this definition purely for illustrative purposes. In this paper we only use the stronger knowledge notions described in Section 4.2.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Zero knowledge.</h4>

    <p class="text-gray-300"><span class="math">\\mathsf{HOL}</span> has (perfect) zero knowledge with query bound <span class="math">\\mathsf{b}</span> if there exists a probabilistic polynomial-time simulator <span class="math">\\mathbf{S}</span> such that for every <span class="math">(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}},\\mathbf{\\mathbbm{w}})\\in\\mathcal{R}</span> and <span class="math">\\mathsf{b}</span>-query algorithm <span class="math">\\tilde{\\mathbf{V}}</span> the random variables <span class="math">\\mathrm{View}(\\mathbf{P}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}},\\mathbf{\\mathbbm{w}}),\\tilde{\\mathbf{V}})</span> and <span class="math">\\mathbf{S}^{\\tilde{\\mathbf{V}}}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}})</span>, defined below, are identical. (An algorithm is <span class="math">\\mathsf{b}</span>-query if it makes <em>less than</em> <span class="math">\\mathsf{b}</span> queries in total to any oracles it has access to.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{View}(\\mathbf{P}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}},\\mathbf{\\mathbbm{w}}),\\tilde{\\mathbf{V}})</span> is the <em>view</em> of <span class="math">\\tilde{\\mathbf{V}}</span>, i.e., is the random variable <span class="math">(r,a_{1},\\ldots,a_{q})</span> where <span class="math">r</span> is <span class="math">\\tilde{\\mathbf{V}}</span>’s randomness and <span class="math">a_{1},\\ldots,a_{q}</span> are the responses to <span class="math">\\tilde{\\mathbf{V}}</span>’s queries determined by the oracles sent by <span class="math">\\mathbf{P}</span>.</li>

      <li><span class="math">\\mathbf{S}^{\\tilde{\\mathbf{V}}}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}})</span> is the output of <span class="math">\\mathbf{S}(\\dot{\\mathfrak{s}},\\mathbf{\\mathbbm{x}})</span> when given straightline access to <span class="math">\\tilde{\\mathbf{V}}</span> (<span class="math">\\mathbf{S}</span> may interact with <span class="math">\\tilde{\\mathbf{V}}</span>, <em>without rewinding</em>, by exchanging messages with <span class="math">\\tilde{\\mathbf{V}}</span> and answering its oracle queries), <em>prepended</em> with <span class="math">\\tilde{\\mathbf{V}}</span>’s randomness <span class="math">r</span>. Note that <span class="math">r</span> could be of super-polynomial size, so <span class="math">\\mathbf{S}</span> cannot sample <span class="math">r</span> on <span class="math">\\tilde{\\mathbf{V}}</span>’s behalf and then output it; instead, we restrict <span class="math">\\mathbf{S}</span> to not see <span class="math">r</span>, and prepend <span class="math">r</span> to <span class="math">\\mathbf{S}</span>’s output.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{HOL}</span> is <em>honest-verifier</em> zero knowledge if the above holds with <span class="math">\\tilde{\\mathbf{V}}:=\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathbf{\\mathbbm{x}})</span>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Public coins.</h4>

    <p class="text-gray-300"><span class="math">\\mathsf{HOL}</span> is <em>public-coin</em> if each verifier message to the prover is a random string. This means that the verifier’s randomness is its messages <span class="math">\\rho_{1},\\ldots,\\rho_{\\mathsf{k}}\\in\\{0,1\\}^{<em>}</span> and possibly additional randomness <span class="math">\\rho_{\\mathsf{k}+1}\\in\\{0,1\\}^{</em>}</span> used after the interaction. All verifier queries can be postponed, without loss of generality, to a query phase that occurs after the interactive phase with the prover.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">Reed-Solomon encoded IOPs (RS-encoded IOPs) were introduced in [BCRSVW19] to provide a formal framework for separating protocol design from the technical issues introduced by low-degree testing. We adopt this formalism in this paper as well, with straightforward modifications for the holographic setting.</p>

    <p class="text-gray-300">Informally, in an RS-encoded IOP, the prover and verifier engage in a public-coin IOP interaction and, after the interaction, the verifier outputs a set of algebraic claims about the prover's messages. The completeness condition requires that in the "yes" case, when the verifier interacts with the honest prover, the output claims are true with probability 1. The soundness condition requires that in the "no" case, when the verifier interacts with a malicious prover, at least one of the output claims will be false with high probability no matter what the prover's messages are. The holographic setting introduces the sole difference that the verifier's algebraic claims may include statements about the codewords output by the indexer.</p>

    <p class="text-gray-300">In more detail, by "algebraic claim" we specifically mean a rational constraint, defined next.</p>

    <p class="text-gray-300"><strong>Definition 4.1.</strong> A rational constraint is a tuple <span class="math">\\mathbf{c} = (p,q,d)</span> where <span class="math">p\\colon \\mathbb{F}^{1 + \\ell}\\to \\mathbb{F}</span> and <span class="math">q\\colon \\mathbb{F}\\to \\mathbb{F}</span> are arithmetic circuits, and <span class="math">d\\in \\mathbb{N}</span> is a degree bound. The arithmetic circuits <span class="math">(p,q)</span> and a list of words <span class="math">f_{1},\\ldots ,f_{\\ell}\\colon L\\to \\mathbb{F}</span> jointly define the word <span class="math">(p,q)[f_1,\\dots ,f_\\ell ]\\colon L\\to \\mathbb{F}</span> given by</p>

    <div class="my-4 text-center"><span class="math-block">\\forall a \\in L, (p, q) [ f _ {1}, \\dots , f _ {\\ell} ] (a) := \\frac {p (a , f _ {1} (a) , \\dots , f _ {\\ell} (a))}{q (a)}.</span></div>

    <p class="text-gray-300">A rational constraint <span class="math">\\mathbf{c} = (p,q,d)</span> is satisfied with respect to <span class="math">f_{1},\\ldots ,f_{\\ell}</span> if <span class="math">(p,q)[f_1,\\dots ,f_\\ell ]\\in \\mathrm{RS}[L,d]</span>.</p>

    <p class="text-gray-300">When describing rational constraints, we will often use the shorthand notation “<span class="math">\\deg (\\hat{f}) \\leq d</span>”, where <span class="math">f \\colon L \\to \\mathbb{F}</span> is defined as a rational equation over some oracles. This should be taken to mean the rational constraint <span class="math">\\mathbf{c} = (p,q,d)</span> that is naturally induced by the expression that defines <span class="math">f</span>.</p>

    <p class="text-gray-300">A special type of rational constraint is a boundary constraint, defined next.</p>

    <p class="text-gray-300"><strong>Definition 4.2.</strong> A boundary constraint is a rational constraint that expresses a condition such as “<span class="math">\\hat{f}(\\alpha) = \\beta</span>” for some word <span class="math">f \\colon L \\to \\mathbb{F}</span> and elements <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>. Such a condition is represented via the rational constraint <span class="math">\\mathbf{c} = (p, q, \\deg(\\hat{f}) - 1)</span> where <span class="math">p(X, Y) := Y - \\beta</span> and <span class="math">q(X) := X - \\alpha</span>, which can be summarized as “<span class="math">\\deg(\\hat{g}) \\leq \\deg(\\hat{f}) - 1</span>” where <span class="math">g(a) := (f(a) - \\beta)/(a - \\alpha)</span>. We denote this constraint simply by “<span class="math">\\hat{f}(\\alpha) = \\beta</span>”.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following we use <span class="math">\\mathrm{RS}[L,(d_1,\\ldots ,d_k)]\\subseteq (\\mathbb{F}^k)^L</span> to denote the interleaved Reed-Solomon code over <span class="math">L</span> with degree bounds <span class="math">(d_{1},\\ldots ,d_{k})</span>, i.e., the set of $k\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> matrices where the </span>i<span class="math">-th row is a codeword of </span>\\mathrm{RS}[L,d_i]<span class="math"> (which itself is all evaluations over </span>L<span class="math"> of univariate polynomials of degree at most </span>d_{i}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A Reed-Solomon encoded holographic IOP (RS-hIOP) for an indexed relation <span class="math">\\mathcal{R}</span> is a tuple</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I}, \\mathbf {P}, \\mathbf {V}, \\{\\vec {d} _ {\\mathbf {I}}, \\vec {d} _ {\\mathbf {P}, 1}, \\dots , \\vec {d} _ {\\mathbf {P}, k} \\}\\right)</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{I}</span> is a deterministic algorithm, <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> are probabilistic interactive algorithms, and <span class="math">\\vec{d}_{\\mathbf{I}} \\in \\mathbb{N}^{\\ell_0}, \\vec{d}_{\\mathbf{P},i} \\in \\mathbb{N}^{\\ell_i}</span> are vectors of degree bounds, that satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Degree bounds:</strong> On input any <span class="math">\\mathbb{i}</span>, the indexer <span class="math">\\mathbf{I}</span> outputs a codeword of <span class="math">\\mathrm{RS}[L,\\vec{d}_{\\mathbf{I}}]</span>. Moreover, on input any <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w}) \\in \\mathcal{R}</span> and for every round <span class="math">i</span>, the <span class="math">i</span>-th message of <span class="math">\\mathbf{P}(\\mathbb{i},\\mathbb{x},\\mathbb{w})</span> is a codeword of <span class="math">\\mathrm{RS}[L,\\vec{d}_{\\mathbf{P},i}]</span>.</p>

    <p class="text-gray-300"><strong>Completeness:</strong> For every <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})\\in \\mathcal{R}</span>, all rational constraints output by <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathbb{i})}(\\mathbb{x})</span> after interacting with <span class="math">\\mathbf{P}(\\mathbb{i},\\mathbb{x},\\mathbb{w})</span> are satisfied with respect to <span class="math">\\mathbf{I}(\\mathbb{i})</span> and <span class="math">\\mathbf{P}(\\mathbb{i},\\mathbb{x},\\mathbb{w})</span>'s messages with probability 1.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">For every <span class="math">(\\mathfrak{i},\\mathfrak{z})\\notin\\mathcal{L}(\\mathcal{R})</span> and unbounded malicious prover <span class="math">\\tilde{\\mathbf{P}}</span> whose <span class="math">i</span>-th message is a codeword of <span class="math">\\mathrm{RS}[L,\\vec{d}_{\\mathbf{P},i}]</span>, all rational constraints output by <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathfrak{z})</span> after interacting with <span class="math">\\tilde{\\mathbf{P}}</span> are satisfied with respect to <span class="math">\\mathbf{I}(\\mathfrak{i})</span> and the prover’s messages with probability at most <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Often we will write that <span class="math">\\mathbf{V}</span> “accepts”, which means that all of the rational constraints it outputs are satisfied, or that it “rejects”, which means that at least one rational constraint is not satisfied.</p>

    <p class="text-gray-300">We conclude by discussing useful complexity measures for RS-encoded IOPs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The query evaluation time <span class="math">t_{\\mathtt{q}}</span> is the natural complexity measure for <span class="math">\\mathbf{V}</span>, and equals the sum of the query evaluation times of the rational constraints output by <span class="math">\\mathbf{V}</span>. The query evaluation time of a single rational constraint <span class="math">\\mathbf{c}=(p,q,d)</span> is the time required to compute <span class="math">(p,q)<a href="a">f_{1},\\ldots,f_{\\ell}</a>\\in\\mathbb{F}</span> given <span class="math">a\\in L</span> and oracle access to <span class="math">f_{1},\\ldots,f_{\\ell}</span> (and possibly additional information provided by the indexer). That is, it is the time needed to (construct and) evaluate the arithmetic circuits <span class="math">(p,q)</span> at a single point.</li>

      <li>The maximum degree is a pair <span class="math">(d_{\\mathtt{c}},d_{\\mathtt{e}})\\in\\mathbb{N}\\times\\mathbb{N}</span> defined as follows.</li>

    </ul>

    <p class="text-gray-300"><span class="math">d_{\\mathtt{c}}</span> is the “constraint degree”, defined as the maximum specified degree of any oracle sent by the prover and any constraint output by the verifier, i.e., <span class="math">d_{\\mathtt{c}}:=\\max\\ \\vec{d}_{\\mathbf{P},1}\\cup\\cdots\\cup\\vec{d}_{\\mathbf{P},\\mathtt{k}}\\cup\\{d:\\mathbf{V}\\ \\text{outputs}\\ (p,q,d)\\}</span>.</p>

    <p class="text-gray-300"><span class="math">d_{\\mathtt{e}}</span> is the “effective degree”, which is a quantity arising from the compilation from an RS-encoded IOP to a standard IOP via low-degree testing that is defined as follows:</p>

    <p class="text-gray-300"><span class="math">d_{\\mathtt{e}}:=\\max\\{d_{\\mathtt{c}}\\}\\cup\\Big{\\{}\\mathrm{deg}(p;\\vec{d}_{\\mathbf{I}},\\vec{d}_{\\mathbf{P},1},\\ldots,\\vec{d}_{\\mathbf{P},\\mathtt{k}}),d+\\mathrm{deg}(q):\\mathbf{V}\\ \\text{outputs}\\ (p,q,d)\\Big{\\}}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathrm{deg}(P;\\vec{d})</span> for an arithmetic circuit <span class="math">P\\colon\\mathbb{F}^{1+m}\\to\\mathbb{F}</span> and degree bounds <span class="math">d\\in\\mathbb{F}^{m}</span> denotes the degree of the composed polynomial <span class="math">P(X,Q_{1}(X),\\ldots,Q_{m}(X))</span> when <span class="math">\\mathrm{deg}(Q_{i})=d_{i}</span>. Note that <span class="math">d_{\\mathtt{e}}\\geq d_{\\mathtt{c}}</span>.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">4.2 Stronger notions of soundness</h3>

    <p class="text-gray-300">Aside from the standard notion of soundness above, there are two further soundness notions that arise when constructing non-interactive arguments from IOPs. These are round-by-round soundness <em>[x1, x10]</em> and state-restoration soundness <em>[x11]</em>, adapted to holographic IOPs. We discuss these below.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Round-by-round soundness.</h4>

    <p class="text-gray-300">We begin by defining the notion of a (partial) transcript of an IOP, which means all proof strings and verifier messages up to a point where the prover is about to move.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 4.3.</h6>

    <p class="text-gray-300">A transcript <span class="math">\\mathtt{tr}</span> of a holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is a tuple of the form <span class="math">(\\Pi_{1},m_{1},\\ldots,\\Pi_{i},m_{i})</span> for some <span class="math">i\\in[\\mathtt{k}]</span>, where each <span class="math">\\Pi_{j}</span> is a prover (oracle) message and each <span class="math">m_{j}</span> is a verifier message. We denote the empty transcript by <span class="math">\\emptyset</span>. A transcript is full if <span class="math">i=\\mathtt{k}</span>, where <span class="math">\\mathtt{k}</span> is the round complexity of <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>.</p>

    <p class="text-gray-300">A protocol <span class="math">\\mathsf{HOL}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> has <em>round-by-round soundness error</em> <span class="math">\\epsilon_{\\mathtt{rbr}}</span> if there exists a function <span class="math">\\mathsf{State}</span> from the set of transcripts to <span class="math">\\{\\mathsf{accept},\\mathsf{reject}\\}</span> such that for every transcript <span class="math">\\mathtt{tr}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">(\\mathfrak{i},\\mathfrak{z})\\notin\\mathcal{L}(\\mathcal{R})</span> and <span class="math">\\mathtt{tr}=\\emptyset</span>, then <span class="math">\\mathsf{State}(\\mathfrak{i},\\mathfrak{z},\\mathtt{tr})=\\mathsf{reject}</span>;</li>

      <li>if <span class="math">\\mathsf{State}(\\mathfrak{i},\\mathfrak{z},\\mathtt{tr})=\\mathsf{reject}</span>, then <span class="math">\\mathsf{rbr}(\\mathtt{tr})\\leq\\epsilon_{\\mathtt{rbr}}</span> where</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{rbr}(\\mathtt{tr}):=\\max_{\\Pi}\\Pr_{m}\\left[\\mathsf{State}(\\mathfrak{i},\\mathfrak{z},\\mathtt{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)=\\mathsf{accept}\\right]\\ \\ ;$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathsf{State}(\\mathfrak{i},\\mathfrak{z},\\mathtt{tr})=\\mathsf{reject}</span> and <span class="math">\\mathtt{tr}</span> is a full transcript, then <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathfrak{z};\\mathtt{tr})</span> rejects.</li>

    </ul>

    <p class="text-gray-300">The notion of round-by-round soundness for RS-encoded holographic IOPs is as above, except that the maximum in the definition of rbr is taken over <span class="math">\\Pi_{i}\\in\\mathrm{RS}[L,\\vec{d}_{\\mathbf{P},i}]</span>, for tr a transcript of <span class="math">i-1</span> rounds, and the third condition above need only hold for full transcripts tr where <span class="math">\\Pi_{i}\\in\\mathrm{RS}[L,\\vec{d}_{\\mathbf{P},i}]</span> for all <span class="math">i</span>. In particular, it suffices to define <span class="math">\\mathsf{State}(\\mathbbm{i},\\mathbbm{z},\\mathsf{tr})</span> only for tr where the prover messages are of the prescribed degrees; otherwise, the state can be taken to be accept.</p>

    <p class="text-gray-300">Finally we recall the definition of round-by-round knowledge soundness from <em>[x10]</em>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for a relation <span class="math">\\mathcal{R}</span> has round-by-round knowledge error <span class="math">\\kappa_{\\mathrm{rbr}}</span> if there exists a function <span class="math">\\mathsf{State}</span> and a polynomial-time extractor <span class="math">\\mathbf{E}</span> such that for every index <span class="math">\\mathbbm{i}</span>, instance <span class="math">\\mathbbm{z}</span>, transcript <span class="math">\\mathsf{tr}</span> such that <span class="math">\\mathsf{State}(\\mathbbm{i},\\mathbbm{z},\\mathsf{tr})=\\mathsf{reject}</span>, and every oracle message <span class="math">\\Pi</span>, if $\\mathrm{Pr}_{m}[\\mathsf{State}(\\mathbbm{i},\\mathbbm{z},\\mathsf{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)=\\mathsf{accept}]>\\kappa_{\\mathrm{rbr}}<span class="math"> then </span>(\\mathbbm{i},\\mathbbm{z},\\mathbf{E}(\\mathbbm{i},\\mathbbm{z},\\mathsf{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi))\\in\\mathcal{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For RS-encoded holographic IOPs we relax the above so that <span class="math">\\mathbf{E}</span> need only succeed for tr where the prover messages are of the prescribed degrees.</p>

    <p class="text-gray-300">State-restoration soundness. State-restoration soundness captures the ability of the prover to cheat when it is able to rewind the verifier a bounded number of times. State-restoration soundness essentially exactly captures the soundness of non-interactive arguments derived from IOPs via the BCS transformation <em>[x1]</em>. In Section 10 we prove that this continues to be true when we modify the BCS transform to construct preprocessing non-interactive arguments from holographic IOPs. However here we do not define state-restoration soundness because in our proof of the compiler we will rely on the BCS transformation as a black box. We note only that if a protocol has round-by-round soundness error <span class="math">\\epsilon_{\\mathrm{rbr}}</span> then it has state-restoration soundness error <span class="math">\\epsilon_{\\mathrm{sr}}(t)\\leq t\\cdot\\epsilon_{\\mathrm{rbr}}</span>, where <span class="math">t</span> is the bound on the number of rewinds. This fact is relevant because in Section 8 we prove that our efficient holographic IOP for R1CS has small round-by-round soundness error.</p>

    <p class="text-gray-300">Knowledge soundness is somewhat delicate and so we discuss it in more detail. In this work we will use the following (fairly strong) definition for state-restoration knowledge soundness.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 4.5.</h6>

    <p class="text-gray-300">An IOP <span class="math">(\\mathbf{P},\\mathbf{V})</span> for a relation <span class="math">\\mathcal{R}</span> has state restoration knowledge error <span class="math">\\kappa_{\\mathrm{sr}}</span> if there exists a polynomial-time extractor <span class="math">\\mathbf{E}</span> such that for all <span class="math">\\mathbbm{i},\\mathbbm{z}</span> and every state-restoration prover <span class="math">\\tilde{\\mathbf{P}}</span>,</p>

    <p class="text-gray-300">\\[ \\mathrm{Pr}\\left[\\begin{array}[]{c c c}\\mathsf{tr}_{\\mathrm{sr}}\\text{ is accepting }\\wedge\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbbm{i},\\mathbbm{z},\\mathbbm{w})\\notin\\mathcal{R}\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c c c}\\mathsf{tr}_{\\mathrm{sr}}\\leftarrow\\langle\\tilde{\\mathbf{P}},\\mathbf{V}\\rangle_{\\mathrm{sr}}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathbbm{w}\\leftarrow\\mathbf{E}(\\mathbbm{i},\\mathbbm{z},\\mathsf{tr}_{\\mathrm{sr}})\\end{array}\\Big{]}\\leq\\kappa_{\\mathrm{sr}}\\enspace. \\]</p>

    <p class="text-gray-300">Note that the power of the extractor is limited compared to the definition given in <em>[x1]</em>; in particular, we do not allow the extractor even black-box access to the prover itself, only to a (state-restoration) transcript.</p>

    <p class="text-gray-300">If <span class="math">(\\mathbf{P},\\mathbf{V})</span> has round-by-round knowledge error <span class="math">\\kappa_{\\mathrm{rbr}}</span> then it has state-restoration knowledge error <span class="math">\\kappa_{\\mathrm{sr}}(t)\\leq t\\cdot\\kappa_{\\mathrm{rbr}}</span>. This can be seen as follows: recall that a state-restoration transcript <span class="math">\\mathsf{tr}_{\\mathrm{sr}}</span> consists of a collection of partial (standard) transcripts generated via the state restoration game. The state restoration extractor <span class="math">\\mathbf{E}</span> applies the RBR extractor to every partial transcript in <span class="math">\\mathsf{tr}_{\\mathrm{sr}}</span>, and outputs the first valid witness it obtains. Since <span class="math">\\mathsf{tr}_{\\mathrm{sr}}</span> is accepting and the empty transcript is rejecting, at least one such partial transcript changes state from reject to accept. Round-by-round knowledge error implies that if the RBR extractor fails for this transcript, this happens with probability at most <span class="math">\\kappa_{\\mathrm{rbr}}</span>; the result follows by a union bound.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 Sumcheck for rational functions</p>

    <p class="text-gray-300">We describe how to extend the univariate sumcheck protocol of <em>[x1]</em> from univariate <em>polynomials</em> to univariate <em>rational functions</em>. We thus obtain a protocol for checking the value of the sum of a rational function <span class="math">\\hat{p}(X)/\\hat{q}(X)\\in\\mathbb{F}(X)</span> over a subgroup <span class="math">K</span> of <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be the set of all pairs <span class="math">(\\mathbbm{x},\\mathbbm{w})=\\big{(}(\\mathbb{F},L,K,d_{p},d_{q},\\sigma),(p,q)\\big{)}</span> such that <span class="math">p\\in\\mathrm{RS}[L,d_{p}]</span>, <span class="math">q\\in\\mathrm{RS}[L,d_{q}]</span>, and <span class="math">\\hat{q}(a)\\neq 0</span> for all <span class="math">a\\in K</span>. The promise relation <span class="math">\\mathcal{R}_{\\mathrm{RSUM}}=(\\mathcal{R}_{\\mathrm{RSUM}}^{\\mathrm{YES}},\\mathcal{R}_{\\mathrm{RSUM}}^{\\mathrm{NO}})</span> is defined as follows: <span class="math">\\mathcal{R}_{\\mathrm{RSUM}}^{\\mathrm{YES}}</span> is the subset of pairs in <span class="math">\\mathcal{R}</span> such that <span class="math">\\sum_{a\\in K}\\hat{p}(a)/\\hat{q}(a)=\\sigma</span>, and <span class="math">\\mathcal{R}_{\\mathrm{RSUM}}^{\\mathrm{NO}}:=\\mathcal{R}\\setminus\\mathcal{R}_{\\mathrm{RSUM}}^{\\mathrm{YES}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\sigma\\in\\mathbb{F}</span> be the claimed value for the sum. We know from Lemma 3.4 that a polynomial <span class="math">\\hat{f}(X)</span> of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> sums to </span>\\sigma<span class="math"> over </span>K<span class="math"> if and only if there exists a polynomial </span>\\hat{g}(X)<span class="math"> with degree at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math"> such that </span>\\Sigma_{K}(\\hat{g},\\sigma)(X)<span class="math"> equals </span>\\hat{f}(X)$. While we do not know how to obtain an equivalence like this one for the case of rational functions, there is a natural approach to build on the case of polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover computes the <em>polynomial</em> <span class="math">\\hat{f}(X)</span> of minimal degree that agrees with the <em>rational function</em> <span class="math">\\hat{p}(X)/\\hat{q}(X)</span> on <span class="math">K</span>, and then sends (the evaluation of) the corresponding polynomial <span class="math">\\hat{g}</span> guaranteed by Lemma 3.4 (i.e., such that <span class="math">\\Sigma_{K}(\\hat{g},\\sigma)(X)\\equiv\\hat{f}(X)</span>). The verifier can check that <span class="math">\\Sigma_{K}(\\hat{g},\\sigma)(X)</span> sums to <span class="math">\\sigma</span> via the rational constraint “$\\deg(\\hat{g})\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math">”. Then the verifier is left to check that </span>\\Sigma_{K}(\\hat{g},\\sigma)(X)<span class="math"> agrees with </span>\\hat{p}(X)/\\hat{q}(X)<span class="math"> on </span>K<span class="math">, which is equivalent to checking that </span>\\Sigma_{K}(\\hat{g},\\sigma)(X)\\hat{q}(X)-\\hat{p}(X)<span class="math"> vanishes on </span>K<span class="math"> (as </span>\\hat{q}(a)\\neq 0<span class="math"> for all </span>a\\in K$), which can be done via a standard use of a second rational constraint.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-42" class="text-base font-medium mt-4">Construction 5.2 (rational sumcheck).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">(\\mathbbm{x},\\mathbbm{w})=\\big{(}(\\mathbb{F},L,K,d_{p},d_{q},\\sigma),(p,q)\\big{)}</span> be a pair in <span class="math">\\mathcal{R}</span>. In the rational sumcheck protocol, the honest prover <span class="math">\\mathbf{P}</span> receives as input <span class="math">(\\mathbbm{x},\\mathbbm{w})</span>, and sends a codeword $g\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2]<span class="math"> that is obtained as follows: compute the unique polynomial </span>\\hat{f}<span class="math"> of degree at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> that agrees with </span>\\hat{p}(X)/\\hat{q}(X)<span class="math"> on </span>K<span class="math">; compute the unique polynomial </span>\\hat{g}(X)<span class="math"> of degree at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math"> such that </span>\\Sigma_{K}(\\hat{g},\\sigma)(X)\\equiv\\hat{f}(X)<span class="math">; evaluate </span>\\hat{g}(X)<span class="math"> over </span>L<span class="math"> to obtain </span>g<span class="math">. The honest verifier </span>\\mathbf{V}<span class="math"> receives as input </span>\\mathbbm{x}<span class="math">, and outputs the following two rational constraints: “</span>\\deg(\\hat{g})\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math">” and “</span>\\deg(\\hat{e})\\leq d_{e}<span class="math">”, where </span>e\\colon L\\to\\mathbb{F}<span class="math"> is a function and </span>d_{e}\\in\\mathbb{N}$ is a degree bound that are defined as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\forall\\,a\\in L\\,,\\ e(a):=\\frac{\\Sigma_{K}(g,\\sigma)(a)\\cdot q(a)-p(a)}{v_{K}(a)}\\quad\\text{and}\\quad d_{e}:=\\max(d_{p},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1+d_{q})-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\enspace.$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Formally, the above is an <em>RS-encoded PCP of proximity</em> for <span class="math">\\mathcal{R}_{\\mathrm{RSUM}}</span> (see <em>[x1]</em> for definitions). For simplicity, in the lemma below we directly establish the properties that we need without this abstraction.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 5.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">(\\mathbbm{x},\\mathbbm{w})=\\big{(}(\\mathbb{F},L,K,d_{p},d_{q},\\sigma),(p,q)\\big{)}\\in\\mathcal{R}</span> be such that <span class="math">L\\cap K=\\emptyset</span>, <span class="math">K</span> is a subgroup of <span class="math">\\mathbb{F}</span>, and $\\max(d_{p},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1+d_{q})<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The protocol </span>(\\mathbf{P},\\mathbf{V})$ in Construction 5.2 satisfies the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Completeness</em>: if <span class="math">(\\mathbbm{x},\\mathbbm{w})\\in\\mathcal{R}_{\\mathrm{RSUM}}^{\\mathrm{YES}}</span> then <span class="math">\\mathbf{V}(\\mathbbm{x})</span> outputs rational constraints that are satisfied by <span class="math">(p,q,g)</span>, where <span class="math">g</span> is the oracle sent by the honest prover <span class="math">\\mathbf{P}(\\mathbbm{x},\\mathbbm{w})</span>.</li>

      <li><em>Soundness</em>: if <span class="math">(\\mathbbm{x},\\mathbbm{w})\\in\\mathcal{R}_{\\mathrm{RSUM}}^{\\mathrm{NO}}</span> then for every malicious prover <span class="math">\\tilde{\\mathbf{P}}</span> at least one of the rational constraints output by <span class="math">\\mathbf{V}(\\mathbbm{x})</span> is not satisfied by <span class="math">(p,q,g)</span>, where <span class="math">g</span> is the oracle sent by the malicious prover <span class="math">\\tilde{\\mathbf{P}}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The protocol has constraint degree $\\max(d_{p}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d_{q}-1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2)<span class="math"> and effective degree </span>\\max(d_{p},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1+d_{q})<span class="math">. The query evaluation time of the verifier is </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first argue completeness and then soundness.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Completeness.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">\\sum_{a\\in K}\\hat{p}(a)/\\hat{q}(a)=\\sigma</span>. The honest prover <span class="math">\\mathbf{P}</span> sends the polynomial <span class="math">\\hat{g}(X)</span> with degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math"> such that </span>\\Sigma_{K}(\\hat{g},\\sigma)(X)<span class="math"> agrees with </span>\\hat{p}(X)/\\hat{q}(X)<span class="math"> on </span>K<span class="math">; the existence of </span>\\hat{g}(X)<span class="math"> is guaranteed by Lemma 3.4. Since </span>\\hat{q}(a)\\neq 0<span class="math"> for all </span>a\\in K<span class="math">, we also have that </span>\\Sigma_{K}(\\hat{g},\\sigma)(a)\\cdot\\hat{q}(a)=\\hat{p}(a)$ for all</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">a \\in K</span> . Thus the polynomial  <span class="math">\\Sigma_K(\\hat{g}, \\sigma)(X) \\cdot \\hat{q}(X) - \\hat{p}(X)</span>  is divisible by the vanishing polynomial  <span class="math">v_K(X)</span> . We conclude that the two rational constraints " $\\deg(\\hat{g}) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2<span class="math"> &quot; and &quot; </span>\\deg(\\hat{e}) \\leq d_e$ " are satisfied.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that  <span class="math">\\sum_{a\\in K}\\hat{p} (a) / \\hat{q} (a)\\neq \\sigma</span> . Let  <span class="math">g</span>  be the oracle sent by  <span class="math">\\tilde{\\mathbf{P}}</span>  and suppose that the rational constraint "deg  $(\\hat{g})\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2<span class="math">  &quot; is satisfied (or else we are done). By Lemma 3.4 we know that  </span>\\sum_{a\\in K}\\Sigma_K(\\hat{g},\\sigma)(a) = \\sigma<span class="math"> . Hence there must exist  </span>a^<em>\\in K<span class="math">  such that  </span>\\Sigma_K(\\hat{g},\\sigma)(a^</em>)\\cdot \\hat{q} (a^<em>)\\neq \\hat{p} (a^</em>)<span class="math"> , so  </span>a^*<span class="math">  is not a root of the polynomial  </span>\\Sigma_K(\\hat{g},\\sigma)(X)\\cdot \\hat{q} (X) - \\hat{p} (X)<span class="math"> . By definition of  </span>e<span class="math"> , the polynomials  </span>\\Sigma_K(\\hat{g},\\sigma)(X)\\cdot \\hat{q} (X) - \\hat{p} (X)<span class="math">  and  </span>\\hat{e} (X)\\cdot v_{K}(X)<span class="math">  agree on  </span>L<span class="math"> . Since  </span>d_{e} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\max (d_{p},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 + d_{q}) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , if the rational constraint &quot;deg  </span>(\\hat{e})\\leq d_e<span class="math">  &quot; is also satisfied, then we can conclude that these two polynomials are identical, which is a contradiction because  </span>a^*<span class="math">  is a root of  </span>\\hat{e} (X)\\cdot v_{K}(X)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The verifier outputs a rational constraint on  <span class="math">g</span> , which is the oracle sent by the prover, and a rational constraint on  <span class="math">e</span> , which is the virtual oracle defined in Eq. (1). So the query evaluation time is dominated by the number of field operations to evaluate  <span class="math">e</span>  at a single point, which is  $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  (due to the need to evaluate the vanishing polynomial  </span>v_{K}$  at that point). The stated constraint and effective degrees can be obtained by keeping track of the degrees of the relevant real and virtual oracles in the protocol (as in the table) and then using the definitions in Section 4.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">oracle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">constraint degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">numerator degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denominator degree</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g</td>

            <td class="px-3 py-2 border-b border-gray-700">real</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">- 2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">e</td>

            <td class="px-3 py-2 border-b border-gray-700">virtual</td>

            <td class="px-3 py-2 border-b border-gray-700">de</td>

            <td class="px-3 py-2 border-b border-gray-700">max(dp,</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1 + dq)</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 5.4 (zero knowledge). In Section 6, the above construction will be used as a subprotocol to evaluate the arithmetization of a public matrix. For this reason, we do not require any zero knowledge properties of the above construction (and indeed, the construction as described is not zero knowledge). Nonetheless, it is relatively straightforward to obtain a zero knowledge variant of this construction by using bounded independence and zero knowledge sumcheck as in [BCRSVW19].</p>

    <p class="text-gray-300">6 Holographic lincheck</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We describe a holographic variant of the lincheck protocol of <em>[x1]</em>. The <em>lincheck problem</em> involves checking linear relations between encodings: given <span class="math">H\\subseteq\\mathbb{F}</span>, Reed–Solomon codewords <span class="math">f,g\\in\\mathrm{RS}[L,d]</span>, and matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span>, check that $\\hat{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}=M\\cdot\\hat{g}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math">. Below we consider matrices </span>M$ that are given in a <em>sparse representation</em> (see Definition 3.1), as the protocol that we describe leverages this sparsity for efficiency.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 6.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}</span> be the set of all pairs $(\\mathfrak{i},\\mathbbm{x},\\mathbbm{w})=\\big{(}(\\mathbb{F},L,H,K,d,\\langle M\\rangle),1^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(f_{1},f_{2})\\big{)}<span class="math"> such that </span>\\mathbb{F}<span class="math"> is a finite field, </span>L,H,K<span class="math"> are subsets of </span>\\mathbb{F}<span class="math">, </span>\\langle M\\rangle\\colon K\\to H\\times H\\times\\mathbb{F}<span class="math"> is a sparse representation of a matrix </span>M\\in\\mathbb{F}^{H\\times H}<span class="math">, </span>d\\in\\mathbb{N}<span class="math"> is a degree bound, and </span>f_{1},f_{2}\\in\\mathrm{RS}[L,d]<span class="math"> are codewords. The indexed promise relation </span>\\mathcal{R}_{\\mathrm{LIN}}=(\\mathcal{R}^{\\mathrm{YES}}_{\\mathrm{LIN}},\\mathcal{R}^{\\mathrm{NO}}_{\\mathrm{LIN}})<span class="math"> is such that </span>\\mathcal{R}^{\\mathrm{YES}}_{\\mathrm{LIN}}<span class="math"> is the subset of </span>\\mathcal{R}<span class="math"> with </span>\\hat{f}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}=M\\cdot\\hat{f}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math">, and </span>\\mathcal{R}^{\\mathrm{NO}}_{\\mathrm{LIN}}:=\\mathcal{R}\\setminus\\mathcal{R}^{\\mathrm{YES}}_{\\mathrm{LIN}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The goal of this section is to prove the following lemma.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 6.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $(\\mathfrak{i},\\mathbbm{x},\\mathbbm{w})=\\big{(}(\\mathbb{F},L,H,K,d,\\langle M\\rangle),1^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(f_{1},f_{2})\\big{)}\\in\\mathcal{R}<span class="math"> be such that </span>H,K<span class="math"> are subgroups of </span>\\mathbb{F}<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3<span class="math">, and </span>L\\cap(H\\cup K)=\\emptyset<span class="math">. The protocol </span>(\\mathbf{I},\\mathbf{P},\\mathbf{V})$ in Construction 6.8 satisfies the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Completeness</em>: if <span class="math">(\\mathfrak{i},\\mathbbm{x},\\mathbbm{w})\\in\\mathcal{R}^{\\mathrm{YES}}_{\\mathrm{LIN}}</span> then <span class="math">\\mathbf{V}(\\mathbbm{x})</span> outputs rational constraints that are satisfied by <span class="math">(f_{1},f_{2})</span> and the oracles sent by the honest prover <span class="math">\\mathbf{P}(\\mathfrak{i},\\mathbbm{x})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <em>Soundness</em>: if <span class="math">(\\mathfrak{i},\\mathbbm{x},\\mathbbm{w})\\in\\mathcal{R}^{\\mathrm{NO}}_{\\mathrm{LIN}}</span> then for every malicious prover <span class="math">\\tilde{\\mathbf{P}}</span> all of the rational constraints output by <span class="math">\\mathbf{V}(\\mathbbm{x})</span> are satisfied by <span class="math">(f_{1},f_{2})</span> and the oracles sent by <span class="math">\\tilde{\\mathbf{P}}</span> with probability at most $2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In particular, the construction has two rounds and RBR soundness error </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Moreover, the construction can be made zero knowledge; the RBR soundness error is then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover and indexer run in time $O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and the verifier’s query evaluation time is </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The constraint degree is </span>\\max(d-1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2,2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3)<span class="math"> and the effective degree is </span>\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1+d,3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Formally, Construction 6.8 is an RS-encoded IOP of proximity for <span class="math">\\mathcal{R}_{\\mathrm{LIN}}</span>. However, for simplicity, we directly establish the properties we need without this abstraction. The notion of zero knowledge is as usual for proximity notions: we require that if a malicious verifier <span class="math">\\tilde{\\mathbf{V}}</span> makes <span class="math">t</span> queries across all of the oracles available to it, the simulator can reproduce its view by making <span class="math">t</span> queries to <em>each of</em> the witness oracles.</p>

    <p class="text-gray-300">The remainder of this section proceeds as follows. In Section 6.1, we describe a subprotocol for checking an evaluation of the low-degree (bivariate) extension of a matrix. In Section 6.2, we describe how to use this subprotocol to build a holographic lincheck protocol, proving Lemma 6.2. Throughout this section we rely on the notion of a sparse representation of a matrix (see Section 3.1) and on facts about vanishing polynomials and their derivatives (see Section 3.3).</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">6.1 Holographic proof for sparse matrix arithmetization</h3>

    <p class="text-gray-300">The <em>bivariate low-degree extension</em> of a given matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span> is the unique polynomial <span class="math">\\hat{M}\\in\\mathbb{F}[X,Y]</span> of minimal degree such that <span class="math">\\hat{M}(a,b)=M_{a,b}</span> for all <span class="math">a,b\\in H</span>. We wish to check statements of the form “<span class="math">\\hat{M}(\\alpha,\\beta)=\\gamma</span>” for <span class="math">\\alpha,\\beta</span> chosen (almost) arbitrarily in <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Definition 6.3.</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{MAT}}</span> is the set of triples <span class="math">(\\mathfrak{i},\\mathbbm{x},\\mathbbm{w})=\\big{(}(\\mathbb{F},H,K,\\langle M\\rangle),(\\alpha,\\beta,\\gamma),\\bot\\big{)}</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">H</span> and <span class="math">K</span> are subsets of <span class="math">\\mathbb{F}</span>, <span class="math">\\langle M\\rangle\\colon K\\to H\\times H\\times\\mathbb{F}</span> is a sparse representation of a matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span>, <span class="math">\\alpha,\\beta,\\gamma\\in\\mathbb{F}</span> are field elements, and <span class="math">\\hat{M}(\\alpha,\\beta)=\\gamma</span>. (This relation has no witnesses.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{MAT}}</span> is tractable: one can check if <span class="math">\\hat{M}(\\alpha,\\beta)=\\gamma</span> in time $O_{\\mathbb{F}}(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> by directly computing the value of the low-degree extension </span>\\hat{M}(X,Y)<span class="math"> at </span>(\\alpha,\\beta)<span class="math">. Without holography, it is not possible to verify this equation in time </span>o_{\\mathbb{F}}(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> since in general </span>\\hat{M}(\\alpha,\\beta)<span class="math"> depends on every entry of </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show how to significantly reduce this cost via a protocol that holographically stores information about <span class="math">M</span> in the encoded index in order to achieve an online verification time of $O(\\log\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Our protocol relies on expressing the bivariate low-degree extension </span>\\hat{M}(X,Y)<span class="math"> in terms of univariate low-degree extensions that describe the non-zero entries of </span>M$. We explain this algebraic identity, and then how our protocol uses it.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given a sparse representation <span class="math">\\langle M\\rangle\\colon K\\to H\\times H\\times\\mathbb{F}</span>, define <span class="math">\\mathsf{row}_{\\langle M\\rangle},\\hat{\\mathsf{col}}_{\\langle M\\rangle}\\colon K\\to H,\\hat{\\mathsf{val}}_{\\langle M\\rangle}\\in\\mathbb{F}[X]</span> to be the unique polynomials of minimal degree such that for each <span class="math">k\\in K</span>, letting <span class="math">(a,b,\\alpha):=\\langle M\\rangle(k)</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{row}_{\\langle M\\rangle}(k):=a\\ ,\\quad\\hat{\\mathsf{col}}_{\\langle M\\rangle}(k):=b\\ ,\\quad\\hat{\\mathsf{val}}_{\\langle M\\rangle}(k):=\\frac{\\alpha}{u_{H}(a,a)\\cdot u_{H}(b,b)}\\enspace.</span></p>

    <p class="text-gray-300">The following claim expresses <span class="math">\\hat{M}</span> in terms of <span class="math">\\mathsf{row}_{\\langle M\\rangle},\\hat{\\mathsf{col}}_{\\langle M\\rangle},\\hat{\\mathsf{val}}_{\\langle M\\rangle}</span>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Claim 6.4.</h6>

    <p class="text-gray-300">For any sparse representation <span class="math">\\langle M\\rangle\\colon K\\to H\\times H\\times\\mathbb{F}</span> of a matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span>,</p>

    <p class="text-gray-300"><span class="math">\\hat{M}(X,Y)\\equiv\\sum_{k\\in K}\\frac{v_{H}(X)}{(X-\\mathsf{row}_{\\langle M\\rangle}(k))}\\cdot\\frac{v_{H}(Y)}{(Y-\\hat{\\mathsf{col}}_{\\langle M\\rangle}(k))}\\cdot\\hat{\\mathsf{val}}_{\\langle M\\rangle}(k)\\enspace.</span></p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Denote the right-hand side of the equation by <span class="math">P(X,Y)</span>. Since <span class="math">\\mathsf{row}_{\\langle M\\rangle}(k),\\hat{\\mathsf{col}}_{\\langle M\\rangle}(k)\\in H</span> for all <span class="math">k\\in K</span>, <span class="math">P(X,Y)</span> is a polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> in both </span>X<span class="math"> and </span>Y<span class="math">. We now argue that </span>P(a,b)=M_{a,b}<span class="math"> for arbitrary </span>a,b\\in H<span class="math"> (which implies that </span>P<span class="math"> agrees with </span>\\hat{M}<span class="math"> on </span>H\\times H<span class="math"> and hence that </span>P\\equiv\\hat{M}<span class="math">). Suppose first that there is no </span>k\\in K,\\gamma\\in\\mathbb{F}<span class="math"> such that </span>\\langle M\\rangle(k)=(a,b,\\gamma)<span class="math">. By definition of </span>M<span class="math">, </span>M_{a,b}=0<span class="math">; moreover for any </span>k\\in K<span class="math"> either </span>v_{H}(X)/(X-\\mathsf{row}_{\\langle M\\rangle}(k))<span class="math"> has a root at </span>a<span class="math"> or </span>v_{H}(Y)/(Y-\\hat{\\mathsf{col}}_{\\langle M\\rangle}(k))<span class="math"> has a root at </span>b<span class="math">, and so </span>P(a,b)=0<span class="math"> as well. Now suppose that there exists </span>k\\in K,\\gamma\\in\\mathbb{F}<span class="math"> such that </span>\\langle M\\rangle(k)=(a,b,\\gamma)<span class="math">; note that </span>k<span class="math"> is unique because </span>\\langle M\\rangle<span class="math"> is injective. Hence </span>P(a,b)=u_{H}(a,a)\\cdot u_{H}(b,b)\\cdot\\hat{\\mathsf{val}}_{\\langle M\\rangle}(k)=M_{a,b}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Construction 6.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The indexer <span class="math">\\mathbf{I}</span> receives as input an index <span class="math">\\hat{\\mathfrak{i}}=(\\mathbb{F},H,K,\\langle M\\rangle)</span> along with an evaluation domain <span class="math">L\\subseteq\\mathbb{F}</span>, computes the low-degree extensions <span class="math">\\mathsf{row}_{\\langle M\\rangle},\\hat{\\mathsf{col}}_{\\langle M\\rangle},\\hat{\\mathsf{val}}_{\\langle M\\rangle}</span>, and then outputs their evaluations $\\mathsf{row}_{\\langle M\\rangle},\\hat{\\mathsf{col}}_{\\langle M\\rangle},\\hat{\\mathsf{val}}_{\\langle M\\rangle}\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1]<span class="math">. The indexer </span>\\mathbf{I}<span class="math"> also outputs descriptions of </span>\\mathbb{F},H,K$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Subsequently, given an instance <span class="math">\\mathfrak{x}=(\\alpha,\\beta,\\gamma)</span>, the honest prover <span class="math">\\mathbf{P}</span> receives as input <span class="math">(\\hat{\\mathfrak{i}},\\mathfrak{x})</span> and the honest verifier <span class="math">\\mathbf{V}</span> receives as input <span class="math">\\mathfrak{x}</span> and oracle access to <span class="math">\\mathbf{I}(\\hat{\\mathfrak{i}})</span>. The prover <span class="math">\\mathbf{P}</span> and verifier <span class="math">\\mathbf{V}</span> engage in the rational sumcheck protocol (see Section 5) to show that</p>

    <p class="text-gray-300"><span class="math">\\sum_{k\\in K}\\frac{v_{H}(\\alpha)}{(\\alpha-\\mathsf{row}_{\\langle M\\rangle}(k))}\\cdot\\frac{v_{H}(\\beta)}{(\\beta-\\hat{\\mathsf{col}}_{\\langle M\\rangle}(k))}\\cdot\\hat{\\mathsf{val}}_{\\langle M\\rangle}(k)=\\gamma\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In particular, the verifier <span class="math">\\mathbf{V}</span> outputs the rational constraints “$\\deg(\\hat{g})\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math">” for </span>g<span class="math"> sent by </span>\\mathbf{P}<span class="math">, and “</span>\\deg(\\hat{e})\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3<span class="math">” for </span>e\\colon L\\to\\mathbb{F}$ defined as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,a\\in L\\,,\\ e(a):=\\frac{\\Sigma_{K}(g,\\gamma)(a)\\cdot(\\alpha-\\mathsf{row}_{\\langle M\\rangle}(a))(\\beta-\\hat{\\mathsf{col}}_{\\langle M\\rangle}(a))-v_{H}(\\alpha)v_{H}(\\beta)\\hat{\\mathsf{val}}_{\\langle M\\rangle}(a)}{v_{K}(a)}\\enspace.</span> (2)</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 6.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any field <span class="math">\\mathbb{F}</span> and evaluation domain <span class="math">L\\subseteq\\mathbb{F}</span>, Construction 6.5 is an RS-encoded holographic PCP over domain <span class="math">L</span> for the indexed relation <span class="math">\\mathcal{R}_{\\mathrm{MAT}}</span> with perfect completeness and perfect soundness, for indices <span class="math">\\hat{\\mathfrak{i}}=(\\mathbb{F},H,K,\\langle M\\rangle)</span> and instances <span class="math">\\mathfrak{x}=(\\alpha,\\beta,\\gamma)</span> with <span class="math">H,K</span> subgroups of <span class="math">\\mathbb{F}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3<span class="math">, </span>L\\cap K=\\emptyset<span class="math">, and </span>\\alpha,\\beta\\in\\mathbb{F}\\setminus H$. In particular, the following properties hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: if <span class="math">(\\hat{\\mathfrak{i}},\\mathfrak{x},\\bot)\\in\\mathcal{R}_{\\mathrm{MAT}}</span> then <span class="math">\\mathbf{V}^{\\mathbf{I}(\\hat{\\mathfrak{i}})}(\\mathfrak{x})</span> outputs rational constraints that are satisfied by the oracles sent by the honest prover <span class="math">\\mathbf{P}(\\hat{\\mathfrak{i}},\\mathfrak{x})</span>.</li>

    </ol>

    <p class="text-gray-300">.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: if <span class="math">(\\mathbbm{i},\\mathbbm{x},\\bot)\\not\\in\\mathcal{R}_{\\mathrm{MAT}}</span> then for every malicious prover <span class="math">\\tilde{\\mathbf{P}}</span> at least one of the rational constraints output by <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathbbm{i})}(\\mathbbm{x})</span> is not satisfied by the oracles sent by <span class="math">\\tilde{\\mathbf{P}}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The constraint degree is $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3<span class="math">, and the effective degree is </span>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3<span class="math">. The indexer and prover run in time </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and the query evaluation time of the verifier is </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Completeness and soundness follow immediately from Claim 6.4, the completeness and soundness of the rational sumcheck protocol, and the observation that the denominator of the rational summand for <span class="math">\\hat{M}(\\alpha,\\beta)</span> is nonzero for all <span class="math">k\\in K</span> when <span class="math">\\alpha,\\beta\\in\\mathbb{F}\\setminus H</span>. The query evaluation time is dominated by the cost of evaluating <span class="math">v_{H}</span> and <span class="math">v_{K}</span> at a point, which is $O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The constraint degree and effective degree are obtained from setting </span>d_{p}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> and </span>d_{q}:=2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2$ in the rational sumcheck protocol (see Lemma 5.3). ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">6.2 The protocol</h3>

    <p class="text-gray-300">Recall from Section 3.3 that <span class="math">\\vec{r}:=\\big{(}u_{H}(a,Y))_{a\\in H}\\in\\mathbb{F}[Y]^{H}</span> is a vector of linearly independent polynomials in <span class="math">Y</span>. The primary computational task in the lincheck protocol is to evaluate the low-degree extension <span class="math">u_{M}(X,Y)</span> of <span class="math">\\vec{r}M\\in\\mathbb{F}[Y]^{H}</span> at a uniformly chosen point in <span class="math">\\mathbb{F}\\times\\mathbb{F}</span>. For this, we use the protocol for sparse matrix arithmetization discussed above, along with an observation showing that it suffices to compute the arithmetization of a matrix <span class="math">M^{*}</span> related to <span class="math">M</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Claim 6.7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any matrix <span class="math">M\\in\\mathbb{F}^{H\\times H}</span>, let <span class="math">M^{<em>}\\in\\mathbb{F}^{H\\times H}</span> be the matrix given by <span class="math">M^{</em>}_{a,b}:=M_{b,a}\\cdot u_{H}(b,b)</span> for all <span class="math">a,b\\in H</span>; note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">u_{M}(X,Y)\\equiv\\hat{M^{*}}(X,Y)\\enspace.</span></p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By the definition of low-degree extension,</p>

    <p class="text-gray-300"><span class="math">u_{M}(X,Y)\\equiv\\sum_{a\\in H}(\\vec{r}M)_{a}\\cdot L_{a,H}(X)\\equiv\\sum_{a\\in H}L_{a,H}(X)\\sum_{b\\in H}M_{b,a}\\cdot u_{H}(b,Y)\\enspace.</span></p>

    <p class="text-gray-300">Recall that <span class="math">u_{H}(b,Y)\\equiv u_{H}(b,b)L_{b,H}(Y)</span>. Hence</p>

    <p class="text-gray-300"><span class="math">u_{M}(X,Y)\\equiv\\sum_{a\\in H}\\sum_{b\\in H}L_{a,H}(X)L_{b,H}(Y)M_{b,a}u_{H}(b,b)\\equiv\\hat{M^{*}}(X,Y)\\enspace.\\qed</span></p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Construction 6.8 (holographic lincheck).</h6>

    <p class="text-gray-300">The indexer <span class="math">\\mathbf{I}</span> receives as input an index <span class="math">\\mathbbm{i}=(\\mathbb{F},L,H,K,d,\\langle M\\rangle)</span>, computes a sparse representation <span class="math">\\langle M^{<em>}\\rangle</span> of the matrix <span class="math">M^{</em>}</span> (as in Claim 6.7), and then runs the indexer of the sparse matrix arithmetization protocol (Construction 6.5) on the index <span class="math">(\\mathbb{F},H,K,\\langle M^{*}\\rangle)</span>; note that the output of the latter includes descriptions of <span class="math">\\mathbb{F},H,K</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Subsequently, given an instance $\\mathbbm{x}=1^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and witness </span>\\mathbbm{w}=(f_{1},f_{2})<span class="math">, the honest prover </span>\\mathbf{P}<span class="math"> receives as input </span>(\\mathbbm{i},\\mathbbm{x})<span class="math">, the honest verifier </span>\\mathbf{V}<span class="math"> receives as input </span>\\mathbbm{x}<span class="math"> and oracle access to </span>\\mathbf{I}(\\mathbbm{i})$, and they engage in the following protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> sends <span class="math">\\alpha\\in\\mathbb{F}\\setminus H</span> uniformly at random.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\mathbf{P}</span> sends the evaluation $t\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1]<span class="math"> of the polynomial </span>\\hat{t}(X):=u_{M}(X,\\alpha)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P},\\mathbf{V}</span> engage in the sumcheck protocol to show that <span class="math">\\sum_{b\\in H}u_{H}(b,\\alpha)\\hat{f}_{1}(b)-\\hat{t}(b)\\hat{f}_{2}(b)=0</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That is, <span class="math">\\mathbf{P}</span> sends $g_{1}\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2]<span class="math"> and </span>\\mathbf{V}<span class="math"> outputs the rational constraints “</span>\\deg(\\hat{g}_{1})\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math">” and “</span>\\deg(\\hat{h})\\leq d-1$” where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,b\\in L\\,,\\ h(b):=\\frac{u_{H}(b,\\alpha)f_{1}(b)-t(b)f_{2}(b)-\\Sigma_{H}(g_{1},0)(b)}{v_{H}(b)}\\enspace.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> sends <span class="math">\\beta \\in \\mathbb{F} \\setminus H</span> uniformly at random.</li>

      <li><span class="math">\\mathbf{P}</span> sends the field element <span class="math">\\gamma \\coloneqq u_{M}(\\beta, \\alpha) = \\hat{t}(\\beta)</span>, and <span class="math">\\mathbf{V}</span> outputs the boundary constraint “<span class="math">\\hat{t}(\\beta) = \\gamma</span>”.</li>

      <li><span class="math">\\mathbf{P}, \\mathbf{V}</span> engage in the matrix arithmetization protocol (Construction 6.5) to show that <span class="math">\\hat{M}^{*}(\\beta, \\alpha) = \\gamma</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That is, <span class="math">\\mathbf{P}</span> sends $g_{2} \\in \\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2]<span class="math"> and </span>\\mathbf{V}<span class="math"> outputs the rational constraints “</span>\\deg(\\hat{g}_{2}) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2<span class="math">” and “</span>\\deg(\\hat{e}) \\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 3<span class="math">”, where </span>e \\colon L \\to \\mathbb{F}<span class="math"> is as in Eq. (2) with </span>g_{2}<span class="math"> in place of </span>g<span class="math"> and </span>M^{*}<span class="math"> in place of </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of Lemma 6.2. For <span class="math">\\alpha \\in \\mathbb{F}</span>, let <span class="math">\\vec{r}_{\\alpha} \\coloneqq (u_{H}(b, \\alpha))_{b \\in H} \\in \\mathbb{F}^{H}</span>. One can verify that <span class="math">\\vec{r}_{\\alpha} M = (u_{M}(b, \\alpha))_{b \\in H}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Completeness. Suppose that $\\hat{f}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H = M \\cdot \\hat{g}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H<span class="math">. Then for every </span>\\alpha \\in \\mathbb{F} \\setminus H$ it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{b \\in H} u_{H}(b, \\alpha) \\hat{f}_{1}(b) = \\langle \\vec{r}_{\\alpha}, \\hat{f}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H} \\rangle = \\langle \\vec{r}_{\\alpha}, M \\cdot \\hat{f}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H} \\rangle = \\langle \\vec{r}_{\\alpha} M, \\hat{f}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H} \\rangle = \\sum_{b \\in H} u_{M}(b, \\alpha) \\hat{f}_{2}(b) = \\sum_{b \\in H} \\hat{t}(b) \\hat{f}_{2}(b)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and so the sumcheck protocol in Step 3 succeeds. Next, Claim 6.7 tells us that <span class="math">u_{M}(X,Y) \\equiv \\hat{M}^{<em>}(X,Y)</span> and so for every <span class="math">\\beta \\in \\mathbb{F} \\setminus H</span> it holds that <span class="math">u_{M}(\\beta, \\alpha) = \\hat{M}^{</em>}(\\beta, \\alpha)</span>. This means that <span class="math">\\hat{M}^{*}(\\beta, \\alpha) = \\hat{t}(\\beta) = \\gamma</span>, and so the matrix arithmetization subverifier accepts, and the boundary constraint “<span class="math">\\hat{t}(\\beta) = \\gamma</span>” is satisfied.</p>

    <p class="text-gray-300">Round-by-round soundness. We define the State function as follows.</p>

    <p class="text-gray-300">State <span class="math">(M, f_1, f_2, (\\alpha, t, g_1, \\beta, (\\gamma, g_2)))</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If <span class="math">\\alpha \\neq \\bot</span> is such that $\\langle \\vec{r}_{\\alpha}, \\hat{f}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H \\rangle = \\langle \\vec{r}_{\\alpha}, M \\cdot \\hat{f}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H \\rangle$, output accept.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\hat{t}(X) \\neq u_M(X, \\alpha)</span> and <span class="math">\\beta \\neq \\bot</span> is such that <span class="math">\\hat{t}(\\beta) = u_M(\\beta, \\alpha)</span>, output accept.</li>

      <li>Otherwise, output reject.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly <span class="math">\\operatorname{State}(\\emptyset) = \\operatorname{reject}</span>. Suppose that $\\hat{f}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H \\neq M \\cdot \\hat{f}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H<span class="math">. Then </span>\\operatorname{Pr}_{\\alpha \\in \\mathbb{F} \\setminus H}[\\langle \\vec{r}_{\\alpha}, \\hat{f}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H \\rangle = \\langle \\vec{r}_{\\alpha}, M \\cdot \\hat{f}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H \\rangle] \\leq (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and so the probability of moving to accept in the first round is at most </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Similarly, if </span>\\hat{t}(X) \\neq u_M(X, \\alpha)<span class="math">, then </span>\\operatorname{Pr}_{\\beta \\in \\mathbb{F} \\setminus H}[\\hat{t}(\\beta) = u_M(\\beta, \\alpha)] \\leq (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and so the probability of moving to accept in the second round is at most </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now suppose that <span class="math">\\operatorname{State}(M, f_1, f_2, (\\alpha, t, g_1, \\beta, (\\gamma, g_2))) = \\operatorname{reject}</span>; we show that with probability 1 there is some constraint which is not satisfied. By definition of State, $\\langle \\vec{r}_{\\alpha}, \\hat{f}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H \\rangle \\neq \\langle \\vec{r}_{\\alpha}, M \\cdot \\hat{f}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_H \\rangle<span class="math">. If </span>\\hat{t}(X) \\equiv u_M(X, \\alpha)<span class="math"> then the sumcheck constraint is not satisfied with probability 1, by the soundness of the sumcheck protocol. Otherwise </span>\\hat{t}(X) \\neq u_M(X, \\alpha)<span class="math">; then by definition of State, it holds that </span>\\hat{t}(\\beta) \\neq u_M(\\beta, \\alpha)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence with probability 1, either the sumcheck constraint is not satisfied, the boundary constraint “<span class="math">\\hat{t}(\\beta) = \\gamma</span>” is not satisfied, or <span class="math">\\gamma = \\hat{t}(\\beta) \\neq u_M(\\beta, \\alpha) = \\hat{M}^*(\\beta, \\alpha)</span>, and so the matrix arithmetization subverifier outputs a rational constraint that is not satisfied.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zero knowledge. Note that since <span class="math">M</span> is part of the index rather than the witness, it is not relevant for zero knowledge; in particular, the simulator has access to <span class="math">M</span>. Hence to ensure zero knowledge we need only modify Step 3 to use the zero knowledge sumcheck protocol. This adds an additional oracle (the random mask) but not an additional round, since we can run the protocols in parallel. The soundness error increases by at most $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (and since the ZK sumcheck protocol is one round, so does the RBR soundness error). The sumcheck simulator satisfies the property that the view of a malicious verifier making </span>t<span class="math"> queries across all oracles can be simulated by making </span>t<span class="math"> queries to the summand. Since the summand is defined pointwise with respect to </span>(f_1, f_2)<span class="math">, this results in at most </span>t<span class="math"> queries to each of </span>f_1, f_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The indexer runs the indexer of the holographic protocol for sparse matrix arithmetization on (a modification of) the given matrix, and so runs in time $O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The first message of the prover is for the sumcheck protocol and the second message of the prover is for the sparse matrix arithmetization protocol, and so the prover runs in time </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The query evaluation time of the verifier is dominated by the cost to evaluate the vanishing polynomials </span>v_H<span class="math"> and </span>v_K<span class="math"> at a point, and so is </span>O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">30</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The constraint degree is  $\\max(d - 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2, 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 3)<span class="math">  and the effective degree is  </span>\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 + d, 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 3)$ , as can be seen by keeping track of the degrees of all relevant real and virtual oracles in the protocol (as in the table) and then using the definitions in Section 4.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">oracle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">constraint degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">numerator degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denominator degree</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g1</td>

            <td class="px-3 py-2 border-b border-gray-700">real</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">- 2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">h</td>

            <td class="px-3 py-2 border-b border-gray-700">virtual</td>

            <td class="px-3 py-2 border-b border-gray-700">d - 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1 + d</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g2</td>

            <td class="px-3 py-2 border-b border-gray-700">real</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">- 2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">e</td>

            <td class="px-3 py-2 border-b border-gray-700">virtual</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">- 3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">- 3</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">7 RS-encoded holographic IOP for R1CS</p>

    <p class="text-gray-300">We describe an RS-encoded holographic IOP for R1CS. The main subroutine that we use is the RS-encoded holographic protocol for lincheck that we obtained in Section 6.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 7.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix some <span class="math">L\\subseteq\\mathbb{F}</span> and <span class="math">\\mathtt{b}\\in\\mathbb{N}</span>. Construction 7.2 below is a RS-encoded holographic IOP of knowledge for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> (Definition 3.2) over domain <span class="math">L</span> for indices <span class="math">(\\mathbb{F},H,K,\\langle A\\rangle,\\langle B\\rangle,\\langle C\\rangle)</span> such that <span class="math">H,K</span> are subgroups of <span class="math">\\mathbb{F}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3<span class="math">, and </span>L\\cap(H\\cup K)=\\emptyset<span class="math">. The protocol has 5 messages (prover moves first), is zero knowledge against verifiers making less than </span>\\mathtt{b}<span class="math"> queries, and has round-by-round knowledge error </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The index length is </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and the proof length is </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The prover and indexer run in time </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the verifier runs in time </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The constraint degree is </span>\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}-2,2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3)<span class="math">, and the effective degree is </span>\\max(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}-2,3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-3)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-60" class="text-base font-medium mt-4">Construction 7.2.</h6>

    <p class="text-gray-300">We describe an RS-encoded holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for R1CS. (See Fig. 4 for a diagram of this protocol after applying optimizations described in Remark 7.3 below.) In the description below we denote by <span class="math">(\\mathbf{I}_{\\textsc{LIN}},\\mathbf{P}_{\\textsc{LIN}},\\mathbf{V}_{\\textsc{LIN}})</span> the zero knowledge holographic protocol for lincheck (Construction 6.8).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The indexer <span class="math">\\mathbf{I}</span> receives as input an index <span class="math">\\dot{\\mathtt{i}}=(\\mathbb{F},H,K,\\langle A\\rangle,\\langle B\\rangle,\\langle C\\rangle)</span>, computes the encoded index <span class="math">\\mathbb{I}_{M}\\leftarrow\\mathbf{I}_{\\textsc{LIN}}(\\dot{\\mathtt{i}}^{M}_{\\textsc{LIN}})</span> where $\\dot{\\mathtt{i}}^{M}_{\\textsc{LIN}}:=(\\mathbb{F},L,H,K,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}-1,\\langle M\\rangle)<span class="math"> for each </span>M\\in\\{A,B,C\\}<span class="math"> for each </span>M\\in\\{A,B,C\\}<span class="math">, and then outputs the tuple </span>(\\mathbb{I}_{A},\\mathbb{I}_{B},\\mathbb{I}_{C})<span class="math">. (Implicitly this includes descriptions of </span>\\mathbb{F},H,K<span class="math">; recall also that in an RS-encoded protocol all parties have access to a description of the evaluation domain </span>L$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Subsequently, the prover <span class="math">\\mathbf{P}</span> receives as input the index <span class="math">\\dot{\\mathtt{i}}</span>, an instance <span class="math">\\mathtt{x}=(I,x)</span>, and a witness <span class="math">\\mathtt{w}=w</span>; the verifier <span class="math">\\mathbf{V}</span> receives as input the instance <span class="math">\\mathtt{x}</span> only. Let <span class="math">z:=(x,w)\\in\\mathbb{F}^{H}</span> be the full variable assignment.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute LDE of the input. Before the interaction, the prover <span class="math">\\mathbf{P}</span> constructs <span class="math">\\hat{f}_{x}(X)</span>, the unique polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that, for all </span>b\\in I<span class="math">, </span>\\hat{f}_{x}(b)=x_{b}<span class="math">. Define </span>f_{x}:=\\hat{f}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}<span class="math">. Note that the verifier </span>\\mathbf{V}<span class="math">, which knows </span>x<span class="math">, can evaluate </span>\\hat{f}_{x}(X)<span class="math"> at any point in </span>\\mathbb{F}<span class="math"> in time </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Witness and auxiliary oracles. The prover <span class="math">\\mathbf{P}</span> sends to the verifier <span class="math">\\mathbf{V}</span> the oracles</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f_{w}\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}-1]\\quad\\text{and}\\quad f_{Az},f_{Bz},f_{Cz}\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}-1]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">defined as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $f_{w}:=\\bar{f}_{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}<span class="math"> where </span>\\bar{f}_{w}<span class="math"> is a random polynomial of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,a\\in H\\setminus I,\\quad\\bar{f}_{w}(a)=\\frac{w_{a}-\\hat{f}_{x}(a)}{v_{I}(a)}\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $f_{Az}:=\\bar{f}_{Az}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}<span class="math"> where </span>\\bar{f}_{Az}<span class="math"> is a random polynomial of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}<span class="math"> such that, for all </span>a\\in H<span class="math">, </span>\\hat{f}_{Az}(a)=\\sum_{b\\in H}A_{a,b}\\cdot z_{b}=(Az)_{a}<span class="math">. The other codewords, </span>f_{Bz}<span class="math"> and </span>f_{Cz}$, are defined similarly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The codewords <span class="math">f_{x}</span> and <span class="math">f_{w}</span> implicitly define the “virtual oracle” $f_{z}\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{b}-1]<span class="math"> where </span>f_{z}(a):=f_{w}(a)v_{I}(a)+f_{x}(a)<span class="math"> for </span>a\\in L<span class="math">. Note that </span>\\hat{f}_{z}(a)=z_{a}<span class="math"> for all </span>a\\in H<span class="math">, so </span>\\bar{f}_{z}<span class="math"> is a low-degree extension of </span>z$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,a\\in L\\,,\\ s(a):=\\frac{f_{Az}(a)\\cdot f_{Bz}(a)-f_{Cz}(a)}{v_{H}(a)}\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Linchecks. To test that $\\hat{f}_{Mz}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}=M\\cdot\\hat{f}_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math"> for each </span>M\\in\\{A,B,C\\}<span class="math">, the prover </span>\\mathbf{P}<span class="math"> and verifier </span>\\mathbf{V}<span class="math"> run the following in parallel. Recall that the verifier </span>\\mathbf{V}<span class="math"> has oracle access to the encoded index is </span>(\\mathbb{I}_{A},\\mathbb{I}_{B},\\mathbb{I}_{C})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) $\\left(\\mathbf{P}_{\\textsc{LIN}}(\\dot{\\mathbf{i}}_{\\textsc{LIN}}^{A},1^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(f_{Az},f_{z})),\\mathbf{V}_{\\textsc{LIN}}^{f_{Az},f_{z},\\mathbb{I}_{A}}(1^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\right).$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(c) $\\left(\\mathbf{P}_{\\textsc{LIN}}(\\dot{\\mathbf{i}}_{\\textsc{LIN}}^{C},1^{\\log</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">},(f_{Cz},f_{z})),\\mathbf{V}_{\\textsc{LIN}}^{f_{Cz},f_{z},\\mathbb{I}_{C}}(1^{\\log</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">})\\right).$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix an index <span class="math">\\dot{\\mathbf{i}}=(\\mathbb{F},H,K,\\langle A\\rangle,\\langle B\\rangle,\\langle C\\rangle)</span> and instance <span class="math">\\mathbf{x}=(I,x)</span>.</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">Completeness.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">(\\dot{\\mathbf{i}},\\mathbf{x},w)\\in\\mathcal{R}_{\\textsc{R1CS}}</span>, and let <span class="math">z:=(x,w)</span>. Note that, by construction, <span class="math">\\hat{f}_{z}</span> is a low-degree extension of <span class="math">z</span>. Since <span class="math">Az\\circ Bz=Cz</span>, we know that $\\hat{f}_{Az}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}\\circ\\hat{f}_{Bz}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}=\\hat{f}_{Cz}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math"> and </span>\\hat{f}_{Mz}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}=M\\cdot\\hat{f}_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math"> for each </span>M\\in\\{A,B,C\\}<span class="math">. Hence, for all </span>a\\in H<span class="math"> it holds that </span>f_{Az}(a)\\cdot f_{Bz}(a)-f_{Cz}(a)=0<span class="math">, and so </span>\\hat{s}(X)<span class="math"> is a polynomial of degree at most </span>2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{b}-1)-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2\\mathsf{b}-2$, so the rational constraint in Step 3 is satisfied. Moreover, the holographic lincheck protocol in Step 4a yields rational constraints which are satisfied; by a similar argument, Steps 4b and 4c yield satisfied rational constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">Round-by-round soundness.</h4>

    <p class="text-gray-300">We define the following State function (recall <span class="math">\\dot{\\mathbf{i}}=(\\mathbb{F},H,K,\\langle A\\rangle,\\langle B\\rangle,\\langle C\\rangle)</span>):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>State<span class="math">(\\dot{\\mathbf{i}},(I,x),(f_{w},f_{Az},f_{Bz},f_{Cz},\\mathsf{tr}_{\\textsc{LIN}}))</span>:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. If $(\\dot{\\mathbf{i}},(I,x),\\hat{f}_{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H\\setminus I})\\in\\mathcal{R}_{\\textsc{R1CS}}$, output accept.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, output reject.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">(\\dot{\\mathbf{i}},(I,x))\\notin\\mathcal{L}(\\mathcal{R}_{\\textsc{R1CS}})</span>. Item 1 never holds. By the round-by-round soundness of the lincheck protocol, the probability that State moves to accept at any round is at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. It remains to show that when </span>\\mathsf{State}(\\dot{\\mathbf{i}},(I,x),(f_{w},f_{Az},f_{Bz},f_{Cz},\\mathsf{tr}_{\\textsc{LIN}}))=\\mathsf{reject}<span class="math">, the verifier rejects with probability </span>1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">f_{z}</span> be the virtual oracle induced by <span class="math">f_{w}</span> as sent by <span class="math">\\tilde{\\mathbf{P}}</span>. Then either $\\hat{f}_{Az}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}\\circ\\hat{f}_{Bz}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}\\neq\\hat{f}_{Cz}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math">, or there exists </span>M\\in\\{A,B,C\\}<span class="math"> such that </span>\\hat{f}_{Mz}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}\\neq M\\cdot\\hat{f}_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math">. In the former case, the rational constraint output in Step 3 is not satisfied (with probability </span>1<span class="math">), so suppose that the latter holds. Then by the definition of State, the state function for the lincheck protocol rejects for some such </span>M$. Hence some rational constraint output by the verifier in Steps 4a, 4b and 4c is not satisfied.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">Proof of knowledge.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The extractor <span class="math">\\mathbf{E}(\\dot{\\mathbf{i}},\\mathbf{x},\\mathsf{tr})</span> operates as follows: read <span class="math">f_{w}</span> from <span class="math">\\mathsf{tr}</span> and output $\\hat{f}_{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H\\setminus I}<span class="math">. Let </span>S:=\\{f_{w}:(\\dot{\\mathbf{i}},\\mathbf{x},\\hat{f}_{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H\\setminus I})\\in\\mathcal{R}_{\\textsc{R1CS}}\\}<span class="math">. From the round-by-round soundness analysis, it holds that conditioned on </span>f_{w}\\notin S<span class="math">, the state moves to accept with probability at most </span>\\epsilon:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Hence if the state moves to accept with probability greater than </span>\\epsilon<span class="math">, it must be that </span>f_{w}\\in S<span class="math">, and so </span>\\mathbf{E}$ succeeds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-65" class="text-lg font-semibold mt-6">Zero knowledge.</h4>

    <p class="text-gray-300">The simulator <span class="math">\\mathbf{S}</span> simulates the oracles <span class="math">f_{w},f_{Az},f_{Bz},f_{Cz}</span> by answering <span class="math">\\tilde{\\mathbf{V}}</span>’s queries with uniformly random elements of <span class="math">\\mathbb{F}</span>. It runs the simulator for the zero knowledge holographic lincheck protocol as appropriate, answering the subsimulators’ queries to the oracles with uniformly random field elements. Since <span class="math">\\tilde{\\mathbf{V}}</span> makes <span class="math">t&lt;\\mathsf{b}</span> queries across all oracles, the guarantees of the subsimulators ensure that we only need to simulate at most <span class="math">t</span> evaluations of each of <span class="math">f_{w},f_{Az},f_{Bz},f_{Cz}</span> in <span class="math">L</span> (with <span class="math">L\\cap H=\\emptyset</span>), which by bounded independence properties of random polynomials will be uniformly random elements of <span class="math">\\mathbb{F}</span>. For a detailed simulator construction for a similar protocol, see <em>[x1, Section 7.1]</em>.</p>

    <h4 id="sec-66" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The running time of the indexer follows from the running time of the lincheck indexer; in particular, its computation cost is dominated by the cost of a constant number of FFTs over <span class="math">L</span>. The running time of the prover is similarly dominated. The constraint cost of the verifier consists of evaluating the low degree extension of <span class="math">x</span> at a single point in <span class="math">\\mathbb{F}</span>, and running the lincheck and rowcheck subverifiers whose cost is dominated by evaluating <span class="math">v_{H}</span> and <span class="math">v_{K}</span>; using preprocessing this can be achieved for <span class="math">H,K</span> subgroups of <span class="math">\\mathbb{F}</span> in time $O_{\\mathbb{F}}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Remark 7.3 (batching linchecks).</h6>

    <p class="text-gray-300">We would like to batch the three lincheck protocols from Steps 4a to 4c into a single one, similarly to what is done in the non-holographic protocol for R1CS of <em>[x1]</em>. Informally, we want the verifier to send random elements <span class="math">\\eta_{A},\\eta_{B},\\eta_{C}</span> and then run a holographic lincheck for the matrix <span class="math">\\eta_{A}A+\\eta_{B}B+\\eta_{C}C</span>. However doing this requires some care because the verifier only has access to the encoded indices <span class="math">(\\mathbb{I}_{A},\\mathbb{I}_{B},\\mathbb{I}_{C})</span> for the matrices <span class="math">A,B,C</span>, as opposed to an encoded index for the matrix <span class="math">\\eta_{A}A+\\eta_{B}B+\\eta_{C}C</span>, and our holographic lincheck protocol is <em>not</em> linear in the encoded indices.</p>

    <p class="text-gray-300">We now explain how to overcome this issue by “opening up” the lincheck protocol into its components, described in Construction 6.8 in Section 6. The resulting protocol is summarized in Fig. 4.</p>

    <p class="text-gray-300">The first message of the verifier consists of random elements <span class="math">\\eta_{A},\\eta_{B},\\eta_{C}</span> for the random linear combination, along with the random challenge <span class="math">\\alpha</span> prescribed by Step 1 of the holographic lincheck protocol.</p>

    <p class="text-gray-300">The subsequent two steps are straightforward to adapt due to linearity:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- In Step 2, the prover must send the evaluation of the polynomial <span class="math">\\hat{t}(X):=u_{\\eta_{A}A+\\eta_{B}B+\\eta_{C}C}(X,\\alpha)</span>, which by linearity equals to <span class="math">\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}u_{M}(X,\\alpha)</span>. The prover thus sends $t:=\\hat{t}\\mid_{L}\\in\\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Step 3, the prover and verifier must run the zero knowledge sumcheck protocol (relative to a random mask <span class="math">r</span> sent earlier) to show that <span class="math">\\sum_{b\\in H}u_{H}(b,\\alpha)\\hat{f}_{\\mathbb{S}}(b)-\\hat{t}(b)\\hat{f}_{z}(b)=0</span> where <span class="math">\\hat{f}_{\\mathbb{S}}(X)</span> is the low-degree extension of the vector <span class="math">(\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}M)z</span>. By linearity, <span class="math">\\hat{f}_{\\mathbb{S}}(X)=\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\hat{f}_{M}(X)</span>, which means that the verifier can do this since the prover has sent <span class="math">f_{z},f_{A},f_{B},f_{C}</span>.</li>

    </ul>

    <p class="text-gray-300">Then there are two steps that remain unchanged: the verifier sends the random challenge <span class="math">\\beta</span> prescribed by Step 4 of the holographic lincheck protocol, and the prover answers with the evaluation <span class="math">\\gamma:=\\hat{t}(\\beta)</span> prescribed in Step 5 of the holographic lincheck protocol.</p>

    <p class="text-gray-300">The final step of the holographic lincheck protocol, Step 6, involves a rational sumcheck checking that <span class="math">\\gamma</span> is the value of the low-degree extension of <span class="math">\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}M</span> at <span class="math">(\\beta,\\alpha)</span>. This is the step that lacks linear structure and we need to modify it. Specifically we need to turn the expression</p>

    <p class="text-gray-300"><span class="math">\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\frac{v_{H}(\\alpha)}{(\\alpha-\\mathsf{row}_{\\langle M^{<em>}\\rangle}(X))}\\cdot\\frac{v_{H}(\\beta)}{(\\beta-\\mathsf{col}_{\\langle M^{</em>}\\rangle}(X))}\\cdot\\mathsf{val}_{\\langle M^{*}\\rangle}(X)</span></p>

    <p class="text-gray-300">into a rational function in <span class="math">X</span>. This is achieved by “multiplying up” denominators, to obtain the rational function <span class="math">\\hat{p}(X)/\\hat{q}(X)</span> where</p>

    <p class="text-gray-300"><span class="math">\\hat{p}(X)</span> <span class="math">:=v_{H}(\\alpha)v_{H}(\\beta)\\sum_{M\\in\\{A,B,C\\}}\\eta_{M}\\mathsf{val}_{\\langle M^{<em>}\\rangle}(X)\\prod_{N\\in\\{A,B,C\\}\\setminus\\{M\\}}(\\alpha-\\mathsf{row}_{\\langle N^{</em>}\\rangle}(X))(\\beta-\\mathsf{col}_{\\langle N^{<em>}\\rangle}(X))</span> (3) <span class="math">\\hat{q}(X)</span> <span class="math">:=\\prod_{M\\in\\{A,B,C\\}}(\\alpha-\\mathsf{row}_{\\langle M^{</em>}\\rangle}(X))(\\beta-\\mathsf{col}_{\\langle M^{*}\\rangle}(X))\\enspace.</span> (4)</p>

    <p class="text-gray-300">Crucially, the verifier can easily evaluate <span class="math">\\hat{p}</span> and <span class="math">\\hat{q}</span> at any point on <span class="math">L</span> by having oracle access to the encoded indices <span class="math">(\\mathbb{I}_{A},\\mathbb{I}_{B},\\mathbb{I}_{C})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">\\mathbf{P}((\\mathbb{F},H,K,\\langle A\\rangle ,\\langle B\\rangle ,\\langle C\\rangle),(x,I),w)</p>

    <p class="text-gray-300">\\mathbf{V}^{\\{\\mathrm{row}_{\\langle M^{<em>}\\rangle},\\mathrm{col}_{\\langle M^{</em>}\\rangle},\\mathrm{val}_{\\langle M^{*}\\rangle}\\}_{M\\in \\{A,B,C\\}}}(\\mathbb{F},H,K,(x,I))</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sample  $f_{w}\\in \\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 1]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sample  $f_{Az},f_{Bz},f_{Cz}\\in \\mathrm{RS}[L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 1]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sample  $r\\in \\mathrm{RS}[L,2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{b} - 2]<span class="math">  s.t.  </span>\\sum_{a\\in H}\\hat{r} (a) = 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 4: Diagram of our RS-encoded holographic IOP for R1CS (Construction 7.2), after applying the optimizations described in Remark 7.3 (which batch the three holographic linchecks into one holographic protocol).</p>

    <p class="text-gray-300">8 Holographic IOP for R1CS</p>

    <p class="text-gray-300">We construct an efficient holographic IOP for rank-1 constraint satisfiability (R1CS). Our preprocessing zkSNARK is obtained by applying our compiler to this protocol (reparametrized to reduce soundness error).</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Theorem 8.1.</h6>

    <p class="text-gray-300">There exists a public-coin holographic IOP <span class="math">\\mathsf{HOL}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for the indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> (Definition 3.2) that is a zero knowledge proof of knowledge with the following efficiency features.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Indexing. The indexer <span class="math">\\mathbf{I}</span>, given an index <span class="math">\\mathbbm{i}=(\\mathbb{F},H,K,\\langle A\\rangle,\\langle B\\rangle,\\langle C\\rangle)</span>, where <span class="math">H,K</span> are subgroups of <span class="math">\\mathbb{F}</span>, runs in time $O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to compute an encoded index </span>\\mathbf{I}(\\mathbbm{i})<span class="math"> of size </span>O_{\\mathbb{F}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}(\\mathbbm{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbm{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Above, <span class="math">\\epsilon_{\\mathrm{FRI}}(\\mathbb{F},\\rho,\\delta)</span> denotes the round-by-round soundness error of the FRI low-degree test <em>[x1]</em> over the field <span class="math">\\mathbb{F}</span> for proximity parameter <span class="math">\\delta</span> and rate parameter <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">The rest of this section is organized as follows: (1) we introduce a generic theorem (Theorem 8.2) that allows us to “compile” an RS-encoded holographic IOP into a holographic IOP via a low-degree test; then (2) we show how to apply this theorem with the FRI low-degree test <em>[x1]</em> to prove Theorem 8.1. Theorem 8.2 is adapted from <em>[x2]</em> to handle holography and round-by-round soundness, and to more carefully account for the running time of the verifier. Before stating the theorem, we briefly describe the construction.</p>

    <p class="text-gray-300">The compiled holographic IOP consists of two conceptual stages: first, the prover and verifier engage in the RS-encoded holographic IOP; then, the prover proves to the verifier that the oracles it sent were of degree <span class="math">d</span> using the low-degree test. For efficiency, rather than proving the degree of <span class="math">f_{1},\\ldots,f_{\\mathsf{k}}</span> separately, we introduce an additional round of interaction where the verifier chooses a vector <span class="math">\\vec{z}\\in\\mathbb{F}^{\\mathsf{k}}</span> and the prover shows that the oracle <span class="math">\\sum_{i}z_{i}f_{i}</span> has degree <span class="math">d</span>. (If the oracles sent have differing prescribed degrees, then we “shift” them so they all have the same degree.) Finally, for zero knowledge, the prover sends a random <span class="math">f_{0}</span> of degree <span class="math">d</span> (before seeing <span class="math">\\vec{z}</span>) and shows instead that <span class="math">f_{0}+\\sum_{i}z_{i}f_{i}</span> is of degree <span class="math">d</span>. We now state and prove the theorem.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Theorem 8.2 (adapted from <em>[x2]</em>).</h6>

    <p class="text-gray-300">Suppose that we are given:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an RS-encoded holographic IOP <span class="math">\\mathsf{HOL}_{\\mathcal{R}}=(\\mathbf{I}_{\\mathcal{R}},\\mathbf{P}_{\\mathcal{R}},\\mathbf{V}_{\\mathcal{R}},\\{\\vec{d_{\\mathbf{I}}},\\vec{d}_{\\mathbf{P},1},\\ldots,\\vec{d}_{\\mathbf{P},\\mathsf{k}}\\})</span> over <span class="math">L</span>, with maximum degree <span class="math">(d_{\\mathsf{c}},d_{\\mathsf{e}})</span>, for an indexed relation <span class="math">\\mathcal{R}</span>;</li>

      <li>a low-degree test <span class="math">(\\mathbf{P}_{\\mathrm{LDT}},\\mathbf{V}_{\\mathrm{LDT}})</span> for the Reed–Solomon code <span class="math">\\mathrm{RS}[L,d_{\\mathsf{c}}]</span>.</li>

    </ul>

    <p class="text-gray-300">Fix any proximity parameter <span class="math">\\delta^{\\mathsf{LDT}}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta^{\\mathsf{LDT}}<\\min\\left(\\frac{1-2\\rho_{c}}{2},\\frac{1-\\rho_{c}}{3},1-\\rho_{e}\\right)\\quad\\text{where}\\quad\\rho_{c}:=\\frac{d_{\\mathsf{c}}+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\quad\\text{and}\\quad\\rho_{e}:=\\frac{d_{\\mathsf{e}}+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then we can combine the above two ingredients to obtain a holographic IOP <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for <span class="math">\\mathcal{R}</span> with the following parameters. (Parameters with superscript “<span class="math">\\mathcal{R}</span>” and “<span class="math">\\mathsf{LDT}</span>” are parameters for <span class="math">(\\mathbf{I}_{\\mathcal{R}},\\mathbf{P}_{\\mathcal{R}},\\mathbf{V}_{\\mathcal{R}})</span> and <span class="math">(\\mathbf{P}_{\\mathrm{LDT}},\\mathbf{V}_{\\mathrm{LDT}})</span> respectively.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{k}^{\\mathcal{R}}+\\mathsf{k}^{\\mathsf{LDT}}</span> rounds,</li>

      <li>query complexity <span class="math">\\mathsf{q}_{\\mathsf{\\sigma}}^{\\mathsf{LDT}}+\\mathsf{q}_{\\mathbb{w}}^{\\mathsf{LDT}}\\cdot(\\mathsf{k}^{\\mathcal{R}}+1)</span>,</li>

      <li>proof length <span class="math">\\mathsf{L}^{\\mathcal{R}}+\\mathsf{L}^{\\mathsf{LDT}}</span>,</li>

    </ol>

    <p class="text-gray-300">4</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(iv) soundness error $\\epsilon^{\\mathcal{R}} + \\epsilon^{\\mathrm{LDT}} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The new indexer <span class="math">\\mathbf{I}</span> equals <span class="math">\\mathbf{I}_{\\mathcal{R}}</span>; the new prover <span class="math">\\mathbf{P}</span> runs in time <span class="math">\\mathrm{time}(\\mathbf{P}^{\\mathrm{LDT}}) + \\mathrm{time}(\\mathbf{P}^{\\mathcal{R}})</span>; and the new verifier <span class="math">\\mathbf{V}</span> runs in time <span class="math">\\mathrm{time}(\\mathbf{V}^{\\mathrm{LDT}}) + \\mathbf{q}_{\\pi}^{\\mathrm{LDT}} \\cdot t_{\\mathbf{q}}^{\\mathcal{R}}</span>.</p>

    <p class="text-gray-300">If <span class="math">(\\mathbf{I}_{\\mathcal{R}}, \\mathbf{P}_{\\mathcal{R}}, \\mathbf{V}_{\\mathcal{R}})</span> is zero-knowledge then <span class="math">(\\mathbf{I}, \\mathbf{P}, \\mathbf{V})</span> is also zero-knowledge (with the same query bound).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">(\\mathbf{I}_{\\mathcal{R}}, \\mathbf{P}_{\\mathcal{R}}, \\mathbf{V}_{\\mathcal{R}})</span> has round-by-round knowledge error <span class="math">\\kappa_{\\mathrm{rbr}}^{\\mathcal{R}}</span> then <span class="math">(\\mathbf{I}, \\mathbf{P}, \\mathbf{V})</span> has round-by-round knowledge error $\\max (\\kappa_{\\mathrm{rbr}}^{\\mathcal{R}}, \\epsilon_{\\mathrm{rbr}}^{\\mathrm{LDT}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. The proof is essentially identical to [BCRSVW19, Theorem 8.1]; note, however, that we do not need to low-degree test the encoded index since it is honestly generated.</p>

    <p class="text-gray-300">To show round-by-round soundness, we define a state function <span class="math">\\mathsf{State}</span> using the state functions <span class="math">\\mathsf{State}^{\\mathcal{R}}</span> and <span class="math">\\mathsf{State}^{\\mathrm{LDT}}</span> of the holographic IOP and low-degree test, respectively. Since the protocols are sequentially composed, we can split the transcript into three parts: <span class="math">\\mathsf{tr}^{\\mathcal{R}}</span>, the first <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds; <span class="math">\\vec{z}</span>, the verifier message in round <span class="math">\\mathsf{k}^{\\mathcal{R}} + 1</span> (to make a full round we precede this with a "dummy" prover message); and <span class="math">\\mathsf{tr}^{\\mathrm{LDT}}</span>, the last <span class="math">\\mathsf{k}^{\\mathrm{LDT}}</span> rounds. The state function is described by the following algorithm:</p>

    <p class="text-gray-300">State( <span class="math">\\dot{\\mathfrak{s}}, \\mathfrak{z}, \\mathfrak{tr}^{\\mathcal{R}}, \\vec{z}, \\mathfrak{tr}^{\\mathrm{LDT}}</span> ):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(\\Pi_1, m_1, \\ldots, \\Pi_j, m_j) := \\operatorname{tr}^{\\mathcal{R}}</span> (for some <span class="math">j \\leq k^{\\mathcal{R}}</span>). If <span class="math">\\Pi_i</span> is <span class="math">\\delta^{\\mathrm{LDT}}</span>-close to <span class="math">\\operatorname{RS}[L, \\vec{d}_{\\mathbf{P},i}]</span> for all <span class="math">i \\in [j]</span>, output <span class="math">\\mathsf{State}^{\\mathcal{R}}(\\Pi_1&#x27;, m_1, \\ldots, \\Pi_j&#x27;, m_j)</span> where <span class="math">\\Pi_i&#x27; \\in \\operatorname{RS}[L, \\vec{d}_{\\mathbf{P},i}]</span> is the closest codeword to <span class="math">\\Pi_i</span>.</li>

      <li>If <span class="math">\\vec{z}</span> is empty then output reject; if <span class="math">\\vec{z}^T\\Pi</span> is <span class="math">\\delta^{\\mathrm{LDT}}</span>-close to <span class="math">\\mathrm{RS}[L, d_{\\mathbf{c}}]</span> then output accept, where <span class="math">\\Pi</span> is the "stacked" proof matrix (see [BCRSVW19, Protocol 8.2]).</li>

      <li>Otherwise, output <span class="math">\\mathsf{State}^{\\mathrm{LDT}}(\\dot{\\mathfrak{s}}, \\mathfrak{z}, \\mathfrak{tr}^{\\mathrm{LDT}})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly <span class="math">\\mathsf{State}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\emptyset) = \\mathsf{State}^{\\mathcal{R}}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\emptyset) = \\mathsf{reject}</span>. For any partial transcript <span class="math">\\mathfrak{tr}</span>, if <span class="math">\\mathfrak{tr}</span> ends during the first stage of the protocol then <span class="math">\\mathsf{rbr}(\\mathfrak{tr}) \\leq \\epsilon_{\\mathrm{rbr}}^{\\mathcal{R}}</span>. If <span class="math">\\mathfrak{tr}</span> ends with round <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> and <span class="math">\\mathsf{State}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\mathfrak{tr}) = \\mathsf{reject}</span> then the probability that <span class="math">\\vec{z}^T\\Pi</span> is <span class="math">\\delta^{\\mathrm{LDT}}</span>-close to <span class="math">\\mathrm{RS}[L,d_{\\mathbf{c}}]</span> is bounded by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; hence </span>\\mathsf{rbr}(\\mathfrak{tr}) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Finally, if </span>\\mathfrak{tr}<span class="math"> ends after round </span>\\mathsf{k}^{\\mathcal{R}} + 1<span class="math">, if </span>\\mathsf{State}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\mathfrak{tr}) = \\mathsf{reject}<span class="math"> then </span>\\vec{z}^T\\Pi<span class="math"> is </span>\\delta^{\\mathrm{LDT}}<span class="math">-far from </span>\\mathrm{RS}[L,d_{\\mathbf{c}}]<span class="math">, and so by the RBR soundness guarantee of the low-degree test </span>\\mathsf{rbr}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\mathfrak{tr}) \\leq \\epsilon_{\\mathrm{rbr}}^{\\mathrm{LDT}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The same state function witnesses round-by-round knowledge soundness. Suppose that for some transcript <span class="math">\\mathfrak{tr}</span> with <span class="math">\\mathsf{State}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\mathfrak{tr}) = \\mathsf{reject}</span>, $\\mathsf{rbr}(\\mathfrak{tr}) &gt; \\max (\\kappa_{\\mathrm{rbr}}^{\\mathcal{R}},\\epsilon_{\\mathrm{rbr}}^{\\mathrm{LDT}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Since </span>\\mathsf{rbr}(\\mathfrak{tr}) &gt; \\max (\\epsilon_{\\mathrm{rbr}}^{\\mathrm{LDT}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, it must be that </span>\\Pi_i<span class="math"> is </span>\\delta^{\\mathrm{LDT}}<span class="math">-close to </span>\\mathrm{RS}[L,\\vec{d}_{\\mathbf{P},i}]<span class="math"> for all </span>i<span class="math">; hence </span>\\mathsf{State}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\mathfrak{tr}_c^{\\mathcal{R}}) = \\mathsf{State}(\\dot{\\mathfrak{s}},\\mathfrak{z},\\mathfrak{tr}) = \\mathsf{accept}<span class="math">. We apply the knowledge extractor of the RS-hIOP to </span>\\tilde{\\mathbf{P}}_c<span class="math">, which runs </span>\\tilde{\\mathbf{P}}$ and corrects its output words. The knowledge soundness guarantee for the RS-hIOP ensures that this extractor succeeds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Theorem 8.1. The two main ingredients in the proof are the RS-hIOP of Theorem 7.1 and the FRI low-degree test [BBHR18]. These are combined using Theorem 8.2 to build the described IOP. The indexer in our construction will choose <span class="math">L</span> to be a coset of a smooth subgroup of <span class="math">\\mathbb{F}</span> with, say, $8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>(H \\cup K) \\cap L = \\emptyset$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">We denote by  <span class="math">\\mathcal{U}(\\lambda)</span>  the set of all functions that map  <span class="math">\\{0,1\\}^<em></span>  to  <span class="math">\\{0,1\\}^\\lambda</span> . A random oracle with security parameter  <span class="math">\\lambda</span>  is a function  <span class="math">\\rho \\colon \\{0,1\\}^</em> \\to \\{0,1\\}^\\lambda</span>  sampled uniformly at random from  <span class="math">\\mathcal{U}(\\lambda)</span> .</p>

    <p class="text-gray-300">A tuple of algorithms  <span class="math">\\mathsf{ARG} = (\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  is a preprocessing non-interactive argument in the random oracle model (ROM) for an indexed relation  <span class="math">\\mathcal{R}</span>  if the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every adversary  <span class="math">\\mathcal{A}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\dot {\\mathfrak {i}}, \\mathfrak {z}, \\mathfrak {w}) \\notin \\mathcal {R} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\vee &amp;amp; (\\mathfrak {i k}, \\mathfrak {z}, \\mathfrak {w}) \\leftarrow \\mathcal {A} ^ {\\rho} \\\\ \\mathcal {V} ^ {\\rho} (\\mathfrak {i k}, \\mathfrak {z}, \\mathfrak {w}) = 1 &amp;amp; (\\mathfrak {i p k}, \\mathfrak {i k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\dot {\\mathfrak {i}}) \\\\ &amp;amp; \\pi \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathfrak {i p k}, \\mathfrak {z}, \\mathfrak {w}) \\end{array} \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For every  <span class="math">t</span> -query adversary  <span class="math">\\tilde{\\mathcal{P}}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\dot {\\mathfrak {i}}, \\mathfrak {z}) \\notin \\mathcal {L} (\\mathcal {R}) &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; (\\dot {\\mathfrak {i}}, \\mathfrak {z}, \\mathfrak {w}) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} \\\\ \\mathcal {V} ^ {\\rho} (\\mathfrak {i k}, \\mathfrak {z}, \\mathfrak {w}) = 1 &amp;amp; (\\mathfrak {i p k}, \\mathfrak {i k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\dot {\\mathfrak {i}}) \\end{array} \\right] \\leq \\epsilon (t, \\lambda)  .</span></div>

    <p class="text-gray-300">The above formulation of completeness allows  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z},\\mathfrak{w})</span>  to depend on the random oracle  <span class="math">\\rho</span> , and the above formulation of soundness allows  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z})</span>  to depend on the random oracle  <span class="math">\\rho</span> .</p>

    <p class="text-gray-300">All constructions in this paper achieve the stronger property of knowledge soundness, and optionally also the property of (statistical) zero knowledge. We define both of these properties below.</p>

    <p class="text-gray-300">Knowledge soundness. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has (adaptive) knowledge error  <span class="math">\\kappa</span>  if there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every  <span class="math">t</span> -query adversary  <span class="math">\\tilde{\\mathcal{P}}</span>  and predicate  <span class="math">p</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} p (\\vec {\\mathfrak {i}}, \\vec {\\mathfrak {z}}, \\mathsf {a u x}) = 1 &amp;amp; (\\vec {\\mathfrak {i}}, \\vec {\\mathfrak {z}}, \\vec {\\mathfrak {w}}, \\mathsf {a u x}) \\leftarrow \\mathcal {E} ^ {\\tilde {\\mathcal {P}}} (1 ^ {t}, 1 ^ {\\lambda}) \\\\ \\wedge \\forall j \\in [ \\ell ], &amp;amp; (\\mathfrak {i}, \\mathfrak {z}, \\mathfrak {w}, \\mathfrak {w}) \\in \\mathcal {R} \\end{array} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c c} p (\\vec {\\mathrm {i}}, \\vec {\\mathrm {z}}, \\mathrm {a u x}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge \\forall j \\in [ \\ell ], &amp;amp; (\\vec {\\mathrm {i}}, \\vec {\\mathrm {z}}, \\vec {\\pi}, \\mathrm {a u x}) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k} _ {j}, \\mathrm {z} _ {j}, \\pi_ {j}) = 1 &amp;amp; \\forall j, (\\mathrm {i p k} _ {j}, \\mathrm {i v k} _ {j}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathrm {i} _ {j}) \\end{array} \\right] - \\kappa (t, \\lambda , \\ell). \\tag {5} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This implies that the distributions of  <span class="math">(\\vec{\\mathfrak{i}},\\vec{\\mathfrak{z}},\\mathrm{aux})</span>  in the following experiments are  <span class="math">\\kappa</span> -close:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\vec{\\mathfrak{i}}, \\vec{\\mathfrak{z}}, \\vec{\\pi}, \\mathrm{aux}) \\gets \\tilde{\\mathcal{P}}^{\\rho}</span> , restricted to the space where for all  <span class="math">j</span> ,  <span class="math">\\pi_j</span>  is a valid proof for  <span class="math">(\\dot{\\mathfrak{i}}_j, \\mathfrak{z}_j)</span> ; and</li>

      <li><span class="math">(\\vec{\\mathfrak{i}}, \\vec{\\mathfrak{z}}, \\vec{\\mathfrak{w}}, \\mathrm{aux}) \\gets \\mathcal{E}^{\\tilde{\\mathcal{P}}} (1^t, 1^\\lambda)</span> , restricted to the space where for all  <span class="math">j</span> ,  <span class="math">(\\dot{\\mathfrak{i}}_j, \\mathfrak{z}_j, \\mathfrak{w}_j) \\in \\mathcal{R}</span> .</li>

    </ul>

    <p class="text-gray-300">Zero knowledge. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has (adaptive statistical) zero knowledge if there exists a probabilistic polynomial-time simulator  <span class="math">S</span>  such that for every  <span class="math">t</span> -query honest adversary  <span class="math">\\mathcal{A}</span>  the distributions below are statistically close (as a function of  <span class="math">\\lambda</span> ):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{(\\rho , \\dot {\\mathfrak {i}}, \\mathfrak {z}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\dot {\\mathfrak {i}}, \\mathfrak {z}, \\mathfrak {w}) \\leftarrow \\mathcal {A} ^ {\\rho} \\\\ (\\mathfrak {i p k}, \\mathfrak {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\dot {\\mathfrak {i}}) \\\\ \\pi \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathfrak {i p k}, \\mathfrak {z}, \\mathfrak {w}) \\end{array} \\right\\} \\quad \\text {a n d} \\quad \\left\\{(\\rho [ \\mu ], \\dot {\\mathfrak {i}}, \\mathfrak {z}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\dot {\\mathfrak {i}}, \\mathfrak {z}, \\mathfrak {w}) \\leftarrow \\mathcal {A} ^ {\\rho} \\\\ (\\mu , \\pi) \\leftarrow \\mathcal {S} ^ {\\rho} (\\dot {\\mathfrak {i}}, \\mathfrak {z}) \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">above, <span class="math">\\rho[\\mu]</span> is the function that, on input <span class="math">x</span>, equals <span class="math">\\mu(x)</span> if <span class="math">\\mu</span> is defined on <span class="math">x</span>, or <span class="math">\\rho(x)</span> otherwise. This definition uses explicitly-programmable random oracles <em>[x1]</em>. (Non-interactive zero knowledge with non-programmable random oracles is impossible for non-trivial languages <em>[x21, x3]</em>.) Here, by an honest adversary we mean an adversary whose output satisfies <span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})\\in\\mathcal{R}</span> with probability <span class="math">1</span>.</p>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">Post-quantum security.</h4>

    <p class="text-gray-300">The above definitions consider security against classical adversaries that make a bounded number of queries to the oracle (and are otherwise computationally unbounded). We also consider security against quantum adversaries, whose queries to the oracle can be in superposition. This setting is known as the quantum random oracle model (QROM) <em>[x2]</em>, and is the established model to study post-quantum security for constructions that use random oracles. The soundness definition and knowledge soundness definition for post-quantum security are identical to the ones above, except that <span class="math">\\hat{\\mathcal{P}}^{\\rho}</span> is now taken to mean that <span class="math">\\hat{\\mathcal{P}}</span> has superposition query access to <span class="math">\\rho</span>; the zero knowledge definition remains unchanged because indistinguishability holds against unbounded adversaries that see the whole oracle.</p>

    <p class="text-gray-300">We do not know if, in the quantum setting, knowledge soundness with auxiliary output is polynomially related to knowledge soundness without auxiliary output.</p>

    <p class="text-gray-300">40</p>

    <p class="text-gray-300">We describe how to transform any public-coin holographic IOP (Section 4) into a corresponding preprocessing non-interactive argument in the ROM (Section 9). We additionally explain how the same transformation achieves post-quantum security in the QROM. A main goal is achieving adaptive knowledge soundness.</p>

    <p class="text-gray-300"><strong>Theorem 10.1.</strong> There exists a polynomial-time transformation <span class="math">\\mathrm{T}</span> such that if <span class="math">\\mathrm{HOL} = (\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is a public-coin holographic IOP for an indexed relation <span class="math">\\mathcal{R}</span> then <span class="math">\\mathsf{ARG} = (\\mathcal{I},\\mathcal{P},\\mathcal{V}) := \\mathrm{T}(\\mathrm{HOL})</span> is a preprocessing non-interactive argument in the ROM for <span class="math">\\mathcal{R}</span>. The transformation <span class="math">\\mathrm{T}</span> satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Efficiency</strong>: If HOL has oracle length L and query complexity q then ARG has argument size <span class="math">O(\\lambda \\cdot q \\cdot \\log L)</span>; moreover, the time complexities of the argument indexer, prover, and verifier are as follows</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{time}(\\mathcal{I}) = \\operatorname{time}(\\mathbf{I}) + O(\\lambda \\mathrm{L}) \\, , \\\\ \\operatorname{time}(\\mathcal{P}) = \\operatorname{time}(\\mathbf{P}) + O(\\lambda \\mathrm{L}) \\, , \\\\ \\operatorname{time}(\\mathcal{V}) = \\operatorname{time}(\\mathbf{V}) + O(\\lambda \\cdot \\mathfrak{q} \\cdot \\log \\mathrm{L}) \\, . \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>ZK preservation</strong>: if HOL is honest-verifier zero knowledge then ARG is adaptive statistical zero knowledge.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Adaptive knowledge from SR</strong>: If HOL has state-restoration knowledge error <span class="math">\\kappa_{\\mathrm{sr}}(t)</span> then ARG has adaptive knowledge error <span class="math">\\kappa(t, \\lambda, \\ell) = t \\cdot (\\kappa_{\\mathrm{sr}}(t) + O(t^2 \\cdot 2^{-\\lambda}))</span>.¹³</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Adaptive knowledge from RBR</strong>: If HOL has round-by-round knowledge error <span class="math">\\kappa_{\\mathrm{rbr}}</span> then ARG has adaptive knowledge error <span class="math">\\kappa(t, \\lambda, \\ell) = t \\cdot \\kappa_{\\mathrm{rbr}} + O(t^2 \\cdot 2^{-\\lambda})</span> in the ROM and adaptive knowledge error <span class="math">\\kappa(t, \\lambda, \\ell) = O(t^2 \\cdot \\kappa_{\\mathrm{rbr}} + t^3 \\cdot 2^{-\\lambda})</span> in the QROM.</li>

    </ul>

    <h2 id="sec-73" class="text-2xl font-bold">10.1 Construction</h2>

    <p class="text-gray-300">The transformation <span class="math">\\mathrm{T}</span> has two parts. First, we apply the BCS transformation [BCS16] to the holographic IOP to obtain a “holographic” non-interactive argument, namely, a non-interactive argument where the (deterministic) argument verifier is fast when given oracle access to the encoded index. Next, we transform this into a preprocessing non-interactive argument by having the argument indexer output a Merkle commitment to the encoded index, and having the argument prover additionally output Merkle openings to the positions of the encoded index queried by the IOP verifier.</p>

    <p class="text-gray-300">We now describe the transformation <span class="math">\\mathrm{T}</span> in more detail: in Construction 10.2 we recall the transformation <span class="math">\\mathrm{T}_{\\mathrm{BCS}}</span> of [BCS16], adapting its presentation to holographic IOPs (but the construction is identical otherwise); then in Construction 10.3 we describe the transformation <span class="math">\\mathrm{T}</span>, using <span class="math">\\mathrm{T}_{\\mathrm{BCS}}</span> as a subroutine.</p>

    <p class="text-gray-300"><strong>Construction 10.2 (T<span class="math">_{\\mathrm{BCS}}</span>)</strong>. The transformation <span class="math">\\mathrm{T}_{\\mathrm{BCS}}</span> takes as input a holographic IOP <span class="math">\\mathsf{HOL} = (\\mathbf{I}, \\mathbf{P}, \\mathbf{V})</span> and outputs the (standard) non-interactive argument <span class="math">\\mathsf{ARG}_{\\mathrm{BCS}} = (\\mathcal{P}_{\\mathrm{BCS}}, \\mathcal{V}_{\\mathrm{BCS}})</span> defined below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{\\mathrm{BCS}}^{\\rho}(\\dot{\\mathbf{i}}, \\mathbf{x}, \\mathbf{w})</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Set $\\sigma_0 := \\mathrm{ivk} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}<span class="math">, where </span>(\\mathrm{ivk}, \\mathrm{ipk}) \\gets \\mathcal{I}(\\dot{\\mathbf{i}})<span class="math"> and </span>\\mathcal{I}$ is the argument indexer in Construction 10.3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i = 1, \\ldots, k</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute randomness <span class="math">\\rho_{i}:=\\rho(\\sigma_{i-1})</span> for the <span class="math">i</span>-th round.</li>

      <li>Provide <span class="math">\\rho_{i}</span> to the IOP prover <span class="math">\\mathbf{P}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})</span> to obtain a proof oracle <span class="math">\\Pi_{i}</span>.</li>

      <li>Use <span class="math">\\rho</span> to compute a Merkle tree on <span class="math">\\Pi_{i}</span>, and in particular to obtain a Merkle root <span class="math">\\mathsf{rt}_{i}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Set $\\sigma_{i}:=\\rho(\\sigma_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{rt}_{i})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute randomness <span class="math">\\rho_{k+1}:=\\rho(\\sigma_{k})</span> for the query phase.</li>

      <li>Run the IOP verifier <span class="math">\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathfrak{x};\\rho_{1},\\ldots,\\rho_{k},\\rho_{k+1})</span>, answering queries via the proof oracles <span class="math">(\\Pi_{1},\\ldots,\\Pi_{k})</span>, so to deduce the set of queries <span class="math">Q</span> that are asked on randomness <span class="math">(\\rho_{1},\\ldots,\\rho_{k},\\rho_{k+1})</span>.</li>

      <li>Output the proof string <span class="math">\\pi</span> that contains all the Merkle roots <span class="math">(\\mathsf{rt}_{1},\\cdots,\\mathsf{rt}_{k})</span> and, for each query in <span class="math">Q</span>, an answer supported by an authentication path (against the appropriate root).</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}_{\\text{\\tiny BCS}}^{\\rho}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\pi)\\equiv\\mathcal{V}_{\\text{\\tiny BCS}}^{\\rho,\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathfrak{x},\\pi)</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Set <span class="math">\\sigma_{0}:=0^{\\lambda}</span> and use the <span class="math">i</span>-th root <span class="math">\\mathsf{rt}_{i}</span> in <span class="math">\\pi</span> to set $\\sigma_{i}:=\\rho(\\sigma_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{rt}_{i})<span class="math"> for </span>i=1,\\ldots,k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute each randomness: <span class="math">\\rho_{1}:=\\rho(\\sigma_{0}),\\ldots,\\rho_{k}:=\\rho(\\sigma_{k-1}),\\rho_{k+1}:=\\rho(\\sigma_{k})</span>.</li>

      <li>Run the IOP verifier <span class="math">\\mathbf{V}^{\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathfrak{x};\\rho_{1},\\ldots,\\rho_{k},\\rho_{k+1})</span>. Whenever <span class="math">\\mathbf{V}</span> queries a proof oracle <span class="math">\\Pi_{i}</span>, validate the authentication path for this query in <span class="math">\\pi</span>, and answer the query with the corresponding value in <span class="math">\\pi</span>. (If <span class="math">\\pi</span> contains no entry for a query, reject.) Accept if and only if <span class="math">\\mathbf{V}</span> accepts.</li>

    </ol>

    <p class="text-gray-300">We write <span class="math">\\mathcal{V}_{\\text{\\tiny BCS}}</span> as an algorithm with oracle access to <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span> to emphasize that <span class="math">\\mathrm{T}_{\\text{\\tiny BCS}}</span> is black-box with respect to <span class="math">\\mathbf{V}</span>: the queries <span class="math">\\mathcal{V}_{\\text{\\tiny BCS}}</span> makes to <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span> are exactly the queries <span class="math">\\mathbf{V}</span> makes to <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span> (on appropriate randomness).</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Construction 10.3 (T).</h6>

    <p class="text-gray-300">The transformation <span class="math">\\mathrm{T}</span> takes as input a public-coin holographic IOP <span class="math">\\mathsf{HOL}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> and outputs the preprocessing non-interactive argument <span class="math">\\mathsf{ARG}=(\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> defined below. We let <span class="math">(\\mathcal{P}_{\\text{\\tiny BCS}},\\mathcal{V}_{\\text{\\tiny BCS}})</span> be the BCS prover and verifier output by <span class="math">\\mathrm{T}_{\\text{\\tiny BCS}}(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>, and view <span class="math">\\mathcal{V}_{\\text{\\tiny BCS}}</span> as having oracle access to <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Indexer. On input <span class="math">\\dot{\\mathfrak{s}}</span>, <span class="math">\\mathcal{I}^{\\rho}</span> computes the encoded index <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span>, computes a Merkle commitment <span class="math">\\mathsf{rt}</span> to <span class="math">\\mathbf{I}(\\dot{\\mathfrak{s}})</span> using the sub-oracle <span class="math">\\rho_{0}</span>, and outputs the key pair <span class="math">(\\mathsf{ipk},\\mathsf{ivk}):=((\\dot{\\mathfrak{s}},\\mathbf{I}(\\dot{\\mathfrak{s}})),(\\mathsf{rt},\\rho_{0}(\\dot{\\mathfrak{s}}))</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Prover. On input <span class="math">(\\mathsf{ipk},\\mathfrak{x},\\mathfrak{w})</span>, <span class="math">\\mathcal{P}^{\\rho}</span> parses the proving key <span class="math">\\mathsf{ipk}</span> as <span class="math">(\\dot{\\mathfrak{s}},\\mathbf{I}(\\dot{\\mathfrak{s}}))</span>, computes $z:=\\rho_{0}(\\rho_{0}(\\dot{\\mathfrak{s}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{x})<span class="math">, computes the output of the BCS prover </span>\\pi_{\\text{\\tiny BCS}}:=\\mathcal{P}_{\\text{\\tiny BCS}}^{\\rho_{z}}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathfrak{w})<span class="math">, simulates the BCS verifier </span>\\mathcal{V}_{\\text{\\tiny BCS}}^{\\rho_{z},\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathfrak{x},\\pi_{\\text{\\tiny BCS}})<span class="math"> letting </span>\\mathsf{ap}_{i}<span class="math"> be the authentication path for its </span>i<span class="math">-th query to </span>\\mathbf{I}(\\dot{\\mathfrak{s}})<span class="math">, and outputs the proof string </span>\\pi:=(\\pi_{\\text{\\tiny BCS}},(\\mathsf{ap}_{1},\\ldots,\\mathsf{ap}_{k}))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above we use certain domain separations for the random oracle. We define $\\rho_{b}(m):=\\rho(b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)<span class="math"> for </span>b\\in\\{0,1\\}<span class="math"> and </span>\\rho_{z}(m):=\\rho_{1}(z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)<span class="math">. The sub-oracle </span>\\rho_{0}<span class="math"> is used to commit to the index </span>\\dot{\\mathfrak{s}}<span class="math">, while the sub-oracle </span>\\rho_{1}<span class="math"> is used by BCS prover and BCS verifier (further specialized with session identifier </span>z$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">10.2 Completeness, efficiency, and non-adaptive zero knowledge</h3>

    <h5 id="sec-76" class="text-base font-semibold mt-4">Completeness.</h5>

    <p class="text-gray-300">This is straightforward from the protocol description.</p>

    <h5 id="sec-77" class="text-base font-semibold mt-4">Efficiency.</h5>

    <p class="text-gray-300">The proof string <span class="math">\\pi</span> output by the argument prover <span class="math">\\mathcal{P}</span> has two components: the proof string <span class="math">\\pi_{\\text{\\tiny BCS}}</span> output by the BCS prover <span class="math">\\mathcal{P}_{\\text{\\tiny BCS}}</span>, and authentication paths <span class="math">(\\mathsf{ap}_{1},\\ldots,\\mathsf{ap}_{k})</span> that answer queries by the IOP verifier <span class="math">\\mathbf{V}</span> to the encoded index. Each of these components has size <span class="math">O(\\lambda\\cdot\\mathsf{q}\\cdot\\log\\mathsf{L})</span>. We now discuss time complexities. The overhead of the argument indexer <span class="math">\\mathcal{I}</span> with respect to the IOP indexer <span class="math">\\mathbf{I}</span> is <span class="math">O(\\lambda\\cdot\\mathsf{L})</span>, due to the cost of committing to the encoded index output by <span class="math">\\mathbf{I}</span>. The overhead of the argument prover <span class="math">\\mathcal{P}</span> with respect</p>

    <p class="text-gray-300">to the IOP prover <span class="math">\\mathbf{P}</span> is <span class="math">O(\\lambda \\cdot \\mathsf{L})</span>, due to the cost of committing to each oracle output by <span class="math">\\mathbf{P}</span> (and the cost to answer queries by the IOP verifier <span class="math">\\mathbf{V}</span> to the oracles or the encoded index). The overhead of the argument verifier <span class="math">\\mathcal{V}</span> with respect to the IOP verifier <span class="math">\\mathbf{V}</span> is <span class="math">O(\\lambda \\cdot \\mathsf{q} \\cdot \\log \\mathsf{L})</span>, due to the cost to validate the authentication path associated to each query made by <span class="math">\\mathbf{V}</span> (to a proof oracle or the encoded index).</p>

    <p class="text-gray-300"><strong>Non-adaptive zero knowledge.</strong> The fact that the transformation <span class="math">\\mathrm{T}</span> preserves zero knowledge follows from the fact that the BCS transformation <span class="math">\\mathrm{T}_{\\mathrm{BCS}}</span> preserves zero knowledge (if leaves in the Merkle tree are suitably salted), because the simulator is given the index <span class="math">\\hat{\\mathbf{s}}</span> as input. See [BCS16] for details on why if HOL is honest-verifier zero knowledge (when viewed as a non-holographic proof system) then <span class="math">(\\mathcal{P}_{\\mathrm{BCS}}, \\mathcal{V}_{\\mathrm{BCS}})</span> is statistical zero knowledge, in the <em>non-adaptive</em> case (where the index and instance are fixed in advance). Note that in the non-adaptive case there is no difference between classical and post-quantum statistical zero knowledge for a non-interactive protocol.</p>

    <h2 id="sec-78" class="text-2xl font-bold">10.3 Non-adaptive soundness and knowledge</h2>

    <p class="text-gray-300">We first consider <em>non-adaptive</em> soundness and knowledge soundness in both the classical and post-quantum settings as a warm up to the adaptive case.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Classical soundness.</strong> Consider an index-instance pair <span class="math">(\\hat{\\mathbf{s}}, \\mathbf{x})</span> that is not in <span class="math">\\mathcal{L}(\\mathcal{R})</span> and a <span class="math">t</span>-query malicious prover <span class="math">\\tilde{\\mathcal{P}}</span>. Let <span class="math">E</span> be the event that, over a random oracle <span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span> and letting <span class="math">(\\mathsf{ipk}, \\mathsf{ivk}) \\gets \\mathcal{I}^{\\rho_0}(\\hat{\\mathbf{s}})</span>, for the proof string <span class="math">\\tilde{\\pi} = (\\tilde{\\pi}_{\\mathrm{BCS}}, (\\mathsf{ap}_1, \\ldots, \\mathsf{ap}_k))</span> output by <span class="math">\\tilde{\\mathcal{P}}^\\rho</span> there exists an authentication path <span class="math">\\mathsf{ap}_i</span> for some query location $j \\in</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}(\\hat{\\mathbf{s}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is valid with respect to </span>\\mathsf{ivk}<span class="math">, </span>\\rho<span class="math"> but the opened value is not equal to </span>\\mathbf{I}(\\hat{\\mathbf{s}})_j<span class="math">. If </span>E<span class="math"> occurs then we can find a collision in </span>\\rho<span class="math"> via </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}(\\hat{\\mathbf{s}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ additional queries. Therefore</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr_{\\rho} \\left[ \\mathcal{V}^{\\rho} (\\mathrm{ivk}, \\mathbf{x}, \\tilde{\\pi}) = 1 \\right] \\\\ \\leq \\Pr_{\\rho} \\left[ \\mathcal{V}^{\\rho} (\\mathrm{ivk}, \\mathbf{x}, \\tilde{\\pi}) = 1 \\mid \\neg E \\right] + \\Pr_{\\rho} [E] \\\\ \\leq \\Pr_{z, \\rho_1} \\left[ \\mathcal{V}_{\\mathrm{BCS}}^{\\rho_z, \\mathbf{I}(\\hat{\\mathbf{s}})} (\\mathbf{x}, \\tilde{\\pi}_{\\mathrm{BCS}}) = 1 \\right] + (t + O(\\mathsf{L}))^2 / 2^{\\lambda}. \\tag{6} \\end{array}</span></div>

    <p class="text-gray-300">The (non-adaptive) soundness guarantee of <span class="math">\\mathrm{T}_{\\mathrm{BCS}}</span> ensures that for any string <span class="math">z</span>, <span class="math">\\operatorname{Pr}_{\\rho_1}[\\mathcal{V}_{\\mathrm{BCS}}^{\\rho_z,\\mathbf{I}(\\hat{\\mathbf{s}})}(\\mathbf{x},\\tilde{\\pi}_{\\mathrm{BCS}}) = 1] \\leq \\epsilon_{\\mathrm{sr}}(t) + O(t^2 \\cdot 2^{-\\lambda})</span>, which yields the stated bound (since the query bound <span class="math">t</span> can be assumed to be at least <span class="math">\\mathsf{L}</span>).</p>

    <p class="text-gray-300"><strong>Post-quantum soundness.</strong> The post-quantum soundness argument follows the same outline as the classical argument, except that: (i) we now use the result of [CMS19] to bound the probability that the BCS verifier accepts in the QROM, and (ii) we use the quantum query lower bound for collisions [AS04] to bound the probability of the event <span class="math">E</span> (which implies that a collision was found). This yields the stated bound.</p>

    <p class="text-gray-300"><strong>Classical knowledge soundness.</strong> We will prove the following non-adaptive knowledge soundness property. For all <span class="math">\\hat{\\mathbf{s}},\\mathbf{x}</span>, and <span class="math">t</span>-query adversaries <span class="math">\\tilde{\\mathcal{P}}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mu := \\Pr \\left[ \\begin{array}{c c} (\\hat{\\mathbf{s}}, \\mathbf{x}, \\mathbf{w}) \\notin \\mathcal{R} &amp;amp; \\rho \\leftarrow \\mathcal{U}(\\lambda) \\\\ \\wedge &amp;amp; (\\pi; Q) \\leftarrow \\tilde{\\mathcal{P}}^{\\rho} \\\\ \\mathcal{V}^{\\rho}(\\mathrm{ivk}, \\mathbf{x}, \\pi) = 1 &amp;amp; \\mathbf{w} \\leftarrow \\mathcal{E}(\\hat{\\mathbf{s}}, \\mathbf{x}, \\pi, Q) \\\\ &amp;amp; (\\mathrm{ipk}, \\mathrm{ivk}) \\leftarrow \\mathcal{I}^{\\rho}(\\hat{\\mathbf{s}}) \\end{array} \\right] \\leq \\kappa_T(t, \\lambda).</span></div>

    <p class="text-gray-300">where <span class="math">(\\pi;Q) \\gets \\tilde{\\mathcal{P}}^{\\rho}</span> denotes that <span class="math">\\pi</span> is the output of <span class="math">\\tilde{\\mathcal{P}}^{\\rho}</span> and <span class="math">Q\\colon \\{0,1\\}^{*} \\rightharpoonup \\{0,1\\}^{\\lambda}</span> is a database of its oracle queries and answers. Note that if <span class="math">\\tilde{\\mathcal{P}}</span> has some auxiliary output (as in the full adaptive knowledge soundness definition) then the distribution of this output is clearly preserved when we extract.</p>

    <p class="text-gray-300">42</p>

    <p class="text-gray-300">Inspection of the proof of knowledge soundness in [BCS16] shows that if HOL is state-restoration knowledge sound in the sense of Definition 4.5 then the extractor <span class="math">\\mathcal{E}_{\\text{\\tiny BCS}}</span> for <span class="math">\\mathsf{ARG}_{\\text{\\tiny BCS}}</span> fulfills the guarantee</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathrm {i}}, \\mathrm {z}, \\mathrm {w}) \\notin \\mathcal {R} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; (\\pi ; Q) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} \\\\ \\mathcal {V} ^ {\\rho , \\mathbf {I} (\\dot {\\mathrm {i}})} (\\mathrm {z}, \\pi) = 1 &amp;amp; \\mathrm {w} \\leftarrow \\mathcal {E} _ {\\mathrm {B C S}} (\\dot {\\mathrm {i}}, \\mathrm {z}, \\pi , Q) \\end{array} \\right] \\leq \\kappa_ {\\mathrm {s r}} (t) + O \\left(t ^ {2} \\cdot 2 ^ {- \\lambda}\\right) \\tag {7}</span></div>

    <p class="text-gray-300">for all <span class="math">\\dot{\\mathbf{i}},\\mathbf{z}</span> and <span class="math">t</span>-query <span class="math">\\tilde{\\mathcal{P}}</span>; in particular, the extractor <span class="math">\\mathcal{E}_{\\mathrm{BCS}}</span> need only see the queries and answers of the prover, and does not otherwise interact with it. This leads naturally to the extractor <span class="math">\\mathcal{E}</span> for ARG described below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}(\\dot{\\mathbf{i}},\\mathbf{z},\\pi ,Q)</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Let $z\\coloneqq Q(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathbf{i}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z})<span class="math"> be the &quot;session identifier&quot; for the index </span>\\dot{\\mathbf{i}}<span class="math"> and instance </span>\\mathbf{z}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the BCS extractor <span class="math">\\mathbf{w} \\gets \\mathcal{E}_{\\mathrm{BCS}}(\\dot{\\mathbf{i}}, \\mathbf{z}, \\pi_{\\mathrm{BCS}}, Q&#x27;)</span>.</li>

      <li>Output <span class="math">\\mathbf{w}</span>.</li>

    </ol>

    <p class="text-gray-300">Fix arbitrary <span class="math">\\dot{\\mathbf{i}},\\mathbf{z},\\tilde{\\mathcal{P}}</span>. Observe that running <span class="math">\\mathcal{E}</span> on <span class="math">\\tilde{\\mathcal{P}}</span> is equivalent to running <span class="math">\\mathcal{E}_{\\mathrm{BCS}}</span> on the algorithm:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tilde{\\mathcal{P}}_0^\\rho</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Simulate <span class="math">\\tilde{\\mathcal{P}}</span>, answering its queries with uniform randomness, until it queries $(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathbf{i}})<span class="math">; respond with random </span>a\\in \\{0,1\\}^{\\lambda}$ (else abort).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Continue simulating <span class="math">\\tilde{\\mathcal{P}}</span> until it halts and outputs <span class="math">(\\pi_{\\mathrm{BCS}},\\tilde{\\mathrm{ap}})</span>, answering its queries $(1\\</td>

            <td class="px-3 py-2 border-b border-gray-700">z\\</td>

            <td class="px-3 py-2 border-b border-gray-700">q)<span class="math"> with </span>\\rho (q)$ and other queries with uniform randomness.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\pi_{\\mathrm{BCS}}</span>.</li>

    </ol>

    <p class="text-gray-300">From Eq. (6) and standard random oracle arguments it is then straightforward to show that</p>

    <div class="my-4 text-center"><span class="math-block">\\mu \\leq \\operatorname * {P r} \\left[ \\begin{array}{c c} (\\dot {\\mathbf {i}}, \\mathbf {z}, \\mathbf {w}) \\notin \\mathcal {R} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; (\\pi_ {\\mathrm {B C S}}; Q) \\leftarrow \\tilde {\\mathcal {P}} _ {0} ^ {\\rho} \\\\ \\mathcal {V} _ {\\mathrm {B C S}} ^ {\\rho , \\mathbf {I} (\\dot {\\mathbf {i}})} (\\mathbf {z}, \\pi_ {\\mathrm {B C S}}) = 1 &amp;amp; \\mathbf {w} \\leftarrow \\mathcal {E} _ {\\mathrm {B C S}} (\\dot {\\mathbf {i}}, \\mathbf {z}, \\pi_ {\\mathrm {B C S}}, Q) \\end{array} \\right] + O (t ^ {2} \\cdot 2 ^ {- \\lambda}) ,</span></div>

    <p class="text-gray-300">which, combined with Eq. (7), completes the proof of classical non-adaptive knowledge soundness.</p>

    <p class="text-gray-300"><strong>Post-quantum knowledge soundness.</strong> We omit a proof of non-adaptive post-quantum knowledge soundness. Instead, we sketch the main idea and how it differs from the classical case. Knowledge soundness for the BCS transformation in the QROM is argued in [CMS19] by analyzing the "instability" of a certain set of partial functions related to the queries the verifier makes to the oracle. Showing non-adaptive knowledge soundness for Construction 10.3 amounts to showing that this quantity does not change significantly when we prefix each query with the session identifier. Note that in the classical proof above we were able to construct a new adversary <span class="math">\\tilde{\\mathcal{P}}_0</span> by simulating <span class="math">\\tilde{\\mathcal{P}}</span> and monitoring its queries to the oracle; this is not possible in the quantum setting due to no-cloning.</p>

    <h2 id="sec-79" class="text-2xl font-bold">10.4 Classical adaptive knowledge from state restoration knowledge</h2>

    <p class="text-gray-300">We provide a "direct" proof of classical adaptive knowledge soundness from state-restoration knowledge of the hIOP. In some cases this provides a tighter bound in the classical setting than the bound from round-by-round soundness in Section 10.5; it also uses more standard techniques.</p>

    <p class="text-gray-300">43</p>

    <p class="text-gray-300">We will prove an adaptive transcript extraction property that, in the classical setting, directly implies the knowledge soundness property given in Section 9. The property states that there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every  <span class="math">t</span> -query adversary  <span class="math">\\tilde{\\mathcal{P}}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\dot {\\mathfrak {i}}, \\mathfrak {z}, \\mathfrak {w}) \\notin \\mathcal {R} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; (\\dot {\\mathfrak {i}}, \\mathfrak {z}, \\pi ; Q) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathfrak {z}, \\pi) = 1 &amp;amp; \\mathfrak {w} \\leftarrow \\mathcal {E} (\\dot {\\mathfrak {i}}, \\mathfrak {z}, \\pi , Q) \\\\ &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\dot {\\mathfrak {i}}) \\end{array} \\right] \\leq \\kappa_ {T} (t, \\lambda).</span></div>

    <p class="text-gray-300">In particular, if  <span class="math">\\mathcal{E}</span>  satisfies the above, then we can achieve knowledge error  <span class="math">\\kappa(t, \\lambda, \\ell) = \\kappa_T(t, \\lambda)</span>  in the sense of Eq. (5), simply by running  <span class="math">\\mathcal{E}(\\dot{\\mathfrak{i}}_j, \\mathfrak{z}_j, \\pi_j, Q)</span>  for all  <span class="math">j</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use a series of hybrids to prove the adaptive transcript extraction property. We assume, without loss of generality, that  <span class="math">\\tilde{\\mathcal{P}}</span>  repeats no oracle query. For convenience we write  <span class="math">\\rho_b(\\cdot)</span>  for  $\\rho(b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot)<span class="math">  for  </span>b \\in \\{0,1\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">H_0</span> : Real adaptive transcript extraction experiment.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span></li>

      <li><span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z},\\pi ;Q)\\gets \\tilde{\\mathcal{P}}^{\\rho}</span></li>

      <li><span class="math">\\mathfrak{w}\\gets \\mathcal{E}(\\dot{\\mathfrak{i}},\\mathfrak{z},\\pi ,Q)</span></li>

      <li><span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\gets \\mathcal{I}^{\\rho}(\\dot{\\mathfrak{i}})</span></li>

      <li>If  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z},\\mathfrak{w})\\notin \\mathcal{R}</span>  and  <span class="math">\\nu^{\\rho}(\\mathrm{ivk},\\mathfrak{z},\\pi) = 1</span>  output 1.</li>

    </ol>

    <p class="text-gray-300"><span class="math">H_{1}</span> : Choose a random query  <span class="math">i</span>  to  <span class="math">\\rho_0</span>  to be the commitment to the index and instance.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Choose  <span class="math">i \\in \\{1, \\dots, t\\}</span>  uniformly at random. Run  <span class="math">\\tilde{\\mathcal{P}}^\\rho</span>  until just before its  <span class="math">i</span> -th query to  <span class="math">\\rho_0</span> , and parse this query as  $a' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{z}'<span class="math"> . Let  </span>Q_1$  be the set of all queries made so far.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Continue running  <span class="math">\\tilde{\\mathcal{P}}^{\\rho}</span>  until it halts and outputs  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z},\\pi)</span> . Let  <span class="math">Q_{2}</span>  be the queries made in this phase.</li>

      <li><span class="math">\\mathfrak{w}\\gets \\mathcal{E}(\\dot{\\mathfrak{i}},\\mathfrak{z}&#x27;,\\pi ,Q_1\\cup Q_2)</span></li>

      <li><span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\gets \\mathcal{I}^{\\rho}(\\dot{\\mathfrak{i}})</span> , and then parse  <span class="math">\\mathrm{ivk}</span>  as a pair  <span class="math">(\\mathsf{rt},a)</span> . Recall from Construction 10.3 that  <span class="math">\\mathsf{rt}</span>  is a Merkle tree commitment of  <span class="math">\\mathbf{I}(\\dot{\\mathfrak{i}})</span>  and  <span class="math">a = \\rho_0(\\dot{\\mathfrak{i}})</span> .</li>

      <li>If  <span class="math">(\\mathfrak{i},\\mathfrak{z}&#x27;,\\mathfrak{w})\\notin \\mathcal{R}</span> ,  <span class="math">a&#x27; = a</span> , and  <span class="math">\\mathcal{V}^{\\rho}(\\mathrm{ivk},\\mathfrak{z}&#x27;,\\pi) = 1</span> , output 1.</li>

    </ol>

    <p class="text-gray-300"><span class="math">H_{2}</span> : Extract index from  <span class="math">Q_{1}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Choose  <span class="math">i \\in \\{1, \\dots, t\\}</span>  uniformly at random. Run  <span class="math">\\tilde{\\mathcal{P}}^{\\rho}</span>  until just before its  <span class="math">i</span> -th query to  <span class="math">\\rho_0</span> , and parse this query as  $a' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{z}'<span class="math"> . Let  </span>Q_1$  be the set of all queries made so far.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Continue running  <span class="math">\\tilde{\\mathcal{P}}^{\\rho}</span>  until it halts and outputs  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z},\\pi)</span> . Let  <span class="math">Q_{2}</span>  be the queries made in this phase.</li>

      <li><span class="math">\\mathfrak{w}\\gets \\mathcal{E}(\\dot{\\mathfrak{i}}^{\\prime},\\mathfrak{z}^{\\prime},\\pi ,Q_{1}\\cup Q_{2})</span></li>

      <li><span class="math">(\\mathrm{ipk}&#x27;,\\mathrm{ivk}&#x27;)\\gets \\mathcal{I}^{\\rho}(\\dot{\\mathfrak{i}}&#x27;)</span></li>

      <li>If  <span class="math">(\\mathfrak{i}&#x27;,\\mathfrak{z}&#x27;,\\mathfrak{w})\\notin \\mathcal{R}</span> , and  <span class="math">\\mathcal{V}^{\\rho}(\\mathrm{ivk}&#x27;,\\mathfrak{z}&#x27;,\\pi) = 1</span> , output 1.</li>

    </ol>

    <p class="text-gray-300"><span class="math">H_{3}</span> : Unpack  <span class="math">\\mathcal{E}</span>  and  <span class="math">\\mathcal{V}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Choose  <span class="math">i \\in \\{1, \\dots, t\\}</span>  uniformly at random. Run  <span class="math">\\tilde{\\mathcal{P}}^{\\rho}</span>  until just before its  <span class="math">i</span> -th query to  <span class="math">\\rho_0</span> , and parse this query as  $a' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{z}'<span class="math"> . Let  </span>Q_1$  be the set of all queries made so far.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Continue running <span class="math">\\tilde{\\mathcal{P}}^{\\rho}</span> until it halts and outputs <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\pi)</span>. Let <span class="math">Q_{2}</span> be the queries made in this phase. Parse <span class="math">\\pi</span> as <span class="math">(\\pi_{\\mathrm{BCS}},\\mathrm{a}\\tilde{\\mathrm{p}})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. <span class="math">\\underline{\\mathbf{w}}\\gets \\mathcal{E}_{\\mathrm{BCS}}(\\dot{\\mathfrak{s}}^{\\prime},\\underline{\\mathfrak{x}}^{\\prime},\\pi_{\\mathrm{BCS}},Q_{1}^{\\prime}\\cup Q_{2}^{\\prime})</span>, where $Q_{i}^{\\prime}\\coloneqq \\{(q_{0},b):(1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_{0},a)\\in Q_{i}\\}<span class="math"> and </span>z\\coloneqq Q(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underline{\\mathbf{x}}^{\\prime})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(\\dot{\\mathfrak{s}}^{\\prime},\\mathfrak{x}^{\\prime},\\mathfrak{w})\\notin \\mathcal{R}</span>, and <span class="math">\\mathcal{V}_{\\mathrm{BCS}}^{\\mathbf{I}(\\dot{\\mathfrak{s}}^{\\prime}),\\rho_{2}}(\\mathfrak{x}^{\\prime},\\pi_{\\mathrm{BCS}}) = 1</span>, output 1.</li>

    </ol>

    <p class="text-gray-300"><span class="math">H_{4}</span>: Answer <span class="math">\\tilde{\\mathcal{P}}</span>'s queries with uniform randomness, except for those after the <span class="math">i</span>-th with the prefix <span class="math">a&#x27; \\parallel \\mathfrak{x}&#x27;</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">i \\in \\{1, \\dots, t\\}</span> uniformly at random. Run <span class="math">\\tilde{\\mathcal{P}}</span> until just before its <span class="math">i</span>-th query with prefix 0, answering all of its queries with uniform randomness. Parse the <span class="math">i</span>-th query as <span class="math">\\mathrm{ivk} \\parallel \\mathfrak{x}</span>. Let <span class="math">Q_{1}</span> be the set of all (simulated) queries made so far.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. If there exists $((0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q),a^{\\prime})\\in Q_{1}<span class="math">, then set </span>\\dot{\\mathfrak{s}}^{\\prime}\\coloneqq q$; otherwise, abort.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho^{\\prime}\\gets \\mathcal{U}(\\lambda)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Respond to the <span class="math">i</span>-th query with random <span class="math">z \\in \\{0,1\\}^{\\lambda}</span>. Continue running <span class="math">\\tilde{\\mathcal{P}}</span> until it halts and outputs <span class="math">(\\dot{\\mathfrak{s}}, \\mathfrak{x}, \\pi)</span>, answering its queries of the form $(1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_0)<span class="math"> with </span>\\rho'(q_0)<span class="math"> and all other queries uniformly at random. Let </span>Q_2'<span class="math"> be the set of queries made to </span>\\rho'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{w}\\gets \\mathcal{E}_{\\mathrm{BCS}}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\pi_{\\mathrm{BCS}},Q_2&#x27;)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">(\\dot{\\mathfrak{s}}^{\\prime},\\mathfrak{x}^{\\prime},\\mathfrak{w})\\notin \\mathcal{R}</span> and <span class="math">\\mathcal{V}_{\\mathrm{BCS}}^{\\mathbf{I}(\\dot{\\mathfrak{s}}^{\\prime}),\\rho^{\\prime}}(\\mathfrak{x}^{\\prime},\\pi_{\\mathrm{BCS}}) = 1</span>, output 1.</li>

    </ol>

    <p class="text-gray-300">For <span class="math">i = 0, \\ldots, 4</span>, let <span class="math">p_i := \\operatorname{Pr}[H_i \\text{ outputs } 1]</span>. Note that <span class="math">p_0</span> is the probability we wish to bound, and <span class="math">p_4 \\leq \\kappa_{\\mathrm{sr}}(t) + O(t^2 \\cdot 2^{-\\lambda})</span> by the knowledge guarantee of the BCS transformation (Eq. (7)), since <span class="math">\\dot{\\mathfrak{s}}&#x27;</span> and <span class="math">\\mathfrak{x}&#x27;</span> are chosen independently of the oracle <span class="math">\\rho&#x27;</span>. We prove the following claims.</p>

    <p class="text-gray-300"><strong>Claim 10.4.</strong> <span class="math">p_0 \\leq t \\cdot p_1 + 2^{-\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Let <span class="math">E_1</span> be the event that <span class="math">\\tilde{\\mathcal{P}}^\\rho</span> outputs <span class="math">(\\dot{\\mathfrak{s}}, \\mathfrak{x})</span> such that $0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{x}<span class="math"> is never queried for </span>a = \\rho_0(\\dot{\\mathfrak{s}})<span class="math">. Then the probability that </span>\\mathcal{V}<span class="math"> accepts given </span>E_1<span class="math"> is at most </span>2^{-\\lambda}<span class="math">. If </span>E_1<span class="math"> does not hold then with probability at least </span>1 / t<span class="math">, </span>\\mathfrak{x} = \\mathfrak{x}'<span class="math"> and </span>a = a'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Claim 10.5.</strong> <span class="math">p_1 \\leq p_2 + (t + 2)^2 \\cdot 2^{-\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> If there does not exist $((0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q),a)\\in Q_1<span class="math"> then the probability that </span>a^\\prime = \\rho_0(\\dot{\\mathfrak{s}}) = a<span class="math"> is at most </span>(t + 1)\\cdot 2^{-\\lambda}<span class="math">. Otherwise, since </span>\\rho_0(\\dot{\\mathfrak{s}}) = a = a' = \\rho_0(\\dot{\\mathfrak{s}}')<span class="math">, the probability that </span>\\dot{\\mathfrak{s}}\\neq \\dot{\\mathfrak{s}}'<span class="math"> is at most </span>(t + 1)^2\\cdot 2^{-\\lambda}$, since this would constitute a collision.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Claim 10.6.</strong> <span class="math">p_2 \\leq p_3 + (t + O(\\log L))^2 \\cdot 2^{-\\lambda}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> This follows directly from the soundness argument, and the definition of <span class="math">\\mathcal{E}</span>.</p>

    <p class="text-gray-300"><strong>Claim 10.7.</strong> <span class="math">p_3 \\leq p_4 + t \\cdot 2^{-\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Let $z \\coloneqq \\rho_0(\\mathrm{ivk} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{x})<span class="math">. Since </span>\\tilde{\\mathcal{P}}<span class="math"> queries </span>\\rho_0<span class="math"> at </span>\\mathrm{ivk} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{x}<span class="math"> for the first time at query </span>i<span class="math">, its queries before the </span>i<span class="math">-th are independent of </span>z<span class="math">. Hence the probability that any of those queries has prefix </span>1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z<span class="math"> is at most </span>t \\cdot 2^{-\\lambda}<span class="math">. If none of these queries have prefix </span>1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z<span class="math">, then </span>Q_1' = \\emptyset<span class="math">, and </span>\\mathcal{V}_{\\mathrm{BCS}}<span class="math">&#x27;s queries are disjoint from </span>Q_1'<span class="math">. Neither </span>\\mathcal{E}_{\\mathrm{BCS}}<span class="math"> nor </span>\\mathcal{V}_{\\mathrm{BCS}}<span class="math"> query </span>\\rho_0$, and so making the specified modifications to the oracles does not change their behavior.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We thus obtain that <span class="math">p_0 \\leq t \\cdot \\kappa_{\\mathrm{sr}}(t) + O(t^3 \\cdot 2^{-\\lambda})</span>, from which the stated expression follows.</p>

    <p class="text-gray-300">10.5 Adaptive knowledge from round-by-round knowledge</p>

    <p class="text-gray-300">In this section we obtain a bound on adaptive knowledge soundness from round-by-round soundness. We rely heavily on concepts and notation introduced in <em>[x10, Sections 3–5]</em>, and we strongly recommend that the interested reader become familiar with these before proceeding with this section.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We begin with some additional preliminaries on modeling the random oracle. In this analysis, we will model the random oracle as a random function with fixed input length <span class="math">3\\lambda+1</span> and output length <span class="math">\\lambda</span>. For larger inputs to <span class="math">\\rho</span>, which for us will have prefix <span class="math">0</span>, we recursively define $\\rho(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}):=\\rho(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1})<span class="math"> for </span>s_{0}\\in\\{0,1\\}^{3\\lambda}<span class="math"> and </span>s_{1}\\in\\{0,1\\}^{2k\\lambda}<span class="math">, </span>k\\geq 1<span class="math"> (we will implicitly pad inputs up to an odd multiple of </span>\\lambda<span class="math">). For a database </span>D\\colon\\{0,1\\}^{2\\lambda+1}\\rightharpoonup\\{0,1\\}^{\\lambda}<span class="math"> we use almost the same convention, except when </span>D(b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0})$ is undefined:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}):=\\begin{cases}\\bot&\\text{if }D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0})=\\bot;\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a database <span class="math">D\\colon\\{0,1\\}^{3\\lambda+1}\\rightharpoonup\\{0,1\\}^{\\lambda}</span>, let $S_{b}(D):=\\{s_{0}\\in\\{0,1\\}^{\\lambda}:\\exists s_{1}\\in\\{0,1\\}^{2\\lambda}\\,,(b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1})\\in\\operatorname{supp}(D)\\}$. We make use of the following simple lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 10.8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">D\\colon\\{0,1\\}^{3\\lambda+1}\\rightharpoonup\\{0,1\\}^{\\lambda}</span> be a database. Let <span class="math">k\\geq 3</span> be an odd integer, and let <span class="math">s\\in\\{0,1\\}^{k\\lambda},x\\in\\{0,1\\}^{3\\lambda+1}\\setminus\\operatorname{supp}(D),y,a\\in\\{0,1\\}^{\\lambda}</span> be such that $D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s)\\neq(D+[x\\mapsto y])(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s)=a<span class="math">. Then </span>y\\in\\{a\\}\\cup S_{0}(D)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We proceed by induction on <span class="math">k</span>. Let <span class="math">D^{\\prime}:=D+[x\\mapsto y]</span>. Note first that if $D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s)\\neq D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s)<span class="math">, it must be that </span>D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s)=\\bot<span class="math">. For the base case, if </span>k=3<span class="math">, then </span>x=0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s<span class="math"> and so </span>y=a<span class="math">. Now suppose that for all odd </span>k^{\\prime}<k<span class="math">, the lemma holds for all </span>s^{\\prime}\\in\\{0,1\\}^{k\\lambda}<span class="math">. Let </span>s_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}:=s<span class="math">, where </span>s_{0}\\in\\{0,1\\}^{3\\lambda}<span class="math">, </span>s_{1}\\in\\{0,1\\}^{(k-3)\\lambda}<span class="math">. If </span>D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0})=\\bot<span class="math">, then </span>x=0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0}<span class="math">, and so </span>D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s)=D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1})\\neq\\bot<span class="math">. If </span>k-3=2<span class="math">, then </span>y\\in S_{0}(D)<span class="math"> immediately; otherwise, </span>D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1})=D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}^{\\prime})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{2})<span class="math"> for some </span>s_{1}^{\\prime}\\in\\{0,1\\}^{2\\lambda}<span class="math">, and so </span>D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}^{\\prime})\\neq\\bot<span class="math">, whence </span>y\\in S_{0}(D)<span class="math">. Otherwise, let </span>b:=D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{0})<span class="math">; we have that </span>D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1})=\\bot<span class="math">, but </span>D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1})=a<span class="math">. Since </span>b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}\\in\\{0,1\\}^{(k-2)\\lambda}<span class="math">, by induction </span>y\\in\\{a\\}\\cup S_{0}(D)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a database <span class="math">D</span>, <span class="math">z\\in\\{0,1\\}^{\\lambda}</span>, we write $D_{1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z}<span class="math"> for the database </span>\\{(x,y):(1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,y)\\in D\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma 10.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\{\\mathcal{P}_{\\mathfrak{i},\\mathbb{x}}\\}_{\\mathfrak{i},\\mathbb{x}}</span> be a set of database properties indexed by <span class="math">\\mathfrak{i},\\mathbb{x}</span>. Let <span class="math">\\mathcal{P}</span> be the property consisting of databases <span class="math">D</span> for which there exist <span class="math">\\mathfrak{i},\\mathbb{x},a,b</span> such that $D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i})=a<span class="math">, </span>D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x})=b<span class="math"> and </span>D_{1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b}\\in\\mathcal{P}_{\\mathfrak{i},\\mathbb{x}}<span class="math">. Then </span>I(\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\operatorname{col}},t)\\leq\\max(\\max_{\\mathfrak{i},\\mathbb{x}}I(\\mathcal{P}_{\\mathfrak{i},\\mathbb{x}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\operatorname{col}},t),t/2^{\\lambda})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first bound <span class="math">\\operatorname{flip}(\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{P}}_{\\operatorname{col}}\\to\\mathcal{P}\\cap\\bar{\\mathcal{P}}_{\\operatorname{col}})</span>. Let <span class="math">D\\in\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{P}}_{\\operatorname{col}}</span>, fix some <span class="math">x\\in\\{0,1\\}^{3\\lambda+1}\\setminus\\operatorname{supp}(D)</span>. We consider two cases.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The first bit of <span class="math">x</span> is <span class="math">0</span>. We show that if <span class="math">y</span> is such that <span class="math">D^{\\prime}=D+[x\\mapsto y]\\in\\mathcal{P}\\cap\\bar{\\mathcal{P}}_{\\operatorname{col}}</span>, then <span class="math">y\\in S_{0}(D)\\cup S_{1}(D)</span>, and so $\\operatorname{Pr}_{y}[D+[x\\mapsto y]\\in\\mathcal{P}\\cap\\bar{\\mathcal{P}}_{\\operatorname{col}}]\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{0}(D)\\cup S_{1}(D)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^{\\lambda}\\leq t/2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By definition there exist <span class="math">\\mathfrak{i},\\mathbb{x},a,b</span> such that $D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i})=a<span class="math">, </span>D^{\\prime}(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x})=b<span class="math"> and </span>D^{\\prime}_{1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b}\\in\\mathcal{P}_{\\mathfrak{i},\\mathbb{x}}<span class="math">. Since </span>D\\in\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{P}}_{\\operatorname{col}}<span class="math"> and the first bit of </span>x<span class="math"> is </span>0<span class="math">, one of the first two conditions does not hold for </span>D$; we consider these in turn.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x})\\neq b<span class="math">; then </span>y\\in S_{0}(D)\\cup\\{b\\}<span class="math"> by Lemma 10.8. Then since </span>D^{\\prime}_{1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b}\\in\\mathcal{P}_{\\mathfrak{i},\\mathbb{x}}<span class="math">, </span>b\\in S_{1}(D)<span class="math">, and so </span>y\\in S_{0}(D)\\cup S_{1}(D)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The first bit of <span class="math">x</span> is 1. Then $D_{1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b} \\notin \\mathcal{P}_{\\mathfrak{i},\\mathbb{x}}<span class="math">; let </span>x = 1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x'<span class="math"> for some </span>x' \\in \\{0,1\\}^{\\lambda}<span class="math">. Note that since </span>D \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}<span class="math">, there exists a unique choice of </span>\\dot{\\mathfrak{s}}, \\mathbb{x}<span class="math"> such that </span>D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x}) = b<span class="math">. Hence in this case, </span>\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\mathcal{P} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}] = \\operatorname{Pr}_y[D_{1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b} + [x' \\mapsto y] \\in \\mathcal{P}_{\\dot{\\mathfrak{s}},\\mathbb{x}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}] \\leq I(\\mathcal{P}_{\\dot{\\mathfrak{s}},\\mathbb{x}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\mathrm{col}}, t) \\leq \\max_{\\dot{\\mathfrak{s}},\\mathbb{x}} I(\\mathcal{P}_{\\dot{\\mathfrak{s}},\\mathbb{x}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\mathrm{col}}, t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now bound <span class="math">\\mathrm{flip}(\\mathcal{P} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}} \\to \\bar{\\mathcal{P}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}})</span>. Let <span class="math">D \\in \\mathcal{P} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>. Note that if the first bit of <span class="math">x</span> is 0, there is no <span class="math">y</span> such that <span class="math">D + [x \\mapsto y] \\in \\bar{\\mathcal{P}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>. If the first bit of <span class="math">x</span> is 1, $\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\bar{\\mathcal{P}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}] \\leq \\max_{\\dot{\\mathfrak{s}},\\mathbb{x}} I(\\mathcal{P}_{\\dot{\\mathfrak{s}},\\mathbb{x}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\mathrm{col}},t)$ by a similar argument to the above. This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To simplify the subsequent analysis we define a modified verifier algorithm <span class="math">\\mathcal{V}_0(\\dot{\\mathfrak{s}},\\mathbb{x},\\pi)</span> which parses <span class="math">\\pi</span> as <span class="math">(\\pi_{\\mathrm{BCS}},\\bar{\\mathrm{ap}})</span>, computes $z\\coloneqq \\rho_0(\\rho_0(\\dot{\\mathfrak{s}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x})<span class="math"> and accepts if </span>\\mathcal{V}_{\\mathrm{BCS}}^{\\rho_1(z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot),\\mathbf{I}(\\dot{\\mathfrak{s}})}(\\mathbb{x},\\pi_{\\mathrm{BCS}})<span class="math"> accepts. Fix some predicate </span>p<span class="math">. We denote by </span>\\mu$ the probability</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} p (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\mathsf {a u x}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge \\forall j \\in [ \\ell ], &amp;amp; (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\vec {\\pi}, \\mathsf {a u x}) \\leftarrow \\bar {\\mathcal {P}} ^ {\\rho} \\\\ \\mathcal {V} _ {0} ^ {\\rho} (\\dot {\\mathfrak {s}} _ {j}, \\mathbb {x} _ {j}, \\pi_ {j}) = 1 &amp;amp; \\forall j, (\\mathsf {i p k} _ {j}, \\mathsf {i v k} _ {j}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\dot {\\mathfrak {s}} _ {j}) \\end{array} \\right] - O (t ^ {3} \\cdot 2 ^ {- \\lambda}),</span></div>

    <p class="text-gray-300">and so it suffices to show the proof of knowledge property for the verifier <span class="math">\\mathcal{V}_0</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}_{\\mathcal{V}(\\vec{\\mathfrak{s}},\\vec{\\mathfrak{s}},\\vec{\\pi})}</span> be the set of databases <span class="math">Q</span> such that the verifier accepts: i.e., <span class="math">Q</span> such that for all <span class="math">j\\in [\\ell ]</span>, <span class="math">\\mathcal{V}_0^Q (\\dot{\\mathfrak{s}}_j,\\mathfrak{x}_j,\\pi_j) = 1</span>. Let <span class="math">\\mathcal{P}_{\\mathcal{E}(\\vec{\\mathfrak{s}},\\vec{\\mathfrak{s}},\\vec{\\pi})}</span> be the set of databases <span class="math">Q</span> such that the extractor succeeds: i.e., <span class="math">Q</span> such that for all <span class="math">j\\in [\\ell ]</span>, <span class="math">\\mathbb{W}_j\\coloneqq \\mathcal{E}(\\dot{\\mathfrak{s}}_j,\\mathfrak{x}_j,\\pi_j,Q)</span> is such that <span class="math">(\\dot{\\mathfrak{s}}_j,\\mathfrak{x}_j,\\mathbb{W}_j)\\in \\mathcal{R}</span>. Finally, let <span class="math">\\mathcal{P}_{\\mathcal{V}\\backslash \\mathcal{E}}</span> be the set of databases <span class="math">Q</span> where the verifier accepts but the extractor fails for some choice of <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\pi)</span>: i.e., <span class="math">Q</span> such that there exists <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\pi)</span> for which <span class="math">\\mathcal{V}_0^Q (\\dot{\\mathfrak{s}},\\mathfrak{x},\\pi) = 1</span> but <span class="math">\\mathbb{W}\\coloneqq \\mathcal{E}(\\dot{\\mathfrak{s}},\\mathfrak{x},\\pi ,Q)</span> is such that <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x},\\mathbb{W})\\notin \\mathcal{R}</span>.</p>

    <p class="text-gray-300">We lower bound the success probability of the extractor in the quantum setting in terms of these properties as follows. The classical proof is analogous and so we will not give it explicitly.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} p (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\mathsf {a u x}) = 1 &amp; (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\vec {\\pi}, \\mathsf {a u x}; Q) \\leftarrow \\mathsf {S i m} ^ {<em>} (\\tilde {\\mathcal {P}}) \\\\ \\wedge \\forall j \\in [ \\ell ], &amp; \\forall j \\in [ \\ell ], \\mathbb {W} _ {j} \\leftarrow \\mathcal {E} (\\dot {\\mathfrak {s}} _ {j}, \\mathfrak {x} _ {j}, \\pi_ {j}; Q) \\end{array} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c c} p (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\mathsf {a u x}) = 1 &amp; \\\\ \\wedge Q \\in \\mathcal {P} _ {\\mathcal {E} (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\vec {\\pi})} \\cap \\mathcal {P} _ {\\mathcal {V} (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\vec {\\pi})} &amp; (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\vec {\\pi}, \\mathsf {a u x}; Q) \\leftarrow \\mathsf {S i m} ^ {</em>} (\\tilde {\\mathcal {P}}) \\end{array} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c c} p (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\mathsf {a u x}) = 1 &amp; (\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\vec {\\pi}, \\mathsf {a u x}; Q) \\leftarrow \\mathsf {S i m} ^ {*} (\\tilde {\\mathcal {P}}) \\end{array} \\right] - \\Pr \\left[ Q \\in \\mathcal {P} _ {\\mathcal {V} \\backslash \\mathcal {E}} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\vec {\\mathfrak {s}}, \\vec {\\mathfrak {s}}, \\vec {\\pi}, \\mathsf {a u x}; Q) \\leftarrow \\mathsf {S i m} ^ {*} (\\tilde {\\mathcal {P}}) \\right] \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">By [Zha19, Lemma 5] (which connects the success probability of <span class="math">\\mathsf{Sim}^*</span> with a real execution), and since the verifier makes <span class="math">O(\\mathfrak{q}\\log \\mathsf{L})</span> queries to the oracle, the first term on the last line is at least <span class="math">\\mu - O(\\mathfrak{q}\\log \\mathsf{L} \\cdot 2^{-\\lambda})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By construction of <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{E}</span>, <span class="math">\\mathcal{P}_{\\mathcal{V} \\setminus \\mathcal{E}}</span> is exactly of the form described in Lemma 10.9 for the set <span class="math">\\{\\mathcal{P}_{\\mathfrak{s},\\mathfrak{x}}\\}_{\\mathfrak{s},\\mathfrak{x}}</span> where <span class="math">\\mathcal{P}_{\\mathfrak{s},\\mathfrak{x}}</span> is the set of databases such that there exists a proof <span class="math">\\pi</span> for which <span class="math">\\mathcal{V}_{\\mathrm{BCS}}^D(\\mathfrak{s},\\mathfrak{x},\\pi)</span> accepts but <span class="math">\\mathcal{E}_{\\mathrm{BCS}}(\\mathfrak{s},\\mathfrak{x},\\pi, D)</span> fails to produce a valid witness. By [CMS19, Proposition 8.14], $I(\\mathcal{P}_{\\mathfrak{s},\\mathfrak{x}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\mathrm{col}}, t) \\leq \\kappa_{\\mathrm{rbr}} + O(t \\cdot 2^{-\\lambda})<span class="math">. Hence by Lemma 10.9, </span>I(\\mathcal{P}_{\\mathcal{V}, \\mathcal{E}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\mathrm{col}}, t) \\leq \\kappa_{\\mathrm{rbr}} + O(t \\cdot 2^{-\\lambda})$. Then by [CMS19, Lemma 5.13] (their "lifting lemma"),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ Q \\in \\mathcal {P} _ {\\mathcal {V} \\backslash \\mathcal {E}} \\mid (\\dot {\\mathfrak {s}}, \\mathfrak {x}, \\pi ; Q) \\leftarrow \\operatorname {S i m} ^ {*} (\\tilde {\\mathcal {P}}) \\right] \\leq 6 t ^ {2} \\cdot \\kappa_ {\\mathrm {r b r}} + O (t ^ {3} \\cdot 2 ^ {- \\lambda}).</span></div>

    <p class="text-gray-300">We thus obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} p (\\vec {\\mathfrak {i}}, \\vec {\\mathfrak {z}}, \\mathsf {a u x}) = 1 &amp;amp; (\\vec {\\mathfrak {i}}, \\vec {\\mathfrak {z}}, \\vec {\\pi}, \\mathsf {a u x}; Q) \\leftarrow \\mathsf {S i m} ^ {*} (\\tilde {\\mathcal {P}}) \\\\ \\wedge \\forall j \\in [ \\ell ], &amp;amp; \\forall j \\in [ \\ell ], \\mathfrak {w} _ {j} \\leftarrow \\mathcal {E} (\\mathfrak {i} _ {j}, \\mathfrak {z} _ {j}, \\pi_ {j}; Q) \\end{array} \\right] \\geq \\mu - 6 t ^ {2} \\cdot \\kappa_ {\\mathrm {r b r}} - O ((t ^ {3} + \\mathfrak {q} \\log \\mathsf {L}) \\cdot 2 ^ {- \\lambda}) ,</span></div>

    <p class="text-gray-300">which completes the proof.</p>

    <h2 id="sec-84" class="text-2xl font-bold">10.6 Adaptive zero knowledge</h2>

    <p class="text-gray-300">To achieve adaptive zero knowledge we need a minor but standard modification to Construction 10.3. In our modified construction, the prover chooses a random seed  <span class="math">\\alpha \\in \\{0,1\\}^{\\lambda}</span>  that it prefixes to all queries to  <span class="math">\\rho_z</span> ; it then provides  <span class="math">\\alpha</span>  in the proof. It is relatively straightforward to show that this preserves (adaptive) soundness and knowledge soundness, both in the classical and quantum settings.</p>

    <p class="text-gray-300">In the classical setting, it is easy to show that this modification achieves adaptive zero knowledge. The simulator is identical to the non-adaptive simulator, except that it prefixes its simulated queries (and hence the locations in  <span class="math">\\mu</span> ) with a random  <span class="math">\\alpha</span> . The probability that  <span class="math">\\mathcal{A}</span>  ever queries a location with prefix  <span class="math">\\alpha</span>  is at most  <span class="math">t / 2^{-\\lambda}</span> , and so the output of  <span class="math">\\mathcal{A}</span>  is almost independent from oracle locations with prefix  <span class="math">\\alpha</span> . Zero knowledge then follows by the non-adaptive (statistical) zero knowledge guarantee.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the quantum setting, the argument is more delicate; we only sketch it here. We rely on the strong one-way-to-hiding lemma of [AHU19]. Using this lemma, one can show that for any fixed oracles  <span class="math">f, g</span> , the output distribution of any  <span class="math">t</span> -query adversary  <span class="math">\\mathcal{A}^f</span>  is  <span class="math">O(t^2 / 2^{-\\lambda})</span> -close to  <span class="math">\\mathcal{A}^{f_g}</span> , where  <span class="math">f_g</span>  is a random function drawn by choosing  <span class="math">\\alpha \\in \\{0,1\\}^\\lambda</span>  uniformly at random and setting  $f_g(\\alpha \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q) = g(q)<span class="math"> , and  </span>f_g(q') = f(q')<span class="math">  otherwise. This again shows that the output of  </span>\\mathcal{A}$  is almost independent of any programmed oracle location, and so zero knowledge follows by the non-adaptive (statistical) zero knowledge guarantee.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">We describe how to transform any preprocessing SNARK in the URS model into a preprocessing PCD scheme in the URS model. The transformation preserves post-quantum security.</p>

    <p class="text-gray-300">This section is organized as follows. In Section 11.1 we define preprocessing SNARKs in the URS model. In Section 11.2 we define preprocessing PCD schemes in the URS model. In Section 11.3 we state the properties of the transformation from SNARK to PCD. In sec:recursion-efficiency we describe the construction and prove its efficiency properties. In Section 11.5 we prove the security properties.</p>

    <p class="text-gray-300">In this section by "polynomial-size" we mean a (non-uniform) family of polynomial-size circuits.</p>

    <p class="text-gray-300">Informally, the definition of a preprocessing SNARK in the URS model is similar to the definition of a preprocessing SNARK in the random oracle model (see Section 9) except that the random oracle is replaced by a poly  <span class="math">(\\lambda)</span> -size uniform random string  <span class="math">\\mathfrak{urs}</span> . The formal definition follows.</p>

    <p class="text-gray-300">A tuple of algorithms  <span class="math">\\mathsf{ARG} = (\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  is a preprocessing non-interactive argument (of knowledge) in the uniform random string (URS) model for an indexed relation  <span class="math">\\mathcal{R}</span>  if the following properties hold.</p>

    <p class="text-gray-300">Completeness. For every adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\dot {\\mathbb {1}}, \\mathbb {z}, \\mathbb {w}) \\notin \\mathcal {R} &amp;amp; \\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ \\vee &amp;amp; (\\dot {\\mathbb {1}}, \\mathbb {z}, \\mathbb {w}) \\leftarrow \\mathcal {A} (\\mathsf {u r s}) \\\\ \\mathcal {V} (\\mathsf {u r s}, \\mathsf {i v k}, \\mathbb {z}, \\pi) = 1 &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {I} (\\mathsf {u r s}, \\dot {\\mathbb {1}}) \\\\ &amp;amp; \\pi \\leftarrow \\mathcal {P} (\\mathsf {u r s}, \\mathsf {i p k}, \\mathbb {z}, \\mathbb {w}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">The above formulation of completeness allows  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z},\\mathfrak{w})</span>  to depend on the reference string  <span class="math">\\mathfrak{urs}</span> .</p>

    <p class="text-gray-300">Knowledge soundness. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has (adaptive) knowledge error  <span class="math">\\kappa</span>  if for every polynomial-size adversary  <span class="math">\\tilde{\\mathcal{P}}</span>  there exists a polynomial-size extractor  <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span>  such that for every predicate  <span class="math">p</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} p (\\mathsf {u r s}, \\vec {\\mathbb {i}}, \\vec {\\mathbb {z}}, \\mathsf {a u x}) = 1 &amp;amp; \\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ \\wedge \\forall j \\in [ \\ell ], &amp;amp; (\\vec {\\mathbb {i}}, \\vec {\\mathbb {z}}, \\vec {\\mathbb {w}}, \\mathsf {a u x}) \\leftarrow \\mathcal {E} _ {\\tilde {\\mathcal {P}}} (\\mathsf {u r s}) \\end{array} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c c} p (\\mathsf {u r s}, \\vec {\\mathbb {i}}, \\vec {\\mathbb {z}}, \\mathsf {a u x}) = 1 &amp;amp; \\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ \\wedge \\forall j \\in [ \\ell ], &amp;amp; (\\vec {\\mathbb {i}}, \\vec {\\mathbb {z}}, \\vec {\\pi}, \\mathsf {a u x}) \\leftarrow \\tilde {\\mathcal {P}} (\\mathsf {u r s}) \\\\ \\mathcal {V} (\\mathsf {i v k} _ {j}, \\mathbb {z} _ {j}, \\pi_ {j}) = 1 &amp;amp; \\forall j, (\\mathsf {i p k} _ {j}, \\mathsf {i v k} _ {j}) \\leftarrow \\mathcal {I} (\\mathsf {u r s}, \\dot {\\mathbb {i}} _ {j}) \\end{array} \\right] - \\kappa (\\lambda , \\ell). \\tag {8} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Zero knowledge. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator  <span class="math">S</span>  such that for every polynomial-size honest adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{(\\mathsf {u r s}, \\dot {\\mathbb {1}}, \\mathbb {z}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ (\\dot {\\mathbb {1}}, \\mathbb {z}, \\mathbb {w}) \\leftarrow \\mathcal {A} (\\mathsf {u r s}) \\\\ (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {I} (\\mathsf {u r s}, \\dot {\\mathbb {1}}) \\\\ \\pi \\leftarrow \\mathcal {P} (\\mathsf {u r s}, \\mathsf {i p k}, \\mathbb {z}, \\mathbb {w}) \\end{array} \\right\\} \\quad \\text {a n d} \\quad \\left\\{(\\mathsf {u r s}, \\dot {\\mathbb {1}}, \\mathbb {z}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {u r s}, \\tau) \\leftarrow \\mathcal {S} (1 ^ {\\lambda}) \\\\ (\\dot {\\mathbb {1}}, \\mathbb {z}, \\mathbb {w}) \\leftarrow \\mathcal {A} (\\mathsf {u r s}) \\\\ \\pi \\leftarrow \\mathcal {S} (\\dot {\\mathbb {1}}, \\mathbb {z}, \\tau) \\end{array} \\right. \\right\\} \\right. \\right.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where here an adversary is honest if its output satisfies  <span class="math">(\\dot{\\mathfrak{i}},\\mathfrak{z},\\mathfrak{w})\\in \\mathcal{R}</span>  with probability 1.</p>

    <p class="text-gray-300">Remark 11.1 (post-quantum security). The above definitions consider security against classical polynomial-size adversaries. We also consider security against quantum polynomial-size adversaries. The definitions for this case are identical, except that  <span class="math">\\tilde{\\mathcal{P}}</span>  is a (non-uniform) family of polynomial-size quantum circuits (as is the zero knowledge adversary  <span class="math">\\mathcal{A}</span> ).</p>

    <p class="text-gray-300">50</p>

    <h2 id="sec-87" class="text-2xl font-bold">11.2 Preprocessing PCD in the URS model</h2>

    <p class="text-gray-300">We have informally introduced PCD in Section 2.5. Formally, a triple of algorithms <span class="math">\\mathsf{PCD} = (\\mathbb{I},\\mathbb{P},\\mathbb{V})</span> is a proof-carrying data scheme (PCD scheme) in the uniform random string (URS) model for a class of compliance predicates <span class="math">\\mathsf{F}</span> if the properties below hold.</p>

    <p class="text-gray-300"><strong>Definition 11.2.</strong> A transcript <span class="math">\\mathsf{T}</span> is a directed acyclic graph where each vertex <span class="math">u \\in V(\\mathsf{T})</span> is labeled by a local data <span class="math">z_{\\mathrm{loc}}^{(u)}</span> and each edge <span class="math">e \\in E(\\mathsf{T})</span> is labeled by a message <span class="math">z^{(e)} \\neq \\bot</span>. The output of a transcript <span class="math">\\mathsf{T}</span>, denoted <span class="math">\\mathsf{o}(\\mathsf{T})</span>, is <span class="math">z^{(e)}</span> where <span class="math">e = (u, v)</span> is the lexicographically-first edge such that <span class="math">v</span> is a sink.</p>

    <p class="text-gray-300"><strong>Definition 11.3.</strong> A vertex <span class="math">u \\in V(\\mathsf{T})</span> is <span class="math">\\Phi</span>-compliant for <span class="math">\\Phi \\in \\mathsf{F}</span> if for all outgoing edges <span class="math">e = (u, v) \\in E(\\mathsf{T})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(base case) if <span class="math">u</span> has no incoming edges, <span class="math">\\Phi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, \\bot, \\ldots, \\bot)</span> accepts;</li>

      <li>(recursive case) if <span class="math">u</span> has incoming edges <span class="math">e_1, \\ldots, e_m</span>, <span class="math">\\Phi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, z^{(e_1)}, \\ldots, z^{(e_m)})</span> accepts.</li>

    </ul>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{T}</span> is <span class="math">\\Phi</span>-compliant if all of its vertices are <span class="math">\\Phi</span>-compliant.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> For every adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\left(\\Phi \\in \\mathsf{F} \\land \\left(\\forall i, z _ {i} = \\bot \\lor \\forall i, \\mathbb {V} (\\mathsf {i v k}, z _ {i}, \\pi_ {i}) = 1\\right) \\land \\\\ \\Phi (z, z _ {\\mathsf {l o c}}, z _ {1}, \\ldots , z _ {m}) \\text { accepts}\\right) \\\\ \\Downarrow \\\\ \\mathbb {V} (\\mathsf {i v k}, z, \\pi) = 1 \\end{array} \\right] \\begin{array}{c} \\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ \\left(\\Phi , z, z _ {\\mathsf {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}\\right) \\leftarrow \\mathcal {A} (\\mathsf {u r s}) \\\\ \\left(\\mathsf {i p k}, \\mathsf {i v k}\\right) \\leftarrow \\mathbb {I} (\\mathsf {u r s}, \\Phi) \\\\ \\pi \\leftarrow \\mathbb {P} \\left(\\mathsf {i p k}, z, z _ {\\mathsf {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}\\right) \\end{array} \\left. \\right] = 1.</span></div>

    <p class="text-gray-300">Observe that this completeness condition is fairly strong: it requires that <span class="math">\\mathbb{P}</span> produce a valid PCD proof for any valid <span class="math">z, z_{\\mathrm{loc}}, [z_i, \\pi_i]_{i=1}^m</span>, even if they were not honestly (or even efficiently) generated.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Knowledge soundness.</strong> We say that <span class="math">\\mathsf{PCD} = (\\mathbb{I},\\mathbb{P},\\mathbb{V})</span> has knowledge soundness <span class="math">\\kappa (\\lambda)</span> if there exists some polynomial <span class="math">e</span> such that for every polynomial-size adversary <span class="math">\\tilde{\\mathbb{P}}</span>, there exists an extractor <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> of size at most $e(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbb{P}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> such that for every predicate </span>p$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} \\Phi \\in \\mathsf {F} \\wedge p (\\mathsf {u r s}, \\Phi , \\mathsf {o} (\\mathsf {T})) = 1 &amp;amp; \\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ \\wedge \\mathsf {T} \\text { is } \\Phi \\text {-compliant} &amp;amp; (\\Phi , \\mathsf {T}) \\leftarrow \\mathbb {E} _ {\\tilde {\\mathbb {P}}} (\\mathsf {u r s}) \\end{array} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c c} \\Phi \\in \\mathsf {F} \\wedge p (\\mathsf {u r s}, \\Phi , \\mathsf {o}) = 1 &amp;amp; \\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ \\wedge \\mathcal {V} (\\mathsf {i v k}, \\mathsf {o}, \\pi) = 1 &amp;amp; (\\Phi , \\mathsf {o}, \\pi) \\leftarrow \\tilde {\\mathbb {P}} (\\mathsf {u r s}) \\\\ &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathbb {I} (\\mathsf {u r s}, \\Phi) \\end{array} \\right] - \\kappa (\\lambda). \\end{array}</span></div>

    <p class="text-gray-300"><strong>Zero knowledge.</strong> We say that <span class="math">\\mathsf{PCD} = (\\mathbb{I},\\mathbb{P},\\mathbb{V})</span> has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator <span class="math">\\mathbb{S}</span> such that for all honest adversaries <span class="math">\\mathcal{A}</span> the distributions below are statistically close:</p>

    <p class="text-gray-300">$$ \\left\\{</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\mathsf {u r s}, \\Phi , z, \\pi\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {u r s} \\leftarrow \\{0, 1 \\} ^ {\\mathsf {p o l y} (\\lambda)} \\\\ \\left(\\Phi , z, z _ {\\mathsf {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}\\right) \\leftarrow \\mathcal {A} (\\mathsf {u r s}) \\\\ \\left(\\mathsf {i p k}, \\mathsf {i v k}\\right) \\leftarrow \\mathbb {I} (\\mathsf {u r s}, \\Phi) \\end{array} \\right. \\begin{array}{c}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\mathsf {u r s}, \\Phi , z, \\pi\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\left(\\mathsf {u r s}, \\tau\\right) \\leftarrow \\mathbb {S} \\\\ \\left(\\Phi , z, z _ {\\mathsf {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}\\right) \\leftarrow \\mathcal {A} (\\mathsf {u r s}) \\\\ \\pi \\leftarrow \\mathbb {S} (\\Phi , z, \\tau) \\end{array} \\right. \\end{array} \\right. $$</p>

    <p class="text-gray-300">Here, an adversary is honest if its output satisfies the implicant of the completeness condition with probability 1, namely: <span class="math">\\Phi \\in \\mathsf{F}</span>, <span class="math">\\Phi(z, z_{\\mathrm{loc}}, z_1, \\ldots, z_m) = 1</span>, and either for all <span class="math">i, z_i = \\bot</span>, or for all <span class="math">i</span>, <span class="math">\\mathbb{V}(\\mathsf{ivk}, z_i, \\pi_i) = 1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency.</strong> The indexer <span class="math">\\mathbb{I}</span>, prover <span class="math">\\mathbb{P}</span> and verifier <span class="math">\\mathbb{V}</span> run in polynomial time. A proof <span class="math">\\pi</span> has size $\\mathrm{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; in particular, it is not permitted to grow with each application of </span>\\mathbb{P}<span class="math">. In general the indexer can be incorporated into the prover and verifier; we consider it separately since this allows the verifier to potentially run in time sublinear in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">11.3 Theorem statement</p>

    <p class="text-gray-300">The key parameter that determines the efficiency of the preprocessing PCD scheme is the size of the preprocessing SNARK verifier as a circuit (or constraint system), as captured by the following definition.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Definition 11.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{ARG}=(\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> be a preprocessing non-interactive argument in the URS model. We denote by <span class="math">\\mathcal{V}^{(\\lambda,N,k)}</span> the circuit (or constraint system) corresponding to the computation of the SNARK verifier <span class="math">\\mathcal{V}</span>, for security parameter <span class="math">\\lambda</span>, when checking indices of size at most <span class="math">N</span> and instances of size at most <span class="math">k</span>. Hence, for every <span class="math">\\mathsf{urs}\\in\\{0,1\\}^{\\mathsf{poly}(\\lambda)}</span> and index-instance pair <span class="math">(\\mathfrak{i},\\mathfrak{z})</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k<span class="math">, index key pair </span>(\\mathsf{ipk},\\mathsf{ivk})\\in\\mathcal{I}(\\mathsf{urs},\\mathfrak{i})<span class="math">, and candidate proof </span>\\pi<span class="math">, we have </span>\\mathcal{V}^{(\\lambda,N,k)}(\\mathsf{urs},\\mathsf{ivk},\\mathfrak{z},\\pi)=\\mathcal{V}(\\mathsf{urs},\\mathsf{ivk},\\mathfrak{z},\\pi)<span class="math">. We denote by </span>\\mathsf{v}(\\lambda,N,k)<span class="math"> the size of the circuit </span>\\mathcal{V}^{(\\lambda,N,k)}<span class="math">, and by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the size of the index verification key </span>\\mathsf{ivk}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The <em>depth</em> of a compliance predicate <span class="math">\\Phi\\colon\\mathbb{F}^{(m+2)\\ell}\\to\\mathbb{F}</span>, denoted <span class="math">d(\\Phi)</span>, is the maximum depth of any <span class="math">\\Phi</span>-compliant transcript <span class="math">\\mathsf{T}</span>. We prove the following theorem, which constructs a PCD system for constant-depth compliance predicates from any sufficiently efficient preprocessing SNARK.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Theorem 11.5.</h6>

    <p class="text-gray-300">There exists a polynomial-time transformation <span class="math">\\mathrm{T}</span> such that if <span class="math">\\mathsf{ARG}=(\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> is an adaptive preprocessing SNARK for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> in the URS model then <span class="math">\\mathsf{PCD}=(\\mathbb{I},\\mathbb{P},\\mathbb{V}):=\\mathrm{T}(\\mathsf{ARG})</span> is a preprocessing PCD scheme in the URS model for constant-depth compliance predicates, provided</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\exists\\,\\epsilon\\in(0,1)\\text{ and a polynomial }\\alpha\\text{ s.t. }\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)=O(N^{1-\\epsilon}\\cdot\\alpha(\\lambda,\\ell))\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, if the size of the predicate <span class="math">\\Phi\\colon\\mathbb{F}^{(m+2)\\ell}\\to\\mathbb{F}</span> is <span class="math">f=\\omega((m\\cdot\\alpha(\\lambda,\\ell))^{1/\\epsilon})</span> then the PCD indexer, PCD prover, and PCD verifier run in time that equal those of the SNARK indexer, SNARK prover, and SNARK verifier on R1CS indices <span class="math">\\mathfrak{i}</span> of size <span class="math">f+o(f)</span> (and R1CS instances <span class="math">\\mathfrak{z}</span> of size <span class="math">O(\\lambda)+\\ell</span>).</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{ARG}</span> is adaptive zero knowledge, then <span class="math">\\mathsf{PCD}</span> is adaptive zero knowledge.</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{ARG}</span> is secure against quantum adversaries, then <span class="math">\\mathsf{PCD}</span> is secure against quantum adversaries.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Remark 11.6.</h6>

    <p class="text-gray-300">Our preprocessing zkSNARK for R1CS, <span class="math">\\mathsf{Fractal}</span>, achieves the following verifier size:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)=O(\\lambda\\ell+\\lambda^{2}\\log^{2}(N))\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">assuming a choice of cryptographic hash function that can be expressed via a constraint system of size <span class="math">O(\\lambda)</span>. This means that we may take any <span class="math">\\epsilon\\in(0,1)</span> and <span class="math">\\alpha(\\lambda,\\ell):=\\lambda(\\lambda+\\ell)</span>. In particular, if the size of a compliance predicate <span class="math">\\Phi</span> grows as <span class="math">(m\\lambda(\\lambda+\\ell))^{1+\\delta}</span> for any <span class="math">\\delta&gt;0</span>, then the time bounds in Theorem 11.5 hold for us.</p>

    <h3 id="sec-91" class="text-xl font-semibold mt-8">11.4 Construction and its efficiency</h3>

    <p class="text-gray-300">We describe how to construct the preprocessing PCD scheme, and then prove the efficiency properties stated in Theorem 11.5. We defer proving the security properties to Section 11.5.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Construction 11.7 (from SNARK to PCD).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ARG}=(\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> be a preprocessing SNARK for R1CS. We describe how to construct a preprocessing PCD scheme <span class="math">\\mathsf{PCD}=(\\mathbb{I},\\mathbb{P},\\mathbb{V})</span>.</p>

    <p class="text-gray-300">Given a compliance predicate <span class="math">\\Phi\\colon\\mathbb{F}^{(m+2)\\ell}\\to\\mathbb{F}</span>, the circuit that realizes the recursion is as follows.</p>

    <p class="text-gray-300"><span class="math">R^{(\\lambda,N,k)}_{\\mathcal{V},\\Phi,\\mathsf{urs}}\\big{(}(\\mathsf{ivk},z_{\\mathsf{out}}),(z_{\\mathsf{loc}},(z_{\\mathsf{in}}^{(i)},\\pi_{\\mathsf{in}}^{(i)})_{i\\in[m]})\\big{)}:</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the compliance predicate <span class="math">\\Phi(z_{\\mathsf{out}},z_{\\mathsf{loc}},z_{\\mathsf{in}}^{(1)},\\ldots,z_{\\mathsf{in}}^{(m)})</span> accepts.</li>

      <li>If there exists <span class="math">i</span> such that <span class="math">(z_{\\mathsf{in}}^{(i)},\\pi_{\\mathsf{in}}^{(i)})\\neq\\bot</span>:</li>

    </ol>

    <p class="text-gray-300">check that, for every <span class="math">i\\in[m]</span>, the SNARK verifier <span class="math">\\mathcal{V}^{(\\lambda,N,k)}(\\mathsf{urs},\\mathsf{ivk},(\\mathsf{ivk},z_{\\mathsf{in}}^{(i)}),\\pi_{\\mathsf{in}}^{(i)})</span> accepts.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the above checks hold, output <span class="math">0</span>; otherwise, output <span class="math">1</span></li>

    </ol>

    <p class="text-gray-300">Next we describe the indexer <span class="math">\\mathbb{I}</span>, prover <span class="math">\\mathbb{P}</span>, and verifier <span class="math">\\mathbb{V}</span> of the PCD scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{I}(\\mathsf{urs},\\Phi)</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute $N:=N(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,\\ell)<span class="math">, where </span>N$ is as defined in Lemma 11.8 below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the index key pair <span class="math">(\\mathsf{ipk},\\mathsf{ivk})\\leftarrow\\mathcal{I}(\\mathsf{urs},R)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{P}(\\mathsf{urs},\\mathsf{ipk},z_{\\mathsf{out}},z_{\\mathsf{loc}},\\vec{z}_{\\mathsf{in}},\\vec{\\pi}_{\\mathsf{in}})</span>: output the proof <span class="math">\\pi_{\\mathsf{out}}\\leftarrow\\mathcal{P}\\big{(}\\mathsf{urs},\\mathsf{ipk},(\\mathsf{ivk},z_{\\mathsf{out}}),(z_{\\mathsf{loc}},\\vec{z}_{\\mathsf{in}},\\vec{\\pi}_{\\mathsf{in}})\\big{)}</span>.</li>

      <li><span class="math">\\mathbb{V}(\\mathsf{urs},\\mathsf{ivk},z_{\\mathsf{out}},\\pi_{\\mathsf{out}})</span>: accept if <span class="math">\\mathcal{V}(\\mathsf{urs},\\mathsf{ivk},(\\mathsf{ivk},z_{\\mathsf{out}}),\\pi_{\\mathsf{out}})</span> accepts.</li>

    </ul>

    <h6 id="sec-93" class="text-base font-medium mt-4">Proof of Theorem 11.5 (efficiency).</h6>

    <p class="text-gray-300">Denote by <span class="math">f</span> the size of <span class="math">\\Phi</span> as an R1CS instance. In Construction 11.7, the explicit input consists of the index verification key <span class="math">\\mathsf{ivk}</span>, whose size depends on <span class="math">N</span> and <span class="math">\\lambda</span>, and a message <span class="math">z</span> whose size is <span class="math">\\ell</span> (independent of <span class="math">N</span>). The security parameter <span class="math">\\lambda</span> is also independent of <span class="math">N</span>. The circuit on which we wish to invoke <span class="math">\\mathcal{V}</span> is of size</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S(\\lambda,f,m,\\ell,N)=S_{0}(f,m,\\ell)+m\\cdot\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)\\quad\\text{for some}\\quad S_{0}(f,m,\\ell)=f+O(m\\ell)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We want to find a function <span class="math">N</span> such that <span class="math">S(\\lambda,f,m,\\ell,N(\\lambda,f,m,\\ell))\\leq N(\\lambda,f,m,\\ell)</span> and <span class="math">N</span> is not too large.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Lemma 11.8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that for every security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and message size <span class="math">\\ell\\in\\mathbb{N}</span> the ratio of verifier circuit size to index size $\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)/N<span class="math"> is monotone decreasing in </span>N<span class="math">. Then there exists a size function </span>N(\\lambda,f,m,\\ell)$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\,\\lambda,f,m,\\ell\\in\\mathbb{N}\\quad S(\\lambda,f,m,\\ell,N(\\lambda,f,m,\\ell))\\leq N(\\lambda,f,m,\\ell)\\enspace.</span></p>

    <p class="text-gray-300">Moreover if for some <span class="math">\\epsilon&gt;0</span> and some increasing function <span class="math">\\alpha</span> it holds that, for all <span class="math">N,\\lambda,\\ell</span> sufficiently large,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)\\leq N^{1-\\epsilon}\\alpha(\\lambda,\\ell)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then, for all <span class="math">\\lambda,\\ell</span> sufficiently large,</p>

    <p class="text-gray-300"><span class="math">N(\\lambda,f,m,\\ell)\\leq O(f)+(2m\\cdot\\alpha(\\lambda,\\ell))^{1/\\epsilon}\\enspace.</span></p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">N_{0}:=N_{0}(\\lambda,m,\\ell)</span> be the smallest integer such that $\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)/N<1/(2m)<span class="math">; this exists because of the monotone decreasing condition. Let </span>N(\\lambda,f,m,\\ell):=\\max(N_{0}(\\lambda,m,\\ell),2S_{0}(f,m,\\ell))<span class="math">. Then for </span>N:=N(\\lambda,f,m,\\ell)$ it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S(\\lambda,f,m,\\ell,N)=S_{0}(f,m,\\ell)+mN\\cdot\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)/N<N/2+N/2=N\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly <span class="math">S_{0}(f,m,\\ell)=O(f)</span>. Now suppose that $\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)\\leq(N^{1-\\epsilon}\\alpha(\\lambda,\\ell))<span class="math"> for all sufficiently large </span>N,\\lambda,\\ell<span class="math">. Let </span>N^{\\prime}(\\lambda,m,\\ell):=(2m\\cdot\\alpha(\\lambda,\\ell))^{1/\\epsilon}<span class="math">. Then for all </span>m<span class="math"> and sufficiently large </span>\\lambda,\\ell<span class="math">, for </span>N^{\\prime}:=N^{\\prime}(\\lambda,m,\\ell)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{v}(\\lambda,N^{\\prime},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)/N^{\\prime}<\\alpha(\\lambda,\\ell)\\cdot(2m\\cdot\\alpha(\\lambda,\\ell))^{-1}=1/(2m)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence <span class="math">N_{0}\\leq N^{\\prime}=(2m\\cdot\\alpha(\\lambda,\\ell))^{1/\\epsilon}</span>. ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The size of the circuit <span class="math">R_{\\mathcal{V},\\Phi,\\mathsf{urs}}^{(\\lambda,N,k)}</span> for <span class="math">N:=N(\\lambda,f,m,\\ell)</span> and $k:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell$ is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">S(\\lambda,f,m,\\ell,N)</span> $=f+O(m\\ell)+m\\cdot\\mathsf{v}(\\lambda,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ivk}(\\lambda,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=f+O(N^{1-\\epsilon}m\\alpha(\\lambda,\\ell))</span> <span class="math">=f+O(f^{1-\\epsilon}m\\cdot\\alpha(\\lambda,\\ell)+(m\\cdot\\alpha(\\lambda,\\ell))^{1/\\epsilon})\\enspace.</span></p>

    <p class="text-gray-300">In particular if <span class="math">f=\\omega((m\\cdot\\alpha(\\lambda,\\ell))^{1/\\epsilon})</span> then this is <span class="math">f+o(f)</span>, and so the stated efficiency bounds hold.</p>

    <p class="text-gray-300">11.5 Security reduction</p>

    <p class="text-gray-300">We establish the security properties in Theorem 11.5. We discuss knowledge soundness in Section 11.5.1, post-quantum security in Section 11.5.2, and zero knowledge in Section 11.5.3.</p>

    <h4 id="sec-96" class="text-lg font-semibold mt-6">11.5.1 Knowledge soundness</h4>

    <p class="text-gray-300">In the following, since the extracted transcript <span class="math">\\mathsf{T}</span> will be a tree, we find it convenient to associate the label <span class="math">(z^{(u,v)},\\pi^{(u,v)})</span> of the unique outgoing edge of a node <span class="math">u</span> with the node <span class="math">u</span> itself, so we refer to this as <span class="math">(z^{(u)},\\pi^{(u)})</span>. It is straightforward to transform such a transcript into one that satisfies Definition 11.2.</p>

    <p class="text-gray-300">Given a malicious prover <span class="math">\\tilde{\\mathbb{P}}</span>, we will define an extractor <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> that satisfies knowledge soundness. In the process we construct a sequence of extractors <span class="math">\\mathbb{E}_{1},\\ldots,\\mathbb{E}_{d}</span> for <span class="math">d:=d(\\Phi)</span> (the depth of <span class="math">\\Phi</span>); <span class="math">\\mathbb{E}_{j}</span> outputs a tree of depth <span class="math">j+1</span>. Let <span class="math">\\mathbb{E}_{0}(\\mathsf{urs})</span> run <span class="math">(\\Phi,\\mathsf{o},\\pi)\\leftarrow\\tilde{\\mathbb{P}}(\\mathsf{urs})</span> and output <span class="math">(\\Phi,\\mathsf{T}_{0})</span>, where <span class="math">\\mathsf{T}_{0}</span> is a single node labeled with <span class="math">(\\mathsf{o},\\pi)</span>. Let <span class="math">l_{\\mathsf{T}}(j)</span> denote the vertices of <span class="math">\\mathsf{T}</span> at depth <span class="math">j</span>; <span class="math">l_{\\mathsf{T}}(0):=\\emptyset</span> and <span class="math">l_{\\mathsf{T}}(1)</span> is the singleton containing the root.</p>

    <p class="text-gray-300">Now we define the extractor <span class="math">\\mathbb{E}_{j}</span> inductively for each <span class="math">j\\in\\{1,\\ldots,d\\}</span>. Suppose we have already constructed <span class="math">\\mathbb{E}_{j-1}</span>. We construct a SNARK prover <span class="math">\\tilde{\\mathcal{P}}_{j}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathcal{P}}_{j}(\\mathsf{urs})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">(\\Phi,\\mathsf{T}_{j-1})\\leftarrow\\mathbb{E}_{j-1}(\\mathsf{urs})</span>; for each vertex <span class="math">v\\in l_{\\mathsf{T}_{j-1}}(j)</span>, denote its label by <span class="math">(z^{(v)},\\pi^{(v)})</span>.</li>

      <li>Run the indexer <span class="math">(\\mathsf{ipk},\\mathsf{ivk})\\leftarrow\\mathcal{I}(\\mathsf{urs},R^{(\\lambda,N,k)}_{\\mathcal{V},\\Phi,\\mathsf{urs}})</span>.</li>

      <li>Output</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\vec{\\tilde{\\mathsf{s}}},\\vec{\\mathsf{z}},\\vec{\\pi},\\mathsf{aux}):=\\Big{(}\\vec{R},(\\mathsf{ivk},z^{(v)})_{v\\in l_{\\mathsf{T}_{j-1}}(j)},(\\pi^{(v)})_{v\\in l_{\\mathsf{T}_{j-1}}(j)},(\\Phi,\\mathsf{T}_{j-1})\\Big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\vec{R}</span> is the vector <span class="math">(R^{(\\lambda,N,k)}_{\\mathcal{V},\\Phi,\\mathsf{urs}},\\ldots,R^{(\\lambda,N,k)}_{\\mathcal{V},\\Phi,\\mathsf{urs}})</span> of the appropriate length.</p>

    <p class="text-gray-300">Next let <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}_{j}}</span> be the extractor that corresponds to <span class="math">\\tilde{\\mathcal{P}}_{j}</span>, via the knowledge soundness of the non-interactive argument <span class="math">\\mathsf{ARG}</span>. Finally the extractor <span class="math">\\mathbb{E}_{j}</span> is defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}_{j}(\\mathsf{urs})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the extractor <span class="math">(\\vec{\\tilde{\\mathsf{s}}},\\vec{\\mathsf{z}},\\vec{\\pi},\\mathsf{aux},\\vec{\\mathsf{w}})\\leftarrow\\mathcal{E}_{\\tilde{\\mathcal{P}}_{j}}(\\mathsf{urs})</span>, and parse the auxiliary output <span class="math">\\mathsf{aux}</span> as <span class="math">(\\Phi,\\mathsf{T}^{\\prime})</span>.</li>

      <li>If <span class="math">\\mathsf{T}^{\\prime}</span> is not a transcript of depth <span class="math">j</span>, abort.</li>

      <li>Output <span class="math">(\\Phi,\\mathsf{T}_{j})</span> where <span class="math">\\mathsf{T}_{j}</span> is the transcript constructed from <span class="math">\\mathsf{T}^{\\prime}</span> by doing the following for each vertex <span class="math">v\\in l_{\\mathsf{T}^{\\prime}}(j)</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>obtain the local data <span class="math">z^{(v)}_{\\mathsf{loc}}</span> and input messages <span class="math">\\big{(}z^{(i)}_{\\mathsf{in}},\\pi^{(i)}_{\\mathsf{in}}\\big{)}_{i\\in[m]}</span> from <span class="math">\\mathsf{w}^{(v)}</span>;</li>

      <li>append <span class="math">z^{(v)}_{\\mathsf{loc}}</span> to the label of <span class="math">v</span>, and if there exists any <span class="math">z^{(i)}_{\\mathsf{in}}</span> with <span class="math">z^{(i)}_{\\mathsf{in}}\\neq\\bot</span>, attach <span class="math">m</span> children to <span class="math">v</span> where the <span class="math">i</span>-th child is labeled with <span class="math">(z^{(i)}_{\\mathsf{in}},\\pi^{(i)}_{\\mathsf{in}})</span>.</li>

    </ul>

    <p class="text-gray-300">The extractor <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> runs <span class="math">(\\Phi,\\mathsf{T}_{d})\\leftarrow\\mathbb{E}_{d}(\\mathsf{urs})</span> and outputs <span class="math">(\\Phi,\\mathsf{o},\\pi,\\mathsf{T}_{d})</span>, where <span class="math">(\\mathsf{o},\\pi)</span> labels the root node.</p>

    <p class="text-gray-300">We now show that <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> has polynomial size and that it outputs a transcript that is <span class="math">\\Phi</span>-compliant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Size of the extractor. <span class="math">\\tilde{\\mathcal{P}}_{j}</span> is a circuit of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+O(2^{j})<span class="math">, so </span>\\mathcal{E}_{\\tilde{\\mathcal{P}}_{j}}<span class="math"> is a circuit of size </span>e(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+O(2^{j}))<span class="math"> Then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+c\\cdot 2^{j})<span class="math"> for some </span>c\\in\\mathbb{N}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A solution to this recurrence (for <span class="math">e(n)\\geq n</span>) is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e^{(j)}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbb{P}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+j\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2c\\cdot 2^{j})<span class="math">, where </span>e^{(j)}<span class="math"> is the function </span>e<span class="math"> iterated </span>j<span class="math"> times. Hence in particular if </span>d(\\Phi)<span class="math"> is a constant, </span>\\mathbb{E}_{\\tilde{\\mathbb{P}}}$ is a circuit of polynomial size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Correctness of the extractor. Fix a predicate <span class="math">p</span>. We show by induction that, for all <span class="math">j \\in \\{0, \\dots, d\\}</span>, the transcript <span class="math">\\mathsf{T}_j</span> output by <span class="math">\\mathbb{E}_j</span> is <span class="math">\\Phi</span>-compliant up to depth <span class="math">j</span>, that <span class="math">\\mathcal{V}^{(\\lambda, N, k)}(\\mathrm{urs}, \\mathrm{ivk}, (\\mathrm{ivk}, z^{(v)}), \\pi^{(v)})</span> accepts for all <span class="math">v \\in \\mathsf{T}</span>, and that <span class="math">p(\\Phi, \\mathsf{o}) = 1</span> and <span class="math">\\Phi \\in \\mathsf{F}</span> with probability <span class="math">\\mu - 2j \\cdot \\kappa(\\lambda, m^j)</span>.</p>

    <p class="text-gray-300">For <span class="math">j = 0</span> the statement is implied by <span class="math">\\mathbb{V}</span> accepting, and <span class="math">p(\\Phi, \\mathsf{o})</span> and <span class="math">\\Phi \\in \\mathsf{F}</span> holding, with probability <span class="math">\\mu</span>.</p>

    <p class="text-gray-300">Now suppose that <span class="math">(\\Phi, \\mathsf{T}_{j-1}) \\gets \\mathbb{E}_{j-1}</span> is such that <span class="math">\\mathsf{T}_{j-1}</span> is <span class="math">\\Phi</span>-compliant up to depth <span class="math">j-1</span>, that <span class="math">\\mathcal{V}^{(\\lambda,N,k)}(\\mathrm{urs},\\mathrm{ivk},(\\mathrm{ivk},z^{(v)}),\\pi^{(v)})</span> accepts for all <span class="math">v \\in \\mathsf{T}_{j-1}</span>, and that <span class="math">p(\\Phi,\\mathsf{o}(\\mathsf{T})) = 1</span> and <span class="math">\\Phi \\in \\mathsf{F}</span>, with probability <span class="math">\\mu - 2(j-1) \\cdot \\kappa(\\lambda,m^{j-1})</span>. Let <span class="math">(\\vec{\\mathbb{i}},(\\mathrm{ivk}_v,z^{(v)})_v,(\\pi^{(v)})_v,(\\Phi,\\mathsf{T}&#x27;),\\vec{\\mathfrak{w}}) \\gets \\mathcal{E}_{\\tilde{\\mathcal{P}}_j}</span>.</p>

    <p class="text-gray-300">Let <span class="math">p^{\\prime}(\\mathrm{urs},\\vec{\\mathbb{i}},(\\mathrm{ivk}_v,z^{(v)})_v,(\\Phi ,\\mathsf{T}^{\\prime})) = 1</span> if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">p(\\Phi, \\mathsf{o}(\\mathsf{T}&#x27;)) = 1</span> and <span class="math">\\Phi \\in \\mathsf{F}</span>,</li>

      <li><span class="math">\\mathfrak{i}^{(v)} = R_{\\mathcal{V},\\Phi,\\mathrm{urs}}^{(\\lambda,N,k)}</span> for all <span class="math">v</span>,</li>

      <li><span class="math">\\mathsf{T}&#x27;</span> is <span class="math">\\Phi</span>-compliant up to depth <span class="math">j - 1</span>, and</li>

      <li>for <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>, <span class="math">v</span> is labeled with <span class="math">(z^{(v)}, \\pi^{(v)})</span> and <span class="math">\\mathrm{ivk}_v = \\mathrm{ivk}</span> where <span class="math">(\\mathrm{ipk}, \\mathrm{ivk}) \\gets \\mathcal{I}(\\mathrm{urs}, R_{\\mathcal{V}, \\Phi, \\mathrm{urs}}^{(\\lambda, N, k)})</span>.</li>

    </ul>

    <p class="text-gray-300">By knowledge soundness, with probability <span class="math">\\mu - 2j \\cdot \\kappa(\\lambda, m^j)</span>, <span class="math">p&#x27;(\\mathrm{urs}, \\vec{\\mathbb{i}}, (\\mathrm{ivk}_v, z_v)_v, (\\Phi, \\mathsf{T}&#x27;)) = 1</span> and for every vertex <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>, <span class="math">(R_{\\mathcal{V}, \\Phi, \\mathrm{urs}}^{(\\lambda, N, k)}, (\\mathrm{ivk}_v, z^{(v)}), \\mathfrak{w}^{(v)}) \\in \\mathcal{R}_{\\mathrm{R1CS}}</span>. Here we use the predicate and auxiliary output in the knowledge soundness definition of ARG to ensure consistency between the values <span class="math">z^{(v)}</span> and <span class="math">\\mathsf{T}&#x27;</span>, and to ensure that <span class="math">\\mathsf{T}&#x27;</span> is <span class="math">\\Phi</span>-compliant.</p>

    <p class="text-gray-300">Now since <span class="math">(R_{\\mathcal{V},\\Phi,\\mathrm{urs}}^{(\\lambda,N,k)},(\\mathrm{ivk}_v,z^{(v)}),\\mathfrak{w}^{(v)})\\in \\mathcal{R}_{\\mathrm{R1CS}}</span>, we obtain from <span class="math">\\mathfrak{w}^{(v)}</span> either</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>local data <span class="math">z_{\\mathrm{loc}}^{(v)}</span> and input messages <span class="math">(z_{\\mathrm{in}}^{(i)}, \\pi_{\\mathrm{in}}^{(i)})_{i \\in [m]}</span> such that <span class="math">\\Phi(z^{(v)}, z_{\\mathrm{loc}}^{(v)}, z_{\\mathrm{in}}^{(1)}, \\ldots, z_{\\mathrm{in}}^{(m)})</span> accepts and for all <span class="math">i \\in [m]</span> the SNARK verifier <span class="math">\\mathcal{V}^{(\\lambda,N,k)}(\\mathrm{urs}, \\mathrm{ivk}, (\\mathrm{ivk}, z_{\\mathrm{in}}^{(i)}), \\pi_{\\mathrm{in}}^{(i)})</span> accepts; or</li>

      <li>local data <span class="math">z_{\\mathrm{loc}}^{(v)}</span> such that <span class="math">\\Phi(z^{(v)}, z_{\\mathrm{loc}}^{(v)}, \\bot, \\dots, \\bot)</span> accepts.</li>

    </ul>

    <p class="text-gray-300">In both cases we append <span class="math">z_{\\mathrm{loc}}^{(v)}</span> to the label of <span class="math">v</span>. In the former case we label the children of <span class="math">v</span> with <span class="math">(z_{\\mathrm{in}}^{(i)}, \\pi_{\\mathrm{in}}^{(i)})</span>, and so <span class="math">v</span> is <span class="math">\\Phi</span>-compliant, and all of its descendants <span class="math">w</span> have that <span class="math">\\mathcal{V}^{(\\lambda,N,k)}(\\mathrm{urs}, \\mathrm{ivk}, (\\mathrm{ivk}, z^{(w)}), \\pi^{(w)})</span> accepts. In the latter case, <span class="math">v</span> has no children and so is <span class="math">\\Phi</span>-compliant by the base case condition. Hence <span class="math">\\mathsf{T}_j \\gets \\mathbb{E}_j</span> is <span class="math">\\Phi</span>-compliant up to depth <span class="math">j</span>.</p>

    <p class="text-gray-300">Since <span class="math">d(\\Phi) \\leq d</span> it must be the case that all vertices <span class="math">v</span> at depth <span class="math">d</span> are in the base case. Hence by induction, <span class="math">(\\Phi, \\mathsf{T}) \\gets \\mathbb{E} = \\mathbb{E}_d</span> has <span class="math">\\Phi</span>-compliant <span class="math">\\mathsf{T}</span>, <span class="math">p(\\Phi, o(\\mathsf{T})) = 1</span> and <span class="math">\\Phi \\in \\mathsf{F}</span> with probability at least <span class="math">\\mu - 2d \\cdot \\kappa(\\lambda, m^d)</span>.</p>

    <h2 id="sec-97" class="text-2xl font-bold">11.5.2 Post-quantum security</h2>

    <p class="text-gray-300">In the quantum setting, <span class="math">\\tilde{\\mathbb{P}}</span> is taken to be a polynomial-size quantum circuit; hence also <span class="math">\\tilde{\\mathcal{P}}_j,\\mathcal{E}_{\\tilde{\\mathcal{P}}_j},\\mathbb{E}_j</span> are quantum circuits for all <span class="math">j</span>, as is the final extractor <span class="math">\\mathbb{E}</span>. Our definition of knowledge soundness is such that this proof then generalizes immediately to show security against quantum adversaries. In particular, the only difficulty arising from quantum adversaries is that they can generate their own randomness, whereas in the classical case we can force an adversary to behave deterministically by fixing its randomness. This is accounted for by the distributional requirement placed on the extractor of the argument system ARG.</p>

    <h2 id="sec-98" class="text-2xl font-bold">11.5.3 Zero knowledge</h2>

    <p class="text-gray-300">The PCD simulator <span class="math">\\mathbb{S}</span> operates as follows: define <span class="math">\\mathbb{S}(1^{\\lambda}) := \\mathcal{S}(1^{\\lambda})</span>; then</p>

    <p class="text-gray-300"><span class="math">\\mathbb{S}(\\Phi ,z,\\tau)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\gets \\mathcal{I}(\\mathrm{urs},R_{\\mathcal{V},\\Phi ,\\mathrm{urs}}^{(\\lambda ,N,k)})</span> (we assume that <span class="math">\\tau</span> includes urs).</li>

      <li>Output <span class="math">\\pi \\gets \\mathcal{S}(R_{\\mathcal{V},\\Phi ,\\mathrm{urs}}^{(\\lambda ,N,k)},(\\mathrm{ivk},z),\\tau)</span>.</li>

    </ol>

    <p class="text-gray-300">Zero knowledge then follows immediately from the (adaptive) zero knowledge guarantee of ARG, applied to the honest adversary <span class="math">\\mathcal{A}&#x27;</span> which runs the honest PCD adversary <span class="math">(\\Phi, z, z_{\\mathrm{loc}}, [z_i, \\pi_i]_{i=1}^m) \\gets \\mathcal{A}(\\mathrm{urs})</span> and outputs <span class="math">(R_{\\mathcal{V}, \\Phi, \\mathrm{urs}}^{(\\lambda, N, k)}, (\\mathrm{ivk}, z), (z_{\\mathrm{loc}}, [z_i, \\pi_i]_{i=1}^m))</span> where <span class="math">(\\mathrm{ipk}, \\mathrm{ivk}) \\gets \\mathcal{I}(\\mathrm{urs}, R_{\\mathcal{V}, \\Phi, \\mathrm{urs}}^{(\\lambda, N, k)})</span>. The same argument holds in the quantum setting; in that case, <span class="math">\\mathcal{A}&#x27;</span> is an honest quantum adversary.</p>

    <p class="text-gray-300">12 Implementation of recursive composition</p>

    <p class="text-gray-300">In Section 12.1 we describe our implementation work to realize our preprocessing zkSNARK (Fractal), and in Section 12.2 we describe our implementation work to realize recursive composition.</p>

    <h3 id="sec-99" class="text-xl font-semibold mt-8">12.1 The preprocessing zkSNARK</h3>

    <p class="text-gray-300">Our starting point is libiop <em>[x23]</em>, a library that provides (a) an implementation of the BCS transformation, which compiles any public-coin IOP into a corresponding SNARG by using (instantiated) random oracles; and (b) the non-holographic IOPs for R1CS underlying Aurora <em>[x1]</em> and Ligero <em>[x1]</em>.</p>

    <p class="text-gray-300">Our work to implement Fractal consists of (1) extending the BCS transformation to compile any public-coin holographic IOP into a corresponding preprocessing SNARG (following Section 10); and (2) implementing our efficient holographic IOP for R1CS (following Section 8). We discuss each in turn.</p>

    <p class="text-gray-300">(1) From holography to preprocessing. Our transformation from Section 10 is a black-box extension of the BCS transformation (see Construction 10.3), which made it possible to extend the current implementation of the BCS transformation while re-using much of the existing infrastructure. We modified the generic IOP infrastructure in libiop to additionally support expressing holographic IOPs, by providing an indexer algorithm (in addition to the prover and verifier algorithms). We modified the transformation to determine if the input IOP is holographic and, if so, to additionally produce an indexer for the argument system, which uses a Merkle tree on the encoded index to produce an index proving key and index verification key. In this case, the prover and verifier for the argument use these keys to produce/authenticate answers about the encoded index, following our construction. Overall, our implementation simultaneously supports the old transformation (from IOP to SNARG) and our new one (from holographic IOP to preprocessing SNARG).</p>

    <p class="text-gray-300">(2) Holographic IOP for R1CS. Our holographic IOP is built from two components (see Theorem 8.2): an RS-encoded holographic IOP and a low-degree test. For the latter, we reuse the generic low-degree testing infrastructure in libiop: the randomized reduction from testing multiple words to testing single words, and the FRI low-degree test <em>[x3]</em>. Our implementation work is about the former component.</p>

    <p class="text-gray-300">Specifically we implement the RS-encoded holographic IOP summarized in Fig. 4 (or, more precisely, an optimized and parametrized refinement of it), along with its indexer algorithm (not part of the figure). We reuse the reduction from R1CS to lincheck from the Aurora protocol in libiop (as our protocol shares the same reduction). The new key component that we implement is a holographic multi-lincheck, which simultaneously supports checking multiple linear relations that were holographically encoded. We believed that this building block of the protocol is of independent interest for the design of holographic proofs.</p>

    <p class="text-gray-300">In addition to enabling sublinear verification, the holographic setting also presents new opportunities for improvements in the concrete efficiency of certain subroutines of the verifier, because we can use the indexer to provide useful precomputed information to the verifier. We leverage such opportunities to precompute various algebraic objects (such as vanishing polynomials), achieving noticeable efficiency improvements.</p>

    <h3 id="sec-100" class="text-xl font-semibold mt-8">12.2 Designing the verifier’s constraint system</h3>

    <p class="text-gray-300">In order to recursively compose Fractal, we need to design a constraint system that expresses its verifier. We describe a general method for designing constraint systems for the verifiers of SNARGs obtained by combining an RS-encoded IOP and the FRI low-degree test (as in Theorem 8.2) and then transforming the resulting IOP into a SNARG using Theorem 10.1 (henceforth referred to as the “BCS transformation”).</p>

    <p class="text-gray-300">The verifier in such SNARGs splits naturally into an “algebraic” part arising from the underlying IOP (hereafter the “IOP verifier”) and a “hash-based” part arising from the BCS transformation (described in</p>

    <p class="text-gray-300">Construction 10.2, hereafter the "BCS verifier"). We treat them separately: the BCS verifier is discussed in Section 12.2.1 and the IOP verifier in Section 12.2.2.</p>

    <p class="text-gray-300">The BCS verifier can be further broken down into two subcomponents. The first is a hashchain that ensures that the IOP verifier's randomness for each round is correctly derived from the Merkle roots (Steps 1 and 2 of the BCS verifier in Construction 10.2). The second is the verification of the Merkle tree authentication paths to ensure the validity of the query answers (Step 3 of the BCS verifier in Construction 10.2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The hashchain. The hashchain computation of the BCS verifier is as follows: initialize  $\\sigma_0 \\coloneqq \\mathrm{ivk} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}<span class="math"> ; then, for each round  </span>i \\in \\{1, \\dots, k\\}<span class="math"> , derive the randomness  </span>\\rho_i \\coloneqq \\rho(\\sigma_{i-1})<span class="math">  and use the  </span>i<span class="math"> -th root  </span>\\mathsf{rt}_i<span class="math">  in the argument  </span>\\pi<span class="math">  to compute  </span>\\sigma_i \\coloneqq \\rho(\\sigma_{i-1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{rt}_i)<span class="math"> ; finally, derive the post-interaction randomness  </span>\\rho_{k+1} \\coloneqq \\rho(\\sigma_k)<span class="math"> . We require a constraint system  </span>S<span class="math">  that, given assignments to the variables  </span>(\\mathrm{ivk}, \\mathbf{x}, \\mathsf{rt}_1, \\rho_1, \\dots, \\mathsf{rt}_k, \\rho_k)$ , is satisfiable if and only if these assignments are consistent with this hashchain computation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We realize  <span class="math">S</span>  via a sponge construction [BDPV08], where first ivk and  <span class="math">\\mathbf{x}</span>  are absorbed into the state and then, for each round  <span class="math">i \\in \\{1, \\dots, k\\}</span> , the randomness  <span class="math">\\rho_i</span>  is squeezed from the state and the  <span class="math">i</span> -th root  <span class="math">\\mathsf{rt}_i</span>  is absorbed into the state; the post-interaction randomness  <span class="math">\\rho_{k+1}</span>  is then squeezed from the state. See Fig. 5 for a diagram of this. The size of the constraint system  <span class="math">S</span>  is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S _ {\\mathrm {i n}} \\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {i v k} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {x} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) + \\left(\\sum_ {i = 1} ^ {\\mathrm {k}} S _ {\\mathrm {i n}} \\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {r t} _ {i} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) + S _ {\\mathrm {o u t}} \\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_ {i} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)\\right) + S _ {\\mathrm {o u t}} \\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_ {\\mathrm {k} + 1} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">S_{\\mathrm{in}}(n)</span>  denotes the number of constraints to absorb  <span class="math">n</span>  field elements and  <span class="math">S_{\\mathrm{out}}(n)</span>  denotes the number of constraints to squeeze  <span class="math">n</span>  field elements. Naturally, these numbers depend on the particular choice of state transformation that is used to instantiate the sponge (see our evaluation in Section 13.2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above discussion omits some details. First, in some rounds the prover sends auxiliary information beyond the Merkle root (e.g., the third message of the prover in Fig. 4 includes a field element that allegedly equals an evaluation of the polynomial  <span class="math">\\hat{t}</span> ), and this auxiliary information must be absorbed together with the Merkle root. Second, Fig. 5 suggests that the rate of the sponge is large enough to absorb/squeeze any round's root/randomness with a single application of the state transformation, but this need not be the case, especially if sizes vary across rounds (e.g., we expect  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{ivk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to be larger than  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{rt}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ). Indeed, in our implementation we pick the rate of the sponge in such a way as to minimize the overall number of constraints for the hashchain, which means that some information may be absorbed/squeezed across multiple applications of the state transformation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 5: We use a sponge construction to realize the hashchain in the BCS verifier.</p>

    <p class="text-gray-300">Authentication paths. For every query made by the IOP verifier to the encoded index or to a proof oracle, the BCS prover provides an authentication path for that query relative to the appropriate Merkle root. Recall that the index verification key ivk contains the root  <span class="math">\\mathsf{rt}_0</span>  of the Merkle tree on the encoded index  <span class="math">\\mathbf{I}(\\mathbf{i})</span> ; and the</p>

    <p class="text-gray-300">argument <span class="math">\\pi</span> contains the roots <span class="math">\\mathsf{rt}_1,\\ldots ,\\mathsf{rt}_{\\mathsf{k}}</span> of the <span class="math">\\mathsf{k}</span> Merkle trees that correspond to the <span class="math">\\mathsf{k}</span> rounds of interaction. For every <span class="math">i\\in \\{0,1,\\dots ,\\mathsf{k}\\}</span>, we denote by <span class="math">Q_{i}</span> the queries to the leaves of the <span class="math">i</span>-th Merkle tree, by <span class="math">A_{i}</span> the claimed query answers, and by <span class="math">W_{i}</span> the corresponding auxiliary information to validate them. Both <span class="math">A_{i}</span> and <span class="math">W_{i}</span> are provided in the argument <span class="math">\\pi</span> for all <span class="math">i</span> (including <span class="math">i = 0</span>). Overall, we require a constraint system <span class="math">\\mathcal{S}</span> that, given assignments to the variables <span class="math">(\\mathsf{rt}_i,Q_i,A_i,W_i)_{i = 0}^{\\mathsf{k}}</span>, is satisfiable if and only if, for every <span class="math">i\\in \\{0,1,\\dots ,\\mathsf{k}\\}</span>, the auxiliary information <span class="math">W_{i}</span> validates the claimed answers in <span class="math">A_{i}</span> with respect to the queries in <span class="math">Q_{i}</span>.</p>

    <p class="text-gray-300">Below we describe the basic approach to designing the constraint system. Afterward we describe how to significantly reduce the number of constraints via several optimizations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The basic approach is to individually validate an authentication path for each query via a separate constraint system. Namely, let <span class="math">\\mathsf{rt}</span> be a root, <span class="math">j = \\sum_{k=1}^{d} j_k 2^{k-1}</span> a query location (in binary representation), <span class="math">a</span> a claimed answer, <span class="math">s</span> a salt used for hiding, and <span class="math">(u_k)_{k=1}^d</span> an authentication path. We require a constraint system that, given assignments to the variables <span class="math">(\\mathsf{rt}, j, a, s, (u_k)_{k=1}^d)</span>, is satisfiable if and only if the check in the following computation passes: (1) let <span class="math">v_d</span> be the hash of the salted answer $a \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s<span class="math">; (2) for each </span>k = d, \\ldots, 1<span class="math">: if the </span>k<span class="math">-th bit of </span>j<span class="math"> is 0 then let </span>v_{k-1}<span class="math"> be the hash of </span>v_k \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_k<span class="math">, and if instead it is 1 then let </span>v_{k-1}<span class="math"> be the hash of </span>u_k \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_k<span class="math">; (3) check that </span>v_0 = \\mathsf{rt}$. See Fig. 6 for a diagram of this constraint system.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we denote by <span class="math">S_{2 \\to 1}</span> the number of constraints to hash two hashes into a single hash, by <span class="math">S_{\\mathrm{cswap}}</span> the number of constraints for a "controlled swap" on two hashes, and by <span class="math">S_{\\mathrm{leaf}}(n)</span> the number of constraints to hash the answer and salt into a single hash, then the number of constraints for the above computation is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S _ {\\text {l e a f}} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + d \\cdot \\left(S _ {\\text {c s w a p}} + S _ {2 \\rightarrow 1}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If we replicate the above strategy for each round <span class="math">i \\in \\{0, 1, \\ldots, k\\}</span> and each query in the query set <span class="math">Q_i</span>, then the total number of constraints to validate all the query answers is:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {i = 0} ^ {k} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q _ {i} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\left(S _ {\\text {l e a f}} \\left(\\alpha_ {i} + \\sigma_ {i}\\right) + d _ {i} \\cdot \\left(S _ {\\text {c s w a p}} + S _ {2 \\rightarrow 1}\\right)\\right), \\tag {9}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\alpha_{i}\\in \\mathbb{N}</span> denotes the number of field elements to answer a query in round <span class="math">i</span>, <span class="math">\\sigma_{i}\\in \\mathbb{N}</span> the number of field elements in a salt in round <span class="math">i</span>, and <span class="math">d_{i}\\in \\mathbb{N}</span> the depth of the Merkle tree in round <span class="math">i</span>. (Note that <span class="math">\\sigma_0</span> is always 0 because no hiding is needed for the round that involves the encoded index; <span class="math">\\sigma_{i}</span> may also be 0 for <span class="math">i &amp;gt; 0</span> in some protocols because zero knowledge may not rely on any query bound to oracles in the <span class="math">i</span>-th round.)</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 6: Diagram of a constraint system for validating an authentication path.</p>

    <p class="text-gray-300">We can do significantly better than Eq. (9) if we leverage the structure of query sets, as we now describe.</p>

    <p class="text-gray-300">First, there are known optimizations that increase "leaf size" to reduce argument size [BBHR19; BCRSVW19] that we use to also reduce the number of constraints in our setting. We explain these below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hash by column. In protocols derived from RS-encoded IOPs using Theorem 8.2, each round's oracles are over the same domain and the IOP verifier queries the same locations across those oracles. This includes</li>

    </ul>

    <p class="text-gray-300">the “<span class="math">0</span>-th round oracles”, i.e., the oracles in the encoded index <span class="math">\\mathbf{I}(\\mathbbm{i})</span>. Hence, for <span class="math">i=0,1,\\ldots,\\mathsf{k}</span>, the BCS prover can hash the <span class="math">i</span>-th round oracles <em>column-wise</em>: if <span class="math">\\ell_{i}\\in\\mathbb{N}</span> is the number of oracles in the <span class="math">i</span>-th round then each leaf in the <span class="math">i</span>-th Merkle tree contains a vector in <span class="math">\\mathbb{F}^{\\ell_{i}}</span> (the “column”) representing one symbol from each of the <span class="math">\\ell_{i}</span> oracles. Thus a single authentication path suffices to authenticate all the answers from a query to the entire leaf. This not only reduces argument size (fewer authentication paths are included in the argument) but also reduces the number of constraints (fewer authentication paths are validated).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Hash by subset.</em> The low-degree test that we use (see Section 12.2.2) yields queries that consider each domain as partitioned into subsets of equal size and each query requests the values of all locations in a subset, i.e., for each round <span class="math">i</span> there is a parameter <span class="math">m_{i}\\in\\mathbb{N}</span> for which queries to oracles in the <span class="math">i</span>-th round are always grouped in disjoint subsets of size <span class="math">m_{i}</span>. Hence the BCS prover can hash all of these locations as part of the same leaf, which now is expanded from a vector in <span class="math">\\mathbb{F}^{\\ell_{i}}</span> to a matrix in <span class="math">\\mathbb{F}^{m_{i}\\times\\ell_{i}}</span>. This reduces the number of authentication paths, and also reduces the depth of the <span class="math">i</span>-th Merkle tree by <span class="math">\\log_{2}m_{i}</span> levels.</li>

    </ul>

    <p class="text-gray-300">Second, there are optimizations that pertain only to the goal of reducing the number of constraints, as we now exemplify. Since each oracle is queried at several locations, many authentication paths will overlap in the top layers of the Merkle trees. For argument size, this leads to the optimization of <em>path pruning</em> where the argument will contain the minimal collection of hashes that suffices to authenticate a <em>set</em> of queries. This optimization (which we continue to use for argument size) does <em>not</em> significantly reduce the number of constraints because validating the set of queries still involves re-computing the omitted hashes. Even worse, since query locations are random, we cannot hard-code in the constraint system which hash computations are repeated. We mitigate this problem via the following hybrid approach.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Tree cap.</em> By the pigeonhole principle, any set of authentication paths must overlap towards the top of the tree. To take advantage of this, we modify the Merkle tree in each round <span class="math">i</span> by connecting the vertices at layer <span class="math">t_{i}</span> (to be chosen later) directly to the root (and discarding the layers in between), so that the root has degree <span class="math">2^{t_{i}}</span>. We then compute the Merkle tree root using a “tree cap” hash function taking in <span class="math">2^{t_{i}}</span> hashes. Letting <span class="math">S_{\\mathsf{cap}}(n)</span> denote the number of constraints for such a hash of <span class="math">n</span> hashes, the total number of constraints across all rounds for the first layer alone is <span class="math">\\sum_{i=0}^{\\mathsf{k}}S_{\\mathsf{cap}}(2^{t_{i}})</span>.</li>

      <li><em>Other layers.</em> For the other layers, we treat the authentication paths as disjoint, and allocate a separate constraint system to validate the segment of each such path. This amounts to invoking the basic strategy described above, whose cost is summarized in Eq. (9), with the modification that the authentication path is reduced from length <span class="math">d_{i}</span> to length <span class="math">d_{i}-t_{i}</span>. Note that, in light of the above discussions on answer size, we know that the answer in round <span class="math">i</span> is of size <span class="math">\\alpha_{i}:=m_{i}\\cdot\\ell_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">The above hybrid approach yields a total number of constraints equal to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{i=0}^{\\mathsf{k}}S_{\\mathsf{cap}}(2^{t_{i}})+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\Big{(}S_{\\mathsf{leaf}}(m_{i}\\cdot\\ell_{i}+\\sigma_{i})+(d_{i}-t_{i})\\cdot(S_{\\mathsf{cswap}}+S_{2\\to 1})\\Big{)}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The constants <span class="math">t_{i}</span> are chosen to minimize the above expression. In Section 13.2 we discuss the concrete improvements of the hybrid approach over the simplistic approach.</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Remark 12.1 (arity of the Merkle tree).</h6>

    <p class="text-gray-300">There are algebraic hash functions for which using Merkle trees with large arity significantly reduces the number of constraints required to check many authentication paths <em>[ACGKLRS19, GKRRS19]</em>. This comes at the cost of a larger argument size, and our implementation currently does not provide the option of such tradeoffs.</p>

    <h5 id="sec-103" class="text-base font-semibold mt-4">Representing query locations.</h5>

    <p class="text-gray-300">We have so far assumed that the inputs and outputs of hash functions are field elements, as opposed to bits. This is because we instantiate all hash functions via algebraic constructions that require fewer constraints to express (see Section 13.2) and also because certain aspects of the verifier are simpler (e.g., the verifier’s randomness in the protocol is essentially uniformly random in <span class="math">\\mathbb{F}</span>). That said, for the query part, the verifier does not draw query locations from the whole field <span class="math">\\mathbb{F}</span> but, instead, from an evaluation domain contained in <span class="math">\\mathbb{F}</span>, and we need to obtain a bit-representation of these locations to check Merkle tree authentication paths. Recall also that queries are grouped into subset, and so the location will refer to the subset in the evaluation domain rather than to a single element in the evaluation domain.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We thus perform a bit decomposition of the field elements output by the hash function, split the resulting string into substrings of appropriate size, and regard each substring as a bit-representation of the queried subset. In more detail, for each round <span class="math">i\\in\\{0,1,\\ldots,\\mathsf{k}\\}</span>, let <span class="math">L_{i}\\subseteq\\mathbb{F}</span> be the evaluation domain of round <span class="math">i</span> and recall that queries in round <span class="math">i</span> are on subsets of size <span class="math">m_{i}</span>. This means that we can obtain $\\lfloor\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rfloor/(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\log_{2}m_{i})<span class="math"> subsets in </span>L_{i}<span class="math"> for each element in </span>\\mathbb{F}<span class="math"> output by the hash function. Therefore, if we need to sample </span>\\mathsf{q}<span class="math"> subsets in </span>L_{i}<span class="math">, the number of field elements that we need to allocate in </span>\\rho_{\\mathsf{k}+1}<span class="math"> is </span>\\lceil\\mathsf{q}\\cdot\\frac{\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\log_{2}m_{i}}{\\lfloor\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rfloor}\\rceil<span class="math">. Obtaining from these field elements the corresponding bit representations requires about </span>\\mathsf{q}\\cdot(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\log_{2}m_{i}+2)$ constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We stress that queries across rounds need not be independent. Indeed, for the IOP verifiers that we consider (see Section 12.2.2), it will hold that each round receives the same number of queries (informally, there exists <span class="math">\\mathsf{q}</span> such that $\\mathsf{q}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\cdots=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{\\mathsf{k}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) and all the queries are correlated in that the </span>\\mathsf{q}<span class="math"> subsets for each round can all be derived from </span>\\mathsf{q}$ samples of a certain length.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-104" class="text-lg font-semibold mt-6">12.2.2 The IOP verifier</h4>

    <p class="text-gray-300">We describe the design of a constraint system that can express the verifier of any (holographic) IOP derived from an RS-encoded (holographic) IOP and a low-degree test, according to the construction underlying Theorem 8.2. Informally, the RS-encoded (holographic) IOP is an interactive reduction that leads to a set of algebraic claims about the prover’s oracles (and possibly also about the encoded index); and the low-degree test is an interactive protocol that is used to ensure that these algebraic claims hold.</p>

    <h5 id="sec-105" class="text-base font-semibold mt-4">Outline.</h5>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> be a holographic IOP for an indexed relation <span class="math">\\mathcal{R}</span> constructed via Theorem 8.2. Note that <span class="math">\\mathcal{R}</span> need not be the R1CS indexed relation. Below we recall the two ingredients of the construction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <span class="math">\\mathsf{k}^{\\mathcal{R}}</span>-round RS-encoded holographic IOP <span class="math">(\\mathbf{I}_{\\mathcal{R}},\\mathbf{P}_{\\mathcal{R}},\\mathbf{V}_{\\mathcal{R}},\\{\\vec{d}_{\\mathbf{I}},\\vec{d}_{\\mathbf{P},1},\\ldots,\\vec{d}_{\\mathbf{P},\\mathsf{k}^{\\mathcal{R}}}\\})</span> over a domain <span class="math">L</span>, with maximum degree <span class="math">(d_{\\mathsf{c}},d_{\\mathsf{e}})</span>, for the indexed relation <span class="math">\\mathcal{R}</span>. In each of <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds, the RS-hIOP verifier <span class="math">\\mathbf{V}_{\\mathcal{R}}</span> sends randomness and the RS-hIOP prover <span class="math">\\mathbf{P}_{\\mathcal{R}}</span> sends an oracle; after the interaction, the RS-hIOP verifier <span class="math">\\mathbf{V}_{\\mathcal{R}}</span> outputs a set of rational constraints (the algebraic claims, see Definition 4.1). We view the RS-hIOP verifier <span class="math">\\mathbf{V}_{\\mathcal{R}}</span> as a function that maps an instance <span class="math">\\mathbf{\\Xi}</span> and randomness <span class="math">\\boldsymbol{\\rho}^{\\mathcal{R}}</span> to a set of rational constrains <span class="math">\\mathcal{C}</span>.</li>

      <li>A <span class="math">\\mathsf{k}^{\\mathrm{LDT}}</span>-round low-degree test <span class="math">(\\mathbf{P}_{\\mathrm{LDT}},\\mathbf{V}_{\\mathrm{LDT}})</span> for the Reed–Solomon code <span class="math">\\mathrm{RS}[L,d_{\\mathsf{c}}]</span>. In each of <span class="math">\\mathsf{k}^{\\mathrm{LDT}}</span> rounds, the LDT verifier <span class="math">\\mathbf{V}_{\\mathrm{LDT}}</span> sends randomness and the LDT prover <span class="math">\\mathbf{P}_{\\mathrm{LDT}}</span> sends an oracle; after the interaction, the LDT verifier <span class="math">\\mathbf{V}_{\\mathrm{LDT}}</span> makes <span class="math">\\mathsf{q}^{\\mathrm{LDT}}</span> queries, and then accepts or rejects. We can view the LDT verifier <span class="math">\\mathbf{V}_{\\mathrm{LDT}}</span> as two algorithms: a query algorithm <span class="math">\\mathbf{V}_{\\mathrm{LDT}}.\\mathrm{Q}</span> such that <span class="math">(Q_{0},Q_{1},\\ldots,Q_{\\mathsf{k}^{\\mathrm{LDT}}}):=\\mathbf{V}_{\\mathrm{LDT}}.\\mathrm{Q}(\\boldsymbol{\\rho}^{\\mathrm{LDT}})</span> are the queries to the tested oracle and the <span class="math">\\mathsf{k}^{\\mathrm{LDT}}</span> prover oracles on randomness <span class="math">\\boldsymbol{\\rho}^{\\mathrm{LDT}}</span>; and a decision algorithm <span class="math">\\mathbf{V}_{\\mathrm{LDT}}.\\mathrm{D}</span> such that <span class="math">\\mathbf{V}_{\\mathrm{LDT}}.\\mathrm{D}(A_{0},A_{1},\\ldots,A_{\\mathsf{k}^{\\mathrm{LDT}}},\\boldsymbol{\\rho}^{\\mathrm{LDT}})</span> is the decision of the verifier given answers to the queries and the same randomness.</li>

    </ul>

    <p class="text-gray-300">We need to design a constraint system to express the computation of the holographic IOP verifier <span class="math">\\mathbf{V}</span>, and so we are faced with three sub-tasks: (1) design a constraint system for the RS-hIOP verifier <span class="math">\\mathbf{V}_{\\mathcal{R}}</span>; (2) design a constraint system for the LDT verifier <span class="math">\\mathbf{V}_{\\mathrm{LDT}}</span>; (3) combine these two into a constraint system for <span class="math">\\mathbf{V}</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">We review features of the construction in Theorem 8.2 relevant for designing the constraint system.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomness. The verifier <span class="math">\\mathbf{V}</span> has <span class="math">\\mathsf{k}^{\\mathcal{R}}+\\mathsf{k}^{\\text{LDT}}</span> rounds of interaction where the first <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds are for <span class="math">\\mathbf{V}_{\\mathcal{R}}</span> and the remaining <span class="math">\\mathsf{k}^{\\text{LDT}}</span> rounds are for <span class="math">\\mathbf{V}_{\\text{LDT}}</span>. This means that we can split the randomness <span class="math">\\boldsymbol{\\rho}</span> of <span class="math">\\mathbf{V}</span> into randomness <span class="math">\\boldsymbol{\\rho}^{\\mathcal{R}}</span> for <span class="math">\\mathbf{V}_{\\mathcal{R}}</span> and randomness <span class="math">\\boldsymbol{\\rho}^{\\text{LDT}}</span> for <span class="math">\\mathbf{V}_{\\text{LDT}}</span>.</li>

      <li>Domains. The oracles in the encoded index and in the first <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds are all over the domain <span class="math">L</span>, while oracles in the other <span class="math">\\mathsf{k}^{\\text{LDT}}</span> rounds are over domains determined by the LDT.</li>

      <li>Queries. The queries to the oracles in the encoded index and in the first <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds are all the same, i.e., they are specified by the query set <span class="math">Q_{0}\\subseteq L</span> for the tested oracle determined by the LDT verifier.</li>

      <li>Tested oracle. The low-degree test is invoked on a “virtual oracle” <span class="math">f\\colon L\\to\\mathbb{F}</span> defined as a random linear combination of rational constraints output by the RS-hIOP verifier. Namely, if <span class="math">((p_{k},q_{k},d_{k}))_{k=1}^{r}</span> are the rational constraints output by <span class="math">\\mathbf{V}_{\\mathcal{R}}(\\mathbbm{x};\\boldsymbol{\\rho}^{\\mathcal{R}})</span>, <span class="math">\\alpha_{1},\\ldots,\\alpha_{k}</span> are the random coefficients, and <span class="math">f_{1},\\ldots,f_{\\ell}\\colon L\\to\\mathbb{F}</span> are the oracles sent by the RS-hIOP prover across the <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds, then <span class="math">f</span> is defined as follows:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\forall\\,a\\,,\\ f(a):=\\sum_{k=1}\\alpha_{k}\\cdot\\frac{p_{k}(a,f_{1}(a),\\ldots,f_{\\ell}(a))}{q_{k}(a)}\\enspace.</span></p>

    <p class="text-gray-300">The low-degree test will read <span class="math">f</span> at the query set <span class="math">Q_{0}</span>, which means that all oracles <span class="math">f_{1},\\ldots,f_{\\ell}</span> will also be read at <span class="math">Q_{0}</span>, and their answers must be combined according to the rational constraints and random coefficients.</p>

    <h4 id="sec-106" class="text-lg font-semibold mt-6">(1) RS-hIOP.</h4>

    <p class="text-gray-300">First we note that the structure of the interactive phase of the RS-hIOP for <span class="math">\\mathcal{R}</span> determines what the hashchain described in Section 12.2.1 needs to squeeze and absorb for the first <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds. In the case of our RS-hIOP for R1CS this round information can be directly read off from Fig. 4.</p>

    <p class="text-gray-300">We now turn to discussing the constraint system associated to <span class="math">\\mathbf{V}_{\\mathcal{R}}</span>, which is tasked to evaluate the rational constraints output by <span class="math">\\mathbf{V}_{\\mathcal{R}}</span> at a set of locations <span class="math">Q\\subseteq L</span> (the queries for the oracle tested by the LDT).</p>

    <p class="text-gray-300">Suppose that the number of oracles sent by the RS-hIOP prover across the <span class="math">\\mathsf{k}^{\\mathcal{R}}</span> rounds is <span class="math">\\ell</span>, and suppose that the number of rational constraints output by the RS-hIOP verifier is <span class="math">r</span>. We seek a constraint system that, given as input an instance <span class="math">\\mathbbm{x}</span>, randomness <span class="math">\\boldsymbol{\\rho}^{\\mathcal{R}}</span>, query set <span class="math">Q</span>, answers from all oracles <span class="math">(\\beta_{a,j})_{a\\in Q,j\\in[\\ell]}</span> and claimed evaluations <span class="math">(\\gamma_{a,k})_{a\\in Q,k\\in[r]}</span>, is satisfiable if and only if, letting <span class="math">((p_{k},q_{k},d_{k}))_{k=1}^{r}</span> be the rational constraints output by <span class="math">\\mathbf{V}_{\\mathcal{R}}(\\mathbbm{x};\\boldsymbol{\\rho}^{\\mathcal{R}})</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\forall\\,a\\in Q\\ ,\\ \\forall\\,k\\in[r]\\ ,\\ \\gamma_{a,k}=\\frac{p_{k}(a,\\beta_{a,1},\\ldots,\\beta_{a,\\ell})}{q_{k}(a)}\\enspace.</span></p>

    <p class="text-gray-300">In all known RS-encoded protocols, including the RS-hIOP for R1CS in Fig. 4, the rational constraints output by the RS-hIOP verifier depend on the instance <span class="math">\\mathbbm{x}</span> and randomness <span class="math">\\boldsymbol{\\rho}^{\\mathcal{R}}</span> in an algebraic way, in the sense that we can view <span class="math">\\mathbbm{x}</span> and <span class="math">\\boldsymbol{\\rho}^{\\mathcal{R}}</span> as auxiliary variables of the arithmetic circuits <span class="math">(p_{k})_{k=1}^{r}</span>. This means that the cost to check all the equations above is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\left(\\sum_{k=1}^{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1\\right)\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote the sizes of the arithmetic circuits for </span>p_{k}<span class="math"> and </span>q_{k}<span class="math">. (The additive </span>1$ accounts for checking the equality given variables that contain the outputs of the two arithmetic circuits.) Note that these complexity measures are related to, but different from, the query evaluation time defined in Section 4.1: query evaluation time is a uniform complexity measure, whereas circuit size is non-uniform.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In our implementation we additionally reuse sub-computations across constraint systems and across evaluation points to reduce the size of the constraint system. For example, if <span class="math">q_{k}=q_{k^{\\prime}}</span> for distinct <span class="math">k,k^{\\prime}</span> then we know that we only need to compute <span class="math">q_{k}(a)</span> once; similarly if <span class="math">p_{k}</span> and <span class="math">p_{k^{\\prime}}</span> share sub-computations. One can verify that there are several such opportunities for the RS-hIOP for R1CS in Fig. 4.</p>

    <h4 id="sec-107" class="text-lg font-semibold mt-6">11.2.2 (2) Low-degree test.</h4>

    <p class="text-gray-300">The low-degree test that we use in this paper is FRI <em>[x1]</em>, which is a logarithmic-round logarithmic-query protocol. Below we describe a constraint system that represents the FRI verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">L</span> be the domain of the oracle to be tested (i.e., the domain of the RS-hIOP). The size of <span class="math">L</span> induces a list of “localization parameters” <span class="math">(\\eta_{1},\\ldots,\\eta_{\\mathsf{k}^{\\mathsf{LDT}}})</span> which in turn induces a list of domains <span class="math">(L_{1},\\ldots,L_{\\mathsf{k}^{\\mathsf{LDT}}})</span> with progressively smaller sizes, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^{\\eta_{i}}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^{\\eta_{1}+\\cdots+\\eta_{i}}<span class="math"> with </span>L_{0}:=L<span class="math">. Each domain </span>L_{i}<span class="math"> is obtained from </span>L_{i-1}<span class="math"> as the image of a </span>2^{\\eta_{i}}<span class="math">-to-</span>1<span class="math"> map </span>h_{i}<span class="math"> that maps cosets of size </span>2^{\\eta_{i}}<span class="math"> in </span>L_{i-1}<span class="math"> to single points in </span>L_{i}<span class="math">. Any coset </span>U_{0}<span class="math"> of size </span>2^{\\eta_{1}}<span class="math"> in the domain </span>L_{0}=L<span class="math"> determines </span>\\mathsf{k}^{\\mathsf{LDT}}-1<span class="math"> cosets </span>(U_{1},\\ldots,U_{\\mathsf{k}^{\\mathsf{LDT}}-1})<span class="math"> of respective sizes </span>(2^{\\eta_{2}},\\ldots,2^{\\mathsf{k}^{\\mathsf{LDT}}})<span class="math"> contained in </span>(L_{1},\\ldots,L_{\\mathsf{k}^{\\mathsf{LDT}}-1})<span class="math"> as follows: for each </span>i\\in\\{1,\\ldots,\\mathsf{k}^{\\mathsf{LDT}}-1\\}<span class="math">, </span>U_{i}<span class="math"> is the unique coset of size </span>2^{\\eta_{i+1}}<span class="math"> that contains the point </span>h_{i}(U_{i-1})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We separately address the interactive phase and the query phase.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Interactive phase. For <span class="math">i\\in\\{1,\\ldots,\\mathsf{k}^{\\mathsf{LDT}}\\}</span>, in round <span class="math">i</span> the FRI verifier sends a random field element <span class="math">\\alpha_{i}</span> and the FRI prover replies with an oracle <span class="math">f_{i}\\colon L_{i}\\to\\mathbb{F}</span> if <span class="math">i&lt;\\mathsf{k}^{\\mathsf{LDT}}</span>, or with a (non-oracle) message containing the coefficients of a polynomial <span class="math">\\hat{f}_{\\mathsf{k}^{\\mathsf{LDT}}}(X)</span> if <span class="math">i=\\mathsf{k}^{\\mathsf{LDT}}</span>. If the degree to be tested is <span class="math">d</span> then the degree of <span class="math">\\hat{f}_{\\mathsf{k}^{\\mathsf{LDT}}}(X)</span> is <span class="math">d_{\\mathsf{k}^{\\mathsf{LDT}}}:=d/2^{\\eta_{1}+\\cdots+\\eta_{\\mathsf{k}^{\\mathsf{LDT}}}}</span>. Queries to domain <span class="math">L_{i-1}</span> are grouped in cosets of size <span class="math">2^{\\eta_{i}}</span>. Hence larger localization parameters lead to fewer rounds, at the expense of querying larger cosets. (Choosing these parameters well is crucial to minimizing constraint complexity, as we discuss in Section 13.2.)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the FRI verifier is public-coin, its interactive phase does not yield any special constraints. However the specifics of the interaction affect the hashchain described in Section 12.2.1, which is responsible to squeeze verifier randomness and absorb prover messages. We deduce that, for each round <span class="math">i\\in\\{1,\\ldots,\\mathsf{k}^{\\mathsf{LDT}}-1\\}</span>: the hashchain is required to squeeze a single field element and then to absorb a single Merkle root, and the depth of the corresponding Merkle tree is $\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(\\eta_{1}+\\cdots+\\eta_{i+1})<span class="math">. In the last round (</span>i=\\mathsf{k}^{\\mathsf{LDT}}<span class="math">), the hashchain is required to squeeze a single field element and then to absorb </span>d_{\\mathsf{k}^{\\mathsf{LDT}}}+1$ field elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query phase. The FRI verifier repeats the following <span class="math">\\mathsf{q}</span> times, for a number <span class="math">\\mathsf{q}</span> that controls soundness error.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Queries. The FRI verifier samples a random coset <span class="math">U_{0}</span> of size <span class="math">2^{\\eta_{1}}</span> in the domain <span class="math">L_{0}=L</span>, and reads the values of the oracle to be tested at <span class="math">U_{0}</span>. The coset <span class="math">U_{0}</span> determines, for each <span class="math">i\\in\\{1,\\ldots,\\mathsf{k}^{\\mathsf{LDT}}-1\\}</span>, a coset <span class="math">U_{i}</span> of size <span class="math">2^{\\eta_{i+1}}</span> in the domain <span class="math">L_{i}</span>, and the FRI verifier reads the values of the oracle <span class="math">f_{i}</span> in round <span class="math">i</span> at <span class="math">U_{i}</span>. Finally, the FRI verifier also reads all the <span class="math">d_{\\mathsf{k}^{\\mathsf{LDT}}}+1</span> coefficients of the polynomial sent in round <span class="math">\\mathsf{k}^{\\mathsf{LDT}}</span>.</li>

      <li>Decision. For each <span class="math">i\\in\\{0,1,\\ldots,\\mathsf{k}^{\\mathsf{LDT}}-1\\}</span>, let <span class="math">p_{i}(X)</span> be the polynomial of degree less than <span class="math">2^{\\eta_{i+1}}</span> that equals the interpolation of the values read for the <span class="math">i</span>-th coset <span class="math">U_{i}</span>. Let <span class="math">\\hat{f}_{\\mathsf{k}^{\\mathsf{LDT}}}(X)</span> be the polynomial of degree <span class="math">d_{\\mathsf{k}^{\\mathsf{LDT}}}</span> sent by the prover in the last round (round <span class="math">i=\\mathsf{k}^{\\mathsf{LDT}}</span>).</li>

    </ul>

    <p class="text-gray-300">The FRI verifier performs the following <span class="math">\\mathsf{k}^{\\mathsf{LDT}}</span> consistency checks: for each <span class="math">i\\in\\{1,\\ldots,\\mathsf{k}^{\\mathsf{LDT}}-1\\}</span>, check that <span class="math">p_{i-1}(\\alpha_{i})=f_{i}(h_{i}(U_{i-1}))</span>; also check that <span class="math">p_{\\mathsf{k}^{\\mathsf{LDT}}-1}(\\alpha_{\\mathsf{k}^{\\mathsf{LDT}}})=\\hat{f}_{\\mathsf{k}^{\\mathsf{LDT}}}(\\alpha_{\\mathsf{k}^{\\mathsf{LDT}}})</span>.</p>

    <p class="text-gray-300">The implication of the first item above to the constraint system is that the hashchain described in Section 12.2.1 needs to squeeze enough field elements to determine <span class="math">\\mathsf{q}</span> samples of starting cosets in the domain <span class="math">L_{0}=L</span> (with each sample indexed in binary as already discussed). Moreover, the constraint system needs to check, for each starting coset <span class="math">U_{0}</span>, that the remaining <span class="math">\\mathsf{k}^{\\mathsf{LDT}}-1</span> cosets <span class="math">U_{i}</span> are correctly chosen. For this, since <span class="math">h_{i}</span> has degree <span class="math">2^{\\eta_{i}}</span>, we need at most <span class="math">2^{\\eta_{i}}</span> constraints. Hence, the total constraint cost for checking <span class="math">\\mathsf{q}</span> lists of cosets is <span class="math">\\mathsf{q}\\cdot\\sum_{i=1}^{\\mathsf{k}^{\\mathsf{LDT}}}2^{\\eta_{i}}</span>. (In fact, we can avoid this cost altogether: by choosing an appropriate</p>

    <p class="text-gray-300">it representation, we can obtain the bit decomposition of the index of coset <span class="math">U_{i}</span> by truncating the bit decomposition of the index of coset <span class="math">U_{i-1}</span>, in which case no constraints are needed.)</p>

    <p class="text-gray-300">The implication of the second item above to the constraint system is that the FRI verifier, for each of q runs, needs to evaluate the interpolation of k^{LDT} cosets at a single point and also evaluate the polynomial contained in the last message at a single point. This number of constraints for this is</p>

    <p class="text-gray-300"><span class="math">\\textsf{q}\\cdot\\left(S_{\\textsf{eval}}\\left(\\frac{d}{2^{\\eta_{1}+\\cdots+\\eta_{\\textsf{k}^{LDT}}}}\\right)+\\sum_{i=1}^{\\textsf{k}^{LDT}}S_{\\textsf{lde}}(2^{\\eta_{i}})\\right)\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">S_{\\textsf{eval}}(n)=n</span> is the number of constraints to evaluate a polynomial of degree <span class="math">n</span> (say, via a constraint system that follows Horner’s method), and <span class="math">S_{\\textsf{lde}}(n)=2n+O(\\log n)</span> is the number of constraints to evaluate at a single point the interpolation of a function defined over a size-<span class="math">n</span> coset. We justify this latter cost below, because the design of the constraint system for interpolation requires some care.</p>

    <h4 id="sec-108" class="text-lg font-semibold mt-6">Coset interpolation.</h4>

    <p class="text-gray-300">We require a constraint system that, given the identifier of a coset <span class="math">S</span> in a domain <span class="math">L</span>, a function <span class="math">f\\colon S\\to\\mathbb{F}</span>, an evaluation point <span class="math">\\gamma\\in\\mathbb{F}</span>, and a claimed evaluation <span class="math">v\\in\\mathbb{F}</span>, is satisfiable if and only if <span class="math">v=\\sum_{a\\in S}f(a)L_{a,S}(\\gamma)</span>, where <span class="math">\\{L_{a,S}(X)\\}_{a\\in S}</span> are the Lagrange polynomials for <span class="math">S</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We describe a constraint system of size $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">. Given the Lagrange coefficients, we can compute the inner product of the function and the Lagrange coefficients with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> constraints. This leaves </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$ constraints to compute the Lagrange coefficients, as we discuss below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A simplistic approach would be to deduce the coefficients of each Lagrange polynomial <span class="math">\\{L_{a,S}(X)\\}_{a\\in S}</span>, hardcode these coefficients in the constraint system, and then let the constraint system compute <span class="math">\\{L_{a,S}(\\gamma)\\}_{a\\in S}</span> for the given evaluation point <span class="math">\\gamma\\in\\mathbb{F}</span>. However, the choice of coset <span class="math">S</span> is not known at “compile time” (when constructing the constraint system) because the identifier of <span class="math">S</span> in the domain <span class="math">L</span> is an input to the constraint system. We now explain how to efficiently compute all the evaluations without “generically” deriving the coefficients of each Lagrange polynomial (which would be much more expensive).</p>

    <p class="text-gray-300">Observe that, at compile time, we know some information about <span class="math">S</span>: the base coset (i.e., subgroup) <span class="math">S^{<em>}</span> from which the coset <span class="math">S</span> is derived as a shift (<span class="math">S^{</em>}</span> need not be in <span class="math">L</span>). Namely, in the additive case <span class="math">S=S^{<em>}+\\xi</span> for some <span class="math">\\xi\\in\\mathbb{F}</span>, and in the multiplicative case <span class="math">S=\\xi S^{</em>}</span> for some <span class="math">\\xi\\in\\mathbb{F}</span>. Thus the identifier of <span class="math">S</span> in <span class="math">L</span> can be viewed as encoding the shift <span class="math">\\xi</span> that determines <span class="math">S</span> from <span class="math">S^{<em>}</span>. This is useful because: (a) the vanishing polynomial of a coset <span class="math">S</span> is closely related to the vanishing polynomial of its base coset <span class="math">S^{</em>}</span>; and (b) each Lagrange polynomial can be expressed via the vanishing polynomial <span class="math">v_{S}(X)</span> and its derivative <span class="math">v^{\\prime}_{S}(X)</span>. Specifically, for every <span class="math">a\\in S</span>, <span class="math">L_{a,S}(X)=\\frac{1}{v^{\\prime}_{S}(a)}\\cdot\\frac{v_{S}(X)}{X-a}</span>. This enables us to hardcode in the constraint system information about the base coset <span class="math">S^{*}</span>, and task the constraint system with a cheap computation that depends on the shift <span class="math">\\xi</span>.</p>

    <p class="text-gray-300">We describe this approach for the additive and multiplicative cases separately.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Additive case. The derivative <span class="math">v^{\\prime}_{S}(X)</span> is a constant <span class="math">c_{S^{<em>}}\\in\\mathbb{F}</span> that only depends on the base coset <span class="math">S^{</em>}</span>. Hence all the values <span class="math">\\{v^{\\prime}_{S}(a)\\}_{a\\in S}</span> (and their inverses) are known at compile time, as they all equal <span class="math">c_{S^{<em>}}</span>. The polynomial <span class="math">v_{S}(X)</span> equals <span class="math">v_{S^{</em>}}(X-\\xi)</span>, which has $O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> non-zero monomials. Hence, if we hardcode the polynomial </span>v_{S^{<em>}}<span class="math"> in the constraint system, we can compute </span>v_{S}(\\gamma)=v_{S^{</em>}}(\\gamma-\\xi)\\in\\mathbb{F}<span class="math">, and also </span>v_{S}(\\gamma)/c_{S^{<em>}}=v_{S^{</em>}}(\\gamma-\\xi)/c_{S^{*}}\\in\\mathbb{F}<span class="math"> (common to all Lagrange coefficients) with </span>O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$ constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, note that each element <span class="math">a\\in S</span> can be written as <span class="math">a=a^{<em>}+\\xi</span> for a corresponding element <span class="math">a^{</em>}\\in S^{<em>}</span>. This means that <span class="math">\\{X-a\\}_{a\\in S}=\\{X-a^{</em>}-\\xi\\}_{a^{<em>}\\in S^{</em>}}</span>, where the elements <span class="math">a^{<em>}</span> are hardcoded in the constraint system and <span class="math">\\xi</span> is an input to the constraint system. In particular, given <span class="math">v_{S^{</em>}}(\\gamma-\\xi)/c_{S^{<em>}}\\in\\mathbb{F}</span> we can compute <span class="math">\\{L_{a,S}(\\gamma)\\}_{a\\in S}=\\{\\frac{v_{S^{</em>}}(\\gamma-\\xi)}{c_{S^{<em>}}}\\cdot\\frac{1}{\\gamma-a^{</em>}-\\xi}\\}_{a^{<em>}\\in S^{</em>}}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ additional constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Multiplicative case. The polynomial <span class="math">v_{S}(X)</span> is the polynomial $X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and its derivative </span>v_{S}'(X)<span class="math"> is the polynomial </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math">; recall that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and so this quantity is known at compile time. Moreover, each element </span>a \\in S<span class="math"> can be written as </span>a = \\xi a^{<em>}<span class="math"> for a corresponding element </span>a^{</em>} \\in S^{*}$. Therefore we can re-write each Lagrange polynomial as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l} L_{a,S}(X) = \\frac{1}{v_{S}'(a)} \\cdot \\frac{v_{S}(X)}{X - a} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\xi a^{*})^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}} \\cdot \\frac{X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{X - \\xi a^{*}} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">\\xi^{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}} \\cdot \\frac{X^{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">} - \\xi^{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}}{X(\\xi a^{*})^{-1} - 1}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above expression leads to the following strategy. The constraint system first uses the shift <span class="math">\\xi</span> and evaluation point <span class="math">\\gamma</span> to compute, via $O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> constraints, the value </span>\\frac{\\gamma^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math">; and also one constraint to compute </span>\\gamma \\xi^{-1}<span class="math">. Then, the constraint system computes the values </span>\\{L_{a,S}(\\gamma)\\}_{a\\in S} = \\{\\frac{\\gamma^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\cdot \\frac{1}{\\gamma(\\xi a^{<em>})^{-1} - 1}\\}_{a^{</em>} \\in S^{*}}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ additional constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">64</p>

    <p class="text-gray-300">In Section 13.1 we evaluate our implementation of the preprocessing zkSNARK, and in Section 13.2 we evaluate our implementation of recursive composition.</p>

    <p class="text-gray-300">All reported measurements were run in single-threaded mode on a machine with an Intel Xeon 6136 CPU at <span class="math">3.0\\,\\mathrm{GHz}</span> with <span class="math">252\\,\\mathrm{GB}</span> of RAM (no more than <span class="math">32\\,\\mathrm{GB}</span> of RAM were used in any experiment).</p>

    <h2 id="sec-110" class="text-2xl font-bold">13.1 Performance of the preprocessing zkSNARK</h2>

    <p class="text-gray-300">We report on the performance of FRACTAL, the preprocessing zkSNARK for R1CS that we have implemented by extending libiop as described in Section 12.1. We configure our implementation to achieve 128 bits of security, for constraints expressed over a prime field of 181 bits. This field choice is illustrative, as the only requirement on the field is that it should contain suitable subgroups for us to use.</p>

    <p class="text-gray-300">In Fig. 7 we report the costs for several efficiency measures, and for each measure also indicate how much of the cost is due to the probabilistic proof and how much is due to the cryptographic compiler. The costs depend on the number of constraints <span class="math">n</span> in the R1CS instance, <span class="math">^{14}</span> and so we report how the costs change as we vary <span class="math">n</span> over the range <span class="math">\\{2^{10}, 2^{11}, \\ldots, 2^{20}\\}</span>. Below, by native execution time we mean the time that it takes to check that an assignment satisfies the constraint system, and by native witness size we mean the number of bytes required to represent an assignment to the constraint system.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Indexer time. In the upper left, we plot the running time of the indexer, as absolute cost (top graph) and as relative cost when compared to native execution time (bottom graph). Indexer times range from fractions of a second to several minutes, and the plot confirms the quasilinear complexity of the indexer. Indexer time is dominated by the cost of running the underlying HIOP indexer.</li>

      <li>Prover time. In the upper right, we plot the running time of the prover, as absolute cost (top graph) and as relative cost when compared to native execution time (bottom graph). Prover times range from fractions of a second to several minutes, and the plot confirms the quasilinear complexity of the prover. Prover time is dominated by the cost of running the underlying HIOP prover.</li>

      <li>Argument size. In the lower left, we plot argument size, as absolute cost (top graph) and as relative cost when compared to native witness size (bottom graph). Argument sizes range from <span class="math">80\\,\\mathrm{kB}</span> to <span class="math">160\\,\\mathrm{kB}</span> with compression (argument size is smaller than native witness size) occurring for <span class="math">n \\geq 4,000</span>, and the plot confirms the polylogarithmic complexity of the argument. Argument size is dominated by the cryptographic digests to authenticate query answers.</li>

      <li>Verifier time. In the lower right, we plot the running time of the verifier, as absolute cost (top graph) and as relative cost when compared to native execution time (bottom graph). Verifier times are several milliseconds and become faster than native execution for <span class="math">n \\geq 65,000</span>, and the plot confirms the polylogarithmic complexity of the verifier. Verifier time is dominated by the cost of running the underlying HIOP verifier.</li>

    </ul>

    <p class="text-gray-300"><span class="math">^{14}</span>More precisely, the costs in general depend on (a) <span class="math">n</span>, the number of constraints (i.e., number of rows in each matrix); (b) <span class="math">n&#x27;</span>, the number of variables (i.e., number of columns in each matrix); (c) <span class="math">m</span>, the number of non-zero entries in a matrix; and (d) <span class="math">k</span>, the number of public inputs. The number of constraints <span class="math">n</span> and the number of variables <span class="math">n&#x27;</span> are typically approximately equal, and indeed in this paper we have assumed for simplicity that <span class="math">n = n&#x27;</span> (the matrices in Definition 3.2 are square); so we only keep track of <span class="math">n</span>. The number of non-zero entries <span class="math">m</span> is typically within a small factor of <span class="math">n</span>, and in our experiments <span class="math">m/n</span> is approximately 1. Finally, the number of public inputs <span class="math">k</span> is at most <span class="math">n&#x27;</span>, and in typical applications it is much smaller than <span class="math">n&#x27;</span>, so we do not focus on it.</p>

    <p class="text-gray-300">65</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Indexer Time</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Prover Time</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Argument Size</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Verifier Time</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 7: Performance of FRACTAL.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a></p>

    <p class="text-gray-300">Finally, in Fig. 8, we compare FRACTAL with the state of the art in several types of zkSNARKs for R1CS:</p>

    <p class="text-gray-300">(1) Aurora, a non-preprocessing zkSNARK in the (quantum) random oracle model [BCRSVW19]; (2) Groth16, a preprocessing zkSNARK with circuit-specific SRS [Gro16]; (3) Marlin, a preprocessing zkSNARK with universal SRS [CHMMVW20].</p>

    <p class="text-gray-300">The first protocol is configured the same as our protocol (128 bits of security over a prime field of 181 bits), and the implementation that we use is from libiop [SCI19]. The second and third protocols require a choice of pairing-friendly elliptic curve, which we take to be b1s12-381; the implementation of the second protocol is from libzexe [zexe19] and the implementation of the third protocol is from marlin [mar19].</p>

    <p class="text-gray-300">While informative, the comparison should be considered qualitative, because the protocols expose R1CS defined over different prime fields, which means that the same statement may require a different number of constraints when expressed over one field versus another.</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> Indexer Time</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a> Prover Time</p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a> Argument Size</p>

    <p class="text-gray-300">!<a href="img-16.jpeg">img-16.jpeg</a> Verifier Time Figure 8: Comparison across several zkSNARKs for R1CS. The argument size for [Gro16] is 192 B and for [CHMMVW20, Marlin] is 880 B; they are not plotted in the argument size graph because they are much smaller than the argument sizes for the other protocols (which differ in that they are post-quantum and transparent). Note that the setup algorithm for [Gro16] is plotted in the indexer graph because it also serves as an indexer.</p>

    <p class="text-gray-300">We report on the performance of recursive composition based on FRACTAL. Recall from Section 11 that the quantity governing the efficiency of recursion is the complexity of the verifier when expressed as an R1CS</p>

    <p class="text-gray-300">constraint system. For R1CS, the we measure complexity by the number of constraints and the total nonzero coefficients (which are sometimes in contention); we refer to these quantities together as the verifier size.</p>

    <p class="text-gray-300">If we were to directly translate the “native” verifier that we evaluate in the previous section into a constraint system, it would be much too large to prove. The primary culprit for this is the choice of hash function. In the previous section we chose a hash function with fast native execution; unfortunately, it is large when represented as an R1CS constraint system. For recursive composition, we will choose a hash function that has a much smaller R1CS representation. Since this hash function is much slower to execute natively, this results in an increase in the proving time per constraint; however, this increase is modest compared to the significant saving arising from the smaller constraint system.</p>

    <p class="text-gray-300">In the remainder of this section we discuss our choice of hash function and how we set its parameters; we then discuss an optimization that significantly improves the native execution time of the hash function without increasing the constraint system size.</p>

    <h4 id="sec-112" class="text-lg font-semibold mt-6">Choice of hash function.</h4>

    <p class="text-gray-300">We instantiate the various hash functions required in Section 12.2.1 via different parameterizations of Poseidon <em>[GKRRS19]</em>. This is a sponge hash function <em>[BDPV08]</em>, which means that it maintains a state that is split into two parts: the rate part of the state, which is used to absorb inputs and squeeze outputs; and the capacity part of the state, the size of which determines the security of the sponge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will set the Poseidon parameters for each hash function in order to jointly minimize the number of constraints and the number of nonzero coefficients. We assume our field is such that $\\lfloor\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\rfloor\\geq 2\\lambda<span class="math">, which allows us to set the capacity to be one field element, and the hash output size as one field element. It remains to choose the rate, and the Poseidon parameter </span>\\alpha$, which controls the degree of the S-Box permutations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We set <span class="math">\\alpha=17</span> for all of our hash functions. This is higher than typical instantiations of Poseidon. This choice reduces the number of rounds of the hash function, which greatly reduces the number of non-zero R1CS coefficients in exchange for a modest increase in the number of R1CS constraints. We find empirically that the number of non-zero R1CS coefficients per element of rate is minimized for <span class="math">\\alpha=17</span> when the rate is <span class="math">10</span>. Correspondingly, we set the rate of each hash function to be the minimum of <span class="math">10</span> and the number of elements that must be absorbed/squeezed in a single execution of the hash function.</p>

    <h4 id="sec-113" class="text-lg font-semibold mt-6">Prover execution time.</h4>

    <p class="text-gray-300">The recursive prover’s running time is affected by the native execution time of the hash function. The direct implementation of Poseidon as our hash function is too slow, causing a 100<span class="math">\\times</span> slowdown to the recursive prover. This is due to every round requiring the multiplication of a vector by a random MDS matrix. To address this, we instead rely on MDS matrices with “light-weight circuits” <em>[DR02, DG18]</em>, i.e., MDS matrices with small entries (when viewed as integer matrices), for which matrix-vector products can be computed without field multiplications. This leads to a <span class="math">10\\times</span> performance improvement in hash execution time, which reduces the slowdown versus the “standalone” prover to <span class="math">10\\times</span>.</p>

    <h4 id="sec-114" class="text-lg font-semibold mt-6">Verifier size.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall from Definition 11.4 that <span class="math">\\mathcal{V}^{(\\lambda,N,k)}</span> denotes an R1CS instance expressing the computation of the SNARK verifier <span class="math">\\mathcal{V}</span>, for security parameter <span class="math">\\lambda</span>, when checking R1CS instances with at most <span class="math">N</span> constraints and an explicit input of size at most <span class="math">k</span>. Our goal is to minimize the size of <span class="math">\\mathcal{V}^{(\\lambda,N,k)}</span>. For our evaluation we fix the security parameter <span class="math">\\lambda:=128</span> and the instance size <span class="math">k:=100</span>, and measure how $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}^{(\\lambda,N,k)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> varies with </span>N$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given our choice of hash function parameters, the number of non-zero R1CS coefficients is always within a factor of two of the number of R1CS constraints. Hence for simplicity, below we report only the number of R1CS constraints. This suffices for finding the “recursion threshold”, the smallest value <span class="math">N^{<em>}</span> for which <span class="math">\\mathcal{V}^{(\\lambda,N^{</em>},k)}</span> has fewer than <span class="math">N^{<em>}</span> constraints (and hence the smallest <span class="math">N^{</em>}</span> that admits recursion).</p>

    <p class="text-gray-300">In Section 12.2 we described our design of a generic verifier circuit, which left several parameters unspecified (e.g., the number of commitments sent by the prover in a particular round, the number of field elements sent by the verifier in a particular round, the specific rational constraints, and so on). In our implementation we specialize this design to the verifier for Fractal to obtain a constraint system that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">expresses its correct execution. In Fig. 9 we plot the measured size of  <span class="math">\\mathcal{V}^{(\\lambda, N, k)}</span>  against the number of constraints  <span class="math">N</span>  it is checking. The graph shows that the recursion threshold is at most 2 million: for all  <span class="math">N</span>  greater than 2 million,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}^{(\\lambda, N, k)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N$ . Since we are able to prove constraint systems of this size, this demonstrates feasibility of recursion in our implementation. We are optimistic that further optimizations will further reduce the size of the verifier, and hence also the recursion threshold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-17.jpeg">img-17.jpeg</a> Figure 9: On the left we plot, in a linear-log scale, the number of constraints to express the FRACTAL verifier as a function of the number of constraints it is checking  <span class="math">(N)</span> , using areas of different colors to denote contributions from different constraint types. In the same graph we also plot the number of checked constraints (the function  <span class="math">N \\mapsto N</span> ), which shows how the number of constraints for the verifier (which is  <span class="math">\\mathrm{polylog}_{\\lambda,k}(N)</span> ) grows much slower than  <span class="math">N</span> , giving a cross-over point. On the right, we provide several data points for different values of  <span class="math">N</span> .</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">This research was supported in part by: the Berkeley Haas Blockchain Initiative, a Google Faculty Award, and donations from the Ethereum Foundation and the Interchain Foundation.</p>

    <p class="text-gray-300">This research was supported in part by: the Berkeley Haas Blockchain Initiative, a Google Faculty Award, and donations from the Ethereum Foundation and the Interchain Foundation.</p>

    <h2 id="sec-115" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AABSDS19] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. IACR Cryptology ePrint Archive, Report 2019/426. 2019.</li>

      <li>[ABLSZ19] Behzad Abdolmaleki, Karim Baghery, Helger Lipmaa, Janno Siim, and Michal Zajac. “UC-Secure CRS Generation for SNARKs”. In: Proceedings of the 11th International Conference on Cryptology in Africa. AFRICACRYPT ’19. 2019, pp. 99–117.</li>

      <li>[ACGKLRS19] Martin R Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, and Markus Schofnegger. Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC. IACR Cryptology ePrint Archive, Report 2019/419. 2019.</li>

      <li>[AD18] Tomer Ashur and Siemen Dhooghe. MARVELlous: a STARK-Friendly Family of Cryptographic Primitives. IACR Cryptology ePrint Archive, Report 2018/1098. 2018.</li>

      <li>[AGPRRRRS19] Martin R Albrecht, Lorenzo Grassi, Léo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, and Markus Schofnegger. Feistel Structures for MPC, and More. IACR Cryptology ePrint Archive, Report 2019/397. 2019.</li>

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2087–2104.</li>

      <li>[AHU19] Andris Ambainis, Mike Hamburg, and Dominique Unruh. “Quantum Security Proofs Using Semi-classical Oracles”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 269–295.</li>

      <li>[AS04] Scott Aaronson and Yaoyun Shi. “Quantum lower bounds for the collision and the element distinctness problems”. In: Journal of the ACM 51.4 (2004), pp. 595–605.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Fast Reed–Solomon Interactive Oracle Proofs of Proximity”. In: Proceedings of the 45th International Colloquium on Automata, Languages and Programming. ICALP ’18. 2018, 14:1–14:17.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Scalable Zero Knowledge with No Trusted Setup”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. “Recursive Composition and Bootstrapping for SNARKs and Proof-Carrying Data”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 111–120.</li>

      <li>[BCGGHJ17] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. “Linear-Time Zero-Knowledge Proofs for Arithmetic Circuit Satisfiability”. In: Proceedings of the 23rd International Conference on the Theory and Applications of Cryptology and Information Security. ASIACRYPT ’17. 2017, pp. 336–365.</li>

      <li>[BCGGRS19] Eli Ben-Sasson, Alessandro Chiesa, Lior Goldberg, Tom Gur, Michael Riabzev, and Nicholas Spooner. “Linear-Size Constant-Query IOPs for Delegating Computation”. In: Proceedings of the 17th Theory of Cryptography Conference. TCC ’19. 2019.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BCGTV15] Eli Ben-Sasson, Alessandro Chiesa, Matthew Green, Eran Tromer, and Madars Virza. “Secure Sampling of Public Parameters for Succinct Zero Knowledge Proofs”. In: Proceedings of the 36th IEEE Symposium on Security and Privacy. S&amp;P ’15. 2015, pp. 287–304.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCIOP13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. “Succinct Non-Interactive Arguments via Linear Interactive Proofs”. In: Proceedings of the 10th Theory of Cryptography Conference. TCC ’13. 2013, pp. 315–333.</li>

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. Proof-Carrying Data from Accumulation Schemes. Cryptology ePrint Archive, Report 2020/499. 2020.</li>

      <li>[BCRSVW19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’19. Full version available at https://eprint.iacr.org/2018/828. 2019, pp. 103–128.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: Proceedings of the 34th Annual International Cryptology Conference. CRYPTO ’14. Extended version at http://eprint.iacr.org/2014/595. 2014, pp. 276–294.</li>

      <li>[BDFLSZ11] Dan Boneh, Özgür Dagdelen, Marc Fischlin, Anja Lehmann, Christian Schaffner, and Mark Zhandry. “Random Oracles in a Quantum World”. In: Proceedings of the 17th International Conference on the Theory and Application of Cryptologic and Information Security. ASIACRYPT ’11. 2011, pp. 41–69.</li>

      <li>[BDPV08] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. “On the Indifferentiability of the Sponge Construction”. In: Proceedings of the 27th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’08. 2008, pp. 181–197.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. “Checking computations in polylogarithmic time”. In: Proceedings of the 23rd Annual ACM Symposium on Theory of Computing. STOC ’91. 1991, pp. 21–32.</li>

      <li>[BGG17] Sean Bowe, Ariel Gabizon, and Matthew Green. A multi-party protocol for constructing the public parameters of the Pinocchio zk-SNARK. Cryptology ePrint Archive, Report 2017/602. 2017.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. 2019.</li>

      <li>[BGHSV06] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. “Robust PCPs of Proximity, Shorter PCPs, and Applications to Coding”. In: SIAM Journal on Computing 36.4 (2006), pp. 889–974.</li>

      <li>[BGKS19] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling Outside the Box Improves Soundness. ECCC TR19-044. 2019.</li>

      <li>[BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model. Cryptology ePrint Archive, Report 2017/1050. 2017.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. “Random Oracles are Practical: A Paradigm for Designing Efficient Protocols”. In: Proceedings of the 1st ACM Conference on Computer and Communications Security. CCS ’93. 1993, pp. 62–73.</li>

      <li>[CCHLRR18] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, and Ron D. Rothblum. Fiat–Shamir From Simpler Assumptions. Cryptology ePrint Archive, Report 2018/1004. 2018.</li>

    </ul>

    <p class="text-gray-300">[CCRR92] Richard Chang, Suresh Chari, Desh Ranjan, and Pankaj Rohatgi. “Relativization: a revisionistic retrospective”. In: <em>Bulletin of the European Association for Theoretical Computer Science</em> 47 (1992), pp. 144–153.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CCW19] Alessandro Chiesa, Lynn Chua, and Matthew Weidner. “On Cycles of Pairing-Friendly Elliptic Curves”. In: <em>SIAM Journal on Applied Algebra and Geometry</em> 3.2 (2019). https://arxiv.org/abs/1803.02067, pp. 175–192.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi. “The random oracle methodology, revisited”. In: <em>Journal of the ACM</em> 51.4 (2004), pp. 557–594.</li>

      <li>[CHMMVW20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: <em>Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’20. 2020, pp. 738–768.</li>

      <li>[CL20] Alessandro Chiesa and Siqi Liu. “On the Impossibility of Probabilistic Proofs in Relativized Worlds”. In: <em>Proceedings of the 11th Innovations in Theoretical Computer Science Conference</em>. ITCS ’20. 2020, 57:1–57:30.</li>

      <li>[CMS19] Alessandro Chiesa, Peter Manohar, and Nicholas Spooner. “Succinct Arguments in the Quantum Random Oracle Model”. In: <em>Proceedings of the 17th Theory of Cryptography Conference</em>. TCC ’19. Available as Cryptology ePrint Archive, Report 2019/834. 2019, pp. 1–29.</li>

      <li>[CT10] Alessandro Chiesa and Eran Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: <em>Proceedings of the 1st Symposium on Innovations in Computer Science</em>. ICS ’10. 2010, pp. 310–331.</li>

      <li>[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. “Cluster Computing in Zero Knowledge”. In: <em>Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’15. 2015, pp. 371–403.</li>

      <li>[Co17] O(1) Labs. <em>Coda Cryptocurrency</em>. https://codaprotocol.com/. 2017.</li>

      <li>[DG18] Sébastien Duval and Leurent Gaëtan. <em>MDS Matrices with Lightweight Circuits</em>. Cryptology ePrint Archive, Report 2018/260. 2018.</li>

      <li>[DR02] Joan Daemen and Vincent Rijmen. <em>The Design of Rijndael: AES - The Advanced Encryption Standard</em>. Information Security and Cryptography. 2002.</li>

      <li>[DR04] Irit Dinur and Omer Reingold. “Assignment Testers: Towards a Combinatorial Proof of the PCP Theorem”. In: <em>Proceedings of the 45th Annual IEEE Symposium on Foundations of Computer Science</em>. FOCS ’04. 2004, pp. 155–164.</li>

      <li>[EKR04] Funda Ergün, Ravi Kumar, and Ronitt Rubinfeld. “Fast approximate probabilistically checkable proofs”. In: <em>Information and Computation</em> 189.2 (2004), pp. 135–159.</li>

      <li>[FST10] David Freeman, Michael Scott, and Edlyn Teske. “A Taxonomy of Pairing-Friendly Elliptic Curves”. In: <em>Journal of Cryptology</em> 23.2 (2010), pp. 224–280.</li>

      <li>[For94] Lance Fortnow. “The Role of Relativization in Complexity Theory”. In: <em>Bulletin of the European Association for Theoretical Computer Science</em> 52 (1994), pp. 229–244.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’13. 2013, pp. 626–645.</li>

      <li>[GK03] Shafi Goldwasser and Yael Tauman Kalai. “On the (In)security of the Fiat-Shamir Paradigm”. In: <em>Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science</em>. FOCS ’03. 2003, pp. 102–113.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GKMMM18] Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. “Updatable and Universal Common Reference Strings with Applications to zk-SNARKs”. In: Proceedings of the 38th Annual International Cryptology Conference. CRYPTO ’18. 2018, pp. 698–728.</li>

      <li>[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating Computation: Interactive Proofs for Muggles”. In: Journal of the ACM 62.4 (2015), 27:1–27:64.</li>

      <li>[GKRRS19] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. IACR Cryptology ePrint Archive, Report 2019/458. 2019.</li>

      <li>[GR15] Tom Gur and Ron D. Rothblum. “Non-Interactive Proofs of Proximity”. In: Proceedings of the 6th Innovations in Theoretical Computer Science Conference. ITCS ’15. 2015, pp. 133–142.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive, Report 2019/953. 2019.</li>

      <li>[Gro10] Jens Groth. “Short Pairing-Based Non-interactive Zero-Knowledge Arguments”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’10. 2010, pp. 321–340.</li>

      <li>[Gro16] Jens Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. “Algebraic Methods for Interactive Proof Systems”. In: Journal of the ACM 39.4 (1992), pp. 859–868.</li>

      <li>[Lin03] Yehuda Lindell. “Parallel Coin-Tossing and Constant-Round Secure Two-Party Computation”. In: Journal of Cryptology 16.3 (2003), pp. 143–184.</li>

      <li>[Lip12] Helger Lipmaa. “Progression-Free Sets and Sublinear Pairing-Based Non-Interactive Zero-Knowledge Arguments”. In: Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography. TCC ’12. 2012, pp. 169–189.</li>

      <li>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. “Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updateable Structured Reference Strings”. In: Proceedings of the 26th ACM Conference on Computer and Communications Security. CCS ’19. 2019, pp. 2111–2128.</li>

      <li>[Mic00] Silvio Micali. “Computationally Sound Proofs”. In: SIAM Journal on Computing 30.4 (2000). Preliminary version appeared in FOCS ’94., pp. 1253–1298.</li>

      <li>[Pas03] Rafael Pass. “On Deniability in the Common Reference String and Random Oracle Model”. In: Proceedings of the 23rd Annual International Cryptology Conference. CRYPTO ’03. 2003, pp. 316–337.</li>

      <li>[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC ’16. 2016, pp. 49–62.</li>

      <li>[RU19] Barry Whitehat. Rollup. https://github.com/barryWhiteHat/roll_up. 2018.</li>

      <li>[RVW13] Guy N. Rothblum, Salil P. Vadhan, and Avi Wigderson. “Interactive proofs of proximity: delegating computation in sublinear time”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 793–802.</li>

      <li>[SCI19] SCIPR Lab. libiop: C++ library for IOP-based zkSNARKs. 2019. URL: https://github.com/scipr-lab/libiop.</li>

      <li>[SD19] StarkWare &amp; 0x. StarkDEX. https://www.starkdex.io/. 2019.</li>

    </ul>

    <p class="text-gray-300">[SN] Coda. The SNARK Challenge. https://coinlist.co/build/coda. 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Set19] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. Cryptology ePrint Archive, Report 2019/550. 2019.</li>

      <li>[Tha13] Justin Thaler. “Time-Optimal Interactive Proofs for Circuit Evaluation”. In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO ’13. 2013, pp. 71–89.</li>

      <li>[Val08] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: Proceedings of the 5th Theory of Cryptography Conference. TCC ’08. 2008, pp. 1–18.</li>

      <li>[XZZPS19] Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. “Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[Zc14] Electric Coin Company. Zcash Cryptocurrency. https://z.cash/. 2014.</li>

      <li>[Zha19] Mark Zhandry. “How to Record Quantum Queries, and Applications to Quantum Indifferentiability”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 239–268.</li>

      <li>[mar19] SCIPR Lab. A Rust library for the Marlin preprocessing zkSNARK. 2019. URL: https://github.com/scipr-lab/marlin.</li>

      <li>[zexe19] SCIPR Lab. A Rust library for decentralized private computation. 2019. URL: https://github.com/scipr-lab/libzexe.</li>

    </ul>`;
---

<BaseLayout title="Fractal: Post-Quantum and Transparent Recursive Proofs from ... (2019/1076)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1076
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
