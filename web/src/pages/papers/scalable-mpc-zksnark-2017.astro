---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1050';
---

<BaseLayout title="Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model (2017/1050)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Scalable Multi-party Computation for zk-SNARK Parameters
        in the Random Beacon Model
      </h1>
      <p class="text-gray-400 mb-2">
        Sean Bowe, Ariel Gabizon, Ian Miers
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; Full Version &middot; eprint 2017/1050
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">Our Results</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">Outline</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Overview of Our Approach</a>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">Notation</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">Random Beacons</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">Input Domains</a>
            </li>
            <li>
              <a href="#sec-3.4"
                class="hover:text-white">
                Player-exchangeable Protocols and Adaptive
                Adversaries</a>
            </li>
            <li>
              <a href="#sec-3.5"
                class="hover:text-white">Preliminary Claims</a>
            </li>
            <li>
              <a href="#sec-3.6"
                class="hover:text-white">Auxiliary Methods</a>
            </li>
            <li>
              <a href="#sec-3.7"
                class="hover:text-white">Proofs of Knowledge</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Multi-party Computation for Parameter
            Generation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">The Circuit Structure</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">The Protocol Coordinator</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">The MPC</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">The Phase Structure</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Security Proof</a>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">
            Reducing the Depth of Groth&rsquo;s CRS</a>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">
            Multi-party Computation for Groth&rsquo;s
            zk-SNARK</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-7.1"
                class="hover:text-white">
                Round 1: Powers of Tau</a>
            </li>
            <li>
              <a href="#sec-7.2"
                class="hover:text-white">
                Linear Combinations Between Phases</a>
            </li>
            <li>
              <a href="#sec-7.3"
                class="hover:text-white">Round Two</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-8"
            class="hover:text-white">BLS12-381</a>
        </li>
        <li>
          <a href="#sec-9"
            class="hover:text-white">
            Implementation and Experiments</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        We present MMORPG, a built system for zero-knowledge succinct
        non-interactive arguments of knowledge (zk-SNARK) parameter
        generation. zk-SNARKs are compact, efficient, and publicly
        verifiable zero-knowledge proofs for arbitrary computation.
        They have emerged as a valuable tool for verifiable
        computation, privacy preserving protocols, and blockchains.
        Currently practical schemes require a common reference string
        (CRS) to be constructed in a one-time setup for each
        statement. Corruption of this process leads to forged proofs
        and for applications such as cryptocurrencies, potentially
        billions of dollars in theft. Ben-Sasson, Chiesa, Green,
        Tromer and Virza <a href="#ref-Ben-Sasson+15" class="text-blue-400 hover:text-blue-300">[Ben-Sasson+15]</a> devised a multi-party protocol to
        securely compute such a CRS, and an adaptation of this
        protocol was used to construct the CRS for the Zcash
        cryptocurrency <a href="#ref-BowGabGre17" class="text-blue-400 hover:text-blue-300">[BowGabGre17]</a>. The trustworthiness of these protocols
        is obstructed by the need for a precommitment phase which
        forces the selection of a very small number of participants
        in advance and requires them to secure their secret
        randomness throughout the duration of the protocol. Our
        primary contribution is a more scalable multi-party
        computation (MPC) protocol, secure in the random beacon
        model, which omits the precommitment phase. We show that
        security holds even if an adversary has limited influence on
        the beacon. Next, we apply our main result to obtain a
        two-phase protocol for computing an extended version of the
        CRS of Groth&rsquo;s zk-SNARK <a href="#ref-Groth16" class="text-blue-400 hover:text-blue-300">[Groth16]</a>. We show that knowledge
        soundness is maintained in the generic group model when
        using this CRS. Finally, we implement and evaluate our
        system.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>

      <p class="text-gray-300">
        Zero-knowledge succinct non-interactive arguments of
        knowledge (zk-SNARKs) <a href="#ref-Ben-Sasson+13a" class="text-blue-400 hover:text-blue-300">[Ben-Sasson+13a]</a>, <a href="#ref-Bitansky+13" class="text-blue-400 hover:text-blue-300">[Bitansky+13]</a>, <a href="#ref-Gen+13b" class="text-blue-400 hover:text-blue-300">[Gen+13b]</a>, <a href="#ref-Groth16" class="text-blue-400 hover:text-blue-300">[Groth16]</a>, <a href="#ref-Groth10" class="text-blue-400 hover:text-blue-300">[Groth10]</a>, <a href="#ref-Kilian92" class="text-blue-400 hover:text-blue-300">[Kilian92]</a>, <a href="#ref-Lipmaa12" class="text-blue-400 hover:text-blue-300">[Lipmaa12]</a>, <a href="#ref-Lipmaa13" class="text-blue-400 hover:text-blue-300">[Lipmaa13]</a>,
        <a href="#ref-Micali00" class="text-blue-400 hover:text-blue-300">[Micali00]</a>, <a href="#ref-Parno+13" class="text-blue-400 hover:text-blue-300">[Parno+13]</a> have seen increased usage both in the literature and
        the real world, ranging from publicly verifiable computation,
        to deployed usage for anonymous payment systems such as
        Zerocash <a href="#ref-Ben-Sasson+14" class="text-blue-400 hover:text-blue-300">[Ben-Sasson+14]</a> and Zcash <a href="#ref-Zcash17" class="text-blue-400 hover:text-blue-300">[Zcash17]</a> and smart contract systems such
        as Ethereum.
      </p>

      <p class="text-gray-300">
        Despite the power of zk-SNARKs, challenges stand in the way
        of their widespread use. Most significantly, these schemes
        are secure in the common reference string (CRS) model, which
        assumes a trusted setup of parameters used for constructing
        and verifying proofs. The generation of this CRS is a major
        challenge, given that corruption or subversion of the
        parameters means the proof systems are no longer sound, i.e.
        proofs can be forged. The existence of trusted setup parties
        is often assumed in academic work; in practice these parties
        are hard to find, even harder to get a large and diverse
        group to agree on, and potentially untrustworthy in the face
        of the tangible monetary gains that arise in real world
        deployment.
      </p>

      <p class="text-gray-300">
        The current approach for deployed systems is for the CRS to
        be generated via a multi-party computation protocol <a href="#ref-Ben-Sasson+15" class="text-blue-400 hover:text-blue-300">[Ben-Sasson+15]</a>, <a href="#ref-BowGabGre17" class="text-blue-400 hover:text-blue-300">[BowGabGre17]</a>
        built from scratch for the task of computing a CRS. These
        protocols guarantee soundness &mdash; i.e. that proofs
        cannot be forged &mdash; when at least one participant is
        honest, and guarantee zero-knowledge even if none of the
        participants are honest. However, these protocols
        fundamentally cannot scale beyond a handful of participants,
        and can even be too expensive to perform for just one or two
        participants in some settings. This is not an engineering and
        optimization issue. Fundamentally, it is a cryptographic
        issue: because of restrictions required to deal with adaptive
        attackers, participants in the current MPC schemes must
        commit to their share of the parameters up front and maintain
        availability and security throughout the entire duration of
        the protocol &mdash; even after the majority of their
        individual computation is completed.
      </p>

      <p class="text-gray-300">
        <em>[The paper continues with detailed discussion of the
        need for crowd-scale parameter generation for high-value
        applications, highlighting that systems like Zcash (nearly
        $1 billion) and Ethereum ($40 billion market cap) use
        zk-SNARKs and would benefit from more robust CRS generation.
        The authors also discuss random beacons as a source of public
        randomness, distinguishing them from random oracles by
        noting that beacon values are not available until certain
        time slots.]</em>
      </p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Our Results
      </h3>
      <p class="text-gray-300">
        In this paper, we design, implement, and evaluate a scalable
        open participation multiparty computation protocol for
        generating zk-SNARK parameters. We aim to make zk-SNARKs
        suitable for wide-scale usage by providing a new zk-SNARK
        scheme and MPC system for CRS generation suitable for real
        world usage. We offer three contributions:
      </p>

      <p class="text-gray-300">
        <strong>Player-exchangeable MPC.</strong> Our primary
        contribution is a new kind of multi-party computation
        protocol, a player-exchangeable MPC (px-MPC) and an
        efficient and implemented px-MPC protocol for CRS
        generation. A px-MPC is described by a sequence of messages
        players are supposed to send; however, importantly, there is
        no restriction on the identity of the sender of each
        message. In particular, although we will discuss multi-phase
        protocols where in each phase all players participate in a
        round-robin process, there is no need to assume the same
        players participate in different phases. Since there is no
        private state between messages, players may be swapped out
        or removed after every message.
      </p>

      <p class="text-gray-300">
        <strong>zk-SNARKs with an efficient and amortized px-MPC CRS
        generation process.</strong> We prove the security of
        Groth&rsquo;s zk-SNARK with an extended CRS which allows for
        a two phase px-MPC protocol. The first phase is agnostic to
        the statement (up to statement size), and so can be performed
        once for all statements up to some large (but bounded) size.
        The second phase is statement-specific, but significantly
        cheaper.
      </p>

      <p class="text-gray-300">
        <strong>MMORPG, a built system.</strong> As a final
        contribution, we offer MMORPG, a built system for massively
        multiparty open reusable parameter generation for our
        modified version of Groth&rsquo;s zk-SNARK. For a circuit
        size up to <span class="math">2^&#123;21&#125;</span>
        multiplication gates, participants in the first round must
        receive a 1.2GB file, perform a computation that lasts about
        13 minutes on a desktop machine, and produce a 600MB file.
        We also adopt a new pairing-friendly elliptic curve called
        BLS12-381 which targets 128-bit security.
      </p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Outline
      </h3>
      <p class="text-gray-300">
        This paper is structured as follows. In section 2 we give an
        overview of our approach. In section 3 we give cryptographic
        preliminaries, notation, and supporting lemmas. In section 4
        we detail our MPC protocol. In section 5 we detail a proof
        of security. In section 6 we instantiate our protocol using
        Groth&rsquo;s zk-SNARK. Finally, in section 9 we evaluate
        our implementation.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. OVERVIEW OF OUR APPROACH                                  -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">
        2. Overview of Our Approach
      </h2>

      <p class="text-gray-300">
        Our goal is to build a practical protocol between
        <span class="math">n</span> players and an untrusted
        coordinator that: gives a zk-SNARK CRS where proofs cannot
        be forged if at least one of the
        <span class="math">n</span> players is honest; places no
        limits on <span class="math">n</span>, the number of
        participants; does not require players to be selected in
        advance; and does not require players to pre-commit to their
        random coins and therefore keep them secure throughout the
        protocol.
      </p>

      <p class="text-gray-300">
        The key to achieving these goals is removing the
        pre-commitment phase used in previous protocols <a href="#ref-Ben-Sasson+15" class="text-blue-400 hover:text-blue-300">[Ben-Sasson+15]</a>, <a href="#ref-BowGabGre17" class="text-blue-400 hover:text-blue-300">[BowGabGre17]</a>. To
        do this, we design our protocol around the use of a random
        beacon, a source of public randomness that is not available
        before a fixed time.
      </p>

      <p class="text-gray-300">
        <strong>A toy CRS.</strong> For exposition, we consider a CRS
        that consists only of the elements
        <span class="math">s \cdot g_1</span> and
        <span class="math">\alpha P(s) \cdot g_1</span> where
        <span class="math">g_1</span> is a generator of a group
        <span class="math">\mathbb&#123;G&#125;_1</span> of order
        <span class="math">p</span>;
        <span class="math">s</span> and
        <span class="math">\alpha</span> are uniform elements in
        <span class="math">\mathbb&#123;F&#125;_p^*</span>; and
        <span class="math">P</span> is the degree one polynomial
        <span class="math">P(x) := 3x + 5</span> over
        <span class="math">\mathbb&#123;F&#125;_p</span>.
      </p>

      <p class="text-gray-300">
        <strong>Phase 1.</strong> Alice and Bob need to compute
        <span class="math">s \cdot g_1</span> for a uniform
        <span class="math">s \in \mathbb&#123;F&#125;_p^*</span>
        unknown to either of them. Alice chooses a uniform
        <span class="math">s_1 \in \mathbb&#123;F&#125;_p^*</span>,
        and sends
        <span class="math">M = s_1 \cdot g_1</span> to Bob. Bob is
        requested to multiply
        <span class="math">M</span> by a uniform
        <span class="math">s_2 \in \mathbb&#123;F&#125;_p^*</span>.
        The problem is that as Bob is malicious he can adaptively
        choose <span class="math">s_2</span> based on
        Alice&rsquo;s message. Previous protocols <a href="#ref-Ben-Sasson+15" class="text-blue-400 hover:text-blue-300">[Ben-Sasson+15]</a>, <a href="#ref-BowGabGre17" class="text-blue-400 hover:text-blue-300">[BowGabGre17]</a> solved
        this with a precommitment phase; this paper&rsquo;s main
        observation is that assuming a random beacon, we can omit the
        precommitment phase and still prevent adaptive attacks.
      </p>

      <p class="text-gray-300">
        With the random beacon, our simplified protocol proceeds:
        (1) Alice chooses random
        <span class="math">s_1 \in \mathbb&#123;F&#125;_p^*</span>
        and broadcasts
        <span class="math">M = s_1 \cdot g_1</span>; (2) Bob
        chooses a value
        <span class="math">s_2 \in \mathbb&#123;F&#125;_p^*</span>
        and broadcasts
        <span class="math">M' = s_1 s_2 \cdot g_1</span>; (3) the
        coordinator invokes the random beacon to obtain a uniform
        <span class="math">s_3 \in \mathbb&#123;F&#125;_p^*</span>,
        and the protocol output is
        <span class="math">s_3 \cdot M' = s_1 s_2 s_3 \cdot g_1</span>.
        The output is
        <span class="math">s \cdot g_1</span> for uniform
        <span class="math">s</span> regardless of Bob&rsquo;s
        choice.
      </p>

      <p class="text-gray-300">
        <strong>Phase 2.</strong> After Phase 1,
        <span class="math">P(s) \cdot g_1</span> is a linear
        combination
      </p>
      <div class="math-block">
        P(s) \cdot g_1 = 3 \cdot (s \cdot g_1) + 5 \cdot g_1
      </div>
      <p class="text-gray-300">
        of the public values
        <span class="math">s \cdot g_1, g_1</span>. Thus, the
        coordinator can efficiently compute
        <span class="math">P(s) \cdot g_1</span>. Phase 2 proceeds
        analogously to Phase 1 for computing
        <span class="math">\alpha P(s) \cdot g_1</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. Preliminaries</h2>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Notation
      </h3>
      <p class="text-gray-300">
        We will be working over bilinear groups
        <span class="math">\mathbb&#123;G&#125;_1</span>,
        <span class="math">\mathbb&#123;G&#125;_2</span>, and
        <span class="math">\mathbb&#123;G&#125;_T</span> each of
        prime order <span class="math">p</span>, together with
        respective generators
        <span class="math">g_1, g_2</span> and
        <span class="math">g_T</span>. These groups are equipped
        with a non-degenerate bilinear pairing
        <span class="math">e: \mathbb&#123;G&#125;_1 \times \mathbb&#123;G&#125;_2 \to \mathbb&#123;G&#125;_T</span>,
        with
        <span class="math">e(g_1, g_2) = g_T</span>. We write
        <span class="math">\mathbb&#123;G&#125;_1</span> and
        <span class="math">\mathbb&#123;G&#125;_2</span> additively,
        and <span class="math">\mathbb&#123;G&#125;_T</span>
        multiplicatively. For
        <span class="math">a \in \mathbb&#123;F&#125;_p</span>, we
        denote
        <span class="math">[a]_1 := a \cdot g_1</span>,
        <span class="math">[a]_2 := a \cdot g_2</span>. We use
        the notation
        <span class="math">\mathbf&#123;G&#125; := \mathbb&#123;G&#125;_1 \times \mathbb&#123;G&#125;_2</span>
        and
        <span class="math">\mathbf&#123;g&#125; := (g_1, g_2)</span>.
      </p>

      <p class="text-gray-300">
        We assume that we have a generator
        <span class="math">\mathcal&#123;G&#125;</span> that takes a
        parameter <span class="math">\lambda</span> and returns the
        three groups above having prime order
        <span class="math">p</span> at least super polynomial in
        <span class="math">\lambda</span>, together with uniformly
        chosen generators
        <span class="math">g_1 \in \mathbb&#123;G&#125;_1^*</span>,
        <span class="math">g_2 \in \mathbb&#123;G&#125;_2^*</span>.
        We use the acronym e.w.p. to mean &ldquo;except with
        probability&rdquo;; i.e., e.w.p.
        <span class="math">\gamma</span> means &ldquo;with
        probability at least
        <span class="math">1 - \gamma</span>&rdquo;.
      </p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Random Beacons
      </h3>
      <p class="text-gray-300">
        We assume we have at our disposal a &ldquo;random
        beacon&rdquo; RB that outputs elements in
        <span class="math">\mathbb&#123;F&#125;_p^*</span>. We
        think of RB as a function receiving a time slot
        <span class="math">J</span>, and positive integer
        <span class="math">k</span>; and outputting
        <span class="math">k</span> elements
        <span class="math">a_1, \ldots, a_k \in \mathbb&#123;F&#125;_p^*</span>.
        We say RB is <em>resistant</em> to
        <span class="math">\mathcal&#123;A&#125;</span>, if for any
        positive integers <span class="math">J</span> and
        <span class="math">k</span> for which RB is defined: for
        any random variable <span class="math">X</span> generated
        by <span class="math">\mathcal&#123;A&#125;</span> before
        time <span class="math">J</span>, the distribution of
        <span class="math">\mathsf&#123;RB&#125;(J, k)</span> is
        uniform in
        <span class="math">(\mathbb&#123;F&#125;_p^*)^k</span> and
        independent of
        <span class="math">(\mathrm&#123;rand&#125;_&#123;\mathcal&#123;A&#125;&#125;, X)</span>.
      </p>

      <p class="text-gray-300">
        We say RB is
        <span class="math">u</span>-<em>co-resistant</em> to
        <span class="math">\mathcal&#123;A&#125;</span>, if for any
        positive integers <span class="math">J</span> and
        <span class="math">k</span>: for any random variable
        <span class="math">X</span> generated by
        <span class="math">\mathcal&#123;A&#125;</span> before time
        <span class="math">J</span>, the distribution of
        <span class="math">\mathsf&#123;RB&#125;(J,k)</span>
        conditioned on any fixing of
        <span class="math">(\mathrm&#123;rand&#125;_&#123;\mathcal&#123;A&#125;&#125;, X)</span>
        has co-min-entropy at most
        <span class="math">u</span> (i.e. min-entropy at least
        <span class="math">k \cdot \log |\mathbb&#123;F&#125;_p^*| - u</span>).
      </p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8 mb-3">
        3.3 Input Domains
      </h3>
      <p class="text-gray-300">
        We assume implicitly in all method descriptions that if an
        input is not in the prescribed range the method outputs
        <span class="math">\mathsf&#123;rej&#125;</span>. This means
        that in an implementation of the protocol a method expecting
        input in
        <span class="math">\mathbb&#123;G&#125;_2^*</span> checks
        that the received input is indeed in this range and outputs
        <span class="math">\mathsf&#123;rej&#125;</span> otherwise.
      </p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8 mb-3">
        3.4 Player-exchangeable Protocols and Adaptive Adversaries
      </h3>
      <p class="text-gray-300">
        We assume there are <span class="math">N</span> players
        <span class="math">P_1, \ldots, P_N</span> in each phase of
        the protocol. Though we use this notation for each phase, we
        do not assume it is the same player
        <span class="math">P_i</span> in each phase, nor that the
        identity of the player was determined before the time slot
        where they send their message. When we discuss an adversary
        <span class="math">\mathcal&#123;A&#125;</span> controlling
        <span class="math">K</span> players in the protocol, we
        mean that <span class="math">\mathcal&#123;A&#125;</span>
        can adaptively choose a different subset of
        <span class="math">K</span> players to control in each
        phase.
      </p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8 mb-3">
        3.5 Preliminary Claims
      </h3>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Claim 3.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">A, B</span> be two random
            variables such that for any fixing
            <span class="math">a</span> of
            <span class="math">A</span>,
            <span class="math">B|_&#123;A=a&#125;</span> has
            co-min-entropy at most
            <span class="math">u</span>. Let
            <span class="math">P</span> be a predicate with range
            <span class="math">\&#123;\mathsf&#123;acc&#125;, \mathsf&#123;rej&#125;\&#125;</span>.
            Let <span class="math">B'</span> be a random variable
            independent of <span class="math">A</span> that is
            uniform on the range of
            <span class="math">B</span>. Then
          </p>
          <div class="math-block">
            \Pr(P(A, B') = \mathsf&#123;acc&#125;) \ge 2^&#123;-u&#125; \cdot \Pr(P(A, B) = \mathsf&#123;acc&#125;).
          </div>
        </div>
      </div>

      <h3 id="sec-3.6" class="text-xl font-semibold mt-8 mb-3">
        3.6 Auxiliary Methods
      </h3>
      <p class="text-gray-300">
        We define some methods to check whether certain ratios
        between elements hold, using the pairing function
        <span class="math">e</span>.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Claim 3.2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Given
            <span class="math">A, B \in \mathbb&#123;G&#125;_1^*</span>
            and
            <span class="math">C, D \in \mathbb&#123;G&#125;_2^*</span>,
            <span class="math">\mathsf&#123;SameRatio&#125;((A, B), (C, D)) = \mathsf&#123;acc&#125;</span>
            if and only if there exists
            <span class="math">s \in \mathbb&#123;F&#125;_p^*</span>
            such that
            <span class="math">B = s \cdot A</span> and
            <span class="math">D = s \cdot C</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Algorithm 1</strong> (SameRatio): Determine if
        <span class="math">x \in \mathbb&#123;F&#125;_p^*</span>
        exists such that
        <span class="math">B = A \cdot x</span> and
        <span class="math">D = C \cdot x</span>. Given
        <span class="math">A, B \in \mathbb&#123;G&#125;_1</span>
        and
        <span class="math">C, D \in \mathbb&#123;G&#125;_2</span>,
        check whether
        <span class="math">e(A, D) = e(B, C)</span>. If so, return
        <span class="math">\mathsf&#123;acc&#125;</span>; else
        return
        <span class="math">\mathsf&#123;rej&#125;</span>.
      </p>

      <p class="text-gray-300">
        <strong>Algorithm 2</strong> (Consistent): Check whether the
        ratio between <span class="math">A</span> and
        <span class="math">B</span> is the
        <span class="math">s \in \mathbb&#123;F&#125;_p^*</span>
        encoded in <span class="math">C</span>. This is used in
        the protocol verification to ensure players correctly
        contributed their shares.
      </p>

      <h3 id="sec-3.7" class="text-xl font-semibold mt-8 mb-3">
        3.7 Proofs of Knowledge
      </h3>
      <p class="text-gray-300">
        We will use a discrete log proof of knowledge scheme based
        on the Knowledge of Exponent assumption.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3.3 (Knowledge of Exponent Assumption, KEA)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For any efficient
            <span class="math">\mathcal&#123;A&#125;</span> there
            exists an efficient deterministic
            <span class="math">\chi</span> such that the following
            holds. <span class="math">\mathcal&#123;A&#125;</span>
            is given an arbitrary &ldquo;auxiliary information
            string&rdquo; <span class="math">z</span>, together
            with a uniformly chosen
            <span class="math">r \in \mathbb&#123;G&#125;_2^*</span>,
            that is independent of
            <span class="math">z</span>. He then generates
            <span class="math">x \in \mathbb&#123;G&#125;_1^*</span>
            and
            <span class="math">y \in \mathbb&#123;G&#125;_2^*</span>.
            <span class="math">\chi</span>, given the same inputs
            <span class="math">r</span> and
            <span class="math">z</span> and the internal randomness
            of <span class="math">\mathcal&#123;A&#125;</span>,
            outputs
            <span class="math">\alpha \in \mathbb&#123;F&#125;_p^*</span>.
            The probability that both (1)
            <span class="math">\mathcal&#123;A&#125;</span>
            &ldquo;succeeded&rdquo;, i.e.,
            <span class="math">\mathsf&#123;SameRatio&#125;((g_1,x),(r,y))</span>,
            and (2)
            <span class="math">\chi</span> &ldquo;failed&rdquo;,
            i.e.,
            <span class="math">x \neq [\alpha]_1</span>, is
            <span class="math">\mathrm&#123;negl&#125;(\lambda)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Algorithm 3</strong> (POK): Construct a proof of
        knowledge of
        <span class="math">\alpha</span>. Given
        <span class="math">\alpha \in \mathbb&#123;F&#125;_p^*</span>
        and a string <span class="math">v</span>, compute
        <span class="math">r \leftarrow \mathcal&#123;R&#125;([\alpha]_1, v) \in \mathbb&#123;G&#125;_2^*</span>,
        then return
        <span class="math">([\alpha]_1, \alpha \cdot r)</span>.
      </p>

      <p class="text-gray-300">
        <strong>Algorithm 4</strong> (CheckPok): Verify a proof of
        knowledge. Given
        <span class="math">a \in \mathbb&#123;G&#125;_1^*</span>,
        <span class="math">b \in \mathbb&#123;G&#125;_2^*</span>,
        and a string <span class="math">v</span>, compute
        <span class="math">r \leftarrow \mathcal&#123;R&#125;(a, v) \in \mathbb&#123;G&#125;_2^*</span>,
        then return
        <span class="math">\mathsf&#123;SameRatio&#125;((g_1, a), (r, b))</span>.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Claim 3.5
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Under the KEA assumption, for any efficient oracle
            circuit <span class="math">\mathcal&#123;A&#125;</span>,
            there exists an efficient
            <span class="math">\chi</span> such that the following
            holds. Fix any string
            <span class="math">z</span> that was generated without
            queries to
            <span class="math">\mathcal&#123;R&#125;</span>. Given
            <span class="math">z</span> and random oracle replies
            <span class="math">r_1, \ldots, r_\ell</span>,
            <span class="math">\mathcal&#123;A&#125;</span> produces
            <span class="math">a \in \mathbb&#123;G&#125;_1</span>,
            <span class="math">y \in \mathbb&#123;G&#125;_2</span>
            and a string <span class="math">v</span>; and
            <span class="math">\chi</span>, given the same inputs
            together with the internal randomness used by
            <span class="math">\mathcal&#123;A&#125;</span>,
            produces
            <span class="math">\alpha \in \mathbb&#123;F&#125;_p^*</span>.
            The probability that both (1)
            <span class="math">\mathcal&#123;A&#125;</span>
            &ldquo;succeeds&rdquo;, i.e.,
            <span class="math">\mathsf&#123;CheckPOK&#125;(a, v, y) = \mathsf&#123;acc&#125;</span>,
            and (2)
            <span class="math">\chi</span> &ldquo;failed&rdquo;,
            i.e.,
            <span class="math">a \neq [\alpha]_1</span>, is
            <span class="math">\mathrm&#123;negl&#125;(\lambda)</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>[Proof of Claim 3.5 proceeds by constructing
        <span class="math">\mathcal&#123;A&#125;_i</span> for each
        <span class="math">i \in [\ell]</span>, invoking the KEA
        assumption on each, and applying a union bound over all
        oracle query indices.]</em>
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. MULTI-PARTY COMPUTATION FOR PARAMETER GENERATION          -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Multi-party Computation for Parameter Generation
      </h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 The Circuit Structure
      </h3>
      <p class="text-gray-300">
        We assume we have an arithmetic circuit
        <span class="math">\mathbf&#123;C&#125;</span> over
        <span class="math">\mathbb&#123;F&#125;_p</span> with the
        following structure. The circuit consists of alternate
        multiply/divide layers
        <span class="math">C_1, \ldots, C_d</span>, and linear
        combination layers
        <span class="math">L_1, \ldots, L_d</span>. We call
        <span class="math">d</span> the depth of the circuit. The
        circuit inputs
        <span class="math">\mathbf&#123;x&#125;</span> are
        partitioned into disjoint sets
        <span class="math">\mathbf&#123;x&#125;^1, \ldots, \mathbf&#123;x&#125;^d</span>
        corresponding to the layers.
      </p>
      <p class="text-gray-300">
        A multiply/divide layer <span class="math">C</span>
        satisfies: (1) all gate outputs are outputs of the circuit;
        (2) <span class="math">C = C_\ell</span> has an input gate
        for each of its inputs; (3) all gates besides input gates
        are division and multiplication gates of fan-in two. A
        linear combination layer <span class="math">L</span>
        consists of linear combination gates of unbounded fan-in.
      </p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 The Protocol Coordinator
      </h3>
      <p class="text-gray-300">
        In addition to messages of the players, the protocol
        description includes messages that are to be sent by the
        <em>protocol coordinator</em>. These messages are a
        deterministic function of the protocol description and the
        transcript up to that point. There is no need to trust this
        party, and anyone can later verify that the protocol
        coordinator&rsquo;s messages are correct.
      </p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 The MPC
      </h3>
      <p class="text-gray-300">
        The goal of the protocol is to compute
        <span class="math">\mathbf&#123;C&#125;(\mathbf&#123;x&#125;) \cdot \mathbf&#123;g&#125;</span>
        for uniformly chosen
        <span class="math">\mathbf&#123;x&#125; \in (\mathbb&#123;F&#125;_p^*)^t</span>,
        where <span class="math">t</span> is the number of
        <span class="math">\mathbf&#123;C&#125;</span>&rsquo;s
        inputs. More specifically, we will have
        <span class="math">\mathbf&#123;x&#125; = \mathbf&#123;x&#125;_1 \cdots \mathbf&#123;x&#125;_N \cdot \mathbf&#123;x&#125;'</span>
        (product defined coordinate-wise), where
        <span class="math">\mathbf&#123;x&#125;_i \in (\mathbb&#123;F&#125;_p^*)^t</span>
        is the input of
        <span class="math">P_i</span>, and
        <span class="math">\mathbf&#123;x&#125;'</span> is a
        random beacon output.
      </p>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8 mb-3">
        4.4 The Phase Structure
      </h3>
      <p class="text-gray-300">
        We fix a layer
        <span class="math">\ell \in [1..d]</span> and denote
        <span class="math">C = C_\ell, L = L_\ell</span>. We
        assume that for all gates
        <span class="math">g</span> in previous layers, we have
        already computed an output value
        <span class="math">[g] \in \mathbf&#123;G&#125;</span>.
        Note that the output of every gate
        <span class="math">g \in C</span> is a Laurent monomial in
        <span class="math">C</span>&rsquo;s inputs, possibly
        multiplied by an output from a previous layer.
      </p>
      <p class="text-gray-300">
        The phase consists of three steps: (1) For each
        <span class="math">j \in [N]</span>, Player
        <span class="math">j</span> outputs proofs of knowledge
        for each input and computes the partial gate values
        <span class="math">[g]^&#123;\mathbf&#123;j&#125;&#125;</span>;
        (2) The protocol coordinator computes beacon values and
        final gate outputs; (3) The coordinator computes the linear
        combination layer outputs.
      </p>

      <p class="text-gray-300">
        <strong>Verification:</strong> For each
        <span class="math">j \in [N]</span>, the protocol verifier
        checks: CheckPOK for each input; consistency of input
        updates; and consistency of gate computations (multiplication
        or division) with respect to their left and right inputs.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. SECURITY PROOF                                            -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Security Proof</h2>

      <p class="text-gray-300">
        We denote by
        <span class="math">\mathbf&#123;C&#125;_S</span> a random
        variable equal to the encoded output of the circuit
        <span class="math">\mathbf&#123;C&#125;</span> with
        uniformly chosen input. That is,
        <span class="math">\mathbf&#123;C&#125;_S := [\mathbf&#123;C&#125;(s)]</span>
        for uniform
        <span class="math">s \in (\mathbb&#123;F&#125;_p^*)^t</span>.
        Let <span class="math">\mathcal&#123;A&#125;</span> be an
        adversary that controls a subset of
        <span class="math">N-1</span> players in each phase. We
        denote by
        <span class="math">\mathbf&#123;C&#125;_&#123;\mathcal&#123;A&#125;&#125;</span>
        the circuit output generated by
        <span class="math">\mathcal&#123;A&#125;</span>
        participating in the protocol together with an honest player
        in each phase. For a predicate
        <span class="math">P</span> with range
        <span class="math">\&#123;\mathsf&#123;acc&#125;, \mathsf&#123;rej&#125;\&#125;</span>,
        we define
      </p>
      <div class="math-block">
        \mathrm&#123;adv&#125;_&#123;\mathcal&#123;A&#125;, P&#125; := \Pr(P(\mathbf&#123;C&#125;_&#123;\mathcal&#123;A&#125;&#125;, \mathsf&#123;z&#125;) = \mathsf&#123;acc&#125;).
      </div>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 5.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Fix any efficient oracle circuit
            <span class="math">\mathcal&#123;A&#125;</span> and
            <span class="math">u > 0</span>. Fix a number of
            players <span class="math">N</span> with
            <span class="math">N(\lambda) = \mathrm&#123;poly&#125;(\lambda)</span>.
            There exists an efficient
            <span class="math">\mathcal&#123;B&#125;</span> such
            that if RB is
            <span class="math">u</span>-co-resistant to
            <span class="math">\mathcal&#123;A&#125;</span>, then
            for every predicate
            <span class="math">P</span>
          </p>
          <div class="math-block">
            \Pr(P(\mathbf&#123;C&#125;_S, \mathcal&#123;B&#125;(\mathbf&#123;C&#125;_S)) = \mathsf&#123;acc&#125;) \ge 2^&#123;-ud&#125; \cdot \mathrm&#123;adv&#125;_&#123;\mathcal&#123;A&#125;, P&#125; - \mathrm&#123;negl&#125;(\lambda).
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        Suppose <span class="math">P</span> is a predicate that runs
        a zk-SNARK verifier with some fixed public input, using its
        first input as the zk-SNARK parameters, and the second as
        the proof; take a constant <span class="math">d</span> and
        <span class="math">u = O(\log \lambda)</span>. The theorem
        implies that if
        <span class="math">\mathcal&#123;A&#125;</span> cannot
        construct a correct proof with non-negligible probability for
        independently generated parameters, it cannot do so for
        parameters generated in the protocol in which it
        participated.
      </p>

      <p class="text-gray-300">
        <em>Proof sketch.</em> Denote by
        <span class="math">H</span> the set of inputs of the honest
        player in each phase. The circuit output and the string
        <span class="math">\mathsf&#123;z&#125;</span> that
        <span class="math">\mathcal&#123;A&#125;</span> outputs can
        be viewed as a function of
        <span class="math">\mathsf&#123;x&#125; = (\mathrm&#123;rand&#125;_&#123;\mathcal&#123;A&#125;&#125;, H, \mathrm&#123;rand&#125;_&#123;\mathrm&#123;oracle&#125;&#125;, \mathrm&#123;rand&#125;_&#123;\mathrm&#123;beacon&#125;&#125;)</span>.
        As RB is
        <span class="math">u</span>-co-resistant to
        <span class="math">\mathcal&#123;A&#125;</span>, the beacon
        outputs have co-min-entropy at most
        <span class="math">ud</span> conditioned on other
        randomness. By Claim 3.1:
      </p>
      <div class="math-block">
        \Pr_&#123;\mathsf&#123;x&#125; \leftarrow \mathcal&#123;X&#125;&#125;(P(\mathbf&#123;C&#125;_&#123;\mathcal&#123;A&#125;&#125;(\mathsf&#123;x&#125;), \mathsf&#123;z&#125;(\mathsf&#123;x&#125;)) = \mathsf&#123;acc&#125;) \ge 2^&#123;-ud&#125; \cdot \mathrm&#123;adv&#125;_&#123;\mathcal&#123;A&#125;, P&#125;.
      </div>

      <p class="text-gray-300">
        The proof then constructs
        <span class="math">\mathcal&#123;B&#125;</span> which, given
        <span class="math">[\mathbf&#123;C&#125;(s)]</span>,
        simulates the protocol with
        <span class="math">\mathcal&#123;A&#125;</span> by
        extracting adversary inputs using the KEA extractor, choosing
        the honest player&rsquo;s input to embed
        <span class="math">s</span>, and programming the random
        oracle and beacon accordingly. The key properties are: (1)
        the randomness elements used are uniform and independent; and
        (2) aborts occur with negligible probability by Claim 3.5.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. REDUCING THE DEPTH OF GROTH'S CRS                        -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">
        6. Reducing the Depth of Groth&rsquo;s CRS
      </h2>

      <p class="text-gray-300">
        In this section we assume familiarity with Quadratic
        Arithmetic Programs <a href="#ref-Gen+13a" class="text-blue-400 hover:text-blue-300">[Gen+13a]</a> and the work of Groth <a href="#ref-Groth16" class="text-blue-400 hover:text-blue-300">[Groth16]</a>. Let
        <span class="math">\&#123;u_i, v_i, w_i\&#125;_&#123;i \in [0..m]&#125; \cup \&#123;t\&#125;</span>
        be the polynomials of a degree
        <span class="math">n</span> QAP over
        <span class="math">\mathbb&#123;F&#125;_p</span>, where
        <span class="math">t</span> is the degree
        <span class="math">n</span> target polynomial.
      </p>

      <p class="text-gray-300">
        <strong>The extended Groth CRS.</strong> For
        <span class="math">\alpha, \beta, \delta, x \in \mathbb&#123;F&#125;_p^*</span>,
        <span class="math">\mathrm&#123;Groth&#125;(\alpha, \beta, \delta, x)</span>
        is defined as the set of elements:
      </p>
      <div class="math-block">
        \beta,\; \delta,\; \&#123;x^i\&#125;_&#123;i \in [0..2n-2]&#125;,\; \&#123;\alpha x^i\&#125;_&#123;i \in [0..n-1]&#125;,\; \&#123;\beta x^i\&#125;_&#123;i \in [1..n-1]&#125;,\; \&#123;x^i \cdot t(x)/\delta\&#125;_&#123;i \in [0..n-2]&#125;,\; \left\&#123;\frac&#123;\beta u_i(x) + \alpha v_i(x) + w_i(x)&#125;&#123;\delta&#125;\right\&#125;_&#123;i \in [\ell+1..m]&#125;.
      </div>

      <p class="text-gray-300">
        The additional elements compared to <a href="#ref-Groth16" class="text-blue-400 hover:text-blue-300">[Groth16]</a> are
        <span class="math">\&#123;x^i\&#125;_&#123;i \in [n..2n-2]&#125;</span>,
        <span class="math">\&#123;\alpha x^i\&#125;_&#123;i \in [1..n-1]&#125;</span>,
        <span class="math">\&#123;\beta x^i\&#125;_&#123;i \in [1..n-1]&#125;</span>.
        The elements
        <span class="math">\left\&#123;\frac&#123;\beta u_i(x) + \alpha v_i(x) + w_i(x)&#125;&#123;\gamma&#125;\right\&#125;_&#123;i \in [0..\ell]&#125;</span>
        and <span class="math">\gamma</span> from <a href="#ref-Groth16" class="text-blue-400 hover:text-blue-300">[Groth16]</a> have
        disappeared; they were needed there for verifier computation
        which can now be done as a linear combination of our added
        elements.
      </p>

      <p class="text-gray-300">
        Groth can be computed by a depth two circuit:
        <span class="math">C_1</span> with inputs
        <span class="math">\&#123;x, \alpha, \beta\&#125;</span>
        computes the power/product terms;
        <span class="math">L_1</span> computes linear combinations
        including
        <span class="math">\&#123;x^i \cdot t(x)\&#125;</span> and
        <span class="math">\&#123;\beta u_i(x) + \alpha v_i(x) + w_i(x)\&#125;</span>;
        <span class="math">C_2</span> with input
        <span class="math">\&#123;\delta\&#125;</span> computes the
        division-by-<span class="math">\delta</span> terms.
      </p>

      <p class="text-gray-300">
        <strong>Groth prover and verifier.</strong> The prover
        chooses random
        <span class="math">r, s \in \mathbb&#123;F&#125;_p</span>
        and computes:
      </p>
      <div class="math-block">
        A = \alpha + \sum_&#123;i=0&#125;^&#123;m&#125; a_i u_i(x) + r\delta, \quad B = \beta + \sum_&#123;i=0&#125;^&#123;m&#125; a_i v_i(x) + s\delta
      </div>
      <div class="math-block">
        C = \frac&#123;\sum_&#123;i=\ell+1&#125;^&#123;m&#125; a_i(\beta u_i(x) + \alpha v_i(x) + w_i(x)) + h(x)t(x)&#125;&#123;\delta&#125; + As + Br - rs\delta
      </div>
      <p class="text-gray-300">
        The verifier checks that:
      </p>
      <div class="math-block">
        A \cdot B = \alpha \cdot \beta + \sum_&#123;i=0&#125;^&#123;\ell&#125; a_i(\beta u_i(x) + \alpha v_i(x) + w_i(x)) + C \cdot \delta.
      </div>

      <p class="text-gray-300">
        <strong>Proving knowledge soundness.</strong> From <a href="#ref-Groth16" class="text-blue-400 hover:text-blue-300">[Groth16]</a> it
        is enough to prove that we can extract a witness for the QAP
        given <span class="math">A, B, C</span> that are linear
        combinations of CRS elements such that the verification
        equation holds as a polynomial identity. Our focus is to
        show the new monomials added to the CRS &mdash;
        <span class="math">\&#123;x^i\&#125;_&#123;i \in [n..2n-2]&#125;</span>,
        <span class="math">\&#123;\alpha x^i\&#125;_&#123;i \in [1..n-1]&#125;</span>,
        <span class="math">\&#123;\beta x^i\&#125;_&#123;i \in [1..n-1]&#125;</span>
        &mdash; are not used in
        <span class="math">A, B, C</span>.
      </p>

      <p class="text-gray-300">
        <em>[The proof proceeds by monomial analysis. Since
        <span class="math">\alpha\beta \in A \cdot B</span>, we must
        have <span class="math">\alpha \in A, \beta \in B</span>
        (w.l.o.g.). Assuming
        <span class="math">\beta x^i \in A</span> leads to
        <span class="math">\beta^2 x^k \in A \cdot B</span> which
        cannot appear in
        <span class="math">C^*</span>, yielding a contradiction.
        Similar arguments show
        <span class="math">\alpha x^i \notin B</span> for
        <span class="math">i \geq 1</span>, and that the new terms
        do not appear in the proof. The maximal power of
        <span class="math">x</span> in
        <span class="math">A</span> and
        <span class="math">B</span> is bounded by
        <span class="math">n-1</span>, and similarly for
        <span class="math">C</span>.]</em>
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7. MPC FOR GROTH'S ZK-SNARK                                 -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">
        7. Multi-party Computation for Groth&rsquo;s zk-SNARK
      </h2>

      <p class="text-gray-300">
        We now instantiate the protocol of Section 4 to get a
        protocol for computing the CRS of the zk-SNARK
        corresponding to the NILP described in Section 6. The output
        will have the form:
      </p>
      <div class="math-block">
        \&#123;[x^i]\&#125;_&#123;i \in [0..n-1]&#125;,\; \&#123;[x^i]_1\&#125;_&#123;i \in [n..2n-2]&#125;,\; \&#123;[\alpha x^i]_1\&#125;_&#123;i \in [0..n-1]&#125;,\; [\beta],\; \&#123;[\beta x^i]_1\&#125;_&#123;i \in [1..n-1]&#125;,
      </div>
      <div class="math-block">
        \&#123;[x^i \cdot t(x)/\delta]_1\&#125;_&#123;i \in [0..n-2]&#125;,\; \left\&#123;\left[\frac&#123;\beta u_i(x) + \alpha v_i(x) + w_i(x)&#125;&#123;\delta&#125;\right]_1\right\&#125;_&#123;i \in [\ell+1..m]&#125;
      </div>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8 mb-3">
        7.1 Round 1: &ldquo;Powers of
        <span class="math">\tau</span>&rdquo;
      </h3>
      <p class="text-gray-300">
        We need to compute the set
        <span class="math">\mathbf&#123;M&#125;_1</span> consisting
        of
        <span class="math">\&#123;[x^i]\&#125;_&#123;i \in [0..n-1]&#125;</span>,
        <span class="math">\&#123;[x^i]_1\&#125;_&#123;i \in [n..2n-2]&#125;</span>,
        <span class="math">\&#123;[\alpha x^i]_1\&#125;_&#123;i \in [0..n-1]&#125;</span>,
        <span class="math">[\beta]</span>,
        <span class="math">[\delta]</span>, and
        <span class="math">\&#123;[\beta x^i]_1\&#125;_&#123;i \in [1..n-1]&#125;</span>.
      </p>
      <p class="text-gray-300">
        <strong>Initialization:</strong> Values are initialized with
        <span class="math">[x^i]^&#123;\mathbf&#123;0&#125;&#125; := \mathbf&#123;g&#125;</span>
        for <span class="math">i \in [1..n-1]</span>, and
        <span class="math">g_1</span> for higher powers and
        <span class="math">\alpha, \beta</span> multiples.
      </p>
      <p class="text-gray-300">
        <strong>Computation:</strong> For each
        <span class="math">j \in [N]</span>,
        <span class="math">P_j</span> outputs:
        <span class="math">[\alpha_j]_1, [\beta_j]_1, [x_j]_1</span>;
        proofs of knowledge
        <span class="math">y_&#123;\alpha,j&#125;</span>,
        <span class="math">y_&#123;\beta,j&#125;</span>,
        <span class="math">y_&#123;x,j&#125;</span>; and updated
        partial values
        <span class="math">[x^i]^&#123;\mathbf&#123;j&#125;&#125; := x_j^i \cdot [x^i]^&#123;\mathbf&#123;j&#125;-1&#125;</span>,
        <span class="math">[\alpha x^i]^&#123;\mathbf&#123;j&#125;&#125; := \alpha_j x_j^i \cdot [\alpha x^i]^&#123;\mathbf&#123;j&#125;-1&#125;</span>,
        <span class="math">[\beta x^i]^&#123;\mathbf&#123;j&#125;&#125; := \beta_j x_j^i \cdot [\beta x^i]^&#123;\mathbf&#123;j&#125;-1&#125;</span>.
      </p>
      <p class="text-gray-300">
        After the last player, the coordinator obtains beacon values
        <span class="math">(x', \alpha', \beta') := \mathsf&#123;RB&#125;(J, 3)</span>
        and computes the final values, e.g.
        <span class="math">[x^i] := x'^i \cdot [x^i]^&#123;\mathbf&#123;N&#125;&#125;</span>.
      </p>
      <p class="text-gray-300">
        <strong>Verification:</strong> The verifier checks
        CheckPOK for each player&rsquo;s
        <span class="math">\alpha, \beta, x</span> contributions,
        consistency of each contribution with its proof of knowledge,
        and structural consistency (e.g., that successive powers are
        consistent with the base element).
      </p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8 mb-3">
        7.2 Linear Combinations Between Phases
      </h3>
      <p class="text-gray-300">
        For <span class="math">i \in [0..n-2]</span>, we compute as
        linear combinations of
        <span class="math">\&#123;[x^i]_1\&#125;_&#123;i \in [0..2n-2]&#125;</span>
        the element
        <span class="math">H_i' := [t(x)x^i]_1</span>. Using
        Lagrange polynomials and FFT with
        <span class="math">O(n \log n)</span> group operations, we
        compute
        <span class="math">\mathrm&#123;LAG&#125;_x</span> and
        then obtain the QAP-related linear combinations including
        <span class="math">K_i' := [\beta u_i(x) + \alpha v_i(x) + w_i(x)]_1</span>
        for <span class="math">i \in [\ell+1..m]</span>.
      </p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8 mb-3">
        7.3 Round Two
      </h3>
      <p class="text-gray-300">
        For <span class="math">i \in [\ell+1..m]</span>, denote
        <span class="math">K_i := \frac&#123;\beta u_i(x) + \alpha v_i(x) + w_i(x)&#125;&#123;\delta&#125;</span>.
        For <span class="math">i \in [0..n-2]</span>, denote
        <span class="math">H_i := \frac&#123;t(x)x^i&#125;&#123;\delta&#125;</span>.
        We need to compute
        <span class="math">\mathbf&#123;M&#125;_2 = \&#123;[\delta], \&#123;[K_i]_1\&#125;_&#123;i \in [\ell+1..m]&#125;, \&#123;[H_i]_1\&#125;_&#123;i \in [0..n-2]&#125;\&#125;</span>.
      </p>
      <p class="text-gray-300">
        <strong>Computation:</strong> For each
        <span class="math">j \in [N]</span>,
        <span class="math">P_j</span> outputs
        <span class="math">[\delta_j]_1</span>, proof of knowledge
        <span class="math">y_&#123;\delta,j&#125;</span>, and
        updated partial values by dividing by
        <span class="math">\delta_j</span>:
        <span class="math">[\delta]^&#123;\mathbf&#123;j&#125;&#125; := [\delta]^&#123;\mathbf&#123;j&#125;-1&#125;/\delta_j</span>,
        <span class="math">[K_i]^&#123;\mathbf&#123;j&#125;&#125; := [K_i]^&#123;\mathbf&#123;j&#125;-1&#125;/\delta_j</span>,
        <span class="math">[H_i]^&#123;\mathbf&#123;j&#125;&#125; := [H_i]^&#123;\mathbf&#123;j&#125;-1&#125;/\delta_j</span>.
        At the end, the beacon output
        <span class="math">\delta'</span> is applied similarly.
      </p>
      <p class="text-gray-300">
        <strong>Verification:</strong> The verifier checks
        CheckPOK for each
        <span class="math">\delta_j</span>, consistency of
        <span class="math">[\delta]</span> updates, and consistency
        of <span class="math">[K_i]</span> and
        <span class="math">[H_i]</span> updates.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 8. BLS12-381                                                 -->
    <!-- ============================================================ -->

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8. BLS12-381</h2>

      <p class="text-gray-300">
        The most common pairing-friendly elliptic curve construction
        used in zk-SNARK software is a Barreto-Naehrig <a href="#ref-BarNae05" class="text-blue-400 hover:text-blue-300">[BarNae05]</a> (BN)
        construction with a 254-bit base field and group order, as
        designed in <a href="#ref-Ben-Sasson+13b" class="text-blue-400 hover:text-blue-300">[Ben-Sasson+13b]</a>. Although the construction originally
        targeted the 128-bit security level, recent optimizations to
        the Number Field Sieve algorithm <a href="#ref-KimBar15" class="text-blue-400 hover:text-blue-300">[KimBar15]</a> have reduced its
        concrete security.
      </p>

      <p class="text-gray-300">
        Subsequent analysis <a href="#ref-MenSarSin16" class="text-blue-400 hover:text-blue-300">[MenSarSin16]</a> recommended that BN curves and
        Barreto-Lynn-Scott (BLS) curves <a href="#ref-BarLynSco02" class="text-blue-400 hover:text-blue-300">[BarLynSco02]</a> with embedding degree
        <span class="math">k = 12</span> have approximately 384-bit
        base fields in order to target 128-bit security. BLS12
        curves with 384-bit base fields give rise to 256-bit group
        orders, making them ideal for use with zk-SNARKs.
      </p>

      <p class="text-gray-300">
        The largest construction with smallest Hamming weight that
        meets the requirements is
        <span class="math">x = -2^&#123;63&#125; - 2^&#123;62&#125; - 2^&#123;60&#125; - 2^&#123;57&#125; - 2^&#123;48&#125; - 2^&#123;16&#125;</span>,
        which is named BLS12-381. This curve exists within a
        subfamily of curves, as in <a href="#ref-CosLauNae11" class="text-blue-400 hover:text-blue-300">[CosLauNae11]</a>, which have immediately
        determined curve parameters. The authors provide an
        implementation of this curve in Rust <a href="#ref-Pairing17" class="text-blue-400 hover:text-blue-300">[Pairing17]</a>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 9. IMPLEMENTATION AND EXPERIMENTS                            -->
    <!-- ============================================================ -->

    <section id="sec-9" class="mb-10">
      <h2 class="text-2xl font-bold">
        9. Implementation and Experiments
      </h2>

      <p class="text-gray-300">
        The implementation of both MMORPG and the pairing library is
        in Rust. All benchmarks for phase 1 and 2 were done on an
        Intel Core i7-3770S CPU @ 3.10GHz with 32GB of RAM running
        Arch Linux.
      </p>

      <p class="text-gray-300">
        Because the performance of the protocol is independent of
        the number of participants, the experimental setup simply
        measures the performance of a single user in each phase. The
        experiments consist of running MMORPG for three different
        circuit sizes:
        <span class="math">2^&#123;10&#125;</span>,
        <span class="math">2^&#123;17&#125;</span>, and
        <span class="math">2^&#123;21&#125;</span> gates.
        <span class="math">2^&#123;21&#125;</span> is the size of
        the largest circuit publicly generated using <a href="#ref-BowGabGre17" class="text-blue-400 hover:text-blue-300">[BowGabGre17]</a> and
        corresponds to approximately 60 SHA256 invocations.
        <span class="math">2^&#123;17&#125;</span> corresponds to
        the size of the proposal for the next generation of Zcash
        <a href="#ref-Bowe17" class="text-blue-400 hover:text-blue-300">[Bowe17]</a>.
      </p>

      <p class="text-gray-300">
        <strong>Bandwidth:</strong> For circuit size
        <span class="math">2^&#123;15&#125;</span>, phase 1
        requires 1.13 GB download / 0.56 GB upload, and phase 2
        requires 0.37 GB download / 0.19 GB upload. The results show
        that a user need only spend 15 minutes doing a computation
        and after that need no longer participate, requiring low
        investment and no need to maintain heightened security for
        extended periods.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        We thank Paulo Barreto for helpful feedback about the
        BLS12-381 elliptic curve. We thank Daniel Benarroch, Daira
        Hopwood and Antoine Rondelet for helpful comments. We thank
        the anonymous reviewers of S&amp;P 2018 for their comments.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-2 text-gray-400 text-sm list-none">
        <li id="ref-Bonneau17">
          <span class="text-gray-500">[Bonneau17]</span>
          Joseph Bonneau. Personal communication.
        </li>
        <li id="ref-Pairing17">
          <span class="text-gray-500">[Pairing17]</span>
          Pairing library.
          <a
            href="https://github.com/ebfull/pairing"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/ebfull/pairing</a>.
        </li>
        <li id="ref-Zcash17">
          <span class="text-gray-500">[Zcash17]</span>
          Zcash.
          <a
            href="https://z.cash"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >z.cash</a>.
        </li>
        <li id="ref-Ames+17">
          <span class="text-gray-500">[Ames+17]</span>
          Scott Ames, Carmit Hazay, Yuval Ishai, and
          Muthuramakrishnan Venkitasubramaniam. &ldquo;Ligero:
          Lightweight Sublinear Arguments Without a Trusted
          Setup&rdquo;. In: <em>CCS 2017</em>, pp.
          2087&ndash;2104, 2017.
        </li>
        <li id="ref-Aranha+12">
          <span class="text-gray-500">[Aranha+12]</span>
          Diego F. Aranha, Laura Fuentes-Casta&ntilde;eda,
          Edward Knapp, Alfred Menezes, and Francisco
          Rodr&iacute;guez-Henr&iacute;quez.
          &ldquo;Implementing Pairings at the 192-bit Security
          Level&rdquo;. Cryptology ePrint Archive, Report
          2012/232, 2012.
        </li>
        <li id="ref-BarDuq17">
          <span class="text-gray-500">[BarDuq17]</span>
          Razvan Barbulescu and Sylvain Duquesne.
          &ldquo;Updating Key Size Estimations for
          Pairings&rdquo;. Cryptology ePrint Archive, Report
          2017/334, 2017.
        </li>
        <li id="ref-BarLynSco02">
          <span class="text-gray-500">[BarLynSco02]</span>
          Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott.
          &ldquo;Constructing Elliptic Curves with Prescribed
          Embedding Degrees&rdquo;. Cryptology ePrint Archive,
          Report 2002/088, 2002.
        </li>
        <li id="ref-BarNae05">
          <span class="text-gray-500">[BarNae05]</span>
          Paulo S. L. M. Barreto and Michael Naehrig.
          &ldquo;Pairing-friendly Elliptic Curves of Prime
          Order&rdquo;. Cryptology ePrint Archive, Report
          2005/133, 2005.
        </li>
        <li id="ref-Ben-Sasson+15">
          <span class="text-gray-500">[Ben-Sasson+15]</span>
          E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and
          M. Virza. &ldquo;Secure Sampling of Public Parameters
          for Succinct Zero Knowledge Proofs&rdquo;. In:
          <em>IEEE S&amp;P 2015</em>, pp. 287&ndash;304, 2015.
        </li>
        <li id="ref-Ben-Sasson+17a">
          <span class="text-gray-500">[Ben-Sasson+17a]</span>
          Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa,
          Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya
          Pergament, Michael Riabzev, Mark Silberstein, Eran
          Tromer, and Madars Virza. &ldquo;Computational Integrity
          with a Public Random String from Quasi-Linear
          PCPs&rdquo;. In: <em>EUROCRYPT 2017, Part III</em>,
          pp. 551&ndash;579, 2017.
        </li>
        <li id="ref-Ben-Sasson+14">
          <span class="text-gray-500">[Ben-Sasson+14]</span>
          Eli Ben-Sasson, Alessandro Chiesa, Christina Garman,
          Matthew Green, Ian Miers, Eran Tromer, and Madars Virza.
          &ldquo;Zerocash: Decentralized Anonymous Payments from
          Bitcoin&rdquo;. In: <em>IEEE S&amp;P 2014</em>,
          pp. 459&ndash;474, 2014.
        </li>
        <li id="ref-Ben-Sasson+13a">
          <span class="text-gray-500">[Ben-Sasson+13a]</span>
          Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin,
          Eran Tromer, and Madars Virza. &ldquo;SNARKs for C:
          Verifying Program Executions Succinctly and in Zero
          Knowledge&rdquo;. In: <em>CRYPTO 2013</em>,
          pp. 90&ndash;108, 2013.
        </li>
        <li id="ref-Ben-Sasson+13b">
          <span class="text-gray-500">[Ben-Sasson+13b]</span>
          Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin,
          Eran Tromer, and Madars Virza. &ldquo;SNARKs for C:
          Verifying Program Executions Succinctly and in Zero
          Knowledge&rdquo;. Cryptology ePrint Archive, Report
          2013/507, 2013.
        </li>
        <li id="ref-Bishop15">
          <span class="text-gray-500">[Bishop15]</span>
          Bryan Bishop. &ldquo;Review of Bitcoin Scaling
          Proposals&rdquo;. In: <em>Scaling Bitcoin Workshop
          Phase</em>, vol. 1, 2015.
        </li>
        <li id="ref-Bitansky+13">
          <span class="text-gray-500">[Bitansky+13]</span>
          Nir Bitansky, Alessandro Chiesa, Yuval Ishai,
          Rafail Ostrovsky, and Omer Paneth. &ldquo;Succinct
          Non-interactive Arguments via Linear Interactive
          Proofs&rdquo;. In: <em>TCC 2013</em>,
          pp. 315&ndash;333, 2013.
        </li>
        <li id="ref-BowGabGre17">
          <span class="text-gray-500">[BowGabGre17]</span>
          S. Bowe, A. Gabizon, and M. D. Green. &ldquo;A
          Multi-party Protocol for Constructing the Public
          Parameters of the Pinocchio zk-SNARK&rdquo;. IACR
          Cryptology ePrint Archive, 2017:602, 2017.
        </li>
        <li id="ref-Bowe17">
          <span class="text-gray-500">[Bowe17]</span>
          Sean Bowe. &ldquo;Cultivating Sapling: Faster
          zk-SNARKs&rdquo;.
          <a
            href="https://z.cash/blog/cultivating-sapling-faster-zksnarks.html"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >z.cash/blog</a>, September 2017.
        </li>
        <li id="ref-BunGolBon17">
          <span class="text-gray-500">[BunGolBon17]</span>
          Benedikt B&uuml;nz, Steven Goldfeder, and Joseph
          Bonneau. &ldquo;Proofs-of-delay and Randomness Beacons
          in Ethereum&rdquo;. In: <em>S&amp;B 2017</em>, April
          2017.
        </li>
        <li id="ref-ButPoo17">
          <span class="text-gray-500">[ButPoo17]</span>
          Vitalik Buterin and Joseph Poon. &ldquo;Plasma:
          Scalable Autonomous Smart Contracts&rdquo;.
          <a
            href="http://plasma.io/plasma.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >plasma.io</a>, August 2017.
        </li>
        <li id="ref-Chiesa+17">
          <span class="text-gray-500">[Chiesa+17]</span>
          Alessandro Chiesa, Matthew Green, Jingcheng Liu,
          Peihan Miao, Ian Miers, and Pratyush Mishra.
          &ldquo;Decentralized Anonymous Micropayments&rdquo;. In:
          <em>EUROCRYPT 2017, Part II</em>, pp. 609&ndash;642,
          2017.
        </li>
        <li id="ref-CosLauNae11">
          <span class="text-gray-500">[CosLauNae11]</span>
          Craig Costello, Kristin Lauter, and Michael Naehrig.
          &ldquo;Attractive Subfamilies of BLS Curves for
          Implementing High-Security Pairings&rdquo;. Cryptology
          ePrint Archive, Report 2011/465, 2011.
        </li>
        <li id="ref-Fuchsbauer17">
          <span class="text-gray-500">[Fuchsbauer17]</span>
          Georg Fuchsbauer. &ldquo;Subversion-zero-knowledge
          SNARKs&rdquo;. Cryptology ePrint Archive, Report
          2017/587, 2017.
        </li>
        <li id="ref-Gen+13a">
          <span class="text-gray-500">[Gen+13a]</span>
          R. Gennaro, C. Gentry, B. Parno, and M. Raykova.
          &ldquo;Quadratic Span Programs and Succinct NIZKs
          without PCPs&rdquo;. In: <em>EUROCRYPT 2013</em>,
          pp. 626&ndash;645, 2013.
        </li>
        <li id="ref-Gen+13b">
          <span class="text-gray-500">[Gen+13b]</span>
          Rosario Gennaro, Craig Gentry, Bryan Parno, and
          Mariana Raykova. &ldquo;Quadratic Span Programs and
          Succinct NIZKs without PCPs&rdquo;. In:
          <em>EUROCRYPT 2013</em>, pp. 626&ndash;645, 2013.
        </li>
        <li id="ref-Gilad+17">
          <span class="text-gray-500">[Gilad+17]</span>
          Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios
          Vlachos, and Nickolai Zeldovich. &ldquo;Algorand:
          Scaling Byzantine Agreements for
          Cryptocurrencies&rdquo;. In: <em>SOSP 2017</em>,
          pp. 51&ndash;68, 2017.
        </li>
        <li id="ref-Goldwasser+13">
          <span class="text-gray-500">[Goldwasser+13]</span>
          Shafi Goldwasser, Yael Kalai, Raluca Ada Popa,
          Vinod Vaikuntanathan, and Nickolai Zeldovich.
          &ldquo;How to Run Turing Machines on Encrypted
          Data&rdquo;. Cryptology ePrint Archive, Report
          2013/229, 2013.
        </li>
        <li id="ref-Groth16">
          <span class="text-gray-500">[Groth16]</span>
          J. Groth. &ldquo;On the Size of Pairing-based
          Non-interactive Arguments&rdquo;. In:
          <em>EUROCRYPT 2016, Part II</em>, pp. 305&ndash;326,
          2016.
        </li>
        <li id="ref-Groth10">
          <span class="text-gray-500">[Groth10]</span>
          Jens Groth. &ldquo;Short Pairing-based
          Non-interactive Zero-knowledge Arguments&rdquo;. In:
          <em>ASIACRYPT 2010</em>, pp. 321&ndash;340, 2010.
        </li>
        <li id="ref-Kilian92">
          <span class="text-gray-500">[Kilian92]</span>
          Joe Kilian. &ldquo;A Note on Efficient
          Zero-knowledge Proofs and Arguments (Extended
          Abstract)&rdquo;. In: <em>STOC 1992</em>,
          pp. 723&ndash;732, 1992.
        </li>
        <li id="ref-KimBar15">
          <span class="text-gray-500">[KimBar15]</span>
          Taechan Kim and Razvan Barbulescu. &ldquo;Extended
          Tower Number Field Sieve: A New Complexity for the Medium
          Prime Case&rdquo;. Cryptology ePrint Archive, Report
          2015/1027, 2015.
        </li>
        <li id="ref-Kosba+16">
          <span class="text-gray-500">[Kosba+16]</span>
          Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen,
          and Charalampos Papamanthou. &ldquo;Hawk: The Blockchain
          Model of Cryptography and Privacy-preserving Smart
          Contracts&rdquo;. In: <em>IEEE S&amp;P 2016</em>,
          pp. 839&ndash;858, 2016.
        </li>
        <li id="ref-Lipmaa12">
          <span class="text-gray-500">[Lipmaa12]</span>
          Helger Lipmaa. &ldquo;Progression-free Sets and
          Sublinear Pairing-based Non-interactive Zero-knowledge
          Arguments&rdquo;. In: <em>TCC 2012</em>,
          pp. 169&ndash;189, 2012.
        </li>
        <li id="ref-Lipmaa13">
          <span class="text-gray-500">[Lipmaa13]</span>
          Helger Lipmaa. &ldquo;Succinct Non-interactive Zero
          Knowledge Arguments from Span Programs and Linear
          Error-correcting Codes&rdquo;. In:
          <em>ASIACRYPT 2013</em>, pp. 41&ndash;60, 2013.
        </li>
        <li id="ref-MenSarSin16">
          <span class="text-gray-500">[MenSarSin16]</span>
          Alfred Menezes, Palash Sarkar, and Shashank Singh.
          &ldquo;Challenges with Assessing the Impact of NFS
          Advances on the Security of Pairing-based
          Cryptography&rdquo;. Cryptology ePrint Archive, Report
          2016/1102, 2016.
        </li>
        <li id="ref-Micali00">
          <span class="text-gray-500">[Micali00]</span>
          Silvio Micali. &ldquo;Computationally Sound
          Proofs&rdquo;. In: <em>SIAM J. Comput.</em>,
          30(4):1253&ndash;1298, 2000.
        </li>
        <li id="ref-Parno+13">
          <span class="text-gray-500">[Parno+13]</span>
          Bryan Parno, Craig Gentry, Jon Howell, and Mariana
          Raykova. &ldquo;Pinocchio: Nearly Practical Verifiable
          Computation&rdquo;. In: <em>IEEE S&amp;P 2013</em>,
          pp. 238&ndash;252, 2013.
        </li>
        <li id="ref-Peck16">
          <span class="text-gray-500">[Peck16]</span>
          Morgen E. Peck. &ldquo;The Crazy Security Behind the
          Birth of Zcash, the Inside Story&rdquo;.
          <a
            href="https://spectrum.ieee.org/tech-talk/computing/networks/the-crazy-security-behind-the-birth-of-zcash"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >IEEE Spectrum</a>, December 2016.
        </li>
        <li id="ref-EthTeam17">
          <span class="text-gray-500">[EthTeam17]</span>
          Ethereum Team. &ldquo;Byzantium HF
          Announcement&rdquo;.
          <a
            href="https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >blog.ethereum.org</a>, October 2017.
        </li>
      </ul>
    </section>

  </article>
</BaseLayout>
