---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/1018';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Algebraic Algorithms for LWE';
const AUTHORS_HTML = 'Martin R.  Albrecht, Carlos Cid, Jean-Charles Faugère, Ludovic Perret';

const CONTENT = `    <p class="text-gray-300">Martin R. Albrecht<span class="math">^{1}</span>, Carlos Cid<span class="math">^{1}</span>, Jean-Charles Faugère<span class="math">^{2}</span>, and Ludovic Perret<span class="math">^{2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Information Security Group Royal Holloway, University of London Egham, Surrey TW20 0EX, United Kingdom</p>

    <p class="text-gray-300"><span class="math">^{2}</span> INRIA, Paris-Rocquencourt Center, POLSYS Project UPMC Univ Paris 06, UMR 7606, LIP6, F-75005, Paris, France CNRS, UMR 7606, LIP6, F-75005, Paris, France martin.albrecht@rhul.ac.uk, carlos.cid@rhul.ac.uk, jean-charles.faugere@inria.fr, ludovic.perret@lip6.fr</p>

    <p class="text-gray-300">Abstract. The Learning with Errors (LWE) problem, proposed by Regev in 2005, has become an ever-popular cryptographic primitive, due mainly to its simplicity, flexibility and convincing theoretical arguments regarding its hardness. Among the main proposed approaches to solving LWE instances — namely, lattice algorithms, combinatorial algorithms, and algebraic algorithms — the last is the one that has received the least attention in the literature, and is the focus of this paper. We present a detailed and refined complexity analysis of the original Arora-Ge algorithm, which reduced LWE to solving a system of high-degree, error-free polynomials. Moreover, we generalise their method and establish the complexity of applying Gröbner basis techniques from computational commutative algebra to solving LWE. As a result, we show that the use of Gröbner basis algorithms yields an exponential speed-up over the basic Arora-Ge algorithm. On the other hand, our results show that such techniques do not yield a subexponential algorithm for the LWE problem.</p>

    <p class="text-gray-300">We also apply our algebraic algorithm to the BinaryError-LWE problem, which was recently introduced by Micciancio and Peikert. We show that BinaryError-LWE in dimension <span class="math">n</span> can be solved in subexponential time given access to a quasi-linear number of samples <span class="math">m</span> under a regularity assumption. We also give precise complexity bounds for BinaryError-LWE given access to linearly many samples. Our approach outperforms the best currently-known generic heuristic exact CVP solver as soon as <span class="math">m/n \\geq 6.6</span>.</p>

    <p class="text-gray-300">The results in this work depend crucially on the assumption that the encountered systems have no special structure. We give experimental evidence that this assumption holds and also prove the assumption in some special cases. Therewith, we also make progress towards proving Fröberg's long-standing conjecture from algebraic geometry.</p>

    <p class="text-gray-300">Learning with Errors. Since its introduction, the Learning with Errors problem (LWE) has proven to be a rich and versatile source of many innovative cryptographic constructions, such as the oblivious transfer protocol by Peikert et al. [37], a leakage-resilient cryptosystem by Akavia et al. [1], and homomorphic encryption [3, 15, 30], among many others.</p>

    <p class="text-gray-300">Definition 1 (LWE [38, 39]). Let <span class="math">n, m \\geq 1</span> be integers, <span class="math">q</span> be an odd positive integer, <span class="math">\\chi</span> be a probability distribution on <span class="math">\\mathbb{Z}_q</span> and <span class="math">\\mathbf{s} \\in \\mathbb{Z}_q^n</span> be a secret vector. We denote by <span class="math">L_{\\mathbf{s},\\chi}^{(n)}</span> the probability distribution on <span class="math">\\mathbb{Z}_q^{n \\times m} \\times \\mathbb{Z}_q^m</span> obtained by choosing <span class="math">A \\in \\mathbb{Z}_q^{n \\times m}</span> uniformly at random, sampling a vector <span class="math">\\mathbf{e} \\in \\mathbb{Z}_q^m</span> according to <span class="math">\\chi^m</span>, and returning <span class="math">(A, \\mathbf{s} \\cdot A + \\mathbf{e}) = (A, \\mathbf{c}) \\in \\mathbb{Z}_q^{n \\times m} \\times \\mathbb{Z}_q^m</span>. LWE is the problem of finding <span class="math">\\mathbf{s} \\in \\mathbb{Z}_q^n</span> from <span class="math">(A, \\mathbf{s} \\cdot A + \\mathbf{e})</span> sampled according to <span class="math">L_{\\mathbf{s},\\chi}^{(n)}</span>.</p>

    <p class="text-gray-300">In what follows, <span class="math">\\chi_{\\alpha,q}</span> will denote a discrete Gaussian distribution over <span class="math">\\mathbb{Z}</span> which returns an integer <span class="math">x</span> with probability <span class="math">\\exp\\left(-\\pi x^2 / s^2\\right) / \\sum_{y \\in \\mathbb{Z}} \\exp\\left(-\\pi y^2 / s^2\\right)</span>, where <span class="math">s = \\alpha q</span>, considered modulo <span class="math">q</span>. A typical setting is <span class="math">\\alpha q = n^\\epsilon</span>, with <span class="math">0 \\leq \\epsilon \\leq 1</span>. It has been shown that as soon as <span class="math">\\epsilon &amp;gt; 1/2</span>, worst-case GAPSVP<span class="math">_{\\tilde{\\mathcal{O}}(n/\\alpha)}</span> reduces to average-case LWE [14, 36, 38, 39]. Thus, any algorithm solving LWE for <span class="math">\\epsilon &amp;gt; 1/2</span> can solve GAPSVP<span class="math">_{\\tilde{\\mathcal{O}}(n/\\alpha)}</span>. It is widely believed that only exponential classical and quantum algorithms exist for solving GAPSVP<span class="math">_{\\tilde{\\mathcal{O}}(n/\\alpha)}</span>.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Arora and Ge’s algorithm</h4>

    <p class="text-gray-300">In <em>[5]</em>, Arora and Ge proposed the first algebraic algorithm to solve the LWE problem. Their approach reduces LWE to finding the common root of a multivariate system of high-degree, error-free polynomials. The proposed algorithm solves LWE in <span class="math">2^{\\tilde{\\mathcal{O}}(n^{2\\epsilon})}</span> operations, hence being sub-exponential when <span class="math">\\epsilon&lt;\\frac{1}{2}</span>. This shows that Regev’s original reduction in <em>[38, 39]</em> is indeed tight.</p>

    <p class="text-gray-300">In more detail, let <span class="math">(\\mathbf{a},c)\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> be an LWE sample and write <span class="math">f=c-\\sum_{i=1}^{n}\\mathbf{a}_{i}\\cdot x_{i}</span> where the <span class="math">x_{i}</span> are variables. If we assume that the error <span class="math">e</span> is in the interval <span class="math">\\{-T,\\ldots,T\\}</span>, then the polynomial <span class="math">F=f\\cdot\\prod_{i=1}^{T}(f+i)\\cdot(f-i)</span> of degree <span class="math">2T+1</span> evaluates to zero when <span class="math">x_{i}=s_{i}</span>. Thus, if <span class="math">T&lt;\\lfloor q/2\\rfloor</span> then <span class="math">F=0</span> is a constraint on the possible values for the secret vector <span class="math">\\mathbf{s}</span>, and collecting many such equations and solving the resulting multivariate high-degree system of equations allows to recover the secret. In <em>[5]</em> these systems are solved by the linearisation method, i.e. first replacing monomials with a new linearised variable and then by solving the resulting linear system of equations. This method requires <span class="math">\\mathcal{O}\\left(n^{2T+1}\\right)</span> equations to succeed, which could be obtained by collecting more samples. However, since <span class="math">\\chi_{\\alpha,q}</span> is a discrete Gaussian distribution, requesting more samples also increases the probability that the noise of at least one sample falls outside of the chosen interval <span class="math">\\{-T,\\ldots,T\\}</span> invalidating the constraint <span class="math">F=0</span>. Hence, as the number of samples grows so does the required value of <span class="math">T</span> so that the polynomial system remains error-free. This on the other hand may require a further increase in the number of samples (cf. Section 3). This trade-off is analysed in <em>[5]</em> to obtain the complexity of the Arora-Ge algebraic algorithm to solve LWE. We note however that the discussion above implies that the algorithm from <em>[5]</em> is not applicable if the number of available samples is smaller than <span class="math">\\mathcal{O}\\left(n^{2T+1}\\right)</span>.</p>

    <p class="text-gray-300">In Section 4, we make a detailed analysis of the original Arora-Ge algorithm, and derive the precise complexity of applying linearisation as described above. The results of our analysis are given in the following theorem.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Result 1</h6>

    <p class="text-gray-300">Let <span class="math">n,q,\\sigma=\\alpha q/\\sqrt{2\\pi}</span> be parameters of an <span class="math">\\mathrm{LWE}_{\\chi_{\\alpha,q}}</span> instance, <span class="math">2\\leq\\omega&lt;3</span> be the linear algebra constant and <span class="math">D_{\\mathrm{AG}}=8\\,\\sigma^{2}\\log n+1</span>.</p>

    <p class="text-gray-300">If <span class="math">D_{\\mathrm{AG}}\\in o(n)</span> then the Arora-Ge algorithm solves the computational LWE problem in</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{\\,\\omega\\cdot D_{\\mathrm{AG}}\\log\\frac{n}{D_{\\mathrm{AG}}}}\\cdot\\sigma\\,q\\log q\\right)=\\mathcal{O}\\left(2^{\\,8\\,\\omega\\,\\sigma^{2}\\log n(\\log n-\\log(8\\,\\sigma^{2}\\log n))}\\cdot\\mathrm{poly}(n)\\right)</span></p>

    <p class="text-gray-300">operations and in</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{\\,\\omega\\cdot n\\log\\frac{D_{\\mathrm{AG}}}{n}}\\cdot\\sigma\\,q\\log q\\right)=\\mathcal{O}\\left(2^{\\,\\omega\\,n\\log(8\\,\\sigma^{2}\\log n)-\\omega\\,n\\log n}\\cdot\\mathrm{poly}(n)\\right)</span></p>

    <p class="text-gray-300">operations if <span class="math">n\\in o(\\sigma^{2}\\log(n))</span>.</p>

    <p class="text-gray-300">Specialising to <span class="math">\\sigma=\\sqrt{n}</span> we obtain a complexity of <span class="math">\\mathcal{O}\\left(2^{(2+\\epsilon)\\omega n\\log\\log n}\\right)</span>. Our results shows that, in this case, the original Arora-Ge algorithm is asymptotically slower than the BKW algorithm <em>[2]</em> and lattice reduction if sieving is used to implement the SVP oracle, but asymptotically faster than lattice reduction if enumeration is used to implement the SVP oracle <em>[4]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Gröbner bases</h4>

    <p class="text-gray-300">Gröbner bases are fundamental tools in commutative algebra and algebraic geometry. A Gröbner basis <span class="math">G</span> for an ideal <span class="math">\\mathcal{I}</span> in a polynomial ring is a basis such that any leading term of any element in the ideal <span class="math">\\mathcal{I}</span> is divisible by a leading term of an element in <span class="math">G</span>. In univariate polynomial rings the notion of a Gröbner basis coincides with the greatest common divisor; for linear polynomials it coincides with the notion of a row echelon form. Gröbner bases go back to the seminal work of Buchberger <em>[16, 17, 19]</em> who also gave a first algorithm for computing them by showing that repeated computation and reduction of S-polynomials computes a Gröbner basis. Gröbner basis algorithms have been frequently applied (successfully) on the algebraic cryptanalysis of a range of cryptographic schemes <em>[27]</em>.</p>

    <p class="text-gray-300">In this work we are interested in the fact that Gröbner bases allow to find all common roots of multivariate polynomial systems. Indeed, the linearisation approach described above is a special case of a Gröbner basis computation. In contrast to this special case, though, general Gröbner basis algorithms are also applicable if less than <span class="math">\\mathcal{O}\\left(n^{d}\\right)</span> polynomials of degree <span class="math">d</span> are available – at the cost of increased computational complexity. We give more background on Gröbner bases in Section 2.</p>

    <p class="text-gray-300">In Section 5 we show that applying standard Gröbner basis algorithms yields an exponential speed-up for solving <span class="math">\\mathrm{LWE}</span> compared to Result 1, under a regularity assumption. In particular, we arrive at the following theorem.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Result 2</h6>

    <p class="text-gray-300">Let <span class="math">\\omega</span> be the linear algebra constant, let <span class="math">H_{2}(x)=-x\\log_{2}(x)-(1-x)\\log_{2}(1-x)</span> be the binary entropy function and <span class="math">C</span> some known constant which can be explicitly computed. Let <span class="math">\\left(\\mathbf{a}_{i},b_{i}\\right)_{i\\geq 1}</span> be elements of <span class="math">\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> sampled according to <span class="math">\\mathrm{LWE}_{\\chi_{\\alpha,q}}</span> with a standard deviation <span class="math">\\sigma=\\frac{\\sqrt{n}}{\\sqrt{2\\pi}}</span>. There is an algorithm solving the computational <span class="math">\\mathrm{LWE}</span> problem in</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{n\\left(\\omega\\left(1+C\\right)H_{2}\\left(\\frac{C}{1+C}\\right)+\\frac{\\pi\\cdot\\log_{2}(x)}{4}\\right)}\\right)</span> (1)</p>

    <p class="text-gray-300">operations with success probability of at least <span class="math">1-\\frac{2}{\\pi\\sqrt{n}}=1-o(1)</span>, if the system of equations encountered during the execution of the algorithm is semi-regular.</p>

    <p class="text-gray-300">Hence, applying Gröbner basis algorithms gives an exponential speed-up over the algorithm from <em>[5]</em>. This places it in the same complexity class as the BKW algorithm or lattice reduction when sieving implements the SVP oracle, albeit with a larger leading constant in the exponent. It is worth noting that all known algorithms for achieving time complexity <span class="math">2^{\\mathcal{O}(n)}</span> – BKW, sieving, Gröbner bases – also require <span class="math">2^{\\mathcal{O}(n)}</span> memory.</p>

    <p class="text-gray-300">BinaryError-<span class="math">\\mathrm{LWE}</span>. A variant of LWE with errors values in <span class="math">\\{0,1\\}</span> (or any uniform range) was recently introduced by Micianccio and Peikert in <em>[35]</em>. This generalises an earlier result of Döttling and Müller-Quade <em>[22]</em> who first introduced a variant of <span class="math">\\mathrm{LWE}</span> with uniform errors whilst keeping a strong security reduction to lattice problems. These two works highlight the current interest of the cryptographic community in studying variants of <span class="math">\\mathrm{LWE}</span> with small non-Gaussian errors. From a practical perspective these variants are interesting because they allow to forgoe Gaussian sampling (with large parameters) which is often the most expensive step when implementing lattice-based cryptography. In this regard <em>[35]</em> represents a significant step forward as it allows to sample the error from a binary distribution while still regaining a reduction to <span class="math">\\mathrm{GapSVP}_{.}</span> albeit with a severe limit on the number of samples <span class="math">m</span>:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1 (BinaryError-<span class="math">\\mathrm{LWE}</span> <em>[35]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">n,m=n\\left(1+\\frac{1}{c\\log(n)}\\right)</span> for <span class="math">c&gt;1</span> be integers, and <span class="math">q\\geq n^{\\mathcal{O}(1)}</span> be a sufficiently large polynomially bounded (prime) modulus. Then, solving LWE with parameters <span class="math">n,m,q</span> and independent uniformly random binary errors is at least as hard as approximating lattice problems in the worst-case on <span class="math">\\Theta\\big{(}n/\\log(n)\\big{)}</span> -dimensional lattices within a factor <span class="math">\\tilde{\\mathcal{O}}(\\sqrt{n}\\cdot q)</span>.</p>

    <p class="text-gray-300">As already pointed out in <em>[22, 35]</em>, the algorithm from <em>[5]</em> yields a polynomial-time algorithm for solving BinaryError-<span class="math">\\mathrm{LWE}</span> as soon as <span class="math">m=\\mathcal{O}\\left(n^{2}\\right)</span>. Hence, there is a gap between <span class="math">m=n\\left(1+\\frac{1}{c\\log(n)}\\right)</span> for <span class="math">c&gt;1</span>, where the hardness reduces to standard LWE, and <span class="math">m=\\mathcal{O}\\left(n^{2}\\right)</span> where the problem is known to be easy due to the Arora-Ge algorithm. However, understanding the hardness of the problem for samples within this interval should be of great interest: applications in lattice-based cryptography typically require the provision of <span class="math">n\\left(1+\\frac{1}{c\\log(n)}\\right)&lt;m&lt;\\mathcal{O}\\left(n^{2}\\right)</span> samples, e.g. <span class="math">m=\\mathcal{O}\\left(n\\right)</span> or <span class="math">m=\\tilde{\\mathcal{O}}(n)</span>. It is hence a natural and relevant open question how the security of BinaryError-<span class="math">\\mathrm{LWE}</span> degrades as more samples are made available.</p>

    <p class="text-gray-300">From <em>[5]</em> and our generalisation using Gröbner basis algorithms, it follows that the complexity of solving LWE with uniform errors in <span class="math">\\{-T,\\ldots,T\\}</span> is at most the cost of computing a Gröbner basis for <span class="math">m</span> polynomials of degree <span class="math">2T+1</span> in <span class="math">n</span> variables. In Section 6, we show – under a similar regularity assumption as above – that BinaryError-LWE can be solved in sub-exponential time as soon as the number of samples is quasi-linear, e.g. <span class="math">m=\\mathcal{O}\\left(n\\log\\log n\\right)</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Result 3</h6>

    <p class="text-gray-300">Let <span class="math">\\omega</span> be the linear algebra constant and let <span class="math">H_{2}(x)=-x\\log_{2}(x)-(1-x)\\log_{2}(1-x)</span> be the binary entropy function. If <span class="math">m=\\mathcal{O}\\left(n\\log\\log n\\right)</span>, then there exists an algorithm which solves the BinaryError-<span class="math">\\mathrm{LWE}</span> problem in</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(m^{2}\\,2^{\\frac{n\\cdot n\\,\\log\\log\\log n}{8\\log\\log n}}\\right)</span></p>

    <p class="text-gray-300">operations if the equation system encountered in the execution of the algorithm is semi-regular.</p>

    <p class="text-gray-300">If <span class="math">m=C\\cdot n</span>, with <span class="math">C\\geq 1</span>, then there exists an algorithm which solves the BinaryError-LWE problem in</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(n^{2}\\,2^{\\omega\\,n(1+\\beta)\\,H_{2}\\left(\\frac{\\beta}{1+\\beta}\\right)}\\right)</span></p>

    <p class="text-gray-300">operations with with <span class="math">\\beta=\\left(C-\\frac{1}{2}-\\sqrt{C(C-1)}\\right)</span> if the system of equations encountered during the execution of the algorithm is semi-regular.</p>

    <p class="text-gray-300">More concretely, the algorithm discussed in this paper can solve the BinaryError-LWE problem in dimension <span class="math">n</span> in time <span class="math">n^{2}\\cdot 2^{0.344\\,n}</span> as soon as <span class="math">m\\geq 6.6\\,n</span>. For comparison, the best currently-known generic exact CVP solver <em>[11]</em> takes time <span class="math">2^{0.377\\,n}</span>. We note that many other LWE solving strategies such as combinatorial algorithms <em>[2]</em> or lattice reduction in the low advantage regime <em>[34]</em> do not apply in this setting.</p>

    <p class="text-gray-300">Our results (Theorem 7, Section 6) show therefore that, despite its attractive implementation features, BinaryError-LWE should be ruled out for cryptographic applications that require a quasi-linear number of samples. Finally we note that while our results can also apply to the natural generalisations of BinaryError-LWE to any uniform error in a bounded interval <span class="math">\\{-T,\\ldots,T\\}</span> <em>[35, Theorem 4.6]</em>, in this paper we focus on the BinaryError-LWE case for brevity.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Regularity Assumptions.</h4>

    <p class="text-gray-300">Our complexity estimates depend crucially on two algebraic assumptions about the systems we consider. The assumption is as follows for BinaryError-LWE:</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Assumption 2.</h6>

    <p class="text-gray-300">Let <span class="math">(A,\\mathbf{s}\\cdot A+\\mathbf{e})=(A,\\mathbf{c})\\in\\mathbb{Z}_{q}^{n\\times m}\\times\\mathbb{Z}_{q}^{m}</span> be sampled according to <span class="math">L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}</span>, and let <span class="math">P(x)=X(X-1)</span>. We define:</p>

    <p class="text-gray-300"><span class="math">f_{1}=P\\big{(}c_{1}-\\sum_{j=1}^{n}s_{j}A_{j,1}\\big{)}=0,\\,\\,\\ldots\\,,f_{m}=P\\big{(}c_{m}-\\sum_{j=1}^{n}s_{j}A_{j,m}\\big{)}=0.</span></p>

    <p class="text-gray-300">It holds that <span class="math">\\langle f_{1},\\ldots,f_{m}\\rangle</span> is semi-regular (Definition 2, Section 2), i.e. has only trivial algebraic dependencies.</p>

    <p class="text-gray-300">For general LWE, Assumption 1 is similar but we consider a polynomial <span class="math">P(X)=X\\prod_{i=1}^{C_{\\mathrm{GB}}\\cdot\\sigma}(X+i)(X-i)</span>, where <span class="math">C_{\\mathrm{GB}}</span> depends on the parameters of the Gaussian distribution.</p>

    <p class="text-gray-300">It is believed that random systems of equations are semi-regular. Hence, our semi-regularity assumptions essentially state that our systems are neither easier nor harder to solve than random systems of equations.</p>

    <p class="text-gray-300">If the systems considered in this work were easier than random systems this would imply that the analysis of Section 5 could be much improved and lead to progress towards a sub-exponential classical algorithm for solving GapSVP. On the other hand, if these systems were harder to solve than random systems, this would reveal new algebraic dependencies amongst LWE samples, which could likely also be used to improve (non-algebraic) solving strategies. Hence, our assumption in this paper that there is no special structure in our problem instances seems to be a reasonable one. We note also that Gröbner basis algorithms do not rely on this regularity assumption. Indeed, they have been successfully used in the past to exploit that a problem instance which does not behave like a semi-regular sequence <em>[27]</em>.</p>

    <p class="text-gray-300">Section 7.1 reports on our experimental verification that Assumptions 1 and 2 hold for reasonable parameter sets. For example, for BinaryError-LWE, we have verified them for <span class="math">n\\leq 100</span>.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Fröberg’s Conjecture.</h4>

    <p class="text-gray-300">Our assumptions are closely related to the long-standing Fröberg conjecture <em>[28]</em> in algebraic geometry which states that semi-regular sequences form a dense subset among the set of all sequences. More precisely, the Fröberg conjecture states that generically the rank of some linear map associated to Macaulay matrices (the matrices occurring in a Gröbner basis computation) is maximal. A property is said to be generic if it holds on a Zariski open subset <span class="math">Z_{O}</span> when the characteristic of the base field <span class="math">\\mathbb{K}</span> is <span class="math">0</span>. In Zariski’s topology, a closed subset is defined as the vanishing set of algebraic equations. Hence, we can find a polynomial <span class="math">h(\\mathbf{a})</span> in <span class="math">\\mathbb{Z}[\\mathbf{a}]</span> which does not depend on the field <span class="math">\\mathbb{K}</span> such that <span class="math">h(\\mathbf{a})\\neq 0\\Rightarrow\\mathbf{a}\\in Z_{O}</span>.</p>

    <p class="text-gray-300">The main difficulty in proving Fröberg’s conjecture is to prove that the polynomial <span class="math">h</span> is not identically zero or that <span class="math">Z_{O}</span> is not empty (see <em>[29]</em>).</p>

    <p class="text-gray-300">To prove Fröberg’s conjecture it is sufficient to find one explicit family of polynomials which can be proven semi-regular for any <span class="math">m</span> and <span class="math">n</span>. Proving Assumptions 1 or 2 would provide such family and hence prove Fröberg’s conjecture. Furthermore, any non-trivial partial results on our assumptions would lead to progress on the general Fröberg’s conjecture. over a sufficiently big finite field, sequences with the same number of polynomials (<span class="math">m</span>) and same number of variables (<span class="math">n</span>), <span class="math">m=n+1</span> in characteristic <span class="math">0</span>, <span class="math">m</span> polynomials of degree <span class="math">2</span> with <span class="math">n\\leq 11</span>, and <span class="math">m</span> polynomials of degree <span class="math">3</span> with <span class="math">n\\leq 8</span> <em>[20, 28, 29]</em>. Indeed, Fröberg and Hollman <em>[29]</em> already investigated semi-regularity for powers of generic linear forms. In characteristic <span class="math">0</span>, <em>[29, Lemma 2.1]</em> proves that a sequence of <span class="math">n+1</span> squares of generic linear forms in <span class="math">n</span> variables is generically semi-regular.</p>

    <p class="text-gray-300">In Section 7 we report on progress towards proving Fröberg conjecture by investigating our assumptions. In Theorem 8 (Section A.2), we first prove that the equations <span class="math">f_{1},\\ldots,f_{m}</span> generated for BinaryError-LWE are linearly independent with high probability. Secondly, we show that the sequence <span class="math">f_{1},\\ldots,f_{m}</span> is semi-generic (Definition 3), i.e. <span class="math">\\{x_{i}\\cdot f_{j}\\}_{1\\leq i\\leq n}^{1\\leq j\\leq n}</span> spans a vector space of maximal dimension. We prove that such algebraic independence at low degree holds with <span class="math">m\\leq n+\\lfloor\\frac{n-2}{2}\\rfloor</span> in Theorem 10. This improves on a result of <em>[29, Theorem 2.2]</em> where Fröberg and Hollman proved that the squares of <span class="math">m</span> generic linear forms are semigeneric as long as <span class="math">m\\leq n+15</span> and <span class="math">n\\leq 6</span>. Finally, we consider algebraic independence at higher degree and prove in Theorem 11 that BinaryError-LWE samples give rise to a semi-regular sequence with high probability for <span class="math">m=n+1</span> and for a sufficiently large field.</p>

    <p class="text-gray-300">In closing, we note that Fröberg’s conjecture is similar in spirit to the Gaussian Heuristic often relied on in the complexity analysis of lattice-reduction algorithms. For example, the complexity analysis of the currently best know heuristic CVP solver <em>[11]</em> mentioned above and predictions for the quality of output for the BKZ algorithm <em>[18]</em> rely on it. Where Fröberg’s conjecture asserts that most ideals have a predictable degree of regularity, i.e. no special structure deviating from this expectation, the Gaussian Heuristic asserts that for most lattices the shortest vectors of random lattices have a predictable norm, i.e. no special structure deviating from this expectation.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Open problems.</h4>

    <p class="text-gray-300">While computational commutative algebra provides a rich resource to improve on the results in <em>[5]</em> for solving LWE and variants thereof, our results indicate that it is unlikely that sub-exponential algorithms for solving LWE can be found by directly applying standard Gröbner basis algorithms to LWE. A promising avenue, however, is to combine geometric with algebraic techniques to improve our understanding of the hardness of LWE. Secondly, applying algebraic techniques to Ring-LWE, which offers a much richer algebraic structure, is an area for future work.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Computation of Gröbner Bases</h2>

    <p class="text-gray-300">Lazard <em>[32]</em> showed that computing a Gröbner basis for a system of homogeneous polynomials <span class="math">f_{1}\\ldots,f_{m}</span> is equivalent to perform Gaussian elimination on the <em>Macaulay matrices</em> <span class="math">\\mathcal{M}_{d,m}^{\\mathrm{acaulay}}</span> for <span class="math">d</span>, where <span class="math">\\min\\big{(}\\deg(f_{1}),\\ldots,\\deg(f_{m})\\big{)}\\leq d\\leq D</span> for some integer <span class="math">D</span>. The Macaulay matrix <span class="math">\\mathcal{M}_{d,m}^{\\mathrm{acaulay}}</span> for a set of homogeneous polynomials <span class="math">f_{1}\\ldots,f_{m}</span> is defined as the coefficient matrix of <span class="math">(t_{i,j}\\cdot f_{i})</span> where <span class="math">1\\leq i\\leq m</span> and <span class="math">t_{i,j}</span> runs through all monomials of degree <span class="math">d-\\deg(f_{i})</span>. It can be shown that Macaulay matrices up to degree <span class="math">d</span> can be used to compute a partial Gröbner basis, called <span class="math">d</span>-Gröbner basis. Lazard showed that for <span class="math">d</span> big enough, a <span class="math">d</span>-Gröbner basis is indeed a Gröbner basis:</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Theorem 2 (<em>[32]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">q</span> be a prime and let <span class="math">\\mathbf{f}=(f_{1},\\ldots,f_{m})\\in\\left(\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]\\right)^{m}</span> be homogeneous polynomials and <span class="math">\\prec</span> be a monomial ordering. There exists a positive integer <span class="math">D</span> for which Gaussian elimination on all <span class="math">\\mathcal{M}_{d,m}^{\\mathrm{acaulay}}(f_{1},\\ldots,f_{m})</span> matrices for <span class="math">d,1\\leq d\\leq D</span> computes a Gröbner basis of <span class="math">\\langle f_{1},\\ldots,f_{m}\\rangle</span> w.r.t. to <span class="math">\\prec</span>.</p>

    <p class="text-gray-300">It follows that the complexity of computing a Gröbner basis is bounded by the complexity of performing Gaussian elimination on the Macaulay matrices up to some degree <span class="math">D</span>. In general, computing the maximum degree occurring in a Gröbner computation is a difficult problem. However, for a specific family of polynomial systems this degree is known <em>[6, 7, 8, 10]</em>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2 (Semi-regular Sequence <em>[8, 10]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">m\\geq n</span>, and <span class="math">f_{1},\\ldots,f_{m}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span> be homogeneous polynomials of degrees <span class="math">d_{1},\\ldots,d_{m}</span> respectively and <span class="math">\\mathcal{I}</span> the ideal generated by these polynomials. The system is said to be a <em>semi-regular sequence</em> if the Hilbert polynomial <em>[19]</em> associated to <span class="math">\\mathcal{I}</span> w.r.t. the grevlex order is:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{HP}(z)=\\left[\\frac{\\prod_{i=1}^{m}(1-z^{d_{i}})}{(1-z)^{n}}\\right]_{+},</span> (2)</p>

    <p class="text-gray-300">with <span class="math">[S]_{+}</span> being the polynomial obtained by truncating the series <span class="math">S</span> before the index of its first non-positive coefficient. We shall call degree of regularity of a semi-regular sequence the quantity:</p>

    <p class="text-gray-300"><span class="math">1+\\deg\\left(\\mathrm{HP}(z)\\right).</span></p>

    <p class="text-gray-300">This degree of regularity is the degree <span class="math">D</span> involved in Theorem 2 for a semi-regular sequence.</p>

    <p class="text-gray-300">Finally, let <span class="math">f_{1},\\ldots,f_{m}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span> be a sequence of affine polynomials. We denote by <span class="math">f_{1}^{\\mathrm{H}},\\ldots,f_{m}^{\\mathrm{H}}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span> the corresponding homogeneous components of highest degree. We shall say that <span class="math">f_{1},\\ldots,f_{m}</span> is semi-regular if the sequence <span class="math">f_{1}^{\\mathrm{H}},\\ldots,f_{m}^{\\mathrm{H}}</span> is semi-regular.</p>

    <p class="text-gray-300">Throughout this paper, we will use the following complexity results about computing Gröbner bases for semi-regular sequences.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 1 (adapted from <em>[9]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{F}=(f_{1},\\ldots,f_{m})\\in\\left(\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]\\right)^{m}</span> be affine polynomials with <span class="math">m&gt;n</span>. If <span class="math">f_{1},\\ldots,f_{m}</span> is semi-regular, then the number of operations in <span class="math">\\mathbb{Z}_{q}</span> required to compute a Gröbner basis for any admissible order is bounded by:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(m\\,D_{reg}\\left(\\genfrac{}{}{0.0pt}{}{n+D_{reg}}{D_{reg}}\\right)^{\\omega}\\right),\\text{as }D_{reg}\\to\\infty,</span> (3)</p>

    <p class="text-gray-300">where <span class="math">2\\leq\\omega&lt;3</span> is the linear algebra constant and <span class="math">D_{reg}</span> is the degree of regularity of <span class="math">\\langle f_{1},\\ldots,f_{m}\\rangle</span>.</p>

    <p class="text-gray-300">In general, (3) only holds for the <em>grevlex</em> monomial ordering, but efficient algorithms exist to convert a Gröbner basis from one ordering to another <em>[26]</em>. However, in our case where <span class="math">m&gt;n</span> we expect a unique solution which implies the Gröbner bases with respect to all monomial orderings are identical and the issue does not arise (cf. <em>[12]</em>).</p>

    <p class="text-gray-300">The complexity bound (3) is pessimistic as we do not take the particular structure of the matrices involved into account. Typically, Macaulay matrices have huge rank defects which correspond to useless computations. More recent algorithms such as <span class="math">\\mathrm{F}_{4}</span> <em>[23]</em> and <span class="math">\\mathrm{F}_{5}</span> <em>[24]</em> take advantage of the structure of Macaulay matrices and avoid some or all of these useless computations. This leads to considerable speed-ups in practice <em>[25, 27]</em> and in theory <em>[9]</em>. However, to simplify the asymptotical analysis we apply Theorem 2 which performs row reductions on Macaulay matrices.</p>

    <p class="text-gray-300">The following classical approximation of the binomial coefficient due to Stirling will be useful to prove some of our results below.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">H_{2}(x)=-x\\log_{2}(x)-(1-x)\\log_{2}(1-x)</span> be the binary entropy. For <span class="math">n</span> and <span class="math">k</span> large enough, we have <span class="math">\\log_{2}\\binom{n}{k}\\approx n\\,H_{2}\\binom{k}{n}</span>.</p>

    <p class="text-gray-300">Similarly, we have the following lemma.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">\\[ \\log\\left(\\genfrac{}{}{0.0pt}{}{n+D}{D}\\right)\\approx\\left\\{\\begin{array}[]{l}D\\log(n/D),\\,\\,\\text{if}\\,D\\in o(n),\\\\ \\\\ n\\log(D/n),\\,\\,\\text{if}\\,n\\in o(D).\\end{array}\\right. \\]</p>

    <p class="text-gray-300">This follows easily from Stirling’s expansion of the binomial.</p>

    <p class="text-gray-300">3 The Arora & Ge Algorithm</p>

    <p class="text-gray-300">The Arora & Ge algorithm proceeds by generating a non-linear system of (error-free) multivariate equations from LWE samples by making use of the following well-known fact about the Gaussian distribution.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\chi</span> denote the Gaussian distribution with standard deviation <span class="math">\\sigma</span>. Furthermore, for <span class="math">x&gt;0</span>, we denote <span class="math">Q(x)=\\frac{1}{2}\\left(1-\\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right)</span>. Then, for all <span class="math">C&gt;0</span>, it holds that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\textup{Pr}[e\\stackrel{{\\scriptstyle\\mathfrak{s}}}{{\\leftarrow}}\\chi:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>C\\cdot\\sigma]\\approx 2\\times Q(C)\\leq\\frac{2}{C\\sqrt{2\\pi}}e^{-C^{2}/2}\\in e^{\\mathcal{O}\\left(-C^{2}\\right)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">That is, for a <span class="math">C&gt;0</span>, elements sampled from a Gaussian distribution take only values on the interval <span class="math">[-C\\cdot\\sigma,\\ldots,C\\cdot\\sigma]</span> of <span class="math">\\mathbb{Z}_{q}</span> with probability at least <span class="math">1-e^{\\mathcal{O}\\left(-C^{2}\\right)}</span> if we represent elements in <span class="math">\\mathbb{Z}_{q}</span> as integers in <span class="math">[-\\lfloor\\frac{q}{2}\\rfloor,\\ldots,\\lfloor\\frac{q}{2}\\rfloor]</span>. Moreover, if <span class="math">e\\stackrel{{\\scriptstyle\\mathfrak{s}}}{{\\leftarrow}}\\chi</span> then <span class="math">P(e)=0</span> for</p>

    <p class="text-gray-300"><span class="math">P(X)=X\\prod_{i=1}^{C\\cdot\\sigma}(X+i)(X-i),</span></p>

    <p class="text-gray-300">with probability at least <span class="math">1-e^{\\mathcal{O}\\left(-C^{2}\\right)}</span>. Clearly <span class="math">P</span> is of degree <span class="math">2\\,C\\cdot\\sigma+1\\in\\mathcal{O}\\left(C\\cdot\\sigma\\right)</span>.</p>

    <p class="text-gray-300">It follows that if <span class="math">(\\mathbf{a}_{i},b_{i})=(\\mathbf{a}_{i},\\langle\\mathbf{a}_{i},\\mathbf{s}\\rangle+e_{i})\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span>, and <span class="math">e_{i}\\stackrel{{\\scriptstyle\\mathfrak{s}}}{{\\leftarrow}}\\chi</span>, then</p>

    <p class="text-gray-300"><span class="math">P\\big{(}-b+\\sum_{j=1}^{n}(\\mathbf{a}_{i})_{(j)}x_{j}\\big{)}=0,</span> (4)</p>

    <p class="text-gray-300">with probability at least <span class="math">1-e^{\\mathcal{O}\\left(-C^{2}\\right)}</span>. Each sample <span class="math">(\\mathbf{a}_{i},\\langle\\mathbf{a}_{i},\\mathbf{s}\\rangle+e_{i})=(\\mathbf{a}_{i},b_{i})\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> allows to generate a non-linear equation of degree <span class="math">2\\,C\\cdot\\sigma+1</span> in the <span class="math">n</span> components of the secret <span class="math">\\mathbf{s}</span> which holds with probability <span class="math">1-e^{\\mathcal{O}\\left(-C^{2}\\right)}</span>.</p>

    <p class="text-gray-300">The Arora & Ge algorithm then proceeds by generating <span class="math">M_{\\mathrm{AG}}</span> independent equations of the form (4), to be then solved by linearisation. However, a value for <span class="math">C</span> – denoted by <span class="math">C_{\\mathrm{AG}}</span> – occurring in Lemma 3 has to be chosen sufficiently large so that all errors <span class="math">e_{i}</span> lie with high probability in the interval <span class="math">[-C_{\\mathrm{AG}}\\cdot\\sigma,\\ldots,C_{\\mathrm{AG}}\\cdot\\sigma]\\subseteq\\mathbb{Z}_{q}</span>, i.e. such that the secret <span class="math">\\mathbf{s}</span> is indeed a common solution of the <span class="math">M_{\\mathrm{AG}}</span> equations. To this end, let <span class="math">\\mathcal{S}_{\\mathrm{AG}}</span> be the system of equations generated from <span class="math">M_{\\mathrm{AG}}</span> equations as in (4) and bound the probability of failure by the union bound:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p_{f}=M_{\\mathrm{AG}}\\times\\textup{Pr}[e\\stackrel{{\\scriptstyle\\mathfrak{s}}}{{\\leftarrow}}\\chi_{\\alpha,q}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>C_{\\mathrm{AG}}\\cdot\\sigma]\\leq\\frac{M_{\\mathrm{AG}}}{e^{\\mathcal{O}\\left(C_{\\mathrm{AG}}^{2}\\right)}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, <span class="math">p_{f}</span> is an upper bound on the probability that the secret <span class="math">\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}</span> is not a solution to <span class="math">\\mathcal{S}_{\\mathrm{AG}}</span> . Let also <span class="math">D_{\\mathrm{AG}}=2\\,C_{\\mathrm{AG}}\\,\\sigma+1</span> be the degree of the equations occuring in <span class="math">\\mathcal{S}_{\\mathrm{AG}}</span>. It is shown in <em>[5]</em> (cf. Section 4) that taking <span class="math">C_{\\mathrm{AG}}\\in\\tilde{\\mathcal{O}}(\\sigma)</span> allows us to make the probability of failure negligible.</p>

    <p class="text-gray-300">In summary, the Arora & Ge algorithm reduces solving LWE to linearisation of a system of <span class="math">M_{\\mathrm{AG}}</span> equations of degree <span class="math">D_{\\mathrm{AG}}=2\\,C_{\\mathrm{AG}}\\,\\sigma+1\\in\\tilde{\\mathcal{O}}(\\sigma^{2})</span>. In particular, the following theorem holds:</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 3 (<em>[5]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">D_{\\mathrm{AG}}&lt;q</span>. The system obtained by linearizing</p>

    <p class="text-gray-300"><span class="math">M_{\\mathrm{AG}}=\\mathcal{O}\\left(\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}\\right)^{\\omega}\\sigma\\,q\\log q</span> <span class="math">=n^{\\mathcal{O}(D_{\\mathrm{AG}})}=2^{\\tilde{\\mathcal{O}}(D_{\\mathrm{AG}})}</span></p>

    <p class="text-gray-300">equations as in (4) has at most one solution with high probability.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathcal{O}\\left(\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}\\right)</span> equations is sufficient to linearise the system. The extra factor <span class="math">\\sigma\\,q\\log q</span> allows to prove that the linearised system has at most one solution with high probability <em>[5]</em>. The overall complexity</p>

    <p class="text-gray-300">of the Arora-Ge algorithm is the cost of performing Gaussian elimination on a matrix of size <span class="math">M_{\\mathrm{AG}}\\times\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{\\mathrm{AG}}^{\\mathrm{plx}}=n^{\\mathcal{O}(D_{\\mathrm{AG}})}=2^{\\tilde{\\mathcal{O}}(\\sigma^{2})}=2^{\\tilde{\\mathcal{O}}(n^{2\\epsilon})}.</span></p>

    <p class="text-gray-300">Note also that, if we have the standard deviation <span class="math">\\sigma=n^{\\epsilon}</span>, then the algorithm requires <span class="math">2^{\\tilde{\\mathcal{O}}(n^{2\\epsilon})}</span> LWE samples for performing the linearisation step. It follows that the Arora & Ge algorithm is subexponential when <span class="math">\\epsilon&lt;1/2</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4 Refined Analysis of the Arora & Ge Algorithm</h2>

    <p class="text-gray-300">We note that the analysis above and in <em>[5]</em> leaves much room for improvements, as it hides not only constants <em>in the exponent</em> but also logarithm factors. In this section, we make a more refined analysis of the complexity of the Arora & Ge algorithm when using the linearisation method, so that we can then compare potential improvements due to the application of Gröbner bases in Section 5.</p>

    <p class="text-gray-300">As established in the previous section, the overall complexity of solving an LWE instance with the Arora & Ge algorithm is that of executing Gaussian elimination on a matrix of size <span class="math">M_{\\mathrm{AG}}\\times\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}</span>. Gaussian elimination on an <span class="math">m\\times n</span> matrix of rank <span class="math">r</span> has complexity <span class="math">\\mathcal{O}\\left(mnr^{\\omega-2}\\right)</span> <em>[31]</em>. The Arora & Ge algorithm hence has a complexity of</p>

    <p class="text-gray-300">\\[ \\mathcal{O}\\left(M_{\\mathrm{AG}}\\cdot\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}^{\\omega-1}\\right)=\\mathcal{O}\\left(M_{\\mathrm{AG}}\\cdot\\binom{n+2\\,C_{\\mathrm{AG}}\\,\\sigma+1}{2\\,C_{\\mathrm{AG}}\\,\\sigma+1}^{\\omega-1}\\right). \\]</p>

    <p class="text-gray-300">We now consider the bound on <span class="math">C_{\\mathrm{AG}}</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">n,q,\\sigma=\\alpha q/\\sqrt{2\\pi}</span> be parameters of an <span class="math">\\mathrm{LWE}_{\\chi_{\\alpha,q}}</span> instance where <span class="math">q=\\mathrm{poly}(n)</span>. Let <span class="math">p^{\\prime}_{f}\\in[0,1]</span> be a constant upper bound on the probability of failure and</p>

    <p class="text-gray-300"><span class="math">C_{\\mathrm{AG}}\\leq 2\\,\\sigma\\log n+a^{1/2}\\approx 4\\,\\sigma\\log n,</span></p>

    <p class="text-gray-300">with <span class="math">a=4(\\sigma\\log n)^{2}+2\\log(\\sigma\\,q\\log q)-2\\log p^{\\prime}_{f}+2\\log n</span>. Finally, let also <span class="math">D_{\\mathrm{AG}}=2\\,C_{\\mathrm{AG}}\\,\\sigma+1</span>. Then, the system obtained by linearizing <span class="math">\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}\\sigma\\,q\\log q</span> equations of degree as in (4) is correct, i.e. the secret is a zero of all the polynomials, with probability bigger than <span class="math">1-p^{\\prime}_{f}</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The probability of failure is upper bounded by:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p_{f}=M_{\\mathrm{AG}}\\times\\textrm{Pr}[e\\stackrel{{\\scriptstyle\\sharp}}{{\\leftarrow}}\\chi_{\\alpha,q}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>C_{\\mathrm{AG}}\\cdot\\sigma]\\approx\\frac{2\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}\\sigma\\,q\\log q}{\\sqrt{2\\pi}\\,C_{\\mathrm{AG}}\\,e^{C_{\\mathrm{AG}}^{2}/2}}<\\frac{\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}\\sigma\\,q\\log q}{C_{\\mathrm{AG}}\\cdot e^{C_{\\mathrm{AG}}^{2}/2}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We bound <span class="math">\\binom{n+D_{\\mathrm{AG}}}{D_{\\mathrm{AG}}}</span> by <span class="math">n^{D_{\\mathrm{AG}}}</span>. While this approximation is rather loose, it allows to simplify our expression sufficiently to recover a closed form of the complexity. With this simplification, our goal is to find <span class="math">C_{\\mathrm{AG}}</span> such that:</p>

    <p class="text-gray-300"><span class="math">0\\leq\\ \\frac{n^{D_{\\mathrm{AG}}}\\cdot\\sigma\\,q\\log q}{C_{\\mathrm{AG}}\\cdot e^{C_{\\mathrm{AG}}^{2}/2}}=p^{\\prime}_{f}\\leq 1.</span></p>

    <p class="text-gray-300">That is:</p>

    <p class="text-gray-300"><span class="math">\\frac{e^{\\log\\left(\\sigma\\,q\\log q\\right)}e^{\\left(2\\,C_{\\mathrm{AG}}\\,\\sigma+1\\right)\\log n}}{e^{\\log p^{\\prime}_{f}}\\cdot\\left(e^{\\log C_{\\mathrm{AG}}}\\cdot e^{C_{\\mathrm{AG}}^{2}/2}\\right)}=1.</span></p>

    <p class="text-gray-300">Thus we need to solve</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=\\log(\\sigma\\,q\\log q)+2\\,C_{\\mathrm{AG}}\\,\\sigma\\log n+\\log n-\\log C_{\\mathrm{AG}}-\\log p^{\\prime}_{f}-C_{\\mathrm{AG}}^{2}/2</span> <span class="math">&gt;\\log(\\sigma\\,q\\log q)+2\\,C_{\\mathrm{AG}}\\,\\sigma\\log n+\\log n-\\log p^{\\prime}_{f}-C_{\\mathrm{AG}}^{2}/2</span></p>

    <p class="text-gray-300">for <span class="math">C_{\\mathrm{AG}}</span>. The last line has <span class="math">2</span> roots:</p>

    <p class="text-gray-300"><span class="math">[R_{1}=2\\,\\sigma\\cdot\\log(n)-a^{1/2},R_{2}=2\\,\\sigma\\cdot\\log(n)+a^{1/2}],</span></p>

    <p class="text-gray-300">with <span class="math">a=4(\\sigma\\log n)^{2}+2\\log(\\sigma\\,q\\log q)-2\\log p^{\\prime}_{f}+2\\log n</span>.</p>

    <p class="text-gray-300">Note that <span class="math">a^{1/2}&gt;2\\,\\sigma\\log(n)</span> and hence <span class="math">R_{1}&lt;0</span>. Thus, the smallest possible value for <span class="math">C_{\\mathrm{AG}}</span> is <span class="math">R_{2}</span>. Now, assume that <span class="math">q\\in\\mathrm{poly(n)}</span>, i.e. <span class="math">q\\approx n^{c}</span>. Also, recall that <span class="math">p^{\\prime}_{f}</span> is a constant. Thus, for <span class="math">n</span> big enough:</p>

    <p class="text-gray-300"><span class="math">a</span> <span class="math">=4(\\sigma\\log n)^{2}+2\\log(\\sigma\\,q\\log q)-2\\log p^{\\prime}_{f}+2\\log n</span> <span class="math">=4(\\sigma\\log n)^{2}+2c\\log(\\sigma\\,n\\,c\\log n)-2\\log p^{\\prime}_{f}+2\\log n</span> <span class="math">\\approx 4(\\sigma\\log n)^{2}.</span></p>

    <p class="text-gray-300">So, we have <span class="math">C_{\\mathrm{AG}}\\leq 2\\,\\sigma\\log n+a^{1/2}\\approx 4\\,\\sigma\\log n</span>. ∎</p>

    <p class="text-gray-300">We arrive at the following theorem:</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Let <span class="math">n,q,\\sigma=\\alpha\\,q/\\sqrt{2\\pi}</span> be parameters of an <span class="math">\\mathrm{LWE}_{{\\chi_{\\alpha,q}}}</span> instance. If <span class="math">D_{\\mathrm{AG}}(=8\\,\\sigma^{2}\\log n+1)\\in o(n)</span> then the Arora & Ge algorithm solves the computational <span class="math">\\mathrm{LWE}</span> problem in time complexity</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{\\,\\omega\\cdot D_{\\mathrm{AG}}\\log\\frac{n}{D_{\\mathrm{AG}}^{\\,\\cdot}}}\\cdot\\sigma\\,q\\log q\\right)=\\mathcal{O}\\left(2^{\\,8\\,\\omega\\,\\sigma^{2}\\log n(\\log n-\\log(8\\,\\sigma^{2}\\log n))}\\cdot\\mathrm{poly}(n)\\right)</span></p>

    <p class="text-gray-300">and memory complexity</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{\\,2\\cdot D_{\\mathrm{AG}}\\log\\frac{n}{D_{\\mathrm{AG}}^{\\,\\cdot}}}\\cdot\\sigma\\,q\\log q\\right)=\\mathcal{O}\\left(2^{\\,16\\,\\sigma^{2}\\log n(\\log n-\\log(8\\,\\sigma^{2}\\log n))}\\cdot\\mathrm{poly}(n)\\right).</span></p>

    <p class="text-gray-300">If <span class="math">n\\in o(\\sigma^{2}\\log(n))</span> then the Arora & Ge algorithm solves the computational <span class="math">\\mathrm{LWE}</span> problem in time complexity</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{\\,\\omega\\cdot n\\log\\frac{D_{\\mathrm{AG}}}{n}}\\cdot\\sigma\\,q\\log q\\right)=\\mathcal{O}\\left(2^{\\,\\omega\\,n\\log(8\\,\\sigma^{2}\\log n)-\\omega\\,n\\log n}\\cdot\\mathrm{poly}(n)\\right)</span></p>

    <p class="text-gray-300">and memory complexity</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{\\,2n\\log\\frac{D_{\\mathrm{AG}}}{n}}\\cdot\\sigma\\,q\\log q\\right)=\\mathcal{O}\\left(2^{\\,2n\\log(8\\,\\sigma^{2}\\log n)-2\\,n\\log n}\\cdot\\mathrm{poly}(n)\\right).</span></p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The result follows immediately from plugging the Lemmata 2 and 4 into Theorem 3.</p>

    <h2 id="sec-26" class="text-2xl font-bold">5 Solving <span class="math">\\mathrm{LWE}</span> with Gröbner Bases</h2>

    <p class="text-gray-300">In this section we address the natural question of whether the complexity of the basic Arora & Ge algorithm can be improved by using Gröbner basis algorithms instead of the linearisation method. The main motivation is that the constant <span class="math">C_{\\mathrm{AG}}</span> (and hence the degree of the equations) depends on the number of equations <span class="math">M_{\\mathrm{AG}}</span> considered. Hence, on the one hand, we may lower the number of equations to a value lower than <span class="math">\\tilde{\\mathcal{O}}(n^{2\\,\\epsilon})</span> whilst keeping the probability of failure small enough. On the other hand, this means that the cost of solving the resulting system will grow compared to that of linearisation. The optimisation target is then to find a tradeoff allowing to improve upon linearisation.</p>

    <p class="text-gray-300">We assume that <span class="math">\\sigma=n^{\\epsilon}</span>, with <span class="math">0\\leq\\epsilon\\leq 1</span>. Let also <span class="math">\\theta,0\\leq\\theta\\leq\\epsilon\\leq 1</span>. We consider the number of samples of the following form:</p>

    <p class="text-gray-300"><span class="math">M_{\\mathrm{GB}}=e^{\\gamma_{\\theta}}</span>, with <span class="math">\\gamma_{\\theta}=n^{2\\cdot(\\epsilon-\\theta)}</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\theta=0</span> corresponds up to polylog factors to the basic Arora-Ge approach. To explain the rational for the choosing this form for <span class="math">M_{\\mathrm{GB}}</span> the number of samples, we state below a simple lemma which relates the number of samples to the degree of the multivariate equations:</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{a}_{1},b_{1}),\\ldots,(\\mathbf{a}_{m},b_{m})</span> be elements of <span class="math">\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> sampled according to <span class="math">\\mathrm{LWE}_{\\chi_{\\alpha,q}}</span>. If <span class="math">C=\\sqrt{2\\log(m)}</span> then the equations generated as in (4) vanish with probability at least:</p>

    <p class="text-gray-300"><span class="math">p_{\\mathrm{g}}=1-\\sqrt{\\frac{1}{\\pi\\cdot\\log(m)}}.</span></p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By Lemma 3, the probability of failure satisfies</p>

    <p class="text-gray-300"><span class="math">\\leq\\frac{2\\,m}{C\\sqrt{2\\pi}}e^{-C^{2}/2}=\\frac{2m}{\\sqrt{4\\pi\\cdot\\log(m)}}e^{-\\left(\\sqrt{2\\log(m)}\\right)^{2}/2}=\\frac{1}{\\sqrt{\\pi\\cdot\\log(m)}}.</span></p>

    <p class="text-gray-300">From this the probably of success <span class="math">p_{\\mathrm{g}}\\geq 1-p_{\\mathrm{f}}</span> follows. ∎</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">If <span class="math">m\\in\\mathcal{O}\\left(n\\right)</span> then it holds that <span class="math">p_{\\mathrm{g}}\\in 1-o(1)</span>.</p>

    <p class="text-gray-300">We can then deduce the degree <span class="math">D_{\\mathrm{GB}}</span> required for <span class="math">M_{\\mathrm{GB}}=e^{\\gamma_{\\theta}}</span> equations. From Lemma 5, we have to fix <span class="math">C_{\\mathrm{GB}}=\\sqrt{2\\cdot\\log(M_{\\mathrm{GB}})}=\\sqrt{2\\cdot\\gamma_{\\theta}}</span>. Thus:</p>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{GB}}</span> <span class="math">=2\\,\\sqrt{2\\cdot\\log(M_{\\mathrm{GB}})}\\cdot\\sigma+1</span> <span class="math">\\in\\mathcal{O}\\left(\\sqrt{\\log(M_{\\mathrm{GB}})}\\cdot\\sigma\\right)=\\mathcal{O}\\left(\\sqrt{\\gamma_{\\theta}}\\cdot\\sigma\\right)=\\mathcal{O}\\left(n^{2\\epsilon-\\theta}\\right)=\\mathcal{O}\\left(\\gamma_{\\theta}\\cdot n^{\\theta}\\right).</span></p>

    <p class="text-gray-300">To ease the analysis below, we further simplify <span class="math">D_{\\mathrm{GB}}</span> to:</p>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{GB}}\\approx\\gamma_{\\theta}\\cdot n^{\\theta}=\\log(M_{\\mathrm{GB}})\\cdot n^{\\theta}.</span></p>

    <p class="text-gray-300">Furthermore, we restrict our attention to the case <span class="math">\\sigma=\\sqrt{n}/\\sqrt{2\\pi}</span>. Now, in order to analyse the complexity of the Gröbner basis computation, we need to make the following assumption about the structure of the generated equations:</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Assumption 1</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{a}_{1},b_{1}),\\ldots,(\\mathbf{a}_{M_{\\mathrm{GB}}},b_{M_{\\mathrm{GB}}})</span> be elements of <span class="math">\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> sampled according to <span class="math">\\mathrm{LWE}_{\\chi_{\\alpha,q}}</span>. Let <span class="math">P(X)=X\\prod_{i=1}^{C_{\\mathrm{GB}}\\cdot\\sigma}(X+i)(X-i)</span>. We define:</p>

    <p class="text-gray-300"><span class="math">f_{i}=P\\big{(}-b+\\sum_{j=1}^{n}(\\mathbf{a}_{i})_{(j)}x_{j}\\big{)}=0,\\forall i,1\\leq i\\leq M_{\\mathrm{GB}}.</span> (5)</p>

    <p class="text-gray-300">Then, <span class="math">\\langle f_{1},\\ldots,f_{m}\\rangle</span> is semi-regular.</p>

    <p class="text-gray-300">We justify this assumption in Section 7.</p>

    <p class="text-gray-300">From <span class="math">D_{\\mathrm{GB}}</span> and <span class="math">M_{\\mathrm{GB}}</span> we now need to establish the degree of regularity. Whilst there are classical results on the degree of regularity in the literature, these do not apply here. In particular, we need to consider systems of equations having a non-constant degree. For brevity and due to the fact a detailed analysis is beyond the scope of this paper, we only provide the general statement which allows to derive the result below in Appendix A (Proposition 3).</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Let <span class="math">A\\geq 1</span>, and <span class="math">f_{1},\\ldots,f_{m}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span> be semi-regular polynomials of degree <span class="math">\\frac{n}{A}</span>, and <span class="math">D_{\\mathrm{reg}}</span> be the degree of regularity of these polynomials. If <span class="math">m=e^{\\frac{\\pi\\cdot n}{4\\cdot A^{2}}}</span>, then it holds that <span class="math">D_{\\mathrm{reg}}</span> behaves asymptotically as</p>

    <p class="text-gray-300"><span class="math">C_{A}\\cdot n,\\text{where }C_{A}\\text{ is a constant which depends on }A.</span></p>

    <p class="text-gray-300">The constant <span class="math">C_{A}</span> in the Lemma can be computed explicitly for any value of <span class="math">A</span> as explained in Proposition 3. For <span class="math">A=1</span>, we get in particular that <span class="math">D_{\\mathrm{reg}}=1.41\\cdot n</span>, for <span class="math">n</span> big enough. Putting all these results together we can now derive the complexity of solving <span class="math">\\mathrm{LWE}</span> using a Gröbner basis algorithm.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">A\\geq 1,\\omega</span>, <span class="math">C_{A}</span> be as defined in Lemma 6, <span class="math">\\omega,2\\leq\\omega&lt;3</span>, be the linear algebra constant, and <span class="math">H_{2}(x)=-x\\log_{2}(x)-(1-x)\\log_{2}(1-x)</span>. Let <span class="math">(\\mathbf{a}_{i},b_{i})_{i\\geq 1}</span> be elements of <span class="math">\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> sampled according to <span class="math">\\mathrm{LWE}_{\\chi_{n,q}}</span> with a standard deviation <span class="math">\\sigma=\\frac{\\sqrt{n}}{\\sqrt{2\\pi}}</span> and <span class="math">A\\geq 1</span>. There is an algorithm recovering the secret in</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(2^{n\\left(\\omega\\left(1+C_{A}\\right)H_{2}\\left(\\frac{C_{A}}{1+C_{A}}\\right)+\\frac{\\pi\\cdot\\log_{2}(e)}{4\\cdot A^{2}}\\right)}\\right)</span> (time) and <span class="math">\\mathcal{O}\\left(2^{n\\left(2\\left(1+C_{A}\\right)H_{2}\\left(\\frac{C_{A}}{1+C_{A}}\\right)+\\frac{\\pi\\cdot\\log_{2}(e)}{4\\cdot A^{2}}\\right)}\\right)</span> (memory).</p>

    <p class="text-gray-300">The algorithm has success probability <span class="math">\\geq 1-\\frac{2}{\\pi\\sqrt{n}}=1-o(1)</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">M_{\\mathrm{GB}}=e^{\\frac{\\pi\\cdot n}{4\\cdot A^{2}}}</span> and <span class="math">D_{\\mathrm{GB}}=n/A</span>. We generate a system of <span class="math">M_{\\mathrm{GB}}</span> non-linear equations of degree <span class="math">D_{\\mathrm{GB}}</span> as (5). Under our regularity assumption 1, the complexity of computing a Gröbner basis for this system is:</p>

    <p class="text-gray-300">\\[ \\mathcal{O}\\left(n\\,e^{\\frac{\\pi\\cdot n}{4\\cdot A^{2}}}\\begin{pmatrix}n(1+C_{A})\\\\ C_{A}\\,n\\end{pmatrix}^{\\omega}\\right), \\] (6)</p>

    <p class="text-gray-300">Combining this with Lemma 1 gives the complexity. By Lemma 3, the probability of failure verifies is <span class="math">\\leq\\frac{2\\,m}{C\\sqrt{2\\pi}}e^{-C^{2}/2}</span>. In our case, <span class="math">C\\approx\\frac{\\sqrt{2\\pi n}}{2}</span> which gives a failure probability <span class="math">\\leq\\frac{2}{\\pi\\sqrt{n}}</span>. ∎</p>

    <p class="text-gray-300">Note that the complexities in Theorem 5 are minimized by taking a constant <span class="math">A=1</span>. So, we get a complexity of <span class="math">\\mathcal{O}\\left(2^{n\\left(2.35\\,\\omega+1.13\\right)}\\right)</span> (time) and <span class="math">\\mathcal{O}\\left(2^{5.85\\,n}\\right)</span> (memory). Thus, our analysis shows that using Gröbner bases yields an exponential speed-up (for <span class="math">\\sigma=\\sqrt{n}/\\sqrt{2\\pi}</span> and under Assumption 1) over the basic Arora-Ge approach (cf. Theorem 4). On the slightly negative side, our results also give a negative answer to the natural question whether the combination of Gröner basis techniques with the Arora-Ge modelling can yield a subexponential algorithm for the <span class="math">\\mathrm{LWE}</span> problem: from Lemma 6, one can notice that there is no choice of <span class="math">A</span> (constant, <span class="math">\\log n</span>, <span class="math">\\dots</span>) which makes the number of samples sub-exponential whilst keeping the degree of regularity sub-linear.</p>

    <h2 id="sec-34" class="text-2xl font-bold">6 Solving <span class="math">\\mathrm{LWE}</span> with Bounded Errors</h2>

    <p class="text-gray-300">We now turn to studying the complexity of solving BinaryError-<span class="math">\\mathrm{LWE}</span> using the modelling of Arora & Ge <em>[5]</em> and applying a Gröbner basis algorithm for solving the resulting system of equations. As discussed earlier, BinaryError-<span class="math">\\mathrm{LWE}</span> is an <span class="math">\\mathrm{LWE}</span> instance over <span class="math">\\mathbb{Z}_{q}</span> but with errors restricted to the binary field <em>[35]</em>. This variant is particularly attractive for real-world practical implementations of LWE-based cryptographic schemes. Generating noise-free non-linear equations for BinaryError-<span class="math">\\mathrm{LWE}</span> is straightforward: if <span class="math">\\mathbf{e}=(e_{1},\\dots,e_{m})\\in\\{0,1\\}^{m}</span> and <span class="math">P(X)=X(X-1)</span>, then we have <span class="math">P(e_{i})=0</span>, for all <span class="math">i,1\\leq i\\leq m</span>.</p>

    <p class="text-gray-300">Now, let <span class="math">(G,\\mathbf{s}\\times G+\\mathbf{e})=(G,\\mathbf{c})\\in\\mathbb{Z}_{q}^{n\\times m}\\times\\mathbb{Z}_{q}^{m}</span> be sampled according to <span class="math">L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}</span>. Then</p>

    <p class="text-gray-300"><span class="math">e_{i}=c_{i}-\\sum_{j=1}^{n}s_{j}G_{j,i},\\text{ for }1\\leq i\\leq m.</span></p>

    <p class="text-gray-300">It follows that the secret <span class="math">\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}</span> is a solution of the following algebraic system:</p>

    <p class="text-gray-300"><span class="math">f_{1}=P\\big{(}c_{1}-\\sum_{j=1}^{n}s_{j}G_{j,1}\\big{)}=0,\\ \\dots,\\ f_{m}=P\\big{(}c_{n}-\\sum_{j=1}^{n}s_{j}G_{j,n}\\big{)}=0.</span> (7)</p>

    <p class="text-gray-300">is is an algebraic system of <span class="math">m</span> quadratic equations in <span class="math">\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span>. As already pointed out in <em>[5, 35]</em>, this system can be solved using linearization if <span class="math">m=\\mathcal{O}\\left(n^{2}\\right)</span>. However the case <span class="math">m&lt;\\mathcal{O}\\left(n^{2}\\right)</span> remained untreated. Here, we address this problem of evaluating the complexity of solving the algebraic system (7) with an arbitrary number <span class="math">m</span> of equations.</p>

    <p class="text-gray-300">As discussed in Section 2, answering this question in general is hard. But for one particular class of systems, namely semi-regular systems of equations, this question has in fact been settled. In particular, the following result <em>[6, 7, 8, 10]</em> allows us to classify the complexity of solving polynomial systems with respect to the number of equations.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 6.</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">m=C\\cdot n</span>, with <span class="math">C&gt;1</span>, and let <span class="math">f_{1},\\ldots,f_{m}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span> be a semi-regular system of equations. The degree of regularity of <span class="math">f_{1},\\ldots,f_{m}</span> behaves asymptotically as</li>

    </ol>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{reg}}=\\left(C-\\frac{1}{2}-\\sqrt{C(C-1)}\\right)n-\\frac{a_{1}}{2\\big{(}C(C-1)\\big{)}^{1/6}}\\,n^{\\frac{1}{3}}</span> <span class="math">-\\left(2-\\frac{2C-1}{4\\big{(}C(C-1)\\big{)}^{1/2}}\\right)+\\mathcal{O}\\left(\\frac{1}{n^{\\frac{1}{3}}}\\right),</span></p>

    <p class="text-gray-300">where <span class="math">a_{1}\\approx 2.3381</span> is the largest zero of the classical Airy function.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">m=n\\cdot\\log^{1/\\epsilon}(n)</span>, for any constant <span class="math">\\epsilon&gt;0</span>, or <span class="math">m=n\\log\\log n</span>. The degree of regularity of <span class="math">f_{1},\\ldots,f_{m}</span> behaves asymptotically as:</li>

    </ol>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{reg}}=\\frac{n^{2}}{8m}\\left(1+o(1)\\right).</span></p>

    <p class="text-gray-300">A proof of <span class="math">i)</span> can be found, for instance, in <em>[10, Theorem 1]</em>. A proof similar to the case of ii) can be found in <em>[7]</em>. However, there is slight difference between <em>[7]</em> (binary fields) and our case (generic prime fields). In Appendix A we briefly sketch a proof for <span class="math">ii)</span> of Theorem 6.</p>

    <p class="text-gray-300">Hence, under the assumption that the system (7) behaves like a semi-regular system of equations, Theorem 6 allows one to compute an upper bound on the complexity for solving it with Gröbner basis algorithms. While no proof currently exists that would demonstrate that the system (7) does indeed behave like a semi-regular system, we make the following assumption based on the discussion in Section 7.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Assumption 2</h6>

    <p class="text-gray-300">Let <span class="math">(G,\\mathbf{s}\\times G+\\mathbf{e})=(G,\\mathbf{c})\\in\\mathbb{Z}_{q}^{n\\times m}\\times\\mathbb{Z}_{q}^{m}</span> be sampled according to <span class="math">L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}</span>, and let <span class="math">P(x)=X(X-1)</span>. We define:</p>

    <p class="text-gray-300"><span class="math">f_{1}=P\\big{(}c_{1}-\\sum_{j=1}^{n}s_{j}G_{j,1}\\big{)}=0,\\,\\,\\,\\ldots\\,\\,,f_{m}=P\\big{(}c_{n}-\\sum_{j=1}^{n}s_{j}G_{j,m}\\big{)}=0.</span> (8)</p>

    <p class="text-gray-300">It holds that <span class="math">\\langle f_{1},\\ldots,f_{m}\\rangle</span> is semi-regular.</p>

    <p class="text-gray-300">Based on Assumption 2, we can now state the main result of this section. We classify the hardness of our approach with various number of samples. The first one corresponds to the number of equations required in the security proof <em>[35, Theorem 1.2]</em>. We then consider a slightly larger number of equations than what is required in the security proof, i.e. <span class="math">m=2n</span> equations. In addition we give the results for a quasi-linear number of equations.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">Let <span class="math">\\omega,2\\leq\\omega&lt;3</span>, be the linear algebra constant, and <span class="math">H_{2}(x)=-x\\log_{2}(x)-(1-x)\\log_{2}(1-x)</span>. Under Assumption 2, we have the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">m=n\\left(1+\\frac{1}{\\log(n)}\\right)</span>, then there is an algorithm solving <em>BinaryError-LWE</em> with a time complexity:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(n^{2}\\,2^{1.37\\,\\omega\\,n}\\right).</span> (9)</p>

    <p class="text-gray-300">If <span class="math">m=2\\cdot n</span>, then there is an algorithm solving BinaryError-LWE with a time complexity</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(n^{2}\\,2^{0.43\\,\\omega\\,n}\\right).</span> (10)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>More generally, if <span class="math">m=C\\cdot n</span>, with <span class="math">C&gt;1</span>, there is an algorithm solving BinaryError-LWE in:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(n^{2}\\,2^{\\omega\\,n(1+\\beta)\\,H_{2}\\left(\\frac{\\beta}{1+\\beta}\\right)}\\right)</span> (time) and <span class="math">\\mathcal{O}\\left(n^{2}\\,2^{2n(1+\\beta)\\,H_{2}\\left(\\frac{\\beta}{1+\\beta}\\right)}\\right)</span> (memory), (11)</p>

    <p class="text-gray-300">with <span class="math">\\beta=\\left(C-\\frac{1}{2}-\\sqrt{C(C-1)}\\right)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">m=\\mathcal{O}\\left(n\\log\\log n\\right)</span>, then there is a subexponential algorithm solving BinaryError-LWE with complexity</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(m^{2}\\,2^{\\frac{\\omega\\,n\\,\\log\\log\\log n}{8\\log\\log n}}\\right)</span> (time), <span class="math">\\mathcal{O}\\left(m^{2}\\,2^{\\frac{2n\\,\\log\\log\\log n}{8\\log\\log n}}\\right)</span> (memory). (12)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, if <span class="math">m=n\\cdot\\log^{1/\\epsilon}(n)</span>, for any <span class="math">\\epsilon&gt;0</span>, then there is a subexponential algorithm solving BinaryError-LWE whose complexity is:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(m^{2}\\,2^{\\frac{\\omega\\,n\\,\\log\\left(\\log^{1/\\epsilon}(n)\\right)}{8\\log^{1/\\epsilon}(n)}}\\right)</span> (time), <span class="math">\\mathcal{O}\\left(m^{2}\\,2^{\\frac{2n\\,\\log\\left(\\log^{1/\\epsilon}(n)\\right)}{8\\log^{1/\\epsilon}(n)}}\\right)</span> (memory). (13)</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">As explained Section 2, the complexity of computing a Gröbner basis is:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(m\\,D_{\\mathrm{reg}}\\binom{n+D_{\\mathrm{reg}}}{D_{\\mathrm{reg}}}^{\\omega}\\right)</span> (time), <span class="math">\\mathcal{O}\\left(m\\,D_{\\mathrm{reg}}\\binom{n+D_{\\mathrm{reg}}}{D_{\\mathrm{reg}}}^{2}\\right)</span> (memory). (14)</p>

    <p class="text-gray-300">Under our semi-regularity assumption, Theorem 6 gives: <span class="math">D_{reg}=0.5\\cdot n+o(n)</span> for <span class="math">m=n\\left(1+\\frac{1}{\\log(n)}\\right)</span>, <span class="math">D_{\\mathrm{reg}}=0.08\\cdot n+o(n)</span> for <span class="math">m=2\\cdot n</span> and more generally</p>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{reg}}=\\left(C-\\frac{1}{2}-\\sqrt{C(C-1)}\\right)n+o(n)</span></p>

    <p class="text-gray-300">for <span class="math">m=C\\cdot n</span>, for any constant <span class="math">C&gt;1</span>. In these cases, the binomial coefficient in (14) has the following form:</p>

    <p class="text-gray-300"><span class="math">\\binom{\\alpha\\cdot n}{\\beta\\cdot n},\\text{ for some }\\alpha&gt;\\beta&gt;0.</span></p>

    <p class="text-gray-300">We obtain (9) – (11) by taking <span class="math">\\beta=\\left(C-\\frac{1}{2}-\\sqrt{C(C-1)}\\right)</span> by applying Lemma 1. For (12) and (13), we combine Lemma 2 and Theorem 6. ∎</p>

    <p class="text-gray-300">It follows from Theorem 7 that we can solve BinaryError-LWE in dimension <span class="math">n</span> in time <span class="math">n^{2}\\,2^{0.344\\,n}</span> using memory <span class="math">n^{2}\\,2^{0.289\\,n}</span> as soon as as soon as <span class="math">m\\geq 6.6\\,n</span>. We note that this is better than the best currently-known generic (exact) CVP solver <em>[11]</em>. Theorem 7 also provides a good picture of the hardness degradation of BinaryError-LWE for the number of available samples ranging from <span class="math">m=n\\left(1+\\frac{1}{c\\log(n)}\\right)</span> for <span class="math">c&gt;1</span>, a case for which BinaryError-LWE is as hard as solving some lattice problem in the worst case (as shown in <em>[35]</em>) to <span class="math">m=\\mathcal{O}\\left(n^{2}\\right)</span>, the case for which it can be solved in polynomial-time. In view of items (iv)-(v) of Theorem 7, we conclude that BinaryError-LWE should be ruled out for cryptographic applications that require a quasi-linear number of samples.</p>

    <h2 id="sec-39" class="text-2xl font-bold">7 Justifications of our Assumptions</h2>

    <p class="text-gray-300">The results in this work depend crucially on two assumptions, namely that all systems of equations occurring in this work are semi-regular, i.e. have no special structure. While no full proof currently exists that</p>

    <p class="text-gray-300">would demonstrate either Assumption 1 or 2, we argue below why it is reasonable to believe that these assumptions hold. Each semi-regularity assumption essentially states that our systems are not easier and not harder to solve than a random system of equations and reiterate that if these systems were easier than random systems this would imply that the analysis of Section 5 could be much improved and lead to progress towards a subexponential classical algorithm for solving Bounded Distance Decoding. Furthermore, this subexponential classical algorithm would work despite ignoring the particular error distribution and would consist of applying a generic Gröbner basis algorithm. We consider this case to be unlikely. Furthermore, we note that Arora and Ge showed in [5] that Assumption 1 holds for  <span class="math">m = 2^{\\tilde{\\mathcal{O}}(\\sigma^2)}</span>  (Theorem 3).</p>

    <p class="text-gray-300">Following [5], we prove that Assumption 2 holds for  <span class="math">m = \\mathcal{O}\\left(n^{2}\\right)</span>  in Section A.2. We also prove several partial results regarding our assumptions in Section A.2 and present experimental evidencethat these assumptions hold for reasonably large parameters in Section 7.1.</p>

    <p class="text-gray-300">We experimentally confirmed that our assumptions hold for reasonably large parameters. Namely, we verified Assumption 1 for systems up to  <span class="math">n = 8</span>  variables. In particular we computed for  <span class="math">n = 8</span>  and  <span class="math">m = 256</span> ,  <span class="math">\\alpha \\cdot q / \\sqrt{2\\pi} = 1</span>  using MAGMA [13] (V2.20-4) and Sage [41]. The generated system of equations has degree 9 and the degree of semi-regularity is 13. The highest degree reached was indeed degree 13.</p>

    <p class="text-gray-300">While  <span class="math">n \\leq 8</span>  might seem rather small, we point out that it is the last  <span class="math">n</span>  for which we can reasonably expect to run experiments on current hardware. Theorem 5 bounds the memory complexity by  <span class="math">\\mathcal{O}\\left(2^{5.85n}\\right)</span> . We note that for  <span class="math">n = 8</span> , our computation required 65GB of memory and 68 hours to complete. Hence, we would require about  <span class="math">2^{5.85} \\cdot 65\\mathrm{GB}</span>  of memory to perform this computation for  <span class="math">n = 9</span>  which is beyond our reach.</p>

    <p class="text-gray-300">To verify Assumption 2, we generated systems as in (8). We took  <span class="math">q</span>  as the next prime larger than  <span class="math">n</span>  (or  <span class="math">n^2</span>  in some instances). We then computed a Gröbner basis of the equations using MAGMA. Below we report the maximal degree reached  <span class="math">D_{\\mathrm{real}}</span>  in our experiments, and the theoretical degree of regularity  <span class="math">D_{\\mathrm{reg}}</span> , as given by Assumption 2. We note that the largest of these experiments took 7 days to complete.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dreg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dreal</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∈{5,...,25}</td>

            <td class="px-3 py-2 border-b border-gray-700">[n log2(n)]</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∈{26,...,53}</td>

            <td class="px-3 py-2 border-b border-gray-700">[n log2(n)]</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">[2 n log2(n)]</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">4 · [n log2(n)]</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In addition of these experimental results, we provide formal proofs of our assumptions in several cases in Appendix A.2.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adi Akavia, Shafi Goldwasser, and Vinod Vaikuntanathan. Simultaneous hardcore bits and cryptography against memory attacks. In Omer Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 474-495. Springer, March 2009.</li>

      <li>Martin R. Albrecht, Carlos Cid, Jean-Charles Faugère, Robert Fitzpatrick, and Ludovic Perret. On the complexity of the BKW algorithm on LWE. Designs, Codes and Cryptography, pages 1-30, 2013.</li>

      <li>Martin R. Albrecht, Pooya Farshim, Jean-Charles Faugère, and Ludovic Perret. Polly cracker, revisited. In Lee and Wang [33], pages 179-196.</li>

      <li>Martin R. Albrecht, Rachel Player, and Sam Scott. On the concrete hardness of learning with errors. Cryptology ePrint Archive, Report 2015/046, 2015. http://eprint.iacr.org/2015/046.</li>

      <li>Sanjeev Arora and Rong Ge. New algorithms for learning in presence of errors. In Luca Aceto, Monika Henzinger, and Jiri Sgall, editors, ICALP 2011, Part I, volume 6755 of LNCS, pages 403-415. Springer, July 2011.</li>

      <li>Magali Bardet. Étude des systèmes algébriques sundéterminés. Applications aux codes correcteurs et à la cryptographie. PhD thesis, Université de Paris VI, 2004.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[7] Magali Bardet, Jean-Charles Faugère, and Bruno Salvy. Complexity study of Gröbner basis computation. Technical report, INRIA, 2002. http://www.inria.fr/rrrt/rr-5049..</li>

      <li>[8] Magali Bardet, Jean-Charles Faugère, and Bruno Salvy. On the complexity of Gröbner basis computation of semi-regular overdetermined algebraic equations. In Proc. International Conference on Polynomial System Solving (ICPSS), pages 71–75, 2004.</li>

      <li>[9] Magali Bardet, Jean-Charles Faugère, and Bruno Salvy. On the Complexity of the F5 Gröbner basis Algorithm. Journal of Symbolic Computation, pages 1–24, September 2014. 24 pages.</li>

      <li>[10] Magali Bardet, Jean-Charles Faugère, Bruno Salvy, and Bo-Yin Yang. Asymptotic behaviour of the degree of regularity of semi-regular polynomial systems. In Proc. of MEGA 2005, Eighth International Symposium on Effective Methods in Algebraic Geometry, 2005.</li>

      <li>[11] Anja Becker, Nicolas Gama, and Antoine Joux. Solving shortest and closest vector problems: The decomposition approach. Cryptology ePrint Archive, Report 2013/685, 2013. http://eprint.iacr.org/2013/685.</li>

      <li>[12] Luk Bettale, Jean-Charles Faugère, and Ludovic Perret. Hybrid Approach for solving multivariate systems over finite fields. Journal of Mathematical Cryptology, 3(3):177–197, 2010.</li>

      <li>[13] Wieb Bosma, John J. Cannon, and Catherine Playoust. The Magma algebra system I: The user language. Journal of Symbolic Computation, 24(3-4):235–265, 1997.</li>

      <li>[14] Zvika Brakerski, Adeline Langlois, Chris Peikert, Oded Regev, and Damien Stehlé. Classical hardness of learning with errors. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, 45th ACM STOC, pages 575–584. ACM Press, June 2013.</li>

      <li>[15] Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) LWE. In Rafail Ostrovsky, editor, 52nd FOCS, pages 97–106. IEEE Computer Society Press, October 2011.</li>

      <li>[16] Bruno Buchberger. Ein Algorithmus zum Auffinden der Basiselemente des Restklassenringes nach einem nulldimensionalen Polynomideal. PhD thesis, University of Innsbruck, 1965.</li>

      <li>[17] Bruno Buchberger, Georges E. Collins, Rudiger G. K. Loos, and Rudolph Albrecht. Computer algebra symbolic and algebraic computation. SIGSAM Bull., 16(4):5–5, 1982.</li>

      <li>[18] Yuanmi Chen and Phong Q. Nguyen. BKZ 2.0: Better lattice security estimates. In Lee and Wang <em>[33]</em>, pages 1–20.</li>

      <li>[19] David A. Cox, John B. Little, and Don O’Shea. Ideals, Varieties and Algorithms. Springer Verlag, 2005.</li>

      <li>[20] 1986. D. J. Anick. 100(1) :235?259. Thin algebras of embedding dimension three. J. Algebra, 100 (1):235 – 259, 1986.</li>

      <li>[21] R. DeMillo and R. Lipton. A probabilistic remark on algebraic program testing. Information Processing Letters, 7(4):192–194, 1978.</li>

      <li>[22] Nico Döttling and Jörn Müller-Quade. Lossy codes and a new variant of the learning-with-errors problem. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 18–34. Springer, May 2013.</li>

      <li>[23] Jean-Charles Faugère. A new efficient algorithm for computing Gröbner bases (F4). Journal of Pure and Applied Algebra, 139:61–88, June 1999.</li>

      <li>[24] Jean Charles Faugère. A new efficient algorithm for computing Gröbner bases without reduction to zero <span class="math">(F_{5})</span>. In Teo Mora, editor, ISSAC 2002: Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation, July 07–10, 2002, Université de Lille, Lille, France, pages 75–83, New York, NY 10036, USA, 2002. ACM Press.</li>

      <li>[25] Jean-Charles Faugère, Françoise Levy dit Vehel, and Ludovic Perret. Cryptanalysis of minrank. In Wagner <em>[42]</em>, pages 280–296.</li>

      <li>[26] Jean-Charles Faugère, Patrizia M. Gianni, Daniel Lazard, and Teo Mora. Efficient computation of zero-dimensional Gröbner bases by change of ordering. Journal of Symbolic Computation, 16(4):329–344, 1993.</li>

      <li>[27] Jean-Charles Faugère and Antoine Joux. Algebraic cryptanalysis of hidden field equation (HFE) cryptosystems using gröbner bases. In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS, pages 44–60. Springer, August 2003.</li>

      <li>[28] Ralf Fröberg. An inequality for Hilbert series of graded algebras. Mathematica Scandinavica, 56:117–144, 1985.</li>

      <li>[29] Ralf Fröberg and Joachim Hollman. Hilbert series for ideals generated by generic forms. J. Symb. Comput., 17(2):149–157, 1994.</li>

      <li>[30] Craig Gentry. A fully homomorphic encryption scheme. PhD thesis, Stanford University, 2009. Available at http://crypto.stanford.edu/craig.</li>

      <li>[31] Claude-Pierre Jeannerod, Clément Pernet, and Arne Storjohann. Rank-profile revealing Gaussian elimination and the CUP matrix decomposition. J. Symb. Comput., 56:46–68, 2013.</li>

      <li>[32] Daniel Lazard. Gröbner-bases, Gaussian elimination and resolution of systems of algebraic equations. In Proceedings of the European Computer Algebra Conference on Computer Algebra, volume 162 of Lecture Notes in Computer Science, Berlin, Heidelberg, New York, 1983. Springer Verlag.</li>

      <li>[33] Dong Hoon Lee and Xiaoyun Wang, editors. ASIACRYPT 2011, volume 7073 of LNCS. Springer, December 2011.</li>

    </ul>

    <p class="text-gray-300">34] Richard Lindner and Chris Peikert. Better key sizes (and attacks) for LWE-based encryption. In Aggelos Kiayias, editor, <em>CT-RSA 2011</em>, volume 6558 of <em>LNCS</em>, pages 319–339. Springer, February 2011.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[35] Daniele Micciancio and Chris Peikert. Hardness of SIS and LWE with small parameters. In Ran Canetti and Juan A. Garay, editors, <em>CRYPTO 2013, Part I</em>, volume 8042 of <em>LNCS</em>, pages 21–39. Springer, August 2013.</li>

      <li>[36] Chris Peikert. Public-key cryptosystems from the worst-case shortest vector problem: extended abstract. In Michael Mitzenmacher, editor, <em>41st ACM STOC</em>, pages 333–342. ACM Press, May / June 2009.</li>

      <li>[37] Chris Peikert, Vinod Vaikuntanathan, and Brent Waters. A framework for efficient and composable oblivious transfer. In Wagner <em>[42]</em>, pages 554–571.</li>

      <li>[38] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. In Harold N. Gabow and Ronald Fagin, editors, <em>37th ACM STOC</em>, pages 84–93. ACM Press, May 2005.</li>

      <li>[39] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. <em>Journal of the ACM</em>, 56(6):34:1–34:40, September 2009.</li>

      <li>[40] J. T. Schwartz. Fast probabilistic algorithms for verification of polynomial identities. <em>Journal of the ACM</em>, 27(4):701–717, 1980.</li>

      <li>[41] William Stein et al. <em>Sage Mathematics Software Version 6.2</em>. The Sage Development Team, 2013. Available at http://www.sagemath.org.</li>

      <li>[42] David Wagner, editor. <em>CRYPTO 2008</em>, volume 5157 of <em>LNCS</em>. Springer, August 2008.</li>

      <li>[43] R. Zippel. Probabilistic algorithms for sparse polynomials. In <em>Symbolic and algebraic computation (EUROSAM’79), Internat. Sympos.</em>, volume 72 of <em>Lecture Notes in Computer Science</em>, pages 216–226. Springer Verlag, 1979.</li>

    </ul>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix A Appendix</h2>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">A.1 Degree of Regularity</h3>

    <p class="text-gray-300">The proof of Theorem 6-<span class="math">ii)</span> is derived from the following more general result.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proposition 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\epsilon&gt;0</span>, and <span class="math">F(n)\\in\\{\\log^{1/\\epsilon}(n),\\log\\log n\\}</span>. Assuming <span class="math">m=F(n)\\,n</span>, then the degree of regularity of a system of quadratic semi-regular equations <span class="math">f_{1},\\ldots,f_{m}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span> behaves asymptotically as:</p>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{reg}}=\\left(F\\left(n\\right)-1/2-\\sqrt{F^{2}(n)-F(n)}\\right)\\,n=\\frac{1}{8}\\frac{n}{F(n)}+\\mathcal{O}\\left(\\frac{n}{F^{2}(n)}\\right).</span></p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We assume that we have <span class="math">m</span> quadratic equations in <span class="math">n</span> variables. In this case, we have to consider the Hilbert series:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{H}_{m,n}(z)=\\frac{\\left(1-z^{2}\\right)^{m}}{\\left(1-z\\right)^{n}}=\\sum_{d=0}^{\\infty}h_{d}\\,z^{d}.</span></p>

    <p class="text-gray-300">The degree of regularity is the index <span class="math">D_{\\mathrm{reg}}</span> such that <span class="math">h_{D_{\\mathrm{reg}}}&lt;0</span>. We try to find <span class="math">D_{\\mathrm{reg}}=\\ell(n)\\,n=\\ell\\,n</span> such that <span class="math">h_{\\ell\\,n}&lt;0</span>. To do so, we consider :</p>

    <p class="text-gray-300"><span class="math">h_{\\ell\\,n}=\\oint\\frac{\\mathrm{H}_{m,n}(z)}{z^{\\ell\\,n}}dz=\\oint e^{f(z)\\,n}dz,</span></p>

    <p class="text-gray-300">where the contour is a circle centered in <span class="math">0</span> whose radius is smaller than <span class="math">1</span>.</p>

    <p class="text-gray-300">In our context:</p>

    <p class="text-gray-300"><span class="math">f(z)=\\frac{\\log(\\mathrm{H}_{m,n}(z))}{n}=\\frac{m\\log\\left(1-z^{2}\\right)-n\\log\\left(1-z\\right)-n\\,\\ell\\,\\log\\left(z\\right)}{n}.</span></p>

    <p class="text-gray-300">Laplace’s Method gives then:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h_{\\ell\\,n}\\approx\\sum_{\\{a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f^{\\prime}(a)=0\\}}e^{f(a)n}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More details about this preliminary part can be found in the literature, for instance <em>[6, 7, 8, 10]</em>. As <span class="math">n</span> increases, the integral concentrates in the neighbourhood of one or several saddle points, i.e. the solutions of <span class="math">f^{\\prime}=0</span></p>

    <p class="text-gray-300">When the equation  <span class="math">f&#x27;(z) = 0</span>  has two solutions, we have  <span class="math">h_{\\ell n} \\approx e^{f(z^{-})n} + e^{f(z^{+})n} \\to \\infty</span> . Hence, since when  <span class="math">d = D_{\\mathrm{reg}} = \\ell n</span>  we must have  <span class="math">h_d = 0</span>  this implies that the equation  <span class="math">f&#x27;(z) = 0</span>  has a multiple root.</p>

    <p class="text-gray-300">In our case, we have:</p>

    <div class="my-4 text-center"><span class="math-block">f ^ {\\prime} (z) = \\frac {1}{1 - z} - \\frac {2 m z}{n (1 - z ^ {2})} - \\frac {\\ell}{z}.</span></div>

    <p class="text-gray-300">Now, we set  <span class="math">m = nF(n)</span> . We have multiple root if the discriminant of  <span class="math">f&#x27;</span>  is 0. As a consequence,  <span class="math">\\ell = \\ell(n)</span>  is the smallest real root of:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(4 n ^ {3} F (n) ^ {2} + 4 n ^ {3} - 8 n ^ {3} F (n)\\right) \\ell^ {2} + \\left(- 8 n ^ {3} F (n) ^ {3} - 1 6 n ^ {3} F (n) + 2 0 n ^ {3} F (n) ^ {2} + 4 n ^ {3}\\right) \\ell - 2 n ^ {3} F (n) + n ^ {3} F (n) ^ {2} + n ^ {3}.</span></div>

    <p class="text-gray-300">This yields :</p>

    <div class="my-4 text-center"><span class="math-block">\\ell (n) = \\left(F (n) - 1 / 2 - \\sqrt {F ^ {2} (n) - F (n)}\\right) n = \\frac {1}{8} \\frac {n}{F (n)} + \\mathcal {O} \\left(\\frac {n}{F ^ {2} (n)}\\right).</span></div>

    <p class="text-gray-300">In Section 5, we use the following result.</p>

    <p class="text-gray-300">Proposition 3. Let  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  be constants  <span class="math">&amp;gt;0</span> , and  <span class="math">f_{1},\\ldots ,f_{m}\\in \\mathbb{K}[x_{1},\\ldots ,x_{n}]</span>  be semi-regular polynomials of degree  <span class="math">\\alpha n</span> . We define the function  <span class="math">F(X,\\ell) =</span></p>

    <p class="text-gray-300"><span class="math">\\log (1 + \\ell) - \\ell \\log (\\ell) + \\ell \\log (1 + \\ell) - \\log (1 + \\ell -X) + \\log (\\ell -X)\\ell -\\log (\\ell -X)\\alpha -\\log (1 + \\ell -X)\\ell +\\log (1 + \\ell -X)\\alpha -\\log (\\beta).</span></p>

    <p class="text-gray-300">Assuming  <span class="math">m = \\beta^n</span> , then it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {D _ {\\mathrm {r e g}}}{n} \\approx \\left\\{ \\begin{array}{l l} \\alpha \\text {i f} \\alpha &amp;lt;   \\alpha_ {0} \\\\ \\mathrm {P o s i t i v e R e a l R o o t} \\big (F (\\alpha , \\ell) \\big), \\text {i f} \\alpha_ {0} \\leq \\alpha &amp;lt;   6, \\end{array} \\right.</span></div>

    <p class="text-gray-300">and  <span class="math">\\alpha_0</span>  is the real value such that  <span class="math">F(\\alpha_0, \\alpha_0) = 0</span> .</p>

    <p class="text-gray-300">We give below the value of  <span class="math">\\alpha_0</span>  for various  <span class="math">\\beta</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">eπ/4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3595671731</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.293815373</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.641794121</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.019208159</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For  <span class="math">\\beta = e^{\\pi /4}</span> , the degree of regularity is then for instance  <span class="math">\\approx 1.41n</span> . Below, we compare the theoretical degree of regularity obtained from Proposition 3 for various  <span class="math">\\beta</span>  and  <span class="math">\\alpha</span>  with the degree of regularity obtained by computing the generic Hilbert series (Definition 2).</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">The proof of this result is beyond the scope of this paper. The first step is similar to the previous Proposition 2, i.e. we use Laplace's method to approximate the coefficient  <span class="math">h_{\\ell n}</span>  in the Hilbert series. The next step requires different tools than the ones used classically to cancel the coefficient asymptotically. The proof will be the full version of this paper.</p>

    <p class="text-gray-300">To simplify the analysis, it is possible to upper bound uniformly the degree of regularity, i.e.:</p>

    <p class="text-gray-300">Proposition 4. Let  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  be constants  <span class="math">&amp;gt;0</span> , and  <span class="math">f_{1},\\ldots ,f_{m}\\in \\mathbb{K}[x_{1},\\ldots ,x_{n}]</span>  be semi-regular polynomials of degree  <span class="math">\\alpha n</span> . If  <span class="math">m = \\beta^n</span> :</p>

    <div class="my-4 text-center"><span class="math-block">D _ {\\mathrm {r e g}} \\leq n \\cdot \\frac {\\beta}{\\beta - 1}</span></div>

    <p class="text-gray-300">For  <span class="math">\\beta = e^{\\frac{\\beta}{4}}</span> , we have  <span class="math">\\frac{\\beta}{\\beta - 1} = 1.83</span> .</p>

    <p class="text-gray-300">A technical difficulty for proving results towards Froberg's conjecture is that over a finite field the notion of Zariski open set is meaningless due to the field equations. However, the notion of genericity can be understood via the classical Schwartz-Zippel-DeMillo-Lipton lemma [21, 40, 43].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 7 (Schwartz, Zippel, DeMillo, Lipton [21, 40, 43]). Let  <span class="math">\\mathbb{K}</span>  be a field and  <span class="math">P\\in \\mathbb{K}[x_1,\\ldots ,x_n]</span>  be a non-zero polynomial. Select  <span class="math">r_1,\\dots,r_n</span>  uniformly at random from a finite subset  <span class="math">\\mathcal{X}</span>  of  <span class="math">\\mathbb{K}</span> . Then, the probability that  <span class="math">P(r_{1},\\ldots ,r_{n}) = 0</span>  is less than  $\\deg (P) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Linear Independence. Assumption 2 for BinaryError-LWE implies in particular that the equations (8) are linearly independent with high probability which we prove below for any <span class="math">1\\leq m\\leq\\binom{n+1}{2}</span>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">Let <span class="math">(A,\\mathbf{s}\\cdot A+\\mathbf{e})=(A,\\mathbf{c})\\in\\mathbb{Z}_{q}^{n\\times m}\\times\\mathbb{Z}_{q}^{m}</span> be sampled according to <span class="math">L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}</span>, and let <span class="math">P(x)=X(X-1)</span>. Assume that <span class="math">q&gt;2m</span>. Then, for all <span class="math">1\\leq m\\leq\\binom{n+1}{2}</span>, the equations</p>

    <p class="text-gray-300"><span class="math">f_{1}=P\\big{(}c_{1}-\\sum_{j=1}^{n}x_{j}A_{j,1}\\big{)},\\ \\ldots\\ ,f_{m}=P\\big{(}c_{m}-\\sum_{j=1}^{n}x_{j}A_{j,m}\\big{)},</span> (15)</p>

    <p class="text-gray-300">are linearly independent with probability <span class="math">\\geq 1-\\frac{2m}{q}</span>. In particular, the homogeneous components <span class="math">f_{1}^{\\mathrm{H}},\\ldots,f_{m}^{\\mathrm{H}}</span> of degree <span class="math">2</span> are linearly independent with probability <span class="math">\\geq 1-\\frac{2m}{q}</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The coefficients of the <span class="math">f_{i}</span>s can be viewed as polynomials of degree <span class="math">\\leq 2</span> in the components of the matrix <span class="math">A</span>. We denote the number of monomials of degree <span class="math">2</span> by <span class="math">N</span>, and by <span class="math">\\mathrm{Mac}_{2}</span> the <span class="math">m\\times N</span> matrix whose rows are the coefficients of the <span class="math">f_{i}^{\\mathrm{H}}</span>s. This is the Macaulay matrix of the <span class="math">f_{i}^{\\mathrm{H}}</span>s at degree <span class="math">2</span>. We assume that the monomials are sorted with respect to a graded reverse lexicographical order. Let <span class="math">\\mathrm{Mat}_{2}</span> be a <span class="math">m\\times m</span> sub-matrix of <span class="math">\\mathrm{Mac}_{2}</span>. We can view <span class="math">\\mathrm{Det}(\\mathrm{Mat}_{2})</span> as a polynomial <span class="math">p</span> of degree <span class="math">2m</span> whose variables are the components of <span class="math">A</span>. According to Lemma 9 (Appendix A.3), the polynomial <span class="math">p</span> is non-zero for all <span class="math">1\\leq m\\leq\\binom{n+1}{2}</span>. The Schwartz-Zippel-DeMillo-Lipton Lemma (Lemma 7) yields that <span class="math">p(A)\\neq 0</span> with probability <span class="math">\\geq 1-\\frac{2m}{q}</span>. ∎</p>

    <p class="text-gray-300">Note that the notion of semi-genericity only depends on the homogeneous components of highest degree. Thus, the polynomial <span class="math">P</span> in Theorem 8 can be replaced by <span class="math">X^{2}</span> and the proof would remain the same. By a similar argument the constants <span class="math">c_{i}</span>s are not relevant to the proof. This illustrates that it is equivalent to consider the semi-regularity of the systems as in Assumption 2 or the semi-regularity of the square of linear forms as done by Fröberg and Hollman <em>[29]</em>.</p>

    <p class="text-gray-300">A consequence of Theorem 8 is:</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">q&gt;2m</span>. There is a polynomial-time algorithm solving <em>BinaryError-LWE</em> with probability <span class="math">1-\\frac{2m}{q}</span> as soon as <span class="math">n&lt;m\\leq\\binom{n+1}{2}</span>.</p>

    <p class="text-gray-300">In <em>[35]</em> it was already mentioned that BinaryErrors-LWE can be solved in polynomial-time as soon as the number of samples is <span class="math">\\mathcal{O}\\left(n^{2}\\right)</span>, albeit no proof was given. In particular, a direct adaptation of <em>[5, Theorem 3.1]</em> to BinaryErrors-LWE gives:</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">Let <span class="math">(A,\\mathbf{s}\\cdot A+\\mathbf{e})=(A,\\mathbf{c})\\in\\mathbb{Z}_{q}^{n\\times m}\\times\\mathbb{Z}_{q}^{m}</span> be sampled according to <span class="math">L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}</span>, and let <span class="math">P(x)=X(X-1)</span>. The system obtained by linearizing the <span class="math">f_{i}</span>’s, as defined in (15), has unique solution with probability <span class="math">\\geq 1-2^{m}\\cdot q^{N_{2}-m}</span>, with <span class="math">N_{2}=\\binom{n+2}{2}</span>. The bound is then non-trivial (<span class="math">&lt;1</span>) if <span class="math">m\\geq cN_{2}</span>, for some constant <span class="math">c&gt;0</span>.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We know that <span class="math">\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}</span> is a solution of <span class="math">f_{1},\\ldots,f_{m}</span>. Given <span class="math">\\mathbf{s}^{\\prime}\\neq\\mathbf{s}</span>, the idea is to bound the probability that <span class="math">\\mathbf{s}^{\\prime}</span> vanishes simultaneously the linearised system corresponding to <span class="math">f_{1},\\ldots,f_{m}</span>.</p>

    <p class="text-gray-300">By definition, <span class="math">\\mathbf{c}=(\\mathbf{s}\\cdot A)+\\mathbf{e}</span>. So, we can write:</p>

    <p class="text-gray-300"><span class="math">f_{i}=P\\big{(}e_{i}-\\sum_{j=1}^{n}(\\mathbf{s}_{j}-x_{j})A_{j,i}\\big{)}.</span></p>

    <p class="text-gray-300">Now by setting <span class="math">x_{j}^{*}=(\\mathbf{s}_{j}-x_{j})</span>, we have:</p>

    <p class="text-gray-300"><span class="math">f_{i}^{<em>}(x_{1}^{</em>},\\ldots,x_{n}^{<em>})=f_{i}(\\mathbf{s}_{1}-x_{1}^{</em>},\\ldots,\\mathbf{s}_{n}-x_{n}^{<em>})=P\\big{(}e_{i}-\\sum_{j=1}^{n}x_{j}^{</em>}A_{j,i}\\big{)}.</span></p>

    <p class="text-gray-300">Thus, <span class="math">\\exists\\mathbf{s}^{\\prime}\\neq\\mathbf{s}</span> such that <span class="math">f_{i}(\\mathbf{s}^{\\prime})=0\\iff\\exists</span> a non-zero <span class="math">\\mathbf{s}^{<em>}\\in\\mathbb{Z}_{q}^{n}</span> such that <span class="math">f_{i}^{</em>}(\\mathbf{s}^{<em>})=0</span>. We can view <span class="math">f_{i}^{</em>}(\\mathbf{s}^{<em>})</span> has a multivariate polynomial of degree <span class="math">2</span> in the components of <span class="math">A</span>. Thus, assuming that <span class="math">f_{i}^{</em>}(\\mathbf{s}^{*})</span> is non-identically zero, it holds that:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{(A,\\mathbf{c})\\leftarrow_{\\mathbf{s}}L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}}\\big{(}f_{i}^{<em>}(\\mathbf{s}^{</em>})=0\\mid\\mathbf{e}_{i}=b\\big{)}\\leq 2/q,\\text{ with }b\\in\\{0,1\\}.</span></p>

    <p class="text-gray-300">The fact that the <span class="math">f_{i}^{<em>}(\\mathbf{s}^{</em>})</span> is a non-zero polynomial – viewed as a polynomial whose variables in the components of <span class="math">A</span> follows easily from <em>[5, Lemma 3.4]</em>.</p>

    <p class="text-gray-300">The same result holds if you replace <span class="math">f_{i}^{<em>}</span> by its linearization <span class="math">L_{f_{i}^{</em>}}</span>. Thus, for any <span class="math">\\mathbf{S}^{\\prime}=\\mathbf{s}^{\\prime}\\otimes\\mathbf{s}^{\\prime}\\in\\mathbb{Z}_{q}^{N_{2}}</span> with <span class="math">\\mathbf{s}^{\\prime}\\neq\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}</span>, it holds that:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{(A,\\mathbf{c})\\leftarrow_{\\mathbf{s}}L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}}\\big{(}L_{f_{1}}(\\mathbf{S}^{\\prime})=0,\\ldots,L_{f_{m}}(\\mathbf{S}^{\\prime})=0\\big{)}=\\prod_{i=1}^{m}\\Pr_{(A,\\mathbf{c})\\leftarrow_{\\mathbf{s}}L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}}\\big{(}L_{f_{i}}(\\mathbf{S}^{\\prime})=0\\big{)}.</span></p>

    <p class="text-gray-300">We then have <span class="math">\\Pr_{(A,\\mathbf{c})\\leftarrow_{\\mathbf{s}}L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}}\\big{(}L_{f_{i}}(\\mathbf{S}^{\\prime})=0\\big{)}=</span></p>

    <p class="text-gray-300"><span class="math">\\frac{1}{2}\\Pr_{(A,\\mathbf{c})\\leftarrow_{\\mathbf{s}}L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}}\\big{(}L_{f_{i}}(\\mathbf{S}^{\\prime})=0\\mid\\mathbf{e}_{i}=0\\big{)}+\\frac{1}{2}\\Pr_{(A,\\mathbf{c})\\leftarrow_{\\mathbf{s}}L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}}\\big{(}L_{f_{i}}(\\mathbf{S}^{\\prime})=0\\mid\\mathbf{e}_{i}=1\\big{)}\\leq 2/q.</span></p>

    <p class="text-gray-300">Finally, we consider the event <span class="math">E_{\\mathbf{S}^{\\prime}}=\\text{\`\`}L_{f_{1}}(\\mathbf{S}^{\\prime})=0,\\ldots,L_{f_{m}}(\\mathbf{S}^{\\prime})=0\\text{&#x27;&#x27;}</span>. The probability that the linearised system has more than one solution is the probability of the event <span class="math">\\cup_{\\mathbf{S}^{\\prime}}E_{\\mathbf{S}^{\\prime}}</span> which is:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{(A,\\mathbf{c})\\leftarrow_{\\mathbf{s}}L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}}(\\text{linearised system has not unique solution})\\leq 2^{m}\\cdot q^{N_{2}-m}.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">For linearisation to succeed (Theorem 9) we require a number of samples <span class="math">m\\geq c\\binom{n+2}{2}</span>. In contrast, for a Gröbner basis algorithm to succeed in polynomial time (Corollary 1) <span class="math">m=\\binom{n+1}{2}</span> suffices. Hence, applying a Gröbner basis algorithm reduces the number of samples required to solve BinaryError-LWE in polynomial-time and at the same degree as linearisation.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Semigenericity.</h4>

    <p class="text-gray-300">Following the terminology in <em>[29]</em>, we consider the notion of semigenericity.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">Let <span class="math">f_{1},\\ldots,f_{m}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span> be homogeneous equations of degree <span class="math">d</span>. We shall say that a sequence of polynomials <span class="math">f_{1},\\ldots,f_{m}</span> is semigeneric if <span class="math">\\{x_{i}\\cdot f_{j}\\}_{1\\leq i\\leq n}^{1\\leq j\\leq n}</span> spans a vector space of maximal dimension, i.e. <span class="math">\\min\\big{(}n\\cdot m,\\binom{d-1+n}{d}\\big{)}</span>. For affine polynomials <span class="math">f_{1},\\ldots,f_{m}\\in\\mathbb{Z}_{q}[x_{1},\\ldots,x_{n}]</span>, we shall say that the sequence <span class="math">f_{1},\\ldots,f_{m}</span> is semigeneric if <span class="math">f_{1}^{\\mathrm{H}},\\ldots,f_{m}^{\\mathrm{H}}</span> is semigeneric.</p>

    <p class="text-gray-300">For BinaryError-LWE, this corresponds to investigate Assumption 2 for Macaulay matrices at degree <span class="math">3</span>. In <em>[29, Theorem 2.2]</em>, the authors prove that the square of <span class="math">m</span> generic linear forms are semigeneric as long as <span class="math">m\\leq n+15</span> and <span class="math">n\\leq 6</span>. Here, we prove that system (15) is semigeneric for <span class="math">m\\leq n+\\lfloor\\frac{n-2}{2}\\rfloor\\approx(\\frac{3}{2})n</span> without any restriction on <span class="math">n</span> by employing a strategy similar to the proof of Theorem 8.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 10.</h6>

    <p class="text-gray-300">Let <span class="math">q=\\Omega(n^{2})</span> and let <span class="math">(A,\\mathbf{s}\\cdot A+\\mathbf{e})=(A,\\mathbf{c})\\in\\mathbb{Z}_{q}^{n\\times m}\\times\\mathbb{Z}_{q}^{m}</span> be sampled according to <span class="math">L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}</span>. For any <span class="math">m</span> such that <span class="math">1\\leq m\\leq n+\\lfloor\\frac{n-2}{2}\\rfloor</span> the sequence (15) is semigeneric with probability <span class="math">\\geq 1-\\frac{2mn}{q}</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">N</span> be the number of monomials of degree <span class="math">3</span> and let <span class="math">\\mathrm{Mat}_{3}</span> be a sub-matrix of size <span class="math">m\\cdot n\\times m\\cdot n</span> of the Macaulay matrix <span class="math">f_{1}^{\\mathrm{H}},\\ldots,f_{m}^{\\mathrm{H}}</span> at degree <span class="math">3</span>. We can view <span class="math">\\mathrm{Det}(\\mathrm{Mat}_{3})</span> as a polynomial <span class="math">p</span> of degree <span class="math">2mn</span> whose variables are the components of <span class="math">A</span>. According to Lemma 11 (Appendix A.3), <span class="math">p</span> is non-zero. Hence, Lemma 7 yields that <span class="math">p(A)\\neq 0</span> with probability <span class="math">\\geq 1-\\frac{2mn}{q}</span>. ∎</p>

    <p class="text-gray-300">Full Proof of Assumption 2 for <span class="math">m = n + 1</span>. We conclude this part by proving that Assumption 2 holds for <span class="math">m = n + 1</span> equations. However, the proof imposes a minimum size on <span class="math">q</span>.</p>

    <p class="text-gray-300">We will make use of the following lemma below for which the proof is exactly as for [29, Lemma 2.1].</p>

    <p class="text-gray-300"><strong>Lemma 8.</strong> Let <span class="math">P(x) = X(X - 1)</span> and consider a matrix <span class="math">A^{*} \\in \\mathbb{Z}_{q}^{n \\times n + 1}</span> such that all coefficients are zero except:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A^{*}[i,i] = 1</span>, for all <span class="math">i, 1 \\leq j \\leq n</span>.</li>

      <li><span class="math">A^{*}[i,n + 1] = 1</span>, for all <span class="math">i, 1 \\leq i \\leq n</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathbf{c} = \\mathbf{s} \\cdot A^{<em>} + \\mathbf{e}</span>, <span class="math">\\mathbf{s} \\in \\mathbb{Z}_q^n</span> be chosen uniformly at random, <span class="math">\\mathbf{e} \\in \\{0,1\\}^{n+1}</span> be sampled uniformly. Then, the sequence <span class="math">P\\big(c_1 - \\sum_{k=1}^n x_k A_{k,1}^</em>, \\ldots, P\\big(c_{n+1} - \\sum_{k=1}^n x_k A_{k,n+1}^* \\big) \\in \\mathbb{Z}_q[x_1, \\ldots, x_n]</span> is semi-regular.</p>

    <p class="text-gray-300"><strong>Example 1</strong> For <span class="math">n = 5</span> the matrix <span class="math">A^{*}</span> in Lemma 8 is</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{cccc} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right].</span></div>

    <p class="text-gray-300"><strong>Theorem 11.</strong> Let <span class="math">q = \\mathcal{O}(e^n)</span>, let <span class="math">(A, \\mathbf{s} \\cdot A + \\mathbf{e}) = (A, \\mathbf{c}) \\in \\mathbb{Z}_q^{n \\times m} \\times \\mathbb{Z}_q^m</span> be sampled according to <span class="math">L_{\\mathbf{s}, \\mathcal{U}(\\mathbb{F}_2)}^{(n)}</span>, and let <span class="math">P(X) = X(X - 1)</span>. With probability at least <span class="math">1 - o(1)</span>, it holds that the sequence <span class="math">f_1 = P\\big(c_1 - \\sum_{j=1}^n x_j A_{j,1}\\big), \\ldots, f_{n+1} = P\\big(c_{n+1} - \\sum_{j=1}^n x_j A_{j,n+1}\\big)</span> is semi-regular.</p>

    <p class="text-gray-300"><strong>Proof.</strong> It is well known that the degree of regularity of a semi-generic sequence of <span class="math">m = n + 1</span> equations is <span class="math">\\lceil \\frac{n + 1}{2} \\rceil</span>. So, we need to prove that the Macaulay matrices associated to <span class="math">f_1^{\\mathrm{H}}, \\ldots, f_{n + 1}^{\\mathrm{H}}</span> of degree 2 to <span class="math">\\frac{n + 1}{2}</span> are of maximal possible rank. That is, the only linear dependencies occurring in the Macaulay matrices are the one induces by the trivial syzygies, i.e. <span class="math">f_i^{\\mathrm{H}} f_j^{\\mathrm{H}} = f_j^{\\mathrm{H}} f_i^{\\mathrm{H}}</span>. Until now, we investigated degrees 2 and 3 for which there is no trivial syzygies.</p>

    <p class="text-gray-300">Let <span class="math">[t^d] \\mathrm{HP}(z)</span> be the <span class="math">d</span>th coefficient of the Hilbert polynomials (2). This coefficient gives the rank defects, and then the expected rank, of the Macaulay matrix of <span class="math">f_1^{\\mathrm{H}}, \\ldots, f_m^{\\mathrm{H}}</span> at degree <span class="math">d \\geq 2</span>. As in the previous proofs, we can write easily that Macaulay matrix of <span class="math">f_1^{\\mathrm{H}}, \\ldots, f_m^{\\mathrm{H}}</span> at each degree <span class="math">d</span> has the expected rank if a minor is non-zero. The degree of this minor is <span class="math">\\mathcal{O}\\left(n^{d - 1}\\right)</span>. To conclude the proof we note that Lemma 8 provides a family of sufficiently generic systems with <span class="math">m = n + 1</span> equations.</p>

    <p class="text-gray-300">We note that the results of this section can be adapted from BinaryError-LWE to UniformError-LWE.</p>

    <p class="text-gray-300">We can generalize for instance Theorem 8 to UniformError-LWE.</p>

    <p class="text-gray-300"><strong>Theorem 12.</strong> Let <span class="math">T &amp;gt; 0</span>, and <span class="math">(G, \\mathbf{s} \\times G + \\mathbf{e}) = (G, \\mathbf{c}) \\in \\mathbb{Z}_q^{n \\times m} \\times \\mathbb{Z}_q^m</span> be sampled according to <span class="math">L_{\\mathbf{s}, \\mathcal{U}([ -T, \\dots, T])}^{(n)}</span>. Let also <span class="math">P(x) = X \\prod_{i=1}^{T} (X - i)</span>. We assume that <span class="math">q &amp;gt; (2T + 1) \\cdot m</span>. For all <span class="math">1 \\leq m \\leq \\binom{n+1}{2}</span>, we define:</p>

    <div class="my-4 text-center"><span class="math-block">f_1 = P\\big(c_1 - \\sum_{j=1}^n x_j G_{j,1}\\big), \\ldots, f_m = P\\big(c_m - \\sum_{j=1}^n x_j G_{j,m}\\big).</span></div>

    <p class="text-gray-300">It holds that <span class="math">f_1^{\\mathrm{H}}, \\ldots, f_m^{\\mathrm{H}}</span> are linearly independent with probability <span class="math">\\geq 1 - \\frac{(2T + 1)m}{q}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">N</span> be the number of monomials of degree <span class="math">\\leq 2T + 1</span>. We define <span class="math">\\mathrm{Mac}</span> as <span class="math">m \\times N</span> matrix whose rows are the coefficients of the <span class="math">f_i</span>s. Let <span class="math">p = \\operatorname{Det}(\\mathrm{Mat})</span> be the determinant of a <span class="math">m \\times m</span> sub-matrix <span class="math">\\mathrm{Mat}</span> of <span class="math">\\mathrm{Mac}</span>. If <span class="math">p</span> is non-zero, Schwartz-Zippel-DeMillo-Lipton Lemma yields the result stated. The fact that <span class="math">p</span> is non-zero follows from a similar argument than Lemma 9.</p>

    <p class="text-gray-300">A.3 Auxiliary Lemmas</p>

    <p class="text-gray-300">This appendix collects proofs allowing to show that tge polynomials used in Appendix A.2 are non-zero which allows us to apply Schwartz-Zippel-DeMillo-Lipton Lemma.</p>

    <p class="text-gray-300">The lemma below is used in Theorem 8 to show that the determinant considered is non-zero.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">For all <span class="math">i,1\\leq i\\leq n</span>, construct a <span class="math">n\\times\\big{(}n-(i-1)\\big{)}</span> matrix <span class="math">G_{i}</span> as follows. All the coefficients of <span class="math">G_{i}</span> are zero except:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G_{i}[i,j]=1</span>, for all <span class="math">j,1\\leq j\\leq\\big{(}n-(i-1)\\big{)}</span>.</li>

      <li><span class="math">G_{i}[j+(i-1),j]=1</span>, for all <span class="math">j,1\\leq j\\leq\\big{(}n-(i-1)\\big{)}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, let $G^{*}=G_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{n}<span class="math"> be a block matrix, </span>\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}<span class="math"> chosen uniformly at random, and </span>\\mathbf{e}\\in\\{0,1\\}^{m}<span class="math"> sampled uniformly. We set </span>\\mathbf{c}=\\mathbf{s}\\times G^{*}+\\mathbf{e}<span class="math"> and </span>P(x)=X(X-1)$ and define:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f_{1}=P\\big{(}c_{1}-\\sum_{j=1}^{n}x_{j}G^{<em>}_{j,1}\\big{)},\\ \\dots\\ ,f_{m}=P\\big{(}c_{m}-\\sum_{j=1}^{n}x_{j}G^{</em>}_{j,m}\\big{)}.</span></p>

    <p class="text-gray-300">Then, the homogeneous components <span class="math">f_{1}^{\\mathrm{H}},\\dots,f_{m}^{\\mathrm{H}}</span> of degree <span class="math">2</span> are linearly independent.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">f_{i,j}</span> be the the <span class="math">j</span>th equation derived from the matrix <span class="math">G_{i}</span> (the equation corresponding to the <span class="math">jth</span> column of the <span class="math">i</span>th matrix <span class="math">G_{i}</span>) . We start with the simple case <span class="math">m=n</span> where <span class="math">G^{*}=G_{1}</span>. The monomial of highest degree in <span class="math">f_{1,1}=P(c_{1}-x_{1})</span> is simply <span class="math">x_{1}^{2}</span>. More generally, for all <span class="math">i,1\\leq j\\leq n</span>, the monomials of degree <span class="math">2</span> in <span class="math">f_{1,j}=P(c_{j}-x_{1}-x_{j})</span> are <span class="math">x_{1}^{2},x_{1}x_{j}</span> and <span class="math">x_{j}^{2}</span>. Remark then that the system</p>

    <p class="text-gray-300"><span class="math">F_{1}:=[\\tilde{f}_{1,1}=f_{1,1},\\tilde{f}_{1,2}=-f_{1,1}+f_{1,2},\\dots,\\tilde{f}_{1,n}=-f_{1,1}+f_{1,n}]</span></p>

    <p class="text-gray-300">has a triangular shape: the leading monomial of <span class="math">\\tilde{f}_{1,j}</span> is <span class="math">x_{1}\\cdot x_{j}</span> (all the terms of degree <span class="math">2</span> divisible by <span class="math">x_{1}</span>) and hence distinct.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More generally, let $G^{*}=G_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{3}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{n}<span class="math">. We consider, for all </span>i,1\\leq i\\leq n$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">F_{i}:=[\\tilde{f}_{i,1}=f_{i,1},\\tilde{f}_{i,2}=-f_{i,1}+f_{i,2},\\dots,\\tilde{f}_{i,n-i+1}=-f_{i,1}+f_{i,n-i+1}].</span> (16)</p>

    <p class="text-gray-300">All these equations are in triangular form, and leading monomials of <span class="math">F_{i}</span> are the monomials <span class="math">x_{i}x_{j}</span>, with <span class="math">j\\geq i</span>. Consequently the set of equations <span class="math">\\bigcup_{1\\leq i\\leq n}F_{i}</span> are linearly independent. Finally, the numbers of rows of <span class="math">G^{*}</span> is <span class="math">n+(n-1)+(n-2)+\\cdots(n-(n-1))=n^{2}-n(n-1)/2=n(n+1)/2={n+1\\choose 2}</span>. ∎</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Example 2.</h6>

    <p class="text-gray-300">For <span class="math">n=4</span>, and <span class="math">m=n(n+1)/2=10</span> the matrix <span class="math">G^{*}</span> is as follows:</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}1&1&1&1&0&0&0&0&0\\\\ 0&1&0&0&1&1&1&0&0\\\\ 0&0&1&0&0&1&0&1&1&0\\\\ 0&0&0&1&0&0&1&0&1&1\\end{bmatrix}. \\]</p>

    <p class="text-gray-300">The equations <span class="math">f_{i,j}</span> corresponding are then</p>

    <p class="text-gray-300"><span class="math">[x_{1}^{2}+15\\cdot x_{1}+5,</span> <span class="math">x_{1}^{2}+2\\cdot x_{1}\\cdot x_{2}+x_{2}^{2}+4,</span> <span class="math">x_{1}^{2}+2\\cdot x_{1}\\cdot x_{3}+x_{3}^{2}+10\\cdot x_{1}+10\\cdot x_{3}+12,</span> <span class="math">x_{1}^{2}+2\\cdot x_{1}\\cdot x_{4}+x_{4}^{2}+9\\cdot x_{1}+9\\cdot x_{4}+3,</span> <span class="math">x_{2}^{2}+5\\cdot x_{2}+6,</span> <span class="math">x_{2}^{2}+2\\cdot x_{2}\\cdot x_{3}+x_{3}^{2}+4,</span> <span class="math">x_{2}^{2}+2\\cdot x_{2}\\cdot x_{4}+x_{4}^{2}+16\\cdot x_{2}+16\\cdot x_{4},</span> <span class="math">x_{3}^{2}+13\\cdot x_{3}+8,</span> <span class="math">x_{3}^{2}+2\\cdot x_{3}\\cdot x_{4}+x_{4}^{2}+7\\cdot x_{3}+7\\cdot x_{4}+12,</span> <span class="math">x_{4}^{2}+14\\cdot x_{4}+2].</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">By performing the reductions as in (16), we get:</p>

    <p class="text-gray-300"><span class="math">[\\mathbf{x_{1}^{2}}+15\\cdot x_{1}+5,</span> <span class="math">\\mathbf{2}\\cdot\\mathbf{x_{1}}\\cdot\\mathbf{x_{2}}+x_{2}^{2}+2\\cdot x_{1}+16,</span> <span class="math">\\mathbf{2}\\cdot\\mathbf{x_{1}}\\cdot\\mathbf{x_{3}}+x_{3}^{2}+12\\cdot x_{1}+10\\cdot x_{3}+7,</span> <span class="math">\\mathbf{2}\\cdot\\mathbf{x_{1}}\\cdot\\mathbf{x_{4}}+x_{4}^{2}+11\\cdot x_{1}+9\\cdot x_{4}+15,</span> <span class="math">\\mathbf{x_{2}^{2}}+\\mathbf{5}\\cdot\\mathbf{x_{2}}+6,</span> <span class="math">\\mathbf{2}\\cdot\\mathbf{x_{2}}\\cdot\\mathbf{x_{3}}+x_{3}^{2}+12\\cdot x_{2}+15,</span> <span class="math">\\mathbf{2}\\cdot\\mathbf{x_{2}}\\cdot\\mathbf{x_{4}}+x_{4}^{2}+11\\cdot x_{2}+16\\cdot x_{4}+11,</span> <span class="math">\\mathbf{x_{3}^{2}}+\\mathbf{13}\\cdot\\mathbf{x_{3}}+8,</span> <span class="math">\\mathbf{2}\\cdot\\mathbf{x_{3}}\\cdot\\mathbf{x_{4}}+x_{4}^{2}+11\\cdot x_{3}+7\\cdot x_{4}+4,</span> <span class="math">\\mathbf{x_{4}^{2}}+14\\cdot x_{4}+2].</span></p>

    <p class="text-gray-300">In order to prove Theorem 13, we first consider the case where <span class="math">m=n</span> as an intermediate step.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 13.</h6>

    <p class="text-gray-300">We assume <span class="math">q=\\Omega(n^{2})</span>. Let <span class="math">(G,\\mathbf{s}\\times G+\\mathbf{e})=(G,\\mathbf{c})\\in\\mathbb{Z}_{q}^{n\\times m}\\times\\mathbb{Z}_{q}^{m}</span> be sampled according to <span class="math">L^{(n)}_{\\mathbf{s},\\mathcal{U}(\\mathbb{F}_{2})}</span>, and let <span class="math">P(x)=X(X-1)</span>. For any <span class="math">m,1\\leq m\\leq n</span>, the equations</p>

    <p class="text-gray-300"><span class="math">f_{1}=P\\big{(}c_{1}-\\sum_{j=1}^{n}x_{j}G_{j,1}\\big{)},\\ \\ldots\\ ,f_{m}=P\\big{(}c_{m}-\\sum_{j=1}^{n}x_{j}G_{j,m}\\big{)},</span></p>

    <p class="text-gray-300">are semigeneric with probability <span class="math">\\geq 1-\\frac{2mn}{q}</span>.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The strategy is similar to the proof of Theorem 8. Let <span class="math">N</span> be the number of monomials of degree <span class="math">3</span> and let <span class="math">\\mathrm{Mat}_{3}</span> be a sub-matrix of size <span class="math">m\\cdot n\\times m\\cdot n</span> of the Macaulay matrix at at degree <span class="math">3</span> of <span class="math">f_{1}^{\\mathrm{H}},\\ldots,f_{m}^{\\mathrm{H}}</span>. We can view <span class="math">\\mathrm{Det}(\\mathrm{Mat}_{3})</span> as a polynomial <span class="math">p</span> of degree <span class="math">2mn</span> whose variables are the components of <span class="math">G</span>. The next result shows that the determinant polynomial considered is not identically zero.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">Let <span class="math">P(x)=X(X-1)</span>. Let <span class="math">G^{<em>}=G_{1}</span> be as defined in Lemma 9. We set <span class="math">\\mathbf{c}=\\mathbf{s}\\times G^{</em>}+\\mathbf{e}</span>, <span class="math">\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}</span> chosen uniformly at random, <span class="math">m=n</span> and <span class="math">\\mathbf{e}\\in\\{0,1\\}^{m}</span> sampled uniformly. We define:</p>

    <p class="text-gray-300"><span class="math">f_{1}=P\\big{(}c_{1}-\\sum_{k=1}^{n}x_{k}G_{k,1}^{<em>}\\big{)},\\ \\ldots\\ ,f_{m}=P\\big{(}c_{m}-\\sum_{k=1}^{n}x_{k}G_{k,m}^{</em>}\\big{)}.</span></p>

    <p class="text-gray-300">Then, the polynomials <span class="math">f_{1},\\ldots,f_{m}</span> are semi-generic.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first perform a simple reduction on the <span class="math">f_{j}</span>, that is:</p>

    <p class="text-gray-300"><span class="math">\\tilde{f}_{2}=\\tilde{f}_{2}-f_{1},\\ldots,\\tilde{f}_{n}=\\tilde{f}_{n}-f_{1},\\tilde{f}_{1}=2f_{1}.</span></p>

    <p class="text-gray-300">From now on, we consider a degree ordering for which <span class="math">x_{1}&gt;x_{2}&gt;\\ldots&gt;x_{n}</span>. It holds that</p>

    <p class="text-gray-300"><span class="math">\\mathrm{LT}(\\tilde{f}_{j})=2\\cdot x_{1}\\cdot x_{j},\\forall j,1\\leq j\\leq n.</span></p>

    <p class="text-gray-300">We can see that the terms of degree <span class="math">3</span> in <span class="math">x_{i}\\cdot\\tilde{f}_{1}</span> is equal to <span class="math">T_{i,1}^{(1)}:=\\{2x_{1}^{2}x_{i}\\}_{1\\leq i\\leq n}</span>. Similarly, we have that <span class="math">T_{i,j}^{(1)}:=\\{2\\cdot x_{1}x_{i}x_{j},x_{i}x_{j}^{2}\\}_{1\\leq i\\leq n}^{2\\leq j\\leq n}</span> are terms of degree <span class="math">3</span> in <span class="math">x_{i}\\cdot\\tilde{f}_{j}</span> (with <span class="math">j\\neq 1</span>).</p>

    <p class="text-gray-300">We consider a matrix <span class="math">M^{(1)}:=\\{M^{(1)}[i,j]=x_{i}\\cdot\\tilde{f}_{j}\\}_{1\\leq i\\leq n}^{1\\leq j\\leq m}</span> and define <span class="math">r_{i,j}^{(1)}</span> as the function which returns <span class="math">\\mathrm{LT}(M^{(1)}[i,j])</span>. For all <span class="math">(i,j)\\in[1,\\ldots,n]\\times[1,\\ldots,n]</span>, we have: <span class="math">r_{i,j}^{(1)}=2\\cdot x_{1}\\cdot x_{i}\\cdot x_{j}</span>. Hence, <span class="math">r_{i,j}^{(1)}=r_{j,i}^{(1)}</span> for all <span class="math">(i,j)\\in[1,\\ldots,n]\\times[1,\\ldots,n]</span>. So, <span class="math">M^{(1)}[i,j]</span> and <span class="math">M^{(1)}[j,i]</span> have the same leading terms. Our goal is to perform suitable linear combinations on the polynomials of <span class="math">M^{(1)}[i,j]</span> such that all components have distinct leading terms.</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">We first process the first column and first row of <span class="math">M^{(1)}</span>. We define <span class="math">C_1 := \\{(i, 1) \\mid i \\in [1, \\ldots, n]\\}</span>, and <span class="math">R_1 := \\{(1, j) \\mid j \\in [2, \\ldots, n]\\}</span>. For all <span class="math">(i, j) = (i, 1) \\in C_1</span>, we have <span class="math">\\mathrm{LT}(M^{(1)}[i, 1]) = 2 \\cdot x_1^2 \\cdot x_i</span>. For all <span class="math">(i, j) = (1, j) \\in R_1</span>, we have also <span class="math">\\mathrm{LT}(M^{(1)}[1, j]) = 2 \\cdot x_1^2 \\cdot x_j</span>. Thus, for all <span class="math">(1, j) \\in R_1</span>, we update <span class="math">M^{(1)}[1, j]</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">M ^ {(1)} [ 1, j ] = M ^ {(1)} [ 1, j ] - M ^ {(1)} [ j, 1 ].</span></div>

    <p class="text-gray-300">After this step, for all <span class="math">(1,j)\\in R_1</span>, the term of degree 3 in <span class="math">M^{(1)}[1,j]</span> is now <span class="math">T_{1,j}^{(1)} \\coloneqq \\{x_1x_j^2\\}</span> and then <span class="math">r_{1,j}^{(1)} \\coloneqq x_1x_j^2</span>. For all <span class="math">(i,1)\\in C_1</span>, we still have <span class="math">r_{i,1}^{(1)} \\coloneqq 2x_1^2 \\cdot x_i</span> and <span class="math">T_{i,1}^{(1)} \\coloneqq \\{2x_1^2 x_i\\}</span>.</p>

    <p class="text-gray-300">Now, we consider the set <span class="math">L_{1} := \\{(i,j) \\in [2,\\dots,n] \\times [2,\\dots,n] \\mid i - j \\geq 0\\}</span>. This is the lower diagonal part. For all <span class="math">(i,j) \\in L_{1}</span>, with <span class="math">i \\neq j</span>, we update the matrix <span class="math">M^{(1)}</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">M ^ {(1)} [ i, j ] = M ^ {(1)} [ i, j ] - M ^ {(1)} [ j, i ]</span></div>

    <p class="text-gray-300">For <span class="math">(i,i)\\in L_1</span>, we have that <span class="math">r_{i,i}^{(1)} = 2x_1x_i^2</span>. However, <span class="math">x_{1}^{2}x_{i} = r_{1,i}^{(1)} / 2</span>, we then update the elements of the diagonal as follows:</p>

    <div class="my-4 text-center"><span class="math-block">M ^ {(1)} [ i, i ] = M ^ {(1)} [ i, i ] - 2 \\cdot M ^ {(1)} [ 1, i ].</span></div>

    <p class="text-gray-300">After this step, for all <span class="math">(i,j)\\in L_1</span>, with <span class="math">i\\neq j</span>, the terms of degree 3 in <span class="math">M^{(1)}[i,j]</span> is <span class="math">T_{i,j}^{(1)} = \\{x_j^2 x_i, - x_jx_i^2\\}</span> and we set <span class="math">r_{i,j}^{(1)}\\coloneqq x_j^2 x_i</span>. For <span class="math">i = j &amp;gt; 1</span>, <span class="math">T_{i,i}^{(1)}</span> reduces to <span class="math">\\{x_j^3\\}</span>.</p>

    <p class="text-gray-300">For all <span class="math">(i,j)\\in L_1</span>, the terms <span class="math">r_{i,j}^{(1)}</span> are distinct. Indeed, given <span class="math">(i,j)\\in L_1</span>, the only solution <span class="math">(i&#x27;,j&#x27;)\\in L_1</span> to <span class="math">r_{i,j}^{(1)} = r_{i&#x27;,j&#x27;}^{(1)}</span> is trivial, i.e. <span class="math">(i = i&#x27;,j = j&#x27;)</span>.</p>

    <p class="text-gray-300">Now, let <span class="math">U_{1} \\coloneqq \\{(i,j) \\in [2,\\dots,n] \\times [2,\\dots,n] \\mid i - j &amp;lt; 0\\}</span>. For all <span class="math">(i,j) \\in U_{1}</span>, we have <span class="math">r_{i,j}^{(1)} = 2x_{1}x_{i}x_{j}</span>. For all <span class="math">(i,j) \\in U_{1}</span>, the terms <span class="math">r_{i,j}^{(1)}</span> are distinct. Indeed, given <span class="math">(i,j) \\in U_{1}</span>, the only non-trivial solution <span class="math">(i&#x27;,j&#x27;) \\in U_{1}</span> to <span class="math">r_{i,j}^{(1)} = r_{i&#x27;,j&#x27;}^{(1)}</span> is <span class="math">(i&#x27; = j, j&#x27; = i)</span>. Since <span class="math">(i,j) \\in U_{1}</span>, this implies that <span class="math">i&#x27; - j&#x27; &amp;gt; 0</span> and then <span class="math">(i&#x27;,j&#x27;) \\notin U_{1}</span>. For all, <span class="math">(i,j) \\in U_{1}</span>, the terms of degree 3 of <span class="math">M^{(1)}[i,j]</span> remains <span class="math">T_{i,j}^{(1)} \\coloneqq \\{2x_1x_ix_j,x_ix_j^2\\}_{1\\leq i\\leq n}^{2\\leq j\\leq n}</span>.</p>

    <p class="text-gray-300">To summarize:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r_{i,1}^{(1)} := r_{i,1}^{C_1} = 2x_1^2 x_i</span>, for all <span class="math">i, 1 \\leq i \\leq n</span>,</li>

      <li><span class="math">r_{1,j}^{(1)} := r_{1,j}^{R_1} = x_1x_j^2</span>, for all <span class="math">j, 2 \\leq j \\leq n</span>,</li>

      <li><span class="math">r_{i,j}^{(1)} := r_{i,j}^{U_1} = 2x_1x_ix_j</span>, for all <span class="math">(i,j) \\in U_1</span>,</li>

      <li><span class="math">r_{i,j}^{(1)} := r_{i,j}^{L_1} = x_j^2 x_i</span>, for all <span class="math">(i,j) \\in L_1</span>.</li>

    </ul>

    <p class="text-gray-300">Example 3 For <span class="math">n = 4</span>, <span class="math">G^{*} = G_{1}</span> is as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{l l l l} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right].</span></div>

    <p class="text-gray-300">The equations <span class="math">\\tilde{f}_j</span> corresponding are:</p>

    <div class="my-4 text-center"><span class="math-block">[ 2 \\cdot x _ {1} ^ {2} + 1 4 \\cdot x _ {1} + 7,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot x _ {1} \\cdot x _ {2} + x _ {2} ^ {2} + 1 6 \\cdot x _ {1} + 6 \\cdot x _ {2} + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot x _ {1} \\cdot x _ {3} + x _ {3} ^ {2} + 1 3 \\cdot x _ {1} + 3 \\cdot x _ {3} + 7,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot x _ {1} \\cdot x _ {4} + x _ {4} ^ {2} + 1 4 \\cdot x _ {1} + 4 \\cdot x _ {4} + 1 3].</span></div>

    <p class="text-gray-300">By performing the reductions as in the previous lemma, we get:</p>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {2} \\cdot \\mathbf {x} _ {1} ^ {\\mathbf {3}} + 1 4 \\cdot x _ {1} ^ {2} + 7 \\cdot x _ {1}, \\mathbf {2} \\cdot \\mathbf {x} _ {1} ^ {\\mathbf {2}} \\cdot \\mathbf {x} _ {2} + 1 4 \\cdot x _ {1} \\cdot x _ {2} + 7 \\cdot x _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {2} \\cdot \\mathbf {x} _ {1} ^ {2} \\cdot \\mathbf {x} _ {3} + 1 4 \\cdot x _ {1} \\cdot x _ {3} + 7 \\cdot x _ {3},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {2} \\cdot \\mathbf {x} _ {1} ^ {2} \\cdot \\mathbf {x} _ {4} + 1 4 \\cdot x _ {1} \\cdot x _ {4} + 7 \\cdot x _ {4},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {1} \\cdot \\mathbf {x} _ {2} ^ {2} + 1 6 \\cdot x _ {1} ^ {2} + 9 \\cdot x _ {1} \\cdot x _ {2} + x _ {1} + 1 0 \\cdot x _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {2} \\cdot \\mathbf {x} _ {1} \\cdot \\mathbf {x} _ {2} \\cdot \\mathbf {x} _ {3} + x _ {2} \\cdot x _ {3} ^ {2} + 1 3 \\cdot x _ {1} \\cdot x _ {2} + 3 \\cdot x _ {2} \\cdot x _ {3} + 7 \\cdot x _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {2} \\cdot \\mathbf {x} _ {1} \\cdot \\mathbf {x} _ {2} \\cdot \\mathbf {x} _ {4} + x _ {2} \\cdot x _ {4} ^ {2} + 1 4 \\cdot x _ {1} \\cdot x _ {2} + 4 \\cdot x _ {2} \\cdot x _ {4} + 1 3 \\cdot x _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {1} \\cdot \\mathbf {x} _ {3} ^ {2} + 1 3 \\cdot x _ {1} ^ {2} + 6 \\cdot x _ {1} \\cdot x _ {3} + 7 \\cdot x _ {1} + 1 0 \\cdot x _ {3},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {2} \\cdot \\mathbf {x} _ {1} \\cdot \\mathbf {x} _ {3} \\cdot \\mathbf {x} _ {4} + x _ {3} \\cdot x _ {4} ^ {2} + 1 4 \\cdot x _ {1} \\cdot x _ {3} + 4 \\cdot x _ {3} \\cdot x _ {4} + 1 3 \\cdot x _ {3},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {1} \\cdot \\mathbf {x} _ {4} ^ {2} + 1 4 \\cdot x _ {1} ^ {2} + 7 \\cdot x _ {1} \\cdot x _ {4} + 1 3 \\cdot x _ {1} + 1 0 \\cdot x _ {4},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {2} ^ {3} + \\mathbf {2} \\cdot \\mathbf {x} _ {1} ^ {2} + 1 5 \\cdot x _ {1} \\cdot x _ {2} + 6 \\cdot x _ {2} ^ {2} + 1 5 \\cdot x _ {1} + 1 5 \\cdot x _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {2} ^ {2} \\cdot \\mathbf {x} _ {3} + 1 6 \\cdot x _ {2} \\cdot x _ {3} ^ {2} + 4 \\cdot x _ {1} \\cdot x _ {2} + 1 6 \\cdot x _ {1} \\cdot x _ {3} + 3 \\cdot x _ {2} \\cdot x _ {3} + 1 0 \\cdot x _ {2} + x _ {3},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {2} ^ {2} \\cdot \\mathbf {x} _ {4} + 1 6 \\cdot x _ {2} \\cdot x _ {4} ^ {2} + 3 \\cdot x _ {1} \\cdot x _ {2} + 1 6 \\cdot x _ {1} \\cdot x _ {4} + 2 \\cdot x _ {2} \\cdot x _ {4} + 4 \\cdot x _ {2} + x _ {4},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {3} ^ {3} + 8 \\cdot x _ {1} ^ {2} + x _ {1} \\cdot x _ {3} + 3 \\cdot x _ {3} ^ {2} + 3 \\cdot x _ {1} + 4 \\cdot x _ {3},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {3} ^ {2} \\cdot \\mathbf {x} _ {4} + 1 6 \\cdot x _ {3} \\cdot x _ {4} ^ {2} + 3 \\cdot x _ {1} \\cdot x _ {3} + 1 3 \\cdot x _ {1} \\cdot x _ {4} + 1 6 \\cdot x _ {3} \\cdot x _ {4} + 4 \\cdot x _ {3} + 7 \\cdot x _ {4},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {4} ^ {3} + 6 \\cdot x _ {1} ^ {2} + 4 \\cdot x _ {4} ^ {2} + 8 \\cdot x _ {1} + 1 0 \\cdot x _ {4} ].</span></div>

    <p class="text-gray-300">Finally, the following lemma is used in Theorem 10.</p>

    <p class="text-gray-300"><strong>Lemma 11.</strong> Let <span class="math">P(x) = X(X - 1)</span>. Let <span class="math">G_{1}</span> be defined as in Lemma 10. We consider a <span class="math">n \\times m_{2}</span> matrix <span class="math">G_{2}</span>, with <span class="math">m_{2} = \\left\\lfloor \\frac{n - 2}{2} \\right\\rfloor</span>. The coefficients are zero except for:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G_{2}[2,j] = 1</span>, for all <span class="math">j, 1 \\leq j \\leq m_{2}</span>.</li>

      <li><span class="math">G_{2}[2j + 1,j] = G_{2}[2j + 2,j] = 1</span>, for all <span class="math">j, 1 \\leq j \\leq m_{2}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">m = n + m_2</span>, $G^* = G_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_2<span class="math"> be a block matrix of size </span>n \\times m<span class="math">. We set </span>\\mathbf{c} = \\mathbf{s} \\times G^* + \\mathbf{e}<span class="math">, </span>\\mathbf{s} \\in \\mathbb{Z}_q^n<span class="math"> chosen uniformly at random, and </span>\\mathbf{e} \\in \\{0, 1\\}^m$ sampled uniformly. We define:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">f _ {1} = P \\left(c _ {1} - \\sum_ {k = 1} ^ {n} x _ {k} G _ {k, 1} ^ {*}\\right), \\dots , f _ {m} = P \\left(c _ {m} - \\sum_ {k = 1} ^ {n} x _ {k} G _ {k, m} ^ {*}\\right).</span></div>

    <p class="text-gray-300">Then, the sequence <span class="math">f_{1}, \\ldots, f_{m}</span> is semigeneric.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">M^{(1)}</span> be the matrix constructed as in Lemma 10. The matrix is such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall (1,j)\\in R_1</span>, the term of degree 3 in <span class="math">M^{(1)}[1,j]</span> is <span class="math">T_{1,j}^{(1)} \\coloneqq \\{x_1x_j^2\\}</span>.</li>

      <li><span class="math">\\forall (i,1)\\in C_1</span>, the term of degree 3 in <span class="math">M^{(1)}[i,1]</span> is <span class="math">T_{i,1}^{(1)} \\coloneqq \\{2x_1^2 x_i\\}</span>.</li>

      <li><span class="math">\\forall (i,j)\\in U_1</span>, the terms of degree 3 of <span class="math">M^{(1)}[i,j]</span> is <span class="math">T_{i,j}^{(1)} \\coloneqq \\{2x_1x_ix_j,x_ix_j^2\\}_{1\\leq i\\leq n}^{2\\leq j\\leq n}</span>.</li>

      <li><span class="math">\\forall (i,j)\\in L_1</span>, <span class="math">i\\neq j</span>, the terms of degree 3 in <span class="math">M_{i,j}^{(1)}</span> is <span class="math">T_{i,j}^{(1)} \\coloneqq \\{x_j^2 x_i, - x_jx_i^2\\}</span>.</li>

      <li>The terms of degree 3 in <span class="math">M_{i,i}^{(1)}</span> (<span class="math">i &amp;gt; 1</span>) is <span class="math">T_{i,i}^{(1)} \\coloneqq \\{x_i^3\\}</span>.</li>

    </ul>

    <p class="text-gray-300">The leading terms of the polynomials in <span class="math">M^{(1)}</span> are then divided by a square or divided by <span class="math">x_{1}</span>. In fact, all the terms of degree 3 divisible by <span class="math">x_{1}</span> appear as leading terms.</p>

    <p class="text-gray-300">For all <span class="math">j, 1 \\leq j \\leq m_2</span>, we denote by <span class="math">f_{2,j} = f_{m_1 + j}</span> the equations derived from <span class="math">G_2</span>. This is the polynomial constructed from the <span class="math">j</span>th column of <span class="math">G_2</span>. We define by</p>

    <div class="my-4 text-center"><span class="math-block">T _ {i, j} ^ {(2)} := \\left\\{x _ {i} x _ {2} ^ {2}, x _ {i} x _ {2 j + 1} ^ {2}, x _ {i} x _ {2 j + 2} ^ {2}, 2 x _ {i} x _ {2} x _ {2 j + 1}, 2 x _ {i} x _ {2} x _ {2 j + 2}, 2 x _ {i} x _ {2 j + 1} x _ {2 j + 2} \\right\\} _ {1 \\leq i \\leq n} ^ {1 \\leq j \\leq m _ {2}}</span></div>

    <p class="text-gray-300">the terms of degree <span class="math">3</span> in <span class="math">x_{i}\\cdot f_{2,j}</span>. We also consider a matrix <span class="math">M^{(2)}:=\\{M^{(2)}[i,j]=x_{i}\\cdot f_{2,j}\\}_{1\\leq i\\leq n}^{1\\leq j\\leq m_{2}}</span>. The first step of the proof is to perform all possible reductions of the polynomials in <span class="math">M^{(2)}</span> modulo the polynomials <span class="math">M^{(1)}[i,j]</span>.</p>

    <p class="text-gray-300">The term <span class="math">x_{i}x_{2}^{2}</span> can always be reduced by the leading term of a polynomial in the second column of <span class="math">M^{(1)}</span>. For all <span class="math">(i,j)\\in[1,\\ldots,n]\\times[1,\\ldots,m_{2}]</span>, we cancel this term as follows:</p>

    <p class="text-gray-300"><span class="math">M^{(2)}[i,j]=M^{(2)}[i,j]-M^{(1)}[i,2].</span></p>

    <p class="text-gray-300">After such reductions, the terms of degree <span class="math">3</span> in <span class="math">M^{(2)}[i,j]</span> is updated as:</p>

    <p class="text-gray-300"><span class="math">T_{i,j}^{(2)}=\\{x_{2}x_{i}^{2},x_{i}x_{2j+1}^{2},x_{i}x_{2j+2}^{2},2\\,x_{i}x_{2}x_{2j+1},2\\,x_{i}x_{2}x_{2j+2},2x_{i}x_{2j+1}x_{2j+2}\\},\\text{ for }i&gt;2.</span></p>

    <p class="text-gray-300">For <span class="math">i=1,2</span> the only difference is that the term <span class="math">x_{2}x_{i}^{2}</span> not appear in <span class="math">T_{i,j}^{(2)}</span>.</p>

    <p class="text-gray-300">We consider the particular case of the first row <span class="math">M^{(2)}</span>:</p>

    <p class="text-gray-300"><span class="math">T_{1,j}^{(2)}=\\{2\\,x_{1}x_{2}x_{2j+1},2\\,x_{1}x_{2}x_{2j+2},x_{1}x_{2j+1}^{2},2x_{1}x_{2j+1}x_{2j+2},x_{1}x_{2j+2}^{2}\\}.</span></p>

    <p class="text-gray-300">We can see that all these terms can be reduced by the leading terms of a suitable <span class="math">M^{(1)}[i,j]</span>. More precisely, <span class="math">x_{1}x_{2j+1}^{2}</span>, and <span class="math">x_{1}x_{2j+2}^{2}</span> can be reduced by <span class="math">M^{(1)}[1,2j+1]</span> and <span class="math">M^{(1)}[1,2j+2]</span> respectively. Thus, for all <span class="math">j,1\\leq j\\leq m_{2}</span>, we update the matrix as follows:</p>

    <p class="text-gray-300"><span class="math">M^{(2)}[1,j]=M^{(2)}[1,j]-M^{(1)}[1,2j+1]-M^{(1)}[1,2j+2].</span></p>

    <p class="text-gray-300">The corresponding reductions will only yield new terms of degree <span class="math">&lt;3</span>.</p>

    <p class="text-gray-300">Similarly, <span class="math">x_{1}x_{2}x_{2j+1},x_{1}x_{2}x_{2j+2},x_{1}x_{2j+1}x_{2j+2}</span> can be reduced by a <span class="math">M^{(1)}[i^{\\prime},j^{\\prime}]</span> with <span class="math">(i^{\\prime},j^{\\prime})\\in U_{1}</span>. Thus, for all <span class="math">j,1\\leq j\\leq m_{2}</span>, we update the matrix as follows:</p>

    <p class="text-gray-300"><span class="math">M^{(2)}[1,j]=-M^{(2)}[1,j]+M^{(1)}[2,2j+1]+M^{(1)}[2,2j+2]+M^{(1)}[2j+1,2j+2].</span></p>

    <p class="text-gray-300">After this step, we have:</p>

    <p class="text-gray-300"><span class="math">T_{1,j}^{(2)}=\\{x_{2}x_{2j+1}^{2},x_{2}x_{2j+2}^{2},x_{2j+1}x_{2j+2}^{2}\\}\\text{ and }\\mathrm{LT}(M^{(2)}[1,j])=x_{2}x_{2j+1}^{2}.</span></p>

    <p class="text-gray-300">We consider then the second row of <span class="math">M^{(2)}</span> whose terms of degree <span class="math">3</span> are:</p>

    <p class="text-gray-300"><span class="math">T_{2,j}^{(2)}=\\{2\\,x_{2}^{2}x_{2j+1},2\\,x_{2}^{2}x_{2j+2},x_{2}x_{2j+1}^{2},2\\,x_{2}x_{2j+1}x_{2j+2},x_{2}x_{2j+2}^{2}\\}.</span></p>

    <p class="text-gray-300">We can again reduce <span class="math">x_{2}^{2}x_{2j+1}</span> and <span class="math">x_{2}^{2}x_{2j+2}</span> by the leading terms of polynomials of <span class="math">M^{(1)}</span>. However, the reduction will create new elements <span class="math">x_{2}x_{2j+1}^{2}</span> and <span class="math">x_{2}x_{2j+2}^{2}</span> which are irreducible modulo <span class="math">\\mathrm{LT}(M^{(1)})</span>. For all <span class="math">j,1\\leq j\\leq m_{2}</span>, we set:</p>

    <p class="text-gray-300"><span class="math">M^{(2)}[2,j]=M^{(2)}[2,j]-2\\,M^{(1)}[2j+1,2]-2\\,M^{(1)}[2j+2,2].</span></p>

    <p class="text-gray-300">After this step, we have</p>

    <p class="text-gray-300"><span class="math">T_{2,j}^{(2)}=\\{3\\,x_{2}x_{2j+1}^{2},2\\,x_{2}x_{2j+1}x_{2j+2},3\\,x_{2}x_{2j+2}^{2}\\}\\text{ and }\\mathrm{LT}(M^{(2)}[1,j])=3\\,x_{2}x_{2j+1}^{2}.</span></p>

    <p class="text-gray-300"><span class="math">T_{2,j}^{(2)}</span> and <span class="math">T_{2,j}^{(2)}</span> can not be further reduced by <span class="math">\\mathrm{LT}(M^{(1)})</span>.</p>

    <p class="text-gray-300">Let <span class="math">U_{2}:=\\{(i,j)\\in[4,\\ldots,n]\\times[1,\\ldots,m_{2}]\\mid i&gt;2j+2\\}</span>. In this case, we can cancel the terms <span class="math">x_{2j+1}^{2}x_{i}</span> and <span class="math">x_{2j+2}^{2}x_{i}</span> by <span class="math">M^{(1)}</span>. However, the reduction will create new terms <span class="math">x_{2j+1}x_{i}^{2}</span> and <span class="math">x_{2j+2}x_{i}^{2}</span> which are irreducible modulo <span class="math">\\mathrm{LT}(M^{(1)})</span>. More precisely, for all <span class="math">(i,j)\\in U_{2}</span>, we update the matrix <span class="math">M^{(2)}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">M^{(2)}[i,j]=M^{(2)}[i,j]-M^{(1)}[i,2j+2]-M^{(1)}[i,2j+1].</span></p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300">The terms of degree 3 of <span class="math">M^{(2)}[i,j]</span> are then:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {i, j} ^ {(2)} = \\left\\{2 x _ {2} x _ {2 j + 1} x _ {i}, 2 x _ {2} x _ {2 j + 2} x _ {i}, x _ {2} x _ {i} ^ {2}, 2 x _ {2 j + 1} x _ {2 j + 2} x _ {i}, x _ {2 j + 1} x _ {i} ^ {2}, x _ {2 j + 2} x _ {i} ^ {2} \\right\\}, \\forall (i, j) \\in U _ {2}.</span></div>

    <p class="text-gray-300">The terms of <span class="math">T_{i,j}^{(2)}</span> are clearly no divisible by <span class="math">x_{1}</span>. We have that <span class="math">x_{2}x_{i}^{2}</span> is irreducible modulo <span class="math">\\mathrm{LT}(M^{(1)})</span>. The others terms are divisible by a square only if <span class="math">i = 2j + 2</span>. However, <span class="math">x_{2}x_{2j + 2}^{2}</span> and <span class="math">x_{2j + 1}x_{2j + 2}^{2}</span> can not be reduced modulo <span class="math">\\mathrm{LT}(M^{(1)})</span>. Again, <span class="math">x_{2j + 1}x_{i}^{2}</span> and <span class="math">x_{2j + 2}x_{i}^{2}</span> can not be reduced by <span class="math">\\mathrm{LT}(M^{(1)})</span>. Thus, <span class="math">\\forall (i,j)\\in U_2</span>, the set <span class="math">T_{i,j}^{(2)}</span> is irreducible modulo <span class="math">\\mathrm{LT}(M^{(1)})</span>.</p>

    <p class="text-gray-300">For <span class="math">i = 2j + 2</span>, we have a rather similar situation. The only difference is that the reduction of <span class="math">x_{2j+2}^3</span> will only yield terms of degree <span class="math">&amp;lt; 3</span>. We have then:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {2 j + 2, j} ^ {(2)} = \\left\\{2 x _ {2} x _ {2 j + 1} x _ {2 j + 2}, 3 x _ {2} x _ {2 j + 2} ^ {2}, 3 x _ {2 j + 1} x _ {2 j + 2} ^ {2} \\right\\}.</span></div>

    <p class="text-gray-300">Similarly, for <span class="math">i = 2j + 1</span>, we have:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {i, j} ^ {(2)} = \\left\\{3 x _ {2} x _ {2 j + 1} ^ {2}, 2 x _ {2} x _ {2 j + 1} x _ {2 j + 2}, x _ {2 j + 1} ^ {3}, 2 x _ {2 j + 1} ^ {2} x _ {2 j + 2}, x _ {2 j + 2} x _ {2 j + 1} ^ {2} \\right\\}.</span></div>

    <p class="text-gray-300">Using <span class="math">\\mathrm{LT}(M^{(1)})</span>, we can reduce <span class="math">x_{2j + 1}^2 x_{2j + 2}</span> and <span class="math">x_{2j + 1}^3</span>. So, we compute:</p>

    <div class="my-4 text-center"><span class="math-block">M ^ {(2)} [ 2 j + 1, j ] = M ^ {(2)} [ 2 j + 1, j ] - 2 M ^ {(1)} [ 2 j + 2, 2 j + 1 ] - M ^ {(1)} [ 2 j + 1, 2 j + 1 ].</span></div>

    <p class="text-gray-300">This yields:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {2 j + 1, j} ^ {(2)} = \\left\\{3 x _ {2} x _ {2 j + 1} ^ {2}, 2 x _ {2} x _ {2 j + 1} x _ {2 j + 2}, 3 x _ {2 j + 1} x _ {2 j + 2} ^ {2} \\right\\}.</span></div>

    <p class="text-gray-300">Finally, we define <span class="math">L_{2} \\coloneqq \\{(i,j) \\in [3,\\dots,n] \\times [1,\\dots,m_{2}] \\mid 2 &amp;lt; i &amp;lt; 2j + 1\\}</span>. For all, <span class="math">(i,j) \\in L_{2}</span>, it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {i, j} ^ {(2)} = \\left\\{x _ {2} x _ {i} ^ {2}, 2 x _ {2} x _ {i} x _ {2 j + 1}, 2 x _ {2} x _ {i} x _ {2 j + 2}, x _ {i} x _ {2 j + 1} ^ {2}, x _ {i} x _ {2 j + 2} ^ {2}, 2 x _ {i} x _ {2 j + 1} x _ {2 j + 2} \\right\\}.</span></div>

    <p class="text-gray-300">All in all, after these steps, no term of <span class="math">M^{(2)}</span> can be reduced by <span class="math">\\mathrm{LT}(M^{(1)})</span>.</p>

    <p class="text-gray-300">We have then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{1,j}^{(2)} = \\{x_2x_{2j + 1}^2,x_2x_{2j + 2}^2,x_{2j + 1}x_{2j + 2}^2\\}</span>, for all <span class="math">j,1\\leq j\\leq m_2</span>,</li>

      <li><span class="math">T_{2,j}^{(2)} = \\{3x_2x_{2j + 1}^2,2x_2x_{2j + 1}x_{2j + 2},3x_2x_{2j + 2}^2\\}</span>, for all <span class="math">j,1\\leq j\\leq m_2</span>,</li>

      <li><span class="math">T_{i,j}^{(2)} = \\{x_2x_i^2, 2x_2x_ix_{2j + 1}, 2x_2x_ix_{2j + 2}, x_ix_{2j + 1}^2, x_ix_{2j + 2}^2, 2x_ix_{2j + 1}x_{2j + 2}\\}</span>, <span class="math">\\forall (i,j)\\in L_2</span>,</li>

      <li><span class="math">T_{2j + 1,j}^{(2)} = \\{3x_2x_{2j + 1}^2,2x_2x_{2j + 1}x_{2j + 2},3x_{2j + 1}x_{2j + 2}^2\\}</span>, for all <span class="math">j,1\\leq j\\leq m_2</span>,</li>

      <li><span class="math">T_{2j + 2,j}^{(2)} = \\{2x_2x_{2j + 1}x_{2j + 2},3x_2x_{2j + 2}^2,3x_{2j + 1}x_{2j + 2}^2\\}</span>, for all <span class="math">j,1\\leq j\\leq m_2</span>,</li>

      <li><span class="math">T_{i,j}^{(2)} = \\{2x_2x_{2j + 1}x_i,2x_2x_{2j + 2}x_i,x_2x_i^2,2x_{2j + 1}x_{2j + 2}x_i,x_{2j + 1}x_i^2,x_{2j + 2}x_i^2\\}</span>, <span class="math">\\forall (i,j)\\in U_2</span>.</li>

    </ul>

    <p class="text-gray-300">We now proceed the polynomials <span class="math">M^{(2)}</span> to have distinct leading monomials.</p>

    <p class="text-gray-300">We first reduce polynomials of the second row. That is, for all <span class="math">j, 1 \\leq j \\leq m_2</span>:</p>

    <div class="my-4 text-center"><span class="math-block">M ^ {(2)} [ 2, j ] = M ^ {(2)} [ 2, j ] - 3 M ^ {(2)} [ 1, j ].</span></div>

    <p class="text-gray-300">This gives:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {2, j} ^ {(2)} = \\left\\{\\mathbf {2 x _ {2} x _ {2 j + 1} x _ {2 j + 2}}, - 3 x _ {2 j + 1} x _ {2 j + 2} ^ {2} \\right\\}.</span></div>

    <p class="text-gray-300">Also, for all <span class="math">j, 1 \\leq j \\leq m_2</span>, we compute:</p>

    <div class="my-4 text-center"><span class="math-block">M ^ {(2)} [ 2 j + 2, j ] = M ^ {(2)} [ 2 j + 2, j ] - M ^ {(2)} [ 2, j ].</span></div>

    <p class="text-gray-300">This gives:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {2 j + 2, j} ^ {(2)} = \\left\\{\\mathbf {3 x _ {2} x _ {2 j + 2} ^ {2}}, 6 x _ {2 j + 1} x _ {2 j + 2} ^ {2} \\right\\}.</span></div>

    <p class="text-gray-300">For all <span class="math">j, 1 \\leq j \\leq m_2</span>, we compute:</p>

    <div class="my-4 text-center"><span class="math-block">M^{(2)}[2j + 1, j] = M^{(2)}[2j + 1, j] - 3M^{(2)}[1, j].</span></div>

    <p class="text-gray-300">This gives:</p>

    <div class="my-4 text-center"><span class="math-block">T_{2j+1,j}^{(2)} = \\left\\{ \\mathbf{2} \\mathbf{x}_2 \\mathbf{x}_{2j+1} \\mathbf{x}_{2j+2}, -3x_2 x_{2j+2}^2 \\right\\}.</span></div>

    <p class="text-gray-300">Finally, for all <span class="math">j, 1 \\leq j \\leq m_2</span>:</p>

    <div class="my-4 text-center"><span class="math-block">M^{(2)}[2j + 1, j] = M^{(2)}[2j + 1, j] - M^{(2)}[2, j].</span></div>

    <p class="text-gray-300">This gives:</p>

    <div class="my-4 text-center"><span class="math-block">T_{2j+1,j}^{(2)} = \\left\\{ -\\mathbf{3} \\mathbf{x}_2 \\mathbf{x}_{2j+2}^2, 3x_{2j+1} x_{2j+2}^2 \\right\\}.</span></div>

    <p class="text-gray-300">Finally, for all <span class="math">j, 1 \\leq j \\leq m_2</span>:</p>

    <div class="my-4 text-center"><span class="math-block">M^{(2)}[2j + 1, j] = M^{(2)}[2j + 1, j] + M^{(2)}[2j + 2, j].</span></div>

    <p class="text-gray-300">This gives</p>

    <div class="my-4 text-center"><span class="math-block">T_{2j+1,j}^{(2)} = \\left\\{ \\mathbf{9} \\mathbf{x}_{2j+1} \\mathbf{x}_{2j+2}^2 \\right\\}.</span></div>

    <p class="text-gray-300">To summarize, we have:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{1,j}^{(2)} = \\{\\mathbf{x}_2\\mathbf{x}_{2j+1}^2, x_2 x_{2j+2}^2, x_{2j+1} x_{2j+2}^2\\}</span>, and <span class="math">r_{1,j}^{(2)} = x_2 x_{2j+1}^2</span>, for all <span class="math">j, 1 \\leq j \\leq m_2</span>,</li>

      <li><span class="math">T_{2,j}^{(2)} = \\{\\mathbf{2} \\mathbf{x}_2 \\mathbf{x}_{2j+1} \\mathbf{x}_{2j+2}, -3x_{2j+1} x_{2j+2}^2\\}</span>, and <span class="math">r_{2,j}^{(2)} = 2x_2 x_{2j+1} x_{2j+2}</span>, for all <span class="math">j, 1 \\leq j \\leq m_2</span>,</li>

      <li><span class="math">T_{i,j}^{(2)} = \\{x_2 x_i^2, 2x_2 x_i x_{2j+1}, 2x_2 x_i x_{2j+2}, x_i x_{2j+1}^2, x_i x_{2j+2}^2, \\mathbf{2} \\mathbf{x}_i \\mathbf{x}_{2j+1} \\mathbf{x}_{2j+2}\\}</span>, and <span class="math">r_{i,j}^{U_2} = 2x_i x_{2j+1} x_{2j+2}, \\forall (i,j) \\in U_2</span>,</li>

      <li><span class="math">T_{2j+2,j}^{(2)} = \\{\\mathbf{3} \\mathbf{x}_2 \\mathbf{x}_{2j+2}^2, 6x_{2j+1} x_{2j+2}^2\\}</span>, and and <span class="math">r_{2j+2,j}^{(2)} = 3x_2 x_{2j+2}^2</span>, for all <span class="math">j, 1 \\leq j \\leq m_2</span>,</li>

      <li><span class="math">T_{2j+1,j}^{(2)} = \\{\\mathbf{9} \\mathbf{x}_{2j+1} \\mathbf{x}_{2j+2}^2\\}</span>, and <span class="math">r_{2j+2,1}^{(2)} = 9x_{2j+1} x_{2j+2}^2</span> for all <span class="math">j, 1 \\leq j \\leq m_2</span>,</li>

      <li><span class="math">T_{i,j}^{(2)} = \\{\\mathbf{2} \\mathbf{x}_2 \\mathbf{x}_{2j+1} \\mathbf{x}_i, 2x_2 x_{2j+2} x_i, x_2 x_i^2, 2x_{2j+1} x_{2j+2} x_i, x_{2j+1} x_i^2, x_{2j+2} x_i^2\\}</span>, and <span class="math">r_{i,j}^{U_2} = 2x_2 x_{2j+1} x_i, \\forall (i,j) \\in U_2</span></li>

    </ul>

    <p class="text-gray-300">By inspecting the terms in bold, it can be noticed that they are all distinct.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Example 4 For <span class="math">n = 5</span>, $G^{*} = G_{1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{2}$ is as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{cccc} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\end{array} \\right].</span></div>

    <p class="text-gray-300">The initial system – after a first simple reduction on the equations of <span class="math">G_1</span> – is:</p>

    <div class="my-4 text-center"><span class="math-block">[2 \\cdot x_1^2 + 16 \\cdot x_1 + 17, 2 \\cdot x_1 \\cdot x_2 + x_2^2 + 5 \\cdot x_1 + 13 \\cdot x_2 + 19,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot x_1 \\cdot x_3 + x_3^2 + 3 \\cdot x_1 + 11 \\cdot x_3 + 7,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot x_1 \\cdot x_4 + x_4^2 + 27 \\cdot x_1 + 6 \\cdot x_4 + 22,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot x_1 \\cdot x_5 + x_5^2 + 15 \\cdot x_1 + 23 \\cdot x_5 + 22,</span></div>

    <div class="my-4 text-center"><span class="math-block">x_2^2 + 2 \\cdot x_2 \\cdot x_3 + 2 \\cdot x_2 \\cdot x_4 + x_3^2 + 2 \\cdot x_3 \\cdot x_4 + x_4^2 + 3 \\cdot x_2 + 3 \\cdot x_3 + 3 \\cdot x_4 + 2].</span></div>

    <p class="text-gray-300">We give below homogeneous components of degree 3 of the polynomials of <span class="math">M^{(2)}</span> after all the operations described in the previous proof.</p>

    <div class="my-4 text-center"><span class="math-block">[\\mathbf{x}_2 \\cdot \\mathbf{x}_3^2 + x_2 \\cdot x_4^2 + x_3 \\cdot x_4^2,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot \\mathbf{x}_2 \\cdot \\mathbf{x}_3 \\cdot \\mathbf{x}_4 + 26 \\cdot x_3 \\cdot x_4^2,</span></div>

    <div class="my-4 text-center"><span class="math-block">9 \\cdot \\mathbf{x}_3 \\cdot \\mathbf{x}_4^2,</span></div>

    <div class="my-4 text-center"><span class="math-block">3 \\cdot \\mathbf{x}_2 \\cdot \\mathbf{x}_4^2 + 6 \\cdot x_3 \\cdot x_4^2,</span></div>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot \\mathbf{x}_2 \\cdot \\mathbf{x}_3 \\cdot \\mathbf{x}_5 + 2 \\cdot x_2 \\cdot x_4 \\cdot x_5 + x_2 \\cdot x_5^2 + 2 \\cdot x_3 \\cdot x_4 \\cdot x_5 + x_3 \\cdot x_5^2 + x_4 \\cdot x_5^2].</span></div>

    <p class="text-gray-300">29</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 2. We emphasize that we have found an example which extends Lemma 11. We construct a matrix $G := G_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_n<span class="math">. The matrices </span>G_1<span class="math"> and </span>G_2<span class="math"> are defined as in Lemma 11. Each block </span>G_b, b &gt; 2<span class="math"> will be of size </span>n \\times \\left\\lfloor \\frac{n - b}{b + 1} \\right\\rfloor$ and such that all the coefficients are zero except for:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G_2[b, j] = 1</span>, for all <span class="math">j, 1 \\leq j \\leq m_2</span>.</li>

      <li><span class="math">G_2[j(b + 1), j] = G_2[b \\cdot j + 2, j] = 1, \\dots, G_2[j(b + 1) + b, j]</span>, for all <span class="math">j, 1 \\leq j \\leq \\left\\lfloor \\frac{n - b}{b + 1} \\right\\rfloor</span>.</li>

    </ul>

    <p class="text-gray-300">We perform experiments to verify that such <span class="math">G</span> yields semigeneric systems. We have been able to verify the assumption up to <span class="math">n = 100</span>. However, we have not been able to prove that such family is semigeneric. This would allow to prove semigenericity for <span class="math">m \\approx n^2 / \\log n</span>.</p>`;
---

<BaseLayout title="Algebraic Algorithms for LWE (2014/1018)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/1018
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
