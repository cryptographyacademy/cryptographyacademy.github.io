---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/939';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Proof is in the Pudding: Proofs of Work for Solving Discrete Logarithms';
const AUTHORS_HTML = 'Marcella Hastings, Nadia Heninger, Eric Wustrow';

const CONTENT = `    <p class="text-gray-300">Marcella Hastings [11] Nadia Heninger [22] Eric Wustrow [32]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We propose a proof of work protocol that computes the discrete logarithm of an element in a cyclic group. Individual provers generating proofs of work perform a distributed version of the Pollard rho algorithm. Such a protocol could capture the computational power expended to construct proof-of-work-based blockchains for a more useful purpose, as well as incentivize advances in hardware, software, or algorithms for an important cryptographic problem. We describe our proposed construction and elaborate on challenges and potential trade-offs that arise in designing a practical proof of work.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">Proofs of work, discrete log, Pollard rho</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">We propose a proof of work scheme that is useful for cryptanalysis, in particular, solving discrete logarithms. The security of the ECDSA digital signature scheme is based on the hardness of the elliptic curve discrete log problem. Despite the problem’s cryptographic importance, the open research community is small and has limited resources for the engineering and computation required to update cryptanalytic records; recent group sizes for elliptic curve discrete log records include 108 bits in 2002 <em>[12]</em>, 112 bits in 2009 <em>[11]</em>, and 113 bits in 2014 <em>[31]</em>.</p>

    <p class="text-gray-300">Our proposition aims to harness the gigawatts of energy spent on Bitcoin mining <em>[29]</em> to advance the state of the art in discrete log cryptanalysis. Jakobsson and Juels <em>[17]</em> call this a <em>bread pudding</em> proof of work. Just as stale bread becomes a delicious dessert, individual proofs of work combine to produce a useful computation. While memory-hard functions aim to discourage specialized hardware for cryptocurrency mining <em>[21]</em>, we hope for the exact opposite effect. Just as Bitcoin has prompted significant engineering effort to develop efficient FPGAs and ASICs for SHA-256, we wish to use the lure of financial rewards from cryptocurrency mining to incentivize special-purpose hardware for cryptanalysis.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Background</h2>

    <p class="text-gray-300">Let <span class="math">G</span> be a cyclic group with generator <span class="math">g</span> of order <span class="math">q</span>. We represent the group operation as multiplication, but every algorithm in our paper applies to a generic</p>

    <p class="text-gray-300">group. Every element <span class="math">h\\in G</span> can be represented as an integer power of <span class="math">g</span>, <span class="math">g^{a}=h</span>, <span class="math">0\\leq a&lt;q</span>, and also has a unique representation as a sequence of bits. The discrete logarithm <span class="math">log_{g}(h)</span> is <span class="math">a</span>, <span class="math">0\\leq a&lt;q</span> satisfying <span class="math">g^{a}=h</span>. Computing discrete logs is believed to be difficult for certain groups, including multiplicative groups modulo primes and elliptic curve groups. The conjectured hardness of discrete log underlies the security of multiple important cryptographic algorithms, including the Diffie-Hellman key exchange <em>[12, 4]</em> and the Digital Signature Algorithm <em>[20]</em>. Efficient computation of a discrete log for a group used for Diffie-Hellman key exchange would allow an adversary to compute the private key from the public key exchange messages; for DSA signatures, such an adversary could compute the private signing key from the public key and forge arbitrary signatures.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 Discrete Log Cryptanalysis</h3>

    <p class="text-gray-300">There are two main families of algorithms for solving the discrete log problem. The first family works over any group, and includes Shanks’s baby step giant step algorithm <em>[24]</em>, and the Pollard rho and lambda algorithms <em>[22]</em>. These algorithms run in time <span class="math">O(\\sqrt{q})</span> for any group of order <span class="math">q</span>. It is this family of algorithms we target in this paper. A second family of algorithms is based on index calculus <em>[15, 3]</em>; these algorithms have sub-exponential running times only over finite fields.</p>

    <p class="text-gray-300">Current best practices for elliptic curves are to use 256-bit curves <em>[4]</em>, although 160-bit curves remain supported in some implementations <em>[27]</em>. Bitcoin miners currently perform around <span class="math">2^{90}</span> hashes per year and consume 0.33% of the world’s electricity <em>[29]</em>. If this effort were instead focused on discrete log, a 180-bit curve could be broken in around a year. Scaling this to discrete logs in 224-bit groups would require all current electricity production on Earth for 10,000 years. Alternative cryptocurrencies such as Litecoin, Ethereum, and Dogecoin achieve lower hash rates of about <span class="math">2^{72}</span> hashes per year.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 Pollard Rho with Distinguished Points</h3>

    <p class="text-gray-300">The protocols we study in this paper compute the discrete log of an element <span class="math">h</span> by finding a collision <span class="math">g^{a}h^{b}=g^{a^{\\prime}}h^{b^{\\prime}}</span> with <span class="math">b\\not\\equiv b^{\\prime}\\mod q</span>. Given such an equivalence, the discrete log of <span class="math">h</span> can be computed as <span class="math">(a^{\\prime}-a)/(b-b^{\\prime})\\bmod q</span>.</p>

    <p class="text-gray-300">Pollard’s rho algorithm for discrete logarithms <em>[22]</em> works for any cyclic group <span class="math">G</span> of order <span class="math">q</span>. The main idea is to take a deterministic pseudorandom walk inside of the group until the same element is encountered twice along the walk. By the birthday bound, such an element will be found with high probability after <span class="math">\\Theta(\\sqrt{q})</span> steps. The non-parallelized version of this algorithm uses a cycle-finding algorithm to discover this collision, and computes the log as above.</p>

    <p class="text-gray-300">We base our proof of work on Van Oorschot and Wiener’s <em>[28]</em> parallelized Pollard rho algorithm using the method of distinguished points. A distinguished</p>

    <p class="text-gray-300">point is an element whose bitwise representation matches some easily-identifiable condition, such as having <span class="math">d</span> leading zeros. Each individual process <span class="math">j</span> independently chooses a random starting point <span class="math">g^{a_{j}}h^{b_{j}}</span> and generates a psuedorandom walk sequence from this starting element. When the walk reaches a distinguished point, the point is saved to a central repository and the process starts over again from a new random starting point until a collision is found.</p>

    <p class="text-gray-300">The number of steps required to compute the discrete log is independent of <span class="math">d</span>, which we call the difficulty parameter below; <span class="math">d</span> only determines the storage required. We expect to find a collision after <span class="math">\\Theta(\\sqrt{q})</span> steps by all processes. With <span class="math">m</span> processes running in parallel, the calendar running time is <span class="math">O(\\sqrt{q}/m)</span>.</p>

    <p class="text-gray-300">The pseudorandom walk produces a deterministic sequence within the group from some starting value. Given a group generator <span class="math">g</span> and a target <span class="math">h</span>, the walk generates a random starting point <span class="math">x_{0}=g^{a_{0}}h^{b_{0}}</span> by choosing random exponents <span class="math">a_{0}</span>, <span class="math">b_{0}</span>. In practice, most implementations use the Teske pseudorandom walk <em>[26]</em>: given a disjoint partition of <span class="math">G</span> with 20 sets of equal size <span class="math">T_{1},\\ldots,T_{20}</span> parameterized by the bitwise representation of an element, choose <span class="math">m_{s},n_{s}\\in[1,q]</span> at random and define <span class="math">M_{s}=g^{m_{s}}h^{n_{s}}</span> for <span class="math">s\\in[1,20]</span>. Then we can define the walk <span class="math">\\mathcal{W}(x)=M_{s}*x</span> for <span class="math">x\\in T_{s}</span>. In general, an effective pseudorandom walk updates the group representation of a point based on some property of the bitwise representation.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.3 Proofs of Work</h3>

    <p class="text-gray-300">A proof of work <em>[13, 16]</em> protocol allows a <em>prover</em> to demonstrate to a <em>verifier</em> that they have executed an amount of work. We use the definition from <em>[2]</em>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A <span class="math">(t(n),\\delta(n))</span>-Proof of Work (PoW) consists of three algorithms <span class="math">(\\mathsf{Gen},\\mathsf{Solve},\\mathsf{Verify})</span> that satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficiency:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{n})</span> runs in time <span class="math">\\tilde{O}(n)</span>.</li>

      <li>For any <span class="math">c\\leftarrow\\mathsf{Gen}(1^{n})</span>, <span class="math">\\mathsf{Solve}(c)</span> runs in time <span class="math">\\tilde{O}(t(n))</span>.</li>

      <li>For any <span class="math">c\\leftarrow\\mathsf{Gen}(1^{n})</span> and any <span class="math">\\pi</span>, <span class="math">\\mathsf{Verify}(c,\\pi)</span> runs in time <span class="math">\\tilde{O}(n)</span>.</li>

      <li>Completeness: For any <span class="math">c\\leftarrow\\mathsf{Gen}(1^{n})</span> and any <span class="math">\\pi\\leftarrow\\mathsf{Solve}(c)</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{Verify}(c,\\pi)=accept]=1</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hardness: For any polynomial <span class="math">\\ell</span>, any constant <span class="math">\\epsilon&gt;0</span>, and any algorithm <span class="math">\\mathsf{Solve}_{\\ell}^{*}</span> that runs in time <span class="math">\\ell(n)t(n)^{1-\\epsilon}</span> when given as input <span class="math">\\ell(n)</span> challenges <span class="math">\\{c_{i}\\leftarrow\\mathsf{Gen}(1^{n})\\}_{i\\in[\\ell(n)]}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\forall i\\,\\mathsf{Verify}(c_{i},\\pi_{i})=accept\\mid(\\pi_{1},\\ldots,\\pi_{\\ell(n)})\\leftarrow\\mathsf{Solve}_{\\ell}^{*}(c_{1},\\ldots,c_{\\ell(n)})\\right]&lt;\\delta(n)</span></p>

    <p class="text-gray-300">We can describe the hash puzzle proof of work <em>[1]</em> used by Bitcoin <em>[19]</em> in this framework as follows. The challenge generated by <span class="math">\\mathsf{Gen}</span> is the hash of the previous block. <span class="math">\\mathsf{Solve}</span> is parameterized by a difficulty <span class="math">d</span>; individual miners search for a nonce <span class="math">n</span> such that SHA-256<span class="math">(c,n)\\leq 2^{256-d}</span> when mapped to an integer. Assuming that SHA-256 acts like a random function, miners must brute force search random values of <span class="math">n</span>; the probability that a random fixed-length integer is below the difficulty threshold is <span class="math">2^{-d}</span>, so the conjectured running time for <span class="math">\\mathsf{Solve}</span> is <span class="math">t(n)=O(2^{d})</span>. <span class="math">\\mathsf{Verify}</span> runs in constant time and accepts if SHA-256<span class="math">(c,n)\\leq 2^{256-d}</span>.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">2.0.2 Proposals for “useful” proofs of work.</h4>

    <p class="text-gray-300">Primecoin <em>[17]</em> proofs contain prime chains, which may be of scientific interest. DDoSCoin <em>[31]</em> proofs can cause a denial of service attack. TorPath <em>[6]</em> increases bandwidth on the Tor network. Ball et al. <em>[2]</em> describe theoretical proof-of-work schemes based on worst-case hardness assumptions from computational complexity theory. Lochter <em>[18]</em> independently outlines a similar discrete log proof of work.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 Proof of work for discrete log</h2>

    <p class="text-gray-300">The goal of this thought experiment is to develop a proof of work scheme that, if provided with mining power at Bitcoin’s annual hash rate, can solve a discrete log in a 160-bit group. We outline our proposed scheme, explain limitations of the simple model, and describe possible avenues to fix the gap.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1 Strawman Pollard rho proof of work proposal</h3>

    <p class="text-gray-300">In our rho-inspired proof of work scheme, workers compute a pseudorandom walk from a starting point partially determined by the input challenge and produce a distinguished point. The parameters defining the group <span class="math">G</span>, group generator <span class="math">g</span>, discrete log target <span class="math">h</span>, and deterministic pseudorandom walk function <span class="math">\\mathcal{W}</span>, are global for all workers and chosen prior to setup. A distinguished point <span class="math">x</span> at difficulty <span class="math">d</span> is defined as having <span class="math">d</span> leading zeros in the bitwise representation, where <span class="math">d</span> is a difficulty parameter provided by the challenge generator.</p>

    <p class="text-gray-300">In the terminology of Definition 1, Gen produces a challenge bit string <span class="math">c</span>; when used in a blockchain, <span class="math">c</span> can be the hash of the previous block.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To execute the Solve function, miners generate a starting point for their walk, for example by generating a pair of integers $(a_{0},b_{0})=H(c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n)<span class="math"> where </span>n<span class="math"> is a nonce chosen by a miner and </span>H<span class="math"> is a cryptographically secure hash function, and computing the starting point </span>P_{0}=g^{a_{0}}h^{b_{0}}<span class="math">. Workers then iteratively compute </span>P_{i}=\\mathcal{W}(P_{i-1})<span class="math"> until they encounter a distinguished point </span>P_{D}=g^{a_{D}}h^{b_{D}}<span class="math"> of difficulty </span>d<span class="math">, and output </span>\\pi=(n,a_{D},b_{D},P_{D})<span class="math">. A single prover expects to take </span>O(2^{d})$ steps before a distinguished point is encountered.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The Verify function can check that <span class="math">P_{D}=g^{a_{D}}h^{b_{D}}</span> and has <span class="math">d</span> leading zeros. This confirms that <span class="math">P_{D}</span> is distinguished, but does not verify that <span class="math">P_{D}</span> lies on the random walk of length <span class="math">\\ell</span> starting at the point determined by <span class="math">(a_{0},b_{0})</span>. Without this check, a miner can pre-mine a distinguished point and lie about its relationship to the starting point. A verifier can prevent this by verifying every step of the random walk, but this does not satisfy the efficiency constraints of Definition 1.</p>

    <p class="text-gray-300">A discrete log in a group of order <span class="math">q</span> takes <span class="math">\\sqrt{q}</span> steps to compute (see Section 2.2). A set of <span class="math">m</span> honest miners working in parallel expect to perform <span class="math">O(2^{d})</span> work per proof. If all miners have equal computational power, the winning miner will find a distinguished point after expected <span class="math">O(2^{d}/m)</span> individual work. This construction expects to store <span class="math">\\sqrt{q}m/2^{d}</span> distinguished points in a block chain before a collision is found; the total amount of work performed by all miners for all blocks to</p>

    <p class="text-gray-300">compute the discrete log is <span class="math">\\sqrt{q}m</span>. Each distinguished point wastes <span class="math">(m-1)/m</span> work performed by miners who do not find the “winning” point.</p>

    <p class="text-gray-300">We next examine several modified proof-of-work schemes based on this idea that attempt to solve the problems of verification and wasted work.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.2 Reducing the cost of wasted work</h3>

    <p class="text-gray-300">To reduce wasted work, we can allow miners that do not achieve the first block to announce their blocks and receive a partial block reward. One technique is to use the Greedy Heaviest-Observed Sub-Tree method <em>[25]</em> to determine consensus, which has been adopted by Ethereum in the form of Uncle block rewards <em>[14]</em>. In this consensus method, the main (heaviest) chain is defined as the sub-tree of blocks containing the most work, rather than the longest chain. This allows stale blocks to contribute to the security of a single chain, and allocates rewards to their producers. In Ethereum, this supports faster block times and lowers orphan rates but we could use it to incentivize miners to publish their useful work rather than discard it when each new block is found.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.3 Limiting the length of the pseudorandom walk</h3>

    <p class="text-gray-300">We attempt to reduce the cost of the Verify function by limiting the length of the random walk in a proof to at most <span class="math">2^{\\ell}</span> steps for some integer <span class="math">\\ell</span>. Individual miners derive a starting point from the challenge <span class="math">c</span> and a random nonce <span class="math">n</span>. They walk until they either find a distinguished point or pass <span class="math">2^{\\ell}</span> steps. In the latter case, the miner chooses another random nonce <span class="math">n</span> and restarts the walk.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Solve requires miners to produce a proof <span class="math">\\pi=(n,\\mathcal{L},a_{D},b_{D})</span> satisfying four criteria: (1) the walk begins at the point derived from a hash of the challenge and nonce values $((a_{0},b_{0})=H(c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n))<span class="math">, (2) walking from this initial point for </span>\\mathcal{L}<span class="math"> steps leads to the specified endpoint </span>(W^{\\mathcal{L}}(g^{a_{0}}h^{b_{0}})=g^{a_{D}}h^{b_{D}})<span class="math">, (3) the bitwise representation of the endpoint </span>g^{a_{D}}h^{b_{D}}<span class="math"> is distinguished and (4) the walk does not exceed the maximum walk length (</span>\\mathcal{L}<2^{\\ell}<span class="math">). Solve runs in expected time </span>O(2^{d})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Verify retraces the short walk and runs in <span class="math">O(2^{\\ell})</span> steps. Overall, fixing a maximum walk length forces more total work to be done, since walks over <span class="math">2^{\\ell}</span> steps are never published. The probability that a length <span class="math">2^{\\ell}</span> random walk contains a distinguished point of difficulty <span class="math">d</span> is <span class="math">2^{\\ell-d}</span>, so a prover expects to perform <span class="math">2^{d-\\ell}</span> random walks before finding a distinguished point. An individual prover in a group of order <span class="math">q</span> can expect to store <span class="math">O(\\sqrt{q}/2^{\\ell})</span> distinguished points before a collision is found. With <span class="math">2^{d}</span> work performed per distinguished point stored, the total amount of work is <span class="math">O(2^{d-\\ell}\\sqrt{q})</span>. For <span class="math">m\\ll 2^{d-\\ell}</span> miners working in parallel, the work wasted by parallel mining is subsumed by that of discarded long walks.</p>

    <p class="text-gray-300">To target a 160-bit group with mining power of around <span class="math">2^{90}</span> hashes per year, the total amount of work performed by miners should not exceed <span class="math">2^{90}\\geq 2^{d-\\ell}2^{80}</span>, or <span class="math">10\\geq d-\\ell</span>, with a total of <span class="math">2^{80-\\ell}</span> distinguished points. If we allow 1 GB = <span class="math">8\\cdot 10^{9}</span> storage, this allows up to <span class="math">2^{25}</span> 160-bit distinguished points, so we have <span class="math">\\ell=55</span>, and thus we set the difficulty <span class="math">d=65</span>. This is feasible: as of Sep 2018, Bitcoin miners produce nearly <span class="math">2^{75}</span> hashes per block and the blockchain is <span class="math">\\sim</span>183 GB.</p>

    <p class="text-gray-300">###</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.4 Efficiently verifying pseudorandom walks</h3>

    <p class="text-gray-300">In theory, a SNARK <em>[7]</em> solves the efficient verification problem for the proof of work. Provers compute the SNARK alongside the pseudorandom walk, and include the result with the proof of work. Verification executes in constant time. Unfortunately, generating a SNARK is thousands of times more expensive than performing the original computation. A STARK <em>[5]</em> takes much less work to solve but slightly longer to verify and comes with a non-negligible space trade-off. In our framework, Solve finds a distinguished point and build a STARK: this takes time <span class="math">O(d^{2}2^{2d})</span> and space <span class="math">O(d2^{d})</span> group elements. Verify executes the STARK verify function in time <span class="math">O(d)</span>. Verifiable delay functions <em>[9]</em> could also be used to solve this problem, but existing solutions appear to take advantage of algebraic structure that we do not have in our pseudorandom walk.</p>

    <p class="text-gray-300">We attempted to emulate a verifiable delay function by defining an alternate pseudorandom walk. We experimented with several possibilities, for example a “rotating” walk that performs a set of multiplications and exponentiations in sequence. A walk of this type has the convenient algebraic property that it is simple to verify for a given start point, end point, and length <span class="math">\\mathcal{L}</span>, that the end point is <span class="math">\\mathcal{L}</span> steps from the start. Unfortunately, it has terrible pseudorandom properties: collisions are either trivial or occur after <span class="math">O(q)</span> steps. There appears to be a tension between the pseudorandomness properties required for the Pollard rho algorithm to achieve <span class="math">O(\\sqrt{q})</span> running time and an algebraic structure allowing efficient verification of the walk. Effective random walks determine each step by the bitwise representation of a given element—independent of its group element representation <span class="math">g^{a_{i}}h^{b_{i}}</span>—but this independence makes it difficult to reconstruct or efficiently summarize the group steps without repeating the entire computation. We leave the discovery of such a pseudorandom walk to future work.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.5 Distributed verification</h3>

    <p class="text-gray-300">An alternate block chain formulation has miners accept blocks unless they see a proof that it is invalid, and incentivizes other validators to produce such proofs. This technique has been proposed for verifying off-chain transactions in Ethereum Plasma <em>[23]</em>. We extend this idea to allow validators to prove a miner has submitted an invalid block and offer rewards for such discoveries.</p>

    <p class="text-gray-300">In this scheme, the Verify function accompanies a <em>reject</em> decision with a proof of falsification <span class="math">f</span>, and can take as long as mining: <span class="math">\\tilde{O}(t(n))</span>. We define a function <span class="math">\\mathsf{Check}(c,f)</span> to check whether this proof of falsification is accurate, which runs in time <span class="math">\\tilde{O}(n)</span>. In a block chain, miners Solve proofs of work and dedicated verifiers Verify. If a verifier produces a proof of falsification <span class="math">f</span> (that is, finds an invalid block) it broadcasts <span class="math">(c,f)</span> to all participants, who must Check the falsification.</p>

    <p class="text-gray-300">To increase verification cost, there must be a matching increase in incentive. For example, a time-delayed bounty system requires a miner to provide a bounty with each new block, which is either collected by the miner with the block reward after a fixed amount of time, or partially poached by a verifier who produces a valid falsification. Such a scheme aims to prevent collusion between miners and verifiers to collect rewards and bounty for no useful work.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">3.2.2 Walk summaries.</h4>

    <p class="text-gray-300">A first idea modifies the proof of work <span class="math">\\pi</span> to include intermediate points <span class="math">s_{0},s_{1},\\dots</span> spaced at regular intervals along the walk. The Verify function picks a random subset of the <span class="math">s_{i}</span> and retraces the walks from <span class="math">s_{i}</span> to <span class="math">s_{i+1}</span>. An invalid proof has the property that at least one interval does not have a valid path between the endpoints. For a walk with <span class="math">I</span> intervals of length <span class="math">\\ell</span>, a verifier that checks <span class="math">k</span> intervals has probability <span class="math">k/I</span> of detecting an invalid proof with work <span class="math">kI</span>. However, checking a claimed falsification <span class="math">f</span> requires <span class="math">\\ell</span> work. A malicious verifier can report incorrect falsifications and force other participants to perform arbitrary work. To fix this, we need more efficiently checkable falsifications.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">3.2.3 Bloom filters for secondary validation.</h4>

    <p class="text-gray-300">One approach to efficiently checkable proof falsifications uses Bloom filters <em>[8]</em>, a probabilistic data structure that tests set membership. It may return false positives, but never false negatives. We modify our walk summary proof of work <span class="math">\\pi</span> above to also include a Bloom filter containing every point on the walk. The Verify function chooses a random interval <span class="math">s_{i}</span> and takes <span class="math">\\ell</span> walk steps, which takes work <span class="math">\\ell</span>. If an element <span class="math">e_{i}</span> on the walk is absent from the filter, the verifier broadcasts the sequence of points <span class="math">f=(e_{i-k},\\dots,e_{i})</span>. The Check function confirms that the points <span class="math">f</span> are a correctly generated random walk and that all points except <span class="math">e_{i}</span> are contained in the Bloom filter. This takes time <span class="math">k</span>. The short sequence prevents a malicious verifier from invalidating a correct block by taking advantage of false positives in Bloom filters.</p>

    <p class="text-gray-300">A Bloom filter containing every element in a random walk for a reasonable difficulty value will be too large (we estimate at least 150 TB for a walk of length <span class="math">2^{60}</span>). To shrink the filter, we could store hashes of short sub-walks of length <span class="math">\\ell^{\\prime}</span>, rather than every step. To Check, a participant must walk <span class="math">\\ell^{\\prime}</span> steps for each of the <span class="math">k</span> broadcast sub-walks. This increases the work to <span class="math">k\\ell^{\\prime}</span>, but decreases Bloom filter size by a factor of <span class="math">\\ell^{\\prime}</span>.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Acknowledgement. Joseph Bonneau, Brett Hemenway, Michael Rudow, Terry Sun, and Luke Valenta contributed to early versions of this work. Nadia Heninger carried out this research while at the University of Pennsylvania. This work was supported by the National Science Foundation under grants no. CNS-1651344 and CNS-1513671 and by the Office of Naval Research under grant no. 568751.</p>
    </blockquote>

    <h2 id="sec-19" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Back, A.: Hashcash-a denial of service counter-measure (2002)</li>

      <li>[2] Ball, M., Rosen, A., Sabin, M., Vasudevan, P.N.: Proofs of work from worst-case assumptions. In: CRYPTO 2018. Springer International Publishing (2018)</li>

      <li>[3] Barbulescu, R., Gaudry, P., Joux, A., Thomé, E.: A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In: EURO-CRYPT’14 (2014)</li>

      <li>[4] Barker, E., Chen, L., Roginsky, A., Vassilev, A., Davis, R.: SP 800-56A Revision 3. Recommendation for pair-wise key establishment schemes using discrete logarithm cryptography. National Institute of Standards & Technology (2018)</li>

    </ul>

    <p class="text-gray-300">Marcella Hastings, Nadia Heninger, and Eric Wustrow</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[5] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive (2018)</li>

      <li>[6] Biryukov, A., Pustogarov, I.: Proof-of-work as anonymous micropayment: Rewarding a Tor relay. In: FC’15. Springer (2015)</li>

      <li>[7] Bitansky, N., Canetti, R., Chiesa, A., Goldwasser, S., Lin, H., Rubinstein, A., Tromer, E.: The hunting of the SNARK. Journal of Cryptology 30(4) (2017)</li>

      <li>[8] Bloom, B.H.: Space/time trade-offs in hash coding with allowable errors. Commun. ACM 13(7), 422–426 (Jul 1970). https://doi.org/10.1145/362686.362692</li>

      <li>[9] Boneh, D., Bonneau, J., Bünz, B., Fisch, B.: Verifiable delay functions. In: Annual International Cryptology Conference. pp. 757–788. Springer (2018)</li>

      <li>[10] Bos, J.W., Kaihara, M.E., Kleinjung, T., Lenstra, A.K., Montgomery, P.L.: Solving a 112-bit prime elliptic curve discrete logarithm problem on game consoles using sloppy reduction. International Journal of Applied Cryptography 2(3) (2012)</li>

      <li>[11] Certicom ECC challenge (1997), http://certicom.com/images/pdfs/challenge-2009.pdf, Updated 10 Nov 2009. Accessed via Web Archive</li>

      <li>[12] Diffie, W., Hellman, M.: New directions in cryptography. IEEE transactions on Information Theory 22(6), 644–654 (1976)</li>

      <li>[13] Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In: Annual International Cryptology Conference. pp. 139–147. Springer (1992)</li>

      <li>[14] Ethereum Project: Ethereum white paper, https://github.com/ethereum/wiki/wiki/White-Paper\\#modified-ghost-implementation</li>

      <li>[15] Gordon, D.M.: Discrete logarithms in GF(P) using the number field sieve. SIAM J. Discret. Math. 6(1), 124–138 (Feb 1993). https://doi.org/10.1137/0406010</li>

      <li>[16] Jakobsson, M., Juels, A.: Proofs of work and bread pudding protocols. In: Secure Information Networks, pp. 258–272. Springer (1999)</li>

      <li>[17] King, S.: Primecoin: Cryptocurrency with prime number proof-of-work (2013)</li>

      <li>[18] Lochter, M.: Blockchain as cryptanalytic tool. Cryptology ePrint Archive, Report 2018/893 (2018), https://eprint.iacr.org/2018/893.pdf</li>

      <li>[19] Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system. White paper (2008)</li>

      <li>[20] National Institute of Standards and Technology: FIPS PUB 186-4: Digital Signature Standard (DSS). National Institute of Standards and Technology (Jul 2013)</li>

      <li>[21] Percival, C., Josefsson, S.: The scrypt password-based key derivation function. RFC 7914, RFC Editor (Aug 2016), http://rfc-editor.org/rfc/rfc7914.txt</li>

      <li>[22] Pollard, J.M.: Monte carlo methods for index computation (mod <span class="math">p</span>). In: Mathematics of Computation. vol. 32 (1978)</li>

      <li>[23] Poon, J., Buterin, V.: Plasma: Scalable autonomous smart contracts (2017)</li>

      <li>[24] Shanks, D.: Class number, a theory of factorization, and genera. In: Proc. of Symp. Math. Soc., 1971. vol. 20, pp. 41–440 (1971)</li>

      <li>[25] Sompolinsky, Y., Zohar, A.: Secure high-rate transaction processing in Bitcoin. In: FC’15. pp. 507–527. Springer (2015)</li>

      <li>[26] Teske, E.: Speeding up Pollard’s rho method for computing discrete logarithms. In: ANTS-III. pp. 541–554. Springer-Verlag, Berlin, Heidelberg (1998)</li>

      <li>[27] Valenta, L., Sullivan, N., Sanso, A., Heninger, N.: In search of CurveSwap: Measuring elliptic curve implementations in the wild. In: EuroS&amp;P. IEEE (2018)</li>

      <li>[28] Van Oorschot, P.C., Wiener, M.J.: Parallel collision search with cryptanalytic applications. Journal of cryptology 12(1), 1–28 (1999)</li>

      <li>[29] de Vries, A.: Bitcoin’s growing energy problem. Joule 2(5), 801–805 (2018)</li>

      <li>[30] Wenger, E., Wolfger, P.: Harder, better, faster, stronger: elliptic curve discrete logarithm computations on FPGAs. Journal of Cryptographic Engineering (2016)</li>

      <li>[31] Wustrow, E., VanderSloot, B.: DDoSCoin: Cryptocurrency with a malicious proof-of-work. In: WOOT (2016)</li>

    </ul>`;
---

<BaseLayout title="The Proof is in the Pudding: Proofs of Work for Solving Disc... (2018/939)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/939
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
