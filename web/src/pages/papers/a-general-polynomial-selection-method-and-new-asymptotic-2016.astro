---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/485';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A General Polynomial Selection Method and New Asymptotic Complexities for the Tower Number Field Sieve Algorithm';
const AUTHORS_HTML = 'Palash Sarkar, Shashank Singh';

const CONTENT = `    <p class="text-gray-300">Palash Sarkar and Shashank Singh</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In a recent work, Kim and Barbulescu had extended the tower number field sieve algorithm to obtain improved asymptotic complexities in the medium prime case for the discrete logarithm problem on <span class="math">\\mathbb{F}_{p^{n}}</span> where <span class="math">n</span> is not a prime power. Their method does not work when <span class="math">n</span> is a composite prime power. For this case, we obtain new asymptotic complexities, e.g., <span class="math">L_{p^{n}}(1/3,(64/9)^{1/3})</span> (resp. <span class="math">L_{p^{n}}(1/3,1.88)</span> for the multiple number field variation) when <span class="math">n</span> is composite and a power of <span class="math">2</span>; the previously best known complexity for this case is <span class="math">L_{p^{n}}(1/3,(96/9)^{1/3})</span> (resp. <span class="math">L_{p^{n}}(1/3,2.12)</span>). These complexities may have consequences to the selection of key sizes for pairing based cryptography. The new complexities are achieved through a general polynomial selection method. This method, which we call Algorithm-<span class="math">\\mathcal{C}</span>, extends a previous polynomial selection method proposed at Eurocrypt 2016 to the tower number field case. As special cases, it is possible to obtain the generalised Joux-Lercier and the Conjugation method of polynomial selection proposed at Eurocrypt 2015 and the extension of these methods to the tower number field scenario by Kim and Barbulescu. A thorough analysis of the new algorithm is carried out in both concrete and asymptotic terms.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The discrete logarithm problem (DLP) over the multiplicative group of a finite field is a basic problem in cryptography. Two general approaches are known for tackling the DLP on such groups. These are the function field sieve (FFS) <em>[1, 2, 12, 14]</em> algorithm and the number field sieve (NFS) <em>[8, 13, 15]</em> algorithm.</p>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime, <span class="math">n\\geq 1</span> be an integer and <span class="math">Q=p^{n}</span>. Suppose that <span class="math">p=L_{Q}(a,c_{p})</span> where</p>

    <p class="text-gray-300"><span class="math">L_{Q}(a,c_{p})=\\exp\\left((c_{p}+o(1))(\\ln Q)^{a}(\\ln\\ln Q)^{1-a}\\right).</span></p>

    <p class="text-gray-300">Depending of the value of <span class="math">a</span>, fields <span class="math">\\mathbb{F}_{Q}</span> are classified into the following types: small characteristic, if <span class="math">a\\leq 1/3</span>; medium characteristic, if <span class="math">1/3&lt;a&lt;2/3</span>; boundary, if <span class="math">a=2/3</span>; and large characteristic, if <span class="math">a&gt;2/3</span>.</p>

    <p class="text-gray-300">For fields of small characteristic, there has been tremendous progress in the FFS algorithm leading to a quasi-polynomial time algorithm <em>[4]</em>. Based on the</p>

    <p class="text-gray-300">FFS algorithms given in <em>[11, 4]</em>, a record computation of discrete log in the binary extension field <span class="math">\\mathbb{F}_{2^{9234}}</span> was reported by Granger et al <em>[9]</em>. Applications of the FFS algorithm to the medium prime case have been reported in <em>[14, 10, 19]</em>.</p>

    <p class="text-gray-300">For medium to large characteristic finite fields, the NFS algorithm is generally considered to be the state-of-the-art. NFS was initially proposed for solving the factoring problem. Its application to DLP was first proposed by Gordon <em>[8]</em> for prime order fields. Application to composite order fields was shown by Schirokauer <em>[21]</em>. Important improvements to the NFS for prime order fields was given by Joux and Lercier <em>[13]</em>.</p>

    <p class="text-gray-300">A major step in the application of NFS was by Joux, Lercier, Smart and Vercauteren <em>[15]</em> who showed that the NFS algorithm is applicable to all finite fields. When the prime <span class="math">p</span> is of a special form, Joux and Pierrot <em>[16]</em> showed the application of the special number field sieve algorithm to obtain improved complexity.</p>

    <p class="text-gray-300">The NFS algorithm proceeds by constructing two polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> over the integers which have a common factor <span class="math">\\varphi(x)</span> of degree <span class="math">n</span> modulo <span class="math">p</span>. The polynomial <span class="math">\\varphi(x)</span> defines the field <span class="math">\\mathbb{F}_{p^{n}}</span> while the polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> define two number fields. The efficiency of the NFS algorithm is crucially dependent on the properties of the polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> used to construct the number fields. Consequently, polynomial selection is an important step in the NFS algorithm and is an active area of research.</p>

    <p class="text-gray-300">There has been a recent spurt of interest in the study of the NFS algorithm for DLP in finite fields. The work <em>[3]</em> by Barbulescu et al. extends a previous method <em>[13]</em> for polynomial selection and also presents a new method. The extension of <em>[13]</em> is called the generalised Joux-Lercier (GJL) method while the new method proposed in <em>[3]</em> is called the Conjugation method. The paper also provides a comprehensive comparison of the trade-offs in the complexity of the NFS algorithm offered by the various polynomial selection methods.</p>

    <p class="text-gray-300">The NFS based algorithm has been extended to multiple number field sieve algorithm (MNFS). The work <em>[6]</em> showed the application of the MNFS to medium to high characteristic finite fields. More recently, Pierrot <em>[18]</em> proposed MNFS variants of the GJL and the Conjugation methods. Sarkar and Singh proposed <em>[20]</em> a new polynomial selection method which subsumes both the GJL and the Conjugation methods. Using this method, the asymptotic complexity of both the NFS and the MNFS were worked out in <em>[20]</em>.</p>

    <p class="text-gray-300">The minimum asymptotic complexities using the NFS algorithm of Barbulescu et al. <em>[3]</em> can be written as <span class="math">L_{Q}(1/3,(c/9)^{1/3})</span> where <span class="math">c=96</span> for the medium characteristic case; <span class="math">c=48</span> for the boundary case and <span class="math">c=64</span> for the large characteristic case. The multiple number field sieve algorithm <em>[18]</em> improves these complexities. Further, the minimum complexities are achievable for a certain value of <span class="math">c_{p}</span>. The analysis in <em>[20]</em> improves the asymptotic complexity of the boundary case for a range of values of <span class="math">c_{p}</span>.</p>

    <p class="text-gray-300">When the extension degree <span class="math">n</span> is composite, the finite field <span class="math">\\mathbb{F}_{p^{n}}</span> can be represented as a tower of fields. The idea of using this in the context of DLP is due</p>

    <p class="text-gray-300">to Schirokauer <em>[21]</em>. This variant is called the tower number field sieve (TNFS) algorithm.</p>

    <p class="text-gray-300">At Asiacrypt 2015, Barbulescu et al., <em>[5]</em> presented a detailed analysis of the tower number field sieve (TNFS) variant. In a recent paper, Kim and Barbulescu <em>[17]</em> extended the TNFS algorithm and applied previous polynomial selection methods to the TNFS, the multiple TNFS (MTNFS) and the special TNFS variants. These were respectively called the exTNFS, MexTNFS and the SexTNFS algorithms. The polynomial selection methods considered in <em>[17]</em> include the methods from Joux-Lercier-Smart-Vercauteren <em>[15]</em>, the GJL and the Conjugation methods from <em>[3]</em> and the polynomial selection method from <em>[20]</em>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">Consequences to the medium prime case</h3>

    <p class="text-gray-300">An important achievement of the work by Kim and Barbulescu <em>[17]</em> is to improve the asymptotic complexity of the medium prime case when <span class="math">n</span> is not a prime power. In this case, they show that the complexity <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span> is achievable. Further, if <span class="math">p</span> is of a special form, then the complexity of <span class="math">L_{Q}(1/3,(32/9)^{1/3})</span> is achievable. The condition <span class="math">n</span> is not a prime power is equivalent to saying that <span class="math">n</span> can be written as <span class="math">\\eta\\kappa</span> with <span class="math">\\gcd(\\eta,\\kappa)=1</span>. How restrictive is the condition <span class="math">\\gcd(\\eta,\\kappa)=1</span>?</p>

    <p class="text-gray-300">One way of removing this restriction is to embed <span class="math">\\mathbb{F}_{p^{n}}</span> into <span class="math">\\mathbb{F}_{p^{nm}}</span> with <span class="math">\\gcd(n,m)=1</span> and compute discrete logarithms in <span class="math">\\mathbb{F}_{p^{nm}}</span>. Let <span class="math">Q=p^{n}</span> and <span class="math">Q^{\\prime}=p^{nm}</span>. The complexity of the NFS algorithm in <span class="math">\\mathbb{F}_{Q^{\\prime}}</span> can be written as <span class="math">L_{Q^{\\prime}}(1/3,\\mu)</span> where <span class="math">\\mu</span> is a constant. Note that <span class="math">L_{Q^{\\prime}}(1/3,\\mu)</span> is <span class="math">L_{Q}(1/3,\\mu m^{1/3})</span> (ignoring small terms). The best complexity obtained by Kim and Barbulescu is <span class="math">\\mu=(48/9)^{1/3}</span>. So, the best complexity achieved for solving DLP in <span class="math">\\mathbb{F}_{p^{n}}</span> by embedding into <span class="math">\\mathbb{F}_{p^{nm}}</span> is <span class="math">L_{Q}(1/3,\\nu)</span> where <span class="math">\\nu=(48m/9)^{1/3}</span>.</p>

    <p class="text-gray-300">Since <span class="math">m\\geq 2</span>, <span class="math">\\nu\\geq(96/9)^{1/3}</span>. For <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3&lt;a&lt;2/3</span>, the complexity of NFS for directly solving DLP in <span class="math">\\mathbb{F}_{p^{n}}</span> is <span class="math">L_{Q}(1/3,(96/9)^{1/3})</span>. So, we see that trying to solve DLP in <span class="math">\\mathbb{F}_{p^{n}}</span> by embedding into a larger field increases the complexity. This motivates the problem of finding a variant of NFS for fields <span class="math">\\mathbb{F}_{p^{n}}</span> where <span class="math">n</span> is a composite prime-power with complexity <span class="math">L_{Q}(1/3,\\nu)</span> with <span class="math">\\nu&lt;(96/9)^{1/3}</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">Our Contributions</h3>

    <p class="text-gray-300">This paper makes two contributions.</p>

    <p class="text-gray-300">The first contribution is to present a general polynomial selection method which we call Algorithm-<span class="math">\\mathcal{C}</span>. The polynomial selection method of <em>[20]</em> can be obtained as a special case and so, in turn, the GJL and the Conjugation methods are also obtained as special cases. Further, the exTNFS variants of the GJL and the Conjugation methods are also obtained as special cases of Algorithm-<span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">One important feature of Algorithm-<span class="math">\\mathcal{C}</span> is that both prime-power and non prime-power <span class="math">n</span> can be covered. For the medium prime case, we have the following consequences.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For non prime-power <span class="math">n</span>, the minimum complexity achievable is that obtained by Kim and Barbulescu <em>[17]</em>. The analysis, however, reveals improvement</li>

    </ol>

    <p class="text-gray-300">over the complexities achieved by Kim and Barbulescu in certain ranges of the relevant parameters.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For composite prime-power  <span class="math">n</span> , the complexities achieved by the new polynomial selection method are currently the best known. For some small values of  <span class="math">n</span> , the minimum achievable complexities using the exTNFS and the MexTNFS algorithms are shown in Table 1. For  <span class="math">n = 4,8,9</span>  and 16 the new complexities may have consequences to choosing the key sizes for pairing based cryptography.</li>

    </ol>

    <p class="text-gray-300">Table 1. Improved minimum complexities  <span class="math">L_{Q}(1/3, c)</span>  for some composite prime-power  <span class="math">n</span> . The entries in the table are the various values of  <span class="math">c</span>  in different cases.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NFS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MNFS</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">new</td>

            <td class="px-3 py-2 border-b border-gray-700">[3]</td>

            <td class="px-3 py-2 border-b border-gray-700">new</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2i, i≥2</td>

            <td class="px-3 py-2 border-b border-gray-700">(64/9)1/3≈1.92</td>

            <td class="px-3 py-2 border-b border-gray-700">(96/9)1/3≈2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.88</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">(112/15)1/3≈1.95</td>

            <td class="px-3 py-2 border-b border-gray-700">(96/9)1/3≈2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.92</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(880/117)1/3≈1.96</td>

            <td class="px-3 py-2 border-b border-gray-700">(96/9)1/3≈2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.94</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The target is to compute discrete logarithm in the field  <span class="math">\\mathbb{F}_{p^n}</span>  where  <span class="math">n</span>  is composite. Suppose that  <span class="math">n = \\eta \\kappa</span>  is a non-trivial factorisation of  <span class="math">n</span> . We do not necessarily require  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> .</p>

    <p class="text-gray-300">Let  <span class="math">h(z)</span>  be a monic polynomial of degree  <span class="math">\\eta</span>  which is irreducible over both  <span class="math">\\mathbb{Z}</span>  and  <span class="math">\\mathbb{F}_p</span> . Let  <span class="math">R = \\mathbb{Z}[z] / (h(z))</span> . Also, note that  <span class="math">\\mathbb{F}_{p^\\eta} = \\mathbb{F}_p[z] / (h(z))</span> .</p>

    <p class="text-gray-300">Let  <span class="math">f(x)</span>  and  <span class="math">g(x)</span>  be polynomials in  <span class="math">R[x]</span>  whose leading coefficients are from  <span class="math">\\mathbb{Z}</span> . The other coefficients of  <span class="math">f</span>  and  <span class="math">g</span>  are polynomials in  <span class="math">z</span>  of degrees at most  <span class="math">\\eta - 1</span> . In particular,  <span class="math">f</span>  and  <span class="math">g</span>  can be viewed as bi-variate polynomials in  <span class="math">x</span>  and  <span class="math">z</span>  with coefficients in  <span class="math">\\mathbb{Z}</span> . The following properties are required.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both  <span class="math">f(x)</span>  and  <span class="math">g(x)</span>  are irreducible over  <span class="math">R</span> .</li>

      <li>Over  <span class="math">\\mathbb{F}_{p^n}</span> ,  <span class="math">f(x)</span>  and  <span class="math">g(x)</span>  have a common factor  <span class="math">\\varphi (x)</span>  of degree  <span class="math">\\kappa</span> .</li>

    </ol>

    <p class="text-gray-300">The field  <span class="math">\\mathbb{F}_{p^n}</span>  is realised as  <span class="math">\\mathbb{F}_{p^n}[x] / (\\varphi (x)) = (R / pR)[x] / (\\varphi (x))</span></p>

    <p class="text-gray-300">Let  <span class="math">K_{f}</span>  and  <span class="math">K_{g}</span>  be the number fields associated with the polynomials  <span class="math">f</span>  and  <span class="math">g</span>  respectively. The above set-up provides two different decompositions of a homomorphism from  <span class="math">R[x]</span>  to  <span class="math">\\mathbb{F}_{p^n}</span> . One of these goes through  <span class="math">R[x] / (f(x))</span>  and the other goes through  <span class="math">R[x] / (g(x))</span> .</p>

    <p class="text-gray-300">With this set-up, it is possible to set up a factor base and perform the three main steps (relation collection, linear algebra and descent) of the NFS algorithm. For details we refer to [5, 17]. In this work, we will need only the following facts.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The factor base consists of <span class="math">B</span> elements for some value <span class="math">B</span> which determines the overall complexity of the algorithm.</li>

      <li>A polynomial <span class="math">\\phi(x) \\in R[x]</span> generates a relation if both the norms <span class="math">N(\\phi, f)</span> and <span class="math">N(\\phi, g)</span> are <span class="math">B</span>-smooth, where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} N(\\phi, f) := \\operatorname{Res}_z(\\operatorname{Res}_x(\\phi(x), f(x)), h(z)); \\\\ N(\\phi, g) := \\operatorname{Res}_z(\\operatorname{Res}_x(\\phi(x), g(x)), h(z)). \\end{array}</span></div>

    <p class="text-gray-300">In this work, we describe a method to choose <span class="math">h(z), f(x), g(x)</span> and <span class="math">\\varphi(x)</span> such that the above norms are suitably bounded. Consequences to the complexity of the NFS algorithm are analysed.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2.1 Bounds on Resultants</h2>

    <p class="text-gray-300">Let <span class="math">f(z, x)</span> be a bivariate polynomial with integer coefficients where <span class="math">f_{i,j}</span> is the coefficient of <span class="math">x^i z^j</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = \\max</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We summarise bounds on resultants of univariate and bivariate polynomials given in [7].</p>

    <p class="text-gray-300"><strong>Univariate polynomials:</strong> Let <span class="math">a(u)</span> and <span class="math">b(u)</span> be two polynomials with integer coefficients. From [7], we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}_u(a(u), b(u))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><strong>Bivariate polynomials:</strong> Let <span class="math">a(u, v)</span> and <span class="math">b(u, v)</span> be two polynomials with integer coefficients. Let <span class="math">c(u) = \\operatorname{Res}_v(a(u, v), b(u, v))</span>. Then</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq (\\deg_v(a) + \\deg_v(b))! (\\max(\\deg_u(a), \\deg_u(b)) + 1)^{\\deg_v(a) + \\deg_v(b) + 1} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg_v(b)} \\times \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg_v(a)}. \\tag{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">The bounds given by (1) and (2) combine to provide bounds on <span class="math">N(\\phi, f)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\phi(x, z)</span> and <span class="math">f(x, z)</span> be two polynomials and</p>

    <div class="my-4 text-center"><span class="math-block">\\rho(z) = \\operatorname{Res}_x(\\phi(x, z), f(x, z)).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further, suppose <span class="math">\\deg_x \\phi \\leq t - 1</span> and <span class="math">\\deg_z \\phi \\leq \\eta - 1</span>. For $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = E^{2/(t\\eta)}<span class="math">, the number of possible </span>\\phi(x, z)<span class="math">&#x27;s is </span>E^2<span class="math">. Assuming that </span>t, \\eta, \\deg_x f<span class="math"> and </span>\\deg_z f<span class="math"> are small in comparison to </span>E$, using (2) we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O\\left(E^{2\\deg_x(f)/(t\\eta)} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{t-1}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose <span class="math">h(z)</span> is a polynomial of degree <span class="math">\\eta</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = H$. Let</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Gamma = \\operatorname{Res}_z\\left(\\operatorname{Res}_x(\\phi(x), f(x)), h(z)\\right).</span></div>

    <p class="text-gray-300">Assuming that <span class="math">H</span> is negligible in comparison to <span class="math">E</span>, using (1) we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Gamma \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O \\left(\\left(\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\eta} \\cdot \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ^ {\\deg (\\rho)}\\right)\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Note that in the TNFS set-up described above <span class="math">N(\\phi, f) = \\Gamma</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Sieving polynomials:</strong> Sieving is done using polynomials <span class="math">\\phi(x) \\in R[x]</span> of degrees at most <span class="math">t - 1</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = E^{2 / \\eta t}<span class="math">. Then the number of sieving polynomials is </span>E^2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The work [3] provides two methods for selecting polynomials for the classical NFS algorithm. These are called the generalised Joux-Lercier (GJL) and the Conjugation method. The GJL method is based on an earlier method due to Joux and Lercier [13] and uses the LLL algorithm to select polynomials.</p>

    <p class="text-gray-300"><strong>The GJL matrix:</strong> Given a vector <span class="math">\\mathbf{a} = [a_0, \\dots, a_{n-1}] \\mathbb{F}_p^n</span> and <span class="math">r \\geq n</span>, define an <span class="math">(r+1) \\times (r+1)</span> matrix in the following manner.</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c c c c c c} p &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; p &amp;amp; &amp;amp; \\\\ a _ {0} &amp;amp; a _ {1} &amp;amp; \\dots &amp;amp; a _ {n - 1} &amp;amp; 1 &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; a _ {0} &amp;amp; a _ {1} &amp;amp; \\dots &amp;amp; a _ {n - 1} \\\\ &amp;amp; 1 \\end{array} \\right] \\tag {3}</span></div>

    <p class="text-gray-300">We extend the idea of the GJL to work for tower fields. In the TNFS set-up, <span class="math">Q = p^n</span> where <span class="math">n = \\eta \\kappa</span>. Recall that <span class="math">h(z)</span> is a monic irreducible polynomial of degree <span class="math">\\eta</span> over the integers and <span class="math">R = \\mathbb{Z}[z] / (h(z))</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\varphi(x) \\in R[x]</span> be a monic polynomial of degree <span class="math">k</span>. We can write</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi (x) = x ^ {k} + \\varphi_ {k - 1} (z) x ^ {k - 1} + \\dots + \\varphi_ {1} (z) x + \\varphi_ {0} (z),</span></div>

    <p class="text-gray-300">where each</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi_ {i} (z) = \\varphi_ {i, 0} + \\varphi_ {i, 1} z + \\dots + \\varphi_ {i, \\eta - 1} z ^ {\\eta - 1}</span></div>

    <p class="text-gray-300">is a polynomial of degree less than <span class="math">\\eta</span> with the coefficients <span class="math">\\varphi_{i,j}</span> in <span class="math">\\mathbb{Z}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\lambda</span> be an integer such <span class="math">\\deg (\\varphi_i) \\leq \\lambda - 1</span> for <span class="math">i = 0, \\dots, k</span>. The possible values of <span class="math">\\lambda</span> are <span class="math">1, \\ldots, \\eta</span>. The quantity <span class="math">\\lambda</span> will be a parameter of the polynomial selection algorithm and the asymptotic complexity. Though in theory <span class="math">\\lambda</span> can take any value in the range <span class="math">1, \\ldots, \\eta</span>, in practice the values of <span class="math">\\lambda</span> which can be achieved</p>

    <p class="text-gray-300">are 1 and <span class="math">\\eta</span>. Later we will consider these values of <span class="math">\\lambda</span> in more details. Note that the condition <span class="math">\\eta = 1</span> reduces to the classical NFS and in this case <span class="math">\\lambda</span> is necessarily 1.</p>

    <p class="text-gray-300">The polynomial <span class="math">\\varphi_{i}(z)</span> can be uniquely encoded by the vector <span class="math">\\varphi_{i} = (\\varphi_{i,0},\\dots ,\\varphi_{i,\\lambda -1})</span> and the polynomial <span class="math">\\varphi (x)</span> is uniquely encoded by the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\varphi} = \\left(\\varphi_ {0, 0}, \\dots , \\varphi_ {0, \\lambda - 1}, \\dots , \\varphi_ {k - 1, 0}, \\dots , \\varphi_ {k - 1, \\lambda - 1}\\right) \\tag {4}</span></div>

    <p class="text-gray-300">which is the concatenation of the vectors <span class="math">\\varphi_0,\\ldots ,\\varphi_{k - 1}</span></p>

    <p class="text-gray-300">We introduce some matrix notation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{diag}_i(p)</span>: the <span class="math">i \\times i</span> diagonal matrix having all the diagonal entries to be <span class="math">p</span>.</li>

      <li><span class="math">\\mathbf{0}_{i,j}</span>: the <span class="math">i \\times j</span> matrix all of whose entries are 0.</li>

      <li>For a vector <span class="math">\\mathbf{a}</span>, let <span class="math">\\mathrm{shift}_i(\\mathbf{a})</span> be the vector <span class="math">(\\underbrace{0,\\ldots,0}_{i},\\mathbf{a})</span>.</li>

    </ol>

    <p class="text-gray-300">Given the polynomial <span class="math">\\varphi(x)</span> and an integer <span class="math">r \\geq k</span>, we define a lower triangular matrix <span class="math">M_{\\varphi, r}</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\varphi , r} = \\left[ \\begin{array}{c c c c c} \\operatorname {d i a g} _ {\\lambda k} (p) &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ \\varphi &amp;amp; 1 &amp;amp; &amp;amp; &amp;amp; \\\\ \\mathbf {0} _ {\\lambda - 1, 1 + \\lambda k} \\operatorname {d i a g} _ {\\lambda - 1} (p) &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ \\operatorname {s h i f t} _ {\\lambda} (\\varphi) &amp;amp; 1 &amp;amp; &amp;amp; &amp;amp; \\\\ \\mathbf {0} _ {\\lambda - 1, 1 + \\lambda (k + 1)} &amp;amp; \\operatorname {d i a g} _ {\\lambda - 1} (p) &amp;amp; &amp;amp; &amp;amp; \\\\ \\operatorname {s h i f t} _ {2 \\lambda} (\\varphi) &amp;amp; &amp;amp; 1 &amp;amp; &amp;amp; \\\\ \\ddots &amp;amp; &amp;amp; \\ddots &amp;amp; &amp;amp; \\\\ \\mathbf {0} _ {\\lambda - 1, 1 + \\lambda (r - 1)} &amp;amp; &amp;amp; &amp;amp; \\operatorname {d i a g} _ {\\lambda - 1} (p) &amp;amp; \\\\ \\operatorname {s h i f t} _ {(r - k) \\lambda} (\\varphi) &amp;amp; &amp;amp; &amp;amp; 1 \\end{array} \\right] _ {(r \\lambda + 1) \\times (r \\lambda + 1)} \\tag {5}</span></div>

    <p class="text-gray-300">Note that for <span class="math">\\lambda = 1</span>, the matrix given by (5) becomes identical to the matrix given by (3).</p>

    <p class="text-gray-300">Apply the LLL algorithm to <span class="math">M_{\\varphi, r}</span> and let the first row of the resulting LLL-reduced matrix be written as</p>

    <div class="my-4 text-center"><span class="math-block">[ \\psi_ {0, 0}, \\dots , \\psi_ {0, \\lambda - 1}, \\psi_ {1, 0}, \\dots , \\psi_ {1, \\lambda - 1}, \\dots , \\psi_ {r - 1, 0}, \\dots , \\psi_ {r - 1, \\lambda - 1}, \\psi_ {r} ].</span></div>

    <p class="text-gray-300">This vector is taken to represent a polynomial <span class="math">\\psi (x)\\in R[x]</span> of degree <span class="math">r</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\psi (x) = \\psi_ {0} (z) + \\psi_ {1} (z) x + \\dots + \\psi_ {r - 1} (z) x ^ {r - 1} + \\psi_ {r} x ^ {r};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {i} (z) = \\psi_ {i, 0} + \\psi_ {i, 1} z + \\dots + \\psi_ {i, \\lambda - 1} z ^ {\\lambda - 1}.</span></div>

    <p class="text-gray-300">We denote <span class="math">\\psi (x)</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\psi (x) = \\operatorname {L L L} \\left(M _ {\\varphi , r}\\right). \\tag {6}</span></div>

    <p class="text-gray-300">The number of rows of <span class="math">M_{\\varphi, r}</span> which are constructed from <span class="math">\\varphi</span> is <span class="math">r - k + 1</span>. Each of these rows contribute 1 as the diagonal entry. All the other rows contribute <span class="math">p</span> as the diagonal entry and there are <span class="math">r\\lambda + 1 - (r - k + 1) = r(\\lambda - 1) + k</span> such rows.</p>

    <p class="text-gray-300"><span class="math">M_{\\varphi,r}</span> is a lower triangular matrix, its determinant is the product of its diagonal entries which is equal to <span class="math">p^{r(\\lambda-1)+k}</span>. Since the matrix has <span class="math">r\\lambda+1</span> rows, each entry of the first row of the matrix formed by applying LLL to <span class="math">M_{\\varphi,r}</span> is at most</p>

    <p class="text-gray-300"><span class="math">p^{\\frac{r(\\lambda-1)+k}{r\\lambda+1}}.</span></p>

    <p class="text-gray-300">So, each <span class="math">\\psi_{i,j}</span> and also <span class="math">\\psi_{r}</span> is at most this value. Consequently,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=p^{\\frac{r(\\lambda-1)+k}{r\\lambda+1}}=Q^{\\frac{1}{n}\\cdot\\frac{r(\\lambda-1)+k}{r\\lambda+1}}=Q^{\\varepsilon/n}$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\varepsilon=\\frac{r(\\lambda-1)+k}{r\\lambda+1}.</span> (8)</p>

    <p class="text-gray-300">Note that for <span class="math">k\\leq r</span>, <span class="math">\\varepsilon&lt;1</span>. The quantity <span class="math">\\varepsilon</span> will be another parameter in the asymptotic analysis.</p>

    <h2 id="sec-9" class="text-2xl font-bold">4 A New Polynomial Selection Method for TNFS</h2>

    <p class="text-gray-300">Algorithm <span class="math">\\mathcal{C}</span> describes the polynomial selection method for TNFS. It extends Algorithm-<span class="math">\\mathcal{A}</span> in <em>[20]</em> to the setting of tower fields.</p>

    <p class="text-gray-300">The following result states the basic properties of Algorithm <span class="math">\\mathcal{C}</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">The outputs <span class="math">f(x)</span>, <span class="math">g(x)</span> and <span class="math">\\varphi(x)</span> of Algorithm <span class="math">\\mathcal{C}</span> satisfy the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg(f)=d(r+1)</span>; <span class="math">\\deg(g)=rd</span> and <span class="math">\\deg(\\varphi)=\\kappa</span>;</li>

      <li>over <span class="math">\\mathbb{F}_{p^{n}}</span>, both <span class="math">f(x)</span> and <span class="math">g(x)</span> have <span class="math">\\varphi(x)</span> as a factor;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(\\ln(p))<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(Q^{\\varepsilon/n})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently, if <span class="math">\\phi</span> is a sieving polynomial, then</p>

    <p class="text-gray-300"><span class="math">N(\\phi,f)</span> <span class="math">=E^{2d(r+1)/t}\\times L_{Q}(2/3,o(1));</span> (9) <span class="math">N(\\phi,g)</span> <span class="math">=E^{2dr/t}\\times Q^{(t-1)\\varepsilon/\\kappa}\\times L_{Q}(2/3,o(1));</span> (10) <span class="math">N(\\phi,f)\\times N(\\phi,g)</span> <span class="math">=E^{(2d(2r+1))/t}\\times Q^{(t-1)\\varepsilon/\\kappa}L_{Q}(2/3,o(1)).</span> (11)</p>

    <p class="text-gray-300">We note the following points.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\eta=1</span>, then <span class="math">\\lambda</span> must be 1 and we obtain Algorithm-<span class="math">\\mathcal{A}</span> of <em>[20]</em>. As has been noted in <em>[20]</em>, Algorithm-<span class="math">\\mathcal{A}</span> generalises and also subsumes the GJL and the Conjugation methods for polynomial selection for the classical NFS given in <em>[3]</em>.</li>

      <li>If <span class="math">\\eta&gt;1</span> and <span class="math">\\lambda=1</span>, then <span class="math">\\varphi(x)</span> produced by Algorithm-<span class="math">\\mathcal{C}</span> has coefficients in <span class="math">\\mathbb{F}_{p}</span> and is of degree <span class="math">\\kappa</span>. For such a <span class="math">\\varphi(x)</span> to be irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span> it is required that <span class="math">\\gcd(\\eta,\\kappa)=1</span>.</li>

    </ol>

    <p class="text-gray-300">|  Algorithm: C: Polynomial selection for TNFS.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: p, n = ηκ, d (a factor of κ), r ≥ κ/d and λ ∈ [1,η].  |   |</p>

    <p class="text-gray-300">|  Output: f(x), g(x) and φ(x).  |   |</p>

    <p class="text-gray-300">|  Let k = κ/d;  |   |</p>

    <p class="text-gray-300">|  Let R = Z[z]/(h(z));  |   |</p>

    <p class="text-gray-300">|  Let Fpη = Fp[z]/(h(z));  |   |</p>

    <p class="text-gray-300">|  repeat  |   |</p>

    <p class="text-gray-300">|  Randomly choose a monic polynomial A1(x) ∈ R[x] having the following properties: deg A1(x) = r + 1; A1(x) is irreducible over Q[z]/(h(z)) and hence over R; A1(x) has coefficient polynomials of size O(ln(p)); over Fpη, A1(x) has an irreducible factor A2(x) of degree k such that all the coefficient polynomials of A2(x) have degrees at most λ - 1.  |   |</p>

    <p class="text-gray-300">|  Randomly choose monic polynomials C0(x) and C1(x) with small integer coefficients such that deg C0(x) = d and deg C1(x) < d. Define  |   |</p>

    <p class="text-gray-300">|  f(x) = Resy(A1(y), C0(x) + yC1(x));  |   |</p>

    <p class="text-gray-300">|  φ(x) = Resy(A2(y), C0(x) + yC1(x)) mod p;  |   |</p>

    <p class="text-gray-300">|  ψ(x) = LLL(MA2,r);  |   |</p>

    <p class="text-gray-300">|  g(x) = Resy(ψ(y), C0(x) + yC1(x)).  |   |</p>

    <p class="text-gray-300">|  until f(x) and g(x) are irreducible over Q[z]/(h(z)) (and hence over R) and φ(x) is irreducible over Fpη = Fp[z]/(h(z)).  |   |</p>

    <p class="text-gray-300">|  return f(x), g(x) and φ(x).  |   |</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TNFS variants of the GJL and the Conjugation methods were described in [17]. These can be seen as special cases of Algorithm- <span class="math">\\mathcal{C}</span> : Suppose  <span class="math">\\eta &amp;gt; 1</span>  and  <span class="math">\\lambda = 1</span> ; if  <span class="math">k = \\kappa</span> , then we obtain the TNFS variant of the GJL algorithm; and if  <span class="math">r = k = 1</span> , then we obtain the TNFS variant of the Conjugation method.</li>

      <li>The case  <span class="math">\\lambda = \\eta &amp;gt; 1</span>  has not been considered earlier. Later we show that this case leads to new asymptotic complexity when  <span class="math">n</span>  is a composite prime-power.</li>

      <li>As mentioned earlier, the case  <span class="math">1 &amp;lt; \\lambda &amp;lt; \\eta</span>  is difficult to achieve in practice and so we will not consider the details of this case.</li>

    </ol>

    <p class="text-gray-300">In Table 2, we compare the expressions for norm bounds for the various algorithms. As has already been mentioned in [20], the NFS-GJL and the NFS-Conj methods can be seen as special cases of NFS- <span class="math">\\mathcal{A}</span> : for the former choose  <span class="math">d = 1</span>  while for the latter, choose  <span class="math">d = n</span>  and  <span class="math">r = k = 1</span> . We explain that NFS- <span class="math">\\mathcal{A}</span> , exTNFS-GJL and exTNFS-Conj can be seen as special cases of exTNFS- <span class="math">\\mathcal{C}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose  <span class="math">\\eta = \\lambda = 1</span>  in exTNFS- <span class="math">\\mathcal{C}</span>  to obtain NFS- <span class="math">\\mathcal{A}</span> .</li>

      <li>Choose  <span class="math">\\eta &amp;gt; 1</span> ,  <span class="math">\\lambda = 1</span>  and  <span class="math">d = 1</span>  in exTNFS- <span class="math">\\mathcal{C}</span>  to obtain exNFS-GJL.</li>

      <li>Choose  <span class="math">\\eta &amp;gt; 1</span> ,  <span class="math">\\lambda = 1</span> ,  <span class="math">d = \\kappa</span>  and  <span class="math">r = k</span>  in exTNFS- <span class="math">\\mathcal{C}</span>  to obtain exNFS-Conj. Choosing  <span class="math">\\eta &amp;gt; 1</span> ,  <span class="math">\\lambda = 1</span> ,  <span class="math">d = \\kappa</span>  and  <span class="math">r &amp;gt; k</span>  in exTNFS- <span class="math">\\mathcal{C}</span>  provides a generalisation of exNFS-Conj.</li>

    </ol>

    <p class="text-gray-300">We note that NFS-JLSV1 cannot be derived as a special case of NFS- <span class="math">\\mathcal{A}</span>  and similarly, exTNFS-JLSV1 cannot be derived as a special case of exTNFS- <span class="math">\\mathcal{C}</span> .</p>

    <p class="text-gray-300">The exTNFS-JLSV1, exTNFS-GJL and exTNFS-Conj algorithms are applicable only for non-prime power  <span class="math">n</span> . These algorithms cannot be applied when  <span class="math">n</span>  is a composite prime-power. In Table 3, we compare concrete norm bounds for  <span class="math">n = 4,8</span>  and 9 for NFS-JLSV1, NFS-GJL, NFS-Conj, NFS- <span class="math">\\mathcal{A}</span>  with exTNFS- <span class="math">\\mathcal{C}</span> . This shows that new trade-offs are achievable with exTNFS- <span class="math">\\mathcal{C}</span> . In Table 4, we compare concrete norm bounds for  <span class="math">n = 6</span>  and 12. This shows that exTNFS-GJL and exTNFS-Conj can be seen as special cases of exTNFS- <span class="math">\\mathcal{C}</span> ; also, by choosing  <span class="math">r &amp;gt; k</span> , new trade-offs are achievable.</p>

    <p class="text-gray-300">Table 2. Parameterised efficiency estimates for NFS obtained from the different polynomial selection methods.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">norms product</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conditions</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-JLSV1 [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">E4n/ℓQt-1/n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-GJL [3]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2(2r+1)/ℓQt-1/r+1</td>

            <td class="px-3 py-2 border-b border-gray-700">r≥n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-Conj [3]</td>

            <td class="px-3 py-2 border-b border-gray-700">E6n/ℓQt-1/2n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-A [20]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2d(2r+1)/ℓQt-1/d(r+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

            <td class="px-3 py-2 border-b border-gray-700">n, r≥n/d</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-JLSV1 [17]</td>

            <td class="px-3 py-2 border-b border-gray-700">E4n/ℓQt-1/n</td>

            <td class="px-3 py-2 border-b border-gray-700">n=ηκ, gcd(η,κ)=1, η small</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-GJL [17]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2(2r+1)/ℓQt-1/r+1</td>

            <td class="px-3 py-2 border-b border-gray-700">n=ηκ, gcd(η,κ)=1, η small, r≥κ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-Conj [17]</td>

            <td class="px-3 py-2 border-b border-gray-700">E6n/ℓQt-1/2κ</td>

            <td class="px-3 py-2 border-b border-gray-700">n=ηκ, gcd(η,κ)=1, η small</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C</td>

            <td class="px-3 py-2 border-b border-gray-700">E2d(2r+1)/ℓQ(t-1)(r(λ-1)+k)/κ(rλ+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">n=ηκ, k=κ/d, r≥k; NFS: η=λ=1; exTNFS (gcd(η,κ)=1): η>1, λ=1; exTNFS: η=λ.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Comparison of norm bounds for composite prime-power  <span class="math">n</span>  with  <span class="math">t = 2</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FQ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">norm bound</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp4</td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">E8Q1/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-GJL (r=n)</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q1/5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">E12Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-A (d=2, r=n/d)</td>

            <td class="px-3 py-2 border-b border-gray-700">E10Q1/6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=λ=2, κ=2, d=1, r=k=κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">E5Q2/3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=λ=2, κ=2, d=2, r=k=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">E6Q1/3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp8</td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">E16Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-GJL (r=n)</td>

            <td class="px-3 py-2 border-b border-gray-700">E17Q1/9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">E24Q1/10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-A (d=2, r=n/d)</td>

            <td class="px-3 py-2 border-b border-gray-700">E18Q1/10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-A (d=4, r=n/d)</td>

            <td class="px-3 py-2 border-b border-gray-700">E20Q1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=λ=2, κ=4, d=1, r=k=κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q2/9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=λ=2, κ=4, d=2, r=k=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">E10Q1/5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=λ=2, κ=4, d=4, r=k=4)</td>

            <td class="px-3 py-2 border-b border-gray-700">E12Q1/6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp9</td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">E18Q1/9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-GJL (r=n)</td>

            <td class="px-3 py-2 border-b border-gray-700">E19Q1/10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">E27Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-A (d=3, r=n/d)</td>

            <td class="px-3 py-2 border-b border-gray-700">E21Q1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=λ=3, κ=3, d=1, r=k=κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">E7Q3/10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=λ=3, κ=3, d=3, r=k=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q1/4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Figure 1, we provide plots of norm bound for various finite fields of composite prime power extension degree. It is clear from the plots that for composite prime power extension degree, the algorithm- <span class="math">\\mathcal{C}</span>  provides the lowest norm bound. Note that we have used the estimates of  <span class="math">Q - E</span>  pairs given in the Table 2 of the paper [3] for plotting these norm bound.</p>

    <p class="text-gray-300">Plots of norm bound for extension degrees 12 and 24 are given in the Figure 2. Note that for these extension degrees, two types of towers are possible; one for which  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> , and the other for which  <span class="math">\\gcd(\\eta, \\kappa) \\neq 1</span> . Let us denote by Algorithm- <span class="math">\\mathcal{B}</span> , the special case of Algorithm- <span class="math">\\mathcal{C}</span>  where  <span class="math">\\lambda = 1</span>  and so  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> . Plots for Algorithm- <span class="math">\\mathcal{B}</span>  are shown separately in Figures 2. It is interesting to note that, in the certain range of finite fields, the minimum norm bound achieved by Algorithm- <span class="math">\\mathcal{C}</span>  is lower than the minimum norm bound achieved by Algorithm- <span class="math">\\mathcal{B}</span> , i.e., it is not necessarily the best to choose  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> . While this appears in the concrete comparison, it is not captured by the asymptotic analysis.</p>

    <p class="text-gray-300">Table 4. Comparison of norm bounds for non prime-power  <span class="math">n</span>  with  <span class="math">t = 2</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FQ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">norm bound</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp6</td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">E12Q1/6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-GJL (r=n)</td>

            <td class="px-3 py-2 border-b border-gray-700">E13Q1/7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">E18Q1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-A (d=2, r=n/d)</td>

            <td class="px-3 py-2 border-b border-gray-700">E14Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-JLSV1 (η=2, κ=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">E6Q1/3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-GJL (η=2, r=κ=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">E7Q1/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-Conj (η=2, κ=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q1/6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=2, λ=1, d=1, r=k=κ=3)</td>

            <td class="px-3 py-2 border-b border-gray-700">E7Q1/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=2, λ=1, d=3, κ=3, r=k=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q1/6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=2, λ=1, d=3, κ=3, k=1, r=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">E15Q1/9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fp12</td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">E24Q1/12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-GJL (r=n)</td>

            <td class="px-3 py-2 border-b border-gray-700">E25Q1/3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">E36Q1/24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">NFS-A (d=2, r=n/d)</td>

            <td class="px-3 py-2 border-b border-gray-700">E26Q1/14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-JLSV1 (η=3, κ=4)</td>

            <td class="px-3 py-2 border-b border-gray-700">E8Q1/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-GJL (η=3, r=κ=4)</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q1/5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-Conj (η=3, κ=4)</td>

            <td class="px-3 py-2 border-b border-gray-700">E12Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=3, λ=1, d=1, r=k=κ=4)</td>

            <td class="px-3 py-2 border-b border-gray-700">E9Q1/5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=3, λ=1, d=4, κ=4, r=k=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">E12Q1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C (η=3, λ=1, d=4, κ=4, k=1, r=2)</td>

            <td class="px-3 py-2 border-b border-gray-700">E20Q1/12</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) Polynomials for  <span class="math">\\mathbb{F}_{p^4}</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) Polynomials for  <span class="math">\\mathbb{F}_{p^8}</span></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (c) Polynomials for  <span class="math">\\mathbb{F}_{p^9}</span></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (d) Polynomials for  <span class="math">\\mathbb{F}_{p^{16}}</span> Fig. 1. Product of norms for various polynomial selection methods</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (a) Polynomials for  <span class="math">\\mathbb{F}_{p^{12}}</span></p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (b) Polynomials for  <span class="math">\\mathbb{F}_{p^{24}}</span> Fig. 2. Product of norms for various polynomial selection methods. Note that algorithm- <span class="math">\\mathcal{B}</span>  is the algorithm- <span class="math">\\mathcal{C}</span>  with  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> .</p>

    <p class="text-gray-300">Example 1. Let  <span class="math">p</span>  is a 201-bit prime given below</p>

    <p class="text-gray-300"><span class="math">p = 1606938044258990275541962092341162602522202993782792835301611</span>  (12)</p>

    <p class="text-gray-300">and  <span class="math">n = 6</span></p>

    <p class="text-gray-300">Case 1: Let <span class="math">(\\eta, \\kappa) = (2,3)</span> so we can take <span class="math">\\lambda = 1</span>. Choose <span class="math">d = \\kappa</span>, and so <span class="math">k = \\kappa / d = 1</span>. Taking <span class="math">r = k</span>, we get the following polynomials.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h(z) = z^2 + 14z + 20 \\\\ f(x) = x^6 + 5x^5 + 6x^4 + 18x^3 + 73x^2 + 52x + 20 \\\\ g(x) = 516378785784706099560748701401x^3 + 1874354673374387667869084608560x^2 \\\\ \\quad + 459276162276102007999766811670x + 1683194203609950937495174411516 \\\\ \\phi(x) = x^3 + 4370464675316262929768958368698673612607491294431378655895x^2 \\\\ \\quad + 13111394025948788789306875106096020837822473883294135967675x \\\\ \\quad + 8740929350632525859537916737397347225214982588862757311786 \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly, the above polynomials represent the polynomials generated by Conjugation method and we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\approx 2^{100}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we choose <span class="math">r = k + 1</span> i.e., <span class="math">r = 2</span>, we get the following polynomials.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h(z) = z^2 + z + 20 \\\\ f(x) = x^9 + 14x^8 + 74x^7 + 183x^6 + 200x^5 - 32x^4 - 375x^3 - 232x^2 - 48x - 1 \\\\ g(x) = 46647198736133019425x^6 + 530869201059776791498x^5 + 2094297655062561189093x^4 \\\\ \\quad + 3465328474724235168588x^3 + 2717008192279799547052x^2 \\\\ \\quad + 1322043132032704860464x + 290748395825577445032 \\\\ \\phi(x) = x^3 + 315444052193803149917391335705534526435873425227915090402562x^2 \\\\ \\quad + 1261776208775212599669565342822138105743493700911660361610232x \\\\ \\quad + 315444052193803149917391335705534526435873425227915090402559 \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\approx 2^{71}<span class="math">. Thus taking </span>r &gt; k$, gives us the polynomials which are not obtained by Conjugation method.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 2: Let <span class="math">(\\eta, \\kappa) = (3,2)</span>. Taking <span class="math">d = \\kappa</span> and <span class="math">r = 1</span>, we get the following polynomials.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} h(z) = z^3 + z^2 + 15z + 7 \\\\ f(x) = x^4 - x^3 - 2x^2 - 7x - 3 \\\\ g(x) = 717175561486984577278242843019x^2 + 2189435313197775056442946543188x \\\\ \\quad + 2906610874684759633721189386207 \\\\ \\phi(x) = x^2 + 131396875851816610915684123600060137654000542337369130402554x \\\\ \\quad + 131396875851816610915684123600060137654000542337369130402555 \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{101}<span class="math">. If we take </span>d=\\kappa<span class="math"> and </span>r=2<span class="math">, we get the following set of polynomials where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{69}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+z^{2}+{}_{15}z+{}_{7}</span> <span class="math">f(x)=x^{6}-{}_{4}x^{5}-{}_{53}x^{4}-{}_{147}x^{3}-{}_{188}x^{2}-{}_{157}x-{}_{92}</span> <span class="math">g(x)={}_{15087279002722300985}x^{4}+{}_{124616743720753879934}x^{3}+{}_{451785460058994237397}x^{2}</span> <span class="math">\\qquad{}_{+749764394939964245000}x+{}_{567202989572349792620}</span> <span class="math">\\phi(x)=x^{2}+{}_{459743211307624787973091830151418256356779099860453048165628}x</span> <span class="math">\\qquad{}_{+1379229633922874363919275490454254769070337299581359144496879}</span></p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Example 2.</h6>

    <p class="text-gray-300">Consider <span class="math">p</span> given by the equation (12) and <span class="math">n=12</span>. Take <span class="math">\\eta=3</span>, so we have <span class="math">\\kappa=4</span>. Since <span class="math">\\gcd(\\eta,\\kappa)=1</span>, we can take <span class="math">\\lambda=1</span>. For <span class="math">d=4</span> and <span class="math">r=1</span>, we get the following set of polynomials.</p>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+{}_{4}z^{2}+z+{}_{10}</span> <span class="math">f(x)=x^{8}-{}_{76}x^{7}-{}_{2425}x^{6}-{}_{18502}x^{5}-{}_{29145}x^{4}-{}_{27738}x^{3}-{}_{19029}x^{2}-{}_{5470}x-{}_{899}</span> <span class="math">g(x)={}_{671675518400038868509761185847}x^{4}+{}_{9229254771349687453155139482193}x^{3}</span> <span class="math">\\qquad{}_{+26443212483689677462178491316111}x^{2}+{}_{10373268895295520528776837441409}x</span> <span class="math">\\qquad{}_{+12363161023892249178889813706137}</span> <span class="math">\\phi(x)=x^{4}+{}_{646864792711457069399567439420493376414881652645022449494547}x^{3}</span> <span class="math">\\qquad{}_{+1021416876665447593884133690181094257197328168116350116415450}x^{2}</span> <span class="math">\\qquad{}_{+667312667750761865313480451840635053444883928304549026363993}x</span> <span class="math">\\qquad{}_{+40895750078609591827826024840283354060004551319053153738907}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{104}<span class="math">. If we take </span>d=2<span class="math"> and </span>r=2$, we get the following set of polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+{}_{9}z^{2}+{}_{16}z+{}_{6}</span> <span class="math">f(x)=x^{6}-{}_{31}x^{5}-{}_{1368}x^{4}-{}_{12769}x^{3}-{}_{25114}x^{2}+{}_{80676}x+{}_{46152}</span> <span class="math">g(x)=-{}_{3110542872966491216142377505541399497324}x^{4}</span> <span class="math">\\qquad{}_{-54264461590446758438380470085644010261628}x^{3}</span> <span class="math">\\qquad{}_{-314785140535769975569807658242015173572525}x^{2}</span> <span class="math">\\qquad{}_{-494316435479518971993478541468803889032252}x</span> <span class="math">\\qquad{}_{+1282345843739963030376594369830360797777868}</span> <span class="math">\\phi(x)=x^{4}+{}_{1116388795346251464070007744580761572151679553868796347306938}x^{3}</span> <span class="math">\\qquad{}_{+244260557761228308164124096832151544783881431251339247716776}x^{2}</span> <span class="math">\\qquad{}_{+1431585169281315380026562186279392445746733001920060626360960}x</span> <span class="math">\\qquad{}_{+32011873619053829538406325963389282580742061899867342029365}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{139}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Example 3. Consider again the prime  <span class="math">p</span>  given by the equation (12). Let  <span class="math">n = 4</span> . Take  <span class="math">\\eta = 2</span> , so we have  <span class="math">\\kappa = 2</span>  and  <span class="math">\\gcd(\\eta, \\kappa) \\neq 1</span> . For  <span class="math">d = 2</span>  and  <span class="math">r = 1</span> , we get the following set of polynomials.</p>

    <div class="my-4 text-center"><span class="math-block">h (z) = z ^ {2} + 3 z + 9</span></div>

    <div class="my-4 text-center"><span class="math-block">f (x) = x ^ {4} - 6 3 x ^ {3} + (z - 2 2 5 2) x ^ {2} + (2 6 z - 1 6 7 8 8) x + 1 6 9 z - 4 5 4 7</span></div>

    <div class="my-4 text-center"><span class="math-block">g (x) = 1 3 8 3 4 1 4 8 7 8 8 8 2 1 2 5 9 9 5 9 2 6 1 0 3 1 8 3 6 1 9 4 0 9 6 4 3 7 5 3 x ^ {2} + (- 1 2 0 5 5 6 1 8 7 9 7 1 6 2 7 9 6 2 6 4</span></div>

    <div class="my-4 text-center"><span class="math-block">4 7 3 5 4 6 9 9 6 0 1 9 2 9 1 3 2 1 9 3 4 z + 1 4 0 1 2 6 7 2 3 1 1 1 3 1 9 3 6 9 8 9 0 9 0 7 7 5 8 7 8 3 6 0 5 1 3 1 2 9 1 4 5) x</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 5 6 7 2 3 0 4 4 3 6 3 1 1 6 3 5 1 4 3 8 1 5 6 1 1 0 9 4 8 2 5 0 7 8 7 1 8 5 1 4 2 z - 6 4 0 8 3 1 0 8 3 9 6 3 0 3 2 4 6 4 1 6</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">6 6 6 2 8 0 2 6 5 5 6 8 2 4 5 9 0 9 1 4 9</span></div>

    <div class="my-4 text-center"><span class="math-block">\\phi (x) = x ^ {2} + \\left(7 9 8 4 1 6 6 2 2 3 3 7 5 0 0 0 9 1 3 8 1 9 1 0 5 7 5 1 5 8 2 8 8 5 5 4 0 6 2 5 5 5 1 8 6 6 8 8 0 2 4 0 7 8 6 3 5 4 6 6 z \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>7 8 5 8 3 0 4 9 0 8 9 6 8 5 7 7 9 5 4 2 9 6 2 8 2 4 5 1 0 4 4 4 4 5 8 9 1 5 0 7 9 5 8 7 8 9 3 5 0 8 0 6 9 0 2 5 0 3 4 5) x</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>7 3 7 7 8 7 8 2 4 8 3 3 5 5 9 5 3 4 7 1 3 0 6 4 9 2 3 0 1 0 7 7 5 5 8 7 6 7 9 9 9 9 4 6 4 2 4 7 5 5 6 0 1 0 4 5 1 3 9 2 z</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5 7 4 1 6 8 1 1 6 1 0 5 2 0 9 6 8 7 3 3 3 3 9 4 6 3 2 3 1 0 8 0 4 0 4 3 8 2 7 1 2 8 4 6 3 4 5 9 2 9 1 9 6 1 4 4 4 6 4 1</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{136}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Example 4. Consider  <span class="math">n = 8</span>  and  <span class="math">p</span>  as given by the equation (12). Take  <span class="math">\\eta = 2</span> , so we have  <span class="math">\\kappa = 4</span>  and  <span class="math">\\gcd(\\eta, \\kappa) \\neq 1</span> . For  <span class="math">d = 2</span>  and  <span class="math">r = 2</span> , we get the following set of polynomials.</p>

    <div class="my-4 text-center"><span class="math-block">h (z) = z ^ {2} + 5 z + 1</span></div>

    <div class="my-4 text-center"><span class="math-block">f (x) = x ^ {6} - 1 2 x ^ {5} - 3 4 x ^ {4} + (- z + 5 5 5) x ^ {3} + (- 2 1 z - 2 7 6 8) x ^ {2} + (- 1 4 7 z - 9 4 0 5) x</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(- 3 4 3 z + 2 3 4 7 7)</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">g (x) = - 8 5 4 2 2 2 8 8 1 2 6 7 3 5 8 7 3 7 6 9 5 2 8 7 6 5 7 0 7 6 6 4 1 3 8 6 6 2 0 0 5 8 4 8 4 4 0 5 x ^ {4}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left(4 6 7 4 1 4 3 4 5 9 7 8 3 3 7 9 9 5 2 6 6 3 6 7 8 4 1 5 3 2 2 8 0 4 5 4 4 7 5 0 2 1 9 1 3 6 3 4 z \\right.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 8 7 8 4 7 5 9 7 3 5 2 4 6 1 8 5 3 4 3 9 6 0 1 1 1 9 3 8 8 5 0 9 0 5 2 6 7 9 3 1 1 5 6 5 8 9 7 9) x ^ {3}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left(3 2 4 8 2 3 0 3 5 6 5 6 3 6 6 1 9 6 7 0 3 8 4 9 0 4 9 6 7 0 1 1 4 6 0 7 1 6 7 6 3 8 2 7 9 2 9 4 0 z \\right.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 9 3 5 5 1 2 9 1 9 1 1 0 4 7 2 9 5 8 1 1 0 1 1 8 6 5 8 9 8 0 4 6 8 2 6 0 4 0 9 8 4 7 4 2 6 8 8 4 7) x ^ {2}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left(1 0 7 0 8 6 2 1 2 3 9 4 9 1 5 7 9 8 8 2 3 3 9 2 2 0 0 8 2 4 9 4 0 1 8 2 8 3 4 2 2 7 7 3 0 5 9 3 0 z \\right.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2 0 7 6 1 8 6 9 1 6 4 1 6 9 3 1 9 4 0 1 3 9 1 3 8 5 6 4 3 7 4 4 0 7 9 9 3 5 9 4 7 7 3 9 4 7 0 8 3 3) x</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>8 6 5 5 8 6 8 0 6 6 5 9 4 6 0 1 9 0 9 1 1 5 5 8 9 3 6 4 9 6 1 8 5 1 1 7 1 1 8 5 7 0 0 6 6 3 9 1 2 z</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 0 0 0 7 8 5 4 5 7 2 8 0 0 7 3 4 1 1 5 5 2 8 5 5 5 6 2 0 2 5 8 7 5 0 2 7 8 6 7 2 5 3 2 8 9 2 6 8 4 0</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\phi(x)=x^{4}+\\left(219112197525249939489021148723396195060526757240452305599911\\,z\\right.</span> <span class="math">\\left.+232195459756277207668290744189666458139902433390551341656528\\right)x^{3}</span> <span class="math">\\left.+\\left(594916073500040823788294024401624746100803972996113795081168\\,z\\right.\\right.</span> <span class="math">\\left.+1491733188035767138269714863651199530197565717202128281224736\\right)x^{2}</span> <span class="math">\\left.+\\left(368670618173749485914803951629408734838837634364966781557695\\,z\\right.\\right.</span> <span class="math">\\left.+432633999913395482830349485439642501997391862510211315077671\\right)x</span> <span class="math">\\left.+377149149105267014252611707616265415027056683736547273647776\\,z\\right.</span> <span class="math">\\left.+1541864260749309457110332874518502663676542578712339437212985\\right.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{166}<span class="math">. If we take </span>d=4<span class="math"> and </span>r=1$, we get the following polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(z)=z^{2}+{}_{12}\\,z+{}_{7}</span> <span class="math">f(x)=x^{8}-{}_{33}\\,x^{7}+{}_{(z-732)}\\,x^{6}+{}_{(14\\,z-3424)}\\,x^{5}+{}_{(57\\,z-2627)}\\,x^{4}+{}_{(68\\,z-5218)}\\,x^{3}</span> <span class="math">\\left.+(100\\,z-3524)\\,x^{2}+(48\\,z-2940)\\,x+(36\\,z-1764)\\right.</span> <span class="math">g(x)=-8459635622214131881453154771645357881453\\,x^{4}+\\left(279295371920032891418561\\right.</span> <span class="math">\\left.2401694261426806\\,z-75589030561045575141735230547349874103523\\right)x^{3}+\\left(1955\\right.</span> <span class="math">\\left.0676034402302399299286811859829987642\\,z-46258053500428493420510179894369\\right.</span> <span class="math">\\left.30074575\\right)x^{2}+\\left(11171814876801315656742449606777045707224\\,z-485670535777\\right.</span> <span class="math">\\left.58344123346279040038759970502\\right)x+16757722315201973485113674410165568560</span> <span class="math">\\left.836\\,z-47471673499995120540659954245122066311394\\right.</span> <span class="math">\\phi(x)=x^{4}+\\left(565475204609949271152307636708128312016958684733798907353217\\,z+11\\right.</span> <span class="math">\\left.84756784924463459634744713698224486003358229093291131584098\\right)x^{3}+\\left(744450\\right.</span> <span class="math">\\left.343751664346982229272274572979074304805571006680869297\\,z+258607273176292\\right.</span> <span class="math">\\left.839733402534181758389412492634739073744580569\\right)x^{2}+\\left(654962774180806809067\\right.</span> <span class="math">\\left.268454491350645545631745152402794111257\\,z+1525151051179873287455054670110\\right.</span> <span class="math">\\left.572738969026928807578855733140\\right)x+178975139141715075829921635566444667057</span> <span class="math">\\left.346120837207773516080\\,z+6807885325108196556406199128246965059313373994285\\right.</span> <span class="math">\\left.75448298096\\right.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{135}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-16" class="text-base font-medium mt-4">Example 5.</h6>

    <p class="text-gray-300">Consider <span class="math">n=9</span> and <span class="math">p</span> as given by the equation (12). Take <span class="math">\\eta=3</span>, so we have <span class="math">\\kappa=3</span>. For <span class="math">d=1</span> and <span class="math">r=3</span>, we get the following set of polynomials.</p>

    <p class="text-gray-300"><span class="math">h(z)=z^{3}+z^{2}+{}_{18}\\,z+{}_{15}</span> <span class="math">f(x)=x^{4}-{}_{6}\\,x^{3}-{}_{211}\\,x^{2}-{}_{1187}\\,x+{}_{z-2034}</span></p>

    <p class="text-gray-300"><span class="math">g(x)=26981402912709485347737825847046497279699330705965517\\,x^{3}</span> <span class="math">+\\left(-145287218523022264703232833237431484597080807921826676\\,z^{2}\\right.</span> <span class="math">\\left.+50411393983336265694242961439957876885464685858782189\\,z\\right.</span> <span class="math">\\left.+206881479896404787521252534650020897293982167689590409\\right)x^{2}</span> <span class="math">+\\left(-562799080702299135013029013687164984984908940586595961\\,z^{2}\\right.</span> <span class="math">\\left.+349365561960939643979968647853372949952345188547313416\\,z\\right.</span> <span class="math">\\left.-23877234432621396396578679238125394048073361562258711\\right)x</span> <span class="math">\\left.+1285779122778936362366127131791594871482581595497499229\\,z^{2}\\right.</span> <span class="math">\\left.+687713620758567056387946957984845559129643558060874123\\,z\\right.</span> <span class="math">\\left.-830129381763336761947236727036816628661146469569955030\\right.</span> <span class="math">\\phi(x)=x^{3}+\\left(669339476643413131528050298510860109656533927528567342123649\\,z^{2}\\right.</span> <span class="math">\\left.+1552664467516964209731788191787357794434681140723383971203939\\,z\\right.</span> <span class="math">\\left.+943932691068840507491372697519702885049901068217108999449340\\right)x^{2}</span> <span class="math">+\\left(1191853923360225777848944386877957883516261096877478017413866\\,z^{2}\\right.</span> <span class="math">\\left.+421341580961908534729044227924897299449513889433708503340901\\,z\\right.</span> <span class="math">\\left.+235622039392351511019273446915854970293312748291080468943554\\right)x</span> <span class="math">\\left.+209551211497370380856126797068962682591000324511877123851147\\,z^{2}\\right.</span> <span class="math">\\left.+1000724369592593057730299648522737075992111849892300346453870\\,z\\right.</span> <span class="math">\\left.+1059974783679948959817423948843794374202743207017793637420370\\right.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{179}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-17" class="text-2xl font-bold">6 Asymptotic Complexity Analysis for the Medium Prime Case</h2>

    <p class="text-gray-300">For <span class="math">1/3&lt;a\\leq 2/3</span>, write</p>

    <p class="text-gray-300"><span class="math">p=L_{Q}(a,c_{p}),\\text{ where }c_{p}=\\frac{1}{n}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1-a}\\text{ and so }n=\\frac{1}{c_{p}}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1-a}.</span> (13)</p>

    <p class="text-gray-300">For each <span class="math">c_{p}</span>, the runtime of the NFS algorithm is the same for the family of finite fields <span class="math">\\mathbb{F}_{p^{n}}</span> where <span class="math">p</span> is given by (13).</p>

    <p class="text-gray-300">Recall that <span class="math">n=\\eta\\kappa</span>. Suppose <span class="math">\\eta</span> can be written as</p>

    <p class="text-gray-300"><span class="math">\\eta=c_{\\eta}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{2/3-a}.</span> (14)</p>

    <p class="text-gray-300">The boundary case arises when <span class="math">a=2/3</span> and in this case <span class="math">\\eta=c_{\\eta}</span>. If further, we have <span class="math">\\eta=1</span>, then <span class="math">c_{\\eta}</span> is also <span class="math">1</span>.</p>

    <p class="text-gray-300">From <span class="math">n=\\eta\\kappa</span>, we get</p>

    <p class="text-gray-300"><span class="math">\\kappa</span> <span class="math">=\\frac{1}{c_{\\theta}}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1/3}\\text{ where}</span> (15) <span class="math">c_{\\theta}</span> <span class="math">=c_{p}c_{\\eta}.</span></p>

    <p class="text-gray-300">, given <span class="math">Q</span> and <span class="math">\\kappa</span>, the value of <span class="math">c_{\\theta}</span> is fixed.</p>

    <p class="text-gray-300">We recall the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The number of polynomials to be considered for sieving is <span class="math">E^{2}</span>, so the cost of relation collection step is <span class="math">O(E^{2})</span>.</li>

      <li>The factor base is of size <span class="math">B</span> and hence cost of linear algebra step is <span class="math">O(B^{2})</span>.</li>

    </ol>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">B=L_{Q}(1/3,c_{b}).</span> (16)</p>

    <p class="text-gray-300">Set</p>

    <p class="text-gray-300"><span class="math">E=B</span> (17)</p>

    <p class="text-gray-300">so that asymptotically, the cost of relation collection step is same as the cost of linear algebra step.</p>

    <p class="text-gray-300">Let <span class="math">\\pi=\\Psi(\\Gamma,B)</span> be the probability that a random positive integer which is at most <span class="math">\\Gamma</span> is <span class="math">B</span>-smooth. Let <span class="math">\\Gamma=L_{Q}(z,\\zeta)</span> and <span class="math">B=L_{Q}(b,c_{b})</span>. Using the L-notation version of the Canfield-Erdös-Pomerance theorem,</p>

    <p class="text-gray-300"><span class="math">\\left(\\Psi(\\Gamma,B)\\right)^{-1}=L_{Q}\\left(z-b,(z-b)\\frac{\\zeta}{c_{b}}\\right).</span> (18)</p>

    <p class="text-gray-300">Following the usual convention, we assume that the same smoothness probability <span class="math">\\pi</span> holds for the event that a random sieving polynomial <span class="math">\\phi(x)</span> is smooth over the factor base.</p>

    <p class="text-gray-300">Since the total number of polynomials considered for sieving is <span class="math">E^{2}</span>, the number of relations obtained after sieving is <span class="math">E^{2}\\pi</span>. For linear algebra step to be successful, we need <span class="math">E^{2}\\pi=B</span> and so</p>

    <p class="text-gray-300"><span class="math">\\pi^{-1}=B.</span> (19)</p>

    <p class="text-gray-300">Obtaining <span class="math">\\pi^{-1}</span> from (18) and setting it to be equal to <span class="math">B</span> allows solving for <span class="math">c_{b}</span>. Balancing the costs of the sieving and the linear algebra phases leads to the runtime of the NFS algorithm to be <span class="math">B^{2}=L_{Q}(b,2c_{b})</span>. So, to determine the runtime, we need to determine <span class="math">c_{b}</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">Let <span class="math">n=\\eta\\kappa</span> and <span class="math">\\kappa=kd</span> for positive integers <span class="math">\\eta,k</span> and <span class="math">d</span>. Using the expressions for <span class="math">p</span> and <span class="math">E(=B)</span> given by (13) and (16), we obtain the following.</p>

    <p class="text-gray-300">\\[ \\left.E^{\\frac{2}{t}d(2r+1)}=L_{Q}\\left(4/3-a,\\frac{2c_{b}(2r+1)}{c_{p}\\eta kt}\\right);\\right\\} \\] (20) <span class="math">\\left.Q^{\\frac{(t-1)\\varepsilon}{\\kappa}}=L_{Q}\\left(a,\\eta c_{p}(t-1)\\varepsilon\\right).\\right.</span></p>

    <p class="text-gray-300">If further <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln\\ln Q)^{2/3-a}</span>, then</p>

    <p class="text-gray-300">\\[ \\left.E^{\\frac{2}{t}d(2r+1)}=L_{Q}\\left(2/3,\\frac{2c_{b}(2r+1)}{c_{\\theta}kt}\\right);\\right\\} \\] (21) $\\left.Q^{\\frac{(t-1)\\varepsilon}{\\kappa}}=L_{Q}\\left(2/3,(t-1)c_{\\theta}\\varepsilon\\right).\\right\\} \\]</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">n=\\eta\\kappa</span>; <span class="math">\\kappa=kd</span>; <span class="math">r\\geq k</span>; <span class="math">t\\geq 2</span>; <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3&lt;a\\leq 2/3</span>; and <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln\\ln Q)^{2/3-a}</span>. It is possible to ensure that the runtime of the NFS algorithm with polynomials chosen by Algorithm <span class="math">\\mathcal{B}</span> is <span class="math">L_{Q}(1/3,2c_{b})</span> where</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2(2r+1)}{6c_{\\theta}kt}+\\sqrt{\\left(\\frac{2r+1}{3c_{\\theta}kt}\\right)^{2}+\\frac{(t-1)c_{\\theta}\\varepsilon}{3}}.</span> (22)</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The product of the norms given by (21) is</p>

    <p class="text-gray-300"><span class="math">\\Gamma=L_{Q}\\left(\\frac{2}{3},\\frac{2c_{b}(2r+1)}{c_{\\theta}kt}+(t-1)c_{\\theta}\\varepsilon\\right).</span></p>

    <p class="text-gray-300">Then <span class="math">\\pi^{-1}</span> given by (18) is</p>

    <p class="text-gray-300"><span class="math">L_{Q}\\left(\\frac{1}{3},\\frac{1}{3}\\left(\\frac{2(2r+1)}{c_{\\theta}kt}+\\frac{(t-1)c_{\\theta}\\varepsilon}{c_{b}}\\right)\\right).</span></p>

    <p class="text-gray-300">From the condition <span class="math">\\pi^{-1}=B</span>, we get</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{1}{3}\\left(\\frac{2(2r+1)}{c_{\\theta}kt}+\\frac{(t-1)c_{\\theta}\\varepsilon}{c_{b}}\\right).</span> (23)</p>

    <p class="text-gray-300">Solving the quadratic for <span class="math">c_{b}</span> and choosing the positive root gives</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2(2r+1)}{6c_{\\theta}kt}+\\sqrt{\\left(\\frac{2r+1}{3c_{\\theta}kt}\\right)^{2}+\\frac{(t-1)c_{\\theta}\\varepsilon}{3}}.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We wish to minimise the value of <span class="math">c_{b}</span> with respect to <span class="math">c_{\\theta}</span>. To do this, we differentiate (22) with respect to <span class="math">c_{\\theta}</span> and set to <span class="math">0</span> to obtain the following equation which has to be solved for <span class="math">c_{\\theta}</span>.</p>

    <p class="text-gray-300"><span class="math">0=\\frac{-2(2r+1)}{6ktc_{\\theta}^{2}}+\\frac{1}{2}\\left(\\left(\\frac{2r+1}{3c_{\\theta}kt}\\right)^{2}+\\frac{(t-1)c_{\\theta}\\varepsilon}{3}\\right)^{-1/2}\\left(\\frac{-2(2r+1)^{2}}{9k^{2}t^{2}c_{\\theta}^{3}}+\\frac{(t-1)\\varepsilon}{3}\\right)</span></p>

    <p class="text-gray-300">This can be seen as a quadratic in <span class="math">c_{\\theta}^{3}</span> which can be solved using standard algebraic manipulations to obtain</p>

    <p class="text-gray-300"><span class="math">c_{\\theta}^{3}=8\\left(\\frac{2r+1}{3kt}\\right)^{2}\\cdot\\frac{3}{(t-1)\\varepsilon}.</span></p>

    <p class="text-gray-300">Taking cube roots on both sides gives the value of <span class="math">c_{\\theta}</span>. Substituting this value of <span class="math">c_{\\theta}</span> in (22) we obtain</p>

    <p class="text-gray-300"><span class="math">2c_{b}=\\left(\\frac{64(2r+1)(t-1)\\varepsilon}{9kt}\\right)^{1/3}=\\left(\\frac{64(2r+1)(t-1)}{9kt}\\cdot\\frac{r(\\lambda-1)+k}{r\\lambda+1}\\right)^{1/3}</span> (24)</p>

    <p class="text-gray-300">The expression on the right hand side of (24) clearly increases as <span class="math">t</span> increases. So, to minimise <span class="math">2c_{b}</span>, we should choose the minimum value of <span class="math">t</span> which is <span class="math">t=2</span>. With <span class="math">t=2</span>, the right hand side of (24) becomes</p>

    <p class="text-gray-300"><span class="math">\\left(\\frac{32(2r+1)}{9k}\\cdot\\frac{r(\\lambda-1)+k}{r\\lambda+1}\\right)^{1/3}</span> (25)</p>

    <p class="text-gray-300">We consider several cases:</p>

    <p class="text-gray-300">Case <span class="math">\\lambda=1</span>: The right hand side of (25) becomes</p>

    <p class="text-gray-300"><span class="math">\\left(\\frac{32(2r+1)}{9(r+1)}\\right)</span></p>

    <p class="text-gray-300">which takes the minimum value of <span class="math">(48/9)^{1/3}</span> for <span class="math">r=1</span>. This can arise in the following ways.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\eta=1</span>, <span class="math">a=2/3</span>: This corresponds to the boundary case and the minimum complexity of <span class="math">(48/9)^{1/3}</span> has already been reported in <em>[3]</em>.</li>

      <li><span class="math">\\eta&gt;1</span>, <span class="math">1/3&lt;a&lt;2/3</span>: Again, the minimum complexity of <span class="math">(48/9)^{1/3}</span> for this case has already been reported in <em>[17]</em>. Note that since <span class="math">\\lambda=1</span> and <span class="math">\\eta&gt;1</span>, this case requires <span class="math">\\gcd(\\eta,\\kappa)=1</span> and hence applies to non prime-power values of <span class="math">n</span>.</li>

    </ol>

    <p class="text-gray-300">In both the above cases, the minimum complexity is not achievable for all values of <span class="math">c_{\\theta}</span>. The minimum achievable values of <span class="math">2c_{b}</span> as <span class="math">c_{\\theta}</span> varies depends on the values of <span class="math">r,k</span> and <span class="math">t</span>. This is shown in Figure 3 by the plot of <span class="math">2c_{b}</span> against <span class="math">c_{\\theta}</span> where <span class="math">c_{b}</span> is given by (22). This plot extends a similar plot provided in <em>[20]</em> for the case <span class="math">\\eta=1</span>.</p>

    <p class="text-gray-300">Case <span class="math">\\lambda=\\eta&gt;1</span>: For a fixed <span class="math">k</span>, increasing <span class="math">r</span> leads to increase in the value of (25) which shows that this expression is minimised for the minimum value of <span class="math">r</span> which is <span class="math">r=k</span>. Setting <span class="math">r=k</span>, and using <span class="math">\\lambda=\\eta</span>, (25) becomes</p>

    <p class="text-gray-300"><span class="math">\\left(\\frac{32(2k+1)}{9}\\cdot\\frac{\\eta}{k\\eta+1}\\right)^{1/3}.</span> (26)</p>

    <p class="text-gray-300">The expression given by (26) decreases as <span class="math">k</span> increases and so the minimum is achieved for the maximum value of <span class="math">k</span> which is <span class="math">k=\\kappa</span> implying that <span class="math">d=1</span>. Using <span class="math">k=\\kappa</span> in (26) we obtain the minimum possible value of <span class="math">2c_{b}</span> in this case to be</p>

    <p class="text-gray-300"><span class="math">\\left(\\frac{32(2\\kappa+1)}{9}\\cdot\\frac{\\eta}{\\kappa\\eta+1}\\right)^{1/3}=\\left(\\frac{32(2n+\\eta)}{9(n+1)}\\right)^{1/3}.</span> (27)</p>

    <p class="text-gray-300">We consider composite prime-power values of <span class="math">n</span>. Suppose that <span class="math">n</span> can be written as <span class="math">n=\\eta^{i}</span> for some prime <span class="math">\\eta</span> and some <span class="math">i&gt;1</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\eta=2</span>, then the minimum possible value of <span class="math">2c_{b}</span> for the case <span class="math">\\lambda=\\eta=2</span> is <span class="math">(64/9)^{1/3}\\approx 1.92</span> for all <span class="math">n=2^{i}</span>. In particular, this case covers <span class="math">n=4,8,16</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\eta = 3</span>  and  <span class="math">n = 9</span> , then the minimum possible value of  <span class="math">2c_{b}</span>  for the case  <span class="math">\\lambda = \\eta = 3</span>  is  <span class="math">(112 / 15)^{1 / 3} \\approx 1.95</span> .</li>

      <li>If  <span class="math">\\eta = 5</span>  and  <span class="math">n = 25</span> , then the minimum possible value of  <span class="math">2c_{b}</span>  for the case  <span class="math">\\lambda = \\eta = 5</span>  is  <span class="math">(880 / 117)^{1 / 3} \\approx 1.96</span> .</li>

    </ol>

    <p class="text-gray-300">The above covers the small composite prime-power values of  <span class="math">n</span>  and the minimum value of  <span class="math">2c_{b}</span>  that can be achieved in each case. Note that similar to the case of  <span class="math">\\lambda = 1</span> , this minimum is achieved at a particular value of  <span class="math">c_{\\theta}</span> . The more general picture of the variation in complexity is given by  <span class="math">2c_{b}</span>  where the expression for  <span class="math">c_{b}</span>  is given by (22). Figure 3 shows the plots of  <span class="math">2c_{b}</span>  (minimised over  <span class="math">t</span> ,  <span class="math">k</span>  and  <span class="math">r</span> ) against  <span class="math">c_{\\theta}</span>  for different values of  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 3. Complexity plots for the medium prime case using the exTNFS algorithm.</p>

    <p class="text-gray-300">In the multiple number field sieve (MNFS) algorithm, several number fields are considered. These number fields are generated by the irreducible polynomials in  <span class="math">R[x]</span> , having a common irreducible factor over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . There are two variants of MNFS algorithm. We discuss the second variant of MNFS only where the image of  <span class="math">\\phi(x)</span>  needs to be smooth in the first number field and at least one of the other  <span class="math">V</span>  number fields.</p>

    <p class="text-gray-300">Methods for obtaining the collection of number fields for MNFS algorithm have been mentioned in [18]. We adapt one of these methods to our setting. Note</p>

    <p class="text-gray-300">that the Algorithm <span class="math">\\mathcal{C}</span> produces two polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> of degrees <span class="math">d(r+1)</span> and <span class="math">dr</span> respectively. The polynomial <span class="math">g(x)</span> is defined as <span class="math">\\mathrm{Res}_y(\\psi(y), C_0(x)+yC_1(x))</span> where <span class="math">\\psi(x)=\\mathrm{LLL}(M_{A_2,r})</span>, i.e., <span class="math">\\psi(x)</span> is defined from the first row of the matrix obtained after applying the LLL-algorithm to <span class="math">M_{A_2,r}</span>. We use <span class="math">f(x)</span> for constructing the first number field. Let <span class="math">g_1(x)=g(x)</span> and <span class="math">g_2(x)=\\mathrm{Res}_y(\\psi_2(y), C_0(x)+yC_1(x))</span>, where <span class="math">\\psi_2(x)</span> is the polynomial defined from the second row of the matrix <span class="math">M_{A_2,r}</span>. For <span class="math">i=3,\\ldots,V</span>, we consider <span class="math">g_i(x)=s_i g_1(x)+t_i g_2(x)</span> where the coefficients <span class="math">s_i</span> and <span class="math">t_i</span> are of the size of <span class="math">\\sqrt{V}</span>. These <span class="math">g_i(x)</span> are used for constructing the other <span class="math">V</span> number fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly the <span class="math">g_i</span>'s have degree <span class="math">dr</span>. Asymptotically, we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=Q^{1/(d(r+1))}<span class="math">. If we choose </span>V=L_Q(1/3)<span class="math">, all the </span>g_i$'s have their infinity norms given by Proposition 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">B</span> and <span class="math">B&#x27;</span> be the bounds on the norms of the ideals which are in the factor basis defined by <span class="math">f</span> and each of <span class="math">g_i</span>'s respectively. So, the size of the entire factor basis is <span class="math">B + VB&#x27;</span>. We further use the following condition to balances the factor basis.</p>

    <div class="my-4 text-center"><span class="math-block">B = V B&#x27;. \\tag{28}</span></div>

    <p class="text-gray-300">With this condition, the size of the factor basis is <span class="math">B^{1 + o(1)}</span> and so asymptotically, the linear algebra step takes time <span class="math">B^2</span>. Similar to the analysis of NFS variant, the number of sieving polynomials is <span class="math">E^2</span> and the coefficient polynomials of <span class="math">\\phi(x)</span> can take <span class="math">E^{2 / t}</span> distinct values. Since we require that the cost of relation collection should be same as the cost of linear algebra, we have <span class="math">E^2 = B^2</span> i.e., <span class="math">E = B</span>.</p>

    <p class="text-gray-300">As before, let <span class="math">\\pi</span> be the probability that a random sieving polynomial <span class="math">\\phi(x)</span> gives rise to a relation. Let <span class="math">\\pi_1</span> be the probability that <span class="math">\\phi(x)</span> is smooth over the factor basis for the first number field and <span class="math">\\pi_2</span> be the probability that <span class="math">\\phi(x)</span> is smooth over at least one of the other <span class="math">V</span> factor bases. Further, let <span class="math">\\Gamma_1 = \\mathrm{Res}_x(f(x),\\phi(x))</span> be the bound on the norm corresponding to the first number field and <span class="math">\\Gamma_2 = \\mathrm{Res}_x(g_i(x),\\phi(x))</span> be the bound on the norm for any of the other number fields. Recall that <span class="math">\\Gamma_2</span> is determined only by the degree and the <span class="math">L_{\\infty}</span>-norm of <span class="math">g_i(x)</span> and hence is the same for all <span class="math">g_i(x)</span>'s. Heuristically, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_1 = \\Psi(\\Gamma_1, B);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_2 = V\\Psi(\\Gamma_2, B&#x27;); \\tag{29}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi = \\pi_1 \\times \\pi_2.</span></div>

    <p class="text-gray-300">One relation is obtained in about <span class="math">\\pi^{-1}</span> trials and so total number of relations obtained after sieving would be <span class="math">E^2\\pi</span> and this should be equal to <span class="math">B</span> for linear algebra step to go through. Hence we have, as before, <span class="math">B = E = \\pi^{-1}</span>.</p>

    <p class="text-gray-300">The following choices of <span class="math">B</span> and <span class="math">V</span> are made.</p>

    <div class="my-4 text-center"><span class="math-block">E = B = L_Q\\left(\\frac{1}{3}, c_b\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">V = L_Q\\left(\\frac{1}{3}, c_v\\right); \\text{ and so} \\tag{30}</span></div>

    <div class="my-4 text-center"><span class="math-block">B&#x27; = B/V = L_Q\\left(\\frac{1}{3}, c_b - c_v\\right).</span></div>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">n=\\eta\\kappa</span>; <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3&lt;a&lt;2/3</span>; and <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln\\ln Q)^{2/3-a}</span>. It is possible to ensure that the runtime of the MNFS algorithm is <span class="math">L_{Q}(1/3,2c_{b})</span> where</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2r+1}{3c_{\\theta}kt}+\\sqrt{\\frac{r(3r+2)}{9c_{\\theta}^{2}k^{2}t^{2}}+\\frac{(t-1)c_{\\theta}\\varepsilon}{3}}.</span> (31)</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For a sieving polynomial <span class="math">\\phi</span>,</p>

    <p class="text-gray-300"><span class="math">\\Gamma_{1}</span> <span class="math">=N(\\phi,f)=E^{2d(r+1)/t}L_{Q}(2/3,o(1))</span> <span class="math">=L_{Q}(2/3,(2c_{b}(r+1))/(c_{\\theta}kt));</span> <span class="math">\\pi_{1}^{-1}</span> <span class="math">=L_{Q}(1/3,2(r+1)/(3c_{\\theta}kt));</span> <span class="math">\\Gamma_{2}</span> <span class="math">=N(\\phi,g)=E^{2dr/t}\\times Q^{(t-1)\\varepsilon/\\kappa}L_{Q}(2/3,o(1)</span> <span class="math">=L_{Q}(2/3,2c_{b}r/(c_{\\theta}kt)+(t-1)c_{\\theta}\\varepsilon);</span> <span class="math">\\pi_{2}^{-1}</span> <span class="math">=L_{Q}\\left(\\frac{1}{3},-c_{v}+\\frac{1}{3(c_{b}-c_{v})}\\left(\\frac{2c_{b}r}{c_{\\theta}kt}+(t-1)c_{\\theta}\\varepsilon\\right)\\right);</span> <span class="math">\\pi^{-1}</span> <span class="math">=L_{Q}\\left(\\frac{1}{3},\\frac{2(r+1)}{3c_{\\theta}kt}-c_{v}+\\frac{1}{3(c_{b}-c_{v})}\\left(\\frac{2c_{b}r}{c_{\\theta}kt}+(t-1)c_{\\theta}\\varepsilon\\right)\\right);</span></p>

    <p class="text-gray-300">From the condition <span class="math">\\pi^{-1}=B</span>, we obtain the following equation.</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2(r+1)}{3c_{\\theta}kt}-c_{v}+\\frac{1}{3(c_{b}-c_{v})}\\left(\\frac{2c_{b}r}{c_{\\theta}kt}+(t-1)c_{\\theta}\\varepsilon\\right).</span> (32)</p>

    <p class="text-gray-300">Simplifying, we obtain</p>

    <p class="text-gray-300"><span class="math">3c_{\\theta}kt(c_{b}^{2}-c_{v}^{2})=2(2r+1)c_{b}-2(r+1)c_{v}+(t-1)c_{\\theta}^{2}\\varepsilon kt.</span> (33)</p>

    <p class="text-gray-300">We wish to find <span class="math">c_{v}</span> such that <span class="math">c_{b}</span> is minimised subject to the constraint (33). Using the method of Lagrange multipliers, the partial derivative of (33) with respect to <span class="math">c_{v}</span> gives</p>

    <p class="text-gray-300"><span class="math">c_{v}=\\frac{(r+1)}{3c_{\\theta}kt}.</span></p>

    <p class="text-gray-300">Using this value of <span class="math">c_{v}</span> in (33) provides the following quadratic in <span class="math">c_{b}</span>.</p>

    <p class="text-gray-300"><span class="math">(3c_{\\theta}kt)^{2}c_{b}^{2}-(6(2r+1)c_{\\theta}kt)c_{b}+(r+1)^{2}-3(t-1)c_{\\theta}^{3}k^{2}t^{2}\\varepsilon=0.</span></p>

    <p class="text-gray-300">Solving this and taking the positive square root, we obtain the expression for <span class="math">c_{b}</span> given by (31). ∎</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 4: Complexity plots for the medium prime case using the MexTNFS algorithm.</p>

    <p class="text-gray-300">To find the absolute minimum complexity, we need to minimise the expression for <span class="math">c_{b}</span> given by (31) with respect to <span class="math">c_{\\theta}</span>. The standard way of doing this is to differentiate with respect to <span class="math">c_{\\theta}</span> and set to 0 to find the value of <span class="math">c_{\\theta}</span> for which the minimum value of <span class="math">c_{b}</span> is attained. Differentiating the right hand side of (31) with respect to <span class="math">c_{\\theta}</span> and setting to 0 yields (after some simplifications) a quadratic in <span class="math">c_{\\theta}^{3}</span> which can be solved to obtain:</p>

    <p class="text-gray-300"><span class="math">c_{\\theta}^{3}=\\frac{2}{3\\varepsilon k^{2}t^{2}(t-1)}\\cdot\\left(4r^{2}+9r+1+\\sqrt{7r^{2}+16r+1}\\right).</span> (34)</p>

    <p class="text-gray-300">Substituting the value of <span class="math">c_{\\theta}</span> in (31) provides the expression for the corresponding value of <span class="math">2c_{b}</span> in terms of <span class="math">t,r,k</span> and <span class="math">\\lambda</span>. For each value of <span class="math">\\lambda</span>, we wish to obtain the minimum possible value of <span class="math">2c_{b}</span>. This is achieved with <span class="math">t=2</span> and <span class="math">r=k</span>. The actual value of <span class="math">r</span> depends on the value of <span class="math">\\lambda</span>: for <span class="math">\\lambda=1</span> the minimum value of <span class="math">2c_{b}</span> is <span class="math">\\approx 1.71</span> and is achieved for <span class="math">r=1</span>; for <span class="math">\\lambda=2</span> the minimum value of <span class="math">2c_{b}</span> is <span class="math">\\approx 1.88</span> and is achieved for <span class="math">r=1</span>; for <span class="math">\\lambda=3</span> the minimum value of <span class="math">2c_{b}</span> is <span class="math">\\approx 1.92</span> and is achieved for <span class="math">r=4</span>; for <span class="math">\\lambda=5</span> the minimum value of <span class="math">2c_{b}</span> is <span class="math">\\approx 1.94</span> and is achieved for <span class="math">r=4</span>.</p>

    <p class="text-gray-300">The variation of <span class="math">2c_{b}</span> with <span class="math">c_{\\theta}</span> is more complex. Figure 4 shows these plots for various values of <span class="math">\\lambda</span>. From <em>[17]</em>, the complexities for the medium characteristic case, the large characteristic case and the best complexity for the boundary case are respectively <span class="math">L_{Q}(1/3,2.12)</span>, <span class="math">L_{Q}(1/3,1.90)</span> and <span class="math">L_{Q}(1/3,1.71)</span>. For composite prime-power <span class="math">n</span>, these are the previously known best known complexities for these</p>

    <p class="text-gray-300">cases. To make the comparison of the new complexities easier, Figure 4 shows the lines for 2.12, 1.90 and 1.71.</p>

    <h2 id="sec-24" class="text-2xl font-bold">8 Conclusion</h2>

    <p class="text-gray-300">In this paper, we have presented a new polynomial selection method for exTNFS algorithm. The new polynomial selection method subsumes GJL, Conjugation and Sarkar-Singh polynomial selection methods. The exTNFS algorithm combined with new polynomial selection method provides new asymptotic complexities for the extension fields with composite prime power extension degrees.</p>

    <h2 id="sec-25" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Leonard M. Adleman. The function field sieve. In Leonard M. Adleman and Ming-Deh A. Huang, editors, ANTS, volume 877 of Lecture Notes in Computer Science, pages 108–121. Springer, 1994.</li>

      <li>[2] Leonard M. Adleman and Ming-Deh A. Huang. Function field sieve method for discrete logarithms over finite fields. Inf. Comput., 151(1-2):5–16, 1999.</li>

      <li>[3] Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and François Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology – EUROCRYPT 2015, volume 9056 of Lecture Notes in Computer Science, pages 129–155. Springer Berlin Heidelberg, 2015.</li>

      <li>[4] Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Phong Q. Nguyen and Elisabeth Oswald, editors, Advances in Cryptology - EUROCRYPT 2014 - 33rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Copenhagen, Denmark, May 11-15, 2014. Proceedings, volume 8441 of Lecture Notes in Computer Science, pages 1–16. Springer, 2014.</li>

      <li>[5] Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung. The tower number field sieve. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part II, volume 9453 of Lecture Notes in Computer Science, pages 31–55. Springer, 2015.</li>

      <li>[6] Razvan Barbulescu and Cécile Pierrot. The multiple number field sieve for medium and high characteristic finite fields. LMS Journal of Computation and Mathematics, 17:230–246, 2014.</li>

      <li>[7] Yuval Bistritz and Alexander Lifshitz. Bounds for resultants of univariate and bivariate polynomials. Linear Algebra and its Applications, 432(8):1995 – 2005, 2010. Special issue devoted to the 15th {ILAS} Conference at Cancun, Mexico, June 16-20, 2008.</li>

      <li>[8] Daniel M. Gordon. Discrete logarithms in GF(p) using the number field sieve. SIAM J. Discrete Math., 6(1):124–138, 1993.</li>

      <li>[9] Robert Granger, Thorsten Kleinjung, and Jens Zumbrägel. Discrete logarithms in GF(2^{9234}). NMBRTHRY list, January 2014.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[10] Antoine Joux. Faster index calculus for the medium prime case: Application to 1175-bit and 1425-bit finite fields. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT, volume 7881 of Lecture Notes in Computer Science, pages 177–193. Springer, 2013.</li>

      <li>[11] Antoine Joux. A new index calculus algorithm with complexity <span class="math">L(1/4+o(1))</span> in small characteristic. In Tanja Lange, Kristin E. Lauter, and Petr Lisonek, editors, Selected Areas in Cryptography - SAC 2013 - 20th International Conference, Burnaby, BC, Canada, August 14-16, 2013, Revised Selected Papers, volume 8282 of Lecture Notes in Computer Science, pages 355–379. Springer, 2013.</li>

      <li>[12] Antoine Joux and Reynald Lercier. The function field sieve is quite special. In Claus Fieker and David R. Kohel, editors, ANTS, volume 2369 of Lecture Notes in Computer Science, pages 431–445. Springer, 2002.</li>

      <li>[13] Antoine Joux and Reynald Lercier. Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the gaussian integer method. Math. Comput., 72(242):953–967, 2003.</li>

      <li>[14] Antoine Joux and Reynald Lercier. The function field sieve in the medium prime case. In Serge Vaudenay, editor, EUROCRYPT, volume 4004 of Lecture Notes in Computer Science, pages 254–270. Springer, 2006.</li>

      <li>[15] Antoine Joux, Reynald Lercier, Nigel P. Smart, and Frederik Vercauteren. The number field sieve in the medium prime case. In Cynthia Dwork, editor, Advances in Cryptology - CRYPTO 2006, 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006, Proceedings, volume 4117 of Lecture Notes in Computer Science, pages 326–344. Springer Berlin Heidelberg, 2006.</li>

      <li>[16] Antoine Joux and Cécile Pierrot. The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> - Application to pairing-friendly constructions. In Zhenfu Cao and Fangguo Zhang, editors, Pairing-Based Cryptography - Pairing 2013 - 6th International Conference, Beijing, China, November 22-24, 2013, Revised Selected Papers, volume 8365 of Lecture Notes in Computer Science, pages 45–61. Springer, 2013.</li>

      <li>[17] Taechan Kim and Razvan Barbulescu. Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, Report 2015/1027, 2015. http://eprint.iacr.org/.</li>

      <li>[18] Cécile Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 156–170. Springer Berlin Heidelberg, 2015.</li>

      <li>[19] Palash Sarkar and Shashank Singh. Fine tuning the function field sieve algorithm for the medium prime case. IEEE Transactions on Information Theory, 62(4):2233–2253, April 2016. http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&arnumber=7405328.</li>

      <li>[20] Palash Sarkar and Shashank Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In Marc Fischlin and Jean-Sébastien Coron, editors, Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part I, volume 9665 of Lecture Notes in Computer Science, pages 429–458. Springer, 2016.</li>

      <li>[21] Oliver Schirokauer. Using number fields to compute logarithms in finite fields. Math. Comp., 69(231):1267–1283, 2000.</li>

    </ul>`;
---

<BaseLayout title="A General Polynomial Selection Method and New Asymptotic Com... (2016/485)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/485
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
