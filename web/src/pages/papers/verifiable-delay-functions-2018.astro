---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/601';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Verifiable Delay Functions';
const AUTHORS_HTML = 'Dan Boneh, Joseph Bonneau, Benedikt Bünz, Ben Fisch';

const CONTENT = `    <p class="text-gray-300">Dan Boneh [ Stanford University ] Joseph Bonneau [ New York University ] Benedikt Bünz [ Stanford University ] Ben Fisch [ Stanford University ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We study the problem of building a <em>verifiable delay function</em> (VDF). A VDF requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDFs have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDFs and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Consider the problem of running a verifiable lottery using a <em>randomness beacon</em>, a concept first described by Rabin <em>[66]</em> as an ideal service that regularly publishes random values which no party can predict or manipulate. A classic approach is to apply an extractor function to a public entropy source, such as stock prices <em>[24]</em>. Stock prices are believed to be difficult to predict for a passive observer, but an active adversary could manipulate prices to bias the lottery. For example, a high-frequency trader might slightly alter the closing price of a stock by executing (or not executing) a few transactions immediately before the market closes.</p>

    <p class="text-gray-300">Suppose the extractor takes only a single bit per asset (e.g. whether the stock finished up or down for the day) and suppose the adversary is capable of changing this bit for <span class="math">k</span> different assets using last-second trades. The attacker could read the prices of the assets it cannot control, quickly simulate <span class="math">2^{k}</span> potential lottery outcomes based on different combinations of the <span class="math">k</span> outcomes it can control, and then manipulate the market to ensure its preferred lottery outcome occurs.</p>

    <p class="text-gray-300">One solution is to add a delay function after extraction, making it slow to compute the beacon outcome from an input of raw stock prices. With a delay function of say, one hour, by the time the adversary simulates the outcome of any potential manipulation strategy, the market will be closed and prices finalized, making it too late to launch an attack. This suggests the key security property for a delay function: it should be infeasible for an adversary to distinguish the function’s output from random in less than a specified amount of wall-clock time, even given a potentially large number of parallel processors.</p>

    <p class="text-gray-300">A trivial delay function can be built by iterating a cryptographic hash function. For example, it is reasonable to assume it is infeasible to compute <span class="math">2^{40}</span> iterations of SHA-256 in a matter of</p>

    <p class="text-gray-300">seconds, even using specialized hardware. However, a lottery participant wishing to verify the output of this delay function must repeat the computation in its entirety (which might take many hours on a personal computer). Ideally, we would like to design a delay function which any observer can quickly verify was computed correctly.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Defining delay functions.</h4>

    <p class="text-gray-300">In this paper we formalize the requirements for a <em>verifiable delay function</em> (VDF) and provide the first constructions which meet these requirements. A VDF consists of a triple of algorithms: Setup, Eval, and Verify. <span class="math">\\mathsf{Setup}(\\lambda,t)</span> takes a security parameter <span class="math">\\lambda</span> and delay parameter <span class="math">t</span> and outputs public parameters <span class="math">\\mathbf{pp}</span> (which fix the domain and range of the VDF and may include other information necessary to compute or verify it). <span class="math">\\mathsf{Eval}(\\mathbf{pp},x)</span> takes an input <span class="math">x</span> from the domain and outputs a value <span class="math">y</span> in the range and (optionally) a short proof <span class="math">\\pi</span>. Finally, <span class="math">\\mathsf{Verify}(\\mathbf{pp},x,y,\\pi)</span> efficiently verifies that <span class="math">y</span> is the correct output on <span class="math">x</span>. Crucially, for every input <span class="math">x</span> there should be a <em>unique</em> output <span class="math">y</span> that will verify. Informally, a VDF scheme should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>sequential</em>: honest parties can compute <span class="math">(y,\\pi)\\leftarrow\\mathsf{Eval}(\\mathbf{pp},x)</span> in <span class="math">t</span> sequential steps, while no parallel-machine adversary with a polynomial number of processors can distinguish the output <span class="math">y</span> from random in significantly fewer steps.</li>

      <li><em>efficiently verifiable</em>: We prefer <span class="math">\\mathsf{Verify}</span> to be as fast as possible for honest parties to compute; we require it to take total time <span class="math">O(\\mathrm{polylog}(t))</span>.</li>

      <li><em>unique</em>: for all inputs <span class="math">x</span>, it is difficulty to find a <span class="math">y</span> for which <span class="math">\\mathsf{Verify}(\\mathbf{pp},x,y,\\pi)=\\mathit{Yes}</span>, but <span class="math">y\\neq\\mathsf{Eval}(\\mathbf{pp},x)</span>.</li>

    </ul>

    <p class="text-gray-300">A VDF should remain secure even in the face of an attacker able to perform polynomially bounded pre-computation.</p>

    <p class="text-gray-300">Some VDFs may also offer additional useful properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>decodable</em>: A VDF is decodable if there exists a decoding algorithm <span class="math">\\mathsf{Dec}</span> such that <span class="math">(\\mathsf{Eval},\\mathsf{Dec})</span> form a lossless encoding scheme. A lossless encoding scheme is a pair of algorithms <span class="math">(\\mathsf{Enc},\\mathsf{Dec})</span> where <span class="math">\\mathsf{Enc}:X\\rightarrow Y</span> and <span class="math">\\mathsf{Dec}:Y\\rightarrow X</span> such that <span class="math">\\mathsf{Dec}(\\mathsf{Enc}(x))=x</span> for all <span class="math">x\\in X</span>. We say that a VDF is <em>efficiently decodable</em> if it is decodable and <span class="math">\\mathsf{Dec}</span> is efficient. In this case, <span class="math">\\mathsf{Eval}</span> need not include a proof as <span class="math">\\mathsf{Dec}</span> itself can be used to verify the output. There are many different kinds of encoding schemes with different properties, including compression schemes, error correcting codes, ciphers, etc. Of course any VDF can be turned in a trivial encoding scheme by appending the input <span class="math">x</span> to the output, however this would not have any interesting properties as an encoding scheme. In Section 2, we will describe one interesting application of an encoding scheme that is both an efficiently invertible ideal cipher and a VDF. The application is to <em>proofs-of-replication</em>.</li>

      <li><em>incremental</em>: a single set of public parameters <span class="math">\\mathbf{pp}</span> supports multiple hardness parameters <span class="math">t</span>. The number of steps used to compute <span class="math">y</span> is specified in the proof, instead of being fixed during <span class="math">\\mathsf{Setup}</span>. The main benefit of incremental VDFs over a simple chaining of VDFs to increase the delay is a reduced aggregate proof size. This is particularly useful for applications of VDFs to computational time-stamping or blockchain consensus.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Classic slow functions</h4>

    <p class="text-gray-300">Time-lock puzzles <em>[68]</em> are similar to VDFs in that they involve computing an inherently sequential function. An elegant solution uses repeated squaring in an RSA group as a time-lock puzzle. However, time-lock puzzles are not required to be universally verifiable and in all known constructions the verifier uses its secret state to prepare each puzzle and verify the results. VDFs, by contrast, may require an initial trusted setup but then must be usable on any randomly chosen input.</p>

    <p class="text-gray-300">Another construction for a slow function dating to Dwork and Naor <em>[31]</em> is extracting modular square roots. Given a challenge <span class="math">x\\in\\mathbb{Z}_{p}^{<em>}</span> (with <span class="math">p\\equiv 3\\pmod{4}</span>), computing <span class="math">y=\\sqrt{x}=x^{\\frac{p+1}{4}}</span> (mod <span class="math">p</span>) can be efficiently verified by checking that <span class="math">y^{2}=x\\pmod{p}</span>. There is no known algorithm for computing modular exponentiation which is sublinear in the bit-length of the exponent. However, the difficulty of puzzles is limited to <span class="math">t=O(\\log p)</span> as the exponent can be reduced modulo <span class="math">p-1</span> before computation, requiring the use of a very large prime <span class="math">p</span> to produce a difficult puzzle. While it was not originally proposed for its sequential nature, it has subsequently been considered as such several times </em>[41, 48]<em>. In particular, Lenstra and Wesolowski </em>[48]<em> proposed chaining a series of such puzzles together in a construction called Sloth, with lotteries as a specific motivation. Sloth is best characterized as a </em>time-asymmetric encoding*, offering a trade-off in practice between computation and inversion (verification), and thus can be viewed as a pseudo-VDF. However, it does not meet our asymptotic definition of a VDF because it does not offer asymptotically efficient verification: the <span class="math">t</span>-bit modular exponentiation can be computed in parallel time <span class="math">t</span>, whereas the output (a <span class="math">t</span>-bit number) requires <span class="math">\\Omega(t)</span> time simply to read, and therefore verification cannot run in total time <span class="math">\\operatorname{polylog}(t)</span>. We give a more complete overview of related work in Section 9.</p>

    <p class="text-gray-300">Our contributions: In addition to providing the first formal definitions of VDFs, we contribute the following candidate constructions and techniques:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A theoretical VDF can be constructed using <em>incrementally verifiable computation</em> <em>[70]</em> (IVC), in which a proof of correctness for a computation of length <span class="math">t</span> can be computed in parallel to the computation with only <span class="math">\\operatorname{polylog}(t)</span> processors. We prove security of this theoretical VDF using IVC as a black box. IVC can be constructed from succinct non-interactive arguments of knowledge (SNARKs) under a suitable extractor complexity assumption <em>[14]</em>. In an update (May 2019) we present a simpler construction based only on verifiable computation (Section 5).</li>

      <li>We propose a construction based on injective polynomials over algebraic sets that cannot be inverted faster than computing polynomial GCDs. Computing polynomial GCD is sequential in the degree <span class="math">d</span> of the polynomials on machines with fewer than <span class="math">O(d^{2})</span> processors. We propose a candidate construction of time-asymmetric encodings from a particular family of <em>permutation polynomials</em> over finite fields <em>[39]</em>. This construction is asymptotically a strict improvement on Sloth, and to the best of our knowledge is the first encoding offering an exponential time gap between evaluation and inversion. We call this a <em>weak VDF</em> because it requires the honest <span class="math">\\mathsf{Eval}</span> to use greater than <span class="math">polylog(t)</span> parallelism to run in parallel time <span class="math">t</span> (the delay parameter).</li>

      <li>In Section 7 we describe a practical efficiency boost to constructing VDFs from IVC using time-asymmetric encodings as the underlying sequential computation, offering up to a 7,000 fold improvement (in the SNARK efficiency) over naive hash chains. In this</li>

    </ol>

    <p class="text-gray-300">construction the SNARK proof is only used to boost the efficiency of verification as the output <span class="math">(y,\\pi)</span> of <span class="math">\\mathsf{Eval}</span> on an input <span class="math">x</span> can also be verified directly without <span class="math">\\pi</span> by computing the inverse of <span class="math">y</span>, which is still faster than computing <span class="math">y</span> from <span class="math">x</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We construct a VDF secure against bounded pre-computation attacks following a generalization of time-lock puzzles based on exponentiation in a group of unknown order.</li>

    </ol>

    <h2 id="sec-6" class="text-2xl font-bold">2 Applications</h2>

    <p class="text-gray-300">Before giving precise definitions and describing our constructions, we first informally sketch several important applications of VDFs.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Randomness beacons.</h4>

    <p class="text-gray-300">VDFs are useful for constructing randomness beacons from sources such as stock prices <em>[24]</em> or proof-of-work blockchains (e.g. Bitcoin, Ethereum) <em>[17, 63, 12]</em>. Proof-of-work blockchains include randomly sampled solutions to computational puzzles that network participants (called miners) continually find and publish for monetary rewards. Underpinning the security of proof-of-work blockchains is the strong belief that these solutions have high computational min-entropy. However, similar to potential manipulation of asset prices by high-frequency traders, powerful miners could potentially manipulate the beacon result by refusing to post blocks which produce an unfavorable beacon output.</p>

    <p class="text-gray-300">Again, this attack is only feasible if the beacon can be computed quickly, as each block is fixed to a specific predecessor and will become “stale” if not published. If a VDF with a suitably long delay is used to compute the beacon, miners will not be able to determine the beacon output from a given block before it becomes stale. More specifically, given the desired delay parameter <span class="math">t</span>, the public parameters <span class="math">\\mathbf{pp}=(\\mathsf{ek},\\mathsf{vk})\\ \\epsilon^{\\underline{\\mathsf{n}}}\\ \\mathsf{Setup}(\\lambda,t)</span> are posted on the blockchain, then given a block <span class="math">b</span> the beacon value is determined to be <span class="math">r</span> where <span class="math">(r,\\pi)=\\mathsf{Eval}(\\mathsf{ek},b)</span>, and anyone can verify correctness by running <span class="math">\\mathsf{Verify}(\\mathsf{vk},b,r,\\pi)</span>. The security of this construction, and in particular the length of delay parameter which would be sufficient to prevent attacks, remains an informal conjecture due to the lack of a complete game-theoretic model capturing miner incentives in Nakamoto-style consensus protocols. We refer the reader to <em>[17, 63, 12]</em> for proposed models for blockchain manipulation. Note that most formal models for Nakamoto-style consensus such as that of Garay et al. <em>[36]</em> do not capture miners with external incentives such as profiting from lottery manipulation.</p>

    <p class="text-gray-300">Another approach for constructing beacons derives randomness from a collection of participants, such as all participants in a lottery <em>[38, 48]</em>. The simplest paradigm is “commit-and-reveal” paradigm where <span class="math">n</span> parties submit commitments to random values <span class="math">r_{1},...,r_{n}</span> in an initial phase and subsequently reveal their commitments, at which point the beacon output is computed as <span class="math">r=\\bigoplus_{i}r_{i}</span>. The problem with this approach is that a malicious adversary (possibly controlling a number of parties) might manipulate the outcome by refusing to open its commitment after seeing the other revealed values, forcing a protocol restart. Lenstra and Wesolowski proposed a solution to this problem (called “Unicorn”<em>[48]</em>) using a delay function: instead of using commitments, each participant posts their <span class="math">r_{i}</span> directly and <span class="math">seed=H(r_{1},\\ldots,r_{n})</span> is passed through a VDF. The output of <span class="math">\\mathsf{Eval}</span> is then posted and can be efficiently verified. The final beacon outcome is the hash of the output of <span class="math">\\mathsf{Eval}</span>. With a sufficiently long delay parameter (longer than the time period during which values may be submitted), even the last party to publish their <span class="math">r_{i}</span> cannot predict what its impact will be on the final beacon outcome. The beacon is unpredictable even</p>

    <p class="text-gray-300">to an adversary who controls <span class="math">n-1</span> of the participating parties. It has linear communication complexity and uses only two rounds. This stands in contrast to coin-tossing beacons which use verifiable secret sharing and are at best resistant to an adversary who controls a minority of the nodes <em>[1, 69, 23]</em>. These beacons also use super-linear communication and require multiple rounds of interaction. In the two party setting there are tight bounds that an <span class="math">r</span>-round coin-flipping protocol can be biased with <span class="math">O(1/r)</span> bias <em>[57]</em>. The “Unicorn” construction circumvents these bounds by assuming semi-synchronous communication, i.e. there exists a bound to how long an adversary can delay messages.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Resource-efficient blockchains.</h4>

    <p class="text-gray-300">Amid growing concerns over the long-term sustainability of proof-of-work blockchains like Bitcoin, which consume a large (and growing) amount of energy, there has been concerted effort to develop resource-efficient blockchains in which miners invest an upfront capital expenditure which can then be re-used for mining. Examples include proof-of-stake <em>[46, 55, 45, 28, 13]</em>, proof-of-space <em>[61]</em>, and proof-of-storage <em>[56, 2]</em>. However, resource-efficient mining suffers from <em>costless simulation</em> attacks. Intuitively, since mining is not computationally expensive, miners can attempt to produce many separate forks easily.</p>

    <p class="text-gray-300">One method to counter simulation attacks is to use a randomness beacon to select new leaders at regular intervals, with the probability of becoming a leader biased by the quality of proofs (i.e. amount of stake, space, etc) submitted by miners. A number of existing blockchains already construct beacons from tools such as <em>verifiable random functions</em>, <em>verifiable secret sharing</em>, or <em>deterministic threshold signatures</em> <em>[45, 28, 23, 4]</em>. However, the security of these beacons requires a non-colluding honest majority; with a VDF-based lottery as described above this can potentially be improved to participation of any honest party.</p>

    <p class="text-gray-300">A second approach, proposed by Cohen <em>[26]</em>, is to combine proofs-of-resources with incremental VDFs and use the product of resources proved and delay induced as a measure of blockchain quality. This requires a proof-of-resource which is costly to initialize (such as certain types of proof-of-space). This is important such that the resources are committed to the blockchain and cannot be used for other purposes. A miner controlling <span class="math">N</span> units of total resources can initialize a proof <span class="math">\\pi</span> demonstrating control over these <span class="math">N</span> units. Further assume that the proof is non-malleable and that in each epoch there is a common random challenge <span class="math">c</span>, e.g. a block found in the previous epoch, and let <span class="math">H</span> be a random oracle available to everyone. In each epoch, the miner finds <span class="math">\\tau=\\min_{1\\leq i\\leq N}\\{H(c,\\pi,i)\\}</span> and computes a VDF on input <span class="math">c</span> with a delay proportional to <span class="math">\\tau</span>. The first miner to successfully compute the VDF can broadcast their block successfully. Note that this process mimics the random delay to find a Bitcoin block (weighted by the amount of resources controlled by each miner), but without each miner running a large parallel computation.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Proof of replication.</h4>

    <p class="text-gray-300">Another promising application of VDFs is <em>proofs of replication</em>, a special type of proof of data storage which requires the prover to dedicate unique storage even if the data is available from another source. For instance, this could be used to prove that a number of replicas of the same file are being stored. Classic <em>proofs of retrievability</em> <em>[43]</em> are typically defined in a private-key client/server setting, where the server proves to the client that it can retrieve the client’s (private) data, which the client verifies using a private key.</p>

    <p class="text-gray-300">Instead, the goal of a <em>proof of replication</em> <em>[6, 2, 3]</em> is to verify that a given server is storing a <em>unique replica</em> of some data which may be publicly available. An equivalent concept to proof-of-replication was first introduced by Sergio Demian Lerner in 2014 under the name “proof of</p>

    <p class="text-gray-300">unique blockchain storage” <em>[49]</em>. Lerner proposed using time-asymmetric encodings to apply a slow transformation to a file using a unique identifier as a key. During a challenge-response protocol, a verifier periodically challenges the server for randomly sampled blocks of the uniquely encoded file. The basic idea is that the server should fail to respond quickly enough if it has deleted the encoding. Verifying that the received blocks of the encoding are correct is fast in comparison due to the time-asymmetry of the encoding. Lerner proposed using a Pohlig-Hellman cipher, using the permutation <span class="math">x^{3}</span> on <span class="math">\\mathbb{Z}_{p}^{<em>}</span>, which has asymmetry roughly equivalent to modular square roots. Armknecht et al. </em>[6]* proposed a similar protocol in the private verifier model using RSA time-lock puzzles. The verification of this protocol may be outsourced, but is still less transparent as it fundamentally requires a designated private-key verifier per file.</p>

    <p class="text-gray-300">Efficiently decodable VDFs can be used to improve Lerner’s publicly verifiable and transparent construction by using the VDF as the time-asymmetric encoding. As VDFs achieve an exponential gap between parallel-time computation and verification they would improve the challenge-response protocol by reducing the frequency of polling. The frequency needs to be set such that the server cannot delete and recompute the encoding between challenges. Technically, the security property we need the VDF to satisfy is that a stateless adversary running in parallel time less than <span class="math">T</span> cannot predict any component of the output on any given input, which is stronger than the plain sequentiality requirement of a VDF. A formal way to capture this requirement is to model the VDF as an <em>ideal delay cipher</em> <em>[35]</em>, namely as an oracle that implements an ideal cipher and takes <span class="math">T</span> sequential steps to respond to queries on any point.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We review briefly the construction, now based on VDFs. The replicator is given an input file, a unique replicator identifier <span class="math">id</span>, and public parameters <span class="math">\\mathbf{pp}\\xleftarrow{\\text{\\tiny N}}\\mathbf{Setup}(\\lambda,t)</span>, and computes a <em>slow</em> encoding of the file using the VDF cipher. This takes sequential time <span class="math">T</span> to derive. In more detail, the encoding is computed by breaking the file into <span class="math">b</span>-bit blocks <span class="math">B_{1},\\ldots,B_{n}</span> and storing <span class="math">y_{1},...,y_{n}</span> where $(y_{i},\\bot)=\\mathsf{Eval}(\\mathbf{pp},B_{i}\\oplus H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i))<span class="math"> where </span>H<span class="math"> is a collision-resistant hash function </span>H:\\{0,1\\}^{*}\\to\\{0,1\\}^{b}<span class="math">. To verify that the replicator has stored this unique copy, a verifier can query an encoded block </span>y_{i}<span class="math"> (which must be returned in significantly less time than it is feasible to compute </span>\\mathsf{Eval}<span class="math">). The verifier can quickly decode this response and check it for correctness, proving that the replicator has stored (or can quickly retrieve from somewhere) an encoding of this block which is unique to the identifier </span>id<span class="math">. If the unique block encoding </span>y_{i}<span class="math"> has not been stored, the VDF ensures that it cannot be re-computed quickly enough to fool the verifier, even given access to </span>B_{i}<span class="math"> . The verifier can query for as many blocks as desired; each query has a </span>1-\\rho<span class="math"> chance of exposing a cheating prover that is only storing a fraction </span>\\rho$ of the encoded blocks.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More generally, if the inputs <span class="math">B_{1},..,B_{n}</span> are fixed and known to the verifier then this construction is also a <em>proof of space</em> <em>[32]</em>. A proof of space is an interactive protocol in which the prover can provide a compact proof that it is persistently using <span class="math">\\Omega(N)</span> space. This construction is in fact a <em>tight</em> PoS, meaning that it requires an honest prover to use <span class="math">N</span> space and for any <span class="math">\\epsilon&amp;gt;0</span> it can be tuned so that an adversary who uses <span class="math">(1-\\epsilon)N</span> space will be caught with overwhelming probability. A proof-of-replication is a special kind of proof of space that is quite delicate to formally define and has been developed further in followup work <em>[35]</em>.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Computational timestamping.</h4>

    <p class="text-gray-300">All known proof-of-stake systems are vulnerable to long-range forks due to post-hoc stakeholder misbehavior <em>[46, 55, 45, 13]</em>. In proof-of-stake protocols, at any given time the current stakeholders in the system are given voting power proportionate to their stake in the system. An honest majority (or supermajority) is assumed because the current stakeholders are incentivized to keep the system running correctly. However, after stakeholders</p>

    <p class="text-gray-300">have divested they no longer have this incentive. Once the majority (eq. supermajority) of stakeholders from a point in time in the past are divested, they can collude (or sell their key material to an attacker) in order to create a long alternate history of the system up until the present. Current protocols typically assume this is prevented through an external timestamping mechanism which can prove to users that the genuine history of the system is much older.</p>

    <p class="text-gray-300">Incremental VDFs can provide computational evidence that a given version of the state’s system is older (and therefore genuine) by proving that a long-running VDF computation has been performed on the genuine history just after the point of divergence with the fraudulent history. This potentially enables detecting long-range forks without relying on external timestamping mechanisms.</p>

    <p class="text-gray-300">We note however that this application of VDFs is fragile as it requires precise bounds on the attacker’s computation speed. For other applications (such as randomness beacons) it may be acceptable if the adversary can speed up VDF evaluation by a factor of 10 using faster hardware; a higher <span class="math">t</span> can be chosen until even the adversary cannot manipulate the beacon even with a hardware speedup. For computational timestamping, a 10-fold speedup would be a serious problem: once the fraudulent history is more than one-tenth as old as the genuine history, an attacker can fool participants into believing the fraudulent history is actually <em>older</em> than the genuine one.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 Model and definitions</h2>

    <p class="text-gray-300">We now define VDFs more precisely. In what follows we say that an algorithm runs in <em>parallel time</em> <span class="math">t</span> with <span class="math">p</span> processors if it can be implemented on a PRAM machine with <span class="math">p</span> parallel processors running in time <span class="math">t</span>. We say <em>total time</em> (eq. sequential time) to refer to the time needed for computation on a single processor.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A VDF <span class="math">V=(\\text{Setup},\\text{Eval},\\text{Verify})</span> is a triple of algorithms as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Setup}(\\lambda,t)\\rightarrow\\mathbf{pp}=(\\text{ek},\\text{vk})</span> is a randomized algorithm that takes a security parameter <span class="math">\\lambda</span> and a desired puzzle difficulty <span class="math">t</span> and produces public parameters <span class="math">\\mathbf{pp}</span> that consists of an evaluation key <span class="math">\\text{ek}</span> and a verification key <span class="math">\\text{vk}</span>. We require Setup to be polynomial-time in <span class="math">\\lambda</span>. By convention, the public parameters specify an input space <span class="math">\\mathcal{X}</span> and an output space <span class="math">\\mathcal{Y}</span>. We assume that <span class="math">\\mathcal{X}</span> is efficiently sampleable. Setup might need secret randomness, leading to a scheme requiring a trusted setup. For meaningful security, the puzzle difficulty <span class="math">t</span> is restricted to be sub-exponentially sized in <span class="math">\\lambda</span>.</li>

      <li><span class="math">\\text{Eval}(\\text{ek},x)\\rightarrow(y,\\pi)</span> takes an input <span class="math">x\\in\\mathcal{X}</span> and produces an output <span class="math">y\\in\\mathcal{Y}</span> and a (possibly empty) proof <span class="math">\\pi</span>. <span class="math">\\text{Eval}</span> may use random bits to generate the proof <span class="math">\\pi</span> but not to compute <span class="math">y</span>. For all <span class="math">\\mathbf{pp}</span> generated by <span class="math">\\text{Setup}(\\lambda,t)</span> and all <span class="math">x\\in\\mathcal{X}</span>, algorithm <span class="math">\\text{Eval}(\\text{ek},x)</span> must run in parallel time <span class="math">t</span> with <span class="math">\\text{poly}(\\log(t),\\lambda)</span> processors.</li>

      <li><span class="math">\\text{Verify}(\\text{vk},x,y,\\pi)\\rightarrow\\{\\text{Yes},\\text{No}\\}</span> is a deterministic algorithm takes an input, output and proof and outputs Yes or No. Algorithm <span class="math">\\text{Verify}</span> must run in total time polynomial in <span class="math">\\log t</span> and <span class="math">\\lambda</span>. Notice that <span class="math">\\text{Verify}</span> is much faster than <span class="math">\\text{Eval}</span>.</li>

    </ul>

    <p class="text-gray-300">Additionally <span class="math">V</span> must satisfy Correctness (Definition 2), Soundness (Definition 3), and Sequentiality (Definition 4).</p>

    <p class="text-gray-300">Correctness and Soundness Every output of Eval must be accepted by Verify. We guarantee that the output <span class="math">y</span> for an input <span class="math">x</span> is unique because Eval evaluates a deterministic function on <span class="math">\\mathcal{X}</span>. Note that we do not require the proof <span class="math">\\pi</span> to be unique, but we do require that the proof is sound and that a verifier cannot be convinced that some different output is the correct VDF outcome. More formally,</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2 (Correctness).</h6>

    <p class="text-gray-300">A VDF <span class="math">V</span> is correct if for all <span class="math">\\lambda</span>, <span class="math">t</span>, parameters <span class="math">({\\sf ek},{\\sf vk})</span> <span class="math">\\epsilon^{\\underline{\\sf u}}</span> <span class="math">{\\sf Setup}(\\lambda,t)</span>, and all <span class="math">x\\in\\mathcal{X}</span>, if <span class="math">(y,\\pi)</span> <span class="math">\\epsilon^{\\underline{\\sf u}}</span> <span class="math">{\\sf Eval}({\\sf ek},x)</span> then <span class="math">{\\sf Verify}({\\sf vk},x,y,\\pi)=</span> Yes.</p>

    <p class="text-gray-300">We also require that for no input <span class="math">x</span> can an adversary get a verifier to accept an incorrect VDF output.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 3 (Soundness).</h6>

    <p class="text-gray-300">A VDF is sound if for all algorithms <span class="math">\\mathcal{A}</span> that run in time <span class="math">O</span> <span class="math">({\\sf poly}(t,\\lambda))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ P_{T}\\left[\\begin{array}[]{c}{\\sf Verify}({\\sf vk},x,y,\\pi)=$ Yes \\[ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\begin{array}[]{c}{\\bf pp}=({\\sf ek},{\\sf vk})\\ \\epsilon^{\\underline{\\sf u}}\\ {\\sf Setup}(\\lambda,t)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(x,y,\\pi)\\ \\epsilon^{\\underline{\\sf u}}\\ \\mathcal{A}(\\lambda,{\\bf pp},t)\\end{array}\\right.\\left. \\right]\\leq{\\sf negl}(\\lambda) \\]</p>

    <p class="text-gray-300">Size restriction on <span class="math">t</span> Asymptotically <span class="math">t</span> must be subexponential in <span class="math">\\lambda</span>. The reason for this is that the adversary needs to be able to run in time at least <span class="math">t</span> (Eval requires this), and if <span class="math">t</span> is exponential in <span class="math">\\lambda</span> then the adversary might be able to break the underlying computational security assumptions that underpin both the soundness as well as the sequentiality of the VDF, which we will formalize next.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parallelism in Eval The practical implication of allowing more parallelism in Eval is that “honest” evaluators may be required to have this much parallelism in order to complete the challenge in time <span class="math">t</span>. The sequentiality security argument will compare an adversary’s advantage to this optimal implementation of Eval. Constructions of VDFs that do not require any parallelism to evaluate Eval in the optimal number of sequential steps are obviously superior. However, it is unlikely that such constructions exist (without trusted hardware). Even computing an iterated hash function or modular exponentiation (used for time-lock puzzles) could be computed faster by parallelizing the hash function or modular arithmetic. In fact, for an decodable VDF it is necessary that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;{\\sf poly}(t)<span class="math">, and thus the challenge inputs to Eval have size </span>{\\sf poly}\\log(t)<span class="math">. Therefore, in our definition we allow algorithm Eval up to </span>{\\sf poly}\\log(t)$ parallelism.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.1 VDF Security</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We call the security property needed for a VDF scheme <span class="math">\\sigma</span>-sequentiality. Essentially, we require that no adversary is able to compute an output for Eval on a random challenge in parallel time <span class="math">\\sigma(t)&lt;t</span>, <span class="math">\\sigma</span>="" <span class="math">\\mathcal{y}</span>.="" <span class="math">o(t)</span>="" $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">="" 0.="" 2}<span class="math">=&quot;&quot; a=&quot;&quot; an=&quot;&quot; and=&quot;&quot; are=&quot;&quot; amount=&quot;&quot; an=&quot;&quot; andwe=&quot;&quot; are=&quot;&quot; be=&quot;&quot; bound=&quot;&quot; by=&quot;&quot; can=&quot;&quot; compute=&quot;&quot; critical=&quot;&quot; defined=&quot;&quot; describe=&quot;&quot; decodable=&quot;&quot; definition.=&quot;&quot; different=&quot;&quot; does=&quot;&quot; each=&quot;&quot; efficient=&quot;&quot; efficiently=&quot;&quot; even=&quot;&quot; evenwith=&quot;&quot; fainting=&quot;&quot; for=&quot;&quot; from=&quot;&quot; has=&quot;&quot; have=&quot;&quot; if=&quot;&quot; in=&quot;&quot; incorporate=&quot;&quot; into=&quot;&quot; is=&quot;&quot; large=&quot;&quot; large)=&quot;&quot; may=&quot;&quot; means=&quot;&quot; needs=&quot;&quot; note=&quot;&quot; of=&quot;&quot; on=&quot;&quot; out=&quot;&quot; output=&quot;&quot; poly}(t)</span>,="" parallel="" parallelism,="" parallelism.="" parallelism.="" possible="" processors="" processes="" qn="" qn}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">="" random="" recall="" requires="" same="" security="" should="" simulatenously="" simulatenously.="" that="" the="" this="" to="" trying="" vdf="" vdf,="" we="" with="" “many”="">{\\sf poly}(t)<span class="math">, and cannot achieve </span>\\sigma<span class="math">-sequentiality against an adversary with greater than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ processors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define the following sequentiality game applied to an adversary <span class="math">\\mathcal{A}\\coloneqq(\\mathcal{A}_{0},\\mathcal{A}_{1})</span>:</p>

    <p class="text-gray-300"></t$,></p>

    <p class="text-gray-300"><span class="math">\\mathbf{pp} \\xleftarrow{\\mathrm{n}} \\mathbf{Setup}(\\lambda, t)</span>  // choose a random <span class="math">\\mathbf{pp}</span> <span class="math">L \\xleftarrow{\\mathrm{n}} \\mathcal{A}_0(\\lambda, \\mathbf{pp}, t)</span>  // adversary preprocesses <span class="math">\\mathbf{pp}</span> <span class="math">x \\xleftarrow{\\mathrm{n}} \\mathcal{X}</span>  // choose a random input <span class="math">x</span> <span class="math">y_A \\xleftarrow{\\mathrm{n}} \\mathcal{A}_1(L, \\mathbf{pp}, x)</span>  // adversary computes an output <span class="math">y_A</span></p>

    <p class="text-gray-300">We say that <span class="math">(\\mathcal{A}_0, \\mathcal{A}_1)</span> wins the game if <span class="math">y_A = y</span> where <span class="math">(y, \\pi) \\coloneqq \\operatorname{Eval}(\\mathbf{pp}, x)</span>.</p>

    <p class="text-gray-300"><strong>Definition 4 (Sequentiality).</strong> For functions <span class="math">\\sigma(t)</span> and <span class="math">p(t)</span>, the VDF is <span class="math">(p, \\sigma)</span>-sequential if no pair of randomized algorithms <span class="math">\\mathcal{A}_0</span>, which runs in total time <span class="math">O(\\text{poly}(t, \\lambda))</span>, and <span class="math">\\mathcal{A}_1</span>, which runs in parallel time <span class="math">\\sigma(t)</span> on at most <span class="math">p(t)</span> processors, can win the sequentiality game with probability greater than <span class="math">\\text{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">The definition captures the fact that even after <span class="math">\\mathcal{A}_0</span> computes on the parameters <span class="math">\\mathbf{pp}</span> for a (polynomially) long time, the adversary <span class="math">\\mathcal{A}_1</span> cannot compute an output from the input <span class="math">x</span> in time <span class="math">\\sigma(t)</span> on <span class="math">p(t)</span> parallel processors. If a VDF is <span class="math">(p, \\sigma)</span>-sequential for any polynomial <span class="math">p</span>, then we simply say the VDF is <span class="math">\\sigma</span>-sequential. In the sequentiality game we do not require the online attack algorithm <span class="math">\\mathcal{A}_1</span> to output a proof <span class="math">\\pi</span>. The reason is that in many of our applications, for example in a lottery, the adversary can profit simply by learning the output early, even without being able to prove correctness to a third party.</p>

    <p class="text-gray-300"><strong>Values of <span class="math">\\sigma(t)</span></strong> Clearly any candidate construction trivially satisfies <span class="math">\\sigma(t)</span>-sequentiality for some <span class="math">\\sigma</span> (e.g. <span class="math">\\sigma(t) = 0</span>). Thus, security becomes more meaningful as <span class="math">\\sigma(t) \\to t</span>. No construction can obtain <span class="math">\\sigma(t) = t</span> because by design Eval runs in parallel time <span class="math">t</span>. Ideal security is achieved when <span class="math">\\sigma(t) = t - 1</span>. This ideal security is in general unrealistic unless, for example, time steps are measured in rounds of queries to an ideal oracle (e.g. random oracle). In practice, if the oracle is instantiated with a concrete program (e.g. a hash function), then differences in hardware/implementation would in general yield small differences in the response time for each query. An almost-perfect VDF would achieve <span class="math">\\sigma(t) = t - o(t)</span> sequentiality. Even <span class="math">\\sigma(t) = t - \\epsilon t</span> sequentiality for small <span class="math">\\epsilon</span> is sufficient for most applications. Security degrades as <span class="math">\\epsilon \\to 1</span>. The naive VDF construction combining a hash chain with succinct verifiable computation (i.e. producing a SNARG proof of correctness following the hash chain computation) cannot beat <span class="math">\\epsilon = 1/2</span>, unless it uses at least <span class="math">\\omega(t)</span> parallelism to generate the proof in sublinear time (exceeding the allowable parallelism for VDFs, though see a relaxation to "weak" VDFs below).</p>

    <p class="text-gray-300"><strong>Unpredictability and min-entropy</strong> Definition 4 captures an unpredictability property for the output of the VDF, similar to a one-way function. However, similar to random oracles, the output of the VDF on a given input is never indistinguishable from random. It is possible that no depth <span class="math">\\sigma(t)</span> circuit can distinguish the output on a randomly sampled challenge from random, but only if the VDF proof is not given to the distinguisher. Efficiently decodable VDFs cannot achieve this stronger property.</p>

    <p class="text-gray-300">For the application to random beacons (e.g. for lotteries), it is only necessary that on a random challenge the output is unpredictable and also has sufficient min-entropy¹ conditioned</p>

    <p class="text-gray-300">¹A randomness extractor can then be applied to the output to map it to a uniform distribution.</p>

    <p class="text-gray-300">on previous outputs for different challenges. In fact, <span class="math">\\sigma</span>-sequentiality already implies that min-entropy is <span class="math">\\Omega(\\log\\lambda)</span>. Otherwise some fixed output <span class="math">y</span> occurs with probability <span class="math">1/\\mathsf{poly}(\\lambda)</span> for randomly sampled input <span class="math">x</span>; the adversary <span class="math">\\mathcal{A}_{0}</span> can computes <span class="math">O(\\mathsf{poly}(\\lambda))</span> samples of this distribution in the preprocessing to find such a <span class="math">y^{\\prime}</span> with high probability, and then <span class="math">\\mathcal{A}_{1}</span> could output <span class="math">y^{\\prime}</span> as its guess. Moreover, if <span class="math">\\sigma</span>-sequentiality is achieved for <span class="math">t</span> superpolynomial (sub-exponential) in <span class="math">\\lambda</span>, then the preprocessing adversary is allowed <span class="math">2^{o(\\lambda)}</span> samples, implying some <span class="math">o(\\lambda)</span> min-entropy of the output must be preserved. By itself, <span class="math">\\sigma</span>-sequentiality does not imply <span class="math">\\Omega(\\lambda)</span> min-entropy. Stronger min-entropy preservation can be demonstrated in other ways given additional properties of the VDF, e.g. if it is a permutation or collision-resistant. Under suitable complexity theoretic assumptions (namely the existence of subexponential <span class="math">2^{o(n)}</span> circuit lower bounds) a combination of Nisan-Wigderson type PRGs and extractors can also be used to generate <span class="math">\\mathsf{poly}(\\lambda)</span> pseudorandom bits from a string with min-entropy <span class="math">\\log\\lambda</span>.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Random “Delay” Oracle</h4>

    <p class="text-gray-300">In the random oracle model, <em>any</em> unpredictable string (regardless of its min-entropy) can be used to extract an unpredictable <span class="math">\\lambda</span>-bit uniform random string. For the beacon application, a random oracle <span class="math">H</span> would simply be applied to the output of the VDF to generate the beacon value. We can even model this construction as an ideal object itself, a <em>Random Delay Oracle</em>, which implements a random function <span class="math">H^{\\prime}</span> and on any given input <span class="math">x</span> it waits for <span class="math">\\sigma(t)</span> steps before returning the output <span class="math">H^{\\prime}(x)</span>. Demonstrating a construction from a <span class="math">\\sigma</span>-sequential VDF and random oracle <span class="math">H</span> that is provably <em>indifferentiable</em> <em>[53]</em> from a Random Delay Oracle is an interesting research question.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Remark:</h4>

    <p class="text-gray-300">Removing any single property makes VDF construction easy. We note the existence of well-known outputs if any property is removed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{Verify}</span> is not required to be fast, then simply iterating a one-way function <span class="math">t</span> times yields a trivial solution. Verification is done by re-computing the output, or a set of <span class="math">\\ell</span> intermediate points can be supplied as a proof which can be verified in parallel time <span class="math">\\Theta(t/\\ell)</span> using <span class="math">\\ell</span> processors, with total verification time remaining <span class="math">\\Theta(t)</span>.</li>

      <li>If we do not require <em>uniqueness</em>, then the construction of Mahmoody et al. <em>[52]</em> using hash functions and depth-robust graphs suffices. This construction was later improved by Cohen and Pietrzak <em>[19]</em>. This construction fails to ensure uniqueness because once an output <span class="math">y</span> is computed it can be easily mangled into many other valid outputs <span class="math">y^{\\prime}\\neq y</span>, as discussed in Section 9.1.</li>

      <li>If we do not require <em><span class="math">\\sigma</span>-sequentiality</em>, many solutions are possible, such as finding the discrete log of a challenge group element with respect to a fixed generator. Note that computing an elliptic curve discrete log can be done in parallel time <span class="math">o(t)</span> using a parallel version of the Pollard rho algorithm <em>[71]</em>.</li>

    </ul>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Weaker VDFs</h4>

    <p class="text-gray-300">For certain applications it is still interesting to consider a VDF that requires even more than <span class="math">\\mathrm{polylog}(t)</span> parallelism in <span class="math">\\mathsf{Eval}</span> to compute the output in parallel time <span class="math">t</span>. For</p>

    <p class="text-gray-300">example, in the randomness beacon application only one party is required to compute the VDF and all other parties can simply verify the output. It would not be unreasonable to give this one party a significant amount of parallel computing power and optimized hardware. This would yield a secure beacon as long as no adversary could compute the outputs of Eval in faster that <span class="math">t</span> steps given even more parallelism than this party. Moreover, for small values of <span class="math">t</span> it may be practical for anyone to use up to <span class="math">O(t)</span> parallelism (or more). With this in mind, we define a weaker variant of a VDF that allows additional parallelism in Eval.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">We call a system <span class="math">V=(\\text{Setup},\\text{Eval},\\text{Verify})</span> a weak-VDF if it satisfies Definition 1 with the exception that Eval is allowed up to <span class="math">poly(t,\\lambda)</span> parallelism.</p>

    <p class="text-gray-300">Note that <span class="math">(p,\\sigma)</span>-sequentiality can only be meaningful for a weak-VDF if Eval is allowed strictly less that <span class="math">p(t)</span> parallelism, otherwise the honest computation of Eval would require more parallelism than even the adversary is allowed.</p>

    <h2 id="sec-20" class="text-2xl font-bold">4 VDFs from Incrementally Verifiable Computation</h2>

    <p class="text-gray-300">VDFs are by definition sequential functions. We therefore require the existence of sequential functions in order to construct any VDF. We begin by defining a sequential function.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 6 (<span class="math">(t,\\epsilon)</span>-Sequential function).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">f:X\\to Y</span> is a <span class="math">(t,\\epsilon)</span>-sequential function if for $\\lambda=O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$, if the following conditions hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists an algorithm that for all <span class="math">x\\in X</span> evaluates <span class="math">f</span> in parallel time <span class="math">t</span> using <span class="math">\\text{poly}(\\log(t),\\lambda)</span> processors.</li>

      <li>For all <span class="math">\\mathcal{A}</span> that run in parallel time strictly less than <span class="math">(1-\\epsilon)\\cdot t</span> with <span class="math">\\text{poly}(t,\\lambda)</span> processors:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Pr\\Big{[}y_{A}=f(x)\\ \\ \\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\ y_{A}\\ \\xleftarrow{\\text{a}}\\ \\mathcal{A}(\\lambda,x),\\ x\\ \\xleftarrow{\\text{a}}\\ X\\Big{]}\\leq\\text{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">In addition we consider iterated sequential functions that are defined as the iteration of some round function. The key property of an iterated sequential function is that iteration of the round function is the fastest way to evaluate the function.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 7 (Iterated Sequential Function).</h6>

    <p class="text-gray-300">Let <span class="math">g:X\\to X</span> be a <span class="math">(t,\\epsilon)</span>-sequential function. A function <span class="math">f:\\mathbb{N}\\times X\\to X</span> defined as <span class="math">f(k,x)=g^{(k)}(x)=\\underbrace{g\\circ g\\circ\\cdots\\circ g}_{k\\text{ times}}</span> is said to be an <em>iterated sequential function</em> (with round function <span class="math">g</span>) if for all <span class="math">k=2^{o(\\lambda)}</span> the function <span class="math">h:X\\to X</span> defined by <span class="math">h(x)=f(k,x)</span> is <span class="math">(k\\cdot t,\\epsilon)</span>-sequential as in Definition 6.</p>

    <p class="text-gray-300">It is widely believed that the function obtained from iterating a hash function like SHA-256 is an iterated sequential function with <span class="math">t=O(\\lambda)</span> and <span class="math">\\epsilon</span> negligible in <span class="math">\\lambda</span>. The sequentiality of such functions can be proved in the random oracle model <em>[47, 52]</em>. We will use the functions <span class="math">g</span> explicitly and require it to have an explicit arithmetic circuit representation. Modeling <span class="math">g</span> as an oracle, therefore, does not suffice for our construction.</p>

    <p class="text-gray-300">Another candidate for an iterated sequential function is exponentiation in a finite group of unknown order, where the round function is squaring in the group. The fastest known way to compute this is by repeated squaring which is an iterative sequential computation.</p>

    <p class="text-gray-300">Based on these candidates, we can make the following assumption about the existence of iterated sequential functions:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Assumption 1.</strong> For all <span class="math">\\lambda \\in \\mathbb{N}</span> there exist (1) an <span class="math">\\epsilon, t</span> with <span class="math">t = \\text{poly}(\\lambda)</span>, and (2) a function <span class="math">g_{\\lambda}: X \\to X</span>, where $\\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lambda<span class="math"> and </span>X<span class="math"> can be sampled in time </span>\\text{poly}(\\lambda)<span class="math">. This </span>g_{\\lambda}<span class="math"> satisfies: (i) </span>g_{\\lambda}<span class="math"> is a </span>(t, \\epsilon)<span class="math">-sequential function, and (ii) the function </span>f: \\mathbb{N} \\times X \\to X<span class="math"> with round function </span>g_{\\lambda}$ is an iterated sequential function.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An iterated sequential function by itself gives us many of the properties needed for a secure VDF. It is sequential by definition and the trivial algorithm (iteratively computing <span class="math">g</span>) uses only <span class="math">\\text{poly}(\\lambda)</span> parallelism. Such a function by itself, however, does not suffice to construct a VDF. The fastest generic verification algorithm simply recomputes the function. While this ensures soundness it does not satisfy the efficient verification requirement of a VDF. The verifier of a VDF needs to be exponentially faster than the prover.</p>

    <p class="text-gray-300"><strong>SNARGs and SNARKs</strong> A natural idea to improve the verification time is to use verifiable computation. In verifiable computation the prover computes a succinct argument (SNARG) that a computation was done correctly. The argument can be efficiently verified using resources that are independent of the size of the computation. A SNARG is a weaker form of a succinct non-interactive argument of knowledge (SNARK) [37] for membership in an NP language <span class="math">\\mathcal{L}</span> with relation <span class="math">R</span> (Definition 8). The additional requirement of a SNARK is that for any algorithm that outputs a valid proof of membership of an instance <span class="math">x \\in \\mathcal{L}</span> there is also an extractor that "watches" the algorithm and outputs a witness <span class="math">w</span> such that <span class="math">(x, w) \\in R</span>. In the special case of providing a succinct proof that a (polynomial size) computation <span class="math">F</span> was done correctly, i.e. <span class="math">y</span> is the output of <span class="math">F</span> on <span class="math">x</span>, the NP witness is empty and the NP relation simply consists of pairs <span class="math">((x, y), \\bot)</span> such that <span class="math">F(x) = y</span>.</p>

    <p class="text-gray-300"><strong>Definition 8 (Verifiable Computation / SNARK).</strong> Let <span class="math">\\mathcal{L}</span> denote an NP language with relation <span class="math">R_{\\mathcal{L}}</span>, where <span class="math">x \\in \\mathcal{L}</span> iff <span class="math">\\exists w R_{\\mathcal{L}}(x, w) = 1</span>. A SNARK system for <span class="math">R_{\\mathcal{L}}</span> is a triple of polynomial time algorithms (SNKGen, SNKProve, SNKVerify) that satisfy the following properties:</p>

    <p class="text-gray-300"><strong>Completeness:</strong></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\forall (x, w) \\in R_{\\mathcal{L}}: Pr\\left[ \\text{SNKVerify}(\\mathsf{vk}, x, \\pi) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf{vk}, \\mathsf{ek}) \\xleftarrow{\\text{n}} \\text{SNKGen}(1^{\\lambda}) \\\\ \\pi \\xleftarrow{\\text{n}} \\text{SNKProve}(\\mathsf{ek}, x, w) \\end{array} \\right. \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Succinctness:</strong> The length of a proof and complexity of SNKVerify is bounded by $\\text{poly}\\big(\\lambda, \\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\big)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Knowledge extraction:</strong> [sub-exponential adversary knowledge extractor] For all adversaries <span class="math">\\mathcal{A}</span> running in time <span class="math">2^{o(\\lambda)}</span> there exists an extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> running in time <span class="math">2^{o(\\lambda)}</span> such that for all auxiliary inputs <span class="math">z</span> of size <span class="math">\\text{poly}(\\lambda)</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr\\left[ \\begin{array}{c} \\text{SNKVerify}(\\mathsf{vk}, x, \\pi) = 1 \\\\ R_{\\mathcal{L}}(x, w) \\neq 1 \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf{vk}, \\mathsf{ek}) \\xleftarrow{\\text{n}} \\text{SNKGen}(1^{\\lambda}) \\\\ (x, \\pi) \\xleftarrow{\\text{n}} \\mathcal{A}(z, \\mathsf{ek}) \\\\ w \\xleftarrow{\\text{n}} \\mathcal{E}_{\\mathcal{A}}(z, \\mathsf{ek}) \\end{array} \\right. \\right] \\leq \\text{negl}(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Impractical VDF from SNARGs.</h4>

    <p class="text-gray-300">Consider the following construction for a VDF from a <span class="math">(t,\\epsilon)</span>-sequential function <span class="math">f</span>. Let <span class="math">\\mathbf{pp}=(\\mathsf{ek},\\mathsf{vk})\\xleftarrow{\\textup{{n}}}\\mathsf{SNKGen}(\\lambda)</span> be the public parameter of a SNARG scheme for proving membership in the language of pairs <span class="math">(x,y)</span> such that <span class="math">f(x)=y</span>. On input <span class="math">x\\in X</span> the <span class="math">\\mathsf{Eval}</span> computes <span class="math">y=f(x)</span> and a succinct argument <span class="math">\\pi\\xleftarrow{\\textup{{n}}}\\mathsf{SNKProve}(\\mathsf{ek},(x,y),\\bot)</span>. The prover outputs <span class="math">((x,y),\\pi)</span>. On input <span class="math">((x,y),\\pi)</span> the verifier checks <span class="math">y=f(x)</span> by checking <span class="math">\\mathsf{SNKVerify}(\\mathsf{vk},(x,y),\\pi)=1</span>.</p>

    <p class="text-gray-300">This construction clearly satisfies fast verification. All known SNARK constructions are quasi-linear in the length of the underlying computation <span class="math">f</span> <em>[11]</em>. Assuming the cost for computing a SNARG for a computation of length <span class="math">t</span> is <span class="math">k\\cdot t\\log(t)</span> then the SNARG VDF construction achieves <span class="math">\\sigma(t)=\\frac{(1-\\epsilon)\\cdot t}{(k+1)\\cdot\\log(t)}</span> sequentiality. This does not even achieve the notion of <span class="math">(1-\\epsilon^{\\prime})t</span> sequentiality for any adversary. This means that the adversary can compute the output of the VDF in a small fraction of the time that it takes the honest prover to convince an honest verifier. If, however, <span class="math">\\mathsf{SNKProve}</span> is sufficiently parallelizable then it is possible to partially close the gap between the sequentiality of <span class="math">f</span> and the sequentiality of the VDF. The <span class="math">\\mathsf{Eval}</span> simply executes <span class="math">\\mathsf{SNKProve}</span> on a parallel machine to reduce the relative total running time compared to the computation of <span class="math">f</span>. SNARK constructions can run in parallel time <span class="math">\\mathrm{polylog}(t)</span> on <span class="math">O(t\\cdot\\mathrm{polylog}(t))</span> processors. This shows that a VDF can theoretically be built from verifiable computation.</p>

    <p class="text-gray-300">The construction has, however, two significant downsides: First, in practice computing a SNARG is more than 100,000 times more expensive than evaluating the underlying computation <em>[72]</em>. This means that to achieve meaningful sequentiality, the SNARG computation would require massive parallelism using hundreds thousands of cores. The required parallelism additionally depends on the time <span class="math">t</span>. Second, the construction does not achieve <span class="math">(1-\\epsilon)t</span> sequentiality, which is the optimal sequentiality that can be achieved by a construction which involves the evaluation of <span class="math">f</span>.</p>

    <p class="text-gray-300">We therefore, now give a VDF construction with required parallelism independent of <span class="math">t</span> and <span class="math">\\sigma</span>-sequentiality asymptotically close to <span class="math">(1-\\epsilon)t</span> where <span class="math">\\epsilon</span> will be defined by the underlying sequential computation.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Incremental Verifiable Computation (IVC).</h4>

    <p class="text-gray-300">IVC provides a direction for circumventing the problem mentioned above. IVC was first studied by Valiant <em>[70]</em> in the context of computationally sound proofs <em>[54]</em>. Bitansky et al. <em>[14]</em> generalized IVC to distributed computations and to other proof systems such as SNARKs. IVC requires that the underlying computation can be expressed as an iterative sequence of evaluations of the same Turing machine. An iterated sequential function satisfies this requirement.</p>

    <p class="text-gray-300">The basic idea of IVC is that at every incremental step of the computation, a prover can produce a proof that a certain state is indeed the current state of the computation. This proof is updated after every step of the computation to produce a new proof. Importantly, the complexity of each proof in proof size and verification cost is bounded by <span class="math">\\mathsf{poly}(\\lambda)</span> for any sub-exponential length computation. Additionally the complexity of updating the proof is independent of the total length of the computation.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Towards VDFs from IVC.</h4>

    <p class="text-gray-300">Consider a VDF construction that runs a sequential computation and after each step uses IVC to update a proof that both this step and the previous proof were</p>

    <p class="text-gray-300">correct. Unfortunately, for IVC that requires knowledge extraction we cannot prove soundness of this construction for <span class="math">t&gt;O(\\lambda)</span>. The problem is that a recursive extraction yields an extractor that is exponential in the recursion depth <em>[14]</em>.</p>

    <p class="text-gray-300">The trick around this is to construct a binary tree of proofs of limited depth <em>[70, 14]</em>. The leaf proofs verify computation steps whereas the internal node proofs prove that their children are valid proofs. The verifier only needs to check the root proof against the statement that all computation steps and internal proofs are correct.</p>

    <p class="text-gray-300">We focus on the special case that the function <span class="math">f</span> is an iterated sequential function. The regularity of the iterated function ensures that the statement that the verifier checks is succinct. We impose a strict requirement on our <span class="math">IVC</span> scheme to output both the output of <span class="math">f</span> and a final proof with only an additive constant number of additional steps over evaluating <span class="math">f</span> alone.</p>

    <p class="text-gray-300">We define <em>tight</em> IVC for an iterated sequential functions, which captures the required primitive needed for our theoretical VDF. We require that incremental proving is almost overhead free in that the prover can output the proof almost immediately after the computation has finished. The definition is a special case of Valiant’s definition <em>[70]</em>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 9 (Tight IVC for iterated sequential functions).</h6>

    <p class="text-gray-300">Let <span class="math">f_{\\lambda}:\\mathbb{N}\\times\\mathcal{X}\\rightarrow\\mathcal{X}</span> be an iterated sequential function with <span class="math">(t,\\epsilon)</span>-sequential round function <span class="math">g_{\\lambda}</span> iterated <span class="math">k=2^{o(\\lambda)}</span> times. An IVC system for <span class="math">f_{\\lambda}</span> is a triple of polynomial time algorithms <span class="math">(\\text{IVCGen},\\text{IVCProve},\\text{IVCVerify})</span> that satisfy the following properties:</p>

    <p class="text-gray-300">Completeness:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\forall x\\in\\mathcal{X}:\\ Pr\\left[\\text{IVCVerify}(\\mathsf{vk},x,y,k,\\pi)=\\text{Yes}\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(\\mathsf{vk},ek)\\ \\epsilon^{\\underline{n}}\\ \\text{IVCGen}(\\lambda,f)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(y,\\pi)\\ \\epsilon^{\\underline{n}}\\ \\text{IVCProve}(ek,k,x)\\end{array}\\right.\\right]=1 \\]</p>

    <p class="text-gray-300">Succinctness: The length of a proof and the complexity of SNKVerify is bounded by <span class="math">\\text{poly}\\big{(}\\lambda,\\log(k\\cdot t)\\big{)}</span>.</p>

    <p class="text-gray-300">Soundness:[sub-exponential soundness] For all algorithms <span class="math">\\mathcal{A}</span> running in time <span class="math">2^{o(\\lambda)}</span>:</p>

    <p class="text-gray-300">\\[ Pr\\left[\\begin{array}[]{c}\\text{IVCVerify}(\\mathsf{vk},x,y,k,\\pi)=\\text{Yes}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(k,x)\\neq y\\end{array}\\right.\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(\\mathsf{vk},ek)\\ \\epsilon^{\\underline{n}}\\ \\text{IVCGen}(\\lambda,f)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(x,y,k,\\pi)\\ \\epsilon^{\\underline{n}}\\ \\mathcal{A}(\\lambda,\\mathsf{vk},ek)\\end{array}\\right.\\right]\\leq\\text{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">Tight Incremental Proving: There exists a <span class="math">k^{\\prime}</span> such that for all <span class="math">k\\geq k^{\\prime}</span> and <span class="math">k=2^{o(\\lambda)}</span>, <span class="math">\\text{IVCProve}(ek,k,x)</span> runs in parallel time <span class="math">k\\cdot t+O(1)</span> using <span class="math">\\text{poly}(\\lambda,t)</span>-processors.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Existence of tight IVC.</h4>

    <p class="text-gray-300">Bitansky et al. <em>[14]</em> showed that any SNARK system such as <em>[62]</em> can be used to construct IVC. Under strong knowledge of exponent assumptions there exists an IVC scheme using a SNARK tree of depth less than <span class="math">\\lambda</span> (Theorem 1 of <em>[14]</em>). In every computation step the prover updates the proof by computing <span class="math">\\lambda</span> new SNARKs each of complexity <span class="math">\\text{poly}(\\lambda)</span>, each verifying another SNARK and one of complexity <span class="math">t</span> which verifies one evaluation of <span class="math">g_{\\lambda}</span>, the round function of <span class="math">f_{\\lambda}</span>. Ben Sasson et al. <em>[10]</em> discuss the parallel complexity of the Pinocchio SNARK <em>[62]</em> and show that for a circuit of size <span class="math">m</span> there exists a parallel prover using <span class="math">O(m\\cdot\\log(m))</span> processors that computes a SNARK in time <span class="math">O(\\log(m))</span>. Therefore, using these SNARKs we can construct an IVC proof system <span class="math">(\\text{IVCGen},\\text{IVCProve},\\text{IVCVerify})</span> where, for sufficiently large <span class="math">t</span>, <span class="math">\\text{IVCProve}</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{O}(\\lambda + t)</span> parallelism to produce each incremental IVC output in time <span class="math">\\lambda \\cdot \\log(t + \\lambda) \\leq t</span>. If <span class="math">t</span> is not sufficiently large, i.e. <span class="math">t &amp;gt; \\lambda \\cdot \\log(t + \\lambda)</span> then we can construct an IVC proof system that creates proofs for <span class="math">k&#x27;</span> evaluations of <span class="math">g_{\\lambda}</span>. The IVC proof system chooses <span class="math">k&#x27;</span> such that <span class="math">t \\leq \\lambda \\cdot \\log(k&#x27; \\cdot t + \\lambda)</span>. Given this the total parallel runtime of IVCProve on <span class="math">k</span> iterations of an <span class="math">(t, \\epsilon)</span>-sequential function would thus be <span class="math">k \\cdot t + \\lambda \\cdot \\log(k&#x27; \\cdot t + \\lambda) = k \\cdot t + O(1)</span>. This shows that we can construct tight IVC from existing SNARK constructions.</p>

    <p class="text-gray-300"><strong>VDF<span class="math">_{\\text{IVC}}</span> construction.</strong> We now construct a VDF from a tight IVC. By Assumption 1 we are given a family <span class="math">\\{f_{\\lambda}\\}</span>, where each <span class="math">f_{\\lambda}:\\mathbb{N}\\times X_{\\lambda}\\to X_{\\lambda}</span> is defined by <span class="math">f_{\\lambda}(k,x) = g_{\\lambda}^{(k)}(x)</span>. Here <span class="math">g_{\\lambda}</span> is a <span class="math">(s,\\epsilon)</span>-sequential function on an efficiently sampleable domain of size <span class="math">O(2^{\\lambda})</span>.</p>

    <p class="text-gray-300">Given a tight IVC proof system (IVCGen, IVCProve, IVCVerify) for <span class="math">f</span> we can construct a VDF that satisfies <span class="math">\\sigma(t)</span>-sequentiality for <span class="math">\\sigma(t) = (1 - \\epsilon) \\cdot t - O(1)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup<span class="math">(\\lambda, t)</span>: Let <span class="math">g_{\\lambda}</span> be a <span class="math">(t, \\epsilon)</span>-sequential function and <span class="math">f_{\\lambda}</span> the corresponding iterated sequential function as described in Assumption 1. Run <span class="math">(\\mathsf{ek}, \\mathsf{vk}) \\xleftarrow{\\mathsf{n}} \\mathsf{IVCGen}(\\lambda, f_{\\lambda})</span>. Set <span class="math">k</span> to be the largest integer such that IVCProve<span class="math">(\\mathsf{ek}, k, x)</span> takes time less than <span class="math">t</span>. Output <span class="math">\\mathbf{pp} = \\big((\\mathsf{ek}, k), (\\mathsf{vk})\\big)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Eval<span class="math">((\\mathsf{ek}, k), x)</span>: Run <span class="math">(y, \\pi) \\xleftarrow{\\mathsf{n}} \\mathsf{IVCProve}(\\mathsf{ek}, k, x)</span>, output <span class="math">(y, \\pi)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify<span class="math">(\\mathsf{vk}, x, (y, \\pi))</span>: Run and output IVCVerify<span class="math">(\\mathsf{vk}, x, y, k, \\pi)</span>.</li>

    </ul>

    <p class="text-gray-300">Note that <span class="math">t</span> is fixed in the public parameters. It is, however, also possible to give <span class="math">t</span> directly to Eval. VDF<span class="math">_{\\text{IVC}}</span> is, therefore, incremental.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> <span class="math">VDF_{IVC}</span> satisfies soundness (Definition 3)</p>

    <p class="text-gray-300"><strong>Proof.</strong> Assume that an <span class="math">\\mathsf{poly}(t, \\lambda)</span> algorithm <span class="math">\\mathcal{A}</span> outputs (with non-negligible probability in <span class="math">\\lambda</span>) a tuple <span class="math">(x, y, \\pi)</span> on input <span class="math">\\lambda</span>, <span class="math">t</span>, and <span class="math">\\mathbf{pp} \\xleftarrow{\\mathsf{n}} \\mathsf{Setup}(\\lambda, t)</span> such that <span class="math">\\mathsf{Verify}(\\mathbf{pp}, x, y, \\pi) = \\mathsf{Yes}</span> but <span class="math">f_{\\lambda}(k, x) \\neq y</span>. We can then construct an adversary <span class="math">\\mathcal{A}&#x27;</span> that violates IVC soundness. Given <span class="math">(\\mathsf{vk}, \\mathsf{ek}) \\xleftarrow{\\mathsf{n}} \\mathsf{IVCGen}(\\lambda, f_{\\lambda})</span> the adversary <span class="math">\\mathcal{A}&#x27;</span> runs <span class="math">\\mathcal{A}</span> on <span class="math">\\lambda, t</span>, and <span class="math">(\\mathsf{vk}, \\mathsf{ek})</span>. Since <span class="math">(\\mathsf{vk}, \\mathsf{ek})</span> is sampled from the same distribution as <span class="math">\\mathbf{pp} \\xleftarrow{\\mathsf{n}} \\mathsf{Setup}(\\lambda, t)</span> it follows that, with non-negligible probability in <span class="math">\\lambda</span>, <span class="math">\\mathcal{A}&#x27;</span> outputs <span class="math">(x, y, \\pi)</span> such that <span class="math">\\mathsf{Verify}(\\mathbf{pp}, x, y, \\pi) = \\mathsf{IVCVerify}(\\mathsf{vk}, x, y, k, \\pi) = \\mathsf{Yes}</span> and <span class="math">f_{\\lambda}(k, x) \\neq y</span>, which directly violates the soundness of IVC.</p>

    <p class="text-gray-300"><strong>Theorem 1 (VDF<span class="math">_{\\text{IVC}}</span>).</strong> <span class="math">VDF_{IVC}</span> is a VDF scheme with <span class="math">\\sigma(t) = (1 - \\epsilon)t - O(1)</span> sequentiality.</p>

    <p class="text-gray-300"><strong>Proof.</strong> First note that the VDF<span class="math">_{\\text{IVC}}</span> algorithms satisfy the definition of the VDF algorithms. IVCProve runs in time <span class="math">\\left(\\frac{t}{s} - 1\\right) \\cdot s + s = t</span> using <span class="math">\\mathsf{poly}(\\lambda, s) = \\mathsf{poly}(\\lambda)</span> processors. IVCVerify runs in total time <span class="math">\\mathsf{poly}(\\lambda, \\log(t))</span>. Correctness follows from the correctness of the IVC scheme. Soundness was proved in Lemma 1. The scheme is <span class="math">\\sigma(t)</span>-sequential because IVCProve runs in time <span class="math">k \\cdot s + O(1) &amp;lt; t</span>. If any algorithm that uses <span class="math">\\mathsf{poly}(t, \\lambda)</span> processors can produce the VDF output in time less than <span class="math">(1 - \\epsilon)t - O(1)</span> he can directly break the <span class="math">t, \\epsilon</span>-sequentiality of <span class="math">f_{\\lambda}</span>. Since <span class="math">s</span> is independent of <span class="math">t</span> we can conclude that VDF<span class="math">_{\\text{IVC}}</span> has <span class="math">\\sigma(t) = (1 - \\epsilon)t - O(1)</span> sequentiality.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">We next present a VDF construction from verifiable computation. This construction is simpler than the one in the previous section in that it does not require tight incremental verifiable computation. Verifiable computation is sufficient.</p>

    <p class="text-gray-300">The core idea is that we can run a sequential computation and, in parallel, compute multiple SNARGs that prove the correctness of different parts of the computation. The protocol we propose computes <span class="math">\\log N</span> SNARGs in parallel for segments of geometrically decreasing size.</p>

    <p class="text-gray-300">Let <span class="math">f</span> be an iterated sequential function obtained from iterating a round function <span class="math">k</span> times. As a warmup, assume that constructing a SNARG for an evaluation of <span class="math">f</span> takes exactly the same time as computing the function <span class="math">f</span>. The VDF prover first iterates the round function <span class="math">k/2</span> times, to complete half the computation of <span class="math">f</span> on a given input. It then iterates the round function <span class="math">k/2</span> more times, and <em>in parallel</em>, computes a SNARG for the first <span class="math">k/2</span> iterations. This way the SNARG computation and the function evaluation will complete at the same time. The prover then continues by constructing a SNARG for the next <span class="math">k/4</span> iterations of the round function, then the next <span class="math">k/8</span> iterations, and so on. All these SNARGs are constructed in parallel to computing the function. The final iteration requires no SNARG as the verifier can check it directly. All these SNARG computations are done in parallel. Using <span class="math">\\log_{2}(k)</span> processors, the evaluation of <span class="math">f</span> and all the SNARG computations will complete at exactly the same time. Hence, constructing the SNARGs adds no time to the evaluation of <span class="math">f</span>, but requires <span class="math">\\log_{2}k</span> parallelism at the evaluator.</p>

    <p class="text-gray-300">We will now describe a more general construction that allows for arbitrary gaps between the SNARG prover time and the function evaluation time. The construction uses an iterated sequential function and a SNARG proof system. However, an analogous construction can be built from any underlying VDF scheme. The construction can amplify the VDF scheme to a “tight” VDF scheme in which the prover outputs the proof concurrently with the output. The amplification has a logarithmic overhead in proof size, verifier time, and prover parallelism. This is described in more detail in concurrent work by Döttling, Garg, Malavolta and Vasudevan<em>[33]</em>.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">VDF_{VC} construction</h4>

    <p class="text-gray-300">As in the VDF_{IVC} we use a family of sequential iterated functions <span class="math">\\{f_{\\lambda}\\}</span> such that each <span class="math">f_{\\lambda}:\\mathbb{Z}\\times X_{\\lambda}\\to X_{\\lambda}</span> is defined as <span class="math">f_{\\lambda}(k,x)=g_{\\lambda}^{(k)}(x)</span> for an <span class="math">(s,\\epsilon)</span> sequential function <span class="math">g_{\\lambda}</span>. We are also given a SNARK systems (SNKGen,SNKProve,SNKVerify) for the family of relations <span class="math">R_{f_{\\lambda},k}:=\\{\\big{(}(x,y),\\bot\\big{)}:f_{\\lambda}(k,x)=y\\}</span>. The SNARK only needs to satisfy the soundness definition and not the knowledge extraction so a SNARG suffices. We slightly modify the system compared to Definition 8 by letting <span class="math">\\mathsf{SNKGen}_{f_{\\lambda},k}</span> be the setup for a SNARG corresponding to <span class="math">R_{f_{\\lambda},k}</span>. We also let <span class="math">\\alpha\\in\\mathbb{R}^{+}</span> denote how much slower the SNARG prover runs compared to the evaluation of <span class="math">f_{\\lambda}</span>. That is, if <span class="math">f_{\\lambda}(k,x)</span> can be evaluated in time <span class="math">t</span> then SNKProve runs in time at most <span class="math">\\alpha\\cdot t</span> on the same machine. Note that we implicitly require that SNKProve is a linear algorithm but the construction can easily modified for quasilinear algorithms. VDF_{VC} works by running the computation of <span class="math">f_{\\lambda}</span> until <span class="math">t\\cdot(\\frac{1}{\\alpha+1})</span> time has passed. That is, compute <span class="math">\\frac{k}{\\alpha+1}</span> iterations of <span class="math">g_{\\lambda}</span> on the input. Then the prover continues the computation and in parallel computes a SNARG for that first <span class="math">\\frac{1}{\\alpha+1}</span> fraction of the computation. The same process is repeated using geometrically decreasing parts of the computation. Namely, the prover produce a SNARG for the next <span class="math">\\frac{1}{\\alpha+1}</span> fraction of the remaining computation and in parallel continue the computation of <span class="math">f_{\\lambda}</span> as well as all other executing SNARG computations. After <span class="math">\\ell</span> steps a <span class="math">\\left(\\frac{\\alpha}{\\alpha+1}\\right)^{\\ell}</span> fraction of the computation remains and <span class="math">\\ell</span> SNARGs are being computed in parallel. Thus after <span class="math">n=\\log_{\\frac{\\alpha}{\\alpha+1}}(k)</span> steps only 1 invocation of <span class="math">g</span> remains. The verifier can check this invocation directly. For simplicity we assume that <span class="math">k</span> is a power of <span class="math">\\frac{\\alpha}{\\alpha+1}</span>. Note that all SNARG computations will finish at the same time, precisely when the computation of <span class="math">f_{\\lambda}</span> is completed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(\\lambda,t):</span> Let <span class="math">g_{\\lambda}</span> be a <span class="math">(s,\\epsilon)</span> sequential function. Let <span class="math">k=\\frac{t}{s}</span>. For <span class="math">i=1</span> to <span class="math">n=\\log_{\\frac{\\alpha}{\\alpha+1}}(k)</span> the</li>

    </ul>

    <p class="text-gray-300">setup generates <span class="math">(\\mathsf{vk}_i,\\mathsf{ek}_i)\\gets \\mathsf{SNKGen}_{f_\\lambda ,k_i}(\\lambda)</span>, where <span class="math">k_{i}</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">k _ {i} = \\left((\\frac {\\alpha}{\\alpha + 1}) ^ {i - 1} - (\\frac {\\alpha}{\\alpha + 1}) ^ {i}\\right) \\cdot \\frac {t}{s}.</span></div>

    <p class="text-gray-300">Output <span class="math">\\mathbf{pp} = \\left\\{\\left((\\mathsf{ek}_i,k_i),\\mathsf{vk}_i\\right)\\right\\}_{i = 1,\\dots ,n}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Eval(pp, <span class="math">x</span>): Let <span class="math">x_0 = x</span>. For <span class="math">i = 1</span> to <span class="math">n</span> compute <span class="math">x_i = g^{(k_i)}(x_{i-1})</span> and in parallel start the computation of <span class="math">\\pi_i = \\mathsf{SNKProve}(\\mathsf{ek}_i, (x_{i-1}, x_i), \\bot)</span>. Finally let <span class="math">y = g(x_n)</span>. Output <span class="math">\\{y, (x_1, \\pi_1, \\dots, x_n, \\pi_n)\\}</span></li>

      <li>Verify <span class="math">(\\{\\mathsf{vk}_1, \\ldots, \\mathsf{vk}_n\\}, x, (y, (x_1, \\pi_1, \\ldots, x_n, \\pi_n)))</span>: Verify the proofs by running SNKVerify <span class="math">(\\mathsf{vk}_i, (x_{i-1}, x_i), \\pi_i)</span>. If any verification fails, reject. Else output 'yes' if <span class="math">g(x_n) = y</span> and reject otherwise.</li>

    </ul>

    <p class="text-gray-300"><strong>Lemma 2 (soundness).</strong> Given a sound SNARG system as defined by Definition 8, <span class="math">VDF_{VC}</span> satisfies soundness (Definition 3)</p>

    <p class="text-gray-300"><strong>Proof.</strong> Assume that an <span class="math">\\mathsf{poly}(t,\\lambda)</span> algorithm <span class="math">\\mathcal{A}</span> outputs (with non-negligible probability in <span class="math">\\lambda</span>) a tuple <span class="math">(x,y,\\pi)</span> on input <span class="math">\\lambda</span>, <span class="math">t</span>, and <span class="math">\\mathbf{pp}</span> such that <span class="math">\\mathsf{Verify}(\\mathbf{pp},x,y,\\pi) = \\mathrm{Yes}</span> but <span class="math">f_{\\lambda}(k,x)\\neq y</span>. We can then construct an adversary <span class="math">\\mathcal{A}&#x27;</span> that violates the SNARG soundness. Note that the proof contains the intermediate computation steps <span class="math">x_0,\\ldots ,x_n</span> with <span class="math">x_0 = x</span>. The verification guarantees that <span class="math">g(x_{n}) = y</span>. However, if <span class="math">f(x)\\neq y</span> then there must be an <span class="math">i\\in [0,n - 1]</span> such that <span class="math">g^{(k_i)}(x_i)\\neq x_{i + 1}</span> for <span class="math">k_{i} = \\frac{\\alpha^{i - 1}}{(\\alpha + 1)^{i}}\\cdot \\frac{t}{s}</span>. Note that this directly contradicts the soundness of the underlying SNARG. <span class="math">\\mathcal{A}&#x27;</span> therefore simply runs <span class="math">\\mathcal{A}</span> using honestly generated <span class="math">(\\mathsf{vk}_i,\\mathsf{ek}_i)</span> for all <span class="math">n</span> SNARG proof systems. <span class="math">\\mathcal{A}&#x27;</span> is able to break at the soundness of at least one of the proof systems simply using the output of <span class="math">\\mathcal{A}</span>, i.e. <span class="math">\\pi_{i}</span> and <span class="math">x_{i},x_{i + 1}</span>. Since by assumption <span class="math">\\mathcal{A}&#x27;</span> can only succeed with negligible probability <span class="math">\\mathcal{A}&#x27;</span> also only succeeds with negligible probability. This shows that <span class="math">\\mathrm{VDF_{VC}}</span> is sound.</p>

    <p class="text-gray-300"><strong>Theorem 2 (VDFVC is a VDF).</strong> Given a <span class="math">(s,\\epsilon)</span> sequential function <span class="math">f_{\\lambda}</span> and a SNARG proof system with perfect completeness, <span class="math">VDF_{VC}</span> is a VDF scheme with <span class="math">\\sigma(t) = (1 - \\epsilon)t</span> sequentiality.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The algorithms of <span class="math">\\mathrm{VDF_{VC}}</span> satisfy the definition of the VDF algorithms. Treating <span class="math">\\alpha</span> and <span class="math">s</span> as constants, the verifier checks only a logarithmic (in <span class="math">t</span>) number of succinct proofs and one evaluation of <span class="math">g_{\\lambda}</span>. The prover requires <span class="math">\\log(t)</span> parallelism for the computation of the proofs. Correctness is immediate from the construction and the completeness of the SNARG. Soundness was proved in Lemma 2. It remains to prove sequentiality. The Eval algorithm runs exactly in the time that it takes to compute <span class="math">f_{\\lambda}\\left(\\frac{t}{s},x\\right)</span> as all the proof computation runs in parallel and by assumption completes the same moment the computation of <span class="math">f_{\\lambda}</span> completes. Any adversary that can output the VDF value in time less than <span class="math">(1 - \\epsilon)t</span> will therefore directly break the <span class="math">(t,\\epsilon)</span> sequentiality of <span class="math">f_{\\lambda}</span>.</p>

    <h2 id="sec-30" class="text-2xl font-bold">5.1 Discussion</h2>

    <p class="text-gray-300">We note that both the proof size, the verifier time, and the required parallelism of <span class="math">\\mathrm{VDF_{VC}}</span> are highly dependent on <span class="math">\\alpha</span>. If <span class="math">\\alpha &amp;gt; 1</span> the number of iterations, i.e. the number of proofs and required parallelism is close to <span class="math">\\log(t / s) \\cdot \\alpha</span>, i.e. linear in <span class="math">\\alpha</span>. If <span class="math">\\alpha \\approx 100,000</span>, as is the case for modern SNARGs on arbitrary computations, then this may become prohibitively large. In Section 6 and Section 7 we show how we can boost the construction to significantly reduce the prover</p>

    <p class="text-gray-300">overhead. In particular we construct specific instantiations of <span class="math">g</span> and <span class="math">f</span> that a) are more efficient to verify than to evaluate, allowing a SNARG proof to assert a simpler statement and b) that are specifically optimized for modern SNARG systems. With these optimizations and certain parameter selection it is feasible to bring <span class="math">\\alpha</span> closer to 1 or possibly even below 1.</p>

    <p class="text-gray-300">We also note that the same technique of computing several proofs in parallel can be used to boost subsequent VDF constructions such as the RSA based constructions by Pietrzak <em>[64]</em> and Wesolowski <em>[73]</em>. These VDFs, in particular Wesolowski’s construction, have a significant prover overhead. This leads to a suboptimal <span class="math">\\sigma(t)</span>-sequentiality. Using the same technique of computing proofs in parallel we can create “tight” VDFs with only a logarithmic overhead in terms of required parallelism, proof size, and verifier overhead.</p>

    <h2 id="sec-31" class="text-2xl font-bold">6 A weak VDF based on injective rational maps</h2>

    <p class="text-gray-300">In this section we explore a framework for constructing a weak VDF satisfying <span class="math">(t^{2},o(t))</span>-sequentiality based on the existence of degree <span class="math">t</span> injective rational maps that cannot be inverted faster than computing polynomial greatest common denominators (GCDs) of degree <span class="math">t</span> polynomials, which we conjecture cannot be solved in parallel time less than <span class="math">t-o(t)</span> on fewer than <span class="math">t^{2}</span> parallel processors. Our candidate map will be a permutation polynomial over a finite field of degree <span class="math">t</span>. The construction built from it is a weak VDF because the Eval will require <span class="math">O(t)</span> parallelism to run in parallel time <span class="math">t</span>.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">6.1 Injective rational maps</h3>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Rational maps on algebraic sets.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An <em>algebraic rational function</em> on finite vector spaces is a function <span class="math">F:\\mathbb{F}_{q}^{n}\\to\\mathbb{F}_{q}^{m}</span> such that <span class="math">F=(f_{1},\\ldots,f_{m})</span> where each <span class="math">f_{i}:\\mathbb{F}_{q}^{n}\\to\\mathbb{F}_{q}</span> is a rational function in <span class="math">\\mathbb{F}_{q}(X_{1},\\ldots,X_{n})</span>, for <span class="math">i=1,\\ldots,m</span>. An <em>algebraic set</em> <span class="math">\\mathcal{Y}\\subseteq\\mathbb{F}_{q}^{n}</span> is the complete set of points on which some set <span class="math">S</span> of polynomials simultaneously vanish, i.e. $\\mathcal{Y}=\\{x\\in\\mathbb{F}_{q}^{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x)=0\\text{ for all }f\\in S\\}<span class="math"> for some </span>S\\subset\\mathbb{F}_{q}[X_{1},\\ldots,X_{n}]<span class="math">. An <em>injective rational map</em> of algebraic sets </span>\\mathcal{Y}\\subseteq\\mathbb{F}_{q}^{n}<span class="math"> to </span>\\mathcal{X}\\subseteq\\mathbb{F}_{q}^{m}<span class="math"> is an algebraic rational function </span>F<span class="math"> that is injective on </span>\\mathcal{Y}<span class="math">, i.e. if </span>\\mathcal{X}\\coloneqq F(\\mathcal{Y})<span class="math">, then for every </span>\\bar{x}\\in\\mathcal{X}<span class="math"> there exists a unique </span>\\bar{y}\\in\\mathcal{Y}<span class="math"> such that </span>F(\\bar{y})=\\bar{x}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Inverting rational maps.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the problem of inverting an injective rational map <span class="math">F=(f_{1},....,f_{m})</span> on algebraic sets <span class="math">\\mathcal{Y}\\subseteq\\mathbb{F}_{q}^{n}</span> to <span class="math">\\mathcal{X}\\subseteq\\mathbb{F}_{q}^{m}</span>. Here <span class="math">\\mathcal{Y}\\subseteq\\mathbb{F}_{q}^{n}</span> is the set of vanishing points of some set of polynomials <span class="math">S</span>. For <span class="math">x\\in\\mathbb{F}_{q}^{m}</span>, a solution to <span class="math">F(\\bar{y})=\\bar{x}</span> is a point <span class="math">\\bar{y}\\in\\mathbb{F}_{q}^{n}</span> such that all polynomials in <span class="math">S</span> vanish at <span class="math">\\bar{y}</span> and <span class="math">f_{i}(\\bar{y})=x_{i}</span> for <span class="math">i=1,...,m</span>. Furthermore, each <span class="math">f_{i}(\\bar{y})=g(\\bar{y})/h(\\bar{y})=x_{i}</span> for some polynomials <span class="math">g,h</span>, and hence yields a polynomial constraint <span class="math">z_{i}(\\bar{y})\\coloneqq g(\\bar{y})-x_{i}h(\\bar{y})=0</span>. In total we are looking for solutions to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+m<span class="math"> polynomial constraints on </span>\\bar{y}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We illustrate two special cases of injective rational maps that can be inverted by a univariate polynomial GCD computation. In general, inverting injective rational maps on <span class="math">\\mathbb{F}_{q}^{d}</span> for constant <span class="math">d</span> can be reduced to a univariate polynomial GCD computation using resultants.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Rational functions on finite fields.</em> Consider any injective rational function <span class="math">F(X)=g(X)/h(X)</span>, for univariate polynomials <span class="math">h,g</span>, on a finite field <span class="math">\\mathbb{F}_{q}</span>. A finite field is actually a special case of an algebraic set over itself; it is the set of roots of the polynomial <span class="math">X^{q}-X</span>. Inverting <span class="math">F</span> on a</li>

    </ul>

    <p class="text-gray-300">point <span class="math">c \\in \\mathbb{F}_q</span> can be done by calculating <span class="math">GCD(X^q - X, g(X) - c \\cdot h(X))</span>, which outputs <span class="math">X - s</span> for the unique <span class="math">s</span> such that <span class="math">F(s) = c</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rational maps on elliptic curves. An elliptic curve <span class="math">E(\\mathbb{F}_q)</span> over <span class="math">\\mathbb{F}_q</span> is a 2-dimensional algebraic set of vanishing points in <span class="math">\\mathbb{F}_q^2</span> of a bivariate polynomial <span class="math">E(y, x) = y^2 - x^3 - ax - b</span>. Inverting an injective rational function <span class="math">F</span> on a point in the image of <span class="math">F(E(\\mathbb{F}_q))</span> involves computing the GCD of three bivariate polynomials: <span class="math">E, z_1, z_2</span>, where <span class="math">z_1</span> and <span class="math">z_2</span> come from the two rational function components of <span class="math">F</span>. The resultant <span class="math">R = Res_y(z_1, z_2)</span> is a univariate polynomial in <span class="math">x</span> of degree <span class="math">deg(z_1) \\cdot deg(z_2)</span> such that <span class="math">R(x) = 0</span> iff there exists <span class="math">y</span> such that <span class="math">(x, y)</span> is a root of both <span class="math">z_1</span> and <span class="math">z_2</span>. Finally, taking the resultant again <span class="math">R&#x27; = Res_y(R, E)</span> yields a univariate polynomial such that any root <span class="math">x</span> of <span class="math">R&#x27;</span> has a corresponding coordinate <span class="math">y</span> such that <span class="math">(x, y)</span> is a point on <span class="math">E</span> and satisfies constraints <span class="math">z_1</span> and <span class="math">z_2</span>. Solving for the unique root of <span class="math">R&#x27;</span> reduces to a Euclidean GCD computation as above. Then given <span class="math">x</span>, there are two possible points <span class="math">(x, y) \\in E</span>, so we can try them both and output the unique point that satisfies all the constraints.</li>

    </ul>

    <p class="text-gray-300">Euclidean algorithm for univariate polynomial GCD. Univariate polynomials over a finite field form a Euclidean domain, and therefore the GCD of two polynomials can be found using the Euclidean algorithm. For two polynomials <span class="math">f</span> and <span class="math">g</span> such that <span class="math">deg(f) &amp;gt; deg(g) = d</span>, one first reduces <span class="math">f \\mod g</span> and then computes <span class="math">GCD(f, g) = GCD(f \\mod g, g)</span>. In the example <span class="math">f = X^q - X</span>, the first step of reducing <span class="math">X^q \\mod g</span> requires <span class="math">O(\\log(q))</span> multiplications of degree <span class="math">O(deg(g))</span> polynomials. Starting with <span class="math">X</span>, we run the sequence of repeated squaring operations to get <span class="math">X^q</span>, reducing the intermediate results mod <span class="math">g</span> after each squaring operation. Then running the Euclidean algorithm to find <span class="math">GCD(f \\mod g, g)</span> involves <span class="math">O(d)</span> sequential steps where in each step we subtract two <span class="math">O(d)</span> degree polynomials. On a sequential machine this computation takes <span class="math">O(d^2)</span> time, but on <span class="math">O(d)</span> parallel processors this can be computed in parallel time <span class="math">O(d)</span>.</p>

    <p class="text-gray-300">NC algorithm for univariate polynomial GCD. There is an algorithm for computing the GCD of two univariate polynomials of degree <span class="math">d</span> in <span class="math">O(\\log^2 (d))</span> parallel time, but requires <span class="math">O(d^{3.8})</span> parallel processors. This algorithm runs <span class="math">d</span> parallel determinant calculations on submatrices of the Sylvester matrix associated with the two polynomials, each of size <span class="math">O(d^{2})</span>. Each determinant can be computed in parallel time <span class="math">O(\\log^2 (d))</span> on <span class="math">M(d)\\in O(d^{2.85})</span> parallel processors [25]. The parallel advantage of this method over the euclidean GCD method kicks in after <span class="math">O(d^{2.85})</span> processors. For any <span class="math">c\\leq d / \\log^2 (d)</span>, it is possible to compute the GCD in <span class="math">O(d / c)</span> steps on <span class="math">c\\log^2 (d)M(d)</span> processors.</p>

    <p class="text-gray-300">Sequentiality of univariate polynomial GCD. The GCD can be calculated in parallel time <span class="math">d</span> using <span class="math">d</span> parallel processors via the Euclidean algorithm. The NC algorithm only beats this bound on strictly greater than <span class="math">d^{2.85}</span> processors, but a hybrid of the two methods can gain an <span class="math">o(d)</span> speedup on only <span class="math">d^2</span> processors. Specifically, we can run the Euclidean method for <span class="math">d - d^{2/3}</span> steps until we are left with two polynomials of degree <span class="math">d^{2/3}</span>, then we can run the NC algorithm using <span class="math">\\log^3(d)M(d^{2/3}) &amp;lt; (d^{2/3})^3 = d^2</span> processors to compute the GCD of these polynomials in <span class="math">O(d^{2/3} / \\log(d))</span> steps, for a total of <span class="math">d - \\epsilon d^{2/3}</span> steps. This improvement can be tightened further, but generally results in <span class="math">d - o(d)</span> steps as long as <span class="math">M(d) \\in \\omega(d^2)</span>.</p>

    <p class="text-gray-300">We pose the following assumption on the parallel complexity of calculating polynomials GCDs on fewer than <span class="math">O(d^{2})</span> processors. This assumption would be broken if there is an NC</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">algorithm for computing the determinant of a <span class="math">n \\times n</span> matrix on <span class="math">o(n^2)</span> processors, but this would require a significant advance in mathematics on a problem that has been studied for a long time.</p>

    <p class="text-gray-300"><strong>Assumption 2.</strong> There is no general algorithm for computing the GCD of two univariate polynomials of degree <span class="math">d</span> over a finite field <span class="math">\\mathbb{F}_q</span> (where <span class="math">q &amp;gt; d^3</span>) in less than parallel time <span class="math">d - o(d)</span> on <span class="math">O(d^2)</span> parallel processors.</p>

    <p class="text-gray-300">On the other hand, evaluating a polynomial of degree <span class="math">d</span> can be logarithmic in its degree, provided the polynomial can be expressed as a small arithmetic circuit, e.g. <span class="math">(ax + b)^d</span> can be computed with <span class="math">O(\\log(d))</span> field operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Abstract weak VDF from an injective rational map.</strong> Let <span class="math">F: \\mathbb{F}_q^n \\to \\mathbb{F}_q^m</span> be a rational function that is an injective map from <span class="math">\\mathcal{Y}</span> to <span class="math">\\mathcal{X} \\coloneqq F(\\mathcal{Y})</span>. We further require that <span class="math">\\mathcal{X}</span> is efficiently sampleable and that <span class="math">F</span> can be evaluated efficiently for all <span class="math">\\bar{y} \\in \\mathcal{Y}</span>. When using <span class="math">F</span> in a VDF we will require that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\lambda t^3<span class="math"> to prevent brute force attacks, where </span>t<span class="math"> and </span>\\lambda$ are given as input to the Setup algorithm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will need a family <span class="math">\\mathcal{F} \\coloneqq \\{(q, F, \\mathcal{X}, \\mathcal{Y})\\}_{\\lambda, t}</span> parameterized by <span class="math">\\lambda</span> and <span class="math">t</span>. Given such a family we can construct a weak VDF as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup <span class="math">(\\lambda, t)</span>: choose a <span class="math">(q, F, \\mathcal{X}, \\mathcal{Y}) \\in \\mathcal{F}</span> specified by <span class="math">\\lambda</span> and <span class="math">t</span>, and output <span class="math">\\mathbf{pp} := ((q, F), (q, F))</span>.</li>

      <li>Eval <span class="math">((q,F),\\bar{x})</span>: for an output <span class="math">\\bar{x} \\in \\mathcal{X} \\subseteq \\mathbb{F}_q^m</span> compute <span class="math">\\bar{y} \\in \\mathcal{Y}</span> such that <span class="math">F(\\bar{y}) = \\bar{x}</span>; The proof <span class="math">\\pi</span> is empty.</li>

      <li>Verify <span class="math">((q,F),\\bar{x},\\bar{y},\\pi)</span> outputs Yes if <span class="math">F(\\bar{y}) = \\bar{x}</span>.</li>

    </ul>

    <p class="text-gray-300">The reason we require that <span class="math">F</span> be injective on <span class="math">\\mathcal{Y}</span> is so that the solution <span class="math">\\bar{y}</span> be unique.</p>

    <p class="text-gray-300">The construction is a weak <span class="math">(p(t),\\sigma (t))</span>-VDF for <span class="math">p(t) = t^2</span> and <span class="math">\\sigma (t) = t - o(t)</span> assuming that there is no algorithm that can invert of <span class="math">F\\in \\mathcal{F}</span> on a random value in less than parallel time <span class="math">d - o(d)</span> on <span class="math">O(d^{2})</span> processors. Note that this is a stronger assumption than 2 as the inversion reduces to a specific GCD computation rather than a general one.</p>

    <p class="text-gray-300"><strong>Candidate rational maps.</strong> The question, of course, is how to instantiate the function family <span class="math">\\mathcal{F}</span> so that the resulting weak VDF system is secure. There are many examples of rational maps on low dimensional algebraic sets among which we can search for candidates. Here we will focus on the special case of efficiently computable permutation polynomials over <span class="math">\\mathbb{F}_q</span>, and one particular family of permutation polynomials that may be suitable.</p>

    <h2 id="sec-35" class="text-2xl font-bold">6.2 Univariate permutation polynomials</h2>

    <p class="text-gray-300">The simplest instantiation of the VDF system above is when <span class="math">n = m = 1</span> and <span class="math">\\mathcal{Y} = \\mathbb{F}_q</span>. In this case, the function <span class="math">F</span> is a univariate polynomial <span class="math">f: \\mathbb{F}_q \\to \\mathbb{F}_q</span>. If <span class="math">f</span> implements an injective map on <span class="math">\\mathbb{F}_q</span>, then it must be a permutation of <span class="math">\\mathbb{F}_q</span>, which brings us to the study of univariate permutation polynomials as VDFs.</p>

    <p class="text-gray-300">The simplest permutation polynomials are the monomials <span class="math">x^{e}</span> for <span class="math">e \\geq 1</span>, where <span class="math">gcd(e, q - 1) = 1</span>. These polynomials however, can be easily inverted and do not give a secure VDF. Dickson polynomials [50] <span class="math">D_{n,\\alpha} \\in \\mathbb{F}_p[x]</span> are another well known family of polynomials over <span class="math">\\mathbb{F}_p</span> that permute <span class="math">\\mathbb{F}_p</span>. Dickson polynomials are defined by a recurrence relation and can be evaluated efficiently.</p>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">ickson polynomials satisfy <span class="math">D_{t,\\alpha^{n}}(D_{n,\\alpha}(x))=x</span> for all <span class="math">n,t,\\alpha</span> where <span class="math">n\\cdot t=1\\bmod p-1</span>, hence they are easy to invert over <span class="math">\\mathbb{F}_{p}</span> and again do not give a secure VDF.</p>

    <p class="text-gray-300">A number of other classes of permutation polynomials have been discovered over the last several decades <em>[40]</em>. We need a class of permutation polynomials over a suitably large field that have a tunable degree, are fast to evaluate (i.e. have <span class="math">\\operatorname{polylog}(d)</span> circuit complexity), and cannot be inverted faster than running the parallelized Euclidean algorithm on <span class="math">\\operatorname{O}(d)</span> processors.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Candidate permutation polynomial.</h4>

    <p class="text-gray-300">We consider the following polynomial of Guralnick and Muller <em>[39]</em> over <span class="math">\\mathbb{F}_{p^{m}}</span>:</p>

    <p class="text-gray-300"><span class="math">\\frac{(x^{s}-ax-a)\\cdot(x^{s}-ax+a)^{s}+((x^{s}-ax+a)^{2}+4a^{2}x)^{(s+1)/2}}{2x^{s}}</span> (6.1)</p>

    <p class="text-gray-300">where <span class="math">s=p^{r}</span> for odd prime <span class="math">p</span> and <span class="math">a</span> is not a <span class="math">(s-1)st</span> power in <span class="math">\\mathbb{F}_{p^{m}}</span>. This polynomial is a degree <span class="math">s^{3}</span> permutation on the field <span class="math">\\mathbb{F}_{p^{m}}</span> for all <span class="math">s,m</span> chosen independently.</p>

    <p class="text-gray-300">Below we discuss why instantiating a VDF with nearly all other examples of permutation polynomials would not be secure and why attacks on these other polynomials do not work against this candidate.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Attacks on other families of permutation polynomials.</h4>

    <p class="text-gray-300">We list here several other families of permutation polynomials that can be evaluated in <span class="math">O(\\operatorname{polylog}(d))</span> time, yet would not yield a secure VDF. We explain why each of these attacks do not work against the candidate polynomial.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sparse permutation polynomials. Sparse polynomials have a constant number of terms and therefore can be evaluated in time <span class="math">O(\\log(d))</span>. There exist families of non-monomial sparse permutation polynomials, e.g. <span class="math">X^{2^{t+1}+1}+X^{3}+X\\in\\mathbb{F}_{2^{2t+1}}[X]</span> <em>[40, Thm 4.12]</em>. The problem is that the degree of this polynomial is larger than the square root of the field size, which allows for brute force parallel attacks. Unfortunately, all known sparse permutation polynomials have this problem. In our candidate the field size can be made arbitrarily large relative to the degree of the polynomial.</li>

      <li>Linear algebraic attacks. A classic example of a sparse permutation polynomial of tunable degree over an arbitrarily large field, due to Mathieu <em>[34]</em>, is the family <span class="math">x^{p^{i}}-ax</span> over <span class="math">\\mathbb{F}_{p^{m}}</span> where <span class="math">a</span> is not a <span class="math">p-1</span>st power. Unfortunately, this polynomial is easy to invert because <span class="math">x\\mapsto x^{p^{i}}</span> is a linear operator in characteristic <span class="math">p</span> so the polynomial can be written as a linear equation over an <span class="math">m</span>-dimensional vector space. To prevent linear algebraic attacks the degree of at least one non-linear term in the polynomial cannot be divisible by the field characteristic <span class="math">p</span>. In our candidate there are many such non-linear terms, e.g. of degree <span class="math">s+1</span> where <span class="math">s=p^{r}</span>.</li>

      <li>Exceptional polynomials co-prime to characteristic. An exceptional polynomial is a polynomial <span class="math">f\\in\\mathbb{F}_{q}[X]</span> which is a permutation on <span class="math">\\mathbb{F}_{q^{m}}</span> for infinitely many <span class="math">m</span>, which allows us to choose sufficiently large <span class="math">m</span> to avoid brute force attacks. Any permutation polynomial of degree at most <span class="math">q^{1/4}</span> over <span class="math">F_{q}</span> is exceptional <em>[74]</em>. Since we want <span class="math">q</span> to be exponential in the security parameter and the degree to be sub-exponential we can restrict the search for candidate polynomials to exceptional polynomials. However, all exceptional polynomials</li>

    </ol>

    <p class="text-gray-300">over <span class="math">\\mathbb{F}_{q}</span>. of degree co-prime to <span class="math">q</span> can be written as the composition of Dickson polynomials and linear polynomials, which are easy to invert <em>[59]</em>. In our candidate, the degree <span class="math">s^{3}</span> of the polynomial and field size are both powers of <span class="math">p</span>, and are therefore not co-prime.</p>

    <h5 id="sec-38" class="text-base font-semibold mt-4">Additional application: a new family of one-way permutations.</h5>

    <p class="text-gray-300">We note that a sparse permutation polynomial of sufficiently high degree over a sufficiently large finite field may be a good candidate for a one-way permutation. This may give a secure one-way permutation over a domain of smaller size than what is possible by other methods.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">6.3 Comparison to square roots mod p</h3>

    <p class="text-gray-300">A classic approach to designing a sequentially slow verifiable function, dating back to Dwork and Naor <em>[31]</em>, is computing modular square roots. Given a challenge <span class="math">x\\in\\mathbb{Z}_{p}^{*}</span>, computing <span class="math">y=x^{\\frac{p+1}{4}}\\pmod{p}</span> can be efficiently verified by checking that <span class="math">y^{2}=x\\pmod{p}</span> (for <span class="math">p\\equiv 3\\pmod{4}</span>). There is no known way to compute this exponentiation in faster than <span class="math">\\log(p)</span> sequential field multiplications.</p>

    <p class="text-gray-300">This is a special case of inverting a rational function over a finite field, namely the polynomial <span class="math">f(y)=y^{2}</span>, although this function is not injective and therefore cannot be calculated with GCDs. An injective rational function with nearly the same characteristics is the permutation <span class="math">f(y)=y^{3}</span>. Since the inverse of <span class="math">3\\bmod{p-1}</span> will be <span class="math">O(\\log p)</span> bits, this requires <span class="math">O(\\log p)</span> squaring operations to invert. Viewed another way, this degree 3 polynomial can be inverted on a point <span class="math">c</span> by computing the <span class="math">\\text{GCD}(y^{p}-y,y^{2}-c)</span>, where the first step requires reducing <span class="math">y^{p}-y\\bmod{y^{3}-c}</span>, involving <span class="math">O(\\log p)</span>) repeated squarings and reductions <span class="math">\\bmod{y^{3}-c}</span>.</p>

    <p class="text-gray-300">While this approach appears to offer a delay parameter of <span class="math">t=\\log(p)</span>, as <span class="math">t</span> grows asymptotically the evaluator can use <span class="math">O(t)</span> parallel processors to gain a factor <span class="math">t</span> parallel speedup in field multiplications, thus completing the challenge in parallel time equivalent to one squaring operation on a sequential machine. Therefore, there is asymptotically no difference in the parallel time complexity of the evaluation and the total time complexity of the verification, which is why this does not even meet our definition of a weak VDF. Our approach of using higher degree injective rational maps gives a strict (asymptotic) improvement on the modular square/cubes approach, and to the best of our knowledge is the first concrete algebraic candidate to achieve an exponential gap between parallel evaluation complexity and total verification complexity.</p>

    <h2 id="sec-40" class="text-2xl font-bold">7 Practical improvements on VDFs from IVC</h2>

    <p class="text-gray-300">In this section we propose a practical boost to constructing VDFs from IVC (Section 4). In an IVC construction the prover constructs a SNARK which verifies a SNARK. Ben-Sasson et al. <em>[11]</em> showed an efficient construction for IVC using “cycles of Elliptic curves”. This construction builds on the pairing-based SNARK <em>[62]</em>. This SNARK system operates on arithmetic circuits defined over a finite field <span class="math">\\mathbb{F}_{p}</span>. The proof output consists of elements of an elliptic curve group <span class="math">E/\\mathbb{F}_{q}</span> of prime order <span class="math">p</span> (defined over a field <span class="math">\\mathbb{F}_{q}</span>). The SNARK verification circuit, which computes a pairing, is therefore an arithmetic circuit over <span class="math">\\mathbb{F}_{q}</span>. Since <span class="math">q\\neq p</span>, the prover cannot construct a new SNARK that directly operates on the verification circuit, as the SNARK operates on circuits defined over <span class="math">\\mathbb{F}_{p}</span>. Ben-Sasson et. al. propose using two SNARK systems where the curve order of one is equal to the base field of the other, and vice versa. This requires finding a pair</p>

    <p class="text-gray-300">of pairing-friendly elliptic curves <span class="math">E_1, E_2</span> (defined over two different base fields <span class="math">\\mathbb{F}_1</span> and <span class="math">\\mathbb{F}_2</span>) with the property that the order of each curve is equal to the size of the base field of the other.</p>

    <p class="text-gray-300">The main practical consideration in <span class="math">\\mathrm{VDF}_{\\mathrm{IVC}}</span> is that the evaluator needs to be able to update the incremental SNARK proofs at the same rate as computing the underlying sequential function, and without requiring a ridiculous amount of parallelism to do so. Our proposed improvements are based on two ideas:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In current SNARK/IVC constructions (including [62], [11]) the prover complexity is proportional to the multiplicative arithmetic complexity of the underlying statement over the field <span class="math">\\mathbb{F}_p</span> used in the SNARK (<span class="math">p \\approx 2^{128}</span>). Therefore, as an optimization, we can use a "SNARK friendly" hash function (or permutation) as the iterated sequential function such that the verification of each iteration has a lower multiplicative arithmetic complexity over <span class="math">\\mathbb{F}_p</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We can use the Eval of a weak VDF as the iterated sequential function, and compute a SNARK over the Verify circuit applied to each incremental output instead of the Eval circuit. This should increase the number of sequential steps required to evaluate the iterated sequential function relative to the number of multiplication gates over which the SNARK is computed.</li>

    </ol>

    <p class="text-gray-300">An improvement of type (1) alone could be achieved by simply using a cipher or hash function that has better multiplicative complexity over the SNARK field <span class="math">\\mathbb{F}_q</span> than AES or SHA256 (e.g., see MiMC [5], which has <span class="math">1.6\\%</span> complexity of AES). We will explain how using square roots in <span class="math">\\mathbb{F}_q</span> or a suitable permutation polynomial over <span class="math">\\mathbb{F}_q</span> (from Section 6) as the iterated function achieve improvements of both types (1) and (2).</p>

    <h2 id="sec-41" class="text-2xl font-bold">7.1 Iterated square roots in <span class="math">\\mathbb{F}_q</span></h2>

    <p class="text-gray-300"><strong>Sloth</strong> A recent construction called Sloth [48] proposed a secure way to chain a series of square root computations in <span class="math">\\mathbb{Z}_p</span> interleaved with a simple permutation <span class="math">^4</span> such that the chain must be evaluated sequentially, i.e. is an iterated sequential function (Definition 7). More specifically, Sloth defines two permutations on <span class="math">\\mathbb{F}_p</span>: a permutation <span class="math">\\rho</span> such that <span class="math">\\rho(x)^2 = \\pm x</span>, and a permutation <span class="math">\\sigma</span> such that <span class="math">\\sigma(x) = x \\pm 1</span> depending on the parity of <span class="math">x</span>. The parity of <span class="math">x</span> is defined as the integer parity of the unique <span class="math">\\hat{x} \\in \\{0, \\dots, p - 1\\}</span> such that <span class="math">\\hat{x} = x \\mod p</span>. Then Sloth iterates the permutation <span class="math">\\tau = \\rho \\circ \\sigma</span>.</p>

    <p class="text-gray-300">The verification of each step in the chain requires a single multiplication over <span class="math">\\mathbb{Z}_p</span> compared to the <span class="math">O(\\log(p))</span> multiplications required for evaluation. Increasing the size of <span class="math">p</span> amplifies this gap, however it also introduces an opportunity for parallelizing multiplication in <span class="math">\\mathbb{Z}_p</span> for up to <span class="math">O(\\log(p))</span> speedup.</p>

    <p class="text-gray-300">Using Sloth inside <span class="math">\\mathrm{VDF}_{\\mathrm{IVC}}</span> would only achieve a practical benefit if <span class="math">p = q</span> for the SNARK field <span class="math">\\mathbb{F}_q</span>, as otherwise implementing multiplication in <span class="math">\\mathbb{Z}_p</span> in an arithmetic circuit over <span class="math">\\mathbb{F}_q</span> would have <span class="math">O(\\log^2(p))</span> complexity. On modern architectures, multiplication of integers modulo a 256-bit prime is near optimal on a single core, whereas multi-core parallelized algorithms only offer speed-ups for larger primes [8]. Computing a single modular square root for a 256-bit prime</p>

    <p class="text-gray-300"><span class="math">^4</span>If square roots are iterated on a value <span class="math">x</span> without an interleaved permutation then there is a shortcut to the iterated computation that first computes <span class="math">v = \\left(\\frac{p + 1}{4}\\right)^t \\mod p</span> and then the single exponentiation <span class="math">x^v</span>.</p>

    <p class="text-gray-300">23</p>

    <p class="text-gray-300">takes approximately 45,000 cycles on an Intel Core i7 <em>[48]</em>, while computing SHA256 for 256-bit outputs takes approximately 864 cycles.</p>

    <p class="text-gray-300">The best known arithmetic circuit implementation of SHA256 has 27,904 multiplication gates<em>[9]</em>. In stark contrast, the arithmetic circuit over <span class="math">\\mathbb{F}_{p}</span> for verifying a modular square root is a single multiplication gate. Verifying the permutation <span class="math">\\sigma</span> is more complex as it requires a parity check, but this requires at most <span class="math">O(\\log(p))</span> complexity.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Sloth++ extension</h4>

    <p class="text-gray-300">Replacing SHA256 with Sloth as the iterated function in VDF_{IVC} already gives a significant improvement, as detailed above. Here we suggest yet a further optimization, which we call Sloth++. The main arithmetic complexity of verifying a step of Sloth comes from the fact that the permutation <span class="math">\\sigma</span> is not naturally arithmetic over <span class="math">\\mathbb{F}_{p}</span>, which was important for preventing attacks that factor <span class="math">\\tau^{\\ell}(x)</span> as a polynomial over <span class="math">\\mathbb{F}_{p}</span>. Our idea here is to compute square roots over a degree 2 extension field <span class="math">\\mathbb{F}_{p^{2}}</span> interleaved with a permutation that is arithmetic over <span class="math">\\mathbb{F}_{p}</span> but not over <span class="math">\\mathbb{F}_{p^{2}}</span>.</p>

    <p class="text-gray-300">In any degree <span class="math">r</span> extension field <span class="math">\\mathbb{F}_{p^{r}}</span> of <span class="math">\\mathbb{F}_{p}</span> for a prime <span class="math">p=3\\mod 4</span> a square root of an element <span class="math">x\\in\\mathbb{F}_{p^{r}}</span> can be found by computing <span class="math">x^{(p^{r}+1)/4}</span>. This is computed in <span class="math">O(r\\log(p))</span> repeated squaring operations in <span class="math">\\mathbb{F}_{p}^{r}</span>. Verifying a square root requires a single multiplication over <span class="math">\\mathbb{F}_{p^{r}}</span>. Elements of <span class="math">\\mathbb{F}_{p^{r}}</span> can be represented as length <span class="math">r</span> vectors over <span class="math">\\mathbb{F}_{p}</span>, and each multiplication reduces to <span class="math">O(r^{2})</span> arithmetic operations over <span class="math">\\mathbb{F}_{p}</span>. For <span class="math">r=2</span> the verification <em>multiplicative</em> complexity over <span class="math">\\mathbb{F}_{p}</span> is exactly 4 gates.</p>

    <p class="text-gray-300">In Sloth++ we define the permutation <span class="math">\\rho</span> exactly as in Sloth, yet over <span class="math">\\mathbb{F}_{p^{2}}</span>. Then we define a simple non-arithmetic permutation <span class="math">\\sigma</span> on <span class="math">\\mathbb{F}_{p^{2}}</span> that swaps the coordinates of elements in their vector representation over <span class="math">\\mathbb{F}_{p}</span> and adds a constant, i.e. maps the element <span class="math">(x,y)</span> to <span class="math">(y+c_{1},x+c_{2})</span>. The arithmetic circuit over <span class="math">\\mathbb{F}_{p}</span> representing the swap is trivial: it simply swaps the values on the input wires. The overall multiplicative complexity of verifying an iteration of Sloth++ is only 4 gates over <span class="math">\\mathbb{F}_{p}</span>. Multiplication can be parallelized for a factor 2 speedup, so 4 gates must be verified roughly every 89,000 parallel-time evaluation cycles. Thus, even if an attacker could manage to speedup the modular square root computation by a factor 100 using an ASIC designed for 256-bit multiplication, for parameters that achieve the same wall-clock delay, the SNARK verification complexity of Sloth++ is over a 7,000 fold improvement over that of a SHA256 chain.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">Cube roots</h4>

    <p class="text-gray-300">The underlying permutation in both Sloth and Sloth++ can be replaced by cube roots over <span class="math">\\mathbb{F}_{q}</span> when <span class="math">gcd(3,q-1)=1</span>. In this case the slow function is computing <span class="math">\\rho(x)=x^{v}</span> where <span class="math">3v=1\\bmod q-1</span>. The output can be verified as <span class="math">\\rho(x)^{3}=x</span>.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">7.2 Iterated permutation polynomials</h3>

    <p class="text-gray-300">Similar to Sloth+, we can use our candidate permutation polynomial (Equation 6.1) over <span class="math">\\mathbb{F}_{q}</span> as the iterated function in VDF_{IVC}. Recall that <span class="math">\\mathbb{F}_{q}</span> is an extension field chosen independently from the degree of the polynomial. We would choose <span class="math">q\\approx 2^{256}</span> and use the same <span class="math">\\mathbb{F}_{q}</span> as the field used for the SNARK system. For each <span class="math">O(d)</span> sequential provers steps required to invert the polynomial on a point, the SNARK only needs to verify the evaluation of the polynomial on the inverse,</p>

    <p class="text-gray-300">which has multiplicative complexity <span class="math">O(\\log(d))</span> over <span class="math">\\mathbb{F}_{q}</span>. Concretely, for each <span class="math">10^{5}</span> parallel-time evaluation cycles a SNARK needs to verify approximately 16 gates. This is yet another factor 15 improvement over Sloth+. The catch is that the evaluator must use <span class="math">10^{5}</span> parallelism to optimize the polynomial GCD computation. We must also assume that an adversary cannot feasibly amass more than <span class="math">10^{14}</span> parallel processors to implement the NC parallelized algorithm for polynomial GCD.</p>

    <p class="text-gray-300">From a theory standpoint, using permutation polynomials inside VDF_{IVC} reduces it to a weak VDF because the degree of the polynomial must be super-polynomial in <span class="math">\\lambda</span> to prevent an adversary from implementing the NC algorithm on <span class="math">poly(\\lambda)</span> processors, and therefore the honest evaluator is also required to use super-polynomial parallelism. However, the combination does yield a better weak VDF, and from a practical standpoint appears quite promising for many applications.</p>

    <h2 id="sec-45" class="text-2xl font-bold">8 Towards VDFs from exponentiation in a finite group</h2>

    <p class="text-gray-300">The sequential nature of large exponentiation in a finite group may appear to be a good source for secure VDF systems. This problem has been used extensively in the past for time-based problems such as time-lock puzzles <em>[68]</em>, benchmarking <em>[21]</em>, timed commitments <em>[16]</em>, and client puzzles <em>[31, 48]</em>. Very recently, Pietrzak <em>[65]</em> showed how to use this problem to construct a VDF that requires a trusted setup. The trusted setup can be eliminated by instead choosing a sufficiently large random number <span class="math">N</span> so that <span class="math">N</span> has two large prime factors with high probability. However, the large size of <span class="math">N</span> provides the adversary with more opportunity for parallelizing the arithmetic. It also increases the verifier’s running time. Alternatively, one can use the class group of an imaginary quadratic order <em>[20]</em>, which is an efficient group of unknown order with a public setup <em>[51]</em>.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">8.1 Exponentiation-based VDFs with bounded pre-computation</h3>

    <p class="text-gray-300">Here we suggest a simple exponentiation-based approach to constructing VDFs whose security would rely on the assumption that the adversary cannot run a long pre-computation between the time that the public parameters <span class="math">\\mathbf{pp}</span> are made public and the time when the VDF needs to be evaluated. Therefore, in terms of security this construction is subsumed by the more recent solution of Pietrzak <em>[65]</em>, however it yields much shorter proofs. We use the following notation to describe the VDF:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">L=\\{\\ell_{1},\\ell_{2},\\ldots,\\ell_{t}\\}</span> be the first <span class="math">t</span> odd primes, namely <span class="math">\\ell_{1}=3,\\ \\ell_{2}=5</span>, etc. Here <span class="math">t</span> is the provided delay parameter.</li>

      <li>let <span class="math">P</span> be the product of the primes in <span class="math">L</span>, namely <span class="math">P:=\\ell_{1}\\cdot\\ell_{2}\\cdots\\ell_{t}</span>. This <span class="math">P</span> is a large integer with about <span class="math">t\\log t</span> bits.</li>

    </ul>

    <p class="text-gray-300">With this notation, the trusted setup procedure works as follows: construct an RSA modulus <span class="math">N</span>, say 4096 bits long, where the prime factors are strong primes. The trusted setup algorithm knows the factorization of <span class="math">N</span>, but no one else will. Let <span class="math">\\mathbb{G}:=(\\mathbb{Z}/N\\mathbb{Z})^{*}</span>. We will also need a random hash function <span class="math">H:\\mathbb{Z}\\rightarrow\\mathbb{G}</span>. Next, for a given preprocessing security parameter <span class="math">B</span>, say <span class="math">B=2^{30}</span>, do:</p>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">i = 1, \\ldots, B</span>: compute <span class="math">h_i \\gets H(i) \\in \\mathbb{G}</span> and then compute <span class="math">g_i := h_i^{1/P} \\in \\mathbb{G}</span>.</li>

      <li>output</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\text{ek} := (\\mathbb{G}, H, g_1, \\dots, g_B) \\quad \\text{and} \\quad \\text{vk} := (\\mathbb{G}, H).</span></div>

    <p class="text-gray-300">Note that the verifier's public parameters are short, but the evaluators parameters are not.</p>

    <p class="text-gray-300">Solving a challenge <span class="math">x</span>: Algorithm <span class="math">\\mathsf{Eval}(\\mathbf{pp}_{\\mathrm{eval}}, x)</span> takes as input the public parameters <span class="math">\\mathbf{pp}_{\\mathrm{eval}}</span> and a challenge <span class="math">x \\in \\mathcal{X}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>using a random hash function, map the challenge <span class="math">x</span> to a random subset <span class="math">L_x \\subseteq L</span> of size <span class="math">\\lambda</span>, and a random subset <span class="math">S_x</span> of <span class="math">\\lambda</span> values in <span class="math">\\{1, \\ldots, B\\}</span>.</li>

      <li>Let <span class="math">P_x</span> be the product of all the primes in <span class="math">L_x</span>, and let <span class="math">g</span> be <span class="math">g \\coloneqq \\prod_{i \\in S_x} g_i \\in \\mathbb{G}</span>.</li>

      <li>the challenge solution <span class="math">y</span> is simply <span class="math">y \\gets g^{P / P_x} \\in \\mathbb{G}</span>, which takes <span class="math">O(t \\log t)</span> multiplications in <span class="math">\\mathbb{G}</span>.</li>

    </ul>

    <p class="text-gray-300">Verifying a solution <span class="math">y</span>: Algorithm <span class="math">\\mathsf{Verify}(\\mathbf{pp}_{\\mathrm{verify}}, x, y)</span> works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">P_x</span> and <span class="math">S_x</span> as in algorithm <span class="math">\\mathsf{Eval}(\\mathbf{pp}_{\\mathrm{eval}}, x)</span>.</li>

      <li>let <span class="math">h</span> be <span class="math">h := \\prod_{i \\in S_x} H(i) \\in \\mathbb{G}</span>.</li>

      <li>output yes if and only if <span class="math">y^{P_x} = h</span> in <span class="math">\\mathbb{G}</span>.</li>

    </ul>

    <p class="text-gray-300">Note that exactly one <span class="math">y \\in \\mathbb{G}</span> will be accepted as a solution for a challenge <span class="math">x</span>. Verification takes only <span class="math">\\tilde{O}(\\lambda)</span> group operations.</p>

    <p class="text-gray-300"><strong>Security.</strong> The scheme does not satisfy the definition of a secure VDF, but may still be useful for some of the applications described in Section 2. In particular, the system is not secure against an adversary who can run a large pre-computation once the parameters <span class="math">\\mathbf{pp}</span> are known. There are several pre-computation attacks possible that require <span class="math">tB</span> group operations in <span class="math">\\mathbb{G}</span>. Here we describe one such instructive attack. It uses space <span class="math">O(sB)</span>, for some <span class="math">s &amp;gt; 0</span>, and gives a factor of <span class="math">s</span> speed up for evaluating the VDF.</p>

    <p class="text-gray-300">Consider the following pre-computation, for a given parameter <span class="math">s</span>, say <span class="math">s = 100</span>. Let <span class="math">b = \\lfloor P^{1 / s} \\rfloor</span>, then the adversary computes and stores a table of size <span class="math">sB</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\text{for all } i = 1, \\dots, B: \\quad g_i^b, g_i^{(b^2)}, \\dots, g_i^{(b^s)} \\in \\mathbb{G}. \\tag{8.1}</span></div>

    <p class="text-gray-300">Computing these values is comparable to solving <span class="math">B</span> challenges. Once computed, to evaluate the VDF at input <span class="math">x</span>, the adversary uses the precomputed table to quickly compute</p>

    <div class="my-4 text-center"><span class="math-block">g^b, g^{(b^2)}, \\dots, g^{(b^s)} \\in \\mathbb{G}.</span></div>

    <p class="text-gray-300">Now, to compute <span class="math">g^{P / P_x}</span>, it can write <span class="math">P / P_x</span> in base <span class="math">b</span> as:</p>

    <p class="text-gray-300"><span class="math">P / P_x = \\alpha_0 + \\alpha_1 b + \\alpha_2 b^2 + \\ldots + \\alpha_s b^s</span> so that</p>

    <div class="my-4 text-center"><span class="math-block">g^{P / P_x} = g^{\\alpha_0} \\cdot (g^b)^{\\alpha_1} \\cdot (g^{(b^2)})^{\\alpha_2} \\cdots (g^{(b^s)})^{\\alpha_s}.</span></div>

    <p class="text-gray-300">This expression can be evaluated in parallel and gives a parallel adversary a factor of <span class="math">s</span> speed-up over a sequential solver, which violates the sequentiality property of the VDF.</p>

    <p class="text-gray-300">To mount this attack, the adversary must compute the entire table (8.1) for all <span class="math">g_1, \\ldots, g_B</span>, otherwise it can only gain a factor of two speed-up with negligible probability in <span class="math">\\lambda</span>. Hence, the scheme is secure for only <span class="math">B</span> challenges, after which new public parameters need to be generated. This may be sufficient for some applications of a VDF.</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">Taking a broad perspective, VDFs can be viewed as an example of moderately hard cryptographic functions. Moderately hard functions are those whose difficulty to compute is somewhere in between ‘easy’ (designed to be as efficient as possible) and ‘hard’ (designed to be so difficult as to be intractable). The use of moderately hard cryptographic functions dates back at least to the use of a deliberately slow DES variant for password hashing in early UNIX systems <em>[58]</em>. Dwork and Naor <em>[31]</em> coined the term moderately hard in a classic paper proposing client puzzles or “pricing functions” for the purpose of preventing spam. Juels and Brainard proposed the related notion of a client puzzle, in which a TCP server creates a puzzle which must be solved before a client can open a connection <em>[44]</em>. Both concepts have been studied for a variety of applications, including TLS handshake requests <em>[7, 29]</em>, node creation in peer-to-peer networks <em>[30]</em>, creation of digital currency <em>[67, 27, 60]</em> or censorship resistance <em>[18]</em>. For interactive client puzzles, the most common construction is as follows: the server chooses a random <span class="math">\\ell</span>-bit value <span class="math">x</span> and sends to the client <span class="math">\\mathrm{H}(x)</span> and <span class="math">x[\\ell-\\log_{2}t-1]</span>. The client must send back the complete value of <span class="math">x</span>. That is, the server sends the client <span class="math">\\mathrm{H}(x)</span> plus all of the bits of <span class="math">x</span> except the final <span class="math">\\log_{2}t+1</span> bits, which the client must recover via brute force.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">9.1 Inherently sequential puzzles</h3>

    <p class="text-gray-300">The simple interactive client puzzle described above is embarrassingly parallel and can be solved in constant time given <span class="math">t</span> processors. In contrast, the very first construction of a client puzzle proposed by Dwork and Naor involved computing modular square roots and is believed to be inherently sequential (although they did not discuss this as a potential advantage).</p>

    <p class="text-gray-300">The first interest in designing puzzles that require an inherently sequential solving algorithm appears to come for the application of hardware benchmarking. Cai et al. <em>[21, 22]</em> proposed the use of inherently sequential puzzles to verify claimed hardware performance as follows: a customer creates an inherently-sequential puzzle and sends it to a hardware vendor, who then solves it and returns the solution (which the customer can easily verify) as quickly as possible. Note that this work predated the definition of client puzzles. Their original construction was based on exponentiation modulo an RSA number <span class="math">N</span>, for which the customer has created <span class="math">N</span> and therefore knows <span class="math">\\varphi(N)</span>. They later proposed solutions based on a number of other computational problems not typically used in cryptography, including Gaussian elimination, fast Fourier transforms, and matrix multiplication.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Time-lock puzzles</h4>

    <p class="text-gray-300">Rivest, Shamir, and Wagner <em>[68]</em> constructed a time-lock encryption scheme, also based on the hardness of RSA factoring and the conjectured sequentiality of repeated exponentiation in a group of unknown order. The encryption key <span class="math">K</span> is derived as <span class="math">K=x^{2^{t}}\\in\\mathbb{Z}_{N}</span> for an RSA modulus <span class="math">N</span> and a published starting value <span class="math">x</span>. The encrypting party, knowing <span class="math">\\varphi(N)</span>, can reduce the exponent <span class="math">e=2^{t}\\bmod\\varphi(N)</span> to quickly derive <span class="math">K=x^{e}\\bmod N</span>. The key <span class="math">K</span> can be publicly recovered slowly by <span class="math">2^{t}</span> iterated squarings. Boneh and Naor <em>[16]</em> showed that the puzzle creator can publish additional information enabling an efficient and sound proof that <span class="math">K</span> is correct. In the only alternate construction we are aware of, Bitansky et al. <em>[15]</em> show how to construct time-lock puzzles from randomized encodings assuming any inherently-sequential functions exist.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Time-lock puzzles are similar to VDFs in that they involve computing an inherently sequential function. However, time-lock puzzles are defined in a private-key setting where the verifier uses its private key to prepare each puzzle (and possibly a verification proof for the eventual answer). In contrast to VDFs, this trusted setup must be performed per-puzzle and each puzzle takes no unpredictable input.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Proofs of sequential work</h4>

    <p class="text-gray-300">Mahmoody et al.<em>[52]</em> proposed publicly verifiable proofs of sequential work (PoSW) which enable proving to any challenger that a given amount of sequential work was performed on a specific challenge. As noted, time-lock puzzles are a type of PoSW, but they are not publicly verifiable. VDFs can be seen as a special case of publicly verifiable proofs of sequential work with the additional guarantee of a unique output (hence the use of the term “function” versus “proof”).</p>

    <p class="text-gray-300">Mahmoody et al.’s construction uses a sequential hash function <span class="math">H</span> (modeled as a random oracle) and depth robust directed-acyclic graph <span class="math">G</span>. Their puzzle involves computing a <em>labeling</em> of <span class="math">G</span> using <span class="math">H</span> salted by the challenge <span class="math">c</span>. The label on each node is derived as a hash of all the labels on its parent nodes. The labels are committed to in a Merkle tree and the proof involves opening a randomly sampled fraction. Very briefly, the security of this construction is related to graph pebbling games (where a pebble can be placed on a node only if all its parents already have pebbles) and the fact that depth robust graphs remain sequentially hard to pebble even if a constant fraction of the nodes are removed (in this case corresponding to places where the adversary cheats). Mahmoody et. al. proved security unconditionally in the random oracle model. Depth robust graphs and parallel pebbling hardness are use similarly to construct memory hard functions <em>[42]</em> and proofs of space <em>[32]</em>. Cohen and Pietrzak <em>[19]</em> constructed a similar PoSW using a simpler non-depth-robust graph based on a Merkle tree.</p>

    <p class="text-gray-300">PoSWs based on graph labeling don’t naturally provide a VDF because removing any single edge in the graph will change the output of the proof, yet is unlikely to be detected by random challenges.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Sequentially hard functions</h4>

    <p class="text-gray-300">The most popular solution for a slow function which can be viewed as a proto-VDF, dating to Dwork and Naor <em>[31]</em>, is computing modular square roots. Given a challenge <span class="math">x\\in\\mathbb{Z}_{p}^{*}</span>, computing <span class="math">y=x^{\\frac{p+1}{4}}\\pmod{p}</span> can be efficiently verified by checking that <span class="math">y^{2}=x\\pmod{p}</span> (for <span class="math">p\\equiv 3\\pmod{4}</span>). There is no known algorithm for computing modular exponentiation which is sublinear in the exponent. However, the difficulty of puzzles is fixed to <span class="math">t=\\log p</span> as the exponent can be reduced modulo <span class="math">p-1</span> before computation, requiring the use of a very large prime <span class="math">p</span> to produce a difficult puzzle.</p>

    <p class="text-gray-300">This puzzle has been considered before for similar applications as our VDFs, in particular randomness beacons <em>[41, 48]</em>. Lenstra and Wesolowski <em>[48]</em> proposed creating a more difficult puzzle for a small <span class="math">p</span> by chaining a series of such puzzles together (interleaved with a simple permutation) in a construction called Sloth. We proposed a simple improvement of this puzzle in Section 7. Recall that this does not meet our asymptotic definition of a VDF because it does not offer (asymptotically) efficient verification, however we used it as an important building block to construct a more practical VDF based on IVC. Asymptotically, Sloth is comparable to a hash chain of length <span class="math">t</span> with <span class="math">t</span> checkpoints provided as a proof, which also provides <span class="math">O(\\mathrm{polylog}(t))</span>-time verification (with <span class="math">t</span> processors) and a solution of size <span class="math">\\Theta(t\\cdot\\lambda)</span>.</p>

    <p class="text-gray-300">Given their large number of interesting applications, we hope this work stimulates new practical uses for VDFs and continued study of theoretical constructions. We still lack a theoretically optimal VDF, consisting of a simple inherently sequential function requiring low parallelism to compute but yet being very fast (e.g. logarithmic) to invert. These requirements motivate the search for new problems which have not traditionally been used in cryptography. Ideally, we want a VDF that is also post-quantum secure.</p>

    <p class="text-gray-300">We thank Micheal Zieve for his help with permutation polynomials. We thank the CRYPTO reviewers for their helpful comments. This work was supported by NSF, a grant from ONR, the Simons Foundation, and a Google faculty fellowship.</p>

    <h2 id="sec-53" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Randao: A dao working as rng of ethereum. Technical report, 2016.</li>

      <li>[2] Filecoin: A decentralized storage network. Protocol Labs, 2017. https://filecoin.io/filecoin.pdf.</li>

      <li>[3] Proof of replication. Protocol Labs, 2017. https://filecoin.io/proof-of-replication.pdf.</li>

      <li>[4] Threshold relay. Dfinity, 2017. https://dfinity.org/pdfs/viewer.?file=../library/threshold-relay-blockchain-stanford.pdf.</li>

      <li>[5] M. R. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In ASIACRYPT, pages 191–219, 2016.</li>

      <li>[6] F. Armknecht, L. Barman, J.-M. Bohli, and G. O. Karame. Mirror: Enabling proofs of data replication and retrievability in the cloud. In USENIX Security Symposium, pages 1051–1068, 2016.</li>

      <li>[7] T. Aura, P. Nikander, and J. Leiwo. Dos-resistant authentication with client puzzles. In International workshop on security protocols, pages 170–177. Springer, 2000.</li>

      <li>[8] S. Baktir and E. Savas. Highly-parallel montgomery multiplication for multi-core general-purpose microprocessors. In Computer and Information Sciences III, pages 467–476. Springer, 2013.</li>

      <li>[9] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zero-cash: Decentralized anonymous payments from Bitcoin. In IEEE Symposium on Security and Privacy, 2014.</li>

      <li>[10] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In CRYPTO, 2013.</li>

      <li>[11] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via cycles of elliptic curves. In Algorithmica, pages 1102–1160, 2014.</li>

      <li>[12] I. Bentov, A. Gabizon, and D. Zuckerman. Bitcoin beacon. arXiv preprint arXiv:1605.04559, 2016.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[13] I. Bentov, R. Pass, and E. Shi. Snow white: Provably secure proofs of stake. IACR Cryptology ePrint Archive, 2016, 2016.</li>

      <li>[14] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for snarks and proof-carrying data. In Proceedings of the forty-fifth annual ACM symposium on Theory of computing, pages 111–120. ACM, 2013.</li>

      <li>[15] N. Bitansky, S. Goldwasser, A. Jain, O. Paneth, V. Vaikuntanathan, and B. Waters. Time-lock puzzles from randomized encodings. In ACM Conference on Innovations in Theoretical Computer Science, 2016.</li>

      <li>[16] D. Boneh and M. Naor. Timed commitments. In Advances in CryptologyCrypto 2000, pages 236–254. Springer, 2000.</li>

      <li>[17] J. Bonneau, J. Clark, and S. Goldfeder. On bitcoin as a public randomness source. URL https://eprint.iacr.org/2015/1015.pdf, 2015.</li>

      <li>[18] J. Bonneau and R. Xu. Scrambling for lightweight censorship resistance. In International Workshop on Security Protocols. Springer, 2011.</li>

      <li>[19] K. P. Bram Cohen. Simple proofs of sequential work. In EUROCRYPT, 2018.</li>

      <li>[20] J. Buchmann and H. C. Williams. A key-exchange system based on imaginary quadratic fields. Journal of Cryptology, 1(2):107–118, 1988.</li>

      <li>[21] J. Cai, R. J. Lipton, R. Sedgewick, and A. C. Yao. Towards uncheatable benchmarks. In Structure in Complexity Theory, 1993.</li>

      <li>[22] J.-Y. Cai, A. Nerurkar, and M.-Y. Wu. The design of uncheatable benchmarks using complexity theory, 1997.</li>

      <li>[23] I. Cascudo and B. David. Scrape: Scalable randomness attested by public entities. Cryptology ePrint Archive, Report 2017/216, 2017. http://eprint.iacr.org/2017/216.</li>

      <li>[24] J. Clark and U. Hengartner. On the Use of Financial Data as a Random Beacon. Usenix EVT/WOTE, 2010.</li>

      <li>[25] B. Codenottia, B. N. Datta, K. Datta, and M. Leoncini. Parallel algorithms for certain matrix computations. In Theoretical Computer Science, 1997.</li>

      <li>[26] B. Cohen. Proofs of space and time. Blockchain Protocol Analysis and Security Engineering, 2017. https://cyber.stanford.edu/sites/default/files/bramcohen.pdf.</li>

      <li>[27] W. Dai. B-money. Consulted, 1:2012, 1998.</li>

      <li>[28] B. David, P. Gazi, A. Kiayias, and A. Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain. In Eurocrypt. Springer, 2018.</li>

      <li>[29] D. Dean and A. Stubblefield. Using client puzzles to protect tls. In USENIX Security Symposium, volume 42, 2001.</li>

      <li>[30] J. R. Douceur. The sybil attack. In International Workshop on Peer-to-Peer Systems, pages 251–260. Springer, 2002.</li>

      <li>[31] C. Dwork and M. Naor. Pricing via processing or combatting junk mail. In CRYPTO, 1992.</li>

      <li>[32] S. Dziembowski, S. Faust, V. Kolmogorov, and K. Pietrzak. Proofs of space. In CRYPTO, 2015.</li>

      <li>[33] N. Dttling, S. Garg, G. Malavolta, and P. N. Vasudevan. Tight verifiable delay functions. Cryptology ePrint Archive, Report 2019/659, 2019. https://eprint.iacr.org/2019/659.</li>

      <li>[34] Émile Mathieu. Mémoire sur l’étude des fonctions de plusieurs quantités sur la manière de les former et sur les substitutions qui les laissent invariables. In J. Math. Pures Appl. (2) 6, 1861.</li>

      <li>[35] B. Fisch. Poreps: Proofs of space on useful data. Cryptology ePrint Archive, Report</li>

    </ul>

    <p class="text-gray-300">2018/678, 2018. https://eprint.iacr.org/2018/678.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[36] J. Garay, A. Kiayias, and N. Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. Cryptology ePrint Archive # 2014/765, 2014.</li>

      <li>[37] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct nizks without pcps. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 626–645. Springer, 2013.</li>

      <li>[38] D. M. Goldschlag and S. G. Stubblebine. Publicly Verifiable Lotteries: Applications of Delaying Functions. In Financial Cryptography, 1998.</li>

      <li>[39] R. M. Guralnick and P. Müller. Exceptional polynomials of affine type. Journal of Algebra, 194(2):429–454, 1997.</li>

      <li>[40] X.-d. Hou. Permutation polynomials over finite fieldsa survey of recent advances. Finite Fields and Their Applications, 32:82–119, 2015.</li>

      <li>[41] Y. I. Jerschow and M. Mauve. Non-parallelizable and non-interactive client puzzles from modular square roots. In Availability, Reliability and Security (ARES), 2011.</li>

      <li>[42] J. B. Joël Alwen and K. Pietrzak. Depth-robust graphs and their cumulative memory complexity. In Eurocrypt, 2017.</li>

      <li>[43] A. Juels and B. S. Kaliski Jr. Pors: Proofs of retrievability for large files. In Proceedings of the 14th ACM conference on Computer and communications security, pages 584–597. Acm, 2007.</li>

      <li>[44] A. Jules and J. Brainard. Client-puzzles: a cryptographic defense against connection depletion. In Proc. Network and Distributed System Security Symp.(NDSS’99), pages 151–165, 1999.</li>

      <li>[45] A. Kiayias, A. Russell, B. David, and R. Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In CRYPTO, 2017.</li>

      <li>[46] S. King and S. Nadal. Peercoin–secure &amp; sustainable cryptocoin. Aug-2012 [Online]. Available: https://peercoin. net/whitepaper.</li>

      <li>[47] D. Kogan, N. Manohar, and D. Boneh. T/key: Second-factor authentication from secure hash chains. In ACM Conference on Computer and Communications Security, 2017.</li>

      <li>[48] A. K. Lenstra and B. Wesolowski. A random zoo: sloth, unicorn, and trx. IACR Cryptology ePrint Archive, 2015, 2015.</li>

      <li>[49] S. D. Lerner. Proof of unique blockchain storage, 2014. https://bitslog.wordpress. com/2014/11/03/proof-of-local-blockchain-storage/.</li>

      <li>[50] R. Lidl, G. L. Mullen, and G. Turnwald. Dickson polynomials, volume 65. Chapman &amp; Hall/CRC, 1993.</li>

      <li>[51] H. Lipmaa. Secure accumulators from euclidean rings without trusted setup. In International Conference on Applied Cryptography and Network Security, pages 224–240. Springer, 2012.</li>

      <li>[52] M. Mahmoody, T. Moran, and S. Vadhan. Publicly verifiable proofs of sequential work. In Proceedings of the 4th conference on Innovations in Theoretical Computer Science. ACM, 2013.</li>

      <li>[53] U. Maurer, R. Renner, and C. Holenstein. Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology. In TCC, 2004.</li>

      <li>[54] S. Micali. Cs proofs. In Foundations of Computer Science, 1994 Proceedings., 35th Annual Symposium on, pages 436–453. IEEE, 1994.</li>

      <li>[55] S. Micali. Algorand: the efficient and democratic ledger. arXiv preprint arXiv:1607.01341, 2016.</li>

    </ul>

    <p class="text-gray-300">[56] A. Miller, A. Juels, E. Shi, B. Parno, and J. Katz. Permacoin: Repurposing bitcoin work for data preservation. In Security and Privacy (SP), 2014 IEEE Symposium on, pages 475–490. IEEE, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[57] T. Moran, M. Naor, and G. Segev. An optimally fair coin toss. In Theory of Cryptography Conference, pages 1–18. Springer, 2009.</li>

      <li>[58] R. Morris and K. Thompson. Password security: A case history. Communications of the ACM, 22(11):594–597, 1979.</li>

      <li>[59] P. Müller. A weil-bound free proof of schur’s conjecture. Finite Fields and Their Applications, 3(1):25–32, 1997.</li>

      <li>[60] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.</li>

      <li>[61] S. Park, K. Pietrzak, A. Kwon, J. Alwen, G. Fuchsbauer, and P. Gai. Spacemint: A cryptocurrency based on proofs of space. Cryptology ePrint Archive, Report 2015/528, 2015. http://eprint.iacr.org/2015/528.</li>

      <li>[62] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE Security and Privacy, 2013.</li>

      <li>[63] C. Pierrot and B. Wesolowski. Malleability of the blockchains entropy. 2016.</li>

      <li>[64] K. Pietrzak. Simple verifiable delay functions. Cryptology ePrint Archive, Report 2018/627, 2018. https://eprint.iacr.org/2018/627.</li>

      <li>[65] K. Pietrzak. Unique proofs of sequential work from time-lock puzzles, 2018. Manuscript.</li>

      <li>[66] M. O. Rabin. Transaction protection by beacons. Journal of Computer and System Sciences, 1983.</li>

      <li>[67] R. L. Rivest and A. Shamir. Payword and micromint: Two simple micropayment schemes. In International Workshop on Security Protocols, pages 69–87. Springer, 1996.</li>

      <li>[68] R. L. Rivest, A. Shamir, and D. A. Wagner. Time-lock puzzles and timed-release crypto. 1996.</li>

      <li>[69] E. Syta, P. Jovanovic, E. K. Kogias, N. Gailly, L. Gasser, I. Khoffi, M. J. Fischer, and B. Ford. Scalable bias-resistant distributed randomness. In Security and Privacy (SP), 2017 IEEE Symposium on, pages 444–460. Ieee, 2017.</li>

      <li>[70] P. Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. Theory of Cryptography, pages 1–18, 2008.</li>

      <li>[71] P. C. Van Oorschot and M. J. Wiener. Parallel collision search with application to hash functions and discrete logarithms. In ACM Conference on Computer and Communications Security, 1994.</li>

      <li>[72] R. S. Wahby, S. T. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient ram and control flow in verifiable outsourced computation. In NDSS, 2015.</li>

      <li>[73] B. Wesolowski. Efficient verifiable delay functions. Cryptology ePrint Archive, Report 2018/623, 2018. https://eprint.iacr.org/2018/623.</li>

      <li>[74] M. Zieve. Exceptional polynomials. http://dept.math.lsa.umich.edu/~zieve/papers/epfacts.pdf.</li>

    </ul>`;
---

<BaseLayout title="Verifiable Delay Functions (2018/601)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/601
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
