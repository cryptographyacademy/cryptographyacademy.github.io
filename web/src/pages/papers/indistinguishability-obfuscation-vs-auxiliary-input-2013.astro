---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/468';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'How To Construct Extractable One-Way Functions Against Uniform Adversaries';
const AUTHORS_HTML = 'Nir Bitansky, Ran Canetti, Omer Paneth';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">A function $f$ is extractable if  it is possible to algorithmically \`\`extract,&#x27;&#x27; from any program that outputs a value $y$ in the image of $f,$ a preimage of $y$. % under $f$.
When combined with hardness properties such as one-wayness or collision-resistance, extractability has proven to be a powerful tool. However, so far, extractability has not been explicitly shown. Instead, it has only been considered as a non-standard {\\em knowledge assumption} on certain functions.

We give the first construction of extractable one-way functions assuming only standard hardness assumptions (e.g. the subexponential Learning with Errors Assumption).
Our functions are extractable against adversaries with bounded polynomial advice and unbounded polynomial running time. We then use these functions to construct the first 2-message zero-knowledge arguments and 3-message zero-knowledge arguments of knowledge, against the same class of adversarial verifiers, from essentially the same assumptions.

The construction uses ideas from [Barak, FOCS01] and [Barak, Lindell, and Vadhan, FOCS03], and rely on the recent breakthrough construction of privately verifiable $\\P$-delegation schemes [Kalai, Raz, and Rothblum]. The extraction procedure uses the program evaluating $f$ in a non-black-box way, which we show to be necessary.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Knowledge Extraction &middot; Extractable Functions &middot; Zero-Knowledge &middot; Non-Black-Box Techniques</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Program obfuscation</h3>

    <p class="text-gray-300">Program obfuscation, namely the task of making code unintelligible while preserving its functionality, has been long considered to be a holy grail of cryptography, with diverse and far reaching applications. The rigorous treatment of obfuscation was initiated by Barak et al. <a href="#page-9-2">[BGI</a>+01], who formulated a number of definitions of security for this task. However, until very recently, we only knew how to obfuscate a number of specific and restricted classes of programs under <em>any</em> of these definitions. Furthermore, Barak et al. demonstrated a class of programs that are <em>unobfuscatable</em> according to a natural definition, namely virtual black box (VBB) obfuscation, which guarantees that access to the obfuscated program gives no more power than access to an impenetrable black box with the same input-output functionality. Impossibility results for more natural classes of programs, with respect to stronger variants of VBB obfuscation, subsequently followed <a href="#page-10-0">[GK05]</a>.</p>

    <p class="text-gray-300">All of this changed with the work by Garg et al. <a href="#page-10-1">[GGH</a>+13b] who proposed a candidate construction of general-purpose obfuscators. They show that, under algebraic assumptions closely related to multilinear</p>

    <p class="text-gray-300"><sup>&lowast;</sup>Tel Aviv University. Email: nirbitan@tau.ac.il. Supported by an IBM Ph.D. Fellowship, the Check Point Institute for Information Security, and an ISF grant 20006317.</p>

    <p class="text-gray-300"><sup>&dagger;</sup>Boston University and Tel Aviv University. Email: canetti@bu.edu. Supported by the Check Point Institute for Information Security, an ISF grant 20006317, an NSF EAGER grant, and an NSF Algorithmic foundations grant 1218461.</p>

    <p class="text-gray-300"><sup>&Dagger;</sup>Boston University. Email: omer@bu.edu. Supported by the Simons award for graduate students in theoretical computer science and an NSF Algorithmic foundations grant 1218461.</p>

    <p class="text-gray-300"><sup>&sect;</sup>Efi Arazi School of Computer Science, IDC Herzliya, Israel. Email: alon.rosen@idc.ac.il. Supported by ISF grant no. 1255/12 and by the ERC under the EU's Seventh Framework Programme (FP/2007-2013) ERC Grant Agreement n. 307952.</p>

    <p class="text-gray-300">maps <a href="#page-10-2">[GGH13a,</a> <a href="#page-9-3">CLT13]</a>, their construction satisfies the relaxed notion of <em>indistinguishability obfuscation</em> (iO) <a href="#page-9-2">[BGI</a>+01], for which no impossibility results are known. The notion of iO only requires that it is hard to distinguish an obfuscation of C<sup>0</sup> from an obfuscation of C1, for any two circuits C<sup>0</sup> and C<sup>1</sup> of the same size that compute the exact same function.</p>

    <p class="text-gray-300">The security of the Garg et al. construction is based on a specific family of intractability assumptions (different for any obfuscated function). Being introduced only recently, these assumptions are still not wellunderstood, though several recent works have verified the validity of the constructions (or variants thereof) in idealized algebraic models <a href="#page-9-4">[CV13,</a> <a href="#page-9-5">BR13,</a> <a href="#page-9-6">BGTK</a>+13]. In fact, in these models the construction is even shown to obtain the stronger VBB notion.</p>

    <p class="text-gray-300">A priori, it is not clear how strong or meaningful is the iO notion of security. However, as observed in <a href="#page-9-2">[BGI</a>+01, <a href="#page-10-3">GR07]</a>, iO is &quot;best possible,&quot; in the sense that <em>if</em> a class of programs is obfuscatable according to some notion of security, then a general iO obfuscator, applied to this class of programs, will provide essentially the same security guarantee. Furthermore, several recent works <a href="#page-10-1">[GGH</a>+13b, <a href="#page-11-0">SW13,</a> <a href="#page-10-4">HSW13,</a> <a href="#page-10-5">GGHR13]</a> showed that general iO obfuscation can be combined with more standard cryptographic primitives to construct many powerful primitives such as functional encryption, public-key encryption from one way functions, attribute-based encryption, as well as NIZKs, CCA encryption, 2-message multi-party computation <a href="#page-10-5">[GGHR13]</a>, deniable encryption, and more. Despite these dramatic advances, many questions are still open and the full range of implications of iO for all circuits still seems far from being well understood.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Extractable Functions</h3>

    <p class="text-gray-300">The concept of extractable functions originates with the work of Damgard over 20 years ago <a href="#page-10-6">[Dam92]</a>, &#730; which first formulated the &quot;knowledge of exponent assumption&quot; (KEA). The KEA notion, with respect to a group G, says that for any adversary A, there exists an extractor E, such that whenever A, given two random generators (g, h) of G outputs two group elements of the form (g x , h<sup>x</sup> ) for some x, then E, given the same (g, h), outputs x. Variants of this assumption have been used in the context of CCA and plaintext aware encryption, zero knowledge, non-interactive succinct arguments and other primitives, e.g., <a href="#page-10-6">[Dam92,</a> <a href="#page-10-7">HT98,</a> <a href="#page-9-7">BP04a,</a> <a href="#page-9-8">BP04b,</a> <a href="#page-10-8">Gro10,</a> <a href="#page-9-9">BSW12,</a> <a href="#page-10-9">GS12]</a>.</p>

    <p class="text-gray-300">Abstracting from this assumption, Canetti and Dakdouk <a href="#page-9-10">[CD08,</a> <a href="#page-9-11">CD09]</a> defined the notion of <em>extractable function families</em>. Similarly to KEA, a family of functions F is extractable if for any adversary A there exists an extractor E, such that whenever A, given a random key e for a function f<sup>e</sup> &isin; F, outputs an element y in the image of fe, then E, given the same e, outputs a preimage of y. Intuitively, this means that the &quot;only way&quot; to generate a value in the image of f<sup>e</sup> is to &quot;honestly&quot; apply f<sup>e</sup> on some chosen input. When F has additional hardness properties (such as one-wayness or collision resistance), this abstraction has proven to be quite powerful <a href="#page-9-11">[CD09,</a> <a href="#page-8-0">BCCT12,</a> <a href="#page-10-10">DFH12,</a> <a href="#page-10-11">GLR11]</a>.</p>

    <p class="text-gray-300">Different formulations of assumptions of this kind exhibit widely different properties. While variants differ in several aspects, let us concentrate on a particular aspect: the &quot;advice&quot;, or &quot;auxiliary information&quot; available to the adversary and extractor. One straightforward formulation requires that, for any possible adversary (modeled as a uniform algorithm) there exists an extractor (again, modeled as a uniform algorithm) that successfully extracts as described above, given the adversary's coin tosses. An alternative is to model both the adversary and the extractor as non-uniform families of polysize circuits.</p>

    <p class="text-gray-300">However, neither formulation suffices when using extractable functions with other components in a larger cryptographic scheme or protocol. Indeed, during the execution of such a protocol or scheme, an adversary A may gather information z from other components and use it as <em>additional</em> auxiliary input when evaluating the extractable function. While, in the non-uniform definition, for every z, there exists an extractor for A(z, &middot;), a reduction/simulator might not be able to efficiently find this extractor. Similar issues are encountered in various cryptographic contexts that involve composition: a classic example, from the context of zero-knowledge, is in proving that zero-knowledge is closed under sequential composition. There, the solution is to require a stronger notion of auxiliary-input zero-knowledge.</p>

    <p class="text-gray-300">In the context of extractable functions, the solution is to require a single extractor that can handle any auxiliary information z gathered by the adversary. Specifically, we require that for any polytime adversary A there should exist a polytime extractor E such that extraction succeeds <em>when</em> A <em>and</em> E <em>are given the same advice string</em> z<em>.</em> That is, for any polysize z, and for a randomly chosen key e, the probability that A, given (z, e) outputs a value y in the image of f<sup>e</sup> and E, given (z, e), does not output a preimage of y, is negligible. We call this property <em>auxiliary-input</em> extractability.</p>

    <p class="text-gray-300">Indeed, this notion is needed in order to use extractable functions to obtain the standard notion of auxiliary-input zero-knowledge. In certain cases, auxiliary-input extractability can be relaxed to consider only the case where the common auxiliary input is taken from some specific distribution that captures the 'possible' auxiliary information in a given system (see e.g. <a href="#page-8-0">[BCCT12]</a>).</p>

    <p class="text-gray-300">Do auxiliary-input extractable functions exist? With one recent exception, in which the adversary is assumed to have only bounded-length advice <a href="#page-9-0">[BCP13]</a>, we do not have any candidate extractable one-way functions with an explicit, constructive extraction algorithm under <em>any</em> of the above formulations. Instead, existence of such an extractor is merely <em>assumed</em> (e.g., <a href="#page-10-6">[Dam92,</a> <a href="#page-9-11">CD09,</a> <a href="#page-8-0">BCCT12,</a> <a href="#page-10-8">Gro10,</a> <a href="#page-10-12">GGPR13]</a>. Such assumptions are arguably not satisfying. In particular, they do not qualify as &quot;efficiently falsifiable&quot; <a href="#page-11-1">[Nao03]</a>; namely, unlike standard assumptions where it possible to algorithmically study the best possible &quot;breakers&quot;, here we do not even have an algorithmic way to test whether a given adversary A breaks the assumption.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Our Result</h3>

    <p class="text-gray-300">Auxiliary-input extractability is a strong requirement: the auxiliary-input z may potentially encode arbitrary circuits, which may be executed by the adversary, meaning that the extractor needs to extract from arbitrary circuits. Given our current lack of understanding of non-black-box extraction techniques, the latter further decreases our confidence in such assumptions. Furthermore, the need to extract from arbitrary code reveals a clear tension between extractable functions and obfuscation: if z contains obfuscated code, how can we expect the extractor to algorithmically extract useful information out of it?</p>

    <p class="text-gray-300">We show that general iO suffices to make this intuition rigorous:</p>

    <p class="text-gray-300">Theorem 1.1. <em>If there exist indistinguishability obfuscators for all circuits, then there do not exist one-way functions that are auxiliary-input extractable.</em></p>

    <p class="text-gray-300">So, is the knowledge of exponent assumption wrong? Originally <a href="#page-10-6">[Dam92]</a>, the knowledge of exponent assumption (KEA) was not stated with auxiliary-input extractability, but rather according to the notion where every adversary A has an extractor E, and the only joint extra information is the adversary's coin tosses and key for the function. In particular, given a non-uniform adversary A with an obfuscated code as advice z, the extractor is allowed to have a different advice z 0 , representing the &quot;deobfuscated&quot; code. Indeed, our result does not rule out such a notion of extraction (even assuming iO for all cicruits). Our result does not disvalidate the intuition that &quot;the only way&quot; to compute (g x , h<sup>x</sup> ), given (g, h) is by &quot;knowing&quot; x. As we shall see, our adversary and auxiliary-input will be devised so that x is actually known, but only by an underlying obfuscated computation, and thus cannot be figured out efficiently from it by an external extractor.</p>

    <p class="text-gray-300">We also note that our result does not rule out extractable functions with respect to adversaries with bounded polynomial advice, such as those constructed in <a href="#page-9-0">[BCP13]</a>. Neither do they rule out extractable functions with respect to auxiliary input that is taken from specific distributions, e.g. the uniform distribution, required in [BCCT12].</p>

      <h3 id="sec-1.4" class="text-xl font-semibold mt-8">1.4 Proof Idea</h3>

    <p class="text-gray-300">To show that the existence of  <span class="math">i\\mathcal{O}</span>  rules out auxiliary-input extractable functions, we follow the basic intuition given above. We focus on the 'hardest scenario', where the auxiliary input z may represent an arbitrary malicious, and potentially obfuscated code. Specifically, we consider the following folklore case (sketched in [BCCT12, BC12, BC1+13, BCCT13]) where z is an obfuscation of a circuit  <span class="math">C_k</span>  that, given key e for an extractable  <span class="math">f_e</span> , chooses its preimage in an unpredictable way: it applies a pseudo-random function PRF <span class="math">_k</span>  to the key, and outputs the result  <span class="math">f_e(PRF_k(e))</span> .</p>

    <p class="text-gray-300">Note that an adversary, given such an obfuscated circuit as auxiliary input z, can run it on the key e for the extractable function and always obtain a proper image. The question is whether the extractor, given the same (e,z), can output a preimage. Intuitively, had we given the extractor black-box access to the circuit  <span class="math">C_k</span> , instead of an obfuscation of  <span class="math">C_k</span> , it would have to invert the one-way function to obtain such a preimage. Note that as an oracle  <span class="math">C_k</span>  only returns  <span class="math">f_{e&#x27;}(\\mathsf{PRF}_k(e&#x27;))</span>  for any query e', and thus by pseudo-randomness, finding a preimage of  <span class="math">f_e(\\mathsf{PRF}_k(e))</span>  is as hard as finding a preimage for a random image  <span class="math">f_e(u)</span> .</p>

    <p class="text-gray-300">If z is a VBB obfuscation of  <span class="math">C_k</span> , the above could be translated to an actual proof; but is that also the case if we use indistinguishability obfuscation? When  <span class="math">z = i\\mathcal{O}(C_k)</span> , it is not as clear what kind of information leaks on the PRF key k. Nevertheless, we show that the above argument can still be salvaged. The idea is to consider an alternative to the circuit  <span class="math">C_k</span>  that computes the same function, but without actually &quot;knowing&quot; PRF <span class="math">_k(e)</span> . This is achieved using the puncturing technique of Sahai and Waters [SW13].</p>

    <p class="text-gray-300">Specifically, instead of using any PRF family, we use a <em>puncturable PRF</em>. In such PRFs it is possible to puncture a given key k at an arbitrary point  <span class="math">x^*</span>  in the domain of the function. The punctured function PRF <span class="math">_{k_{x^*}}</span> , with punctured key  <span class="math">k_{x^*}</span> , preserves functionality at any other point, but hides any information on the point PRF <span class="math">_k(x^*)</span> ; namely, this value is pseudo-random, even given  <span class="math">(x^*, k_{x^*})</span> . As shown in several recent works [BW13, BGI13, KPTZ13], such puncturable PRFs follow from the [GGM86] construction.</p>

    <p class="text-gray-300">Using a puncturable PRF in the implementation of  <span class="math">C_k</span> , we can now show that if the extractor succeeds in finding a preimage of  <span class="math">y = f_e(\\mathsf{PRF}_k(e))</span> , it would also succeed had we provided it with an obfuscation of the alternative circuit  <span class="math">C_{k_e,y}</span> . The circuit  <span class="math">C_{k_e,y}</span>  computes the same function as  <span class="math">C_k</span> , but in a different way: it only has the punctured key  <span class="math">k_e</span> , and has the value  <span class="math">y = f_e(\\mathsf{PRF}_k(e))</span>  directly hardwired into it, so that it does not have to evaluate the PRF in order to compute it. Thus, the fact that the extractor still succeeds follows by the guarantee of indistinguishability obfuscation. However, now by the pseudo-randomness guarantee at the punctured point e, we know that  <span class="math">\\mathsf{PRF}_k(e)</span>  is pseudo random, and thus the extractor can be used to invert the one-way function  <span class="math">f_e</span>  from scratch.</p>

    <p class="text-gray-300">Finally, we note that since puncturable PRFs can be constructed from one-way functions, and any EOWF is in particular a OWF, it follows that the impossibility of EOWFs is implied by indistinguishability obfuscation without any further assumptions.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Definitions</h2>

    <p class="text-gray-300">We define extractable one-way functions, indistinguishability obfuscation, and puncturable pseudo-random functions.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Auxiliary-Input Extractable One-Way Functions</h3>

    <p class="text-gray-300">In this paper, we focus attention to extractable one-way functions. Our results directly extend to stronger extractable function primitives, such as extractable collision-resistant hashing, and extractable commitments.</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (Auxiliary-input EOWFs [CD08]). Let  <span class="math">\\ell, \\ell&#x27;, m</span>  be polynomially bounded length functions. An efficiently computable family of functions</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F} = \\left\\{ f_e : \\{0, 1\\}^{\\ell(n)} \\to \\{0, 1\\}^{\\ell&#x27;(n)} \\mid e \\in \\{0, 1\\}^{m(n)}, n \\in \\mathbb{N} \\right\\} ,</span>$</p>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler  <span class="math">K_{\\mathcal{F}}</span> , is an auxiliary-input extractable one-way function if it satisfies:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>One-wayness:</strong> For PPT A, large enough security parameter  <span class="math">n \\in \\mathbb{N}</span> , and  <span class="math">z \\in \\{0,1\\}^{\\text{poly}(n)}</span> :</li>
    </ol>

    <p class="text-gray-300">
<span class="math">$\\Pr_{\\substack{e \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^n) \\\\ x \\leftarrow \\{0,1\\}^{\\ell(n)}}} \\left[ \\begin{array}{c} x&#x27; \\leftarrow \\mathcal{A}(e, f_e(x); z) \\\\ f_e(x&#x27;) = f_e(x) \\end{array} \\right] \\leq \\operatorname{negl}(n) .</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Extractability:</strong> For any PPT adversary A, there exists a PPT extractor  <span class="math">\\mathcal{E}</span>  such that, for any large enough security parameter  <span class="math">n \\in \\mathbb{N}</span> , and advice  <span class="math">z \\in \\{0, 1\\}^{\\text{poly}(n)}</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\Pr_{e \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^n)} \\left[ \\begin{array}{c} y \\leftarrow \\mathcal{A}(e; z) \\\\ \\exists x : f_e(x) = y \\end{array} \\wedge \\begin{array}{c} x&#x27; \\leftarrow \\mathcal{E}(e; z) \\\\ f_e(x&#x27;) \\neq y \\end{array} \\right] \\leq \\operatorname{negl}(n)</span>$
(1)</p>

    <p class="text-gray-300">Remark 2.1 (On the auxiliary input). For our results it is critical that the extractor  <span class="math">\\mathcal{E}</span>  receives the same auxiliary input z, which could be of arbitrary polynomial length, as  <span class="math">\\mathcal{A}</span>  does, and has to operate efficiently with respect to this auxiliary input. This flavor of definition is standard in defining auxiliary-input security, e.g., auxiliary-input zero-knowledge, and auxiliary-input obfuscation. Additional motivation for this formulation appears in the introduction.</p>

    <p class="text-gray-300">Still, one could consider weaker notions of extractability which may still suffice for some applications, and are not ruled out by our results, even assuming indistinguishability obfuscation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Separate auxiliary inputs: Here we only require that for any  <span class="math">\\mathcal{A}</span>  with non-uniform advice  <span class="math">z_s</span> , there exists an extractor with non-uniform advice  <span class="math">z_{s&#x27;}</span> , which may arbitrarily and inefficiently depend on  <span class="math">z_s</span> , and could be of an arbitrary polynomial size. This weaker notion may be useful in cases where the adversary's auxiliary inputs do not depend on computations that may have taken place in the system before the extractable function is used. Examples include CCA and plaintext-aware encryption with non-uniform security reductions [Dam92, BP04b], and weak versions of 3-message zero-knowledge where the where the verifier doe not get auxiliary information and simulator is allowed to be more non-uniform than the verifier [HT98, BP04a].</li>
      <li>Common but benign auxiliary input: Here A and S, in addition to arbitrary separate auxiliary-inputs  <span class="math">z_s</span>  and  <span class="math">z_{s&#x27;}</span> , respectively, get common auxiliary input z as that id drawn from a specific distribution that is <em>conjectured</em> to be 'benign', in the sense that it is unlikely to encode a malicious obfuscation. For instance, the distribution can be uniform or an encryption of a random string. Examples where this is sufficient includes essentially all the works on succinct non-interactive arguments (SNARGs), succinct NIZKs, and targeted malleability that rely on extractable primitives [DCL08, Mie08, Gro10, GLR11, BSW12, BCCT12, BC12, DFH12, Lip12, BCCT13, BCI<sup>+</sup>13, GGPR13, Lip13].</li>
    </ul>

    <p class="text-gray-300">&bull; <strong>Bounded auxiliary input:</strong> Here there is a bound on the size of the auxiliary-input that the adversary may get. EOWFs according to this notion are constructed in [BCP13] from standard assumptions, and shown to suffice for 3-message arguments of knowledge and 2-message arguments that are bounded auxiliary-input zero-knowledge.</p>

    <p class="text-gray-300">Finally, we remark that one may consider adversaries with both separate and common dynamic auxiliary input. That is, for any  <span class="math">\\mathcal{A}</span>  and auxiliary input  <span class="math">z_s</span>  there should exist  <span class="math">\\mathcal{S}</span>  and auxiliary input  <span class="math">z_{s&#x27;}</span>  such that (1) holds for any common auxiliary input z. This notion is also ruled out by our techniques.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Indistinguishability Obfuscation</h3>

    <p class="text-gray-300">Indistinguishability obfuscation was introduced in [BGI<sup>+</sup>01] and given a candidate construction in [GGH<sup>+</sup>13b], and subsequently in [BR13, BGTK<sup>+</sup>13, CV13].</p>

    <p class="text-gray-300"><strong>Definition 2.2</strong> (Indistinguishability obfuscation [BGI <span class="math">^+</span> 01]). A PPT algorithm  <span class="math">i\\mathcal{O}</span>  is said to be an indistinguishability obfuscator (INDO) for  <span class="math">\\mathcal{C}</span> , if it satisfies:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Functionality: For any  <span class="math">C \\in \\mathcal{C}</span> ,</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\Pr_{i\\mathcal{O}}\\left[\\forall x: i\\mathcal{O}(1^n, C)(x) = C(x)\\right] = 1.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Indistinguishability:</strong> For any ensemble of circuit pairs  <span class="math">\\{(C_n^{(1)}, C_n^{(2)}) \\in \\mathcal{C} \\times \\mathcal{C}\\}_{n \\in \\mathbb{N}}</span> , where the two circuits in each pair are of the same size and functionality, it holds that:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\left\\{ i\\mathcal{O}(1^n, C_n^{(1)}) \\right\\}_{n \\in \\mathbb{N}} \\approx_c \\left\\{ i\\mathcal{O}(1^n, C_n^{(2)}) \\right\\}_{n \\in \\mathbb{N}} .</span>$</p>

    <p class="text-gray-300">For ease of notation, we shall often omit  <span class="math">1^n</span>  from the input to the obfuscator.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Puncturable PRFs</h3>

    <p class="text-gray-300">We next define puncturable PRFs. We consider a simple case of the puncturable PRFs where any PRF might be punctured at a single point. The definition is formulated as in [SW13].</p>

    <p class="text-gray-300"><strong>Definition 2.3</strong> (Puncturable PRFs). Let  <span class="math">\\ell</span> , m be polynomially bounded length functions. An efficiently computable family of functions</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{PRF} = \\left\\{ \\mathsf{PRF}_k : \\{0,1\\}^{m(n)} \\to \\{0,1\\}^{\\ell(n)} \\; \\middle| \\; k \\in \\{0,1\\}^n, n \\in \\mathbb{N} \\right\\} \\; ,</span>$</p>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler  <span class="math">\\mathcal{K}_{PRF}</span> , is a puncturable PRF if there exists a puncturing algorithm Punc that takes as input a key  <span class="math">k \\in \\{0,1\\}^n</span> , and a point  <span class="math">x^*</span> , and outputs a punctured key  <span class="math">k_{x^*}</span> , so that the following conditions are satisfied:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Functionality is preserved under puncturing: For every  <span class="math">x^* \\in \\{0,1\\}^{\\ell(n)}</span> ,</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\Pr_{k \\leftarrow \\mathcal{K}_{\\mathcal{PRF}}(1^n)} \\left[ \\forall x \\neq x^* : \\mathsf{PRF}_k(x) = \\mathsf{PRF}_{k_{x^*}}(x) \\mid k_{x^*} = \\mathsf{Punc}(k, x^*) \\right] = 1 \\ .</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Indistinguishability at punctured points:</strong> The following ensembles are computationally indistinguishable:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ \\ \\{x^*, k_{x^*}, \\mathsf{PRF}_k(x^*) \\mid k \\leftarrow \\mathcal{K}_{\\mathcal{PRF}}(1^n), k_{x^*} = \\mathsf{Punc}(k, x^*)\\}_{x^* \\in \\{0,1\\}^{m(n)}, n \\in \\mathbb{N}}</span></li>
      <li><span class="math">\\bullet \\ \\left\\{ x^*, k_{x^*}, u \\mid k \\leftarrow \\mathcal{K}_{\\mathcal{PRF}}(1^n), k_{x^*} = \\mathsf{Punc}(k, x^*), u \\leftarrow \\{0, 1\\}^{\\ell(n)} \\right\\}_{x^* \\in \\{0, 1\\}^{m(n)}, n \\in \\mathbb{N}}.</span></li>
    </ul>

    <p class="text-gray-300">To be explicit, we include  <span class="math">x^*</span>  in the distribution; throughout, we shall assume for simplicity that a punctured key  <span class="math">k_{x^*}</span>  includes  <span class="math">x^*</span>  in the clear. As shown in [BGI13, BW13, KPTZ13], the GGM [GGM86] PRF yield puncturable PRFs as defined above.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 From <span class="math">i\\mathcal{O}</span> to Impossibility of Extractable Functions</h2>

    <p class="text-gray-300">We now show that if indistinguishability obfuscators exist, there do not exist EOWFs according to Definition 2.1. For this purpose, assuming the existence of an EOWF family  <span class="math">\\mathcal{F}</span> , we shall describe an adversary  <span class="math">\\mathcal{A}</span>  and a distribution  <span class="math">\\mathcal{Z}</span>  on auxiliary inputs, such that any extractor fails, for auxiliary inputs sampled from  <span class="math">\\mathcal{Z}</span> .</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 The Universal Adversary</h3>

    <p class="text-gray-300">We consider a universal PPT adversary  <span class="math">\\mathcal{A}</span>  that given  <span class="math">(e, z) \\in \\{0, 1\\}^{m(n)} \\times \\{0, 1\\}^{\\text{poly}(n)}</span> , parses z as a circuit and returns z(e).</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 The Auxiliary Input Distribution.</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{F}</span>  be a family of extractable one-way functions and let  <span class="math">\\mathcal{PRF}</span>  be a puncturable pseudo-random function family. We start by defining two families of circuits</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C} = \\left\\{ C_k : \\{0, 1\\}^{m(n)} \\to \\{0, 1\\}^{\\ell&#x27;(n)} \\mid k \\in \\{0, 1\\}^n, n \\in \\mathbb{N} \\right\\} ,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C}^* = \\left\\{ C_{k_{e^*}, y^*} : \\{0, 1\\}^{m(n)} \\to \\{0, 1\\}^{\\ell&#x27;(n)} \\mid k \\in \\{0, 1\\}^n, n \\in \\mathbb{N} \\right\\} .</span>$</p>

    <p class="text-gray-300">The circuit  <span class="math">C_k</span> , given a key e for an EOWF, applies  <span class="math">\\mathsf{PRF}_k</span>  to e, obtains an input x, and returns the result of applying the EOWF  <span class="math">f_e</span>  to x.</p>

    <p class="text-gray-300"><span class="math">C_k</span></p>

    <p class="text-gray-300"><strong>Hardwired:</strong> a PRF key  <span class="math">k \\in \\{0, 1\\}^n</span> .</p>

    <p class="text-gray-300"><strong>Input:</strong> an EOWF key  <span class="math">e \\in \\{0, 1\\}^{m(n)}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">x = \\mathsf{PRF}_k(e)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return  <span class="math">y = f_e(x)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 1: The circuit  <span class="math">C_k</span> .</p>

    <p class="text-gray-300">The circuit  <span class="math">C_{k_{e^*},y^*}</span> , has a hardwired PRF key  <span class="math">k_{e^*}</span>  that was derived from k by puncturing it at the point  <span class="math">e^*</span> . In addition, it has hardwired an output  <span class="math">y^*</span>  to replace the punctured result. In particular, when  <span class="math">y^* = f_{e^*}(\\mathsf{PRF}_k(e^*))</span>  the circuit  <span class="math">C_{k_{e^*},y^*}</span>  computes the same function as  <span class="math">C_k</span> .</p>

    <p class="text-gray-300">We are now ready to define our auxiliary input distribution  <span class="math">\\mathcal{Z} = \\{Z_n\\}_{n \\in \\mathbb{N}}</span> . Let s = s(n) be the maximal size of circuits in either  <span class="math">\\mathcal{C}</span>  or  <span class="math">\\mathcal{C}^*</span> , corresponding to security parameter n, and denote by  <span class="math">[C]_s</span>  a</p>

    <p class="text-gray-300"><span class="math">$C_{k_{e^*},y^*}</span>$</p>

    <p class="text-gray-300"><strong>Hardwired:</strong> a punctured PRF key  <span class="math">k_{e^*} = \\text{Punc}(k, e^*)</span>  and  <span class="math">y^* \\in \\{0, 1\\}^{\\ell&#x27;(n)}</span> .</p>

    <p class="text-gray-300"><strong>Input:</strong> an EOWF key  <span class="math">e \\in \\{0,1\\}^{m(n)}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">e \\neq e^*</span> , compute  <span class="math">x = \\mathsf{PRF}_{k_{e^*}}(e)</span> , and return  <span class="math">y = f_e(x)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">e = e^*</span> , return  <span class="math">y^*</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 2: The circuit  <span class="math">C_{k_{a^*},y^*}</span> .</p>

    <p class="text-gray-300">circuit C padded with zeros to size s. Let  <span class="math">i\\mathcal{O}</span>  be an indistinguishability obfuscator. The distribution  <span class="math">Z_n</span>  simply consists of an obfuscated (padded) circuit  <span class="math">C_k</span> .</p>

    <p class="text-gray-300"><span class="math">$Z_n</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample  <span class="math">k \\leftarrow \\mathcal{K}_{\\mathcal{PRF}}(1^n)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample an obfuscation  <span class="math">z \\leftarrow i\\mathcal{O}([C_k]_s)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output z.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 3: The auxiliary input distribution  <span class="math">Z_n</span> .</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 <span class="math">\\mathcal{A}</span> Does Not Have an Extractor</h3>

    <p class="text-gray-300">We next show that A cannot have any extractor  <span class="math">\\mathcal{E}</span>  satisfying Definition 2.1. In fact, we show a stronger claim; namely, that for the auxiliary input distribution  <span class="math">\\mathcal{Z}</span> , any extractor fails with overwhelming probability.</p>

    <p class="text-gray-300"><strong>Proposition 3.1.</strong> Let  <span class="math">\\mathcal{E}</span>  be any PPT candidate extractor for  <span class="math">\\mathcal{A}</span>  then</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{e \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^n) \\\\ z \\leftarrow Z_n}} \\left[ \\begin{array}{c} y \\leftarrow \\mathcal{A}(e;z) \\\\ \\exists x : f_e(x) = y \\end{array} \\wedge \\begin{array}{c} x&#x27; \\leftarrow \\mathcal{E}(e;z) \\\\ f_e(x&#x27;) \\neq y \\end{array} \\right] \\geq 1 - \\operatorname{negl}(n) .</span>$</p>

    <p class="text-gray-300">We note that, since the key e is sampled above independently of the auxiliary input z, the above indeed disproves extractability.</p>

    <p class="text-gray-300">Proof of Proposition 3.1. First, we note that</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{e \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^n) \\\\ z \\leftarrow Z_n}} \\left[ \\begin{array}{c} y \\leftarrow \\mathcal{A}(e; z) \\\\ \\exists x : f_e(x) = y \\end{array} \\right] = 1 ;</span>$</p>

    <p class="text-gray-300">indeed, by the definition of A and  <span class="math">Z_n</span> , and the correctness of  <span class="math">i\\mathcal{O}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{A}(e,z) = z(e) = C_k(e) = f_e(\\mathsf{PRF}_k(e)) \\ ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">C_k \\in \\mathcal{C}</span>  is the circuit obfuscated in z, i.e.  <span class="math">z = i\\mathcal{O}([C_k]_s)</span> .</p>

    <p class="text-gray-300">Now, assume towards contradiction that, for infinitely many  <span class="math">n \\in \\mathbb{N}</span> , the extractor  <span class="math">\\mathcal{E}</span>  successfully outputs an image with noticeable probability  <span class="math">\\epsilon(n)</span> , i.e.</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{e \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^n) \\\\ z \\leftarrow Z_n}} \\left[ \\begin{array}{c} x&#x27; \\leftarrow \\mathcal{E}(e; z) \\\\ f_e(x&#x27;) = z(e) = f_e(\\mathsf{PRF}_k(e)) \\end{array} \\right] \\ge \\epsilon(n) \\ ,</span>$</p>

    <p class="text-gray-300">where as before,  <span class="math">z = i\\mathcal{O}([C_k]_s)</span> .</p>

    <p class="text-gray-300">Next, for every  <span class="math">e^*</span>  we consider an alternative distribution  <span class="math">Z_n(e^*,y^*)</span>  that, instead of sampling a circuit  <span class="math">C_k</span> , samples a circuit  <span class="math">C_{k_{e^*},y^*}</span> , by first sampling k as usual, and then computing  <span class="math">y^* = f_{e^*}(\\mathsf{PRF}_k(e^*))</span> , and the punctured key  <span class="math">k_{e^*}</span> . (Note that  <span class="math">Z_n(e^*,y^*)</span>  is actually only parameterized by  <span class="math">e^*</span> , we add  <span class="math">y^*</span>  to the notation, to be more explicit.) We claim that the extractor still succeeds in finding a preimage, i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{e^* \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^n) \\\\ z^* \\leftarrow Z_n(e^*, y^*)}} \\left[ \\begin{array}{c} x&#x27; \\leftarrow \\mathcal{E}(e^*; z^*) \\\\ f_{e^*}(x&#x27;) = z^*(e^*) = y^* = f_{e^*}(\\mathsf{PRF}_k(e^*)) \\end{array} \\right] \\ge \\epsilon(n) - \\mathrm{negl}(n) \\ .</span>$</p>

    <p class="text-gray-300">This follows from the fact that, for any  <span class="math">e^*</span>  and k,  <span class="math">C_k</span>  and  <span class="math">C_{k_{e^*},y^*}</span>  compute the same function, and the  <span class="math">i\\mathcal{O}</span>  indistinguishability guarantee.</p>

    <p class="text-gray-300">Next, we consider another experiment where  <span class="math">Z_n(e^*,y^*)</span>  is altered to a new distribution  <span class="math">Z_n(e^*,u)</span>  that, instead of sampling  <span class="math">y^* = f_{e^*}(\\mathsf{PRF}_k(e^*))</span>  in  <span class="math">C_{k_{e^*},y^*}</span> , samples  <span class="math">y^* = f_{e^*}(u)</span> , for an independent random  <span class="math">u \\leftarrow \\{0,1\\}^\\ell</span> . We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{e^* \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^n) \\\\ z^* \\leftarrow Z_n(e^*, u)}} \\left[ \\begin{array}{c} x&#x27; \\leftarrow \\mathcal{E}(e^*; z^*) \\\\ f_{e^*}(x&#x27;) = z^*(e^*) = y^* = f_{e^*}(u) \\end{array} \\right] \\ge \\epsilon(n) - \\operatorname{negl}(n) ;</span>$</p>

    <p class="text-gray-300">indeed, this follows from the fact that  <span class="math">PRF_k(e^*)</span>  is pseudo-random, even given the punctured key  <span class="math">k_{e^*}</span> .</p>

    <p class="text-gray-300">This means that  <span class="math">\\mathcal{E}</span>  can be used to break the one-wayness of  <span class="math">\\mathcal{F}</span> . Indeed, given a random key  <span class="math">e^*</span> , and a challenge  <span class="math">y^* = f_{e^*}(u)</span> , an inverter can simply sample a punctured  <span class="math">k_{e^*}</span>  on its own, construct the circuit  <span class="math">C_{k_{e^*},y^*}</span> , with its challenge  <span class="math">y^*</span>  hardwired in, and sample an obfuscation  <span class="math">z^* \\leftarrow i\\mathcal{O}(C_{k_{e^*},y^*})</span> . Finally, it runs  <span class="math">\\mathcal{E}(e^*,z^*)</span>  to invert  <span class="math">y^*</span> , with the same probability  <span class="math">\\epsilon(n) - \\operatorname{negl}(n)</span> .</p>

    <p class="text-gray-300">Remark 3.1 (Separate vs. common auxiliary input). As mentioned in Remark 2.1, our proof also holds in the case that the extractor  <span class="math">\\mathcal{E}</span>  is allowed extra (separate) auxiliary input s, which does not depend on the (common) auxiliary input z (provided that the EOWF is one-way against non-uniform adversaries).</p>

    <p class="text-gray-300">Finally, we note that since puncturable PRFs can be constructed from one-way functions, and any EOWF is, in particular, a OWF, the impossibility of auxiliary-input EOWFs is implied by indistinguishability obfuscation without any further assumptions. Thus, Theorem 1.1 follows.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[BC12] Nir Bitansky and Alessandro Chiesa. Succinct arguments from multi-prover interactive proofs and their efficiency benefits. In <em>CRYPTO</em>, pages 255&ndash;272, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>Proceedings</em> of the 3rd Innovations in Theoretical Computer Science Conference, ITCS '12, pages 326&ndash;349, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for snarks and proof-carrying data. In <em>STOC</em>, pages 111&ndash;120, 2013.</p></li>
      <li><p class="text-gray-300">[BCI+13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In <em>TCC</em>, pages 315&ndash;333, 2013.</p></li>
      <li><p class="text-gray-300">[BCP13] Nir Bitansky, Ran Canetti, and Omer Paneth. How to construct extractable one-way functions against uniform adversaries. <em>IACR Cryptology ePrint Archive</em>, 2013:468, 2013.</p></li>
      <li><p class="text-gray-300">[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable oneway functions. In <em>Proceedings of the 46th Annual ACM Symposium on Theory of Computing</em>, STOC '14, 2014.</p></li>
      <li><p class="text-gray-300">[BGI+01] Boaz Barak, Oded Goldreich, Russell Impagliazzo, Steven Rudich, Amit Sahai, Salil P. Vadhan, and Ke Yang. On the (im)possibility of obfuscating programs. In <em>CRYPTO</em>, pages 1&ndash;18, 2001.</p></li>
      <li><p class="text-gray-300">[BGI13] Elette Boyle, Shafi Goldwasser, and Ioana Ivan. Functional signatures and pseudorandom functions. <em>IACR Cryptology ePrint Archive</em>, 2013:401, 2013.</p></li>
      <li><p class="text-gray-300">[BGTK+13] Boaz Barak, Sanjam Garg, Yael Tauman-Kalai, Omer Paneth, and Amit Sahai. Protecting obfuscation against algebraic attacks. <em>IACR Cryptology ePrint Archive</em>, 2013:631, 2013.</p></li>
      <li><p class="text-gray-300">[BP04a] Mihir Bellare and Adriana Palacio. The knowledge-of-exponent assumptions and 3-round zero-knowledge protocols. In <em>Proceedings of the 24th Annual International Cryptology Conference</em>, pages 273&ndash;289, 2004.</p></li>
      <li><p class="text-gray-300">[BP04b] Mihir Bellare and Adriana Palacio. Towards plaintext-aware public-key encryption without random oracles. In <em>ASIACRYPT</em>, pages 48&ndash;62, 2004.</p></li>
      <li><p class="text-gray-300">[BR13] Zvika Brakerski and Guy Rothblum. Virtual black-box obfuscation for all circuits via generic graded encoding. <em>IACR Cryptology ePrint Archive</em>, 2013:563, 2013.</p></li>
      <li><p class="text-gray-300">[BSW12] Dan Boneh, Gil Segev, and Brent Waters. Targeted malleability: homomorphic encryption for restricted computations. In <em>ITCS</em>, pages 350&ndash;366, 2012.</p></li>
      <li><p class="text-gray-300">[BW13] Dan Boneh and Brent Waters. Constrained pseudorandom functions and their applications. <em>IACR Cryptology ePrint Archive</em>, 2013:352, 2013.</p></li>
      <li><p class="text-gray-300">[CD08] Ran Canetti and Ronny Ramzi Dakdouk. Extractable perfectly one-way functions. In <em>Proceedings of the 35th International Colloquium on Automata, Languages and Programming</em>, pages 449&ndash;460, 2008.</p></li>
      <li><p class="text-gray-300">[CD09] Ran Canetti and Ronny Ramzi Dakdouk. Towards a theory of extractable functions. In <em>TCC</em>, pages 595&ndash;613, 2009.</p></li>
      <li><p class="text-gray-300">[CLT13] Jean-Sebastien Coron, Tancr &acute; ede Lepoint, and Mehdi Tibouchi. Practical multilinear maps \` over the integers. In <em>CRYPTO (1)</em>, pages 476&ndash;493, 2013.</p></li>
      <li><p class="text-gray-300">[CV13] Ran Canetti and Vinod Vaikuntanathan. Obfuscating branching programs using black-box pseudo-free groups. <em>IACR Cryptology ePrint Archive</em>, 2013:500, 2013.</p></li>
      <li><p class="text-gray-300">[Dam92] Ivan Damgard. Towards practical public key systems secure against chosen ciphertext attacks. &#730; In <em>Proceedings of CRYPTO91</em>, pages 445&ndash;456, 1992.</p></li>
      <li><p class="text-gray-300">[DCL08] Giovanni Di Crescenzo and Helger Lipmaa. Succinct NP proofs from an extractability assumption. In <em>Proceedings of the 4th Conference on Computability in Europe</em>, pages 175&ndash;185, 2008.</p></li>
      <li><p class="text-gray-300">[DFH12] Ivan Damgard, Sebastian Faust, and Carmit Hazay. Secure two-party computation with low &#730; communication. In <em>TCC</em>, pages 54&ndash;74, 2012.</p></li>
      <li><p class="text-gray-300">[GGH13a] Sanjam Garg, Craig Gentry, and Shai Halevi. Candidate multilinear maps from ideal lattices. In <em>EUROCRYPT</em>, pages 1&ndash;17, 2013.</p></li>
      <li><p class="text-gray-300">[GGH+13b] Sanjam Garg, Craig Gentry, Shai Halevi, Mariana Raykova, Amit Sahai, and Brent Waters. Candidate indistinguishability obfuscation and functional encryption for all circuits. In <em>FOCS</em>, 2013.</p></li>
      <li><p class="text-gray-300">[GGHR13] Sanjam Garg, Craig Gentry, Shai Halevi, and Mariana Raykova. Two-round secure mpc from indistinguishability obfuscation. <em>IACR Cryptology ePrint Archive</em>, 2013:601, 2013.</p></li>
      <li><p class="text-gray-300">[GGM86] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. <em>J. ACM</em>, 33(4):792&ndash;807, 1986.</p></li>
      <li><p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In <em>EUROCRYPT</em>, pages 626&ndash;645, 2013.</p></li>
      <li><p class="text-gray-300">[GK05] Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In <em>FOCS</em>, pages 553&ndash;562, 2005.</p></li>
      <li><p class="text-gray-300">[GLR11] Shafi Goldwasser, Huijia Lin, and Aviad Rubinstein. Delegation of computation without rejection problem from designated verifier CS-proofs. Cryptology ePrint Archive, Report 2011/456, 2011.</p></li>
      <li><p class="text-gray-300">[GR07] Shafi Goldwasser and Guy N. Rothblum. On best-possible obfuscation. In <em>TCC</em>, pages 194&ndash; 213, 2007.</p></li>
      <li><p class="text-gray-300">[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In <em>ASIACRYPT</em>, pages 321&ndash;340, 2010.</p></li>
      <li><p class="text-gray-300">[GS12] Divya Gupta and Amit Sahai. On constant-round concurrent zero-knowledge from a knowledge assumption. <em>IACR Cryptology ePrint Archive</em>, 2012:572, 2012.</p></li>
      <li><p class="text-gray-300">[HSW13] Susan Hohenberger, Amit Sahai, and Brent Waters. Replacing a random oracle: Full domain hash from indistinguishability obfuscation. <em>IACR Cryptology ePrint Archive</em>, 2013:509, 2013.</p></li>
      <li><p class="text-gray-300">[HT98] Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge protocols. In <em>Proceedings of the 18th Annual International Cryptology Conference</em>, pages 408&ndash;423, 1998.</p></li>
      <li><p class="text-gray-300">[KPTZ13] Aggelos Kiayias, Stavros Papadopoulos, Nikos Triandopoulos, and Thomas Zacharias. Delegatable pseudorandom functions and applications. <em>IACR Cryptology ePrint Archive</em>, 2013:379, 2013.</p></li>
      <li><p class="text-gray-300">[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zeroknowledge arguments. In <em>TCC</em>, pages 169&ndash;189, 2012.</p></li>
      <li><p class="text-gray-300">[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. <em>IACR Cryptology ePrint Archive</em>, 2013:121, 2013.</p></li>
      <li><p class="text-gray-300">[Mie08] Thilo Mie. Polylogarithmic two-round argument systems. <em>Journal of Mathematical Cryptology</em>, 2(4):343&ndash;363, 2008.</p></li>
      <li><p class="text-gray-300">[Nao03] Moni Naor. On cryptographic assumptions and challenges. In <em>Proceedings of the 23rd Annual International Cryptology Conference</em>, pages 96&ndash;109, 2003.</p></li>
      <li><p class="text-gray-300">[SW13] Amit Sahai and Brent Waters. How to use indistinguishability obfuscation: Deniable encryption, and more. <em>IACR Cryptology ePrint Archive</em>, 2013:454, 2013.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="How To Construct Extractable One-Way Functions Against Unifo... (2013/468)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/468
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="indistinguishability-obfuscation-vs-auxiliary-input-2013" />
  </article>
</BaseLayout>
