---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/641';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Indistinguishability Obfuscation vs. Auxiliary-Input Extractable Functions: One Must Fall';
const AUTHORS_HTML = 'Nir Bitansky, Ran Canetti, Omer Paneth, Alon Rosen';

const CONTENT = `    <p class="text-gray-300">How To Construct Extractable One-Way Functions Against Uniform Adversaries</p>

    <p class="text-gray-300">Nir Bitansky*, Ran Canetti†, and Omer Paneth‡</p>

    <p class="text-gray-300">Tel Aviv University and Boston University</p>

    <p class="text-gray-300">June 3, 2014</p>

    <p class="text-gray-300">This is an out of date draft. The paper was merged with <em>Indistinguishability Obfuscation vs. Auxiliary-Input Extractable Functions: One Must Fall</em> [BCPR13] to form <em>On the Existence of Extractable One-Way Functions</em> [BCPR14].</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">A function <span class="math">f</span> is extractable if it is possible to algorithmically “extract,” from any program that outputs a value <span class="math">y</span> in the image of <span class="math">f</span>, a preimage of <span class="math">y</span>. When combined with hardness properties such as one-wayness or collision-resistance, extractability has proven to be a powerful tool. However, so far, extractability has not been explicitly shown. Instead, it has only been considered as a non-standard <em>knowledge assumption</em> on certain functions.</p>

    <p class="text-gray-300">We give the first construction of extractable one-way functions assuming only standard hardness assumptions (e.g., subexponential security of Decision Diffie-Hellman or Quadratic Residousity). Our functions are extractable against adversaries with bounded polynomial advice and unbounded polynomial running time. We then use these functions to construct the first 2-message zero-knowledge arguments and 3-message zero-knowledge arguments of knowledge, against the same class of adversarial verifiers, from essentially the same assumptions.</p>

    <p class="text-gray-300">The construction uses ideas from [Barak, FOCS01] and [Barak, Lindell, and Vadhan, FOCS03], and rely on the recent breakthrough construction of privately verifiable P-delegation schemes [Kalai, Raz, and Rothblum]. The extraction procedure uses the program evaluating <span class="math">f</span> in a non-black-box way, which we show to be necessary.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The ability to argue about what adversarial programs “know” in the context of a given interaction is central to modern cryptography. A central facet of such argumentation is the ability to efficiently “extract” knowledge from the adversarial program, or alternatively to channel it into meaningful use. Establishing this ability is often a crucial step in security analysis of cryptographic protocols and schemes.</p>

    <p class="text-gray-300">One basic flavor of such extraction takes the form of security reductions; namely, efficiently transforming an adversarial program that breaks the security of the analyzed scheme into a program that performs some computational task that is believed to be hard. Examples include transforming a distinguisher for a pseudorandom generator into an inverter of the underlying one-way function [BM84, GL89,</p>

    <p class="text-gray-300">*Supported by an IBM Ph.D. Fellowship, the Check Point Institute for Information Security, and an ISF grant 20006317. Part of this research was conducted while visiting Boston University. †Supported by the Check Point Institute for Information Security, an ISF grant 20006317, and an NSF grant 1218461. ‡Supported by the Simons award for graduate students in theoretical computer science and NSF award 1218461. Part of this research was conducted while at Microsoft Research New England.</p>

    <p class="text-gray-300">HILL99]<em>, or transforming a cheating prover in a proof system into a collision-finder in the underlying function </em>[x10]*.</p>

    <p class="text-gray-300">Adversarial knowledge also plays a central role in formulating definitions of security: Here we often require that adversarial participants in a computation “know” their inputs to the computation. This is used as a means for guaranteeing global meaningfulness and secure composition of protocols, for instance in the context of proofs of knowledge and ideal-process based security <em>[x5, x4, x5]</em>.</p>

    <p class="text-gray-300">The ability to extract values from the adversary is also useful when <em>simulating</em> the adversary’s view in a given protocol, to establish privacy of secret inputs, as in the case of zero-knowledge or multi-party computation <em>[x11, x12]</em>. A quintessential example here is the Feige-Lapidot-Shamir paradigm <em>[x6]</em>, discussed in more detail below and used extensively in the protocol design literature.</p>

    <p class="text-gray-300">How is knowledge extracted? Traditionally, the basic technique for extracting knowledge from an adversary is to run it on multiple related inputs to deduce what it “knows” from the resulting outputs. In the context of interactive protocols (which will be in the focus of this work), this technique is known as rewinding. The power of the technique is in that it treats the adversary as a black-box and does not need to know anything regarding its “internals”. However, as a number of impossibility results for black-box reductions and simulation show, this technique is also quite limited. One main limitation of rewinding-based extraction is that it requires multiple rounds of interaction with the adversary. Indeed, proving security of candidate 3-message zero-knowledge protocols, succinct non-interactive arguments (SNARGs), and other tasks are out of the technique’s reach <em>[x11, x13]</em>.</p>

    <p class="text-gray-300">Starting with the work of Barak et al. <em>[x2]</em>, a handful of extraction techniques that go beyond the limitations of black-box extraction have been developed. These techniques use in an essential way having access to the actual adversarial program. However, these techniques too require at least several rounds of protocol interaction. Thus, like black-box rewinding techniques, do not work in the above contexts.</p>

    <p class="text-gray-300">Extractable functions. Originating in Damgård’s work <em>[x3]</em>, and abstracted by Canetti and Dakdouk <em>[x4, x5]</em>, the notion of <em>extractable functions</em> provides an alternative extraction method that does not rely on multiple rounds of interaction with the adversary. These are function families <span class="math">\\{f_{k}\\}</span> where, in addition to standard hardness properties, such as one-wayness or collision-resistance, any program <span class="math">M</span> that given <span class="math">k</span> outputs <span class="math">v</span> in the image of <span class="math">f_{k}</span> has an “extractor” <span class="math">\\mathsf{Ext}</span> that given <span class="math">k</span> and the code of <span class="math">M</span>, outputs a preimage of <span class="math">v</span>. As an expression to their power, extractable one-way functions are known to suffice for constructing 3-message zero-knowledge protocols <em>[x14, x1, x5]</em>. Extractable collision-resistant hash functions are known to suffice for constructing succinct non-interactive arguments (SNARGs) <em>[x1]</em>. Extractable functions also given rise to relatively efficient CCA constructions <em>[x3, x11]</em>.</p>

    <p class="text-gray-300">The black-box impossibility of some of the above applications imply that it is impossible to obtain extractable functions where the extractor uses the adversary’s program <span class="math">M</span> only as a black box. Coming up with the suitable non-black-box techniques has been the main obstacle in constructing extractable function, and to date, no construction with an explicit extraction procedure is known. Instead, for all the existing candidate constructions of extractable functions (e.g., <em>[x3, x5, x1, x2]</em>), the existence of such an extractor is merely <em>assumed</em>. Such assumptions are arguably not satisfying. For one, they do not qualify as “efficiently falsifiable” <em>[x15]</em>; namely, unlike standard assumptions where it possible to algorithmically study the best possible “breakers”, here we do not even have an algorithmic way to test whether a given adversary <span class="math">M</span> breaks the assumption. In addition, the impossibility of extractable functions with black-box extraction only further decreases our confidence in such assumptions, as our current understanding of non-black-box techniques and their limitations is quite partial.</p>

    <p class="text-gray-300">Thus, a natural question arises:</p>

    <p class="text-gray-300">*Can we construct useful extractable functions from standard hardness assumptions?</p>

    <p class="text-gray-300">We provide a positive answer to this question. Specifically, we construct one-way functions that are extractable against adversaries with non-uniform advice of bounded polynomial length, but unbounded polynomial running time (from hereon, BAPT adversaries). Note that this class includes, in particular, all uniform PT adversaries. We also show how to use our constructions to obtain 3-message and 2-message zero-knowledge, against BAPT adversarial verifiers.</p>

    <p class="text-gray-300">A bit more precisely, we construct a variant of EOWF, which we call generalized extractable one-way functions (GEOWF). A GEOWF is associated with an equivalence relation on its range. The one-wayness requirement is strengthened: not only is it hard to find an exact preimage of <span class="math">v</span>, but it is also hard to find a preimage of any equivalent <span class="math">v&#x27;</span>. The extractability requirement is weakened commensurately: the extractor does not have to output a preimage of <span class="math">v</span>, but only a preimage of some equivalent <span class="math">v&#x27;</span>. Such a generalization was previously considered in <em>[x1]</em> for a similar purpose, in the context of extractable collision-resistant hash functions (referred to as proximity ECRHs).</p>

    <p class="text-gray-300">Our extraction technique is inspired by the uniform public-coin ZK protocol of Barak <em>[x1]</em>. The main technical tool used in our constructions are non-interactive computationally sound proofs for deterministic polytime statements, from hereon referred to as P-delegation schemes. In a recent breakthrough, Kalai, Raz, and Rothblum <em>[x12]</em> construct a P-delegation scheme based on the assumption of a subexponentially secure private information retrieval scheme.</p>

    <p class="text-gray-300">We show:</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Theorem 1.1 (informal).</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assuming P-delegation, and 1-Hop homomorphic encryption with function privacy <em>[x10]</em>, there exist GEOWFs against BAPT adversaries.</li>

      <li>Assuming GEOWFs as above and ZAPs <em>[x11]</em>, there exist a 3-message ZK argument of knowledge against BAPT verifiers.</li>

      <li>Assuming the GEOWFs are one-way against subexponential adversaries, there exists a 2-message ZK argument against BAPT verifiers.</li>

    </ol>

    <p class="text-gray-300">We note that all the assumptions above can be reduced, for example, to subexponential Decision Diffie-Hellman (or Quadratic Residuosity) and trapdoor permutations <em>[x2, x26, x12, x13, x14, x15]</em>.</p>

    <p class="text-gray-300">Limitations and previous work. 3-message zero-knowledge protocols with black-box simulation exist only for trivial languages <em>[x13]</em>. Impossibility extends to the case of adversaries with bounded advice of size <span class="math">n^{\\Omega(1)}</span>, where <span class="math">n</span> is the security parameter. See Appendix A for more details. All previous 3-message zero-knowledge protocols were based on knowledge of exponent (or more general extractability) assumptions, where the simulator uses a non-black extractor that is only assumed to exist, but not explicitly constructed <em>[x16, x4, x7]</em>.</p>

    <p class="text-gray-300">Two-message zero-knowledge arguments against adversaries with unbounded polynomial advice exist only for trivial languages (regardless of how simulation is done) <em>[x14]</em>. In fact, impossibility extends even to adversaries with bounded advice, provided that the advice string is longer than the verifier’s message. Barak et al. <em>[x5]</em> construct a 2-message argument that is zero-knowledge as long as the verifier’s advice is shorter than the verifier message by super-logarithmic additive factor. However, security of the Barak et al. protocol is only shown assuming existence of P-delegation schemes that</p>

    <p class="text-gray-300">3</p>

    <p class="text-gray-300">are publicly verifiable. While this assumption is falsifiable <em>[x11]</em>, its only candidate constructions are either Micali’s CS proof construction in the random oracle model, or the publicly verifiable SNARGs of <em>[x5]</em> based on knowledge of exponent type assumptions. We obtain the same result, under the assumptions stated above.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Techniques</h3>

    <p class="text-gray-300">Constructing extractable functions. We now sketch how we construct extractable one-way functions against BAPT adversaries. To convey the basic idea behind our construction, consider the following first attempt. Let <span class="math">\\mathsf{PRG}:\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{3n}</span> be a pseudorandom generator. Define <span class="math">f:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{3n}</span> as so:</p>

    <p class="text-gray-300">\\[ f(i;s)=\\begin{cases}\\mathsf{PRG}(s)&\\text{ if }i\\neq 0^{n}\\\\ s(1^{n})&\\text{ if }i=0^{n}\\end{cases}\\ . \\]</p>

    <p class="text-gray-300">That is, if <span class="math">i\\neq 0^{n}</span>, apply the <span class="math">\\mathsf{PRG}</span> to the seed <span class="math">s</span>. Otherwise, interpret <span class="math">s</span> as a machine, and output its first <span class="math">3n</span> output bits. The one-wayness of <span class="math">f</span> follows from the pseudo-randomness of its output and the fact that a truly random output would have high Kolmogorov complexity. <span class="math">f</span> is also extractable with respect to programs <span class="math">M</span> whose description size is bounded by <span class="math">n</span>: If <span class="math">M</span> outputs some <span class="math">v\\in\\{0,1\\}^{3n}</span>, the extractor <span class="math">\\mathsf{Ext}</span> just outputs <span class="math">(0^{n},M)</span>.</p>

    <p class="text-gray-300">The main problem is that the time required to compute <span class="math">f</span> is not bounded by any particular polynomial. One can try to fix this by padding the input with <span class="math">1^{t}</span> where <span class="math">t</span> is the running time of <span class="math">s(1^{n})</span>. However, now the length of the extracted primage depends on the running time of <span class="math">M</span> and is not bounded by any particular polynomial in the length of the image. Such extractable functions do not seem to be as powerful though; in particular, we do not know how to use them for constructing 2-message and 3-message ZK protocols.</p>

    <p class="text-gray-300">A similar problem is encountered in Barak’s zero-knowledge protocol <em>[x2]</em>, where the entire computation of a malicious verifier is used as the simulation trapdoor. As in the protocol of <em>[x6]</em>, we get around this problem using a non-interactive proof system that allows for quick verification of (possibly long) computations. Instead of computing the output <span class="math">v</span> of <span class="math">s(1^{n})</span>, <span class="math">f</span> will (quickly) verify a proof for the fact that <span class="math">s(1^{n})</span> outputs <span class="math">v</span>. That is, we define <span class="math">f^{\\prime}(0^{n},s,v,\\pi)</span> that outputs <span class="math">v</span> only if <span class="math">\\pi</span> is a convincing proof that <span class="math">s(1^{n})=v</span>. Intuitively, the soundness of the proof guarantees that function is still one-way. Extraction from a BAPT adversary <span class="math">M</span> is done by simply computing a proof for its computation.</p>

    <p class="text-gray-300">However, which proof system should we use? Barak <em>[x2]</em> uses interactive universal arguments <em>[x24, x3]</em>, whereas we need a non-interactive version of universal arguments that we call NIUA. More precisely, in a NIUA, the verifier generates, once and for all, an “offline message” <span class="math">\\sigma</span> together with a private verification state <span class="math">\\tau</span> and sends <span class="math">\\sigma</span> to the prover. Then, the prover can compute a non-interactive proof <span class="math">\\pi</span> for any adaptively chosen statement of the sort: “machine <span class="math">M</span> outputs <span class="math">v</span> within <span class="math">t</span> steps”. We require that the verifier runs in time polynomial in the security parameter <span class="math">n</span>, but only polylogarithmic in <span class="math">t</span>, and the prover runs in time polynomial in <span class="math">(t,n)</span>.</p>

    <p class="text-gray-300">EOWFs can be constructed from NIUA that are publicly verifiable, that is, where the verification state <span class="math">\\tau</span> can be published without compromising soundness. We define a function family <span class="math">\\{f^{\\prime}_{k}\\}</span> as above, where the the key <span class="math">k</span> contains the NIUA offline message <span class="math">\\sigma</span> and the verification state <span class="math">\\tau</span>. The function <span class="math">f^{\\prime}_{k}</span> will verify an NIUA proof <span class="math">\\pi</span> for the fact that the program <span class="math">s</span> outputs <span class="math">v</span> within, say, <span class="math">n^{\\log n}</span> steps.</p>

    <p class="text-gray-300">Instantiating NIUAs. Alas, we do not know how to construct publicly verifiable NIUAs from standard assumptions. Still, in a recent breakthrough result, Kalai, Raz and Rothblum <em>[x20, x21]</em> construct P-delegation scheme based on any private information retrieval scheme with sub-exponential security. Such P-delegation scheme directly yield NIUA that are privately-verifiable. The problem is that now,</p>

    <p class="text-gray-300">including the NIUA’s private verification state <span class="math">\\tau</span> as part of the key <span class="math">k</span> will break the soundness of the NIUA and thus also the one-wayness of <span class="math">f^{\\prime}_{k}</span>.</p>

    <p class="text-gray-300">Our solution is to modify the function as follows: The key <span class="math">k</span> will contain the offline message <span class="math">\\sigma</span> together with a fully homomorphic encryption <span class="math">\\mathsf{c}_{\\tau}</span> of the corresponding verification state <span class="math">\\tau</span>. (In fact, a 1-HOP, non-compact homomorphic encryption suffices.) Intuitively, the function is defined as before except that verification of the proof <span class="math">\\pi</span> is done homomorphically, using the encrypted verification state <span class="math">\\tau</span>. That is, we define <span class="math">f^{\\prime\\prime}_{\\sigma,\\mathsf{c}_{\\tau}}(0^{n},s,v,\\pi)=(v,\\hat{\\mathsf{c}})</span>, where <span class="math">\\hat{\\mathsf{c}}</span> is the result of homomorphically evaluating the privately-verifiable NIUA verifier. In the case that the first field <span class="math">i</span> is not <span class="math">0^{n}</span>, instead of just outputting <span class="math">\\mathsf{PRG}(s)</span>, the output includes also an encryption <span class="math">\\mathsf{c}_{1}</span> of the value <span class="math">1</span>.</p>

    <p class="text-gray-300">Generalized EOWF. Note that the function <span class="math">f^{\\prime\\prime}</span> is no longer extractable in the standard sense. Given a BAPT adversary <span class="math">M</span> that outputs an image <span class="math">(v,\\hat{\\mathsf{c}})</span>, the extractor can compute a proof <span class="math">\\pi</span> for the computation of <span class="math">M</span> and output the preimage <span class="math">(0^{n},M,v,\\pi)</span> as before. However, <span class="math">f^{\\prime\\prime}</span> on this preimage will output <span class="math">(v,\\hat{\\mathsf{c}}^{\\prime})</span> where <span class="math">\\hat{\\mathsf{c}}^{\\prime}</span> is an encryption of <span class="math">1</span> that is most probably different than <span class="math">\\hat{\\mathsf{c}}</span>. Nonetheless, <span class="math">f^{\\prime\\prime}</span> satisfies the notion of generalized extractable one-way functions (GEOWF). We define an equivalence relation <span class="math">\\sim</span> on the range of <span class="math">f_{k}</span> as follows: <span class="math">(v,\\hat{\\mathsf{c}})\\sim(v^{\\prime},\\hat{\\mathsf{c}}^{\\prime})</span> iff <span class="math">v=v^{\\prime}</span> and both <span class="math">\\hat{\\mathsf{c}}</span> and <span class="math">\\hat{\\mathsf{c}}^{\\prime}</span> are encryptions of <span class="math">1</span>. As required, the extractor described above outputs a preimage of <span class="math">(v,\\hat{\\mathsf{c}}^{\\prime})</span> such that <span class="math">(v,\\hat{\\mathsf{c}})\\sim(v,\\hat{\\mathsf{c}}^{\\prime})</span>. The one-wayness of <span class="math">f^{\\prime\\prime}</span> with respect to <span class="math">\\sim</span> follows from the one-wayness of <span class="math">f^{\\prime}_{k}</span> and the semantic security of the encryption: given an image <span class="math">(v,\\hat{\\mathsf{c}})</span>, finding a primage <span class="math">u</span> of <span class="math">(v,\\hat{\\mathsf{c}}^{\\prime})</span> such that <span class="math">(v,\\hat{\\mathsf{c}})\\sim(v,\\hat{\\mathsf{c}}^{\\prime})</span> is hard, since if <span class="math">\\hat{\\mathsf{c}}^{\\prime}</span> is an encryption of <span class="math">1</span>, <span class="math">u</span> must also be a valid preimage of <span class="math">v</span> under <span class="math">f^{\\prime}</span>, whereas by sematic security the encrypted verification state <span class="math">\\mathsf{c}_{\\tau}</span> should not help in inverting <span class="math">f^{\\prime}</span>. Note that the relation <span class="math">\\sim</span> can only be tested given the secret key for the encryption. We refer to such a relation as privately testable. (The above is somewhat of an oversimplification of the actual definition of <span class="math">f^{\\prime\\prime}_{k}</span>. See the body for details.)</p>

    <p class="text-gray-300">Next, we show how to construct 2-message and 3-message zero-knowledge protocols from GEOWF with a privately testable relation.</p>

    <p class="text-gray-300">From EOWF to 3-message zero-knowledge. We start by describing a 3-message zero-knowledge protocol from strict EOWFs (namely, when the equivalence relation <span class="math">\\sim</span> is equality). The protocol follows the Feige-Lapidot-Shamir trapdoor paradigm <em>[x11]</em>. The basic idea is to have the verifier sample a function <span class="math">f_{k}</span> from the EOWF family, and send an image <span class="math">v=f_{k}(u)</span> of a random element <span class="math">u</span>, which will serve as the trapdoor. The prover would then give a witness-indistinguishable proof of knowledge attesting that it either knows a witness <span class="math">w</span> for the proven statement, or it knows a preimage <span class="math">u^{\\prime}</span> of <span class="math">v</span>. Intuitively, soundness (and actually proof of knowledge) follow from the one-wayness of <span class="math">f_{k}</span> and the proof of knowledge property of the WI system. Zero-knowledge follows from the extractability of <span class="math">f_{k}</span>. Indeed, the simulator, given the code of the verifier, can run the extractor of the EOWF, obtain <span class="math">u</span>, and use it to simulate the WI proof.</p>

    <p class="text-gray-300">Following through on this intuition encounters several difficulties. First, since a WI proof of knowledge requires 3 messages, the first WI prover message must be sent in the first message of the protocol. However, the WI statement is only determined when the verifier sends <span class="math">v</span> in the second protocol message. Therefore, we must make sure to use a WI proof of knowledge where the first prover message does not depend on the statement. Another basic problem concerns the length of the first WI message. Recall that, in our construction of EOWFs against BAPT adversaries, the function’s output is longer than the adversary’s advice. Since a cheating verifier may compute <span class="math">v</span> using the first WI message as an advice, we must use a WI system where the length of the first message is independent of the length of the proven statement. We design a WI proof of knowledge with the required properties based on ZAPs <em>[x10]</em> and extractable commitments <em>[x20]</em>.</p>

    <p class="text-gray-300">2-message zero-knowledge. In the 2-message protocol, we replace the 3-message WI proof of knowledge with a 2-message WI proof (e.g. ZAP). However, in the above 3-message protocol, soundness is established by using the proof-of-knowledge property of the WI, whereas 2-message WI proofs of knowledge are not known. Instead, we prove soundness using complexity leveraging. The prover adds</p>

    <p class="text-gray-300">to its message a statistically binding commitment to junk, and proves that either “<span class="math">x\\in\\mathcal{L}</span>”, or “<span class="math">f_{k}(u)=v</span> and the commitment is to <span class="math">u</span>”. We require that the commitment is invertible in some superpolynomial time <span class="math">T</span>, whereas the one-wayness of <span class="math">f_{k}</span> still holds against adversaries that run in time <span class="math">\\mathrm{poly}(T)</span>. Now, an inverter of <span class="math">f_{k}</span> can run the cheating prover with a verifier message that contains its input image <span class="math">v</span>, and brute-force break the commitment to obtain a preimage of <span class="math">v</span>.</p>

    <p class="text-gray-300">Replacing EOWF with GEOWF. The zero-knowledge protocols from GEOWFs are similar, with the exception that now, rather than proving knowledge of a preimage of <span class="math">v</span>, the prover will send an image <span class="math">v^{\\prime}</span> such that <span class="math">v^{\\prime}\\sim v</span> and prove knowledge of a preimage of <span class="math">v^{\\prime}</span>. To keep the protocol ZK, the honest prover must be able to sample an image <span class="math">v^{\\prime}</span> that is distributed like the image that is sent by the simulator even without knowing a corresponding preimage. In our GEOWF construction, such an equivalent image can be efficiently sampled.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.3 Why Extractable Functions?</h3>

    <p class="text-gray-300">As pointed out above, the extractable functions constructed here mimic Barak’s zero-knowledge protocol <em>[x1]</em>. The similarity becomes even stronger when considering the two-message zero-knowledge protocol of Barak et. al <em>[x4]</em>: Our two message protocol can be directly obtained from that of <em>[x4]</em> by replacing the CS proofs with P-delegation, and accounting for private verifiability as sketched above. This can be done without mention of extractable functions. Still, we believe that the abstraction of extractable functions is helpful in this context. In particular, it helps separating the protocol structure from the underlying mechanism of extracting a secret value from a given adversarial program.</p>

    <p class="text-gray-300">Furthermore, we hope that this abstraction will prove useful for additional applications beyond two and three-message zero-knowledge. Applications like succinct non-interactive arguments (SNARGs) and efficient CCA encryption seem to require extractable functions with stronger properties such as injectiveness or collision-resistance <em>[x10, x5]</em>. At this point, candidates for extractable functions with such properties are known based on non-standard assumptions regarding different number theoretic and algebraic structures, such as the knowledge-of-exponent assumption. In contrast, our construction is unstructured and does not satisfy the above properties. Indeed, in our function it is easy to find collisions: Consider a machine <span class="math">M</span> that just evaluates the function on any arbitrary input <span class="math">u</span>. By simply applying the extractor on <span class="math">M</span>, we can obtain a different preimage <span class="math">u^{\\prime}</span> mapping to an equivalent image.</p>

    <p class="text-gray-300">We hope that the proposed construction will provide a stepping stone to improved constructions of stronger extractable functions based on standard and better understood hardness assumptions. Two natural targets here are extractable collision-resistant hash functions and extractable non-interactive commitments.</p>

    <p class="text-gray-300">Organization. Section 2 defines the notion of NIUA and other main tools used in our constructions. Section 3 presents our main construction of GEOWF against BAPT adversaries. Section 4 constructs 2-message and 3-message ZK protocols against BAPT verifiers.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Tools</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 Non-Interactive Universal Arguments for Deterministic Computations & Delegation</h3>

    <p class="text-gray-300">We define non-interactive universal arguments for deterministic computations (NIUAs), which can be seen as a special case of Barak’s and Goldreich’s <em>[x2]</em> UAs. We then explain the relation to the problem of delegation and the corresponding existence result of Kalai, Raz, and Rothblum <em>[x16]</em>.</p>

    <p class="text-gray-300">In what follows, we denote by <span class="math">\\mathcal{L}_{\\mathcal{U}}</span> the universal language consisting of all tuples <span class="math">(M,x,t)</span> such that <span class="math">M</span> accepts <span class="math">y</span> within <span class="math">t</span> steps. We denote by <span class="math">\\mathcal{L}_{\\mathcal{U}}(T)</span> all pairs <span class="math">(M,x)</span> such that <span class="math">(M,x,T)\\in\\mathcal{L}_{\\mathcal{U}}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Let <span class="math">T(n) \\in (2^{\\omega(\\log n)}, 2^{\\mathrm{poly}(n)})</span> be a computable superpolynomial function. An NIUA system for <span class="math">\\mathrm{Dtime}(T)</span> consists of three algorithms <span class="math">(\\mathcal{G}, \\mathcal{P}, \\mathcal{V})</span> that work as follows. The (probabilistic) generator <span class="math">\\mathcal{G}</span>, given a security parameter <span class="math">1^n</span>, outputs a reference string <span class="math">\\sigma</span> and a corresponding verification state <span class="math">\\tau</span>; in particular, <span class="math">\\mathcal{G}</span> is independent of any statement to be proven later. The honest prover <span class="math">\\mathcal{P}(M, x; \\sigma)</span> produces a certificate <span class="math">\\pi</span> for the fact that <span class="math">(M, x) \\in \\mathcal{L}_{\\mathcal{U}}(T(n))</span>. The verifier <span class="math">\\mathcal{V}(M, x; \\pi, \\tau)</span> verifies the validity of <span class="math">\\pi</span>.</p>

    <p class="text-gray-300"><strong>Definition 2.1 (NIUA).</strong> A triple of algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is a non-interactive universal argument system for for <span class="math">\\mathrm{Dtime}(T)</span> if it satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Perfect Completeness:</strong></li>

    </ul>

    <p class="text-gray-300">For any <span class="math">n \\in \\mathbb{N}</span> and <span class="math">(M, x) \\in \\mathcal{L}_{\\mathcal{U}}(T(n))</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{(\\sigma, \\tau) \\leftarrow \\mathcal{G}(1^n)} \\left[ \\mathcal{V}(M, x; \\pi, \\tau) = 1 \\mid \\pi \\leftarrow \\mathcal{P}(M, x; \\sigma) \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Adaptive soundness:</strong></li>

    </ul>

    <p class="text-gray-300">For any polysize prover <span class="math">\\mathcal{P}^*</span> and large enough <span class="math">n \\in \\mathbb{N}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{(\\sigma, \\tau) \\leftarrow \\mathcal{G}(1^n)} \\left[ \\mathcal{V}(M, x; \\pi, \\tau) = 1 \\quad \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (M, x, \\pi) \\leftarrow \\mathcal{P}^*(\\sigma) \\\\ (M, x) \\in \\{0, 1\\}^n \\setminus \\mathcal{L}_{\\mathcal{U}}(T(n)) \\end{array} \\right. \\right] \\leq \\operatorname{negl}(n).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Fast verification and relative prover efficiency:</strong></li>

    </ul>

    <p class="text-gray-300">There exists a polynomial <span class="math">p</span> such that for every <span class="math">n \\in \\mathbb{N}</span>, <span class="math">t \\leq T(n)</span>, and <span class="math">(M, x) \\in \\mathcal{L}_{\\mathcal{U}}(t)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the generator <span class="math">\\mathcal{G}</span> runs in time <span class="math">p(n)</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the verifier <span class="math">\\mathcal{V}</span> runs in time $p(n +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The system is said to be publicly verifiable if it is sound when <span class="math">\\tau</span> is public. In this case, we will assume WLOG that <span class="math">\\sigma = \\tau</span>.</p>

    <p class="text-gray-300"><strong>Existence and connection to delegation of computation.</strong> There are two differences between the notion of delegation for deterministic computations (See, e.g., [KRR13]) and the NIUA notion defined above. The first is that a delegation system is associated with a given language <span class="math">\\mathcal{L}(M)</span> for a fixed deterministic machine <span class="math">M</span>, and the corresponding efficiency parameters depend on the worst-case running time <span class="math">T_M</span> of <span class="math">M</span>. In particular, the generator <span class="math">\\mathcal{G}</span> depends on <span class="math">T_M</span> as an extra parameter, and the prover's efficiency is polynomial in the worst-case running time <span class="math">T_M</span>. The second difference is that only non-adaptive soundness is required; in particular, the generator's message <span class="math">\\sigma</span> may depend on the input <span class="math">x</span>.</p>

    <p class="text-gray-300">Kalai, Raz, and Rothblum [KRR] show how to construct such a privately verifiable delegation scheme for every language in <span class="math">\\mathrm{Dtime}(T) \\subseteq \\mathrm{EXP}</span>, assuming subexponentially secure private information retrieval schemes that are subexponentially secure, which can in turn be constructed based on the subexponential Learning with Errors assumption [BV11].<span class="math">^3</span></p>

    <p class="text-gray-300">In order to get a (privately verifiable) NIUA for <span class="math">\\mathrm{Dtime}(T)</span>, we could potentially use their result with respect to a universal machine and worst-case running time <span class="math">O(T)</span>. However, this solution would lack the required prover efficiency, as the prover will always run in time <span class="math">\\mathrm{poly}(T)</span>, even for machines <span class="math">M</span> with running time <span class="math">t_M &amp;lt;&amp;lt; T</span>. This is undesired in our case, as we will be interested in <span class="math">T</span> that is superpolynomial. Fortunately, a rather standard transformation does allow to get the required efficiency from</p>

    <p class="text-gray-300"><span class="math">^3</span>Private information retrieval based on Quadratic Residuosity, Decision Diffie-Helmman, or more generally additively homomorphic encryption can also be used. However, this induces worst communication complexity [OI07], and leads to NIUAs for smaller, but still super-polynomial, upper bound <span class="math">T</span>; this is still sufficient for our purpose.</p>

    <p class="text-gray-300">their result. Specifically, we could run the generator in their solution to generate reference string and verification state <span class="math">(\\sigma,\\tau)</span> for computations of size <span class="math">t</span> for all <span class="math">t\\in\\left\\{1,2,2^{2},\\ldots,2^{\\log T}\\right\\}</span>, and have the prover and verifier use the right <span class="math">(\\sigma,\\tau)</span> according to the concrete running time <span class="math">t_{M}&lt;T</span>, guaranteeing that the prover’s running time is at most <span class="math">\\mathrm{poly}(2t_{M})</span> as required.</p>

    <p class="text-gray-300">Also, in their scheme, the generator works independently of the input <span class="math">x</span>, but soundness is shown only when <span class="math">\\sigma</span> is generated independently of <span class="math">x</span>. To guarantee soundness for adaptively chosen inputs <span class="math">x\\in\\{0,1\\}^{n}</span>, we may repeat the above argument <span class="math">2n</span> times. Since parallel repetition exponentially reduces the soundness error in two-message arguments, we can then take a union bound over all <span class="math">2^{n}</span> adaptive choices of <span class="math">x</span> and get the required soundness. The <span class="math">2n</span>-factor hit in succinctness and verification time are still tolerable for our purposes (and still satisfy the above definition).</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 1-Hop Homomorphic Encryption</h3>

    <p class="text-gray-300">A <em>1-Hop homomorphic encryption scheme</em> <em>[x13]</em> allows a pair of parties to securely evaluate a function as follows: the first party encrypts an input, the second party homomorphically evaluates a function on the ciphertext, and the first party decrypts the evaluation result. Such a scheme can be instantiated based on garbled-circuits and an appropriate 2-message oblivious transfer protocol, based on either Decision Diffie-Hellman or Quadratic Residuosity <em>[x19, x12, x20, x21]</em>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.2.</h6>

    <p class="text-gray-300">A scheme <span class="math">(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Eval},\\mathsf{Dec})</span> is a semantically-secure, circuit-private, 1-Hop homomorphic encryption scheme if it satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect correctness:</li>

    </ul>

    <p class="text-gray-300">For any <span class="math">n\\in\\mathbb{N}</span>, <span class="math">u\\in\\{0,1\\}^{n}</span> and circuit <span class="math">C</span>:</p>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}\\mathbf{sk}\\leftarrow\\mathsf{Gen}(1^{n})\\\\ \\mathbf{c}\\leftarrow\\mathsf{Enc}_{\\mathsf{sk}}(u)\\\\ \\mathsf{Eval}\\end{subarray}}\\left[\\begin{array}[]{c}\\hat{\\mathsf{c}}\\leftarrow\\mathsf{Eval}_{\\mathsf{sk}}(\\mathsf{c},C)\\\\ \\mathsf{Dec}_{\\mathsf{sk}}(\\hat{\\mathsf{c}})=C(u)\\end{array}\\right]=1\\enspace. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Semantic security:</li>

    </ul>

    <p class="text-gray-300">For any polysize <span class="math">\\mathcal{A}</span>, large enough <span class="math">n\\in\\mathbb{N}</span>, and any pair of inputs <span class="math">u_{0},u_{1}\\in\\{0,1\\}^{n}</span></p>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}\\mathbf{b}\\leftarrow\\{0,1\\}\\\\ \\mathbf{sk}\\leftarrow\\mathsf{Gen}(1^{n})\\end{subarray}}\\left[\\mathcal{A}(\\mathsf{Enc}_{\\mathsf{sk}}(u_{\\mathsf{b}}))=\\mathsf{b}\\right]<\\frac{1}{2}+\\mathrm{negl}(n)\\enspace. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Circuit privacy: A randomized evaluation should not leak information on the input circuit <span class="math">C</span>. This should hold even for malformed ciphertexts. Formally, let <span class="math">\\mathcal{E}(x)=\\mathsf{Supp}(\\mathsf{Enc}(x))</span> be the set of all legal encryptions of <span class="math">x</span>, let <span class="math">\\mathcal{E}_{n}=\\cup_{x\\in\\{0,1\\}^{n}}\\mathcal{E}(x)</span> be the set legal encryptions for strings of length <span class="math">n</span>, and let <span class="math">\\mathcal{C}_{n}</span> be the set of all circuits on <span class="math">n</span> input bits. There exists a (possibly unbounded) simulator <span class="math">\\mathcal{S}</span> such that:</li>

    </ul>

    <p class="text-gray-300">$\\{C,\\mathsf{Eval}(c,C)\\}_{\\begin{subarray}{c}n\\in\\mathbb{N},C\\in\\mathcal{C}_{n}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\in\\{0,1\\}^{n},c\\in\\mathcal{E}(x)\\end{subarray}}<span class="math"> </span>\\approx_{c}\\ \\{C,\\mathcal{S}(c,C(x),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}_{\\begin{subarray}{c}n\\in\\mathbb{N},C\\in\\mathcal{C}_{n}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">x\\in\\{0,1\\}^{n},c\\in\\mathcal{E}(x)\\end{subarray}}<span class="math"> </span>\\{C,\\mathsf{Eval}(c,C)\\}_{\\begin{subarray}{c}n\\in\\mathbb{N}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\in\\mathcal{C}_{n},c\\notin\\mathcal{E}_{n}\\end{subarray}}<span class="math"> </span>\\approx_{c}\\ \\{C,\\mathcal{S}(c,\\bot,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\}_{\\begin{subarray}{c}n\\in\\mathbb{N}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C\\in\\mathcal{C}_{n},c\\notin\\mathcal{E}_{n}\\end{subarray}}\\ .$</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Extractable One-Way Functions against Adversaries with Bounded Advice</h2>

    <p class="text-gray-300">In this section, we define and construct extractable one-way functions against adversaries with bounded advice.</p>

    <p class="text-gray-300">3.1 Definitions</p>

    <p class="text-gray-300">For brevity, we refer to extractable one-way functions against polytime adversaries with <span class="math">m</span>-bounded advice as EOWFs against <span class="math">m</span>-BAPT adversaries. Such functions are one-way in the usual sense, and in addition it is possible to efficiently extract a pre-image from the code of any adversary that outputs a valid image, provided that the adversary only has bounded non-uniform advice, but arbitrary polynomial running time; this, in particular, includes the class of <em>uniform polytime adversaries</em>. Concretely, we shall focus on PPT adversaries with non-uniform advice <span class="math">z\\in\\{0,1\\}^{m(n)}</span>. We treat any randomness that the machines may use as part of their advice <span class="math">z</span>; in particular, our adversaries are only allowed bounded randomness, which in most application is not a restriction, as they can use a PRG to stretch it (see Remark 3.2).</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3.1 (EOWFs against <span class="math">m</span>-BAPT adversaries).</h6>

    <p class="text-gray-300">Let <span class="math">\\ell,\\ell^{\\prime}</span> be polynomially bounded length functions. An efficiently computable family of functions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{F}=\\left\\{f_{k}:\\{0,1\\}^{\\ell(n)}\\rightarrow\\{0,1\\}^{\\ell^{\\prime}(n)}\\ \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ k\\in\\{0,1\\}^{\\operatorname{poly}(n)},n\\in\\mathbb{N}\\right\\}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler <span class="math">\\mathcal{K}</span>, is an extractable one-way function against adversaries with <span class="math">m</span>-bounded advice if it satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One-wayness: For any polysize <span class="math">\\mathcal{A}</span>, and large enough security parameter <span class="math">n\\in\\mathbb{N}</span>:</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}k\\leftarrow\\mathcal{K}(1^{n})\\\\ u\\leftarrow\\{0,1\\}^{\\ell(n)}\\end{subarray}}\\left[\\begin{array}[]{c}u^{\\prime}\\leftarrow\\mathcal{A}(k,f_{k}(u))\\\\ f_{k}(u^{\\prime})=f_{k}(u)\\end{array}\\right]\\leq\\operatorname{negl}(n)\\enspace. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extractability: For any PPT adversary <span class="math">M</span>, there exists a PPT extractor <span class="math">\\mathsf{Ext}</span> such that, for any large enough security parameter <span class="math">n\\in\\mathbb{N}</span>, and advice <span class="math">z\\in\\{0,1\\}^{m(n)}</span>:</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}k\\leftarrow\\mathcal{K}(1^{n})\\end{subarray}}\\left[\\begin{array}[]{c}v\\leftarrow M(k;z)\\\\ \\exists u:f_{k}(u)=v\\end{array}\\wedge\\begin{array}[]{c}u^{\\prime}\\leftarrow\\mathsf{Ext}(k;z)\\\\ f_{k}(u^{\\prime})\\neq v\\end{array}\\right]\\leq\\operatorname{negl}(n)\\enspace. \\]</p>

    <p class="text-gray-300">Generalized EOWFs. We next define <em>generalized EOWFs</em> (GEOWFs), analogous to the <em>proximity extractable collision-resistance</em> in <em>[x1]</em>. Here the extractable function family <span class="math">\\{f_{k}\\}</span> is associated with an equivalence relation <span class="math">\\sim</span> on the range of <span class="math">f_{k}</span>. The one-wayness requirement is then strengthened: not only is it hard to find an exact preimage of <span class="math">v</span>, but it is also hard to find a preimage of any equivalent <span class="math">v^{\\prime}\\sim v</span> (we shall often refer to such a preimage as a “relative preimage”). The extractability requirement is weakened accordingly: the extractor does not have to output an exact preimage of <span class="math">v</span>, but only a preimage of some equivalent <span class="math">v^{\\prime}\\sim v</span>. Intuitively, one can think of a generalized EOWF where each <span class="math">f_{k}</span> maps <span class="math">\\{0,1\\}^{\\ell}</span> to <span class="math">\\{0,1\\}^{\\ell^{\\prime}}</span> as a standard EOWF that maps <span class="math">\\{0,1\\}^{\\ell}</span> to the quotient space of co-sets in <span class="math">\\{0,1\\}^{\\ell^{\\prime}}</span> modulo <span class="math">\\sim</span>.</p>

    <p class="text-gray-300">We may further allow that the relation <span class="math">\\sim</span> depends on the key <span class="math">k</span>, where the relation <span class="math">\\sim</span> can either be publicly-testable given <span class="math">k</span>, or require the private coins used to sample <span class="math">k</span> for efficient testing. In particular, any standard EOWF is a GEOWF with the publicly-testable equality relation.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 3.2 (GEOWFs against <span class="math">m</span>-BAPT adversaries).</h6>

    <p class="text-gray-300">An efficiently computable family of functions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{F}=\\left\\{f_{k}:\\{0,1\\}^{\\ell(n)}\\rightarrow\\{0,1\\}^{\\ell^{\\prime}(n)}\\ \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ k\\in\\{0,1\\}^{\\operatorname{poly}(n)},n\\in\\mathbb{N}\\right\\}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler <span class="math">\\mathcal{K}</span>, is an extractable one-way function, with proximity relation <span class="math">\\sim</span> on <span class="math">\\{0,1\\}^{\\ell^{\\prime}(n)}\\times\\{0,1\\}^{\\ell^{\\prime}(n)}</span>, against adversaries with <span class="math">m</span>-bounded advice, if it satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Strong one-wayness: for any polysize <span class="math">\\mathcal{A}</span>, and large enough security parameter <span class="math">n\\in\\mathbb{N}</span>:</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}k\\leftarrow\\mathcal{K}(1^{n})\\\\ u\\leftarrow\\{0,1\\}^{\\ell(n)}\\end{subarray}}\\left[\\begin{array}[]{c}u^{\\prime}\\leftarrow\\mathcal{A}(k,f_{k}(u))\\\\ f_{k}(u)\\sim f_{k}(u^{\\prime})\\end{array}\\right]\\leq\\mathrm{negl}(n)\\enspace. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Weak extractability: for any PPT adversary <span class="math">M</span>, there exists a PPT extractor <span class="math">\\mathsf{Ext}</span> such that, for any large enough security parameter <span class="math">n\\in\\mathbb{N}</span>, and advice <span class="math">z\\in\\{0,1\\}^{m(n)}</span>:</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}k\\leftarrow\\mathcal{K}(1^{n})\\end{subarray}}\\left[\\begin{array}[]{c}v\\leftarrow M(k;z)\\\\ \\exists u:f_{k}(u)=v\\end{array}\\wedge\\begin{array}[]{c}u^{\\prime}\\leftarrow\\mathsf{Ext}(k;z)\\\\ f_{k}(u^{\\prime})\\not\\sim v\\end{array}\\right]\\leq\\mathrm{negl}(n)\\enspace. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Testable relation: There exists a deterministic polytime machine <span class="math">\\mathcal{T}</span> such that, given the random coins used by <span class="math">\\mathcal{K}</span> to sample <span class="math">k</span>, <span class="math">\\mathcal{T}</span> accepts <span class="math">v,v^{\\prime}\\in\\{0,1\\}^{\\ell^{\\prime}(n)}</span> if and only if <span class="math">v\\sim_{k}v^{\\prime}</span>. The relation is publicly-testable <span class="math">\\mathcal{T}</span> only requires <span class="math">k</span>, but not the private coins used to sample it.</li>

    </ul>

    <h6 id="sec-12" class="text-base font-medium mt-4">Remark 3.1 (universal extractor).</h6>

    <p class="text-gray-300">In the above definitions, each PPT <span class="math">M</span> is required to have a designated PPT extractor <span class="math">\\mathsf{Ext}_{M}</span>. Our constructions will, in fact, guarantee the existence of one universal extractor <span class="math">\\mathsf{Ext}</span> that given any <span class="math">(M,z,k)</span> and a bound <span class="math">1^{t_{M}}</span> on the running time of <span class="math">M(k;z)</span>, can perform extraction. Moreover, the running time of <span class="math">\\mathsf{Ext}</span> is bounded by some (universal) polynomial <span class="math">\\mathrm{poly}(t_{M})</span> in the running time of <span class="math">M</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Remark 3.2 (bounded randomness).</h6>

    <p class="text-gray-300">In our definitions, we assumed that any randomness used by the machines is part of their bounded advice, and in particular, is bounded itself. For many applications, this is sufficient as we can transform any adversary that uses arbitrary polynomial randomness to one that uses bounded randomness, by having it stretch its randomness with a PRG. (Alternatively, we can achieve an alternative extraction definition where the extractor is randomized and is allowed to simulate the adversary’s randomness.) This approach is applicable for example for ZK against BAPT verifiers (see Section 4), as well as for any application where testing if the adversary breaks the scheme can be done efficiently.</p>

    <p class="text-gray-300">Additional properties of GEOWFs. We next discuss additional properties of GEOWFs that will prove useful in the design of protocols.</p>

    <p class="text-gray-300">The first property is called everywhere extractability and requires that extractability does not only hold with overwhelming over keys <span class="math">k\\leftarrow\\mathcal{K}(1^{n})</span>, but also holds for any maliciously chosen key.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 3.3.</h6>

    <p class="text-gray-300">A GEOWF (or EOWF) is said to satisfy everywhere extractability if weak extractability holds for any <span class="math">k\\in\\{0,1\\}^{\\mathrm{poly}(n)}</span>, where <span class="math">\\mathrm{poly}(n)</span> is the length of keys output by <span class="math">\\mathcal{K}(1^{n})</span>.</p>

    <p class="text-gray-300">We note that everywhere extractability cannot be achieved if the output of the function <span class="math">\\ell^{\\prime}</span> is shorter than the length of the advice <span class="math">m</span> that the adversary is allowed; otherwise, the adversary may simply get as advice a random image under some key, and the extractor would fail to invert for that key. Indeed, in our constructions that achieve everywhere extractability, the output of the function will be longer than the allowed advice.</p>

    <p class="text-gray-300">Also, we note that one can make an analogous property of everywhere one-wayness, which for some applications may be a sufficient alternative to everywhere extractability; however, we will not require (nor achieve) this property in this work.</p>

    <p class="text-gray-300">The second property, called oblivious image sampling, strengthens even further the extractability requirement, saying that the distribution of images <span class="math">v^{\\prime}=f_{k}(u^{\\prime})</span> induced by the extraction procedure <span class="math">\\mathsf{Ext}</span> is simulatable, given only the image <span class="math">v</span> output by the adversary <span class="math">M</span> (and without the code of <span class="math">M</span>). Accordingly, the extractor <span class="math">\\mathsf{Ext}</span> will now be randomized.</p>

    <p class="text-gray-300">The requirement that <span class="math">\\tilde{v}\\sim v</span> is stated for the sake of clarity, and actually follows automatically from the fact that everywhere extraction guarantees <span class="math">v^{\\prime}\\sim v</span>, and that <span class="math">v^{\\prime}\\approx_{c}\\tilde{v}^{\\prime}</span>. We also note that oblivious image sampling automatically holds for standard EOWFs (rather than GEOWF) that are everywhere extractable. Indeed, the image sampler can just output the same image <span class="math">v</span> it gets as input.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.2 Constructions</h3>

    <p class="text-gray-300">We start by describing a construction of a (standard) EOWF against BAPT adversaries from any publicly verifiable NIUA system and any pseudorandom generator. We then provide an augmented construction of a GEOWF based only on privately verifiable NIUA and any 1-Hop homomorphic encryption scheme.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">3.2.1 EOWF from publicly verifiable NIUA.</h4>

    <p class="text-gray-300">In what follows, let <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> be a publicly verifiable NIUA system for <span class="math">\\text{Dtime}(T(n))</span> for some function <span class="math">T(n)\\in(2^{\\omega(\\log n)},2^{\\text{poly}(n)})</span>, and assume that for security parameter <span class="math">n</span>, <span class="math">\\mathcal{G}(1^{n})</span> outputs the public reference string (which is also the verification state) <span class="math">\\sigma\\in\\{0,1\\}^{n}</span>, and that <span class="math">\\mathcal{P}</span> outputs certificates <span class="math">\\pi</span> of size <span class="math">n</span>. Let <span class="math">\\mathsf{PRG}</span> be a pseudo random generator stretching <span class="math">n</span> bits to <span class="math">m(n)+2n</span> bits. The construction basically follows the high-level ideas presented in the introduction (with slight syntactic differences).</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Construction 3.1.</h6>

    <p class="text-gray-300">The key generation algorithm <span class="math">\\mathcal{K}</span> is just the generator <span class="math">\\mathcal{G}</span>.</p>

    <p class="text-gray-300">The function is defined as follows:</p>

    <p class="text-gray-300">\\[ (i;M,y,\\pi;s)\\stackrel{{\\scriptstyle f_{\\sigma}}}{{\\longmapsto}}\\begin{cases}y,\\mathcal{V}(M,\\sigma,y;\\pi,\\sigma)&\\text{ if }i=0^{n}\\\\ \\mathsf{PRG}(s),1&\\text{ if }i\\neq 0^{n}\\end{cases}, \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathcal{V}(M,\\sigma,y;\\pi,\\sigma)</span> is the result of verifying the certificate <span class="math">\\pi</span> for the statement “<span class="math">M(\\sigma)=y</span> within <span class="math">T(n)</span> steps”. Each of the inputs to the function is of length <span class="math">n</span>, except <span class="math">M</span> that is of length <span class="math">m</span>, and <span class="math">y</span> that is of length <span class="math">m+2n</span>, like <span class="math">\\mathsf{PRG}(s)</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 3.1.</h6>

    <p class="text-gray-300">The function family <span class="math">\\mathcal{F}=\\{f_{k}\\}_{n\\in\\mathbb{N}}</span>, given by Construction 3.1, is a GEOWF against (<span class="math">m-\\omega(1)</span>)-BAPT adversaries.</p>

    <p class="text-gray-300">High-level idea behind the proof. To see that the function is one-way, note that a random image <span class="math">v</span> is almost always the output of a <span class="math">\\mathsf{PRG}</span> (i.e., comes from the <span class="math">i\\neq 0^{n}</span> branch). To invert it, the adversary must either invert the <span class="math">\\mathsf{PRG}</span>, in which case it can produce a preimage of the <span class="math">i\\neq 0^{n}</span> type, or it could find a short machine <span class="math">M</span> and an accepting proof that it outputs <span class="math">v</span>, in which case it can produce a preimage of the <span class="math">i=0^{n}</span> type. The first case does not occur since <span class="math">\\mathsf{PRG}</span> is one-way. The second case cannot occur because of the pseudorandomness of <span class="math">\\mathsf{PRG}</span> and the soundness of the NIUA; indeed, had we replace the output <span class="math">v</span> of the <span class="math">\\mathsf{PRG}</span> with a truly random string, it would almost surely have high Kolomogorov complexity, and a short machine <span class="math">M</span> that outputs <span class="math">v</span> wouldn’t exist, meaning that the inverter would have to produce an accepting proof for a false statement, and violate soundness.</p>

    <p class="text-gray-300">As for extraction, given a machine <span class="math">M_{z}</span> with short advice <span class="math">z</span> that outputs <span class="math">(v,1)</span>, the extractor simply computes a proof <span class="math">\\pi</span> for this computation, and outputs the preimage <span class="math">(0^{n};M_{z},v,\\pi;1^{n})</span>. If <span class="math">M</span> outputs something of the form <span class="math">(v,0)</span>, the extractor produces instead some non accepting statement and proof <span class="math">(M^{\\prime},\\pi^{\\prime})</span>, and outputs <span class="math">(0^{n};M^{\\prime},v,\\pi^{\\prime};1^{n})</span>.</p>

    <p class="text-gray-300">We omit the full proof, which is subsumed by the proof of the private-verifiability case treated below.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">3.2.2 GEOWF from privately verifiable NIUA.</h4>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> be a privately verifiable NIUA system for <span class="math">\\text{Dtime}(T(n))</span> for some function <span class="math">T(n)\\in(2^{\\omega(\\log n)},2^{\\text{poly}(n)})</span>, and assume that for security parameter <span class="math">n</span>, <span class="math">\\mathcal{G}(1^{n})</span> outputs a public reference string <span class="math">\\sigma</span> and private verification state <span class="math">\\tau</span>, each of size <span class="math">n</span>, and assume that <span class="math">\\mathcal{P}</span> outputs certificates <span class="math">\\pi</span> of size <span class="math">n</span>. Let <span class="math">\\mathsf{PRG}</span> be a</p>

    <p class="text-gray-300">pseudo random generator stretching <span class="math">n</span> bits to <span class="math">m(n)+n^{2}+2n</span> bits. Let <span class="math">(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec},\\mathsf{Eval})</span> be a 1-Hop homomorphic encryption scheme (not necessarily compact), and assume that a cipher <span class="math">\\mathsf{c}</span> encrypting <span class="math">n</span> bits is of size <span class="math">n^{2}</span>. Let <span class="math">\\mathcal{C}_{\\mathcal{V}}=\\mathcal{C}_{\\mathcal{V}}\\left(M,\\sigma,\\mathsf{c},y,\\pi,\\cdot\\right)</span> be a circuit that, given <span class="math">\\tau</span> as input, verifies that <span class="math">\\mathcal{V}(M,(\\sigma,\\mathsf{c}),y;\\pi,\\tau)=1</span>; namely, it verifiers the certificate <span class="math">\\pi</span> for the statement “<span class="math">M(\\sigma,\\mathsf{c})=y</span> within <span class="math">T(n)</span> steps”. Let <span class="math">\\mathcal{C}_{\\mathbf{1}}</span> be a circuit that always outputs <span class="math">1</span> and is of the same size as <span class="math">\\mathcal{C}_{\\mathcal{V}}</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Construction 3.2.</h6>

    <p class="text-gray-300">The key generator <span class="math">\\mathcal{K}</span> samples <span class="math">(\\sigma,\\tau)\\leftarrow\\mathcal{G}(1^{n})</span>, <span class="math">\\mathsf{c}_{\\tau}\\leftarrow\\mathsf{Enc}(\\tau)</span>, and outputs <span class="math">\\sigma,\\mathsf{c}_{\\tau}</span>.</p>

    <p class="text-gray-300">The function <span class="math">f_{\\sigma,\\mathsf{c}_{\\tau}}</span> is defined as follows:</p>

    <p class="text-gray-300">\\[ (i;M,y,\\pi;s)\\stackrel{{\\scriptstyle f_{\\sigma,\\mathsf{c}_{\\tau}}}}{{{\\longmapsto}}}\\begin{cases}y,\\hat{\\mathsf{c}}_{\\mathcal{V}},i&\\text{if }i=0^{n}\\\\ \\mathsf{PRG}(s),\\hat{\\mathsf{c}}_{1},i&\\text{if }i\\neq 0^{n}\\end{cases}\\ , \\]</p>

    <p class="text-gray-300">where <span class="math">\\hat{\\mathsf{c}}_{\\mathcal{V}}\\leftarrow\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathsf{c}_{\\tau})</span> and <span class="math">\\hat{\\mathsf{c}}_{1}\\leftarrow\\mathsf{Eval}(\\mathcal{C}_{\\mathbf{1}},\\mathsf{c}_{\\tau})</span> (both <span class="math">\\mathsf{Eval}</span> can be deterministic). Each of the inputs to the function are of length <span class="math">n</span>, except <span class="math">M</span> that is of length <span class="math">m</span>, and <span class="math">y</span> that is of length <span class="math">m+n^{2}+2n</span>.</p>

    <p class="text-gray-300">The proximity relation <span class="math">\\sim</span> is defined as follows: <span class="math">(y,\\hat{\\mathsf{c}},i)\\sim(y^{\\prime},\\hat{\\mathsf{c}}^{\\prime},i^{\\prime})</span> if either</p>

    <p class="text-gray-300"><span class="math">y=y^{\\prime}\\text{ and }\\mathsf{Dec}(\\hat{\\mathsf{c}})=\\mathsf{Dec}(\\hat{\\mathsf{c}}^{\\prime})=1,</span> <span class="math">\\text{ or }i=i^{\\prime}=0\\enspace.</span></p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 3.2.</h6>

    <p class="text-gray-300">The function family <span class="math">\\mathcal{F}=\\left\\{f_{k}\\right\\}_{n\\in\\mathbb{N}}</span>, given by Construction 3.1, is a GEOWF, against <span class="math">(m-\\omega(1))</span>-BAPT adversaries, with a privately testable equivalence relation.</p>

    <p class="text-gray-300">High-level idea behind the proof. The proof follows the same high-level ideas as in the previous construction, except that now there is a private NIUA verification state <span class="math">\\tau</span> that has to remain secret or soundness, and thus also one-wayness, will be compromised. By including an encryption of <span class="math">\\tau</span> in the key, we guarantee that soundness and one-wayness are maintained. However, now the NIUA verification has to be done homomorphically under the encryption. The reason that <span class="math">i</span> is added to the output of the function is to guarantee that we can extract in cases that the adversary produces an output of <span class="math">v,\\hat{\\mathsf{c}}</span>, where <span class="math">\\mathsf{Dec}(\\hat{\\mathsf{c}})=0</span> (e.g. by choosing a false statement). Unlike in the previous construction, the extractor cannot tell that this is the case simply by looking at <span class="math">\\hat{\\mathsf{c}}</span>, which is why we provide it with <span class="math">i</span>.</p>

    <p class="text-gray-300">We now provide a more detailed proof sketch.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">We first show strong one-wayness, and then show weak extractability. The fact that the relation is testable given the coins used to sample <span class="math">k</span> (specifically the decryption key) follows readily.</p>

    <p class="text-gray-300">Strong one-wayness. Assume that given <span class="math">f_{\\sigma,\\mathsf{c}_{\\tau}}(u)</span>, where <span class="math">u\\leftarrow\\{0,1\\}^{t(n)}</span> and <span class="math">(\\sigma,\\mathsf{c}_{\\tau})\\leftarrow\\mathcal{K}(1^{n})</span>, a polysize inverter <span class="math">\\mathcal{I}</span> finds <span class="math">u^{\\prime}</span> such that <span class="math">f_{k}(u)\\sim f_{k}(u^{\\prime})</span> with noticeable probability <span class="math">\\epsilon</span>. We describe a polysize adversary <span class="math">\\mathcal{B}</span> that breaks the soundness of the NIUA with probability <span class="math">\\epsilon-\\mathrm{negl}(n)</span>. Given <span class="math">\\sigma</span>, <span class="math">\\mathcal{B}</span> first samples <span class="math">\\mathsf{c}_{0}\\leftarrow\\mathsf{Enc}(0^{n})</span>, and computes <span class="math">\\hat{\\mathsf{c}}\\leftarrow\\mathsf{Eval}(\\mathcal{C}_{\\mathbf{1}},\\mathsf{c}_{0})</span>. It then samples <span class="math">r\\leftarrow U_{m+n^{2}+2n}</span>, <span class="math">i\\leftarrow U_{n}</span>, and runs the inverter <span class="math">\\mathcal{I}((\\sigma,\\mathsf{c}_{0}),(r,\\hat{\\mathsf{c}},i))</span> who outputs <span class="math">u^{\\prime}=(i^{\\prime};M^{\\prime},y^{\\prime},\\pi^{\\prime};s^{\\prime})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We claim that, with probability <span class="math">\\epsilon-\\mathrm{negl}(n)</span>, <span class="math">\\pi^{\\prime}</span> is a valid certificate for the fact that <span class="math">M^{\\prime}(\\sigma,\\mathsf{c}_{0})=r</span>; namely, <span class="math">\\mathcal{V}(M^{\\prime},(\\sigma,\\mathsf{c}_{0}),y^{\\prime};\\pi,\\tau)=1</span>. Indeed, if this is the case, we are done since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{c}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m+n+n^{2}<span class="math">, and thus </span>M^{\\prime}(\\sigma,\\mathsf{c}_{0})=r<span class="math"> with probability at most </span>2^{-n}<span class="math">. This implies that </span>\\pi^{\\prime}<span class="math"> is an accepting proof for a false statement with probability </span>\\epsilon-\\mathrm{negl}(n)$. To prove the claim we consider two hybrid breakers.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Breaker <span class="math">\\mathcal{B}_{0}</span> samples <span class="math">r_{0}\\leftarrow\\mathsf{PRG}(U_{n})</span>, <span class="math">i\\leftarrow U_{n}</span> on its own, gets an external encryption <span class="math">\\mathsf{c}_{\\tau}</span> of the random coins used by the generator <span class="math">\\mathcal{G}</span> of the NIUA system, computes <span class="math">\\hat{\\mathsf{c}}\\leftarrow\\mathsf{Eval}(\\mathcal{C}_{\\mathbf{1}},\\mathsf{c}_{\\tau})</span>, and runs <span class="math">\\mathcal{I}((\\sigma,\\mathsf{c}_{\\tau}),(r_{0},\\hat{\\mathsf{c}},i))</span>. We claim that, with probability <span class="math">\\epsilon-\\mathrm{negl}(n)</span>, <span class="math">\\mathcal{B}_{0}</span> obtains <span class="math">u^{\\prime}</span> such that <span class="math">f_{\\sigma,\\mathsf{c}_{\\tau}}(u^{\\prime})\\sim(r_{0},\\hat{\\mathsf{c}},i)</span>. Indeed, <span class="math">\\mathcal{I}</span>’s input is distributed identically to the original inversion experiment conditioned on <span class="math">i\\neq 0^{n}</span>, which occurs with probability <span class="math">1-2^{-n}</span>.</p>

    <p class="text-gray-300">Now, consider <span class="math">\\mathcal{B}_{0}</span>’s output <span class="math">u^{\\prime}=(i^{\\prime};M^{\\prime},y^{\\prime},\\pi^{\\prime};s^{\\prime})</span>. We claim that, except with negligible probability, whenever <span class="math">(r_{0},\\hat{\\mathsf{c}},i)\\sim f_{\\sigma,\\mathsf{c}_{\\tau}}(u^{\\prime})</span>, it must be that <span class="math">i^{\\prime}=0^{n}</span> (and <span class="math">i\\neq 0^{n}</span>), meaning that <span class="math">\\mathcal{B}_{0}</span> finds <span class="math">(M^{\\prime},y^{\\prime},\\pi^{\\prime})</span>, such that <span class="math">\\mathsf{Dec}(\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathsf{c}_{\\tau}))=\\mathsf{Dec}(\\hat{\\mathsf{c}})=1</span>, and <span class="math">y^{\\prime}=r_{0}</span>, which in turn implies that <span class="math">\\pi^{\\prime}</span> is an accepting proof for the fact that <span class="math">M^{\\prime}(\\sigma,\\mathsf{c}_{\\tau})=y^{\\prime}=r_{0}</span>. Indeed, if (relative) inversion occurs with noticeable probability when <span class="math">i^{\\prime}\\neq 0^{n}</span>, we can use <span class="math">\\mathcal{B}_{0}</span> to invert <span class="math">\\mathsf{PRG}</span>, contradicting its one-wayness.</p>

    <p class="text-gray-300">Breaker <span class="math">\\mathcal{B}_{1}</span> operates exactly like <span class="math">\\mathcal{B}_{0}</span>, but gets an external encryption <span class="math">\\mathsf{c}_{0}</span> of <span class="math">0^{n}</span>, instead of <span class="math">\\tau</span>. By semantic security, <span class="math">\\mathcal{B}_{1}</span> would also find <span class="math">(M^{\\prime},\\pi^{\\prime})</span> such that <span class="math">\\pi^{\\prime}</span> is a valid for certificate for the statement “<span class="math">M^{\\prime}(\\sigma,\\mathsf{c}_{0})=r_{0}</span> within <span class="math">T(n)</span> steps” with probability <span class="math">\\epsilon-\\mathrm{negl}(n)</span>.</p>

    <p class="text-gray-300">To conclude the proof, we observe that the only difference between <span class="math">\\mathcal{B}_{1}</span> and <span class="math">\\mathcal{B}</span> is that <span class="math">\\mathcal{B}</span> samples <span class="math">r\\leftarrow U_{m+n^{2}+2n}</span>, rather than <span class="math">r_{0}\\leftarrow\\mathsf{PRG}(U_{n})</span>, and so the claim follows by pseudo-randomness.</p>

    <p class="text-gray-300">Weak extractability. We now show weak extractability via a universal extractor <span class="math">\\mathsf{Ext}</span> (see Remark 3.1). For an adversarial code <span class="math">M</span> and advice <span class="math">z\\in\\{0,1\\}^{m-\\omega(1)}</span> denote by <span class="math">M_{z}</span> the machine <span class="math">M(\\cdot;z)</span>. Given any key <span class="math">k=(\\sigma,\\mathsf{c}_{\\tau})</span> and <span class="math">(M,z)</span>, where <span class="math">M_{z}</span> has description size at most <span class="math">m(n)</span> and running time at most <span class="math">t&lt;T(n)</span>, and <span class="math">M_{z}(\\sigma,\\mathsf{c}_{\\tau})=(y,\\hat{\\mathsf{c}},i)\\in\\mathsf{Image}(f_{k})</span>.</p>

    <p class="text-gray-300">Our extractor <span class="math">\\mathsf{Ext}</span> works according to two cases. If <span class="math">i=0^{n}</span>, the extractor simply outputs some canonical <span class="math">u^{\\prime}_{\\star}=(i^{\\prime};M^{\\prime},y^{\\prime},\\pi^{\\prime};s^{\\prime})</span>, such that <span class="math">i^{\\prime}=0^{n}</span>. If <span class="math">i\\neq 0^{n}</span>, <span class="math">\\mathsf{Ext}</span> computes a certificate <span class="math">\\pi</span> for the fact that “<span class="math">M_{z}(\\sigma,\\mathsf{c}_{\\tau})=y</span>”, and then outputs the (relative) pre-image <span class="math">u^{\\prime}=(0^{n},M_{z},y,\\pi,s)</span>, where <span class="math">s</span> could be any arbitrary string, e.g., <span class="math">1^{n}</span>. By definition <span class="math">f_{k}(u^{\\prime})=(y,\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathsf{c}_{\\tau}),0^{n})</span>, so to guarantee that <span class="math">f_{k}(u^{\\prime})\\sim(y,\\hat{\\mathsf{c}},i)</span>, it is left to see that <span class="math">\\mathsf{Dec}(\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathsf{c}_{\\tau}))=\\mathsf{Dec}(\\hat{\\mathsf{c}})</span>. Indeed, if <span class="math">i\\neq 0^{n}</span>, it is guaranteed that <span class="math">\\mathsf{Dec}(\\hat{\\mathsf{c}})=1</span>. Furthermore, for any <span class="math">k\\in\\mathrm{supp}(\\mathcal{K}(1^{n}))</span>, by the perfect completeness of the NIUA system and perfect correctness of the 1-Hop homomorphic encryption, it also holds that <span class="math">\\mathsf{Dec}(\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathsf{c}_{\\tau}))=1</span>. ∎</p>

    <p class="text-gray-300">Everywhere extractability and oblivious image sampling. We note that the extractor described above works for <span class="math">k\\in\\mathrm{supp}(\\mathcal{K}(1^{n}))</span>, and not only for an overwhelming fraction of keys in the support. However, the extractor is not guaranteed to work for a maliciously chosen <span class="math">k\\notin\\mathrm{supp}(\\mathcal{K}(1^{n}))</span>. For example, if the NIUA keys <span class="math">\\sigma</span> and <span class="math">\\tau</span> (determined by <span class="math">\\mathsf{c}_{\\tau}</span>) are maliciously sampled, it may be that the NIUA verification procedure would reject true statements; in particular, it could be that <span class="math">\\mathsf{Dec}(\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathsf{c}_{\\tau}))=0</span>, and thus extraction would fail. Looking ahead, the very same problem would prevent us from obtaining oblivious image sampling for maliciously chosen keys.</p>

    <p class="text-gray-300">We now show, however, that we can slightly augment the construction so it would satisfy both everywhere extractability and oblivious image sampling. The high-level idea is to simply embed inside the function a test for the validity of the key <span class="math">k</span>.</p>

    <p class="text-gray-300">Specifically, instead of including in the key only an encryption <span class="math">\\mathsf{c}_{\\tau}</span> of the NIUA’s private verification state, we will include an encryption <span class="math">\\mathsf{c}_{r}</span> of the randomness <span class="math">r</span> used by the NIUA generator <span class="math">\\mathcal{G}</span> to sample <span class="math">(\\sigma,\\tau)</span>. Now, instead of the circuit <span class="math">\\mathcal{C}_{\\mathcal{V}}=\\mathcal{C}_{\\mathcal{V}}\\left(M,\\sigma,\\mathsf{c},y,\\pi,\\cdot\\right)</span> that, given <span class="math">\\tau</span> as input, verifies that <span class="math">\\mathcal{V}(M,(\\sigma,\\mathsf{c}),y;\\pi,\\tau)=1</span>, we will consider a new circuit <span class="math">\\mathcal{C}_{\\mathcal{V},\\mathcal{G}}\\left(M,\\sigma,\\mathsf{c},y,\\pi,\\cdot\\right)</span> that, given <span class="math">r</span> derives <span class="math">\\tau</span>, and checks the above, but in addition also checks that <span class="math">\\sigma</span> is consistent with <span class="math">\\mathcal{G}(1^{n};r)</span>. Analogously, instead of the circuit <span class="math">\\mathcal{C}_{\\mathbf{1}}</span> that always outputs <span class="math">1</span>, we will consider the circuit <span class="math">\\mathcal{C}_{\\mathcal{G}}(\\sigma,\\cdot)</span> that, given <span class="math">r</span>, checks that <span class="math">\\sigma</span> is consistent with <span class="math">\\mathcal{G}(1^{n};r)</span>. A last additional tweak meant to support oblivious image sampling is that now the homomorphic evaluation procedures will be randomized to guarantee circuit privacy.</p>

    <p class="text-gray-300">Overall the augmented function <span class="math">f_{\\sigma,\\mathsf{c}_{r}}</span> is defined as follows:</p>

    <p class="text-gray-300">\\[ \\big{(}i;M,y,\\pi;s;r^{\\prime}\\big{)}\\stackrel{{\\scriptstyle f_{\\sigma,\\mathsf{c}_{\\tau}}}}{{\\longmapsto}}\\begin{cases}y,\\hat{\\mathsf{c}}_{\\mathcal{V},\\mathcal{G}},i&\\text{if }i=0^{n}\\\\ \\mathsf{PRG}(s),\\hat{\\mathsf{c}}_{\\mathcal{G}},i&\\text{if }i\\neq 0^{n}\\end{cases}, \\]</p>

    <p class="text-gray-300">where <span class="math">\\hat{\\mathsf{c}}_{\\mathcal{V}}\\leftarrow\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathsf{c}_{r};r^{\\prime})</span> and <span class="math">\\hat{\\mathsf{c}}_{\\mathcal{G}}\\leftarrow\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{G}},\\mathsf{c}_{\\tau};r^{\\prime})</span> are now randomized to guarantee circuit privacy. The proximity relation <span class="math">\\sim</span> is augmented to account also for the case that <span class="math">\\mathsf{Dec}(\\hat{\\mathsf{c}})=0</span> (due to a malicious choice of keys):</p>

    <p class="text-gray-300"><span class="math">y=y^{\\prime}</span> and <span class="math">\\mathsf{Dec}(\\hat{\\mathsf{c}})=\\mathsf{Dec}(\\hat{\\mathsf{c}}^{\\prime}),</span> or <span class="math">i=i^{\\prime}=0</span> .</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Claim 3.1.</h6>

    <p class="text-gray-300">The augmented construction is a GEOWF that satisfies both everywhere extractability and oblivious image sampling.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">First, since for an honestly sampled <span class="math">k</span> the new function is equivalent to the previous, strong one-wayness of the function holds just as before. As for extractability, the extractor is defined exactly as before only that now it also has to output randomness <span class="math">r^{\\prime}</span> for the homomorphic evaluation, which it will just sample uniformly at random. Now, even when <span class="math">k\\notin\\operatorname{supp}(\\mathcal{K}(1^{n}))</span>, extraction is still guaranteed. Indeed, the only case that changes is when <span class="math">\\sigma</span> is not sampled consistently with <span class="math">r</span> and <span class="math">i\\neq 0^{n}</span>; here, both <span class="math">\\hat{\\mathsf{c}}_{V,\\mathcal{G}}</span> corresponding to the extracted value, and <span class="math">\\hat{\\mathsf{c}}_{\\mathcal{G}}</span> corresponding to the adversary’s image would decrypt to <span class="math">0</span>.</p>

    <p class="text-gray-300">We next show that oblivious key sampling holds. The image sampler <span class="math">\\mathcal{I}</span>, given a key <span class="math">k=(\\tau,\\mathsf{c}_{r})</span> and an image <span class="math">v=(y,\\hat{\\mathsf{c}},i)</span>, acts according to two cases (similarly to the extractor). If <span class="math">i=0^{n}</span>, it can completely imitate the extractor choosing a canonical <span class="math">u^{\\prime}_{<em>}=(i^{\\prime};M^{\\prime},y^{\\prime},\\pi^{\\prime};s^{\\prime};r^{\\prime})</span> with <span class="math">i^{\\prime}=n</span>, and outputting <span class="math">\\tilde{v}=f_{k}(u^{\\prime}_{</em>})</span>. If <span class="math">i\\neq 0^{n}</span>, <span class="math">\\mathcal{I}</span> outputs <span class="math">\\tilde{v}=(y,\\hat{\\mathsf{c}}^{\\prime\\prime},i)</span>, where <span class="math">\\hat{\\mathsf{c}}^{\\prime\\prime}\\leftarrow\\mathsf{Eval}(\\mathcal{C}_{\\mathcal{G}},\\mathsf{c}_{\\tau})</span> (and <span class="math">\\mathsf{Eval}</span> is randomized). Indeed, the image output by <span class="math">\\mathcal{I}</span> is the same as the one induced by the extractor, except that <span class="math">\\hat{\\mathsf{c}}^{\\prime\\prime}</span> may differ from the evaluated cipher <span class="math">\\hat{\\mathsf{c}}^{\\prime}</span> output by the extractor. However, as explained above, we are guaranteed that in this case <span class="math">\\mathsf{Dec}(\\hat{\\mathsf{c}}^{\\prime\\prime})=\\mathsf{Dec}(\\hat{\\mathsf{c}}^{\\prime})</span>, and so by the circuit privacy of the 1-Hop scheme, the output <span class="math">\\tilde{v}</span> of <span class="math">\\mathcal{I}</span> is computationally indistinguishable from the output <span class="math">v^{\\prime}</span> induced by the extraction procedure <span class="math">\\mathsf{Ext}</span>. (Recall that circuit privacy here holds even if the cipher <span class="math">\\mathsf{c}_{r}</span> is sampled maliciously.) ∎</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 3.3 (one-wayness against superpolynomial adversaries).</h6>

    <p class="text-gray-300">In Section 4.3.2, we shall require GEOWFs that are one way even against adversaries of size <span class="math">\\operatorname{poly}(T(n))</span>, for some superpolynomial function <span class="math">T(n)</span>. Such GEOWFs can be obtained from our constructions, by using a PRG that is secure that is secure against <span class="math">\\operatorname{poly}(T(n))</span> adversaries, and an NIUA that is sound against such adversaries (such an NIUA can be obtained from <em>[x12]</em>, based on an appropriately strong private information retrieval scheme).</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 2-Message and 3-Message Zero-Knowledge against Verifiers with Bounded Advice</h2>

    <p class="text-gray-300">In this section, we define and construct two and three message ZK arguments against verifiers with bounded advice.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.1 Definition</h3>

    <p class="text-gray-300">The standard definition of zero-knowledge <em>[x10, x11]</em> considers adversarial verifiers with non-uniform auxiliary input of arbitrary polynomial size. We consider a relaxed notion of zero-knowledge against verifiers that have bounded non-uniform advice, but arbitrary polynomial running time. This relaxed notion, in particular, includes zero-knowledge against uniform verifiers (sometimes referred to as <em>plain zero-knowledge</em> <em>[x5]</em>).</p>

    <p class="text-gray-300">Concretely, we shall focus on PPT verifiers <span class="math">V^{*}</span> having advice <span class="math">z</span> of size at most <span class="math">m</span>, and using an arbitrary polynomial number of random coins.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">An argument system <span class="math">(P,V)</span> is zero-knowledge against verifiers with <span class="math">m</span>-bounded advice if for every PPT verifier <span class="math">V^{*}</span>, there exists a PPT simulator <span class="math">\\mathsf{Sim}</span> such that:</p>

    <p class="text-gray-300">\\[ \\{\\langle P(w)\\leftrightarrows V^{*}(z)\\rangle(x)\\}_{\\begin{subarray}{c}(x,w)\\in\\mathcal{R}_{\\mathcal{L}}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\in\\{0,1\\}^{m(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\end{subarray}}\\approx_{c}\\{\\mathsf{Sim}(z,x)\\}_{\\begin{subarray}{c}(x,w)\\in\\mathcal{R}_{\\mathcal{L}}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where computational indistinguishability is with respect to arbitrary non-uniform distinguishers.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Remark 4.1 (universal simulator).</h6>

    <p class="text-gray-300">In the above definition, each PPT <span class="math">V^{<em>}</span> is required to have a designated PPT simulator <span class="math">\\mathsf{Sim}^{</em>}_{V}</span>. Our constructions will, in fact, guarantee the existence of one universal simulator <span class="math">\\mathsf{Sim}</span> that, in addition to <span class="math">(z,x)</span>, is also given the code of <span class="math">V^{<em>}</span> and a bound <span class="math">1^{t^{</em>}_{V}}</span> on the running time of <span class="math">V^{<em>}(x;z)</span>, and simulates <span class="math">V^{</em>}</span>’s view. Moreover, the running time of <span class="math">\\mathsf{Sim}</span> is bounded by some (universal) polynomial <span class="math">\\mathrm{poly}(t^{<em>}_{V})</span> in the running time of <span class="math">V^{</em>}</span>. We note that, in ZK with unbounded polynomial auxiliary input, such universality follows automatically by considering the universal machine and auxiliary input <span class="math">(V^{<em>},1^{t^{</em>}_{V}})</span>. In our context, however, this does not hold since <span class="math">t_{V^{*}}</span> is unbounded and can be larger than the bound <span class="math">m</span> on the size of the advice.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">4.2 WI Proof of Knowledge with an Instance-Independent First Message</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we define and construct 3-message WI proofs of knowledge with an instance-independent first message, which will be used in our construction of a 3-message ZK argument of knowledge. In such proof systems, the prover’s first message is completely independent of the statement and witness <span class="math">(x,w)\\in\\mathcal{R}_{\\mathcal{L}}</span> to be proven; in particular, it is of fixed polynomial length in the security parameter <span class="math">n</span>, independently of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Classical WIPOK protocols do not satisfy this requirement. For example, in the classical Hamiltonicity protocol <em>[x1]</em>, the first message is independent of the witness <span class="math">w</span>, but does depend on the statement <span class="math">x</span>. In Lapidot and Shamir’s Hamiltonicity variant <em>[x10]</em>, the first message is independent of <span class="math">(x,w)</span> themselves, but does depend on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (see details in <em>[x12]</em>). ZAPs do satisfy the independence requirement (as there is no first prover message at all), but they do not provide proof of knowledge.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show that, using ZAPs, and 3-message extractable commitments, we can obtain a WIPOK where the first (prover) message is completely independent of <span class="math">(x,w)</span>, even of their length, and the second (verifier) message only depends on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 4.2 (WIPOK with instance-independent first message).</h6>

    <p class="text-gray-300">Let <span class="math">\\langle P\\leftrightarrows V\\rangle</span> be a 3-message proof system for <span class="math">\\mathcal{L}</span> with messages <span class="math">(\\alpha,\\beta,\\gamma)</span>; we say it is a WIPOK with instance-independent first message, if it satisfies:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness with first message independence: For any <span class="math">x\\in\\mathcal{L}\\cap\\{0,1\\}^{\\ell}</span>, <span class="math">w\\in\\mathcal{R}_{\\mathcal{L}}(x)</span>, <span class="math">n\\in\\mathbb{N}</span>:</li>

    </ol>

    <p class="text-gray-300">\\[ \\Pr\\left[V(x,\\alpha,\\beta,\\gamma;r^{\\prime})=1\\begin{vmatrix}&\\alpha\\leftarrow P(1^{n};r)\\\\ &\\beta\\leftarrow V(\\ell,\\alpha;r^{\\prime})\\\\ \\gamma\\leftarrow P(x,w,\\alpha,\\beta;r)\\end{vmatrix}\\right]=1\\enspace, \\]</p>

    <p class="text-gray-300">where <span class="math">r,r^{\\prime}\\leftarrow\\{0,1\\}^{\\mathrm{poly}(n)}</span> are the randomness used by <span class="math">P</span> and <span class="math">V</span>.</p>

    <p class="text-gray-300">The honest prover’s first message <span class="math">\\alpha</span> is of length <span class="math">n</span>, independently of the length of the statement and witness <span class="math">(x,w)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive witness-indistinguishability: for any deterministic polysize verifier <span class="math">V^{*}</span> and all large enough <span class="math">n\\in\\mathbb{N}</span>:</li>

    </ol>

    <p class="text-gray-300">\\[ \\Pr\\left[V^{<em>}(x,\\alpha,\\beta,\\gamma)=b\\begin{vmatrix}&\\alpha\\leftarrow P(1^{n};r)\\\\ &x,w_{0},w_{1},\\beta\\leftarrow V^{</em>}(\\alpha)\\\\ \\gamma\\leftarrow P(x,w_{b},\\alpha,\\beta;r)\\end{vmatrix}\\right]\\leq\\frac{1}{2}+\\mathrm{negl}(n)\\enspace, \\]</p>

    <p class="text-gray-300">where <span class="math">b\\leftarrow\\{0,1\\}</span>, <span class="math">r\\leftarrow\\{0,1\\}^{\\mathrm{poly}(n)}</span> is the randomness used by <span class="math">P</span>, and <span class="math">w_{0},w_{1}\\in\\mathcal{R}_{\\mathcal{L}}(x)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive Proof of knowledge: there is a PPT extractor <span class="math">\\mathsf{Ext}</span>, such that, for any polynomial <span class="math">\\ell = \\ell(n)</span>, all large enough <span class="math">n \\in \\mathbb{N}</span>, and any deterministic prover <span class="math">P^*</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{if } \\operatorname{Pr} \\left[ V(x, \\alpha, \\beta, \\gamma; r') = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\alpha \\leftarrow P^<em> \\\\ \\beta \\leftarrow V(\\ell(n), \\alpha; r') \\\\ x, \\gamma \\leftarrow P^</em>(\\alpha, \\beta) \\end{array} \\right. \\right] \\geq \\epsilon,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{then } \\operatorname{Pr} \\left[ \\begin{array}{l l} w \\leftarrow \\operatorname{Ext}^{P^*}(1^{1/\\epsilon}, x, \\alpha, \\beta, \\gamma) &amp;amp; \\alpha \\leftarrow P^* \\\\ w \\notin \\mathcal{R}_{\\mathcal{L}}(x) &amp;amp; \\beta \\leftarrow V(\\ell(n), \\alpha; r&#x27;) \\\\ x, \\gamma \\leftarrow P^*(\\alpha, \\beta) &amp;amp; \\\\ V(x, \\alpha, \\beta, \\gamma; r&#x27;) = 1 &amp;amp; \\end{array} \\right] \\leq \\operatorname{negl}(n),</span></div>

    <p class="text-gray-300">where <span class="math">x \\in \\{0,1\\}^{\\ell(n)}</span>, and <span class="math">r&#x27; \\gets \\{0,1\\}^{\\mathrm{poly}(n)}</span> is the randomness used by <span class="math">P^*</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction from ZAPs. We now show how to use ZAPs and extractable commitments to construct a WIPOK with the required properties. As mentioned above, ZAPs already have the required independence, but they do not provide POK. The high-level idea is to add the POK feature to ZAPs, while maintaining the required instance-independence. This can be done by having the prover commit to a random string <span class="math">r</span> using a 3-message extractable commitment (e.g., as formalized in [PW09]), and then sending, as the third message, the padded witness <span class="math">w \\oplus r</span> along with a ZAP proof that it was computed correctly. While the first message is independent of <span class="math">x</span>, <span class="math">w</span> it does depend on the length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; this is naturally solved by committing to a seed </span>s<span class="math"> of fixed length and later deriving </span>r$ using a PRG.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Intuitively, extraction of the witness is now possible by extracting <span class="math">r</span> (or <span class="math">s</span>) from the committing prover. To ensure WI we use the idea of turning a single witness statement into a two independent-witnesses statement as done in [FS90, COSV12, BP13].</p>

    <p class="text-gray-300">In what follows, we denote by <span class="math">(\\mathcal{C}, \\mathcal{R})</span> the committer and receiver algorithms of a perfectly-binding 3-message extractable commitment protocol, and we denote by <span class="math">\\vec{C} = (C^{(1)}, C^{(2)}, C^{(3)})</span> its three messages. We further required that extraction is possible given any two valid transcripts <span class="math">\\vec{C}, \\vec{C}&#x27;</span> that share the same first message. Such an extractable commitment can be constructed from any perfectly-binding non-interactive commitment, see e.g. [PW09].</p>

    <p class="text-gray-300"><strong>Lemma 4.1.</strong> Protocol 1 is a 3-message WIPOK with instance-independent first message.</p>

    <p class="text-gray-300">We next prove the lemma. The proof is an adaptation of a proof from [BP13].</p>

    <p class="text-gray-300"><strong>Proof.</strong> We start by showing that the protocol is WI. Let</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathcal{X}, \\mathcal{W}_0, \\mathcal{W}_1) = \\{(x, w_0, w_1) : (x, w_0), (x, w_1) \\in \\mathcal{R}_{\\mathcal{L}} \\}</span></div>

    <p class="text-gray-300">be any infinite sequence of instances in <span class="math">\\mathcal{L}</span> and corresponding witness pairs. We next consider a sequence of hybrids starting with an hybrid describing an interaction with a prover that uses <span class="math">w_0 \\in \\mathcal{W}_0</span>, and ending with an hybrid describing an interaction with a prover that uses <span class="math">w_1 \\in \\mathcal{W}_1</span>, where both <span class="math">w_0, w_1</span>, are witnesses for some <span class="math">x \\in \\mathcal{X}</span>. We shall prove that no efficient verifier can distinguish between any two hybrids in the sequence. The list of hybrids is given in Table 1. We think of the hybrids as two symmetric sequences: one 0.1-6, starts from witness <span class="math">w_0</span>, and the other 1.1-6 starts at witness <span class="math">w_1</span>. We will show that within these sequences the hybrids are indistinguishable, and then we will show that 0.6 is indistinguishable from 1.6.</p>

    <p class="text-gray-300"><strong>Hybrid 0.1:</strong> This hybrid describes a true interaction of a malicious verifier <span class="math">V^*</span> with an honest prover <span class="math">P</span> that uses <span class="math">w_0</span> as a witness for the statement <span class="math">x \\in \\mathcal{L}</span>. In particular, the ZAP uses the witness <span class="math">((s_0, w_0), (s_1, w_0))</span>; formally, the witness also includes the randomness for the commitments <span class="math">\\vec{C}_0</span> and <span class="math">\\vec{C}_1</span>, but for notational brevity, we shall omit it. In Table 1, the witness used in part 0 of the ZAP is referred to as <span class="math">\\mathsf{zapw}_0</span>, and the one corresponding to 1 in <span class="math">\\mathsf{zapw}_1</span>.</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">Common Input: security parameter  <span class="math">n</span> , and  <span class="math">x \\in \\mathcal{L} \\cap \\{0,1\\}^{\\mathrm{poly}(n)}</span> .</p>

    <p class="text-gray-300">Auxiliary Input to  <span class="math">P</span> :  <span class="math">w \\in \\mathcal{R}_{\\mathcal{L}}(x)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.  <span class="math">P</span>  samples seeds  <span class="math">s_0, s_1 \\gets \\{0, 1\\}^{\\sqrt{n}}</span> , and a bit  <span class="math">b \\gets \\{0, 1\\}</span> , and sends the first commitment message to each of the three  <span class="math">(C_0^{(1)}, C_1^{(1)}, C^{(1)}) \\gets (\\mathcal{C}(s_0), \\mathcal{C}(s_1), \\mathcal{C}(b))</span> , where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(C_0^{(1)}, C_1^{(1)}, C^{(1)})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n^a$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P</span> , given  <span class="math">(x, w)</span> , now performs the following:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>computes the third committer messages</li>

    </ul>

    <p class="text-gray-300"><span class="math">(C_0^{(3)}, C_1^{(3)}, C^{(3)}) \\gets (\\mathcal{C}(s_0, C_0^{(2)}), \\mathcal{C}(s_1, C_1^{(2)}), \\mathcal{C}(b, C^{(2)}))</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>computes  <span class="math">a_0 = w \\oplus \\mathsf{PRG}(s_0), a_1 = w \\oplus \\mathsf{PRG}(s_1)</span> .</li>

      <li>computes an ZAP proof  <span class="math">\\pi</span>  for the statement:</li>

    </ul>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A 3-message WIPOK with instance-independent first message</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sends  <span class="math">C_0^{(3)}, C_1^{(3)}, C^{(3)}, a_0, a_1, \\pi</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span>  verifies the ZAP proof  <span class="math">\\pi</span> , the validity of the commitments transcripts, and decides whether to accept accordingly.</li>

    </ol>

    <p class="text-gray-300">Hybrid 0.2: This hybrid differs from the previous one only in the witness used in the ZAP. Specifically, for the bit  <span class="math">b</span>  given by  <span class="math">\\vec{C}</span> , the witness for the ZAP is set to be  <span class="math">(b, (s_{1 - b}, w_0))</span> , instead of  <span class="math">((s_b, w_0), (s_{1 - b}, w_0))</span> . (Again the witness should include the randomness for the commitment  <span class="math">\\vec{C}</span> , and  <span class="math">\\vec{C}_{1 - b}</span> , but is omitted from our notation.) Since the ZAP is WI, this hybrid is computationally indistinguishable from the previous one.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hybrid 0.3: In this hybrid, the commitment  <span class="math">\\vec{C}_b</span>  is for the plaintext  $0^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , instead of the plaintext  </span>s_b<span class="math"> . This hybrid is computationally indistinguishable from the previous one due to the computational hiding of the commitment scheme  </span>\\vec{C}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hybrid 0.4: In this hybrid, instead of padding with  <span class="math">\\mathsf{PRG}(s_b)</span> , padding is done with a random independent string  $u \\gets \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{PRG}(s_b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ . Computational indistinguishability of this hybrid and the previous one, follows pseudorandomness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hybrid 0.5: In this hybrid, the padded value  <span class="math">a_{b}</span>  is taken to be  <span class="math">w_{1} \\oplus r_{b}</span> , instead of  <span class="math">w_{0} \\oplus r_{b}</span> . Since  <span class="math">r_{b}</span>  is now uniform and independent of all other elements, this hybrid induces the exact same distribution as the previous hybrid.</p>

    <p class="text-gray-300">Hybrid 0.6: This hybrid now backtracks, returning to the same experiment as in hybrid 0.1 with</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hyb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zapwb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ab ⊕ rb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zapw1-b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C1-b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r1-b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a1-b ⊕ r1-b</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">(sb, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">PRGb(sb)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">PRGb(sb)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PRGb(sb)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">u</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">u</td>

            <td class="px-3 py-2 border-b border-gray-700">w1</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">(sb, w1)</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">PRGb(sb)</td>

            <td class="px-3 py-2 border-b border-gray-700">w1</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">(sb, w0)</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">PRGb(sb)</td>

            <td class="px-3 py-2 border-b border-gray-700">w0</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w1)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1.2-5</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">(sb, w1)</td>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">PRGb(sb)</td>

            <td class="px-3 py-2 border-b border-gray-700">w1</td>

            <td class="px-3 py-2 border-b border-gray-700">(s1-b, w1)</td>

            <td class="px-3 py-2 border-b border-gray-700">s1-b</td>

            <td class="px-3 py-2 border-b border-gray-700">PRG(s1-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">w1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: The sequence of hybrids; the bit  <span class="math">b</span>  corresponds to the bit commitment  <span class="math">\\bar{C}</span> ; the gray cells indicate the difference from the previous hybrid.</p>

    <p class="text-gray-300">the exception that the ZAP witness is now  <span class="math">((s_b, w_1), (s_{1-b}, w_0))</span>  instead of  <span class="math">((s_b, w_0), (s_{1-b}, w_0))</span> . This indistinguishability follows exactly as when moving from 0.1 to 0.5 (only backwards).</p>

    <p class="text-gray-300">Hybrids 1.1 to 1.6: These hybrids are symmetric to the above hybrids, only that they start from  <span class="math">w_{1}</span>  instead of  <span class="math">w_{0}</span> . This means that they end in 1.6 which uses an ZAP witness  <span class="math">((s_b, w_0), (s_{1 - b}, w_1))</span> , which is the same as 0.6, only in reverse order.</p>

    <p class="text-gray-300">Hybrids 0.6 and 1.6 are computationally indistinguishable. This follows directly from the computational hiding of the commitment  <span class="math">\\vec{C}</span>  to  <span class="math">b</span> . Indeed, assume towards contradiction that  <span class="math">V</span>  distinguishes the two hybrids. Concretely, denote the probability it outputs 1 on 0.6 by  <span class="math">p_0</span> , and the probability it outputs 1 on 1.6 by  <span class="math">p_1</span> , and assume WLOG that  <span class="math">p_0 - p_1 \\geq \\epsilon</span> , for some noticeable  <span class="math">\\epsilon = \\epsilon(n)</span> . We can construct a predictor that given a commitment  <span class="math">\\vec{C} = \\mathcal{C}(b)</span>  to a random bit  <span class="math">b \\gets \\{0,1\\}</span> , guesses  <span class="math">b</span>  with probability  <span class="math">\\frac{1 + \\epsilon}{2}</span> . The predictor, samples a random  <span class="math">b&#x27; \\gets \\{0,1\\}</span>  as a candidate guess for  <span class="math">b</span> , and performs the experiment corresponding to 0.6, only that it locates  <span class="math">w_0</span>  and  <span class="math">w_1</span>  according to  <span class="math">b&#x27;</span> , rather than the unknown  <span class="math">b</span> . If the distinguisher outputs 1, the predictor guesses  <span class="math">b = b&#x27;</span>  and otherwise it guesses  <span class="math">b = 1 - b&#x27;</span> .</p>

    <p class="text-gray-300">Conditioned on  <span class="math">b = b&#x27;</span> ,  <span class="math">V</span>  is experiencing 0.6, and thus the guess will be correct with probability  <span class="math">p_0</span> ; conditioned on  <span class="math">b = 1 - b&#x27;</span> ,  <span class="math">V</span>  is experiencing 1.6, and the guess will be right with probability  <span class="math">1 - p_1</span> . So overall the guessing probability is  <span class="math">\\frac{p_0}{2} + \\frac{1 - p_1}{2} \\geq \\frac{1}{2} + \\frac{\\epsilon}{2}</span> . This completes the proof that the protocol is WI.</p>

    <p class="text-gray-300">It is left to show that the protocol is an argument of knowledge. Indeed, let  <span class="math">P^<em></span>  be any prover that convinces the honest verifier of accepting with noticeable probability  <span class="math">\\epsilon = \\epsilon(n)</span> , then with probability at least  <span class="math">\\epsilon/2</span>  over its first message, it holds with probability at least  <span class="math">\\epsilon/2</span>  over the rest of the protocol that  <span class="math">P^</em></span>  convinces  <span class="math">V</span> . Let us call such a prefix good. Now for any good prefix, we can consider the perfectly binding induced commitment to the bit  <span class="math">b</span> , and from the soundness of the ZAP, we get a circuit that with probability at least  <span class="math">\\epsilon/2 - \\mathrm{negl}(n)</span>  completes produces an accepting commitment transcript for the plaintext  <span class="math">s_{1-b}</span> , and gives a valid witness  <span class="math">w \\in \\mathcal{R}_{\\mathcal{L}}</span> , padded with  <span class="math">\\mathrm{PRG}(s_{1-b})</span> . This in particular, means that we can first sample a prefix (hope it is good), and then use the extraction guarantee of the commitment to learn  <span class="math">s_{1-b}</span>  and  <span class="math">\\mathrm{PRG}(s_{1-b})</span> , and thus also the witness  <span class="math">w</span> . This completes the proof of Lemma 4.1.</p>

    <p class="text-gray-300">2-message WI with instance-independent first message. We shall also make use of 2-message WI with instance-independent first message. Here, there are two verifier and prover messages. Like in the three message definition the verifier message does not depend on the instance, but is allowed to depend on its length. In such a protocol, we only require soundness. ZAPs, for instance, satisfy this requirement, but we can also do with a privately verifiable protocol rather than a ZAP. (In fact, also in the above construction of 3-message WIPOKs with instance-independent first message, the ZAPs can be replace with any 2-message WI with instance-independent first message.</p>

    <p class="text-gray-300">In this section, we construct zero-knowledge protocols against verifiers with bounded advice from generalized extractable one-way functions against adversaries with bounded advice (GEOWFs against BAPT adversaries). We start by describing a construction of a 3-message argument of knowledge from any GEOWF that is everywhere extractable and has oblivious image verification, and every 3-message WIPOK with instance-independent first message. We then show a 2-message argument, assuming (non-interactive) commitments that can be inverted in super-poly time  <span class="math">T(n)</span> , GEOWFs that are one-way against  <span class="math">\\mathrm{poly}(T(n))</span> -size adversaries, and any 2-message WI with instance-independent verifier message (in particular, ZAPs).</p>

    <p class="text-gray-300">In what follows, let  <span class="math">\\mathcal{F}</span>  be a family of GEOWFs, against  <span class="math">m</span> -BAPT adversaries, and assume that  <span class="math">\\mathcal{F}</span>  is everywhere extractable and has an oblivious image sampler  <span class="math">\\mathcal{I}</span> . We shall denote by  <span class="math">(\\mathrm{wi}_1, \\mathrm{wi}_2, \\mathrm{wi}_3)</span>  the messages of a WIPOK with an instance-independent first message (as in Definition 4.2). The protocol is given in Figure 2.</p>

    <p class="text-gray-300">Common Input:  <span class="math">x \\in \\mathcal{L} \\cap \\{0,1\\}^n</span> .</p>

    <p class="text-gray-300">Auxiliary Input to  <span class="math">P</span> : a witness  <span class="math">w</span>  for  <span class="math">x</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P</span>  sends the first message  <span class="math">\\mathsf{wi}_1\\in \\{0,1\\} ^n</span>  of the instance-dependent WIPOK.</li>

      <li><span class="math">V</span>  samples  <span class="math">k\\gets \\mathcal{K}(1^n;r),u\\gets \\{0,1\\}^{\\ell (n)}</span>  , computes  <span class="math">v = f_{k}(u)</span>  and sends  <span class="math">(k,v)</span>  , as well as the second WIPOK message  <span class="math">\\mathsf{wi}_2</span></li>

      <li><span class="math">P</span>  samples  <span class="math">\\tilde{v} \\gets \\mathcal{I}(k, v)</span> , and sends  <span class="math">\\tilde{v}</span> , together with the third WIPOK message  <span class="math">\\mathsf{wi}_3</span>  stating that:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\{x\\in \\mathcal{L}\\} \\bigvee \\left\\{\\exists u:\\tilde{v} = f_k(u)\\right\\} ,</span></p>

    <p class="text-gray-300">using the witness  <span class="math">w\\in \\mathcal{R}_{\\mathcal{L}}(x)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span>  verifies the proof and tests that the equivalence relation holds by running  <span class="math">\\mathcal{T}(v,\\tilde{v},r)</span></li>

    </ol>

    <p class="text-gray-300">Figure 2: A 3-message ZK argument of knowledge against verifiers with  <span class="math">m</span> -bounded advice.</p>

    <p class="text-gray-300">Theorem 4.1. Protocol 2 is a zero-knowledge argument of knowledge against  <span class="math">m</span> -BAPT verifiers.</p>

    <p class="text-gray-300">Remark 4.2 (Instance-independent first-message). An additional feature of the protocol is that it preserves the first message instance-independence of the WIPOK system.</p>

    <p class="text-gray-300">The high-level idea behind the proof is provided in the introduction, we now provide a more detailed proof sketch.</p>

    <p class="text-gray-300">Proof sketch. We first show that the protocol is an argument of knowledge.</p>

    <p class="text-gray-300">Claim 4.1. Protocol 2 is an argument of knowledge against against arbitrary polysize provers.</p>

    <p class="text-gray-300">Proof sketch. Let  <span class="math">P^<em></span>  be any polysize prover that convinces  <span class="math">V</span>  of accepting with noticeable probability  <span class="math">\\epsilon = \\epsilon(n)</span> . The witness extractor would derive from  <span class="math">P^</em></span>  a new prover for  <span class="math">P_{\\mathrm{wi}}^<em></span>  that emulates  <span class="math">P^</em></span>  in the WIPOK; in particular, it would honestly sample  <span class="math">(k, v)</span>  as part of the second verifier message that  <span class="math">P^<em></span>  gets. The extractor would then choose the random coins  <span class="math">r</span>  for  <span class="math">P_{\\mathrm{wi}}^</em></span> , sample a transcript  <span class="math">\\mathrm{tr}_{\\mathrm{wi}}</span>  of an execution</p>

    <p class="text-gray-300">with the honest WIPOK verifier <span class="math">V_{\\mathsf{wi}}</span>, and apply the WIPOK extractor on the transcript <span class="math">\\mathsf{tr}</span>, with oracle access to <span class="math">P^{*}_{\\mathsf{wi}}</span>. The WIPOK extractor then hopefully obtains a witness for the WI statement</p>

    <p class="text-gray-300"><span class="math">\\{x\\in\\mathcal{L}\\}\\bigvee\\left\\{\\exists u:\\tilde{v}=f_{k}(u)\\right\\}\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">(k,v)</span> are those honestly sampled by <span class="math">P^{<em>}_{\\mathsf{wi}}</span>, and <span class="math">\\tilde{v}</span> is output by <span class="math">P^{</em>}</span>.</p>

    <p class="text-gray-300">We claim that, with noticeable probability <span class="math">\\epsilon^{2}/2-\\mathrm{negl}(n)</span>, we find a witness <span class="math">w</span> for the first part of the statement <span class="math">x\\in\\mathcal{L}</span>. Otherwise, we can use <span class="math">P^{<em>}</span> to break the (strong) one-wayness of <span class="math">\\mathcal{F}</span>. To prove the claim, we first note that the emulated transcript <span class="math">\\mathsf{tr}</span> in this experiment is distributed identically to the transcript in a real execution of <span class="math">P^{</em>}</span> with the honest verifier. Thus, we know that such a transcript <span class="math">\\mathsf{tr}</span> is accepted by <span class="math">V</span> with probability at least <span class="math">\\epsilon</span>. Now, let us call random coins <span class="math">r</span> for <span class="math">P^{<em>}_{\\mathsf{wi}}</span> good if they are such that with probability at least <span class="math">\\epsilon/2</span> over the coins of the WIPOK verifier <span class="math">V_{\\mathsf{wi}}</span>, it accepts the proof given by <span class="math">P^{</em>}_{\\mathsf{wi}}</span>. Since we know that overall <span class="math">V_{\\mathsf{wi}}</span> accepts with probability at least <span class="math">\\epsilon</span>, then by a standard averaging argument, at least an <span class="math">\\epsilon/2</span> fraction of the coins <span class="math">r</span> for <span class="math">P^{*}_{\\mathsf{wi}}</span> are good. Furthermore, conditioned on a transcript <span class="math">\\mathsf{tr}</span> that is accepted by <span class="math">V</span>, the probability that the corresponding coins <span class="math">r</span> are good increases. Thus, it follows that the probability that <span class="math">\\mathsf{tr}</span> is accepting and the corresponding coins <span class="math">r</span> are good is at least <span class="math">\\epsilon\\cdot\\epsilon/2</span>. Now, recall that, whenever this occurs, the extractor for the WIPOK would also output a witness for the corresponding statement (except with negligible probability).</p>

    <p class="text-gray-300">We would like to show that the extracted witness is the one for the <span class="math">x\\in\\mathcal{L}</span> statement. Indeed, assume that, with noticeable probability <span class="math">\\eta</span> , it holds that <span class="math">\\mathsf{tr}</span> is accepting, the extractor outputs a witness, but the witness is for the second statement. This, in particular, means that the witness extractor outputs <span class="math">u^{\\prime}</span>, and <span class="math">v^{\\prime}=f_{k}(u^{\\prime})</span>, such that <span class="math">\\tilde{v}=f_{k}(u^{\\prime})</span>, where <span class="math">\\tilde{v}</span> is the output of <span class="math">P^{*}</span>. Moreover, since the transcript is accepting, we know that <span class="math">v\\sim v^{\\prime}</span>.</p>

    <p class="text-gray-300">We can now construct an inverter that breaks the (strong) one-wayness of <span class="math">\\mathcal{F}</span>. The inverter, given <span class="math">(k,v)</span> would simply emulate all of the experiment above on its own, where <span class="math">P_{\\mathsf{wi}}</span> would use <span class="math">(k,v)</span> to emulate the second verifier message, instead of sampling it on its own. By the above, it would obtain a (relative) preimage with noticeable probability <span class="math">\\eta</span>.</p>

    <p class="text-gray-300">This completes the proof. ∎</p>

    <p class="text-gray-300">We next show that the protocol is ZK. We note that, since the ZK simulator is allowed to simulate the (apriori unbounded) randomness of the verifier <span class="math">V^{<em>}</span>, we can restrict attention to verifiers <span class="math">V^{</em>}</span> that only have bounded randomness. Indeed (assuming there exist OWFs), we can always consider a new verifier <span class="math">\\widehat{V}^{<em>}</span> that first stretches its bounded randomness using a PRG and then emulates <span class="math">V^{</em>}</span>. Then to simulate the view of <span class="math">V^{<em>}</span>, we can first apply the simulator <span class="math">\\widehat{\\mathsf{Sim}}</span> for <span class="math">\\widehat{V}^{</em>}</span>, and then apply the PRG on the simulated randomness to obtain a full simulated view for <span class="math">V^{<em>}</span>. In particular, from hereon we we can simply focus on deterministic verifiers <span class="math">V^{</em>}</span> that get their bounded randomness as part of their bounded advice.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Claim 4.2.</h6>

    <p class="text-gray-300">Protocol 2 is ZK against any polytime verifier <span class="math">V^{*}</span> with advice of size at most <span class="math">m(n)-2n</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">We describe a universal ZK simulator <span class="math">\\mathsf{Sim}</span> and show its validity (universality is in the sense of Remark 4.1). Let <span class="math">x\\in\\mathcal{L}</span> and let <span class="math">V^{<em>}</span> be the code of any malicious verifier, and let <span class="math">z^{\\prime}</span> be any advice of length at most <span class="math">m-2n</span>. <span class="math">\\mathsf{Sim}</span> starts by honestly computing the first message <span class="math">\\mathsf{wi}_{1}\\in\\{0,1\\}^{n}</span> of the WIPOK with instance-independent first message. It then feeds <span class="math">\\mathsf{wi}_{1}</span> to <span class="math">V^{</em>}(x;z^{\\prime})</span> who returns <span class="math">(k,v,\\mathsf{wi}_{2})</span> that are (allegedly) a key for an extractable function, an image under the function, and the second message of the WIPOK.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Sim}</span> now constructs from the code of <span class="math">V^{<em>}</span> a machine <span class="math">M_{V^{</em>}}</span> that, given <span class="math">k</span> and <span class="math">z=(z^{\\prime},x,\\mathsf{wi}_{1})</span> as input, outputs some <span class="math">v</span>, and whose running time is linear in the running time <span class="math">t_{V^{<em>}}</span> of <span class="math">V^{</em>}</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{wi}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m(n)<span class="math">, and thus </span>\\mathsf{Sim}<span class="math"> can apply the extractor </span>\\mathsf{Ext}<span class="math"> on </span>M_{V^{<em>}}<span class="math">, and obtain </span>u^{\\prime}\\in\\{0,1\\}^{\\ell}<span class="math"> in time </span>\\mathrm{poly}(t_{V}^{</em>})<span class="math">. </span>\\mathsf{Sim}<span class="math"> now computes </span>v^{\\prime}=f_{k}(u^{\\prime})<span class="math"> to </span>V^{*}<span class="math">, and completes the WIPOK using the trapdoor </span>u^{\\prime}$ as a witness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The validity of the simulator now follows by witness indistinguishability, as well as the oblivious image sampling guarantee. Specifically, we can first move to a hybrid simulator Sim' that proves the WIPOK statement using the witness  <span class="math">w</span> . The view generated by Sim' is indistinguishable from the one generated by Sim due to the WI property. Now, we can claim that the view generated by Sim' is indistinguishable from that generated by honest prover  <span class="math">P</span> . Indeed, the only difference between the two is that  <span class="math">P</span>  sends  <span class="math">\\tilde{v} \\gets \\mathcal{I}(k,v)</span> , whereas Sim' sends  <span class="math">v&#x27; = f_k(u&#x27;)</span> , for the extracted input  <span class="math">u&#x27;</span> ; however, by the oblivious image sampling guarantee  <span class="math">\\tilde{v} \\approx_c v&#x27;</span> .</p>

    <p class="text-gray-300">This completes the proof of Theorem 4.1.</p>

    <p class="text-gray-300">In this section, we show that, using complexity leveraging (and superpolynomial hardness assumptions), we can augment the protocol from the previous section to a 2-message argument.</p>

    <p class="text-gray-300">In what follows, let  <span class="math">\\mathcal{C}</span>  be a perfectly binding commitment that is hiding against polysize adversaries, and can be completely inverted in time  <span class="math">T(n)</span> , for some computable super-polynomial function  <span class="math">T(n) = n^{\\omega(1)}</span> . Let  <span class="math">\\mathcal{F}</span>  be a family of GEOWFs, against  <span class="math">m</span> -BAPT adversaries, and assume that  <span class="math">\\mathcal{F}</span>  is everywhere extractable and has an oblivious image sampler  <span class="math">\\mathcal{I}</span> . Further assume that  <span class="math">\\mathcal{F}</span>  is one-way against adversaries of size  <span class="math">\\mathrm{poly}(T)</span>  (see Remark 3.3). Also, we shall denote by  <span class="math">(\\mathrm{wi}_1, \\mathrm{wi}_2)</span>  the verifier and prover messages of a 2-message WI with an instance-independent first message (as in Definition 4.2).</p>

    <p class="text-gray-300">Common Input:  <span class="math">x \\in \\mathcal{L} \\cap \\{0,1\\}^n</span> .</p>

    <p class="text-gray-300">Auxiliary Input to  <span class="math">P</span> : a witness  <span class="math">w</span>  for  <span class="math">x</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V</span>  samples  <span class="math">k \\gets \\mathcal{K}(1^n; r)</span> ,  <span class="math">u \\gets \\{0, 1\\}^{\\ell(n)}</span> , computes  <span class="math">v = f_k(u)</span> , and sends  <span class="math">k, v</span> , as well as the first WI message  <span class="math">\\mathsf{wi}_1</span> .</li>

      <li><span class="math">P</span>  samples a commitment to zero  <span class="math">C \\gets \\mathcal{C}(0^{\\ell})</span> , and  <span class="math">\\tilde{v} \\gets \\mathcal{I}(k, v)</span> , and sends  <span class="math">C, \\tilde{v}</span> , together with the second WI message  <span class="math">\\mathrm{wi}_2</span>  stating that:</li>

    </ol>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: A 2-message ZK argument against verifiers with bounded advice.</p>

    <p class="text-gray-300">High-level idea behind the proof. Proving ZK against verifiers with bounded advice is essentially the same as in the 3-message protocol, only that now the simulator also commits to the input that it extracts from the verifier (and by the hiding of the commitment ZK is maintained). The proof of soundness is essentially the same as showing POK in the 3-message protocol, only that now we will construct an extractor that works in time  <span class="math">\\mathrm{poly}(T(n))</span> , by inverting the prover's commitment with brute-force. Since one-wayness holds even against  <span class="math">\\mathrm{poly}(T(n))</span> -adversaries, soundness follows.</p>

    <p class="text-gray-300">A more detailed proof follows.</p>

    <p class="text-gray-300">Proof sketch. We first show that the protocol is a sound against polysize adversaries.</p>

    <p class="text-gray-300">Claim 4.3. Protocol 3 is an argument.</p>

    <p class="text-gray-300">Proof sketch. Let <span class="math">P^{<em>}</span> be any polysize prover, and assume towards contradiction that for infinitely many <span class="math">x \\notin \\mathcal{L}</span>, <span class="math">P^{</em>}</span> convinces <span class="math">V</span> of accepting with noticeable probability <span class="math">\\epsilon = \\epsilon(n)</span>. We show to break the strong one-wayness of <span class="math">\\mathcal{F}</span>. The inverter, given <span class="math">(k, v)</span> would sample a first WI message <span class="math">\\mathsf{wi}_1</span>, and feed <span class="math">(k, v, \\mathsf{wi}_1)</span> to <span class="math">P^{*}</span>, who outputs a commitment <span class="math">C</span>, an alleged image <span class="math">\\tilde{v}</span>, and a proof <span class="math">\\mathsf{wi}_2</span> for the statement</p>

    <div class="my-4 text-center"><span class="math-block">\\{x \\in \\mathcal{L}\\} \\bigvee \\left\\{ \\exists u: \\begin{array}{l} \\tilde{v} = f_k(u) \\\\ C = \\mathcal{C}(u) \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">We know that with probability <span class="math">\\epsilon</span> the proof is convincing, so by the soundness of the WI scheme, and since <span class="math">x \\notin \\mathcal{L}</span>, it follows that <span class="math">C</span> is a commitment to a (relative) preimage of <span class="math">v</span>. The inverter can now break <span class="math">C</span> in time <span class="math">T(n)</span> and thus break the strong one-wayness of <span class="math">\\mathcal{F}</span>.</p>

    <p class="text-gray-300">We next show that the protocol is ZK. As noted in the previous section, we can restrict attention to deterministic verifiers <span class="math">V^{*}</span> that get their bounded randomness as part of their bounded advice.</p>

    <p class="text-gray-300">Claim 4.4. Protocol 3 is ZK against any polytime verifier <span class="math">V^{*}</span> with advice of size at most <span class="math">m(n) - n</span>.</p>

    <p class="text-gray-300">Proof sketch. We describe a universal ZK simulator Sim and show its validity (universality is in the sense of Remark 4.1). Let <span class="math">x \\in \\mathcal{L}</span> and let <span class="math">V^{<em>}</span> be the code of any malicious verifier, and let <span class="math">z&#x27;</span> be any advice of length at most <span class="math">m - n</span>. Sim starts by running <span class="math">V^{</em>}(x; z&#x27;)</span> who returns <span class="math">(k, v, \\mathsf{wi}_1)</span> that are (allegedly) a key for an extractable function, an image of the function, and the verifier message of the WI protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sim now constructs from the code of <span class="math">V^{<em>}</span> a machine <span class="math">M_{V^{</em>}}</span> that, given <span class="math">k</span> and <span class="math">z = (z&#x27;, x)</span> as input, outputs some <span class="math">v</span>, and whose running time is linear in the running time <span class="math">t_{V^{<em>}}</span> of <span class="math">V^{</em>}</span>. In particular, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m(n)<span class="math">. Sim then applies the extractor Ext on </span>M_{V^{<em>}}<span class="math">, and obtains </span>u' \\in \\{0, 1\\}^{\\ell}<span class="math"> in time </span>\\mathrm{poly}(t_V^</em>)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Sim now computes <span class="math">v&#x27; = f_k(u&#x27;)</span>, as well as a commitment <span class="math">C</span> to <span class="math">u&#x27;</span>, and completes the WI using the trapdoor <span class="math">u&#x27;</span> as a witness. It sends <span class="math">C, v&#x27;, \\mathsf{wi}_2</span> to complete the simulation.</p>

    <p class="text-gray-300">The validity of the simulator now follows by witness indistinguishability, as well as the oblivious image sampling guarantee. Specifically, we can first move to a hybrid simulator Sim' that proves the WIPOK statement using the witness <span class="math">w</span>. The view generated by Sim' is indistinguishable from the one generated by Sim due to the WI property. Now, we can claim that the view generated by Sim' is indistinguishable from that generated by honest prover <span class="math">P</span>. Indeed, the only difference between the two is that <span class="math">P</span> commits to <span class="math">0^{\\ell}</span> instead of <span class="math">u&#x27;</span>, and sends <span class="math">\\tilde{v} \\gets \\mathcal{I}(k, v)</span>, whereas Sim' sends <span class="math">v&#x27; = f_k(u&#x27;)</span>, for the extracted input <span class="math">u&#x27;</span>. Thus, the two views are indistinguishable by the hiding of the commitment and by the oblivious image sampling guarantee that <span class="math">\\tilde{v} \\approx_c v&#x27;</span>.</p>

    <p class="text-gray-300">This completes the proof of Theorem 4.2.</p>

    <h2 id="sec-41" class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">[AIR01] William Aiello, Yuval Ishai, and Omer Reingold. Priced oblivious transfer: How to sell digital goods. In EUROCRYPT, pages 119–135, 2001. [Bar01] Boaz Barak. How to go beyond the black-box simulation barrier. In FOCS, pages 106–115, 2001. [BC12] Nir Bitansky and Alessandro Chiesa. Succinct arguments from multi-prover interactive proofs and their efficiency benefits. In CRYPTO, pages 255–272, 2012.</p>

    <p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, ITCS ’12, pages 326–349, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for snarks and proof-carrying data. In STOC, pages 111–120, 2013.</li>

      <li>[BCPR13] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. Indistinguishability obfuscation vs. auxiliary-input extractable functions: One must fall. IACR Cryptology ePrint Archive, 2013:641, 2013.</li>

      <li>[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In Proceedings of the 46th Annual ACM Symposium on Theory of Computing, STOC ’14, 2014.</li>

      <li>[BG08] Boaz Barak and Oded Goldreich. Universal arguments and their applications. SIAM J. Comput., 38(5):1661–1694, 2008.</li>

      <li>[Blu86] Manuel Blum. How to prove a theorem so no one else can claim it. In Proceedings of the International Congress of Mathematicians, pages 1444–1451, 1986.</li>

      <li>[BLV06] Boaz Barak, Yehuda Lindell, and Salil P. Vadhan. Lower bounds for non-black-box zero knowledge. J. Comput. Syst. Sci., 72(2):321–391, 2006.</li>

      <li>[BM84] Manuel Blum and Silvio Micali. How to generate cryptographically strong sequences of pseudo-random bits. SIAM J. Comput., 13(4):850–864, 1984.</li>

      <li>[BP04] Mihir Bellare and Adriana Palacio. The knowledge-of-exponent assumptions and 3-round zero-knowledge protocols. In Proceedings of the 24th Annual International Cryptology Conference, pages 273–289, 2004.</li>

      <li>[BP13] Nir Bitansky and Omer Paneth. On the impossibility of approximate obfuscation and applications to resettable cryptography. In STOC, pages 241–250, 2013.</li>

      <li>[BV11] Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) lwe. In FOCS, pages 97–106, 2011.</li>

      <li>[Can00] Ran Canetti. Security and composition of multiparty cryptographic protocols. Journal of Cryptology, pages 143–202, 2000.</li>

      <li>[Can01] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In Proceedings of the 42nd Annual IEEE Symposium on Foundations of Computer Science, pages 136–145, 2001.</li>

      <li>[CD08] Ran Canetti and Ronny Ramzi Dakdouk. Extractable perfectly one-way functions. In Proceedings of the 35th International Colloquium on Automata, Languages and Programming, pages 449–460, 2008.</li>

      <li>[CD09] Ran Canetti and Ronny Ramzi Dakdouk. Towards a theory of extractable functions. In TCC, pages 595–613, 2009.</li>

      <li>[CLP13] Kai-Min Chung, Huijia Lin, and Rafael Pass. Constant-round concurrent zero knowledge from p-certificates. In FOCS, 2013.</li>

    </ul>

    <p class="text-gray-300">[COSV12] Chongwon Cho, Rafail Ostrovsky, Alessandra Scafuro, and Ivan Visconti. Simultaneously resettable arguments of knowledge. In TCC, pages 530–547, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Dam92] Ivan Damgård. Towards practical public key systems secure against chosen ciphertext attacks. In Proceedings of CRYPTO91, pages 445–456, 1992.</li>

      <li>[DN07] Cynthia Dwork and Moni Naor. Zaps and their applications. SIAM J. Comput., 36(6):1513–1543, 2007.</li>

      <li>[FLS99] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple noninteractive zero knowledge proofs under general assumptions. SIAM J. Comput., 29(1):1–28, 1999.</li>

      <li>[FS89] Uriel Feige and Adi Shamir. Zero knowledge proofs of knowledge in two rounds. pages 526–544, 1989.</li>

      <li>[FS90] Uriel Feige and Adi Shamir. Witness indistinguishable and witness hiding protocols. In STOC, pages 416–426, 1990.</li>

      <li>[GHV10] Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. <span class="math">i</span>-hop homomorphic encryption and rerandomizable yao circuits. In CRYPTO, pages 155–172, 2010.</li>

      <li>[GK96] Oded Goldreich and Hugo Krawczyk. On the composition of zero-knowledge proof systems. SIAM J. Comput., 25(1):169–192, 1996.</li>

      <li>[GL89] O. Goldreich and L. A. Levin. A hard-core predicate for all one-way functions. In STOC ’89: Proceedings of the twenty-first annual ACM symposium on Theory of computing, pages 25–32, New York, NY, USA, 1989. ACM.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Comput., 18(1):186–208, 1989.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game. In STOC ’87: Proceedings of the nineteenth annual ACM symposium on Theory of computing, pages 218–229, 1987.</li>

      <li>[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. Journal of Cryptology, 7(1):1–32, December 1994.</li>

      <li>[Gol04] Oded Goldreich. Foundations of Cryptography: Volume 2, Basic Applications. Cambridge University Press, New York, NY, USA, 2004.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Proceedings of the 43rd Annual ACM Symposium on Theory of Computing, pages 99–108, 2011.</li>

      <li>[HILL99] Johan Håstad, Russell Impagliazzo, Leonid A. Levin, and Michael Luby. A pseudorandom generator from any one-way function. SIAM J. Comput., 28(4):1364–1396, 1999.</li>

      <li>[HK12] Shai Halevi and Yael Tauman Kalai. Smooth projective hashing and two-message oblivious transfer. J. Cryptology, 25(1):158–193, 2012.</li>

      <li>[HT98] Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge protocols. In Proceedings of the 18th Annual International Cryptology Conference, pages 408–423, 1998.</li>

    </ul>

    <p class="text-gray-300">[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In Proceedings of the 24th Annual ACM Symposium on Theory of Computing, pages 723–732, 1992.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KRR] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for p. In Announcement at STOC13.</li>

      <li>[KRR13] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for bounded space. In STOC, pages 565–574, 2013.</li>

      <li>[LS90] Dror Lapidot and Adi Shamir. Publicly verifiable non-interactive zero-knowledge proofs. In CRYPTO, pages 353–365, 1990.</li>

      <li>[Nao03] Moni Naor. On cryptographic assumptions and challenges. In Proceedings of the 23rd Annual International Cryptology Conference, pages 96–109, 2003.</li>

      <li>[NP01] Moni Naor and Benny Pinkas. Efficient oblivious transfer protocols. In SODA, pages 448–457, 2001.</li>

      <li>[OI07] Rafail Ostrovsky and William E. Skeith III. A survey of single-database private information retrieval: Techniques and applications. In Public Key Cryptography, pages 393–411, 2007.</li>

      <li>[OV12] Rafail Ostrovsky and Ivan Visconti. Simultaneous resettability from collision resistance. Electronic Colloquium on Computational Complexity (ECCC), 2012.</li>

      <li>[PW09] Rafael Pass and Hoeteck Wee. Black-box constructions of two-party protocols from one-way functions. In TCC, pages 403–418, 2009.</li>

      <li>[Yao86] Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In FOCS, pages 162–167, 1986.</li>

    </ul>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix A Black-Box Lower Bounds</h2>

    <p class="text-gray-300">In our construction of EOWFs (or GEOWFs) against BAPT adversaries, the extractor is non-black-box, i.e., it makes explicit use of the adversary’s code. In particular, the simulation of our 2-message and 3-message ZK protocols, which invokes this extractor, makes a non-black-box use of the adversarial verifier. In this section, we show that this is inherent by extending known results for adversaries with unbounded polynomial advice to the case of BAPT adversaries. We also observe that such black-box impossibilities do not hold for totally uniform adversaries (having no advice at all, on top of their constant size description).</p>

    <p class="text-gray-300">EOWF with black-box extractors. We sketch why there do not exist EOWFs against <span class="math">m</span>-BAPT adversaries where <span class="math">m=n^{\\Omega(1)}</span>, for security parameter <span class="math">n</span>, and where the extractor only uses the adversary as a black-box (a similar implication can be shown for the case of generalized EOWFs). Specifically, we show that given a function family <span class="math">\\mathcal{F}</span> that satisfies one-wayness, there does not exist a PPT black-box extractor <span class="math">\\mathsf{Ext}</span> such that for any PPT adversary <span class="math">M</span>, any large enough security parameter <span class="math">n\\in\\mathbb{N}</span>, and any advice <span class="math">z\\in\\{0,1\\}^{m(n)}</span>:</p>

    <p class="text-gray-300">\\[ \\operatorname*{\\mathrm{Pr}}_{k\\leftarrow K(1^{n})}\\left[\\begin{array}[]{cc}v\\leftarrow M(k;z)&\\quad u^{\\prime}\\leftarrow\\mathsf{Ext}^{M(\\cdot;z)}(k)\\\\ \\exists u:f_{k}(u)=v&\\quad f_{k}(u^{\\prime})\\neq v\\end{array}\\right]\\leq\\operatorname{negl}(n)\\enspace. \\]</p>

    <p class="text-gray-300">To see this, consider the adversary <span class="math">M</span> that interprets its auxiliary input as a seed of a pseudo-random function <span class="math">\\mathsf{PRF}</span> that maps the keys of <span class="math">\\mathcal{F}</span> to inputs of <span class="math">\\mathcal{F}</span>. On input <span class="math">(k;z)</span>, <span class="math">M</span> computes an input <span class="math">u=\\mathsf{PRF}_{z}(k)</span> and outputs <span class="math">v=f_{k}(u)</span>. Using the guarantee of the pseudo-random function, it is not hard to</p>

    <p class="text-gray-300">see that any black-box extractor <span class="math">\\mathsf{Ext}</span> can be used to break the one-wayness property of <span class="math">\\mathcal{F}</span>. Indeed, given <span class="math">(k,y)</span>, an inverter can simulate the view of <span class="math">\\mathsf{Ext}</span> in an interaction with <span class="math">M(\\cdot;z)</span> by answering any query <span class="math">k^{\\prime}\\neq k</span> with a random image <span class="math">f_{k^{\\prime}}(x)</span>, and answering the query <span class="math">k</span> with <span class="math">y</span>.</p>

    <p class="text-gray-300">Note that the above does not hold when <span class="math">m=O(\\log(n))</span>, since then the advice cannot contain a seed for a secure pseudo-random function. In fact, when <span class="math">m=O(\\log(n))</span>, any family that is EOWF against <span class="math">m</span>-BAPT adversaries also has a black-box extractor. The extractability property of the EOWF guarantees the existence of an extractor for every adversary <span class="math">M</span> and advice <span class="math">z</span>. Since there are only polynomially many different pairs <span class="math">(M,z)</span>, a black-box extractor can run the (possibly non-black-box) extractor for every such <span class="math">(M,z)</span>, and is guaranteed that one of these executions outputs a valid preimage.</p>

    <p class="text-gray-300">3-round ZK with black-box simulation. Goldreich and Krawczyk <em>[x11]</em> show that a 3-message protocol for a language <span class="math">\\mathcal{L}\\notin</span> BPP that is zero-knowledge against non-uniform verifiers cannot have a black-box simulator. That is, there is no simulator that only uses the verifier as a black-box. To show this, they first construct a specific family <span class="math">\\mathcal{V}</span> of non-uniform verifiers, and then prove that any black-box simulator that can simulate verifiers in <span class="math">\\mathcal{V}</span> can be used to decide <span class="math">\\mathcal{L}</span> efficiently. This proof, however, does not directly rule out black-box simulation for BAPT verifiers. The reason is that, in the proof of <em>[x11]</em>, the advice given to verifiers in <span class="math">\\mathcal{V}</span> encodes a key for a <span class="math">p</span>-wise independent hash function where <span class="math">p</span> bounds the running time of the simulator. Now, to rule out any polytime simulator, we must require simulation for verifiers with advice of arbitrary polynomial length.</p>

    <p class="text-gray-300">However, assuming one-way functions exist, we can replace the <span class="math">p</span>-wise independent hash function in the construction of <span class="math">\\mathcal{V}</span> by a pseudo-random function with seed length that is independent of <span class="math">p</span>. Then, using the same argument as <em>[x11]</em>, we can show that black-box simulation is impossible even for <span class="math">m</span>-BAPT verifiers where <span class="math">m=n^{\\Omega(1)}</span>.</p>

    <p class="text-gray-300">Similarly to the case EOWF, there is no impossibility for 3-message ZK against <span class="math">m</span>-BAPT verifiers where <span class="math">m=O(\\log(n))</span>. In fact, as explained above, in this case, the non-black-box extractor of our EOWF also implies a black-box extractor, which we can use to construct a black-box simulator in our 3-message ZK protocol.</p>

    <p class="text-gray-300">2-round ZK. Goldreich and Oren <em>[x10]</em> show that 2-message protocols for any language <span class="math">\\mathcal{L}\\notin</span> BPP that are zero-knowledge against non-uniform verifiers do not exist (even with non-black-box simulation). Their result crucially relies on the fact that the advice of the verifier can encode the first message of the protocol (and can in fact be extended to also rule out the case of BAPT verifiers, with advice longer that the first message). Our construction of 2-message ZK does not contradict the impossibility of <em>[x10]</em> sice it is only ZK against <span class="math">m</span>-BAPT adversaries where <span class="math">m</span> is smaller then the length of the first protocol message.</p>`;
---

<BaseLayout title="Indistinguishability Obfuscation vs. Auxiliary-Input Extract... (2013/641)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/641
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
