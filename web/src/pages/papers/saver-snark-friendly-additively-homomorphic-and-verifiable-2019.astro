---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1270';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'SAVER: SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization';
const AUTHORS_HTML = 'Jiwon Lee, Jaekyoung Choi, Jihye Kim, Hyunok Oh';

const CONTENT = `    <p class="text-gray-300">Jiwon Lee^{1}, Jaekyoung Choi^{2}, Jihye Kim^{2}, and Hyunok Oh^{1}</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In the pairing-based zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARK), there often exists a requirement for the proof system to be combined with encryption. As a typical example, a blockchain-based voting system requires the vote to be confidential (using encryption), while verifying voting validity (using zk-SNARKs). In these combined applications, a typical solution is to extend the zk-SNARK circuit to include the encryption code. However, complex cryptographic operations in the encryption algorithm increase the circuit size, which leads to impractically large proving time and CRS size.</p>

    <p class="text-gray-300">In this paper, we propose <em>SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization</em> or <em>SAVER</em>, which is a novel approach to detach the encryption from the SNARK circuit. The encryption in SAVER holds many useful properties. It is <em>SNARK-friendly</em>: the encryption is conjoined with an existing pairing-based SNARK, in a way that the encryptor can prove pre-defined properties while encrypting the message apart from the SNARK. It is <em>additively-homomorphic</em>: the ciphertext holds a homomorphic property from the ElGamal-based encryption. It is a <em>verifiable encryption</em>: one can verify arbitrary properties of encrypted messages by connecting with the SNARK system. It provides a <em>verifiable decryption</em>: anyone without the secret can still verify that the decrypted message is indeed from the given ciphertext. It provides <em>rerandomization</em>: the proof and the ciphertext can be rerandomized as independent objects so that even the encryptor (or prover) herself cannot identify the origin.</p>

    <p class="text-gray-300">For the representative application, we also propose a <em>Vote-SAVER</em> based on SAVER, which is a novel voting system where voter’s secret key lies only with the voter himself. The Vote-SAVER satisfies receipt-freeness (which implies ballot privacy), individual verifiability (which implies non-repudiation), vote verifiability, tally uniqueness, and voter anonymity. The experimental results show that our SAVER with respect to the Vote-SAVER relation yields 0.7s for zk-SNARK proving time and 10ms for encryption, with the CRS size of 16MB.</p>

    <p class="text-gray-300">Keywords: pairing-based zk-SNARK, verifiable encryption, verifiable decryption, public-key encryption, additively-homomorphic, rerandomization</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Verifiable encryption (VE) <em>[x1, x3, x2, x4, YAS^{+}12]</em> is a cryptographic system where the encrypted data provides a proof that can guarantee publicly-defined properties. It can be a useful primitive in trust-based protocols, such as group signatures or key escrow services. The verifiable property varies depending on the nature of the application. For instance, in the group signature, the verifiable encryption is used for the signer to encrypt and prove its identity commitment, which is evidence for detecting the malicious signer in case of treachery. In the key escrow systems where users deposit their keys to the trusted party, the verifiable encryption can let users prove their legitimacy of encrypted keys to the others.</p>

    <p class="text-gray-300">The zero-knowledge proof (ZKP) system is a primitive where one can prove a knowledge for some pre-defined relation <span class="math">\\mathcal{R}</span>, without revealing any other information. As in previous definitions <em>[x3, x11]</em>, the verifiable encryption can be also viewed as an encryption scheme combined with the ZKP system, by considering the encrypted message as an instance which satisfies the pre-defined relation <span class="math">\\mathcal{R}</span>. But until now, the ZKP was fixed for checking the validity of the message, and it was sort of mixed in the encryption protocol as a limited design. For example, in <em>[x3]</em>, the relation is pre-defined as discrete logarithm problem; it only guarantees that the ciphertext is an encryption of <span class="math">(m_{1},\\ldots,m_{k})</span> such that <span class="math">\\delta=\\gamma_{1}^{m_{1}}\\cdots\\gamma_{k}^{m_{k}}</span> for common inputs <span class="math">(\\delta,\\gamma_{1},\\cdots,\\gamma_{k})</span>.</p>

    <p class="text-gray-300">Generic VE from zk-SNARKs. If we consider the ZKP with arbitrary relations, it is possible to construct verifiable encryption with generic relations, which can prove any desired properties of the message. The ZKP for verifiable encryption requires the following conditions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The ZKP should be non-interactive, to be compatible with the ciphertext in non-interactive public-key encryption.</li>

      <li>The ZKP should guarantee knowledge-soundness of the message; it requires at least zero-knowledge arguments of knowledge (zk-AoK).</li>

      <li>The ZKP should guarantee that the instances for proving the relation are the same as messages in the encryption, i.e., <span class="math">m=m^{\\prime}</span> for <span class="math">\\mathsf{Prove}(m)</span> and <span class="math">\\mathsf{Enc}(m^{\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">Considering the fact that the proof size determines the ciphertext payload, the most suitable primitive would be zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARK). Specifically, pairing-based zk-SNARKs <em>[x13, x7, x6, x10, x12, x14]</em> yields constant-sized proof, regardless of the relation complexities. The pairing-based zk-SNARK can take any pre-defined arithmetic circuit (e.g. quadratic arithmetic program) as an input so that the</p>

    <p class="text-gray-300">prover can convince the verifier that the prover indeed evaluates the function correctly. As for the verifiable encryption, if any desired property is included in the zk-SNARK circuit, the proof ensures that the encrypted data satisfies the property in the circuit.</p>

    <p class="text-gray-300">Unfortunately, the naive combination of the zk-SNARK and encryption is beyond practicality, because of the third condition. To satisfy the consistency of <span class="math">m</span> in the third condition, the entire encryption process must be included in the zk-SNARK circuit to ensure that <span class="math">m</span> is an input for both encryption and the relation, which incurs large overhead. This problem has recently been studied in <em>[KZM^{+}15b, KZM^{+}15a]</em>, which focused on boosting the performance when including the standard cryptographic protocols in the zk-SNARK circuit. They designed the SNARK-friendly encryption with minimal multiplications since the circuit size in pairing-based zk-SNARKs relies on the number of multiplications. By optimizing the encryption circuit, their experiment result could boost the zk-SNARK with RSA-OAEP public-key encryption up to the nearly-practical level: 8.9s proving time and 216MB common reference string (CRS) size.</p>

    <p class="text-gray-300">Necessity for an advanced VE. However, in real-world applications, we often need to prove more than a simple RSA encryption. Due to the recent functionality requirements, the encryption schemes have evolved to more sophisticated primitives such as identity-based encryption (IBE) <em>[x1, x10]</em>, attribute-based encryption (ABE) <em>[AHL^{+}12]</em>, or rerandomizable encryption <em>[x16]</em>. When adopting these advanced schemes as generic verifiable encryption, they involve heavy cryptographic operations like pairings or access tree comparisons. In case of rerandomizable encryption which enables the encryption to be unlinkable, the rerandomization needs to prove the verification process of the previous ciphertext, which becomes impractically heavy due to multiple pairings.</p>

    <p class="text-gray-300">If we build generic verifiable encryption by proving the whole encryption process within the circuit (a.k.a. <em>encryption-in-the-circuit</em>), the efficiency becomes unrealistic when the encryption is a bit out of simplicity. For instance, to cover the example of voting application described in 1.1, the circuit needs to include additively-homomorphic encryption such as Paillier encryption <em>[x14]</em>, zk-SNARK verification, rerandomization, decryption procedure, etc. All these properties require huge amount of work on the prover’s side.</p>

    <p class="text-gray-300">Separating the encryption. An intriguing idea to deviate from this efficiency problem is to <em>separate</em> the encryption from the zk-SNARK circuit. The main purpose of including the encryption in the circuit is to ensure that the same <span class="math">m</span> is used for both <span class="math">\\mathsf{Prove(m)}</span> and <span class="math">\\mathsf{Enc(m^{\\prime})}</span> within the relation. If we can prove this consistency with some pre-published commitments, there is no need to include the entire encryption in the circuit anymore. This idea is well-addressed in <em>commit-and-prove</em> system of LegoSNARK <em>[x3]</em>, which let the user commit for the value ahead of time, and let the pre-published commitment be connected to the zk-SNARK proof gadgets. If we commit <span class="math">C_{M}</span> for the message ahead of time and design the encryption ciphertext <span class="math">\\mathcal{CT}</span> to be compatible, it is possible to</p>

    <p class="text-gray-300">connect encryption to the zk-SNARK proof <span class="math">\\pi</span> by asserting two additional checks on <span class="math">\\mathcal{CT}\\leftrightarrow C_{M}</span> and <span class="math">C_{M}\\leftrightarrow\\pi</span>.</p>

    <p class="text-gray-300">Still, the commit-and-prove approach cannot avoid including the encryption in the circuit since there is no such scheme which can connect the ciphertext and the commitment. To enable the commit-and-prove connectivity, candidate systems to be connected should carry commitments; to connect an encryption system, the encryption must output a commitment as well as the ciphertext (a.k.a. <em>commit-carrying encryption</em>). Without commit-carrying encryption, the commit-and-prove framework can only separate the encryption circuit and the other circuit (which proves arbitrary properties of the message), which let the encryption still be included in the SNARK circuit.</p>

    <p class="text-gray-300">Enc-with-Prove, Enc-and-Prove. In the generic verifiable encryption, the user encrypts a message and proves its properties at the same time. Therefore, commit-carrying encryption is not necessary for the generic verifiable encryption; it is sufficient to design an <em>encrypt-with-prove</em> scheme based on a fixed relation for each key generation. The fixed relation indicates that the CRS is already generated, which enables exploiting the existing CRS to work with the SNARK verifying equation. If the encryption is specifically designed by embedding the CRS parameters, it is possible to directly plug-in the connectivity check to the zk-SNARK verification. In this case, verifying the proof will imply both the soundness of relation and the connectivity between encryption and SNARK.</p>

    <p class="text-gray-300">Nevertheless, when the user wants to encrypt a message ahead of time and prove its arbitrary properties later, we require modularity in addition to the verifiable encryption, similar to the commit-and-prove framework. To add modularity, we need to extend the encrypt-with-prove verifiable encryption to become a commit-carrying encryption, which can be interpreted as designing an <em>encrypt-and-prove</em> scheme. In the encrypt-and-prove style, the encryption must output a commitment for the connectivity and the verification requires an additional connectivity check (via commit-and-prove) between the encryption and SNARK. We intend to capture both types by designing the <em>commit-carrying</em>, <em>encrypt-with-prove</em> scheme so that the user can use the efficient encrypt-with-prove itself or/and use the modular encrypt-and-prove (with the existing commitment) as desired.</p>

    <p class="text-gray-300">Generic SAVER. We propose a new commit-carrying encryption <em>SAVER: SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization</em>, which detaches encryption from the zk-SNARK circuit while maintaining the connectivity. SAVER is an efficient encrypt-with-prove scheme which supports generic verifiable encryption without including encryption in the circuit. At the same time, SAVER is also a commit-carrying encryption: it can be used as a composable encrypt-and-prove (or LegoEncryption) scheme by providing a commitment compatible with the commit-and-prove framework of LegoSNARK <em>[x11]</em>.</p>

    <p class="text-gray-300">Moreover, the proposed SAVER supports more advanced functionalities than just a simple encryption, which emphasizes the efficiency improvement compared</p>

    <p class="text-gray-300">to the encryption-in-the-circuit approach. Instead of including the entire complicated encryption in the zk-SNARK circuit, SAVER provides verifiable encryption with various functionalities conjoined with the existing zk-SNARKs (e.g. <em>[x10, x11, x4, x16]</em>) for a generic relation.</p>

    <p class="text-gray-300">The proposed SAVER is generic verifiable encryption which satisfies zk-SNARK connectivity (SNARK-friendly), additive homomorphism, rerandomizability, and verifiable decryption. We describe each property as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SNARK-friendly encryption: SAVER can be conjoined with zk-SNARK supporting generic relations, which can be realized as generic verifiable encryption. In the encryption, the encryptor can prove any arbitrary pre-defined relation, while encrypting the message separately from the circuit. Later, the proof and ciphertext are jointly verified to guarantee the relation of the message in the ciphertext.</li>

      <li>Additively-homomorphic encryption: an additively-homomorphic encryption is a well-known primitive that allows computations on ciphertexts. SAVER is an additively-homomorphic encryption based on ElGamal encryption variants <em>[x7]</em>, i.e., <span class="math">G^{m_{1}+m_{2}}=G^{m_{1}}\\cdot G^{m_{2}}</span>; the ciphertext can be merged by simple elliptic curve cryptography (ECC) multiplications.</li>

      <li>Verifiable decryption: a verifiable decryption <em>[x5]</em> is a primitive which can convince the verifier that the decrypted message is indeed from the corresponding ciphertext. Likewise, the decryption in SAVER entails a decryption proof, which is verified with message and ciphertext to guarantee the validity. This allows the decryptor to prove the correctness of decrypted messages without revealing her secret key.</li>

      <li>Rerandomizable encryption: a rerandomizable encryption <em>[x20]</em> is a public-key encryption scheme where the ciphertext can be rerandomized, which can be viewed as a newly-encrypted ciphertext. Likewise, ciphertext in SAVER can be rerandomized as a new unlinkable ciphertext. Since SAVER outputs a proof as verifiable encryption, the proof is also rerandomized along with the ciphertext.</li>

    </ul>

    <p class="text-gray-300">To justify the practicality, we implemented the proposed SAVER by applying the voting relation in section 1.1. The experiment result yields 0.7s for the voting time when assuming <span class="math">2^{16}</span> total voters, which includes both encryption and zk-SNARK proof. The encryption time takes less than 10ms, which indicates that the additional encryption overhead to the zk-SNARK is almost negligible. The CRS size for the voting relation is only 16MB, and the public key and verification key for the verifiable encryption is from 1MB to 8MB, linearly depending on the message size.</p>

    <p class="text-gray-300">Our contributions. We summarize the contributions of the paper, from various perspectives listed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generic verifiable encryption: the proposed SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization (SAVER) is generic verifiable encryption. SAVER can be connected with</li>

    </ul>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">zk-SNARKs such as <em>[x13]</em> with any generic relation. The ciphertext and proof guarantee the message satisfies pre-defined relation from zk-SNARK.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>zk-SNARK connectivity: instead of including the encryption in the circuit for the generic verifiable encryption, SAVER detaches encryption from the zk-SNARK circuit with providing connectivity. The verification in SAVER guarantees a linkage between encryption and relation, as well as knowledge soundness of the proof.</li>

      <li>Modularity: SAVER is a commit-carrying, encrypt-with-prove scheme. The user can choose whether to deploy SAVER as an encrypt-with-prove scheme to be a generic verifiable encryption, or/and an encrypt-and-prove scheme to be compatible with the modular commit-and-prove framework.</li>

      <li>Functionalities: the proposed SAVER supports and satisfies many functionalities. It is <em>SNARK-friendly</em>: the encryption is compatible with zk-SNARK composition. It is <em>additively-homomorphic</em>: the ciphertext can be merged additively from the homomorphic property. It is <em>verifiable encryption</em>: one can encrypt a message while proving any generic relation for the message. It is <em>verifiable decryption</em>: the decryptor can convince the verifier that the decrypted message is indeed from the ciphertext, without revealing her secret key. It provides <em>rerandomization</em>: the ciphertext can be rerandomized to be unlinkable to the original one.</li>

      <li>Vote-SAVER: to justify the functionalities in SAVER, we define an ideal voting system and propose an efficient application Vote-SAVER (section 1.1) based on the SAVER scheme. While existing voting systems let the authority responsible for the key distribution, the Vote-SAVER let only the voter hold its own secret key supporting <em>non-repudiation</em>.</li>

      <li>Implementation: we implement our SAVER with respect to the Vote-SAVER relation on the real computer system to show the practicality of the construction. The experiment result yields 0.7s for zk-SNARK proving time and 10ms for encryption when assuming <span class="math">2^{16}</span> total voters, with the CRS size of 16MB for the voting relation.</li>

      <li>Security: the proposed SAVER requires many security notions: indistinguishability (IND-CPA), encryption knowledge soundness, rerandomizability, perfect decryption soundness, and perfect zero-knowledge. We formally define each property and provide security proof in a standard model. We also provide a formal proof for the Vote-SAVER which satisfies various properties described in section 1.1, based on the security of SAVER scheme.</li>

    </ul>

    <p class="text-gray-300">The rest of the paper proceeds as follows. Section 1.1 provides a specific application Vote-SAVER, to justify the functionalities in SAVER. Section 2 organizes related works. In section 3, we describe some necessary preliminaries and formal definitions. Section 4 presents insights and the formal construction of SAVER, and section 5 provides formal security proofs. In section 6, we present a formal protocol of the Vote-SAVER, and section 7 provides formal security proofs. Section 8 shows experiment results of SAVER, with respect to the Vote-SAVER application. In section 9, we draw a conclusion.</p>

    <p class="text-gray-300">1.1 Application: Vote-SAVER</p>

    <p class="text-gray-300">Our proposed SAVER is generic verifiable encryption with many useful functionalities - zk-SNARK connectivity, additive-homomorphism, rerandomizability, and verifiable decryption. To strengthen the justifications on such complex functionalities, we specify one of the interesting applications, <em>voting</em>, which is mentioned as a representative example of verifiable encryption in the cryptography encyclopedia <em>[x21]</em>.</p>

    <p class="text-gray-300">In the history of voting systems, the main focus was on capturing both privacy and verifiability of the vote. The commonly accepted properties and related works are well-described in BeleniosRF <em>[x10]</em>: the security notion for privacy has evolved from <em>ballot privacy</em> to <em>receipt-freeness</em>, and <em>coercion-resistance</em>. The ballot privacy refers to the standard privacy of the vote, while receipt-freeness extends the ballot privacy to where even the voter cannot reproduce the vote for vote-buying. The coercion-resistance must allow the voter to vote for his intended choice even when he is corrupted by the coercing adversary, which essentially requires re-voting functionality. In general, the coercion-resistance implies receipt-freeness, which in turn implies ballot privacy.</p>

    <p class="text-gray-300">The verifiability is another important property of the voting system; it is recently proved that the lack of verifiability leads to a privacy leak <em>[x9]</em>. The three commonly accepted properties are <em>eligibility verifiability</em>, <em>individual verifiability</em>, and <em>universal verifiability</em>. The eligibility verifiability is often from the authority’s view, which indicates it should be able to check that the vote is from an eligible voting right. On the contrary, the individual verifiability is from the voter’s view, which ensures that the voter should be able to verify that his vote is included in the public ballot box. The universal verifiability is from the observer’s view including voters, which ensures that the tally result is from the public ballot box; sometimes it can be substituted with stronger notion called <em>tally uniqueness</em>.</p>

    <p class="text-gray-300">Since coercion-resistance is more theoretical than practical due to the requirement of re-voting issue, it is commonly accepted that a reliable voting system should provide non-interactive receipt-freeness along with the verifiability. Among the existing proposals, BeleniosRF <em>[x10]</em> is a well-known work to successfully achieve both receipt-freeness and individual verifiability which seemed like a contradiction; the voter should not be allowed to reproduce his vote, but should still be able to check that his vote is included in the box. BeleniosRF resolves this issue by combining rerandomizability to the verifiable encryption. When the vote is rerandomized before enrollment, it can prevent the voter from reproducing the vote, since he does not know the new random used in the rerandomization. Nevertheless, he can still check the proof to verify that at least his original message is preserved in the rerandomized vote.</p>

    <p class="text-gray-300">The SK holder. However, in our observation, all existing voting systems including BeleniosRF are missing a crucial requirement: the voter’s secret key must not be originated from others, even from authority. If there exists an authority responsible for the system setup and key distribution, the authority holds the secret voting key of each voter. At the end, this leads to the authority discovering the voter’s identity from the vote, or even allow authority to forge a malicious proxy vote on behalf of the voter. Therefore, for the fundamental privacy, we emphasize that it is important to let the voter be responsible for his own key generation, which should not be compromised to any other entities. Therefore, by adding new definitions based on this idea to typical definitions in the literature <em>[x10, x3]</em>, we organize the essential properties of a reliable voting system listed as below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Board integrity:</em> the voting system often requires a technical support where the public bulletin board for ballot box is non-malleable.</li>

      <li><em>Receipt-freeness:</em> the receipt-freeness implies ballot privacy; it ensures that the ballot must guarantee the privacy of voting message while the voter cannot reproduce his vote.</li>

      <li><em>Individual verifiability:</em> the voter must be able to verify the inclusion of his vote, and no others can convince the voter with a false ballot.</li>

      <li><em>Eligibility verifiability:</em> the ballot can only be generated from an eligible voter with a voting right.</li>

      <li><em>Tally uniqueness:</em> the tally uniqueness implies universal verifiability; it ensures that the tally result is unique corresponding to the ballots in the public board.</li>

      <li><em>Voter anonymity:</em> we define a new security notion, which ensures that the ballot does not reveal the voter’s identity to any entities, even from the authority.</li>

      <li><em>Non-repudiation:</em> we define another new security notion, indicating that the ballot is unique only from the voter and there exists no proxy votes.</li>

    </ul>

    <p class="text-gray-300">Note that BeleniosRF satisfies the typical properties (i.e. board integrity, receipt-freeness, individual verifiability, eligibility verifiability, and unversal verifiability), but it cannot support voter anonymity and non-repudiation since the key distributing authority knows the voting key of the voters.</p>

    <p class="text-gray-300">Membership tests for voting. The zero-knowledge proof of membership is a well-known technique to prove the membership with respect to the accumulated value, while hiding the identity of the prover within the zero-knowledge; it is often achieved by constructing Merkle tree or RSA accumulator inside the zk-SNARK. The most representative example is Zerocash <em>[BCG^{+}14]</em> which is an anonymous blockchain cryptocurrency: for each transaction, a sender runs the zk-SNARK to prove that the coin is a valid coin within the Merkle tree membership test. Intuitively, the public key for a coin is set as <span class="math">pk=H(sk)</span> for any collision-resistant hash <span class="math">H</span>. When the sender proves the membership test in zk-SNARK, the relation asserts <span class="math">pk=H_{1}(sk)</span>, <span class="math">rt=MerkleTree(pk,copath)</span>, and <span class="math">sn=H_{2}(sk)</span> with hiding the <span class="math">sk,pk,copath</span> as witnesses (<span class="math">rt</span> is the input, and <span class="math">sn</span></p>

    <p class="text-gray-300">is the output). The relation guarantees that the valid <span class="math">pk</span> is included in the Merkle tree of <span class="math">rt</span>, and the deterministic serial number <span class="math">sn</span> can prevent double-spending.</p>

    <p class="text-gray-300">When observing the membership test in Zerocash, it is very similar to the nature of voting. If we consider the coin as a voter, we can let the voter keep his own <span class="math">sk</span> and only publish <span class="math">pk=H(sk)</span>. When we build a Merkle tree of <span class="math">pk</span> from eligible voters, the voter can hold <span class="math">sk</span> for himself but prove that he is within the eligible membership with respect to the Merkle root <span class="math">rt</span>. Also, the serial number <span class="math">sn</span> now prevents double-voting, equivalent to the detection of double-spending. Therefore, if we let the voter prove his membership along with the vote, the vote message now only contains the <em>anonymous</em> message while the property of the message (i.e. voter’s membership) can be proved as zero-knowledge. In other words, if we have a generic verifiable encryption from zk-SNARK described in section 1, it is possible to design the voting system where the voting key belongs only to the voter. Based on the idea, we describe how to capture the essential properties by using the concept of generic verifiable encryption:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>blockchain for <em>board integrity</em>: the blockchain system is well-known for its tamper-proof property based on the proof of work, which is a suitable platform for the non-malleable board.</li>

      <li>rerandomizable encryption for <em>receipt-freeness</em>: similar to the BeleniosRF approach, letting the blockchain node rerandomize the ballot can provide receipt-freeness since the voter does not know the modified random.</li>

      <li>verifiable encryption for <em>individual verifiability</em>: by verifying the proof with respect to the original statements, the voter can be convinced that his vote statement remains in the ballot.</li>

      <li>zk-SNARK for <em>eligibility verifiability</em>: the membership test relation of the zk-SNARK can guarantee that the ballot is from the eligible voter within the Merkle tree of <span class="math">rt</span>.</li>

      <li>homomorphism & verifiable decryption for <em>tally uniqueness</em>: if the ballots can be merged with the additively-homomorphic encryption and the message can be verified with the verifiable decryption, an observer can verify that the decrypted tally is indeed from the merged ciphertext.</li>

      <li>zk-SNARK for <em>voter anonymity</em>: the zero-knowledge of zk-SNARK can guarantee that the voter’s identity is hidden within the membership test, since <span class="math">sk</span> and <span class="math">pk</span> are zero-knowledge witnesses.</li>

      <li>zk-SNARK for <em>non-repudiation</em>: the ballot can be only generated from the voter who holds the valid <span class="math">sk</span> for the <span class="math">pk</span>.</li>

    </ul>

    <p class="text-gray-300">Overall, to satisfy all the given properties, it is required to design a generic verifiable encryption from zk-SNARK, which also supports the functionalities of <em>rerandomizable encryption</em>, <em>additively-homomorphic encryption</em> and <em>verifiable decryption</em>. It justifies that we require an advanced verifiable encryption, which is more complex than just a simple verifiable encryption.</p>

    <p class="text-gray-300">Scenario. Figure 1 represents how to efficiently proceed a voting scenario by utilizing the advanced verifiable encryption. The system works with a publicly</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: The Vote-SAVER framework from the advanced verifiable encryption with rerandomizability, additive-homomorphism, and verifiable decryption</p>

    <p class="text-gray-300">available blockchain, where the consensus block defines the relation  <span class="math">\\mathcal{R}</span>  of membership test and message validity, with the corresponding common reference string  <span class="math">CRS_{\\mathcal{R}}</span>  generated from zk-SNARK setup. There are two entities, voters and an administrator, who interact mainly through the blockchain subscription. We refer to the election committee as an administrator, rather than authority, because the administrator does not distribute the secret key of the voters. The administrator is only responsible for tallying the anonymous results; even when corrupted, she holds no power to trace or manipulate the votes at any cost.</p>

    <p class="text-gray-300">Before election. Our voting system let each user publish his own  <span class="math">pk</span>  to the public, where  <span class="math">pk</span>  is generated from user's secret value. For example, a simple way is to let  <span class="math">pk = H(sk)</span>  for collision-resistant hash  <span class="math">H</span> . Without knowing  <span class="math">sk</span> , no one can make a valid ballot.</p>

    <p class="text-gray-300">Initiating election. First, to open an election, the administrator makes the  <span class="math">pklist</span>  of the voters, which prescribes the selection of eligible voters who participate in the election. Then she generates a secret key  <span class="math">SK</span> , a public key  <span class="math">PK</span> , and a verification key  <span class="math">VK</span>  for the occasion, to publish  <span class="math">PK, VK</span>  on the blockchain along with the  <span class="math">pklist</span>  and its Merkle root  <span class="math">rt</span> . This set of  <span class="math">PK, VK</span>  and  <span class="math">pklist, rt</span>  defines each election; a new election can be initiated with a different set of  <span class="math">PK&#x27;, VK&#x27;</span>  and  <span class="math">pklist&#x27;, rt&#x27;</span> .</p>

    <p class="text-gray-300">Casting votes. After the election is initiated, voters who are selected in the list can cast a vote. Each voter must encrypt the vote and prove the relation</p>

    <p class="text-gray-300">(i.e. membership test and message validity) at the same time, via generic verifiable encryption from zk-SNARK. Similar to the membership test in Zerocash <em>[BCG^{+}14]</em>, the zk-SNARK circuit outputs a Merkle root <span class="math">rt</span> to prove the belonging within the <span class="math">pklist</span>, and a serial number <span class="math">sn</span> to prevent the duplication. Note that the <span class="math">sn</span> does not reveal the identity; it is only used for checking the duplication. As a ballot, a set of serial number <span class="math">sn</span>, proof <span class="math">\\pi</span> and ciphertext <span class="math">\\mathcal{CT}</span> is sent to the blockchain network as a transaction. The blockchain node checks if <span class="math">sn</span> already exists in the blockchain (then abort). If <span class="math">sn</span> is unique, it first verifies the proof, rerandomizes the vote from <span class="math">\\pi,\\mathcal{CT}</span> to <span class="math">\\pi^{\\prime},\\mathcal{CT}^{\\prime}</span>, and publishes (by mining the block) the renewed vote <span class="math">sn,\\pi^{\\prime},\\mathcal{CT}^{\\prime}</span> on the blockchain. The voter verifies <span class="math">\\pi^{\\prime},\\mathcal{CT}^{\\prime}</span> for his <span class="math">sn</span> within the verifiable encryption, to be convinced that his vote is included. This satisfies the individual verifiability, but the voter can only check the existence of his vote; <span class="math">\\pi^{\\prime},\\mathcal{CT}^{\\prime}</span> is unlinkable from <span class="math">\\pi,\\mathcal{CT}</span>, which also achieves the receipt-freeness.</p>

    <p class="text-gray-300">Tallying results. After all the votes from participants are posted on the blockchain, the administrator closes the vote by declaring the tally result. Since the encryption scheme is additively-homomorphic, anyone can get the merged ciphertext <span class="math">\\mathcal{CT}_{sum}</span>. The administrator is responsible for decrypting the <span class="math">\\mathcal{CT}_{sum}</span> with her own <span class="math">SK</span>, and publishing the corresponding vote result <span class="math">M_{sum}</span> along with the decryption proof <span class="math">\\nu</span>. By verifying <span class="math">M_{sum},\\nu</span> with the verifiable decryption, anyone can be convinced that the result is tallied correctly (universal verifiability).</p>

    <p class="text-gray-300">We define the relation for the voting scenario in section 8, and also provide implementation results of the entire voting system on the real machine.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Related Work</h2>

    <p class="text-gray-300">A zero-knowledge succinct non-interactive argument of knowledge (zk-SNARK) is introduced in <em>[x1]</em>, as a proof system where a prover can generate a proof that they know a witness to an instance in a manner which is <span class="math">succinct</span>: proofs are short and verifier computation is small, and zero-knowledge: proofs do not reveal the witness. Since Gennaro et al. <em>[x10]</em> introduced a notion of quadratic arithmetic program (QAP), a pairing-based zk-SNARKs (or pre-processing SNARKs with trusted setup) <em>[x16, x15, x4, x14, x17]</em> have received significant attention for their constant sized proof and verification. Groth’s protocol <em>[x16]</em> set an efficient standard, by yielding three group elements as a proof. Then there has been efforts to add modularity to these zk-SNARK proof systems. Agrawal et al. <em>[x1]</em> proposed a proof system for composite statements using Pinocchio <em>[x22]</em>, and LegoSNARK <em>[x13]</em> proposed a general commit-and-prove framework that provides a modular composition of commit-carrying proof systems. On the security side, Groth and Maller <em>[x15]</em> introduced a notion of simulation-extractability, to prevent malleability in the proof of <em>[x16]</em>. However, to achieve simulation-extractability, <em>[x15]</em> requires a square arithmetic program (SAP) instead of QAP, which doubles the circuit size - which sacrifices proving time and CRS size. To address this issue, Bowe and Gabizon <em>[x4]</em> applied random oracle to <em>[x16]</em>,</p>

    <p class="text-gray-300">which can transform the <em>[x10]</em> to be simulation-extractable. However, this compromises the proof size to five elements. Lipmaa <em>[x16]</em> proposed a QAP-based simulation-extractable zk-SNARK with four elements, from the help of more general assumption. Recently, Kim et al. <em>[x12]</em> devised the most efficient simulation-extractable zk-SNARK, which achieves both QAP and three elements as a proof, compatible with non simulation-extractable <em>[x10]</em>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Preliminaries</h2>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">3.1 Notations</h3>

    <p class="text-gray-300">In this section, we define some essential notations. For the simple legibility, we define the term <span class="math">\\frac{\\partial u_{i}(x)+\\alpha v_{i}(x)+w_{i}(x)}{2}</span> in <em>[x10]</em> as <span class="math">y_{i}(x)</span>. Then, we denote <span class="math">G^{y_{i}(x)}</span> as <span class="math">G_{i}</span>. We use <span class="math">\\bm{x}</span> or <span class="math">\\{x_{i}\\}</span> for the list of elements, which is equivalent to a vector. We also define <span class="math">\\llbracket X\\rrbracket=span\\{X\\}</span> as a linear combination of <span class="math">x\\in X</span>, i.e., <span class="math">\\llbracket X\\rrbracket=\\{\\sum_{x_{i}\\in X}\\eta_{i}x_{i}\\}</span>. For any set <span class="math">\\llbracket X\\rrbracket</span>, we define <span class="math">\\llbracket A\\rrbracket\\times\\llbracket B\\rrbracket=\\{a\\cdot b\\mid a\\in\\llbracket A\\rrbracket,\\ b\\in\\llbracket B\\rrbracket\\}</span> and <span class="math">\\llbracket A\\rrbracket^{-1}=\\{a^{-1}\\mid a\\in\\llbracket A\\rrbracket\\}</span>. For any given vectors, <span class="math">\\circ</span> represents a Hadamard product (i.e. let <span class="math">\\bm{a}=(a_{1},a_{2})</span> and <span class="math">\\bm{b}=(b_{1},b_{2})</span>, then <span class="math">\\bm{a}\\circ\\bm{b}=(a_{1}\\cdot b_{1},a_{2}\\cdot b_{2})</span>) and <span class="math">\\oslash</span> represents a Hadamard division(<span class="math">\\bm{a}\\oslash\\bm{b}=(a_{1}/b_{1},a_{2}/b_{2})</span>).</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.2 Relations</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a security parameter <span class="math">1^{\\lambda}</span>, a relation generator <span class="math">\\mathcal{RG}</span> returns a polynomial time decidable relation <span class="math">\\mathcal{R}\\leftarrow\\mathcal{RG}(1^{\\lambda})</span>. For <span class="math">(\\Phi,w)\\in\\mathcal{R}</span> we say <span class="math">w</span> is a witness to the statement (I/O) <span class="math">\\Phi</span> being in the relation. The statement <span class="math">\\Phi</span> in SAVER consists of <span class="math">\\Phi=M\\cup\\hat{\\Phi}</span> for message statements <span class="math">\\{m_{1},\\ldots,m_{n}\\}</span> by splitting $M=(m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{n})<span class="math"> and arbitrary statements </span>\\hat{\\Phi}=\\{\\phi_{n+1},\\cdots,\\phi_{l}\\}<span class="math">, where </span>l$ is the number of statements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.3 Bilinear Groups</h3>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1</h6>

    <p class="text-gray-300">A bilinear group generator <span class="math">\\mathcal{BG}</span> takes a security parameter as input in unary and returns a bilinear group <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,aux)</span> consisting of cyclic groups <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span>, <span class="math">\\mathbb{G}_{T}</span> of prime order <span class="math">p</span> and a bilinear map <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span> possibly together with some auxiliary information (aux) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there are efficient algorithms for computing group operations, evaluating the bilinear map, deciding membership of the groups, and for sampling the generators of the groups;</li>

      <li>the map is bilinear, i.e., for all <span class="math">G\\in\\mathbb{G}_{1}</span> and <span class="math">H\\in\\mathbb{G}_{2}</span> and for all <span class="math">a</span>, <span class="math">b\\in\\mathbb{Z}</span> we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">e(G^{a},H^{b})=e(G,H)^{ab};</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>and the map is non-degenerate (i.e., if <span class="math">e(G,H)=1</span> then <span class="math">G=1</span> or <span class="math">H=1</span>).</li>

    </ul>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">Usually bilinear groups are constructed from elliptic curves equipped with a pairing, which can be tweaked to yield a non-degenerate bilinear map. There are many ways to set up bilinear groups, both as symmetric bilinear groups, where  <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span> , and as asymmetric bilinear groups, where  <span class="math">\\mathbb{G}_1 \\neq \\mathbb{G}_2</span> . We will be working in the asymmetric setting, in what Galbraith, Paterson, and Smart [GPS08] call the Type III setting where there is no efficiently computable nontrivial homomorphism in either direction between  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> . Type III bilinear groups are the most efficient type of bilinear groups and hence the most relevant for practical applications.</p>

    <p class="text-gray-300">We use Power Knowledge of Exponent (d-PKE) with Batch Knowledge Check assumption [Gab19]. In [Gab19] (lemma 2.3), it is proven that the  <span class="math">d</span> -PKE can be used to batch knowledge checks, stated as below:</p>

    <p class="text-gray-300">Assumption 1. batch - PKE (Lemma 2.3 of [Gab19]): Assuming the  <span class="math">d</span> -PKE the following holds. Fix  <span class="math">k = \\text{poly}(\\lambda)</span> , a constant  <span class="math">t</span>  and an efficiently computable degree  <span class="math">d</span>  rational map  <span class="math">S: \\mathbb{F}^{t+1} \\to \\mathbb{F}^M</span> . Fix any  <span class="math">i \\in [k]</span> . For any efficient  <span class="math">\\mathcal{A}</span>  there exists an efficient  <span class="math">\\chi_{\\mathcal{A}}</span>  such that the following holds. Consider the following experiment.  <span class="math">\\alpha_1, \\ldots, \\alpha_k, \\tau \\in \\mathbb{F}</span>  and  <span class="math">\\pmb{x} \\in \\mathbb{F}^t</span>  are chosen uniformly.  <span class="math">\\mathcal{A}</span>  is given as input  <span class="math">[S(\\tau, \\pmb{x})]</span>  and  <span class="math">\\{[\\alpha_j \\cdot \\tau^l]\\}_{j \\in [k], l \\in [0..d]}</span>  and outputs a sequence of elements  <span class="math">([a_1], \\ldots, [a_k], [b])</span>  in  <span class="math">\\mathbb{G}</span> .  <span class="math">\\chi_{\\mathcal{A}}</span> , given the same input as  <span class="math">\\mathcal{A}</span>  together with the randomness of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\{\\alpha_j\\}_{j \\in [k] \\setminus \\{i\\}}</span> , outputs  <span class="math">\\mathcal{A}(X) \\in \\mathbb{F}[X]</span>  of degree at most  <span class="math">d</span>  such that the probability that both</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span>  "succeeded", i.e.,  <span class="math">b = \\sum_{j=1}^{k} \\alpha_j \\cdot a_j</span> . But,</li>

      <li><span class="math">\\chi_{\\mathcal{A}}</span>  "failed", i.e.,  <span class="math">a_i \\neq [\\mathcal{A}(\\tau)]</span> .</li>

    </ol>

    <p class="text-gray-300">is  <span class="math">\\mathbf{Adv}_{\\mathcal{R},\\mathcal{A},\\chi_{\\mathcal{A}}}^{\\mathrm{batch - PKE}}(\\lambda) = negl(\\lambda)</span> .</p>

    <p class="text-gray-300">We also introduce a decisional version of the polynomial (Poly) assumption, which is originated from the computational Poly assumption adopted in [GM17]. In the univariate case, the Poly assumption states that for any  <span class="math">G \\in \\mathbb{G}_1</span> , given  <span class="math">G^{g_1(\\pmb{x})}, \\ldots, G^{g_I(\\pmb{x})}</span> , an adversary cannot compute  <span class="math">G^{g_c(\\pmb{x})}</span>  for a polynomial  <span class="math">g_c</span>  that is linearly independent from  <span class="math">g_1, \\ldots, g_I</span>  - even if it knows  <span class="math">H^{g_c(\\pmb{x})}</span>  for  <span class="math">H \\in \\mathbb{G}_2</span> .</p>

    <p class="text-gray-300">We extend the computational Poly assumption to the decisional Poly assumption (D-Poly). In the D-Poly game, the adversary acts similarly as in computational Poly game, except that it queries a challenge polynomial and guesses the nature of the output (i.e. whether the output is generated from the polynomial or from an independent random). In this case, the restriction for the challenge  <span class="math">g_{c} \\notin [[Q_{1}]]</span>  is not sufficient where  <span class="math">Q_{1} = \\{g_{1},\\ldots ,g_{I}\\}</span> . For example, the adversary should not have  <span class="math">H^{g_c(\\pmb {x})}</span> ; otherwise it can check whether the received challenge  <span class="math">T</span>  is  <span class="math">G^{g_c(\\pmb {x})}</span>  or a random group element by applying pairings (i.e. check the nature of  <span class="math">T</span>  by  <span class="math">e(T,H^{g_c(\\pmb {x})})</span> ). Thus, the restriction should be extended to</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300"><span class="math">H \\in \\mathbb{G}_2</span> , to prevent the adversary from obtaining the span of  <span class="math">g_c(\\pmb{x})</span>  in  <span class="math">\\mathbb{G}_2</span> . The formal description of the  <span class="math">D - Poly</span>  is as follows.</p>

    <p class="text-gray-300">Assumption 2. D - Poly: Let  <span class="math">\\mathcal{A}</span>  be a PPT adversary, and define the advantage  <span class="math">\\mathbf{Adv}_{\\mathcal{BG},d(\\lambda),q(\\lambda),\\mathcal{A}}^{D - Poly}(\\lambda) = Pr[\\mathcal{G}_{\\mathcal{BG},d(\\lambda),q(\\lambda),\\mathcal{A}}^{D - Poly}] - \\frac{1}{2}</span>  where  <span class="math">\\mathcal{G}_{\\mathcal{BG},d(\\lambda),q(\\lambda),\\mathcal{A}}^{D - Poly}</span>  is defined as below and  <span class="math">Q_{1},Q_{2}</span>  is the set of polynomials  <span class="math">g_{i}(X_{1},\\ldots ,X_{q}),h_{i}(X_{1},\\ldots ,X_{q})</span>  queried to  <span class="math">\\mathcal{O}_{G,\\pmb{x}}^{1},\\mathcal{O}_{H,\\pmb{x}}^{2}</span> .</p>

    <p class="text-gray-300">|  MAIN G0BG,d(λ),q(λ),A(λ)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  (p, G1, G2, GT, e, aux) ← BG(1λ);  |</p>

    <p class="text-gray-300">|  G ← G1; H ← G2; x ← (Zp*)q  |</p>

    <p class="text-gray-300">|  gc(X1, ..., Xq) ← A0G, x, O0H, x (p, G1, G2, GT, e, aux)  |</p>

    <p class="text-gray-300">|  where gc(x)∉ [Q1] × [Q2] × [Q2]^-1  |</p>

    <p class="text-gray-300">|  set T1 ← Ggc(x), T0 ← G1  |</p>

    <p class="text-gray-300">|  b ← {0,1}, T = Tb  |</p>

    <p class="text-gray-300">|  b' ← A0G, x, O0H, x (T)  |</p>

    <p class="text-gray-300">|  return 1 if b = b'  |</p>

    <p class="text-gray-300">|  else return 0  |</p>

    <p class="text-gray-300"><span class="math">\\frac{\\mathcal{O}_{G,\\pmb{x}}^{1}(g_{i})}{assent g_{i}\\in\\mathbb{Z}_{p}^{<em>}[X_{1},\\ldots,X_{q}]}</span> <span class="math">\\frac{\\mathcal{O}_{H,\\pmb{x}}^{2}(h_{j})}{assert h_{j}\\in\\mathbb{Z}_{p}^{</em>}[X_{1},\\ldots,X_{q}]}</span>  assert deg  <span class="math">(g_{i})\\leq d</span>  assert deg  <span class="math">(h_j)\\leq d</span>  return  <span class="math">G^{g_i(\\pmb {x})}</span>  return  <span class="math">H^{h_j(\\pmb {x})}</span></p>

    <p class="text-gray-300">The  <span class="math">(d(\\lambda), q(\\lambda)) - D - \\text{Poly assumption holds relative to } \\mathcal{BG}</span>  if for all PPT adversaries  <span class="math">\\mathcal{A}</span> , we have  <span class="math">\\mathbf{Adv}_{\\mathcal{BG}, d(\\lambda), q(\\lambda), \\mathcal{A}}^{D - \\text{Poly}}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">For the paring-based zk-SNARK, we adopt the definitions from [Gro16, GM17].</p>

    <p class="text-gray-300">Definition 2. A zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARK) for  <span class="math">\\mathcal{R}</span>  is a set of four algorithms  <span class="math">\\Pi_{\\mathrm{snark}} = (\\mathrm{Setup}, \\mathrm{Prove}, \\mathrm{Vfy}, \\mathrm{SimProve})</span>  working as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(CRS, \\tau) \\gets \\mathsf{Setup}(\\mathcal{R})</span> : takes a relation  <span class="math">\\mathcal{R} \\gets \\mathcal{RG}(1^{\\lambda})</span>  as input and returns a common reference string  <span class="math">CRS</span>  and a simulation trapdoor  <span class="math">\\tau</span> .</li>

      <li><span class="math">\\pi \\gets \\operatorname{Prove}(CRS, \\Phi, w)</span> : takes a common reference string  <span class="math">CRS</span> , a relation  <span class="math">\\mathcal{R}</span> , a statement and witness in the relation  <span class="math">(\\Phi, w) \\in \\mathcal{R}</span>  as inputs, and returns a proof  <span class="math">\\pi</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">0/1\\leftarrow\\mathsf{Vfy}(CRS,\\Phi,\\pi)</span>: takes a common reference string <span class="math">CRS</span>, a statement <span class="math">\\Phi</span>, a proof <span class="math">\\pi</span> as inputs and returns 0 (reject) or 1 (accept).</li>

      <li><span class="math">\\pi\\leftarrow\\mathsf{SimProve}(CRS,\\tau,\\Phi)</span>: takes a common reference string <span class="math">CRS</span>, a simulation trapdoor <span class="math">\\tau</span>, a statement <span class="math">\\Phi</span> as inputs and returns a proof <span class="math">\\pi</span>.</li>

    </ul>

    <p class="text-gray-300">It satisfies completeness, knowledge soundness, zero-knowledge, and succinctness described as below:</p>

    <p class="text-gray-300">Completeness: Given a true statement, a prover with a witness can convince the verifier. For all <span class="math">\\lambda\\in\\mathbb{N}</span>, for all <span class="math">\\mathcal{R}</span> and for all <span class="math">(\\Phi,w)\\in\\mathcal{R}</span>, <span class="math">Pr[(CRS,\\tau)\\leftarrow\\mathsf{Setup}(\\mathcal{R}),\\pi\\leftarrow\\mathsf{Prove}(CRS,\\Phi,w):\\mathsf{Vfy}(CRS,\\Phi,\\pi)=1]=1</span>.</p>

    <p class="text-gray-300">Computational Knowledge Soundness: Computational knowledge soundness says that the prover must know a witness and such knowledge can be efficiently extracted from the prover by a knowledge extractor. Proof of knowledge requires that for every adversarial prover <span class="math">\\mathcal{A}</span> generating an accepting proof, there must be an extractor <span class="math">\\chi_{\\mathcal{A}}</span> that, given the same input of <span class="math">\\mathcal{A}</span>, outputs a valid witness. Formally, an argument system <span class="math">\\mathsf{\\Pi}_{\\mathsf{snark}}</span> is computationally considered as knowledge sound if for any PPT adversary <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\chi_{\\mathcal{A}}</span>, such that <span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi}_{\\mathsf{snark}},\\mathcal{A},\\chi_{\\mathcal{A}}}^{sound}(\\lambda)</span> is negligible.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\mathsf{\\Pi}_{\\mathsf{snark}},\\mathcal{A},\\chi_{\\mathcal{A}}}^{sound}(\\lambda)=Pr[(CRS,\\tau)\\leftarrow\\mathsf{Setup}(\\mathcal{R}),(\\Phi^{<em>},\\pi^{</em>})\\leftarrow\\mathcal{A}(CRS),w\\leftarrow\\chi_{\\mathcal{A}}(trans_{\\mathcal{A}}):</span> <span class="math">Vfy(CRS,\\Phi^{<em>},\\pi^{</em>})=1\\wedge(\\Phi^{*},w)\\not\\in\\mathcal{R}]=negl(\\lambda).</span></p>

    <p class="text-gray-300">Perfect Zero-Knowledge: Perfect zero-knowledge states that the system does not leak any information besides the truth of the statement. This is modelled by a simulator that does not know the witness but has some trapdoor information that enables it to simulate proofs.</p>

    <p class="text-gray-300">Succinctness: Succinctness states that the argument generates the proof of polynomial size in the security parameter, and the verifier’s computation time is polynomial in the security parameter and in statement size.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.6 Commit-Carrying SNARK and Commit-and-Prove SNARK</h3>

    <p class="text-gray-300">The commit-carrying SNARK (cc-SNARK) and the commit-and-prove SNARK (CP-SNARK) are originally defined in LegoSNARK <em>[x10]</em>. The main concept of the LegoSNARK is to connect the modular SNARK systems and ensure the same input between them via commitments.</p>

    <p class="text-gray-300">The cc-SNARK is a proof system where the proof includes a commitment to the portion of witnesses, which can be used for the connection. There is no specific restriction for the commitment scheme, but it is convenient to consider it as the Pedersen vector commitment <span class="math">c=h^{o}\\cdot h_{1}^{u_{1}}\\cdots h_{n}^{u_{n}}</span> for a random <span class="math">o\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{Z}_{p}^{*}<span class="math">, messages </span>u_{1},\\cdots,u_{n}<span class="math"> and generators </span>h,h_{1},\\cdots,h_{n}$.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 3</h6>

    <p class="text-gray-300">(cc-SNARK: Definition 3.2 of <em>[x10]</em>). A commit-carrying zk-SNARKs for a relation <span class="math">\\mathcal{R}</span> is a set of four of algorithms <span class="math">\\mathsf{\\Pi}_{\\mathsf{cc}}=({\\sf KeyGen},{\\sf Prove},{\\sf VerProof},{\\sf VerCommit})</span> that works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(ck,ek,vk)\\leftarrow\\mathsf{KeyGen}(\\mathcal{R}):</span> takes a relation <span class="math">\\mathcal{R}</span> as inputs, and outputs a commom reference string which includes a commitment key <span class="math">ck</span>, an evaluation key <span class="math">ek</span>, and a verification key <span class="math">vk</span>.</li>

      <li><span class="math">(c,\\pi;o)\\leftarrow\\mathsf{Prove}(ek,x,w):</span> takes an evaluation key <span class="math">ek</span>, a statement <span class="math">x</span> and a witness <span class="math">w:=(m,\\omega)</span> such that the relation <span class="math">\\mathcal{R}</span> holds as inputs, and outputs a proof <span class="math">\\pi</span>, a commitment <span class="math">c</span> and an opening <span class="math">o</span> such that <span class="math">\\mathsf{VerCommit}(ck,c,u,o)=1</span>.</li>

      <li><span class="math">0/1\\leftarrow\\mathsf{VerProof}(vk,x,c,\\pi):</span> takes a verification key <span class="math">vk</span>, a statement <span class="math">x</span>, a commitment <span class="math">c</span>, a proof <span class="math">\\pi</span> as inputs, and outputs 1 if <span class="math">x,c,\\pi</span> is within the relation <span class="math">\\mathcal{R}</span>, or 0 otherwise.</li>

      <li><span class="math">0/1\\leftarrow\\mathsf{VerCommit}(ck,c,u,o):</span> takes a commitment key <span class="math">ck</span>, a commitment <span class="math">c</span>, a message <span class="math">u</span> and an opening <span class="math">o</span> as inputs, and outputs 1 if the commitment opening is correct, or 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">which satisfies completeness, succinctness, knowledge soundness, zero knowledge and binding (described in <em>[x1]</em>).</p>

    <p class="text-gray-300">The CP-SNARK is a proof system that can link existing cc-SNARKs by using their commitments. The LegoSNARK defines the CP-SNARK framework and provides a CP-SNARK scheme <span class="math">\\mathsf{CP}</span>, that guarantees the connectivity between multiple cc-SNARKs via Pedersen vector commitments.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">(CP-SNARK: Definition 3.1 of <em>[x1]</em>). Let <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be a family of relations <span class="math">R</span> over <span class="math">\\mathcal{D}_{x}\\times\\mathcal{D}_{u}\\times\\mathcal{D}_{\\omega}</span> such that <span class="math">\\mathcal{D}_{u}</span> splits over <span class="math">l</span> arbitrary domains <span class="math">(\\mathcal{D}_{1}\\times\\cdots\\times\\mathcal{D}_{l})</span> for some arity parameter <span class="math">l\\geq 1</span>. Let <span class="math">\\mathsf{Com}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{VerCommit})</span> be a commitment scheme (as per Definition 2.1) whose input space <span class="math">\\mathcal{D}</span> is such that <span class="math">\\mathcal{D}_{i}\\subset\\mathcal{D}</span> for all <span class="math">i\\in[l]</span>. A commit and prove zk-SNARK for <span class="math">\\mathsf{Com}</span> and <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> is a zk-SNARK for a family of relations <span class="math">\\{\\mathcal{R}_{\\lambda}^{\\mathsf{Com}}\\}_{\\lambda\\in\\mathbb{N}}</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>every <span class="math">\\bm{R}\\in\\mathcal{R}^{\\mathsf{Com}}</span> is represented by a pair <span class="math">(ck,R)</span> where <span class="math">ck\\in\\mathsf{Setup}(1^{\\lambda})</span> and <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>;</li>

      <li><span class="math">\\bm{R}</span> is over pairs <span class="math">(\\bm{x},\\bm{w})</span> where the statement is <span class="math">\\bm{x}:=(x,(c_{j})_{j\\in[l]})\\in\\mathcal{D}_{x}\\times\\mathcal{C}^{l}</span>, the witness is <span class="math">\\bm{w}:=((u_{j})_{j\\in[l]},(o_{j})_{j\\in[l]},\\omega)\\in\\mathcal{D}_{1}\\times\\cdots\\times\\mathcal{D}_{l}\\times\\mathcal{O}^{l}\\times\\mathcal{D}_{\\omega}</span>, and the relation <span class="math">\\bm{R}</span> holds iff</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bigwedge_{j\\in[l]}\\mathsf{VerCommit}(ck,c_{j},u_{j},o_{j})=1\\wedge\\mathcal{R}(x,(u_{j})_{j\\in[l]},\\omega)=1</span></p>

    <p class="text-gray-300">We denote a CP-SNARK as a triple of algorithms <span class="math">\\mathsf{CP}=(\\mathsf{KeyGen},\\mathsf{Prove},\\mathsf{VerProof})</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(ek,vk)\\leftarrow\\mathsf{KeyGen}(ck,R):</span> takes a commitment key <span class="math">ck</span>, a relation <span class="math">\\mathcal{R}</span> as inputs, and outputs a commom reference string which includes an evaluation key <span class="math">ek</span>, and a verification key <span class="math">vk</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\mathsf{Prove}(ek,x,(c_{j})_{j\\in[l]},(u_{j})_{j\\in[l]},(o_{j})_{j\\in[l]},\\omega):</span> takes an evaluation key <span class="math">ek</span>, a statement <span class="math">x</span>, commitments <span class="math">c_{j}</span>, messages <span class="math">u_{j}</span>, randoms <span class="math">o_{j}</span>, witnesses <span class="math">\\omega</span>, and outputs the proof of correct commitment.</li>

      <li><span class="math">0/1\\leftarrow\\mathsf{VerProof}(vk,x,(c_{j})_{j\\in[l]},\\pi):</span> takes a verification key <span class="math">vk</span>, a statement <span class="math">x</span>, commitments <span class="math">c_{j}</span>, a proof <span class="math">\\pi</span>, and rejects or accepts the proof.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3.7 Commit-Carrying Encryption</p>

    <p class="text-gray-300">We define a new notion of encryption that can output a commitment which shares a same format with the commit-carrying SNARKs. If the encryption scheme is capable of outputting the Pedersen vector commitment from existing ciphertexts, we say that it is a <em>commit-carrying encryption</em>. It can be formally defined as follows:</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">Suppose a public-key encryption scheme <span class="math">\\mathsf{\\Pi_{enc}}</span> which outputs a ciphertext <span class="math">\\mathcal{CT}</span> for the message input <span class="math">m</span>. For the ciphertext <span class="math">\\mathcal{CT}</span> and a Pedersen vector commitment <span class="math">c=\\mathsf{Ped.Commit}(m)</span> of the message <span class="math">m</span>, if there exists an efficient polynomial-time function <span class="math">f_{c}(x)</span> which satisfies <span class="math">f_{c}(\\mathcal{CT})=c</span>, we say that the encryption scheme <span class="math">\\mathsf{\\Pi_{enc}}</span> is a commit-carrying encryption.</p>

    <p class="text-gray-300">The commit-carrying encryption follows the definition of standard public-key encryption, but it also gains modular composability between other commit-carrying systems via commit-and-prove SNARK (CP-SNARK).</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.8 Additively-Homomorphic Encryption</h3>

    <p class="text-gray-300">We adopt the definition of additively-homomorphic encryption from homomorphic ElGamal encryption <em>[x11]</em>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">Suppose we have an encryption scheme <span class="math">\\mathsf{\\Pi_{enc}}</span> which satisfies the definition of standard public-key encryption. We say that <span class="math">\\mathsf{\\Pi_{enc}}</span> is an additively-homomorphic encryption <span class="math">\\mathsf{\\Pi_{AH}}</span>, if it additionally satisfies Completeness described as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Enc}(M_{i})\\circ\\mathsf{Enc}(M_{j})=\\mathsf{Enc}(M_{i}+M_{j})</span> <span class="math">\\mathsf{Dec}(\\mathcal{CT}_{i})+\\mathsf{Dec}(\\mathcal{CT}_{j})=\\mathsf{Dec}(\\mathcal{CT}_{i}\\circ\\mathcal{CT}_{j})</span></p>

    <p class="text-gray-300">for any messages <span class="math">M_{i},M_{j}</span> and any ciphertexts <span class="math">\\mathcal{CT}_{i},\\mathcal{CT}_{j}</span>.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.9 Verifiable Encryption</h3>

    <p class="text-gray-300">We refine the definition of verifiable encryption by combining the previous definitions in <em>[x10, x23]</em>. We mostly follow the definitions in <em>[x10]</em>, but separate the verification phase individual from decryption as in <em>[x23]</em>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">Suppose we have an encryption scheme <span class="math">\\mathsf{\\Pi_{enc}}</span> which satisfies the definition of standard public-key encryption. We say that <span class="math">\\mathsf{\\Pi_{enc}}</span> is a verifiable encryption <span class="math">\\mathsf{\\Pi_{VE}}</span>, if it additionally includes the following polynomial-time algorithm for some pre-defined relation <span class="math">\\mathcal{R}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi,\\mathcal{CT}\\leftarrow\\mathsf{Enc}(PK,M):</span> the encryption of a message <span class="math">M</span> under the public key <span class="math">PK</span> must output a proof <span class="math">\\pi</span>, along with the corresponding ciphertext <span class="math">\\mathcal{CT}</span>.</li>

      <li><span class="math">0/1\\leftarrow\\mathsf{Verify\\_Enc}(VK,\\pi,\\mathcal{CT}):</span> takes a verification key <span class="math">VK</span>, an encryption proof <span class="math">\\pi</span>, a corresponding ciphertext <span class="math">\\mathcal{CT}</span> as inputs, and outputs 1 if <span class="math">\\pi,\\mathcal{CT}</span> is within the relation <span class="math">\\mathcal{R}</span>, or 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">with satisfying completeness, encryption soundness, and perfect zero-knowledge as described below:</p>

    <p class="text-gray-300">Completeness: A proof <span class="math">\\pi</span> and a ciphertext <span class="math">\\mathcal{CT}</span> must pass the verification if they are honestly generated from a message <span class="math">M</span> which satisfies <span class="math">M\\in\\mathcal{R}</span>, formally as <span class="math">Pr[(\\pi,\\mathcal{CT})\\leftarrow\\mathsf{Enc}(PK,M),M\\in\\mathcal{R}:\\mathsf{Verify\\_Enc}(VK,\\pi,\\mathcal{CT})=1]=1</span>.</p>

    <p class="text-gray-300">Encryption Soundness: The advantage of an adversary forging verifying <span class="math">\\pi^{<em>},\\mathcal{CT}^{</em>}</span> where <span class="math">M\\not\\in\\mathcal{R}</span> is negligible.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{sound}_{\\Pi_{\\mathsf{VE}},\\mathcal{A}}(\\lambda)=Pr[(SK,PK,VK)\\leftarrow KeyGen(\\lambda),(\\mathcal{CT}^{<em>},\\pi^{</em>})\\leftarrow\\mathcal{A}(PK,VK):</span> <span class="math">\\mathsf{Verify\\_Enc}(VK,\\pi^{<em>},\\mathcal{CT}^{</em>})=1\\wedge\\mathsf{Dec}(SK,\\mathcal{CT}^{*})\\not\\in\\mathcal{R}]=negl(\\lambda).</span></p>

    <p class="text-gray-300">Indistinguishability: Assuming within a same relation <span class="math">\\mathcal{R}</span>, a verifiable encryption should satisfy IND-CPA of the original public-key encryption, with providing additional information <span class="math">\\pi</span> to the adversary.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.10 Verifiable Decryption</h3>

    <p class="text-gray-300">We refine the definition of verifiable decryption from <em>[x10]</em>; the definition in <em>[x10]</em> represents the proof system and the encryption system separately, but we intend to combine them as an encryption scheme with verifying phase. Plus, we strengthen the security notion from decryption soundness to perfect decryption soundness, and introduce a new security notion - perfect zero-knowledge.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 8</h6>

    <p class="text-gray-300">Suppose we have an encryption scheme <span class="math">\\Pi_{\\mathsf{enc}}</span> which satisfies the definition of standard public-key encryption. We say that <span class="math">\\Pi_{\\mathsf{enc}}</span> is a verifiable decryption <span class="math">\\Pi_{\\mathsf{VD}}</span>, if it additionally includes the following polynomial-time algorithm:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M,\\nu\\leftarrow\\mathsf{Dec}(SK,\\mathcal{CT}):</span> the decryption of a ciphertext <span class="math">\\mathcal{CT}</span> outputs a message <span class="math">M</span>, along with the corresponding decryption proof <span class="math">\\nu</span>.</li>

      <li><span class="math">0/1\\leftarrow\\mathsf{Verify\\_Dec}(VK,M,\\nu,\\mathcal{CT}):</span> takes a verification key <span class="math">VK</span>, a message <span class="math">M</span>, a decryption proof <span class="math">\\nu</span>, a ciphertext <span class="math">\\mathcal{CT}</span> as inputs, and outputs 1 if <span class="math">M,\\nu</span> is a valid decryption for <span class="math">\\mathcal{CT}</span> or 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">with satisfying completeness, and perfect decryption soundness, and indistinguishability as described below:</p>

    <p class="text-gray-300">Completeness: A message <span class="math">M</span> and a decryption proof <span class="math">\\nu</span> must pass the verification, if decrypting <span class="math">\\mathcal{CT}</span> with <span class="math">SK</span> outputs <span class="math">M</span>, formally as <span class="math">Pr[(M,\\nu)\\leftarrow\\mathsf{Dec}(SK,\\mathcal{CT}),\\mathcal{CT}=\\mathsf{Enc}(PK,M):\\mathsf{Verify\\_Dec}(VK,M,\\nu,\\mathcal{CT})=1]=1</span>.</p>

    <p class="text-gray-300">Perfect Decryption Soundness: The advantage of an adversary forging verifying <span class="math">M^{<em>},\\nu^{</em>},\\mathcal{CT}^{<em>}</span> where <span class="math">M^{</em>}</span> is not a decryption of <span class="math">\\mathcal{CT}</span> is 0.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\Pi_{\\textsf{VD}},\\mathcal{A}}^{sound}(\\lambda)=Pr[(M^{<em>},\\nu^{</em>},\\mathcal{CT}^{<em>})\\leftarrow\\mathcal{A}(SK,PK,VK):</span> <span class="math">\\textsf{Verify\\_Dec}(VK,M^{</em>},\\nu^{<em>},\\mathcal{CT}^{</em>})=1\\wedge\\textsf{Dec}(SK,\\mathcal{CT}^{<em>})\\neq M^{</em>}]=0.</span></p>

    <p class="text-gray-300">Indistinguishability: A verifiable decryption should satisfy IND-CPA of the original public-key encryption, with providing additional information <span class="math">\\nu</span> to an adversary <span class="math">\\mathcal{A}</span>, for <span class="math">\\mathcal{A}</span>’s chosen messages.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.11 Rerandomizable Encryption</h3>

    <p class="text-gray-300">We adopt the definition of rerandomizable encryption from <em>[x23]</em>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">Suppose we have an encryption scheme <span class="math">\\Pi_{\\textsf{enc}}</span> which satisfies the definition of standard public-key encryption. We say that <span class="math">\\Pi_{\\textsf{enc}}</span> is a rerandomizable encryption <span class="math">\\Pi_{\\textsf{RR}}</span>, if it additionally includes the following polynomial-time algorithm:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{CT}^{\\prime}\\leftarrow\\textsf{Rerandomize}(PK,\\mathcal{CT}):</span> a randomized algorithm which takes a public key PK and a ciphertext <span class="math">\\mathcal{CT}</span> and outputs another ciphertext <span class="math">\\mathcal{CT}^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">which satisfies completeness and rerandomizability described as below:</p>

    <p class="text-gray-300">Completeness: For every ciphertext <span class="math">\\mathcal{CT}</span> and every <span class="math">\\mathcal{CT}^{\\prime}</span> in the support of <span class="math">\\textsf{Rerandomize}(PK,\\mathcal{CT})</span>, we must have <span class="math">\\textsf{Dec}(SK,\\mathcal{CT}^{\\prime})=\\textsf{Dec}(SK,\\mathcal{CT})</span>.</p>

    <p class="text-gray-300">Rerandomizability: For every plaintext <span class="math">M</span> and every ciphertext <span class="math">\\mathcal{CT}</span> in the support of <span class="math">\\textsf{Enc}(PK,M)</span>, the distribution of <span class="math">\\textsf{Rerandomize}(PK,\\mathcal{CT})</span> is identical to another round of <span class="math">\\textsf{Enc}(PK,M)</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.12 Definition of SAVER</h3>

    <p class="text-gray-300">We represent the definition of our SAVER: SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization - which satisfies the properties of zk-SNARK <span class="math">\\Pi_{\\textsf{snark}}</span>, additively-homomorphic encryption <span class="math">\\Pi_{\\textsf{AH}}</span>, verifiable encryption <span class="math">\\Pi_{\\textsf{VE}}</span>, verifiable decryption <span class="math">\\Pi_{\\textsf{VD}}</span> and rerandomizable encryption <span class="math">\\Pi_{\\textsf{RR}}</span> altogether.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 10.</h6>

    <p class="text-gray-300">For any arbitrary zk-SNARK relation <span class="math">\\mathcal{R}</span> (also noted as relation), the SAVER consists of seven polynomial-time algorithms as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">CRS\\leftarrow\\textsf{Setup(relation)}:</span> takes an arbitrary relation <span class="math">\\mathcal{R}</span> as an input, and outputs the corresponding common reference string <span class="math">CRS</span>.</li>

      <li><span class="math">SK,PK,VK\\leftarrow\\textsf{KeyGen}(CRS):</span> takes a <span class="math">CRS</span> as an input, and outputs the corresponding secret key <span class="math">SK</span>, public key <span class="math">PK</span>, verification key <span class="math">VK</span>.</li>

      <li><span class="math">\\pi,\\mathcal{CT}\\leftarrow\\textsf{Enc}(CRS,PK,M,\\tilde{\\Phi};w):</span> takes <span class="math">CRS</span>, a public key <span class="math">PK</span>, a message <span class="math">M=m_{1},\\ldots,m_{n}</span>, a zk-SNARK statement <span class="math">\\tilde{\\Phi}=\\{\\phi_{n+1},\\ldots,\\phi_{l}\\}</span>, and a witness <span class="math">w</span> as inputs, and outputs a proof <span class="math">\\pi</span> and a ciphertext <span class="math">\\mathcal{CT}=(c_{0},\\cdots,c_{n},\\psi)</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi&#x27;, \\mathcal{CT}&#x27; \\gets \\text{Rerandomize}(PK, \\pi, \\mathcal{CT})</span> : takes a public key <span class="math">PK</span>, a proof <span class="math">\\pi</span>, a ciphertext <span class="math">\\mathcal{CT}</span> as inputs, and outputs a new proof <span class="math">\\pi&#x27;</span> and a new ciphertext <span class="math">\\mathcal{CT}&#x27;</span> with fresh randomness.</li>

      <li><span class="math">0/1 \\gets \\text{Verify\\_Enc}(CRS, \\pi, \\mathcal{CT}, \\hat{\\varPhi})</span> : takes <span class="math">CRS</span>, a proof <span class="math">\\pi</span>, a ciphertext <span class="math">\\mathcal{CT}</span>, and a statement <span class="math">\\hat{\\varPhi} = \\{\\phi_{n+1}, \\ldots, \\phi_l\\}</span> as inputs, and outputs 1 if <span class="math">\\mathcal{CT}, \\hat{\\varPhi}</span> is in the relation <span class="math">\\mathcal{R}</span>, or 0 otherwise.</li>

      <li><span class="math">M, \\nu \\gets \\mathsf{Dec}(CRS, SK, VK, \\mathcal{CT})</span> : takes <span class="math">CRS</span>, a secret key <span class="math">SK</span>, a verification key <span class="math">VK</span>, and a ciphertext <span class="math">\\mathcal{CT} = (c_0, \\dots, c_n, \\psi)</span> as inputs, and outputs a plaintext <span class="math">M = m_1, \\dots, m_n</span> and a decryption proof <span class="math">\\nu</span>.</li>

      <li><span class="math">0/1 \\gets \\text{Verify\\_Dec}(CRS, VK, M, \\nu, \\mathcal{CT})</span> : takes <span class="math">CRS</span>, a verification key <span class="math">VK</span>, a message <span class="math">M</span>, a decryption proof <span class="math">\\nu</span>, and a ciphertext <span class="math">\\mathcal{CT}</span> as inputs, and outputs 1 if <span class="math">M</span> is a valid decryption of <span class="math">\\mathcal{CT}</span>, or 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">It satisfies completeness, indistinguishability, encryption knowledge soundness, rerandomizability, decryption soundness, perfect zero-knowledge as described below:</p>

    <p class="text-gray-300"><strong>Completeness</strong>: The completeness of SAVER must satisfy the completeness of <span class="math">\\Pi_{\\text{snark}}</span>, <span class="math">\\Pi_{\\text{AH}}</span>, <span class="math">\\Pi_{\\text{VE}}</span>, <span class="math">\\Pi_{\\text{VD}}</span> and <span class="math">\\Pi_{\\text{RR}}</span> altogether.</p>

    <p class="text-gray-300"><strong>Indistinguishability</strong>: The indistinguishability is also known as semantic security (IND-CPA). The IND-CPA of the SAVER should be indistinguishability of <span class="math">\\Pi_{\\mathsf{VE}}</span> and <span class="math">\\Pi_{\\mathsf{VD}}</span>, which is defined by an adversary <span class="math">\\mathcal{A}</span> and a challenger <span class="math">\\mathcal{C}</span> via following game.</p>

    <p class="text-gray-300"><strong>Setup</strong>: The challenger <span class="math">\\mathcal{C}</span> runs Setup(relation) to obtain <span class="math">CRS, \\tau</span>, and share <span class="math">CRS, \\tau</span> and statements <span class="math">\\hat{\\varPhi}</span> to <span class="math">\\mathcal{A}</span>. Note that the adversary <span class="math">\\mathcal{A}</span> is given the trapdoor <span class="math">\\tau = \\{\\alpha, \\beta, \\gamma, \\delta\\}</span> as an additional information, since ability to simulate the proof does not affect the security of the ciphertext indistinguishability.</p>

    <p class="text-gray-300"><strong>KeyGen</strong>: <span class="math">\\mathcal{C}</span> runs KeyGen(CRS) to obtain a secret key <span class="math">SK</span>, a public key <span class="math">PK</span>, and a verification key <span class="math">VK</span>. Then, <span class="math">\\mathcal{C}</span> gives <span class="math">PK, VK</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}_{\\nu}</span> phase 1: If the message is decrypted, the decryption proof <span class="math">\\nu</span> is also revealed. Therefore, <span class="math">\\mathcal{A}</span> may request decryption proof for <span class="math">M</span> as an additional information since knowing <span class="math">M</span> may indicate it is already decrypted. For the polynomial-time, <span class="math">\\mathcal{A}</span> may issue decryption proof query as <span class="math">M_{i}</span>, to obtain the corresponding ciphertext <span class="math">\\mathcal{CT}_i</span> and a decryption proof <span class="math">\\nu_{i}</span>. <span class="math">\\mathcal{C}</span> generates <span class="math">\\pi_i,\\mathcal{CT}_i</span> by running Enc(CRS, PK, <span class="math">M_{i},\\hat{\\varPhi};w</span>), generates <span class="math">\\nu_{i}</span> by running Dec(CRS, SK, VK, <span class="math">\\mathcal{CT}_i</span>), and returns <span class="math">(\\pi_i,\\mathcal{CT}_i,\\nu_i)</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300"><strong>Challenge</strong>: For the challenge, <span class="math">\\mathcal{A}</span> outputs two messages <span class="math">M_0</span> and <span class="math">M_1</span>. <span class="math">\\mathcal{C}</span> picks <span class="math">b \\in \\{0, 1\\}</span> to choose <span class="math">M_b</span>, generates <span class="math">\\pi, \\mathcal{CT}</span> by running Enc(CRS, PK, <span class="math">M_b, \\hat{\\varPhi}; w</span>), and returns <span class="math">\\pi, \\mathcal{CT}</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}_{\\nu}</span> phase 2: <span class="math">\\mathcal{A}</span> can continue to issue encryption queries <span class="math">M_{j}</span>, same as <span class="math">\\mathcal{O}_{\\nu}</span> phase 1. The only restriction is that <span class="math">M_{j} \\notin \\{M_{0}, M_{1}\\}</span>.</p>

    <p class="text-gray-300"><strong>Guess</strong>: <span class="math">\\mathcal{A}</span> outputs its guess <span class="math">b&#x27; \\in \\{0,1\\}</span> for <span class="math">b</span>, and wins the game if <span class="math">b = b&#x27;</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{Adv}^{ind}_{\\mathsf{SAVER},\\mathcal{A}}(\\lambda)</span> be the advantage of <span class="math">\\mathcal{A}</span> winning the above game. For a negligible function <span class="math">\\epsilon</span>, it is IND-CPA secure if for any adversary <span class="math">\\mathcal{A}</span> we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}^{ind}_{\\mathsf{SAVER},\\mathcal{A}}(\\lambda)-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Encryption Knowledge Soundness: The encryption knowledge soundness is a combined definition of computational knowledge soundness in <span class="math">\\mathsf{\\Pi_{snark}}</span> and encryption soundness in <span class="math">\\mathsf{\\Pi_{VE}}</span>. It is formally defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{sound}_{\\mathsf{SAVER},\\mathcal{A},\\chi_{\\mathcal{A}}}(\\lambda)=Pr[(CRS,\\tau)\\leftarrow\\mathsf{Setup}(\\mathcal{R}),(PK,SK,VK)\\leftarrow\\mathsf{KeyGen}(CRS),</span> <span class="math">(\\pi^{<em>},\\mathcal{CT}^{</em>},\\tilde{\\varPhi}^{<em>})\\leftarrow\\mathcal{A}(CRS,PK,VK),(M,w)\\leftarrow\\chi_{\\mathcal{A}}(trans_{\\mathcal{A}}):</span> <span class="math">\\mathsf{Verify\\_Enc}(CRS,\\pi^{</em>},\\mathcal{CT}^{<em>},\\tilde{\\varPhi}^{</em>})=1\\wedge(\\mathsf{Dec}(\\mathcal{CT}^{<em>})\\neq M\\vee(M,\\tilde{\\varPhi}^{</em>},w)\\not\\in\\mathcal{R})]=negl(\\lambda).</span></p>

    <p class="text-gray-300">Rerandomizability: The rerandomizability is extended from <span class="math">\\mathsf{\\Pi_{RR}}</span>, to include <span class="math">\\pi</span> as follows: for all <span class="math">M</span> and <span class="math">\\pi,\\mathcal{CT}</span> in the support of <span class="math">\\mathsf{Enc}(CRS,PK,M,\\tilde{\\varPhi};w)</span>, the distribution of <span class="math">\\mathsf{Rerandomize}(PK,\\pi,\\mathcal{CT})</span> is identical to another round of <span class="math">\\mathsf{Enc}(CRS,PK,M,\\tilde{\\varPhi};w)</span>.</p>

    <p class="text-gray-300">Perfect Decryption Soundness: Equivalent to the perfect decryption soundness in <span class="math">\\mathsf{\\Pi_{VD}}</span>.</p>

    <p class="text-gray-300">Perfect Zero-Knowledge: Equivalent to the perfect zero-knowledge in <span class="math">\\mathsf{\\Pi_{snark}}</span>.</p>

    <h2 id="sec-25" class="text-2xl font-bold">4 Proposed SAVER</h2>

    <p class="text-gray-300">In this section, we represent the formal construction of the proposed SAVER: SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization. In section 4.1, we provide some intuitive ideas on designing SAVER. Then we show the construction in section 4.2, which is a commit-carrying encrypt-with-prove scheme. In section 4.3, we show that the construction in section 4.2 also satisfies the encrypt-and-prove framework by using the commitment <span class="math">\\psi</span> included in the ciphertext <span class="math">\\mathcal{CT}</span>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">4.1 Main Idea</h3>

    <p class="text-gray-300">Before presenting the construction, we provide some intuitive ideas on designing the proposed SAVER. For the voting application in section 1.1, the main objective is to design generic verifiable encryption with additional functionalities: additive-homomorphism, rerandomizability, and verifiable decryption. A naive approach to achieve this is to include the entire encryption algorithm in the zk-SNARK circuit along with the generic relation (to ensure the consistency of <span class="math">m</span> between <span class="math">\\mathsf{Prove}</span> and <span class="math">\\mathsf{Enc}</span>), which we refer to as encryption-in-the-circuit method <em>[KZM^{+}15a, KZM^{+}15b]</em>.</p>

    <p class="text-gray-300">Algorithm 1 represents zk-SNARK relations required when applying the encryption-in-the-circuit approach. We need three individual relations of <span class="math">\\mathsf{relation_{enc}}</span>, <span class="math">\\mathsf{relation_{rerand}}</span>, and <span class="math">\\mathsf{relation_{dec}}</span> to satisfy the desired properties. In <span class="math">\\mathsf{relation_{enc}}</span>, a</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">|  Algorithm 1 Encryption-in-the-circuit  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  relationenc(PK,CT,φn+1,...,φl;M):  |</p>

    <p class="text-gray-300">|  CT←ΠRR,AH.Enc(PK,M)  |</p>

    <p class="text-gray-300">|  ...  |</p>

    <p class="text-gray-300">|  relationrerand(PK,CT',φn+1,...,φl;π,CT):  |</p>

    <p class="text-gray-300">|  Πsnark.Verify(π,PK,CT,φn+1,...,φl)  |</p>

    <p class="text-gray-300">|  CT'←ΠRR,AH.Rerandomize(PK,CT)  |</p>

    <p class="text-gray-300">|  relationdec(CT,M;SK)  |</p>

    <p class="text-gray-300">|  M←ΠRR,AH.Dec(SK,CT)  |</p>

    <p class="text-gray-300">rerandomizable homomorphic encryption  <span class="math">\\Pi_{\\mathsf{RR},\\mathsf{AH}}</span>  like Paillier [Pai99] is combined with the arbitrary relation to satisfy the verifiable additively-homomorphic encryption. In relationrerand for rerandomizability, the relation includes the verification of proof  <span class="math">\\pi</span>  to check the relation of  <span class="math">\\mathcal{CT}</span> , along with the rerandomization of the ciphertext. For example, in the voting application, the administrator must first verify the vote before rerandomizing it, to check that the vote is generated honestly from an eligible user. In relationdec, the decryption algorithm is included to provide verifiable decryption property. When proceeding the verifiable encryption with these relations, the construction becomes very inefficient: Enc should include  <span class="math">\\Pi_{\\mathsf{snark}}</span> . Prove(relationenc), Rerandomize should include  <span class="math">\\Pi_{\\mathsf{snark}}</span> . Prove(relationrerand), and Dec should include  <span class="math">\\Pi_{\\mathsf{snark}}</span> . Prove(relationdec).</p>

    <p class="text-gray-300">To avoid the inefficiency, we separate encryption from the zk-SNARK relation and provide connectivity between them, similar to the Hash&amp;Prove  <span class="math">\\mathrm{[FFG^{+}16]}</span>  or Commit&amp;Prove in LegoSNARK [CFQ19]. Naively binding the encryption and zk-SNARK via commitments as in  <span class="math">\\mathrm{[FFG^{+}16]}</span>  may require additional verifications for the linkage. Instead of verifying the linkage separately, we let the ciphertext blend into the original zk-SNARK verification, by replacing the statement (Inputs/Outputs). Intuitively, since zk-SNARK statements are constructed as linear encodings, it is possible to extend the statement as an ElGamal ciphertext.</p>

    <p class="text-gray-300">Let us observe the zk-SNARK verification in [Gro16] as follows:</p>

    <div class="my-4 text-center"><span class="math-block">e (A, B) = e \\left(G ^ {\\alpha}, H ^ {\\beta}\\right) \\cdot e \\left(\\prod_ {i = 0} ^ {l} G _ {i} ^ {\\phi_ {i}}, H ^ {\\gamma}\\right) \\cdot e (C, H ^ {\\delta})</span></div>

    <p class="text-gray-300">In the equation,  <span class="math">(\\phi_1,\\ldots ,\\phi_l)</span>  can be not only a statement and but also a plaintext. Suppose that  <span class="math">\\phi_{1}</span>  should be encrypted. Let a plaintext message  <span class="math">M = \\phi_{1}</span> . Then we may construct a ciphertext  <span class="math">\\mathcal{CT} = G_1^M</span>  similar to the ElGamal encryption, which maintains the original verification format as following:</p>

    <div class="my-4 text-center"><span class="math-block">e (A, B) = e \\left(G ^ {\\alpha}, H ^ {\\beta}\\right) \\cdot e \\left(\\mathcal {C T} \\cdot \\prod_ {i = 2} ^ {l} G _ {i} ^ {\\phi_ {i}}, H ^ {\\gamma}\\right) \\cdot e (C, H ^ {\\delta})</span></div>

    <p class="text-gray-300">However, it is obvious that  <span class="math">\\mathcal{CT}</span>  should include additional blinding factors mixed to  <span class="math">G_1^M</span> . When we denote the blinding factor as  <span class="math">X^r</span> , i.e.,  <span class="math">\\mathcal{CT} = X^r \\cdot G_1^M</span> ,</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">the pairing <span class="math">e(X^r \\cdot G_1^M \\cdot \\prod_{i=2}^l G_i^{\\phi_i}, H^\\gamma)</span> generates unintended <span class="math">\\gamma r</span> term in <span class="math">e(X^r, H^\\gamma)</span>, which breaks equality of the equation. To resolve this problem, we include <span class="math">G^{-\\gamma}</span> in the CRS. The prover modifies the proof element <span class="math">C</span> as <span class="math">C = C \\cdot G^{-\\gamma r}</span> so that the <span class="math">\\gamma r</span> term can be eliminated with respect to the <span class="math">\\delta</span> from <span class="math">e(C, H^\\delta)</span>. As a result, the verification of zk-SNARK can ensure the existence of <span class="math">M</span> in the ciphertext, as well as the soundness of <span class="math">M</span> within the relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Another interesting fact is that the form of <span class="math">G_{i}^{M}</span> can be plugged into the additive-homomorphism based on the ElGamal encryption. As introduced in [CGS97], it is easy to transform the ElGamal encryption by encrypting <span class="math">G_{i}^{M}</span> instead of <span class="math">M</span>, to achieve additive-homomorphism as <span class="math">G_{i}^{M_{1}} \\cdot G_{i}^{M_{2}} = G_{i}^{M_{1} + M_{2}}</span>. In this case, the decryption requires finding the short discrete log of <span class="math">G_{i}^{M}</span>, which restricts the message space to be short enough. Therefore, we split the message <span class="math">M</span> into short message spaces as $M = (m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{n})<span class="math"> (e.g. </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 4bits<span class="math">), and encrypt each block </span>m_{i}<span class="math"> in the form of </span>X_{i}^{r} \\cdot G_{i}^{m_{i}}<span class="math"> where </span>X_{i}^{r}<span class="math"> is a blinding factor. The decryptor who can remove the blinding factor can obtain </span>m_{i}<span class="math"> by the simple brute-forcing (less than </span>2^{4}<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 4bits$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-27" class="text-2xl font-bold">4.2 SAVER Construction</h2>

    <p class="text-gray-300">We now represent a formal construction of the proposed SAVER: SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization. To be an encrypt-with-prove scheme, SAVER utilizes a zk-SNARK <span class="math">\\Pi_{\\mathsf{snark}}</span> as a building block; we used Groth's protocol [Gro16] as a standard. It is possible to adopt other pairing-based zk-SNARKs such as [GM17] and [KLO20], with some adjustments on Verify_Enc and Rerandomize to assemble the verification and proof format<span class="math">^{6}</span>. SAVER is also a commit-carrying encryption (encrypt-and-prove) at the same time; the ciphertext <span class="math">\\mathcal{CT}</span> includes a commitment <span class="math">\\psi</span> which can be connected to the commit-and-prove framework of LegoSNARK [CFQ19].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In SAVER, a message <span class="math">M</span> is split into <span class="math">n</span> blocks as $M = (m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{n})<span class="math">, to form a vector </span>M = \\{m_1,\\ldots ,m_n\\}<span class="math">. A ciphertext </span>\\mathcal{CT}<span class="math"> consists of </span>n + 2<span class="math"> blocks as </span>\\mathcal{CT} = \\{c_0,\\dots ,c_n,\\psi \\}<span class="math">, where </span>c_{0}<span class="math"> contains the random, </span>\\psi<span class="math"> contains a commitment, and the remaining </span>c_{i}<span class="math"> contains an encryption of </span>m_{i}<span class="math"> for </span>1\\leq i\\leq n<span class="math">. Within the construction, we work with </span>\\{m_1,\\dots ,m_n\\}<span class="math">, assuming that </span>M<span class="math"> is already parsed to </span>M = (m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{n})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 2 represents the formal construction of SAVER. The term relation denotes an arbitrary relation <span class="math">\\mathcal{R}</span> for the zk-SNARK, and the terms of <span class="math">\\alpha, \\beta, \\gamma</span>, and <span class="math">\\delta</span> within the functions come from <span class="math">CRS</span> (common reference string) of the adopted zk-SNARK scheme [Gro16]. In case of encrypt-and-prove, there is a possibility that the relation has not been determined yet (when encrypting only</p>

    <p class="text-gray-300"><span class="math">^{6}</span> Rerandomization of the proof can be viewed as a manipulation, which is prohibited in the simulation-extractable zk-SNARKs. Providing additional terms (for example, <span class="math">G^{a\\delta}</span> to rerandomize [KLO20]) can resolve this by allowing one-time rerandomization in a restricted manner.</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">|  Algorithm 2 SAVER construction  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  relation(m1, ..., mn, φn+1, ..., φl; w):  |   |</p>

    <p class="text-gray-300">|  ...  |   |</p>

    <p class="text-gray-300">|  Setup(relation):  |   |</p>

    <p class="text-gray-300">|  CRS← Πmark-Setup(relation)  |   |</p>

    <p class="text-gray-300">|  CRS← CRS ∪ {G-γ}  |   |</p>

    <p class="text-gray-300">|  return CRS  |   |</p>

    <p class="text-gray-300">|  KeyGen(CRS):  |   |</p>

    <p class="text-gray-300">|  {si}n=1, {vi}n=1, {ti}n=0, ρ← Zp*  |   |</p>

    <p class="text-gray-300">|  PK← (Gδ, {Gδsi}n=1, {Gti}n=1, {Hti}n=0, Gδt0Πj=1N Gδtjsi,j, G-γ·(1+∑j=1n sj))  |   |</p>

    <p class="text-gray-300">|  SK← ρ  |   |</p>

    <p class="text-gray-300">|  VK← (Hρ, {HsiVi}n=1, {Hρvi}n=1)  |   |</p>

    <p class="text-gray-300">|  return (SK, PK, VK)  |   |</p>

    <p class="text-gray-300">|  Enc(CRS, PK, m1, ..., mn, φn+1, ..., φl; w):  |   |</p>

    <p class="text-gray-300">|  let PK = (X0, {Xi}n=1, {Yi}n=1, {Zi}n=0, P1, P2)  |   |</p>

    <p class="text-gray-300">|  r← Zp*  |   |</p>

    <p class="text-gray-300">|  CT = (X0<em>, X1</em>G1m1, ..., Xn*Gmn, ψ = P1r, Πj=1N Yjmj)  |   |</p>

    <p class="text-gray-300">|  π = (A, B, C) ← Πmark.Prove(CRS, m1, ..., mn, φn+1, ..., φl; w)  |   |</p>

    <p class="text-gray-300">|  π ← (A, B, C·P2r)  |   |</p>

    <p class="text-gray-300">|  return (π, CT)  |   |</p>

    <p class="text-gray-300">|  Rerandomize(PK, π, CT):  |   |</p>

    <p class="text-gray-300">|  parse π = (A, B, C) and CT = (c0, ..., cn, ψ)  |   |</p>

    <p class="text-gray-300">|  let PK = (X0, {Xi}n=1, {Yi}n=1, {Zi}n=0, P1, P2)  |   |</p>

    <p class="text-gray-300">|  r', z1, z2← Zp*  |   |</p>

    <p class="text-gray-300">|  CT' ← (c0·X0<em>, ..., cn·Xn</em>, ψ·P1r')  |   |</p>

    <p class="text-gray-300">|  π' ← (Az1, Bz1-1·Hδ·z2, C·Az1z2·P2r')  |   |</p>

    <p class="text-gray-300">|  return (π', CT')  |   |</p>

    <p class="text-gray-300">|  Verify.Enc(CRS, PK, π, CT, φn+1, ..., φl):  |   |</p>

    <p class="text-gray-300">|  parse π = (A, B, C) and CT = (c0, ..., cn, ψ)  |   |</p>

    <p class="text-gray-300">|  let PK = (X0, {Xi}n=1, {Yi}n=1, {Zi}n=0, P1, P2)  |   |</p>

    <p class="text-gray-300">|  assert Πn=0e(ci, Zi) = e(ψ, H)  |   |</p>

    <p class="text-gray-300">|  assert e(A, B) = e(Gn, Hβ) · e(Πn=0ci · Πn=1Gn, Hγ) · e(C, Hδ)  |   |</p>

    <p class="text-gray-300">ahead of time); in this case, the relation can be assumed as an empty circuit (i.e.  <span class="math">G^{\\delta}, G_{i}, G^{\\gamma} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_{1}</span> ).</p>

    <p class="text-gray-300">SAVER receives any relation which consists of two I/O statements. Statements  <span class="math">m_{1},\\ldots ,m_{n}</span>  will be encrypted while statements  <span class="math">\\phi_{n + 1},\\dots,\\phi_l</span>  will be used as normal I/O statements in plaintext. For the given relation, Setup generates CRS using the adopted zk-SNARKs scheme, with additional  <span class="math">G^{-\\gamma}</span> . KeyGen generates a private key, a public key, and a verification key. Enc encrypts messages  <span class="math">m_{1},\\ldots ,m_{n}</span>  and generates a proof  <span class="math">\\pi</span>  of statement  <span class="math">\\varPhi=(m_1,\\ldots,m_n,\\phi_{n+1},\\ldots,\\phi_l)</span> .</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <pre><code class="language-latex">$\\begin{array}{rl} &amp;amp; {\\mathrm{Dec}(CRS,SK,VK,\\mathcal{CT}):}\\\\ &amp;amp; {\\mathrm{parse}~SK = \\rho ,~VK = (V_0,\\{V_i\\}_{i = 1}^n,\\{V_i\\}_{i = n + 1}^{2n}),\\mathrm{and}~CT = (c_0,\\ldots ,c_n,\\psi)}\\\\ &amp;amp; {\\mathrm{for}~i = 1\\mathrm{do~to~}n}\\\\ &amp;amp; {\\frac{e(c_i,V_{n + i})}{e(c_0,V_i)^\\rho} = e(G_i,V_{n + i})^{m_i}}\\\\ &amp;amp; {\\mathrm{compute~a~discrete~log~of~}e(G_i,V_{n + i})^{m_i}\\mathrm{~to~obtain~}m_i}\\\\ &amp;amp; {\\mathrm{end~for}}\\\\ &amp;amp; {\\nu \\leftarrow c_0^\\rho}\\\\ &amp;amp; {\\mathrm{return}~(m_1,\\dots m_n,\\nu)}\\\\ &amp;amp; {\\mathrm{Verify\\_Dec}(CRS,VK,m_1,\\dots m_n,\\nu ,\\mathcal{CT}):}\\\\ &amp;amp; {\\mathrm{parse}~VK = (V_0,\\{V_i\\}_{i = 1}^n,\\{V_i\\}_{i = n + 1}^{2n})\\mathrm{~and~}\\mathcal{CT} = (c_0,\\dots ,c_n,\\psi)}\\\\ &amp;amp; {\\mathrm{assert}~e(\\nu ,H) = e(c_0,V_0)}\\\\ &amp;amp; {\\mathrm{for}~i = 1\\mathrm{do~to~}n}\\\\ &amp;amp; {\\mathrm{assert}~\\frac{e(c_i,V_{n + i})}{e(\\nu,V_i)} = e(G_i,V_{n + i})^{m_i}}\\\\ &amp;amp; {\\mathrm{end~for}} \\end{array}$</code></pre>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To check the truth of statement  <span class="math">\\varPhi</span> , Verify_Enc takes  <span class="math">\\pi</span>  and  <span class="math">\\mathcal{CT}</span>  as inputs for verification. Rerandomize does rerandomization of the given ciphertext and the proof. Note that the rerandomized proof is a valid proof of the statement. Dec decrypts the ciphertext  <span class="math">\\mathcal{CT}</span>  by performing decryption for each block  <span class="math">c_{1},\\ldots ,c_{n}</span> , to output  <span class="math">m_{1},\\ldots ,m_{n}</span>  and a decryption proof  <span class="math">\\nu</span> . The original message  <span class="math">M</span>  can be restored as  $M = (m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{n})<span class="math"> . The honest decryption of  </span>\\mathcal{CT}<span class="math">  can be proved by calling Verify_Dec with a message  </span>M<span class="math">  and a decryption proof  </span>\\nu$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The ciphertext  <span class="math">\\mathcal{CT}</span>  in SAVER satisfies additive-homomorphic property. Given  <span class="math">\\mathcal{CT} = (X_0^r, \\{X_i^r G_i^{m_i}\\}_{i=1}^n, P_1^r \\prod_{j=1}^n Y_j^{m_j})</span>  and  <span class="math">\\mathcal{CT}&#x27; = (X_0^{r&#x27;}, \\{X_i^{r&#x27;} G_i^{m_i&#x27;}\\}_{i=1}^n, P_1^{r&#x27;} \\prod_{j=1}^n Y_j^{m_j&#x27;})</span> , it is easy to see that  <span class="math">\\mathcal{CT} \\cdot \\mathcal{CT}&#x27; = (X_0^{r + r&#x27;}, \\{X_i^{r + r&#x27;} G_i^{m_i + m_i&#x27;}\\}_{i=1}^n, P_1^{r + r&#x27;} \\prod_{j=1}^n Y_j^{m_j + m_j&#x27;})</span> , which satisfies additive-homomorphism.</p>

    <p class="text-gray-300">The encrypt-with-prove construction in section 4.2 is also a commit-carrying encryption: it includes an encrypt-and-prove scheme which allows modular composition to other commit-carrying systems. In this section, we show that the commitment  <span class="math">\\psi</span>  in the ciphertext  <span class="math">\\mathcal{CT}</span>  is identical to the Pedersen vector commitment  <span class="math">c</span>  in LegoSNARK [CFQ19]'s commit-and-prove, which implies that the SAVER construction (algorithm 2) is a commit-carrying encryption as defined in section 3.7. Then we briefly show that  <span class="math">\\mathcal{CT}</span>  and  <span class="math">\\psi</span>  can be the inputs of CP-SNARK  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  described in 3.6.</p>

    <p class="text-gray-300">Commit-carrying encryption. When observing algorithm 2, it is obvious that SAVER is a commit-carrying encryption since the ciphertext  <span class="math">\\mathcal{CT}</span>  already includes a commitment  <span class="math">\\psi</span> . We show that  <span class="math">\\psi</span>  is identical to the Pedersen vector commitment of the commit-carrying SNARKs. Recall that the Pedersen vector commitment described in section 3.6 is constructed as  <span class="math">c = h^o \\cdot h_1^{u_1} \\cdots h_n^{u_n}</span>  for a random  <span class="math">o \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p^*</span> , messages  <span class="math">u_1, \\dots, u_n</span> , and random generators  <span class="math">h, h_1, \\dots, h_n</span> .</p>

    <p class="text-gray-300">The commitment <span class="math">\\psi</span> in SAVER is constructed as <span class="math">\\psi=P_{1}^{r}\\cdot\\prod_{j=1}^{n}Y_{j}^{m_{j}}</span>. Notice that <span class="math">P_{1}=G^{\\delta t_{0}}\\prod_{j=1}^{n}G^{\\delta t_{j}s_{j}}</span> can be viewed as a random generator <span class="math">h</span> with respect to the randoms <span class="math">t_{i}</span> and <span class="math">s_{i}</span>, and <span class="math">\\{Y_{i}=G_{i}^{t_{i}}\\}_{i=1}^{n}</span> can be also viewed as random generators <span class="math">h_{1},\\cdots,h_{n}</span> with respect to the random <span class="math">t_{i}</span>. Since the message <span class="math">m_{1},\\cdots,m_{n}</span> and random <span class="math">r</span> for the encryption correspond to the message <span class="math">u_{1},\\cdots,u_{n}</span> and random <span class="math">o</span> for the commitment, <span class="math">\\psi=P_{1}^{r}\\cdot\\prod_{j=1}^{n}Y_{j}^{m_{j}}</span> can be considered as Pedersen vector commitment <span class="math">c=h^{o}\\cdot\\prod_{j=1}^{n}h_{j}^{u_{j}}</span> by matching <span class="math">h=P_{1},o=r,h_{j}=Y_{j},u_{j}=m_{j}</span>.</p>

    <p class="text-gray-300">CP-SNARK composability. We briefly show how to connect algorithm 2 as a commit-carrying system for the CP-SNARK CP. Recall that the CP protocol let the prover prove the relation with the commitment key <span class="math">ck</span> as follows:</p>

    <p class="text-gray-300"><span class="math">crs:=(ek,vk)\\leftarrow\\texttt{KeyGen}(ck,R)</span> <span class="math">\\pi\\leftarrow\\texttt{Prove}(ek,x,(c_{j})_{j\\in[l]},(u_{j})_{j\\in[l]},(o_{j})_{j\\in[l]},\\omega)</span></p>

    <p class="text-gray-300">For the <span class="math">ck</span>, we may assume <span class="math">P_{1}</span> and <span class="math">\\{Y_{i}\\}_{i=1}^{n}</span> as the commitment key <span class="math">ck</span> since they are the ingredients for constructing the commitments <span class="math">\\{\\psi_{j}\\}_{j\\in[l]}</span>. Also, in Prove and VerProof, notice that we already showed the commitments <span class="math">\\{c_{j}\\}_{j\\in[l]}</span> and random <span class="math">o</span> are identical to the commitment <span class="math">\\{\\psi_{j}\\}_{j\\in[l]}</span> and random <span class="math">\\{r_{j}\\}_{j\\in[l]}</span> from SAVER systems (or other cc-SNARK systems). Therefore, it is straightforward to run the CP by matching the inputs as <span class="math">\\{c_{j}=\\psi_{j}\\},\\{o_{j}=r_{j}\\},\\{\\bm{u_{j}}=(m_{1},\\cdots,m_{n})\\}</span> for <span class="math">j\\in[l]</span>.</p>

    <p class="text-gray-300">Conceptual Benefits. In the viewpoint of commit-and-prove, encrypt-and-prove can provide more general extension of selective disclosure. In the encrypt-and-prove, the encrypted ciphertext can also work as a commitment since the commit-carrying encryption has an efficient function <span class="math">f_{c}(x)</span> that can output commitment <span class="math">c</span>. Therefore, when the prover outputs the commit-carrying ciphertext, it can disclose whole data to the secret key holder, while only disclosing proved statements to the other public the same as commit-and-prove. As a simple example, assume a blockchain contract management system where Alice and Bob encrypt a contract to each other. Alice wants to let Bob (who has a secret key) see the whole data, but she also wants to prove some restricted statements publicly. In this case, Alice can upload the ciphertext as a commitment of commit-and-prove; Bob can decrypt the ciphertext, and Alice can use the ciphertext as a commitment later for proving various statements.</p>

    <h2 id="sec-29" class="text-2xl font-bold">5 Security Proof: SAVER</h2>

    <p class="text-gray-300">To satisfy the definition of SAVER, the scheme should satisfy completeness, indistinguishability, encryption knowledge soundness, rerandomizability, and perfect zero-knowledge. The completeness is easy to verify in algorithm 2. For the perfect zero-knowledge, it is sufficient to show that the proof <span class="math">\\pi</span> in SAVER maintains the perfect zero-knowledge of zk-SNARK <em>[x10]</em>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">The proof <span class="math">\\pi</span> generated in SAVER is within the same distribution from the proof <span class="math">\\hat{\\pi}</span> of <span class="math">\\Pi_{\\mathsf{snark}}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">Proof. Since <span class="math">\\hat{\\pi}</span> is in a random distribution and <span class="math">P_2^r</span> is in a random distribution from <span class="math">r</span>, <span class="math">C \\cdot P_2^r</span> is also within a same random distribution.</p>

    <h2 id="sec-31" class="text-2xl font-bold">5.1 Indistinguishability</h2>

    <p class="text-gray-300">In this section, we prove the standard IND-CPA security of our SAVER.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Suppose the Decisional <span class="math">(d(\\lambda), q(\\lambda))</span>-Poly assumption holds in <span class="math">\\mathcal{BG}</span>. Then SAVER is IND-CPA secure.</p>

    <p class="text-gray-300">Proof. Suppose that <span class="math">\\mathcal{A}</span> has an advantage <span class="math">\\epsilon</span> in attacking the SAVER. Using <span class="math">\\mathcal{A}</span>, we build an algorithm <span class="math">\\mathcal{B}</span> that solves the D-Poly problem in <span class="math">\\mathcal{BG}</span>. We first describe the overall sketch of our proof as follows.</p>

    <p class="text-gray-300">The game starts with selecting the generator <span class="math">G, H</span> and the D-Poly secret vector <span class="math">\\boldsymbol{x} = \\{x, t_0, \\dots, t_n, s_1, \\dots, s_n, v_1, \\dots, v_n, \\rho\\}</span> from <span class="math">\\mathbb{Z}_p^*</span>. As a challenger in the D-Poly game, algorithm <span class="math">\\mathcal{B}</span> can query polynomials <span class="math">g_i(X_1, \\dots, X_q)</span> and <span class="math">h_j(X_1, \\dots, X_q)</span> to the oracles <span class="math">\\mathcal{O}_{G,\\boldsymbol{x}}^1</span> and <span class="math">\\mathcal{O}_{H,\\boldsymbol{x}}^2</span> to receive corresponding <span class="math">G^{g_i(\\boldsymbol{x})}</span> and <span class="math">H^{h_j(\\boldsymbol{x})}</span>, within a polynomial time.</p>

    <p class="text-gray-300">With the help of these oracles, <span class="math">\\mathcal{B}</span> simulates the decryption proof oracle <span class="math">\\mathcal{O}_{\\nu}</span> for <span class="math">\\mathcal{A}</span>'s encryption queries; <span class="math">\\mathcal{B}</span> receives query <span class="math">M_{i}</span> from <span class="math">\\mathcal{A}</span> within the polynomial time to return corresponding ciphertext, proof and its decryption proof as <span class="math">(\\mathcal{CT}_i,\\pi_i,\\nu_i)</span>.</p>

    <p class="text-gray-300">Then for the challenge, <span class="math">\\mathcal{B}</span> outputs <span class="math">g_{c}(X_{1},\\dots ,X_{q})</span> which satisfies <span class="math">g_{c}(x)\\notin [[Q_{1}]]\\times [[Q_{2}]]\\times [[Q_{2}]]^{-1}</span>, to receive <span class="math">T = T_{b}</span> from the D-Poly game where <span class="math">T_{b}</span> is randomly chosen from <span class="math">T_{1} = G^{g_{c}(\\boldsymbol{x})}</span> or <span class="math">T_0\\stackrel {\\delta}{\\leftarrow}\\mathbb{G}_1</span>. The goal of algorithm <span class="math">\\mathcal{B}</span> is to guess <span class="math">b</span>, outputting <span class="math">b^{\\prime} = 1</span> if the <span class="math">T</span> is generated from <span class="math">G^{g_c(\\pmb {x})}</span> and <span class="math">b^{\\prime} = 0</span> otherwise. Algorithm <span class="math">\\mathcal{B}</span> works by interacting with <span class="math">\\mathcal{A}</span> in an IND-CPA game as follows:</p>

    <p class="text-gray-300"><strong>Setup:</strong> To generate the CRS, <span class="math">\\mathcal{B}</span> runs a Setup(relation) in [Gro16] with selecting trapdoors <span class="math">\\tau = \\{\\alpha ,\\beta ,\\gamma ,\\delta \\}</span> and using D-Poly oracles for the <span class="math">CRS</span> generation. By querying <span class="math">g_{i}(X_{1},\\dots ,X_{q})</span> to the corresponding oracle <span class="math">\\mathcal{O}_{G,\\pmb{x}}^{1}</span> or <span class="math">\\mathcal{O}_{H,\\pmb{x}}^{2}</span>, <span class="math">\\mathcal{B}</span> can generate all CRS parameters <span class="math">(G^{\\alpha},G^{\\beta},G^{\\delta},\\dots)</span> without the knowledge of the secret vector <span class="math">\\pmb{x}</span>.</p>

    <p class="text-gray-300"><strong>KeyGen:</strong> Algorithm <span class="math">\\mathcal{B}</span> can run the original KeyGen(CRS) by utilizing the existing CRS generated from above. <span class="math">\\mathcal{B}</span> returns <span class="math">(PK, VK)</span> to initialize <span class="math">\\mathcal{A}</span>. Additionally, <span class="math">\\mathcal{B}</span> generates the tag key <span class="math">\\hat{\\nu} = G^{\\delta \\rho}</span> by querying <span class="math">\\delta \\rho</span> to <span class="math">\\mathcal{O}_{G,\\pmb{x}}^{1}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{O}_{\\nu}</span> phase 1: After the initialization, <span class="math">\\mathcal{A}</span> may query <span class="math">\\mathcal{B}</span> for the decryption proof of the message $M_{i} = (m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{n})<span class="math">, to obtain the corresponding ciphertext and decryption proof </span>\\mathcal{CT}_i,\\nu_i<span class="math">. For </span>\\mathcal{A}<span class="math">&#x27;s query </span>M_{i},\\mathcal{B}<span class="math"> generates a ciphertext </span>\\mathcal{CT}_i<span class="math"> by calling Enc(CRS, PK, </span>M_{i}<span class="math">) with picking fresh random </span>r_i<span class="math">, and creates encryption proofs </span>\\pi_{i}<span class="math"> by calling SimProve-snark(CRS, </span>\\tau ,m_1,\\ldots ,m_n,\\phi_{n + 1},\\ldots ,\\phi_l<span class="math">) with trapdoor </span>\\tau<span class="math"> and given statement </span>(m_{1},\\ldots ,m_{n},\\phi_{n + 1},\\ldots ,\\phi_{l})<span class="math"> where SimProve-snark generates a simulated proof available in every zk-SNARK scheme since the zk-SNARK scheme is zero knowledge. Then, </span>\\mathcal{B}<span class="math"> crafts the decryption proof </span>\\nu_{i} = \\hat{\\nu}^{r_{i}}<span class="math">, and returns </span>\\pi_i,\\mathcal{CT}_i,\\nu_i<span class="math"> as a response to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Challenge: When <span class="math">\\mathcal{A}</span> outputs <span class="math">M_0</span> and <span class="math">M_1</span> for the IND-CPA challenge, <span class="math">\\mathcal{B}</span> picks <span class="math">b \\in \\{0,1\\}</span> for <span class="math">M_b</span> then challenges the D-Poly game to receive <span class="math">T</span> and create the ciphertext <span class="math">\\mathcal{CT}</span> by implicitly setting <span class="math">r = x^{d + 1} \\cdot r&#x27;</span> (<span class="math">r&#x27; \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p^*</span>). To describe <span class="math">\\mathcal{B}</span>'s response on $M_b = (m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_n)<span class="math">, we first define two events on generating </span>\\mathcal{CT} = (c_0, \\ldots, \\psi)<span class="math">: REAL and FAKE. Among the blocks </span>c_1, \\ldots, c_n<span class="math"> which are supposed to contain the encrypted message (excluding </span>c_0<span class="math"> and </span>\\psi<span class="math"> which are not related to the message), two events are defined for each block </span>c_i$ as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>REAL: The block <span class="math">c_{i}</span> is crafted honestly with a <em>real</em> message as <span class="math">G^{\\delta s_{i} \\cdot r} G_{i}^{m_{i}}</span>, by querying <span class="math">g(\\pmb{x})</span> to <span class="math">\\mathcal{O}_{G,\\pmb{x}}^{1}</span>.</li>

      <li>FAKE: The block <span class="math">c_{i}</span> is crafted with a <em>random</em> message <span class="math">\\mu_{i} \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_{p}^{*}</span> as <span class="math">G^{\\delta s_{i} \\cdot r} G_{i}^{\\mu_{i}}</span>, by querying <span class="math">g(\\pmb{x})</span> to <span class="math">\\mathcal{O}_{G,\\pmb{x}}^{1}</span>.</li>

    </ol>

    <p class="text-gray-300">When creating <span class="math">c_{1}, \\ldots, c_{n}</span>, <span class="math">\\mathcal{B}</span> picks <span class="math">j \\in \\{1, \\ldots, n\\}</span> to use the challenge response <span class="math">T</span> in <span class="math">c_{j}</span>, and let <span class="math">c_{1}, \\ldots, c_{j-1}</span> generated from REAL while <span class="math">c_{j+1}, \\ldots, c_{n}</span> are generated from FAKE. <span class="math">\\mathcal{B}</span> gains advantage of winning the game only when <span class="math">\\mathcal{A}</span> guesses <span class="math">b</span> <em>exactly</em> from the challenge. If <span class="math">\\mathcal{A}</span> can already distinguish <span class="math">b</span> without the challenge <span class="math">c_{j}</span>, the game fails because <span class="math">\\mathcal{A}</span> will always distinguish <span class="math">b</span> regardless of the nature of <span class="math">T</span>. On the other hand, if <span class="math">\\mathcal{A}</span> requires <span class="math">c_{j&#x27;}</span> for <span class="math">j&#x27; &amp;gt; j</span> to distinguish <span class="math">b</span>, the game fails because <span class="math">\\mathcal{A}</span> always fails to distinguish <span class="math">b</span> regardless of the nature of <span class="math">T</span> since <span class="math">c_{j&#x27;}</span> is from FAKE. More specifically, from <span class="math">\\mathcal{A}</span>'s view, there exists <span class="math">j&#x27; \\in \\{1, \\ldots, n\\}</span> where <span class="math">\\mathcal{A}</span> cannot distinguish <span class="math">b</span> when <span class="math">c_{1}, \\ldots, c_{j&#x27;-1}</span> are from REAL, but can distinguish <span class="math">b</span> when <span class="math">c_{1}, \\ldots, c_{j&#x27;}</span> are from REAL. Therefore, by choosing <span class="math">j</span>, <span class="math">\\mathcal{B}</span> is <em>guessing <span class="math">j&#x27;</span></em>; if <span class="math">\\mathcal{B}</span>'s guess is correct, i.e., <span class="math">j = j&#x27;</span> with the probability of <span class="math">\\frac{1}{n}</span>, <span class="math">\\mathcal{B}</span> can win the D-Poly game since <span class="math">\\mathcal{A}</span> works differently depending on the nature of <span class="math">T</span>.</p>

    <p class="text-gray-300">To prepare the challenge, <span class="math">\\mathcal{B}</span> picks <span class="math">r&#x27; \\stackrel{\\S}{\\leftarrow} \\mathbb{Z}_p^*</span> and interacts with the D-Poly oracle <span class="math">\\mathcal{O}_{G,\\pmb{x}}^1</span> by implicitly setting <span class="math">r</span> as <span class="math">x^{d+1} \\cdot r&#x27;</span>. <span class="math">\\mathcal{B}</span> first queries <span class="math">\\delta \\cdot x^{d+1}</span> to receive <span class="math">\\hat{c}_0</span>. Next, <span class="math">\\mathcal{B}</span> prepares the random parts for all the blocks except <span class="math">j</span>-th block by querying <span class="math">\\{g_i(x) = \\delta s_i \\cdot x^{d+1}\\}_{i=1,\\neq j}^n</span> to receive <span class="math">\\{\\hat{c}_i\\}_{i=1,\\neq j}^n</span>. Then <span class="math">\\mathcal{B}</span> prepares the ingredient for <span class="math">\\psi</span>, by querying <span class="math">x^{d+1} \\cdot (\\delta t_0 \\sum_{i=1}^n \\delta t_i s_i)</span> to receive <span class="math">\\hat{\\psi}_1</span> and querying <span class="math">\\sum_{i=1}^j y_i(x) \\cdot t_i m_i + \\sum_{i=j+1}^n y_i(x) \\cdot t_i \\mu_i</span> to receive <span class="math">\\hat{\\psi}_2</span>. For the encryption proof <span class="math">\\pi</span>, <span class="math">\\mathcal{B}</span> use the trapdoor <span class="math">\\tau</span> to simulate the proof with <span class="math">SimProvespark(CRS, \\tau)</span> as <span class="math">\\pi = (A, B, C)</span>. Note that <span class="math">\\mathcal{B}</span> is required to simulate the proof since it does not know the random <span class="math">r</span>, which is a witness for the relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When <span class="math">\\{\\hat{c}_i\\}_{i=1,\\neq j}^n, \\hat{\\psi}_1, \\hat{\\psi}_2</span> and <span class="math">\\pi</span> are ready, <span class="math">\\mathcal{B}</span> outputs a challenge query for the <span class="math">j</span>-th block <span class="math">g(x) = \\delta s_j \\cdot x^{d+1}</span> to receive <span class="math">T</span>. Notice that the challenge query <span class="math">g(x)</span> satisfies <span class="math">g(x) \\notin [[Q_1]] \\times [[Q_2]] \\times [[Q_2]]^{-1}</span>, since <span class="math">s_j</span> is independent. Then <span class="math">\\mathcal{B}</span> generates the ciphertext <span class="math">\\mathcal{CT}</span> for $M_b = (m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_n)<span class="math"> by exploiting the received elements as </span>c_0 = \\hat{c}_0^{r'}<span class="math">, </span>\\{c_i = \\hat{c}_i^{r'} G_i^{m_i}\\}_{i=1}^{j-1}, c_j = T^{r'} G_j^{m_j}<span class="math"> (REAL), and </span>\\{c_i = \\hat{c}_i^{r'} G_i^{\\mu_i}\\}_{i=j+1}^n<span class="math"> (FAKE). Finally, </span>\\mathcal{B}<span class="math"> computes </span>\\psi<span class="math"> by computing as </span>\\psi = \\hat{\\psi}_1^{r'} \\cdot \\hat{\\psi}_2<span class="math">, and returns </span>\\mathcal{CT} = \\{c_i\\}_{i=1}^n, \\psi<span class="math"> and </span>\\pi<span class="math"> to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{O}_{\\nu}</span> phase 2: <span class="math">\\mathcal{B}</span> can respond to <span class="math">\\mathcal{A}</span>'s queries same as <span class="math">\\mathcal{O}_{\\nu}</span> phase 1.</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">Guess: Finally, <span class="math">\\mathcal{A}</span> outputs a guess <span class="math">b&#x27; \\in \\{0,1\\}</span>. Algorithm <span class="math">\\mathcal{B}</span> concludes its own game by outputting a guess as follows. If <span class="math">b = b&#x27;</span> then <span class="math">\\mathcal{B}</span> outputs 1 meaning <span class="math">T = G^{g_c(\\pmb{x})}</span>. Otherwise, it outputs 0 meaning <span class="math">T</span> is random in <span class="math">\\mathbb{G}_T</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When the input tuple is sampled from <span class="math">T_{1} = G^{g_{c}(\\pmb{x})}</span>, and <span class="math">\\mathcal{B}</span>'s guess with the probability of <span class="math">\\frac{1}{n}</span> is correct as <span class="math">j = j&#x27;</span>, then <span class="math">\\mathcal{A}</span>'s view is identical to its view in a real attack game and therefore <span class="math">\\mathcal{A}</span> satisfies $\\frac{1}{n} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[b = b'] - 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\epsilon<span class="math">. When the input tuple is sampled from </span>T_{0} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}_{1}<span class="math">, then </span>Pr[b = b'] = 1/2<span class="math">. Therefore, with </span>G, H<span class="math"> uniform in </span>\\mathcal{BG}<span class="math">, </span>\\pmb{x}<span class="math"> uniform in </span>\\mathbb{Z}_{p}^{*}<span class="math">, and </span>T<span class="math"> uniform in </span>\\mathbb{G}_{T}$ we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr \\left[ \\mathcal{B} \\left(\\mathcal{BG}, q_{i}(\\boldsymbol{x}), G^{g_{c}(\\boldsymbol{x})}\\right) = 0 \\right] \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">as required, which completes the proof of the theorem.</p>

    <h2 id="sec-32" class="text-2xl font-bold">5.2 Encryption Soundness</h2>

    <p class="text-gray-300">In this section, we prove the soundness of <span class="math">\\pi</span> and <span class="math">\\mathcal{CT}</span> in Verify_Enc, indicating that the <span class="math">M</span> which is encrypted to <span class="math">\\mathcal{CT}</span> is indeed included in the I/O of the conjoined pairing-based SNARK [Gro16]. Formally, we show that the probability of any adversary forging <span class="math">(\\pi^{<em>},\\mathcal{CT}^{</em>},\\bar{\\Phi}^{<em>})</span> where <span class="math">\\bar{\\Phi}^{</em>} = \\{\\phi_{n + 1},\\dots ,\\phi_{l}\\}</span> which passes the Verify_Enc but <span class="math">Dec(\\mathcal{CT}^{<em>})\\neq M</span> or <span class="math">(M,\\bar{\\Phi}^{</em>},w)\\notin \\mathcal{R}</span> is negligible.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Suppose the batch- <span class="math">PKE</span> assumption holds, and the soundness of conjoined pairing-based zk-SNARK [Gro16] holds. Then SAVER satisfies the encryption knowledge soundness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> To prove the theorem, we show that any adversary which breaks the soundness of the SAVER can break the batch-PKE assumption or SNARK-snd, i.e., soundness of the conjoined SNARK [Gro16]. Formally, for all PPT adversaries <span class="math">\\mathcal{A}</span> there exists a PPT algorithm <span class="math">\\mathcal{B},\\mathcal{C}</span> and a PPT extractor <span class="math">\\chi_{\\mathcal{B}}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{Adv}_{\\text{SAVER},\\mathcal{A}}^{sound}(\\lambda) = Pr[(CRS, \\tau) \\leftarrow \\operatorname{Setup}(\\mathcal{R}), (PK, SK, VK) \\leftarrow \\operatorname{KeyGen}(CRS), \\\\ (\\pi^{*}, \\mathcal{CT}^{*}, \\bar{\\Phi}^{*}) \\leftarrow \\mathcal{A}(CRS, PK, VK), (M, w) \\leftarrow \\chi_{\\mathcal{A}}(trans_{\\mathcal{A}}): \\\\ \\operatorname{Verify\\_Enc}(CRS, \\pi^{*}, \\mathcal{CT}^{*}, \\bar{\\Phi}^{*}) = 1 \\wedge (\\operatorname{Dec}(\\mathcal{CT}^{*}) \\neq M \\vee (M, \\bar{\\Phi}^{*}, w) \\notin \\mathcal{R}) \\\\ \\leq \\mathbf{Adv}_{\\mathcal{R},\\mathcal{B},\\chi_{\\mathcal{B}}}^{batch - PKE}(\\lambda) + \\mathbf{Adv}_{\\Pi_{\\text{blank}},\\mathcal{C},\\chi_{\\mathcal{C}}}^{sound}(\\lambda). \\end{array}</span></div>

    <p class="text-gray-300">First, since SAVER requires additional <span class="math">G^{-\\gamma}</span> in the CRS, it is necessary to assure that the soundness of the zk-SNARK [Gro16] still holds with the extended CRS. Fortunately, this issue is resolved instantly from the fact that the security proof in [Gro16] also considers <span class="math">\\gamma</span> term, according to the affine prover strategy. In the statistical knowledge soundness of [Gro16], the element <span class="math">A</span> is demonstrated as:</p>

    <div class="my-4 text-center"><span class="math-block">A = A_{\\alpha} \\alpha + A_{\\beta} \\beta + A_{\\gamma} \\gamma + a_{\\delta} \\delta A(x) + \\sum_{i=0}^{l} A_{i} \\frac{y_{i}(x)}{\\gamma} + \\sum_{i=l+1}^{m} A_{i} \\frac{y_{i}(x)}{\\delta} + A_{h}(x) \\frac{t(x)}{\\delta}</span></div>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">Observe that the <span class="math">A_{\\gamma}\\gamma</span> is included, indicating that the <span class="math">G^{\\gamma}</span> is within the consideration of ingredients. Since the <span class="math">A_{\\gamma}</span> term is eliminated in the proof, adding <span class="math">G^{-\\gamma}</span> in the CRS of [Gro16] does not affect the soundness of the SNARK. Similar to [Gro16], we now view the verification equations as an equality of multi-variate Laurent polynomials. By the Schwartz-Zippel lemma the prover has negligible success probability unless both verification equations hold.</p>

    <p class="text-gray-300">Since <span class="math">\\pi^{<em>},\\mathcal{CT}^{</em>},\\hat{\\Phi}^{*}</span> passes the verification, it passes the two equations in Verify.Enc as stated below:</p>

    <div class="my-4 text-center"><span class="math-block">e(c_1, H^{t_1}) \\times \\cdots \\times e(c_n, H^{t_n}) = e(\\psi, H) \\tag{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">e(A, B) = e(G^{\\alpha}, H^{\\beta}) \\times e\\left(\\prod_{i=0}^{n} c_i \\cdot \\prod_{i=n+1}^{l} G_i^{\\phi_i}, H^{\\gamma}\\right) \\times e(C, H^{\\delta}) \\tag{2}</span></div>

    <p class="text-gray-300">When we see the equation 1, there always exists <span class="math">t_i</span>, since they are fixed in the expression itself as <span class="math">H^{t_i}</span>. Therefore, <span class="math">\\psi</span> must consist of <span class="math">y_i(x)t_i</span> and <span class="math">\\delta t_0 + \\sum_{j=1}^{n} \\delta t_j s_j</span> since the only terms which include <span class="math">t_i</span> in the CRS and PK are <span class="math">G_1^{t_1}, \\dots, G_n^{t_n}</span> and <span class="math">G^{\\delta t_0 + \\sum_{j=1}^{n} \\delta t_j s_j}</span>. Let us express auxiliary indeterminate for each variable as <span class="math">X</span>, which is yet ambiguous. Then, the exponents linearly satisfy the equation below:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} X t_0 + X t_1 + \\cdots + X t_n &amp;amp;= \\\\ X y_1(x) \\cdot t_1 + \\cdots + X y_n(x) \\cdot t_n + X \\left(\\delta t_0 + \\sum_{j=1}^{n} \\delta t_j s_j\\right) \\tag{3} \\end{aligned}</span></div>

    <p class="text-gray-300">When observing equation 3 above, note that the terms with <span class="math">y_i(x) \\cdot t_i</span> and <span class="math">\\delta t_0 + \\sum_{j=1}^{n} \\delta t_j s_j</span> must both exist, since they are the only terms which can balance the <span class="math">t_1, \\dots, t_n</span> and <span class="math">t_0</span> on the left of equal sign. Then, to meet the terms with <span class="math">y_1(x), \\dots, y_n(x)</span>, there must also exist <span class="math">y_i(x)</span> in each term with <span class="math">t_1, \\dots, t_n</span> on the left of equal sign. For the unknown coefficients <span class="math">\\eta_i&#x27;</span>, this leads to:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} X t_0 + \\left(X + \\eta_1&#x27; y_1(x)\\right) \\cdot t_1 + \\cdots + \\left(X + \\eta_n&#x27; y_n(x)\\right) \\cdot t_n &amp;amp;= \\\\ X y_1(x) \\cdot t_1 + \\cdots + X y_n(x) \\cdot t_n + X \\left(\\delta t_0 + \\sum_{j=1}^{n} \\delta t_j s_j\\right) \\tag{4} \\end{aligned}</span></div>

    <p class="text-gray-300">Since only <span class="math">\\delta t_0 + \\sum_{j=1}^{n} \\delta t_j s_j</span> includes <span class="math">\\delta t_0</span>, the <span class="math">t_0</span> term on the left must only include <span class="math">\\delta</span> to generate <span class="math">\\delta t_0</span>. Finally, there remains <span class="math">\\delta t_j s_j</span> in <span class="math">\\sum_{j=1}^{n} \\delta t_j s_j</span>; <span class="math">X</span> in each <span class="math">t_j</span> term must be related to <span class="math">\\delta s_j</span> to generate <span class="math">\\delta t_j s_j</span>. For the unknown coefficients <span class="math">\\eta_0&#x27;</span> and <span class="math">\\eta_i&#x27;&#x27;</span>, this leads to:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\left(\\eta_0&#x27; \\delta\\right) t_0 + \\left(\\eta_1&#x27; \\delta s_1 + \\eta_1&#x27;&#x27; y_1(x)\\right) t_1 + \\cdots + \\left(\\eta_n&#x27; \\delta s_n + \\eta_n&#x27;&#x27; y_n(x)\\right) t_n &amp;amp;= \\\\ X y_1(x) \\cdot t_1 + \\cdots + X y_n(x) \\cdot t_n + X \\left(\\delta t_0 + \\sum_{j=1}^{n} \\delta t_j s_j\\right) \\tag{5} \\end{aligned}</span></div>

    <p class="text-gray-300">Now we can complete the equation with filling up each auxiliary <span class="math">X</span> on the right side with unknown coefficients <span class="math">\\eta_{0}^{\\prime},\\{\\eta_{i}^{\\prime},\\eta_{i}^{\\prime\\prime}\\}_{i=1}^{n}</span>. Especially, since the term with <span class="math">\\delta t_{0}+\\sum_{j=1}^{n}\\delta t_{j}s_{j}</span> is unique, the coefficients for <span class="math">\\delta t_{0}</span> and <span class="math">\\delta s_{i}t_{i}</span> (i.e. <span class="math">\\eta_{0}^{\\prime},\\cdots,\\eta_{n}^{\\prime}</span>) must be same as <span class="math">\\eta^{\\prime}</span>. Therefore, for the unknown coefficients <span class="math">\\eta^{\\prime}</span> and <span class="math">\\eta_{i}^{\\prime\\prime}</span>, the equation can be arranged as:</p>

    <p class="text-gray-300"><span class="math">(\\eta^{\\prime}\\delta)t_{0}+(\\eta^{\\prime}\\delta s_{1}+\\eta_{1}^{\\prime\\prime}y_{1}(x))t_{1}+\\cdots+(\\eta^{\\prime}\\delta s_{n}+\\eta_{n}^{\\prime\\prime}y_{n}(x))t_{n}=</span> (6) <span class="math">\\eta_{1}^{\\prime\\prime}y_{1}(x)\\cdot t_{1}+\\cdots+\\eta_{n}^{\\prime\\prime}y_{n}(x)\\cdot t_{n}+\\eta^{\\prime}(\\delta t_{0}+\\sum_{j=1}^{n}\\delta t_{j}s_{j})</span></p>

    <p class="text-gray-300">When representing the coefficients of <span class="math">t_{0},\\cdots,t_{n}</span> on the left as <span class="math">a_{0},\\cdots,a_{n}</span> (i.e. <span class="math">a_{0}t_{0}+a_{1}t_{1}+\\cdots+a_{n}t_{n}</span>), each <span class="math">a_{i}</span> can be viewed as a value from a multi-variate polynomial <span class="math">f_{i}(\\bm{x})</span> which consists of coefficients <span class="math">\\eta_{0}^{\\prime}</span> and <span class="math">\\eta_{i}^{\\prime\\prime}</span>. Let us represent <span class="math">C</span> from <span class="math">\\pi^{*}</span> as <span class="math">G^{b}</span>. Putting this into the verifying equation 1 gives us:</p>

    <p class="text-gray-300"><span class="math">e(G^{a_{1}},H^{t_{0}})\\times\\cdots\\times e(G^{a_{n}},H^{t_{n}})=e(G^{b},H)</span> (7)</p>

    <p class="text-gray-300">Observe that equation 6 above is equivalent to the check in batch-PKE where <span class="math">t_{i}</span> corresponds to <span class="math">\\alpha_{i}</span>: therefore there exists an extractor <span class="math">\\chi_{\\mathcal{B}}</span> which can extract all the coefficients <span class="math">\\eta_{0}^{\\prime}</span> and <span class="math">\\eta_{i}^{\\prime\\prime}</span> from <span class="math">a_{i}=f_{i}(\\bm{x})</span>. With the knowledge of <span class="math">\\eta_{0}^{\\prime},\\eta_{i}^{\\prime\\prime}</span> in equation 6, it is obvious that <span class="math">\\eta^{\\prime}</span> is equivalent to <span class="math">r</span> and <span class="math">\\eta_{i}^{\\prime\\prime}</span> is equivalent to <span class="math">m_{i}</span>, since the equation is in the same form as the original scheme with <span class="math">c_{0}=G^{\\delta r},c_{1}=G^{\\delta s_{1}r}\\cdot G^{y_{1}(x)m_{1}},\\cdots,c_{n}=G^{\\delta s_{n}r}\\cdot G^{y_{n}(x)\\cdot m_{n}}</span>. If <span class="math">Dec(\\mathcal{CT}^{<em>})\\neq M</span>, then there exists <span class="math">m_{i}^{</em>}=\\eta_{i}^{\\prime\\prime}\\neq m_{i}</span>; the extractor failed as <span class="math">\\eta_{i}^{\\prime\\prime}\\neq[A(\\tau)]</span> which breaks the batch-PKE.</p>

    <p class="text-gray-300"><span class="math">\\therefore Pr[Dec(\\mathcal{CT}^{*})\\neq M]=\\mathbf{Adv}_{\\mathcal{R},\\mathcal{B};\\chi_{\\mathcal{B}}}^{batch\\text{-}PKE}(\\lambda)</span> (8)</p>

    <p class="text-gray-300">The remaining case is where <span class="math">(M,\\hat{\\Phi}^{<em>},w)\\not\\in\\mathcal{R}</span>. In this case, we start with the fact that <span class="math">\\pi^{</em>},\\mathcal{CT}^{<em>},\\hat{\\Phi}^{</em>}</span> passes equation 2, revisited as follows.</p>

    <p class="text-gray-300"><span class="math">e(A,B)=e(G^{\\alpha},H^{\\beta})\\times e(\\prod_{i=0}^{n}c_{i}\\cdot\\prod_{i=n+1}^{l}G_{i}^{\\phi_{i}},H^{\\gamma})\\times e(C,H^{\\delta})</span> (2)</p>

    <p class="text-gray-300">Since equation 8 let <span class="math">\\mathcal{CT}^{<em>}</span> satisfy <span class="math">Dec(\\mathcal{CT}^{</em>})=M</span>, we can write <span class="math">\\mathcal{CT}</span> as a original form, i.e., <span class="math">c_{0}=G^{\\delta r},c_{i}=G^{\\delta s_{i}r}\\cdot G^{m_{i}}</span>. Putting this into equation 2 gives us:</p>

    <p class="text-gray-300"><span class="math">e(A,B)</span> <span class="math">=e(G^{\\alpha},H^{\\beta})</span> (9) <span class="math">\\times e(G^{\\delta r}\\cdot\\prod_{i=1}^{n}(G^{\\delta s_{i}r}\\cdot G^{y_{i}(x)\\cdot m_{i}})\\cdot\\prod_{i=n+1}^{l}G_{i}^{\\phi_{i}},H^{\\gamma})\\times e(C,H^{\\delta})</span></p>

    <p class="text-gray-300">Observe that <span class="math">e(G^{\\delta r}\\cdot\\prod_{i=1}^{n}(G^{\\delta s_{i}r}\\cdot G^{y_{i}(x)\\cdot m_{i}})\\cdot\\prod_{i=n+1}^{l}G_{i}^{\\phi_{i}},H^{\\gamma})</span> always generates <span class="math">\\gamma\\delta s_{i}</span> term. To neutralize <span class="math">\\gamma\\delta s_{i}</span>, the only possible way is either by also generating</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300"><span class="math">\\gamma \\delta s_{i}</span> in <span class="math">e(A,B)</span> on the left of equal sign, or by generating the same term in <span class="math">e(C,H^{\\delta})</span> on the right to eliminate <span class="math">\\gamma \\delta s_{i}</span>.</p>

    <p class="text-gray-300">Case 1 - generating <span class="math">\\gamma \\delta s_{i}</span> in <span class="math">e(A,B) = e(G^{a},H^{b})</span> on the left:</p>

    <p class="text-gray-300">When considering the term with <span class="math">\\alpha \\beta</span> which exists in <span class="math">e(G^{\\alpha},H^{\\beta})</span> on the right side, <span class="math">a</span> must include <span class="math">\\alpha</span> and <span class="math">b</span> must include <span class="math">\\beta</span>, since there are no <span class="math">H^{\\alpha}</span> in the <span class="math">\\mathbb{G}_2</span> of <span class="math">CRS,PK,VK</span>. From the fact that there are no <span class="math">\\delta s_i</span> in <span class="math">\\mathbb{G}_2</span>, the only way to generate the <span class="math">\\gamma \\delta s_i</span> term is to include <span class="math">\\delta s_i</span> in <span class="math">a</span> and include <span class="math">\\gamma</span> in <span class="math">b</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">a = X _ {\\alpha} \\alpha + X _ {\\delta s _ {i}} \\delta s _ {i} + \\dots , \\quad b = X _ {\\beta} \\beta + X _ {\\gamma} \\gamma + \\dots</span></div>

    <p class="text-gray-300">However, this let <span class="math">e(G^{a},H^{b})</span> create <span class="math">\\alpha \\gamma</span> and <span class="math">\\beta \\delta s_{i}</span>, which does not exist in equation 9. Therefore, <span class="math">\\gamma</span> cannot exist in <span class="math">a</span> nor <span class="math">b</span>, which indicates that Case 1 cannot exist.</p>

    <p class="text-gray-300">Case 2 - generating <span class="math">\\gamma \\delta s_{i}</span> in <span class="math">e(C,H^{\\delta}) = e(G^{c},H^{\\delta})</span> on the right:</p>

    <p class="text-gray-300">The remaining case is where <span class="math">c</span> includes <span class="math">\\gamma s_i</span> to generate <span class="math">\\gamma \\delta s_i</span> in <span class="math">e(G^c, H^\\delta)</span> and eliminate the <span class="math">\\gamma \\delta s_i</span> term. The only term which includes <span class="math">\\gamma s_i</span> is <span class="math">R = G^{-\\gamma \\cdot (1 + \\sum_{j=1}^{n} s_j)}</span>, and therefore <span class="math">c</span> must include <span class="math">-\\gamma (1 + \\sum_{j=1}^{n} s_j)</span>. We can write <span class="math">c</span> as <span class="math">c = \\eta \\cdot (-\\gamma (1 + \\sum_{j=1}^{n} s_j) + A_x)</span>, where <span class="math">\\eta</span> is an unknown coefficient, and <span class="math">A_x</span> is a remaining auxiliary polynomial. Putting this into equation 9 gives us:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e (A, B) = e \\left(G ^ {\\alpha}, H ^ {\\beta}\\right) \\\\ \\times e \\left(\\left(G ^ {\\delta r} \\cdot G ^ {\\sum_ {i = 1} ^ {n} \\delta s _ {i} r} \\cdot G ^ {\\sum_ {i = 1} ^ {n} y _ {i} (x) \\cdot m _ {i}}\\right) \\cdot \\prod_ {i = n + 1} ^ {l} G _ {i} ^ {\\phi_ {i}}, H ^ {\\gamma}\\right) \\tag {10} \\\\ \\times e \\left(G ^ {\\eta \\cdot \\left(- \\gamma \\left(1 + \\sum_ {j = 1} ^ {n} s _ {j}\\right)\\right)} \\cdot G ^ {A _ {x}}, H ^ {\\delta}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">To balance <span class="math">\\gamma \\delta s_{i}</span>, the <span class="math">\\sum_{i=1}^{n} \\delta s_{i} r</span> term must meet <span class="math">\\eta \\cdot (-\\gamma (1 + \\sum_{j=1}^{n} s_{j}))</span> to cancel out, and therefore <span class="math">\\eta = r</span>. This leads to:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e (A, B) = e \\left(G ^ {\\alpha}, H ^ {\\beta}\\right) \\tag {11} \\\\ \\times e \\left(G ^ {\\sum_ {i = 1} ^ {n} y _ {i} (x) \\cdot m _ {i}} \\cdot G ^ {\\sum i = n + 1 ^ {l} y _ {i} (x) \\cdot \\phi_ {i}}, H ^ {\\gamma}\\right) \\times e \\left(G ^ {A _ {x}}, H ^ {\\delta}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">When observing equation 11 above, <span class="math">G^{\\sum_{i=1}^{n} y_i(x) \\cdot m_i} \\cdot G^{\\sum i=n+1^l y_i(x) \\cdot \\phi_i}</span> can be combined into <span class="math">G^{\\sum i=1^n a_i y_i(x)}</span>, since <span class="math">m_1, \\dots, m_n</span> and <span class="math">\\phi_{n+1}, \\dots, \\phi_l</span> are <span class="math">\\Phi^<em> = \\{a_1, \\dots, a_l\\}</span>. This let equation 11 equivalent to the verification of the original pairing-based SNARK [Gro16] for the proof elements <span class="math">(A, B, C = G^{A_x})</span> and <span class="math">\\Phi^</em></span>. If <span class="math">(M, \\hat{\\Phi}^*, w) \\notin \\mathcal{R}</span>, then there exists <span class="math">m_i</span> or <span class="math">\\phi_i</span> which is not in the relation, but passes the verification of [Gro16]. This breaks the soundness of the SNARK, which concludes the proof as below:</p>

    <div class="my-4 text-center"><span class="math-block">\\therefore P r [ (M, \\hat {\\Phi} ^ {*}, w) \\notin \\mathcal {R} ] = \\mathbf {A d v} _ {\\Pi_ {\\text {s n a r k}}, \\mathcal {C}, \\chi_ {\\mathcal {C}}} ^ {\\text {s o u n d}} (\\lambda)</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">In this section, we show that a new rerandomized proof and ciphertext  <span class="math">\\pi&#x27;, \\mathcal{CT}&#x27;</span>  takes a same distribution as the original proof and ciphertext  <span class="math">\\pi, \\mathcal{CT}</span>  with a fresh random, which can assure the security of rerandomized proofs.</p>

    <p class="text-gray-300">Proof. The rerandomization of  <span class="math">\\mathcal{CT}</span>  to  <span class="math">\\mathcal{CT}&#x27;</span>  is as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C T} = (X _ {0} ^ {r}, X _ {1} ^ {r} G _ {1} ^ {m _ {1}}, \\dots , X _ {n} ^ {r} G _ {n} ^ {m _ {n}}, P _ {1} ^ {r} \\prod_ {j = 1} ^ {n} Y _ {j} ^ {m _ {j}})</span></div>

    <div class="my-4 text-center"><span class="math-block">r ^ {\\prime} \\stackrel {\\S} {\\leftarrow} \\mathbb {Z} _ {p} ^ {*}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C T} ^ {\\prime} = (X _ {0} ^ {r} \\cdot X _ {0} ^ {r ^ {\\prime}}, X _ {1} ^ {r} G _ {1} ^ {m _ {1}} \\cdot X _ {1} ^ {r ^ {\\prime}}, \\dots , X _ {n} ^ {r} G _ {n} ^ {m _ {n}} \\cdot X _ {n} ^ {r ^ {\\prime}}, P _ {1} ^ {r} \\prod_ {j = 1} ^ {n} Y _ {j} ^ {m _ {j}} \\cdot P _ {1} ^ {r ^ {\\prime}})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\therefore \\mathcal {C T} ^ {\\prime} = (X _ {0} ^ {r + r ^ {\\prime}}, X _ {1} ^ {r + r ^ {\\prime}} G _ {1} ^ {m _ {1}}, \\dots , X _ {n} ^ {r + r ^ {\\prime}} G _ {n} ^ {m _ {n}}, P _ {1} ^ {r + r ^ {\\prime}} \\prod_ {j = 1} ^ {n} Y _ {j} ^ {m _ {j}})</span></div>

    <p class="text-gray-300">It is easy to see that  <span class="math">\\mathcal{CT}&#x27;</span>  is a valid ciphertext with a fresh random  <span class="math">r + r&#x27;</span> .</p>

    <p class="text-gray-300">For the rerandomization of  <span class="math">\\pi = (A,B,C)</span>  to  <span class="math">\\pi^{\\prime} = (A^{\\prime},B^{\\prime},C^{\\prime})</span> , it is necessary to show that the original proof and the rerandomized proof are both within a uniform distribution. Let us decompose the proof elements  <span class="math">(A,B,C)</span>  to  <span class="math">(G^{a},H^{b},G^{c})</span>  as its original form (random  <span class="math">r</span>  from SAVER denoted as  <span class="math">r^*</span>  to avoid the duplication):</p>

    <div class="my-4 text-center"><span class="math-block">a = \\alpha + \\sum_ {i = 0} ^ {m} a _ {i} u _ {i} (x) + r \\delta \\quad b = \\beta + \\sum_ {i = 0} ^ {m} a _ {i} v _ {i} (x) + s \\delta</span></div>

    <div class="my-4 text-center"><span class="math-block">c = \\frac {\\sum_ {i = l + 1} ^ {m} a _ {i} y _ {i} + h (x) t (x)}{\\delta} + A s + B r - r s \\delta - \\gamma \\cdot (1 + \\sum_ {j = 1} ^ {n} s _ {j}) r ^ {*}</span></div>

    <p class="text-gray-300">Observe that the randomness of  <span class="math">a</span>  depends on  <span class="math">r</span> , and the randomness of  <span class="math">b</span>  depends on  <span class="math">s</span> . The randomness of  <span class="math">c</span>  is determined by  <span class="math">a</span>  and  <span class="math">b</span> ; if  <span class="math">a</span>  and  <span class="math">b</span>  is generated appropriately,  <span class="math">c</span>  is automatically determined within a uniform distribution. Therefore, it is sufficient to show that  <span class="math">a&#x27;</span>  and  <span class="math">b&#x27;</span>  from the rerandomized proof are appropriate randoms. When representing  <span class="math">(A, B, C)</span>  as  <span class="math">(G^a, H^b, G^c)</span> , the  <span class="math">a&#x27;, b&#x27;, c&#x27;</span>  in the rerandomized proof  <span class="math">(G^{a&#x27;}, H^{b&#x27;}, G^{c&#x27;})</span>  are:</p>

    <div class="my-4 text-center"><span class="math-block">a ^ {\\prime} = a \\cdot z _ {1} \\qquad b ^ {\\prime} = b \\cdot z _ {1} ^ {- 1} + \\delta \\cdot z _ {2} \\qquad c ^ {\\prime} = c + a \\cdot z _ {1} z _ {2} - \\gamma \\cdot (1 + \\sum_ {j = 1} ^ {n} s _ {j}) r ^ {* \\prime}</span></div>

    <p class="text-gray-300">It is straightforward that  <span class="math">a&#x27;</span>  and  <span class="math">b&#x27;</span>  are within a uniform distribution, where  <span class="math">a&#x27;</span>  depends on a fresh random  <span class="math">z_1</span> , and  <span class="math">b&#x27;</span>  depends on a fresh random  <span class="math">z_2</span> . Since  <span class="math">a&#x27;</span>  and  <span class="math">b&#x27;</span>  are appropriate randoms, we can conclude that  <span class="math">c&#x27;</span>  is also determined within a uniform distribution.</p>

    <p class="text-gray-300">5.4 Decryption Soundness</p>

    <p class="text-gray-300">In this section, we prove the soundness of the decryption proof <span class="math">\\nu</span> in Verify_Dec, indicating that there cannot exist any <span class="math">\\nu^{*}</span> which is connected to the wrong ciphertext but still passes the Verify_Dec.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 5.4</h6>

    <p class="text-gray-300">In our SAVER scheme, there cannot exist any <span class="math">(M^{<em>},\\nu^{</em>},\\mathcal{CT}^{<em>})</span> where <span class="math">\\nu^{</em>}</span> verifies, but <span class="math">\\mathsf{Dec}(\\mathcal{CT}^{<em>})\\neq M^{</em>}</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Let us violate the theorem and assume that there exists <span class="math">(M^{<em>},\\nu^{</em>},\\mathcal{CT}^{<em>})</span> where <span class="math">\\nu^{</em>}</span> verifies, but <span class="math">\\mathsf{Dec}(\\mathcal{CT}^{<em>})\\neq M^{</em>}</span>. More specifically, for <span class="math">\\mathcal{CT}^{<em>}=(c_{0}^{</em>},\\cdots,\\psi^{<em>})</span> and <span class="math">M^{</em>}=(m_{1}^{<em>},\\cdots,m_{n}^{</em>})</span> there exists a block <span class="math">c_{j}^{<em>}</span> which is </em>not<em> decrypted to <span class="math">m_{j}^{</em>}</span> for any <span class="math">j\\in\\{1,\\cdots,n\\}</span> while <span class="math">\\nu^{*}</span> passes the verifications in Verify_Dec.</p>

    <p class="text-gray-300">Since the decryption proof <span class="math">\\nu^{*}</span> verifies, the 2nd equation of Verify_Dec holds as follows:</p>

    <p class="text-gray-300"><span class="math">\\frac{e(c_{j}^{<em>},V_{n+j})}{e(\\nu^{</em>},V_{j})}=e(G_{j},V_{n+j})^{m_{j}^{*}}</span> (12)</p>

    <p class="text-gray-300">However, since <span class="math">\\mathsf{Dec}(\\mathcal{CT}^{<em>})\\neq M^{</em>}</span>,</p>

    <p class="text-gray-300"><span class="math">\\frac{e(c_{j}^{<em>},V_{n+j})}{e(c_{0}^{</em>},V_{j})^{\\rho}}\\neq e(G_{j},V_{n+j})^{m_{j}^{*}}</span> (13)</p>

    <p class="text-gray-300">When comparing equations 12 and 13, the only difference between two equations are <span class="math">e(\\nu^{<em>},V_{j})</span> and <span class="math">e(c_{0}^{</em>},V_{j})^{\\rho}</span>: therefore <span class="math">\\nu^{<em>}\\neq(c_{0}^{</em>})^{\\rho}</span>.</p>

    <p class="text-gray-300">However, this contradicts the first equation of Verify_Dec:</p>

    <p class="text-gray-300"><span class="math">e(\\nu^{<em>},H)</span> <span class="math">=e(c_{0}^{</em>},V_{0})</span> (14) <span class="math">\\therefore\\nu^{<em>}</span> <span class="math">=(c_{0}^{</em>})^{\\rho}</span></p>

    <p class="text-gray-300">Therefore, we conclude that there cannot exist any <span class="math">(m^{<em>},\\nu^{</em>},\\mathcal{CT}^{<em>})</span> where <span class="math">\\nu^{</em>}</span> verifies and <span class="math">\\mathsf{Dec}(\\mathcal{CT}^{<em>})\\neq M^{</em>}</span>. ∎</p>

    <h2 id="sec-36" class="text-2xl font-bold">6 Vote-SAVER</h2>

    <p class="text-gray-300">We present a formal protocol for the voting system application in section 1.1, named as Vote-SAVER. As described in the scenario, the Vote-SAVER consists of series of interactions between multiple administrators and multiple voters, with utilizing SAVER in section 4 as a building block. For the additional building blocks, we use the publicly-available <span class="math">BlockChain</span>, a collision-resistant hash function <span class="math">H</span>, membership test functions <span class="math">MerkleTree</span>, <span class="math">GetMerklePath</span>, <span class="math">GetMerkleRoot</span> from Zerocash <em>[BCG^{+}14]</em>. Note that <span class="math">sn,rt,\\boldsymbol{path}</span> are also from the membership test, where <span class="math">sn</span> is a serial number, <span class="math">rt</span> is a Merkle root, and <span class="math">\\boldsymbol{path}</span> is a vector of co-paths for constructing the Merkle tree. We use <span class="math">ID</span> for each user’s identity, and <span class="math">eid</span> to distinguish each individual election.</p>

    <p class="text-gray-300">Algorithm 3 represents a series of functions for the voter’s side, algorithm 4 represents a function (possibly smart-contract) for the <span class="math">BlockChain</span> nodes, and</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">|  Algorithm 3 Voting system voter  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  GenKey(1κ, ID):  |</p>

    <p class="text-gray-300">|  sk←{0,1}κ  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">skID←ID</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sk</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  pkID=H(skID)  |</p>

    <p class="text-gray-300">|  return skID to voter  |</p>

    <p class="text-gray-300">|  publish pkID  |</p>

    <p class="text-gray-300">|  Vote(CRS, PKeid, eid, rt, pklist, M, pkID, skID):  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">parse M=(m1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mn)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  path←GetMerklePath(pkID, pklist)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sn←H(eid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">skID)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  π,CT←ΠSAVER.Enc(CRS, PKeid, m1,···, mn, eid, sn, rt; path, skID)  |</p>

    <p class="text-gray-300">|  send ballot={eid, sn, π, CT} to BlockChain network  |</p>

    <p class="text-gray-300">|  VerifyVote(CRS, π′ID, CT′ID, eid, rt):  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sn←H(eid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">skID)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  assert SAVER.Verify_Enc(CRS, π′ID, CT′ID, eid, sn, rt) = true  |</p>

    <p class="text-gray-300">|  VerifyTally(CRS, PKeid, VKed, {CT′IDi}i=1N, Msum, ν):  |</p>

    <p class="text-gray-300">|  CT′sum=CT′IDi∘···∘CT′IDN  |</p>

    <p class="text-gray-300">|  assert SAVER.Verify_Dec(CRS, PKeid, VKed, Msum, ν, CT′sum) = true  |</p>

    <p class="text-gray-300">|  Algorithm 4 Voting system nodes  |</p>

    <p class="text-gray-300">|  PostVote(CRS, PKeid, rt, ballot):  |</p>

    <p class="text-gray-300">|  parse ballot={eid, sn, π, CT}  |</p>

    <p class="text-gray-300">|  assert sn∉BlockChain  |</p>

    <p class="text-gray-300">|  assert SAVER.Verify_Enc(CRS, π, CT, eid, sn, rt) = true  |</p>

    <p class="text-gray-300">|  π′,CT′←SAVER.Rerandomize(PKeid, π, CT)  |</p>

    <p class="text-gray-300">|  upload (eid, sn, π′, CT′) on BlockChain  |</p>

    <p class="text-gray-300">algorithm 5 represents functions for the administrator. For the scenario, the election proceeds as follows.</p>

    <p class="text-gray-300">Phase 0: init system. Before running the system, the  <span class="math">CRS</span>  should be generated from InitSystem. To be more accurate, this should be done by a trusted third party or by a general consensus, rather than an individual administrator. Then, every voter who participates in the system runs GenKey to generate his own  <span class="math">sk_{ID}</span>  and publish his  <span class="math">pk_{ID}</span> .</p>

    <p class="text-gray-300">Phase 1: open election. If an administrator wants to open an election, she first selects a list of participants for the election by collecting  <span class="math">pk_{ID}</span>  of each voter. Then she opens an election distinguished as  <span class="math">eid</span> , by calling Election.</p>

    <p class="text-gray-300">Phase 2: cast vote. After the election  <span class="math">eid</span>  is initiated, a voter can run Vote to cast a vote, by sending the transaction ballot to the BlockChain network. The BlockChain node runs PostVote to verify the proof, rerandomize the ballot, and</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">|  Algorithm 5 Voting system administrator  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  relation(m1,...,mn,eid,sn,rt; path,skID):  |</p>

    <p class="text-gray-300">|  pkID←H(skID)  |</p>

    <p class="text-gray-300">|  rt←MerkleTree(path,pkID)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sn←H(eid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">skID)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  assert mi∈{0,1} for i=1 to n  |</p>

    <p class="text-gray-300">|  assert ∑i=1nmi=1  |</p>

    <p class="text-gray-300">|  InitSystem(relation):  |</p>

    <p class="text-gray-300">|  CRS←SAVER.Setup(relation)  |</p>

    <p class="text-gray-300">|  upload CRS on BlockChain  |</p>

    <p class="text-gray-300">|  Election(CRS,1n,{pkIDi}N)  |</p>

    <p class="text-gray-300">|  pklist←{pkIDi}N for total N voters  |</p>

    <p class="text-gray-300">|  rt←GetMerkleRoot(pklist)  |</p>

    <p class="text-gray-300">|  eid←{0,1}n  |</p>

    <p class="text-gray-300">|  SKeid,PKeid,VKeid←SAVER.KeyGen(CRS)  |</p>

    <p class="text-gray-300">|  return SKeid to admin  |</p>

    <p class="text-gray-300">|  upload pklist,PKeid,VKeid,eid,rt on BlockChain  |</p>

    <p class="text-gray-300">|  Tally(CRS,SKeid,VKeid,{CTi}N):  |</p>

    <p class="text-gray-300">|  CT'sum=CT'⊗···⊗CT'  |</p>

    <p class="text-gray-300">|  Msum,ν←SAVER.Dec(CRS,SKeid,VKeid,CT'sum)  |</p>

    <p class="text-gray-300">|  publish (Msum,ν)  |</p>

    <p class="text-gray-300">post the rerandomized ballot on the BlockChain (the posting can be realized as mining of the block). Then, the voter runs VerifyVote with taking the posted ballot of  <span class="math">sn</span>  as an input, to ensure the individual verifiability.</p>

    <p class="text-gray-300">Phase 3: tally results. When the election is over, the administrator runs Tally with collecting posted ballots as inputs, to publish the result of the election  <span class="math">eid</span> . Then all the observers can run VerifyTally to ensure the universal verifiability of the result.</p>

    <p class="text-gray-300">In the proposed Vote-SAVER, the administrator can decrypt the ballots and audit the ongoing election results. In certain circumstances, it may even be necessary to prevent such midterm audits. This problem occurs because there is a single administrator who fully holds the decryption key  <span class="math">\\rho</span> . It can be prohibited by introducing multi-administrators. Unless all administrators collude, auditing the ongoing result is not possible. For the ciphertext for which all administrators provide the decryption information or  <span class="math">\\nu</span>  in algorithm 2, the decryption is applicable.</p>

    <p class="text-gray-300">Assume that there are  <span class="math">c</span>  administrators. Each administrator  <span class="math">AD_{i}</span>  chooses  <span class="math">\\rho_{i}</span>  randomly at KeyGen. And then each  <span class="math">AD_{i}</span>  publishes  <span class="math">VK_{i}</span>  which is based on  <span class="math">\\rho_{i}</span>  instead of  <span class="math">\\rho</span> . Then  <span class="math">VK</span>  becomes  <span class="math">\\prod_{i=1}^{c} VK_{i}</span> . At Dec, each  <span class="math">AD_{i}</span>  publishes</p>

    <p class="text-gray-300"><span class="math">\\nu_{i}=(\\prod_{j=p}^{q}c_{i,0})^{\\rho_{i}}</span>. By combining <span class="math">\\nu_{i}</span>, everyone computes <span class="math">\\nu=\\prod_{i=1}^{c}\\nu_{i}</span>. Using <span class="math">\\nu</span>, the plaintext is decrypted from the summed ciphertext.</p>

    <h2 id="sec-38" class="text-2xl font-bold">7 Security Proof: Vote-SAVER</h2>

    <p class="text-gray-300">In this section, we represent formal security properties of the Vote-SAVER, and provide formal proof for each property based on the security of SAVER scheme.</p>

    <p class="text-gray-300">Board integrity: the board integrity indicates non-malleability, which defines that the result on the public board is tamper-proof.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">It is easily satisfied by the nature of blockchain, which is utilized as a public bulletin board of the whole system. ∎</p>

    <p class="text-gray-300">Receipt-freeness: the receipt-freeness is a security notion for the ballot where even the voter cannot reproduce or distinguish his own vote, which is a stronger notion that implies the ballot privacy. Formally, the ballot privacy can be defined by Game_{BP} between adversary <span class="math">\\mathcal{A}</span> and challenger <span class="math">\\mathcal{C}</span>, and the receipt-freeness is defined by Game_{RF} which is extended from Game_{BP}. In both games, <span class="math">\\mathcal{C}</span> is running as a role of administrator, while <span class="math">\\mathcal{A}</span> is an observer who controls the entire voters for <span class="math">\\mathcal{C}</span>’s election. <span class="math">\\mathcal{A}</span>’s objective is to distinguish which of the two voting sets it submitted was encrypted.</p>

    <p class="text-gray-300">Figure 2 shows the formal security game for both ballot privacy and receipt-freeness. The main purpose of the game is to let the adversary <span class="math">\\mathcal{A}</span> construct two different voting sets with a full control on the entire voters: the ballot privacy should guarantee that <span class="math">\\mathcal{A}</span> cannot distinguish between two sets after they are encrypted as ballots. This should be intact even with <span class="math">\\mathcal{A}</span> looking at the tally result, so the restriction is that the sum of two sets must be same to prevent the tallied sum of message revealing the difference.</p>

    <p class="text-gray-300">The difference between ballot-privacy and receipt-freeness depends on who generates the encrypted ballots: in Game_{BP}, <span class="math">\\mathcal{C}</span> generates the ballots on behalf of <span class="math">\\mathcal{A}</span> (<span class="math">\\mathcal{A}</span> provides the voting key <span class="math">sk_{ID_{i}}</span>), while in Game_{RF} <span class="math">\\mathcal{A}</span> generates the ballots for itself (<span class="math">\\mathcal{A}</span> does not need to provide <span class="math">sk_{ID_{i}}</span>). Therefore, in Game_{RF}, <span class="math">\\mathcal{A}</span> even knows its own ballots; even with the ability to reproduce its own ballots, <span class="math">\\mathcal{A}</span> should not be capable of distinguishing the encrypted set of ballots. It is easy to see that Game_{RF} implies Game_{BP}, which indicates the receipt-freeness implies the ballot privacy. The formal definitions of ballot privacy and receipt-freeness are stated as follows:</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 11</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\text{{Adv}}^{Game_{BP}}_{\\text{V-SAVER},\\mathcal{A}}(\\lambda)</span> be the advantage of <span class="math">\\mathcal{A}</span> winning the Game_{BP}. For a negligible function <span class="math">\\epsilon</span>, the voting system satisfies ballot privacy if for any PPT adversary <span class="math">\\mathcal{A}</span> we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{{Adv}}^{Game_{BP}}_{\\text{V-SAVER},\\mathcal{A}}(\\lambda)-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 12</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\text{{Adv}}^{Game_{RF}}_{\\text{V-SAVER},\\mathcal{A}}(\\lambda)</span> be the advantage of <span class="math">\\mathcal{A}</span> winning the Game_{RF}. For a negligible function <span class="math">\\epsilon</span>, the voting system satisfies receipt-freeness if for any PPT adversary <span class="math">\\mathcal{A}</span> we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{{Adv}}^{Game_{RF}}_{\\text{V-SAVER},\\mathcal{A}}(\\lambda)-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: Security games for ballot privacy (GameBP) and receipt-freeness (GameRF)</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">Theorem 4. If  <span class="math">\\mathbf{Game}_{\\mathbf{SAVER}}^{multi - ind}</span>  is IND-CPA-secure, then the Vote-SAVER scheme satisfies receipt-freeness.</p>

    <p class="text-gray-300">Proof. For the sketch of the proof, we first extend the SAVER indistinguishability game  <span class="math">\\mathbf{Game}_{\\mathbf{SAVER}}^{single - ind}</span>  to the multi-encryption game  <span class="math">\\mathbf{Game}_{\\mathbf{SAVER}}^{multi - ind}</span> , where the encryption is batch-processed for a vector of multiple messages. Then we show that both  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span>  and  <span class="math">\\mathbf{Game}_{\\mathbf{RF}}</span>  can be reduced to  <span class="math">\\mathbf{Game}_{\\mathbf{SAVER}}^{multi - ind}</span> , where  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span>  and  <span class="math">\\mathbf{Game}_{\\mathbf{RF}}</span>  is computationally indistinguishable due to the rerandomizability of SAVER. Formally, we prove:  <span class="math">\\mathbf{Adv}_{\\mathbf{SAVER\\_A}}^{single - ind}(\\lambda) \\approx \\mathbf{Adv}_{\\mathbf{SAVER\\_A}}^{multi - ind}(\\lambda) = \\mathbf{Adv}_{\\mathbf{V - SAVER\\_A}}^{Game_{BF}}(\\lambda) \\approx \\mathbf{Adv}_{\\mathbf{V - SAVER\\_A}}^{v}(\\lambda)</span> .</p>

    <p class="text-gray-300"><span class="math">\\S</span>  GameSAVER  <span class="math">\\approx</span>  GameSAVER</p>

    <p class="text-gray-300">Game  <span class="math">\\mathbf{SAVER}</span>  is the original IND-CPA game of SAVER, where the challenger  <span class="math">\\mathcal{C}</span>  accepts two single messages. On the other hand, Game  <span class="math">\\mathbf{SAVER}</span>  is an extended game where the challenger  <span class="math">\\mathcal{C}</span>  accepts two multiple messages, i.e., two  <span class="math">N</span> -length vectors.</p>

    <p class="text-gray-300">Lemma 2. If  <span class="math">\\mathbf{Game}_{\\mathbf{SAVER}}^{single - ind}</span>  is  <span class="math">(\\epsilon)</span> -IND-CPA-secure, then  <span class="math">\\mathbf{Game}_{\\mathbf{SAVER}}^{multi - ind}</span>  is  <span class="math">(N\\epsilon)</span> -IND-CPA-secure for vector length  <span class="math">N</span> .</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">It is well-known that CPA message indistinguishability implies indistinguishability for multiple messages, via hybrid arguments that swaps the message in vector one by one.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\text{SAVER\\_A}}^{multi - ind}(\\lambda) = \\mathbf{Adv}_{\\text{V-SAVER\\_A}}^{Game_{BP}}(\\lambda)</span></p>

    <p class="text-gray-300">As a main step, we show that the SAVER indistinguishability implies the ballot privacy, by reducing  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span>  to the  <span class="math">\\mathbf{Game}_{\\text{SAVER}}^{multi - ind}</span> .</p>

    <p class="text-gray-300">Lemma 3. If  <span class="math">\\mathbf{Game}_{\\text{SAVER}}^{multi - ind}</span>  is IND-CPA-secure, then the Vote-SAVER scheme satisfies ballot privacy.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{Adv}_{\\mathsf{V - SAVER\\_A}}^{Game_{BP}}(\\lambda)</span>  be the advantage of  <span class="math">\\mathcal{A}</span>  winning the  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span> . Using  <span class="math">\\mathcal{A}</span> , we build an algorithm  <span class="math">\\mathcal{B}</span>  which attempts to win  <span class="math">\\mathbf{Game}_{\\mathsf{SAVER}}^{multi - ind}</span> . As an overall sketch,  <span class="math">\\mathcal{B}</span>  will simulate an election to  <span class="math">\\mathcal{A}</span> , by using the encryption of  <span class="math">\\mathbf{Game}_{\\mathsf{SAVER}}^{multi - ind}</span> . As defined in  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span> ,  <span class="math">\\mathcal{A}</span>  will challenge  <span class="math">\\mathcal{B}</span>  by submitting two sets of plain votes  <span class="math">V_0 = \\{M_1,\\dots ,M_N\\}</span>  and  <span class="math">V_{1} = \\{M_{1}^{\\prime},\\dots ,M_{N}^{\\prime}\\}</span>  for  <span class="math">N</span>  total voters.  <span class="math">\\mathcal{B}</span>  will use the sets  <span class="math">V_{0}</span>  and  <span class="math">V_{1}</span>  as a challenge to  <span class="math">\\mathbf{Game}_{\\mathsf{SAVER}}^{multi - ind}</span> , to receive challenge ciphertexts  <span class="math">CT^{\\star}</span> . Then  <span class="math">\\mathcal{B}</span>  will construct the challenge set of ballots  <span class="math">\\{eid,sn_i,\\pi_i,\\mathcal{CT}_i^*\\}_{i = 1}^N</span>  and return it to  <span class="math">\\mathcal{A}</span> , to let  <span class="math">\\mathcal{A}</span>  guess  <span class="math">b</span>  depending on the  <span class="math">CT</span> .  <span class="math">\\mathcal{B}</span>  also has to provide tally result  <span class="math">M_{sum},\\nu</span>  to  <span class="math">\\mathcal{A}</span>  after the challenge, which can be helped from the decryption proof oracle  <span class="math">\\mathcal{O}_{\\nu}</span>  in  <span class="math">\\mathbf{Game}_{\\mathsf{SAVER}}^{multi - ind}</span> . Formally, the game proceeds as following steps (see figure 2):</p>

    <p class="text-gray-300">Init system:  <span class="math">\\mathcal{B}</span>  first begins with  <span class="math">\\mathbf{Game}_{\\text{SAVER}}^{multi - ind}</span> , and receives  <span class="math">CRS, \\tau</span>  and  <span class="math">PK, VK</span>  for the SAVER encryption system. Then,  <span class="math">\\mathcal{B}</span>  initializes the Vote-SAVER system by outputting  <span class="math">CRS</span>  to  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{A}</span>  constructs  <span class="math">N</span>  voters by running  <span class="math">\\mathsf{GenKey}(1^{\\kappa}, ID_{i})</span>  and outputs  <span class="math">\\{pk_{ID_i}, sk_{ID_i}\\}_{i=1}^N</span>  to  <span class="math">\\mathcal{B}</span> .</p>

    <p class="text-gray-300">Open election: based on the voter set  <span class="math">\\{pk_{ID_i},sk_{ID_i}\\}_{i = 1}^N</span> <span class="math">\\mathcal{B}</span>  constructs  <span class="math">\\pmb{pklist}</span>  and its merkle tree root  <span class="math">rt</span> . Then,  <span class="math">\\mathcal{B}</span>  chooses a random  <span class="math">eid\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\kappa}</span>  and opens an election by outputting  <span class="math">\\pmb{pklist} = \\{pk_{ID_i}\\}_{i = 1}^N,rt,PK_{eid} = PK,VK_{eid} = VK,eid.</span></p>

    <p class="text-gray-300">Challenge: for the challenge of  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span> ,  <span class="math">\\mathcal{A}</span>  submits two plain vote sets  <span class="math">V_{0} = \\{M_{1}, \\dots, M_{N}\\}</span>  and  <span class="math">V_{1} = \\{M_{1}&#x27;, \\dots, M_{N}&#x27;\\}</span> . When receiving two sets,  <span class="math">\\mathcal{B}</span>  first checks if  <span class="math">\\sum V_{0} = \\sum V_{1}</span> . If the sum is equal,  <span class="math">\\mathcal{B}</span>  submits the same  <span class="math">\\{M_{1}, \\dots, M_{N}\\}</span>  and  <span class="math">\\{M_{1}&#x27;, \\dots, M_{N}&#x27;\\}</span>  as a challenge to  <span class="math">\\mathbf{Game}_{\\text{SAVER}}^{multi-ind}</span> , and receives the challenge ciphertext  <span class="math">CT^{\\star} = \\{\\pi_{i}^{\\star}, \\mathcal{CT}_{i}^{\\star}\\}_{i=1}^{N}</span> .</p>

    <p class="text-gray-300">At this point, if  <span class="math">\\mathcal{B}</span>  gives this  <span class="math">CT^{\\star}</span>  to  <span class="math">\\mathcal{A}</span>  as it is,  <span class="math">\\mathcal{B}</span>  cannot simulate the upcoming tally since it does not know the decryption proof  <span class="math">\\nu</span>  for the  <span class="math">CT^{\\star}</span> . Therefore, before responding  <span class="math">\\mathcal{A}</span> 's challenge,  <span class="math">\\mathcal{B}</span>  queries  <span class="math">\\sum_{i=1}^{N} M_i</span>  to  <span class="math">\\mathcal{O}_{\\nu}</span>  in  <span class="math">\\mathbf{Game}_{\\text{SAVER}}^{multi-ind}</span> , and receives the corresponding ciphertext and decryption proof of the sum  <span class="math">\\overline{\\pi}, \\overline{\\mathcal{CT}}, \\overline{\\nu}</span> . But still,  <span class="math">\\overline{\\nu}</span>  is a decryption proof with respect to the random  <span class="math">\\overline{r}</span>  used in  <span class="math">\\overline{\\mathcal{CT}}</span> , which is independent of  <span class="math">CT^{\\star}</span> , so it cannot pass Verify_Dec  <span class="math">(CT^{\\star}, \\overline{\\nu})</span>  in the VerifyTally.</p>

    <p class="text-gray-300">To give a tweak on this problem,  <span class="math">\\mathcal{B}</span>  will use the additively-homomorphic property of the  <span class="math">\\mathcal{CT}</span>  to craft the random. Let us represent the auxiliary random  <span class="math">r</span>  used in the ciphertext  <span class="math">\\mathcal{CT}</span>  as  <span class="math">\\mathcal{CT}_{[r]}</span> . Then, when multiplying two ciphertexts</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300"><span class="math">\\mathcal{CT}_a = \\mathsf{Enc}(a)</span>  and  <span class="math">\\mathcal{CT}_b = \\mathsf{Enc}(b)</span> , due to the homomorphic property of SAVER we have  <span class="math">\\mathcal{CT}_a_{[r_1]} \\circ \\mathcal{CT}_b_{[r_2]} = \\mathcal{CT}_{a + b_{[r_1 + r_2]}}</span> .</p>

    <p class="text-gray-300">By using this property,  <span class="math">\\mathcal{B}</span>  first computes a zero ciphertext  <span class="math">\\mathcal{CT}_{\\emptyset} = \\overline{\\mathcal{C}\\mathcal{T}} \\oslash (\\mathcal{CT}_1^<em> \\circ \\dots \\circ \\mathcal{CT}_N^</em>)</span> , which will be used to cancel out the random inside the challenge which  <span class="math">\\mathcal{B}</span>  does not know. The message of  <span class="math">\\mathcal{CT}_{\\emptyset}</span>  is zero, since the sum of messages are guaranteed to be same. For the random part, the challenge ciphertext set  <span class="math">CT^*</span>  is listed with unknown corresponding randoms  <span class="math">r_1, \\ldots, r_N</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {1} ^ {*}, \\mathcal {C T} _ {1} ^ {*} _ {[ r _ {1} ]} \\quad \\dots \\quad \\pi_ {N} ^ {*}, \\mathcal {C T} _ {N} ^ {*} _ {[ r _ {N} ]}</span></div>

    <p class="text-gray-300">Therefore, with denoting the random in  <span class="math">\\overline{\\mathcal{C}\\mathcal{T}}</span>  as  <span class="math">\\overline{r}</span> , the random in  <span class="math">\\mathcal{CT}_{\\emptyset} = \\overline{\\mathcal{C}\\mathcal{T}}_{[\\overline{r}]} \\oslash (\\mathcal{CT}_1^<em>_{[r_1]} \\circ \\dots \\circ \\mathcal{CT}_N^</em>_{[r_N]})</span>  is transformed into  <span class="math">\\overline{r} - \\sum_{i=1}^{N} r_i</span> . After computing  <span class="math">\\mathcal{CT}_{\\emptyset_{[\\overline{r} - \\sum_{i=1}^{N} r_i]}}</span> ,  <span class="math">\\mathcal{B}</span>  replaces  <span class="math">\\mathcal{CT}_1^*_{[r_1]}</span>  as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C T} _ {1} ^ {*} _ {[ r _ {1} ]} \\leftarrow \\mathcal {C T} _ {1} ^ {* *} _ {[ r _ {1} + \\bar {r} - \\sum_ {i = 1} ^ {N} r _ {i} ]} = \\mathcal {C T} _ {1} ^ {*} _ {[ r _ {1} ]} \\circ \\mathcal {C T} _ {\\emptyset [ \\bar {r} - \\sum_ {i = 1} ^ {N} r _ {i} ]}</span></div>

    <p class="text-gray-300">Now when the ciphertext is gathered into a sum as  <span class="math">\\mathcal{CT}_{sum[\\overline{r}]}^<em> = \\mathcal{CT}_1^{</em>[r_1 + \\overline{r} - \\sum_{i=1}^N r_i]}^\\circ \\mathcal{CT}_2^{<em>[r_2]} \\circ \\dots \\circ \\mathcal{CT}_N^{</em>[r_N]}</span> , the random is transformed into  <span class="math">\\overline{r}</span>  from  <span class="math">\\overline{r} + \\sum_{i=1}^N r_i - \\sum_{i=1}^N r_i</span> . Therefore,  <span class="math">\\mathcal{CT}_{sum[\\overline{r}]}^<em></span>  shares the same random  <span class="math">\\overline{r}</span>  with  <span class="math">\\nu_{[\\overline{r}]}</span> , which can pass Verify_Dec( <span class="math">\\mathcal{CT}_{sum}^</em>, \\sum_{i=1}^N M_i, \\overline{\\nu}</span> ).</p>

    <p class="text-gray-300">A remaining task is that  <span class="math">\\mathcal{B}</span>  also needs to deal with the  <span class="math">\\pi_1^<em></span> : when  <span class="math">\\mathcal{CT}_1^</em>_{[r_1]}</span>  is changed to  <span class="math">\\mathcal{CT}_1^{<em>[r_1 + \\overline{r} - \\sum_{i=1}^N r_i]}</span> , the  <span class="math">\\pi_1^</em></span>  fails the Verify_Enc  <span class="math">(\\pi_1^<em>, \\mathcal{CT}_1^</em>)</span>  in VerifyVote since the proof in Saver is constructed as  <span class="math">\\pi_1^* = (A, B, C \\cdot P_2^{r_1})</span>  for the  <span class="math">PK_{eid}</span>  element  <span class="math">P_2 = G^{-\\gamma \\cdot (1 + \\sum_{j=1}^{\\gamma} s_j)}</span>  where  <span class="math">r_1</span>  should be canceled out from the ciphertexts. Thus, to let the proof pass the verification,  <span class="math">\\mathcal{B}</span>  should generate a new proof for the new random as  <span class="math">\\pi_1^{**} = (A, B, C \\cdot P_2^{r_1 + \\overline{r} - \\sum_{i=1}^N r_i})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To deal with  <span class="math">P_2^{r_1 + \\overline{r} - \\sum_{i=1}^N r_i} = G^{-\\gamma (1 + \\sum_{j=1}^n s_j) \\cdot (r_1 + \\overline{r} - \\sum_{i=1}^N r_i)}</span> ,  <span class="math">\\mathcal{B}</span>  uses the trap-door family  <span class="math">\\tau = \\{\\alpha, \\beta, \\gamma, \\delta\\}</span> . First,  <span class="math">\\mathcal{B}</span>  computes the sum of original challenge ciphertexts as  <span class="math">\\mathcal{CT}_{sum}^<em> [\\sum_{i=1}^N r_i] = \\mathcal{CT}_1^</em> [r_1] \\circ \\dots \\circ \\mathcal{CT}_N^<em> [r_N]</span> . When observing  <span class="math">\\mathcal{CT}_{sum}^</em> [\\sum_{i=1}^N r_i]</span>  for  $M_{sum} = (m_{sum,1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{sum,n})$ , the elements inside take the form of:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">c _ {s u m, 0} = G ^ {\\delta \\cdot \\sum_ {i = 1} ^ {N} r _ {i}}, \\quad \\{c _ {s u m, i} = G ^ {\\delta \\cdot s _ {i} \\cdot \\sum_ {i = 1} ^ {N} r _ {i}} \\cdot G _ {i} ^ {m _ {s u m, i}} \\} _ {i = 1} ^ {n}, \\quad \\psi_ {1} = P _ {1} ^ {\\sum_ {i = 1} ^ {N} r _ {i}} \\prod_ {j = 1} ^ {n} Y _ {j} ^ {m _ {s u m, j}}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{B}</span>  does not know  <span class="math">s_i</span>  and  <span class="math">\\sum_{i=1}^{N} r_i</span> , but it knows the sum of messages  $M_{sum} = (m_{sum,1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{sum,n})<span class="math">  and the trapdoor  </span>\\gamma, \\delta<span class="math"> . So  </span>\\mathcal{B}<span class="math">  can compute  </span>P_2^{\\sum_{i=1}^{N} r_i}<span class="math">  by using  </span>\\gamma, \\delta<span class="math">  on the  </span>\\mathcal{CT}_{sum}$  as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P_{2}^{\\sum_{i=1}^{N} r_{i}} = c_{sum,0}^{-\\frac{\\gamma}{2}} \\cdot \\prod_{j=1}^{n} (c_{sum,j} \\cdot G_{j}^{-m_{sum,j}})^{-\\frac{\\gamma}{2}} \\\\ = G^{\\delta \\sum_{i=1}^{N} r_{i} \\cdot -\\frac{\\gamma}{2}} \\cdot \\prod_{j=1}^{n} (G^{\\delta s_{j} \\sum_{i=1}^{N} r_{i}} \\cdot G_{j}^{m_{sum,j}} \\cdot G_{j}^{-m_{sum,j}})^{-\\frac{\\gamma}{2}} \\\\ = G^{-\\gamma \\sum_{i=1}^{N} r_{i}} \\cdot G^{-\\gamma \\sum_{i=1}^{N} r_{i} \\sum_{j=1}^{n} s_{j}} = G^{-\\gamma (1 + \\sum_{j=1}^{n} s_{j}) \\cdot \\sum_{i=1}^{N} r_{i}} \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a similar way, <span class="math">\\mathcal{B}</span> does not know <span class="math">s_i</span> and <span class="math">\\overline{r}</span>, but it can compute <span class="math">P_2^{\\overline{r}}</span> from <span class="math">\\overline{\\mathcal{C}\\mathcal{T}}</span> for $\\sum_{i=1}^{N} M_i = (m_{\\sum,1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\cdot\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{\\sum,n})<span class="math"> which consists of </span>\\overline{c_0}<span class="math">, </span>\\{\\overline{c_i}\\}_{i=1}^n<span class="math">, </span>\\overline{\\psi}$ as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P_{2}^{\\overline{r}} = \\overline{c_{0}}^{-\\frac{\\gamma}{2}} \\cdot \\prod_{j=1}^{n} (\\overline{c_{j}} \\cdot G_{j}^{-m_{\\sum,j}})^{-\\frac{\\gamma}{2}} \\\\ = G^{\\delta \\overline{r} \\cdot -\\frac{\\gamma}{2}} \\cdot \\prod_{j=1}^{n} (G^{\\delta s_{j} \\overline{r}} \\cdot G_{j}^{m_{\\sum,j}} \\cdot G_{j}^{-m_{\\sum,j}})^{-\\frac{\\gamma}{2}} \\\\ = G^{-\\gamma \\overline{r}} \\cdot G^{-\\gamma \\overline{r} \\sum_{j=1}^{n} s_{j}} = G^{-\\gamma (1 + \\sum_{j=1}^{n} s_{j}) \\cdot \\overline{r}} \\end{array}</span></div>

    <p class="text-gray-300">Using <span class="math">P_{2}^{\\sum_{i=1}^{N} r_{i}}</span> and <span class="math">P_{2}^{\\overline{r}}</span>, <span class="math">\\mathcal{B}</span> computes <span class="math">P_{2}^{\\overline{r} - \\sum_{i=1}^{N} r_{i}} = P_{2}^{\\overline{r}} / P_{2}^{\\sum_{i=1}^{N} r_{i}}</span>. Finally, <span class="math">\\mathcal{B}</span> modifies the proof <span class="math">\\pi_{1}^{<em>} = (A^{</em>}, B^{<em>}, C^{</em>})</span> as <span class="math">\\pi_{1}^{<strong>} = (A^{<em>}, B^{</em>}, C^{<em>} \\cdot P_{2}^{\\overline{r} - \\sum_{i=1}^{N} r_{i}})</span>. Since the original <span class="math">\\pi_{1}^{</em>}</span> takes a form of <span class="math">(A, B, C \\cdot P_{2}^{r_{1}})</span> from the zk-SNARK proof <span class="math">(A, B, C)</span>, <span class="math">\\pi_{1}^{</strong>}</span> will take a form of <span class="math">(A, B, C \\cdot P_{2}^{r_{1} + \\overline{r} - \\sum_{i=1}^{N} r_{i}})</span>, as desired. Now, the new proof <span class="math">\\pi_{1}^{<strong>}</span> passes the Verify_Enc <span class="math">(\\pi_{1}^{</strong>}, \\mathcal{CT}_{1}^{<strong>})</span> since the random <span class="math">r_{1} + \\overline{r} - \\sum_{i=1}^{N} r_{i}</span> can be canceled out in the equation with respect to <span class="math">\\mathcal{CT}_{1}^{</strong>}_{[r_{1} + \\overline{r} - \\sum_{i=1}^{N} r_{i}]}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the challenge, <span class="math">\\mathcal{B}</span> uses the voting key <span class="math">\\{sk_{ID_i}\\}_{i=1}^N</span> to generate the serial number as $\\{sn_i = H(eid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sk_{ID_i})\\}_{i=1}^N<span class="math">, and completes the ballots as </span>ballot_1 = (eid, sn_1, \\pi_1^{<strong>}, \\mathcal{CT}_1^{</strong>})<span class="math"> and </span>\\{ballot_i = (eid, sn_i, \\pi_i^<em>, \\mathcal{CT}_i^</em>)\\}_{i=2}^N<span class="math">. Then </span>\\mathcal{B}<span class="math"> returns the set of ballots </span>\\mathbf{S} = ballot_1 \\cup \\{ballot_i\\}_{i=2}^N<span class="math"> to </span>\\mathcal{A}$ as a response to the challenge.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Tally: <span class="math">\\mathcal{B}</span> gives the tally result as <span class="math">\\sum_{i=1}^{N} M_i</span> and <span class="math">\\overline{\\nu}</span> to <span class="math">\\mathcal{A}</span>. When <span class="math">\\mathcal{A}</span> tries Verify_Dec <span class="math">(\\mathbf{S}, \\sum_{i=1}^{N} M_i, \\overline{\\nu})</span>, the verification passes; when the ciphertexts are gathered into a sum <span class="math">\\mathcal{CT}_{sum[\\overline{r}]}^{<em>} = \\mathcal{CT}_{1[r_1 + \\overline{r} - \\sum_{i=1}^{N} r_i]}^{</em>} \\circ \\mathcal{CT}_{2[r_2]}^{<em>} \\circ \\dots \\circ \\mathcal{CT}_{N[r_N]}^{</em>}</span>, it shares the same random with <span class="math">\\overline{\\nu}_{[\\overline{r}]}</span>.</p>

    <p class="text-gray-300">Guess: <span class="math">\\mathcal{A}</span> outputs its guess <span class="math">b&#x27;</span> to <span class="math">\\mathcal{B}</span>, distinguishing whether <span class="math">\\mathbf{S}</span> is from <span class="math">\\mathbf{V_0}</span> or <span class="math">\\mathbf{V_1}</span>. <span class="math">\\mathcal{B}</span> outputs the same <span class="math">b&#x27;</span> as a guess for <span class="math">\\mathbf{Game}_{\\text{SAVER}}^{multi-ind}</span>; if <span class="math">\\mathbf{CT}^<em></span> was encryption of the set <span class="math">\\{M_i\\}_{i=1}^N</span>, then <span class="math">\\mathcal{A}</span> will output 0, or if <span class="math">\\mathbf{CT}^</em></span> was encryption of the set <span class="math">\\{M_i&#x27;\\}_{i=1}^N</span>, then <span class="math">\\mathcal{A}</span> will output 1. Therefore, we have <span class="math">\\mathbf{Adv}_{\\text{SAVER},\\mathcal{A}}^{multi-ind}(\\lambda) = \\mathbf{Adv}_{\\text{V-SAVER},\\mathcal{A}}^{Game_{BF}}(\\lambda)</span>, which completes the proof of lemma.</p>

    <p class="text-gray-300">§ Game_BP = Game_RF Now, we show that the game for ballot-privacy and receipt-freeness is identical from the <span class="math">\\mathcal{A}</span>'s view, which can complete the theorem as <span class="math">\\mathbf{Adv}_{\\text{SAVER},\\mathcal{A}}^{single-ind}(\\lambda) \\approx \\mathbf{Adv}_{\\text{SAVER},\\mathcal{A}}^{multi-ind}(\\lambda) = \\mathbf{Adv}_{\\text{V-SAVER},\\mathcal{A}}^{Game_{BF}}(\\lambda) = \\mathbf{Adv}_{\\text{V-SAVER},\\mathcal{A}}^{Game_{RF}}(\\lambda)</span>.</p>

    <p class="text-gray-300">Lemma 4. From the adversary's view, <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span> and <span class="math">\\mathbf{Game}_{\\mathbf{RF}}</span> is identical.</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">The only difference between  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span>  and  <span class="math">\\mathbf{Game}_{\\mathbf{RF}}</span>  is that in  <span class="math">\\mathbf{Game}_{\\mathbf{RF}}</span> ,  <span class="math">\\mathcal{A}</span>  submits the encrypted ballots  <span class="math">S_0</span>  and  <span class="math">S_1</span>  in addition to  <span class="math">V_0</span>  and  <span class="math">V_1</span> , while keeping the  <span class="math">\\{sk_{ID_i}\\}_{i=1}^N</span>  for itself. Similar to the algorithm  <span class="math">\\mathcal{B}</span>  in the reduction of  <span class="math">\\mathbf{Game}_{\\mathbf{BP}}</span> , let us build an algorithm  <span class="math">\\mathcal{B}&#x27;</span>  which attempts to win  <span class="math">\\mathbf{Game}_{\\mathrm{SAVER}}^{multi-ind}</span>  using the receipt-freeness attacker  <span class="math">\\mathcal{A}&#x27;</span>  with the advantage of  <span class="math">\\mathbf{Adv}_{\\mathrm{V-SAVER},\\mathcal{A}&#x27;}^{\\mathrm{Game}_{\\mathrm{RF}}}(\\lambda)</span> . Then,  <span class="math">\\mathcal{B}&#x27;</span>  proceeds the same process as  <span class="math">\\mathcal{B}</span> , except it uses the serial number  <span class="math">sn_i</span>  as received from  <span class="math">\\mathcal{A}&#x27;</span>  in the challenge response since  <span class="math">\\mathcal{B}&#x27;</span>  no longer possesses  <span class="math">sk_{ID_i}</span> .</p>

    <p class="text-gray-300">When observing the game between  <span class="math">\\mathcal{B}&#x27;</span>  and  <span class="math">\\mathcal{A}&#x27;</span> , the challenge response of  <span class="math">B&#x27;</span>  consists of a new encryption  <span class="math">CT^*</span> , which can be viewed as  <span class="math">\\mathsf{Enc}(\\mathsf{Dec}(S_b))</span> . In the original  <span class="math">\\mathbf{Game}_{\\mathbf{RF}}</span> ,  <span class="math">\\mathcal{C}</span>  was supposed to rerandomize the ballots by running PostVote  <span class="math">(ballot_i)</span> . However, by the rerandomizability of SAVER, we have that  <span class="math">\\mathsf{Rerandomize}(S_b) = \\mathsf{Enc}(\\mathsf{Dec}(S_b))</span> . Therefore, from  <span class="math">\\mathcal{A}&#x27;</span> 's view, the re-encrypted  <span class="math">S_b</span>  is identical to the rerandomized  <span class="math">\\tilde{S}_b</span> . This ensures that  <span class="math">\\mathcal{A}&#x27;</span>  behaves the same as  <span class="math">\\mathcal{A}</span> , which guarantees that algorithm  <span class="math">\\mathcal{B}&#x27;</span>  can have the same advantage on winning  <span class="math">\\mathbf{Game}_{\\mathsf{SAVER}}^{multi-ind}</span>  as  <span class="math">\\mathbf{Adv}_{\\mathsf{SAVER},\\mathcal{A}}^{multi-ind}(\\lambda) = \\mathbf{Adv}_{\\mathsf{V-SAVER},\\mathcal{A}}^{Game_{\\mathsf{RF}}}(\\lambda)</span> .</p>

    <p class="text-gray-300">Individual verifiability &amp; non-repudiation: the individual verifiability refers to the soundness of blockchain node's vote post from the voter's view, which ensures that the posted vote contains the voter's original message. In the voter's view, the adversary (blockchain node) may forge the serial number to impersonate as the voter, or manipulate the existing vote to let the ciphertext decrypt to a different message: the individual verifiability must be secure from both attempts. This indicates that the individual verifiability implies non-repudiation as well as soundness, since preventing the impersonation can be understood as non-repudiation.</p>

    <p class="text-gray-300">Definition 13. Suppose we have an election  <span class="math">\\mathcal{E}</span>  constructed from the relation  <span class="math">\\mathcal{R}</span> , hash function  <span class="math">H\\in \\mathcal{R}</span>  of length  <span class="math">l</span> ,  <span class="math">CRS\\gets \\mathrm{InitSystem}(\\mathcal{R})</span> ,  <span class="math">\\{sk_{ID_i},pk_{ID_i}\\}_{i = 1}^N\\gets</span>  GenKey  <span class="math">(1^{n},ID_{i})</span> , and  <span class="math">\\pmb {pklist}</span> ,  <span class="math">SK_{eid}</span> ,  <span class="math">PK_{eid}</span> ,  <span class="math">VK_{eid}</span> ,  <span class="math">eid</span> ,  <span class="math">rt\\gets</span>  Election  <span class="math">(CRS,1^n,\\{pk_{ID_i}\\}_{i = 1}^N)</span> . For any secret key  <span class="math">sk_{ID}</span>  for  <span class="math">pk_{ID}\\in \\pmb {pklist}</span> , the voting system satisfies individual verifiability, if for any adversary  <span class="math">\\mathcal{A}</span>  the following advantage  <span class="math">\\mathbf{Adv}_{\\mathrm{V - SAVER},\\mathcal{A}}^{IndVer}(l,\\lambda)</span>  is  <span class="math">negl(\\lambda)</span> .</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P r \\left[ \\begin{array}{l} e i d, s n, \\pi , \\mathcal {C T} \\leftarrow \\mathsf {V o t e} (s k _ {I D}, M, r t, \\dots), \\\\ e i d, s n, \\pi^ {<em>}, \\mathcal {C T} ^ {</em>}, s k _ {I D} ^ {<em>} \\leftarrow \\mathcal {A} (e i d, s n, \\pi , \\mathcal {C T}, H, \\boldsymbol {p k l i s t}, r t): \\\\ \\mathsf {V e r i f y \\_ V o t e} (\\pi^ {</em>}, \\mathcal {C T} ^ {<em>}, e i d, s n, r t) = t r u e \\quad \\wedge \\\\ (\\mathsf {D e c} (\\mathcal {C T} ^ {</em>}) \\neq M \\quad \\vee \\\\ (s k _ {I D} ^ {*} \\neq s k _ {I D} \\wedge H (s k _ {I D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e i d) = H (s k _ {I D} ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e i d) = s n)) \\end{array} \\right]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Theorem 5. If SAVER satisfies the encryption soundness and the hash function  <span class="math">H</span>  is collision-resistant, then the Vote-SAVER scheme satisfies individual verifiability.</p>

    <p class="text-gray-300">Proof. To prove the theorem, we show that any adversary which breaks the individual verifiability can break the collision-resistant hash or the encryption soundness of SAVER. If  <span class="math">\\mathcal{A}</span>  has a non-negligible advantage on  <span class="math">\\mathbf{Adv}_{\\mathrm{V - SAVER},\\mathcal{A}}^{IndVer}(l,\\lambda)</span> ,</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">it outputs a ballot <span class="math">(eid, sn, \\pi^<em>, \\mathcal{CT}^</em>)</span> with respect to <span class="math">skID^<em></span> which passes the Verify_Vote <span class="math">(\\pi^</em>, \\mathcal{CT}^<em>, eid, sn, rt)</span>, where the ciphertext <span class="math">CT^</em></span> does not decrypt to original <span class="math">M</span> <span class="math">(\\mathsf{Dec}(\\mathcal{CT}^<em>) \\neq M)</span> or the pre-image of <span class="math">sn</span> is not <span class="math">sk_{ID}</span> $(sk_{ID}^</em> \\neq sk_{ID} \\land H(sk_{ID}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">eid) = H(sk_{ID}^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">eid) = sn)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $sk_{ID}^{*} \\neq sk_{ID} \\land H(sk_{ID}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">eid) = H(sk_{ID}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">eid) = sn<span class="math">, it indicates that we found a new </span>sk_{ID}^{*}<span class="math"> which satisfies </span>H(sk_{ID}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">eid) = H(sk_{ID}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">eid)<span class="math">, which can break the collision-resistant hash. Otherwise, if </span>\\mathsf{Dec}(\\mathcal{CT}^{*}) \\neq M<span class="math">, it can break the encryption soundness of SAVER since the encryption soundness must guarantee </span>(\\mathsf{Dec}(\\mathcal{CT}) = M \\land (M, \\hat{\\varPhi}, w) \\in \\mathcal{R})<span class="math"> for the verifying proof. Therefore, for the advantage of </span>l<span class="math">-length collision-resistant hash </span>\\mathbf{Adv}_{\\mathrm{Hash}}^{CR}(l)<span class="math"> and the advantage of encryption soundness </span>\\mathbf{Adv}_{\\mathrm{SAVER},\\mathcal{A}}^{sound}(\\lambda)<span class="math">, formally we have </span>\\mathbf{Adv}_{\\mathrm{V-SAVER},\\mathcal{A}}^{IndVer}(l,\\lambda) \\leq \\mathbf{Adv}_{\\mathrm{Hash}}^{CR}(l) + \\mathbf{Adv}_{\\mathrm{SAVER},\\mathcal{A}}^{sound}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300"><strong>Eligibility verifiability</strong>: the eligibility verifiability refers to the soundness of voter's vote from the blockchain node's view, which ensures that the voter's vote is from an eligible voting right, i.e., the vote is within the valid relation (membership test). In the node's view, the adversary (voter) may forge a ballot that does not satisfy the relation of SAVER but still passes the Verify_Vote, which must be prevented by the eligibility verifiability.</p>

    <p class="text-gray-300"><strong>Proof.</strong> It is straightforward to see that the eligibility verifiability is implied by the encryption soundness of SAVER, since the verification process of PostVote <span class="math">(CRS, PK_{eid}, rt, eid, sn, \\pi, \\mathcal{CT})</span> is identical to the Verify_Enc <span class="math">(CRS, PK, \\pi, \\mathcal{CT}, rt, eid, sn)</span> with <span class="math">rt, eid, sn</span> as normal I/O statements <span class="math">\\phi</span> in SAVER.</p>

    <p class="text-gray-300"><strong>Tally uniqueness</strong>: the tally uniqueness [BCG+15] refers to the perfect universal verifiability of the tally result, which ensures that anyone can verify that the result is generated from the ballots in the public board.</p>

    <p class="text-gray-300"><strong>Proof.</strong> It is straightforward to see that the uniqueness of the tally is implied by the decryption soundness of SAVER, since the output of Tally and the process of Verify_Tally in Vote-SAVER is identical to the Dec and Verify_Dec in SAVER.</p>

    <p class="text-gray-300"><strong>Voter anonymity</strong>: the voter anonymity is a new security notion, which defines that the voter's identity must be hidden from any observers, even from the administrator. In standard voting systems, the trusted authority was responsible for distributing the voting keys, which cannot satisfy the voter anonymity. However, in the Vote-SAVER, the ballot does not reveal the identity of the voter; even the administrator can only see the plaintext of the vote, but cannot distinguish the identity since the membership information is hidden as witnesses in the zk-SNARK.</p>

    <p class="text-gray-300">Suppose we have an election <span class="math">\\mathcal{E}</span> constructed from the relation <span class="math">\\mathcal{R}</span>. The voter anonymity is defined by a simple <span class="math">\\mathbf{Game}_{\\mathbf{VA}}</span> between the adversary <span class="math">\\mathcal{A}</span> and the challenger <span class="math">\\mathcal{C}</span> as below:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> initializes the game by running <span class="math">CRS\\leftarrow\\textsf{InitSystem}(\\mathcal{R})</span> and generating voter lists <span class="math">\\{sk_{ID_{i}},pk_{ID_{i}}\\}_{i=1}^{N}\\leftarrow\\textsf{GenKey}(1^{\\kappa},ID_{i})</span>.</li>

      <li><span class="math">\\mathcal{C}</span> opens an election by running <span class="math">\\bm{pklist},SK_{eid},PK_{eid},VK_{eid},eid,rt\\leftarrow\\textsf{Election}</span> <span class="math">(CRS,1^{\\kappa},\\{pk_{ID_{i}}\\}_{i=1}^{N})</span>. Then <span class="math">\\mathcal{C}</span> passes <span class="math">\\bm{pklist},PK_{eid},VK_{eid},eid,rt</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>from <span class="math">\\bm{pklist}</span>, <span class="math">\\mathcal{A}</span> selects two voters as <span class="math">pk_{0},pk_{1}\\in\\bm{pklist}</span> and send them to <span class="math">\\mathcal{C}</span> as a challenge.</li>

      <li><span class="math">\\mathcal{C}</span> picks <span class="math">b\\in\\{0,1\\}</span>, finds the <span class="math">sk_{b}</span> for <span class="math">pk_{b}</span>, and generates the ballot from <span class="math">pk_{b}</span> as <span class="math">\\textsf{Vote}(sk_{b},M,rt,\\cdots)</span>. Then <span class="math">\\mathcal{C}</span> returns the ballot <span class="math">(eid,sn,\\pi,\\mathcal{CT})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> guesses <span class="math">b^{\\prime}</span>, guessing which voter the ballot was made from, and wins if <span class="math">b=b^{\\prime}</span>.</li>

    </ol>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 14.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{Adv}_{\\mathbf{V-SAVER},\\mathcal{A}}^{\\textsf{Game}_{\\text{V}\\mathcal{A}}}(\\lambda)</span> be the advantage of <span class="math">\\mathcal{A}</span> winning the above <span class="math">\\mathbf{Game}_{\\mathbf{VA}}</span>. For a negligible function <span class="math">\\epsilon</span>, the voting system satisfies voter anonymity if for any adversary <span class="math">\\mathcal{A}</span> we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Adv}_{\\mathbf{V-SAVER},\\mathcal{A}}^{\\textsf{Game}_{\\text{V}\\mathcal{A}}}(\\lambda)-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">If SAVER satisfies perfect zero-knowledge, then the Vote-SAVER scheme satisfies voter anonymity.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The perfect zero-knowledge defines that for the same relation, a simulated proof is indistinguishable from a real proof. This can be constructed into a simple game <span class="math">\\mathbf{Game}_{\\textsf{SAVER}}^{\\textsf{sk}}</span>, where the adversary sees <span class="math">\\pi^{*}</span> and output <span class="math">0</span> if it is a simulated proof and output <span class="math">1</span> if it is a real proof. Let <span class="math">\\mathbf{Adv}_{\\mathbf{V-SAVER},\\mathcal{A}}^{\\textsf{Game}_{\\text{V}\\mathcal{A}}}(\\lambda)</span> be the advantage of <span class="math">\\mathcal{A}</span> winning the <span class="math">\\mathbf{Game}_{\\mathbf{VA}}</span>. We build an algorithm <span class="math">\\mathcal{B}</span> has an advantage <span class="math">\\mathbf{Adv}_{\\textsf{SAVER},\\mathcal{A}}^{\\textsf{sk}}(\\lambda)</span> on distinguishing the nature of the proof in <span class="math">\\mathbf{Game}_{\\textsf{SAVER}}^{\\textsf{sk}}</span>.</p>

    <p class="text-gray-300">For <span class="math">\\mathcal{A}</span>’s challenge, <span class="math">\\mathcal{B}</span> always set <span class="math">b=1</span> to pick <span class="math">pk_{1}</span>. Next, <span class="math">\\mathcal{B}</span> generates the ballot with running <span class="math">(eid,sn,\\pi,\\mathcal{CT})\\leftarrow\\textsf{Vote}(sk_{1},M,rt,\\cdots)</span>, and challenges the <span class="math">\\mathbf{Game}_{\\textsf{SAVER}}^{\\textsf{sk}}</span> with respect to <span class="math">(eid,sn,\\mathcal{CT};sk_{1})</span> to receive <span class="math">\\pi^{<em>}</span>. Then, <span class="math">\\mathcal{B}</span> replaces <span class="math">\\pi</span> in the ballot to <span class="math">\\pi^{</em>}</span>, and returns <span class="math">(eid,sn,\\pi^{*},\\mathcal{CT})</span> to <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{B}</span> bypasses <span class="math">\\mathcal{A}</span>’s guess <span class="math">b^{\\prime}</span> to <span class="math">\\mathbf{Game}_{\\textsf{SAVER}}^{\\textsf{sk}}</span>.</p>

    <p class="text-gray-300">When observing the ballot <span class="math">(eid,sn,\\pi^{<em>},\\mathcal{CT})</span>, the only possible way <span class="math">\\mathcal{A}</span> can distinguish <span class="math">b</span> is by the existance of an extractor <span class="math">\\chi_{\\mathcal{A}}</span> for the witnesses, since <span class="math">sn</span> is random in <span class="math">\\mathcal{A}</span>’s view. Therefore, if <span class="math">\\pi^{</em>}</span> was a real proof, <span class="math">\\mathcal{A}</span> will operate normally by extracting the <span class="math">sk_{1}</span> and success identifying the voter as outputting <span class="math">b^{\\prime}=1</span>. However, if <span class="math">\\pi^{*}</span> was a simulated proof, <span class="math">\\mathcal{A}</span> cannot operate normally, which will guess <span class="math">b^{\\prime}</span> with a probability of <span class="math">1/2</span>. Hence, for <span class="math">\\mathbf{Adv}_{\\textsf{SAVER},\\mathcal{A}}^{\\textsf{sk}}(\\lambda)=\\epsilon=0</span>, <span class="math">\\mathcal{B}</span>’s advantage <span class="math">\\mathbf{Adv}_{\\mathbf{V-SAVER},\\mathcal{A}}^{\\textsf{Game}_{\\text{V}\\mathcal{A}}}(\\lambda)</span> can be concluded as <span class="math">\\epsilon/2</span>: since the perfect zero-knowledge defines the <span class="math">\\epsilon</span> as <span class="math">0</span>, we conclude that <span class="math">\\mathbf{Adv}_{\\mathbf{V-SAVER},\\mathcal{A}}^{\\textsf{Game}_{\\text{V}\\mathcal{A}}}(\\lambda)=\\epsilon/2=0</span>. ∎</p>

    <h2 id="sec-45" class="text-2xl font-bold">8 Experiment</h2>

    <p class="text-gray-300">We implement the proposed SAVER, with respect to the Vote-SAVER relation described in section 6. In the relation, Ajtai hash function is adopted as a hash function <em>[x1, KZM^{+}15a]</em> and the tree height is <span class="math">16</span> (up to <span class="math">2^{16}</span> voters). The experiment results are measured on the Ubuntu 18.04 machine with Intel-i5 (3.4GHz) quad-cores and 24GB memory. For the zk-SNARK, we utilized the libsnark <em>[x24]</em> library.</p>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1: Execution time and parameter size in Vote-SAVER, for total  <span class="math">2^{16}</span>  voters. The  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  determines the number of candidates available (ex: assuming each candidate as 4byte, 16 candidates for 256 bits).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Setup</td>

            <td class="px-3 py-2 border-b border-gray-700">2.67s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.67s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.69s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.72s</td>

            <td class="px-3 py-2 border-b border-gray-700">CRS</td>

            <td class="px-3 py-2 border-b border-gray-700">16MB</td>

            <td class="px-3 py-2 border-b border-gray-700">16MB</td>

            <td class="px-3 py-2 border-b border-gray-700">16MB</td>

            <td class="px-3 py-2 border-b border-gray-700">16MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.09s</td>

            <td class="px-3 py-2 border-b border-gray-700">SK</td>

            <td class="px-3 py-2 border-b border-gray-700">32B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Enc (sep)</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6ms</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4ms</td>

            <td class="px-3 py-2 border-b border-gray-700">7.4ms</td>

            <td class="px-3 py-2 border-b border-gray-700">8.8ms</td>

            <td class="px-3 py-2 border-b border-gray-700">PK</td>

            <td class="px-3 py-2 border-b border-gray-700">1246B</td>

            <td class="px-3 py-2 border-b border-gray-700">2321B</td>

            <td class="px-3 py-2 border-b border-gray-700">4465B</td>

            <td class="px-3 py-2 border-b border-gray-700">8753B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πsnark.Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">0.73s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.73s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.73s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.74s</td>

            <td class="px-3 py-2 border-b border-gray-700">VK</td>

            <td class="px-3 py-2 border-b border-gray-700">1126B</td>

            <td class="px-3 py-2 border-b border-gray-700">2184B</td>

            <td class="px-3 py-2 border-b border-gray-700">4296B</td>

            <td class="px-3 py-2 border-b border-gray-700">8520B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify_Enc</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2ms</td>

            <td class="px-3 py-2 border-b border-gray-700">12.7ms</td>

            <td class="px-3 py-2 border-b border-gray-700">21.7ms</td>

            <td class="px-3 py-2 border-b border-gray-700">39.8ms</td>

            <td class="px-3 py-2 border-b border-gray-700">CT</td>

            <td class="px-3 py-2 border-b border-gray-700">477B</td>

            <td class="px-3 py-2 border-b border-gray-700">749B</td>

            <td class="px-3 py-2 border-b border-gray-700">1293B</td>

            <td class="px-3 py-2 border-b border-gray-700">2381B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dec</td>

            <td class="px-3 py-2 border-b border-gray-700">37.7ms</td>

            <td class="px-3 py-2 border-b border-gray-700">75.2ms</td>

            <td class="px-3 py-2 border-b border-gray-700">149.7ms</td>

            <td class="px-3 py-2 border-b border-gray-700">300.4ms</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">128B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify_Dec</td>

            <td class="px-3 py-2 border-b border-gray-700">14.8ms</td>

            <td class="px-3 py-2 border-b border-gray-700">28.3ms</td>

            <td class="px-3 py-2 border-b border-gray-700">55.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">110.1ms</td>

            <td class="px-3 py-2 border-b border-gray-700">ν</td>

            <td class="px-3 py-2 border-b border-gray-700">32B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rerandomize</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06ms</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">*  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=<span class="math">  message size,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 4<span class="math">  bits,  </span>\\Pi_{\\text{snark}} = [Gro16]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1 shows the execution time for each algorithm, and size for the parameters. We vary the message size from 256 bits to 2048 bits, where the message is a ballot for list of candidates. For instance, an integer vote in which 4 bytes data is used for each candidate can represent 8 candidates. We fix the message block size as  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 32<span class="math">  bits for all message spaces. For example, 256-bit  </span>M$  consists of 8 blocks of messages. The block size determines the ciphertext size and decryption time. A larger block size can yield less number of total blocks, which leads to less number of ciphertext blocks to decrease the ciphertext size. However, as a trade-off, it increases the decryption time due to the increased computation of discrete log search. Since we fix the block size, the decryption time is strictly linear to the message size which determines the number of message blocks.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The Enc in SAVER consists of a normal encryption and  <span class="math">\\Pi_{\\mathrm{snark}}</span> . Prove for the voting relation (i.e. membership tests and range checks); Enc (sep) is a separated time for the normal encryption. The zk-SNARK proving time takes 0.74s, which is dominant in the total encryption time, while the normal encryption takes less than 8ms for  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2048<span class="math">  bits. In SAVER, the number of elements for  </span>PK, VK<span class="math">  and  </span>\\mathcal{CT}<span class="math">  is determined by the number of message blocks. Therefore it is shown in the result that  </span>PK, VK, \\mathcal{CT}<span class="math">  size increases along with the message size. For the fixed relation,  </span>CRS$  size remains as 16MB for all message sizes, which is practical to be stored in the portable devices.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This paper proposes SAVER: SNARK-friendly, Additively-homomorphic, and Verifiable Encryption and decryption with Rerandomization, which is generic verifiable encryption achieved from connecting zero-knowledge succinct noninteractive arguments of knowledge (zk-SNARK) and verifiable encryption. The proposed SAVER provides modular composition with other proof systems by supporting commit-and-prove connection from LegoSNARK. SAVER also satis</p>

    <p class="text-gray-300">Jiwon Lee, Jaekyoung Choi, Jihye Kim, and Hyunok Oh</p>

    <p class="text-gray-300">fies many useful functionalities. It is <em>snark-friendly</em>, to be compatible with the pairing-based zk-SNARKs. It is <em>additively-homomorphic</em>, so that the ciphertexts can be merged additively. It is a <em>verifiable encryption</em>, which can prove arbitrary properties of the message. It is a <em>verifiable decryption</em>, which can prove validity of the decryption. It provides <em>rerandomization</em>, where the ciphertext can be rerandomized as a new encryption. The security of the proposed SAVER is formally proved.</p>

    <p class="text-gray-300">This paper also represents a Vote-SAVER achieved by applying the proposed SAVER, which is a novel voting system where only the voter holds its own voting key, not distributed from the authority. The Vote-SAVER satisfies board integrity, receipt-freeness, individual verifiability, vote verifiability, and voter anonymity, where receipt-freeness implies ballot privacy and individual verifiability implies non-repudiation. The experiment results show that the proposed SAVER yields the encryption time of 8.8ms excluding proving time and the CRS size of 16MB for 2048-bit message, which is very practical compared to the encryption-in-the-circuit approach.</p>

    <h2 id="sec-47" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AGM18] Shashank Agrawal, Chaya Ganesh, and Payman Mohassel. Non-interactive zero-knowledge proofs for composite statements. In Annual International Cryptology Conference, pages 643–673. Springer, 2018.</li>

      <li>[AHL^{+}12] Nuttapong Attrapadung, Javier Herranz, Fabien Laguillaumie, Benoit Libert, Elie De Panafieu, and Carla Ràfols. Attribute-based encryption schemes with constant-size ciphertexts. Theoretical computer science, 422:15–38, 2012.</li>

      <li>[Ajt96] Miklós Ajtai. Generating hard instances of lattice problems (extended abstract). In Proceedings of the Twenty-Eighth Annual ACM Symposium on the Theory of Computing, Philadelphia, Pennsylvania, USA, May 22-24, 1996, pages 99–108, 1996.</li>

      <li>[AM16] Syed Taha Ali and Judy Murray. An overview of end-to-end verifiable voting systems. Real-world electronic voting: Design, analysis and deployment, pages 171–218, 2016.</li>

      <li>[Ate04] Giuseppe Ateniese. Verifiable encryption of digital signatures and applications. ACM Transactions on Information and System Security (TISSEC), 7(1):1–20, 2004.</li>

      <li>[BBG05] Dan Boneh, Xavier Boyen, and Eu-Jin Goh. Hierarchical identity based encryption with constant size ciphertext. In Ronald Cramer, editor, Advances in Cryptology - EUROCRYPT 2005, 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Aarhus, Denmark, May 22-26, 2005, Proceedings, volume 3494 of Lecture Notes in Computer Science, pages 440–456. Springer, 2005.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, pages 326–349. ACM, 2012.</li>

      <li>[BCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized</li>

    </ul>

    <p class="text-gray-300">SNARK-friendly, Additive, Verifiable Enc/dec with Rerandomization</p>

    <p class="text-gray-300">anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014, pages 459–474, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCG^{+}15] David Bernhard, Véronique Cortier, David Galindo, Olivier Pereira, and Bogdan Warinschi. Sok: A comprehensive analysis of game-based ballot privacy definitions. In 2015 IEEE Symposium on Security and Privacy, pages 499–516. IEEE, 2015.</li>

      <li>[BG18] Sean Bowe and Ariel Gabizon. Making groth’s zk-snark simulation extractable in the random oracle model. Cryptology ePrint Archive, Report 2018/187, 2018. https://eprint.iacr.org/2018/187.</li>

      <li>[CCFG16] Pyrros Chaidos, Véronique Cortier, Georg Fuchsbauer, and David Galindo. Beleniosrf: A non-interactive receipt-free electronic voting scheme. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 1614–1625, 2016.</li>

      <li>[CD00] Jan Camenisch and Ivan Damgård. Verifiable encryption, group encryption, and their applications to separable group signatures and signature sharing schemes. In International Conference on the Theory and Application of Cryptology and Information Security, pages 331–345. Springer, 2000.</li>

      <li>[CFQ19] Matteo Campanelli, Dario Fiore, and Anaïs Querol. Legosnark: Modular design and composition of succinct zero-knowledge proofs. Cryptology ePrint Archive, Report 2019/142, 2019. https://eprint.iacr.org/2019/142.</li>

      <li>[CGS97] Ronald Cramer, Rosario Gennaro, and Berry Schoenmakers. A secure and optimally efficient multi-authority election scheme. European transactions on Telecommunications, 8(5):481–490, 1997.</li>

      <li>[CL18] Véronique Cortier and Joseph Lallemand. Voting: You can’t have privacy without individual verifiability. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, pages 53–66. ACM, 2018.</li>

      <li>[CS03] Jan Camenisch and Victor Shoup. Practical verifiable encryption and decryption of discrete logarithms. In Annual International Cryptology Conference, pages 126–144. Springer, 2003.</li>

      <li>[FFG^{+}16] Dario Fiore, Cédric Fournet, Esha Ghosh, Markulf Kohlweiss, Olga Ohrimenko, and Bryan Parno. Hash first, argue later: Adaptive verifiable computations on outsourced data. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 1304–1316. ACM, 2016.</li>

      <li>[Gab19] Ariel Gabizon. On the efficiency of pairing-based proofs under the d-pke. Cryptology ePrint Archive, Report 2019/148, 2019. https://eprint.iacr.org/2019/148.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 626–645. Springer, 2013.</li>

      <li>[GM17] Jens Groth and Mary Maller. Snarky signatures: Minimal signatures of knowledge from Simulation-Extractable SNARKs. In Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part II, pages 581–612, 2017.</li>

    </ul>

    <p class="text-gray-300">[GPS08] Steven D. Galbraith, Kenneth G. Paterson, and Nigel P. Smart. Pairings for cryptographers. Discrete Applied Mathematics, 156(16):3113–3121, 2008.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Gro16] Jens Groth. On the size of Pairing-Based non-interactive arguments. In Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, pages 305–326, 2016.</li>

      <li>[JMP13] Hugo Jonker, Sjouke Mauw, and Jun Pang. Privacy and verifiability in voting systems: Methods, developments and trends. Computer Science Review, 10:1–30, 2013.</li>

      <li>[KLLO18] Jihye Kim, Seunghwa Lee, Jiwon Lee, and Hyunok Oh. Scalable wild-carded identity-based encryption. In European Symposium on Research in Computer Security, pages 269–287. Springer, 2018.</li>

      <li>[KLO20] Jihye Kim, Jiwon Lee, and Hyunok Oh. Simulation-extractable zk-snark with a single verification. IEEE Access, 2020.</li>

      <li>[KZM^{+}15a] Ahmed Kosba, Zhichao Zhao, Andrew Miller, Yi Qian, H Chan, Charalampos PAPAMAN-THOU, Rafael Pass, SHELAT ABHI, and EC SHI. c: A framework for building composable zero-knowledge proofs. Technical report, Cryptology ePrint Archive, Report 2015/1093, 2015. http://eprint. iacr. org …, 2015.</li>

      <li>[KZM^{+}15b] Ahmed E Kosba, Zhichao Zhao, Andrew Miller, Yi Qian, T-H Hubert Chan, Charalampos Papamanthou, Rafael Pass, Abhi Shelat, and Elaine Shi. How to use snarks in universally composable protocols. IACR Cryptology ePrint Archive, 2015:1093, 2015.</li>

      <li>[Lip19] Helger Lipmaa. Simulation-extractable snarks revisited. 2019.</li>

      <li>[LN17] Vadim Lyubashevsky and Gregory Neven. One-shot verifiable encryption from lattices. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 293–323. Springer, 2017.</li>

      <li>[Pai99] Pascal Paillier. Public-key cryptosystems based on composite degree residuosity classes. In International Conference on the Theory and Applications of Cryptographic Techniques, pages 223–238. Springer, 1999.</li>

      <li>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages 238–252. IEEE, 2013.</li>

      <li>[PR07] Manoj Prabhakaran and Mike Rosulek. Rerandomizable rcca encryption. In Annual International Cryptology Conference, pages 517–534. Springer, 2007.</li>

      <li>[Sak11] Kazue Sako. Verifiable Encryption, pages 1356–1357. Springer US, Boston, MA, 2011.</li>

      <li>[SL14] SCIPR-Lab. libsnark. https://github.com/scipr-lab/libsnark, 2014.</li>

      <li>[YAS^{+}12] Shota Yamada, Nuttapong Attrapadung, Bagus Santoso, Jacob CN Schuldt, Goichiro Hanaoka, and Noboru Kunihiro. Verifiable predicate encryption and applications to cca security and anonymous predicate authentication. In International Workshop on Public Key Cryptography, pages 243–261. Springer, 2012.</li>

    </ul>`;
---

<BaseLayout title="SAVER: SNARK-friendly, Additively-homomorphic, and Verifiabl... (2019/1270)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1270
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
