---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/913';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Thunderella: Blockchains with Optimistic Instant Confirmation';
const AUTHORS_HTML = 'Rafael Pass, Elaine Shi';

const CONTENT = `    <p class="text-gray-300">Rafael Pass Elaine Shi</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">State machine replication, or “consensus”, is a central abstraction for distributed systems where a set of nodes seek to agree on an ever-growing, linearly-ordered log. In this paper, we propose a practical new paradigm called Thunderella for achieving state machine replication by combining a fast, asynchronous path with a (slow) synchronous “fall-back” path (which only gets executed if something goes wrong); as a consequence, we get <em>simple</em> state machine replications that essentially are as robust as the best synchronous protocols, yet “optimistically” (if a super majority of the players are honest), the protocol “instantly” confirms transactions.</p>

    <p class="text-gray-300">We provide instantiations of this paradigm in both permissionless (using proof-of-work) and permissioned settings. Most notably, this yields a new blockchain protocol (for the permissionless setting) that remains resilient assuming only that a majority of the computing power is controlled by honest players, yet <em>optimistically</em>—if <span class="math">3/4</span> of the computing power is controlled by honest players, and a special player called the “accelerator”, is honest—transactions are confirmed as fast as the actual message delay in the network. We additionally show the <span class="math">3/4</span> optimistic bound is tight for protocols that are resilient assuming only an honest majority.</p>

    <p class="text-gray-300">4</p>

    <p class="text-gray-300">Contents</p>

    <p class="text-gray-300">1 Introduction 1 1.1 The Thunderella Paradigm 2 1.2 Related Work 7</p>

    <p class="text-gray-300">2 Definitions and Preliminaries 9 2.1 Execution Model 9 2.1.1 Modeling Protocol Execution 9 2.1.2 Constrained Execution Environments 11 2.1.3 Notations 12 2.2 State Machine Replication 13 2.3 Abstract Blockchain Protocols 13 2.3.1 Syntax and Security Definitions 14 2.3.2 Blockchain Implies State Machine Replication 16 2.4 Warmup: Blockchain Instantiations 16 2.4.1 Permissionless Environment 16 2.4.2 Permissioned, Classical Environment 17 2.4.3 Permissioned, Sleepy Environment 19 2.5 Preliminaries: Responsiveness and Optimistic Responsiveness 20 2.5.1 Responsiveness 20 2.5.2 “Bare Minimum” Optimistic Responsiveness 22</p>

    <p class="text-gray-300">3 Basic Thunderella Protocol with a Static Committee 25 3.1 Our Basic Protocol in a Nutshell 26 3.1.1 Optimistic Fast Path 26 3.1.2 Falling Back to the Blockchain 27 3.1.3 Initiating a New Optimistic Epoch 28 3.2 Detailed Protocol Description 29 3.2.1 Useful Definitions 29 3.2.2 <span class="math">\\Pi_{\\mathrm{thunder}}</span>: Core Protocol for Consistency 30 3.2.3 Concrete Chain-State Function and Worst-Case Liveness 32 3.2.4 Coordination Protocol <span class="math">\\Pi_{\\mathrm{ella}}</span> and Optimistic Responsiveness 33 3.3 Proofs for Basic Thunderella with Static Committee 35 3.3.1 Consistency 35 3.3.2 Worst-Case Liveness 37 3.3.3 Optimistic Responsiveness 37</p>

    <p class="text-gray-300">5</p>

    <p class="text-gray-300">4 Thunderella for Permissioned 41</p>

    <p class="text-gray-300">4.1 Permissioned, Classical Environments 41 4.2 Permissioned, Sleepy Environments 45 4.2.1 Practical Considerations for Consortium Blockchains 45</p>

    <p class="text-gray-300">5 Thunderella for Permissionless 49</p>

    <p class="text-gray-300">5.1 Thunderella with Robust Committee Reconfiguration 49 5.1.1 Protocol <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}</span>: Consistency and Worst-Case Liveness 50 5.1.2 Protocol <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span>: Optimistic Responsiveness 53 5.1.3 Proofs: Robust Committee Reconfiguration Framework 55</p>

    <p class="text-gray-300">5.2 Recent Blockchain Miners As Committee 58 5.2.1 Preliminary: Mildly Adaptive Corruptions 58 5.2.2 Preliminary: Committee Election in a Permissionless Environment 59 5.2.3 Detailed Protocol 61 5.2.4 Reward Distribution and Incentive Compatibility 62</p>

    <p class="text-gray-300">5.3 Recent Stake-Holders As Committee 62 5.3.1 Fair Committee Down-Selection and Incentive Compatibility 63</p>

    <p class="text-gray-300">5.4 Leader As an Acceleration Service 64</p>

    <p class="text-gray-300">Chapter 1 Introduction</p>

    <p class="text-gray-300">State machine replication, also referred to as atomic broadcast, is a core distributed systems abstraction that has been investigated for three decades. In a state machine replication protocol, a set of servers seek to agree on an ever-growing, linearly-ordered log, such that two important properties are satisfied: 1) consistency, i.e., all servers must have the same view of the log; and 2) liveness, i.e., whenever a client submits a transaction, the transaction is incorporated quickly into the log. In this paper, we will also refer to state machine replication as consensus for short.</p>

    <p class="text-gray-300">State machine replication is a fundamental building block for replicated databases. For more than a decade, companies such as Google and Facebook have deployed Paxos-style protocols <em>[6, 28, 34]</em> to replicate a significant part of their computing infrastructure. These classical deployment scenarios are typically relatively small scale, with fast local-area networking, where crash (rather than byzantine) faults are usually of concern.</p>

    <p class="text-gray-300">Fuelled by decentralized cryptocurrencies, recently the community has been excited about large-scale applications of distributed consensus. Two deployment scenarios are of interest: 1) the permissionless setting where anyone can join freely (e.g., decentralized cryptocurrencies); and 2) the permissioned setting where only approved participants may join (e.g., a consortium blockchain where multiple banks collaborate to build a distributed ledger). Regardless of which setting, the typical deployment would involve a large number of nodes (e.g., thousands or more) controlled by mutually distrustful individuals and organizations.</p>

    <p class="text-gray-300">Roughly speaking, two broad classes of protocols have been considered for the large-scale setting, each with their own set of deficiencies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, classical-style protocols such as PBFT <em>[13]</em> and Byzantine-Paxos <em>[34]</em> confirm transactions quickly in the normal case; but these protocols are notoriously complicated, making implementation, reconfiguration, and maintenance relatively difficult especially in a large-scale setting. Further, these protocols achieve “fast confirmation” by adopting the asynchronous (or partially synchronous) model, and thus inherently they can tolerate at most <span class="math">\\frac{1}{3}</span> corruptions <em>[19, 41]</em>.</li>

      <li>Second, blockchain-style protocols, represented by Nakamoto’s original blockchain <em>[23, 38, 39]</em>, are a new breakthrough in distributed consensus: these protocols are conceptually simple and tolerate minority corruptions. Moreover, it is has been shown how to remove the expensive proof-of-work from blockchain-style consensus <em>[15, 30, 43]</em> thus solving the energy waste problem. Further, not only has blockchains’ robustness been empirically proven, earlier works <em>[15, 43]</em> have</li>

    </ul>

    <p class="text-gray-300">also shown mathematically that blockchain-style consensus indeed achieves certain robustness properties in the presence of sporadic participation and node churn that none of the classical-style protocols can attain! Unfortunately known blockchain-style protocols suffer from slow transaction confirmation, e.g., Bitcoin’s Nakamoto consensus has a 10-minute block interval and it takes several blocks to confirm a transaction with sufficient confidence. Earlier works that mathematically analyze blockchain-style consensus <em>[39, 43]</em> have pointed out that such slowness is inherent for blockchain-style protocols since the expected block interval must be set to be sufficiently large for the protocol to retain security.</p>

    <p class="text-gray-300">A natural question that arises is whether there is some way to <em>simultaneously</em> reap the benefit of both of these “worlds”. Unfortunately, a negative answer was presented by earlier works <em>[41, 42, 43]</em> which showed that a natural notion of fast transaction confirmation called “responsiveness” is unattainable against <span class="math">\\frac{1}{3}</span> (even static) corruptions in classical or permissionless models. In this paper we consider a new notion called <em>optimistic responsiveness</em> that allows us “circumvent” this lower bound such that we can achieve responsiveness most of the time in practice and yet tolerate up to minority corruptions in the worst-case. In our approach, in the <em>optimistic case</em> (when e.g., a super majority is honest), we enjoy the fast nature of asynchronous protocols; and yet we retain the resilience of synchronous (e.g., blockchain) protocols as well as their robustness properties (e.g., support for sporadic participation). More precisely, we show how to combine a fast and simple “asynchronous path”—which guarantees consistency but not liveness—with a (slow) synchronous “fall-back” path which only gets executed if something goes wrong.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 The Thunderella Paradigm</h3>

    <p class="text-gray-300">To characterize what we mean by “fast” or “instant confirmation”, we adopt the same notion of <em>responsiveness</em> as proposed in the work by Attiya, Dwork, Lynch, and Stockmyer <em>[2]</em> and later adopted by others <em>[41, 27]</em>. A consensus protocol is said to be responsive iff any transaction input to an honest node is confirmed in time that depends only on the <em>actual network delay</em>, but not on any a-priori known <em>upper bound on the network delay</em>. Henceforth in this paper, we use <span class="math">\\delta</span> to denote the actual network delay and use <span class="math">\\Delta</span> to denote an a-priori known upper bound of the network’s delay where <span class="math">\\Delta</span> is possibly provided as input to the protocol.</p>

    <p class="text-gray-300">As shown in <em>[41]</em>, achieving responsiveness requires us to assume that <span class="math">2/3</span> of the players are honest. (Additionally, all known protocols that are responsive are very complicated, and thus hard to implement.)</p>

    <p class="text-gray-300">Towards overcoming this issue, we here instead consider a notion of optimistic responsiveness—where responsiveness is only required to hold whenever some “goodness conditions” are satisfies. More precisely, we consider two sets of conditions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>worst-case conditions (denoted <span class="math">W</span>) under which the protocol provides worst-case guarantees including consistency and “slow” confirmation (e.g., <span class="math">W</span> = majority honest).</li>

      <li>optimistic-case conditions (denoted <span class="math">O\\subseteq W</span>) under which the protocol additionally provides responsive confirmation (e.g., <span class="math">O=</span>“more than <span class="math">\\frac{3}{4}</span> are honest and online, and some designated player (the “leader”) is honest”).</li>

    </ul>

    <p class="text-gray-300">Our main result is a paradigm for taking any blockchain protocol (permissioned or permissionless) that satisfies consistency and liveness under conditions <span class="math">W</span>, and transform it into a new protocol that satisfies consistency and liveness under “essentially” the same conditions <span class="math">W</span> (and in many cases, actually the same conditions <span class="math">W</span>), and additionally satisfies optimistic responsiveness under condition <span class="math">O</span></p>

    <p class="text-gray-300">1.1. THE THUNDERELLA PARADIGM</p>

    <h5 id="sec-3" class="text-base font-semibold mt-4">The idea in a nutshell</h5>

    <p class="text-gray-300">To explain our approach, consider first the following simple protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We have a designated entity: the leader, or “accelerator”.</li>

      <li>Transactions are sent to the leader; the leader signs the transaction (with an increasing sequence number), and sends out the signed transaction to a “committee” of players.</li>

      <li>The committee members “ack” all leader-signed transactions, but at most one per sequence number.</li>

      <li>If a transaction has received more than 3/4 of the committees signatures—we refer to such a transaction as being notarized. Participants, can <em>directly output</em> their longest sequence of consecutive (in terms of their sequence numbers) notarized transactions—all those transactions are confirmed.</li>

    </ul>

    <p class="text-gray-300">It is not hard to see that this protocol is consistent under condition <span class="math">W^{\\prime}=</span> “1/2 the committee is honest”); additionally, it satisfies liveness with optimistic responsiveness under condition <span class="math">O=</span> “leader is honest, and 3/4 of the committee is honest”. In fact, under these optimistic condition, we only need 2 communication rounds to confirm a transaction! This approach is extremely practical and indeed this protocol is often used in practice—for instance chain.com use something very similar as their permissioned blockchain (and manage to handle a very high volume of transactions with fast confirmations).</p>

    <p class="text-gray-300">The problem with this approach, however, is that the protocol does not satisfy liveness (even “slow” liveness) under condition <span class="math">W^{\\prime}</span>. If the leader is cheating (or is simply taken down from the network), the protocol halts. (Indeed, in this case chain.com resorts to manually fixing the issue.)</p>

    <p class="text-gray-300">To overcome this problem, we leverage the underlying (slow) blockchain protocol, which satisfies both consistency and liveness under <span class="math">W=</span> “honest majority of players”. Roughly speaking, if players notice that transactions are not getting confirmed by the leader/committee, some “evidence” of this is sent to the underlying blockchain. We then enter a “cool-down” period, where committee members stop signing messages from the leader, yet we allow players to broadcast any notarized transactions they have seen so far. The length of the cool-down period is counted in blocks on the underlying blockchain (say <span class="math">\\kappa</span> blocks where <span class="math">\\kappa</span> is a security parameter). Finally, after the cool-down period ends, we can safely enter a “slow period” where transactions only get confirmed in the underlying blockchain. We can next use the blockchain to switch out the leader (if needed) and begin a new epoch of the optimistic protocol.</p>

    <p class="text-gray-300">Let us point out the reason for having a cool-down period: without it, players may disagree on the set of transactions that have been confirmed before entering the “slow mode”, and thus may end up with inconsistent views. The cool-down period enables honest players to post all notarized transactions they have seen to the (slow) underlying blockchain, and thus (slowly) reach consistency of this set of transactions; once we have reached this consistent view (at the end of the cool-down), we can finally fully switch over to confirming new transactions on the blockchain.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Collecting evidence of cheating</h5>

    <p class="text-gray-300">It only remains to explain how to collect evidence that the leader (and/or committee) is cheating or is simply “unavailable”. This turns out to also be simple: if a player notices that his transaction is not getting confirmed by the leader or committee, he can send the transaction to the underlying blockchain. The leader is additionally instructed to confirm all transactions it sees on the blockchain.</p>

    <p class="text-gray-300">Now, if players see some transaction on the blockchain, that has not gotten notarized within a sufficiently long amount of time—counted in blocks in the underlying blockchains (say within <span class="math">n</span></p>

    <p class="text-gray-300">blocks)—they know that the leader/committee must be cheating/unavailable, and thus should enter the cool-down period. (Note that as long as the leader can confirm transactions before <span class="math">n</span> blocks are created on the underlying blockchain, he cannot be “falsely accused”; and, by the security of the underlying blockchains those blocks cannot be created too fast).</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Selecting the committee</h5>

    <p class="text-gray-300">So far we have constructed a protocol that satisfies consistency and liveness under conditions <span class="math">W\\cap W^{\\prime}</span> (i.e., assuming an honest majority of players, and an honest majority in the committee), and additionally satisfies liveness with optimistic responsiveness under condition <span class="math">O</span>. The question now is how to select the committee. We consider two different approaches:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Using all players as the committee: In a permissioned setting, the simplest approach is to simply use all players as the committee. In this case, <span class="math">W^{\\prime}=W</span> and thus, we trivially have resilience under <span class="math">W</span>. A variant of this approach with improved communication complexity is to subsample a committee among the set of players (for instance, using the approach in <em>[15]</em> which additionally requires a random oracle), and change committees on a regular basis (to ensure adaptive security)—the resulting protocol, however, will only be secure if corruptions are “slow” (to ensure the attacker does not have time to corrupt the whole committee before it gets switched out.) If sub-sampling is instead done “secretly” using a VRF and a random oracle (as in <em>[36]</em>), we can also ensure that the resulting protocol is adaptively secure <em>in a model with erasures</em>, even with “instantaneous corruption”.</li>

    </ul>

    <p class="text-gray-300">We mention that these approaches may also be used in the permissionless setting if Thunderella is used to construct a crypto currency: then we can use (potentially a sub-sample of) recent “stakeholders” to form a committee.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Using “recent miners” as the committee: A different approach that works in both the permissioned and permissionless setting is to select the committee as the miners of recent blocks (as was done in <em>[41]</em>). We note, however, that to rely on this approach, we need to ensure that the underlying is blockchain is “fair” <em>[40]</em> in the sense that the fraction of honestly mined blocks is close to the fraction of honest players. This is not the case for Nakamoto’s original blockchain (see e.g., <em>[21]</em>), but as shown in <em>[40]</em>, any blockchain can be turned into a fair one. If we use this approach, the resulting protocol will now be consistent and live under simply the condition <span class="math">W</span> (i.e., honest majority), yet also satisfy optimistic liveness under condition <span class="math">O</span>. (Again, this only gives security under adaptive corruption where corruption is “slow”, so the set of recent miners changes sufficiently fast before they can all be corrupted.)</li>

    </ul>

    <h5 id="sec-6" class="text-base font-semibold mt-4">Permissionless Thunderella</h5>

    <p class="text-gray-300">For instance, if we apply the second approach (of selecting the committee as the recent miners) to Nakamoto’s proof-of-work based blockchain, we get the following theorem:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1 (Thunderella for permissionless environments, informal).</h6>

    <p class="text-gray-300">Assume a proof-of-work random oracle. Then, there exists a state machine replication protocol that achieves consistency and (non-responsive) liveness in a permissionless environment as long as the adversary wields no more than <span class="math">\\frac{1}{2}-\\epsilon</span> the total online computation power in every round where <span class="math">\\epsilon</span> is an arbitrarily small constant, and moreover it takes a short while for the adversary to adaptively corrupt nodes. Moreover, if more than <span class="math">\\frac{3}{4}</span> of the online computation power is honest and online, then the protocol achieves responsiveness (after a short non-responsive warmup period) in any “epoch” in which the leader is honest and online.</p>

    <p class="text-gray-300">1.1. THE THUNDERELLA PARADIGM</p>

    <p class="text-gray-300">Permissioned Thunderella Similar theorems can be shown for permissioned environments (in e.g., the “sleepy model” of <em>[43]</em>, or even just in the “classic” model of Dolev-Strong <em>[18]</em>.)</p>

    <p class="text-gray-300">The classical mode is essentially the standard synchronous model adopted by the existing distributed systems and cryptography literature. In this model, all nodes are spawned upfront, and their identities and public keys are provided to the protocol as input; further, crashed nodes are treated as faulty and count towards the corruption budget. In a classical, synchronous network, we show that the classical Dolev-Strong byzantine agreement protocol <em>[18]</em> can be extended to implement Thunderella’s underlying “blockchain”. In this case, our Thunderella paradigm (where use the first approach to instantiate the committee) gives rise to the following informal theorem:</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 2 (Thunderella for permissioned, classical environments (informal)).</h6>

    <p class="text-gray-300">Assume the existence of a PKI and one-way functions. There exists a state machine replication protocol that achieves consistency and (non-responsive) liveness in a classical environment under any <span class="math">f&amp;lt;n</span> number of fully adaptive, byzantine corruptions where <span class="math">n</span> denotes the total number of nodes; moreover, the protocol achieves responsiveness as long as the leader is honest and moreover <span class="math">\\lfloor\\frac{n+f}{2}+1\\rfloor</span> nodes are honest.</p>

    <p class="text-gray-300">The “sleepy” model was recently proposed by Pass and Shi <em>[43]</em> to capture the requirements arising from “sporadic participation” in large-scale, permissioned consensus. Specifically, the sleepy model was in fact inspired by permissionless decentralized cryptocurrencies such as Bitcoin, where nodes may come and go frequently during the protocol, and the protocol should nonetheless guarantee consistency and liveness even for players that join late, and for players who might have had a short outage and woke up later to rejoin the protocol.</p>

    <p class="text-gray-300">The sleepy model is “permissioned” in nature in that the set of approved protocol participants and their public keys are a-priori known and provided to the protocol as input. However, unlike the classical setting, 1) nodes are allowed to be non-participating (i.e., sleeping); 2) sleeping nodes are not treated as faulty; and 3) the protocol may not know in advance how many players will actually show up. In comparison, in a classical setting, non-participating nodes are regarded as having crashed and count towards the corruption budget; and moreover a classical protocol need not guarantee consistency and liveness for nodes that have crashed but wake up later to rejoin.</p>

    <p class="text-gray-300">In such a sleepy model, Pass and Shi <em>[43]</em> show that roughly speaking, we can achieve consensus when the majority of online (i.e., non-sleeping) nodes are honest (interestingly, unlike the classical synchronous model, <em>[43]</em> also prove that no state machine replication protocol can tolerate more than <span class="math">\\frac{1}{2}</span> corruption (among online nodes).</p>

    <p class="text-gray-300">Our Thunderella paradigm (again using the first approach for selecting the committee) can be instantiated in the sleepy model using the sleepy consensus protocol as the underlying blockchain. This gives rise to the following informal theorem in a sleepy environment (where we assume that the adversary can adaptively put honest nodes to sleep).</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Theorem 3 (Thunderella for permissioned, sleepy environments (informal)).</h6>

    <p class="text-gray-300">Assume the existence of a PKI, enhanced trapdoor permutations, and a common reference string (CRS). There exists a state machine replication protocol that achieves consistency and (non-responsive) liveness in a sleepy environment with static corruptions, as long as <span class="math">\\frac{1}{2}-\\epsilon</span> of the online nodes are honest in every round for any arbitrarily small constant <span class="math">\\epsilon</span>; moreover, if more than <span class="math">\\frac{3}{4}</span> fraction of nodes are honest and online, the protocol achieves responsiveness (after a short non-responsive warmup period) in any epoch in which leader is honest and online.</p>

    <p class="text-gray-300">In fact, the above theorem also extends to adaptive corruptions with erasures using the adap</p>

    <p class="text-gray-300">tively secure version of sleepy consensus <em>[43]</em> as Thunderella’s underlying blockchain, assuming the existence of a VRF and a random oracle (using the approach from <em>[36]</em>).</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">Lower bounds on the optimistic honest threshold</h5>

    <p class="text-gray-300">We additionally prove that our optimistic bound of <span class="math">3/4</span> is tight: no protocol that is (worst-case) resilient for simply an honest majority, can be optimistically responsive when more than <span class="math">1/4</span> of the player can be corrupted.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Practical Considerations: Instant Confirmation and Scalability</h5>

    <p class="text-gray-300">The <em>low latency</em> and <em>poor scalability</em> of Nakamoto’s blockchain protocol are typically viewed as the main bottlenecks for Bitcoin as well as other cryptocurrencies.</p>

    <p class="text-gray-300">Our paradigm provides a very practical and simple approach for overcoming these issue. The Thunderella paradigm shows how to build on top of currently running blockchains, to enable “optimistic instant confirmation” of transactions. Additionally, note that in our protocol, players only need to send transactions to the leader, who in turn lead the committee to confirm the transaction. Most notably, the underlying blockchain is essentially only used when something goes wrong, and blocks need not be distributed to the whole network before getting confirmed; thus, Thunderella also solves the scalability issue with Nakamoto’s blockchain protocol. Of course, both of these guarantees are only “optimistic”— but arguably, under normal circumstances one would expect <span class="math">3/4</span> of the players to act honestly, and the leader could be incentivized (paid) to perform its job (and if it doesn’t, will be kicked out). Thus, we believe our approach is a practically viable approach for circumventing the main bottlenecks of today’s cryptocurrencies.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Comparison.</h5>

    <p class="text-gray-300">At the surface, our idea is reminiscient of classical-style protocols such as PBFT and Byzantine-Paxos. In particular, protocols like PBFT also have a very simple normal path that consists of <span class="math">O(1)</span> rounds of voting. However, when the normal path gets stuck, PBFT-style protocols fall back to a “view change” mechanism that is also responsive—and thus these protocols tolerate only <span class="math">\\frac{1}{3}</span> corruptions in the worst-case, and are invariably complex due to the need to handle asynchrony. (Furthermore, this approach is not amenable for protocols in the permissionless setting). Our key insight is to instead fall back to a synchronous path in the worst case, thus allowing us to circumvent the <span class="math">\\frac{1}{3}</span> lower bound for partial synchrony and yet still be responsive in practice most of the time. Moreover, since our protocol is fundamentally synchronous, we benefit from the simplicity and robustness enjoyed by synchronous protocols (e.g., blockchains).</p>

    <p class="text-gray-300">Interestingly, Thunderella is also a constant factor faster in the fast path than most PBFT- or Paxos-style protocols. PBFT-style protocols typically require multiple rounds of voting even in the normal path (<em>c.f.</em> Thunderella has exactly one) — and the latter rounds are necessary to prepare for the possibility of a view change. Although it is possible to compress the normal path to a single round of voting, this is typically achieved either by sacrificing resilience (e.g., tolerating only <span class="math">\\frac{1}{5}</span> corruptions) <em>[45]</em> or by adding yet another optimistic layer on top of the normal path — thus further complicating the already complex protocol <em>[33]</em>.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Roadmap</h5>

    <p class="text-gray-300">In this extended abstract, we simply provide a description and proof of the general Thunderella paradigm (informally described above) assuming the existence of a fixed committee, a majority of which is honest. We defer the formal treatment of how to select the committee to the supplemental material (although we described it informally above).</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <h5 id="sec-15" class="text-base font-semibold mt-4">State machine replication: classical and blockchain-style approaches.</h5>

    <p class="text-gray-300">State machine replication or atomic broadcast (referred to as consensus for short in this paper) is a central abstraction of distributed systems, and has been extensively investigated and widely adopted in real-world systems. Roughly speaking, there are two, technically speaking, fundamentally different approaches towards realizing state machine replication, classical-style consensus <em>[13, 18, 19, 29, 34, 35]</em>, and blockchain-style consensus <em>[15, 23, 30, 38, 39, 43]</em>. For a while, it has been vaguely understood by the community that blockchain-style protocols and classical ones achieve different properties — but the community has only recently begun to formally understand and articulate these differences.</p>

    <p class="text-gray-300">The recent work by Pass and Shi <em>[43]</em> point out one fundamental difference between classical style and blockchain-style consensus. Most classical protocols <em>[13, 18, 19, 29, 34, 35]</em>, synchronous and asynchronous ones alike, rely on nodes having collected sufficiently many votes to make progress; thus these protocols would fail in a model where participation is sporadic and the exact number of players that do show up cannot be predicted upfront. More specifically, classical models of consensus would pessimistically treat nodes that do not show up as faulty (also referred to as crash fault); and if too many nodes do not show up, the protocol fails to make progress. In comparison, blockchain-style protocols can make progress regardless of how many players actually show up. Moreover, blockchain-style consensus has also been shown to be secure in a setting where the number of players can vary over time <em>[22]</em>.</p>

    <p class="text-gray-300">Classical deployments of consensus protocols are typically in a relatively small-scale and permissioned setting. Consensus in the permissionless setting was first empirically demonstrated to be possible due to Bitcoin’s ingenious Nakamoto blockchain <em>[38]</em>. While the original Nakamoto blockchain relies on proofs-of-work to solve the Sybil attack in the permissionless setting, other proposals have been suggested since then for securely establishing identities in a permissionless setting — for example, proof-of-stake <em>[3, 4, 8, 14, 15, 30, 31, 36, 44]</em> is a most-oft cited approach where the stake-holders of a cryptocurrency system are responsible for voting on transactions. Recent works <em>[36]</em> have also explored adopting classical style consensus in a permissionless setting where approaches such as proof-of-stake can be used to establish identities.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Other closely related works.</h5>

    <p class="text-gray-300">Our work is also reminiscent of recent works that combine classical consensus and blockchains <em>[16, 32, 41]</em> although these works are of a different nature as we explain below. Among these works, Hybrid Consensus <em>[41]</em> is the only known formally correct approach, and moreover the only known approach that achieves responsiveness. From a theoretical perspective, our results are incomparable to Hybrid Consensus: we tolerate up to <span class="math">\\frac{1}{2}</span> corruption in the worst-case and offer responsiveness only in the optimistic case but not in the worst case; in comparison, Hybrid Consensus achieves responsiveness even in the worst case — but in exchange, their protocol can only tolerate up to <span class="math">\\frac{1}{3}</span> corruption, and this turns out to be inherent for any worst-case responsive protocol even when assuming proof-of-work <em>[19, 41]</em>. From a practical perspective, Thunderella is more likely to be the protocol of choice in a real-world implementation partly due to its simplicity — in comparison, Hybrid Consensus requires a full-fledged classical protocol such as PBFT and Byzantine Paxos as a subroutine, and thus inherits the complexity of these protocols.</p>

    <p class="text-gray-300">A line of research <em>[12, 17, 20, 25, 26, 37]</em> has investigated Byzantine agreement protocols capable of early-stopping when conditions are more benign than the worst-case faulty pattern: e.g., the actual number of faulty nodes turns out to be smaller than the worst-case resilience bound. However, these works are of a different nature than ours as we explain below. First, these earlier works focus on stopping in a fewer number of synchronous rounds, and it is not part of their goal to achieve responsiveness. Second, although some known lower bounds <em>[17]</em> show that the number of actual</p>

    <p class="text-gray-300">rounds must be proportional to the actual number of faulty processors — note that these lower bounds work only for deterministic protocols, and thus they are not applicable in our setting.</p>

    <p class="text-gray-300">Finally, the idea of combining asynchrony and synchrony was described in earlier works <em>[5]</em>; other works have also proposed frameworks for composing multiple BFT protocols <em>[24]</em>. However, to the best of our knowledge, none of the earlier works combined a synchronous fallback path and an asynchronous optimistic path in the manner that we do, allowing us to tolerate more than <span class="math">\\frac{1}{3}</span> corruptions in the worst-case while still be responsive most of the time in practice.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Relevance to Ethereum’s current efforts.</h5>

    <p class="text-gray-300">Ethereum <em>[47]</em>, the second largest decentralized cryptocurrency immediately following Bitcoin <em>[38]</em>, has investigated significant resources in developing the next-generation proof-of-stake consensus protocol <em>[8]</em>. Instead of immediately dispensing with proof-of-work, Ethereum seems to have devised a two-stage agenda, where, in an initial transitional stage, voting by stake-holders and proof-of-work will co-exist — see the recent online blog-post by Vitalik Buterin <em>[7]</em>. Specifically, stake-holders will vote on transactions or blocks atop their existing proof-of-work blockchain. Vitalik Buterin’s blog-post then proposes a set of “minimal slashing conditions” <em>[7]</em> to penalize voters that behave maliciously (e.g., those who cast equivocating votes). However, it is not Ethereum’s goal to achieve optimistic instant confirmation <em>[1]</em>.</p>

    <p class="text-gray-300">Others have also tried to achieve instant finality in blockchains <em>[46]</em> — however, to date there is no provably secure approach, and some folklore approaches even appear flawed.</p>

    <p class="text-gray-300">Chapter 2 Definitions and Preliminaries</p>

    <p class="text-gray-300">Since we would like to capture what the Thunderella paradigm can achieve in various settings including permissionless and permissioned, we adopt the following modeling approach. We first describe a general execution model that is capable of expressing an unconstrained permissionless setting. We then express permissioned settings including classical and sleepy environments as additional constraints that the adversary must respect.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.1 Execution Model</h3>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">2.1.1 Modeling Protocol Execution</h4>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Interactive Turing Machines.</h5>

    <p class="text-gray-300">We adopt the standard Interactive Turing Machines (ITM) approach to model protocol execution <em>[9, 10, 11]</em>. A protocol refers to an algorithm for a set of interactive Turing Machines (also called nodes) to interact with each other. The execution of a protocol <span class="math">\\Pi</span> that is directed by an environment <span class="math">\\mathcal{Z}(1^{\\kappa})</span> (where <span class="math">\\kappa</span> is a security parameter), which activates a number of nodes as either honest or corrupt nodes. Honest nodes would faithfully follow the protocol’s prescription, whereas corrupt nodes are controlled by an adversary <span class="math">\\mathcal{A}</span> which reads all their inputs/message and sets their outputs/messages to be sent.</p>

    <p class="text-gray-300">The environment <span class="math">\\mathcal{Z}</span> is a term often used in protocol composition in the cryptography literature <em>[9, 10, 11]</em> — one can regard the environment <span class="math">\\mathcal{Z}</span> a catch-all term that encompasses everything that lives outside the “box” defined by the protocol. For example, as mentioned later, part of the environment <span class="math">\\mathcal{Z}</span>’s job is to provide inputs to honest nodes and receive outputs from them. This models the fact that the inputs to the protocol may originate from external applications and the protocol’s outputs can be consumed by external applications where any external application or other protocols running in the system are viewed as part of <span class="math">\\mathcal{Z}</span>.</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Round-based execution.</h5>

    <p class="text-gray-300">A protocol’s execution proceeds in rounds that model atomic time steps. Henceforth, we use the terms round and time interchangeably. At the beginning of every round, honest and online nodes receive inputs from an environment <span class="math">\\mathcal{Z}</span>; at the end of every round, honest and online nodes send outputs to the environment <span class="math">\\mathcal{Z}</span>.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Corruption model.</h5>

    <p class="text-gray-300">In the standard distributed systems or cryptography literature, crashed nodes are often treated as faulty and count towards the corruption budget. In this paper, we we distinguish crashed nodes (also referred to as sleeping nodes) and corrupt nodes. An honest node may have a short-term or long-term outage during which it is not able to participate in the</p>

    <p class="text-gray-300">protocol. However, such a crashed node is not in the control of the adversary — in this case we do not attribute this node as corrupt. Informally, we often refer to the set of honest nodes that have not crashed as being online. We also consider all corrupt nodes as being online (since this gives the adversary more advantage).</p>

    <p class="text-gray-300">We stress that the motivation for not treating crashed nodes as corrupt is to allow us to prove a more powerful theorem: our Thunderella paradigm ensures consistency and worst-case liveness when <span class="math">\\alpha</span> fraction of the committee are honest but not necessarily online (and assuming that the underlying blockchain is secure). In particular, as we noted, <span class="math">\\alpha</span> can be as small as a single member of the committee — but in this case the conditions necessary for instant confirmation are somewhat more stringent (i.e., all committee members must be honest and online for instant confirmation). In a more traditional model where crash is treated as corrupt, all of our theorems still apply — except that “honest” would equate to “honest and online”.</p>

    <p class="text-gray-300">More formally, in our model, the environment <span class="math">\\mathcal{Z}</span> controls when nodes are spawned, corrupted, put to sleep, or waken up:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any time during the protocol execution, the environment <span class="math">\\mathcal{Z}</span> can spawn new nodes, and newly spawned nodes can either be honest or corrupt. The adversary <span class="math">\\mathcal{A}</span> has full control of all corrupt nodes.</li>

      <li>At any time during the protocol execution, <span class="math">\\mathcal{Z}</span> can issue a corrupt instruction to an honest (and possibly sleeping) node. When this happens, its internal states are exposed to <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{A}</span> henceforth controls the node.</li>

      <li>At any time during the protocol execution, <span class="math">\\mathcal{Z}</span> can issue a sleep instruction to an honest node. When this happens, the node immediately becomes asleep (or sleeping), and it stops sending and receiving protocol messages and performing any computation. Sleeping is similar to the notion of a crash fault in the classical distributed systems terminology. In our paper, though, we treat sleeping nodes as being honest rather than attributing them towards the faulty budget.</li>

      <li>At any time during the protocol execution, <span class="math">\\mathcal{Z}</span> can issue a wake instruction to an honest, sleeping node. At this point, this node immediately wakes up and continues to participate in the protocol. When an honest, sleeping node wakes up, pending messages that the node should have received while sleeping and additionally some adversarialy inserted messages may be delivered to the waking node.</li>

      <li>At any time during the protocol execution, <span class="math">\\mathcal{Z}</span> can issue a kill instruction to a corrupt node. At this point, the corrupt node is removed from the protocol execution and is no longer considered as an online node — but note that the adversary <span class="math">\\mathcal{A}</span> still knows the internal states of a killed node prior to its being killed.</li>

    </ul>

    <p class="text-gray-300">Formally, we use the terminology online nodes to refer to the set of nodes that are i) either honest and not sleeping; or ii) corrupt but not having been killed.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Communication model.</h4>

    <p class="text-gray-300">We assume that honest and online nodes can send messages to all other honest and online nodes. The adversary <span class="math">\\mathcal{A}</span> is in charge of scheduling message delivery. <span class="math">\\mathcal{A}</span> cannot modify the contents of messages broadcast by honest nodes, but it can reorder and delay messages sent by honest and online nodes, possibly subject to constraints on the maximum delays to be defined later. The adversary <span class="math">\\mathcal{A}</span> is allowed to send messages to a subset of honest and online nodes but not all of them. The identity of the sender is not known to the recipient.</p>

    <p class="text-gray-300">2.1. EXECUTION MODEL</p>

    <p class="text-gray-300">Formally, we say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> <em>respects <span class="math">\\Delta</span>-bounded delay</em> iff <span class="math">\\mathcal{Z}</span> inputs <span class="math">\\Delta</span> to all honest nodes when they are spawned, and moreover the following holds:</p>

    <p class="text-gray-300"><em><span class="math">\\Delta</span>-bounded delay</em>. Suppose an honest (and online) node sends a message at time <span class="math">t</span>, then in any round <span class="math">r\\geq t+\\Delta</span>, any honest node that is online in round <span class="math">r</span> will have received the message, including nodes that may possibly have been sleeping but just woke up in round <span class="math">r</span>, as well as nodes which may have just been spawned at the beginning of round <span class="math">r</span>.</p>

    <p class="text-gray-300">Throughout this paper, we assume that <span class="math">\\mathcal{Z}</span> inputs the maximum delay parameter <span class="math">\\Delta</span> to all honest nodes upon spawning (as noted in the above definition of <span class="math">\\Delta</span>-bounded delay) — this means that the protocol has a-priori knowledge of an upper bound on the network’s maximum delay. This is akin to the synchronous communication model in the classical distributed systems literature.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">2.1.2 Constrained Execution Environments</h4>

    <p class="text-gray-300">Our execution model defined thus far is meant to be general. Later in the paper, sometimes we would like to say that a protocol retains security as long as <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects certain constraints. We will model various assumptions as constraints on <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 1 (<span class="math">(n,\\rho,\\Delta)</span>-permissionless environments).</h6>

    <p class="text-gray-300">We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,\\rho,\\Delta)</span>-permissionless execution w.r.t. some protocol <span class="math">\\Pi</span> iff for every <span class="math">\\kappa\\in\\mathbb{N}</span> and every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there are exactly <span class="math">n</span> online nodes in each round among which at most <span class="math">\\rho n</span> are corrupt;</li>

      <li><span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">\\Delta</span>-bounded delay; and</li>

      <li><span class="math">\\mathcal{Z}</span> informs all honest nodes of the parameters <span class="math">(n,\\rho,\\Delta)</span> upon spawning.</li>

    </ul>

    <p class="text-gray-300">Whenever the context is clear, we often omit writing “w.r.t. which protocol” without risk of ambiguity.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Corruption constraints.</h5>

    <p class="text-gray-300">Our general model by default allows adaptive corruptions; however, for protocols that retain security only under static corruption, we will model static corruption as constraints on <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects static corruption w.r.t. to some protocol <span class="math">\\Pi</span> iff for every <span class="math">\\kappa</span>, for every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, <span class="math">\\mathcal{Z}</span> never issues corrupt to an honest node after spawning (although <span class="math">\\mathcal{Z}</span> is allowed to spawn corrupt nodes directly).</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Permissioned model.</h5>

    <p class="text-gray-300">Similarly, our general execution model can capture permissionless environments where nodes can join and leave the protocol at any time, and there is no a-priori knowledge of the number of nodes. However, whenever we are concerned about the permissioned setting, we can express “permissioned” execution environments also as additional constraints on <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. Specifically, in a permissioned setting, we require that <span class="math">\\mathcal{Z}</span> spawn all nodes upfront and inform all honest nodes the identities of all nodes spawned; further, <span class="math">\\mathcal{Z}</span> is not allowed to issue kill instructions. Henceforth without loss of generality, we may assume that the spawned nodes have identities <span class="math">0,1,\\ldots,n-1</span> respectively. We will distinguish two types of permissioned execution environments:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the permissioned-sleepy environment, <span class="math">\\mathcal{Z}</span> can make nodes sleep — this way, we can treat crashed nodes not under adversarial control differently from corrupt nodes that are under adversarial control. Such a “sleepy” model was first considered in a recent work by Pass and Shi *[43]</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the permissioned-classical environment, <span class="math">\\mathcal{Z}</span> is not allowed to issue sleep or wake instructions — and thus the model here is akin to that considered in the classical distributed computing literature (in this case “honest” and “honest and online” are the same).</li>

    </ol>

    <p class="text-gray-300">We now defined permissioned-sleepy and permissioned-classical environments more formally.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 2 (Permissioned, sleepy environments).</h6>

    <p class="text-gray-300">We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,\\rho,\\Delta)</span>-sleepy execution w.r.t. some protocol <span class="math">\\Pi</span> iff for every <span class="math">\\kappa\\in\\mathbb{N}</span> and every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following hold: 1) <span class="math">\\mathcal{Z}</span> spawns a set of numbered <span class="math">0,1,2,\\ldots,n-1</span> (for some <span class="math">n</span>) upfront prior to the start of protocol execution, and never spawns additional nodes later; 2) in every round, at most <span class="math">\\rho</span> fraction of the online nodes are honest; 3) <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">\\Delta</span>-bounded message delay; 4) <span class="math">\\mathcal{Z}</span> does not issue kill instructions; and 5) <span class="math">\\mathcal{Z}</span> informs all honest nodes of the parameters <span class="math">(n,\\rho,\\Delta)</span> upon spawning.</p>

    <p class="text-gray-300">Henceforth when the context is clear, we often say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,\\rho,\\Delta)</span>-sleepy execution omitting which protocol <span class="math">\\Pi</span> we refer to.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 3 (Permissioned, classical environments).</h6>

    <p class="text-gray-300">We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,f,\\Delta)</span>-classical execution w.r.t. some protocol <span class="math">\\Pi</span> iff for every <span class="math">\\kappa\\in\\mathbb{N}</span> and every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following hold: 1) <span class="math">\\mathcal{Z}</span> spawns a set of numbered <span class="math">0,1,2,\\ldots,n-1</span> (for some <span class="math">n</span>) upfront prior to the start of protocol execution, and never spawns additional nodes later; 2) <span class="math">\\mathcal{Z}</span> never issues sleep, wake, or kill instructions; 3) <span class="math">\\mathcal{Z}</span> corrupts at most <span class="math">f</span> nodes; 4) <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">\\Delta</span>-bounded message delay; and 5) <span class="math">\\mathcal{Z}</span> informs all honest nodes of the parameters <span class="math">(n,f,\\Delta)</span> upon spawning.</p>

    <p class="text-gray-300">Henceforth when the context is clear, we often say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,f,\\Delta)</span>-classical execution omitting which protocol <span class="math">\\Pi</span> we refer to. Note that in a permissioned-classical environment, all nodes are online since <span class="math">\\mathcal{Z}</span> cannot issue sleep instructions; and thus “honest” and “honest and online” are equivalent.</p>

    <p class="text-gray-300">Besides these typical constraints on <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, later we can also define protocol-specific constraints on <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">2.1.3 Notations</h4>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Notations for randomized execution.</h5>

    <p class="text-gray-300">A protocol’s execution is randomized, where the randomness comes from honest nodes, the adversary denoted <span class="math">\\mathcal{A}</span> that controls all corrupt nodes, the environment <span class="math">\\mathcal{Z}</span> that sends inputs to honest nodes during the protocol execution, and possibly the random oracle if the protocol adopts one.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use the notation <span class="math">\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span> to denote a randomly sampled execution trace, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of rounds in the execution trace </span>\\mathsf{view}<span class="math">. More specifically, </span>\\mathsf{view}$ is a random variable denoting the joint view of all nodes (i.e., all their inputs, random coins and messages received, including those from the random oracle) in the above execution; note that this joint view fully determines the execution.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Additional notational conventions.</h5>

    <p class="text-gray-300">We use the notation <span class="math">\\kappa</span> to denote the security parameter. Unless otherwise stated, all variables appearing in the paper are implicitly polynomially bounded (or inverse polynomially bounded) functions of <span class="math">\\kappa</span> (and possibly of other variables). If some variable is not a function of <span class="math">\\kappa</span>, we will explicitly declare it as a constant for clarity.</p>

    <p class="text-gray-300">2.2 State Machine Replication</p>

    <p class="text-gray-300">State machine replication has been a central abstraction in the 30 years of distributed systems literature. In a state machine replication protocol, a set of nodes seek to agree on an ever-growing log over time. We require two critical security properties: 1) <em>consistency</em>, i.e., all honest nodes’ logs agree with each other although some nodes may progress faster than others; 2) <em>liveness</em>, i.e., transactions received by honest nodes as input get confirmed in all honest nodes’ logs quickly. We now define what it formally means for a protocol to realize a “state machine replication” abstraction.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Syntax.</h5>

    <p class="text-gray-300">In a state machine replication protocol, in every round, an honest and online node receives as input a set of transactions txs from <span class="math">\\mathcal{Z}</span> at the beginning of the round, and outputs a LOG collected thus far to <span class="math">\\mathcal{Z}</span> at the end of the round.</p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Security definitions.</h5>

    <p class="text-gray-300">Let <span class="math">T_{\\text{confirm}}(\\kappa,n,\\rho,\\Delta,\\delta)</span> and <span class="math">T_{\\text{warmup}}(\\kappa,n,\\rho,\\Delta,\\delta)</span> be polynomial functions in the security parameter <span class="math">\\kappa</span> and possibly other parameters of the view such as the number of nodes <span class="math">n</span>, the corrupt fraction <span class="math">\\rho</span>, the actual maximum network delay <span class="math">\\delta</span>, the network delay upper bound <span class="math">\\Delta</span> that is provided by <span class="math">\\mathcal{Z}</span> to the protocol as input, etc.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 4 (Security of a state machine replication protocol).</h6>

    <p class="text-gray-300">We say that a state machine replication protocol <span class="math">\\Pi</span> satisfies consistency (or <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}})</span>-liveness resp.) w.r.t. some <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, iff there exists a negligible function <span class="math">\\textsf{negl}(\\cdot)</span>, such that for any <span class="math">\\kappa\\in\\mathbb{N}</span>, except with <span class="math">\\textsf{negl}(\\kappa)</span> probability over the choice of <span class="math">\\textsf{view}\\leftarrow\\textsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, consistency (or <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}})</span>-liveness resp.) is satisfied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Consistency</em>: A view satisfies consistency iff the following holds:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Common prefix</em>. Suppose that in view, an honest node <span class="math">i</span> outputs LOG to <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, and an honest node <span class="math">j</span> outputs <span class="math">\\textsf{LOG}^{\\prime}</span> to <span class="math">\\mathcal{Z}</span> at time <span class="math">t^{\\prime}</span> (<span class="math">i</span> and <span class="math">j</span> may be the same or different), it holds that either <span class="math">\\textsf{LOG}\\prec\\textsf{LOG}^{\\prime}</span> or <span class="math">\\textsf{LOG}^{\\prime}\\prec\\textsf{LOG}</span>. Here the relation <span class="math">\\prec</span> means “is a prefix of”. By convention we assume that <span class="math">\\emptyset\\prec x</span> and <span class="math">x\\prec x</span> for any <span class="math">x</span>.</li>

      <li><em>Self-consistency</em>. Suppose that in view, a node <span class="math">i</span> is honest and online at time <span class="math">t</span> and <span class="math">t^{\\prime}\\geq t</span>, and outputs LOG and <span class="math">\\textsf{LOG}^{\\prime}</span> at times <span class="math">t</span> and <span class="math">t^{\\prime}</span> respectively, it holds that <span class="math">\\textsf{LOG}\\prec\\textsf{LOG}^{\\prime}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Liveness</em>: A view satisfies <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}})</span>-liveness iff the following holds: if in some round $T_{\\text{warmup}}<t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-T_{\\text{confirm}}<span class="math">, some node honest and online in round </span>t<span class="math"> either received from </span>\\mathcal{Z}<span class="math"> an input set txs that contains some transaction </span>\\mathsf{m}<span class="math"> or has </span>\\mathsf{m}<span class="math"> in its output log to </span>\\mathcal{Z}<span class="math"> in round </span>t<span class="math">, then, for any node </span>i<span class="math"> honest and online at any time </span>t^{\\prime}\\geq t+T_{\\text{confirm}}<span class="math">, let LOG be the output of node </span>i<span class="math"> at time </span>t^{\\prime}<span class="math">, it holds that </span>\\mathsf{m}\\in\\textsf{LOG}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Intuitively, liveness says that transactions input to an honest node get included in honest nodes’ LOGs within <span class="math">T_{\\text{confirm}}</span> time; and further, if a transaction appears in some honest node’s LOG, it will appear in every honest node’s LOG within <span class="math">T_{\\text{confirm}}</span> time.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">2.3 Abstract Blockchain Protocols</h3>

    <p class="text-gray-300">A blockchain protocol can be regarded as a way to realize state machine replication. We now formally define what it means for a protocol to realize to a blockchain abstraction. In our paper, our end goal is to realize state machine replication and we leverage an abstract blockchain as an underlying building block. We note that while the blockchain abstraction may superficially resemble</p>

    <p class="text-gray-300">that of state machine replication, the blockchain abstraction in fact allows us to additionally express 1) a rough notion of time through chain growth; and 2) fairness properties <em>[40]</em> through chain quality.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">2.3.1 Syntax and Security Definitions</h4>

    <h5 id="sec-38" class="text-base font-semibold mt-4">Syntax.</h5>

    <p class="text-gray-300">An abstract blockchain protocol satisfies the following syntax. In each round, every node that is honest and online in this round receives from <span class="math">\\mathcal{Z}</span> a set of transactions <span class="math">\\mathsf{txs}</span> at the beginning of the round; and outputs to <span class="math">\\mathcal{Z}</span> an abstract blockchain <span class="math">\\mathsf{chain}</span> at the end of the round. An abstract blockchain denoted <span class="math">\\mathsf{chain}</span> is an ordered sequence of blocks of the following format:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{chain}:=\\{\\mathsf{txs}_{i}\\}_{i\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where each <span class="math">\\mathsf{txs}_{i}</span> is an application-specific payload such as a set of transactions.</p>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Blockchain notations.</h5>

    <p class="text-gray-300">We use the notation <span class="math">\\mathsf{chain}</span> to denote an abstract blockchain. The notation <span class="math">\\mathsf{chain}[:-\\ell]</span> denotes the entire <span class="math">\\mathsf{chain}</span> except the trailing <span class="math">\\ell</span> blocks; <span class="math">\\mathsf{chain}[:\\ell]</span> denotes the entire <span class="math">\\mathsf{chain}</span> upto the block at length <span class="math">\\ell</span>; <span class="math">\\mathsf{chain}[-\\ell:]</span> denotes the trailing <span class="math">\\ell</span> blocks of <span class="math">\\mathsf{chain}</span>; and <span class="math">\\mathsf{chain}[\\ell:]</span> denotes all blocks at length <span class="math">\\ell</span> or greater.</p>

    <p class="text-gray-300">Henceforth we say that <span class="math">\\mathsf{chain}</span> is ”an honest chain in view”, iff <span class="math">\\mathsf{chain}</span> is some honest (and online) node’s output to the environment <span class="math">\\mathcal{Z}</span> in some round in view. We use the notation <span class="math">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</span> to denote node <span class="math">i</span>’s chain in round <span class="math">t</span> in view — since the context is clear, we often omit writing the view explicitly in the above notation.</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Security definitions.</h5>

    <p class="text-gray-300">A blockchain protocol should satisfy chain growth, chain quality, and consistency. Intuitively, chain growth requires that honest nodes’ blockchains grow steadily, neither too fast nor too slow. Chain quality requires that in any honest node’s chain, any sufficiently long window of consecutive blocks contains a certain fraction of blocks that are mined by honest nodes. Consistency requires that all honest nodes’ chains agree with each other except for the trailing few blocks. We will formally define these security properties below.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 5 (Security of an abstract blockchain protocol).</h6>

    <p class="text-gray-300">We say that a blockchain protocol <span class="math">\\Pi_{\\text{blockchain}}</span> satisfies <span class="math">(T,g_{0},g_{1})</span>-chain growth, <span class="math">(T,\\mu)</span>-chain quality, and <span class="math">T</span>-consistency w.r.t. some <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, iff there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span>, such that for every <span class="math">\\kappa\\in\\mathbb{N}</span>, except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability over the choice of <span class="math">\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi_{\\text{blockchain}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following hold for view:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(T,g_{0},g_{1})</span>-chain growth. A view satisfies <span class="math">(T,g_{0},g_{1})</span>-chain growth iff the following hold:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistent length: If in round <span class="math">r</span> some honest chain is of length <span class="math">\\ell</span>, then in round <span class="math">r+\\Delta</span>, all honest chains must be of length at least <span class="math">\\ell</span>.</li>

      <li>Growth lower bound: For any <span class="math">r</span> and <span class="math">t</span> such that <span class="math">g_{0}(t-r)\\geq T</span>, let <span class="math">\\mathsf{chain}^{r}</span> and <span class="math">\\mathsf{chain}^{t}</span> denote two honest chains in round <span class="math">r</span> and <span class="math">t</span> respectively, it holds that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}^{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}^{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\lfloor g_{0}(t-r)\\rfloor$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Growth upper bound: For any <span class="math">r</span> and <span class="math">t</span> such that <span class="math">g_{1}(t-r)\\geq T</span>, let <span class="math">\\mathsf{chain}^{r}</span> and <span class="math">\\mathsf{chain}^{t}</span> denote two honest chains in round <span class="math">r</span> and <span class="math">t</span> respectively, it holds that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}^{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}^{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\lceil g_{1}(t-r)\\rceil$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(T,L,\\mu)</span>-chain quality. A view satisfies <span class="math">(T,L,\\mu)</span>-chain quality iff the following holds: for any honest chain denoted chain in view, for any <span class="math">T</span> consecutive blocks chain[<span class="math">j+1..j+T</span>], more than <span class="math">\\mu</span> fraction of the blocks in chain[<span class="math">j+1..j+T</span>] are mined by honest nodes at most <span class="math">L</span> blocks ago — here we say that a block chain[<span class="math">i</span>] is “mined by an honest node at most <span class="math">L</span> blocks ago” iff there is a set txs such that txs <span class="math">\\subseteq</span> chain[<span class="math">i</span>] and moreover <span class="math">\\mathcal{Z}</span> input txs to some honest node when its last output to <span class="math">\\mathcal{Z}</span> contains the prefix chain[<span class="math">:i-L</span>] (here if <span class="math">i-L&lt;0</span>, we round it to 0).</li>

      <li><span class="math">T</span>-consistency. A view satisfies <span class="math">T</span>-consistency iff the following hold: for any two honest chains chain^{r} and chain^{t} in round <span class="math">r</span> and <span class="math">t\\geq r</span> respectively, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{chain}^{r}[:-T]\\prec\\textsf{chain}^{t}</span></p>

    <p class="text-gray-300">We stress that since chain^{r} and chain^{t} can possibly belong to the same node, the above definition also implies “future self consistency” except for the trailing <span class="math">T</span> blocks.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Liveness as a derived property.</h4>

    <p class="text-gray-300">Intuitively, liveness requires that if honest nodes receive a transaction m as input, then m appear in honest chains very soon. More formally, we say that a blockchain protocol <span class="math">\\Pi_{\\text{blockchain}}</span> satisfies <span class="math">(K,T)</span>-liveness w.r.t. some <span class="math">(\\mathcal{A},\\mathcal{Z})</span> iff there exists a negligible function <span class="math">\\textsf{negl}(\\cdot)</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span>, except with <span class="math">\\textsf{negl}(\\kappa)</span> probability over the choice of view <span class="math">\\leftarrow\\textsf{EXEC}^{\\Pi_{\\text{blockchain}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that in any round <span class="math">r\\geq t</span>, <span class="math">\\mathcal{Z}</span> always inputs a set that contains some m to every honest and online node <span class="math">i</span> unless <span class="math">\\textsf{m}\\in\\textsf{chain}_{i}^{r}[:-T]</span>. Then, for any honest chain denoted chain in view whose length is at least <span class="math">\\ell+K+T</span>, it holds that chain[<span class="math">:\\ell+K</span>] contains m where <span class="math">\\ell</span> denotes the shortest honest chain length at time <span class="math">t</span>.</li>

    </ul>

    <p class="text-gray-300">The liveness of a blockchain protocol is directly implied by chain growth and chain quality as stated in the following lemma.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 1 (Liveness).</h6>

    <p class="text-gray-300">Suppose that a blockchain protocol <span class="math">\\Pi_{\\text{blockchain}}</span> satisfies <span class="math">(K,g_{0},g_{1})</span>-chain growth, <span class="math">(K^{\\prime},L,\\mu)</span> chain quality and <span class="math">T</span>-consistency w.r.t. some <span class="math">(\\mathcal{A},\\mathcal{Z})</span> for positive parameters <span class="math">K,g_{0},g_{1},K^{\\prime},L,\\mu</span> and <span class="math">T</span>, then it holds that <span class="math">\\Pi_{\\text{blockchain}}</span> satisfies <span class="math">(2K+2g_{1}+K^{\\prime}+L,T)</span>-liveness w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We ignore the negligible fraction of views where relevant bad events take place. Let <span class="math">r^{\\prime}</span> be the earliest round in which some honest chain reaches length at least <span class="math">\\ell+K+g_{1}+K^{\\prime}+L+T</span>, and let chain^{∗} be an honest chain in round <span class="math">r^{\\prime}</span> of length at least <span class="math">\\ell+K+g_{1}+K^{\\prime}+L+T</span>. By chain quality, in the window chain^{∗}[<span class="math">\\ell+K+g_{1}+L+1:\\ell+K+g_{1}+K^{\\prime}+L</span>], there must be an honest block denoted B such that <span class="math">\\mathcal{Z}</span> input (a subset of) the contents of B to some honest node <span class="math">i</span> in round <span class="math">r\\leq r^{\\prime}</span> when its chain contains the prefix chain^{∗}[<span class="math">:\\ell+K+g_{1}+1</span>]. By chain growth upper bound, the longest honest chain in round <span class="math">t</span> must be of length at most <span class="math">\\ell+K+g_{1}</span>, and thus B must be input to some honest and online node <span class="math">i</span> by <span class="math">\\mathcal{Z}</span> in some round <span class="math">r</span> where <span class="math">t\\leq r\\leq r^{\\prime}</span>. By assumption, B must contain m unless chain<span class="math">{}_{i}^{r}[:-T]</span> already contains m. By consistency, it must be that chain^{∗} and chain<span class="math">{}_{i}^{r}</span> are no longer than <span class="math">\\ell+2(K+g_{1})+K^{\\prime}+L+T</span>. By consistency, for any honest chain ch in view of length at least <span class="math">\\ell+2(K+g_{1})+K^{\\prime}+L+T</span>, it must be that chain<span class="math">{}_{i}^{r}[:-T]\\prec\\textsf{ch}[:{\\ell+2(K+g_{1})+K^{\\prime}+L}]</span> and chain^{∗}[<span class="math">:-T]\\prec\\textsf{ch}[:{\\ell+2(K+g_{1})+K^{\\prime}+L}]</span>, and thus ch[<span class="math">:\\ell+2(K+g_{1})+K^{\\prime}+L]</span> must contain m. ∎</p>

    <p class="text-gray-300">2.3.2 Blockchain Implies State Machine Replication</p>

    <p class="text-gray-300">Given any blockchain protocol <span class="math">\\Pi_{\\text{blockchain}}</span>, it is easy to construct a state machine replication protocol where 1) nodes run an instance of <span class="math">\\Pi_{\\text{blockchain}}</span>; 2) an honest node broadcasts all newly seen transactions to each other; and 3) in every round, nodes remove the trailing <span class="math">T</span> blocks from the present chain (where <span class="math">T</span> is the consistency parameter) and output the truncated chain to the environment <span class="math">\\mathcal{Z}</span> <em>[41, 43]</em>. It is not difficult to see that consistency (of the resulting state machine replication protocol) follows directly from consistency of the blockchain; and liveness follows from chain quality and chain growth. The above intuition has been formalized in earlier works <em>[41, 43]</em>.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">2.4 Warmup: Blockchain Instantiations</h3>

    <p class="text-gray-300">The most representative blockchain protocol is obviously Nakamoto’s orginal blockchain <em>[38]</em>, i.e., the core consensus protocol underlying Bitcoin. In this section, however, we give several instantiations of an “abstract blockchain protocol” in both the permissioned and permissionless models to demonstrate the generality of this abstraction.</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">2.4.1 Permissionless Environment</h4>

    <h5 id="sec-47" class="text-base font-semibold mt-4">Modeling a proof-of-work oracle.</h5>

    <p class="text-gray-300">Our technique can be instantiated in a blackbox manner from any blockchain protocol, including proof-of-work and non-proof-of-work blockchains. A proof-of-work blockchain as represented by Nakamoto’s original proposal <em>[39, 23, 38]</em> relies on a proof-of-work random oracle. Let <span class="math">H:\\{0,1\\}^{<em>}\\to\\{0,1\\}^{\\kappa}</span> denote a random function. Nodes are allowed to query two functions <span class="math">\\mathsf{H}</span> and <span class="math">\\mathsf{H.ver}</span>. <span class="math">\\mathsf{H}(x)</span> simply outputs the outcome of the random function <span class="math">H(x)</span>, and <span class="math">\\mathsf{H.ver}(x,y)</span> outputs 1 iff <span class="math">H(x)=y</span>, else it outputs 0. In any round, any node is allowed to make an arbitrary number of queries to <span class="math">\\mathsf{H.ver}</span> but </em>at most one query* to <span class="math">\\mathsf{H}</span>. If the adversary <span class="math">\\mathcal{A}</span> controls <span class="math">q</span> corrupt nodes, we allow <span class="math">\\mathcal{A}</span> to make <span class="math">q</span> sequential queries to <span class="math">\\mathsf{H}</span>. We emphasize that the environment <span class="math">\\mathcal{Z}</span> cannot access the random oracle.</p>

    <h5 id="sec-48" class="text-base font-semibold mt-4">Nakamoto’s proof-of-work blockchain.</h5>

    <p class="text-gray-300">Nakamoto’s original proposal <em>[38]</em> relies on proof-of-work to defend against Sybil attacks and achieve consensus in a permissionless setting. Garay et al. <em>[23]</em> and Pass et al. <em>[39]</em> formally show that Nakamoto’s blockchain is secure in a fully adaptive corruption model as long as the adversary controls only a minority of the computation power.</p>

    <p class="text-gray-300">In the following theorem, we say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\text{nak}}^{\\eta}</span> (parametrized by a positive constant <span class="math">\\eta</span>) iff there exist <span class="math">n,\\Delta</span> and some positive constant <span class="math">\\rho&lt;\\frac{1}{2}</span> such that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,\\rho,\\Delta)</span>-permissionless execution.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Theorem 4 (Nakamoto’s blockchain <em>[42, 39, 23, 38]</em>).</h6>

    <p class="text-gray-300">Assume the existence of a proof-of-work random oracle. Then, for any positive constant <span class="math">\\eta</span>, there exist a blockchain protocol <span class="math">\\Pi_{\\text{nak}}^{\\eta}</span> and positive constants <span class="math">c_{0},c_{1}</span>, such that for any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair that is compliant w.r.t. <span class="math">\\Pi_{\\text{nak}}^{\\eta}</span>, <span class="math">\\Pi_{\\text{nak}}^{\\eta}</span> satisfies the following w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> for any positive constant <span class="math">\\epsilon</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\epsilon\\kappa,\\frac{1}{c_{0}\\Delta},\\frac{1}{c_{1}\\Delta})</span>-chain growth;</li>

      <li><span class="math">(\\epsilon\\kappa,1,1-\\frac{(1+\\eta)\\rho}{1-\\rho})</span>-chain quality;</li>

      <li><span class="math">\\epsilon\\kappa</span>-consistency; and</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\epsilon\\kappa,\\epsilon\\kappa)</span>-liveness.</li>

    </ul>

    <p class="text-gray-300">In the above theorem, Nakamoto’s protocol <span class="math">\\Pi^{\\eta}_{\\text{nak}}</span> will automatically pick a suitable difficulty parameter based on the parameters <span class="math">(n,\\rho,\\Delta)</span> honest nodes receive from <span class="math">\\mathcal{Z}</span> as well as <span class="math">\\eta</span>. We refer the readers to earlier works <em>[39, 42]</em> regarding how to concretely choose an appropriate difficulty parameter.</p>

    <p class="text-gray-300">We stress that since we rely on the underlying blockchain as a blackbox, Thunderella can also be instantiated with a varying difficulty blockchain <em>[22, 38]</em> such that we can allow the number of players to vary over time.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">2.4.2 Permissioned, Classical Environment</h4>

    <p class="text-gray-300">As a warmup, we will additionally show that in a permissioned, classical environment and assuming the existence of a public-key infrastructure (PKI), we can realize an abstract blockchain by modifying the classical Dolev-Strong protocol <em>[18]</em> that tolerates arbitrary number of corruptions.</p>

    <p class="text-gray-300">Recall that the permissioned, classical setting can be formally modeled as further constraints on <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. Specifically, recall that we say that <span class="math">\\mathcal{Z}</span> respects permissioned-classical execution (or <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects permissioned-classical execution) iff the following holds: 1) <span class="math">\\mathcal{Z}</span> must spawn all nodes upfront prior to protocol execution; 2) <span class="math">\\mathcal{Z}</span> must input the identities of all spawned nodes to every honest node as soon as it is spawned; and 3) <span class="math">\\mathcal{Z}</span> is not allowed to issue sleep or wake instructions. Henceforth in this subsection, we will implicitly assume such a permissioned, classical execution environment; and in particular, “honest” now equates to “honest and online”.</p>

    <h5 id="sec-51" class="text-base font-semibold mt-4">Multi-valued broadcast: definitions.</h5>

    <p class="text-gray-300">First, we describe a multi-valued variant of the Dolev-Strong protocol which realizes a multi-valued broadcast abstraction. In a multi-valued broadcast protocol, there is a publicly known sender that will try to broadcast one or more values to all other nodes. At the beginning of the protocol, all nodes receive from <span class="math">\\mathcal{Z}</span> the identity of the sender, as well as the maximum number of corrupt nodes <span class="math">f</span> and the maximum network delay <span class="math">\\Delta</span>. Moreover, an honest sender would receive an input set <span class="math">U</span> from <span class="math">\\mathcal{Z}</span>. At the end of the protocol, all honest nodes output a set of values <span class="math">V</span>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 6 (Security of multi-valued broadcast).</h6>

    <p class="text-gray-300">We say that a multi-valued broadcast protocol <span class="math">\\Pi_{\\text{bcast}}</span> satisfies consistency and validity w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> iff except with negligible probability over the choice of view <span class="math">\\leftarrow</span> EXEC<span class="math">{}^{\\Pi_{\\text{bcast}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following properties hold for view:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency. If two honest nodes output the sets <span class="math">V</span> and <span class="math">V^{\\prime}</span> respectively in view, then <span class="math">V=V^{\\prime}</span>.</li>

      <li>Validity. If the sender remains honest in view, then all honest nodes output <span class="math">U</span> where <span class="math">U</span> is the input the sender receives from <span class="math">\\mathcal{Z}</span> at the beginning of view.</li>

    </ul>

    <h5 id="sec-53" class="text-base font-semibold mt-4">Multi-valued broadcast from Dolev-Strong.</h5>

    <p class="text-gray-300">One can easily modify the Dolev-Strong protocol to realize multi-valued broadcast. The protocol <span class="math">\\Pi_{\\text{bcast}}</span> is as described below — without loss of generality, imagine that there are <span class="math">n</span> nodes numbered <span class="math">0,1,\\ldots,n-1</span>, and node <span class="math">0</span> is the sender. Henceforth we use the notation <span class="math">\\mathsf{pk}_{i}</span> to denote node <span class="math">i</span>’s public key registered with the PKI.</p>

    <p class="text-gray-300">Henceforth in our protocol, a message-round is defined to be <span class="math">\\Delta</span> small rounds where <span class="math">\\Delta</span> denotes the maximum network delay. In other words, nodes always wait sufficiently long to receive messages sent by honest nodes in the previous message round before taking any new action.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Remark 1 (Regarding composition).</h6>

    <p class="text-gray-300">Our state machine replication protocol will make use of multiple instances of multi-valued broadcast. we adopt the following conventions necessary for secure protocol composition:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All instances of multi-valued broadcast are spawned with a unique session identifier denoted <span class="math">sid</span>.</li>

      <li>We describe our protocols assuming a global signing functionality <span class="math">\\mathcal{G}^{\\Sigma}_{\\text{sign}}</span> (parametrized by a signature scheme <span class="math">\\Sigma</span>) shared by all instances of multi-valued broadcast — see Appendix 5.4 for a formal specification and regarding how <span class="math">\\mathcal{Z}</span> can interact with <span class="math">\\mathcal{G}_{\\text{sign}}</span>. Such a global signing functionality can be realized in the most obvious manner from a global bare public-key infrastructure shared by all multi-valued broadcast instances.</li>

      <li>Henceforth, when we describe our multi-valued broadcast protocol, when honest nodes need to sign messages, although not explicitly noted we assume that they always call <span class="math">\\mathcal{G}^{\\Sigma}_{\\text{sign}}</span> to obtain a signature.</li>

    </ol>

    <p class="text-gray-300">We now describe our multi-valued broadcast protocol below in the <span class="math">\\mathcal{G}^{\\Sigma}_{\\text{sign}}</span>-hybrid world.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialize:</em> Initialize <span class="math">V:=\\emptyset</span>.</li>

      <li><em>Message-round 0:</em> For every <span class="math">v\\in U</span>, sender broadcasts a tuple <span class="math">(v,\\sigma_{0})</span> where <span class="math">\\sigma_{0}</span> is a signature on the value <span class="math">v</span>. All other nodes do nothing.</li>

      <li><em>Each message-round <span class="math">r</span> where <span class="math">1\\leq r\\leq f+1</span> :</em> The following is performed by all nodes. For every message <span class="math">(v,\\{\\sigma_{i}\\}_{i\\in S})</span> received from the network where <span class="math">S</span> is a set of size <span class="math">r</span> and <span class="math">\\sigma_{i}</span> is a signature on <span class="math">v</span> valid under <span class="math">\\mathsf{pk}_{i}</span>: if <span class="math">v\\notin V</span>, then</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>add <span class="math">v</span> to <span class="math">V</span>;</li>

      <li>let <span class="math">S^{\\prime}:=S\\cup\\{\\sigma^{<em>}\\}</span> where <span class="math">\\sigma^{</em>}</span> is the current node’s signature on the value <span class="math">v</span>; and</li>

      <li>broadcast <span class="math">(v,S^{\\prime})</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Output:</em> Finally, at the end of message-round <span class="math">f+1</span>, output <span class="math">V</span>.</li>

    </ul>

    <p class="text-gray-300">Henceforth we say that a protocol <span class="math">\\Pi</span> satisfies consistency (or validity resp.) in <span class="math">(n,f,\\Delta)</span>-classical environments iff for every p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that respects <span class="math">(n,f,\\Delta)</span>-classical execution, <span class="math">\\Pi</span> satisfies consistency (or validity resp.) w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proposition 1 (Security of <span class="math">\\Pi_{\\text{bcast}}</span>).</h6>

    <p class="text-gray-300">Assume that the signature scheme <span class="math">\\Sigma</span> is secure. For every <span class="math">n,\\Delta</span> and every <span class="math">f&lt;n</span>, <span class="math">\\Pi_{\\text{bcast}}</span> satisfies consistency and validity in <span class="math">(n,f,\\Delta)</span>-classical environments.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is a straightforward modification of the classical proof due to Dolev and Strong <em>[18]</em>. ∎</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Blockchain from multi-valued broadcast.</h4>

    <p class="text-gray-300">We can construct the following blockchain protocol <span class="math">\\Pi_{\\text{DS}}</span> in a permissioned, classical environment from multi-valued broadcast. We now describe <span class="math">\\Pi_{\\text{DS}}</span> in the <span class="math">\\mathcal{G}_{\\text{sign}}</span>-hybrid world.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Broadcast:</em> At the beginning of each message-round <span class="math">r</span>, for each sender <span class="math">i\\in\\{0,1,\\ldots,n-1\\}</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>fork a new instance of multi-valued broadcast <span class="math">\\Pi_{\\text{bcast}}[sid=(r,i)]</span> where the sender <span class="math">i</span> is input as the sender.</li>

    </ol>

    <p class="text-gray-300">let chain be the sender <span class="math">i</span>’s last output to <span class="math">\\mathcal{Z}</span>, <span class="math">i</span> inputs to <span class="math">\\Pi_{\\text{bcast}}[sid=(r,i)]</span> a set containing every transaction that has been received from <span class="math">\\mathcal{Z}</span> but is not in chain.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output: At the end of every message round <span class="math">r</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">r&lt;f+1</span>, let <span class="math">\\mathsf{B}:=\\emptyset</span>; else for any <span class="math">i</span>, create a new block <span class="math">\\mathsf{B}</span> by concatenating the outputs of instances <span class="math">\\Pi_{\\text{bcast}}[(r-(f+1),i)]</span> for <span class="math">i=0,1,\\ldots,n-1</span>.</li>

      <li>let chain be the last output to <span class="math">\\mathcal{Z}</span> and chain = if nothing has been output.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. output chain$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{B}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\text{DS}}</span> iff there exists some <span class="math">n,\\Delta</span> and some <span class="math">f&lt;n</span> such that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,f,\\Delta)</span>-classical execution.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Theorem 5 (Blockchain tolerating arbitrary corruptions in a permissioned, classical environment).</h6>

    <p class="text-gray-300">Suppose that the signature scheme <span class="math">\\Sigma</span> is secure. Then, for any p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\text{DS}}</span>, <span class="math">\\Pi_{\\text{DS}}</span> satisfies the following security properties w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(0,\\frac{1}{\\Delta},\\frac{1}{\\Delta})</span>-chain growth;</li>

      <li><span class="math">(1,2,1)</span>-chain quality;</li>

      <li>0-consistency; and</li>

      <li><span class="math">(2,0)</span>-liveness.</li>

    </ul>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows from the security of <span class="math">\\Pi_{\\text{bcast}}</span>, proof is straightforward and left as an exercise for the reader. ∎</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">2.4.3 Permissioned, Sleepy Environment</h4>

    <p class="text-gray-300">Classical modeling techniques in the distributed computing and cryptography literature typically treat crashed nodes as corrupt, and thus crashes would count towards the corruption budget. We next consider a permissioned model in which crashed nodes that are not under adversarial control are treated not as corrupt, but rather as honest but “sleepy” <em>[43]</em>. Such a “sleepy model” was first proposed in the recent work <em>[43]</em>. In the sleepy model, the set of online and honest nodes in adjacent rounds may be completely disjoint; and nodes can go to sleep and then wake up later. Recent work <em>[43]</em> showed that the following interesting facts:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>State machine replication is possible in such a permissioned, sleepy model, as long as in every round, the majority of online nodes are honest (Theorem 6).</li>

      <li>Interestingly, no known classical consensus protocol can achieve state machine replication in the sleepy model, even when we are guaranteed that 99% of online nodes must be honest in every round.</li>

      <li>Moreover, the honest majority assumption (among online nodes) turns out to be necessary to realize state machine replication in the sleepy model <em>[43]</em>.</li>

    </ul>

    <p class="text-gray-300">More concretely, Pass and Shi construct a blockchain protocol in the permissioned, sleepy model called “sleepy consensus” <em>[43]</em>, assuming the existence of a PKI and a common reference string. Their protocol is inspired by Nakamoto’s proof-of-work blockchain, but they show how to remove</p>

    <p class="text-gray-300">the proof-of-work securely in a permissioned, sleepy setting. At a high level, the sleepy consensus protocol is very similar in nature to the original Nakamoto blockchain — while Nakamoto’s blockchain uses proof-of-work to elect random leaders, the sleepy consensus protocol emulates the random leader election mechanism without relying on proof-of-work. Based on this high-level idea, a few extra tricks are necessary to ensure the security of the protocol <em>[43]</em>.</p>

    <p class="text-gray-300">Although Pass and Shi <em>[43]</em> show positive results under both adaptive and static corruption environments, below we state the theorem for the static corruption version where the parameters are tighter.</p>

    <p class="text-gray-300">In the following theorem, we say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi^{\\eta}_{\\text{sleepy}}</span> iff there exist some <span class="math">n,\\Delta</span> and some positive constant <span class="math">\\rho&lt;\\frac{1}{2}</span> such that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,\\rho,\\Delta)</span>-sleepy execution, and moreover <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects static corruption.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Theorem 6 (Blockchains in permissioned, sleepy environments <em>[43]</em>).</h6>

    <p class="text-gray-300">Assume the existence of a common reference string, a bare public-key infrastructure, and enhanced trapdoor permutations. For any positive constant <span class="math">\\eta</span>, there exists a blockchain protocol <span class="math">\\Pi^{\\eta}_{\\text{sleepy}}</span> and positive constants <span class="math">c_{0}</span> and <span class="math">c_{1}</span>, such that for any p.p.t. pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi^{\\eta}_{\\text{sleepy}}</span>, for any positive constant <span class="math">\\epsilon</span>, <span class="math">\\Pi^{\\eta}_{\\text{sleepy}}</span> satisfies the following w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\epsilon\\kappa,\\frac{\\chi}{c_{0}\\Delta},\\frac{1}{c_{1}\\Delta})</span>-chain growth;</li>

      <li><span class="math">(\\epsilon\\kappa,1,1-\\frac{(1+\\eta)\\rho}{1-\\rho})</span>-chain quality;</li>

      <li><span class="math">\\epsilon\\kappa</span>-consistency; and</li>

      <li><span class="math">(\\epsilon\\kappa,\\epsilon\\kappa)</span>-liveness.</li>

    </ul>

    <p class="text-gray-300">where <span class="math">\\chi(\\textsf{view}):=\\widetilde{n}(\\textsf{view})/n</span> is the ratio of minimum number of online nodes in any round in view over <span class="math">n</span>.</p>

    <p class="text-gray-300">In the above theorem, we assume that <span class="math">\\Pi^{\\eta}_{\\text{sleepy}}</span> will automatically choose an appropriate difficulty parameter based on the parameters <span class="math">n,\\rho</span> and <span class="math">\\Delta</span> from <span class="math">\\mathcal{Z}</span> as well as <span class="math">\\eta</span>. We refer the readers to the earlier work <em>[43]</em> for concrete choice of parameters.</p>

    <p class="text-gray-300">We stress that our Thunderella paradigm can also be extended to the adaptively secure version of the sleepy consensus protocol <em>[43]</em> although protocol parameters must be re-selected.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">2.5 Preliminaries: Responsiveness and Optimistic Responsiveness</h3>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">2.5.1 Responsiveness</h4>

    <p class="text-gray-300">Recall that throughout this paper we always assume that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">\\Delta</span>-bounded delay for some <span class="math">\\Delta</span>, i.e., <span class="math">\\mathcal{Z}</span> informs the protocol of a delay upper bound <span class="math">\\Delta</span> upfront and all honest messages are then delivered within <span class="math">\\Delta</span> number of rounds. A state machine replication protocol is said to be responsive if the transaction confirmation time is independent of the a-priori known upper bound <span class="math">\\Delta</span> of the network’s delay, but depends only on the actual maximum network delay. To put our results in perspective, we formally define the notion of responsiveness below and state a known lower bound result suggesting the impossibility of responsiveness against <span class="math">\\frac{1}{3}</span> fraction of corruption. In the remainder of the paper, we will show that if one optimistically hopes for responsiveness only in lucky situations, then we can have protocols that retains consistency and liveness even under more than <span class="math">\\frac{1}{3}</span> corruption. In practice, this means that we can have protocols that are responsive most of the time, and even when more than <span class="math">\\frac{1}{3}</span> nodes are corrupt, the protocol can still guarantee consistency and liveness although performance would degrade when under attaack.</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">Responsiveness.</h4>

    <p class="text-gray-300">We define a technical notion called responsiveness for a state machine replication protocol. Intuitively, responsiveness requires that except for a (possibly non-responsive) warmup period in the beginning, all transactions input afterwards will perceive transaction confirmation delay that is independent of the a-priori set upper bound <span class="math">\\Delta</span> on the network’s delay. As shown in earlier works <em>[19, 41]</em>, responsive state machine replication is impossible if <span class="math">\\frac{1}{3}</span> or more fraction of the nodes are corrupt (even in a permissioned, classical environment with static corruptions, and even assuming that a proof-of-work oracle exists).</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Definition 7 (Responsive state machine replication <em>[41]</em>).</h6>

    <p class="text-gray-300">Suppose that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">\\Delta</span>-bounded delay for some <span class="math">\\Delta</span>. We say that a state machine replication protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}}</span>-responsiveness w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> iff <span class="math">\\Pi</span> satisfies <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}})</span>-liveness w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, and moreover the function <span class="math">T_{\\text{confirm}}</span> does not depend on the a-prior delay upper bound <span class="math">\\Delta</span>.</p>

    <p class="text-gray-300">We say that a protocol <span class="math">\\Pi</span> satisfies consistency (or responsiveness resp.) in <span class="math">(n,f,\\Delta)</span>-classical, static environments iff for every p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair that respects <span class="math">(n,f,\\Delta)</span>-classical execution and static corruption, <span class="math">\\Pi</span> satisfies consistency (or responsiveness resp.) w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. We can similarly define <span class="math">(n,\\rho,\\Delta)</span>-sleepy, static environments and <span class="math">(n,\\rho,\\Delta)</span>-permissionless, static environments.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Theorem 7 (Impossibility of responsiveness against <span class="math">\\frac{1}{3}</span> corruption <em>[41]</em>).</h6>

    <p class="text-gray-300">For any <span class="math">n</span> and <span class="math">f</span> such that <span class="math">n\\leq 3f</span> and for any polynomial <span class="math">T_{\\text{confirm}}</span> in <span class="math">\\kappa</span> and <span class="math">\\delta</span>, and <span class="math">T_{\\text{warmup}}</span> in <span class="math">\\kappa,\\Delta</span>, and <span class="math">\\delta</span>, there exists some polynomial function <span class="math">\\Delta</span> in <span class="math">\\kappa</span> such that no state machine replication protocol no state machine replication protocol can can simultaneously achieve consistency and <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}})</span>-responsiveness in <span class="math">(n,f,\\Delta)</span>-classical, static environments even assuming the existence of a proof-of-work oracle.</p>

    <p class="text-gray-300">The proof of the above theorem was presented by Pass and Shi in a recent work <em>[41]</em> where they modified the classical lower bound proof by Dwork, Lynch, and Stockmeyer <em>[19]</em> and made it work even in the proof-of-work setting.</p>

    <p class="text-gray-300">Recall that permissioned-classical is expressed as constraints on <span class="math">(\\mathcal{A},\\mathcal{Z})</span> in our formal framework. This means that a lower bound for <span class="math">n\\leq 3f</span> in the classical setting immediately implies a lower bound in more permissive settings where <span class="math">(\\mathcal{A},\\mathcal{Z})</span> need not respect the permissioned-classical constraints as long as <span class="math">n\\leq 3f</span> (or the equivalent holds). Thus the following corollaries are immediate from Theorem 7.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">For any <span class="math">n</span> and any <span class="math">\\rho\\geq\\frac{1}{3}</span>, for any polynomial <span class="math">T_{\\text{confirm}}</span> in <span class="math">\\kappa</span>, and <span class="math">\\delta</span> and polynomial <span class="math">T_{\\text{warmup}}</span> in <span class="math">\\kappa,\\Delta</span>, and <span class="math">\\delta</span>, there exists some polynomial function <span class="math">\\Delta</span> in <span class="math">\\kappa</span> such that no state machine replication protocol no state machine replication protocol can can simultaneously achieve consistency and <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}})</span>-responsiveness in <span class="math">(n,\\rho,\\Delta)</span>-sleepy, static environments even assuming the existence of a proof-of-work oracle.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">For any <span class="math">n</span> and any <span class="math">\\rho\\geq\\frac{1}{3}</span>, for any polynomial <span class="math">T_{\\text{confirm}}</span> in <span class="math">\\kappa</span>, and <span class="math">\\delta</span> and polynomial <span class="math">T_{\\text{warmup}}</span> in <span class="math">\\kappa,\\Delta</span>, and <span class="math">\\delta</span>, there exists some polynomial function <span class="math">\\Delta</span> in <span class="math">\\kappa</span> such that no state machine replication protocol no state machine replication protocol can can simultaneously achieve consistency and <span class="math">(T_{\\text{confirm}},T_{\\text{warmup}})</span>-responsiveness in <span class="math">(n,\\rho,\\Delta)</span>-permissionless, static environments even assuming the existence of a proof-of-work oracle.</p>

    <p class="text-gray-300">Interestingly, how to achieve responsive state machine replication against fewer than <span class="math">\\frac{1}{3}</span> fraction of corruption is also known in the in the permissioned setting assuming the existence of a PKI <em>[13]</em>, as well as in the permissionless setting assuming proof-of-work <em>[41]</em> (and under additional technical assumptions).</p>

    <p class="text-gray-300">2.5.2 “Bare Minimum” Optimistic Responsiveness</p>

    <p class="text-gray-300">Since full responsiveness is subject to a <span class="math">\\frac{1}{3}</span> corruption lower bound as stated in Theorem 7, we consider how to relax the notion of responsiveness such that we can in practical scenarios hope for responsiveness, say, most of the time, but not be subject to the <span class="math">\\frac{1}{3}</span> corruption lower bound for worst-case security guarantees.</p>

    <p class="text-gray-300">Although our protocols achieve much stronger guarantees regarding optimistic responsiveness, we start with a bare-minimum goal one can hope for: informally speaking, can we have have a protocol (for permissionless or permissioned settings) that resists <span class="math">\\rho\\geq\\frac{1}{3}</span> fraction of corruption in the worst case, but is at least “occasionally responsive” in honest executions where all nodes remain honest and online throughout? Interestingly, to the best of our knowledge, no known state machine replication protocol can satisfy even the above “bare minimum” goal.</p>

    <p class="text-gray-300">Let <span class="math">T_{\\mathrm{opt}}</span> be a polynomial function in <span class="math">\\kappa,n,\\rho</span>, and <span class="math">\\delta</span> where <span class="math">n,\\rho,\\delta</span> are functions of a view and <span class="math">\\delta</span> represents the maximum actual network delay. Henceforth in this paper, without loss of generality, we assume that <span class="math">\\mathcal{Z}</span> always inputs a fresh transaction to some honest node in every round.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">Given a view, we say that <span class="math">[t_{0},t_{1}]</span> is a <span class="math">T_{\\mathrm{opt}}</span>-responsive period in view iff for every transaction <span class="math">\\mathsf{m}</span> input to some honest node in some round <span class="math">t\\in[t_{0},t_{1}]</span>, it holds that in any round <span class="math">r\\geq t+T_{\\mathrm{opt}}(\\kappa,n,\\rho,\\delta)</span>, any honest node’s output log to <span class="math">\\mathcal{Z}</span> contains <span class="math">\\mathsf{m}</span>.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">We say that <span class="math">\\Pi</span> is <span class="math">T_{\\mathrm{opt}}</span>-occasionally responsive w.r.t. some <span class="math">(\\mathcal{A},\\mathcal{Z})</span> iff there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span>, such that for every <span class="math">\\kappa</span>, except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability over the choice of <span class="math">\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, view contains a <span class="math">T_{\\mathrm{opt}}</span>-responsive period of non-zero length.</p>

    <p class="text-gray-300">Note that the above definition is only interesting if <span class="math">(\\mathcal{A},\\mathcal{Z})</span> inputs a larger upper bound <span class="math">\\Delta</span> than the actual maximum message delay.</p>

    <p class="text-gray-300">Unfortunately, almost all known state machine replication protocols in the synchronous model (including blockchain-style protocols) are not occasionally responsive even when all nodes are honest. In particular, recall that earlier we described three blockchain instantiations <span class="math">\\Pi_{\\mathrm{nak}}</span>, <span class="math">\\Pi_{\\mathrm{DS}}</span>, and <span class="math">\\Pi_{\\mathrm{sleepy}}</span> in the permissionless, permissioned-classical, and permissioned-sleepy settings respctively. As noted in Section 2.3.2, we can easily construct state machine replication protocols from blockchains. The following facts state that the resulting state machine replication protocols are never responsive even under honest executions. Below we say that a protocol <span class="math">\\Pi</span> is <span class="math">T_{\\mathrm{opt}}</span>-occasionally responsive in <span class="math">(n,\\rho,\\Delta)</span>-permissionless environments iff <span class="math">\\Pi</span> is <span class="math">T_{\\mathrm{opt}}</span>-occasionally responsive w.r.t. to any <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that respects <span class="math">(n,\\rho,\\Delta)</span>-permissionless execution. The notions of <span class="math">(n,f,\\Delta)</span>-classical environments and <span class="math">(n,\\rho,\\Delta)</span>-sleepy environments are similarly defined.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Fact 1.</h6>

    <p class="text-gray-300">For any polynomial function <span class="math">T_{\\mathrm{opt}}</span> and any <span class="math">n</span>, there exists a polynomial function <span class="math">\\Delta</span> such that the state machine replication protocol implied by <span class="math">\\Pi_{\\mathrm{nak}}</span> is not <span class="math">T_{\\mathrm{opt}}</span>-occasionally responsive in <span class="math">(n,\\rho=0,\\Delta)</span>-permissionless environments.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Fact 2.</h6>

    <p class="text-gray-300">For any polynomial function <span class="math">T_{\\mathrm{opt}}</span> and any <span class="math">n</span>, there exists a polynomial function <span class="math">\\Delta</span> such that the state machine replication protocol implied by <span class="math">\\Pi_{\\mathrm{DS}}</span> is not <span class="math">T_{\\mathrm{opt}}</span>-occasionally responsive in <span class="math">(n,f=0,\\Delta)</span>-classical environments.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Fact 3.</h6>

    <p class="text-gray-300">For any polynomial function <span class="math">T_{\\mathrm{opt}}</span> and any <span class="math">n</span>, there exists a polynomial function <span class="math">\\Delta</span> such that the state machine replication protocol implied by <span class="math">\\Pi_{\\mathrm{sleepy}}</span> is not <span class="math">T_{\\mathrm{opt}}</span>-occasionally responsive in <span class="math">(n,\\rho=0,\\Delta)</span>-classical environments.</p>

    <p class="text-gray-300">Note that in the above theorem, we say that the sleepy consensus protocol <span class="math">\\Pi_{\\mathrm{sleepy}}</span> is not even occasionally responsive in honest classical environments where all nodes are honest and online throughout (in comparison, in sleepy environments, honest nodes can fall asleep).</p>

    <p class="text-gray-300">2.5. PRELIMINARIES: RESPONSIVENESS AND OPTIMISTIC RESPONSIVENESS</p>

    <p class="text-gray-300">Indeed, asking for occasional responsiveness in entirely honest executions is the bare minimum to hope for — despite this, no known state machine replication protocol can achieve it while tolerating <span class="math">\\frac{1}{3}</span> corruptions in the worst case. Later in our paper, we will construct protocols that tolerate minority or arbitrarily many corruptions in the worst case, and achieve not just occasional responsiveness, but full responsiveness in honest executions. In fact, our protocols will achieve a much stronger form of optimistic responsiveness (not just in honest executions). Roughly speaking, our protocols are epoch based. We will guarantee optimistic responsiveness of the following nature: whenever we encounter a lucky epoch during which (<span class="math">\\mathcal{A},\\mathcal{Z}</span>) behaves “somewhat nicely”, then during this epoch transactions will confirm responsively. More specifically, our protocols are leader-based such that during each epoch, a designated leader plays the role of a coordinator. Informally, suppose that we ask for worst-case guarantees under minority corruption — then, if during any epoch the leader remains honest and online and moreover more than <span class="math">\\frac{3}{4}</span> fraction of nodes are honest and online, then this epoch is a lucky epoch. As a special case, if more than <span class="math">\\frac{3}{4}</span> fraction of the nodes remain honest and online throughout the execution and the initial leader also remains honest and online, then the entire execution will be responsive.</p>

    <p class="text-gray-300">CHAPTER 2. DEFINITIONS AND PRELIMINARIES</p>

    <p class="text-gray-300">Chapter 3 Basic Thunderella Protocol with a Static Committee</p>

    <p class="text-gray-300">We first describe the basic Thunderella protocol assuming a static committee that is known a-priori to all nodes. We will discuss how to perform committee reconfiguration later in the paper. For conceptual simplicity, we describe a version of the protocol where the blockchain is also collecting transactions constantly in the background — in practical implementations, it will not be too difficult to optimize our theoretical construction further such that the blockchain need not store an additional copy of all transactions under optimistic conditions.</p>

    <p class="text-gray-300">As mentioned, in general, the Thunderella paradigm can be instantiated with any suitable asynchronous protocol to serve as the optimistic path and any suitable synchronous protocol to serve as the fallback path. However, we believe that a particular attractive instantiation is to use a simple voting-based protocol for the optimistic path and a blockchain as the fallback. Thus for concreteness, we will describe Thunderella for this specific instantiation.</p>

    <h5 id="sec-74" class="text-base font-semibold mt-4">Terminology.</h5>

    <p class="text-gray-300">Our basic approach assumes three logical entities:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>miners of the underlying blockchain <span class="math">\\Pi_{\\text{blockchain}}</span>;</li>

      <li>a leader; and</li>

      <li>a committee denoted committee.</li>

    </ul>

    <p class="text-gray-300">To retain consistency and worst-case liveness (i.e., confirmation in the speed of the underlying <span class="math">\\Pi_{\\text{blockchain}}</span>), we need to assume that 1) the underlying blockchain <span class="math">\\Pi_{\\text{blockchain}}</span> retains security (and this would translate to different compliance rules depending on how we instantiate the underlying blockchain); 2) <span class="math">\\alpha</span> fraction of the committee are assumed to remain honest (but not necessarily online) where <span class="math">\\alpha</span> is a knob that effectively allows us to trade-off security and performance as is explained later. Notably, the leader need not be trusted for consistency and worst-case liveness.</p>

    <p class="text-gray-300">For concreteness, in our description we will often assume that <span class="math">\\alpha=\\frac{1}{2}</span>, but in fact our approach generalizes to any choice where <span class="math">0&lt;\\alpha&lt;1</span>; and whenever appropriate, we will remark how to generalize the scheme’s parameters for arbitrary <span class="math">\\alpha</span>.</p>

    <p class="text-gray-300">For simplicity, in this section we start out by assuming a static committee. In a permissioned setting, this committee can be the set of all nodes. In a permissionless setting where the set of players are not known in advance, we can elect the committee dynamically from the underlying blockchain using known techniques <em>[40, 41]</em> or have stake-holders act as the committee <em>[7, 15, 36]</em> — however we defer the discussion of committee election and reconfiguration to later sections. Although we</p>

    <p class="text-gray-300">assume a static committee in this section, our basic protocol supports leader reconfiguration. In our presentation below we focus on describing the mechanism that enables leader reconfiguration without specifying concretely what leader re-election policy to adopt — exactly what policy to adopt depends on the application context and we thus defer the discussion of policies to later sections.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">3.1 Our Basic Protocol in a Nutshell</h3>

    <p class="text-gray-300">We first describe the intuition behind our basic protocol. For simplicity, we focus our description on what happens within a single epoch in which the identity of the leader is common knowledge.</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">3.1.1 Optimistic Fast Path</h4>

    <p class="text-gray-300">The optimistic fast path consists of a single round of voting to confirm each transaction (or batch). The leader serves as a coordinator and sequences transactions in the optimistic path. It tags each freshly seen transaction (or a batch) with a sequence number that increments over time, and the resulting tuple <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> is referred to as a notarization request. Whenever the committee members hear a notarization request <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> from the leader, it will sign the tuple <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> as long as it has not signed any tuple for <span class="math">\\mathsf{seq}</span> before. For consistency, it is important that an honest committee member signs only one unique tuple <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> for every sequence number <span class="math">\\mathsf{seq}</span>.</p>

    <p class="text-gray-300">Whenever an honest node observes that a notarization request <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> has collected votes from more than <span class="math">\\frac{3}{4}</span> of the committee, <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> is considered notarized. Although any notarized transaction is ready to be confirmed, an honest node is only allowed to output a notarized <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> tuple iff for every <span class="math">s&lt;\\mathsf{seq}</span>, a tuple <span class="math">(s,\\_)</span> has already been output. In other words, the output sequence is not allowed to skip any sequence numbers (since transactions must be processed in a linearized order). Henceforth, we referred to a sequence of notarized transactions with contiguous, non-skipping sequence numbers as a <em>lucky sequence</em>. In other words, honest nodes always output the maximal lucky sequence they have observed.</p>

    <p class="text-gray-300">It is not hard to see that the optimistic, fast path satisfies the following properties as long as <em>the majority of the online committee members are honest</em> (below, we focus our discussion for the specific case <span class="math">\\alpha=\\frac{1}{2}</span>, although the argument can easily be generalized to arbitrary choices of <span class="math">\\alpha</span>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The following <em>agreement</em> property is satisfied even when the leader is corrupt and the committee may not be online: if any two honest nodes have output <span class="math">(\\mathsf{seq},\\mathsf{tx})</span> and <span class="math">(\\mathsf{seq},\\mathsf{tx}^{\\prime})</span> respectively, it must be that <span class="math">\\mathsf{tx}=\\mathsf{tx}^{\\prime}</span> (except with negligible probability over the choice of view).</li>

      <li>The following <em>liveness</em> property is satisfied only when the leader is honest and online and moreover more than <span class="math">\\frac{3}{4}</span> of the committee are honest and online (i.e., when the optimistic conditions hold): every transaction input to an honest node will appear in all nodes’ output logs in <span class="math">O(1)</span> actual roundtrips — in other words, when optimistic conditions hold, not only do we achieve liveness but we in fact also achieve <em>responsiveness</em>.</li>

    </ul>

    <p class="text-gray-300">Note that when the optimistic conditions do not hold, liveness is not guaranteed for the optimistic path. For example, a corrupt leader can propose different transactions to different nodes for the same sequence number, and thus no transaction will collect enough votes to become notarized. Further, progress can also be hampered if not enough committee members are honest and online to vote.</p>

    <p class="text-gray-300">Summarizing the above, if the leader is honest and online and moreover more than <span class="math">\\frac{3}{4}</span> fraction of the committee are honest and online, all nodes will confirm transactions responsively in the</p>

    <p class="text-gray-300">3.1. OUR BASIC PROTOCOL IN A NUTSHELL</p>

    <p class="text-gray-300">optimistic path. However, to make our protocol complete, we need to deal with the case when either the leader is corrupt (or not online), or the committee is not more than <span class="math">\\frac{3}{4}</span> honest and online — in the latter case, we wish to fall back to the worst-case guarantees offered by the underlying blockchain. Below we describe how such fallback can be achieved.</p>

    <h4 id="sec-77" class="text-lg font-semibold mt-6">3.1.2 Falling Back to the Blockchain</h4>

    <p class="text-gray-300">In the fallback slow path, nodes will confirm transactions using the slow blockchain. The most non-trivial part of our protocol is how to switch between the optimistic path and the fallback path. To this end, we must answer the following two questions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>How do nodes decide when to fall back to the slow path?</li>

      <li>Once the above decision is made, what is the mechanism for achieving this fallback?</li>

    </ol>

    <h5 id="sec-78" class="text-base font-semibold mt-4">When to fall back.</h5>

    <p class="text-gray-300">The idea is to use the underlying blockchain to collect evidence of the optimistic path not working (e.g., either due to corrupt or crashed leader or due to not sufficiently many committee members being honest and online). Such evidence must be robust such that the adversary cannot raise false alarms when the optimistic path is actually working.</p>

    <p class="text-gray-300">For conceptual simplicity, we can imagine the following: 1) whenever honest nodes mine a block, they incorporate into the block their entire view so far, including all unnotarized transactions and notarized transactions they have seen — in the actual protocol, the transactions stored in the blockchain can be easily deduplicated and compressed; 2) honest nodes always gossip their views to each other, such that if one honest node sees some (notarized or unnotarized) transaction by round <span class="math">r</span>, then all honest nodes will have seen it by round <span class="math">r+\\Delta</span>. Thus by the liveness property of the underlying blockchain, if any (notarized or unnotarized) transaction is observed by any honest node in round <span class="math">r</span>, then in roughly <span class="math">\\epsilon\\kappa</span> blocks of time, the transaction will appear in the blockchain.</p>

    <p class="text-gray-300">Now, we may use the following criterion to detect when the optimistic path is not working:</p>

    <h5 id="sec-79" class="text-base font-semibold mt-4">Fallback condition:</h5>

    <p class="text-gray-300">Assume that chain is the stabilized prefix of some honest node’s blockchain. If some unnotarized transaction tx appears in the block chain[<span class="math">\\ell</span>] but tx still has not become part of a lucky sequence contained in chain[: <span class="math">\\ell+\\kappa</span>] where <span class="math">\\kappa</span> is a security parameter, then we conclude that the optimistic path has failed, and that a fallback is necessary.</p>

    <p class="text-gray-300">Note that if the optimistic conditions hold, then the leader would have observed the unnotarized tx when its blockchain is roughly <span class="math">\\ell</span> in length, and the committee would have notarized tx quickly; thus tx will soon become part of a lucky sequence contained in every node’s blockchain. If this has not happened within <span class="math">\\kappa</span> blocks of time, then the optimistic conditions must no longer hold.</p>

    <p class="text-gray-300">We also note that using the above mechanism, all honest nodes will decide to fall back within <span class="math">\\Delta</span> rounds from each other. We now reach our next question: what mechanism do we rely on for the falling back?</p>

    <h5 id="sec-80" class="text-base font-semibold mt-4">How to fall back.</h5>

    <p class="text-gray-300">The challenge is that when honest nodes decide to fall back (within <span class="math">\\Delta</span> rounds from each other), although their optimistic logs are prefixes of each other, the logs could be of different lengths. One decision to make during the fallback is where (i.e., at which sequence number) to end the optimistic log before switching to blockchain mode — importantly, for consistency, honest nodes must agree on this decision. We point out that agreeing on this decision actually requires a</p>

    <p class="text-gray-300">1Transactions of a lucky sequence are allowed to appear out of order in the blockchain.</p>

    <p class="text-gray-300">CHAPTER 3. BASIC THUNDERELLA PROTOCOL WITH A STATIC COMMITTEE</p>

    <p class="text-gray-300">full agreement instance — unlike the optimistic path where we punted on liveness, here this decision must be made with both consistency and liveness.</p>

    <p class="text-gray-300">Thus the most natural idea is to rely on the underlying blockchain to reach agreement regarding this decision. To this end, we introduce the notion of a grace period that serves as a cool-down period before we eventually fall back into slow mode. The grace period consists of <span class="math">\\kappa</span> number of consecutive blocks where <span class="math">\\kappa</span> is a security parameter. Let chain denote the stabilized part of an honest node’s blockchain and suppose that <span class="math">\\ell^{<em>}</span> is the first block such that chain[: <span class="math">\\ell^{</em>}</span>] triggers the “fallback condition” as described above. Then, the grace period will consist of the blocks chain<span class="math">[\\ell^{*}+1:\\ell+\\kappa]</span>. Informally speaking, the grace period is utilized in the following manner:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let LOG^{∗} be an honest node’s output log at the moment that the grace period starts (thus LOG^{∗} must be a lucky sequence);</li>

      <li>Let chain be the stabilized prefix of this honest node’s chain:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the grace period has not ended in chain, then the node outputs the longer of 1) LOG^{∗}; and 2) the maximal lucky sequence contained in chain. Note that in this case, the node does not output any additional transactions that are not part of the lucky sequence.</li>

      <li>Else if the grace period has ended in chain, then the node first outputs the maximal lucky sequence contained in chain; then it outputs every other transaction (notarized or unnotarized) contained in chain (in the order that they are included in chain). In other words, after the grace period is over, the nodes start confirming transactions based on the blockchain.</li>

    </ul>

    <p class="text-gray-300">Let LOG_{max} denote the maximal lucky sequence contained in an honest node’s blockchain by the end of the grace period. Effectively, in the above mechanism, nodes agree on LOG_{max} before falling to blockchain mode. Importantly, the following informal claim must hold:</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Claim 1 (Informal).</h6>

    <p class="text-gray-300">Except with negligible probability, LOG_{max} must be at least as long as any honest node’s output log when the node detects the start of the grace period.</p>

    <p class="text-gray-300">To see why, recall that as mentioned earlier, all honest nodes gossip always their protocol views to each other; and honest nodes always embed their entire protocol view into any block they mine (in the actual protocol, the messages can be compressed). Thus, by liveness, any honest node’s output log when the grace period starts will be in the blockchain <span class="math">\\kappa</span> blocks later.</p>

    <h4 id="sec-82" class="text-lg font-semibold mt-6">3.1.3 Initiating a New Optimistic Epoch</h4>

    <p class="text-gray-300">So far, we have described our protocol from the perspective of a single epoch in which the leader is common knowledge. Whenever the protocol is in a slow path, however, we would like to allow the nodes to try to reinitiate an optimistic epoch and try to be fast again. This is easy to achieve since our underlying blockchain is always up and live! Thus one can simply rely on the underlying blockchain to implement any policy-based decision to reinitiate a new epoch. For example, the blockchain can be used to agree on 1) at which block length to reinitiate a new epoch; and 2) who will act as the leader in the new epoch. Our Thunderella framework leaves it to the application layer to specify such policy decisions (e.g., such policies can be implemented through generic smart contracts running atop the underlying blockchain).</p>

    <p class="text-gray-300">Our detailed description in the remainder of this section is aware of the existence of multiple epochs, and thus transactions’ sequence numbers are tagged with the epoch number to avoid namespace collision.</p>

    <p class="text-gray-300">3.2 Detailed Protocol Description</p>

    <p class="text-gray-300">We now formally describe our basic Thunderella protocol with a static committee. Our description and proofs are modularized. Specifically, we first describe the minimal set of protocol instructions necessary for guaranteeing consistency (Section 3.2.2) — in an actual implementation, security audit should be prioritized for this part of the protocol. We then describe other surrounding mechanisms (e.g., how to concretely instantiate the chain state function and how the leader proposes transactions) that allow us to additionally achieve worst-case liveness (Section 3.2.3) and optimistic responsiveness (Section 3.2.4).</p>

    <h4 id="sec-83" class="text-lg font-semibold mt-6">Concrete blockchain parameters.</h4>

    <p class="text-gray-300">For concreteness, henceforth in this section we assume a blockchain protocol denoted <span class="math">\\Pi_{\\text{blockchain}}</span> that achieves <span class="math">(0.05\\kappa,g_{0},g_{1}=\\frac{1}{c\\Delta})</span>-chain growth for some positive <span class="math">g_{0}</span> and some positive constant <span class="math">c</span>, <span class="math">(0.05\\kappa,1,\\mu)</span>-chain quality where <span class="math">\\mu</span> is positive, <span class="math">0.05\\kappa</span>-consistency, and <span class="math">(0.05\\kappa,0.05\\kappa)</span>-liveness w.r.t. to any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\text{blockchain}}</span>. All the concrete blockchain instantiations mentioned earlier in Section 2.4 satisfy these parameters (Theorems 4, 5, and 6). Although we assume these concrete parameters, our Thunderella framework can easily be generalized to other parameters.</p>

    <h4 id="sec-84" class="text-lg font-semibold mt-6">3.2.1 Useful Definitions</h4>

    <p class="text-gray-300">Henceforth, let <span class="math">\\Sigma=(\\textsf{Gen},\\textsf{Sign},\\textsf{Vf})</span> denote a digital signature scheme.</p>

    <h4 id="sec-85" class="text-lg font-semibold mt-6">Notarized transactions.</h4>

    <p class="text-gray-300">We say that a tuple <span class="math">(e,s,\\mathsf{m},V)</span> is a notarized transaction for epoch <span class="math">e</span> and sequence number <span class="math">s</span> w.r.t. committee iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">(\\mathsf{pk},\\sigma)\\in V</span>, <span class="math">\\mathsf{pk}\\in\\textsf{committee}</span> and moreover <span class="math">\\sigma</span> is a valid signature for <span class="math">(e,s,\\mathsf{m})</span> under <span class="math">\\mathsf{pk}</span> — in this case, we also say that <span class="math">(\\mathsf{pk},\\sigma)</span> is a valid vote for <span class="math">(e,s,\\mathsf{m})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- There are more than $\\frac{3}{4}\\cdot\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\textsf{committee}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> votes in </span>V<span class="math"> with distinct </span>\\mathsf{pks}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">(e,s,\\mathsf{m},V)</span> is a notarized transaction, we also say that <span class="math">V</span> is a valid notarization for <span class="math">(e,s,\\mathsf{m})</span>.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Note that the above definition works for <span class="math">\\alpha=\\frac{1}{2}</span>. For a general <span class="math">\\alpha\\in(0,1]</span>, we can simply replace the constant <span class="math">\\frac{3}{4}</span> with <span class="math">1-\\frac{\\alpha}{2}</span>.</p>

    <h4 id="sec-87" class="text-lg font-semibold mt-6">Blockchain states.</h4>

    <p class="text-gray-300">We assume that there is a deterministic and efficiently computable function <span class="math">\\Gamma</span> such that given an abstract blockchain chain, the function <span class="math">\\Gamma</span> divides chain into multiple epochs interspersed with interims. Each epoch is a sequence of consecutive blocks in chain, and <span class="math">f</span> also outputs a unique epoch number <span class="math">e</span> for each epoch. A sequence of consecutive blocks that do not belong to any epoch are called interim blocks. Each epoch always contains two sub-phases, an optimistic period followed by a grace period, each of which contains at least <span class="math">\\kappa</span> consecutive blocks and thus each epoch contains at least <span class="math">2\\kappa</span> consecutive blocks (unless end of chain is reached).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Formally, we say that <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot)</span> is a chain-state function iff for any chain and $0\\leq\\ell\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\Gamma(\\kappa,\\textsf{chain},\\ell)$ outputs one of the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>some <span class="math">(e,\\textsf{optimistic})</span>: in this case we say that <span class="math">\\textsf{chain}[\\ell]</span> is an optimistic block belonging to epoch <span class="math">e</span> (w.r.t. <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot)</span>);</li>

      <li>some <span class="math">(e,\\textsf{grace})</span>: in this case we say that <span class="math">\\textsf{chain}[\\ell]</span> is a grace block belonging to epoch <span class="math">e</span> (w.r.t. <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot)</span>);</li>

    </ul>

    <p class="text-gray-300">CHAPTER 3. BASIC THUNDERELLA PROTOCOL WITH A STATIC COMMITTEE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>or interim: in this case we say that chain[ℓ] is an interim block (w.r.t. Γ(κ,·,·)).</li>

    </ul>

    <p class="text-gray-300">We say that a chain-state function Γ(κ,·,·) is admissible iff for any chain:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. for any 0 ≤ ℓ ≤ ℓ′ ≤</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, if chain[ℓ] belongs to epoch e and chain[ℓ′] belongs to epoch e′, then e′ ≥ e;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every e: all blocks corresponding to epoch e in chain must appear in a consecutive window, and moreover, all optimistic blocks for epoch e must appear before grace blocks for epoch e;</li>

      <li>for every epoch e appearing in chain: there must be at least κ grace blocks belonging to epoch e in chain unless chain ends at an epoch-e block.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. for every chain and every 0 ≤ ℓ ≤</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, Γ(κ,chain,ℓ) depends only on chain[: ℓ] but not chain[ℓ + 1 :].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lucky sequence.</strong> A sequence of notarized transactions {(e_i, s_i, m_i, V_i)}_i∈[m] is said to be a lucky sequence for epoch e iff for all i ∈ [m], e_i = e and s_i = i.</p>

    <p class="text-gray-300"><strong>Blockchain linearization.</strong> Given an abstract blockchain chain, we do not simply output all transactions in chain in the most natural way. Instead, we adopt an algorithm denoted linearizeΓ(κ,·,·)(chain) for chain linearization. Henceforth we often write linearize(chain) for simplicity without explicitly denoting the chain-state function Γ(κ,·,·).</p>

    <p class="text-gray-300">Our chain linearization algorithm linearize(chain) is defined as follows: scan through the chain from left to right, and output the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each epoch chain[ℓ : ℓ′] encountered with the epoch number e, output the following in order:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>first extract the maximal lucky sequence TXs for epoch e from chain[: ℓ′] and output strip(TXs) where strip(·) will be defined below;</li>

      <li>if chain[ℓ] is not the end of chain, let TXs′ be all remaining records in chain[ℓ : ℓ′] not contained in TXs, output strip(TXs′);</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each interim chain[ℓ : ℓ′] encountered, extract all transactions TXs from chain[ℓ : ℓ′] and output strip(TXs).</li>

    </ol>

    <p class="text-gray-300">In the above, the function strip(·) removes signatures from notarized transactions: for a notarized transaction strip(e, s, m, V) := (e, s, m); for an unnotarized transaction we define strip(m) := m. If the input to strip(·) is a sequence of transactions, the same operation is applied to each transaction.</p>

    <h2 id="sec-88" class="text-2xl font-bold">3.2.2 Π Thunder: Core Protocol for Consistency</h2>

    <p class="text-gray-300"><strong>Additional notation.</strong> A node's view consists of every message (including blockchains) it has received from Z or over the network. Henceforth we say that a notarized transaction (e, s, m, V) is in a node's view iff (e, s, m) exists in the node's view, and every (pk, σ) ∈ V exists in the node's view (not necessarily appearing together in the node's view). Multiple notarized transactions can exist for a unique (e, s, m) by taking different subsets of V — but in our presentation below, we always take V to be all the valid votes for (e, s, m) in a node's view, such that if for some tuple (e, s, m) there is a notarized transaction (e, s, m, V) in a node's view, then the choice is unique.</p>

    <p class="text-gray-300"><strong>Assumptions.</strong> Although not explicitly noted, henceforth in all of our protocols, we assume that whenever an honest node receives any message on the network, if the message has not been broadcast before, the honest node broadcasts the message.</p>

    <p class="text-gray-300">3.2. DETAILED PROTOCOL DESCRIPTION</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\mathrm{thunder}}</span>. Below we describe the <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> protocol that is parametrized by an admissible chain-state function <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot)</span>. Henceforth in our scheme, we often omit explicitly writing the chain-state function <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Call <span class="math">(\\mathsf{pk},\\mathsf{sk})\\gets \\Sigma .\\mathsf{Gen}(\\kappa)</span> to generate a signing key pair. Output <span class="math">\\mathsf{pk}</span> to <span class="math">\\mathcal{Z}</span>.</li>

      <li>Wait to receive committee from <span class="math">\\mathcal{Z}</span>, and henceforth, validity of votes and acceptability of chains will be defined w.r.t. committee.</li>

      <li>Fork an instance of the <span class="math">\\Pi_{\\mathrm{blockchain}}</span> protocol with appropriate parameters determined by <span class="math">\\rho, n</span> and <span class="math">\\Delta^2</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Notarize. Upon receiving notarization request <span class="math">(e, s, \\mathfrak{m})</span> from <span class="math">\\mathcal{Z}</span>: if <span class="math">\\mathsf{pk} \\in \\text{committee}</span> and no signature has been produced for <span class="math">(e, s)</span> earlier, compute <span class="math">\\sigma := \\Sigma \\cdot \\operatorname{Sign}_{\\mathbf{sk}}(e, s, \\mathfrak{m})</span> and broadcast <span class="math">((e, s, \\mathfrak{m}), \\sigma)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Propose. Every round, let chain be the output from the <span class="math">\\Pi_{\\mathrm{blockchain}}</span> instance.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{TXs}</span> be a set containing 1) every notarized transaction <span class="math">(e,s,\\mathfrak{m},V)</span> in the node's view such that no notarized transaction <span class="math">(e,s,\\mathfrak{m}, - )</span> has appeared in chain[: <span class="math">-0.5\\kappa</span>]; and 2) every unnotarized transaction <span class="math">\\mathfrak{m}</span> in the node's view such that no <span class="math">\\mathfrak{m}</span> or notarized transaction <span class="math">(e,s,\\mathfrak{m}, - )</span> has appeared in chain[: <span class="math">-0.5\\kappa</span>].</li>

      <li>Propose TXs to <span class="math">\\Pi_{\\mathrm{blockchain}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output. In every round, let chain be the output from <span class="math">\\Pi_{\\mathrm{blockchain}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If chain[-0.5κ] is an optimistic block belonging to epoch <span class="math">e</span>:</li>

    </ul>

    <p class="text-gray-300">a) let chain[-l] be the starting block for epoch <span class="math">e</span> in chain where <span class="math">\\ell \\geq 0.5\\kappa</span> b) extract the maximal lucky sequence TXs for epoch <span class="math">e</span> from the node's view so far.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c) let $\\overline{\\mathsf{LOG}} := \\text{linearize}(\\text{chain}[: -(\\ell + 1)])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else, let <span class="math">\\overline{\\mathsf{LOG}} := \\text{linearize}(\\text{chain}[: -0.5\\kappa])</span>.</li>

      <li>Let LOG be the previous output to <span class="math">\\mathcal{Z}</span>: if LOG is longer than LOG, output LOG; else output LOG to <span class="math">\\mathcal{Z}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mempool. Upon receiving any other message from the network or <span class="math">\\mathcal{Z}</span>, record the tuple.</li>

    </ul>

    <p class="text-gray-300">Compliant executions. We say that <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{blockchain}}</span>;</li>

      <li>in every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>, <span class="math">\\mathcal{Z}</span> always inputs the same committee to all honest nodes;</li>

      <li>in every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>, more than <span class="math">\\frac{1}{2}</span> fraction (or in general, more than <span class="math">\\alpha</span> fraction) of the distinct public keys in committee are output by nodes that remain honest (but not necessarily online) forever.</li>

    </ul>

    <p class="text-gray-300">2Unless otherwise noted, all messages sent from the <span class="math">\\Pi_{\\mathrm{blockchain}}</span> instance or destined for <span class="math">\\Pi_{\\mathrm{blockchain}}</span> are automatically passed through, but these messages also count towards the view of the current <span class="math">\\Pi_{\\mathrm{thunder}}</span> protocol instance.</p>

    <p class="text-gray-300">The following theorem says that for any chain-state function <span class="math">f</span> that is admissible, <span class="math">\\Pi^{f}_{\\text{thunder}}</span> satisfies consistency under compliant executions.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Theorem 8 (Consistency).</h6>

    <p class="text-gray-300">Let <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot)</span> be any admissible chain-state function. Then, <span class="math">\\Pi^{\\Gamma(\\kappa,\\cdot,\\cdot)}_{\\text{thunder}}</span> satisfies consistency as defined in Section 2.2 w.r.t. any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi^{\\Gamma(\\kappa,\\cdot,\\cdot)}_{\\text{thunder}}</span>.</p>

    <p class="text-gray-300">The proof of this theorem will be presented in Section 3.3.1.</p>

    <h4 id="sec-90" class="text-lg font-semibold mt-6">3.2.3 Concrete Chain-State Function and Worst-Case Liveness</h4>

    <p class="text-gray-300">We will adopt the following chain-state function <span class="math">\\Gamma^{\\mathsf{pred}}(\\kappa,\\cdot,\\cdot)</span> that is parametrized by a polynomial-time boolean predicate pred henceforth referred to as the “next-epoch” function. Basically, the job of pred is to examine the prefix of some blockchain and decide whether we want to advance to a larger epoch. Specifically, for some chain prefix chain[: <span class="math">i</span>] if <span class="math">\\mathsf{pred}(\\mathsf{chain}[:i],e)=1</span> then the blockchain wants to advance to epoch <span class="math">e</span> if it is not already in epoch <span class="math">e</span> — if there are multiple such <span class="math">e</span>’s such that the above holds, then the blockchain wants to go the the largest such epoch.</p>

    <p class="text-gray-300">At this moment, we define the chain state function <span class="math">\\Gamma</span> while leaving the pred unspecified. We will show that worst-case liveness is satisfied in compliant executions regardless of the concrete policy pred. Intuitively, our concrete chain state function is very simple: If the blockchain is currently in some epoch <span class="math">e</span>, then the chain will stay in epoch <span class="math">e</span> unless one of the following things happen:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>either pred (applied to the prefix of the blockchain) wants to go to a larger epoch; or</li>

      <li>during the current epoch some transaction did not get confirmed for a long time.</li>

    </ol>

    <p class="text-gray-300">If one of the above did happen, then the chain gracefully transitions to an interim ensuring that there are at least <span class="math">\\kappa</span> optimistic blocks for the current epoch <span class="math">e</span> followed by at least <span class="math">\\kappa</span> grace blocks for epoch <span class="math">e</span>. If the blockchain is in an interim and pred wants to go to a next epoch, then we advance to the next epoch immediately. We note that for consistency and worst-case liveness, we in fact only need that there are at least <span class="math">\\kappa</span> grace blocks for each epoch (but not necessarily <span class="math">\\kappa</span> or more optimistic blocks). Here we additionally require that there are at least <span class="math">\\kappa</span> optimistic blocks for each epoch too — this gives the new epoch some time such that the blockchain can pick up possibly stale transanctions that ought to have been confirmed such that we do not exit from the current epoch too soon.</p>

    <p class="text-gray-300">More formally, for any chain, <span class="math">\\Gamma^{\\mathsf{pred}}(\\kappa,\\mathsf{chain},\\cdot)</span> is inductively defined as the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The chain[<span class="math">0</span>] := genesis block is considered an interim block;</li>

      <li>If chain[<span class="math">i</span>] is an interim block, let <span class="math">e</span> be the largest epoch number such that <span class="math">\\mathsf{pred}(\\mathsf{chain}[:i+1],e)=1</span>, but no prefix of chain[: <span class="math">i</span>] was ever in epoch <span class="math">e</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If such an epoch <span class="math">e</span> is found: then <span class="math">\\mathsf{chain}[i+1..i+\\kappa]</span> are all optimistic blocks for epoch <span class="math">e^{\\prime}</span> (and if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><i+\\kappa<span class="math">, then all of </span>\\mathsf{chain}[i+1:<span class="math">] are optimistic blocks for epoch </span>e^{\\prime}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else <span class="math">\\mathsf{chain}[i+1]</span> is also an interim block;</li>

      <li>If chain[<span class="math">i</span>] is the <span class="math">\\ell</span>-th optimistic block of some epoch <span class="math">e</span> where <span class="math">\\ell\\geq\\kappa</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If one of the following two conditions C1 or C2 hold, then <span class="math">\\mathsf{chain}[i+1..i+\\kappa]</span> are all grace blocks for epoch <span class="math">e</span>, and <span class="math">\\mathsf{chain}[i+\\kappa+1]</span> is an interim block (and if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq i+\\kappa<span class="math"> then all of </span>\\mathsf{chain}[i+1:<span class="math">] are grace blocks for epoch </span>e$):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3.2. DETAILED PROTOCOL DESCRIPTION</p>

    <p class="text-gray-300">C1: some <span class="math">\\mathfrak{m}</span> or some notarized transaction <span class="math">(-, -, \\mathfrak{m}, -)</span> appears in chain[: <span class="math">i - 0.5\\kappa</span>] but linearize(chain[: <span class="math">i</span>]) does not contain <span class="math">\\mathfrak{m}</span> or <span class="math">(-, -, \\mathfrak{m})</span>, i.e., if some transaction has not occurred in any lucky sequence even after a sufficiently long time; C2: there exists some <span class="math">e&#x27; &amp;gt; e</span> such that <span class="math">\\text{pred}(\\text{chain}[: i + 1], e&#x27;) = 1</span>, i.e., if the next-epoch policy function wants to switch to a larger epoch than the current one.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else chain <span class="math">[i + 1]</span> is an optimistic block of epoch <span class="math">e</span>.</li>

    </ul>

    <p class="text-gray-300">Theorem 9 (Worst-case liveness). Let <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot) \\coloneqq \\Gamma^{\\mathrm{pred}}(\\cdot, \\cdot, \\cdot)</span> be the chain-state function as specified above for any polynomial-time boolean predicate pred. Let <span class="math">g_0</span> denote the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>'s chain growth lower bound parameter, and let <span class="math">T_{\\mathrm{confirm}}(\\kappa) \\coloneqq \\frac{3\\kappa}{g_0}</span>. For any p.p.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for every <span class="math">\\kappa \\in \\mathbb{N}</span>, except with <span class="math">\\mathrm{negl}(\\kappa)</span> probability over the choice of view <span class="math">\\leftarrow \\mathrm{EXEC}^{\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>, the following holds: suppose that <span class="math">\\mathcal{Z}</span> inputs a transaction <span class="math">\\mathfrak{m}</span> to an honest node in round <span class="math">r</span>, then in any round <span class="math">r&#x27; \\geq r + T_{\\mathrm{confirm}}(\\kappa)</span>, all honest and online nodes' output LOG to <span class="math">\\mathcal{Z}</span> will contain some <span class="math">(-, -, \\mathfrak{m})</span> or <span class="math">\\mathfrak{m}</span>.</p>

    <p class="text-gray-300">The proof of the above theorem is deferred to Section 3.3.2.</p>

    <h2 id="sec-91" class="text-2xl font-bold">3.2.4 Coordination Protocol <span class="math">\\Pi_{\\mathrm{ella}}</span> and Optimistic Responsiveness</h2>

    <p class="text-gray-300">We now describe the full protocol <span class="math">\\Pi_{\\mathrm{ella}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> that spells out the leader-based coordination mechanism on top of <span class="math">\\Pi_{\\mathrm{thunder}}</span> as well as the next-epoch function pred. We will then show under exactly what optimistic conditions our protocol achieves responsiveness.</p>

    <p class="text-gray-300">Description of protocol <span class="math">\\Pi_{\\mathrm{ella}}</span>. <span class="math">\\Pi_{\\mathrm{ella}}</span> calls <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma^{\\mathrm{pred}}(\\kappa, \\cdot, \\cdot)}</span> where the chain state function <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot) \\coloneqq \\Gamma^{\\mathrm{pred}}(\\kappa, \\cdot, \\cdot)</span> is as defined in Section 3.2.3. We spell out the next-epoch function pred and the rest of <span class="math">\\Pi_{\\mathrm{ella}}</span> below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next-epoch function. The policy function <span class="math">\\text{pred}(\\text{chain}, e)</span> takes in an abstract blockchain denoted chain and an epoch number <span class="math">e</span>. If there exists a notarized transaction for epoch <span class="math">e</span> in chain, then output 1; else output 0.</li>

      <li>Initialize: fork an instance of the <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> protocol.</li>

      <li>Leader switch: upon input leader<span class="math">(e, i)</span>: if no leader has been recorded for epoch <span class="math">e</span>, record <span class="math">i</span> as the leader for epoch <span class="math">e</span>, and do the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if current node is <span class="math">i</span>: send a notarization request for a special epoch-start transaction <span class="math">(e, s = 1, \\text{start})</span>, and let <span class="math">s = 2</span>;</li>

      <li>for every notarization request <span class="math">(e, s, \\mathfrak{m})</span> received earlier from node <span class="math">i</span>, act as if <span class="math">(e, s, \\mathfrak{m})</span> has just been received from <span class="math">i</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Notarization: upon receiving notarization request <span class="math">(e, s, \\mathfrak{m})</span> from <span class="math">i</span>: if <span class="math">i</span> has been recorded as the leader for epoch <span class="math">e</span>, forward the notarization request <span class="math">(e, s, \\mathfrak{m})</span> to <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span>; else ignore the request.</li>

      <li>Leader: every round: let <span class="math">e</span> be the largest epoch recorded thus far and if current node is recorded as the leader for epoch <span class="math">e</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">\\mathfrak{m}</span> in view such that no <span class="math">\\mathfrak{m}</span> or <span class="math">(-, -, \\mathfrak{m})</span> appears in linearize(chain[: <span class="math">-\\kappa</span>]), if a notarization request has not been broadcast for <span class="math">\\mathfrak{m}</span> earlier, then broadcast the notarization request <span class="math">(e, s, \\mathfrak{m})</span> and let <span class="math">s := s + 1</span>.</li>

    </ul>

    <p class="text-gray-300">CHAPTER 3. BASIC THUNDERELLA PROTOCOL WITH A STATIC COMMITTEE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Other messages: pass through all other messages between <span class="math">\\Pi_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> and <span class="math">\\mathcal{Z}</span>; similarly pass through all other messages between <span class="math">\\Pi_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> and the network.</li>

    </ul>

    <p class="text-gray-300">Compliant executions. To guarantee consistency and worst-case liveness, basically we just need the same conditions as our earlier <span class="math">\\Pi_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span>. We say that <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\text{ella}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> iff <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span>.</p>

    <p class="text-gray-300">Lucky epoch. Below we will describe exactly under what optimistic conditions can we achieve responsiveness. Roughly speaking, whenever a lucky epoch begins, after a short warmup time, we can achieve responsiveness. Specifically, during a lucky epoch, the epoch's leader is online and honest and more than <span class="math">\\frac{3}{4}</span> fraction (or in general, <span class="math">1 - \\frac{\\alpha}{2}</span> fraction of the committee remain honest and online.</p>

    <p class="text-gray-300">Formally, given a view, we say that <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> belongs to a lucky epoch corresponding to epoch <span class="math">e</span> and leader <span class="math">i</span> iff the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In any round <span class="math">r \\geq T_{\\mathrm{start}} + \\Delta</span>, any honest and online node should have received leader <span class="math">(e, i)</span> where <span class="math">i</span> is the common leader that all honest nodes receive for epoch <span class="math">e</span>. Further, prior to <span class="math">T_{\\mathrm{start}}</span>, no honest node has received from <span class="math">\\mathcal{Z}</span> any leader <span class="math">(e&#x27;, -)</span> instruction where <span class="math">e&#x27; \\geq e</span>.</li>

      <li>the leader (i.e., node <span class="math">i</span>) is honest and online at in any round <span class="math">t \\in [T_{\\mathrm{start}}, T_{\\mathrm{end}} + 3\\Delta]</span>;</li>

      <li>more than <span class="math">\\frac{3}{4}</span> fraction (or in general, more than <span class="math">1 - \\frac{\\alpha}{2}</span> fraction) of committee are honest and online in any round <span class="math">t \\in [T_{\\mathrm{start}}, T_{\\mathrm{end}} + 3\\Delta]</span>.</li>

    </ul>

    <p class="text-gray-300">Optimistic responsiveness in lucky epochs. We say that a protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{\\mathrm{warmup}}, T_{\\mathrm{opt}})</span>-optimistic responsiveness in lucky epochs w.r.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> iff except with <span class="math">\\mathrm{negl}(\\kappa)</span> probability over the choice of view <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\mathrm{ella}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>: for any duration <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> in view that belongs to a lucky epoch, <span class="math">[T_{\\mathrm{start}} + T_{\\mathrm{warmup}}, T_{\\mathrm{end}}]</span> is a <span class="math">T_{\\mathrm{opt}}</span>-responsive period in view.</p>

    <p class="text-gray-300">Theorem 10 (Optimistic case responsiveness). Let <span class="math">g_0</span> be the underlying <span class="math">\\Pi_{\\text{blockchain}}</span>'s chain growth lower bound parameter. For every p.p.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\text{ella}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}, \\Pi_{\\text{ella}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> satisfies <span class="math">(T_{\\text{warmup}}, T_{\\text{opt}})</span>-optimistic responsiveness in lucky epochs for <span class="math">T_{\\text{warmup}} = O\\left(\\frac{\\kappa}{g_0}\\right)</span>, and <span class="math">T_{\\text{opt}} = 3\\delta</span> where <span class="math">\\delta</span> is the actual maximum network delay in view.</p>

    <p class="text-gray-300">The proof of the above theorem is deferred to Section 3.3.3. We note that Theorem 10 implies the following: informally speaking, if throughout the execution more than <span class="math">\\frac{3}{4}</span> fraction of the committee remain honest and online and moreover, the initial epoch's leader remains honest and online, then once nodes enter the initial epoch, after a short warmup period, our protocol <span class="math">\\Pi_{\\mathrm{ella}}</span> will achieve responsiveness throughout the remainder of the execution (assuming that the underlying blockchain is secure).</p>

    <p class="text-gray-300">Remark 3 (Leader re-election mechanism). In our scheme earlier, we left it unspecified how the environment <span class="math">\\mathcal{Z}</span> will decide when to issue leader-switch instructions of the form leader <span class="math">(e,i)</span> that will cause nodes to start a new leader epoch. This is an application-specific policy decision. At this point, our paper focuses on providing a general framework that enables any application-specific policy decisions. Later in our paper, we will give some suggestions on leader re-election policies that are useful in practice.</p>

    <p class="text-gray-300">3We say that a public key <span class="math">\\mathsf{pk} \\in \\mathsf{committee}</span> is honest and online in round <span class="math">r</span> if some node that is honest and online in round <span class="math">r</span> output <span class="math">\\mathsf{pk}</span> to <span class="math">\\mathcal{Z}</span> earlier.</p>

    <p class="text-gray-300">3.3. PROOFS FOR BASIC THUNDERELLA WITH STATIC COMMITTEE</p>

    <h2 id="sec-92" class="text-2xl font-bold">3.3 Proofs for Basic Thunderella with Static Committee</h2>

    <p class="text-gray-300">We now move onto presenting the formal proofs for our basic Thunderella protocol.</p>

    <p class="text-gray-300"><strong>Shorthand notations.</strong> Henceforth in Section 3.3.1 and 3.3.2, whenever we say that “except with negligible probability over the choice of view, some property ev(view) holds”, we formally mean that for any <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa,\\cdot,\\cdot)}</span> thunder, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for every <span class="math">\\kappa \\in \\mathbb{N}</span>, except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability over the choice of view <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa,\\cdot,\\cdot)}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, ev(view) holds. Similarly, in Section 3.3.3, whenever we say that “except with negligible probability over the choice of view, some property ev(view) holds”, we formally mean the same as above but now referring to <span class="math">\\Pi_{\\mathrm{ella}}^{\\Gamma(\\kappa,\\cdot,\\cdot)}</span> instead.</p>

    <h2 id="sec-93" class="text-2xl font-bold">3.3.1 Consistency</h2>

    <p class="text-gray-300"><strong>Lemma 2 (Uniqueness).</strong> Assume that the signature scheme is secure, then except with negligible probability over the choice of view, the following holds. For any <span class="math">(e,s)</span> pair, if two notarized transactions <span class="math">(e,s,\\mathfrak{m},V)</span> and <span class="math">(e,s,\\mathfrak{m}&#x27;,V&#x27;)</span> appear in view, then it must be the case that <span class="math">\\mathfrak{m} = \\mathfrak{m}&#x27;</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> For <span class="math">V</span> or <span class="math">V&#x27;</span> to be a notarization for <span class="math">(e, s, \\mathfrak{m})</span> and <span class="math">(e, s, \\mathfrak{m}&#x27;)</span> respectively, there must be more than <span class="math">\\frac{3}{4} M</span> number of signatures from distinct members of committee where $M :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{committee}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since the adversary controls </span>f &lt; \\frac{1}{2} M<span class="math"> members of committee, it must be that at least </span>\\frac{3}{4} M - f<span class="math"> honest members of committee have signed </span>(e, s, \\mathfrak{m})<span class="math"> — otherwise we can leverage </span>(\\mathcal{A}, \\mathcal{Z})<span class="math"> to build a reduction that breaks the signature security. Similarly, at least </span>\\frac{3}{4} M - f<span class="math"> honest members of committee have signed </span>(e, s, \\mathfrak{m}')<span class="math">. Thus, by the pigeon-hole principle at least one honest member of committee has signed both </span>(e, s, \\mathfrak{m})<span class="math"> and </span>(e, s, \\mathfrak{m}')<span class="math">. By definition of the honest protocol, honest nodes will sign each sequence number no more than once. Thus it holds that </span>\\mathfrak{m} = \\mathfrak{m}'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Fact 4.</strong> Let <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot)</span> be any admissible chain-state function. Then for any chain and any $0 \\leq i &lt; j \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\text{linearize}^{\\Gamma(\\kappa, \\cdot, \\cdot)}(\\text{chain}[: i]) \\prec \\text{linearize}^{\\Gamma(\\kappa, \\cdot, \\cdot)}(\\text{chain}[: j])$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Follows directly from the admissibility definition of <span class="math">\\Gamma</span> and the definition of linearize.</p>

    <p class="text-gray-300">Let <span class="math">\\overline{\\mathsf{LOG}_i^r}</span> denote the internal variable <span class="math">\\overline{\\mathsf{LOG}}</span> of node <span class="math">i</span> in round <span class="math">r</span>.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot)</span> be any admissible chain-state function. Except with negligible probability over the choice of view, the following holds: for any <span class="math">r</span> and <span class="math">t</span>, for any node <span class="math">i</span> honest and online in round <span class="math">r</span> and any node <span class="math">j</span> honest and online in round <span class="math">t</span>, either <span class="math">\\overline{\\mathsf{LOG}_i^r} \\prec \\overline{\\mathsf{LOG}_j^t}</span> or <span class="math">\\overline{\\mathsf{LOG}_j^t} \\prec \\overline{\\mathsf{LOG}_i^t}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> In every round, an honest node's <span class="math">\\overline{\\mathsf{LOG}}</span> is of the generalized form $\\text{linearize}(\\text{chain}[: -\\ell])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs})$ where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>either <span class="math">\\mathsf{TXs}</span> is empty and <span class="math">\\ell = 0.5\\kappa</span> or</li>

      <li><span class="math">\\mathsf{TXs}</span> is a non-empty lucky sequence for some epoch <span class="math">e</span> and <span class="math">\\ell \\geq 0.5\\kappa</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that $\\overline{\\mathsf{LOG}}_i^r \\coloneqq \\text{linearize}(\\text{chain}_i^r[: -\\ell])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs})<span class="math"> and </span>\\overline{\\mathsf{LOG}}_j^t \\coloneqq \\text{linearize}(\\text{chain}_j^t[: -\\ell'])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs}')<span class="math"> are output logs by node </span>i<span class="math"> in round </span>r<span class="math"> and by node </span>j<span class="math"> in round </span>t$ respectively in view. Henceforth we ignore the negligible fraction of views where relevant bad events happen. For the remaining good views, the following statements hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By consistency of <span class="math">\\Pi_{\\mathrm{blockchain}}</span>, either <span class="math">\\mathsf{chain}_i^r[: -\\ell] \\prec \\mathsf{chain}_j^t[: -\\ell&#x27;]</span> or <span class="math">\\mathsf{chain}_j^t[: -\\ell&#x27;] \\prec \\mathsf{chain}_i^r[: -\\ell]</span>. Without loss of generality, henceforth we assume that <span class="math">\\mathsf{chain}_i^r[: -\\ell] \\prec \\mathsf{chain}_j^t[: -\\ell&#x27;]</span>. We now consider the following cases:</p>

    <p class="text-gray-300">CHAPTER 3. BASIC THUNDERELLA PROTOCOL WITH A STATIC COMMITTEE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\mathsf{TXs}</span> is empty. In this case, it follows directly from Fact 4 that <span class="math">\\overline{\\mathsf{LOG}_i^r} \\prec \\overline{\\mathsf{LOG}_j^t}</span>.</li>

      <li>Case 2: <span class="math">\\mathsf{TXs}</span> is non-empty. In this case, <span class="math">\\mathsf{chain}_i^r [-\\ell +1]</span> must be the starting block of some epoch <span class="math">e</span>, and <span class="math">\\mathsf{chain}_i^r [-0.5\\kappa ]</span> must be an optimistic block of epoch <span class="math">e</span>. We now consider the following sub-cases:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2a: Epoch <span class="math">e</span> has completed in <span class="math">\\mathsf{chain}_j^t [-\\ell &#x27;]</span>, i.e., there are two adjacent blocks such that the former belongs to epoch <span class="math">e</span> and the latter does not in <span class="math">\\mathsf{chain}_j^t [-\\ell &#x27;]</span>. Let <span class="math">\\mathsf{chain}_j^t [-\\ell ^* ]</span> denote the last block of epoch <span class="math">e</span> in <span class="math">\\mathsf{chain}_j^t [-\\ell &#x27;]</span>. By Fact 4, it suffices to prove that $\\text{linearize}(\\mathsf{chain}_i^r [-\\ell ])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs}) \\prec \\text{linearize}(\\mathsf{chain}_j^t [-\\ell ^* ])$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By definition of the honest protocol, <span class="math">\\mathsf{TXs}</span> must be a lucky sequence for epoch <span class="math">e</span> in node <span class="math">i</span>'s view in round <span class="math">r</span>, and further, by round <span class="math">r + \\Delta</span>, <span class="math">\\mathsf{TXs}</span> must exist in any honest node's view. By the admissibility of the chain-state function <span class="math">\\Gamma</span> and the fact that <span class="math">\\mathsf{chain}_i^r [-0.5\\kappa ]</span> is an optimistic block of epoch <span class="math">e</span>, <span class="math">\\mathsf{chain}_j^t [-\\ell^* ]</span> must be at least <span class="math">0.5\\kappa</span> longer than <span class="math">\\mathsf{chain}_i^r</span>. By chain growth upper bound, by round <span class="math">r + \\Delta</span>, any honest chain must be at most <span class="math">\\ell_i^r + 0.25\\kappa</span> in length where $\\ell_i^r \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_i^r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By liveness, a lucky sequence of length </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{TXs}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for epoch </span>e<span class="math"> must appear in </span>\\mathsf{chain}_j^t [-\\ell^* ]$. The remainder of the proof follows from definition of linearize and Lemma 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2b: Epoch <span class="math">e</span> has not completed in <span class="math">\\mathsf{chain}_j^t [-\\ell &#x27;]</span>. Recall that node <span class="math">i</span> outputs $\\text{linearize}(\\mathsf{chain}_i^r [-\\ell ])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs})<span class="math"> in round </span>r<span class="math">. By definition of the honest algorithm, and since </span>\\mathsf{chain}_i^r [-\\ell ] \\prec \\mathsf{chain}_j^t [-\\ell ']<span class="math">, node </span>j<span class="math">&#x27;s output in round </span>t<span class="math"> must be of the form </span>\\text{linearize}(\\mathsf{chain}_i^r [-\\ell ])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs}^<em>)<span class="math"> where </span>\\mathsf{TXs}^</em><span class="math"> is either empty or some lucky sequence for epoch </span>e<span class="math"> in node </span>j<span class="math">&#x27;s view in round </span>t<span class="math">. By Lemma 2, it holds that either </span>\\overline{\\mathsf{LOG}_i^r} \\prec \\overline{\\mathsf{LOG}_j^t}<span class="math"> or </span>\\overline{\\mathsf{LOG}_j^t} \\prec \\overline{\\mathsf{LOG}_i^r}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 11 (Consistency, restatement of Theorem 8). Let <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot)</span> be any admissible chain-state function. Then, <span class="math">\\Pi_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> satisfies consistency as defined in Section 2.2 w.r.t. any p.p.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span>.</p>

    <p class="text-gray-300">Proof. By construction, an honest node's output log never shrinks. Thus both common prefix and future self-consistency follow directly from Lemma 3 and definition of the honest protocol.</p>

    <p class="text-gray-300">We additionally prove a corollary that will later be useful for proving worst-case liveness.</p>

    <p class="text-gray-300">Corollary 3. Let <span class="math">\\Gamma(\\kappa, \\cdot, \\cdot)</span> be any admissible chain-state function. Except with negligible probability over the choice of view, the following holds: for any round <span class="math">r</span>, for any node <span class="math">i</span> honest and online in round <span class="math">r</span>, <span class="math">\\text{linearize}(\\text{chain}_i^r [:-0.5\\kappa])</span> is a prefix of <span class="math">\\mathsf{LOG}_i^r</span> where <span class="math">\\text{chain}_i^r</span> is node <span class="math">i</span>'s <span class="math">\\Pi_{\\text{blockchain}}</span> output in round <span class="math">r</span>, and <span class="math">\\mathsf{LOG}_i^r</span> is node <span class="math">i</span>'s output log to <span class="math">\\mathcal{Z}</span> in round <span class="math">r</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We ignore the negligible fraction of views where relevant bad events happen and consider only the remaining good views. By definition of the honest protocol and Lemma 3, <span class="math">\\overline{\\mathsf{LOG}_i^r}</span> must be a prefix of <span class="math">\\mathsf{LOG}_i^r</span>. Thus it suffices to prove that <span class="math">\\text{linearize}(\\text{chain}_i^r [:-0.5\\kappa])</span> is a prefix of <span class="math">\\overline{\\mathsf{LOG}_i^r}</span>. If <span class="math">\\text{chain}_i^r [:-0.5\\kappa]</span> is not an optimistic block of some epoch <span class="math">e</span>, then by definition of the honest protocol, <span class="math">\\overline{\\mathsf{LOG}_i^r} = \\text{linearize}(\\text{chain}_i^r [:-0.5\\kappa])</span>. Thus henceforth we consider only the case when <span class="math">\\text{chain}_i^r [:-0.5\\kappa]</span> is an optimistic block of some epoch <span class="math">e</span>. In this case, $\\overline{\\mathsf{LOG}_i^r} = \\text{linearize}(\\text{chain}_i^r [:- \\ell])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs})<span class="math"> where </span>\\text{chain}_i^r [-\\ell]<span class="math"> is the last block before epoch </span>e<span class="math"> in </span>\\text{chain}_i^r<span class="math"> and </span>\\mathsf{TXs}<span class="math"> is the maximal lucky sequence for epoch </span>e<span class="math"> in node </span>i<span class="math">&#x27;s view in round </span>r<span class="math">. On the other hand, </span>\\text{linearize}(\\text{chain}_i^r [:-0.5\\kappa]) = \\text{linearize}(\\text{chain}_i^r [-\\ell])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs}')<span class="math"> where </span>\\mathsf{TXs}'<span class="math"> is the maximal lucky sequence for epoch </span>e<span class="math"> contained in </span>\\text{chain}_i^r [:-0.5\\kappa]<span class="math">. Since </span>\\text{chain}_i^r [:-0.5\\kappa]<span class="math"> is part of node </span>i<span class="math">&#x27;s view in round </span>r<span class="math"> and by Lemma 2, it must be that </span>\\text{strip}(\\mathsf{TXs}') \\prec \\text{strip}(\\mathsf{TXs})$, and the remainder of the proof is straightforward.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-94" class="text-lg font-semibold mt-6">3.3.2 Worst-Case Liveness</h4>

    <h6 id="sec-95" class="text-base font-medium mt-4">Lemma 4 (Worst-case liveness variant).</h6>

    <p class="text-gray-300">Let <span class="math">\\Gamma^{\\mathsf{pred}}(\\kappa,\\cdot,\\cdot)</span> be the chain-state function as specified in Section 3.2.3 for an arbitrary polynomial-time next-epoch function <span class="math">\\mathsf{pred}</span>. Let <span class="math">g_{0}</span> denote the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>’s chain growth lower bound parameter. Except with negligible probability over the choice of view, the following holds: suppose that <span class="math">\\mathcal{Z}</span> inputs a transaction <span class="math">\\mathsf{m}</span> to an honest node when its <span class="math">\\mathsf{chain}</span> output from <span class="math">\\Pi_{\\mathrm{blockchain}}</span> has length <span class="math">\\ell</span>, then for any honest chain <span class="math">\\mathsf{chain}^{\\prime}</span> in view of length at least <span class="math">\\ell+2.5\\kappa</span>, it must hold that <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m})</span> exists in <span class="math">\\mathsf{linearize}^{\\Gamma(\\kappa,\\cdot,\\cdot)}(\\mathsf{chain}^{\\prime}[:\\ell+2.5\\kappa])</span>.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We ignore the negligible fraction of <span class="math">\\mathsf{views}</span> where relevant bad events happen. For the remaining good <span class="math">\\mathsf{views}</span>, the following statements hold.</p>

    <p class="text-gray-300">By liveness of the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>, it must be that either <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m},\\lrcorner)</span> is contained in <span class="math">\\mathsf{chain}^{\\prime}[:\\ell+0.25\\kappa]</span>. Let <span class="math">\\mathsf{chain}^{\\prime}[\\ell_{0}]</span> denote the first block in <span class="math">\\mathsf{chain}^{\\prime}</span> that contains either <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m},\\lrcorner)</span> where <span class="math">\\ell_{0}\\leq\\ell+0.25\\kappa</span>. Now consider the following cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\mathsf{chain}^{\\prime}[\\ell_{0}]</span> is an interim block. By definition of <span class="math">\\mathsf{linearize}</span>, it must hold that <span class="math">\\mathsf{linearize}(\\mathsf{chain}^{\\prime}[:\\ell_{0}])</span> contains either <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m})</span>. The remainder of the proof follows directly from Fact 4.</li>

      <li>Case 2: <span class="math">\\mathsf{chain}^{\\prime}[\\ell_{0}]</span> belongs to some epoch <span class="math">e</span>. By definition of the chain-state function <span class="math">\\Gamma</span>, if <span class="math">\\mathsf{linearize}(\\mathsf{chain}^{\\prime}[:\\ell_{0}+\\kappa])</span> does not contain <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m})</span>, epoch <span class="math">e</span> of <span class="math">\\mathsf{chain}^{\\prime}</span> must enter its grace period at length <span class="math">\\ell_{0}+\\kappa+1</span> or smaller. Thus epoch <span class="math">e</span> of <span class="math">\\mathsf{chain}^{\\prime}</span> must end at length <span class="math">\\ell_{0}+2\\kappa&lt;\\ell+2.5\\kappa</span> or smaller. By definition of <span class="math">\\mathsf{linearize}</span>, it must hold that <span class="math">\\mathsf{linearize}(\\mathsf{chain}^{\\prime}[:\\ell+2.5\\kappa])</span> must contain <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m})</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Theorem 12 (Worst-case liveness, restatement of Theorem 9).</h6>

    <p class="text-gray-300">Let <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot)</span> be the chain-state function as specified in Section 3.2.3. Let <span class="math">g_{0}</span> denote the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>’s chain growth lower bound parameter, and let <span class="math">T_{\\mathrm{confirm}}(\\kappa):=\\frac{3\\kappa}{g_{0}}</span>. For any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa,\\cdot,\\cdot)}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span>, except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability over the choice of <span class="math">\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi_{\\mathrm{thunder}}^{\\Gamma(\\kappa,\\cdot,\\cdot)}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following holds: suppose that <span class="math">\\mathcal{Z}</span> inputs a transaction <span class="math">\\mathsf{m}</span> to an honest node in round <span class="math">r</span>, then in any round <span class="math">r^{\\prime}\\geq r+T_{\\mathrm{confirm}}(\\kappa)</span>, all honest and online nodes’ output <span class="math">\\mathsf{LOG}</span> to <span class="math">\\mathcal{Z}</span> will contain some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m})</span> or <span class="math">\\mathsf{m}</span>.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We ignore the negligible fraction of <span class="math">\\mathsf{views}</span> where relevant bad events happen. For the remaining good <span class="math">\\mathsf{views}</span>, the following statements hold. Suppose that in round <span class="math">r</span>, the longest honest chain is of length <span class="math">\\ell_{r}</span>. By Lemma 4 and Fact 4, for any honest chain denoted <span class="math">\\mathsf{chain}</span> in <span class="math">\\mathsf{view}</span> whose length is at least <span class="math">\\ell_{r}+3\\kappa</span>, <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m})</span> must exist in <span class="math">\\mathsf{linearize}(\\mathsf{chain}[:-0.5\\kappa])</span>. By chain growth lower bound, in round <span class="math">r+T_{\\mathrm{confirm}}</span> or greater, every honest chain must be of length at least <span class="math">\\ell_{r}+3\\kappa</span>. Thus for any honest chain denoted <span class="math">\\mathsf{chain}^{\\prime}</span> in round <span class="math">r+T_{\\mathrm{confirm}}</span> or greater, <span class="math">\\mathsf{m}</span> or some <span class="math">(\\lrcorner,\\lrcorner,\\mathsf{m})</span> must exist in <span class="math">\\mathsf{linearize}(\\mathsf{chain}^{\\prime}[:-0.5\\kappa])</span>. The remainder of the proof follows directly from Corollary 3. ∎</p>

    <h4 id="sec-99" class="text-lg font-semibold mt-6">3.3.3 Optimistic Responsiveness</h4>

    <p class="text-gray-300">We now prove that <span class="math">\\Pi_{\\mathrm{ella}}</span> satisfies optimistic responsiveness in lucky epochs.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Except with negligible probability over the choice of <span class="math">\\mathsf{view}</span>, the following holds: Suppose that <span class="math">[T_{\\mathrm{start}},T_{\\mathrm{end}}]</span> belongs to a lucky epoch in <span class="math">\\mathsf{view}</span> corresponding to epoch <span class="math">e</span> and leader <span class="math">i</span>; and let <span class="math">T_{\\mathrm{warmup}}=\\frac{3\\kappa}{g_{0}}</span> where <span class="math">g_{0}</span> is the chain growth lower bound parameter of the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>. Then, for any honest chain denoted <span class="math">\\mathsf{chain}</span> during <span class="math">[T_{\\mathrm{start}}+T_{\\mathrm{warmup}},T_{\\mathrm{end}}]</span>, <span class="math">\\mathsf{chain}[-0.5\\kappa]</span> must be an optimistic block of epoch <span class="math">e</span>.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">CHAPTER 3. BASIC THUNDERELLA PROTOCOL WITH A STATIC COMMITTEE</p>

    <p class="text-gray-300">Proof. Henceforth we ignore the negligible fraction of views where relevant bad events happen. By our definition of lucky epoch, it holds that by the end of round <span class="math">T_{\\mathrm{start}} + 3\\Delta</span>, all honest nodes will have in their view a notarized transaction for the epoch <span class="math">e</span>. Let <span class="math">\\ell</span> denote the length of the shortest honest chain in round <span class="math">T_{\\mathrm{start}}</span>. By chain growth upper bound, no honest chain is greater than <span class="math">\\ell + 0.25\\kappa</span> in length in round <span class="math">T_{\\mathrm{start}} + 3\\Delta</span>. By liveness of the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>, for any honest chain ch whose length is at least <span class="math">\\ell + 0.5\\kappa</span> during <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span>, ch[: <span class="math">\\ell + 0.5\\kappa</span>] must contain a notarized transaction for epoch <span class="math">e</span>. Further, assuming that the signature scheme is secure, we also conclude that no honest node will have in their view a notarized transaction for any epoch <span class="math">e&#x27; &amp;gt; e</span> in or before round <span class="math">T_{\\mathrm{end}}</span> since otherwise one can easily construct a reduction that breaks signature security. Thus, for any honest chain ch whose length is at least <span class="math">\\ell + 0.5\\kappa + 2\\kappa + 0.5\\kappa</span> during <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span>, it holds that some block in ch[: <span class="math">-0.5\\kappa</span>] must have entered epoch <span class="math">e</span> — since by the honest protocol, once the chain contains a notarized transaction for epoch <span class="math">e</span>, it takes at most <span class="math">\\kappa</span> optimistic blocks and <span class="math">\\kappa</span> grace blocks and one interim block to enter epoch <span class="math">e</span>. Further, we also conclude that no honest chain can enter epoch <span class="math">e</span> before <span class="math">\\ell</span> because otherwise there must exist a notarized transaction for epoch <span class="math">e</span> in some honest node's view before round <span class="math">T_{\\mathrm{start}}</span> — and by definition of a lucky epoch, if this happened then we could easily construct a reduction that breaks signature security.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, it suffices to show that for any honest chain ch during <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> whose length is at least <span class="math">\\ell + 3\\kappa</span>, ch[-0.5κ] must be an optimistic block of epoch <span class="math">e</span> — since if we can show this, then the lemma follows directly due to the chain growth lower bound and the fact that the shortest chain at time <span class="math">T_{\\mathrm{start}}</span> is <span class="math">\\ell</span>. To show this claim, let us assume for the sake of contradiction that there exists some honest chain ch<em> during <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> whose length is at least <span class="math">\\ell + 3\\kappa</span>, but ch</em>[-0.5κ] is not an optimistic block of epoch <span class="math">e</span>. Recall that some block in ch<em>[: -0.5κ] must have entered epoch <span class="math">e</span>, and if ch</em>[-0.5κ] is not an optimistic block of epoch <span class="math">e</span>, there must exist some grace block of epoch <span class="math">e</span> in ch*[-0.5κ]. Since no honest node has in their view a notarized transaction for epoch <span class="math">e&#x27; &amp;gt; e</span> by the earlier argument, the only way to enter the grace period for epoch <span class="math">e</span> is if there exists some <span class="math">\\ell&#x27;</span> satisfying $\\ell + \\kappa \\leq \\ell' \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ch}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 0.5\\kappa<span class="math"> and some m such that i) linearize(ch<em>[: </span>\\ell'<span class="math">]) does not contain m or some </span>(-, -, \\mathsf{m})<span class="math"> but m or some </span>(-, -, \\mathsf{m})<span class="math"> appeared in ch</em>[: </span>\\ell' - 0.5\\kappa<span class="math">]; and ii) ch<em>[ </span>\\ell'<span class="math">] is an optimistic block of epoch </span>e<span class="math">, and there are at least </span>\\kappa<span class="math"> optimistic blocks for epoch </span>e<span class="math"> in ch</em>[: </span>\\ell'$].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By consistency, when the leader's chain is first of length <span class="math">\\ell&#x27; - 0.25\\kappa</span> or greater — let <span class="math">r^<em></span> denote this round and let <span class="math">\\mathsf{ch}&#x27;</span> denote the leader's chain in round <span class="math">r^</em></span> — it must be that m or some <span class="math">(-, -, \\mathsf{m})</span> is in <span class="math">\\mathsf{ch}&#x27;</span>. By growth upper bound, <span class="math">\\mathsf{ch}&#x27;</span> cannot be longer than <span class="math">\\ell&#x27;</span> and thus by consistency, neither m nor <span class="math">(-, -, \\mathsf{m})</span> is in linearize( <span class="math">\\mathsf{ch}&#x27;[: -\\kappa ]</span> ). Notice that by chain growth upper bound, <span class="math">r^<em> \\geq T_{\\mathrm{start}}</span>. Thus by the end of round <span class="math">r^</em></span>, the leader <span class="math">i</span> must have sent a notarization request for the transaction m. Thus by time <span class="math">r^<em> + 2\\Delta</span>, all honest nodes will have some notarized transaction <span class="math">(e, s, \\mathsf{m}, -)</span> in its view as well as a notarized transaction of the form <span class="math">(e, s&#x27;, -, -)</span> for every <span class="math">s&#x27; \\leq s</span>. By growth upper bound, no honest chain is longer than <span class="math">\\ell&#x27; - 0.1\\kappa</span> in round <span class="math">r^</em> + 2\\Delta</span>. By liveness, any honest chain <span class="math">\\mathsf{ch}&#x27;</span> of length at least <span class="math">\\ell&#x27;</span> during <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span>, <span class="math">\\mathsf{ch}&#x27;[: \\ell&#x27;]</span> must contain some notarized transaction <span class="math">(e, s, \\mathsf{m}, -)</span> as well as a notarized transaction of the form <span class="math">(e, s&#x27;, -, -)</span> for every <span class="math">s&#x27; \\leq s</span>. This means that linearize( <span class="math">\\mathsf{ch}[: \\ell&#x27;]</span> ) must contain <span class="math">(e, s, \\mathsf{m})</span> , and this contradicts our assumption.</p>

    <p class="text-gray-300">Theorem 13 (Optimistic case responsiveness, restatement of Theorem 10). Let <span class="math">g_0</span> be the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>'s chain growth lower bound parameter and let <span class="math">T_{\\mathrm{warmup}}(\\kappa) = \\frac{3\\kappa}{g_0}</span>. For every p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{ella}}^{\\Gamma (\\kappa,\\cdot,\\cdot)}</span>, there exists a negligible function <span class="math">\\operatorname{negl}(\\cdot)</span> such that for every <span class="math">\\kappa \\in \\mathbb{N}</span>, except with <span class="math">\\operatorname{negl}(\\kappa)</span> probability over the choice of view <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\mathrm{ella}}^{\\Gamma(\\kappa,\\cdot,\\cdot)}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following holds: Suppose that <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> belongs to a lucky epoch in view. Then, if <span class="math">\\mathcal{Z}</span> inputs m to some honest node in some round <span class="math">t \\in [T_{\\mathrm{start}} + T_{\\mathrm{warmup}}, T_{\\mathrm{end}}]</span>, then every honest node's output LOG will include some <span class="math">(-, -, \\mathsf{m})</span> or m at time <span class="math">t + 3\\delta</span>, where <span class="math">\\delta</span> is the maximum actual network delay between</p>

    <p class="text-gray-300">3.3. PROOFS FOR BASIC THUNDERELLA WITH STATIC COMMITTEE</p>

    <p class="text-gray-300"><span class="math">[T_{\\mathrm{start}} + T_{\\mathrm{warmup}}, T_{\\mathrm{end}} + 3\\Delta]</span> in view.</p>

    <p class="text-gray-300">Proof. Suppose that <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> corresponds to the epoch <span class="math">e</span> and leader <span class="math">i</span> in view. In some round <span class="math">r \\leq t + \\delta</span>, the leader <span class="math">i</span> first sees <span class="math">\\mathfrak{m}</span> in its view. We consider the following two cases — further we ignore the negligible fraction of views where relevant bad events happen and consider only the remaining good views.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\mathfrak{m}</span> or some <span class="math">(-, -, \\mathfrak{m})</span> exists in linearize <span class="math">(\\text{chain}_i^r[: -\\kappa])</span>. In this case, by consistency of the underlying <span class="math">\\Pi_{\\text{blockchain}}</span>, for every honest chain <span class="math">\\mathfrak{ch}</span> in round <span class="math">r + \\delta</span> or greater, <span class="math">\\mathfrak{m}</span> or some <span class="math">(-, -, \\mathfrak{m})</span> exists in linearize <span class="math">(\\mathfrak{ch}[: -0.5\\kappa])</span>. The remainder of the proof follows from Corollary 3.</li>

      <li>Case 2: <span class="math">\\mathfrak{m}</span> or some <span class="math">(-, -, \\mathfrak{m})</span> does not exist in linearize <span class="math">(\\text{chain}_i^r[: -\\kappa])</span>. In this case, by some round <span class="math">r&#x27; \\leq r</span>, the leader will have sent 1) a notarization request of the form <span class="math">(e, s, \\mathfrak{m})</span> for some <span class="math">s</span>; and 2) a notarization request of the form <span class="math">(e, s&#x27;, -)</span> for every <span class="math">s&#x27; \\leq s</span>. Thus in any round <span class="math">s \\geq r + 2\\delta</span>, every node honest and online will have in its view 1) a notarized transaction of the form <span class="math">(e, s, \\mathfrak{m}, -)</span>; and 2) for every <span class="math">s&#x27; \\leq s</span> a notarized transaction of the form <span class="math">(e, s&#x27;, -, -)</span>. By definition of the honest protocol and Lemma 5, <span class="math">(-, -, \\mathfrak{m})</span> exists in the output of any honest and online node in round <span class="math">t + 3\\delta</span> or after.</li>

    </ul>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">CHAPTER 3. BASIC THUNDERELLA PROTOCOL WITH A STATIC COMMITTEE</p>

    <p class="text-gray-300">Chapter 4 Thunderella for Permissioned</p>

    <p class="text-gray-300">In this section, we consider two concrete instantiations of Thunderella in the permissioned setting. We show that 1) in the classical setting, assume the existence of a bare PKI and one-way functions, we can have a state machine replication protocol that tolerates arbitrarily many corruptions, and achieves responsiveness during a lucky epoch; 2) in the permissioned, sleepy setting, assume the existence of a common reference string, a bare PKI, and enhanced trapdoor permutations, we can construct a state machine replication protocol that retains worst-case security as long as the majority of online nodes are honest, and moreover achieves responsiveness during a lucky epoch.</p>

    <p class="text-gray-300">Recall that our optimistic case conditions are more stringent than worst-case conditions, and responsiveness can only be achieved when the optimistic-case conditions hold (i.e., when a lucky epoch occurs). In this section, we shall also prove a lower bound to show that our optimistic-case conditions are in fact tight. This lower bound reflects an inherent tradeoff between the conditions necessary for worst-case security and the conditions necessary for responsive confirmation.</p>

    <h3 id="sec-102" class="text-xl font-semibold mt-8">4.1 Permissioned, Classical Environments</h3>

    <p class="text-gray-300">Recall that in permissioned, classical environments, <span class="math">\\mathcal{Z}</span> spawns all nodes upfront prior to protocol execution and does not spawn any nodes later; and moreover, <span class="math">\\mathcal{Z}</span> does not issue sleep or wake instructions. In this setting, “honest” equates to “honest and online”.</p>

    <h5 id="sec-103" class="text-base font-semibold mt-4">Worst-case security under arbitrarily many corruptions.</h5>

    <p class="text-gray-300">We will show that in a permissioned, classical environment and assuming the existence of a PKI, we can have a state machine replication protocol that achieves consistency and worst-case liveness against arbitrarily many corruptions; and moreover, when “things are good”, transactions can confirm in <span class="math">O(1)</span> actual network rounds. The concrete protocol, henceforth referred to as <span class="math">\\Pi_{\\text{ella}}^{\\text{[DS]}}</span>, works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We instantiate the Thunderella paradigm using a Dolev-Strong-based blockchain <span class="math">\\Pi_{\\text{DS}}</span> as the underlying blockchain (see Section 2.4.2).</li>

      <li>In the classical model, <span class="math">\\mathcal{Z}</span> informs all honest nodes upfront the identities of all nodes participating in the protocol. Thus, we can simply have everyone be part of the committee.</li>

      <li>Let <span class="math">n,f</span> be parameters received from <span class="math">\\mathcal{Z}</span> upfront where <span class="math">n</span> denotes the total number of nodes and <span class="math">f</span> denotes an upper bound on the number of corrupt nodes. For a transaction to be notarized, we require that at least <span class="math">\\lfloor\\frac{n+f}{2}+1\\rfloor</span> signatures from disctinct nodes be collected. Further, the parameters <span class="math">(n,f)</span> is also passed to the inner <span class="math">\\Pi_{\\text{DS}}</span> instance.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, we make a non-essential modification to our earlier scheme such that if we happen to be lucky, transactions will start confirming “instantly” starting from the very beginning of the protocol without any warmup period. Specifically, we will assume that the genesis is an optimistic block of the initial epoch (i.e., the 0-th epoch); similarly, for every <span class="math">i\\leq 0</span>, we assume by convention that chain[<span class="math">i</span>] is an optimistic block of the initial epoch. Moreover, when the protocol begins, every honest node will act as if a leader<span class="math">(0,0)</span> instruction has been input, i.e., node 0 will act as the leader for the initial epoch.</li>

    </ol>

    <p class="text-gray-300">Regarding the last modification, in comparison, our basic protocol earlier treated the genesis block as an interim block — since in general, if we were in a permissionless setting, we may wish to run the blockchain protocol for a while and use the blockchain protocol to elect a committee (see Section 5.2).</p>

    <p class="text-gray-300">We say that a protocol <span class="math">\\Pi</span> satisfies consistency (or optimistic responsiveness in lucky epochs resp.) in <span class="math">(n,f,\\Delta)</span>-classical environments iff for every p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that respects <span class="math">(n,f,\\Delta)</span>-classical execution, <span class="math">\\Pi</span> satisfies consistency (or optimistic responsiveness in lucky epochs resp.) w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Theorem 14 (Thunderella for permissioned, classical environments).</h6>

    <p class="text-gray-300">For any <span class="math">n</span> and any <span class="math">f&lt;n</span>, protocol <span class="math">\\Pi_{\\mathrm{ella}}^{\\mathrm{[DS]}}</span> achieves 1) consistency and <span class="math">T_{\\mathrm{confirm}}</span>-liveness for some <span class="math">T_{\\mathrm{confirm}}=O(\\kappa\\Delta)</span>; and 2) optimistic responsiveness in lucky epochs (where lucky epoch is defined as in Section 3.2.4 for <span class="math">\\alpha:=\\frac{n-f}{n}</span>) in <span class="math">(n,f,\\Delta)</span>-classical environments.</p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward from Theorems 5, 8, 9, and 10 — note also that the proofs of Theorems 8, 9, and 10 hold nonetheless with the non-essential modification mentioned earlier that makes it possible for the protocol to enter a lucky epoch immediately upon execution start. ∎</p>

    <p class="text-gray-300">The above theorem immediately gives rise to the following corollary (Corollary 4) which says that if the initial leader remains honest, then the entire protocol execution is a lucky epoch — and thus responsiveness holds for the entire execution. Before we present Corollary 4, we first extend our definition of <span class="math">(n,f,\\Delta)</span>-classical environments <span class="math">(n,f,\\Delta,S)</span>-classical environments where <span class="math">\\mathcal{Z}</span> is not allowed to corrupt nodes in the set <span class="math">S</span>.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Definition 10.</h6>

    <p class="text-gray-300">We say that some <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,f,\\Delta,S)</span>-classical execution w.r.t. protocol <span class="math">\\Pi</span> for some set <span class="math">S\\subseteq\\{0,1,\\ldots,n-1\\}</span> iff <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,f,\\Delta)</span>-classical execution w.r.t. <span class="math">\\Pi</span> and moreover in every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the nodes in the set <span class="math">S</span> remain honest.</p>

    <p class="text-gray-300">We say that a protocol <span class="math">\\Pi</span> satisfies consistency (or responsiveness resp.) in <span class="math">(n,f,\\Delta,S)</span>-classical environments iff for every p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that respects <span class="math">(n,f,\\Delta,S)</span>-classical execution, <span class="math">\\Pi</span> satisfies consistency (or responsiveness resp.) w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. Security in <span class="math">(n,\\frac{n-f}{2},\\Delta)</span>-classical environments is similarly defined. The definitions for <span class="math">(n,f,\\Delta,S)</span>-classical, static environments or for <span class="math">(n,f,\\Delta)</span>-classical, static environments are similar except that now <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must additionally respect static corruption.</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Corollary 4.</h6>

    <p class="text-gray-300">For any <span class="math">n,\\Delta</span> and any <span class="math">f&lt;n</span>, protocol <span class="math">\\Pi_{\\mathrm{ella}}^{\\mathrm{[DS]}}</span> satisfies consistency in <span class="math">(n,f,\\Delta)</span>-classical environments; and satisfies responsiveness <span class="math">(n,\\lceil\\frac{n-f}{2}-1\\rceil,\\Delta,\\{0\\})</span>-classical environments (see Section 2.5 for the definition of responsiveness).</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Arises naturally from Theorem 14 and our minor modification of the starting conditions such that the protocol can immediately enter a lucky epoch if the initial epoch happens to be lucky. ∎</p>

    <p class="text-gray-300">Another useful interpretation of the above corollary is that we can have protocols that are bimodal:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if a set of worst-case conditions are satisfied, then the execution preserves consistency and worst-case liveness; and</li>

      <li>if a set of more stringent, optimistic-case conditions are satisfied, then the execution confirms transactions responsively throughout.</li>

    </ol>

    <p class="text-gray-300">In fact, not only so, Theorem 14 says that we achieve something even stronger: not only for the initial epoch, if in any epoch a set of optimistic-case conditions are satisfied, then this corresponding epoch will start to confirm transactions responsively. Thus, in some sense, Thunderella provides a general framework in which one can try multiple times to bootstrap a fast epoch, and if in any epoch one happens to be lucky, then transactions can confirm responsively. Thunderella guarantees that the transitions between epochs as well as slow mode (i.e., falling back to the blockchain) will respect consistency.</p>

    <h4 id="sec-109" class="text-lg font-semibold mt-6">Limits on security and performance tradeoff.</h4>

    <p class="text-gray-300">So far, we have seen a tradeoff between worst-case security and the conditions required for responsive confirmation. In particular, if one hopes for consistency and worst-case liveness when a larger number of nodes are corrupt, then the conditions necessary for responsive confirmation becomes more stringent. In the following theorem, we show that in fact, such a trade-off is inherent.</p>

    <p class="text-gray-300">Interestingly, the lower bound below (Theorem 15) is in fact a strict generalization of the <span class="math">\\frac{1}{3}</span>-corruption lower bound for responsive state machine replication stated in Section 2.5. In particular, if we plug in <span class="math">n=3f</span> into the theorem below, we effectively get a slightly stronger version of Theorem 7 (see Section 2.5) — the difference is that here we additionally require that the initial leader (i.e., node <span class="math">0</span>) be honest for responsiveness whereas Theorem 7 does not. Like Theorem 7, our proof below can be generalized to a relaxed notion of responsiveness where non-responsive warmup period is allowed.</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Theorem 15 (Tradeoff between security and performance).</h6>

    <p class="text-gray-300">For any <span class="math">n</span> and any <span class="math">f&lt;n-1</span>, any polynomial function <span class="math">\\mathbf{T}_{\\mathrm{confirm}}</span> in <span class="math">\\kappa</span> and <span class="math">\\delta</span> and polynomial function <span class="math">T_{\\mathrm{warmup}}</span> in <span class="math">\\kappa</span>, <span class="math">\\Delta</span>, and <span class="math">\\delta</span>, there exists a polynomial <span class="math">\\Delta</span> in <span class="math">\\kappa</span>, such that no state machine replication protocol <span class="math">\\Pi</span>, even assuming proof-of-work, can simultaneously achieve the following: 1) satisfy <span class="math">(T_{\\mathrm{confirm}},T_{\\mathrm{warmup}})</span>-responsiveness <span class="math">(n,\\lceil\\frac{n-f}{2}\\rceil,\\Delta,\\{0\\})</span>-classical, static environments, and 2) satisfy consistency in <span class="math">(n,f,\\Delta)</span>-classical, static environments.</p>

    <p class="text-gray-300">The proof of this theorem is inspired by the famous partial synchrony lower bound by Dwork et al. <em>[19]</em>, and later extended by Pass and Shi <em>[41]</em> to the proof-of-work setting to show a <span class="math">\\frac{1}{3}</span> lower bound for responsiveness.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider any fixed <span class="math">n</span>, <span class="math">f&lt;n-1</span>, <span class="math">T_{\\mathrm{confirm}}</span> and <span class="math">T_{\\mathrm{warmup}}</span>, Suppose for the sake of contradiction that there exists a protocol <span class="math">\\Pi</span> such that for any <span class="math">\\Delta</span>, <span class="math">\\Pi</span> simultaneously satisfies <span class="math">(T_{\\mathrm{confirm}},T_{\\mathrm{warmup}})</span>-responsiveness <span class="math">(n,\\lceil\\frac{n-f}{2}\\rceil,\\Delta,\\{0\\})</span>-classical, static environments; and additionally satisfies consistency in <span class="math">(n,f,\\Delta)</span>-classical, static environments.</p>

    <p class="text-gray-300">Now consider the following p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that respects <span class="math">(n,f,\\Delta)</span>-classical execution and static corruption for some choice of <span class="math">\\Delta</span> to be specified later: upfront <span class="math">\\mathcal{Z}</span> spawns <span class="math">n</span> nodes numbered <span class="math">0,1,\\ldots,n-1</span> among which <span class="math">f&lt;n-1</span> are corrupt, and moreover, node <span class="math">0</span>, i.e., the initial leader is corrupt. For the initial <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)</span> time, <span class="math">\\mathcal{Z}</span> inputs a dummy transaction to all honest nodes in every round, and <span class="math">\\mathcal{A}</span> delivers all honest messages immediately in the next round.</p>

    <p class="text-gray-300">Now, in round <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+1</span> <span class="math">(\\mathcal{A},\\mathcal{Z})</span> divides the <span class="math">n-f</span> honest nodes into two camps denoted <span class="math">H_{1}</span> and <span class="math">H_{2}</span> respectively, each of size <span class="math">\\lfloor\\frac{n-f}{2}\\rfloor</span> (if <span class="math">n-f</span> is not even then one honest node will remain and we simply discard it from consideration). Let <span class="math">C</span> denote the set of corrupt nodes including the leader. At this moment, <span class="math">C</span> will simulate in its head two groups of nodes <span class="math">C_{1}</span> and <span class="math">C_{2}</span> (i.e., effectively each corrupt node including the leader forks itself into two simulated instances), where <span class="math">C_{b}</span> plays with <span class="math">H_{b}</span> for <span class="math">b\\in\\{1,2\\}</span>. However, since any corrupt node can only query the proof-of-work oracle at a bounded rate, in our attack described below, the two simulated groups <span class="math">C_{1}</span> and <span class="math">C_{2}</span> will perform work in a temporally interleaved fashion. In round <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+1</span>, the group <span class="math">C_{1}</span> is working and the group <span class="math">C_{1}</span> is dormant.</p>

    <p class="text-gray-300">Now, the environment <span class="math">\\mathcal{Z}</span> generates two random transactions (denoted <span class="math">\\mathfrak{m}_{1}</span> and <span class="math">\\mathfrak{m}_{2}</span> respectively) from <span class="math">\\{0,1\\}^{\\kappa}</span>, and in every round <span class="math">r&gt;T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)</span>, <span class="math">\\mathcal{Z}</span> always inputs <span class="math">\\mathfrak{m}_{1}</span> to honest nodes in the first camp and inputs <span class="math">\\mathfrak{m}_{2}</span> to honest nodes in the second camp. <span class="math">\\mathcal{A}</span> delivers messages sent by honest nodes to other nodes in the same camp immediately in the next round; however, <span class="math">\\mathcal{A}</span> delays honest messages in between the two camps up to the maximum delay parameter <span class="math">\\Delta</span> (which will be set to be sufficiently large later).</p>

    <p class="text-gray-300">Now let us consider the view of honest nodes in the camp <span class="math">H_{1}</span>. It is not hard to see that for these honest nodes, their view in the first <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+\\Delta</span> rounds of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span> is identically distributed as the following alternative execution <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\kappa)</span> in which <span class="math">\\mathcal{Z}^{\\prime}</span> spawns <span class="math">n</span> nodes, among which <span class="math">\\lceil\\frac{n-f}{2}\\rceil</span> nodes are corrupt and crash in round <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+1</span>, but the remaining nodes including the leader are honest. <span class="math">\\mathcal{A}^{\\prime}</span> delivers messages sent by honest nodes immediately in the next round. Further, <span class="math">\\mathcal{Z}^{\\prime}</span> inputs a dummy transaction for every round <span class="math">r\\leq T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)</span> and for every round <span class="math">r&gt;T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)</span>, <span class="math">\\mathcal{Z}^{\\prime}</span> generates a random transaction <span class="math">\\mathfrak{m}_{1}</span> from <span class="math">\\{0,1\\}^{\\kappa}</span> and inputs the same transaction to all honest nodes. By the responsiveness requirement, for every <span class="math">\\Delta</span>, except with negligible probability over the choice of view of the alternative execution <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\kappa)</span>, every honest node must include <span class="math">\\mathfrak{m}_{1}</span> in their output logs by time <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,\\delta=1)+T_{\\mathrm{confirm}}(\\kappa,\\delta=1)+1</span> where <span class="math">T_{\\mathrm{confirm}}</span> is independent of <span class="math">\\Delta</span>. Thus regardless of the choice of <span class="math">\\Delta</span>, except with negligible probability over the choice of view <span class="math">\\leftarrow\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, honest nodes in the first camp must include <span class="math">\\mathfrak{m}_{1}</span> in their output logs by time <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+T_{\\mathrm{confirm}}(\\kappa,\\delta=1)+1</span> as well.</p>

    <p class="text-gray-300">Now, starting in round <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+T_{\\mathrm{confirm}}(\\kappa,\\delta=1)+1</span>, <span class="math">C_{1}</span> becomes dormant and <span class="math">C_{2}</span> starts playing. Whenever a node in <span class="math">C_{2}</span> sends a message to honest nodes in any round <span class="math">r\\geq T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+T_{\\mathrm{confirm}}(\\kappa,\\delta=1)+1</span>, the message is delivered instantly (but it appears that the message was sent in round <span class="math">r-T_{\\mathrm{confirm}}(\\kappa,\\delta=1)</span> and got delayed for <span class="math">\\delta^{\\prime}=T_{\\mathrm{confirm}}(\\kappa,\\delta=1)</span> rounds). Whenever <span class="math">C_{2}</span> receives any message from any honest node in any round <span class="math">r\\geq T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+T_{\\mathrm{confirm}}(\\kappa,\\delta=1)+1</span>, it acts as if the message was received in <span class="math">r-T_{\\mathrm{confirm}}(\\kappa,\\delta=1)</span>. The view of the honest camp <span class="math">H_{2}</span> is identically distributed as the following alternate execution: the environment spawns <span class="math">n</span> nodes, among which <span class="math">\\lceil\\frac{n-f}{2}\\rceil</span> nodes are corrupt and crash in round <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+1</span>, but the remaining nodes including the leader are honest. The adversary delays messages sent by honest nodes by a maximum of <span class="math">\\delta^{\\prime}=T_{\\mathrm{confirm}}(\\kappa,\\delta=1)</span> — note that since <span class="math">C_{2}</span> started playing late, here we are charging this offset to the network delay. Similarly as before, in this alternate execution, the environment inputs a dummy transaction for every round <span class="math">r\\leq T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)</span> and for every round <span class="math">r&gt;T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)</span>, it generates a random transaction <span class="math">\\mathfrak{m}_{2}</span> from <span class="math">\\{0,1\\}^{\\kappa}</span> and inputs the same transaction to all honest nodes. In this alternate execution, by the responsiveness requirement, for every <span class="math">\\Delta</span>, except with negligible probability over the choice of view <span class="math">\\leftarrow\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, honest nodes in <span class="math">H_{2}</span> must include <span class="math">\\mathfrak{m}_{2}</span> in their output logs by time <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+T_{\\mathrm{confirm}}(\\kappa,\\delta^{\\prime})+1</span>.</p>

    <p class="text-gray-300">We now consider a sufficiently large <span class="math">\\Delta</span> such that <span class="math">\\Delta&gt;T_{\\mathrm{confirm}}(\\kappa,\\delta^{\\prime})</span>. In this case, since <span class="math">\\mathfrak{m}_{1}</span> and <span class="math">\\mathfrak{m}_{2}</span> are sampled at random from a high-entropy distribution, except with negligible probability over the choice of view <span class="math">\\leftarrow\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, in round <span class="math">T_{\\mathrm{warmup}}(\\kappa,\\Delta,1)+T_{\\mathrm{confirm}}(\\kappa,\\delta^{\\prime})+1</span>, the output</p>

    <p class="text-gray-300">4.2. PERMISSIONED, SLEEPY ENVIRONMENTS</p>

    <p class="text-gray-300">logs of honest nodes in the first camp do not include <span class="math">\\mathfrak{m}_2</span> and the output logs of honest nodes in the second camp do not include <span class="math">\\mathfrak{m}_1</span> since there is no information flow between the two honest camps thus far.</p>

    <p class="text-gray-300">Summarizing the above, we conclude that except with negligible probability over the choice of view <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, in round <span class="math">T_{\\mathrm{warmup}}(\\kappa ,\\Delta ,1) + T_{\\mathrm{confirm}}(\\kappa ,\\delta^{\\prime}) + 1</span>, the output logs of honest nodes in the first camp must be inconsistent with the output logs of honest nodes in the second camp — but this violates our assumption that <span class="math">\\Pi</span> satisfies consistency w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> and thus we reach a contradiction.</p>

    <h2 id="sec-112" class="text-2xl font-bold">4.2 Permissioned, Sleepy Environments</h2>

    <p class="text-gray-300">In the classical model, we treat crashed nodes as corrupt, and thus crashes count towards the corruption budget. Recent works [43] considered a new model where crashed nodes are treated as "honest but sleeping" and they do not count towards the corruption budget. In such a permissioned, sleepy environment, earlier work showed the following interesting results [43]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, a meaningful question to ask in this model is whether state machine replication is possible when the majority of online nodes are honest — this question was answered in the affirmative by earlier work [43] where they proposed a protocol called "sleepy consensus" (see Theorem 6 of Section 2.4.3).</li>

      <li>Earlier work [42, 43] also showed that indeed, honest majority is necessary to achieve state machine replication in a sleepy environment. Further, this lower bound arises due to the possibility of "late joining" [42, 43], i.e., an honest node can be asleep in the beginning and wake up later. As a result, unlike the permissioned, classical setting, here one cannot hope for security when arbitrarily many among those online are corrupt.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathrm{ella}}^{\\mathrm{[Sleepy]}}</span> be <span class="math">\\Pi_{\\mathrm{ella}}</span> where the underlying blockchain is instantiated with <span class="math">\\Pi_{\\mathrm{sleepy}}</span> in the permissioned, sleepy setting, and the committee being all nodes spawned. We say that a protocol <span class="math">\\Pi</span> satisfies consistency (or liveness, responsiveness in lucky epochs resp.) in <span class="math">(n,\\rho ,\\Delta)</span>-static, sleepy environments iff for every <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that respects <span class="math">(n,\\rho ,\\Delta)</span>-sleepy execution and static corruption, <span class="math">\\Pi</span> satisfies consistency (or liveness, responsiveness in lucky epochs resp.) w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <p class="text-gray-300"><strong>Theorem 16 (Thunderella for permissioned, sleepy environments).</strong> For any <span class="math">n</span>, any <span class="math">\\Delta</span>, and any positive constant <span class="math">\\rho &amp;lt; \\frac{1}{2}</span>, <span class="math">\\Pi_{\\mathrm{ella}}^{\\mathrm{[Sleepy]}}</span> satisfies 1) consistency and <span class="math">T_{\\mathrm{confirm}}</span>-liveness for some <span class="math">T_{\\mathrm{confirm}} = O(\\kappa \\Delta)</span>; and 2) optimistic responsiveness in lucky epochs (where lucky epoch is defined as in Section 3.2.4 for <span class="math">\\alpha := 1 - \\rho</span>) in <span class="math">(n, \\rho, \\Delta)</span>-static, sleepy environments.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Straightforward from Theorems 6, 8, 9, and 10.</p>

    <p class="text-gray-300">We note that although the above theorem is stated for static corruption, our Thunderella paradigm can also generalize to the adaptively secure version of sleepy consensus [43] with parameters adjusted accordingly.</p>

    <h2 id="sec-113" class="text-2xl font-bold">4.2.1 Practical Considerations for Consortium Blockchains</h2>

    <p class="text-gray-300">A consortium blockchain is one of the most important emerging applications for permissioned consensus. In a consortium blockchain, a number of banks (e.g., on the order of hundreds) would like to create a distributed ledger to allow fast inter-bank settlement and reduce back-office manual labor. Thunderella is a good fit for such consortium blockchains — particularly, its simplicity will</p>

    <p class="text-gray-300">facilitate reconfiguration and operational maintainence. A suitable instantiation for this setting is to rely on Sleepy consensus as the underlying blockchain and use Thunderella to add a layer of voting to accelerate transaction confirmation. While the naive strategy is to have all registered consensus nodes act as the committee, it would be desirable to down-select the committee to reduce bandwidth consumption. We discuss how to achieve this below.</p>

    <h5 id="sec-114" class="text-base font-semibold mt-4">Bandwidth reduction and down-selection of committee.</h5>

    <p class="text-gray-300">To reduce the bandwidth consumption associated with the voting step, instead of having all registered nodes act as the committee, we can down-select a committee of size <span class="math">\\Theta(\\kappa)</span> at random. The most naive approach is to randomly select a subset of the nodes to act as the committee upfront using a random oracle (assuming that users’ public keys must be registered upfront before the random oracle is determined). Due to a simple application of the Chernoff bound, as long as overall the adversary controls only <span class="math">\\rho&lt;\\frac{1}{2}-\\epsilon</span> fraction of online nodes, then among the committee the adversary can only control minority as well. However, such an approach would tolerate only static corruptions since an adaptive adversary can observe which <span class="math">\\Theta(\\kappa)</span> nodes get elected as the committee, and then corrupt the committee specifically.</p>

    <p class="text-gray-300">To tolerate adaptive corruptions (and adaptive sleepiness), we can rely on verifiable random functions (VRFs) in a similar fashion as Micali <em>[36]</em> — concretely, such a VRF can be instantiated in practice using a unique signature scheme and a random oracle. Let us assume that a random oracle <span class="math">H</span> is chosen after all nodes’ public keys are registered with the PKI. Let <span class="math">\\Sigma:=(\\mathsf{USign},\\mathsf{Vf})</span> denote a unique signature scheme — this is a separate signature scheme than the one used to notarized transactions. Further, each node will register both public keys (one for the unique signature scheme and one for notarizing transactions) with the PKI.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The idea is that now each sequence number <span class="math">(e,s)</span> will select a different <span class="math">\\Theta(\\kappa)</span>-sized committee, and the committee formation is unpredictable to the adversary in advance.</li>

    </ul>

    <p class="text-gray-300">For each sequence number <span class="math">(e,s)</span>, user <span class="math">i</span> evaluates</p>

    <p class="text-gray-300"><span class="math">r:=H(\\mathsf{USign}_{\\mathsf{sk}_{i}}(e,s))</span></p>

    <p class="text-gray-300">and if <span class="math">r&lt;D_{p}</span>, user <span class="math">i</span> is eligible to vote on a transaction for the sequence number <span class="math">(e,s)</span> where <span class="math">D_{p}</span> is an appropriate difficulty parameter chosen such that the committee size (counting only those that are online) is roughly <span class="math">\\Theta(\\kappa)</span>.</p>

    <p class="text-gray-300">It is not difficult to see that given <span class="math">r</span> and <span class="math">\\mathsf{pk}_{i}</span>, everyone can verify that <span class="math">i</span> is indeed eligible to vote on <span class="math">(e,s)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Users rely on a forward-secure signing scheme to notarize transactions. In a forward-secure signature scheme, a signing key corresponding to a certain timestamp <span class="math">T</span> can only be used to sign transactions stamped with a sequence number <span class="math">T</span> or greater. Further, knowing a signing key for <span class="math">T</span>, a computationally bounded adversary cannot forge signatures for any sequence number smaller than <span class="math">T</span>.</li>

    </ul>

    <p class="text-gray-300">Whenever nodes sign a new notarization request for the sequence number <span class="math">(e,s)</span>, they update the signing key to the timestamp <span class="math">(e,s)</span> and then perform the signing. After notarizing a transaction with the sequence number <span class="math">(e,s)</span>, the signing key is immediately updated to the next timestamp <span class="math">(e,s+1)</span>, and the old copy immediately erased from memory. In this way, even if the adversary immediately corrupts a node that has just notarized a transaction with the sequence number <span class="math">(e,s)</span>, he is unable to make the node change his mind and sign an equivocating transaction for the same <span class="math">(e,s)</span>.</p>

    <p class="text-gray-300">Using techniques similar to Micali <em>[36]</em>, it is not difficult to show that assuming random oracle and the erasure model, among every committee, the majority of online committee members are honest as long as overall, the adversary controls no more than <span class="math">\\rho=\\frac{1}{2}-\\epsilon</span> fraction of the online nodes (for an arbitrarily small positive constant <span class="math">\\epsilon</span>) — and this holds even under adaptive corruptions (and adaptive sleepiness).</p>

    <p class="text-gray-300">CHAPTER 4. THUNDERELLA FOR PERMISSIONED</p>

    <p class="text-gray-300">Chapter 5 Thunderella for Permissionless</p>

    <p class="text-gray-300">In this section, we will consider how to instantiate the Thunderella paradigm in a permissionless framework, e.g., as the underlying consensus mechanism for a decentralized cryptocurrency. Specifically, we will discuss i) how to elect and rotate the committees over time (Sections 5.1, 5.2 and 5.3), and ii) practical considerations for leader election (Section 5.4). Throughout this section, we will also describe how to achieve fairness and incentive compatibility in a decentralized setting.</p>

    <h3 id="sec-115" class="text-xl font-semibold mt-8">5.1 Thunderella with Robust Committee Reconfiguration</h3>

    <p class="text-gray-300">In the permissionless setting, it is not be known upfront who will participate in the protocol. We will suggest two approaches for performing committee reconfiguration: 1) use the underlying blockchain to establish the identities of recent miners <em>[40, 41]</em>, and have recently online miners form the committee; 2) stake-holders can act as the committee <em>[3, 4, 7, 14, 15, 31, 36, 44]</em>.</p>

    <p class="text-gray-300">In such committee election policies, typically the committee will evolve over time. We will describe a robust committee reconfiguration framework on top of Thunderella. An important goal for our committee reconfiguration framework is to defend against posterior corruption. To explain why it is important to resist posterior corruption, let us consider a proof-of-stake application where stake-holders are asked to vote in the consensus mechanism. It is possible that the set of users who hold (possibly the majority of) stake sometime in the past would sell their stake at some point — from that point on, they may be incentivized to misbehave, e.g., to create a fork and double spend their old money. Thus our goal is to maintain worst-case security as long as the majority (or <span class="math">\\alpha</span> fraction for a tunable parameter <span class="math">\\alpha</span>) of the committee remain honest (but not necessarily online) during their term of appointment and shortly afterwards as well. However, sometime after the committee finished their term of appointment, afterwards even if the entire past committee become corrupt, the corrupt past committee should not be able to sign into the past and break the worst-case guarantees.</p>

    <h5 id="sec-116" class="text-base font-semibold mt-4">Roadmap.</h5>

    <p class="text-gray-300">In this section, we will describe a general framework for robust committee election that defends against posterior corruption. In subsequent sections, we will describe two concrete committee rotation strategies: electing the committee either from the set of recently online miners or from recent stake.</p>

    <h5 id="sec-117" class="text-base font-semibold mt-4">Intuition.</h5>

    <p class="text-gray-300">Recall that we would like to have a general framework for robust committee reconfiguration tolerating posterior corruption attacks. Our idea is to tag each notarized transaction with a clock number denoted <span class="math">c</span>, and each clock number can have a different committee denoted</p>

    <p class="text-gray-300">CHAPTER 5. THUNDERELLA FOR PERMISSIONLESS</p>

    <p class="text-gray-300">committee<span class="math">_{c}</span>. In our concrete realization, we will use the block length as a rough notion of time, and thus the clock number roughly corresponds to the time at which the transaction is proposed. Based on this, a notarized transaction will now be of the form <span class="math">(e,s,c,c&#x27;,\\mathsf{m},V)</span>, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e</span> denotes the epoch number,</li>

      <li><span class="math">s</span> denotes the sequence number within the epoch,</li>

      <li><span class="math">\\mathsf{m}</span> denotes the transaction, and <span class="math">V</span> denotes a collection of sufficiently many signatures from <span class="math">\\mathsf{committee}_{c}</span> on the message <span class="math">(e,s,c,c&#x27;,\\mathsf{m})</span>,</li>

      <li><span class="math">c</span> denotes the clock number for the current transaction, and</li>

      <li><span class="math">c&#x27;</span> denotes the intended clock number for the next transaction — the inclusion of <span class="math">c&#x27;</span> uniquely determines the <span class="math">(e, s, c, c&#x27;)</span> tuple of the immediate next transaction in the lucky sequence, such that any notarized lucky sequence for an epoch must be unique.</li>

    </ul>

    <p class="text-gray-300">Intuitively, this clock number <span class="math">c</span> represents the approximate length of honest (and online) nodes' blockchains at the time that the leader of epoch <span class="math">e</span> proposed a notarization request <span class="math">(e,s,c,c&#x27;,\\mathfrak{m})</span>. Additionally, we require that a notarized transaction with the clock number <span class="math">c</span> be incorporated in the blockchain sufficiently soon w.r.t. <span class="math">c</span>. Specifically, a notarized transaction with the clock number <span class="math">c</span> must be incorporated into the blockchain by length <span class="math">c + 2\\kappa</span> — if it is incorporated later than this, it is not considered as a legitimate inclusion in the blockchain and will simply be ignored. Correspondingly, we require that the committees are chosen such that each committee <span class="math">\\mathsf{committee}_{c}</span> will remain honest (but not necessarily online) till the time honest chain lengths are roughly <span class="math">c + 4\\kappa</span> — this makes sure that even if an entire past committee becomes corrupt a posteriori (i.e., after the notarized transactions get incorporated into the blockchain), they cannot overwrite the past.</p>

    <p class="text-gray-300">Finally, when an honest node outputs a lucky sequence of notarized transactions in the optimistic mode, it will make sure that the lucky sequence being output will have enough time to be legitimately incorporated into the blockchain should a grace period ensue immediately.</p>

    <p class="text-gray-300">We now describe our new protocol <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}</span> more formally. Specifically, our description will roughly follow that of Section 3.2 (where we described a protocol <span class="math">\\Pi_{\\mathrm{thunder}}</span> for the case of static committee), but we will focus on describing the new modifications on top of <span class="math">\\Pi_{\\mathrm{thunder}}</span>.</p>

    <h2 id="sec-118" class="text-2xl font-bold">5.1.1 Protocol <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}</span>: Consistency and Worst-Case Liveness</h2>

    <p class="text-gray-300"><strong>Notarized transactions.</strong> Notarized transactions are defined in a very similar way as in Section 3.2 except now we need to incorporate an extra clock number <span class="math">c</span> and for each <span class="math">c</span> there is a different committee denoted <span class="math">\\mathsf{committee}_c</span>. We say that a tuple <span class="math">(e,s,c,c&#x27;,\\mathsf{m},V)</span> is a notarized transaction w.r.t. some committee of public keys denoted <span class="math">\\mathsf{committee}_c</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">(\\mathsf{pk},\\sigma)\\in V</span>, <span class="math">\\mathsf{pk}\\in \\mathsf{committee}_c</span> and moreover <span class="math">\\sigma</span> is a valid signature for <span class="math">(e,s,c,c&#x27;,\\mathsf{m})</span> under <span class="math">\\mathsf{pk}</span> — in this case, we also say that <span class="math">(\\mathsf{pk},\\sigma)</span> is a valid vote for <span class="math">(e,s,c,c&#x27;,\\mathsf{m})</span> w.r.t. <span class="math">\\mathsf{committee}_c</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- There are more than $\\frac{3}{4} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{committee}_c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> votes in </span>V<span class="math"> with distinct pks (or more generally, we can also replace </span>\\frac{3}{4}<span class="math"> with </span>1 - \\frac{\\alpha}{2}<span class="math"> if we wish to tolerate </span>1 - \\alpha$ fraction of corrupt committee in the worst case).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">(e,s,c,c&#x27;,\\mathsf{m},V)</span> is a notarized transaction w.r.t. <span class="math">\\mathsf{committee}_c</span>, we also say that <span class="math">V</span> is a valid notarization for <span class="math">(e,s,c,c&#x27;,\\mathsf{m})</span> w.r.t. <span class="math">\\mathsf{committee}_c</span>.</p>

    <p class="text-gray-300">¹Note that by this definition, if <span class="math">\\mathsf{committee}_c = \\emptyset</span>, no transaction can be notarized w.r.t. to <span class="math">\\mathsf{committee}_c</span>.</p>

    <h4 id="sec-119" class="text-lg font-semibold mt-6">5.1.1 Lucky sequence.</h4>

    <p class="text-gray-300">To define the notion of a lucky sequence, we make the additional assumption that each epoch number <span class="math">e</span> defines the starting clock number, i.e.,</p>

    <p class="text-gray-300"><span class="math">e:=(\\widetilde{e},c_{0})</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{e}</span> denotes the actual epoch number and <span class="math">c_{0}</span> is the starting clock number.</p>

    <p class="text-gray-300">A sequence <span class="math">\\{e_{i},s_{i},c_{i},c^{\\prime}_{i},\\mathsf{m}_{i},_{-}\\}_{i\\in\\{1,2,\\ldots,\\ell\\}}</span> is said to be a lucky sequence iff <span class="math">c_{1}</span> agrees with the starting clock number for epoch <span class="math">e</span>, and moreover, for all <span class="math">i\\in[\\ell-1]</span>, <span class="math">e_{i}=e_{i+1}</span>, <span class="math">s_{i}=i</span>, and <span class="math">c_{i+1}=c^{\\prime}_{i}</span>. In other words, like before, we still require that the sequence numbers increment one by one; but here we additionally require that the next clock number <span class="math">c_{i+1}</span> should always agree with the <span class="math">c^{\\prime}_{i}</span> value declared in the previous transaction,</p>

    <p class="text-gray-300">Note that the above definition ensures the uniqueness of the lucky sequence as long as every <span class="math">\\mathsf{committee}_{c}</span> has sufficiently many nodes that remain honest sufficiently long. In particular, it is not possible to have two committees that are both eligible for notarizing a certain sequence number <span class="math">s</span>, since inductively, as long as the lucky sequence is unique up to sequence number <span class="math">s-1</span>, then the next clock number will be uniquely determined (this will be proved formally later).</p>

    <h4 id="sec-120" class="text-lg font-semibold mt-6">Chain linearization.</h4>

    <p class="text-gray-300">The chain linearization algorithm <span class="math">\\mathsf{linearize}</span> is defined almost identically as in Section 3.2 (using the new notion of lucky sequence), and with the following modification:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any transaction of the form <span class="math">(e,s,c,c^{\\prime},\\mathsf{m},V)</span> can be <em>legitimately included</em> in a blockchain in between lengths <span class="math">[c,c+2\\kappa]</span> — if some transaction of this form appears before length <span class="math">c</span> or after length <span class="math">c+2\\kappa</span>, it is simply ignored.</li>

    </ul>

    <p class="text-gray-300">Later in our compliance rules, we will state the requirement that with probability <span class="math">1</span>, if an honest and online node’s chain is of length <span class="math">c</span> or greater, then the honest node must have recorded <span class="math">\\mathsf{committee}_{c}</span> and moreover all honest and online nodes record the same <span class="math">\\mathsf{committee}_{c}</span> for every <span class="math">c</span> — this way, the validity of any <span class="math">(e,s,c,c^{\\prime},\\mathsf{m},V)</span> tuple in any honest chain is unambiguously defined in every <span class="math">\\mathsf{view}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Further, we modify the definition of the <span class="math">\\mathsf{strip}(\\cdot)</span> function accordingly, such that <span class="math">\\mathsf{strip}(e,s,c,c^{\\prime},\\mathsf{m},V):=(e,s,c,c^{\\prime},\\mathsf{m})</span>.</li>

    </ul>

    <h4 id="sec-121" class="text-lg font-semibold mt-6">Protocol <span class="math">\\widetilde{\\Pi}_{\\mathsf{thunder}}^{\\Gamma(\\cdot,\\cdot,\\cdot)}</span>.</h4>

    <p class="text-gray-300">We now describe our new protocol <span class="math">\\widetilde{\\Pi}_{\\mathsf{thunder}}</span> that provides a committee reconfiguration framework. In particular, we highlight some important new modifications in blue. Like before, although not explicitly noted, we assume that whenever an honest node receives any message on the network, if the message has not been broadcast before, the honest node broadcasts the message.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialize.</em> Fork an instance of <span class="math">\\Pi_{\\mathsf{blockchain}}</span> with appropriate parameters. Unless otherwise noted, all messages sent from the <span class="math">\\Pi_{\\mathsf{blockchain}}</span> instance or destined for <span class="math">\\Pi_{\\mathsf{blockchain}}</span> are automatically passed through, but these messages also count towards the view of the current <span class="math">\\widetilde{\\Pi}_{\\mathsf{thunder}}</span> protocol instance.</li>

      <li><em>Committee selection.</em> On receiving <span class="math">\\mathsf{elect}(c,\\mathsf{committee}_{c})</span> from <span class="math">\\mathcal{Z}</span>, if no committee has been recorded for clock number <span class="math">c</span> earlier, record <span class="math">\\mathsf{committee}_{c}</span> as the committee for <span class="math">c</span>.</li>

      <li><em>Notarize.</em> Upon receiving notarization request <span class="math">(e,s,c,c^{\\prime},\\mathsf{m})</span> from <span class="math">\\mathcal{Z}</span>: if <span class="math">\\mathsf{committee}_{c}</span> has been recorded and <span class="math">\\mathsf{pk}\\in\\mathsf{committee}_{c}</span>, and further no signature has been produced for <span class="math">(e,s)</span> earlier, then compute <span class="math">\\sigma:=\\Sigma.\\mathsf{Sign}_{\\mathsf{sk}}(e,s,c,c^{\\prime},\\mathsf{m})</span> and broadcast <span class="math">((e,s,c,c^{\\prime},\\mathsf{m}),\\sigma)</span>.</li>

      <li><em>Propose.</em> Every round, let <span class="math">\\mathsf{chain}</span> be the output from the <span class="math">\\Pi_{\\mathsf{blockchain}}</span> instance.</li>

    </ul>

    <p class="text-gray-300">CHAPTER 5. THUNDERELLA FOR PERMISSIONLESS</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{TXs}</span> be a set containing 1) every notarized transaction <span class="math">(e, s, c, c&#x27;, \\mathfrak{m}, V)</span> in the node's view such that no notarized transaction <span class="math">(e, s, c, c&#x27;, \\mathfrak{m}, -)</span> was legitimately included in chain[: <span class="math">-0.5\\kappa</span>]; and 2) every unnotarized transaction <span class="math">\\mathfrak{m}</span> in the node's view such that no <span class="math">\\mathfrak{m}</span> or notarized transaction <span class="math">(e, s, c, c&#x27;, \\mathfrak{m}, -)</span> was legitimately included in chain[: <span class="math">-0.5\\kappa</span>].</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Additionally, a node can generate a signing key pair <span class="math">(\\mathsf{pk},\\mathsf{sk})</span> and include <span class="math">\\mathsf{pk}</span> in the block payload as well (such that the environment <span class="math">\\mathcal{Z}</span> can choose the committees based on observed public keys). The corresponding secret key <span class="math">\\mathsf{sk}</span> is kept secret.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Propose $\\mathsf{TXs}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}<span class="math"> to </span>\\Pi_{\\mathrm{blockchain}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Output.</strong> In every round, let chain be the output from <span class="math">\\Pi_{\\mathrm{blockchain}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If chain[-0.5κ] is an optimistic block belonging to epoch <span class="math">e</span>:</li>

    </ul>

    <p class="text-gray-300">a) let chain[-l] be the starting block for epoch <span class="math">e</span> in chain where <span class="math">\\ell \\geq 0.5\\kappa</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b) extract the maximal lucky sequence <span class="math">\\mathsf{TXs}</span> for epoch <span class="math">e</span> from the node's view so far such that for every <span class="math">(e,s,c,c^{\\prime},\\mathfrak{m},V)\\in \\mathsf{TXs}</span>: either some valid <span class="math">(e,s,c,c^{\\prime},\\mathfrak{m}, - )</span> is already legitimately contained in chain[: <span class="math">-0.5\\kappa</span>], or $c + 2\\kappa \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 0.5\\kappa<span class="math">, i.e., the clock number </span>c$ must be large enough for the notarized transaction to be picked up by the grace period should chain[-0.5κ+1] enter a grace period.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c) let $\\overline{\\mathsf{LOG}} := \\text{linearize}(\\text{chain}[: -(\\ell + 1)])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{strip}(\\mathsf{TXs})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else, let <span class="math">\\overline{\\mathrm{LOG}} := \\text{linearize}(\\text{chain}[: -0.5\\kappa])</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let LOG be the previous output to <span class="math">\\mathcal{Z}</span>: if <span class="math">\\overline{\\mathrm{LOG}}</span> is longer than LOG, output <span class="math">\\overline{\\mathrm{LOG}}</span>; else output LOG to <span class="math">\\mathcal{Z}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Mempool.</strong> Upon receiving any other message from the network or <span class="math">\\mathcal{Z}</span>, record the tuple.</li>

    </ul>

    <p class="text-gray-300"><strong>Compliant executions.</strong> We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}^{\\Gamma (\\kappa ,:, - )}</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Blockchain compliance.</strong> <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{blockchain}}</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Consistency and timeliness of committee selection.</strong> For every <span class="math">\\kappa</span>, in every view in the support of EXEC <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>, for every <span class="math">c \\in \\mathbb{N}</span>, if in some round an honest and online node's chain is of length <span class="math">c - 0.25\\kappa</span> or greater, then the node must have recorded committee<span class="math">_c</span>; and moreover, all honest nodes must record the same committee<span class="math">_c</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Resilience.</strong> For every <span class="math">\\kappa</span>, in every view in the support of EXEC <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> <span class="math">(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>, for every clock number <span class="math">c</span>, more than <span class="math">\\frac{1}{2}</span> fraction (or in general, more than <span class="math">\\alpha</span> fraction) of the distinct public keys in committee<span class="math">_c</span> are output by nodes that remain honest (but not necessarily online) till len2time <span class="math">(c + 4\\kappa, \\text{view})</span> where len2time <span class="math">(\\ell, \\text{view})</span> denotes the earliest round in which the shortest honest chain is at least <span class="math">\\ell</span> in length.</li>

    </ul>

    <p class="text-gray-300">Importantly, here we require that the underlying blockchain be secure, and moreover, the majority of every committee must remain honest (but not necessarily online) during its term of appointment, and shortly afterwards as well. We show that <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}</span> satisfies consistency and worst-case liveness in compliant executions. In particular, these worst-case guarantees hold even when some past committee can be entirely corrupt at a future point of time, i.e., our <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}</span> scheme tolerates</p>

    <p class="text-gray-300"><span class="math">^2</span>If committee<span class="math">_c</span> has not been recorded by an honest node, then any tuple <span class="math">(-, -, c, -, -, -)</span> is not considered as a notarized transaction at this moment (but may later become notarized when committee<span class="math">_c</span> has been recorded).</p>

    <p class="text-gray-300">posterior corruption. As earlier works noted <em>[15, 30, 36, 41]</em> formally or informally, the ability to tolerate posterior corruption is important in proof-of-stake contexts where stake-holders are asked to vote on transactions.</p>

    <p class="text-gray-300">We now formally state our worst-case guarantees in compliant executions in the theorems below. The proofs of these theorems are deferred to Section 5.1.3.</p>

    <h6 id="sec-122" class="text-base font-medium mt-4">Theorem 17 (Consistency).</h6>

    <p class="text-gray-300">Let <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot)</span> be any admissible chain-state function. Then, <span class="math">\\widetilde{\\Pi}^{\\Gamma(\\kappa,\\cdot,\\cdot)}_{\\text{thunder}}</span> satisfies consistency as defined in Section 2.2 w.r.t. any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\widetilde{\\Pi}^{\\Gamma(\\kappa,\\cdot,\\cdot)}_{\\text{thunder}}</span>.</p>

    <h4 id="sec-123" class="text-lg font-semibold mt-6">Chain state function.</h4>

    <p class="text-gray-300">Consistency holds for any admissible chain-state function. To prove worst-case liveness, we instantiate <span class="math">\\Gamma^{\\mathsf{pred}}(\\cdot,\\cdot,\\cdot)</span> with the concrete chain state function described in Section 3.2.3. At this moment, we leave <span class="math">\\mathsf{pred}</span> unspecified, since our worst-case liveness guarantees hold regardless of what <span class="math">\\mathsf{pred}</span> is.</p>

    <h6 id="sec-124" class="text-base font-medium mt-4">Theorem 18 (Worst-case liveness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot):=\\Gamma^{\\mathsf{pred}}(\\cdot,\\cdot,\\cdot)</span> be the chain-state function as specified in Section 3.2.3 for any polynomial-time boolean predicate <span class="math">\\mathsf{pred}</span>. Let <span class="math">g_{0}</span> denote the underlying <span class="math">\\Pi_{\\text{blockchain}}</span>’s chain growth lower bound parameter, and let <span class="math">T_{\\text{confirm}}(\\kappa):=\\frac{3\\kappa}{g_{0}}</span>. For any p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\widetilde{\\Pi}^{\\Gamma(\\kappa,\\cdot,\\cdot)}_{\\text{thunder}}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for every <span class="math">\\kappa\\in\\mathbb{N}</span>, except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability over the choice of <span class="math">\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\widetilde{\\Pi}^{\\Gamma(\\kappa,\\cdot,\\cdot)}_{\\text{thunder}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following holds: suppose that <span class="math">\\mathcal{Z}</span> inputs a transaction <span class="math">\\mathsf{m}</span> to an honest node in round <span class="math">r</span>, then in any round <span class="math">r^{\\prime}\\geq r+T_{\\text{confirm}}(\\kappa)</span>, all honest and online nodes’ output <span class="math">\\mathsf{LOG}</span> to <span class="math">\\mathcal{Z}</span> will contain some <span class="math">(\\,\\text{\\tiny</span>\\rightarrow<span class="math">}\\,\\text{\\tiny</span>\\rightarrow<span class="math">}\\,\\mathsf{m})</span> or <span class="math">\\mathsf{m}</span>.</p>

    <h4 id="sec-125" class="text-lg font-semibold mt-6">5.1.2 Protocol <span class="math">\\widetilde{\\Pi}_{\\text{ella}}</span>: Optimistic Responsiveness</h4>

    <p class="text-gray-300">We now describe the leader-based coordination mechanism for ensuring responsiveness during lucky epochs. This part is captured in protocol <span class="math">\\widetilde{\\Pi}_{\\text{ella}}</span>.</p>

    <h4 id="sec-126" class="text-lg font-semibold mt-6">Description of <span class="math">\\widetilde{\\Pi}_{\\text{ella}}</span>.</h4>

    <p class="text-gray-300"><span class="math">\\widetilde{\\Pi}_{\\text{ella}}</span> calls <span class="math">\\widetilde{\\Pi}^{\\Gamma^{\\mathsf{pred}}_{\\text{thunder}}}_{\\text{thunder}}</span>. We spell out the next-epoch function <span class="math">\\mathsf{pred}</span> and the rest of <span class="math">\\widetilde{\\Pi}_{\\text{ella}}</span> below. Most of the protocol is similar to our earlier <span class="math">\\Pi_{\\text{ella}}</span> which works for a static committee. We will highlight the important differences in blue.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Next-epoch function.</em> The policy function <span class="math">\\mathsf{pred}(\\mathsf{chain},e)</span> takes in an abstract blockchain denoted <span class="math">\\mathsf{chain}</span> and an epoch number <span class="math">e</span>. If there exists a notarized transaction for epoch <span class="math">e</span> in <span class="math">\\mathsf{chain}</span>, then output <span class="math">1</span>; else output <span class="math">0</span>. Notice that our definition here depends on <span class="math">\\mathsf{committee}_{c}</span> for each <span class="math">c</span> of concern — later we shall mention that in a compliant execution, all honest nodes record the same <span class="math">\\mathsf{committee}_{c}</span> for every <span class="math">c</span> and thus the definition is unambiguous.</li>

      <li><em>Initialize</em>: fork an instance of the <span class="math">\\widetilde{\\Pi}^{\\Gamma(\\kappa,\\cdot,\\cdot)}_{\\text{thunder}}</span> protocol.</li>

      <li><em>Leader switch</em>: upon input <span class="math">\\mathsf{leader}(e,i)</span>: parse <span class="math">e:=(\\widetilde{e},c)</span> where <span class="math">c</span> denotes the starting clock number, if no leader has been recorded for epoch <span class="math">\\widetilde{e}</span>, record the tuple <span class="math">(e,i)</span>, and do the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if current node is <span class="math">i</span>: wait till the chain output from <span class="math">\\Pi_{\\text{blockchain}}</span> is of length at least <span class="math">c</span>, and then send a notarization request for a special epoch-start transaction <span class="math">(e,s=1,c,c^{\\prime},\\mathsf{start})</span> where <span class="math">c</span> is the starting clock number as mentioned above and <span class="math">c^{\\prime}</span> is the node’s current chain length; and let <span class="math">s=2</span></li>

    </ul>

    <p class="text-gray-300">CHAPTER 5. THUNDERELLA FOR PERMISSIONLESS</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every notarization request <span class="math">(e, s, c, c&#x27;, \\mathfrak{m})</span> received earlier from node <span class="math">i</span>, act as if <span class="math">(e, s, c, c&#x27;, \\mathfrak{m})</span> has just been received from <span class="math">i</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Notarization: upon receiving notarization request <span class="math">(e, s, c, c&#x27;, \\mathfrak{m})</span> from <span class="math">i</span>: if <span class="math">i</span> has been recorded as the leader for epoch <span class="math">e</span>, forward the notarization request <span class="math">(e, s, c, c&#x27;, \\mathfrak{m})</span> to <span class="math">\\widetilde{\\Pi}_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span>; else ignore the request.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Leader: every round: let <span class="math">e</span> be the largest epoch recorded thus far; if current node is recorded as the leader for epoch <span class="math">e</span> and moreover, a start request of the form <span class="math">(e, s = 1, \\rightarrow, \\rightarrow, \\text{start})</span> has been broadcast:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">\\mathfrak{m}</span> in view such that no <span class="math">\\mathfrak{m}</span> or <span class="math">(\\rightarrow, \\rightarrow, \\rightarrow, \\rightarrow, \\mathfrak{m})</span> appears in linearize(chain[: <span class="math">-\\kappa</span>]), if a notarization request has not been broadcast for <span class="math">\\mathfrak{m}</span> earlier, then broadcast a notarization request for <span class="math">\\mathfrak{m}</span> — we will describe below how this is done.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- if the previous notarization request broadcast contained a <span class="math">c&#x27;</span> value that is smaller than the current chain length, then broadcast a notarization request for a dummy transaction dummy</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">nonce for a freshly chosen nonce.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To broadcast a notarization request for any <span class="math">\\mathfrak{m}</span>, do the following: 1) broadcast the tuple <span class="math">(e, s, \\widetilde{c}, \\widetilde{c}&#x27;, \\mathfrak{m})</span> where <span class="math">\\widetilde{c}</span> is the <span class="math">c&#x27;</span> value declared in the previous notarization request, and where the new <span class="math">\\widetilde{c}&#x27;</span> is equal to the current chain length; and 2) let <span class="math">s := s + 1</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Other messages: pass through all other messages between <span class="math">\\widetilde{\\Pi}_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> and <span class="math">\\mathcal{Z}</span>; similarly pass through all other messages between <span class="math">\\widetilde{\\Pi}_{\\text{thunder}}^{\\Gamma(\\kappa, \\cdot, \\cdot)}</span> and the network.</li>

    </ul>

    <p class="text-gray-300">Compliant executions. We say that <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span> iff <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}^{\\Gamma^{\\mathrm{pred}}(\\kappa, \\cdot, \\cdot)}</span> where <span class="math">\\Gamma^{\\mathrm{pred}}(\\kappa, \\cdot, \\cdot)</span> is now concretely instantiated as mentioned above.</p>

    <p class="text-gray-300">Lucky epoch. We now formally define the notion of a lucky epoch. Similarly as before, we will prove that whenever there is a lucky epoch, after a short warmup time, all transactions will confirm responsively (except for a negligible fraction of views). Formally, we say that <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> is a lucky epoch in view iff the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In any round <span class="math">r \\geq T_{\\mathrm{start}} + \\Delta</span>, any honest and online node should have received the same instruction leader <span class="math">(e, i)</span>. Further, prior to <span class="math">T_{\\mathrm{start}}</span>, no honest node has received from <span class="math">\\mathcal{Z}</span> any leader <span class="math">(e&#x27;, \\rightarrow)</span> where <span class="math">e&#x27;</span> is the same or a larger epoch than <span class="math">e</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">c_0</span> denote the starting clock number for epoch <span class="math">e</span>, then the leader <span class="math">i</span>'s chain must be no shorter than <span class="math">c_0 - \\kappa</span> in round <span class="math">T_{\\mathrm{start}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The leader (i.e., node <span class="math">i</span>) is honest and online at in any round <span class="math">t \\in [T_{\\mathrm{start}}, T_{\\mathrm{end}} + 3\\Delta]</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">c \\geq c_0</span> such that <span class="math">\\text{committee}_c</span> was ever input to any honest node in or before <span class="math">T_{\\text{end}}</span>, it must be that <span class="math">\\text{committee}_c</span> is non-empty and more than <span class="math">\\frac{3}{4}</span> fraction (or in general, more than <span class="math">1 - \\frac{\\alpha}{2}</span> fraction) of <span class="math">\\text{committee}_c</span> are honest and online in any round during <span class="math">[\\text{len2time}(c - 0.5\\kappa), \\text{len2time}(c + 0.5\\kappa)]</span>.</li>

    </ul>

    <p class="text-gray-300">The following theorem states that our <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span> achieves optimistic responsiveness in lucky epochs after a short warmup time. Its proof is deferred to Section 5.1.3.</p>

    <p class="text-gray-300">5.1. THUNDERELLA WITH ROBUST COMMITTEE RECONFIGURATION</p>

    <p class="text-gray-300">Theorem 19 (Optimistic responsiveness in lucky epochs). Let <span class="math">g_0</span> be the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>'s chain growth lower bound parameter. For every p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span>, <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span> satisfies <span class="math">(T_{\\mathrm{warmup}},T_{\\mathrm{opt}})</span>-optimistic responsiveness in lucky epochs for <span class="math">T_{\\mathrm{warmup}} = O(\\frac{\\kappa}{g_0})</span>, and <span class="math">T_{\\mathrm{opt}} = 3\\delta</span> where <span class="math">\\delta</span> is the actual maximum network delay in view.</p>

    <h2 id="sec-127" class="text-2xl font-bold">5.1.3 Proofs: Robust Committee Reconfiguration Framework</h2>

    <h3 id="sec-128" class="text-xl font-semibold mt-8">Worst-Case Guarantees</h3>

    <p class="text-gray-300">Henceforth in this subsection, whenever we say that "except with negligible probability over the choice of view, some property ev(view) holds", we formally mean that for any <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\widetilde{\\Pi}_{\\mathrm{thunder}}^{\\Gamma (\\kappa ,\\cdot ,\\cdot)}</span> there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for every <span class="math">\\kappa \\in \\mathbb{N}</span>, except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability over the choice of view <span class="math">\\leftarrow \\mathsf{EXEC}^{\\widetilde{\\Pi}_{\\mathrm{thunder}}^{\\Gamma (\\kappa ,\\cdot ,\\cdot)}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, ev(view) holds.</p>

    <p class="text-gray-300">Lemma 6 (Uniqueness). Assume that the signature scheme is secure, then except with negligible probability over the choice of view, the following holds. For any <span class="math">(e,s,c)</span> tuple, if <span class="math">(e,s,c,c&#x27;,\\mathfrak{m},V)</span> is a notarized transaction in some honest node's view by <span class="math">\\mathsf{len2time}(c + 4\\kappa ,\\mathsf{view})</span>, and similarly <span class="math">(e,s,\\widetilde{c},\\widetilde{c}&#x27;,\\widetilde{\\mathfrak{m}},\\widetilde{V})</span> is also a notarized transaction in some honest node's view by <span class="math">\\mathsf{len2time}(c + 4\\kappa ,\\mathsf{view})</span>, then it must be the case that <span class="math">(c&#x27;,\\mathfrak{m}) = (\\widetilde{c}&#x27;,\\widetilde{\\mathfrak{m}})</span>.</p>

    <p class="text-gray-300">Proof. Similar to the earlier proof of Lemma 2, except that now we additionally rely on the fact that <span class="math">\\alpha</span> fraction of <span class="math">\\mathsf{committee}_c</span> will remain honest till <span class="math">\\mathsf{len2time}(c + 4\\kappa, \\mathsf{view})</span>. <span class="math">\\square</span></p>

    <p class="text-gray-300">Henceforth, we say that an honest and online node <span class="math">i</span> promptly outputs a notarized transaction <span class="math">(e,s,c,c&#x27;,\\mathfrak{m},\\_)</span> in round <span class="math">r</span> in view, if it included <span class="math">(e,s,c,c&#x27;,\\mathfrak{m})</span> in its output in round <span class="math">r</span>, but <span class="math">(e,s,c,c&#x27;,\\mathfrak{m}) \\notin \\mathsf{chain}_i^r[: -0.5\\kappa]</span>.</p>

    <p class="text-gray-300">Lemma 7. Assume that the signature scheme is secure. Except with negligible probability over the choice of view, the following holds: for any epoch <span class="math">e</span>, any sequence number <span class="math">s</span>, if for <span class="math">b \\in \\{0,1\\}</span>, the notarized transaction <span class="math">(e,s,c,c_b&#x27;,\\mathfrak{m}_b,V_b)</span> either is legitimately included in some honest chain in view, or is promptly output by some honest (and online) node in view, then it holds that</p>

    <p class="text-gray-300">(a) for <span class="math">b \\in \\{0,1\\}</span>, <span class="math">(e,s,c,c_b&#x27;,\\mathfrak{m}_b,V_b)</span> must have appeared in view before round <span class="math">\\mathsf{len2time}(c + 4\\kappa ,\\mathsf{view})</span>; and (b) <span class="math">(e,s,c,c_0&#x27;,\\mathfrak{m}_0) = (e,s,c,c_1&#x27;,\\mathfrak{m}_1)</span>.</p>

    <p class="text-gray-300">Proof. To show this, by Lemma 6 and definition of lucky sequence, it suffices to show the following ignoring the negligible fraction of views where relevant bad events happen:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any notarized transaction with the clock number <span class="math">c</span> that legitimately appears in some honest chain ch must appear in view before <span class="math">\\mathsf{len2time}(c + 4\\kappa, \\mathsf{view})</span>. For any notarized transaction contained in <span class="math">\\mathsf{ch}[\\ell^<em>]</span>, its clock number <span class="math">c \\geq \\ell^</em> - 2\\kappa</span>. Since <span class="math">\\mathsf{len2time}(\\ell^<em> + 2\\kappa) \\leq \\mathsf{len2time}(c + 4\\kappa)</span>, it suffices to show that any notarized transaction that appears in <span class="math">\\mathsf{ch}[\\ell^</em>]</span> must appear in view before <span class="math">\\mathsf{len2time}(\\ell^* + 2\\kappa, \\mathsf{view})</span> — and this follows from consistency of the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For any notarized transaction with the clock number <span class="math">c</span> cannot be promptly output by any honest (and online) node in or after <span class="math">\\mathsf{len2time}(c + 4\\kappa, \\mathsf{view})</span>. Suppose that some honest (and online) node <span class="math">i</span> promptly output some notarized transaction with the clock number <span class="math">c</span> in round <span class="math">r</span>. It must hold that $c \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_i^r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1.5\\kappa<span class="math">. By chain growth upper bound, we have that </span>r \\leq \\mathsf{len2time}(c + 4\\kappa)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We now prove the counterpart of Lemma 3 but for our new protocol <span class="math">\\widetilde{\\Pi}_{\\text{thunder}}</span>.</p>

    <h6 id="sec-129" class="text-base font-medium mt-4">Lemma 8.</h6>

    <p class="text-gray-300">Let <span class="math">\\Gamma(\\kappa,\\cdot,\\cdot)</span> be any admissible chain-state function. Except with negligible probability over the choice of view, the following holds: for any <span class="math">r</span> and <span class="math">t</span>, for any node <span class="math">i</span> honest and online in round <span class="math">r</span> and any node <span class="math">j</span> honest and online in round <span class="math">t</span>, either <span class="math">\\overline{\\mathsf{LOG}}_{i}^{r}\\prec\\overline{\\mathsf{LOG}}_{j}^{t}</span> or <span class="math">\\overline{\\mathsf{LOG}}_{j}^{t}\\prec\\overline{\\mathsf{LOG}}_{i}^{r}</span>.</p>

    <h6 id="sec-130" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In every round, an honest node’s <span class="math">\\overline{\\mathsf{LOG}}</span> is of the generalized form $\\mathsf{linearize}(\\mathsf{chain}[:-\\ell])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{strip}(\\mathsf{TXs})$ where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>either <span class="math">\\mathsf{TXs}</span> is empty and <span class="math">\\ell=0.5\\kappa</span> or</li>

      <li><span class="math">\\mathsf{TXs}</span> is a non-empty lucky sequence for some epoch <span class="math">e</span> and <span class="math">\\ell\\geq 0.5\\kappa</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that $\\overline{\\mathsf{LOG}}_{i}^{r}:=\\mathsf{linearize}(\\mathsf{chain}_{i}^{r}[:-\\ell])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{strip}(\\mathsf{TXs})<span class="math"> and </span>\\overline{\\mathsf{LOG}}_{j}^{t}:=\\mathsf{linearize}(\\mathsf{chain}_{j}^{t}[:-\\ell^{\\prime}])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{strip}(\\mathsf{TXs}^{\\prime})<span class="math"> are output logs by node </span>i<span class="math"> in round </span>r<span class="math"> and by node </span>j<span class="math"> in round </span>t$ respectively in view. Henceforth we ignore the negligible fraction of views where relevant bad events happen. For the remaining good views, the following statements hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By consistency of <span class="math">\\Pi_{\\text{blockchain}}</span>, either <span class="math">\\mathsf{chain}_{i}^{r}[:-\\ell]\\prec\\mathsf{chain}_{j}^{t}[:-\\ell^{\\prime}]</span> or <span class="math">\\mathsf{chain}_{j}^{t}[:-\\ell^{\\prime}]\\prec\\mathsf{chain}_{i}^{r}[:-\\ell]</span>. Without loss of generality, henceforth we assume that <span class="math">\\mathsf{chain}_{i}^{r}[:-\\ell]\\prec\\mathsf{chain}_{j}^{t}[:-\\ell^{\\prime}]</span>. We now consider the following cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\mathsf{TXs}</span> is empty. In this case, it follows directly from Fact 4 that <span class="math">\\overline{\\mathsf{LOG}}_{i}^{r}\\prec\\overline{\\mathsf{LOG}}_{j}^{t}</span>.</li>

      <li>Case 2: <span class="math">\\mathsf{TXs}</span> is non-empty. In this case, <span class="math">\\mathsf{chain}_{i}^{r}[-\\ell+1]</span> must be the starting block of some epoch <span class="math">e</span>, and <span class="math">\\mathsf{chain}_{i}^{r}[-0.5\\kappa]</span> must be an optimistic block of epoch <span class="math">e</span>. We now consider the following sub-cases:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2a: Epoch <span class="math">e</span> has completed in <span class="math">\\mathsf{chain}_{j}^{t}[:-\\ell^{\\prime}]</span>, i.e., there are two adjacent blocks such that the former belongs to epoch <span class="math">e</span> and the latter does not in <span class="math">\\mathsf{chain}_{j}^{t}[:-\\ell^{\\prime}]</span>. Let <span class="math">\\mathsf{chain}_{j}^{t}[-\\ell^{*}]</span> denote the last block of epoch <span class="math">e</span> in <span class="math">\\mathsf{chain}_{j}^{t}[:-\\ell^{\\prime}]</span>. By Fact 4, it suffices to prove that $\\mathsf{linearize}(\\mathsf{chain}_{i}^{r}[:-\\ell])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{strip}(\\mathsf{TXs})\\prec\\mathsf{linearize}(\\mathsf{chain}_{j}^{t}[:-\\ell^{*}])$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\ell_{i}^{r}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> be the length of node </span>i<span class="math">’s chain in round </span>r<span class="math">. By definition of the honest protocol, </span>\\mathsf{TXs}<span class="math"> must be a lucky sequence for epoch </span>e<span class="math"> in node </span>i<span class="math">’s view in round </span>r<span class="math">, and further, for every notarized transaction </span>(e,s,c,c^{\\prime},m,V)\\in\\mathsf{TXs}<span class="math">, unless some </span>(e,s,c,c^{\\prime},m,\\_)<span class="math"> is already legitimately contained in </span>\\mathsf{chain}_{i}^{r}[:-0.5\\kappa]<span class="math"> it must be that </span>c+2\\kappa\\geq\\ell_{i}^{r}+0.5\\kappa<span class="math">, i.e., </span>c\\geq\\ell_{i}^{r}-1.5\\kappa<span class="math">. By round </span>r+\\Delta<span class="math">, </span>\\mathsf{TXs}<span class="math"> must exist in any honest node’s view. By the admissibility of the chain-state function </span>\\Gamma<span class="math"> and the fact that </span>\\mathsf{chain}_{i}^{r}[-0.5\\kappa]<span class="math"> is an optmistic block of epoch </span>e<span class="math">, </span>\\mathsf{chain}_{j}^{t}[:-\\ell^{<em>}]<span class="math"> must be at least </span>0.5\\kappa<span class="math"> longer than </span>\\mathsf{chain}_{i}^{r}<span class="math">. By chain growth upper bound, by round </span>r+\\Delta<span class="math">, any honest chain must be at most </span>\\ell_{i}^{r}+0.25\\kappa<span class="math"> in length. By liveness, for any honest chain denoted </span>\\mathsf{ch}<span class="math"> in view whose length is at least </span>\\ell_{i}^{r}+0.5\\kappa<span class="math">, all notarized transactions in </span>\\mathsf{TXs}<span class="math"> must appear in </span>\\mathsf{ch}[: \\ell_{i}^{r}+0.5\\kappa]<span class="math"> (and thus </span>\\mathsf{chain}_{j}^{t}[:-\\ell^{</em>}]<span class="math"> must include </span>\\mathsf{TXs}<span class="math">). We now prove that they are in fact legitimately included in </span>\\mathsf{ch}[: \\ell_{i}^{r}+0.5\\kappa]<span class="math"> (i.e., the clock numbers of notarized transactions in </span>\\mathsf{TXs}<span class="math"> are not too early w.r.t. where they are contained in </span>\\mathsf{ch}<span class="math">.) This is true since we know that any notarized transaction in </span>\\mathsf{TXs}<span class="math"> that is not already legitimately contained in </span>\\mathsf{chain}_{i}^{r}[:-0.5\\kappa]<span class="math"> has a clock number </span>c\\leq\\ell_{i}^{r}-1.5\\kappa<span class="math">; and further, by consistency </span>\\mathsf{chain}_{i}^{r}[:-0.5\\kappa]\\prec\\mathsf{ch}[: \\ell_{i}^{r}+0.5\\kappa]<span class="math">. The remainder of the proof follows directly from definition of </span>\\mathsf{linearize}$ and Lemma 7.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">5.1. THUNDERELLA WITH ROBUST COMMITTEE RECONFIGURATION</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2b: Epoch <span class="math">e</span> has not completed in <span class="math">\\mathsf{chain}_j^t [: -\\ell &#x27;]</span>. Recall that node <span class="math">i</span> outputs $\\mathsf{linearize}(\\mathsf{chain}_i^r [: -\\ell ])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{strip}(\\mathsf{TXs})<span class="math"> in round </span>r<span class="math">. By definition of the honest algorithm, and since </span>\\mathsf{chain}_i^r [: -\\ell ]\\prec \\mathsf{chain}_j^t [: -\\ell ']<span class="math">, node </span>j<span class="math">&#x27;s output in round </span>t<span class="math"> must be of the form </span>\\mathsf{linearize}(\\mathsf{chain}_i^r [: -\\ell ])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{strip}(\\mathsf{TXs}^<em>)<span class="math"> where </span>\\mathsf{TXs}^</em><span class="math"> is either empty or some lucky sequence for epoch </span>e<span class="math"> in node </span>j<span class="math">&#x27;s view in round </span>t<span class="math"> such that any notarized transaction in </span>\\mathsf{TXs}^*<span class="math"> must either have been legitimately included in </span>\\mathsf{chain}_j^t [: -0.5\\kappa ]<span class="math"> or it is &quot;promptly output&quot; by </span>j<span class="math"> in round </span>t<span class="math">. By Lemma 7, it holds that either </span>\\overline{\\mathsf{LOG}}_i^r\\prec \\overline{\\mathsf{LOG}}_j^t<span class="math"> or </span>\\overline{\\mathsf{LOG}}_j^t\\prec \\overline{\\mathsf{LOG}}_i^r$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Proof of consistency. Theorem 17 now follows in a straightforward fashion since by constructions, honest nodes' output logs never shrink. Thus both common prefix and future self-consistency follow from Lemma 8 and definition of the honest protocol.</p>

    <p class="text-gray-300">Proof of worst-case liveness. The proof of worst-case liveness is almost identical to the proof in Section 3.3.2 (except that now in proving the counterpart of Corollary 3, we apply Lemma 7 in place of Lemma 2). We thus omit repeating essentially the same proof and refer the reader to Section 3.3.2.</p>

    <h2 id="sec-131" class="text-2xl font-bold">Optimistic Responsiveness</h2>

    <p class="text-gray-300">We now prove the optimistic responsiveness of our protocol <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span> in lucky epochs. Henceforth in this subsection, whenever we say that "except with negligible probability over the choice of view, some property <span class="math">\\mathsf{ev}(\\mathsf{view})</span> holds", we formally mean that for any <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is compliant w.r.t. <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for every <span class="math">\\kappa \\in \\mathbb{N}</span>, except with <span class="math">\\mathsf{negl}(\\kappa)</span> probability over the choice of <span class="math">\\mathsf{view} \\gets \\mathsf{EXEC}^{\\widetilde{\\Pi}_{\\mathrm{ella}}}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, <span class="math">\\mathsf{ev}(\\mathsf{view})</span> holds.</p>

    <p class="text-gray-300">Fact 5. Except with negligible probability over the choice of view, the following holds: suppose <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> belongs to a lucky epoch <span class="math">e</span> in view in which <span class="math">i</span> is the leader. Then, if node <span class="math">i</span> broadcasts a notarization request of the form <span class="math">(e, s, c, c&#x27;, \\mathfrak{m})</span> in round <span class="math">r \\in [T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span>, it holds that</p>

    <p class="text-gray-300">(a) In any round <span class="math">r&#x27; \\geq r + 3\\delta</span>, all honest nodes will have obtained a valid notarization <span class="math">V</span> for the tuple <span class="math">(e, s, c, c&#x27;, \\mathfrak{m})</span>; and (b) For any honest chain denoted <span class="math">\\mathsf{ch}</span> in view of length <span class="math">c + 0.25\\kappa</span>, <span class="math">\\mathsf{ch}[: c + 0.25\\kappa]</span> legitimately includes some notarized transaction of the form <span class="math">(e, s, c, c&#x27;, \\mathfrak{m}, V)</span>.</p>

    <p class="text-gray-300">Proof. Henceforth we ignore the negligible fraction of views where relevant bad events take place. By honest protocol definition, if the leader <span class="math">i</span> proposes some notarization request of the form <span class="math">(e, s, c, c&#x27;, \\mathfrak{m})</span> in round <span class="math">r \\in [T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span>, it holds that the leader's chain must be of length <span class="math">c - 1</span> in round <span class="math">r - 1</span>. By chain growth upper bound, in round <span class="math">r</span>, all honest and online nodes' chains must be of length at least <span class="math">c - 0.25\\kappa</span>. Further, in round <span class="math">r + \\delta</span>, all honest and online nodes' chains must be of length at most <span class="math">c + 0.25\\kappa</span>. By our compliance rules, in any round <span class="math">r&#x27; \\geq r</span>, any honest and online node must have recorded the same tuple <span class="math">\\mathsf{committee}_c</span>. By definition of a lucky epoch and definition of honest protocol, it holds that more than <span class="math">\\frac{3}{4}</span> fraction of <span class="math">\\mathsf{committee}_c</span> remain honest and online during <span class="math">[r, r + \\delta]</span>. By honest protocol definition, it is not hard to see that claim (a) holds. Now claim (b) also follows by liveness and definition of "legitimately include".</p>

    <p class="text-gray-300">We now prove the equivalent of Lemma 5 but now for our new <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span>.</p>

    <h6 id="sec-132" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">Except with negligible probability over the choice of view, the following holds: Suppose that <span class="math">[T_{\\mathrm{start}},T_{\\mathrm{end}}]</span> belongs to a lucky epoch in view corresponding to epoch <span class="math">e</span> and leader <span class="math">i</span>; and let <span class="math">T_{\\mathrm{warmup}}=\\frac{4\\kappa}{g_{0}}</span> where <span class="math">g_{0}</span> is the chain growth lower bound parameter of the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>. Then, for any honest chain denoted chain during <span class="math">[T_{\\mathrm{start}}+T_{\\mathrm{warmup}},T_{\\mathrm{end}}]</span>, <span class="math">\\mathsf{chain}[-0.5\\kappa]</span> must be an optimistic block of epoch <span class="math">e</span>.</p>

    <h6 id="sec-133" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof would have been the same as that of Lemma 5 if in round <span class="math">T_{\\mathrm{start}}</span>, the leader’s chain were exactly of length <span class="math">c_{0}</span> where <span class="math">c_{0}</span> is the starting epoch number for epoch <span class="math">c</span>. In particular, due to Lemma 7 and Fact 5, every argument made in the proof of Lemma 5 would still follow.</p>

    <p class="text-gray-300">Now, taking into account that our new ”lucky epoch” definition permits the leader’s chain to be <span class="math">c_{0}-\\kappa</span> or longer during round <span class="math">T_{\\mathrm{start}}</span>. We can simply redo the proof of Lemma 7 by replacing <span class="math">T_{\\mathrm{start}}</span> in the proof with <span class="math">\\widetilde{T}_{\\mathrm{start}}</span> where <span class="math">\\widetilde{T}_{\\mathrm{start}}</span> is the earliest round in view in which the leader’s chain is of length <span class="math">c_{0}</span> or greater. By growth lower bound, it holds that <span class="math">\\widetilde{T}_{\\mathrm{start}}\\leq T_{\\mathrm{start}}+\\kappa/g_{0}</span> — note that in our new lemma here, the <span class="math">T_{\\mathrm{warmup}}</span> is redefined as <span class="math">4\\kappa/g_{0}</span>, and the extra <span class="math">\\kappa/g_{0}</span> accounts for the difference between <span class="math">\\widetilde{T}_{\\mathrm{start}}</span> and <span class="math">T_{\\mathrm{start}}</span>. ∎</p>

    <h4 id="sec-134" class="text-lg font-semibold mt-6">Proof of optimistic responsiveness.</h4>

    <p class="text-gray-300">The remainder of the proof for optimistic responsiveness would follow in the same manner as the proof for <span class="math">\\Pi_{\\mathrm{ella}}</span> (for a static committee), but where the new <span class="math">T_{\\mathrm{warmup}}=4\\kappa/g_{0}</span>.</p>

    <h3 id="sec-135" class="text-xl font-semibold mt-8">5.2 Recent Blockchain Miners As Committee</h3>

    <p class="text-gray-300">So far, we have described a general framework for committee reconfiguration but we have not described exactly what committee election policy would be suitable. In this section, we will describe one concrete strategy that leverages the underlying blockchain to elect a set of recently online blockchain miners as the committee. Henceforth in this section, we assume that the underlying blockchain is a proof-of-work blockchain (the mechanism also applies to proof-of-stake blockchains, but for proof-of-stake blockchains simpler mechanisms exist for electing a stake-based committee). We would like to guarantee that as long as the adversary controls <span class="math">\\rho</span> fraction of overall nodes (i.e., computational power), then it must be the case that roughly <span class="math">1-\\rho</span> fraction of the committee will remain honest sufficiently long, i.e., till sometime after its term of appointment. We will formally prove this property (which is required by our earlier committee rotation framework <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span>) under the assumption of a mildly adaptive adversary. Specifically, a <span class="math">\\tau</span>-mildly adaptive adversary is a relaxation of a fully adaptive adversary since it takes at least <span class="math">\\tau</span> time to adaptively corrupt nodes.</p>

    <h4 id="sec-136" class="text-lg font-semibold mt-6">5.2.1 Preliminary: Mildly Adaptive Corruptions</h4>

    <p class="text-gray-300">Let <span class="math">\\tau,\\tau^{\\prime}</span> be functions in <span class="math">\\kappa</span>. In a <span class="math">\\tau</span>-mildly adaptive corruption model, roughly speaking, it takes the adversary at least <span class="math">\\tau(\\kappa)</span> rounds to corrupt an honest node, where <span class="math">\\tau</span> is referred to as the agility parameter <em>[41]</em>. Similarly, we can a corresponding agility parameter for sleepiness too called <span class="math">\\tau^{\\prime}(\\kappa)</span>. In other words, it takes the adversary <span class="math">\\tau^{\\prime}(\\kappa)</span> rounds to put an honest node to sleep.</p>

    <p class="text-gray-300">To formally model this, we can bake this into the underlying model — but to do it more cleanly in our general modeling framework, we choose to model mildly adaptive corruption as an additional constraint on <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. Formally, we say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">(n,\\rho,\\Delta,\\tau,\\tau^{\\prime})</span>-permissionless execution w.r.t. some protocol <span class="math">\\Pi</span> iff for every <span class="math">\\kappa</span>, for every view in the support of <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\kappa)</span>, the following hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{A},\\mathcal{Z})</span> respects <span class="math">\\Delta</span>-bounded network delay w.r.t. <span class="math">\\Pi</span></li>

    </ol>

    <p class="text-gray-300">5.2. RECENT BLOCKCHAIN MINERS AS COMMITTEE</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathcal{Z}</span> issues <span class="math">\\text{corrupt}</span> to any honest node <span class="math">i</span> in round <span class="math">r</span> in <span class="math">\\text{view}</span>, in some round <span class="math">r&#x27; \\leq r - \\tau(\\kappa)</span>, <span class="math">\\mathcal{Z}</span> must output <span class="math">\\text{precorrupt}(i)</span>. Note that the adversary receives node <span class="math">i</span>'s internal states and gets to control node <span class="math">i</span> when the actual <span class="math">\\text{corrupt}</span> instruction is issued to <span class="math">i</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathcal{Z}</span> issues <span class="math">\\text{sleep}</span> to any honest node <span class="math">i</span> in round <span class="math">r</span> in <span class="math">\\text{view}</span>, in some round <span class="math">r&#x27; \\leq r - \\tau&#x27;(\\kappa)</span>, <span class="math">\\mathcal{Z}</span> must output <span class="math">\\text{presleep}(i)</span>. The node actually falls asleep upon receiving <span class="math">\\text{sleep}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>in every round, the total number of precorrupt nodes, corrupt nodes, and honest and online nodes equals to <span class="math">n</span> where precorrupt nodes include every <span class="math">i</span> such that <span class="math">\\mathcal{Z}</span> has said <span class="math">\\text{precorrupt}(i)</span> but <span class="math">i</span> has not become corrupt yet.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>in every round, the total number of precorrupt nodes and corrupt nodes is less than <span class="math">\\rho n</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Z}</span> informs all honest nodes of the parameters <span class="math">(n, \\rho, \\Delta)</span> upon spawning.</li>

    </ol>

    <p class="text-gray-300">In particular, in the above definition, if the agility parameter <span class="math">\\tau = 0</span>, <span class="math">\\tau</span>-mildly adaptive is equivalent to fully adaptive. On the other hand, if <span class="math">\\tau = \\infty</span>, then <span class="math">\\tau</span>-mildly adaptive is equivalent to static corruption. Similarly if <span class="math">\\tau&#x27; = 0</span>, then we model adaptive sleepiness.</p>

    <p class="text-gray-300">Terminology. Henceforth, if <span class="math">\\mathcal{Z}</span> has not output <span class="math">\\text{precorrupt}(i)</span>, then we say that <span class="math">i</span> is intact. If <span class="math">\\mathcal{Z}</span> has not output <span class="math">\\text{corrupt}(i)</span>, we say that <span class="math">i</span> is honest — basically honest nodes include those that are intact (i.e., have not received precorrupt) or those that are precorrupt but have not actually become corrupt. When <span class="math">\\tau = 0</span>, intact and honest mean the same.</p>

    <h2 id="sec-137" class="text-2xl font-bold">5.2.2 Preliminary: Committee Election in a Permissionless Environment</h2>

    <p class="text-gray-300">In a permissionless environment, the set of nodes who participate in the protocol are not known in advance. It would be desirable to have a protocol that allows us to elect a good committee in a permissionless environment, where a committee is good iff the fraction of corrupt (and precorrupt) nodes in the committee is not too much larger than the fraction of overall corruption <span class="math">\\rho</span>. A recent work called Fruitchains [40] showed a protocol for achieving this above goal relying on any abstract blockchain protocol. Fruitchains [40] shows that given any blockchain protocol with positive chain quality, we can construct a blockchain protocol where for every block length, we can "elect a committee" among which, informally speaking, at most <span class="math">(1 + \\epsilon)\\rho</span> fraction can be corrupt (or precorrupt) where <span class="math">\\epsilon</span> is an arbitrarily small constant and <span class="math">\\rho</span> is the overall percentage of corrupt nodes. In other words, if the adversary controls at most <span class="math">\\rho</span> fraction of corrupt (and precorrupt) nodes, he cannot increase his representation in the elected committee by more than any arbitrarily small <span class="math">\\epsilon</span> fraction. We will formalize this property as fruit quality. We define fruit quality in the more general model that allows mildly adaptive corruptions as described in Section 5.2.1.</p>

    <p class="text-gray-300">Fruit quality. Henceforth, given a blockchain protocol <span class="math">\\Pi_{\\mathrm{blockchain}}</span> and an efficiently computable function fruits, we say that the pair <span class="math">(\\Pi_{\\mathrm{blockchain}}, \\mathrm{fruits})</span> satisfies <span class="math">(K_f, L_f, \\mu_f)</span> fruit quality w.r.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> iff there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for any <span class="math">\\kappa \\in \\mathbb{N}</span>, except with negligible probability over the choice of view <span class="math">\\leftarrow \\mathsf{EXEC}^{\\Pi_{\\mathrm{blockchain}}}(\\mathcal{A}, \\mathcal{Z}, \\kappa)</span>, the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given any honest chain denoted chain in view, for every length <span class="math">\\ell \\geq K_f</span> that is not too short, it holds that fruits(chain[: <span class="math">\\ell</span>]) outputs a set of "fruit records" such that more than <span class="math">\\mu_f</span> fraction of the fruit records are intact at most <span class="math">L_f</span> blocks ago w.r.t. chain[: <span class="math">\\ell</span>] — here we say that a fruit record f is intact at most <span class="math">L_f</span> blocks ago w.r.t. chain[: <span class="math">\\ell</span>] iff f was contained in <span class="math">\\mathcal{Z}</span>'s input to some intact node when its chain length was at least <span class="math">\\ell - L_f</span>.</li>

    </ul>

    <p class="text-gray-300">Although our definition of fruit quality is a slight variant in comparison with the original Fruitchains paper <em>[40]</em> — here we chose to define this variant as it is easier to work with — the Fruitchains work <em>[40]</em> essentially proved the following lemma:</p>

    <h6 id="sec-138" class="text-base font-medium mt-4">Lemma 10 (Fruit quality <em>[40]</em>).</h6>

    <p class="text-gray-300">For any <span class="math">n,\\Delta</span>, and any positive constant <span class="math">\\rho</span>, suppose that there exists a blockchain protocol <span class="math">\\Pi</span> such that for any positive constant <span class="math">\\epsilon</span>, <span class="math">\\Pi</span> satisfies <span class="math">\\epsilon\\kappa</span>-consistency, <span class="math">(\\epsilon\\kappa,\\epsilon\\kappa,\\mu)</span>-chain quality for some positive <span class="math">\\mu</span>, and <span class="math">(\\epsilon\\kappa,g_{0},g_{1})</span>-chain growth for some positive <span class="math">g_{0},g_{1}</span> in <span class="math">(n,\\rho,\\Delta)</span>-permissionless environments, then there exists another blockchain protocol <span class="math">\\widetilde{\\Pi}</span>, an efficiently computable function fruits, and some constants <span class="math">C_{0},C_{1}</span> such that for any positive constant <span class="math">\\epsilon</span>, <span class="math">\\eta</span>, <span class="math">(\\widetilde{\\Pi},\\textsf{fruits})</span> satisfies <span class="math">\\epsilon\\kappa</span>-consistency, <span class="math">(\\epsilon\\kappa,\\epsilon\\kappa,\\mu)</span>-chain quality, <span class="math">(\\epsilon\\kappa,g_{0},g_{1})</span>-chain growth, and <span class="math">(C_{0}\\kappa,C_{1}\\kappa,\\mu_{f})</span>-fruit quality where <span class="math">\\mu_{f}:=1-(1+\\eta)\\rho</span> in <span class="math">(n,\\rho,\\Delta)</span>-permissionless environments.</p>

    <p class="text-gray-300">Henceforth we will use the terms “fruit quality” and “committee quality” interchangably. In particular, ideal fruit quality (or committee quality) would be exactly <span class="math">1-\\rho</span> where <span class="math">\\rho</span> denotes the overall fraction of corrupt nodes.</p>

    <h4 id="sec-139" class="text-lg font-semibold mt-6">Overview of Fruitchains.</h4>

    <p class="text-gray-300">A strawman idea for electing committees is simply to elect the miners of recent <span class="math">\\kappa</span> consecutive blocks as the committee, and to achieve consistency of the committee, a node should also remove <span class="math">\\Theta(\\kappa)</span> number of trailing blocks which might not have stablized. Indeed, some variant of this idea was adopted in some recent works such as Byzcoin <em>[32]</em> who incorrectly claimed that they could achieve almost optimal “committee quality”.</p>

    <p class="text-gray-300">An important observation is that such a strawman scheme does not result in almost ideal committee quality due to a well-known selfish mining attack <em>[21, 23, 39]</em>. We use a proof-of-work blockchain as an example below although selfish mining is also relevant to non-proof-of-work blockchains <em>[15, 30, 43]</em>. In such an attack, whenever a corrupt node mines a block, it does not release the block immediately but withholds it to itself. Whenever an honest miner mines a block at the same length, the adversary now performs a network rushing attack and makes sure that the adversary’s private chain is received first by other honest nodes, such that honest nodes would now choose the adversary’s private chain to extend from. Effectively, for every block mined by corrupt nodes, the adversary can erase one block worth of honest work, thus effectively “erasing” a fraction of the honest mining power. Suppose that the adversary controls <span class="math">\\rho</span> fraction of the total mining power and the honest nodes wield <span class="math">1-\\rho</span> fraction. As argued above, the adversary can effectively erase <span class="math">\\rho</span> fraction of the honest mining power, and thus from a back-of-the-envelop calculation (which can in fact be formalized <em>[23, 39]</em>), we can only attain roughly <span class="math">\\frac{1-2\\rho}{1-2\\rho+\\rho}=1-\\frac{\\rho}{1-\\rho}</span> chain quality (c.f., ideal chain quality would be <span class="math">1-\\rho</span>). Thus the strawman scheme described above achieves only <span class="math">1-\\frac{\\rho}{1-\\rho}</span> committee quality. For example, when the adversary controls <span class="math">\\frac{1}{3}</span> fraction of overall mining power, he controls roughly <span class="math">\\frac{1}{2}</span> of the blocks. Similarly, if adversary controls close to <span class="math">\\frac{1}{2}</span> fraction of overall mining power, he controls almost all blocks! Although the above selfish mining assumes that honest nodes pick the chain received earlier to break ties in length, a similar analysis would apply to other ways of tie breaking (but with possibly slightly less degradation in chain quality).</p>

    <p class="text-gray-300">Fruitchain’s idea defends against such selfish mining attacks by introducing conceptually two independent mining processes (in reality, the two processes are piggybacked on top of each other such that no extra mining is required on top of Nakamoto): one for mining blocks and one for mining fruits. Whenever an honest node mines a fruit, it will broadcast this fruit and honest nodes would then include the fruits in blockchains. Since the work of mining the fruits cannot be erased</p>

    <p class="text-gray-300">5.2. RECENT BLOCKCHAIN MINERS AS COMMITTEE</p>

    <p class="text-gray-300">by an adversary, Fruitchain proves that in any sufficiently large window of consecutive blocks, the fraction of recently mined intact fruits approximates the overall fraction of intact nodes.</p>

    <p class="text-gray-300">Henceforth in our paper will leverage Fruitchain's results as a blackbox in the manner stated by Lemma 10.</p>

    <h2 id="sec-140" class="text-2xl font-bold">5.2.3 Detailed Protocol</h2>

    <p class="text-gray-300">We describe a concrete instantiation of our general committee election framework. This concrete protocol, henceforth denoted <span class="math">\\Pi^{*}</span>, is almost identical to <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span> with the following modifications:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span> is concretely instantiated with one that has almost ideal “fruit quality” where fruits denotes the fruit election function. Specifically, we assume that there are fixed constants <span class="math">C_0</span> and <span class="math">C_1</span> such that for any positive constants <span class="math">\\epsilon, \\eta</span>, <span class="math">(\\Pi_{\\mathrm{blockchain}}, \\mathsf{fruits})</span> satisfies <span class="math">\\epsilon \\kappa</span>-consistency, <span class="math">(\\epsilon \\kappa, \\epsilon \\kappa, \\mu)</span>-chain quality for some positive <span class="math">\\mu</span>, <span class="math">(\\epsilon \\kappa, g_0, g_1)</span>-chain growth, and <span class="math">(C_0 \\kappa, C_1 \\kappa, \\mu_f)</span>-fruit quality where <span class="math">\\mu_f = 1 - (1 + \\eta) \\rho</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Committee selection is now concretely instantiated with the following strategy: whenever the chain output from <span class="math">\\Pi_{\\mathrm{blockchain}}</span> is of length <span class="math">c - 0.5\\kappa</span>,</li>

    </ul>

    <p class="text-gray-300">a) if <span class="math">c - 0.5\\kappa &amp;lt; C_0\\kappa</span>, act as if <span class="math">\\mathsf{elect}(c, \\emptyset)</span> is input from <span class="math">\\mathcal{Z}</span> — note that by our definitions earlier, in this case, no transaction can be notarized w.r.t. the <span class="math">c</span>-th committee;</p>

    <p class="text-gray-300">b) else act as if <span class="math">\\mathsf{elect}(c, \\mathsf{fruits}(\\mathsf{chain}[: c - \\kappa]))</span> has been input from <span class="math">\\mathcal{Z}</span>.</p>

    <p class="text-gray-300"><strong>Compliant executions.</strong> We say that <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi^{*}</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{A}, \\mathcal{Z})</span> is compliant w.r.t. <span class="math">\\Pi_{\\mathrm{blockchain}}</span>; and</li>

      <li><span class="math">(\\mathcal{A}, \\mathcal{Z})</span> respects <span class="math">(n, \\rho, \\Delta, \\tau, 0)</span>-permissionless execution w.r.t. <span class="math">\\Pi^{*}</span> for <span class="math">\\tau \\geq \\frac{(C_1 + 6)\\kappa}{g_0}</span> where <span class="math">g_0</span> is the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>'s growth lower bound parameter.</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 20 (Concrete committee rotation strategy in a permissionless setting).</strong> For any p.p.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> compliant w.r.t. <span class="math">\\Pi^{<em>}</span>, the above protocol <span class="math">\\Pi^{</em>}</span> satisfies consistency, <span class="math">T_{\\mathrm{confirm}}</span>-liveness, and <span class="math">(T_{\\mathrm{warmup}}, T_{\\mathrm{opt}})</span>-optimistic responsiveness in lucky epochs w.r.t. <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> for</p>

    <div class="my-4 text-center"><span class="math-block">T_{\\mathrm{confirm}} := O\\left(\\frac{\\kappa}{g_0}\\right), \\quad T_{\\mathrm{warmup}} := O\\left(\\frac{\\kappa}{g_0}\\right), \\text{ and } T_{\\mathrm{opt}} := 3\\delta</span></div>

    <p class="text-gray-300">where <span class="math">g_0</span> is the underlying <span class="math">\\Pi_{\\mathrm{blockchain}}</span>'s chain growth lower bound parameter.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By Theorems 17, 18, and 19, it suffices to prove that “consistency and timeliness of committee selection” and “resilience” conditions (see Section 5.1.1) are satisfied for all but a negligible fraction of the views — these follow in a straightforward fashion from the definition of <span class="math">\\tau</span>-agility, chain growth lower bound, and fruit quality.</p>

    <p class="text-gray-300">Finally, it is not difficult to see that under mildly-adaptive sleepiness for a sufficiently large <span class="math">\\tau&#x27;</span>, and assuming that <span class="math">\\rho &amp;lt; \\frac{1}{4} - \\epsilon</span>, then except with negligible probability, it is guaranteed that more than <span class="math">\\frac{3}{4}</span> of every committee are honest and online during <span class="math">[\\mathsf{len2time}(c - 0.5\\kappa), \\mathsf{len2time}(c + 0.5\\kappa)]</span>. More specifically, if <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> respects <span class="math">(n, \\frac{1}{4} - \\epsilon, \\Delta, \\tau, \\tau&#x27;)</span>-permissionless execution where <span class="math">\\epsilon</span> is an arbitrarily small positive constant, <span class="math">\\tau = \\tau&#x27; &amp;gt; C\\kappa\\Delta</span> for an appropriately large constant <span class="math">C</span>, then, the condition for a lucky epoch boils down to the following: <span class="math">[T_{\\mathrm{start}}, T_{\\mathrm{end}}]</span> is a lucky epoch in view as long as the following hold:</p>

    <p class="text-gray-300">assume a more practical variant where blocks contain both fruits and transactions, and fruits contain only a public key of the fruit’s miner. Lemma 10 is also expressed for this variant.</p>

    <p class="text-gray-300">CHAPTER 5. THUNDERELLA FOR PERMISSIONLESS</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In any round <span class="math">r \\geq T_{\\mathrm{start}} + \\Delta</span>, any honest and online node should have received the same instruction leader(e, i). Further, prior to <span class="math">T_{\\mathrm{start}}</span>, no honest node has received from <span class="math">\\mathcal{Z}</span> any leader(e', _) where <span class="math">e&#x27;</span> is the same or a larger epoch than <span class="math">e</span>.</li>

      <li>Let <span class="math">c_{0}</span> denote the starting clock number for epoch <span class="math">e</span>, then the leader <span class="math">i</span>'s chain must be no shorter than <span class="math">c_{0} - \\kappa</span> in round <span class="math">T_{\\mathrm{start}}</span>.</li>

      <li>The leader (i.e., node <span class="math">i</span>) is honest and online at in any round <span class="math">t \\in [T_{\\mathrm{start}}, T_{\\mathrm{end}} + 3\\Delta]</span>;</li>

    </ul>

    <h2 id="sec-141" class="text-2xl font-bold">5.2.4 Reward Distribution and Incentive Compatibility</h2>

    <p class="text-gray-300">In a decentralized cryptocurrency, it is important to incentivize participation, such that users will be financially driven to participate in the decentralized consensus — the broader the participation, the more decentralized (and thus more secure) the overall system is. Further, if the underlying blockchain is proof-of-work, users also need to be remunerated to offset the costs associated with participation.</p>

    <p class="text-gray-300">Incentive compatible reward distribution can be achieved using the same ideas as Fruitchains [40]. For each block chain[ℓ], the block reward and the transaction fees for all transactions contained in this block can be distributed to the recent set of fruits, i.e., fruits(chain[: ℓ]). Pass and Shi [40] show that such a reward distribution mechanism achieves <span class="math">\\epsilon</span>-Nash equilibrium against any coalition that controls only minority of the total computation power (for an arbitrarily small positive constant <span class="math">\\epsilon</span>). In other words, as long as the adversary controls less than minority of the computation power, it cannot earn more than <span class="math">\\epsilon</span> fraction more than its fair share of rewards.</p>

    <h2 id="sec-142" class="text-2xl font-bold">5.3 Recent Stake-Holders As Committee</h2>

    <p class="text-gray-300">No matter whether the underlying blockchain is proof-of-work or proof-of-stake [8, 15, 30, 36], it may make sense to select recent stake-holders to act as the committee. In Thunderella, we ask that the stake-based committee help accelerate transaction confirmation. Of course, if the underlying blockchain is also proof-of-stake (e.g., Snow White [15]), then the stake-based committee is in fact serving two purposes: 1) execute the underlying consensus protocol (e.g., Snow White [15]); and 2) help accelerate transaction confirmation in optimistic situations.</p>

    <p class="text-gray-300">The selection of a stake-based committee in Thunderella is no different from the earlier works on proof-of-stake blockchains. Two classes of approaches have been proposed [7, 8, 15, 36]. In both approaches, committee re-election happens periodically per epoch, and the election process takes place on the blockchain (i.e., a committee is decided by looking back at a stabilized prefix of the blockchain). We describe the two committee election strategies below:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Have (possibly a random subset of) the recent stake-holders act as the committee. In this case, as Daian et al. [15] suggested, it would be a good idea to limit the liquidity of the cryptocurrency, such that the present committee cannot immediately sell all of its stake and be incentivized to attack the protocol — recall that since our committee rotation framework <span class="math">\\widetilde{\\Pi}_{\\mathrm{ella}}</span> defends against posterior corruption, i.e., a past committee who have entirely sold their stake well after their term of appointment cannot overwrite history and break consensus. Here the limited liquidity requirement prevents the present stake-holders from selling their stake and defecting too quickly. We defer more detailed discussions of the limited liquidity assumption to Daian et al. [15].</li>

    </ol>

    <p class="text-gray-300">5Here a transaction tx is considered to be contained in the block iff this is the first block in which some notarized or unnotarized version of tx first appears.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Stake-holders can express interest in participation by putting down collateral <em>[7, 8]</em>. This collateral is frozen during the stake-holder’s term of appointment. Should there be evidence that a stake-holder misbehaved during the protocol, its collateral may be taken away as penalty <em>[7]</em>.</li>

    </ol>

    <h4 id="sec-143" class="text-lg font-semibold mt-6">5.3.1 Fair Committee Down-Selection and Incentive Compatibility</h4>

    <p class="text-gray-300">In both cases, if too many stake-holders are eligible to vote, we may consider random down-selection of the committee to <span class="math">\\Theta(\\kappa)</span>-size to reduce bandwidth consumption. Since committee members are rewarded for their participation, such down-selection should be fair <em>[40]</em>, such that an adversary controlling <span class="math">\\rho</span> fraction of recent stake cannot control more than <span class="math">(1+\\epsilon)\\rho</span> of the committee where <span class="math">\\epsilon</span> is an arbitrarily small positive constant.</p>

    <h5 id="sec-144" class="text-base font-semibold mt-4">Strawman idea.</h5>

    <p class="text-gray-300">A strawman idea is to rely on a random oracle <span class="math">H</span> to perform the down-selection, i.e., if <span class="math">H(\\mathsf{pk},(e,s,c))&lt;D_{p}</span> where <span class="math">D_{p}</span> is an appropriate difficulty parameter, then <span class="math">\\mathsf{pk}</span> is considered a committee member for the tuple <span class="math">(e,s,c)</span>. Unfortunately, this idea is prone to an adaptive chosen-key attack, where an adversary, having seen the random oracle <span class="math">H</span>, can choose keys that are guaranteed to be elected for a specific committee <span class="math">c</span>.</p>

    <h5 id="sec-145" class="text-base font-semibold mt-4">Dealing with chosen-key attacks.</h5>

    <p class="text-gray-300">To deal with such an adaptive chosen-key attack, we can adopt an idea described by Snow White <em>[15]</em>, where the public keys must be registered on the blockchain before a random nonce is generated to seed the new random oracle. More formally, A public key <span class="math">\\mathsf{pk}</span> is considered an eligible voter for the tuple <span class="math">(e,s,c)</span> iff</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pk}</span> holds sufficient stake in the prefix of the chain <span class="math">\\mathsf{chain}[:c-2\\kappa]</span>; (henceforth, we assume that some minimal stake <span class="math">S</span> is required to become a voter, and if a public key <span class="math">\\mathsf{pk}</span> has <span class="math">kS</span> amount of stake, it is regared as <span class="math">k</span> separate public keys);</li>

      <li>We rely on <span class="math">\\Theta(\\kappa)</span> blocks <span class="math">\\mathsf{chain}[c-2\\kappa:c-\\kappa]</span> to generate a nonce <span class="math">r</span> to seed the new random oracle. Specifically, every miner will embed a sufficiently high-entropy random string into every block it mines; and the nonce is obtained by concatenating the random strings contained in this <span class="math">\\Theta(\\kappa)</span>-sized window. Although an adversary can arbitrarily manipulate the strings contained in corrupt blocks, by chain quality, there is at least one honest block among <span class="math">\\Theta(\\kappa)</span> consecutive blocks — and thus the resulting nonce must have sufficiently high-entropy;</li>

      <li><span class="math">H(r,\\mathsf{pk},(e,s,c))&lt;D_{p}</span> where <span class="math">D_{p}</span> is an appropriate difficulty parameter such that each committee will be roughly <span class="math">\\Theta(\\kappa)</span> in size.</li>

    </ol>

    <h5 id="sec-146" class="text-base font-semibold mt-4">Defense against adaptive corruptions through secret committee election.</h5>

    <p class="text-gray-300">One possible threat is that the adversary may adaptively corrupt committee members after having observed who are elected to a committee. To thwart such an attack, we can rely on verfiable random functions in a similar fashion as Section 4.2.1 — and this idea is inspired by Algorand <em>[36]</em>. Such a VRF allows us to elect a new committee for each <span class="math">(e,s,c)</span> — but who is elected is hidden from the adversary in advance. In particular, the newly seeded random oracle generated in the aforementioned manner will instead be used to implement a VRF that determines if a certain public key is an eligible voter for the tuple <span class="math">(e,s,c)</span>. Further, the signature scheme for performing notarization is replaced with a forward-secure signature scheme as described in Section 4.2.1, such that the signing key evolves upon each usage, and the old state of the signing key is erased and purged from memory immediately after usage. Just as we argued in Section 4.2.1, such a scheme defends against adaptive corruptions in the random oracle model assuming erasure.</p>

    <p class="text-gray-300">Penalty mechanisms.</p>

    <p class="text-gray-300">Another useful idea is to explicitly penalize committee members that have misbehaved (e.g., signed equivocating transactions) <em>[7, 8]</em>. If committee members put down collateral to participate, penalty can be implemented by taking away their collateral and rewarding the party who submits cryptographic evidence of cheating (e.g., doubly signed signatures). Additionally, it would be useful to dis-incentivize free-riding, i.e., stake-holders who register to vote but do not end up participating in an attempt to get free rewards. This can be achieved by adjusting the reward mechanism to give more share to those who have participated (e.g., as cryptographically evident from the signatures they signed).</p>

    <h3 id="sec-147" class="text-xl font-semibold mt-8">5.4 Leader As an Acceleration Service</h3>

    <h4 id="sec-148" class="text-lg font-semibold mt-6">Acceleration service.</h4>

    <p class="text-gray-300">Another question is how to elect the leader in a decentralized deployment. An important observation here is that the leader is only an accelerator and need not be trusted. Even when the leader starts to behave arbitrarily, the worst thing it can do is that our protocol will fall back to the performance of today’s blockchains (e.g., Bitcoin or Ethereum’s blockchains). On the other hand, to get faster performance, it is desirable if the leader is well-provisioned, e.g., in terms of network resources. To obtain a really fast optimistic path, we can even have the leader open direct IP links to every committee member, for propagating notarization proposals and collecting votes. Once a proposal has been notarized, the notarized tuple (with all signatures) can then be propagated over a peer-to-peer overlay network (e.g., Bitcoin or Ethereum’s peer-to-peer network) to everyone else.</p>

    <p class="text-gray-300">One desirable approach is for nodes to bid to become the leader and the leader can potentially charge a percentage of the transaction fees to offset its costs of running an acceleration service. The network should prefer to choose a leader that is well-provisioned and has a fast link to everyone.</p>

    <p class="text-gray-300">Anyone interested in providing such an acceleration service should be aware of the possibility of a Distributed Denial-of-Service (DDoS) attack on the leader. Such a DDoS attack can transiently slow down transaction confirmation until a new leader takes over. There are numerous approaches that a leader can employ to protect itself against such DDoS attacks. For example, it can rely on commercially available DDoS protection services (the associated costs can be offset by collecting fees from running the acceleration service). The leader can also be placed behind geographically distributed proxies and not present a public IP address. The leader can also agilely move from one IP address to another to reduce the risk of being DDoS’ed. Even in the presence of an actual DDoS attack, we can always rely on any form of heuristic offchain mechanism to hand-off to a backup leader — this hand-off mechanism is not on any security critical path, and any suitable heursitics can be adopted, since our protocol is secure even when the logical leader is corrupt.</p>

    <h4 id="sec-149" class="text-lg font-semibold mt-6">Monitoring the leader.</h4>

    <p class="text-gray-300">The network can together monitor the leader and vote the leader out whenever suspicious behavior is detected. For example, one concern might be that the leader in Thunderella can possibly reorder transactions (just like miners in Bitcoin or Etheurem). Fundamentally, since the network has delay up to <span class="math">\\Delta</span>, for transactions that are issued <span class="math">\\Delta</span> rounds apart from each other, it may not be possible to determine their absolute order. However, if the leader attempts to reorder transactions more drastically, e.g., by more than <span class="math">\\Delta</span> rounds, it is possible for other peers to detect it. For example, a peer can monitor the leader by comparing the leader’s proposed order against the order and times at which the peer observes transactions himself. If sufficiently many stake-holders do not like the leader, then they can jointly vote the current leader out and reelect a new one.</p>

    <p class="text-gray-300">Bibliography</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Personal communication with Vitalik Buterin.</li>

      <li>[2] Hagit Attiya, Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Bounds on the time to reach agreement in the presence of timing uncertainty. J. ACM, 41(1):122–152, 1994.</li>

      <li>[3] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. In Financial Cryptography Bitcoin Workshop, 2016.</li>

      <li>[4] Iddo Bentov, Charles Lee, Alex Mizrahi, and Meni Rosenfeld. Proof of activity: Extending bitcoin’s proof of work via proof of stake. In Proceedings of the ACM SIGMETRICS 2014 Workshop on Economics of Networked Systems, NetEcon, 2014.</li>

      <li>[5] Kenneth P. Birman and Thomas A. Joseph. Exploiting virtual synchrony in distributed systems. In Proceedings of the Eleventh ACM Symposium on Operating System Principles, SOSP 1987, Stouffer Austin Hotel, Austin, Texas, USA, November 8-11, 1987, pages 123–138, 1987.</li>

      <li>[6] Mike Burrows. The chubby lock service for loosely-coupled distributed systems. In Proceedings of the 7th Symposium on Operating Systems Design and Implementation, OSDI ’06, pages 335–350, 2006.</li>

      <li>[7] Vitalik Buterin. https://medium.com/@VitalikButerin/minimal-slashing-conditions-20f0b500fc6c, 2017.</li>

      <li>[8] Vitalik Buterin and Vlad Zamfir. Casper. https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/, 2015.</li>

      <li>[9] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</li>

      <li>[10] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Theory of Cryptography, pages 61–85. Springer, 2007.</li>

      <li>[11] Ran Canetti and Tal Rabin. Universal composition with joint state. In CRYPTO, 2003.</li>

      <li>[12] Armando Castañeda, Yannai A. Gonczarowski, and Yoram Moses. Unbeatable consensus. In DISC, 2014.</li>

      <li>[13] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI, 1999.</li>

      <li>[14] User ”cunicula” and Meni Rosenfeld. Proof of stake brainstorming. https://bitcointalk.org/index.php?topic=37194.0, August 2011.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">BIBLIOGRAPHY</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. Cryptology ePrint Archive, Report 2016/919, 2016.</li>

      <li>[16] Christian Decker, Jochen Seidel, and Roger Wattenhofer. Bitcoin meets strong consistency. In ICDCN, 2016.</li>

      <li>[17] Danny Dolev, Ruediger Reischuk, and H. Raymond Strong. Early stopping in byzantine agreement. J. ACM, 37(4):720–741, October 1990.</li>

      <li>[18] Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement. Siam Journal on Computing - SIAMCOMP, 12(4):656–666, 1983.</li>

      <li>[19] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.</li>

      <li>[20] Cynthia Dwork and Yoram Moses. Knowledge and common knowledge in a byzantine environment i: Crash failures. In TARK, pages 149–169, 1986.</li>

      <li>[21] Ittay Eyal and Emin Gun Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC, 2014.</li>

      <li>[22] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol with chains of variable difficulty. Cryptology ePrint Archive, 2016/1048.</li>

      <li>[23] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Eurocrypt, 2015.</li>

      <li>[24] Rachid Guerraoui, Nikola Knežević, Vivien Quéma, and Marko Vukolić. The next 700 bft protocols. In Proceedings of the 5th European Conference on Computer Systems, EuroSys ’10, pages 363–376, New York, NY, USA, 2010. ACM.</li>

      <li>[25] Joseph Y. Halpern, Yoram Moses, and Orli Waarts. A characterization of eventual byzantine agreement. SIAM J. Comput., 31(3):838–865, 2001.</li>

      <li>[26] Maurice Herlihy, Yoram Moses, and Mark R. Tuttle. Transforming worst-case optimal solutions for simultaneous tasks into all-case optimal solutions. In PODC, 2011.</li>

      <li>[27] Amir Herzberg and Shay Kutten. Early detection of message forwarding faults. SIAM J. Comput., 30(4):1169–1196, 2000.</li>

      <li>[28] Flavio P. Junqueira, Benjamin C. Reed, and Marco Serafini. Zab: High-performance broadcast for primary-backup systems. In Proceedings of the 2011 IEEE/IFIP 41st International Conference on Dependable Systems&amp;Networks, DSN ’11, pages 245–256, 2011.</li>

      <li>[29] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst. Sci., 75(2):91–112, February 2009.</li>

      <li>[30] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. Cryptology ePrint Archive, Report 2016/889, 2016. http://eprint.iacr.org/2016/889.</li>

      <li>[31] Sunny King and Scott Nadal. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake. https://peercoin.net/assets/paper/peercoin-paper.pdf, 2012.</li>

    </ul>

    <p class="text-gray-300">[32] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus Gasser, and Bryan Ford. Enhancing bitcoin security and performance with strong consistency via collective signing. CoRR, abs/1602.06997, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[33] Ramakrishna Kotla, Lorenzo Alvisi, Michael Dahlin, Allen Clement, and Edmund L. Wong. Zyzzyva: speculative byzantine fault tolerance. In Proceedings of the 21st ACM Symposium on Operating Systems Principles 2007, SOSP 2007, Stevenson, Washington, USA, October 14-17, 2007, pages 45–58, 2007.</li>

      <li>[34] Leslie Lamport. Fast paxos. Distributed Computing, 19(2):79–103, 2006.</li>

      <li>[35] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. Vertical paxos and primary-backup replication. In PODC, pages 312–313, 2009.</li>

      <li>[36] Silvio Micali. Algorand: The efficient and democratic ledger. https://arxiv.org/abs/1607.01341, 2016.</li>

      <li>[37] Yoram Moses and Michel Raynal. No double discount: Condition-based simultaneity yields limited gain. Inf. Comput., 214:47–58, May 2012.</li>

      <li>[38] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</li>

      <li>[39] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.</li>

      <li>[40] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. In PODC, 2017.</li>

      <li>[41] Rafael Pass and Elaine Shi. Hybrid consensus: Efficient consensus in the permissionless model. In DISC, 2017.</li>

      <li>[42] Rafael Pass and Elaine Shi. Rethinking large-scale consensus (invited paper). In CSF, 2017.</li>

      <li>[43] Rafael Pass and Elaine Shi. The sleepy model of consensus. In Asiacrypt, 2017.</li>

      <li>[44] User ”QuantumMechanic”. Proof of stake instead of proof of work. https://bitcointalk.org/index.php?topic=27787.0, July 2011.</li>

      <li>[45] Yee Jiun Song and Robbert van Renesse. Bosco: One-step byzantine asynchronous consensus. In DISC, pages 438–450, 2008.</li>

      <li>[46] Dominic Williams. How to achieve near-instant finality in public blockchains using a VRF. http://string.technology/2017/02/03/stanford-conference.en/, 2017.</li>

      <li>[47] Gavin Wood. Ethereum: A secure decentralized transaction ledger. http://gavwood.com/paper.pdf, 2014.</li>

    </ul>

    <h2 id="sec-150" class="text-2xl font-bold">Global Signing Functionality</h2>

    <p class="text-gray-300">We define the following global signing functionality <span class="math">\\mathcal{G}^{\\Sigma}_{\\text{sign}}</span> that is parametrized by a signature scheme <span class="math">\\Sigma</span>. This functionality can easily be realized assuming a (global) bare public key infrastructure.</p>

    <p class="text-gray-300">BIBLIOGRAPHY</p>

    <p class="text-gray-300">|  GΣsign  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  ·On receiving initialize from some honest node i: call (pk_i, sk_i) ← Σ.Gen(1κ), notify A of (i, pk_i), and return pk_i.  |</p>

    <p class="text-gray-300">|  ·On receiving setkey(pk_i, sk_i) from some corrupt node i: record (pk_i, sk_i) if a key pair has not been recorded for i.  |</p>

    <p class="text-gray-300">|  ·On honest node i becoming corrupt: disclose sk_i to A.  |</p>

    <p class="text-gray-300">|  ·On receiving sign(msg) from party i in protocol instance sid: if a key pair (pk_i, sk_i) has been recorded for i, then return σ := Σ.Sign(sk_i, (sid, msg)); else return ⊥.  |</p>

    <p class="text-gray-300">|  ·On receiving query(i): return pk_i.  |</p>

    <p class="text-gray-300">Interactions between  <span class="math">\\mathcal{Z}</span>  and  <span class="math">\\mathcal{G}_{\\mathrm{sign}}</span> . We assume that the following types of interactions can happen between  <span class="math">\\mathcal{Z}</span>  and  <span class="math">\\mathcal{G}_{\\mathrm{sign}}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Z}</span>  can interact with  <span class="math">\\mathcal{G}_{\\mathrm{sign}}</span>  acting as the adversary  <span class="math">\\mathcal{A}</span>  or any corrupt node;</li>

      <li><span class="math">\\mathcal{Z}</span>  can interact with  <span class="math">\\mathcal{G}_{\\mathrm{sign}}</span>  acting as an honest party, but only for non-challenge protocol sessions (i.e., where the session identifier must be different from the challenge protocol session that we are concerned about). This models the fact that there may be other rogue protocols running possibly concurrently with the challenge protocol session.</li>

    </ul>`;
---

<BaseLayout title="Thunderella: Blockchains with Optimistic Instant Confirmatio... (2017/913)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/913
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
