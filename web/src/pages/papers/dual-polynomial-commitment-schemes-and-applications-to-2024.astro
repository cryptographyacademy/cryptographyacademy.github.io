---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/943';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Dual Polynomial Commitment Schemes and Applications to Commit-and-Prove SNARKs';
const AUTHORS_HTML = 'Chaya Ganesh, Vineet Nair, Ashish Sharma';

const CONTENT = `    <p class="text-gray-300">Chaya Ganesh^{1}©, Vineet Nair^{2}©, and Ashish Sharma^{2}©</p>

    <p class="text-gray-300">^{1} Indian Institute of Science chaya@iisc.ac.in ^{2} Arithmic Labs {vineet,ashish}@arithmic.com</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In this work, we introduce a primitive called a dual polynomial commitment scheme that allows linking together a witness committed to using a univariate polynomial commitment scheme with a witness inside a multilinear polynomial commitment scheme. This yields commit-and-prove (CP) SNARKs with the flexibility of going back and forth between univariate and multilinear encodings of witnesses. This is in contrast to existing CP frameworks that assume compatible polynomial commitment schemes between different components of the proof systems. In addition to application to CP, we also show that our notion yields a version of Spartan with better proof size and verification complexity, at the cost of a more expensive prover.</p>

    <p class="text-gray-300">We achieve this via a combination of the following technical contributions: (i) we construct a new univariate commitment scheme in the updatable SRS setting that has better prover complexity than KZG (ii) we construct a new multilinear commitment scheme in the updatable setting that is compatible for linking with our univariate scheme (iii) we construct an argument of knowledge to prove a given linear relationship between two witnesses committed using a two-tiered commitment scheme (Pedersen+AFG) using Dory as a black-box. These constructions are of independent interest.</p>

    <p class="text-gray-300">We implement our commitment schemes and report on performance. We also implement the version of Spartan with our dual polynomial commitment scheme and demonstrate that it outperforms Spartan in proof size and verification complexity.</p>

    <p class="text-gray-300">1 Introduction 3 1.1 Applications 4 1.2 Our Contributions 5 1.3 Technical Overview 5 1.4 Related Work 7</p>

    <p class="text-gray-300">2 Preliminaries 7 2.1 Assumptions 9 2.2 Commitment Schemes 9 2.3 Interactive Arguments 9 2.4 Polynomial Commitment Scheme 10</p>

    <p class="text-gray-300">3 Univariate Polynomial Commitment Scheme 11 3.1 Setup Generation 11 3.2 Protocol 12</p>

    <p class="text-gray-300">4 Multilinear Commitment Scheme 14 4.1 Technical Preliminaries 14 4.2 Setup Generation 15 4.3 Protocol 16</p>

    <p class="text-gray-300">5 Dual Polynomial Commitments 19 5.1 DualPCS with Updatable Setup 20 5.2 DualPCS with Transparent Setup 21 5.3 Application: Spartan AIR 22 AIR for Grand-Product 23</p>

    <p class="text-gray-300">6 Implementation 24 6.1 Commitment Schemes 24 6.2 Spartan using Grand-Product AIR 25</p>

    <p class="text-gray-300">A General Approach to derive Linking Soundness 28 B Updatable SRS Model 28 C Univariate PCS KZG-FFT 28 C.1 Updatability of the SRS in KZG-FFT 28 C.2 Proof of Theorem 4 30</p>

    <p class="text-gray-300">D Multilinear PCS KZG-FOURIER 34 D.1 Proofs of Claims and Lemma from Section 4.1 34 D.2 Proof of Theorem 9 37</p>

    <p class="text-gray-300">E Argument of Knowledge to Establish Linear Relations 40 E.1 Transparent Setup for Linear Relation 40 E.2 Proving Linear Relations 40 E.3 Proof of Theorem 16 41</p>

    <p class="text-gray-300">F Proof of Theorems from Section 5 42 F.1 Proof of Theorem 10 42 F.2 Proof of Theorem 11 42</p>

    <p class="text-gray-300">G Succinct Argument of Knowledge for Inner-Pairing Products 42 G.1 Public Parameters 43 G.2 Dory Protocol 43 G.3 Evaluation Proofs using Dory 45</p>

    <p class="text-gray-300">H Additional Results from Implementation 46</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge proofs and argument systems (ZK) <em>[x10]</em> allow proving that a statement is valid without revealing any additional information. <em>Succinct Non-interactive ARguments of Knowledge</em> (zk-SNARKs), are ZK arguments with the additional property that the size of the proof and verifier work to check the proof is sublinear in the size of the statement. zk-SNARKs are a fundamental building block in modern cryptographic systems where it is crucial that the verification time does not scale with the size of the computation. A design principle for constructing SNARKs is to start from an information-theoretic proof system like Polynomial Interactive Oracle Proofs (PIOP)/ Algebraic Holographic Proofs (AHP) and compile them using a cryptographic compiler like a polynomial commitment scheme.</p>

    <p class="text-gray-300">Polynomial Commitment Scheme (PCS). At a high level, a PCS enables a prover to initially commit to a polynomial <span class="math">f</span> of bounded degree. Later, the prover can reveal evaluations of <span class="math">f</span> at chosen points, accompanied by proofs verifying that the disclosed values align with the original commitment. A PCS is a central cryptographic tool used to obtain a SNARK in a modular way. A SNARK resulting from compiling an information-theoretic protocol inherits the complexity of the PCS; that is, the proof size depends on the commitment size and evaluation proof size of the PCS. PCSs (and SNARKs) are either in the Structured Reference String (SRS) model or in idealized models (like ROM,GGM,AGM) or both. If the SRS is produced using secret randomness (soundness depends on the this randomness being secret), the setup is called <em>trusted</em> setup. If the SRS is produced using only public coins, the setup is called <em>transparent</em>. An intermediate notion is that of <em>updatable</em> setup, where parties can continuously contribute to the randomness of the SRS, and an SRS is trusted as long as at least one of the updates is honest.</p>

    <p class="text-gray-300">Commit-and-prove SNARKs (CP-SNARKs). An important family of SNARKs is one with a commit-and-prove extension, called a <em>commit-and-prove</em> SNARKs (CP-SNARKs) <em>[x11]</em> where the inputs are separately committed to. A CP-SNARK allows verification of a proof through this commitment, that, crucially, can be reused across proofs. The presence of these commitments allow to glue together different proof systems that use parts of same witness. CP-SNARKs are useful in a variety of applications where one needs to prove composite statements using the most efficient tool for each part of the statement. CP-SNARKs allow modularity of proof systems thus providing <em>interoperability</em> with different protocols specialized for efficiently proving certain class of relations. For instance, consider a “mixed” computation that naturally presents different components, like Boolean/arithmetic circuit for a hash function, and algebraic representation for group operations. Using a general-purpose zkSNARK for such a computation requires one homogeneous intermediate representation of this computation. This incurs a high cost in performance; for example, writing a modular exponentiation as a circuit requires number of gates that grows with the size of the modulus. A CP-SNARK takes advantage of the native representation of different parts of the computation and does a mix-and-match of the best proof system for each component, e.g., SNARKs for an arithmetic circuit and a Sigma-protocol for an algebraic relation.</p>

    <p class="text-gray-300">Existing CP-SNARK frameworks assume compatibility of the cryptographic compilers used in the different proof components. If one information theoretic proof component is compiled using a PCS, then the linking proofs are designed to be compatible with the representation of the polynomials (vectors of coefficients/ vectors of evaluations) used by the polynomial commitment scheme. That is, the linking that is essential for a CP-SNARK works as long as the PCS match up in how they interpret the polynomial (univariate vs multivariate, vector of coefficients vs vector of evaluations etc.). What if we want a CP-SNARK where one component uses a polynomial represented as a vector of coefficients and committed to using a univariate PCS (like KZG <em>[x16]</em>), and another component represents its polynomials as a vector of evaluations and are committed to using a multilinear scheme (like PST <em>[x17]</em> or Hyrax <em>[WTS^{+}18]</em>) and these polynomials encode the same shared witness?</p>

    <p class="text-gray-300">We put forth the notion of a <em>dual polynomial commitment scheme</em>, that links univariate and multilinear PCS. Specifically, a dual polynomial commitment scheme can be used to prove evaluations of a univariate and a multilinear polynomial derived from the <em>same</em> witness. Towards this, we construct an efficient linking proof for connecting a witness committed to using a univariate polynomial commitment scheme with a witness inside a multivariate polynomial commitment scheme. The dual polynomial commitment scheme allows one to go back and forth between univariate and multilinear encodings of witnesses. To further motivate the need for such flexibility, we now outline some example applications.</p>

    <p class="text-gray-300">1.1 Applications</p>

    <p class="text-gray-300">Commit-and-prove Lookup. There exist general compilers <em>[CFF^{+}21,ABC^{+}22]</em> that take an information-theoretic proof, like an Algebraic Holographic Proof (AHP) or Polynomial Interactive Oracle Proof (PIOP) and compile them into a CP-SNARK using a cryptographic compiler like a PCS. Concrete instantiations of these compilers yield frameworks that can glue together general purpose SNARKS for an arithmetic circuit/Rank 1 constraint system (R1CS),like Marlin/Sonic/Plonk with proof systems for algebraic statements, like Sigma protocols. However, the above works do not directly handle <em>lookup arguments</em>. They can be extended in a straightforward way to lookups, but they are not general since they are limited to lookup arguments that use the same PCS as the compiler or a “compatible” one. For example, the Lasso <em>[x21]</em> lookup argument can be extended to give CP-lookup but can only be linked to Spartan <em>[x18]</em>; and Plookup <em>[x6]</em> can be extended to be CP-lookup linked to Plonk <em>[x7]</em>. We briefly discuss why lookup arguments are useful and it is desirable to have general CP-SNARKs that allow linking to lookups. A lookup argument, at a high level, allows a prover to convince a verifier that <span class="math">v_{i}=t_{a_{i}}</span> for all <span class="math">i</span> given committed vectors <span class="math">\\vec{t},\\vec{u}</span> and <span class="math">\\vec{v}</span>. Circuit based representations are inefficient in expressing certain relations, like bit-decomposition. Lookups are used as custom gates in SNARKs (for instance plookup<em>[x6]</em>, Arya<em>[BCG^{+}18]</em>) where “SNARK-unfriendly” operations like bit-decomposition, range proof etc. are performed via a table lookup instead of a circuit representation using addition/multiplication gates. This rich and growing body of work on lookup arguments culminated in the notion of lookup singularity[Whi] where SNARK front ends produce circuit representations consisting of <em>only</em> lookups. Lasso <em>[x21]</em> and Jolt <em>[x1]</em> together achieve this lookup singularity: (i) a circuit that executes an instruction at each step (SNARK-unfriendly gates like OR, XOR, AND etc) is modeled as a single lookup into a large lookup table (ii) efficient lookup into large tables via table decomposition. Jolt uses Lasso for step (ii) which uses sumcheck arguments and hence requires a multilinear PCS. Thus, while Lasso naturally admits commit-and-prove, this is restricted to SNARKs that encode the witness in a multivariate PCS to match the PCS used in the lookup argument of Lasso. In the spirit of commit-and-prove, our goal is to include lookup as a gadget in the toolbox of CP-SNARKs and modularly build complex schemes by mixing and matching lookup with other widely deployed circuit-based SNARKs. Via our dual polynomial commitment scheme, we can construct a CP-SNARK that combines general purpose SNARKs with lookup arguments, regardless of how the underlying PCS work (univariate/multilinear).</p>

    <p class="text-gray-300">Let us consider the following scenario: The verifier would like to check that <span class="math">a_{1},\\ldots,a_{m}</span> which are certain intermediate values in a computation are all in a large range, like, in <span class="math">\\{0,1,\\ldots,2^{32}-1\\}</span>. Checking <span class="math">m</span> values are in the range <span class="math">&lt;2^{N}</span> requires <span class="math">O(mN)</span> R1CS constraints on an <span class="math">O(mN)</span> length witness. Using STARK, this incurs a cost of at least <span class="math">3m</span> FFTs of length <span class="math">O(N)</span> resulting in a prover complexity of <span class="math">O(mN\\log N)</span> field operations. This cost stems from expensive operations involving bit-decomposition due to the range checks inside the circuit. This cost is avoided by moving the range checks “outside” the SNARK circuit to lookups. Now, there is a need to “tie” the <span class="math">a_{1},\\ldots,a_{m}</span> that were used in the lookup to the intermediate values of the computation. That is, given commitments to <span class="math">a_{1},\\ldots,a_{m}</span>, the lookup argument proves each <span class="math">a_{i}</span> is in the desired range, a general-purpose zkSNARK proves the computation, and this combination is sound only if the verifier is convinced that the each <span class="math">a_{i}</span> used in the lookup argument is indeed the output of the sub-computation up to the range check and the input to the sub-computation after the range check. This gluing step is straightforward if the polynomial commitment scheme used in the lookup argument and the rest of the SNARK is the same (like Lasso <em>[x21]</em> and Spartan <em>[x18]</em>, or Caulk <em>[ZBK^{+}22]</em> and Plonk <em>[x7]</em>). This falls short of the goal of commit-and-prove which is generality: plug-and-play different gadgets for different sub-computations. In particular, if one were to use a SNARK like Groth16 (based on KZG, a univariate PCS) and a lookup argument like Lasso (based on multilinear PCS), then the approach described above will not work as-is. Our constructions overcome the technical difficulty in establishing consistency of witnesses used in the SNARK and the lookup argument encoded via a univariate PCS and a multilinear PCS respectively.</p>

    <p class="text-gray-300">Grand Product and Efficient Spartan. We design a new special-purpose proof system for proving grand product relations that could be of independent interest. One concrete benefit of our grand product argument is that it yields an efficient version of Spartan obtained as a CP-SNARK using our dual polynomial commitment scheme. The polynomials that encode the intermediate computation states of the grand product computation are committed to using our univariate PCS KZG-FFT. This grand product argument can be put together with the rest of the Spartan proof that uses a multilinear PCS relying on the linking soundness guarantee of the dual PCS. The resulting SNARK, Spartan AIR, has concretely better proof complexity and verifier complexity, albeit at the cost of worse prover</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">No Of Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Prover (sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Verifier (sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size (KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan AIR</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan AIR</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan AIR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">17.37</td>

            <td class="px-3 py-2 border-b border-gray-700">97.76</td>

            <td class="px-3 py-2 border-b border-gray-700">0.97</td>

            <td class="px-3 py-2 border-b border-gray-700">0.58</td>

            <td class="px-3 py-2 border-b border-gray-700">69.28</td>

            <td class="px-3 py-2 border-b border-gray-700">35.64</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">32.55</td>

            <td class="px-3 py-2 border-b border-gray-700">936.24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.22</td>

            <td class="px-3 py-2 border-b border-gray-700">0.62</td>

            <td class="px-3 py-2 border-b border-gray-700">82.16</td>

            <td class="px-3 py-2 border-b border-gray-700">39.07</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Metrics comparing Spartan and Spartan-AIR. Spartan denotes Spartan with grand-product check using [GKR08,Tha13], and Spartan AIR denotes spartan with grand-product check using the AoK from Section 5.3. The ratio of sparsity to constraints in the R1CS matrices is maintained to one.</p>

    <p class="text-gray-300">complexity (Table 1). We believe this is a worthwhile trade-off in some applications. One example is the use of a folding-based recursive proof system like Nova [KST22] on the blockchain. Here, most of the time, the system does folding based recursion, and a layer-1 verifier checks the final folded instances which are only infrequently proven after many folding steps. When Nova's folding scheme is applied to Spartan, the large proof-sizes and verifier complexity requires wrapping the Spartan verifier of the relaxed instances inside a more verifier-friendly SNARK like Groth16 [Gro16]. While Groth16 is verifier efficient, it's SRS is circuit dependent and not updatable. In contrast, using our approach, we can obtain better proof size and verifier complexity directly for the Spartan proof while retaining transparent SRS.</p>

    <p class="text-gray-300">zkRollups. Combining lookups with other SNARKs is also relevant in the context of rollups. Blockchain rollups are a scaling solution that move expensive computation off-chain to layer two chains. Here, the network participants only need to verify succinct proofs attesting to the correctness of the off-chain computation. This approach allows verifying the L2 state resulting from several rolled up transactions as part of one transaction verified on the main chain. Commit-and-prove provides better rollup solutions by allowing signature verification to be done using suitable SNARKs and checking validity of transactions using table lookups. While this is an important general application of commit-and-prove lookup, we do not provide details of an end-to-end rollup solution in this work.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We propose a univariate polynomial commitment scheme KZG-FFT where the prover need not perform expensive FFT operations. It is variant of the KZG scheme where we commit to the vector of evaluations over the FFT domain instead of the coefficient vector. Interpolating the witness vector to obtain evaluations is not done by the prover, instead the setup phase creates the SRS after applying the corresponding linear transformation. We then show how to make the SRS universal and updatable.</li>

      <li>We propose a new multilinear polynomial commitment scheme KZG-FOURIER that is suited for linking with our univariate scheme KZG-FFT.</li>

      <li>We define the notion of a dual polynomial commitment scheme (DualPCS) that allows committing to a witness both as a univariate and a multilinear polynomial. We provide two candidate instantiations of dual polynomial commitment scheme: one in the updatable SRS setting that uses KZG-FFT and KZG-FOURIER, and another in the transparent setting. We implement our schemes in Rust and show setup/prover/verifier time for growing witness sizes.</li>

      <li>We present an argument of knowledge to prove a given linear relationship between two witnesses committed using a two-tiered commitment scheme (Pedersen+AFG) that uses Dory as a black-box. We use this argument in our instantiation of a transparent DualPCS. In our instantiation, we preprocess an FFT matrix that determines the linear relationship we need for our DualPCS.</li>

      <li>We construct a new argument of knowledge for proving grand product relations. This is an instantiation of existing proof system using our KZG-FFT commitment scheme as the PCS. However, our DualPCS enables us to switch to multilinear representation and use the grand product argument with Spartan or Lasso yielding smaller proof sizes. We report implementation results of performance of the version of Spartan using our grand product argument.</li>

    </ol>

    <p class="text-gray-300">DUAL POLYNOMIAL COMMITMENT (DualPCS). We put forth the notion of a DualPCS that links a witness encoded in univariate and multilinear polynomial commitment schemes. Given a witness vector, the commit algorithm produces two commitments, obtained by viewing the witness as (i) the</p>

    <p class="text-gray-300">evaluations of a univariate polynomial over the FFT domain, and (ii) a multilinear polynomial encoding over the boolean hypercube. The encoding and the choice of domains are motivated by existing PIOPs that interpret the witness in this way. Like in a regular PCS, there are evaluation protocols that allow opening each of these commitments to claimed evaluations of the underlying polynomial. In addition, a DualPCS comes with a linking proof that guarantees that the univariate and multilinear commitments refer to the <em>same witness</em>. The notion of DualPCS handles any external “linking” proof needed in general-purpose CP-SNARKs and solves the <em>challenge of native compatibility</em> articulated in <em>[x10]</em>. Our first DualPCS candidate KZG-FFT-FOURIER is in the updatable SRS setting. The protocol crucially relies on a linear isomorphism between the space of multilinear polynomials and univariate polynomials. The isomorphism maps the Lagrange bases of multilinear polynomials over the boolean hypercube to the Lagrange basis of univariate polynomials over the multiplicative subgroup generated by primitive roots of unity. Leveraging this isomorphism makes an explicit linking proof unnecessary since given a witness vector, the commitments to encoding via (i) and encoding via (ii) are the <em>same</em>, resulting in no linking overhead. We now provide an overview of the univariate scheme KZG-FFT and the multilinear scheme KZG-FOURIER that make up the DualPCS KZG-FFT-FOURIER.</p>

    <p class="text-gray-300">Univariate scheme KZG-FFT. We begin by outlining the ideas behind the KZG PCS <em>[x24]</em> which is our starting point. The KZG scheme works as follows: the commitment to a univariate polynomial <span class="math">f(Y)</span> is the encoding of the evaluation of the polynomial at a secret point. The encoding used is exponentiation in a bilinear group, which makes the commitment one group element: <span class="math">C:=g^{f(\\tau)}</span>. In order to enable the prover to compute this, the setup produces a structured reference string (srs) consisting of encodings of powers of the secret point <span class="math">\\tau</span>. The prover can use the additive homomorphism of the encoding to compute <span class="math">g^{f(\\tau)}</span> without knowing <span class="math">\\tau</span> using the coefficient vector of <span class="math">f</span> and <span class="math">\\textsf{srs}=\\{g^{\\tau^{\\prime}}\\}</span>. This srs is also <em>updatable</em>: new randomness <span class="math">\\tau_{1}</span> can be sampled and <span class="math">\\textsf{srs}^{\\prime}=\\{g^{\\tau^{\\prime\\prime}}\\}</span> can be computed where <span class="math">\\tau^{\\prime}=\\tau\\cdot\\tau_{1}</span>, using srs and <span class="math">\\tau_{1}</span>. Now, to provably open the committed polynomial at a random point <span class="math">z</span>, the prover produces a proof for the claim <span class="math">f(z)=v</span> as follows. It computes the quotient polynomial <span class="math">q(Y):=(f(Y)-v)/Y-z</span> and provides a commitment to <span class="math">q(Y)</span> as the proof; <span class="math">\\pi=g^{q(\\tau)}</span>. The verifier now checks the polynomial division by checking the above equation at the random point <span class="math">\\tau</span>. The verifier uses the bilinear map to check <span class="math">e(C\\cdot g^{-v},g)=e(\\pi,g^{\\tau}\\cdot g^{-z})</span>. Now, the way typical PIOPs (underlying SNARKs like Marlin/Plonk) encode the witness is by interpolating a polynomial <span class="math">f</span> such that the witness vector agrees with <span class="math">f</span> on a “nice domain”. That is, let <span class="math">w\\in\\mathbb{F}^{n}</span> be the witness vector, then the prover first constructs a <em>witness-carrying polynomial</em> <span class="math">f(Y)=\\sum_{i\\in[n]}w_{i}L_{i}(Y)</span> where the nice domain is typically the multiplicative subgroup generated by primitive root of unity, <span class="math">\\mathbf{H}</span>, and <span class="math">L_{i}(Y)</span> are the Lagrange bases for <span class="math">\\mathbf{H}</span>. The univariate polynomial <span class="math">f(Y)</span> is then committed to using a PCS like KZG where the commitment <span class="math">C_{f}=g^{\\sum_{i\\in[n]}a_{i}\\tau^{\\prime}}=\\prod_{i}g_{i}^{a_{i}}</span> where <span class="math">(a_{1},\\ldots,a_{n})</span> is the coefficient vector of <span class="math">f</span>. Our starting point is to have the commitment <span class="math">C_{f}</span> be a commitment <em>directly</em> to the evaluation vector <span class="math">w</span>; that is, <span class="math">C_{f}=\\prod_{i}g_{i}^{w_{i}}</span>. This is accomplished by having the setup produce <span class="math">\\textsf{srs}=\\{g_{i}=g^{\\alpha_{i}}\\}</span> where <span class="math">\\alpha=\\{\\alpha_{1},\\ldots,\\alpha_{n}\\}</span> is related to the secret point of evaluation <span class="math">\\tau</span> via the FFT matrix. The commitment is still evaluation of the polynomial at a secret point (just like in KZG). The prover uses the witness vector <span class="math">w</span> and commits to it as <span class="math">g^{f(\\tau)}</span> where <span class="math">f</span> agrees with <span class="math">w</span> without having to explicitly obtain the coefficients of <span class="math">f</span>. In order to make the srs updatable, we let the commitment be <span class="math">g^{f(\\tau)}</span> for <span class="math">\\tau=r^{2^{n}}</span>, for a uniformly random <span class="math">r\\in\\mathbb{F}</span>, and <span class="math">2^{n}</span> is the degree of <span class="math">f</span>. The downside now is that the srs is not universal since it depends on the degree of the polynomial being committed to. In order to achieve universality, we let the commitment be <span class="math">g^{f(\\tau)}</span> for <span class="math">\\tau=r^{2^{n-d}}</span> where <span class="math">2^{n}</span> is the bound on the universal srs and <span class="math">2^{d}</span> is the degree bound claimed by the prover. The idea behind the evaluation protocol for the PCS remains the same as in KZG: commit to the quotient polynomial and check polynomial division at <span class="math">\\tau</span>. We show that this scheme satisfies extractability in the AGM assuming N-DLOG. This SRS is also <em>updatable</em> which is more desirable than a fully trusted setup.</p>

    <p class="text-gray-300">As a stand-alone univariate commitment scheme, the prover in KZG-FFT is not required to perform expensive FFT operations in order to obtain the coefficient representation since this work has already been done apriori by setup. This improves prover performance compared to KZG.</p>

    <p class="text-gray-300">Multilinear scheme KZG-FOURIER. Our new multilinear PCS relies on a new linear map and polynomial decomposition. The linear isomorphism <span class="math">\\mathcal{U}_{n}:\\mathbb{F}_{\\leq 1}[X_{0},\\ldots,X_{n-1}]\\to\\mathbb{F}_{&lt;N}[Y]</span> maps the Fourier basis of the space of multilinear polynomials in <span class="math">n</span> variables to the FFT basis of the space of univariate</p>

    <p class="text-gray-300">polynomials of degree at most <span class="math">2^{n}</span>. The map is given by <span class="math">\\prod_{j=0}^{n-1}X_{j}\\cdot i_{j}+(1-X_{j})\\cdot(1-i_{j})\\to L_{i}(Y)</span>, for <span class="math">i\\in[0,2^{n}]</span>, where <span class="math">i_{j}\\in\\{0,1\\}</span> is the <span class="math">j</span>th component of the bit decomposition of <span class="math">i</span>, and <span class="math">L_{i}(Y)</span> are the Lagrange bases over <span class="math">\\mathbf{H}</span>. The commit algorithm interprets the witness vector as evaluations of a multilinear polynomial <span class="math">f</span> over the Fourier basis, and equivalently as the evaluations of a univariate polynomial <span class="math">f^{\\prime}</span> over the FFT domain of size <span class="math">2^{n}</span>. Committing to <span class="math">f</span> is done by committing to <span class="math">f^{\\prime}</span> using KZG-FFT. The evaluation protocol relies on polynomial decomposition that has been used in prior works as well <em>[x20]</em>. For an <span class="math">n</span>-variate polynomial <span class="math">f</span>, and <span class="math">\\mathbf{z}\\in\\mathbb{F}^{n}</span>, there exist polynomials <span class="math">q_{i}(\\mathbf{X})</span> such that, <span class="math">f(\\mathbf{X})-f(\\mathbf{z})=\\sum_{i\\in[n]}(X_{i}-z_{i})q_{i}(\\mathbf{X})</span>. The verifier in the evaluation protocol checks this polynomial identity underneath the linear map <span class="math">\\mathcal{U}_{n}</span>. That is, if the evaluation claim is <span class="math">f(\\mathbf{z})=y</span>, then the protocol has the verifier check that <span class="math">\\mathcal{U}_{n}(f(\\mathbf{X}))-\\mathcal{U}_{n}(y)=\\sum_{i\\in[n]}\\left(\\mathcal{U}_{n}(X_{i}\\cdot q_{i})-\\mathcal{U}_{n}(z_{i}\\cdot q_{i})\\right)</span>. We now note that the above check is a univariate identity which is checked at a randomly chosen point. Towards this, the prover aids the verifier by sending commitments and openings of certain univariate polynomials using KZG-FFT. For soundness, we use several properties of the linear map in order to enable checking the above equation, and finally rely on Schwartz-Zippel.</p>

    <p class="text-gray-300">Transparent DualPCS. We construct another DualPCS candidate with transparent setup, dory-link, that uses the Dory proof system <em>[x14]</em>. The commit algorithm works as follows: given a witness vector <span class="math">w\\in\\mathbb{F}^{n}</span>, the AFG commitment scheme is used to commit to two vectors <span class="math">\\mathbf{a}\\in\\mathbb{G}^{n}</span>, <span class="math">\\mathbf{f}\\in\\mathbb{G}^{n}</span> where <span class="math">\\mathbf{a}=(g_{1}^{w_{1}},\\ldots,g_{n}^{w_{n}})</span> and <span class="math">\\mathbf{f}=(g_{1}^{f_{1}},\\ldots,g_{n}^{f_{n}})</span>, <span class="math">(f_{1},\\ldots f_{n})</span> is the coefficient vector of <span class="math">f\\in\\mathbb{F}[Y]</span> that agrees with <span class="math">\\mathbf{a}</span> over domain <span class="math">\\mathbf{H}</span>. The evaluation protocols are simply Dory proofs of evaluation, since the commitments are already amenable to Dory. The linking proof needs to establish the linear relation between the representations <span class="math">\\mathbf{a},\\mathbf{f}</span> of the same underlying witness <span class="math">w</span>. This is done by preprocessing the FFT matrix that describes the linear relation and constructing a SNARK for the linking proof.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.4 Related Work</h3>

    <p class="text-gray-300">CP-SNARKs. Recent works like Lunar <em>[CFF^{+}21]</em> and Eclipse <em>[ABC^{+}22]</em> present general compilers from information-theoretic objects to CP-SNARKs with a universal and updatable SRS. While the underlying information-theoretic objects can be compiled using any PCS, Eclipse assumes Pedersen vector commitments and Lunar assumes KZG commitments for the linking gadgets of the CP-SNARKs. Thus they are limited as a framework to only those proof systems that use compatible commitment schemes. These compilers can be extended to obtain commit-and-prove lookups, but will be limited to lookup arguments like Caulk <em>[ZBK^{+}22]</em>, Baloo <em>[ZGK^{+}22]</em>, CQ <em>[x10]</em> that are KZG-based.</p>

    <p class="text-gray-300">PCS. Our multilinear PCS KZG-FOURIER is reminiscent of the techniques in <em>[x4]</em> and <em>[x16]</em> in that the central idea is to leverage a linear homomorphism from the <span class="math">\\mathbb{F}</span>-linear space of multilinear polynomials to the <span class="math">\\mathbb{F}</span>-linear space of univariate polynomials. The difference is the linear homomorphism itself: in <em>[x16]</em>, the Fourier basis of the multilinear polynomial is mapped to the monomial basis of the univariate polynomial. In <em>[x4]</em>, the monomial basis of the multilinear polynomial is mapped to the monomial basis of the univariate polynomial. In our scheme, the Fourier basis of the multilinear is mapped to the Fourier basis of the univariate polynomial. As a consequence, our multilinear PCS renders itself to be efficiently linked to our KZG-FFT scheme.</p>

    <p class="text-gray-300">Dual PCS. Recent concurrent work <em>[x11]</em> constructs a compiler that, given any univariate-based lookup argument, converts it into a lookup argument compatible with MLE-based SNARKs. The compiler could be applied to univariate and multilinear PCS combinations (like KZG+Gemini, PST+Zeromorph) to yield DualPCS candidates. Such schemes require an additional linking proof; and this incurs prover and verifier costs for a sum-check protocol, and opening multilinear and the univariate polynomials at the end of the sum-check. The verifier complexity for the sum-check is logarithmic whereas additional evaluation proofs for KZG, Gemini, PST, and Zeromorph increases the number of pairings performed by the verifier. This is in contrast to our KZG-FFT-FOURIER scheme where there is no additional linking proof. We discuss the techniques of <em>[x11]</em> in relation to our work in Appendix A.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Notations and Facts. <span class="math">\\mathbb{F}</span> denotes a prime field of order <span class="math">p</span>, and <span class="math">\\mathbb{N}</span> denotes the set of natural numbers. We denote by <span class="math">\\lambda</span> a security parameter, by <span class="math">\\mathsf{negl}</span> a negligible function. For any integer <span class="math">c&gt;0</span>, there exists <span class="math">n\\in\\mathbb{N}</span>, such that <span class="math">\\forall\\ x&gt;n</span>, <span class="math">\\mathsf{negl}(x)\\leq 1/n^{c}</span>, and if a function is not negligible then we call it non-negligible.</p>

    <p class="text-gray-300">We denote vectors by boldface letters, and inner product between <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span> by <span class="math">\\langle\\mathbf{a},\\mathbf{b}\\rangle</span>. If <span class="math">\\mathbf{a}\\in\\mathbb{F}^{N}</span>, then <span class="math">a_{i}</span> denotes the <span class="math">i</span>-th component of the vector for <span class="math">i\\in[0,N-1]</span>. We use <span class="math">r\\leftarrow_{R}\\mathbb{F}</span> to denote <span class="math">r</span> sampled independently and uniformly at random from <span class="math">\\mathbb{F}</span>. Primitive root of unity of order <span class="math">N</span> is denoted by <span class="math">\\omega_{N}</span>. We state a well-known fact regarding primitive roots of unity next.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Fact 1</h6>

    <p class="text-gray-300">For <span class="math">N\\in\\mathbb{N}</span>, if <span class="math">N</span> is divisible by <span class="math">2</span> then <span class="math">\\omega_{N/2}=\\omega_{N}^{2}</span>. Further, <span class="math">\\omega_{2}</span>, is unique and is equal to <span class="math">-1</span>.</p>

    <p class="text-gray-300">The <span class="math">N\\times N</span> Fast Fourier Transform (FFT) matrix whose <span class="math">(i,j)</span>-th entry is <span class="math">\\omega_{N}^{i\\cdot j}</span> for <span class="math">i,j\\in[0,N-1]</span> is denoted <span class="math">M_{\\omega_{N}}</span>. We note down a well-known fact regarding the FFT matrices.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Fact 2</h6>

    <p class="text-gray-300">For <span class="math">N\\in\\mathbb{N}</span>, <span class="math">M_{\\omega_{N}}^{T}=M_{\\omega_{N}}</span>, and further if <span class="math">N</span> is a power of <span class="math">2</span> then <span class="math">M_{\\omega_{N}}^{-1}=\\frac{1}{N}M_{\\omega_{N}^{-1}}</span>.</p>

    <p class="text-gray-300">We use <span class="math">\\mathbf{H}_{N}</span> to denote the set <span class="math">\\{\\omega_{N}^{0},\\omega_{N}^{1},\\dots,\\,\\omega_{N}^{N-1}\\}</span>. We refer to <span class="math">\\mathbf{H}_{N}</span> as the FFT domain of size <span class="math">N</span>. Similarly, let <span class="math">p^{\\prime}\\in\\mathbb{F}</span> be such that <span class="math">p,p^{\\prime}</span> are coprime integers. Then we refer to the set <span class="math">\\{p^{\\prime}\\cdot\\omega_{N}^{0},p^{\\prime}\\cdot\\omega_{N}^{1},\\dots,</span> <span class="math">p^{\\prime}\\cdot\\omega_{N}^{N-1}\\}</span> as the offset of the FFT domain of size <span class="math">N</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{&lt;N}[Y]</span> denotes the <span class="math">\\mathbb{F}</span>-linear space of univariate polynomials with degree at most <span class="math">N</span>, and <span class="math">\\{Y^{0},\\dots,Y^{N-1}\\}</span> is its standard basis. Let <span class="math">f\\in\\mathbb{F}_{&lt;N}[Y]</span>. Then <span class="math">f(\\mathbf{H}_{N})\\in\\mathbb{F}^{N}</span> denotes the evaluation vector of <span class="math">f(Y)</span> over <span class="math">\\mathbf{H}_{N}</span>, that is the <span class="math">i</span>-th coordinate of <span class="math">f(\\mathbf{H}_{N})</span>, denoted <span class="math">f(\\mathbf{H}_{N})_{i}=f(\\omega_{N}^{i})</span> for <span class="math">i\\in[0,N-1]</span>. If <span class="math">N</span> is clear from the context then we drop <span class="math">N</span> from the subscript and simply write <span class="math">f(\\mathbf{H})</span>. If <span class="math">\\mathbf{a}\\in\\mathbb{F}^{N}</span> and <span class="math">f\\in\\mathbb{F}_{&lt;N}[Y]</span> satisfies <span class="math">\\mathbf{a}=f(\\mathbf{H})</span> then we say <span class="math">\\mathbf{a}</span> agrees with <span class="math">f</span> over the FFT domain of size <span class="math">N</span>. Let <span class="math">\\mathbf{Y}=(Y^{0},\\dots,Y^{N-1})</span> be an <span class="math">N</span> length vector constituting of the standard basis of <span class="math">\\mathbb{F}_{&lt;N}[Y]</span>, and <span class="math">\\mathbf{U}^{(n)}=\\frac{1}{N}\\cdot M_{\\omega_{N}^{-1}}\\cdot\\mathbf{Y}</span>, where <span class="math">n=\\log N</span>. Since <span class="math">M_{\\omega_{N}^{-1}}</span> is invertible, <span class="math">\\{U_{i}^{(n)}\\}_{i\\in[0,N-1]}</span> is an <span class="math">\\mathbb{F}</span>-linear basis of <span class="math">\\mathbb{F}_{&lt;N}[Y]</span>, where <span class="math">U_{i}</span> is the <span class="math">i</span>-th component of <span class="math">\\mathbf{U}^{(n)}</span>. We refer to <span class="math">\\mathbf{U}^{(n)}</span> as the FFT basis of <span class="math">\\mathbb{F}_{&lt;N}[Y]</span>. It is easy to see that the FFT basis is equal to the Lagrange basis with points from <span class="math">\\mathbf{H}_{N}</span>.</p>

    <p class="text-gray-300">Similarly, <span class="math">\\mathbb{F}_{\\leq 1}[X_{0},\\dots,X_{n-1}]</span> denotes the <span class="math">\\mathbb{F}</span>-linear space of multilinear polynomials in <span class="math">n</span> variables, and <span class="math">\\{L_{0}^{(n)},\\dots,L_{2^{n}-1}^{(n)}\\}</span> be the standard Fourier basis of <span class="math">\\mathbb{F}_{\\leq 1}[X_{0},\\dots,X_{n-1}]</span>. Specifically, if <span class="math">i\\in[0,2^{n}-1]</span>, and <span class="math">i_{j}\\in\\{0,1\\}</span> for <span class="math">j\\in[0,n-1]</span> is the <span class="math">j</span>-th least significant bit of <span class="math">i</span> (when <span class="math">i</span> is viewed as an <span class="math">n</span> bit number) then</p>

    <p class="text-gray-300"><span class="math">L_{i}^{(n)}=\\prod_{j=0}^{n-1}((1-X_{j})\\cdot(1-i_{j})+X_{j}\\cdot i_{j})</span></p>

    <p class="text-gray-300">Let <span class="math">f\\in\\mathbb{F}_{\\leq 1}[X_{0},\\dots,X_{n-1}]</span>, and <span class="math">f(X_{0},\\dots,X_{n-1})=\\sum_{i\\in[0,2^{n}-1]}f_{L_{i}^{(n)}}\\cdot L_{i}^{(n)}(X_{0},\\dots,X_{n-1})</span>. Then <span class="math">\\{f_{L_{i}^{(n)}}\\in\\mathbb{F}\\}_{i\\in[0,2^{n-1}]}</span> are referred to as the <span class="math">2^{n}</span> Fourier coefficients of <span class="math">f</span>. Let <span class="math">\\mathbf{a}\\in\\mathbb{F}^{2^{n}}</span>. Then <span class="math">\\tilde{a}\\in\\mathbb{F}[X_{0},\\dots,X_{n-1}]</span> defined as <span class="math">\\tilde{a}(X_{0},\\dots,X_{n-1})=\\sum_{i\\in[0,2^{n}-1]}a_{i}\\cdot L_{i}(X_{0},\\dots,X_{n-1})</span> denotes the Multilinear Extension (MLE) of <span class="math">\\mathbf{a}</span>. It is easy to see that <span class="math">\\tilde{a}(i_{0},\\dots,i_{n-1})=a_{i}</span>, where again <span class="math">i_{j}\\in\\{0,1\\}</span> for <span class="math">j\\in[0,n-1]</span> is the <span class="math">j</span>-th least significant bit of <span class="math">i</span>. We note the following well-known fact regarding multilinear polynomials (see <em>[x21]</em> for a proof).</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Fact 3</h6>

    <p class="text-gray-300">Let <span class="math">f\\in\\mathbb{F}_{\\leq 1}[X_{0},\\dots,X_{n-1}]</span> and <span class="math">x_{0},\\dots,x_{n-1}\\in\\mathbb{F}</span>. Then <span class="math">f(x_{0},\\dots,x_{n-1})=y</span> if and only if there exists <span class="math">q_{k}\\in\\mathbb{F}_{\\leq 1}[X_{0},\\dots,X_{k-1}]</span> for <span class="math">k\\in[1,n-1]</span>, and <span class="math">q_{0}\\in\\mathbb{F}</span> such that</p>

    <p class="text-gray-300"><span class="math">f(X_{0},\\dots,X_{n-1})-y=\\sum_{k=0}^{n-1}(X_{k}-x_{k})\\cdot q_{k}(X_{0},\\dots,X_{k-1})</span></p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}</span> be a group of order <span class="math">p</span>. For <span class="math">\\mathbf{g}=(g_{1},\\dots,g_{n})\\in\\mathbb{G}^{n}</span> and <span class="math">\\mathbf{x}=(x_{1},\\dots,x_{n})\\in\\mathbb{Z}_{p}^{n}</span>, the multi-exponentiation <span class="math">\\mathbf{g^{x}}</span> is defined by <span class="math">\\mathbf{g^{x}}=g_{1}^{x_{1}}\\cdots g_{n}^{x_{n}}</span>.</p>

    <p class="text-gray-300">Bilinear Group. A bilinear group is denoted by the tuple <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g_{1},g_{2})</span>, where <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> are groups of prime order <span class="math">p</span>, <span class="math">g_{1}</span> and <span class="math">g_{2}</span> are generators of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>, and <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is an efficiently computable non-degenerate bilinear map. We denote by <span class="math">\\mathcal{G}</span> a bilinear group generator that outputs these parameters: <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g_{1},g_{2})\\leftarrow_{R}\\mathcal{G}(1^{\\lambda})</span> where <span class="math">p</span> is superpolynomial in <span class="math">\\lambda</span>. Let <span class="math">\\mathbf{h}\\in\\mathbb{G}_{1}^{N}</span>, <span class="math">\\mathbf{q}\\in\\mathbb{G}_{2}^{N}</span>. Then we use the <span class="math">\\langle\\mathbf{h},\\mathbf{q}\\rangle</span> to denote the inner-pairing product <span class="math">\\prod_{i\\in[0,N-1]}e(h_{i},q_{i})</span>. We remark here that notation <span class="math">\\langle\\cdot,\\cdot\\rangle</span> is overloaded to mean both inner products over fields, and inner-pairing products between vectors from <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>, and is implicit from context.</p>

    <p class="text-gray-300">Algebraic Group Model. The Algebraic Group Model (AGM) introduced in <em>[x14]</em> is an idealized model. An adversary <span class="math">\\mathcal{A}</span> is said to be algebraic if every group element output by <span class="math">\\mathcal{A}</span> is accompanied by its representation with respect to all the groups elements <span class="math">\\mathcal{A}</span> has seen so far. Let <span class="math">y_{1},\\dots,y_{k}</span> be all the group</p>

    <p class="text-gray-300">elements previously input and output by <span class="math">\\mathcal{A}</span>. Then, every group element <span class="math">y</span> output by <span class="math">\\mathcal{A}</span>, is accompanied by its representation <span class="math">(x_{1},\\ldots,x_{k})</span> such that <span class="math">y=\\prod_{i=1}^{k}y_{i}^{x_{i}}</span>.</p>

    <p class="text-gray-300">SRS model. We describe our constructions as public-coin interactive protocols in the structured reference string (SRS) model where where both the parties have access to a SRS. The SRS is universal and updatable, where the SRS can be used to prove statements about any computation, as opposed to a circuit-dependent setup required in preprocessing based SNARKs. This universal SRS is, in addition, updatable, meaning parties can continuously contribute to the randomness of the SRS, and an SRS is trusted as long as at least one of the updates was honest.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2.1 Assumptions</h2>

    <p class="text-gray-300"><strong>Definition 1 (DDH Assumption)</strong> For a group <span class="math">\\mathbb{G}</span>, the decisional Diffie-Hellman (DDH) assumption holds for <span class="math">\\mathbb{G}</span> if for all PPT <span class="math">\\mathcal{A}</span>, the following probability is <span class="math">1/2 + \\mathrm{negl}(\\lambda)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( \\begin{array}{c c} b ^ {\\prime} = b &amp;amp; x, y, z \\leftarrow_ {R} \\mathbb {F}, b \\leftarrow_ {R} \\{0, 1 \\} \\\\ b ^ {\\prime} = \\mathcal {A} (\\mathsf {p p}) : &amp;amp; z ^ {\\prime} = x y \\text{ if } b = 0, z ^ {\\prime} = z \\text{ if } b = 1 \\\\ &amp;amp; \\mathsf {p p} = (g, g ^ {x}, g ^ {y}, g ^ {z ^ {\\prime}}) \\end{array} \\right)</span></div>

    <p class="text-gray-300"><strong>Definition 2 (SXDH Assumption)</strong> For <span class="math">(q,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,G,H)\\gets_R\\mathcal{G}(1^\\lambda)</span>, the Symmetric External Diffie-Hellman (SXDH) assumption states that the decisional Diffie-Hellman (DDH) assumption holds for both <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span>.</p>

    <p class="text-gray-300"><strong>Definition 3 (N-DLOG Assumption)</strong> The N-DLOG assumption with respect to <span class="math">\\mathcal{G}</span> holds if for all <span class="math">\\lambda</span>, for all PPT <span class="math">\\mathcal{A}</span>, the following probability is <span class="math">\\mathrm{negl}(\\lambda)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( \\begin{array}{c c} \\tau = \\tau^ {\\prime} &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\tau \\leftarrow_ {R} \\mathbb {F} \\\\ \\tau^ {\\prime} \\leftarrow \\mathcal {A} (\\mathsf {p p}, \\mathbf {v}) ^ {}: &amp;amp; \\mathbf {v} := (g _ {1} ^ {\\tau}, g _ {1} ^ {\\tau^ {2}}, \\ldots , g _ {1} ^ {\\tau^ {N}}, g _ {2} ^ {\\tau}, g _ {2} ^ {\\tau^ {2}}, \\ldots , g _ {2} ^ {\\tau^ {N}}) \\end{array} \\right)</span></div>

    <h2 id="sec-12" class="text-2xl font-bold">2.2 Commitment Schemes</h2>

    <p class="text-gray-300"><strong>AFG Commitment Scheme [AFG⁺10]</strong> The pairing based commitment AFG is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,q,e,g_1,g_1)\\gets \\mathsf{AFG.setup}(1^{\\lambda})</span>: Outputs <span class="math">\\mathbb{G}_1,\\mathbb{G}_2</span>, and <span class="math">\\mathbb{G}_T</span> of order <span class="math">p</span> with <span class="math">g_{1}</span> and <span class="math">g_{2}</span> being generators for <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> and <span class="math">e</span> is the bilinear map.</li>

      <li><span class="math">\\mathsf{ck} = (w_r, w_0, w_1, \\ldots, w_{N-1}) \\gets \\mathsf{AFG.KeyGen}(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, e, g_1, g_2, N)</span>: Outputs the commitment key ck. Here <span class="math">N</span> is the number of group elements to be committed.</li>

      <li><span class="math">c = \\mathsf{AFG.com_{ck}}(\\mathbf{m}, r) = e(w_r, r) \\prod_{i=0}^{N-1} e(w_i, m_i)</span>: Outputs the commitment of message <span class="math">\\mathbf{m}</span> where <span class="math">\\mathbf{m} = (m_0, \\ldots, m_{N-1})</span>.</li>

    </ul>

    <p class="text-gray-300">The AFG commitment scheme is perfectly hiding and binding under the SXDH assumption (see Definition 2).</p>

    <h2 id="sec-13" class="text-2xl font-bold">2.3 Interactive Arguments</h2>

    <p class="text-gray-300">We consider interactive arguments for relations, where a prover <span class="math">P</span> convinces the verifier that it knows a witness <span class="math">w</span> such that for a public statement <span class="math">x, (x, w) \\in \\mathcal{R}</span>. Given a pair of PPT interactive algorithms <span class="math">P, V</span>, we denote by <span class="math">\\langle P, V \\rangle(x; w)</span>, the output of <span class="math">V</span> on interaction with <span class="math">P</span>. Here, <span class="math">w</span> is <span class="math">P</span>'s private input and <span class="math">x</span> is a common input. Let <span class="math">\\mathcal{R} = \\{(x, w)\\}</span>, be a relation and <span class="math">\\mathcal{L}</span> be the corresponding NP language.</p>

    <p class="text-gray-300"><strong>Definition 4 (Succinct Argument of knowledge)</strong> An interactive argument of knowledge (AoK) for a relation <span class="math">\\mathcal{R}</span> consists of a PPT algorithm <span class="math">\\mathrm{setup}(1^{\\lambda})</span> that takes a security parameter <span class="math">\\lambda</span> and outputs public parameters <span class="math">\\mathrm{srs}</span>, and a pair of PPT interactive algorithms <span class="math">\\langle P, V \\rangle</span>. The triple <span class="math">(\\mathrm{setup}, P, V)</span> satisfy the following properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all <span class="math">\\lambda \\in \\mathbb{N}</span>, <span class="math">(x, w) \\in \\mathcal{R}</span>,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\langle P, V \\rangle (\\mathsf {s r s}, x; w) = 1: \\mathsf {s r s} \\leftarrow \\mathsf {s e t u p} (1 ^ {\\lambda})\\right) = 1.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness⁴. An argument system <span class="math">(P, V)</span> for a relation <span class="math">\\mathcal{R}</span> is knowledge sound if for any PPT <span class="math">\\tilde{P} = (\\tilde{P}_1, \\tilde{P}_2)</span>, there exists an expected polynomial time extractor <span class="math">\\mathcal{E}</span> such that the following probability is <span class="math">\\mathrm{negl}(\\lambda)</span>.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left( \\begin{array}{c c} (x, w) \\notin \\mathcal{R} \\wedge &amp;amp; \\mathsf{srs} \\leftarrow \\mathsf{setup}(1^{\\lambda}) \\\\ \\langle \\tilde{P}_2, V \\rangle (\\mathsf{srs}, x; \\mathsf{st}) = 1 &amp;amp; : (x, \\mathsf{st}) \\leftarrow \\tilde{P}_1(1^{\\lambda}, \\mathsf{srs}) \\\\ &amp;amp; w \\leftarrow \\mathcal{E}^{\\tilde{P}_2}(\\mathsf{srs}, x) \\end{array} \\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness. An argument system is succinct if the communication complexity between prover and verifier is sublinear in the size of the statement.</li>

    </ol>

    <p class="text-gray-300">We do not focus on zero-knowledge in this work; we believe it is easily achievable via minor adaptations applying standard techniques to our constructions.</p>

    <p class="text-gray-300">Fiat-Shamir transform. The protocols in this work are public coin interactive arguments where the verifier's messages are uniformly random strings. Public coin protocols can heuristically be compiled into non-interactive arguments by applying the Fiat-Shamir [FS87] transform (FS) in the Random Oracle Model (ROM).</p>

    <h2 id="sec-14" class="text-2xl font-bold">2.4 Polynomial Commitment Scheme</h2>

    <p class="text-gray-300">A polynomial commitment scheme (PCS) allows the prover to open evaluations of the committed polynomial succinctly ([KZG10]). A PCS over <span class="math">\\mathbb{F}</span> is a tuple <span class="math">\\mathsf{PC} = (\\mathsf{setup}, \\mathsf{commit}, \\mathsf{open}, \\mathsf{eval})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{setup}(1^{\\lambda}, n, N)</span>. On input security parameter <span class="math">\\lambda</span>, number of variables <span class="math">n</span>, an upper bound <span class="math">N \\in \\mathbb{N}</span> on the number of distinct monomials in <span class="math">n</span> variables, <span class="math">\\mathsf{setup}</span> generates public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">(C, \\tilde{\\mathbf{c}}) \\gets \\mathrm{commit}(\\mathsf{pp}, f, D)</span>. On input the public parameters <span class="math">\\mathsf{pp}</span>, an <span class="math">n</span>-variate polynomial <span class="math">f(X) \\in \\mathbb{F}[X]</span> with total monomials at most <span class="math">D \\leq N</span>, <span class="math">\\mathrm{commit}</span> outputs a commitment to the polynomial <span class="math">C</span>, and additionally an opening hint <span class="math">\\tilde{\\mathbf{c}}</span>.</li>

      <li><span class="math">b \\gets \\mathrm{open}(\\mathsf{pp}, f(X), d, C, \\tilde{\\mathbf{c}})</span>. On input the public parameters <span class="math">\\mathsf{pp}</span>, the commitment <span class="math">C</span> and the opening hint <span class="math">\\tilde{\\mathbf{c}}</span>, a polynomial <span class="math">f(X)</span> with number of monomials <span class="math">D \\leq N</span>, <span class="math">\\mathrm{open}</span> outputs a bit indicating accept or reject.</li>

      <li><span class="math">b \\gets \\mathrm{eval}(\\mathsf{pp}, C, D, \\mathbf{x}, y; f(X))</span>. A public coin interactive protocol <span class="math">\\langle P_{\\mathrm{eval}}, V_{\\mathrm{eval}} \\rangle(\\mathsf{pp}, C, d, \\mathbf{x}, y; f(X))</span> between a PPT prover and a PPT verifier. The parties have as common input public parameters <span class="math">\\mathsf{pp}</span>, commitment <span class="math">C</span>, monomial bound <span class="math">D</span>, evaluation point <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span>, and claimed evaluation <span class="math">y</span>. The prover has, in addition, the opening <span class="math">f</span> of <span class="math">C</span> with number of monomials at most <span class="math">D</span>. At the end of the protocol, the verifier outputs 1 indicating accepting the proof that <span class="math">f(\\mathbf{x}) = y</span>, or outputs 0 indicating rejecting the proof.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme must satisfy completeness, binding and knowledge soundness (KS).</p>

    <p class="text-gray-300"><strong>Definition 5 (Completeness)</strong> For all polynomials <span class="math">f(X) \\in \\mathbb{F}[X]</span> with number of monomials at most <span class="math">D \\leq N</span>, and for all <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left( \\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{setup}(1^{\\lambda}, N) \\\\ b = 1 : (C, \\tilde{\\mathbf{c}}) \\leftarrow \\mathsf{commit}(\\mathsf{pp}, f(\\mathbf{X}), D) \\\\ y \\leftarrow f(\\mathbf{x}) \\\\ b \\leftarrow \\mathsf{eval}(\\mathsf{pp}, C, D, \\mathbf{x}, y; f(X)) \\end{array} \\right) = 1.</span></div>

    <p class="text-gray-300"><strong>Definition 6 (Binding)</strong> A polynomial commitment scheme <span class="math">\\mathsf{PC}</span> is binding if for all PPT <span class="math">\\mathcal{A}</span>, the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left( \\begin{array}{c c} \\mathsf{open}(\\mathsf{pp}, f_0, D, C, \\tilde{\\mathbf{c}}_0) = 1 \\wedge &amp;amp; \\mathsf{pp} \\leftarrow \\mathsf{setup}(1^{\\lambda}, N) \\\\ \\mathsf{open}(\\mathsf{pp}, f_1, D, C, \\tilde{\\mathbf{c}}_1) = 1 \\wedge &amp;amp; : (C, f_0, f_1, \\tilde{\\mathbf{c}}_0, \\tilde{\\mathbf{c}}_1, D) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\end{array} \\right).</span></div>

    <p class="text-gray-300">⁴ We define KS without considering auxiliary inputs, for simplicity. For a stronger definition, the adversary and the extractor additionally receive an auxiliary input <span class="math">\\mathsf{aux}</span> sampled from a distribution <span class="math">\\mathcal{Z}(1^{\\lambda}, \\mathsf{srs})</span>. KS holds as long as <span class="math">\\mathcal{Z}</span> belongs to a certain class, called “benign” distributions.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 7 (Knowledge soundness)</h6>

    <p class="text-gray-300">eval is an AoK for the relation <span class="math">\\mathcal{R}_{\\text{eval}}</span> defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\text{eval}}=\\{((\\mathsf{pp},C,\\mathbf{x}\\leftarrow_{R}\\mathbb{F}^{n},\\;y\\in\\mathbb{F});\\;(f(X),\\mathbf{\\tilde{c}})):</span> <span class="math">(\\mathsf{open}(\\mathsf{pp},f,D,C,\\mathbf{\\tilde{c}})=1)\\wedge y=f(\\mathbf{x})\\}</span></p>

    <p class="text-gray-300">Though in general, the eval protocol can be run on points <span class="math">\\mathbf{x}</span> chosen by the verifier, in applications to SNARKs, these are uniformly random. This is because when a PCS is used to compile a <em>public-coin</em> argument, the verifier samples the evaluation points uniformly at random. Therefore, we define knowledge soundness for random <span class="math">\\mathbf{x}</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 8 (Succinctness)</h6>

    <p class="text-gray-300">We require the commitments and the evaluation proofs to be of size <span class="math">\\mathsf{poly}(\\lambda)\\cdot\\log(D)</span> where <span class="math">\\pi</span> is the transcript obtained by applying FS to eval. Additionally, the scheme is <em>verifier succinct</em> if eval runs in time <span class="math">\\mathsf{poly}(\\lambda)\\cdot\\log(D)</span> for the verifier. The prover is required to run in time <span class="math">\\tilde{O}(D)</span>.</p>

    <p class="text-gray-300">For our univariate scheme, we achieve a strong notion of succinctness: the commitment and evaluation proofs are of size independent of the degree of the polynomial.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3 Univariate Polynomial Commitment Scheme</h2>

    <p class="text-gray-300">In this section, we introduce a variant of the KZG commitment scheme known as KZG-FFT. This variant commits directly to the evaluations of a polynomial over the FFT domain of an appropriate size, as opposed to using the coefficients of the corresponding polynomial. In many proof systems, the coefficients of the underlying univariate polynomial are derived through interpolation from a witness vector, which serves as the evaluations of the desired polynomial. By committing directly using these evaluations or witness values, the prover can circumvent the costly FFT operation. Moreover, employing multi-scalar multi-exponentiation (MSME) over the witness vector allows us to leverage the low bit representation of the witness values, resulting in computational advantages. It’s worth noting that, in practice, witnesses typically possess low bit complexity despite being represented as elements of large prime fields (see, for instance, <em>[x20]</em>, <em>[x1]</em>). In Section 3.1, we state the algorithm to generate the setup for KZG-FFT, and in Section 3.2 we state the details of the polynomial commitment scheme.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1 Setup Generation</h3>

    <p class="text-gray-300">Algorithm 1 KZG-FFT.setup(<span class="math">1^{\\lambda}</span>): Setup Generation for KZG-FFT Input: <span class="math">\\{1^{\\lambda},N\\}</span> Output: <span class="math">\\{\\mathsf{srs}=(\\mathsf{srs}_{\\mathcal{P}},\\mathsf{srs}_{\\mathcal{V}}),\\pi\\}</span> 1: Sample <span class="math">r\\in_{R}\\mathbb{F}</span>, uniformly at random. 2: Let <span class="math">\\alpha_{i}=N^{-1}\\cdot\\prod_{j\\in[0,n-1]}(1+(\\omega_{N}^{-i}\\cdot r)^{2^{j}})</span> for <span class="math">i\\in[0,N-1]</span>, and <span class="math">n=\\log N</span>. 3: Compute <span class="math">\\mathsf{srs}_{\\mathcal{P}}=\\{h_{1,i}^{(n)}=g_{1}^{\\alpha_{i}}\\in\\mathbb{G}_{1}\\mid i\\in[0,N-1]\\}</span>, <span class="math">\\mathsf{srs}_{\\mathcal{V}}=\\{h_{2,j}=g_{2}^{r^{2^{j}}}\\in\\mathbb{G}_{2}\\mid j\\in[0,n]\\}</span>. 4: Let <span class="math">\\pi=(g_{1}^{\\tau},g_{2}^{\\tau})</span>. 5: Output <span class="math">\\{\\mathsf{srs}=(\\mathsf{srs}_{\\mathcal{P}},\\mathsf{srs}_{\\mathcal{V}}),\\pi\\}</span>.</p>

    <p class="text-gray-300">We state the algorithm to generate the structured reference string (<span class="math">\\mathsf{srs}</span>) in this section. We assume <span class="math">N</span> is a power of <span class="math">2</span>, and <span class="math">\\log N=n</span>. Let <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g_{1},g_{2})\\leftarrow_{R}\\mathcal{G}(1^{\\lambda})</span> be a bilinear group. The <span class="math">\\mathsf{srs}</span> has two disjoint parts <span class="math">(\\mathsf{srs}_{\\mathcal{P}},\\mathsf{srs}_{\\mathcal{V}})</span>: <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span> is used by the prover and <span class="math">\\mathsf{srs}_{\\mathcal{V}}</span> is used by the verifier. The setup algorithm, stated in Algorithm 1 takes as input the security parameter <span class="math">\\lambda</span> and the degree bound <span class="math">N</span>, and outputs <span class="math">\\mathsf{srs}</span> and a proof <span class="math">\\pi</span>. The proof <span class="math">\\pi</span> attests to the correctness of the generated <span class="math">\\mathsf{srs}</span>. We show in Appendix C.1, how the <span class="math">\\mathsf{srs}</span> can be verified using <span class="math">\\pi</span>, and that the setup generated by KZG-FFT.setup is updatable as defined in <em>[x16]</em>. Let <span class="math">r</span> be as sampled at Step 1, and <span class="math">\\alpha_{i}</span> be as defined at Step 2 of Algorithm 1. Let <span class="math">\\alpha,\\mathbf{r}\\in\\mathbb{F}^{N}</span> be vectors such that <span class="math">\\alpha_{i}</span> and <span class="math">r^{i}</span> are the <span class="math">i</span>-th component of <span class="math">\\alpha</span> and <span class="math">\\mathbf{r}</span> respectively for <span class="math">i\\in[0,N-1]</span>. The following claim shows that <span class="math">\\alpha</span> is linearly related to <span class="math">\\mathbf{r}</span> via the FFT matrix <span class="math">M_{\\omega_{N}^{-1}}</span></p>

    <p class="text-gray-300">Claim 1. Let <span class="math">\\alpha, \\mathbf{r} \\in \\mathbb{F}^N</span> be as defined above. Then <span class="math">\\alpha = \\frac{1}{N} M_{\\omega_N^{-1}} \\cdot \\mathbf{r}</span>.</p>

    <p class="text-gray-300">In Section 3.2, we present the commit algorithm for KZG-FFT, and as part of completeness in Lemma 1 argue the structure of the commitment in <span class="math">\\mathbb{G}_1</span>. The proof of the above claim is similar to the proof of Claim 2.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3.2 Protocol</h2>

    <p class="text-gray-300"><strong>Protocol 1: KZG-FFT polynomial commitment scheme</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\mathsf{srs},\\pi \\} \\leftarrow_R</span> KZG-FFT.setup<span class="math">(1^{\\lambda},N)</span>.</li>

      <li><span class="math">C_f \\gets</span> KZG-FFT.commit(<span class="math">\\mathsf{srs}_{\\mathcal{P}}, D, f(\\mathbf{H}_D)</span>), where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C_f = \\prod_{i \\in [0, D - 1]} \\left(h_{1,i}^{(d)}\\right)^{a_i}</span></div>

    <p class="text-gray-300">and <span class="math">\\mathbf{h}^{(d)}\\in \\mathbb{G}_1^D</span> is as defined in Equation 1</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>accept/reject <span class="math">\\leftarrow</span> KZG-FFT.eval(<span class="math">\\mathsf{srs}, C_f, D, u, v; f(\\mathbf{H}_D)</span>), where <span class="math">D \\leq N</span> is a one round public coin interactive protocol <span class="math">\\langle P_{\\mathrm{eval}}, V_{\\mathrm{eval}} \\rangle</span>(<span class="math">\\mathsf{srs}, C_f, D, u, v; f(\\mathbf{H}_D)</span>) between a PPT prover and a PPT verifier.</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">P_{\\mathrm{eval}}</span>: The prover computes the evaluations of <span class="math">q(X)</span> over the FFT domain of size <span class="math">D</span>, where <span class="math">q(X)</span> satisfies <span class="math">f(X) - v = (X - u) \\cdot q(X)</span>. Commits to <span class="math">q(X)</span> (denoted <span class="math">C_q</span>) using <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span>. Sends <span class="math">C_q</span> to <span class="math">V_{\\mathrm{eval}}</span>. (b) <span class="math">V_{\\mathrm{eval}}</span>: Let <span class="math">d = \\log D</span>. Computes <span class="math">C_f \\cdot g_1^{-v} \\in \\mathbb{G}_1</span> and <span class="math">h_{2,n-d} \\cdot g_2^{-u} \\in \\mathbb{G}_2</span>, and accepts if <span class="math">e(C_f \\cdot g_1^{-v}, g_2) = e(C_q, h_{2,n-d} \\cdot g_2^{-u})</span> and rejects otherwise.</p>

    <p class="text-gray-300">The KZG-FFT polynomial commitment scheme is presented in Protocol 1. Let <span class="math">D = 2^d</span>, and <span class="math">f \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>, and <span class="math">\\mathbf{a} \\in \\mathbb{F}^D</span> be such that <span class="math">\\mathbf{a}</span> agrees with <span class="math">f(\\mathbf{H})</span> over the FFT domain of size <span class="math">D</span>. KZG-FFT.setup is presented in Algorithm 1, Section 3.1. The KZG-FFT.commit algorithm takes as input <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span>, the degree bound <span class="math">D</span>, and the evaluation vector <span class="math">\\mathbf{a}</span> of the polynomial <span class="math">f(Y)</span>. To commit to polynomials of degree at most <span class="math">D = 2^d</span> for <span class="math">d \\in [0, n]</span>, the commit algorithm folds the public parameters <span class="math">\\mathsf{srs}_{\\mathcal{P}} = \\{h_{1,i}^{(n)}\\}_{i \\in [0, N-1]}</span> recursively as follows:</p>

    <div class="my-4 text-center"><span class="math-block">h_{1,i}^{(k)} = h_{1,i}^{(k+1)} \\cdot h_{1,i+2^k}^{(k+1)} \\quad \\forall i \\in [0, 2^k - 1] \\tag{1}</span></div>

    <p class="text-gray-300">and outputs <span class="math">C_f = \\prod_{i \\in [0, D-1]} (h_{1,i}^{(d)})^{a_i}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let <span class="math">f</span>, <span class="math">\\mathbf{a}</span>, <span class="math">h_{1,i}^{(d)}</span> for <span class="math">d \\in [1, n]</span> and <span class="math">C_f</span> be as defined above. Then <span class="math">C_f = \\prod_{i \\in [0, D-1]} (h_{1,i}^{(d)})^{a_i} = g_1^{f(r^{2^{n-d}})}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">D = 2^d</span> and <span class="math">f_i</span> be the coefficient of <span class="math">Y^i</span> in <span class="math">f</span>, for <span class="math">i \\in [0, D-1]</span>, and <span class="math">\\mathbf{f} = (f_0, \\ldots, f_{D-1})</span>. Then <span class="math">M_{\\omega_D} \\cdot \\mathbf{f} = f(\\mathbf{H}_D) = \\mathbf{a}</span>, and hence, from Fact 2</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{f} = M_{\\omega_D}^{-1} \\cdot \\mathbf{a} = \\left(\\frac{1}{D} M_{\\omega_D^{-1}}\\right) \\cdot \\mathbf{a} \\tag{2}</span></div>

    <p class="text-gray-300">Let <span class="math">\\alpha^{(\\mathbf{d})}</span> be such that <span class="math">g_1^{\\alpha_i^{(d)}} = h_{1,i}^{(d)}</span> for <span class="math">i \\in [0, D-1]</span>, and <span class="math">\\mathbf{r}^{(d)} \\in \\mathbb{F}^D</span> be such that <span class="math">r_i^{(d)} = r^{i \\cdot 2^{n-d}}</span> for <span class="math">i \\in [0, D-1]</span>. To prove the lemma it is sufficient to show that <span class="math">f(r^{2^{n-d}}) = \\langle \\alpha^{(d)}, \\mathbf{a} \\rangle</span>. We use the following claim to complete the proof (proof below).</p>

    <p class="text-gray-300"><strong>Claim 2.</strong> <span class="math">\\left(\\frac{1}{D} M_{\\omega_D^{-1}}\\right) \\cdot \\mathbf{r}^{(d)} = \\alpha^{(d)}</span></p>

    <p class="text-gray-300">From the above claim, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} f(r^{2^{n-d}}) &amp;amp;= (\\mathbf{r}^{(d)})^T \\cdot \\mathbf{f} \\\\ &amp;amp;= (\\mathbf{r}^{(d)})^T \\cdot \\left(\\frac{1}{D} M_{\\omega_D^{-1}}\\right) \\cdot \\mathbf{a} &amp;amp; \\text{from Equation 2} \\\\ &amp;amp;= (\\alpha^{(d)})^T \\cdot \\mathbf{a} &amp;amp; \\text{from Fact 2} \\end{aligned}</span></div>

    <p class="text-gray-300">Proof (Proof of Claim 2). For <span class="math">d = n</span>, we have from the definition of <span class="math">\\alpha_i^{(n)}</span> in Algorithm 1 (<span class="math">\\alpha_i</span> is identified with <span class="math">\\alpha_i^{(n)}</span>), for all <span class="math">i \\in [0, N-1]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_i^{(n)} = \\frac{1}{N} \\prod_{j \\in [0, n-1]} (1 + (\\omega_N^{-i} r)^{2^j}) = \\sum_{j \\in [0, N-1]} (\\omega_N^{-i} r)^j</span></div>

    <p class="text-gray-300">Hence, we have <span class="math">\\alpha^{(\\mathbf{n})} = \\frac{1}{N} M_{\\omega_N^{-1}} \\cdot \\mathbf{r}^{(n)}</span> To prove this for any <span class="math">d \\in [1, n-1]</span>, we show <span class="math">\\alpha^{(\\mathbf{d})} = \\frac{1}{D} M_{\\omega_D^{-1}} \\cdot \\mathbf{r}^{(d)}</span> assuming <span class="math">\\alpha^{(\\mathbf{d+1})} = \\frac{1}{2^{d+1}} M_{\\omega_{2D}^{-1}} \\cdot \\mathbf{r}^{(d+1)}</span>. In particular, we show that for all <span class="math">i \\in [0, D-1]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_i^{(d)} = \\frac{1}{D} \\prod_{j \\in [0, d-1]} (1 + (\\omega_D^{-i} r^{2^{n-d}})^{2^j})</span></div>

    <p class="text-gray-300">assuming for all <span class="math">i \\in [0, 2D-1]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_i^{(d+1)} = \\frac{1}{2D} \\prod_{j \\in [0, d]} (1 + (\\omega_{2D}^{-i} r^{2^{n-d-1}})^{2^j})</span></div>

    <p class="text-gray-300">By definition of <span class="math">\\alpha_i^{(d)}</span>, we have for all <span class="math">i \\in [0, D-1]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\alpha_i^{(d)} &amp;amp;= \\alpha_i^{(d+1)} + \\alpha_{i+D}^{(d+1)} \\\\ &amp;amp;= \\frac{1}{2D} \\left( \\left( \\prod_{j \\in [0, d]} (1 + \\omega_{2D}^{-i} r^{2^{n-d-1}})^{2^j} \\right) + \\left( \\prod_{j \\in [0, d]} (1 + \\omega_{2D}^{-i-2^d} r^{2^{n-d-1}})^{2^j} \\right) \\right) \\\\ &amp;amp;= \\frac{1}{2D} \\left( \\left( \\prod_{j \\in [0, d]} (1 + \\omega_{2D}^{-i} r^{2^{n-d-1}})^{2^j} \\right) + \\left( \\prod_{j \\in [0, d]} (1 - \\omega_{2D}^{-i} r^{2^{n-d-1}})^{2^j} \\right) \\right) \\\\ &amp;amp;= \\frac{1}{2D} \\cdot \\left( \\sum_{j \\in [0, D-1]} (\\omega_{2D}^{-i} \\cdot r^{2^{n-d-1}})^j + \\sum_{j \\in [0, D-1]} -(\\omega_{2D}^{-i} \\cdot r^{2^{n-d-1}})^j \\right) \\\\ &amp;amp;= \\frac{1}{2D} \\cdot \\left( \\sum_{j=2\\ell, \\ell \\in [0, D-1]} 2 \\cdot (\\omega_{2D}^{-i} \\cdot r^{2^{n-d-1}})^j \\right) \\\\ &amp;amp;= \\frac{1}{D} \\cdot \\left( \\sum_{j \\in [0, D-1]} (\\omega_{2D}^{-2i} \\cdot r^{2^{n-d}})^j \\right) \\\\ &amp;amp;= \\frac{1}{D} \\cdot \\left( \\prod_{j \\in [0, d-1]} (1 + \\omega_D^{-i} r^{2^{n-d}})^j \\right) \\end{aligned}</span></div>

    <p class="text-gray-300">The last equality in the above sequence of equations follows from Fact 1.</p>

    <p class="text-gray-300">KZG-FFT.eval(srs, <span class="math">C_f, d, u, v; f(\\mathbf{H}_D)</span>) is an argument of knowledge for the following relation</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\{( \\mathbf{srs}, (C_f, D, u, v); f(\\mathbf{H}_D) \\mid f \\in \\mathbb{F}_{&amp;lt;D}[Y], f(u) = v, \\\\ \\text{KZG-FFT.commit}(\\mathbf{srs}_{\\mathcal{P}}, D, f(\\mathbf{H}_D)) = C_f \\} \\end{aligned}</span></div>

    <p class="text-gray-300">The main idea behind the evaluation protocol, like in KZG, is to prove the following polynomial relation at a random point <span class="math">r^{2^{n-d}5}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">f(Y) - f(u) = (Y - u) q(Y)</span></div>

    <p class="text-gray-300">To begin with, an honest prover computes <span class="math">f(u)</span> from <span class="math">\\mathbf{a}</span> using Claim 3, the proof of which is similar to Claim 1, and Lemma 1. We note that to compute <span class="math">f(u)</span>, an honest prover has to spend <span class="math">O(D \\cdot d)</span> field operations.</p>

    <p class="text-gray-300">Claim 3. Let <span class="math">f \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>, and <span class="math">\\mathbf{a}</span> agree with <span class="math">f(\\mathbf{H}_D)</span> over the FFT domain of size <span class="math">D</span>. Then for any <span class="math">u \\in \\mathbb{F}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">f(u) = \\frac{ \\sum_{i \\in [0, D-1]} a_i \\cdot \\left( \\prod_{j \\in [0, d-1]} (1 + (\\omega_D^{-i} \\cdot u)^{2^j}) \\right) }{D}.</span></div>

    <p class="text-gray-300">5 In KZG the random point is <span class="math">r</span> irrespective of the degree. In KZG-FFT this is required to make the srs universal.</p>

    <p class="text-gray-300">In the evaluation protocol, the prover <span class="math">P_{\\text{eval}}</span> computes the evaluations of <span class="math">q(Y)</span> over the FFT domain of size <span class="math">D</span> as follows: for <span class="math">i \\in [0, D - 1]</span> <span class="math">q(\\omega_{D}^{i}) = \\frac{a_{i} - f(u)}{\\omega_{D}^{i} - u}</span>. We note that similar to <span class="math">C_f</span>, <span class="math">C_q</span> can be computed from the evaluations of <span class="math">q(Y)</span> over the FFT domain of size <span class="math">D</span>. The verifier <span class="math">V_{\\text{eval}}</span> checks if <span class="math">e(C_f \\cdot g_1^{-v}, g_2) = e(C_q, h_{2,n-d} \\cdot g_2^{-u})</span>. We show in Theorem 4 that this check ensures either <span class="math">f(r^{2^{n-d}}) - v = (r^{2^{n-d}} - u) \\cdot q(r^{2^{n-d}})</span> or there exists <span class="math">k \\in [1, n-d]</span> and <span class="math">q&#x27;(Y) \\in \\mathbb{F}_{&lt;N}[Y]</span> such that <span class="math">f(r) - v = (r^{2^k} - u) \\cdot q&#x27;(r^k)</span>. Since <span class="math">r</span> is chosen independently and uniformly at random, and is not known to the prover, under the <span class="math">N</span>-DLOG assumption the check passes with high probability if and only if either <span class="math">f(u) = v</span> or <span class="math">Y^{2^k} - u</span> divides <span class="math">f(Y) - v</span>. For a given <span class="math">f \\in \\mathbb{F}_{&lt;N}</span> there exists at most <span class="math">N/2</span> such <span class="math">u</span>'s, and hence if <span class="math">u</span> is sampled uniformly at random from <span class="math">\\mathbb{F}</span>, with high probability <span class="math">u</span> is such that <span class="math">(Y^{2^k} - u)</span> does not divide <span class="math">f(Y) - v</span>, and hence <span class="math">f(u) = v</span>.</p>

    <p class="text-gray-300"><strong>On Updatability of the SRS.</strong> The srs can be generated in an updatable fashion and update correctness can be verified using pairings. We show the update and verify-update algorithms in Appendix C.1. The proof of KS in Theorem 4 shows updatable knowledge-soundness for KZG-FFT in the AGM (as in Definition 1 in Appendix B). The work of [GKM⁺18] shows that for any updatable pairing-based SNARK where the srs consists of encoded polynomials, the prover will also know encodings of the monomials that make up the polynomial. For SNARKs where the encoded polynomial consist of secrets, soundness is broken if the prover learns the monomial encodings. If the srs only contains "monomial terms", updatability of the srs follows from the framework of [GKM⁺18]. In our construction even though the srs does not contain only monomial terms, learning the encodings of the monomials of the encoded polynomial does the help the prover break soundness. We show updatable knowledge-soundness of KZG-FFT even though the srs consists of more encodings in <span class="math">r</span> than just monomials.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> Let <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, g_1, g_2) \\gets_R \\mathcal{G}(1^\\lambda)</span> be a bilinear group. The protocol (KZG-FFT_setup, KZG-FFT.commit, KZG-FFT.eval) is a PCS for <span class="math">\\mathbb{F}_{&lt;N}[Y]</span> in the AGM assuming <span class="math">N</span>-DLOG holds with respect to <span class="math">\\mathcal{G}</span>.</p>

    <p class="text-gray-300">The proof of the above theorem is in Appendix C.2.</p>

    <p class="text-gray-300"><strong>Prover and Verifier Complexity:</strong> The commit algorithm is cheaper than KZG as it does not have to interpolate the evaluations to obtain the coefficient vector. The evaluation prover performs <span class="math">O(D)</span> field divisions to compute the evaluations of the quotient polynomial over the appropriate FFT domain, and an MSME of size <span class="math">D</span> to commit to <span class="math">q(X)</span>. We remark that computing the evaluations of the quotient polynomial can be parallelized across the FFT domain unlike the computation of its coefficients which is inherently serial. The verifier in the evaluation protocol performs 1 exponentiation and 1 group addition over <span class="math">\\mathbb{G}_1</span>, and <span class="math">\\mathbb{G}_2</span> respectively, and 1 pairing check, which is similar to the KZG verifier.</p>

    <h2 id="sec-20" class="text-2xl font-bold">4 Multilinear Commitment Scheme</h2>

    <p class="text-gray-300">In this section, we introduce a novel multilinear commitment scheme denoted as KZG-FOURIER. Drawing inspiration from [BCHO22] and [KT23], our approach leverages a linear isomomorphism (denoted <span class="math">\\mathcal{U}_n</span>) from the <span class="math">F</span>-linear space of multilinear polynomials to the <span class="math">\\mathbb{F}</span>-linear space of univariate polynomials. However, in our scheme, <span class="math">\\mathcal{U}n</span>, diverges by mapping the Fourier basis of <span class="math">\\mathbb{F}_{\\leq 1}[X_0,\\ldots ,X_{n - 1}]</span> to the FFT basis of <span class="math">\\mathbb{F}_{&lt;N}[Y]</span> (see Section 2), where <span class="math">N = 2^n</span>. Combining the univariate polynomial commitment scheme outlined in Section 3 with the multilinear commitment scheme presented here, we establish a dual polynomial commitment scheme, a concept elucidated in Section 5. Section 4.1 is dedicated to defining and proving key properties of <span class="math">\\mathcal{U}_n</span>, while the setup generation algorithm is elaborated in Section 4.2, and the multilinear polynomial commitment scheme itself is delineated in Section 4.3. Throughout this exposition, we maintain the assumptions that <span class="math">N = 2^n</span>, <span class="math">D = 2^d</span>, and <span class="math">K = 2^k</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4.1 Technical Preliminaries</h2>

    <p class="text-gray-300">Readers are directed to Section 2 for pertinent notation. The proof of all the claims and lemmas in this section is deferred to Appendix D.1. Recall that <span class="math">U_{i}^{(n)}</span> denotes the <span class="math">i</span>-th component of the FFT basis of <span class="math">\\mathbb{F}_{&lt;N}[Y]</span>, and <span class="math">L_{i}^{(n)}</span> denotes the <span class="math">i</span>-th Fourier basis of <span class="math">\\mathbb{F}_{\\leq 1}[X_0,\\ldots ,X_{n - 1}]</span>. We commence by presenting the subsequent claim, akin to Claim 1.</p>

    <p class="text-gray-300">6 In [KT23], the Fourier basis of <span class="math">\\mathbb{F} \\leq 1[X_0, \\ldots, X_{n-1}]</span> is mapped to the monomial basis of <span class="math">\\mathbb{F}_{&lt;n}[y]</span>, <span class="math">l_i^{(n)}</span>="" <span class="math">l_i^{(n)}</span>="" <span class="math">n=&quot;2^n</span>," <span class="math">n</span>="" <span class="math">u_{i}^{(n)}</span>="" (denoted="" 1.="" 1[x_0,="" 1[x_0, \\ldots,="" 4.1="" 4.2,="" 5.="" a="" algorithm="" all="" and="" are="" as="" assumptions="" be="" by="" claim="" coefficients="" connected="" connected.=""</p>

    <p class="text-gray-300">Claim 5. <span class="math">U_{i}^{(n)} = \\frac{1}{N}\\cdot \\prod_{j\\in [0,n - 1]}(1 + (\\omega_{N}^{-i}\\cdot Y)^{2^{j}})</span></p>

    <p class="text-gray-300">The linear isomorphism <span class="math">\\mathcal{U}_n</span> between <span class="math">\\mathbb{F}_{\\leq 1}[X_0,\\ldots ,X_{n - 1}]</span> and <span class="math">\\mathbb{F}_{&amp;lt; N}[Y]</span> is defined as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {U} _ {n} (L _ {i} ^ {(n)}) = U _ {i} ^ {(n)} \\quad \\mathrm {f o r} i \\in [ 0, N - 1 ].</span></div>

    <p class="text-gray-300">Below, we proceed to establish several properties of <span class="math">\\mathcal{U}_n</span>.</p>

    <p class="text-gray-300">Claim 6. <span class="math">\\mathcal{U}_n(1) = 1</span></p>

    <p class="text-gray-300">Claim 7. <span class="math">\\mathcal{U}_n(L_i^{(d)}) = \\mathcal{U}_n(L_i^{(d + 1)}) + \\mathcal{U}_n(L_{i + D}^{(d + 1)})</span> for <span class="math">d\\in [1,n - 1]</span></p>

    <p class="text-gray-300">Lemma 2. <span class="math">\\mathcal{U}_n(L_i^{(d)}) = U_i^{(d)}(Y^{2^{n - d}})</span>, holds for <span class="math">d\\in [1,n]</span>. Moreover, for <span class="math">f\\in \\mathbb{F}_{\\leq 1}[X_0,\\ldots ,X_{d - 1}]</span>, <span class="math">\\{f_{L_i^{(d)}}\\in \\mathbb{F}\\}_{i\\in [0,D - 1]}</span> represents the Fourier coefficients of <span class="math">f</span> if and only if there exists a <span class="math">g\\in \\mathbb{F}_{&amp;lt; D}[Y]</span> such that <span class="math">\\mathcal{U}_n(f) = g(Y^{2^{n - d}})</span> and <span class="math">g(\\omega_D^i) = f_{L_i^{(d)}}</span>. Lemma 3. For <span class="math">d\\in [1,n - 1]</span>, <span class="math">f\\in \\mathbb{F}_{\\leq 1}[X_0,\\ldots ,X_{d - 1}]</span> if and only if there exists <span class="math">\\psi_f\\in \\mathbb{F}_{&amp;lt; D}[Y]</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {U} _ {n} (X _ {d} \\cdot f) = \\psi_ {f} (Y ^ {2 ^ {n - d - 1}}) \\cdot \\prod_ {j \\in [ 0, D - 1 ]} (Y ^ {2 ^ {n - d - 1}} - \\omega_ {2 D} ^ {j})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {U} _ {n} ((1 - X _ {d}) \\cdot f) = \\psi_ {f} (- Y ^ {2 ^ {n - d - 1}}) \\cdot \\prod_ {j \\in [ 0, D - 1 ]} (Y ^ {2 ^ {n - d - 1}} + \\omega_ {2 D} ^ {j})</span></div>

    <p class="text-gray-300">Claim 8. Let <span class="math">\\psi \\in \\mathbb{F}_{&amp;lt; D}[Y]</span>. Then there exists <span class="math">\\psi_o, \\psi_e \\in \\mathbb{F}_{&amp;lt; 2^{d-1}}[Y]</span> such that <span class="math">\\psi(Y) = \\psi_e(Y^2) + Y \\cdot \\psi_o(Y^2)</span>, and <span class="math">\\psi(-Y) = \\psi_e(Y^2) - Y \\cdot \\psi_e(Y^2)</span>. Further,</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {e} \\left(\\omega_ {2 ^ {d - 1}} ^ {i}\\right) = \\frac {\\psi \\left(\\omega_ {D} ^ {i}\\right) + \\psi \\left(- \\omega_ {D} ^ {i}\\right)}{2} \\quad \\forall i \\in [ 0, 2 ^ {d - 1} - 1 ]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {o} \\left(\\omega_ {2 ^ {d - 1}} ^ {i}\\right) = \\frac {\\psi \\left(\\omega_ {D} ^ {i}\\right) - \\psi \\left(- \\omega_ {D} ^ {i}\\right)}{2 \\omega_ {D} ^ {i}} \\quad \\forall i \\in [ 0, 2 ^ {d - 1} - 1 ]</span></div>

    <h2 id="sec-22" class="text-2xl font-bold">4.2 Setup Generation</h2>

    <p class="text-gray-300">Algorithm 2 KZG-FOURIER.setup(1<span class="math">^{\\lambda}</span>): Setup Generation for KZG-FOURIER</p>

    <p class="text-gray-300">Input: <span class="math">\\{1^{\\lambda},N\\}</span></p>

    <p class="text-gray-300">Output: <span class="math">\\{\\mathsf{srs} = (\\mathsf{srs}_{\\mathcal{P}},\\mathsf{srs}_{\\mathcal{V}}),\\pi ,\\}</span></p>

    <p class="text-gray-300">1: <span class="math">((\\mathsf{srs}_{\\mathcal{P}}^{\\prime},\\mathsf{srs}_{\\mathcal{V}}^{\\prime}),\\pi)\\gets \\mathsf{KZG - FFT .setup}(1^{\\lambda}).</span> 2: Let <span class="math">\\mathsf{srs}_{\\mathcal{P}} = \\mathsf{srs}_{\\mathcal{P}}^{\\prime} = \\{h_{1,i}^{(n)}\\}_{i\\in [0,N - 1]}.</span> 3: For <span class="math">d \\in [0, n-1]</span>, let <span class="math">\\phi_d(Y) = \\prod_{i=0}^{D-1} (Y - \\omega_{2D}^j)</span>, and compute the evaluations of <span class="math">\\phi_d</span> over the FFT domain of size <span class="math">2D</span>. Compute <span class="math">C_{\\phi_d} = \\mathsf{KZG - FFT.commit}(\\mathsf{srs}_{\\mathcal{P}}, 2D, \\phi_d(\\mathbf{H}_{2D}))</span> as the commitment to <span class="math">\\phi_d</span> for <span class="math">d \\in [0, n-1]</span>. 4: Let <span class="math">\\mathsf{srs}_{\\mathcal{V}} = (\\mathsf{srs}_{\\mathcal{V}}^{\\prime},\\{C_{\\phi_d}\\}_{d\\in [1,n - 1]})</span> 5: Output <span class="math">\\{\\mathsf{srs} = (\\mathsf{srs}_{\\mathcal{P}},\\mathsf{srs}_{\\mathcal{V}}),\\pi \\}</span></p>

    <p class="text-gray-300">Let <span class="math">(p,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,g_1,g_2)\\gets_R\\mathcal{G}(1^\\lambda)</span> be a bilinear group. Algorithm 2 computes the setup for KZG-FOURIER. It takes the security parameter <span class="math">\\lambda</span> and the bound on the number of multilinear monomials <span class="math">N</span> as input and produces <span class="math">\\mathsf{srs}</span> along with a proof <span class="math">\\pi</span>. The <span class="math">\\mathsf{srs}</span>, like in KZG-FFT, has two disjoint parts <span class="math">(\\mathsf{srs}_{\\mathcal{P}},\\mathsf{srs}_{\\mathcal{V}})</span>: <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span> is used by the prover and <span class="math">\\mathsf{srs}_{\\mathcal{V}}</span> is used by the verifier. In Step 1, Algorithm 2 invokes KZG-FFT.setup, yielding <span class="math">\\mathsf{srs}&#x27;</span>. It sets <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span> identical to <span class="math">\\mathsf{srs}_{\\mathcal{P}}&#x27;</span>. For the evaluation protocol of KZG-FOURIER, the verifier needs to evaluate <span class="math">\\phi_d(Y) = \\prod_{j=0}^{D-1}(Y - \\omega_{2D}^j)</span> at a randomly chosen point. Hence, <span class="math">\\mathsf{srs}_{\\mathcal{V}}</span> includes commitments to <span class="math">\\phi_d(Y)</span>, for <span class="math">d \\in [1,n-1]</span>, in addition to <span class="math">\\mathsf{srs}_{\\mathcal{V}}&#x27;</span>. Particularly in Step 3, the algorithm computes evaluations of the polynomial <span class="math">\\phi_d(Y)</span> over the FFT domain of size <span class="math">2D</span>, for <span class="math">d \\in [1,n-1]</span>, and at Step 4, it commits to it using KZG-FFT.commit. It's worth noting that despite</p>

    <p class="text-gray-300">7 It is important to note that <span class="math">\\mathcal{U}_n(L_i^{(d)})</span> differs from <span class="math">\\mathcal{U}_d(L_i^{(d)})</span>.</p>

    <p class="text-gray-300">the degree of <span class="math">\\phi_{d}</span> being at most <span class="math">D</span>, Algorithm 2 commits to it as a polynomial of degree at most <span class="math">2D</span>. This is required in batch evaluation check of all the univariate polynomials in KZG-FOURIER.eval. Additionally, even though <span class="math">\\phi_{d}(\\mathbf{H}_{2D})</span> is of size <span class="math">2D</span>, at least <span class="math">D</span> of its components are <span class="math">0</span> since <span class="math">\\phi_{d}(\\omega_{2D}^{2i})=0</span>, for <span class="math">i\\in[0,D-1]</span>. Thus for <span class="math">d\\in[1,n-1]</span>, KZG-FFT.commit requires an MSME of length <span class="math">D</span> (not <span class="math">2D</span>).</p>

    <p class="text-gray-300">Updatability. The srs returned by KZG-FOURIER.setup can be updated using KZG-FFT.update.setup (Algorithm 3) and KZG-FFT.verify.setup (Algorithm 4). The KZG-FOURIER. update_setup algorithm additionally computes new commitments to the public polynomials <span class="math">\\phi_{d}(Y)</span> for <span class="math">d\\in[1,n-1]</span> using the updated SRS returned by KZG-FFT.update_setup. The KZG-FOURIER.verify.. setup algorithm uses KZG-FFT.verify.setup to verify the first part of the SRS. Additionally, it verifies the commitments to <span class="math">\\phi_{d}(Y)</span> for <span class="math">d\\in[1,n-1]</span> by running the KZG-FFT.eval protocol: it evaluates <span class="math">\\phi_{d}(Y)</span> at a random point <span class="math">u\\in_{R}\\mathbb{F}</span>, computes a proof of <span class="math">\\phi_{d}(u)=z</span> and checks that the proof verifies.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.3 Protocol</h3>

    <p class="text-gray-300">The KZG-FOURIER commitment scheme is detailed in Protocol 2. During Step 1, the setup is generated following Algorithm 2. Let <span class="math">f\\in\\mathbb{F}_{\\leq 1}[X_{0},\\ldots,X_{d-1}]</span> and <span class="math">f_{L_{i}^{(d)}}\\in\\mathbb{F}</span> represent its <span class="math">D</span> Fourier coefficients. Throughout this section, we associate <span class="math">f_{i}</span> with <span class="math">f_{L_{i}^{(d)}}</span> for <span class="math">i\\in[0,D-1]</span>. Consider <span class="math">\\mathbf{f}\\in\\mathbb{F}^{D}</span> such that the <span class="math">i</span>-th component of <span class="math">\\mathbf{f}</span> is <span class="math">f_{i}</span> for <span class="math">i\\in[0,D-1]</span>. The KZG-FOURIER.commit algorithm, in Step 2, accepts <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span>, <span class="math">\\mathbf{f}\\in F^{D}</span>, and <span class="math">D</span> as input, and produces <span class="math">C_{f}=\\mathsf{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}},D,\\mathbf{f})</span> as output. From Lemma 2, it follows that there exists <span class="math">w_{f}\\in\\mathbb{F}_{&lt;D}[Y]</span> such that <span class="math">\\mathcal{U}_{d}(f)=w_{f}(Y)</span>, and <span class="math">w_{f}(\\omega_{D}^{i})=f_{i}</span> for <span class="math">i\\in[0,D-1]</span>. When <span class="math">f</span> is evident from the context, we drop it from the subscript of <span class="math">w_{f}</span>. The commit algorithm treats <span class="math">\\mathbf{f}</span> as the evaluations of <span class="math">w</span> over the FFT domain of size <span class="math">D</span> and commits to it using KZG-FFT.commit. From Lemma 1,</p>

    <p class="text-gray-300"><span class="math">C_{f}=C_{w_{f}}=\\mathsf{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}},D,w_{f}(\\mathbf{H}_{D}))=g_{1}^{w(r^{2^{n-d}})}.</span></p>

    <p class="text-gray-300">We interchangeably use <span class="math">C_{f}</span> and <span class="math">C_{w_{f}}</span>, as they denote the same commitment. We denote <span class="math">(X_{0},\\ldots,X_{d-1})</span> as <span class="math">\\mathbf{X}^{(d)}</span> , and <span class="math">(x_{0},\\ldots,x_{d-1})</span> as <span class="math">\\mathbf{x}^{(d)}</span>, where <span class="math">x_{i}\\in\\mathbb{F}</span> for <span class="math">i\\in[0,d-1]</span>. The KZG-FOURIER.eval algorithm at Step 3 is a ten round public coin protocol <span class="math">\\langle P_{\\mathsf{eval}},V_{\\mathsf{eval}}\\rangle(\\mathsf{srs}</span>, <span class="math">C_{f},D,\\mathbf{x}^{(d)}</span>, <span class="math">y;\\mathbf{f})</span>. By Fact 3, <span class="math">f(\\mathbf{x}^{(d)})=y</span> if and only if there exists <span class="math">q_{k}(\\mathbf{X}^{(k)})\\in\\mathbb{F}^{\\leq 1}[\\mathbf{X}^{(k)}]</span> for <span class="math">k\\in[0,d-1]</span> such that</p>

    <p class="text-gray-300"><span class="math">f(\\mathbf{X}^{(d)})-y=\\sum_{k=0}^{d-1}(X_{k}-x_{k})\\cdot q_{k}(\\mathbf{X}^{(k)}).</span> (3)</p>

    <p class="text-gray-300">Hence, ensuring correctness of KZG-FOURIER.eval requires <span class="math">V_{\\mathsf{eval}}</span> to only check the above polynomial relation. Further, as <span class="math">\\mathcal{U}_{n}</span> is a linear isomorphism, it suffices for <span class="math">V_{\\mathsf{eval}}</span> to verify the aforementioned relation under <span class="math">\\mathcal{U}_{n}</span>. In essence, the primary concept behind the evaluation protocol is to empower the verifier to verify the following (univariate) polynomial relation evaluated at a random point <span class="math">z</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{d}(f)-\\mathcal{U}_{d}(y)=\\bigg{(}\\sum_{k=0}^{d-1}\\big{(}\\mathcal{U}_{d}(X_{k}\\cdot q_{k})-\\mathcal{U}_{d}(x_{k}\\cdot q_{k})\\big{)}\\bigg{)}</span> (4)</p>

    <p class="text-gray-300">At Step 3a, <span class="math">P_{\\mathsf{eval}}</span> calculates the Fourier coefficients of such <span class="math">q_{k}(\\mathbf{X}^{(k)})</span> for <span class="math">k\\in[1,d-1]</span>. Let <span class="math">\\psi_{q_{k}}</span>, <span class="math">\\psi_{q_{k},e}</span> and <span class="math">\\psi_{q_{k},o}</span> correspond to <span class="math">q_{k}(\\mathbf{X}^{(k)})</span> as described in Lemma 3 and Claim 8. As outlined in Claim 14, for each <span class="math">k\\in[1,d-1]</span>, <span class="math">P_{\\mathsf{eval}}</span> can determine the evaluations of <span class="math">\\psi_{q_{k},e}(Y)</span> and <span class="math">\\psi_{q_{k},o}(Y)</span> over the FFT domain of size <span class="math">D</span>. <span class="math">P_{\\mathsf{eval}}</span> computes commitments to <span class="math">\\psi_{q_{k},e}</span> and <span class="math">\\psi_{q_{k},o}</span>, for <span class="math">k\\in[1,d-1]</span> as follows:</p>

    <p class="text-gray-300"><span class="math">C_{\\psi_{q_{k},e}}</span> <span class="math">=\\mathsf{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}},D,\\psi_{q_{k},e}(\\mathbf{H}_{D}))</span> (5) <span class="math">C_{\\psi_{q_{k},o}}</span> <span class="math">=\\mathsf{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}},D,\\psi_{q_{k},o}(\\mathbf{H}_{D}))</span> (6)</p>

    <p class="text-gray-300">The primary reason to use commitments to <span class="math">\\psi_{q_{k,e}}</span> and <span class="math">\\psi_{q_{k,o}}</span> is that the evaluations of these polynomials can be used to derive the evaluations of <span class="math">\\mathcal{U}_{d}(X_{k}\\cdot q_{k})</span> and <span class="math">\\mathcal{U}_{d}(q_{k})</span> in a sound manner. This is achieved through Equations 9 and 10 explained below which itself follows from Lemma 3. We note that even though the degrees of <span class="math">\\psi_{q_{k},e}</span> and <span class="math">\\psi_{q_{k},o}</span> are at most <span class="math">K/2</span>, <span class="math">P_{\\mathsf{eval}}</span> commits to them using their evaluations over FFT domain of size <span class="math">D</span>. This helps in batch evaluation of all the univariate polynomials, and establishing degree bounds on them in the steps ahead.</p>

    <p class="text-gray-300">At Step 3c, <span class="math">P_{\\mathsf{eval}}</span> computes <span class="math">w(z)</span>, <span class="math">\\psi_{q_{k},e}(z^{2^{d-k}})</span>, and <span class="math">\\psi_{q_{k},o}(z^{2^{d-k}})</span> for <span class="math">k\\in[1,d-1]</span>, utilizing the evaluations of the respective polynomials over the FFT domains of size <span class="math">D</span> (refer to Claim 3), and <span class="math">\\phi_{k}(z^{2^{d-k-1}})</span> for <span class="math">k\\in[1,d-1]</span> directly by evaluating its expression. At Step 3d, <span class="math">V_{\\mathsf{eval}}</span> calculates <span class="math">\\psi_{q_{k}}(z^{2^{d-k-1}})</span> and</p>

    <p class="text-gray-300"><span class="math">\\psi_{q_k}(-z^{2^{d - k - 1}})</span> using the following equations, derived from Claim 8:</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_{q_k}(z^{2^{d - k - 1}}) = \\psi_{q_k,e}(z^{2^{d - k}}) + z^{2^{d - k - 1}} \\cdot \\psi_{q_k,o}(z^{2^{d - k}}) \\tag{7}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\psi_{q_k}(-z^{2^{d - k - 1}}) = \\psi_{q_k,e}(z^{2^{d - k}}) - z^{2^{d - k - 1}} \\cdot \\psi_{q_k,o}(z^{2^{d - k}}) \\tag{8}</span></div>

    <p class="text-gray-300"><span class="math">V_{\\mathrm{eval}}</span> computes <span class="math">\\mathcal{U}_d(q_k)(z)</span> and <span class="math">\\mathcal{U}_d(X_kq_k)(z)</span> using the following equations, for <span class="math">k \\in [1,d - 1]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{U}_d(q_k)(z) = \\psi_{q_k}(z^{2^{d - k - 1}}) \\cdot \\phi_k(z^{2^{d - k - 1}}) \\tag{9} $$</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\psi_{q_k}(-z^{2^{d - k - 1}}) \\cdot \\frac{z^{2D \\cdot 2^{d - k - 1}} - 1}{\\phi_k(z^{2^{d - k - 1}})}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{U}_d(X_kq_k)(z) = \\psi_{q_k}(z^{2^{d - k - 1}}) \\cdot \\phi_k(z^{2^{d - k - 1}}) \\tag{10}</span></div>

    <p class="text-gray-300">Equation 10 follows directly from Lemma 3, whereas Equation 9 is derived from the linearity of <span class="math">\\mathcal{U}_d</span> and adding both equations in Lemma 3. Equation 9 additionally requires the following fact concerning the primitive root of unity</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{j \\in [0,D - 1]} (Y^{2^{d - k - 1}} - \\omega_{2D}^j) \\cdot \\prod_{j \\in [0,D - 1]} (Y^{2^{d - k - 1}} + \\omega_{2D}^j) = (Y^{2^{d - k - 1}})^{2D} - 1.</span></div>

    <p class="text-gray-300">Additionally, from Claim 6, we have <span class="math">\\mathcal{U}_n(x_0q_0) = x_0q_0</span>. Moreover, according to Lemma 2,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{U}_d(X_0q_0) = \\frac{(1 - Y^{2^{d - 1}})q_0}{2}, \\text{ and hence, } \\mathcal{U}_d(X_0q_0)(z) = \\frac{(1 - z^{2^{d - 1}})q_0}{2}.</span></div>

    <h2 id="sec-24" class="text-2xl font-bold">Protocol 2: KZG-FOURIER multilinear commitment scheme</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\mathsf{srs},\\pi \\} \\gets_R</span> KZG-FOURIER.setup<span class="math">(1^{\\lambda},N)</span>, where <span class="math">\\lambda</span> is security parameter.</li>

      <li><span class="math">C_f \\gets</span> KZG-FOURIER.commit<span class="math">(\\mathsf{srs}_{\\mathcal{P}}, D, \\mathbf{f})</span>, where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C_f = C_{w_f} = \\text{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}}, D, w_f(\\mathbf{H}_D))</span></div>

    <p class="text-gray-300">and <span class="math">\\mathcal{U}_d(f) = w_f(Y)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>accept/reject <span class="math">\\leftarrow</span> KZG-FOURIER.eval<span class="math">(\\mathsf{srs}, C_f, D, \\mathbf{x}^{(d)}, y; \\mathbf{f})</span> is a ten round public coin interactive protocol <span class="math">\\langle P_{\\mathrm{eval}}, V_{\\mathrm{eval}} \\rangle</span> (<span class="math">\\mathsf{srs}, C_f, D, \\mathbf{x}^{(d)}, y; \\mathbf{f}</span>) between a PPT prover and a PPT verifier.</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">P_{\\mathrm{eval}} \\to V_{\\mathrm{eval}}</span>: For <span class="math">k \\in [1, d - 1]</span> - Compute the <span class="math">K</span> Fourier coefficients of <span class="math">q_k(\\mathbf{X}^{(k)})</span> for <span class="math">k \\in [1, d - 1]</span> and <span class="math">q_0 \\in \\mathbb{F}</span>, satisfying Equation 3. Let <span class="math">\\psi_{q_k}</span> correspond to <span class="math">q_k(\\mathbf{X}^{(k)})</span> as described in Lemma 3; Compute the evaluations of <span class="math">\\psi_{q_k,e}</span> and <span class="math">\\psi_{q_k,o}</span> (see Claim 8) over the FFT domain of size <span class="math">D</span>, and commit to them as in Equations 5 and 6 respectively. Send these <span class="math">2(d - 1)</span> commitments and <span class="math">q_0 \\in \\mathbb{F}</span> to <span class="math">V_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(b) <span class="math">V_{\\mathrm{eval}} \\to P_{\\mathrm{eval}}</span>: Sample <span class="math">z \\in_r \\mathbb{F}</span> and send to <span class="math">P_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(c) <span class="math">P_{\\mathrm{eval}} \\to V_{\\mathrm{eval}}</span>: Send <span class="math">w_f(z)</span>, and <span class="math">\\psi_{q_k,e}(z^{2^{d - k}})</span>, <span class="math">\\psi_{q_k,o}(z^{2^{d - k}})</span> and <span class="math">\\phi_k(z^{2^{d - k - 1}})</span> for <span class="math">k \\in [1, d - 1]</span> to <span class="math">V_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(d) <span class="math">V_{\\mathrm{eval}} \\to P_{\\mathrm{eval}}</span>: For <span class="math">k \\in [1, d - 1]</span> - Compute <span class="math">\\psi_{q_k}(z^{2^{d - k - 1}})</span> and <span class="math">\\psi_{q_k}(-z^{2^{d - k - 1}})</span> using Equations 7 and 8, respectively. Then calculate <span class="math">\\mathcal{U}_n(q_k)(z)</span> and <span class="math">\\mathcal{U}_n(X_kq_k)(z)</span> using Equations 9 and 10, respectively. Use these values to check and continue if Equation 11 holds, else output reject. Sample <span class="math">\\gamma_w \\in_r \\mathbb{F}</span>, and <span class="math">\\gamma_{k,e}, \\gamma_{k,e}&#x27;, \\gamma_{k,o}, \\gamma_{k,o}&#x27;, \\delta_k \\in_r \\mathbb{F}</span> for <span class="math">k \\in [1, d - 1]</span>. Send these values to <span class="math">P_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(e) <span class="math">P_{\\mathrm{eval}} \\to V_{\\mathrm{eval}}</span>: <span class="math">\\psi(Y) \\in \\mathbb{F}_{&amp;lt;D}[Y]</span> is as defined in Equation 12. Compute the evaluations of <span class="math">\\psi(Y)</span> over <span class="math">\\mathbf{H}_D</span>, and commit to it as follows: <span class="math">C_\\psi = \\text{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}}, D, \\psi(\\mathbf{H}_D))</span>. Send <span class="math">C_\\psi</span> to <span class="math">V_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(f) <span class="math">V_{\\mathrm{eval}} \\to P_{\\mathrm{eval}}</span>: Sample <span class="math">s \\in_r \\mathbb{F}</span> and send it to <span class="math">P_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(g) <span class="math">P_{\\mathrm{eval}} \\to V_{\\mathrm{eval}}</span>: Send <span class="math">w(s)</span>, <span class="math">\\psi_{k,e}(s)</span>, <span class="math">\\psi_{k,o}(s)</span>, <span class="math">\\phi_k(s)</span> for all <span class="math">k \\in [1, d - 1]</span> to <span class="math">V_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(h) <span class="math">V_{\\mathrm{eval}} \\to P_{\\mathrm{eval}}</span>: Sample <span class="math">\\beta_w \\in_r \\mathbb{F}</span>, and <span class="math">\\beta_{k,e}, \\beta_{k,o}, \\kappa_k \\in_r \\mathbb{F}</span> for <span class="math">k \\in [1, d - 1]</span> independently and uniformly at random from <span class="math">\\mathbb{F}</span> for <span class="math">k \\in [1, d - 1]</span>, and send it to <span class="math">P_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(i) <span class="math">P_{\\mathrm{eval}} \\to V_{\\mathrm{eval}}</span>: Let <span class="math">\\eta(Y)</span> be as defined in Equation 13. Compute the evaluations of <span class="math">\\mu(Y) \\in \\mathbb{F}_{&amp;lt;D}[Y]</span> over <span class="math">\\mathbf{H}_D</span>, where <span class="math">\\eta(Y) - \\eta(s) = (Y - s)\\mu(Y)</span>. Compute the commit to <span class="math">\\mu(Y)</span>: <span class="math">C_\\mu = \\text{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}}, D, \\mu(\\mathbf{H}_D))</span>, and send it to <span class="math">V_{\\mathrm{eval}}</span>.</p>

    <p class="text-gray-300">(j) <span class="math">V_{\\mathrm{eval}} \\to P_{\\mathrm{eval}}</span>: Compute <span class="math">C_\\eta</span> using Equation 14 and <span class="math">\\eta(s)</span> using Equations 12, and 13, and check</p>

    <div class="my-4 text-center"><span class="math-block">e(C_\\eta \\cdot g_1^{-\\eta(s)}, g_2) = e(C_\\mu, h_{2,d} \\cdot g_2^{-s})</span></div>

    <p class="text-gray-300"><span class="math">V_{\\text{eval}}</span> checks whether these values satisfy</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{d}(f)(z)-y=\\sum_{k=0}^{n-1}\\mathcal{U}_{d}(X_{k}\\cdot q_{k})(z)-x_{k}\\cdot\\mathcal{U}_{d}(q_{k})(z)</span> (11)</p>

    <p class="text-gray-300">Conditioned on values sent by <span class="math">P_{\\text{eval}}</span> corresponding to <span class="math">w(z)</span>, and <span class="math">\\psi_{q_{k},e}(z^{2^{d-k}})</span>, <span class="math">\\psi_{q_{k},o}(z^{2^{d-k}})</span>, <span class="math">\\phi_{k}(z^{2^{d-k-1}})</span> for <span class="math">k\\in[1,d-1]</span>, being correct, the above check ensures Equation 4 holds with high probability over the random choice of <span class="math">z</span> (using Schwartz-Zippel). Hence, the protocol hereafter ensures the correctness of these vales sent by <span class="math">P_{\\text{eval}}</span>. To this end, for <span class="math">k\\in[1,d-1]</span>, define <span class="math">\\zeta_{q_{k},e},\\zeta_{q_{k},o}\\in\\mathbb{F}_{&lt;D}[Y]</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\zeta_{q_{k},e}(Y)=Y^{2^{d}-2^{k-1}}\\cdot\\psi_{q_{k},e}(Y),\\text{ and }\\zeta_{q_{k},o}(Y)=Y^{2^{d}-2^{k-1}}\\cdot\\psi_{q_{k},o}(Y)</span></p>

    <p class="text-gray-300">The key concept in the upcoming steps is defining the polynomial <span class="math">\\eta(Y)\\in\\mathbb{F}_{&lt;D}[Y]</span> (see Equations 12 & 13 below) and verifying its evaluation at a random point. The accurate evaluation of <span class="math">\\eta(Y)</span> at the specified random point confirms the correctness of the aforementioned values sent by <span class="math">P_{\\text{eval}}</span>. We elaborate upon these next steps below. At Step 3e, <span class="math">\\psi(Y)\\in\\mathbb{F}_{&lt;D}[Y]</span> is defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\psi(Y)=\\gamma_{w}\\cdot\\frac{w(Y)-w(z)}{Y-z}+</span> <span class="math">\\sum_{k\\in[1,d-1]}\\bigg{(}\\frac{\\delta_{k}\\cdot(\\phi_{k}(Y^{2^{d-k-1}})-\\phi_{k}(z^{2^{d-k-1}}))}{Y^{2^{d-k-1}}-z}\\enspace+</span> <span class="math">\\frac{\\gamma_{k,e}\\cdot\\big{(}\\psi_{q_{k},e}(Y)-\\psi_{q_{k},e}(z^{2^{d-k}})\\big{)}+\\gamma^{\\prime}_{k,e}\\cdot\\big{(}\\zeta_{q_{k},e}(Y)-\\zeta_{q_{k},e}(z^{2^{d-k}})\\big{)}}{Y-z^{2^{d-k}}}\\enspace+</span> <span class="math">\\frac{\\gamma_{k,o}\\cdot\\big{(}\\psi_{q_{k},o}(Y)-\\psi_{q_{k},o}(z^{2^{d-k}})\\big{)}+\\gamma^{\\prime}_{k,o}\\cdot\\big{(}\\zeta_{q_{k},o}(Y)-\\zeta_{q_{k},o}(z^{2^{d-k}})\\big{)}}{Y-z^{2^{d-k}}}\\enspace\\bigg{)}</span> (12)</p>

    <p class="text-gray-300">At Step 3i, <span class="math">\\eta(Y)</span> is defined as follows</p>

    <p class="text-gray-300"><span class="math">\\eta(Y)=\\psi(Y)+\\beta_{w}\\cdot w(Y)+\\sum_{k\\in[1,d-1]}\\bigg{(}\\beta_{k,e}\\cdot\\psi_{q_{k},e}(Y)\\enspace+</span> <span class="math">\\beta_{k,o}\\cdot\\psi_{q_{k},o}(Y)+\\kappa_{k}\\cdot\\phi_{k}(Y^{2^{d-k-1}})\\bigg{)}</span> (13)</p>

    <p class="text-gray-300">From Equation 13, and Lemma 1, it follows that <span class="math">V_{\\text{eval}}</span> at the last step can compute the commitment to <span class="math">\\eta(Y)</span> as follows:</p>

    <p class="text-gray-300"><span class="math">C_{\\eta}=C_{\\psi}\\cdot C_{w}^{\\beta_{w}}\\cdot(\\prod_{k\\in[1,d-1]}C_{\\psi_{q_{k},e}}^{\\beta_{k,e}}\\cdot C_{\\psi_{q_{k},o}}^{\\beta_{k,o}}\\cdot C_{\\phi_{k}}^{\\kappa_{k}})</span> (14)</p>

    <p class="text-gray-300">The check in Step 3j ensures the following: (i) the verifier has the correct values for <span class="math">w_{f}(s)</span>, <span class="math">\\psi_{q_{k,e}}(s^{2^{d-k}})</span>, <span class="math">\\psi_{q_{k,o}}(s^{2^{d-k}})</span>, <span class="math">\\phi(s^{2^{d-k-1}})</span>, and <span class="math">\\psi(s)</span>, and (ii) <span class="math">\\psi(Y)</span>, <span class="math">w_{f}(Y)</span>, <span class="math">\\psi_{q_{k,e}}(Y^{2^{d-k}})</span>, <span class="math">\\psi_{q_{k,o}}(Y^{2^{d-k}})</span>, and <span class="math">\\phi(Y^{2^{d-k-1}})</span> are all low-degree polynomials. This check also ensures the correctness of values claimed by the prover at Step 3c as follows. Let <span class="math">v</span>, <span class="math">v_{k,e}</span>, <span class="math">v_{k,o}</span>, and <span class="math">u_{k}</span> be the claimed values of <span class="math">w_{f}(Y)</span>, <span class="math">\\psi_{q_{k,e}}(Y^{2^{d-k}})</span>, <span class="math">\\psi_{q_{k,o}}(Y^{2^{d-k}})</span>, and <span class="math">\\phi(Y^{2^{d-k-1}})</span> at <span class="math">z</span>. Since <span class="math">\\psi(Y)</span> is a low-degree polynomial and <span class="math">s</span> is chosen randomly, <span class="math">\\psi_{q_{k,e}}(Y)-v_{k,e}</span> and <span class="math">\\psi_{q_{k,o}}(Y)-v_{k,o}</span> are divisible by <span class="math">Y-z^{2^{d-k}}</span>. Similarly, <span class="math">w(Y)-v</span> is divisible by <span class="math">Y-z</span>, and <span class="math">\\phi(Y^{2^{d-k-1}})-u_{k}</span> is divisible by <span class="math">Y^{2^{d-k-1}}-z</span>. This implies the claimed values are correct.</p>

    <p class="text-gray-300">We show in Theorem 2 that (KZG-FOURIER.setup, KZG-FOURIER. commit, KZG-FOURIER.eval) specified in Protocol 2 forms a multilinear polynomial commitment scheme. Additionally, like in Theorem 4, we prove that the evaluation protocol KZG-FOURIER.eval is updatable knowledge sound. The proof is deferred to Appendix D.2.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">The protocol (KZG-FOURIER.setup, KZG-FOURIER. commit KZG-FOURIER.eval) forms a polynomial commitment scheme for <span class="math">\\mathbb{F}_{\\leq 1}[X_{0},\\ldots,X_{n-1}]</span> in the AGM model under the <span class="math">N</span>-DLOG assumption.</p>

    <p class="text-gray-300">Prover and Verifier Complexity: The evaluation prover of KZG-FOURIER works in <span class="math">O(D\\log^{2}D)</span> time, and concretely the prover spends a lot of time at Step 3a computing the evaluations of <span class="math">\\psi_{q_{k},o}</span> and <span class="math">\\psi_{q_{k},e}</span>. This step alone requires <span class="math">4\\log D-4</span> FFTs of appropriate sizes and <span class="math">O(D\\log D)</span> field multiplications and divisions. The evaluation verifier of KZG-FOURIER operates in <span class="math">O(\\log D)</span> time. The check performed by verifier at Step 3d requires <span class="math">O(\\log D)</span> field operations. The computation of <span class="math">C_{\\eta}</span> at Step 3j requires <span class="math">3\\log D-1</span> <span class="math">\\mathbb{G}_{1}</span> exponentiations.</p>

    <p class="text-gray-300">In this section, we introduce the notion of a dual polynomial commitment scheme (DualPCS), that links univariate and multilinear polynomial commitment schemes. Specifically, a DualPCS can be used to prove evaluations of a univariate and multilinear polynomial derived from the same witness. Formally, a DualPCS over  <span class="math">\\mathbb{F}</span>  is a tuple  <span class="math">\\mathsf{PC} = (\\mathsf{setup},\\mathsf{commit},\\mathsf{open},\\mathsf{prove\\_link},\\mathsf{eval\\_mult},\\mathsf{eval\\_uni})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{setup}(1^{\\lambda}, N)</span> . On input security parameter  <span class="math">\\lambda</span> , an upper bound  <span class="math">N \\in \\mathbb{N}</span>  on the degree of the univariate polynomial (alternatively on the size of the Fourier basis in case of multilinear polynomials), setup generates public parameters  <span class="math">\\mathsf{pp}</span> .</li>

      <li><span class="math">(C_f, C_{\\mathbf{a}}, \\mathbf{aux}) \\gets \\mathbf{commit}(\\mathsf{pp}, D, \\mathbf{a})</span> . On input the public parameters  <span class="math">\\mathsf{pp}</span> , a vector  <span class="math">\\mathbf{a} \\in \\mathbb{F}^D</span> , where  <span class="math">D \\leq N</span> , commit outputs auxiliary information  <span class="math">\\mathbf{aux}</span>  and commitments to two polynomials: a)  <span class="math">C_f</span>  is the commitment to the univariate polynomial  <span class="math">f(Y)</span>  such that  <span class="math">\\mathbf{a}</span>  agrees with  <span class="math">f(\\mathbf{H}_D)</span>  b)  <span class="math">C_{\\mathbf{a}}</span>  is the commitment to the MLE  <span class="math">\\tilde{a}</span>  of  <span class="math">\\mathbf{a}</span> .</li>

      <li><span class="math">b \\gets \\text{open}(\\mathsf{pp}, \\mathbf{a}, D, (C_f, C_{\\mathbf{a}}), \\mathbf{aux})</span> . On input public parameters  <span class="math">\\mathsf{pp}</span> , the commitments  <span class="math">(C_f, C_{\\mathbf{a}})</span>  and auxiliary information  <span class="math">\\mathbf{aux}</span> , a vector  <span class="math">\\mathbf{a} \\in \\mathbb{F}^D</span> , open outputs a bit indicating accept or reject.</li>

      <li><span class="math">b \\gets \\text{prove_link}</span> . A public coin interactive protocol</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\langle P_{\\mathrm{link}}, V_{\\mathrm{link}} \\rangle(\\mathsf{pp}, C_f, C_{\\mathbf{a}}, D; \\mathbf{a})</span>  between a PPT prover and a PPT verifier. The parties have as common input public parameters  <span class="math">\\mathsf{pp}</span> , commitments  <span class="math">C_f</span>  and  <span class="math">C_{\\mathbf{a}}</span> , degree  <span class="math">D \\leq N</span> . The prover has, in addition, the witness vector  <span class="math">\\mathbf{a} \\in \\mathbb{F}^D</span>  corresponding to  <span class="math">C_f</span>  and  <span class="math">C_{\\mathbf{a}}</span> . At the end of the protocol, the verifier outputs  <span class="math">1/0</span>  indicating accepting/rejecting the proof respectively.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\text{eval\\_mult}(\\mathsf{pp}, C_{\\mathbf{a}}, D, \\mathbf{x}, y; \\mathbf{a})</span> . A public coin interactive protocol  <span class="math">\\langle P_{\\text{eval\\_mult}}, V_{\\text{eval\\_mult}} \\rangle(\\mathsf{pp}, C_{\\mathbf{a}}, D, \\mathbf{x}, y; \\mathbf{a})</span>  between a PPT prover and a PPT verifier. The parties have as common input public parameters  <span class="math">\\mathsf{pp}</span> , commitment  <span class="math">C_{\\mathbf{a}}</span> , the bound on the number of monomials  <span class="math">D</span> , evaluation point  <span class="math">\\mathbf{x} \\in \\mathbb{F}^d</span> , and claimed evaluation  <span class="math">y</span> . Here,  <span class="math">D = 2^d</span> . The prover has, in addition, the opening  <span class="math">\\mathbf{a}</span>  of  <span class="math">C_{\\mathbf{a}}</span> , where  <span class="math">C_{\\mathbf{a}}</span>  is the commitment to the MLE  <span class="math">\\tilde{a}</span>  of  <span class="math">\\mathbf{a} \\in \\mathbb{F}^D</span> . At the end of the protocol, the verifier outputs  <span class="math">1/0</span>  indicating accepting/rejecting the proof respectively.</li>

      <li><span class="math">b \\gets \\text{eval\\_uni}(\\mathsf{pp}, C_f, D, u, v; f(\\mathbf{H}_D))</span> . A public coin interactive protocol  <span class="math">\\langle P_{\\text{eval\\_uni}}, V_{\\text{eval\\_uni}} \\rangle(\\mathsf{pp}, C_f, D, u, v; f(\\mathbf{H}_D))</span>  between a PPT prover and a PPT verifier. The parties have as common input public parameters  <span class="math">\\mathsf{pp}</span> , commitment  <span class="math">C_f</span> , degree bound  <span class="math">D</span> , evaluation point  <span class="math">u</span> , and claimed evaluation  <span class="math">v</span> . The prover has, in addition, the polynomial  <span class="math">f(Y)</span>  in evaluation-vector representation (given by  <span class="math">f(\\mathbf{H}_D)</span> ) bound to  <span class="math">C_f</span> , with degree of  <span class="math">f</span>  at most  <span class="math">D</span> . At the end of the protocol, the verifier outputs  <span class="math">1/0</span>  indicating accepting/rejecting the proof respectively.</li>

    </ul>

    <p class="text-gray-300">A dual polynomial commitment scheme must satisfy completeness, binding, extractability, and linking soundness.</p>

    <p class="text-gray-300">Definition 9 (Completeness) For all  <span class="math">\\mathbf{a} \\in \\mathbb{F}^D</span> ,  <span class="math">D \\leq N</span> , and for all  <span class="math">\\mathbf{x} \\in \\mathbb{F}^d</span> ,  <span class="math">u \\in \\mathbb{F}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {s e t u p} (1 ^ {\\lambda}, N) \\\\ &amp;amp; (C _ {f}, C _ {\\mathbf {a}}) \\leftarrow \\mathsf {c o m m i t} (\\mathsf {p p}, D, \\mathbf {a}) \\\\ b = 1: &amp;amp; v \\leftarrow f (u), \\mathbf {a} \\text {a g r e e s w i t h} f (\\mathbf {H} _ {D}) \\\\ &amp;amp; y \\leftarrow \\tilde {a} (\\mathbf {x}) \\\\ &amp;amp; b \\leftarrow \\mathsf {e v a l} _ {\\mathsf {m u l t}} (\\mathsf {p p}, C _ {\\mathbf {a}}, D, \\mathbf {x}, y; \\mathbf {a}) \\\\ &amp;amp; \\wedge \\mathsf {e v a l} _ {\\mathsf {u n i}} (\\mathsf {p p}, C _ {f}, D, u, v; f (Y)) \\end{array} \\right) = 1.</span></div>

    <p class="text-gray-300">Definition 10 (Binding) A DualPCS is binding if for all PPT  <span class="math">\\mathcal{A}</span> , the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left( \\begin{array}{c c} \\mathsf {o p e n} (\\mathsf {p p}, \\mathbf {a} _ {0}, D, C, \\mathsf {a u x} _ {0}) = 1 \\wedge &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {s e t u p} (1 ^ {\\lambda}, N) \\\\ \\mathsf {o p e n} (\\mathsf {p p}, \\mathbf {a} _ {1}, D, C, \\mathsf {a u x} _ {1}) = 1 \\wedge : (C, \\mathbf {a} _ {0}, \\mathbf {a} _ {1}, \\mathsf {a u x} _ {0}, \\mathsf {a u x} _ {1}, D) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\mathbf {a} _ {0} \\neq \\mathbf {a} _ {1} &amp;amp; \\mathsf {w h e r e} C = (C _ {f}, C _ {\\mathbf {a}}) \\end{array} \\right)</span></div>

    <p class="text-gray-300">Definition 11 (Evaluation Knowledge soundness) eval_mult and eval_uni are succinct AoKs for the relations  <span class="math">\\mathcal{R}_{\\mathrm{eval\\_mult}}</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{eval\\_uni}}</span>  respectively defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {R} _ {\\text {e v a l - m u l t}} = \\left\\{\\left(\\left(\\mathrm {p p}, C _ {\\mathrm {a}}, \\mathrm {x} \\in \\mathbb {F} ^ {d}, y \\in \\mathbb {F}\\right); \\mathrm {a}\\right): \\right. \\\\ \\left. \\left(C _ {f}, C _ {\\mathbf {a}}\\right) \\leftarrow \\operatorname {c o m m i t} (\\mathrm {p p}, D, \\mathbf {a})\\right) \\wedge y = \\tilde {a} (\\mathbf {x}) \\} \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {R} _ {\\text {e v a l - u n i}} = \\left\\{\\left(\\left(\\mathrm {p p}, C _ {f}, u \\in \\mathbb {F}, v \\in \\mathbb {F}\\right); \\mathrm {a}\\right): \\right. \\\\ \\left. \\left(C _ {f}, C _ {\\mathbf {a}}\\right) \\leftarrow \\operatorname {c o m m i t} (\\mathrm {p p}, D, \\mathbf {a})\\right) \\wedge \\quad v = f (u) \\right\\} \\\\ \\end{array}</span></div>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 12 (Linking Soundness)</h6>

    <p class="text-gray-300">prove_link is a succinct argument for the relation <span class="math">\\mathcal{R}_{\\text{link}}</span> defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\text{link}}=\\{(\\text{p}\\text{p},C_{f},C_{\\mathbf{a}};~{}\\mathbf{a}):(C_{f},C_{\\mathbf{a}})\\leftarrow\\text{commit}(\\text{p}\\text{p},D,\\mathbf{a}))\\}</span></p>

    <p class="text-gray-300">We note that the relation for linking soundness implicitly guarantees that <span class="math">\\mathbf{a}</span> agrees with <span class="math">f</span> on domain <span class="math">\\mathbf{H}_{D}</span> as this is how the commit algorithm produces <span class="math">C_{f}</span> and <span class="math">C_{\\mathbf{a}}</span> by definition. We give two dual polynomial commitment schemes. The first DualPCS, denoted KZG-FFT-FOURIER, is given in Section 5.1. It requires an updatable setup and leverages the univariate and multilinear polynomial commitment schemes presented in Sections 3 and 4 respectively. The second DualPCS, denoted dory-link is given in Section 5.2. It requires a transparent setup and uses Dory <em>[x10]</em> (also see Appendix G) to individually commit and prove evaluations of univariate and multilinear polynomials. Additionally, dory-link uses a novel argument system we present in Appendix E to prove linking soundness. The AoK in Appendix E uses Dory as a blackbox to prove a pre-determined linear relation between two witnesses committed using a two-tiered commitment scheme (Pederson + AFG). Finally, in Section 5.3, we present an application of DualPCS, where we integrate KZG-FFT-FOURIER with Spartan proof system <em>[x23]</em>. We denote such an integration as Spartan-AIR and argue that it has reduced proof complexity and verifier runtime while trading of prover runtime compared to Spartan.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.1 DualPCS with Updatable Setup</h3>

    <p class="text-gray-300">Protocol 3: KZG-FFT-FOURIER</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\text{srs},\\pi\\}\\leftarrow_{R}</span> KZG-FFT-FOURIER.setup <span class="math">(1^{\\lambda},N)</span>, where <span class="math">\\lambda</span> is security parameter.</li>

      <li><span class="math">C_{f},C_{\\mathbf{a}}\\leftarrow_{R}</span> KZG-FFT-FOURIER.commit(<span class="math">\\text{srs}_{\\mathcal{P}},D,\\mathbf{a}</span>). Here, <span class="math">C_{f}=C_{\\mathbf{a}}=\\text{KZG-FFT.commit}(\\text{srs}_{\\mathcal{P}},D,\\mathbf{a})</span>.</li>

      <li>accept/reject <span class="math">\\leftarrow</span> KZG-FFT-FOURIER.prove_link(<span class="math">C_{f},C_{\\mathbf{a}},~{}D;\\mathbf{a}</span>) is the trivial protocol <span class="math">\\langle P_{\\text{link}},V_{\\text{link}}\\rangle(C_{f},C_{\\mathbf{a}},D;\\mathbf{a})</span> between <span class="math">P_{\\text{link}}</span> and <span class="math">V_{\\text{link}}</span>, where <span class="math">V_{\\text{link}}</span> checks <span class="math">C_{f}=C_{\\mathbf{a}}</span>.</li>

      <li>KZG-FFT-FOURIER.eval_mult = KZG-FOURIER.eval (<span class="math">\\text{srs},C_{\\mathbf{a}},D,\\mathbf{x},~{}y;\\mathbf{a}</span>).</li>

      <li>KZG-FFT-FOURIER.eval_uni = KZG-FFT.eval(<span class="math">\\text{srs},~{}C_{f},D,u,v;\\mathbf{a}</span>)</li>

    </ol>

    <p class="text-gray-300">KZG-FFT-FOURIER is presented in Protocol 3. Let <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g_{1},g_{2})\\leftarrow_{R}\\mathcal{G}(1^{\\lambda})</span> be a bilinear group. KZG-FFT-FOURIER. setup takes as input the security parameter <span class="math">\\lambda</span>, and <span class="math">N</span> the degree bound on the set of univariate polynomials (or alternatively the bound on the number of multilinear monomials). The function internally calls KZG-FOURIER.setup<span class="math">(1^{\\lambda},N)</span> and returns its output <span class="math">\\{\\text{srs},\\pi\\}</span>. It is important to note here that the <span class="math">\\text{srs}</span> returned by KZG-FOURIER.setup<span class="math">(1^{\\lambda},n)</span> is a subset of the <span class="math">\\text{srs}</span> returned by KZG-FFT.setup<span class="math">(1^{\\lambda},N)</span>. Let <span class="math">f\\in\\mathbb{F}_{&lt;D}[Y]</span> be such that <span class="math">\\mathbf{a}</span> agrees with <span class="math">f(\\mathbf{H}_{D})</span>. KZG-FFT-FOURIER.commit takes as input <span class="math">\\text{srs}_{\\mathcal{P}}</span>, <span class="math">\\mathbf{a}\\in\\mathbb{F}^{D}</span>, and commits to <span class="math">f(Y)</span> as <span class="math">C_{f}=\\text{KZG-FFT}</span>. commit(<span class="math">\\text{srs}_{\\mathcal{P}},D,\\mathbf{a}</span>). It easily follows from the definition of KZG-FOURIER.commit that</p>

    <p class="text-gray-300"><span class="math">C_{\\mathbf{a}}</span> <span class="math">=\\text{KZG-FOURIER.commit}(\\text{srs}_{\\mathcal{P}},D,\\mathbf{a})</span> <span class="math">=\\text{KZG-FFT.commit}(\\text{srs}_{\\mathcal{P}},D,\\mathbf{a}),</span></p>

    <p class="text-gray-300">where <span class="math">C_{\\mathbf{a}}</span> is the commitment to the MLE <span class="math">\\tilde{a}</span> of <span class="math">\\mathbf{a}</span>. Hence, KZG-FFT- FOURIER.prove_link(<span class="math">C_{f},C_{\\mathbf{a}},D;\\mathbf{a}</span>) is the trivial protocol where the verifier just checks <span class="math">C_{f}=C_{\\mathbf{a}}</span>. KZG-FFT-FOURIER.eval_mult is the evaluation protocol employed by KZG-FOURIER, whereas KZG-FFT -FOURIER.eval_uni is the evaluation protocol employed by KZG-FFT. It is evident from Theorems 4 and 9 that KZG-FFT-FOURIER is a dual polynomial commitment scheme. We state this in Theorem 10 and defer the proof to Appendix F.1.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 10.</h6>

    <p class="text-gray-300">The protocol constituting of algorithms (KZG-FFT-FOURIER.setup, KZG-FFT-FOURIER.commit, KZG-FFT-FOURIER. prove_link, KZG-FFT-FOURIER.eval_mult, KZG-FFT-FOURIER. eval_uni ) forms a dual polynomial commitment scheme in the AGM under the <span class="math">N</span>-DLOG assumption.</p>

    <p class="text-gray-300">5.2 DualPCS with Transparent Setup</p>

    <p class="text-gray-300">Protocol 4: dory-link</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pp <span class="math">\\leftarrow</span> dory-link.setup<span class="math">(1^{\\lambda},N)</span>, where <span class="math">\\lambda</span> is security parameter.</li>

      <li><span class="math">C_{f},C_{\\mathbf{a}}\\leftarrow_{R}</span> dory-link.commit<span class="math">(p\\mathbf{k},\\mathbf{a},D)</span>, where</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{\\mathbf{a}}=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)},g_{2}^{a_{i}}),\\text{ and }C_{f}=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)},g_{2}^{f_{i}})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{a}\\in\\mathbb{F}^{D}</span>, and <span class="math">f\\in\\mathbb{F}_{&lt;D}[Y]</span> agrees with <span class="math">\\mathbf{a}</span> over <span class="math">\\mathbf{H}_{D}</span>. <span class="math">(f_{1},\\ldots,f_{D})i</span> is the coefficient vector of <span class="math">f</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>dory-link.prove_link <span class="math">=\\langle P_{\\text{lin}},V_{\\text{lin}}\\rangle</span> (pp, <span class="math">C_{f},C_{\\mathbf{a}},D;\\mathbf{a}</span>). Here <span class="math">\\langle P_{\\text{lin}},V_{\\text{lin}}\\rangle</span> execute the Linear-Rel AoK (see Protocol 6, Appendix E).</li>

      <li>dory-link.eval_mult <span class="math">=\\langle P_{\\text{dory\\_eval}},V_{\\text{dory\\_eval}}\\rangle(\\text{pp},C_{\\mathbf{a}},\\;D,\\mathbf{x},y;\\mathbf{a})</span>. Here <span class="math">\\langle P_{\\text{dory\\_eval}},V_{\\text{dory\\_eval}}\\rangle</span> is the Dory evaluation protocol restated in Protocol 8 in Appendix G.3.</li>

      <li>dory-link.eval_uni <span class="math">=\\langle P_{\\text{dory\\_eval}},V_{\\text{dory\\_eval}}\\rangle(\\text{pp},C_{\\mathbf{a}},\\;D,u,v;\\mathbf{a})</span>. Here <span class="math">\\langle P_{\\text{dory\\_eval}},V_{\\text{dory\\_eval}}\\rangle</span> is the Dory evaluation protocol restated in Protocol 8 in Appendix G.3.</li>

    </ol>

    <p class="text-gray-300">Protocol 4 states dory-link, a DualPCS that uses a transparent setup. Before explaining the steps of the protocol we present the overarching idea of dory-link. It uses the Dory commitment scheme to commit and later evaluate both the univariate and multilinear polynomials. The proof that commitments to univariate and multilinear polynomials are derived from the same witness requires a novel AoK that establishes a pre-determined linear relationship between two witnesses. Let <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\;\\mathbb{G}_{T},e,g_{1},g_{2})</span> <span class="math">\\leftarrow_{R}\\mathcal{G}(1^{\\lambda})</span> be a bilinear group. Let <span class="math">\\mathbf{a}\\in\\mathbb{F}^{D}</span>, and <span class="math">f\\in\\mathbb{F}_{&lt;D}[Y]</span> be such that it agrees with <span class="math">\\mathbf{a}</span> over <span class="math">\\mathbf{H}_{D}</span>. We briefly describe the Dory commitment structure here, and refer the reader to Appendix G for a detailed description of the Dory commitment scheme. In Dory, commitments to <span class="math">f</span> and <span class="math">\\tilde{a}</span> have a two-tiered structure defined as follows:</p>

    <p class="text-gray-300"><span class="math">C_{\\mathbf{a}}=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)},g_{2}^{a_{i}})</span> (15) <span class="math">C_{f}=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)},g_{2}^{f_{i}})</span> (16)</p>

    <p class="text-gray-300">Here, <span class="math">\\tau_{1}\\in\\mathbb{G}_{1}^{D}</span> is a vector of arbitrary elements from <span class="math">\\mathbb{G}_{1}</span> and is part of public parameters generated in Step 1. Dory commitment scheme, as part of the evaluation protocol, enables the prover to prove the following relations:</p>

    <p class="text-gray-300"><span class="math">\\{C_{\\mathbf{a}}\\in\\mathbb{G}_{T},\\mathbf{x}\\in\\mathbb{F}^{d},y\\in\\mathbb{F}\\mid\\exists\\mathbf{a}\\in\\mathbb{F}^{D}\\text{ such that }\\tilde{a}(\\mathbf{x})=y\\}</span> <span class="math">\\{C_{f}\\in\\mathbb{G}_{T},u\\in\\mathbb{F},v\\in\\mathbb{F}\\mid\\exists f\\in\\mathbb{F}_{&lt;D}[Y]\\text{ such that }f(u)=v\\}</span></p>

    <p class="text-gray-300">In Appendix E, we present a novel AoK, Linear-Rel (Protocol 6) for the following relation:</p>

    <p class="text-gray-300"><span class="math">\\{C_{f},C_{\\mathbf{a}}\\in\\mathbb{G}_{T}\\mid\\exists\\mathbf{a},\\mathbf{f}\\in\\mathbb{F}^{D}\\text{ such that }M_{\\omega_{D}}\\cdot\\mathbf{f}=\\mathbf{a},\\text{ and }</span> <span class="math">C_{\\mathbf{a}},C_{f}\\text{ are as defined in Equations 15 and 16}\\}</span></p>

    <p class="text-gray-300">In the above equation, <span class="math">M_{\\omega_{D}}</span> is <span class="math">D\\times D</span> FFT matrix, and <span class="math">\\mathbf{f}=(f_{0},\\ldots,f_{D-1})</span> represents the coefficients of the univariate polynomial <span class="math">f(Y)</span> corresponding to which the commitment <span class="math">C_{f}</span> is computed. Linear-Rel also uses Dory as blackbox to prove a pre-determined linear relation between two witnesses <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{f}</span>. dory-link uses Linear-Rel to prove the link between univariate and multilinear commitments. Protocol 4, makes concrete the ideas above. In particular, dory-link.setup computes the public parameters pp required by the DualPCS. dory-link.setup internally calls the setup algorithm of Linear-Rel, which is specified in Algorithm 5, Appendix E. Here, we note that the public parameters thus generated, also contains the public parameters required for the Dory argument. The dory-link.commit algorithm computes <span class="math">C_{\\mathbf{a}}</span> as defined in Equation 15. To compute <span class="math">C_{f}</span>, the algorithm computes the coefficient representation of <span class="math">f</span> such that <span class="math">\\mathbf{a}</span> agrees with <span class="math">f(\\mathbf{H}_{D})</span>, and computes <span class="math">C_{f}</span> as in Equation 16. At Step 3, dory-link.prove_link<span class="math">(C_{f},C_{\\mathbf{a}},D;\\mathbf{a})</span> runs the AoK Linear-Rel given in Appendix E.2. Specifically, <span class="math">P_{\\text{link}}</span> and <span class="math">V_{\\text{link}}</span> is the PPT prover and verifier respectively from Protocol 6. Here, we remark that it is sufficient to run only Step 2 of Protocol 6, as <span class="math">C_{\\mathbf{a}}</span> would already be opened as part of dory-link.eval_mult. At Steps 4 and 5, to prove multilinear (resp. univariate) evaluations, Protocol 8 from Appendix G.3 is employed. We show in Theorem 11 that dory-link is a DualPCS (proof in Appendix F.2).</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">The protocol (dory-link.setup, dory-link.commit, dory-link.prove_link, dory-link.eval_mult, dory-link.eval_uni) is a DualPCS assuming SXDH in the bilinear group <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\,\\mathbb{G}_{T},e,g_{1},g_{2})</span>.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">5.3 Application: Spartan AIR</h3>

    <p class="text-gray-300">In this section, we present an application of our dual polynomial commitment scheme (PCS), KZG-FFT-FOURIER. We demonstrate how utilizing this scheme can reduce the proof complexity and verifier runtime of the Spartan proof system, albeit with a trade-off in prover runtime. This approach is particularly beneficial in scenarios where minimizing verifier runtime and proof complexity is crucial, even at the expense of increased prover computation.</p>

    <p class="text-gray-300">Our starting point is the grand-product check relation defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\textsf{GPR}=\\{(q\\in\\mathbb{F};\\mathbf{a}\\in\\mathbb{F}^{N})\\mid q=\\prod_{i\\in[0,N-1]}a_{i})\\}</span></p>

    <p class="text-gray-300">It is well-known how to perform grand-product checks using specialised GKR <em>[x11, x27]</em> for circuits consisting of only multiplication gates. Additionally, <em>[x29]</em> introduced a dedicated sum-check based argument system to perform grand-product checks. The argument system from both the above approaches require the witness vector to be committed as a multilinear polynomial, that is, the witness vector is viewed as the evaluations of a multilinear polynomial over a boolean hypercube. Further, even though we employ verifier efficient commitment schemes with these proof systems the proof sizes and verifier run time are poly-logarithmic in the case of <em>[x11, x27]</em> and logarithmic in case of <em>[x29]</em>. We present an AoK, called GPR-AIR for grand-product check in Protocol 5 that has <span class="math">O(1)</span> proof complexity and verifier runtime but the witness is viewed as evaluations of an univariate polynomial. Grand-product checks are widely used in many argument systems to prove two vectors are permutations of each other. A special instance of this is how the Spartan proof system employs the grand-product check as part of offline memory check in sparse multilinear PCS. We elaborate upon this next.</p>

    <p class="text-gray-300">A crucial component of Spartan involves evaluating a sparse multilinear extension (MLE) <span class="math">\\tilde{A}</span> of an <span class="math">N\\times N</span> matrix <span class="math">A</span> at a random point. The MLE for an <span class="math">N\\times N</span> matrix is a multilinear polynomial in <span class="math">2\\log N</span> variables, with the first <span class="math">\\log N</span> variables corresponding to the rows and the next <span class="math">\\log N</span> variables corresponding to the columns of the matrix. For <span class="math">u,v\\in\\{0,1\\}^{\\log N}</span>, <span class="math">\\tilde{A}(u,v)</span> is defined as <span class="math">A[\\text{value}(u),\\text{value}(v)]</span>, where value is a function that converts binary strings to their corresponding decimal values. The MLE <span class="math">\\tilde{A}</span> is sparse if it has <span class="math">K=O(N)</span> non-zero evaluations over the boolean hypercube. Spartan introduced a sparse multilinear PCS. This reduces the problem of committing and evaluating a sparse multilinear polynomial in <span class="math">2\\log N</span> variables with sparsity <span class="math">K=O(N)</span>, to committing to and evaluating a constant number of <span class="math">\\log K</span> variate multilinear polynomials at a random point. This reduction comprises two key components: a) a sum-check protocol, and b) offline-memory check using grand-product checks. For a more detailed description of this reduction, refer to Section 3 of <em>[x30]</em>.</p>

    <p class="text-gray-300">In the sum-check protocol at the end, the verifier needs to verify evaluations of the MLE of the witnesses at a random point. In Spartan, grand-product checks are executed using a specialised version of the GKR protocol, while in Quarks <em>[x29]</em>, a sum-check based argument is utilized. Both protocols for grand product check require the verifier to check evaluations of the MLE of the witnesses used in the protocol at a random point. In sum-check protocol the prover performs <span class="math">N\\log N</span> field operations, the verifier performs <span class="math">O(\\log N)</span> field operations, and the proof complexity is <span class="math">O(\\log N)</span>. The complexity of both the protocols from <em>[x11, x27]</em>, and <em>[x29]</em> was mentioned above.</p>

    <p class="text-gray-300">It is important to note that the two protocols involved in the sparse multilinear polynomial commitment scheme—the sum-check and grand-product check protocols—share witnesses and therefore require consistent encoding of these witnesses. Specifically, since the sum-check protocol utilizes multilinear encoding, the grand-product check protocol must also use this same encoding. However, our dual polynomial commitment scheme eliminates this constraint. Our AoK, namely GPR-AIR, for the grand-product check can be combined with the sum-check protocol even though GPR-AIR employs univariate encoding for the witnesses. GPR-AIR presented in Protocol 5 uses a KZG-FFT univariate commitment scheme, and a seamless integration with Spartan is possible, when the sum-check protocol employs KZG-FOURIER as the underlying multilinear commitment scheme. Since GPR-AIR has proof complexity and verifier runtime <span class="math">O(1)</span>, its use in Spartan for the grand-product check reduces the verifier runtime and proof complexity of Spartan. We call this new proof system Spartan-Air and concretely compare its performance with Spartan in Section 6.2.</p>

    <p class="text-gray-300">Finally we remark that although GPR-AIR uses KZG-FFT, in principle, it could use any univariate commitment scheme. Hence, any DualPCS can be used for this integration, provided the sum-check</p>

    <p class="text-gray-300">protocol and GPR-AIR in Protocol 5 utilize the corresponding multilinear and univariate PCS, respectively. We specifically chose KZG-FFT-FOURIER because it does not require additional commitments to witnesses, and the linking proof is trivial.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">AIR for Grand-Product.</h4>

    <p class="text-gray-300">We present a novel AoK, denoted GPR-AIR for the grand-product relation which checks if the product of the elements in two a vectors is equal to the claimed value. The grand-product check is widely used as sub-components in bigger SNARKS to ensure that two distinct vectors are permutations of each other. A prominent example of this is the offline memory checking procedure in Spartan <em>[x21]</em>, Lasso <em>[x22]</em>. We present a dedicated algebraic intermediate representation (AIR) for the same and employ our KZG-FFT commitment scheme to check the AIR at a random point. While this approach is simple, our DualPCS KZG-FFT-FOURIER enables us to combine it with Spartan or Lasso, and obtain smaller proof sizes and better verifier time while trading-off prover time (see Section 5.3). The grand-product relation is formally stated as follows:</p>

    <p class="text-gray-300"><span class="math">\\textsf{GPR}=\\{(q\\in\\mathbb{F};\\mathbf{a}\\in\\mathbb{F}^{N})\\mid q=\\prod_{i\\in[0,N-1]}a_{i})\\}</span></p>

    <p class="text-gray-300">Our protocol, GPR-AIR, is given in Protocol 5. We state the proof system using KZG-FFT commitment scheme but any univariate commitment scheme can be used. At Steps 1-2, <span class="math">P_{\\textsf{GPR}}</span> computes the vector <span class="math">\\mathbf{a}^{\\prime}\\in\\mathbb{F}^{D}</span> which iteratively computes <span class="math">q</span>. It is easily seen that for an honest prover <span class="math">a^{\\prime}_{D-1}=q=\\prod_{i\\in[0,N-1]}a_{i}</span>. The AIR enables the verifier to check <span class="math">\\mathbf{a}^{\\prime}</span> is well-formed, and that the last value of <span class="math">\\mathbf{a}^{\\prime}</span>, <span class="math">a^{\\prime}_{D-1}</span> is indeed the claimed product. Let <span class="math">f_{\\mathbf{a}},f_{\\mathbf{a}^{\\prime}}\\in\\mathbb{F}_{&lt;D}[Y]</span> such that <span class="math">\\mathbf{a},\\mathbf{a}^{\\prime}</span> agrees with <span class="math">f_{\\mathbf{a}}(\\mathbf{H}_{D})</span>, <span class="math">f_{\\mathbf{a}^{\\prime}}(\\mathbf{H}_{D})</span>. Further, define the constraint polynomials <span class="math">f_{1},f_{2},f_{3}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">f_{1}(Y)=\\frac{f_{\\mathbf{a}^{\\prime}}(Y)-f_{\\mathbf{a}}(Y)}{Y-1},f_{2}(Y)=\\frac{f_{\\mathbf{a}^{\\prime}}(Y)-q}{Y-\\omega_{D}^{D-1}}</span> <span class="math">f_{3}(Y)=\\frac{\\left(f_{\\mathbf{a}^{\\prime}}(Y)\\cdot f_{\\mathbf{a}}(\\omega_{D}\\cdot Y)-f_{\\mathbf{a}^{\\prime}}(\\omega_{D}\\cdot Y)\\right)\\cdot\\left(Y-\\omega_{D}^{D-1}\\right)}{Y^{D}-1}</span></p>

    <p class="text-gray-300">The polynomials <span class="math">f_{1}(Y),f_{2}(Y)</span>, and <span class="math">f_{3}(Y)</span> ensure that <span class="math">\\mathbf{a}^{\\prime}</span> is well-formed. Specifically, <span class="math">f_{1}(Y),f_{2}(Y)</span>, and <span class="math">f_{3}(Y)</span> ensure that <span class="math">a^{\\prime}_{0}=a_{0}</span>, <span class="math">a^{\\prime}_{D-1}=q</span>, and <span class="math">a^{\\prime}_{i+1}=a_{i+1}\\cdot a^{\\prime}_{i}</span> for <span class="math">i\\in[0,D-2]</span> respectively. Protocol 5 requires <span class="math">P_{\\textsf{GPR}}</span> at Step 2 to commit to univariate polynomials <span class="math">f_{\\mathbf{a}},f_{\\mathbf{a}^{\\prime}}</span>, and then at Step 4 to commit to <span class="math">f</span> defined as a random linear combination of <span class="math">f_{1}(Y),f_{2}(Y)</span>, and <span class="math">f_{3}(Y)</span> as follows:</p>

    <p class="text-gray-300"><span class="math">f(Y)=\\sum_{i\\in[1,3]}\\gamma_{i}\\cdot f_{i}(Y)</span> (17)</p>

    <p class="text-gray-300">At the end of Step 4, it is easily seen that <span class="math">f(Y)\\in\\mathbb{F}_{&lt;D}[Y]</span> and <span class="math">f(Y)</span> is as defined in Equation 17 if and only if <span class="math">\\mathbf{a}^{\\prime}</span> is well-formed. We remark here that in order to commit to <span class="math">f</span>, <span class="math">P_{\\textsf{GPR}}</span> has to compute <span class="math">f(\\mathbf{H}_{D})</span>, which is computationally intensive. This requires the prover to first compute <span class="math">f_{\\mathbf{a}}(Y)</span> and <span class="math">f_{\\mathbf{a}^{\\prime}}(Y)</span> at the offset FFT domain of size <span class="math">D</span>, and use it to compute <span class="math">f(Y)</span> at the offset FFT domain, and then derive <span class="math">f(\\mathbf{H}_{D})</span> from it. The remaining steps of the protocol help <span class="math">V_{\\textsf{GPR}}</span> to check with high probability that <span class="math">f(Y)\\in\\mathbb{F}_{&lt;D}[Y]</span> and <span class="math">f(Y)</span> is as defined in Equation 17. At Step 7, <span class="math">V_{\\textsf{GPR}}</span> checks</p>

    <p class="text-gray-300"><span class="math">f(u)=\\gamma_{1}\\cdot\\frac{f_{\\mathbf{a}^{\\prime}}(u)-f_{\\mathbf{a}}(u)}{u-1}+\\gamma_{2}\\cdot\\frac{f_{\\mathbf{a}^{\\prime}}(u)-q}{u-\\omega_{D}^{D-1}}+</span> <span class="math">\\gamma_{3}\\cdot\\frac{\\left(f_{\\mathbf{a}^{\\prime}}(u)\\cdot f_{\\mathbf{a}}(\\omega_{D}\\cdot u)-f_{\\mathbf{a}^{\\prime}}(\\omega_{D}\\cdot u)\\right)\\cdot\\left(u-\\omega_{D}^{D-1}\\right)}{u^{D}-1}</span> (18)</p>

    <p class="text-gray-300">Using Schwartz-Zippel, the above check ensures <span class="math">f(Y)</span> satisfies Equation 17 with high probability over the random choice of <span class="math">u</span>. At Steps 8-9 <span class="math">V_{\\textsf{GPR}}</span>, <span class="math">V_{\\textsf{GPR}}</span> checks the claimed values sent by <span class="math">P_{\\textsf{GPR}}</span> at Step 6. This is done by batching checks corresponding to polynomials evaluated at the same point. To this end <span class="math">P_{\\textsf{GPR}},V_{\\textsf{GPR}}</span> run KZG-FFT.eval corresponding to polynomials <span class="math">h_{1}</span>, and <span class="math">h_{2}</span> defined as follows.</p>

    <p class="text-gray-300"><span class="math">h_{1}(Y)=\\delta_{1}\\cdot f_{\\mathbf{a}^{\\prime}}(Y)+\\delta_{2}\\cdot f_{\\mathbf{a}}(Y)+\\delta_{3}\\cdot f(Y)</span> (19) <span class="math">h_{2}(Y)=\\delta_{1}\\cdot f_{\\mathbf{a}^{\\prime}}(Y)+\\delta_{2}\\cdot f_{\\mathbf{a}}(Y)</span> (20)</p>

    <p class="text-gray-300"><span class="math">V_{\\textsf{GPR}}</span> can compute the commitments to <span class="math">h_{1}</span>, and <span class="math">h_{2}</span>, which follows from Lemma 1</p>

    <p class="text-gray-300"><span class="math">C_{h_{1}}=C_{\\mathbf{a}^{\\prime}}^{\\delta_{1}}\\cdot C_{\\mathbf{a}}^{\\delta_{2}}\\cdot C_{f}^{\\delta_{3}}\\ ,\\ C_{h_{2}}=C_{\\mathbf{a}^{\\prime}}^{\\delta_{1}}\\cdot C_{\\mathbf{a}}^{\\delta_{2}}</span></p>

    <p class="text-gray-300"><span class="math">V_{\\textsf{GPR}}</span> can also compute the claimed values <span class="math">v_{1}</span>, and <span class="math">v_{2}</span> as follows</p>

    <p class="text-gray-300"><span class="math">v_{1}=h_{1}(u)=\\delta_{1}\\cdot f_{\\mathbf{a}^{\\prime}}(u)+\\delta_{2}\\cdot f_{\\mathbf{a}}(u)+\\delta_{3}\\cdot f(u)</span> <span class="math">v_{2}=h_{2}(\\omega_{D}\\cdot u)=\\delta_{1}\\cdot f_{\\mathbf{a}^{\\prime}}(\\omega_{D}\\cdot u)+\\delta_{2}\\cdot f_{\\mathbf{a}}(\\omega_{D}\\cdot u)</span></p>

    <p class="text-gray-300">Finally, from the proof of Theorem 4, we have that if  <span class="math">V_{\\mathsf{GPR}}</span>  accepts at Steps 8, and 9 then with high probability  <span class="math">f_{\\mathbf{a}}, f_{\\mathbf{a}&#x27;}</span> ,  <span class="math">f \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>  and that their corresponding claimed values are correct.</p>

    <p class="text-gray-300"><span class="math">\\{\\mathsf{srs},\\pi \\} \\leftarrow_{R}\\mathsf{KZG - FFT}\\mathsf{setup}(1^{\\lambda},N)</span>  , where  <span class="math">\\lambda</span>  is security parameter.</p>

    <p class="text-gray-300"><span class="math">\\langle P_{\\mathsf{GPR}},V_{\\mathsf{GPR}}\\rangle (q;\\mathbf{a}\\in \\mathbb{F}^D,D\\leq N)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{\\mathsf{GPR}}</span> :  <span class="math">P_{\\mathsf{GPR}}</span>  computes a vector  <span class="math">\\mathbf{a}&#x27; \\in F^D</span>  such that  <span class="math">a_0&#x27; = a_0</span> , and  <span class="math">a_i&#x27; = a_{i-1}&#x27; \\cdot a_i</span>  for  <span class="math">i \\in [1, D-1]</span> .</li>

      <li><span class="math">P_{\\mathsf{GPR}} \\to V_{\\mathsf{GPR}}</span> :  <span class="math">P_{\\mathsf{GPR}}</span>  computes  <span class="math">C_{\\mathbf{a}} = \\mathsf{KZG - FFT}.\\mathsf{commit}(\\mathsf{srs},D,\\mathbf{a})</span> ,  <span class="math">C_{\\mathbf{a}&#x27;} = \\mathsf{KZG - FFT}.\\mathsf{commit}(\\mathsf{srs},D,\\mathbf{a}&#x27;)</span> , and sends it to  <span class="math">V_{\\mathsf{GPR}}</span></li>

      <li><span class="math">V_{\\mathsf{GPR}} \\to P_{\\mathsf{GPR}}</span> : Samples three values  <span class="math">\\gamma_1, \\gamma_2, \\gamma_3 \\in_r \\mathbb{F}</span>  and sends it to  <span class="math">P_{\\mathsf{GPR}}</span> .</li>

      <li><span class="math">P_{\\mathsf{GPR}} \\to V_{\\mathsf{GPR}}</span> : Compute the evaluations of constraint polynomials  <span class="math">f \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>  (see Equation 17) over the FFT domain of size  <span class="math">D</span> . Commits to  <span class="math">f</span>  with  <span class="math">C_f = \\mathsf{KZG - FFT}.\\mathsf{commit}(\\mathsf{srs},D,f(\\mathbf{H}_D))</span> .</li>

      <li><span class="math">V_{\\mathsf{GPR}} \\to P_{\\mathsf{GPR}}</span> : Samples  <span class="math">u \\in_R \\mathbb{F}</span> .</li>

      <li><span class="math">P_{\\mathsf{GPR}} \\to V_{\\mathsf{GPR}}</span> : Send  <span class="math">f(u)</span> ,  <span class="math">f_{\\mathbf{a}}(u)</span> ,  <span class="math">f_{\\mathbf{a}&#x27;}(u)</span> ,  <span class="math">f_{\\mathbf{a}}(\\omega_D \\cdot u)</span> ,  <span class="math">f_{\\mathbf{a}&#x27;}(\\omega_D \\cdot u)</span>  to  <span class="math">V_{\\mathsf{GPR}}</span> .</li>

      <li><span class="math">V_{\\mathsf{GPR}} \\to P_{\\mathsf{GPR}}</span> : Checks  <span class="math">f(u)</span> ,  <span class="math">f_{\\mathbf{a}}(u)</span> ,  <span class="math">f_{\\mathbf{a}&#x27;}(u)</span> ,  <span class="math">f_{\\mathbf{a}}(\\omega_D \\cdot u)</span> ,  <span class="math">f_{\\mathbf{a}&#x27;}(\\omega_D \\cdot u)</span>  satisfy Equation 18. If yes then samples  <span class="math">\\delta_1, \\delta_2, \\delta_3 \\in_R \\mathbb{F}</span> , and sends it to  <span class="math">P_{\\mathsf{GPR}}</span> .</li>

      <li>Let  <span class="math">h_1 \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>  be as defined in Equation 19.  <span class="math">P_{\\mathsf{GPR}}, V_{\\mathsf{GPR}}</span>  run KZG-FFT.eval(srs,  <span class="math">C_{h_1}, D, u, v_1</span> ), where  <span class="math">v_1</span>  is claimed value of  <span class="math">h_1</span>  at  <span class="math">u</span> .</li>

      <li>Let  <span class="math">h_2 \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>  be as defined in Equation 20.  <span class="math">P_{\\mathsf{GPR}}, V_{\\mathsf{GPR}}</span>  run KZG-FFT.eval(srs,  <span class="math">C_{h_2}, D, \\omega_D \\cdot u, v_2</span> ), where  <span class="math">v_2</span>  is claimed value of  <span class="math">h_2</span>  at  <span class="math">\\omega_D \\cdot u</span> .</li>

    </ol>

    <p class="text-gray-300">We discuss the concrete costs of our DualPCS in this section. We also compare the concrete performance of Spartan [Set20] with Spartan-AIR, which is derived by integrating GPR-AIR with Spartan using KZG-FFT-FOURIER (see Section 5.3). In Section 6.1, we present the relevant metrics of KZG-FFT-FOURIER and dory-link, and also compare it with other relevant commitment schemes. We provide a reference implementation of KZG-FFT-FOURIER, and dory-link in Rust. Our implementation is based on the BLS12-381 curve. In Section 6.2, we compare the performance of GPR-AIR (Protocol 5) with the grand-product check performed using the techniques in [GKR08,Tha13]. Finally, we integrate GPR-AIR with our implementation of Spartan for Extended-R1CS from [KST22] to obtain reduced proof complexity and verifier run-time for the same.</p>

    <p class="text-gray-300">All measurements are taken on QCT RACK Mount server with 256GB RAM and 46 cores. Throughout we report numbers for verifier on single core, and for prover on multiple cores. Our code is available at the following link https://github.com/arithmic/Dual_PCS.git. We use the efficient bilinear group called BLS12-381 field. Specifically, the proof systems are simulated over the BLS12-381 Scalar field which is a 255 bit prime field, and SXDH is known to be at least 128 bits hard over this bilinear group.</p>

    <p class="text-gray-300">Tables 2 and 3 give the commitment times, proof sizes, evaluation prover and verifier times corresponding to KZG-FFT-FOURIER, and dory-link. Table 7 in Appendix H states the prover and verifier times, and the proof complexity for Linear-Rel, the AoK corresponding to linear relations (see Protocol 6 Appendix E). Linear-Rel is used to prove linking soundness in case of dory-link. We report the setup generation time and setup size for both KZG-FFT, KZG-FOURIER and dory-link in Tables 5, 6 and 8, Appendix H, where we compare them with KZG and multilinear KZG [PST13a]. We note here that for KZG-FFT-FOURIER the commitment is the same for both the univariate and multilinear polynomials (see Section 3 and Section 4). In particular, the total time to commit the witness in this case is equal to generating one of them and not their addition as in the case of dory-link. We also compare the performance of KZG-FFT with KZG, and KZG-FOURIER with multilinear KZG in Appendix H (see Tables 9 and 10). Here, we also compare the asymptotic performance of the evaluation protocols of KZG-FOURIER, Gemini, and Zeromorph (see Table 12).</p>

    <p class="text-gray-300">KZG-FFT vs KZG: For polynomials of degree  <span class="math">2^{20}</span> , the commitment time of KZG-FFT is at least 1.5x</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Proof size(KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Uni(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Uni(ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult(ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Uni(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult(KB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">0.26</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">7.21</td>

            <td class="px-3 py-2 border-b border-gray-700">19.83</td>

            <td class="px-3 py-2 border-b border-gray-700">60.21</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">5.56</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">0.45</td>

            <td class="px-3 py-2 border-b border-gray-700">0.55</td>

            <td class="px-3 py-2 border-b border-gray-700">21.75</td>

            <td class="px-3 py-2 border-b border-gray-700">19.89</td>

            <td class="px-3 py-2 border-b border-gray-700">79.46</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">5.93</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">0.60</td>

            <td class="px-3 py-2 border-b border-gray-700">0.79</td>

            <td class="px-3 py-2 border-b border-gray-700">73.99</td>

            <td class="px-3 py-2 border-b border-gray-700">19.91</td>

            <td class="px-3 py-2 border-b border-gray-700">96.10</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">6.31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">1.08</td>

            <td class="px-3 py-2 border-b border-gray-700">1.32</td>

            <td class="px-3 py-2 border-b border-gray-700">282.35</td>

            <td class="px-3 py-2 border-b border-gray-700">19.88</td>

            <td class="px-3 py-2 border-b border-gray-700">125.38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">6.68</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">2.33</td>

            <td class="px-3 py-2 border-b border-gray-700">3.06</td>

            <td class="px-3 py-2 border-b border-gray-700">1096.54</td>

            <td class="px-3 py-2 border-b border-gray-700">19.86</td>

            <td class="px-3 py-2 border-b border-gray-700">244.70</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">7.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">3.74</td>

            <td class="px-3 py-2 border-b border-gray-700">5.04</td>

            <td class="px-3 py-2 border-b border-gray-700">4616.05</td>

            <td class="px-3 py-2 border-b border-gray-700">19.86</td>

            <td class="px-3 py-2 border-b border-gray-700">387.71</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">7.43</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Performance of KZG-FFT-FOURIER</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Proof size(KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Uni(ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult(ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Uni(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Uni(ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult(ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Uni</td>

            <td class="px-3 py-2 border-b border-gray-700">Mult</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">43.78</td>

            <td class="px-3 py-2 border-b border-gray-700">41.59</td>

            <td class="px-3 py-2 border-b border-gray-700">3.76</td>

            <td class="px-3 py-2 border-b border-gray-700">3.79</td>

            <td class="px-3 py-2 border-b border-gray-700">756.69</td>

            <td class="px-3 py-2 border-b border-gray-700">737.45</td>

            <td class="px-3 py-2 border-b border-gray-700">35.75</td>

            <td class="px-3 py-2 border-b border-gray-700">35.75</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">52.12</td>

            <td class="px-3 py-2 border-b border-gray-700">53.95</td>

            <td class="px-3 py-2 border-b border-gray-700">5.68</td>

            <td class="px-3 py-2 border-b border-gray-700">5.93</td>

            <td class="px-3 py-2 border-b border-gray-700">816.74</td>

            <td class="px-3 py-2 border-b border-gray-700">812.71</td>

            <td class="px-3 py-2 border-b border-gray-700">39.68</td>

            <td class="px-3 py-2 border-b border-gray-700">39.68</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">67.19</td>

            <td class="px-3 py-2 border-b border-gray-700">62.22</td>

            <td class="px-3 py-2 border-b border-gray-700">10.49</td>

            <td class="px-3 py-2 border-b border-gray-700">10.47</td>

            <td class="px-3 py-2 border-b border-gray-700">909.61</td>

            <td class="px-3 py-2 border-b border-gray-700">887.17</td>

            <td class="px-3 py-2 border-b border-gray-700">43.62</td>

            <td class="px-3 py-2 border-b border-gray-700">43.62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">212</td>

            <td class="px-3 py-2 border-b border-gray-700">88.92</td>

            <td class="px-3 py-2 border-b border-gray-700">79.18</td>

            <td class="px-3 py-2 border-b border-gray-700">19.57</td>

            <td class="px-3 py-2 border-b border-gray-700">19.70</td>

            <td class="px-3 py-2 border-b border-gray-700">967.61</td>

            <td class="px-3 py-2 border-b border-gray-700">854.22</td>

            <td class="px-3 py-2 border-b border-gray-700">47.56</td>

            <td class="px-3 py-2 border-b border-gray-700">47.56</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">125.80</td>

            <td class="px-3 py-2 border-b border-gray-700">116.66</td>

            <td class="px-3 py-2 border-b border-gray-700">37.84</td>

            <td class="px-3 py-2 border-b border-gray-700">38.19</td>

            <td class="px-3 py-2 border-b border-gray-700">1046.92</td>

            <td class="px-3 py-2 border-b border-gray-700">842.04</td>

            <td class="px-3 py-2 border-b border-gray-700">51.50</td>

            <td class="px-3 py-2 border-b border-gray-700">51.50</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">171.43</td>

            <td class="px-3 py-2 border-b border-gray-700">178.84</td>

            <td class="px-3 py-2 border-b border-gray-700">74.00</td>

            <td class="px-3 py-2 border-b border-gray-700">74.31</td>

            <td class="px-3 py-2 border-b border-gray-700">1120.45</td>

            <td class="px-3 py-2 border-b border-gray-700">878.97</td>

            <td class="px-3 py-2 border-b border-gray-700">55.43</td>

            <td class="px-3 py-2 border-b border-gray-700">55.43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">298.69</td>

            <td class="px-3 py-2 border-b border-gray-700">279.46</td>

            <td class="px-3 py-2 border-b border-gray-700">147.22</td>

            <td class="px-3 py-2 border-b border-gray-700">147.37</td>

            <td class="px-3 py-2 border-b border-gray-700">1187.06</td>

            <td class="px-3 py-2 border-b border-gray-700">902.49</td>

            <td class="px-3 py-2 border-b border-gray-700">59.37</td>

            <td class="px-3 py-2 border-b border-gray-700">59.37</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">better while having remaining parameters almost same. The setup time of KZG-FFT is mostly comparable to KZG but the setup size is 2x.</p>

    <p class="text-gray-300">KZG-FOURIER vs multilinear KZG: performance of KZG-FOURIER with respect to prover run-time and proof complexity is worse compared to multilinear KZG but the verifier run-time of KZG-FOURIER is better. Additionally, the evaluation prover of KZG-FFT-FOURIER is extremely slow and is one of the bottlenecks of the scheme.</p>

    <p class="text-gray-300">Table 3: Performance of dory-link</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">No Of Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Prover(sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Verifier(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Proof size(KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan AIR</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan AIR</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan AIR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">212</td>

            <td class="px-3 py-2 border-b border-gray-700">10.80</td>

            <td class="px-3 py-2 border-b border-gray-700">7.71</td>

            <td class="px-3 py-2 border-b border-gray-700">0.76</td>

            <td class="px-3 py-2 border-b border-gray-700">0.55</td>

            <td class="px-3 py-2 border-b border-gray-700">49.10</td>

            <td class="px-3 py-2 border-b border-gray-700">29.26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">11.38</td>

            <td class="px-3 py-2 border-b border-gray-700">13.66</td>

            <td class="px-3 py-2 border-b border-gray-700">0.81</td>

            <td class="px-3 py-2 border-b border-gray-700">0.56</td>

            <td class="px-3 py-2 border-b border-gray-700">54.53</td>

            <td class="px-3 py-2 border-b border-gray-700">30.98</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">13.57</td>

            <td class="px-3 py-2 border-b border-gray-700">25.45</td>

            <td class="px-3 py-2 border-b border-gray-700">0.87</td>

            <td class="px-3 py-2 border-b border-gray-700">0.56</td>

            <td class="px-3 py-2 border-b border-gray-700">60.22</td>

            <td class="px-3 py-2 border-b border-gray-700">32.70</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">16.84</td>

            <td class="px-3 py-2 border-b border-gray-700">57.53</td>

            <td class="px-3 py-2 border-b border-gray-700">0.92</td>

            <td class="px-3 py-2 border-b border-gray-700">0.57</td>

            <td class="px-3 py-2 border-b border-gray-700">66.16</td>

            <td class="px-3 py-2 border-b border-gray-700">34.42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">21.56</td>

            <td class="px-3 py-2 border-b border-gray-700">153.94</td>

            <td class="px-3 py-2 border-b border-gray-700">1.00</td>

            <td class="px-3 py-2 border-b border-gray-700">0.60</td>

            <td class="px-3 py-2 border-b border-gray-700">72.35</td>

            <td class="px-3 py-2 border-b border-gray-700">36.14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">27.76</td>

            <td class="px-3 py-2 border-b border-gray-700">497.75</td>

            <td class="px-3 py-2 border-b border-gray-700">1.10</td>

            <td class="px-3 py-2 border-b border-gray-700">0.64</td>

            <td class="px-3 py-2 border-b border-gray-700">78.78</td>

            <td class="px-3 py-2 border-b border-gray-700">37.85</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Metrics comparing Spartan and Spartan-AIR. Spartan denotes spartan with grand-product check using [GKR08,Tha13], and Spartan AIR denotes spartan with grand-product check using the AoK from Appendix 5.3. The ratio of sparsity to constraints in the R1CS matrices is maintained to two.</p>

    <p class="text-gray-300">We concretely compare the performance of our AoK, GPR-AIR for grand-product check (Protocol 5) with the proof system for grand-product check from [GKR08,Tha13] in Table 4, Appendix H. We employ multilinear KZG to commit to the witness in latter. For vectors of length  <span class="math">2^{20}</span> , the prover of GKR is  <span class="math">2.2\\mathrm{x}</span>  faster compared to GPR-AIR, whereas the verifier of GPR-AIR is  <span class="math">1.32\\mathrm{x}</span>  faster compared to GKR. As noted before the proof size of GKR grows poly-logarithmically and is  <span class="math">27\\mathrm{KB}</span>  at vector lengths of  <span class="math">2^{20}</span> , whereas the proof size of GPR-AIR is a constant at  <span class="math">0.94\\mathrm{KB}</span> .</p>

    <p class="text-gray-300">In Table 4, we compare the performance of Spartan with grand-product check done using GKR, and Spartan with grand-product check done using GPR-AIR. We call the latter version of Spartan, as Spartan-AIR (also see Section 5.3). The Extended R1CS instance for the simulation is generated similar to <em>[x21]</em>. We remark that since GPR-AIR requires univariate commitments to the witness, such an integration is only possible with a DualPCS like KZG-FFT-FOURIER. For constraints equal to <span class="math">2^{17}</span> Spartan-AIR trades off prover time to get 1.7x better verifier time and at least 2x improvement in proof size.</p>

    <h2 id="sec-37" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">The first author is supported in part by IBM Global University Program Academic Award and Rising Star Award, Intel Corporation.</p>

    <h2 id="sec-38" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABC^{+}22] Diego F. Aranha, Emil Madsen Bennedsen, Matteo Campanelli, Chaya Ganesh, Claudio Orlandi, and Akira Takahashi. ECLIPSE: Enhanced compiling method for pedersen-committed zkSNARK engines. In Goichiro Hanaoka, Junji Shikata, and Yohei Watanabe, editors, PKC 2022, Part I, volume 13177 of LNCS, pages 584–614. Springer, Heidelberg, March 2022.</li>

      <li>[AFG^{+}10] Masayuki Abe, Georg Fuchsbauer, Jens Groth, Kristiyan Haralambiev, and Miyako Ohkubo. Structure-preserving signatures and commitments to group elements. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 209–236. Springer, Heidelberg, August 2010.</li>

      <li>[AST24] Arasu Arun, Srinath T. V. Setty, and Justin Thaler. Jolt: Snarks for virtual machines via lookups. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part VI, volume 14656 of Lecture Notes in Computer Science, pages 3–33. Springer, 2024.</li>

      <li>[BCG^{+}18] Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune K. Jakobsen, and Mary Maller. Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part I, volume 11272 of LNCS, pages 595–626. Springer, Heidelberg, December 2018.</li>

      <li>[BCHO22] Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orrù. Gemini: Elastic SNARKs for diverse environments. In Orr Dunkelman and Stefan Dziembowski, editors, EUROCRYPT 2022, Part II, volume 13276 of LNCS, pages 427–457. Springer, Heidelberg, May / June 2022.</li>

      <li>[CFF^{+}21] Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaïs Querol, and Hadrián Rodríguez. Lunar: A toolbox for more efficient universal and updatable zkSNARKs and commit-and-prove extensions. In Mehdi Tibouchi and Huaxiong Wang, editors, ASIACRYPT 2021, Part III, volume 13092 of LNCS, pages 3–33. Springer, Heidelberg, December 2021.</li>

      <li>[CFG24] Matteo Campanelli, Dario Fiore, and Rosario Gennaro. Natively compatible super-efficient lookup arguments and how to apply them. Cryptology ePrint Archive, Paper 2024/1058, 2024. https://eprint.iacr.org/2024/1058.</li>

      <li>[CFQ19] Matteo Campanelli, Dario Fiore, and Anaïs Querol. LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2075–2092. ACM Press, November 2019.</li>

      <li>[EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon. cq: Cached quotients for fast lookups. Cryptology ePrint Archive, Paper 2022/1763, 2022. https://eprint.iacr.org/2022/1763.</li>

      <li>[FKL18] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 33–62. Springer, Heidelberg, August 2018.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>[GKM^{+}18] Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. Updatable and universal common reference strings with applications to zk-SNARKs. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 698–728. Springer, Heidelberg, August 2018.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In Richard E. Ladner and Cynthia Dwork, editors, 40th ACM STOC, pages 113–122. ACM Press, May 2008.</li>

      <li>[GMR85] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In 17th ACM STOC, pages 291–304. ACM Press, May 1985.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GW20. Ariel Gabizon and Zachary J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Paper 2020/315, 2020. https://eprint.iacr.org/2020/315.</li>

      <li>GWC19. Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Paper 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>KST22. Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part IV, volume 13510 of LNCS, pages 359–388. Springer, Heidelberg, August 2022.</li>

      <li>KT23. Tohru Kohrita and Patrick Towa. Zeromorph: Zero-knowledge multilinear-evaluation proofs from homomorphic univariate commitments. Cryptology ePrint Archive, Paper 2023/917, 2023. https://eprint.iacr.org/2023/917.</li>

      <li>KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010.</li>

      <li>Lee21. Jonathan Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. In Kobbi Nissim and Brent Waters, editors, TCC 2021, Part II, volume 13043 of LNCS, pages 1–34. Springer, Heidelberg, November 2021.</li>

      <li>MBKM19. Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, November 2019.</li>

      <li>PST13a. Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. Signatures of correct computation. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 222–242. Springer, Heidelberg, March 2013.</li>

      <li>PST13b. Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. Signatures of correct computation. In Amit Sahai, editor, Theory of Cryptography - 10th Theory of Cryptography Conference, TCC 2013, Tokyo, Japan, March 3-6, 2013. Proceedings, volume 7785 of Lecture Notes in Computer Science, pages 222–242. Springer, 2013.</li>

      <li>Set20. Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Heidelberg, August 2020.</li>

      <li>SL20. Srinath Setty and Jonathan Lee. Quarks: Quadruple-efficient transparent zksnarks. Cryptology ePrint Archive, Paper 2020/1275, 2020. https://eprint.iacr.org/2020/1275.</li>

      <li>STW24. Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Unlocking the lookup singularity with lasso. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part VI, volume 14656 of Lecture Notes in Computer Science, pages 180–209. Springer, 2024.</li>

      <li>Tha13. Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 71–89. Springer, Heidelberg, August 2013.</li>

      <li>Whi. Barry Whitehat. Lookup singularity.</li>

      <li>WTS^{+}18. Riad S Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zksnarks without trusted setup. In 2018 IEEE Symposium on Security and Privacy (SP), pages 926–943. IEEE, 2018.</li>

      <li>ZBK^{+}22. Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. Caulk: Lookup arguments in sublinear time. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, CCS 2022, Los Angeles, CA, USA, November 7-11, 2022, pages 3121–3134. ACM, 2022.</li>

      <li>ZGK^{+}22. Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, and Carla Råfols. Baloo: Nearly optimal lookup arguments. Cryptology ePrint Archive, Paper 2022/1565, 2022. https://eprint.iacr.org/2022/1565.</li>

    </ul>

    <p class="text-gray-300">A General Approach to derive Linking Soundness</p>

    <p class="text-gray-300">We borrow notation from Section 5. Specifically let <span class="math">\\mathbf{a}\\in\\mathbb{F}^{D}</span>, and let <span class="math">f\\in\\mathbb{F}_{&lt;D}[Y]</span> such that it agrees with <span class="math">\\mathbf{a}</span> over <span class="math">\\mathbf{H}_{D}</span>. Further, let <span class="math">C_{f}</span> and <span class="math">C_{\\mathbf{a}}</span> be commitments to <span class="math">f(Y)</span>, and <span class="math">\\tilde{a}(\\mathbf{X})</span> respectively using some univariate and multilinear PCS respectively. In a concurrent work <em>[x10]</em>, the authors propose a degree three sum-check protocol to establish the linear relationship between the witnesses underlying <span class="math">C_{\\tilde{a}}</span> and <span class="math">C_{f}</span>. This gives a generic way to design DualPCS using any pair of univariate and multilinear commitment schemes where the above argument from <em>[x10]</em> can be used to provide the linking proof. It is important to note here that this linking proof requires at least one evaluation proof opening each for the underlying multilinear and univariate commitment schemes (three multilinear openings if batching is not allowed). The protocol additionally requires preprocessed commits to vectors <span class="math">\\{\\omega_{i}^{j}\\}_{j\\in[0,D-1]}</span> for all <span class="math">i\\in[0,D-1]</span> and <span class="math">D&lt;N</span>. Here, <span class="math">D</span> is a power of two less than <span class="math">N</span>.</p>

    <p class="text-gray-300">This approach is fundamentally similar to our dory-link DualPCS where we prove linear relations over AFG commited witnesses but is more general and is efficient owing to the use of sum-check protocol. The above technique though is significantly different from the techniques used in KZG-FFT-FOURIER, where there is no requirement for a linking proof, and the commitments to both the MLE and the univariate representation is the same, that is, <span class="math">C_{\\mathbf{a}}=C_{f}</span>. This reduces the verifier run-time and proof-complexity for the KZG-FFT-FOURIER DualPCS. In contrast, when a DualPCS is instantiated generically as stated above, the linking proof from <em>[x10]</em> additionally requires: prover-verifier costs for the above sum-check, and the prover-verifier costs for opening the multilinear and the univariate polynomials at the end of the sum-check protocol. The verifier complexity for the sum-check is <span class="math">O(\\log D)</span>, whereas additional evaluation proofs in the case of KZG, Gemini, PST, and Zeromorph increases the number of pairings performed by the verifier. A concrete implementation comparison between such a generic approach and KZG-FFT-Fourier is an interesting future work.</p>

    <h2 id="sec-39" class="text-2xl font-bold">Appendix B Updatable SRS Model</h2>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Updatable SRS setting.</h5>

    <p class="text-gray-300">In the updatable setting, Setup consists of the following: PPT algorithms setup, update_setup, and verify_setup:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{srs},\\rho)\\leftarrow\\mathsf{setup}(1^{\\lambda})</span> takes a security parameter <span class="math">\\lambda</span> and outputs a SRS <span class="math">\\mathsf{srs}</span>, and and correctness proof <span class="math">\\rho</span>.</li>

      <li><span class="math">(\\mathsf{srs}^{\\prime},\\rho^{\\prime})\\leftarrow\\mathsf{update\\_setup}(1^{\\lambda},\\mathsf{srs},\\{\\rho_{i}\\}_{i=1}^{n})</span> takes as input the security parameter <span class="math">\\lambda</span>, a SRS <span class="math">\\mathsf{srs}</span>, a list of update proofs and outputs an updated srs together with a proof of correct update.</li>

      <li><span class="math">b\\leftarrow\\mathsf{verify\\_setup}(1^{\\lambda},\\mathsf{srs},\\{\\rho_{i}\\}_{i=1}^{n})</span> takes the security parameter <span class="math">\\lambda</span>, a SRS <span class="math">\\mathsf{srs}</span>, a list of update proofs, and outputs a bit indicating acceptance or not.</li>

    </ul>

    <p class="text-gray-300">Knowledge soundness of a non-interactive argument system (setup, update_setup, verify_setup, <span class="math">\\mathcal{P},\\mathcal{V}</span>) in the updatable SRS setting is defined as follows.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 1 (Updatable knowledge soundness <em>[x24]</em>).</h6>

    <p class="text-gray-300">An argument system for a relation <span class="math">\\mathcal{R}</span> is updatable knowledge-sound if for all PPT algorithms <span class="math">\\mathcal{A}</span>, there exists an extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> such that the advantage <span class="math">\\mathsf{Adv}_{KS}</span> is negligible in <span class="math">\\lambda</span>, where <span class="math">\\mathsf{Adv}_{KS}=\\Pr\\left(\\mathsf{UPD}\\text{-}\\mathsf{KS}_{\\mathcal{A},\\mathcal{E}_{\\mathcal{A}}}(\\lambda)\\right)</span> denotes the advantage of <span class="math">\\mathcal{A}</span> in the game defined in Figure 1.</p>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix C Univariate PCS KZG-FFT</h2>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">C.1 Updatability of the SRS in KZG-FFT</h3>

    <p class="text-gray-300">In this section, we show that the setup of KZG-FFT is updatable as defined in Definition 3.3, <em>[x24]</em>. To this end we state the update_setup, and verify_setup in Algorithms 3, and 4 respectively. KZG-FFT.update _setup in Algorithm 3, takes as input the bilinear group <span class="math">\\{(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\ \\mathbb{G}_{T},e,g_{1},g_{2})</span> and <span class="math">\\mathsf{srs}</span>, <span class="math">\\{\\pi_{i}\\}_{i\\in[0,\\ell]}\\}</span>, and outputs a new structured reference string <span class="math">\\mathsf{srs}^{\\prime}</span>, and appends a proof <span class="math">\\pi_{\\ell+1}</span> to the list of existing proofs <span class="math">\\{\\pi_{i}\\}_{i\\in[0,\\ell]}</span>. KZG-FFT.verify_setup in Algorithm 4, takes as input <span class="math">\\{(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\ \\mathbb{G}_{T},e,g_{1},g_{2}),\\mathsf{srs}</span>, <span class="math">\\{\\pi_{i}\\}_{i\\in[0,\\ell]}\\}</span> and outputs either accept or reject depending on whether the <span class="math">\\mathsf{srs}</span> is correctly formed. We prove the correctness of the update_setup, and verify_setup algorithms in Lemmas 4, and 5 respectively.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Updatable Knowledge Soundness</p>

    <p class="text-gray-300">Algorithm 3 KZG-FFT.update_setup: Updating Setup for KZG-FFT Input:  <span class="math">\\{(p,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,g_1,g_2)\\mathrm{srs},\\{\\pi_i\\}_{i\\in [0,r]}\\}</span> Output:  <span class="math">\\{\\mathrm{srs}&#x27;,\\{\\pi_i\\}_{i\\in [0,\\ell +1]}\\}</span> 1: Read  <span class="math">\\pi_{i}</span>  as  <span class="math">(u_{1,i},u_{2,i})\\in (\\mathbb{G}_1,\\mathbb{G}_2)</span>  for  <span class="math">i\\in [0,\\ell ]</span> <span class="math">\\mathrm{srs}_{\\mathcal{P}} = \\{h_{1,i}^{(n)}\\mid i\\in [0,N - 1]\\}</span>  , and  <span class="math">\\mathrm{srs}_{\\mathcal{V}} = \\{h_{2,j}\\mid j\\in [0,n]\\}</span> 2: Let  <span class="math">\\mathbf{h}_1\\in \\mathbb{G}_1^N</span>  be such that the  <span class="math">i</span>  -th component of  <span class="math">\\mathbf{h}_1</span>  is  <span class="math">h_{1,i}^{(n)}</span> 3: Compute  <span class="math">\\widehat{\\mathbf{h}}_1 = M_{\\omega_N}\\cdot \\mathbf{h}_1</span> 4: Sample  <span class="math">r_{\\ell +1}\\in \\mathbb{F}</span>  , uniformly at random. 5: for  <span class="math">i\\in [0,N - 1]</span>  do 6: Let  <span class="math">\\widehat{h}_{1,i} = (\\widehat{h}_{1,i})^{r_{\\ell +1}}</span> 7: end for 8: Let  <span class="math">\\widehat{\\mathbf{h}}_1\\in \\mathbb{G}_1^N</span>  be such that the  <span class="math">i</span>  -th component of  <span class="math">\\widehat{\\mathbf{h}}_1</span>  is  <span class="math">\\widehat{h}_{1,i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9: Let  <span class="math">\\mathbf{h}_1&#x27; = \\frac{1}{N} M_{\\omega_N^{-1}}\\cdot \\widehat{\\mathbf{h}}_1</span>  , and  $\\mathrm{srs}_{\\mathcal{P}}' = \\{h_{1,i}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i\\in [0,N - 1]\\}<span class="math">  . Here  </span>h_{1,i}'<span class="math">  is the  </span>i<span class="math">  -th component of  </span>\\mathbf{h}_1'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">10: Let  <span class="math">\\mathrm{srs}_{\\mathcal{V}}&#x27; = \\{h_{2,j}^{2j + 1}\\in \\mathbb{G}_2\\mid j\\in [0,n]\\}</span> 11:  <span class="math">\\pi_{\\ell +1} = (g_1^{r_{\\ell +1}},u_{2,\\ell}^{r_{\\ell +1}})</span> 12: Output  <span class="math">\\{\\mathrm{srs}&#x27; = (\\mathrm{srs}_{\\mathcal{P}}&#x27;,\\mathrm{srs}_{\\mathcal{V}}&#x27;),\\{\\pi_i\\}_{i\\in [0,\\ell +1]}\\}</span></p>

    <p class="text-gray-300">Lemma 4. Let the inputs to update_setup be as in Algorithm 3. Let  <span class="math">\\mathsf{srs}_{\\mathcal{P}} = \\{h_{1,i}^{(n)}\\}_{i\\in [0,n - 1]}</span> ,  <span class="math">\\mathsf{srs}_{\\mathcal{V}} = \\{h_{2,j}\\}_{j\\in [0,n]}</span> , and  <span class="math">\\pi_i = (u_{1,i},u_{2,i})</span>  for  <span class="math">i\\in [0,\\ell ]</span> . Suppose there is an  <span class="math">r\\in \\mathbb{F}</span>  such that a)  <span class="math">h_{1,i}^{(n)} = g_1^{\\alpha_i}</span> , where  <span class="math">\\alpha_{i} = N^{-1}\\cdot \\prod_{j\\in [0,n - 1]}(1 + (\\omega_{N}^{-i}\\cdot r)^{2^{j}})</span>  for  <span class="math">i\\in [0,N - 1]</span> , b)  <span class="math">h_{2,j} = g_2^{r^{2^j}}</span>  for  <span class="math">j\\in [0,n]</span> , and c)  <span class="math">u_{2,\\ell} = g_2^r</span> . Then Algorithm 3, outputs  <span class="math">\\mathsf{srs}&#x27;</span>  and  <span class="math">\\pi_{\\ell +1}</span>  such that a)  <span class="math">h_{1,i}&#x27; = g_1^{\\alpha_i&#x27;}</span> , where  <span class="math">\\alpha_{i}&#x27; = N^{-1}\\cdot \\prod_{j\\in [0,n - 1]}(1 + (\\omega_{N}^{-i}\\cdot r\\cdot r_{\\ell +1})^{2^j})</span>  for  <span class="math">i\\in [0,N - 1]</span> , b)  <span class="math">h_{2,j} = g_2^{(r\\cdot r_{\\ell +1})^{2^j}}</span>  for  <span class="math">j\\in [0,n]</span> , and c)  <span class="math">u_{2,\\ell} = g_2^{r\\cdot r_{\\ell +1}}</span> .</p>

    <p class="text-gray-300">Proof. At Step 3, the  <span class="math">i</span> -th component of  <span class="math">\\widehat{\\mathbf{h}}_1</span> , denoted  <span class="math">\\widehat{h}_{1,i}</span> , is equal to  <span class="math">\\prod_{j = [0,N - 1]}(h_{1,i}^{(n)})^{\\omega_N^{i,j}}</span> . From the supposition, Fact 2, and Claim 1, it follows that there exists  <span class="math">r\\in \\mathbb{F}</span>  such that  <span class="math">\\widehat{h}_{1,i} = g_1^{(r\\cdot r_{\\ell +1})^i}</span>  for  <span class="math">i\\in [0,N - 1]</span> . Hence, at Step 9,  <span class="math">h_{1,i}&#x27; = g_1^{\\alpha_i&#x27;}</span> , where  <span class="math">\\alpha_{i}&#x27; = N^{-1}\\cdot \\prod_{j\\in [0,n - 1]}(1 + (\\omega_{N}^{-i}\\cdot r\\cdot r_{\\ell +1})^{2^j})</span>  for  <span class="math">i\\in [0,N - 1]</span> . Points (b) and (c) follow easily from the construction.</p>

    <p class="text-gray-300">We note that since  <span class="math">M_{\\omega_N}</span>  is the FFT matrix of size  <span class="math">N</span> , the recursive decomposition of the FFT matrix can be exploited to compute  <span class="math">\\widehat{\\mathbf{h}}_1</span>  using  <span class="math">N \\log N</span>  group additions and  <span class="math">N \\log N</span>  group exponentiations. Similarly  <span class="math">\\mathbf{h}_1&#x27;</span>  can be computed at Step 9 using  <span class="math">N \\log N</span>  group additions and  <span class="math">N \\log N + N</span>  group exponentiations.</p>

    <p class="text-gray-300">Lemma 5. Let the inputs to verify_setup be as in Algorithm 4. Let  <span class="math">\\mathsf{srs}_{\\mathcal{P}} = \\{h_{1,i}^{(n)}\\}_{i\\in [0,n - 1]}</span> ,  <span class="math">\\mathsf{srs}_{\\mathcal{V}} = \\{h_{2,j}\\}_{j\\in [0,n]}</span> , and  <span class="math">\\pi_i = (u_{1,i},u_{2,i})</span>  for  <span class="math">i\\in [0,\\ell ]</span> . Then if verify_setup outputs accept then there is an  <span class="math">r\\in \\mathbb{F}</span>  such that a)  <span class="math">h_{1,i}^{(n)} = g_1^{\\alpha_i}</span> , where  <span class="math">\\alpha_{i} = N^{-1}\\cdot \\prod_{j\\in [0,n - 1]}(1 + (\\omega_{N}^{-i}\\cdot r)^{2^{j}})</span>  for  <span class="math">i\\in [0,N - 1]</span> , b)  <span class="math">h_{2,j} = g_2^{r^{2^j}}</span>  for  <span class="math">j\\in [0,n]</span> , and c)  <span class="math">u_{2,\\ell} = g_2^r</span> .</p>

    <p class="text-gray-300">Proof. At Step 3, if verify_setup accepts there is an  <span class="math">r_0 \\in \\mathbb{F}_p</span>  such that  <span class="math">u_{1,0} = g_1^{r_0}</span>  and  <span class="math">u_{2,0} = g_2^{r_0}</span> . At Step 6, if verify_setup accepts there is an  <span class="math">r_i \\in \\mathbb{F}_p</span>  such that  <span class="math">u_{1,i} = g_1^{r_i}</span>  and  <span class="math">u_{2,i} = g_2^{\\prod_{j=0}^i r_j}</span> , for  <span class="math">i \\in [1,\\ell]</span> . In particular, if verify_setup accepts at Step 6 for all  <span class="math">i \\in [1,\\ell]</span> , then  <span class="math">u_{2,\\ell} = g_2^{\\prod_{j=0}^i r_j}</span> . Let  <span class="math">r = \\prod_{j=0}^\\ell r_i</span> ,  <span class="math">u_2 = g_2^r</span> . At Step 13, if verify_setup accepts then for all  <span class="math">i \\in [0,N-1]</span> ,  <span class="math">h_{1,i}&#x27; = g_1^r</span> . From Fact 2, and Claim 1, this implies  <span class="math">h_{1,i}^{(n)} = g_1^{\\alpha_i}</span> , where  <span class="math">\\alpha_i = N^{-1} \\cdot \\prod_{j \\in [0,n-1]} (1 + (\\omega_N^{-i} \\cdot r)^{2^j})</span>  for  <span class="math">i \\in [0,N-1]</span> . Similarly, if verify_setup accepts at Step 21, then  <span class="math">h_{2,j} = g_2^{r^{2^j}}</span>  for  <span class="math">j \\in [0,n]</span> .</p>

    <p class="text-gray-300">Completeness follows from the discussion in Section 3.2. We first prove KZG-FFT.commit satisfies commitment binding, and then prove knowledge soundness.</p>

    <p class="text-gray-300">Commitment Binding: Suppose KZG-FFT.commit does not satisfy commitment binding in the bilinear group  <span class="math">(p,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,g_1,g_2)\\gets_R\\mathcal{G}(1^\\lambda)</span> . Then there exists an adversary  <span class="math">\\mathcal{A}</span>  that on input (srs)  <span class="math">\\leftarrow_{R}</span>  KZG-FFT_setup( <span class="math">\\lambda</span> ), outputs  <span class="math">(f_0(\\mathbf{H}_{D_0}),f_1(\\mathbf{H}_{D_1}))</span>  with a probability non-negligible in  <span class="math">\\lambda</span> , satisfying:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_0\\in \\mathbb{F}_{&amp;lt;  D_0}[Y],f_1\\in \\mathbb{F}_{&amp;lt;  D_1}[Y]</span>  and  <span class="math">f_{0}(Y)\\neq f_{1}(Y)</span></li>

      <li><span class="math">C = \\mathsf{KZG - FFT.commit}(\\mathsf{srs}_{\\mathcal{P}},D_0,f_0(\\mathbf{H}_{D_0})) = \\mathsf{KZG - FFT.commit}(\\mathsf{srs}_{\\mathcal{P}},D_1,f_1(\\mathbf{H}_{D_1}))</span></li>

    </ol>

    <p class="text-gray-300">We show that in this case an adversary  <span class="math">\\mathcal{A}&#x27;</span>  can be constructed that when given input a)  <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, g_1, g_2) \\gets_R \\mathcal{G}(1^\\lambda)</span>  and b)  <span class="math">\\mathsf{srs}&#x27; = \\{(\\mathsf{srs}_{\\mathcal{P}}&#x27;, \\mathsf{srs}_{\\mathcal{V}})\\}</span> , where  <span class="math">\\mathsf{srs}_{\\mathcal{P}}&#x27; = \\{g_1^{r^i}\\}_{i \\in [0, N-1]}</span>  for some  <span class="math">r \\in_R \\mathbb{F}</span> , and  <span class="math">\\mathsf{srs}_{\\mathcal{V}} = \\{g_2^{r^{2^j}}\\}_{j \\in [0, n]}</span> .  <span class="math">\\mathcal{A}&#x27;</span>  outputs the secret random value  <span class="math">r</span>  with a probability non-negligible in  <span class="math">\\lambda</span> , thereby breaking  <span class="math">N</span> -DLOG assumption. Here, we remark that  <span class="math">\\mathsf{srs}_{\\mathcal{P}}&#x27;</span>  is different from  <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span> , and is as in the  <span class="math">N</span> -DLOG challenge (see Definition 3).  <span class="math">\\mathcal{A}&#x27;</span>  first computes  <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span>  (where  <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span>  is as defined in Algorithm 1). From Claim 1, we have that  <span class="math">\\alpha = \\frac{1}{N} M_{\\omega_N^{-1}} \\cdot \\mathbf{r}</span> . Hence, the  <span class="math">i</span> -th element of  <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span>  can be computed by taking MSME with group base elements being  <span class="math">\\mathsf{srs}_{\\mathcal{P}}&#x27;</span>  and the scalars being the  <span class="math">i</span> -th row of  <span class="math">\\frac{1}{N} M_{\\omega_N^{-1}}</span> . In particular,  <span class="math">\\mathsf{srs}_{\\mathcal{P}}</span>  can be computed from  <span class="math">\\mathsf{srs}_{\\mathcal{P}}&#x27;</span>  using at most  <span class="math">N^2</span>  exponentiations and additions over the group  <span class="math">\\mathbb{G}_1</span> .  <span class="math">\\mathcal{A}&#x27;</span>  lets  <span class="math">\\mathsf{srs} = \\{(\\mathsf{srs}_{\\mathcal{P}}, \\mathsf{srs}_{\\mathcal{V}})\\}</span> , and calls  <span class="math">\\mathcal{A}</span>  on input  <span class="math">\\{(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, g_1, g_2), \\mathsf{srs}\\}</span> .  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">(f_0(\\mathbf{H}_{D_0}), f_1(\\mathbf{H}_{D_2}))</span>  satisfying the two properties stated above. Let  <span class="math">D = \\max(D_0, D_1)</span> . By interpolating and evaluating the lower degree polynomial,  <span class="math">\\mathcal{A}&#x27;</span>  can compute  <span class="math">f_0(\\mathbf{H}_D), f_1(\\mathbf{H}_D)</span> . Let  <span class="math">d = \\log D</span> , and let  <span class="math">\\mathbf{a}_0</span>  and  <span class="math">\\mathbf{a}_1</span>  agree with  <span class="math">f_0(\\mathbf{H}_D)</span>  and  <span class="math">f_1(\\mathbf{H}_D)</span> . Since  <span class="math">f_0(Y) \\neq f_1(Y)</span> , we have  <span class="math">\\mathbf{a}_0 \\neq \\mathbf{a}_1</span> , and  <span class="math">\\mathbf{a}_0 - \\mathbf{a}_1 \\neq \\mathbf{0}</span> ,</p>

    <p class="text-gray-300">Algorithm 4 KZG-FFT.verify_setup: Verify Setup for KZG-FFT Input:  <span class="math">\\{(p,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,g_1,g_2),\\mathbf{srs},\\{\\pi_i\\}_{i\\in [0,r]}\\}</span> Output: {accept/reject} 1: Read  <span class="math">\\pi_{i}</span>  as  <span class="math">(u_{1,i},u_{2,i})\\in (\\mathbb{G}_1,\\mathbb{G}_2)</span>  for  <span class="math">i\\in [0,\\ell ]</span> 2: if  <span class="math">e(u_{1,0},g_2)\\neq e(g_1,u_{2,0})</span>  then 3: Output reject 4: end if 5: for  <span class="math">i\\in [1,\\ell ]</span>  do 6: if  <span class="math">e(u_{1,i},u_{2,i - 1})\\neq e(g_1,u_{2,i})</span>  then 7: Output reject 8: end if 9: end for 10: Let  <span class="math">\\mathbf{h}_1\\in \\mathbb{G}_1^N</span>  be such that the  <span class="math">i</span>  -th component of  <span class="math">\\mathbf{h}_1</span>  is  <span class="math">h_{1,i}^{(n)}</span>  . Let  <span class="math">\\mathbf{h}_1^{\\prime} = M_{\\omega_N}\\cdot \\mathbf{h}_1</span> 11: Check  <span class="math">h_{1,0}^{\\prime} = g_{1}</span> 12: for  <span class="math">i\\in [1,N - 1]</span>  do 13: if  <span class="math">e(h_{1,i}^{\\prime},g_2)\\neq e(h_{1,i - 1}^{\\prime},u_{2,\\ell})</span>  then 14: Output reject 15: end if 16: end for 17: if  <span class="math">h_{2,0}\\neq u_{2,\\ell}</span>  then 18: Output reject 19: end if 20: for  <span class="math">j\\in [0,n - 1]</span>  do 21: if  <span class="math">e(h_{1,2i}^{\\prime},h_{2,j})\\neq e(g_1,h_{2,j + 1})</span>  then 22: Output reject 23: end if 24: end for 25: Output accept</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{0}</span>  is the zero vector in  <span class="math">\\mathbb{F}^D</span> . Let  <span class="math">\\mathbf{b} = \\mathbf{a}_0 - \\mathbf{a}_1</span> ,  <span class="math">\\mathbf{f}&#x27; = (\\frac{1}{D} M_{\\omega_D^{-1}})\\cdot \\mathbf{b}</span> , and  <span class="math">f&#x27; \\in \\mathbb{F}_{&amp;lt; D}[Y]</span>  be the polynomial whose coefficient corresponding to  <span class="math">Y^i</span>  is  <span class="math">f_i&#x27;</span>  for  <span class="math">i \\in [0, D-1]</span> . We show in Lemma 6 below that  <span class="math">r^{2^{n-d}}</span>  is a root of  <span class="math">f&#x27;(Y)</span> .</p>

    <p class="text-gray-300">Lemma 6. Let  <span class="math">f&#x27; \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>  be as defined above, and  <span class="math">r \\in \\mathbb{F}</span>  be the random point used to generate  <span class="math">\\mathbf{srs}&#x27;</span> . Then  <span class="math">f&#x27;(r^{2^{n-d}}) = 0</span> .</p>

    <p class="text-gray-300">Proof. From the definition of KZG-FFT.commit we have</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {i \\in [ 0, D - 1 ]} (h _ {1, i} ^ {(d)}) ^ {a _ {0, i}} = \\prod_ {i \\in [ 0, D - 1 ]} (h _ {1, i} ^ {(d)}) ^ {a _ {1, i}}</span></div>

    <p class="text-gray-300">Multiplying by the inverse (over  <span class="math">\\mathbb{G}_1</span> ) of the RHS in the above equation on both sides we have</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {i \\in [ 0, D - 1 ]} \\left(h _ {1, i} ^ {(d)}\\right) ^ {b _ {i}} = \\prod_ {i \\in [ 0, d D - 1 ]} \\left(h _ {1, i} ^ {(d)}\\right) ^ {0} \\tag {21}</span></div>

    <p class="text-gray-300">Let  <span class="math">\\alpha^{(\\mathbf{d})}</span>  be such that  <span class="math">g_1^{\\alpha^{(d)}} = h_{1,i}^{(d)}</span>  for  <span class="math">i\\in [0,D - 1]</span> , and  <span class="math">\\mathbf{r}^{(d)}\\in \\mathbb{F}^D</span>  be such that  <span class="math">r_i^{(d)} = r^{i\\cdot 2^{n - d}}</span>  for  <span class="math">i\\in [0,D - 1]</span> . From Equation 21,  <span class="math">\\langle \\alpha^{(\\mathbf{d})},\\mathbf{b}\\rangle = 0</span> . Further from Claim 2,  <span class="math">(\\mathbf{r}^{(d)})^T\\cdot (\\frac{1}{D} M_{\\omega_D^{-1}}) = \\alpha^{(d)}</span> . This implies</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {r} ^ {(d)}\\right) ^ {T} \\cdot \\left(\\frac {1}{D} M _ {\\omega_ {D} ^ {- 1}}\\right) \\cdot \\mathbf {b} = 0 \\tag {22}</span></div>

    <p class="text-gray-300">From the definition of  <span class="math">\\mathbf{f}&#x27;</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {f} ^ {\\prime} = \\left(\\frac {1}{D} M _ {\\omega_ {D} ^ {- 1}}\\right) \\cdot \\mathbf {b}</span></div>

    <p class="text-gray-300">Since the coefficient of  <span class="math">Y^{i}</span>  in  <span class="math">f^{\\prime}(Y)</span>  is  <span class="math">f_{i}^{\\prime}</span>  for  <span class="math">i\\in [0,D - 1]</span> , from Equation 22, it follows that  <span class="math">r^{2^{n - d}}</span>  is a root of  <span class="math">f^{\\prime}</span> .</p>

    <p class="text-gray-300">It is well-known how to efficiently compute  <span class="math">r</span> , given a polynomial  <span class="math">f&#x27;(Y) \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>  such that  <span class="math">r^{2^{n-d}}</span>  is a root of  <span class="math">f&#x27;(Y)</span> . We note this as a claim below, as we reuse it in knowledge soundness argument.</p>

    <p class="text-gray-300">Claim 12. There is a <span class="math">D^{O(1)}</span> time algorithm that takes as input the coefficients of a polynomial <span class="math">f&#x27;(Y) \\in \\mathbb{F}_{&amp;lt;D}[Y]</span> such that <span class="math">r^{2^{n-d}}</span> is a root of <span class="math">f&#x27;(Y)</span>, and outputs <span class="math">r</span>.</p>

    <p class="text-gray-300">Proof. The algorithm employs root finding algorithm over <span class="math">\\mathbb{F}</span> to find <span class="math">r^{2^{n-d}}</span>, and then employs square-root finding algorithm over <span class="math">\\mathbb{F}</span> recursively to find <span class="math">r</span>.</p>

    <p class="text-gray-300">Knowledge Soundness. We show that KZG-FFT.eval(srs, <span class="math">C_f, D, u, v</span>; <span class="math">f(\\mathbf{H}_D)</span>) is knowledge sound for the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{\\left(\\mathsf{srs}, \\left(C_f, D, u, v\\right)\\right); f \\left(\\mathbf{H}_D\\right) \\mid f \\in \\mathbb{F}_{&amp;lt;D}[Y], f(u) = v, \\right. \\\\ \\left. \\quad \\text{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}}, D, f(\\mathbf{H}_D)) = C_f \\right\\} \\end{array}</span></div>

    <p class="text-gray-300">where the srs is updatable by the adversary. Let <span class="math">\\tilde{P}_{\\mathrm{eval}}</span> be the algebraic adversary that has access to an oracle as stated in Definition 3.3 [MBKM19]. Given input <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, g_1, g_2) \\gets \\mathsf{Gen}(1^\\lambda)</span> and an initial structured reference string <span class="math">\\perp</span> (corresponding to degree <span class="math">N</span> polynomials), let <span class="math">\\tilde{P}_{\\mathrm{eval}}</span> output <span class="math">(\\mathsf{srs}, C_f, D)</span>, and an <span class="math">\\mathbf{a} \\in \\mathbb{F}^N</span> satisfying a) <span class="math">C_f = \\prod_{i \\in [0, N-1]} (h_{1,i}^{(n)})^{a_i}</span>, b) In <span class="math">\\langle P_{\\mathrm{eval}}, V_{\\mathrm{eval}} \\rangle(\\mathsf{srs}, C_f, d, u, v; \\mathbf{a}_f)</span>, where <span class="math">u \\in_R \\mathbb{F}</span>, <span class="math">V_{\\mathrm{eval}}</span> accepts with probability <span class="math">\\epsilon</span> non-negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Here we note that <span class="math">\\perp</span> is the trivial string corresponding to <span class="math">r = 0</span>, and <span class="math">\\tilde{P}_{\\mathrm{eval}}</span> uses the oracle to update it to srs, and <span class="math">V_{\\mathrm{eval}}</span> rejects if <span class="math">\\mathsf{srs} = \\perp</span>. The oracle ensures that srs is well-formed, that is, there is an <span class="math">r \\in \\mathbb{F}</span> such that <span class="math">\\mathsf{srs}_{\\mathcal{P}} = \\{g_1^{\\alpha_i} \\mid \\alpha_i = N^{-1} \\cdot \\prod_{j \\in [0, n-1]} (1 + (\\omega_N^{-i} \\cdot r)^{2^j})</span> for <span class="math">i \\in [0, N-1]\\}</span>, and <span class="math">\\mathsf{srs}_{\\mathcal{V}} = \\{g_2^{\\omega_{2^j}} \\mid j \\in [0, n]\\}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}</span> be the extractor with oracle access to an algebraic prover <span class="math">\\tilde{P}_{\\mathrm{eval}}</span>. <span class="math">\\mathcal{E}</span> invokes <span class="math">\\tilde{P}_{\\mathrm{eval}}</span> to receive <span class="math">(\\mathsf{srs}, C_f, D, u, v)</span>, and a representation <span class="math">\\mathbf{a} \\in \\mathbb{F}^N</span> satisfying the above two conditions, where <span class="math">u \\in_R \\mathbb{F}</span>. The extractor <span class="math">\\mathcal{E}</span> queries <span class="math">\\tilde{P}_{\\mathrm{eval}}</span> at <span class="math">(\\mathsf{srs}, C_f, D, u, v)</span> and with probability <span class="math">\\epsilon</span> obtains <span class="math">C_q</span> and a representation <span class="math">\\mathbf{b} \\in \\mathbb{F}^N</span> such that a) <span class="math">C_q = \\prod_{i \\in [0, N-1]} (h_{1,i}^{(n)})^{b_i}</span>, and b) <span class="math">e(C_f \\cdot g_1^{-v}, g_2) = e(C_q, h_2^{(d)} \\cdot g_2^{-u})</span>. We prove the following claim which helps us in proving degree bound on <span class="math">f</span> and <span class="math">q</span>.</p>

    <p class="text-gray-300">Claim 13. Let <span class="math">\\mathbf{a} \\in \\mathbb{F}^N</span> and <span class="math">C = \\prod_{i \\in [0, N-1]} (h_{1,i}^{(n)})^{a_i}</span>. There exists <span class="math">k \\in [0, n]</span> such that <span class="math">a_i = a_{i+j \\cdot 2^k}</span> for <span class="math">i \\in [0, 2^k - 1]</span> and <span class="math">j \\in [0, 2^{n-k} - 1]</span> if and only if there exists <span class="math">f_{&amp;lt;2^k}&#x27;[Y]</span> such that <span class="math">C = \\text{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}}, k, f(\\mathbf{H}_{2^k}))</span>.</p>

    <p class="text-gray-300">Proof. Its follows from the definition of KZG-FFT.commit, that</p>

    <div class="my-4 text-center"><span class="math-block">C = \\prod_{i \\in [0, 2^k - 1]} \\left(\\prod_{j \\in [0, 2^{n-k} - 1]} \\left(h_{1, i + j \\cdot 2^k}\\right)\\right)^{a_i} = \\prod_{i \\in [0, 2^k - 1]} \\left(h_{1,i}^{(k)}\\right)^{a_i}</span></div>

    <p class="text-gray-300">In the above equality, we have used that <span class="math">h_{1,i}^{(k)} = \\prod_{j \\in [0,2^{n-k}-1]} h_{1,i+j \\cdot 2^k}</span>. Let <span class="math">f(\\mathbf{H}_{2^k})</span> be such that <span class="math">f(\\mathbf{H}_{2^k})_i = a_i</span> for <span class="math">i \\in [0,2^k - 1]</span>. It follows that <span class="math">f&#x27; \\in \\mathbb{F}_{&amp;lt;2^k}[Y]</span> is such that <span class="math">C = \\text{KZG-FFT.commit}(\\mathsf{srs}_{\\mathcal{P}}, k, f(\\mathbf{H}_{2^k}))</span>.</p>

    <p class="text-gray-300">From the above claim and Lemma 1, it follows that there exists <span class="math">k_1, k_2 \\in [0, n]</span> such that <span class="math">f&#x27; \\in \\mathbb{F}_{&amp;lt;2^{k_1}}[Y]</span>, <span class="math">q&#x27; \\in \\mathbb{F}_{&amp;lt;2^{k_2}}[Y]</span>, <span class="math">C_f = g_1^{f&#x27;(r^{2^{n-k_1}})}</span> and <span class="math">C_q = g_1^{q&#x27;(r^{2^{n-k_2}})}</span>. Knowledge soundness of the protocol would follow from the following lemma.</p>

    <p class="text-gray-300">Lemma 7. Suppose <span class="math">k_1, k_2 \\in [0, n]</span> such that <span class="math">f&#x27; \\in \\mathbb{F}_{&amp;lt;2^{k_1}}[Y]</span>, <span class="math">q&#x27; \\in \\mathbb{F}_{&amp;lt;2^{k_2}}[Y]</span>, <span class="math">C_f = g_1^{f&#x27;(r^{2^{n-k_1}})}</span> and <span class="math">C_q = g_1^{q&#x27;(r^{2^{n-k_2}})}</span>. Then only one of the following holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">2^{k_1} \\leq D</span> and there exists <span class="math">q&#x27;&#x27; \\in \\mathbb{F}_{&amp;lt;D}[Y]</span> such that <span class="math">f&#x27;(Y^{2^{d - k_1}}) - v = (Y - u)q&#x27;&#x27;(Y)</span></li>

      <li><span class="math">N \\geq 2^{k_1} &amp;gt; D</span> and <span class="math">Y^{2^{k_1 - d}} - u</span> divides <span class="math">f&#x27;(Y) - v</span>.</li>

    </ol>

    <p class="text-gray-300">Proof. We prove the lemma using a case analysis. In each of the case either <span class="math">f&#x27;(Y)</span> and <span class="math">q&#x27;(Y)</span> satisfy the statement of the lemma or <span class="math">r</span> is a root of a polynomial known to <span class="math">\\tilde{P}_{\\mathrm{eval}}</span>. From Claim 12, it follows that if <span class="math">r</span> is a root of a polynomial known to <span class="math">\\tilde{P}_{\\mathrm{eval}}</span> then <span class="math">\\tilde{P}_{\\mathrm{eval}}</span> can compute <span class="math">r</span> efficiently, and hence break the <span class="math">N</span>-DLOG assumption. Hence, in our analysis we assume <span class="math">r</span> is not the root of the polynomial that arises in each of the cases.</p>

    <p class="text-gray-300">Case a: <span class="math">2^{k_1} \\leq D, 2^{k_2} \\leq D</span>. This implies <span class="math">n - k_1 \\geq n - d</span>, and <span class="math">n - k_2 \\geq n - d</span>. Assume <span class="math">n - k_1 \\geq n - k_2</span>; the other case can be handled similarly. In this case it must be that either i) <span class="math">f&#x27;(Y^{2^{d - k_1}}) - v = (Y - u) \\cdot q&#x27;(Y^{2^{d - k_2}})</span> or ii) <span class="math">r</span> is a root of <span class="math">f&#x27;(Y^{2^{d - k_1}}) - v - (Y - u) \\cdot q&#x27;(Y^{2^{d - k_2}})</span>. Letting <span class="math">q&#x27;&#x27;(Y) = q&#x27;(Y^{2^{d - k_2}})</span>, we have <span class="math">f&#x27;(Y^{2^{d - k_1}}) - v = (Y - u)q&#x27;&#x27;(Y)</span>.</p>

    <p class="text-gray-300">Case b: <span class="math">2^{k_{1}} \\leq D, 2^{k_{2}} &amp;gt; D</span>. In this case it must be that either i) <span class="math">f&#x27;(Y^{2^{k_{2} - k_{1}}}) - v = (Y^{2^{k_{2} - d}} - u) \\cdot q&#x27;(Y)</span> or ii) <span class="math">r</span> is a root of <span class="math">f&#x27;(Y^{2^{k_{2} - k_{1}}}) - v - (Y^{2^{k_{2} - d}} - u) \\cdot q&#x27;(Y)</span>. If</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(Y^{2^{k_{2} - k_{1}}}) - v = (Y^{2^{k_{2} - d}} - u) \\cdot q&#x27;(Y) \\tag{23}</span></div>

    <p class="text-gray-300">then we show that there exists <span class="math">q&#x27;&#x27;(Y)</span> such that <span class="math">q&#x27;(Y) = q&#x27;&#x27;(Y^{2^{k_2 - d}})</span>. Let <span class="math">\\gamma = k_{2} - k_{1}</span>, and <span class="math">\\delta = k_{2} - d</span>, and note that <span class="math">\\gamma - \\delta = d - k_{1} \\geq 0</span>. Using polynomial division, we know there exists <span class="math">r \\in \\mathbb{F}</span> and <span class="math">q&#x27; \\in \\mathbb{F}_{&lt;n}[y]</span> <span class="math">f&#x27;(y^{2^{\\gamma=&quot;&quot; such=&quot;&quot; that=&quot;&quot;&gt;r} = (Y - u)q&#x27;&#x27;(Y) + r</span> \\tag{24}</p>

    <p class="text-gray-300">Since <span class="math">r \\in \\mathbb{F}</span>, substituting <span class="math">Y</span> as <span class="math">Y^{2^{\\delta}}</span> in the above equation, we have</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(Y^{2^{\\gamma}}) = (Y^{2^{\\delta}} - u) q&#x27;&#x27;(Y^{2^{\\delta}}) + r \\tag{25}</span></div>

    <p class="text-gray-300">From Equations 23, and 25, we have <span class="math">(Y^{2^{\\delta}} - u)q&#x27;(Y) = (Y^{2^{\\delta}} - u)q&#x27;&#x27;(Y^{2^{\\delta}}) + r</span>. This implies <span class="math">Y^{2^{\\delta}} - u</span> divides <span class="math">r</span>, and as <span class="math">r = 0</span>, <span class="math">q&#x27;(Y) = q&#x27;&#x27;(Y^{2^{\\delta}})</span>. Hence, Equation 23, can be rewritten as</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(Y^{2^{\\gamma - \\delta}}) - v = (Y - u) \\cdot q&#x27;&#x27;(Y)</span></div>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(Y^{2^{d - k_1}}) - v = (Y - u) \\cdot q&#x27;&#x27;(Y)</span></div>

    <p class="text-gray-300">Case c: <span class="math">2^{k_1} &amp;gt; D, 2^{k_1} \\geq 2^{k_2}</span>. In this case it must be that either i) <span class="math">f&#x27;(Y) - v = (Y^{2^{k_1 - d}} - u) \\cdot q&#x27;(Y^{2^{k_1 - k_2}})</span> or ii) <span class="math">r</span> is a root of <span class="math">f&#x27;(Y) - v = (Y^{2^{k_1 - d}} - u) \\cdot q&#x27;(Y^{2^{k_1 - k_2}})</span>. This implies <span class="math">Y^{2^{k_1 - d}} - u</span> divides <span class="math">f&#x27;(Y) - v</span>.</p>

    <p class="text-gray-300">Case d: <span class="math">2^{k_1} &amp;gt; D, 2^{k_1} &amp;lt; 2^{k_2}</span>. In this case it must be that either i) <span class="math">f&#x27;(Y^{2^{k_2 - k_1}}) - v = (Y^{2^{k_2 - d}} - u) \\cdot q&#x27;(Y)</span> or ii) <span class="math">r</span> is a root of <span class="math">f&#x27;(Y^{2^{k_2 - k_1}}) - v - (Y^{2^{k_2 - d}} - u) \\cdot q&#x27;(Y)</span>. If</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(Y^{2^{k_{2} - k_{1}}}) - v = (Y^{2^{k_{2} - d}} - u) \\cdot q&#x27;(Y) \\tag{26}</span></div>

    <p class="text-gray-300">then we show that there exists <span class="math">q&#x27;&#x27;(Y)</span> such that <span class="math">q&#x27;(Y) = q&#x27;&#x27;(2^{k_2 - k_1})</span>. Let <span class="math">\\gamma = k_{2} - k_{1}</span>, and <span class="math">\\delta = k_{2} - d</span>, and note that, <span class="math">\\delta - \\gamma = k_{1} - d &amp;gt; 0</span>. Using polynomial division, we know there exists <span class="math">r \\in \\mathbb{F}_{&amp;lt;2^{\\delta - \\gamma}}</span> and <span class="math">q&#x27;&#x27; \\in \\mathbb{F}_{&lt;n}[y]</span> <span class="math">f&#x27;(y)=&quot;\\frac{(Y^{2^{\\delta&quot; </span>q''(y)}="\\frac{(Y^{2^{\\delta" <span class="math">q&#x27;&#x27;(y)}=&quot;&quot; (27)=&quot;&quot; 2^{k_1}=&quot;&quot; 2^{k_2}=&quot;&quot; 2^{k_2}=&quot;&quot; 2^{k_1}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}}}{2^{k_2}}}="" 2^{k_2}}{2^{k_1}}}{2^{k_2}}}="" 2^{k_2}}{2^{k_1}}}{2^{k_2}}}="" 2^{k_2}}{2^{k_1}}}{2^{k_2}}}="" 2^{k_2}}{2^{k_1}}}{2^{k_2}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}}}.</span>="" 2^{k_2}}{2^{k_1}}}.<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}{2^{k_1}})</span>="" 2^{k_2}}{2^{k_1}})<span class="math">=&quot;&quot; 2^{k_2}}=&quot;&quot; 2^{k_2}})</span>="" 2^{k_2}})<span class="math">=&quot;&quot; 2^{k_2}})</span>="" 2^{k_2}})<span class="math">=&quot;&quot; 2^{k_2}})</span>="" 2^{k_2}})<span class="math">=&quot;&quot; 2^{k_2}})</span>="" 2^{k_2}})<span class="math">=&quot;&quot; 2^{k_2}})</span>="" 2^{k_2}})<span class="math">=&quot;&quot; 2^{k_2}})</span>="" 2^{k_2}})<span class="math">=&quot;&quot; 2^{k_2}})</span>="" 2^{k_2}})$</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{&lt;D}[Y]</span> such that</p>

    <p class="text-gray-300"><span class="math">(Y^{2^{k_{1}-d}}-u^{\\prime})\\cdot q_{1}^{\\prime}(Y)+v_{1}^{\\prime}</span> <span class="math">=(Y^{2^{k_{1}-d}}-u^{\\prime})\\cdot q_{2}^{\\prime}(Y)+v_{2}^{\\prime}</span> <span class="math">(Y^{2^{k_{1}-d}}-u^{\\prime})\\cdot q_{1}^{\\prime}(Y)</span> <span class="math">=(Y^{2^{k_{1}-d}}-u^{\\prime})\\cdot q_{2}^{\\prime}(Y)+v_{2}^{\\prime}-v_{1}^{\\prime}</span></p>

    <p class="text-gray-300">We subtract <span class="math">v_{1}^{\\prime}</span> from both sides to obtain the above equation. Since <span class="math">(Y^{2^{k_{1}-d}}-u^{\\prime})</span> divides LHS of the above equation, we have <span class="math">v_{1}^{\\prime}=v_{2}^{\\prime}</span>. Next, we argue for every <span class="math">(u_{1}^{\\prime},v_{1}^{\\prime})\\in S</span> and <span class="math">(u_{2}^{\\prime},v_{2}^{\\prime})\\in S</span>, <span class="math">v_{1}^{\\prime}=v_{2}^{\\prime}</span>. If <span class="math">(u_{1}^{\\prime},v_{1}^{\\prime})\\in S</span> and <span class="math">(u_{2}^{\\prime},v_{2}^{\\prime})\\in S</span> then there exists <span class="math">q_{1}^{\\prime}\\in\\mathbb{F}_{&lt;D}[Y]</span> and <span class="math">q_{2}^{\\prime}\\in\\mathbb{F}_{&lt;D}[Y]</span> such that</p>

    <p class="text-gray-300"><span class="math">(Y^{2^{k_{1}-d}}-u_{1}^{\\prime})\\cdot q_{1}^{\\prime}(Y)+v_{1}^{\\prime}</span> <span class="math">=(Y^{2^{k_{1}-d}}-u_{2}^{\\prime})\\cdot q_{2}^{\\prime}(Y)+v_{2}^{\\prime}</span> (28)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">k_{1}-d&gt;d</span> then by observing the degree of the polynomials on LHS and RHS in the above equation we have <span class="math">q_{1}^{\\prime}(Y)=q_{2}^{\\prime}(Y)</span>, <span class="math">u_{1}^{\\prime}=u_{2}^{\\prime}</span> and <span class="math">v_{1}^{\\prime}=v_{2}^{\\prime}</span>. In fact in this case $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">. Suppose </span>k_{1}-d\\leq d<span class="math">. Then from polynomial division there exists </span>q_{2}^{\\prime\\prime}(Y)\\in\\mathbb{F}_{2^{d-(k_{1}-d)}}[Y]<span class="math"> and </span>r(Y)\\in\\mathbb{F}_{<2^{k_{1}-d}}[Y]<span class="math"> such that </span>q_{2}^{\\prime}(Y)=(Y^{2^{k_{1}-d}}-u_{1}^{\\prime})\\cdot q_{2}^{\\prime\\prime}(Y)+r(y)<span class="math">. Substituting </span>q_{2}^{\\prime}(Y)$ in Equation 28</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(Y^{2^{k_{1}-d}}-u_{1}^{\\prime})\\cdot(q_{1}^{\\prime}(Y)-(Y^{2^{k_{1}-d}}-u_{2}^{\\prime})\\cdot q_{2}^{\\prime\\prime}(Y))+v_{1}^{\\prime}</span> <span class="math">=(Y^{2^{k_{1}-d}}-u_{2}^{\\prime})\\cdot r(Y)+v_{2}^{\\prime}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since degree <span class="math">r(Y)</span> is less than <span class="math">2^{k_{1}-d}</span>, again observing the degree of the polynomials on LHS and RHS in the above equation we have either a) <span class="math">r(Y)=0</span>, <span class="math">q_{1}^{\\prime}(Y)=(Y^{2^{k_{1}-d}}-u_{2}^{\\prime})\\cdot q_{2}^{\\prime\\prime}(Y)</span>, and <span class="math">v_{1}^{\\prime}=v_{2}^{\\prime}</span>, or b) <span class="math">r(Y)=0</span>, <span class="math">q_{1}^{\\prime}(Y)=(Y^{2^{k_{1}-d}}-u_{2}^{\\prime})\\cdot q_{2}^{\\prime\\prime}(Y)</span>, <span class="math">u_{1}^{\\prime}=u_{2}^{\\prime}</span> and <span class="math">v_{1}^{\\prime}=v_{2}^{\\prime}</span>. The argument above shows that all tuples in <span class="math">S</span> have the same second element. Let <span class="math">S=\\{(u_{j},v)\\}_{j\\in[S]}</span>. Then for all $j\\in[1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, </span>Y^{2^{d_{1}-k}}-u_{j}<span class="math"> divides </span>f^{\\prime}(Y)-v<span class="math">. Since degree of </span>f^{\\prime}(Y)<span class="math"> is at most </span>2_{1}^{k}<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{2^{k_{1}}}{2^{k_{1}-d}}=2^{d}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-45" class="text-2xl font-bold">Appendix D Multilinear PCS KZG-FOURIER</h2>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">D.1 Proofs of Claims and Lemma from Section 4.1</h3>

    <p class="text-gray-300">Before we proceed, we state a following well-known fact regarding FFT domain, and its offset.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Fact 4</h6>

    <p class="text-gray-300">For <span class="math">z</span> in the offset of the FFT domain of size <span class="math">N</span>, <span class="math">\\prod_{i\\in[0,N-1]}(z-\\omega_{2N}^{i})\\neq 0</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Claim 5</h6>

    <p class="text-gray-300">(restated): <span class="math">U_{i}^{(n)}=\\frac{1}{N}\\cdot\\prod_{j\\in[0,n-1]}(1+(\\omega_{N}^{-i}\\cdot Y)^{2^{j}})</span></p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The <span class="math">i</span>-th component of <span class="math">\\frac{1}{N}\\cdot M_{\\omega_{N}^{-1}}\\cdot Y</span> is equal to</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\ell=0}^{N-1}\\frac{1}{N}\\cdot(\\omega_{N}^{-i}\\cdot Y)^{\\ell}=\\frac{1}{N}\\cdot\\prod_{j\\in[0,n-1]}(1+(\\omega_{N}^{-i}\\cdot Y)^{2^{j}})</span></p>

    <p class="text-gray-300">In the above equation, we use the tensor structure of <span class="math">(1,Y,\\ldots,Y^{N-1})=\\otimes_{i\\in[0,n-1]}(1,Y^{2^{i}})</span>, where <span class="math">n=\\log N</span>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Claim 6</h6>

    <p class="text-gray-300">(restated): <span class="math">\\mathcal{U}_{n}(1)=1</span></p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider the summation <span class="math">\\sum_{i\\in[0,N-1]}L_{i}(X_{0},\\ldots,X_{n-1})=1</span>. Consequently, we have <span class="math">\\mathcal{U}_{n}(1)=\\mathcal{U}_{n}(\\sum_{i\\in[0,N-1]}L_{i}(X_{0},\\ldots,X_{n-1}))</span>. By leveraging linearity and the definition of <span class="math">\\mathcal{U}_{n}</span>, we establish <span class="math">\\mathcal{U}_{n}(1)=\\sum_{i\\in[0,N-1]}U_{i}</span>. Moving forward with the definition of <span class="math">\\mathbf{U}^{(n)}</span>, it ensues that:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[0,N-1]}U_{i}^{(n)}=\\mathbf{1}^{T}\\cdot(\\frac{1}{N}M_{\\omega_{N}^{-1}}\\cdot\\mathbf{Y})</span></p>

    <p class="text-gray-300">Here, <span class="math">\\mathbf{1}</span> denotes the vector of all ones. The claim is substantiated by observing:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{1}^{T}\\cdot(\\frac{1}{N}M_{\\omega_{N}^{-1}})=(1,0,\\ldots,0)</span></p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Claim 7</h6>

    <p class="text-gray-300">(restated): <span class="math">\\mathcal{U}_{n}(L_{i}^{(d)})=\\mathcal{U}_{n}(L_{i}^{(d+1)})+\\mathcal{U}_{n}(L_{i+D}^{(d+1)})</span> for <span class="math">d\\in[1,n-1]</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof relies on the linearity of <span class="math">\\mathcal{U}_{n}</span>, and the observation that <span class="math">L_{i}^{(d)}=L_{i}^{(d+1)}+L_{i+D}^{(d+1)}</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Lemma 2</h6>

    <p class="text-gray-300">(restated): <span class="math">\\mathcal{U}_{n}(L_{i}^{(d)})=U_{i}^{(d)}(Y^{2^{n-d}})</span>, holds for <span class="math">d\\in[1,n]</span>. Moreover, for <span class="math">f\\in\\mathbb{F}_{\\leq 1}[X_{0},\\ldots,X_{d-1}]</span>, <span class="math">\\{f_{L_{i}^{(d)}}\\in\\mathbb{F}\\}_{i\\in[0,D-1]}</span> represents the Fourier coefficients of <span class="math">f</span> if and only if there exists a <span class="math">g\\in\\mathbb{F}_{&lt;D}[Y]</span> such that <span class="math">\\mathcal{U}_{n}(f)=g(Y^{2^{n-d}})</span> and <span class="math">g(\\omega_{D}^{i})=f_{L_{i}^{(d)}}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Proof. For <span class="math">d = n</span>, the relationship follows directly from the definition of <span class="math">\\mathcal{U}_n</span>. To establish <span class="math">\\mathcal{U}_n(L_i^{(d)}) = U_i^{(d)}(Y^{2^{n - d}})</span> we proceed by assuming <span class="math">\\mathcal{U}_n(L_i^{(d + 1)}) = U_i^{(d + 1)}(Y^{2^{n - d - 1}})</span>, for <span class="math">d\\in [1,n - 1]</span>. It follows from Claim 7 that <span class="math">\\mathcal{U}_n(L_i^{(d)}) = \\mathcal{U}_n(L_i^{(d + 1)}) + \\mathcal{U}_n(L_{i + D}^{(d + 1)})</span> for <span class="math">i\\in [0,D - 1]</span>. Moreover, the definition of <span class="math">U_{i}^{(d + 1)}</span> imply Equations 29 and 30 for <span class="math">i\\in [0,D - 1]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {U} _ {n} \\left(L _ {i} ^ {(d + 1)}\\right) = \\frac {1}{2 D} \\cdot \\sum_ {j = 0} ^ {2 D - 1} \\left(\\omega_ {2 D} ^ {- i} \\cdot Y ^ {2 ^ {n - d - 1}}\\right) ^ {j} \\tag {29}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {U} _ {n} \\left(L _ {i + D} ^ {(d + 1)}\\right) = \\frac {1}{2 D} \\sum_ {j = 0} ^ {2 D - 1} \\left(\\omega_ {2 D} ^ {- i - D} \\cdot Y ^ {2 ^ {n - d - 1}}\\right) ^ {j} \\tag {30} \\\\ = \\frac {1}{2 D} \\sum_ {j = 0} ^ {2 D - 1} \\left(- \\omega_ {2 D} ^ {- i} \\cdot Y ^ {2 ^ {n - d - 1}}\\right) ^ {j} \\tag {31} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">(32)</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = \\frac {1}{2 D} \\left(\\sum_ {j = 2 k, k \\in [ 0, D - 1 ]} \\left(\\omega_ {2 D} ^ {- i} \\cdot Y ^ {2 ^ {n - d - 1}}\\right) ^ {j} \\right. \\tag {33} \\\\ + \\sum_ {j = 2 k + 1, k \\in [ 0, D - 1 ]} - \\left(\\omega_ {2 D} ^ {- i} \\cdot Y ^ {2 ^ {n - d - 1}}\\right) ^ {j}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Equation 31 above is inferred using <span class="math">\\omega_{2D}^{-D} = -1</span>. The equation below can be obtained by adding Equations 29, and 33</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathcal {U} _ {n} \\left(L _ {i} ^ {(d + 1)}\\right) + \\mathcal {U} _ {n} \\left(L _ {i + D} ^ {(d + 1)}\\right) \\\\ = \\frac {1}{D} \\sum_ {k \\in [ 0, D - 1 ]} \\left(\\omega_ {2 D} ^ {- 2 i} Y ^ {2 ^ {n - d}}\\right) ^ {k} \\\\ = \\frac {1}{D} \\sum_ {k \\in [ 0, D - 1 ]} \\left(\\omega_ {D} ^ {- i} Y ^ {2 ^ {n - d}}\\right) ^ {k} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This proves <span class="math">\\mathcal{U}_n(L_i^{(d)}) = U_i^{(d)}(Y^{2^{n - d}})</span>, for <span class="math">d\\in [1,n]</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">f(X_0, \\ldots, X_{d-1}) = \\sum_{i \\in [0, D-1]} f_{L_i^{(d)}} \\cdot L_i^{(d)}</span>. By the linearity of <span class="math">\\mathcal{U}_n</span> we can express <span class="math">\\mathcal{U}_n(f) = \\sum_{i \\in [0, D-1]} f_{L_i^{(d)}} \\cdot U_i^{(d)}(Y^{2^{n-d}})</span>. Let <span class="math">g(Y) = \\sum_{i \\in [0, D-1]} f_{L_i^{(d)}} \\cdot U_i^{(d)}(Y)</span>. Then <span class="math">\\mathcal{U}_n(f) = g(Y^{2^{n-d}})</span>, where <span class="math">g(Y) \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>. Additionally, considering Claim 5, and recognizing that <span class="math">M_{\\omega_D}</span> and <span class="math">\\frac{1}{D} \\cdot M_{\\omega_D^{-1}}</span> are matrix inverses of each other, we deduce that <span class="math">g(\\omega_D^i) = f_{L_i^{(d)}}</span> for <span class="math">i \\in [0, D-1]</span>. Conversely, given any <span class="math">g(Y) \\in \\mathbb{F}_{&amp;lt;D}[Y]</span>, we can define an <span class="math">f \\in \\mathbb{F}[X_0, \\ldots, X_{d-1}]</span> such that its <span class="math">D</span> Fourier coefficients are specified as follows: <span class="math">f_{L_i^{(d)}} = g(\\omega_D^i)</span>. Since <span class="math">g</span> is uniquely determined by its evaluations <span class="math">g(\\omega_D^i)_{i \\in [0, D-1]}</span>, we conclude using similar arguments as above that <span class="math">\\mathcal{U}_n(f) = g(Y^{2^{n-d}})</span>.</p>

    <p class="text-gray-300">Lemma 3 (restated): For <span class="math">d \\in [1, n-1]</span>, <span class="math">f \\in \\mathbb{F}_{\\leq 1}[X_0, \\ldots, X_{d-1}]</span> if and only if there exists <span class="math">\\psi_f \\in \\mathbb{F}_{&amp;lt;D}[Y]</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {U} _ {n} (X _ {d} \\cdot f) = \\psi_ {f} (Y ^ {2 ^ {n - d - 1}}) \\cdot \\prod_ {j \\in [ 0, D - 1 ]} (Y ^ {2 ^ {n - d - 1}} - \\omega_ {2 D} ^ {j})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {U} _ {n} ((1 - X _ {d}) \\cdot f) = \\psi_ {f} (- Y ^ {2 ^ {n - d - 1}}) \\cdot \\prod_ {j \\in [ 0, D - 1 ]} (Y ^ {2 ^ {n - d - 1}} + \\omega_ {2 D} ^ {j})</span></div>

    <p class="text-gray-300">Proof. Let <span class="math">f_{L_i^{(d)}}</span>, <span class="math">i \\in [0, D-1]</span> represent the Fourier coefficients of <span class="math">f</span>. Then the Fourier coefficient of <span class="math">X_d \\cdot f</span> corresponding to the basis <span class="math">L_i^{(d+1)}</span> is 0 for <span class="math">i \\in [0, D-1]</span>, and <span class="math">f_{L_i^{(d)}}</span> for <span class="math">i \\in [D, 2D-1]</span>. As established in Lemma 2, there exists <span class="math">\\psi_1(Y) \\in \\mathbb{F}_{&amp;lt;2D}[Y]</span> such that <span class="math">\\mathcal{U}_n(X_d \\cdot f) = \\psi_1(Y^{2^{n-d-1}})</span>. Moreover, <span class="math">\\psi_1(\\omega_{2D}^i) = 0</span> for <span class="math">i \\in [0, D-1]</span>, and <span class="math">\\psi_1(\\omega_{2D}^{i+D}) = f_{L_i^{(d)}}</span> for <span class="math">i \\in [0, D-1]</span>. This implies the existence of <span class="math">\\psi_f \\in \\mathbb{F}_{&amp;lt;D}[Y]</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {1} (Y) = \\psi_ {f} (Y) \\cdot \\prod_ {j \\in [ 0, D - 1 ]} \\left(Y - \\omega_ {2 D} ^ {j}\\right) \\tag {34}</span></div>

    <p class="text-gray-300">Similarly, the Fourier coefficient of <span class="math">(1 - X_d) \\cdot f</span> corresponding to the basis <span class="math">L_i^{(d + 1)}</span> is <span class="math">f_{L_i^{(d)}}</span> for <span class="math">i \\in [0, D - 1]</span>, and 0 for <span class="math">i \\in [D, 2D - 1]</span>. Hence, again as established in Lemma 2, there exists</p>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300"><span class="math">\\psi_{2}(Y)\\in\\mathbb{F}_{&lt;2D}[Y]</span> such that <span class="math">\\mathcal{U}_{n}((1-X_{d})\\cdot f)=\\psi_{2}(Y^{2^{n-d-1}}).</span> Further, <span class="math">\\psi_{2}(\\omega^{i}_{2D})=f_{L_{i}^{(d)}}</span> for <span class="math">i\\in[0,D-1]</span>, and <span class="math">\\psi_{2}(\\omega^{i}_{2D})=0</span> for <span class="math">i\\in[D,2D-1]</span>. This implies the existence of <span class="math">\\psi^{\\prime}_{f}\\in\\mathbb{F}_{&lt;D}[Y]</span> such that</p>

    <p class="text-gray-300"><span class="math">\\psi_{2}(Y)</span> <span class="math">=\\psi^{\\prime}_{f}(Y)\\cdot\\prod_{j\\in[D,2D-1]}(Y-\\omega^{j}_{2D})</span> <span class="math">=\\psi^{\\prime}_{f}(Y)\\cdot\\prod_{j\\in[0,D-1]}(Y+\\omega^{j}_{2D})</span> (35)</p>

    <p class="text-gray-300">To derive Equation 35, observe that <span class="math">\\omega^{j+D}_{2D}=-\\omega^{j}_{2D}</span> for <span class="math">j\\in[0,D-1]</span>. Finally, we prove that <span class="math">\\psi^{\\prime}_{f}(Y)=\\psi_{f}(-Y)</span>, which will complete the proof. Observe that <span class="math">\\psi_{1}(\\omega^{i+D}_{2D})=\\psi_{1}(-\\omega^{i}_{2D})=\\psi_{2}(\\omega^{i}_{2D})</span>, for <span class="math">i\\in[0,D-1]</span>. Substituting this in Equations 34 and 35 we have for <span class="math">i\\in[0,D-1]</span></p>

    <p class="text-gray-300"><span class="math">\\psi_{f}(-\\omega^{i}_{2D})\\cdot\\prod_{j\\in[0,D-1]}(-\\omega^{i}_{2D}-\\omega^{j}_{2D})=</span> <span class="math">\\psi^{\\prime}_{f}(\\omega^{i}_{2D})\\cdot\\prod_{j\\in[0,D-1]}(\\omega^{i}_{2D}+\\omega^{j}_{2D})</span> (36)</p>

    <p class="text-gray-300">Since <span class="math">d\\geq 1</span>, <span class="math">D</span> is even and</p>

    <p class="text-gray-300"><span class="math">\\prod_{j\\in[0,D-1]}(-\\omega^{i}_{2D}-\\omega^{j}_{2D})=\\prod_{j\\in[0,D-1]}(\\omega^{i}_{2D}+\\omega^{j}_{2D})</span></p>

    <p class="text-gray-300">Hence, <span class="math">\\psi^{\\prime}_{f}(\\omega^{i}_{2D})=\\psi_{f}(-\\omega^{i}_{2D})</span> for <span class="math">i\\in[D,2D-1]</span>. As <span class="math">\\psi^{\\prime}_{f}</span> and <span class="math">\\psi_{f}</span> are degree at most <span class="math">D</span> univariate polynomials, it follows that <span class="math">\\psi^{\\prime}_{f}(Y)=\\psi_{f}(-Y)</span>. The above argument also shows that corresponding to any <span class="math">\\psi\\in\\mathbb{F}_{&lt;D}[Y]</span>, if <span class="math">f\\in\\mathbb{F}_{\\leq 1}[X_{0},\\ldots,X_{d-1}]</span> is defined such that</p>

    <p class="text-gray-300"><span class="math">f_{L_{i}^{(d)}}=\\psi(\\omega^{i+D}_{2D})\\cdot\\prod_{j\\in[0,D-1]}(\\omega^{i+D}_{2D}-\\omega^{j}_{2D})</span></p>

    <p class="text-gray-300">for <span class="math">i\\in[0,D-1]</span> then</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{n}(X_{d}\\cdot f)=\\psi(Y^{2^{n-d-1}})\\cdot\\prod_{j\\in[0,D-1]}(Y^{2^{n-d-1}}-\\omega^{j}_{2D})</span> <span class="math">\\mathcal{U}_{n}((1-X_{d})\\cdot f)=\\psi(-Y^{2^{n-d-1}})\\cdot\\prod_{j\\in[0,D-1]}(Y^{2^{n-d-1}}+\\omega^{j}_{2D})</span></p>

    <p class="text-gray-300">Claim 8 (restated): Let <span class="math">\\psi\\in\\mathbb{F}_{&lt;D}[Y]</span>. Then there exists <span class="math">\\psi_{o},\\psi_{e}\\in\\mathbb{F}_{&lt;2^{d-1}}[Y]</span> such that <span class="math">\\psi(Y)=\\psi_{e}(Y^{2})+Y\\cdot\\psi_{o}(Y^{2})</span>, and <span class="math">\\psi(-Y)=\\psi_{e}(Y^{2})-Y\\cdot\\psi_{e}(Y^{2})</span>. Further,</p>

    <p class="text-gray-300"><span class="math">\\psi_{e}(\\omega^{i}_{2^{d-1}})=\\frac{\\psi(\\omega^{i}_{D})+\\psi(-\\omega^{i}_{D})}{2}\\quad\\ \\forall i\\in[0,2^{d-1}-1]</span> <span class="math">\\psi_{o}(\\omega^{i}_{2^{d-1}})=\\frac{\\psi(\\omega^{i}_{D})-\\psi(-\\omega^{i}_{D})}{2\\omega^{i}_{D}}\\quad\\ \\forall i\\in[0,2^{d-1}-1]</span></p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It is easy to see that there exists <span class="math">\\psi_{o},\\psi_{e}\\in\\mathbb{F}_{&lt;2^{d-1}}[Y]</span> such that <span class="math">\\psi(Y)=\\psi_{e}(Y^{2})+Y\\cdot\\psi_{o}(Y^{2})</span>, and <span class="math">\\psi(-Y)=\\psi_{e}(Y^{2})-Y\\cdot\\psi_{e}(Y^{2})</span>. Hence, for <span class="math">i\\in[0,2^{d-1}-1]</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\psi(\\omega^{i}_{D})</span> <span class="math">=\\psi_{e}(\\omega^{i}_{2^{d-1}})+\\omega^{i}_{D}\\cdot\\psi_{o}(\\omega^{i}_{2^{d-1}})</span> <span class="math">\\psi(-\\omega^{i}_{D})</span> <span class="math">=\\psi_{e}(\\omega^{i}_{2^{d-1}})-\\omega^{i}_{D}\\cdot\\psi_{o}(\\omega^{i}_{2^{d-1}})</span></p>

    <p class="text-gray-300">In the above equations, we have used that <span class="math">\\omega^{2i}_{D}=\\omega^{i}_{2^{d-1}}</span>. Adding the above equations and dividing by <span class="math">2</span>, we have the expression for <span class="math">\\psi_{e}</span>. Similarly, subtracting the second equation from the first equation and dividing the expression by <span class="math">2</span>, we have the expression for <span class="math">\\psi_{o}</span>.</p>

    <p class="text-gray-300">We make an additional claim here that notes down the computation required to compute the commits at Step 3a of Protocol 2.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Claim 14.</h6>

    <p class="text-gray-300">Let <span class="math">f\\in\\mathbb{F}_{\\leq 1}[X_{0},\\ldots,X_{d-1}]</span>, <span class="math">\\psi_{f}(Y)</span> corresponds to <span class="math">f</span> as in Lemma 3, and <span class="math">\\psi_{f,e}(Y)</span> and <span class="math">\\psi_{f,o}(Y)</span> correspond to <span class="math">\\psi_{f}(Y)</span> as in Claim 8. There is an algorithm that takes as input the <span class="math">D</span> Fourier coefficients of <span class="math">f</span>, and the evaluations of <span class="math">\\prod_{i\\in[0,D-1]}(Y-\\omega^{i}_{2D})</span> over the offset FFT domain of size <span class="math">D</span>, and outputs the evaluations of <span class="math">\\psi_{f,e}(Y)</span> and <span class="math">\\psi_{f,o}(Y)</span> over the FFT domain of size <span class="math">D</span>. The algorithm performs <span class="math">O(D)</span> <span class="math">\\mathbb{F}</span>-divisions and additions and <span class="math">6</span>-FFT’s of the following domain sizes: 1 of <span class="math">2D</span>, <span class="math">1</span> of <span class="math">D</span>, <span class="math">2</span> of <span class="math">D/2</span>, and <span class="math">2</span> of <span class="math">N</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Recall, from the proof of Lemma 3, <span class="math">\\psi_{1}\\in\\mathbb{F}_{&lt;D}[Y]</span> such that <span class="math">\\psi_{1}(\\omega^{i}_{2D})=0</span> for <span class="math">i\\in[0,D-1]</span>, and <span class="math">\\psi_{1}(\\omega^{i}_{2D})=f_{L_{i}^{(d)}}</span> for <span class="math">i\\in[D,2D-1]</span>. Hence, the <span class="math">D</span> Fourier coefficients of <span class="math">f</span> give the evaluations <span class="math">\\psi_{1}</span> over <span class="math">\\mathbf{H}_{2D}</span>. First, the algorithm computes the evaluations of <span class="math">\\psi_{1}</span> over the offset of FFT domain of size <span class="math">D</span>. This can be done using two FFTs: one over size <span class="math">2D</span>, and the other over size <span class="math">D</span>. Next, the algorithm uses the evaluations of <span class="math">\\prod_{i\\in[0,D-1]}(Y-\\omega^{i}_{2D})</span> to compute the evaluations of <span class="math">\\psi_{f}</span> over the offset of FFT domain of size <span class="math">D</span>. This step requires <span class="math">D</span> field divisions. Here, from Fact 4, it follows that all evaluations of <span class="math">\\prod_{i\\in[0,D-1]}(Y-\\omega^{i}_{2D})</span> over the offset of FFT domain of size <span class="math">K</span> are non-zero. The evaluations of <span class="math">\\psi_{f}</span> are used to compute evaluations of <span class="math">\\psi_{f,e}</span> and <span class="math">\\psi_{f,0}</span> over the offset of FFT domain of size <span class="math">D/2</span>. This can be done using ideas similar to Claim 8. This step requires <span class="math">O(D)</span> field additions and divisions. Finally, the evaluations of <span class="math">\\psi_{f,e}</span> and <span class="math">\\psi_{f,0}</span> are used to compute their evaluations over <span class="math">\\mathbf{H}_{N}</span>. This step requires two FFTs over domain of size <span class="math">D/2</span>, and two FFTs over domain of size <span class="math">N</span>.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">D.2 Proof of Theorem 9</h3>

    <p class="text-gray-300">Completeness stems from the discussion outlined in Section 4.3. Moreover, commitment binding is guaranteed by the proof of commitment binding presented in Theorem 4 (refer to Appendix C.2). Next, we proceed to establish knowledge soundness. Let <span class="math">\\tilde{P}_{\\text{eval}}</span> denote the algebraic adversary with access to an oracle, as described in Definition 3.3 of <em>[x11]</em>. Given inputs <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g_{1},g_{2})\\leftarrow\\textsf{Gen}(1^{\\lambda})</span> and an initial structured reference string <span class="math">\\bot</span> (corresponding to degree <span class="math">N</span> polynomials), <span class="math">\\tilde{P}_{\\text{eval}}</span> outputs <span class="math">(\\textsf{srs},C_{f},D,\\mathbf{x}^{(d)},y)</span> and a vector <span class="math">\\mathbf{a}\\in\\mathbb{F}^{N}</span> satisfying the following conditions: b) In <span class="math">\\langle P_{\\text{eval}},V_{\\text{eval}}\\rangle(\\textsf{srs},C_{f},D,(\\mathbf{x}^{(d)}),y;\\mathbf{a})</span>, where <span class="math">V_{\\text{eval}}</span> accepts with probability <span class="math">\\epsilon</span>, which is non-negligible in <span class="math">\\lambda</span>. Here, <span class="math">\\bot</span> denotes the trivial string corresponding to <span class="math">r=0</span>, and <span class="math">\\tilde{P}_{\\text{eval}}</span> employs the oracle to update it to <span class="math">\\textsf{srs}</span>. <span class="math">V_{\\text{eval}}</span> rejects if <span class="math">\\textsf{srs}=\\bot</span>. The oracle ensures that <span class="math">\\textsf{srs}</span> is well-formed, meaning there exists an <span class="math">r\\in\\mathbb{F}</span> such that <span class="math">\\textsf{srs}_{\\mathcal{P}}=\\{g_{1}^{\\alpha_{i}}\\mid\\alpha_{i}=N^{-1}\\cdot\\prod_{j\\in[0,n-1]}(1+(\\omega_{N}^{-i}\\cdot r)^{2^{j}})</span> for <span class="math">i\\in[0,N-1]\\}</span>, and <span class="math">\\textsf{srs}_{\\mathcal{V}}=\\{g_{2}^{r^{2^{j}}}\\mid j\\in[0,n]\\}</span>.</p>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}</span> rewinds and executes <span class="math">\\tilde{P}_{\\text{eval}}</span>, generating an acceptance transcript for KZG-FOURIER.eval with probability <span class="math">\\epsilon</span>. Below, we provide a brief description of such a transcript. Recall, we denote <span class="math">\\mathcal{U}_{d}(f)</span> as <span class="math">w_{f}(Y)</span>, and</p>

    <p class="text-gray-300"><span class="math">C_{f}=C_{w_{f}}=\\prod_{i\\in[0,N-1]}(h_{1,i}^{(n)})^{a_{i}}</span></p>

    <p class="text-gray-300">is the claimed commitment to <span class="math">f</span>. We omit <span class="math">f</span> from the subscript of <span class="math">w_{f}</span> in the proof below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At Steps 3a and 3b, let <span class="math">C_{\\psi_{q_{k,o}}}</span>, <span class="math">C_{\\psi_{q_{k,o}}}\\in\\mathbb{G}_{1}</span> be the commitments claimed by <span class="math">\\tilde{P}_{\\text{eval}}</span> corresponding to <span class="math">\\psi_{q_{k,o}}(Y)</span>, <span class="math">\\psi_{q_{k,o}}(Y)</span> for <span class="math">k\\in[1,d-1]</span>. <span class="math">\\tilde{P}_{\\text{eval}}</span> also returns <span class="math">q_{0}\\in\\mathbb{F}</span>, and <span class="math">\\mathbf{b}^{(k,e)}</span>, <span class="math">\\mathbf{b}^{(k,o)},\\in\\mathbb{F}^{N}</span>, such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{\\psi_{q_{k},e}}</span> <span class="math">=\\prod_{i\\in[0,N-1]}(h_{1,i}^{(n)})^{b_{i}^{(k,e)}},</span> <span class="math">C_{\\psi_{q_{k},o}}</span> <span class="math">=\\prod_{i\\in[0,N-1]}(h_{1,i}^{(n)})^{b_{i}^{(k,o)}},</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}</span> samples <span class="math">z\\in_{r}\\mathbb{F}</span>, corresponding to which <span class="math">\\tilde{P}_{\\text{eval}}</span> at Step (3d) returns claimed evaluations of <span class="math">w(Y)</span> at <span class="math">z</span>, <span class="math">\\psi_{q_{k,z}}(Y)</span> and <span class="math">\\psi_{q_{k,o}}(Y)</span> at <span class="math">z^{2^{d-k}}</span>, and <span class="math">\\phi_{k}(Y)</span> at <span class="math">z^{2^{d-k-1}}</span> for <span class="math">k\\in[1,d-1]</span>. Let <span class="math">v</span> be the claimed value of <span class="math">w(Y)</span> at <span class="math">z</span>, <span class="math">v_{k,e}</span> and <span class="math">v_{k,o}</span> be the claimed values of <span class="math">\\psi_{q_{k,o}}(Y)</span>, <span class="math">\\phi_{k}(Y)</span> at <span class="math">z^{2^{d-k}}</span> respectively, and <span class="math">u_{k}</span> be the claimed value of <span class="math">\\psi_{q_{k,o}}(Y)</span> at <span class="math">z^{d-k-1}</span> for <span class="math">k\\in[1,d-1]</span>. Additionally, it satisfies the check made by <span class="math">V_{\\text{eval}}</span> at Step (3e) using Equation 37 below. In the following equations, the expressions for <span class="math">m_{k,1}</span>, <span class="math">m_{k,2}</span>, <span class="math">m_{k}</span>, <span class="math">m^{\\prime}_{k}</span> for <span class="math">k\\in[1,d-1]</span> follow from Equations 9 and 10.</li>

    </ol>

    <p class="text-gray-300"><span class="math">m_{k,1}</span> <span class="math">=v_{k,e}+z^{2^{d-k-1}}\\cdot v_{k,o}</span> <span class="math">m_{k,2}</span> <span class="math">=v_{k,e}-z^{2^{d-k-1}}\\cdot v_{k,o}</span> <span class="math">m_{k}</span> <span class="math">=m_{k,1}\\cdot u_{k}</span> <span class="math">m^{\\prime}_{k}</span> <span class="math">=m_{k,1}\\cdot u_{k}+m_{k,2}\\cdot\\frac{z^{2D\\cdot 2^{d-k-1}}-1}{u_{k}}</span> <span class="math">v-y</span> <span class="math">=(\\sum_{k=1}^{d-1}(m_{k}-x_{k}\\cdot m^{\\prime}_{k}))+(z^{2^{d-1}}-x_{0})\\cdot q_{0})</span> (37)</p>

    <p class="text-gray-300">where</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Corresponding to <span class="math">\\gamma_{w}</span>, <span class="math">\\gamma_{k,e},\\gamma^{\\prime}_{k,e},\\gamma_{k,o},\\gamma^{\\prime}_{k,o},\\delta_{k}</span> sampled uniformly, and independently at random by the extractor, <span class="math">\\tilde{P}_{\\sf eval}</span> returns the claimed commitment <span class="math">C_{\\psi}\\in\\mathbb{G}_{1}</span> to <span class="math">\\psi(Y)</span>, and <span class="math">\\mathbf{b}_{\\psi}\\in\\mathbb{F}^{N}</span> such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{\\psi}=\\prod_{i\\in[0,N-1]}(h_{1,i}^{(n)})^{b_{\\psi,i}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Corresponding to <span class="math">s</span> sampled uniformly, and independently at random from <span class="math">\\mathbb{F}</span> by the extractor, <span class="math">\\tilde{P}_{\\sf eval}</span> returns claimed evaluations of <span class="math">w(Y)</span>, <span class="math">\\psi_{q_{k,e}}(Y)</span>, <span class="math">\\psi_{q_{k,o}}(Y)</span>, <span class="math">\\phi_{k}(Y)</span> for <span class="math">k\\in[1,d-1]</span> at <span class="math">s</span>. Let <span class="math">v^{\\prime}</span> be the claimed value of <span class="math">w(Y)</span> at <span class="math">s</span>, and <span class="math">v^{\\prime}_{k,e}</span>, <span class="math">v^{\\prime}_{k,o}</span>, <span class="math">u^{\\prime}_{k}</span> be the claimed values of <span class="math">\\psi_{q_{k,o}}(Y)</span>, <span class="math">\\psi_{q_{k,o}}(Y)</span>, <span class="math">\\phi_{k}(Y)</span> at <span class="math">s</span> for <span class="math">k\\in[1,d-1]</span>. <span class="math">\\mathcal{E}</span> samples <span class="math">\\beta_{w}</span>, <span class="math">\\beta_{k,e},\\beta_{k,o},\\kappa_{k}</span> for <span class="math">k\\in[1,d-1]</span> uniformly, and independently at random from <span class="math">\\mathbb{F}</span>. Using these values the claimed value of <span class="math">\\eta(Y)</span> at <span class="math">s</span> can be computed using Equations 12 and 13. Denote this computed claimed value as <span class="math">t</span>. Finally, <span class="math">\\tilde{P}_{\\sf eval}</span> returns <span class="math">C_{\\mu}</span> the claimed commitment to <span class="math">\\mu(Y)</span>, and <span class="math">\\mathbf{b}_{\\mu}</span> such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{\\mu}=\\prod_{i\\in[0,N-1]}(h_{1,i}^{(n)})^{b_{\\mu,i}},</span></p>

    <p class="text-gray-300">and the following check made by <span class="math">V_{\\sf eval}</span> is satisfied at the last step</p>

    <p class="text-gray-300"><span class="math">e(C_{\\eta}\\cdot g_{1}^{-t},g_{2})=e(C_{\\mu},h_{2}^{(d)}\\cdot g_{2}^{-t})</span> (38)</p>

    <p class="text-gray-300">where <span class="math">C_{\\eta}</span> satisfies Equation 14.</p>

    <p class="text-gray-300">From the proof of Theorem 4, it follows that if Equation 38 is satisfied then the <span class="math">\\mathcal{E}</span> can compute <span class="math">\\eta\\in\\mathbb{F}_{&lt;D}[Y]</span> such that <span class="math">\\eta(s)=t</span>, and <span class="math">C_{\\eta}=g_{1}^{\\eta(r^{2^{n-d}})}</span>. Moreover, from Claim 13, there exists <span class="math">\\psi^{\\prime}\\in\\mathbb{F}_{&lt;2^{\\ell_{\\psi}}}[Y]</span>, <span class="math">w^{\\prime}\\in\\mathbb{F}_{2^{\\ell_{w}}}[Y]</span>, <span class="math">\\psi^{\\prime}_{q_{k,e}}\\in\\mathbb{F}_{&lt;2^{\\ell_{k,e}}}[Y]</span>, <span class="math">\\psi^{\\prime}_{q_{k,o}}\\in\\mathbb{F}_{&lt;2^{\\ell_{k,o}}}[Y]</span>, for <span class="math">k\\in[1,d-1]</span> such that</p>

    <p class="text-gray-300"><span class="math">C_{\\psi}=g_{1}^{\\psi^{\\prime}(r^{2^{n-\\ell_{\\psi}}})},\\hskip 14.22636ptC_{w}=g_{1}^{w^{\\prime}(r^{2^{n-\\ell_{w}}})},</span> <span class="math">C_{\\psi_{q_{k,e}}}=g_{1}^{\\psi^{\\prime}_{q_{k,e}}(r^{2^{n-\\ell_{k,e}}})},\\hskip 14.22636ptC_{\\psi_{q_{k,o}}}=g_{1}^{\\psi^{\\prime}_{q_{k,o}}(r^{2^{n-\\ell_{k,o}}})}</span></p>

    <p class="text-gray-300">Note that the <span class="math">\\mathcal{E}</span> can efficiently compute the evaluations of such polynomials over appropriate FFT domains using <span class="math">\\mathbf{a}</span>, <span class="math">\\mathbf{b}_{\\psi}</span>, <span class="math">\\mathbf{b}_{k,e}</span>, <span class="math">\\mathbf{b}_{k,o}</span> for <span class="math">k\\in[1,d-1]</span> respectively. Also from construction of the setup in Section 4.2, we have</p>

    <p class="text-gray-300"><span class="math">C_{\\phi_{k}}=g_{1}^{\\phi_{k}(r^{2^{n-k-1}})}</span></p>

    <p class="text-gray-300">The construction of <span class="math">C_{\\eta}</span>, Claim 12, and the <span class="math">N</span>-DLOG assumption implies</p>

    <p class="text-gray-300"><span class="math">\\eta(Y^{2^{n-d}})=\\psi^{\\prime}(Y^{2^{n-\\ell_{\\psi}}})+\\beta_{w}\\cdot w^{\\prime}(Y^{2^{n-\\ell_{w}}})+</span> <span class="math">\\sum_{k\\in[1,d-1]}\\bigg{(}\\beta_{k,e}\\cdot\\psi_{q_{k},e}(Y^{2^{n-\\ell_{k,e}}})+\\beta_{k,o}\\cdot\\psi_{q_{k},o}(Y^{2^{n-\\ell_{k,o}}})</span> <span class="math">\\kappa_{k}\\cdot\\phi_{k}(Y^{2^{n-k-1}})\\bigg{)}</span> (39)</p>

    <p class="text-gray-300">In the following claim, we bound the degrees of <span class="math">\\psi^{\\prime}</span>, <span class="math">w^{\\prime}</span>, <span class="math">\\psi^{\\prime}_{k,e}</span>, <span class="math">\\psi^{\\prime}_{k,o}</span> for <span class="math">k\\in[1,d-1]</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Claim 15.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\eta</span>, <span class="math">\\psi^{\\prime}</span>, <span class="math">w^{\\prime}</span>, <span class="math">\\psi^{\\prime}_{k,e}</span>, <span class="math">\\psi^{\\prime}_{k,o}</span> for <span class="math">k\\in[1,d-1]</span> be as defined above. Then the degree of all these polynomials is at most <span class="math">D</span> with probability at least $1-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> over the random choices of </span>\\beta_{w}<span class="math">, and </span>\\beta_{k,e}<span class="math">, </span>\\beta_{k,o}<span class="math">, and </span>\\kappa_{k}<span class="math">, for </span>k\\in[1,d-1]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the degree of <span class="math">\\eta(Y)</span> is at most <span class="math">D=2^{d}</span>, the LHS of Equation 39 has monomials of the form <span class="math">Y^{i\\cdot 2^{n-d}}</span> for <span class="math">i\\in[0,D-1]</span>. Hence, by Schwartz-Zippel with probability at least $\\epsilon(1-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, the monomials in each of the polynomials </span>\\psi^{\\prime}(Y^{2^{n-\\ell_{\\psi}}})<span class="math">, </span>w^{\\prime}(Y^{2^{n-\\ell_{w}}})<span class="math">, </span>\\psi_{q_{k},e}(Y^{2^{n-\\ell_{k,e}}})<span class="math">, </span>\\psi_{q_{k},o}(Y^{2^{n-\\ell_{k,o}}})<span class="math">, </span>\\phi_{k}(Y^{2^{n-k-1}})<span class="math"> for </span>k\\in[1,d-1]<span class="math"> is of the form </span>Y^{i\\cdot 2^{n-d}}<span class="math"> for </span>i\\in[0,D-1]<span class="math">. Now suppose </span>2^{\\ell_{\\psi}}\\geq D<span class="math">. Then this implies there exists </span>j\\neq j^{\\prime}<span class="math"> such that </span>j,j^{\\prime}\\in[0,2^{\\ell_{\\psi}}-1]<span class="math"> such that </span>2^{n-d}\\cdot i=2^{n-\\ell_{\\psi}}\\cdot j<span class="math">, and </span>2^{n-d}\\cdot i=2^{n-\\ell_{\\psi}}\\cdot j^{\\prime}<span class="math">. But this implies </span>j=j^{\\prime}<span class="math">, a contradiction. Hence, </span>2^{\\ell_{\\psi}}<D$. A similar argument can be used to bound the degrees of all the remaining polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From Claim 15, we conclude that <span class="math">\\psi^{\\prime}(Y)</span>, <span class="math">w^{\\prime}(Y)</span>, <span class="math">\\psi^{\\prime}_{q_{k},e}</span>, <span class="math">\\psi^{\\prime}_{q_{k},o}</span> for <span class="math">k\\in[1,d-1]</span> are at most degree <span class="math">D</span> polynomials. Hence, there exists <span class="math">\\psi(Y)</span>, <span class="math">w^{\\prime}(Y)\\in\\mathbb{F}_{&lt;D}[Y]</span>, <span class="math">\\psi^{\\prime}_{q_{k},e}</span>, <span class="math">\\psi^{\\prime}_{q_{k},o}\\mathbb{F}_{&lt;D}[Y]</span> for <span class="math">k\\in[1,d-1]</span> such that <span class="math">\\psi(Y^{2^{n-d}})=\\psi^{\\prime}(Y^{2^{n-\\ell_{\\psi}}})</span>, <span class="math">w(Y^{2^{n-d}})=w^{\\prime}(Y^{2^{n-\\ell_{w}}})</span>, <span class="math">\\psi_{q_{k},e}(Y^{2^{n-d}})=\\psi_{q_{k},e}(Y^{2^{n-\\ell_{q_{k},e}}})</span>, <span class="math">\\psi_{q_{k},o}(Y^{2^{n-d}})=w^{\\prime}(Y^{2^{n-\\ell_{q_{k},o}}})</span>.</p>

    <p class="text-gray-300"><span class="math">\\psi_{q_{k},o}(Y^{2^{n-\\ell_{q_{k},o}}})</span>. For example, if <span class="math">\\ell_{w}=d</span> then let <span class="math">\\psi(Y)=\\psi^{\\prime}(Y)</span>, and if <span class="math">\\ell_{w}=d-1</span> then let <span class="math">\\psi(Y)=\\psi(Y^{2})</span> and so on. Hence, we may rewrite Equation 39 as follows</p>

    <p class="text-gray-300"><span class="math">\\eta(Y)=\\psi(Y)+\\beta_{w}\\cdot w(Y)+</span> <span class="math">\\sum_{k\\in[1,d-1]}\\bigg{(}\\beta_{k,e}\\cdot\\psi_{q_{k},e}(Y)+\\beta_{k,o}\\cdot\\psi_{q_{k},o}(Y)</span> <span class="math">\\kappa_{k}\\cdot\\phi_{k}(Y^{2^{d-k-1}})\\bigg{)}</span> (40)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">E_{1}</span> be the event that the above equation holds. Conditioned on that <span class="math">E_{1}</span> holds, and since <span class="math">\\eta(s)=t</span> and <span class="math">t</span> is computed using Equations 12 and 13 from the claimed values of <span class="math">w(Y)</span>, <span class="math">\\psi_{q_{k},e}</span>, <span class="math">\\psi_{q_{k},o}</span>, and <span class="math">\\phi_{k}</span> at <span class="math">s</span>, we have by Schwartz-Zippel with probability $1-\\frac{D+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> over the random choices of </span>s<span class="math">, </span>\\beta_{w}<span class="math">, </span>\\beta_{k,e}<span class="math">, </span>\\beta_{k,o}<span class="math">, and </span>\\kappa_{k}<span class="math"> for </span>k\\in[1,d-1]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">w(s)=v^{\\prime},\\ \\ \\psi_{q_{k},e}(s)=v^{\\prime}_{k,e},\\qquad\\text{and}</span> <span class="math">\\psi_{q_{k},o}(s)=v^{\\prime}_{k,o},\\ \\ \\psi_{k}(s^{2^{d-k-1}})=u^{\\prime}_{k}</span></p>

    <p class="text-gray-300">and, <span class="math">\\psi(Y)</span> satisfies Equation 12.</p>

    <p class="text-gray-300">Let <span class="math">E_{2}</span> be the event that Equation 12 holds. Conditioned on <span class="math">E_{2}</span>, with probability <span class="math">1-\\frac{1}{\\mathbb{F}}</span>, over the random choices of <span class="math">\\gamma</span>, <span class="math">\\gamma_{k,e}</span>, <span class="math">\\gamma_{k,o}</span>, and <span class="math">\\delta_{k}</span> for <span class="math">k\\in[1,d-1]</span>.</p>

    <p class="text-gray-300"><span class="math">w(z)=v,\\ \\ \\psi_{q_{k},e}(z^{2^{d-k}})=v_{k,e},\\ \\ \\psi_{q_{k},o}(z^{2^{d-k}})=v_{k,o}</span> <span class="math">\\phi_{k}^{z^{2^{d-k-1}}}=u_{k},\\ \\ \\zeta_{q_{k},e}(z^{2^{d-k}})=z^{2^{2d-k}-2^{d}}\\cdot v_{k,e},</span> <span class="math">\\zeta_{q_{k},o}(z^{2^{d-k}})=z^{2^{2d-k}-2^{d}}\\cdot v_{k,o}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">E_{3}</span> be the event that the above relations hold. Conditioned on <span class="math">E_{3}</span>, and since the check using Equation 37 passes, with probability $1-\\frac{2D}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ the following hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\zeta_{q_{k},e}(Y)=Y^{2^{d}-2^{k-1}}\\cdot\\psi_{k,e}(Y)</span>, and <span class="math">\\zeta_{q_{k},o}(Y)=Y^{2^{d}-2^{k-1}}\\cdot\\psi_{k,o}(Y)</span>.</li>

      <li>Let Let <span class="math">\\psi_{q_{k}}(Y)=\\psi_{q_{k},e}(Y^{2})+Y\\cdot\\psi_{q_{k},o}(Y^{2})</span>. Then</li>

    </ol>

    <p class="text-gray-300"><span class="math">w(Y)-v</span> <span class="math">=\\sum_{k\\in[1,d-1]}\\bigg{(}\\psi_{q_{k}}(Y^{2^{d-k-1}})\\cdot\\phi_{k}(Y^{2^{d-k-1}})</span> <span class="math">\\quad-x_{k}\\cdot\\big{(}(\\psi_{q_{k}}(Y^{2^{d-k-1}})\\cdot\\phi_{k}(Y^{2^{d-k-1}})</span> <span class="math">\\quad+\\psi_{q_{k}}(-Y^{2^{d-k-1}})\\cdot\\frac{Y^{2^{d+1}.2^{d-k-1}}}{\\phi_{k}(Y^{2^{d-k-1}})})\\big{)}\\bigg{)}</span> <span class="math">\\quad+(Y^{2^{d-1}}-x_{0})q_{0}</span> (41)</p>

    <p class="text-gray-300">Since degree of <span class="math">\\psi(Y)</span> is at most <span class="math">D</span>, from Equation 12 it follows that degrees of <span class="math">\\zeta_{q_{k},e}(Y)</span> and <span class="math">\\zeta_{q_{k},o}(Y)</span> are at most <span class="math">D</span>. This implies degree of <span class="math">\\psi_{k,e}</span>, and <span class="math">\\psi_{k,o}</span> is at most <span class="math">K/2</span>, and hence degree of <span class="math">\\psi_{q_{k}}(Y)</span> is at most <span class="math">K</span>. From Lemma 2 there exists <span class="math">f\\in\\mathbb{F}_{\\leq 1}[\\mathbf{X}^{(d)}]</span>, and <span class="math">q_{k}\\in\\mathbb{F}_{\\leq 1}[\\mathbf{X}^{(k)}]</span> for <span class="math">k\\in[1,d-1]</span> such that <span class="math">\\mathcal{U}_{d}(f)=w(Y)</span>, and</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{d}(X_{k}\\cdot q_{k})=\\psi_{q_{k}}(Y^{2^{d-k-1}})\\cdot\\phi_{k}(Y^{2^{d-k-1}})</span> <span class="math">\\mathcal{U}_{d}(q_{k})=\\psi_{q_{k}}(Y^{2^{d-k-1}})\\cdot\\phi_{k}(Y^{2^{d-k-1}})+\\psi_{q_{k}}(-Y^{2^{d-k-1}})\\cdot\\frac{Y^{2^{d+1}.2^{d-k-1}}}{\\phi_{k}(Y^{2^{d-k-1}})}</span></p>

    <p class="text-gray-300">Further, it is easy to construct <span class="math">f</span> from <span class="math">w</span> using the evaluations of <span class="math">w</span> over <span class="math">\\mathbf{H}_{D}</span>. Hence, we have from Equation 41,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}_{d}(f)-v=\\sum_{k\\in[0,d-1]}\\mathcal{U}_{d}(X_{k}\\cdot q_{k})-\\mathcal{U}_{d}(x_{k}\\cdot q_{k})</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{U}_{d}</span> is a linear isomorphism, we have</p>

    <p class="text-gray-300"><span class="math">f(X_{0},\\ldots,X_{d-1})-v=\\sum_{k\\in[0,d-1]}(X_{k}-x_{k})\\cdot q_{k}(X_{0},\\ldots,X_{k-1})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This implies if <span class="math">\\mathcal{E}</span> can construct an compute an accepting transcript using <span class="math">\\tilde{P}_{\\text{eval}}</span> with probability <span class="math">\\epsilon</span>, then it can compute the <span class="math">D</span> Fourier coefficients of an <span class="math">f\\in\\mathbb{F}_{\\leq 1}[X_{0},\\ldots,X_{d-1}]</span> such that <span class="math">f(x_{0},\\ldots,x_{d-1})=v</span> with probability at least $\\epsilon(1-\\frac{D}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{4}<span class="math">, which is non-negligible in </span>\\lambda<span class="math"> assuming </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">E Argument of Knowledge to Establish Linear Relations</p>

    <p class="text-gray-300">In this section, we present Linear-Rel, an AoK that facilitates a prover to demonstrate a pre-defined linear relationship between two AFG committed witnesses. This helps in designing a succinct dual polynomial commitment scheme in Section 5.2 requiring only a transparent setup. Consider a bilinear group <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,g_{1},g_{2})\\leftarrow_{R}\\mathcal{G}(1^{\\lambda})</span>. Let <span class="math">d,n,D,N\\in\\mathbb{N}</span> be such that <span class="math">2^{d}=D</span>, <span class="math">2^{n}=N</span>, and <span class="math">D\\leq N</span> Within this context, let <span class="math">\\tau^{(1,d)}\\in\\mathbb{G}_{1}^{D}</span>, and <span class="math">\\tau^{(2,d)}\\in\\mathbb{G}_{2}^{D}</span> be publicly known vectors (also refer to Appendix G.1). Furthermore, let <span class="math">\\mathbf{a},\\mathbf{f}\\in\\mathbb{F}^{D}</span> represent two vectors, and denote the commitments to <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{a}</span> as <span class="math">C_{\\mathbf{f}}</span> and <span class="math">C_{\\mathbf{a}}</span> respectively, defined as follows:</p>

    <p class="text-gray-300"><span class="math">C_{\\mathbf{f}}=\\prod_{i=0}^{D-1}e(\\tau_{i}^{(1,d)},g_{2}^{f_{i}})</span> (42) <span class="math">C_{\\mathbf{a}}=\\prod_{i=0}^{D-1}e(\\tau_{i}^{(1,d)},g_{2}^{a_{i}})</span> (43)</p>

    <p class="text-gray-300">Here <span class="math">a_{i}</span>, and <span class="math">f_{i}</span> represent the <span class="math">i</span>-th component of <span class="math">\\mathbf{a}</span>, and <span class="math">\\mathbf{f}</span> respectively. We note that <span class="math">C_{f}</span> and <span class="math">C_{\\mathbf{a}}</span> is the AFG commitment to <span class="math">g_{2}^{\\mathbf{f}}</span> and <span class="math">g_{2}^{\\mathbf{a}}</span> (and therefore <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{a}</span>) with respect to commitment key <span class="math">\\tau^{(1,d)}</span>. The relation corresponding to which we present the argument of knowledge is as defined below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{R}_{L}=\\{C_{\\mathbf{f}},C_{\\mathbf{a}},D</span> $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\exists\\mathbf{a},\\mathbf{f}\\in\\mathbb{F}^{D}\\text{ such that }M_{\\omega_{D}}\\cdot\\mathbf{f}=\\mathbf{a},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\text{and }C_{\\mathbf{f}},C_{\\mathbf{a}}\\text{ satisfy Eq. 42, 43}\\}</span> (44)</p>

    <p class="text-gray-300">Recall, <span class="math">M_{\\omega_{D}}</span> is the FFT matrix of size <span class="math">D</span>. We remark that, in the argument system, we can replace <span class="math">M_{\\omega_{D}}</span> with any matrix, but for convenience we work with FFT matrices. The argument of knowledge presented in this section requires a transparent setup, which we show how to generate in Appendix E.1. We state the protocol itself and its correctness in Appendix E.2.</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">E.1 Transparent Setup for Linear Relation</h3>

    <p class="text-gray-300">The algorithm to generate the setup for the argument system is presented in Algorithm 5. Linear-Rel presented in Appendix E.2, runs two instances of Dory <em>[x10]</em> (also see Appendix G). Hence, Linear-Rel requires the dory setup denoted <span class="math">\\text{pp}_{\\text{dory}}</span>. We refer the reader to Appendix G.1 for an exact description of <span class="math">\\text{pp}_{\\text{dory}}</span>. At Steps 2-5, Algorithm 5 computes <span class="math">n</span> commitments <span class="math">\\{C_{\\omega_{D}}\\}_{d\\in[1,n]}</span> to matrices <span class="math">\\{M_{\\omega_{D}}\\}_{d\\in[1,n]}</span> respectively, where <span class="math">C_{\\omega_{D}}\\in\\mathbb{G}_{T}</span> and is computed as in Steps 3 and 4. Here, <span class="math">\\tau^{(2,d)}</span> is part of <span class="math">\\text{pp}_{\\text{dory}}</span>. Finally at Step 7, Algorithm 5, outputs the public parameters <span class="math">\\text{pp}=(\\text{pp}_{\\mathcal{P}},\\text{pp}_{\\mathcal{V}})</span>, where <span class="math">\\text{pp}_{\\mathcal{P}}=\\text{pp}_{\\text{dory},\\mathcal{P}}</span>, and <span class="math">\\text{pp}_{\\mathcal{V}}=\\{\\text{pp}_{\\text{dory},\\mathcal{V}},\\{C_{M_{\\omega_{D}}}\\}_{d\\in[1,n]}\\}</span>.</p>

    <p class="text-gray-300">Algorithm 5 Setup Generation for Linear Relation Input: <span class="math">\\{1^{\\lambda},n\\}</span> Output: <span class="math">\\text{pp}=(\\text{pp}_{\\mathcal{P}},\\text{pp}_{\\mathcal{V}})</span> 1: <span class="math">\\text{pp}_{\\text{dory}}\\leftarrow\\text{dory.setup}(1^{\\lambda})</span>. 2: for <span class="math">d\\in[1,n]</span> do 3: Let <span class="math">m_{D,j}=\\prod_{i\\in[0,D-1]}(\\tau_{i}^{(1,d)})^{\\omega_{D}^{i,j}}</span> 4: Compute <span class="math">C_{M_{\\omega_{D}}}=\\prod_{j\\in[0,D-1]}e(m_{d,j},\\tau_{j}^{(2,d)})</span> 5: end for 6: Let <span class="math">\\text{pp}_{\\mathcal{P}}=\\text{pp}_{\\text{dory},\\mathcal{P}}</span>, and <span class="math">\\text{pp}_{\\mathcal{V}}=\\text{pp}_{\\text{dory},\\mathcal{V}}\\cup\\{C_{M_{\\omega_{D}}}\\}_{d\\in[1,n]}</span> 7: Output <span class="math">\\text{pp}=(\\text{pp}_{\\mathcal{P}},\\text{pp}_{\\mathcal{V}})</span>.</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">E.2 Proving Linear Relations</h3>

    <p class="text-gray-300">The argument system for <span class="math">\\mathcal{R}_{L}</span> from Equation 44 is presented in Protocol 6. The public parameters are as generated by Algorithm 5. The central idea of the protocol is to enable the verifier to check</p>

    <p class="text-gray-300"><span class="math">C_{\\mathbf{a}}=\\prod_{j\\in[0,D-1]}e(m_{D,j},g_{2}^{f_{j}})=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)},g_{2}^{a_{i}})</span> (45)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">Here, <span class="math">m_{D,j}</span> is as defined in Step 4 of Algorithm 5. We argue as part of the completeness of the protocol that <span class="math">M_{\\omega_D} \\cdot \\mathbf{f} = \\mathbf{a}</span> implies the above equality. Hence, the linear relation can be established if the verifier is able to check the following two statements:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\exists \\mathbf{a} \\in \\mathbb{F}^D</span> such that <span class="math">C_{\\mathbf{a}} = \\prod_{i=0}^{D-1} e(\\tau_i^{(1,d)}, g_2^{a_i})</span>.</li>

      <li><span class="math">\\exists \\mathbf{f} \\in \\mathbb{F}^D</span> such that <span class="math">C_{\\mathbf{f}} = \\prod_{i=0}^{D-1} e(\\tau_i^{(1,d)}, g_2^{f_i})</span>, <span class="math">C_{M_{\\omega_D}} = \\prod_{j \\in [0, D-1]} e(m_{D,j}, \\tau_j^{(2,d)})</span>, and <span class="math">C_{\\mathbf{a}} = \\prod_{j \\in [0, D-1]} e(m_{D,j}, g_2^{f_j})</span>.</li>

    </ol>

    <p class="text-gray-300">At Step 1, Statement 1 above is proved using one instance of dory (Appendix G.2, Protocol 7): <span class="math">\\langle P_{\\text{dory}}, V_{\\text{dory}} \\rangle(\\mathrm{pp}, C_{\\mathbf{a}}, C_{\\tau_d}, C_{\\mathbf{a}}, D; \\mathbf{a})</span> Here, <span class="math">C_{\\tau_d} = \\langle \\tau^{(1,d)}, \\tau^{(2,d)} \\rangle</span>, and is part of <span class="math">\\mathsf{pp}_{\\text{dory}}</span> (see Section G.1). Also, we remark that although as per Protocol 7 the private input to the prover at Step 1 <span class="math">g_2^{\\mathbf{a}}</span> respectively, we use <span class="math">\\mathbf{a}</span> for clarity as <span class="math">g_2^{\\mathbf{a}}</span> can be computed from <span class="math">\\mathbf{a}</span>. At Step 2, Statement 2 above is proved using an instance of dory: <span class="math">\\langle P_{\\text{dory}}, V_{\\text{dory}} \\rangle(\\mathrm{pp}, C_{\\mathbf{a}}, C_{M_{\\omega_D}}, C_{\\mathbf{f}}, D; \\mathbf{f})</span>. Here, the private input to the prover are <span class="math">(m_{D,0}, \\ldots, m_{D,D-1})</span> and <span class="math">g_2^{\\mathbf{f}}</span>, which can be computed from <span class="math">M_{\\omega_D}</span> and <span class="math">\\mathbf{f}</span>. We argue the correctness of Protocol 6 in Theorem 16.</p>

    <p class="text-gray-300"><strong>Theorem 16.</strong> Assuming SXDH in the bilinear group <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e, g_1, g_2)</span>, Protocol 6 is an argument of knowledge for relation <span class="math">\\mathcal{R}_L</span> stated in Equation 44.</p>

    <p class="text-gray-300"><strong>Protocol 6: Linear-Rel an AoK for Linear Relations</strong></p>

    <p class="text-gray-300"><span class="math">\\mathrm{pp} \\gets \\mathrm{setup}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">\\langle P_{\\mathrm{lin}}, V_{\\mathrm{lin}} \\rangle(\\mathrm{pp}, C_{\\mathbf{f}}, C_{\\mathbf{a}}, D; \\mathbf{a})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{\\mathrm{lin}}, V_{\\mathrm{lin}}</span> execute <span class="math">\\langle P_{\\mathrm{dory}}, V_{\\mathrm{dory}} \\rangle(\\mathrm{pp}, C_{\\mathbf{a}}, C_{\\tau_d}, C_{\\mathbf{a}}, D; \\mathbf{a})</span>. Here <span class="math">C_{\\tau_d} = \\langle \\tau^{(1,d)}, \\tau^{(2,d)} \\rangle</span> is part of <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">P_{\\mathrm{lin}}, V_{\\mathrm{lin}}</span> execute <span class="math">\\langle P_{\\mathrm{dory}}, V_{\\mathrm{dory}} \\rangle(\\mathrm{pp}, C_{\\mathbf{a}}, C_{M_{\\omega_D}}, C_{\\mathbf{f}}, D; M_{\\omega_D}, \\mathbf{f})</span>. Here <span class="math">C_{M_{\\omega_D}}</span> is as explained in Section E.1 and is part of <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">V_{\\mathrm{lin}}</span> accepts if and only if the verifier accepts in all the above steps.</li>

    </ol>

    <h2 id="sec-62" class="text-2xl font-bold">E.3 Proof of Theorem 16</h2>

    <p class="text-gray-300"><strong>Completeness:</strong> First we argue that if <span class="math">M_{\\omega_D} \\cdot \\mathbf{f} = \\mathbf{a}</span> then</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{i \\in [0, D-1]} e(\\tau_i^{(1,d)}, g_2^{a_i}) = \\prod_{j \\in [0, D-1]} e(m_{D,j}, g_2^{f_j}),</span></div>

    <p class="text-gray-300">where <span class="math">m_{D,j}</span> is as computed in Step 4 of Algorithm 5. Since <span class="math">M_{\\omega_D} \\cdot \\mathbf{f} = \\mathbf{a}</span>, for all <span class="math">i \\in [0, D-1]</span></p>

    <div class="my-4 text-center"><span class="math-block">a_i = \\sum_{j \\in [0, D-1]} \\omega_D^{i,j} \\cdot f_j \\tag{46}</span></div>

    <p class="text-gray-300">Now we have the following sequence of equations.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\prod_{j \\in [0, D-1]} e(m_{D,j}, g_2^{f_j}) &amp;amp;= \\prod_{j \\in [0, D-1]} e(m_{D,j}^{f_j}, g_2) \\tag{47} \\\\ &amp;amp;= \\prod_{j \\in [0, D-1]} e\\left(\\prod_{i \\in [0, D-1]} \\left(\\left(\\tau_i^{(1,d)}\\right)^{\\omega_D^{i,j}}\\right)^{f_j}, g_2\\right) \\\\ &amp;amp;= \\prod_{j \\in [0, D-1]} e\\left(\\prod_{i \\in [0, D-1]} \\left(\\tau_i^{(1,d)}\\right)^{f_j \\cdot \\omega_D^{i,j}}, g_2\\right) \\\\ &amp;amp;= \\prod_{i \\in [0, D-1]} \\prod_{j \\in [0, D-1]} e\\left(\\left(\\tau_i^{(1,d)}\\right)^{f_j \\cdot \\omega_D^{i,j}}, g_2\\right) \\\\ &amp;amp;= \\prod_{i \\in [0, D-1]} e\\left(\\prod_{j \\in [0, D-1]} \\left(\\tau_i^{(1,d)}\\right)^{f_j \\cdot \\omega_D^{i,j}}, g_2\\right) \\\\ &amp;amp;= \\prod_{i \\in [0, D-1]} e\\left(\\left(\\tau_i^{(1,d)}\\right)^{\\sum_{j \\in [0, D-1]} f_j \\cdot \\omega_D^{i,j}}, g_2\\right) \\tag{48} \\end{aligned}</span></div>

    <p class="text-gray-300"><span class="math">=\\quad\\prod_{i\\in[0,D-1]}e((\\tau_{i}^{(1,d)})^{a_{i}},g_{2})</span> (49) <span class="math">=\\quad\\prod_{i\\in[0,D-1]}e((\\tau_{i}^{(1,d)}),g_{2}^{a_{i}})</span> (50)</p>

    <p class="text-gray-300">Equations 47 and 50 above follows from bi-linearity of <span class="math">e</span>, and Equation 49 follows from Equation 46. Hence, it follows from the completeness of dory that in this case <span class="math">V_{\\textsf{dory}}</span> always accepts at Steps 2-4, and hence <span class="math">V_{\\textsf{lin}}</span> accepts at Step 5.</p>

    <p class="text-gray-300">Knowledge Soundness: Suppose <span class="math">\\tilde{P}_{\\textsf{lin}}</span> outputs <span class="math">C_{f}</span>, <span class="math">C_{\\mathbf{a}}</span> such that <span class="math">V_{\\textsf{lin}}</span> accepts with non-negligible probability in <span class="math">\\lambda</span>. This implies <span class="math">V_{\\textsf{dory}}</span> accepts at Steps 2-4. By knowledge soundness of Dory, there exists an extractor that can rewind <span class="math">\\tilde{P}_{\\textsf{lin}}</span> and compute <span class="math">\\mathbf{f}\\in\\mathbb{F}^{D}</span>, and <span class="math">\\mathbf{a}\\in\\mathbb{F}^{D}</span> such that the following hold:</p>

    <p class="text-gray-300"><span class="math">C_{\\mathbf{f}}=\\prod_{i=0}^{D-1}e(\\tau_{i}^{(1,d)},g_{2}^{f_{i}})</span> <span class="math">C_{\\mathbf{a}}=\\prod_{i=0}^{n-1}e(\\tau_{i}^{(1,d)}),g_{2}^{a_{i}})</span> <span class="math">\\prod_{j\\in[0,D-1]}e(m_{D,j},g_{2}^{f_{j}})=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)}),g_{2}^{a_{i}})</span> (51)</p>

    <p class="text-gray-300">Hence, it suffices to argue that <span class="math">M_{\\omega_{D}}\\cdot\\mathbf{f}=\\mathbf{a}</span> in this case. Suppose <span class="math">M_{\\omega_{D}}\\cdot\\mathbf{f}\\neq\\mathbf{a}</span>, and <span class="math">M_{\\omega_{D}}\\cdot\\mathbf{f}=\\mathbf{b}</span>. In the above sequence of Equations (from Equation 47 to Equation 50) replacing <span class="math">\\mathbf{a}</span> with <span class="math">\\mathbf{b}</span>, it follows that</p>

    <p class="text-gray-300"><span class="math">\\prod_{j\\in[0,D-1]}e(m_{D,j},g_{2}^{f_{j}})=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)},g_{2}^{b_{i}})</span></p>

    <p class="text-gray-300">Hence, from Equation 51, we have</p>

    <p class="text-gray-300"><span class="math">\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)},g_{2}^{a_{i}})=\\prod_{i\\in[0,D-1]}e(\\tau_{i}^{(1,d)}),g_{2}^{b_{i}})</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathbf{a}\\neq\\mathbf{b}</span>, this implies <span class="math">\\mathcal{E}</span> can efficiently compute two distinct vectors with the same AFG commitment under commitment key <span class="math">\\tau^{(1,d)}</span>. This contradicts SXDH with respect to bilinear group generator <span class="math">\\mathcal{G}</span> .</p>

    <h2 id="sec-63" class="text-2xl font-bold">Appendix F Proof of Theorems from Section 5</h2>

    <h3 id="sec-64" class="text-xl font-semibold mt-8">F.1 Proof of Theorem 10</h3>

    <p class="text-gray-300">Completeness and Evaluation Knowledge Soundness: This follows from the completeness, and evaluation knowledge soundness of KZG-FFT, and KZG-FOURIER proved as part of Theorems 4, and 9 respectively.</p>

    <p class="text-gray-300">Binding: Suppose for contradiction there exists an <span class="math">\\mathcal{A}</span> that with probability non-negligible in <span class="math">\\lambda</span> takes as input <span class="math">\\mathsf{pp}</span> computed by KZG-FFT-FOURIER.setup and returns <span class="math">(C,\\mathbf{a}_{0},\\mathbf{a}_{1},\\text{aux}_{0},\\text{aux}_{1},D)</span> such that a) <span class="math">\\mathbf{a}_{0}\\neq\\mathbf{a}_{1}</span>, b) <span class="math">C=(C_{f},C_{\\mathbf{a}})</span>, where <span class="math">C_{f}=C_{\\mathbf{a}}</span>, and c) KZG-FFT-FOURIER.commit <span class="math">(\\mathsf{srs}_{\\mathcal{P}},D,\\mathbf{a}_{0})=\\mathsf{KZG-FFT-FOURIER.commit}(\\mathsf{srs}_{\\mathcal{P}},D,\\mathbf{a}_{1})=C_{f}</span>. But KZG-FFT-FOURIER.commit internally calls KZG-FFT.commit, and hence, we have KZG-FFT.commit(<span class="math">\\mathsf{srs}_{\\mathcal{P}},D,\\mathbf{a}_{0})=\\mathsf{KZG-FFT.commit}</span> <span class="math">(\\mathsf{srs}_{\\mathcal{P}},D,\\mathbf{a}_{1})=C_{f}</span>. This contradicts the binding property of KZG-FFT we proved as part of Theorem 4.</p>

    <p class="text-gray-300">Linking Soundness: Follows trivially, since the verifier checks <span class="math">C_{f}=C_{\\mathbf{a}}</span>.</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">F.2 Proof of Theorem 11</h3>

    <p class="text-gray-300">Completeness, binding, and evaluation knowledge-soundness follows from dory PCS, whereas linking soundness follows from Theorem 16.</p>

    <h2 id="sec-66" class="text-2xl font-bold">Appendix G Succinct Argument of Knowledge for Inner-Pairing Products</h2>

    <p class="text-gray-300">In this section we revisit the Dory argument system from <em>[x11]</em> that allows the prover to give a succinct proof corresponding to an inner pairing product. In particular, the prover proves there exists a vector <span class="math">\\mathbf{h}\\in\\mathbb{G}_{1}^{D}</span>, a vector <span class="math">\\mathbf{s}\\in\\mathbb{G}_{2}^{D}</span> such that <span class="math">C=\\prod_{i\\in[0,D-1]}e(h_{i},s_{i})</span>. The Dory proof system</p>

    <p class="text-gray-300">enables the prover to iteratively prove the knowledge of <span class="math">\\mathbf{h}</span> and <span class="math">\\mathbf{s}</span> such that <span class="math">C = \\prod_{i\\in [n]}e(h_i,s_i)</span>, <span class="math">C_{\\mathbf{h}} = \\prod_{i\\in [0,D - 1]}e(h_i,\\tau_{2,i})</span>, and <span class="math">C_{\\mathbf{s}} = \\prod_{i\\in [0,D - 1]}e(\\tau_{1,i},s_i)</span>, where <span class="math">\\tau_{1}</span>, and <span class="math">\\tau_{2}</span> are publicly known elements. Additionally, as a special case the Dory proof system can also be used to succinctly prove the knowledge of opening for an AFG commitment.</p>

    <p class="text-gray-300">In Section G.1, we begin by specifying the required public parameters for the Dory proof system, and in Section G.2, we state the Dory argument system. Finally, in Section G.3, we give state how to use Dory argument to prove evaluations for an univariate or a multilinear polynomial.</p>

    <h2 id="sec-67" class="text-2xl font-bold">G.1 Public Parameters</h2>

    <p class="text-gray-300">Let <span class="math">(p,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,g_1,g_2)</span>, be a bilinear group. Let <span class="math">n = \\log N</span>, and <span class="math">\\tau^{(1,j)}\\in \\mathbb{G}_1^{N / 2^{n - j}}</span> and <span class="math">\\tau^{(2,j)}\\in \\mathbb{G}_2^{N / 2^{n - j}}</span> for <span class="math">j\\in [0,n]</span> be publicly known vectors chosen independently and uniformly at random from <span class="math">\\mathbb{G}_1</span>, and <span class="math">\\mathbb{G}_2</span>. Let <span class="math">C_{\\tau_j} = \\langle \\tau^{(1,j)},\\tau^{(2,j)}\\rangle</span>, for <span class="math">j\\in [0,n]</span>, and <span class="math">\\tau_L^{(1,j)}\\in \\mathbb{G}_1^{N / 2^{n - (j + 1)}}</span>, <span class="math">\\tau_R^{(1,j)}\\in \\mathbb{G}_1^{N / 2^{n - (j + 1)}}</span> denote the left and the right halves of the vector <span class="math">\\tau^{(1,j)}</span>, for <span class="math">j\\in [0,n - 1]</span>. Similarly, let <span class="math">\\tau_L^{(2,j)}\\in \\mathbb{G}_2^{N / 2^{n - (j + 1)}}</span>, <span class="math">\\tau_R^{(2,j)}\\in \\mathbb{G}_2^{N / 2^{n - (j + 1)}}</span> denote the left and the right halves of the vector <span class="math">\\tau^{(2,j)}</span>, for <span class="math">j\\in [0,n - 1]</span>. Further, let <span class="math">\\varDelta_L^{(1,j)}=\\langle\\tau_L^{(1,j)},\\tau^{(2,j+1)}\\rangle</span>, <span class="math">\\varDelta_R^{(1,j)}=\\langle\\tau_R^{(1,j)},\\tau^{(2,j+1)}\\rangle</span>, <span class="math">\\varDelta_L^{(2,j)}=\\langle\\tau^{(1,j+1)},\\tau_L^{(2,j)}\\rangle</span>, <span class="math">\\varDelta_R^{(1,j)}=\\langle\\tau^{(1,j+1)},\\tau_R^{(2,j)}\\rangle</span>. For <span class="math">j\\in [0,n - 1]</span>, the quantities <span class="math">\\varDelta_L^{(1,j)},\\varDelta_R^{(1,j)},\\varDelta_L^{(2,j)},\\varDelta_R^{(2,j)}</span> are pre-computed and are part of the public parameters.</p>

    <p class="text-gray-300">Let <span class="math">\\mathrm{pp} \\gets_{R} \\text{dory.setup}(1^{\\lambda}, N)</span>, where <span class="math">\\lambda</span> is security parameter, and <span class="math">N</span> is the vector size-bound on <span class="math">\\mathbf{h}</span> and <span class="math">\\mathbf{s}</span>. Here the public parameters <span class="math">\\mathrm{pp} = (\\mathrm{pp}_{\\mathcal{P}}, \\mathrm{pp}_{\\mathcal{V}})</span>, <span class="math">\\mathrm{pp}_{\\mathcal{P}} = \\{\\tau^{(1,j)}, \\tau^{(2,j)} \\mid j \\in [0,n])\\}</span>, and <span class="math">\\mathrm{pp}_{\\mathcal{V}} = \\{C_{\\tau_j}, \\varDelta_L^{(1,j)}, \\varDelta_R^{(1,j)}, \\varDelta_L^{(2,j)}, \\varDelta_R^{(2,j)} \\mid j \\in [0,n-1])\\}</span>.</p>

    <h2 id="sec-68" class="text-2xl font-bold">G.2 Dory Protocol</h2>

    <p class="text-gray-300">The Dory argument system is given in Protocol 7. <span class="math">\\mathsf{pp}</span> is generated as described in Section G.1. It is an argument of knowledge for the following relation</p>

    <div class="my-4 text-center"><span class="math-block">\\{C, C _ {\\mathbf {h}}, C _ {\\mathbf {s}}, D \\leq N \\mid \\exists \\mathbf {h} \\in \\mathbb {G} _ {1} ^ {D}, \\mathbf {s} \\in \\mathbb {G} _ {2} ^ {D}, \\text{ such that } \\\\ C = \\prod_ {i \\in [ 0, D - 1 ]} e (h _ {i}, s _ {i}), \\quad C _ {\\mathbf {h}} = \\prod_ {i \\in [ 0, D - 1 ]} e (h _ {i}, \\tau_ {i} ^ {(2, d)}), \\\\ C _ {\\mathbf {s}} = \\prod_ {i \\in [ 0, D - 1 ]} e \\left(\\tau_ {i} ^ {(1, d)}, s _ {i}\\right) \\\\</span></div>

    <p class="text-gray-300">The Dory protocol proceeds in <span class="math">d</span> rounds (for loop at Step 2 corresponds to the <span class="math">d</span> rounds), and at each round the size of the instance is reduced by half. At the end of <span class="math">d</span> rounds the size of instance is one and can be checked trivially by the verifier (Steps 10-11). We describe one round of the argument system (that is Steps 2-9), where the instance size is reduced by half.</p>

    <p class="text-gray-300"><strong>Round</strong> <span class="math">j</span>: At the beginning of round <span class="math">j</span> the verifier has knowledge of <span class="math">C_1^{(j + 1)}, C_2^{(j + 1)}, C_3^{(j + 1)}</span> defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">C _ {1} ^ {(j + 1)} = \\langle \\mathbf {h} ^ {(j + 1)}, \\mathbf {s} ^ {(j + 1)} \\rangle , \\quad C _ {2} ^ {(j + 1)} = \\langle \\mathbf {h} ^ {(j + 1)}, \\tau^ {(2, j + 1)} \\rangle ,</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {3} ^ {(j + 1)} = \\langle \\tau^ {(1, j + 1)}, \\mathbf {s} ^ {(j + 1)} \\rangle</span></div>

    <p class="text-gray-300">Here, for <span class="math">j \\in [0,d - 1]</span>, <span class="math">\\tau^{(1,j)}, \\tau^{(2,j)}</span> are as defined in Section G.1, and <span class="math">\\mathbf{h}^{(j)} \\in \\mathbb{G}_1^{D/2^{d-j}}</span>, <span class="math">\\mathbf{s}^{(j)} \\in \\mathbb{G}_2^{D/2^{d-j}}</span>. Additionally, for round <span class="math">j = d - 1</span>: <span class="math">\\mathbf{h}^{(d)} = \\mathbf{h}</span>, <span class="math">\\mathbf{s}^{(d)} = \\mathbf{s}</span>, and hence, <span class="math">C_1^{(d)} = C</span>, <span class="math">C_2^{(d)} = C_{\\mathbf{h}}</span>, <span class="math">C_3^{(d)} = C_{\\mathbf{s}}</span>.</p>

    <p class="text-gray-300"><strong>Protocol 7: Dory Argument System</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{pp} \\leftarrow_ {R} \\text{dory.setup}(1 ^ {\\lambda}, N)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{accept/reject} \\leftarrow \\langle P _ {\\text{dory}}, V _ {\\text{dory}} \\rangle (\\mathfrak {p p}, C, C _ {\\mathbf {h}}, C _ {\\mathbf {s}}, D; \\mathbf {h}, \\mathbf {s})</span></div>

    <p class="text-gray-300">1: Let <span class="math">C_1^{(d)} = C</span>, <span class="math">C_2^{(d)} = C_{\\mathbf{h}}</span>, <span class="math">C_3^{(d)} = C_{\\mathbf{s}}</span>, <span class="math">\\mathbf{h}^{(d)} = \\mathbf{h}</span>, <span class="math">\\mathbf{s}^{(d)} = \\mathbf{s}</span> 2: for <span class="math">j = d - 1</span> to <span class="math">j = 0</span>; <span class="math">j \\text{- do}</span> 3: <span class="math">P_{\\text{dory}} \\rightarrow V_{\\text{dory}}</span>: Compute <span class="math">D_{1,L}, D_{1,R}, D_{2,L}, D_{2,R}</span> as given in Equation 52 and send it to <span class="math">V_{\\text{dory}}</span>.</p>

    <p class="text-gray-300">4: <span class="math">V_{\\text{dory}} \\to P_{\\text{dory}}</span>: Sample <span class="math">\\alpha_j \\in \\mathbb{F}</span> and send to <span class="math">P_{\\text{dory}}</span>. 5: <span class="math">P_{\\text{dory}} \\to V_{\\text{dory}}</span>: Compute <span class="math">s_L</span>, and <span class="math">s_R</span> as in Equation 53 and send it to <span class="math">V_{\\text{dory}}</span>. 6: <span class="math">V_{\\text{dory}} \\to P_{\\text{dory}}</span>: Sample <span class="math">\\beta_j \\in \\mathbb{F}_p</span> and send to <span class="math">P_{\\text{dory}}</span>. 7: <span class="math">P_{\\text{dory}}</span>: Compute <span class="math">\\mathbf{h}^{(j)}</span> and <span class="math">\\mathbf{s}^{(j)}</span> as given in Equation 54. 8: <span class="math">V_{\\text{dory}}</span>: Compute <span class="math">C_1^{(j)}, C_2^{(j)}, C_3^{(j)}</span> as given in Equation 55. 9: end for 10: <span class="math">P_{\\text{dory}} \\to V_{\\text{dory}}</span>: <span class="math">\\mathbf{h}^{(0)} \\in \\mathbb{G}_1</span>, <span class="math">\\mathbf{s}^{(0)} \\in \\mathbb{G}_2</span> 11: <span class="math">V_{\\text{dory}}</span>: Accept if the following are true <span class="math-block"> C_1^{(0)} = e(\\mathbf{h}^{(0)}, \\mathbf{s}^{(0)}), C_2^{(0)} = e(\\mathbf{h}^{(0)}, \\tau^{(2,0)}) </span> <span class="math-block"> C_3^{(0)} = e(\\tau^{(1,0)}, \\mathbf{s}^{(0)}) </span></p>

    <p class="text-gray-300">In round <span class="math">j</span>, the prover and verifier exchange messages to enable the verifier to compute <span class="math">C_1^{(j)}, C_2^{(j)}, C_3^{(j)}</span> corresponding to vectors <span class="math">\\mathbf{h}^{(j)}, \\mathbf{s}^{(j)}, \\tau^{(1,j)}, \\tau^{(2,j)}</span> using the received messages such that if the prover knows <span class="math">\\mathbf{h}^{(j+1)}, \\mathbf{s}^{(j+1)}, \\tau^{(1,j+1)}, \\tau^{(2,j+1)}</span> then it can (efficiently) compute <span class="math">\\mathbf{h}^{(j)}, \\mathbf{s}^{(j)}</span> such that <span class="math-block"> C_1^{(j)} = \\langle \\mathbf{h}^{(j)}, \\mathbf{s}^{(j)} \\rangle, \\quad C_2^{(j)} = \\langle \\mathbf{h}^{(j)}, \\tau^{(2,j)} \\rangle, \\quad C_3^{(j)} = \\langle \\tau^{(1,j)}, \\mathbf{s}^{(j)} \\rangle </span> Ate Step 3, <span class="math">P_{\\text{dory}}</span> computes <span class="math">D_{1,L}, D_{1,R}, D_{2,L}, D_{2,R}</span> as follows: <span class="math-block"> D_{1,L} = \\langle \\mathbf{h}_L^{(j+1)}, \\tau^{(2,j)} \\rangle </span> <span class="math-block"> D_{1,R} = \\langle \\mathbf{h}_R^{(j+1)}, \\tau^{(2,j)} \\rangle </span> <span class="math-block"> D_{2,L} = \\langle \\tau^{(1,j)}, \\mathbf{s}_L^{(j+1)} \\rangle </span> <span class="math-block"> D_{2,R} = \\langle \\tau^{(1,j)}, \\mathbf{s}_R^{(j+1)} \\rangle \\tag{52} </span> Let <span class="math">\\mathbf{w}_1 = \\mathbf{h}^{(j+1)} + \\alpha_j \\cdot \\tau^{(1,j+1)}</span>, <span class="math">\\mathbf{w}_2 = \\mathbf{s}^{(j+1)} + \\alpha_j^{-1} \\cdot \\tau^{(2,j+1)}</span>. At Step 5, <span class="math">P_{\\text{dory}}</span> computes <span class="math">s_L</span>, and <span class="math">s_R</span> as follows: <span class="math-block"> s_L = \\langle \\mathbf{w}_{1,L}, \\mathbf{w}_{2,R} \\rangle </span> <span class="math-block"> s_R = \\langle \\mathbf{w}_{1,R}, \\mathbf{w}_{2,L} \\rangle \\tag{53} </span> At Step 7, <span class="math">P_{\\text{dory}}</span> computes <span class="math">\\mathbf{h}^{(j)}</span> and <span class="math">\\mathbf{s}^{(j)}</span> as follows: <span class="math-block"> \\mathbf{h}^{(j)} = \\mathbf{w}_{1,L}^{\\beta_j} \\cdot \\mathbf{w}_{1,R}^{\\beta_j^{-1}} </span> <span class="math-block"> \\mathbf{s}^{(j)} = \\mathbf{w}_{2,L}^{\\beta_j^{-1}} \\cdot \\mathbf{w}_{2,R}^{\\beta_j} \\tag{54} </span> To compute <span class="math">C_1^{(j)}, C_2^{(j)}, C_3^{(j)}</span> at Step 8, <span class="math">V_{\\text{dory}}</span> first computes <span class="math">\\langle \\mathbf{w}_1, \\mathbf{w}_2 \\rangle</span> <span class="math-block"> \\langle \\mathbf{w}_1, \\mathbf{w}_2 \\rangle = C_1^{(j+1)} \\cdot (C_3^{(j+1)})^{\\alpha_j} \\cdot (C_2^{(j+1)})^{\\alpha_j^{-1}} \\cdot (\\langle \\tau^{(1,j+1)}, \\tau^{(2,j+1)} \\rangle) </span> Finally at Step 8, <span class="math">C_1^{(j)}, C_2^{(j)}, C_3^{(j)}</span> is computed as follows: <span class="math-block"> C_1^{(j)} = (\\langle \\mathbf{w}_1, \\mathbf{w}_2 \\rangle) \\cdot s_L^{\\beta_j^2} \\cdot s_R^{\\beta_j^{-2}} </span> <span class="math-block"> C_2^{(j)} = D_{1,L}^{\\beta_j} \\cdot (\\Delta_{1,L}^{(j)})^{\\beta_j \\alpha_j} \\cdot D_{1,R}^{\\beta_j^{-1}} \\cdot (\\Delta_{1,R}^{(j)})^{\\beta_j^{-1} \\alpha_j} </span> <span class="math-block"> C_3^{(j)} = D_{1,L}^{\\beta_j^{-1}} \\cdot (\\Delta_{2,L}^{(j)})^{\\beta_j^{-1} \\alpha_j^{-1}} \\cdot D_{1,R}^{\\beta_j} \\cdot (\\Delta_{2,R}^{(j)})^{\\beta_j \\alpha_j^{-1}} \\tag{55} </span> It can be easily verified that <span class="math">\\mathbf{h}^{(j)}</span>, and <span class="math">\\mathbf{s}^{(j)}</span> as defined at Step 5, and <span class="math">C_1^{(j)}, C_2^{(j)}, C_3^{(j)}</span> as defined at Step 6 satisfy <span class="math-block"> C_1^{(j)} = \\langle \\mathbf{h}^{(j)}, \\mathbf{s}^{(j)} \\rangle, \\quad C_2^{(j)} = \\langle \\mathbf{h}^{(j)}, \\tau^{(2,j)} \\rangle, \\quad C_3^{(j)} = \\langle \\tau^{(1,j)}, \\mathbf{s}^{(j)} \\rangle </span></p>

    <h2 id="sec-69" class="text-2xl font-bold">Protocol 8: Evaluation Proof using Dory</h2>

    <p class="text-gray-300"><span class="math">\\mathrm{pp} \\leftarrow_R</span> dory.setup<span class="math">(1^{\\lambda}, N)</span> accept/reject <span class="math">\\leftarrow \\langle P_{\\text{dory\\_eval}}, V_{\\text{dory\\_eval}} \\rangle(\\mathsf{pp}, C_f, D, u, v; \\mathbf{f})</span></p>

    <p class="text-gray-300">1: Let <span class="math">C_1^{(d)} = C_f</span>, <span class="math">C_2^{(d)} = \\langle \\tau^{1,d}, \\tau^{2,d} \\rangle</span>, <span class="math">C_3^{(d)} = \\langle \\tau^{1,d}, \\tau^{2,d} \\rangle</span>, <span class="math">\\mathbf{h}^{(d)} = \\tau^{(1,d)}</span>, <span class="math">\\mathbf{s}^{(d)} = g_2^{\\mathbf{f}}</span> 2: <span class="math">P_{\\text{dory}}</span>: Compute <span class="math">\\mathbf{z}^{(d)} = \\otimes_{j \\in [0, d-1]} (1, u^{2^j})</span> 3: <span class="math">V_{\\text{dory}}</span>: Compute <span class="math">q^{(d)} = g_T^y</span></p>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">4: for <span class="math">j = d - 1</span> to <span class="math">j = 0</span>; <span class="math">j</span> - do 5: <span class="math">P_{\\text{dory}} \\to V_{\\text{dory}}</span>: Compute <span class="math">\\theta_L, \\theta_R, \\delta_L, \\delta_R</span> as given in Equations 56-57, and send it to <span class="math">V_{\\text{dory}}</span>. 6: <span class="math">P_{\\text{dory}} \\to V_{\\text{dory}}</span>: Compute <span class="math">D_{1,L}, D_{1,R}, D_{2,L}, D_{2,R}</span> as given in Equation 52 and send it to <span class="math">V_{\\text{dory}}</span>. 7: <span class="math">V_{\\text{dory}} \\to P_{\\text{dory}}</span>: Sample <span class="math">\\alpha_j \\in \\mathbb{F}</span> and send to <span class="math">P_{\\text{dory}}</span>. 8: <span class="math">P_{\\text{dory}} \\to V_{\\text{dory}}</span>: Compute <span class="math">s_L</span>, and <span class="math">s_R</span> as in Equation 53 and send it to <span class="math">V_{\\text{dory}}</span> 9: <span class="math">V_{\\text{dory}} \\to P_{\\text{dory}}</span>: Sample <span class="math">\\beta_j \\in \\mathbb{F}_p</span> and send to <span class="math">P_{\\text{dory}}</span>. 10: <span class="math">P_{\\text{dory}}</span>: Compute <span class="math">\\mathbf{h}^{(j)}</span> and <span class="math">\\mathbf{s}^{(j)}</span> as given in Equation 54. 11: <span class="math">V_{\\text{dory}}</span>: Compute <span class="math">C_1^{(j)}, C_2^{(j)}, C_3^{(j)}</span> as given in Equation 55. 12: <span class="math">P_{\\text{dory}}</span>: Compute <span class="math">\\mathbf{z}^{(j)} = \\beta_j \\cdot \\mathbf{z}_L^{(j+1)} + \\beta_j^{-1} \\cdot \\mathbf{z}_R^{(j+1)}</span> 13: <span class="math">V_{\\text{dory}}</span>: Compute <span class="math">q^{(j)}</span> as in Equation 59. 14: end for 15: <span class="math">P_{\\text{dory}} \\to V_{\\text{dory}}</span>: <span class="math">\\mathbf{h}^{(0)} \\in \\mathbb{G}_1</span>, <span class="math">\\mathbf{s}^{(0)} \\in \\mathbb{G}_2</span> 16: <span class="math">V_{\\text{dory}}</span>: Compute <span class="math">\\mathbf{z}^{(0)} = \\prod_{i \\in [0, d-1]} (\\beta_{d-1-j} + \\beta_{d-1-j}^{-1} \\cdot u^{2^j})</span> 17: <span class="math">V_{\\text{dory}}</span>: Accept if the following are true <span class="math-block"> \\begin{array}{l} C_1^{(0)} = e(\\mathbf{h}^{(0)}, \\mathbf{s}^{(0)}), C_2^{(0)} = e(\\mathbf{h}^{(0)}, \\tau^{(2,0)}) \\\\ C_3^{(0)} = e(\\tau^{(1,0)}, \\mathbf{s}^{(0)}) \\\\ e(g_1^{\\mathbf{z}^{(0)}}, \\mathbf{s}^{(0)}) = q^{(0)} \\\\ \\end{array} </span></p>

    <h2 id="sec-70" class="text-2xl font-bold">G.3 Evaluation Proofs using Dory</h2>

    <p class="text-gray-300">For completeness, in this section, we also state how Dory can be used to evaluate univariate (or multilinear) polynomial at a given point in Protocol 8. The (Fourier) coefficients of the (resp. multilinear) univariate polynomial are committed to using the AFG commitment. In particular, Protocol 8 can be used to prove the following relations for the univariate and multilinear evaluations respectively:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{C_f \\in \\mathbb{G}_T, D \\leq N, u \\in \\mathbb{F}, v \\in \\mathbb{F} \\mid \\exists f \\in \\mathbb{F}_{&amp;lt;D}[Y] \\text{ such that} \\right. \\\\ \\quad C_f = \\prod_{i=0}^{D-1} e(\\tau_i^{(1,d)}, g_2^{f_i}), \\text{ and } \\langle f(u) = v \\rangle \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{C_{\\mathbf{a}} \\in \\mathbb{G}_T, d \\leq n, \\mathbf{x} \\in \\mathbb{F}^d, y \\in \\mathbb{F} \\mid \\exists \\mathbf{a} \\in \\mathbb{F}^D \\text{ such that} \\right. \\\\ \\quad C_{\\mathbf{a}} = \\prod_{i=0}^{D-1} e(\\tau_i^{(1,d)}, g_2^{\\alpha_i}), \\text{ and } \\langle \\tilde{a}(\\mathbf{x}) = y \\rangle \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We explain the protocol for univariate commitment scheme, and the same can be adapted for the multilinear case.</p>

    <p class="text-gray-300">Protocol 8 is similar to Protocol 7, in the sense that it is internally running <span class="math">\\langle P_{\\text{dory}}, V_{\\text{dory}} \\rangle</span> for <span class="math">C = C_{\\mathbf{f}}</span>, <span class="math">C_{\\mathbf{h}} = \\langle \\tau^{1,d}, \\tau^{2,d} \\rangle</span>, <span class="math">C_{\\mathbf{s}} = C_f</span>, where <span class="math">\\mathbf{h} = \\tau^{(1,d)}</span>, <span class="math">\\mathbf{s} = g_2^{\\mathbf{f}}</span>, to open the commitment to <span class="math">\\mathbf{f}</span>. Hence, <span class="math">C_1^{(0)}, C_2^{(0)}</span>, <span class="math">C_3^{(0)}</span> is set accordingly at Step 1. Most of the steps in Protocol 8 are similar to Protocol 7 and we refer to Section G.2 for its description. The protocol involves additional steps to check <span class="math">f(u) = v</span>, which is equivalent to checking <span class="math">\\langle \\mathbf{z}^{(d)}, \\mathbf{f} \\rangle = v</span>, where <span class="math">\\mathbf{z}^{(d)} = \\otimes_{j \\in [0,d-1]} (1, u^{2^j})</span> and <span class="math">\\otimes</span> denote the tensor product. We explain the additional Steps 2-3, 5, 12-13, 16, and the final check at Step 17. At Step 5, <span class="math">P_{\\text{dory}}</span> computes <span class="math">\\theta_L, \\theta_R, \\delta_L, \\delta_R</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\theta_L = \\left\\langle g_1^{\\mathbf{z}^{(j)}}, \\mathbf{s}^{(j)}_{R} \\right\\rangle \\tag{56}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\theta_R = \\left\\langle g_1^{\\mathbf{z}^{(j)}}, \\mathbf{s}^{(j)}_{L} \\right\\rangle \\tag{57}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_L = \\left\\langle g_1^{\\mathbf{z}^{(j)}}, \\tau_R^{(2,j)} \\right\\rangle \\tag{58}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_R = \\left\\langle g_1^{\\mathbf{z}^{(j)}}, \\tau_L^{(2,j)} \\right\\rangle \\tag{59}</span></div>

    <p class="text-gray-300">At Step 13, <span class="math">V_{\\text{dory}}</span> computes <span class="math">\\mathbf{q}^{(j)}</span> as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{q}^{(j)} = q^{(j+1)} \\cdot \\theta_L^{\\beta_j^2} \\cdot \\theta_R^{\\beta_j^{-2}} \\cdot \\delta_L^{\\alpha_j^{-1} \\beta_j^{-2}} \\cdot \\delta_R^{\\alpha_j^{-1} \\beta_j^2} \\tag{60}</span></div>

    <p class="text-gray-300">It is easy to check that for  <span class="math">\\theta_L, \\theta_R, \\delta_L, \\delta_R</span> , and  <span class="math">\\mathbf{q}^{(j)}</span>  as defined for an honest prover we have  <span class="math">\\langle g_1^{\\mathbf{z}^{(j)}}, \\mathbf{s}^{(j)} \\rangle = q^{(j)}</span> , for  <span class="math">j \\in [0, d-1]</span> . Also, the tensor structure of the evaluation point is exploited by  <span class="math">V_{\\mathrm{dory}}</span>  to succinctly compute  <span class="math">\\mathbf{z}^{(0)} = \\prod_{i \\in [0, d-1]} (\\beta_{d-1-j} + \\beta_{d-1-j}^{-1} \\cdot u^{2^j})</span>  at Step 16. Hence, the verifier is succinctly able to check  <span class="math">e(g_1^{\\mathbf{z}^{(0)}}, \\mathbf{s}^{(0)}) = q^{(0)}</span>  at Step 17.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup time(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup size(MB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FFT</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FFT</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">0.74</td>

            <td class="px-3 py-2 border-b border-gray-700">0.62</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">1.42</td>

            <td class="px-3 py-2 border-b border-gray-700">1.19</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">2.60</td>

            <td class="px-3 py-2 border-b border-gray-700">2.36</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">4.83</td>

            <td class="px-3 py-2 border-b border-gray-700">4.38</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">9.47</td>

            <td class="px-3 py-2 border-b border-gray-700">8.51</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">18.94</td>

            <td class="px-3 py-2 border-b border-gray-700">16.80</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Setup Generation of KZG and KZG-FFT</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup time(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup size(MB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">mult-KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FOURIER</td>

            <td class="px-3 py-2 border-b border-gray-700">mult-KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FOURIER</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">0.64</td>

            <td class="px-3 py-2 border-b border-gray-700">1.72</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">1.20</td>

            <td class="px-3 py-2 border-b border-gray-700">4.20</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">2.39</td>

            <td class="px-3 py-2 border-b border-gray-700">12.81</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">4.42</td>

            <td class="px-3 py-2 border-b border-gray-700">44.78</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">8.62</td>

            <td class="px-3 py-2 border-b border-gray-700">167.81</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">17.04</td>

            <td class="px-3 py-2 border-b border-gray-700">643.42</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Setup Generation of multilinear KZG [PST13b] and KZG-FOURIER.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time(sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size(KB)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">4.55</td>

            <td class="px-3 py-2 border-b border-gray-700">1.05</td>

            <td class="px-3 py-2 border-b border-gray-700">46.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">7.26</td>

            <td class="px-3 py-2 border-b border-gray-700">1.18</td>

            <td class="px-3 py-2 border-b border-gray-700">51.18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">12.52</td>

            <td class="px-3 py-2 border-b border-gray-700">1.27</td>

            <td class="px-3 py-2 border-b border-gray-700">56.25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">212</td>

            <td class="px-3 py-2 border-b border-gray-700">23.54</td>

            <td class="px-3 py-2 border-b border-gray-700">1.38</td>

            <td class="px-3 py-2 border-b border-gray-700">61.31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">45.59</td>

            <td class="px-3 py-2 border-b border-gray-700">1.48</td>

            <td class="px-3 py-2 border-b border-gray-700">66.37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">89.29</td>

            <td class="px-3 py-2 border-b border-gray-700">1.59</td>

            <td class="px-3 py-2 border-b border-gray-700">71.43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">177.43</td>

            <td class="px-3 py-2 border-b border-gray-700">1.68</td>

            <td class="px-3 py-2 border-b border-gray-700">76.50</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7: Performance of the AoK for Linear Relations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree Bound</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup time(sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup size(MB)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">3.06</td>

            <td class="px-3 py-2 border-b border-gray-700">0.24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">6.81</td>

            <td class="px-3 py-2 border-b border-gray-700">0.48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">17.95</td>

            <td class="px-3 py-2 border-b border-gray-700">0.95</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">212</td>

            <td class="px-3 py-2 border-b border-gray-700">53.68</td>

            <td class="px-3 py-2 border-b border-gray-700">1.89</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">213</td>

            <td class="px-3 py-2 border-b border-gray-700">175.98</td>

            <td class="px-3 py-2 border-b border-gray-700">3.76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">618.40</td>

            <td class="px-3 py-2 border-b border-gray-700">7.51</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">2227.39</td>

            <td class="px-3 py-2 border-b border-gray-700">15.02</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8: dory-link setup time and setup size</p>

    <p class="text-gray-300">We report additional results corresponding to our commitment schemes and the AoK for grand-product check in this section. Table 5 compares the setup time and setup size of KZG-FFT with KZG. Table 6 compares the setup time and setup size of KZG-FOURIER with multilinear KZG. Here multilinear KZG is an extension of KZG using the factorization from Fact 3 in Section 2. Table 8 reports the setup time and setup size of dory-link. Table 7 report the performance of the AoK for linear relation from Appendix E. Table 9 compares the performance of KZG-FFT and KZG. Table 10 compares the performance of KZG-FOURIER and multilinear KZG. Table 11 compares the performance of our AoK for grand-product check from Appendix 5.3 with the proof system for grand-product check from [GKR08,Tha13]. We employ multilinear KZG to commit to the witness in latter. Finally, in Table 12 we compare the number of operations performed by the prover and the verifier, and the number of field and group elements in the proof of the evaluation protocols of Gemini, Zeromorph, and KZG-FOURIER.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment time(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time(ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size(KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FFT</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FFT</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FFT</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FFT</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">0.26</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">19.83</td>

            <td class="px-3 py-2 border-b border-gray-700">19.51</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">0.45</td>

            <td class="px-3 py-2 border-b border-gray-700">0.55</td>

            <td class="px-3 py-2 border-b border-gray-700">0.51</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

            <td class="px-3 py-2 border-b border-gray-700">19.89</td>

            <td class="px-3 py-2 border-b border-gray-700">19.66</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">0.60</td>

            <td class="px-3 py-2 border-b border-gray-700">0.79</td>

            <td class="px-3 py-2 border-b border-gray-700">0.87</td>

            <td class="px-3 py-2 border-b border-gray-700">0.71</td>

            <td class="px-3 py-2 border-b border-gray-700">19.91</td>

            <td class="px-3 py-2 border-b border-gray-700">19.71</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">1.08</td>

            <td class="px-3 py-2 border-b border-gray-700">1.32</td>

            <td class="px-3 py-2 border-b border-gray-700">1.35</td>

            <td class="px-3 py-2 border-b border-gray-700">1.30</td>

            <td class="px-3 py-2 border-b border-gray-700">19.88</td>

            <td class="px-3 py-2 border-b border-gray-700">19.69</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">2.33</td>

            <td class="px-3 py-2 border-b border-gray-700">3.06</td>

            <td class="px-3 py-2 border-b border-gray-700">2.97</td>

            <td class="px-3 py-2 border-b border-gray-700">2.86</td>

            <td class="px-3 py-2 border-b border-gray-700">19.86</td>

            <td class="px-3 py-2 border-b border-gray-700">19.59</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">3.74</td>

            <td class="px-3 py-2 border-b border-gray-700">5.04</td>

            <td class="px-3 py-2 border-b border-gray-700">5.15</td>

            <td class="px-3 py-2 border-b border-gray-700">4.61</td>

            <td class="px-3 py-2 border-b border-gray-700">19.86</td>

            <td class="px-3 py-2 border-b border-gray-700">19.67</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

            <td class="px-3 py-2 border-b border-gray-700">0.12</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 9: Comparison of KZG vs KZG-FFT</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment time(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover time(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time(ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size(KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FOURIER</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FOURIER</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FOURIER</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FOURIER</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">0.26</td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">7.21</td>

            <td class="px-3 py-2 border-b border-gray-700">182.66</td>

            <td class="px-3 py-2 border-b border-gray-700">44.48</td>

            <td class="px-3 py-2 border-b border-gray-700">1.43</td>

            <td class="px-3 py-2 border-b border-gray-700">5.56</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">0.41</td>

            <td class="px-3 py-2 border-b border-gray-700">0.39</td>

            <td class="px-3 py-2 border-b border-gray-700">0.72</td>

            <td class="px-3 py-2 border-b border-gray-700">21.75</td>

            <td class="px-3 py-2 border-b border-gray-700">276.40</td>

            <td class="px-3 py-2 border-b border-gray-700">47.77</td>

            <td class="px-3 py-2 border-b border-gray-700">1.53</td>

            <td class="px-3 py-2 border-b border-gray-700">5.93</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">0.92</td>

            <td class="px-3 py-2 border-b border-gray-700">0.60</td>

            <td class="px-3 py-2 border-b border-gray-700">1.24</td>

            <td class="px-3 py-2 border-b border-gray-700">73.99</td>

            <td class="px-3 py-2 border-b border-gray-700">300.46</td>

            <td class="px-3 py-2 border-b border-gray-700">68.63</td>

            <td class="px-3 py-2 border-b border-gray-700">1.62</td>

            <td class="px-3 py-2 border-b border-gray-700">6.31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">1.21</td>

            <td class="px-3 py-2 border-b border-gray-700">1.73</td>

            <td class="px-3 py-2 border-b border-gray-700">2.00</td>

            <td class="px-3 py-2 border-b border-gray-700">282.35</td>

            <td class="px-3 py-2 border-b border-gray-700">299.43</td>

            <td class="px-3 py-2 border-b border-gray-700">93.42</td>

            <td class="px-3 py-2 border-b border-gray-700">1.71</td>

            <td class="px-3 py-2 border-b border-gray-700">6.68</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">2.51</td>

            <td class="px-3 py-2 border-b border-gray-700">2.77</td>

            <td class="px-3 py-2 border-b border-gray-700">2.91</td>

            <td class="px-3 py-2 border-b border-gray-700">1096.54</td>

            <td class="px-3 py-2 border-b border-gray-700">308.66</td>

            <td class="px-3 py-2 border-b border-gray-700">152.23</td>

            <td class="px-3 py-2 border-b border-gray-700">1.81</td>

            <td class="px-3 py-2 border-b border-gray-700">7.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">4.23</td>

            <td class="px-3 py-2 border-b border-gray-700">4.65</td>

            <td class="px-3 py-2 border-b border-gray-700">4.23</td>

            <td class="px-3 py-2 border-b border-gray-700">4616.05</td>

            <td class="px-3 py-2 border-b border-gray-700">317.92</td>

            <td class="px-3 py-2 border-b border-gray-700">243.04</td>

            <td class="px-3 py-2 border-b border-gray-700">1.90</td>

            <td class="px-3 py-2 border-b border-gray-700">7.43</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 10: Comparison of multilinear KZG vs KZG-FOURIER</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Prover(sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Verifier(ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval Proof size(KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">AIR</td>

            <td class="px-3 py-2 border-b border-gray-700">GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">AIR</td>

            <td class="px-3 py-2 border-b border-gray-700">GKR</td>

            <td class="px-3 py-2 border-b border-gray-700">AIR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">215</td>

            <td class="px-3 py-2 border-b border-gray-700">1.59</td>

            <td class="px-3 py-2 border-b border-gray-700">2.83</td>

            <td class="px-3 py-2 border-b border-gray-700">262.84</td>

            <td class="px-3 py-2 border-b border-gray-700">155.19</td>

            <td class="px-3 py-2 border-b border-gray-700">15.59</td>

            <td class="px-3 py-2 border-b border-gray-700">0.94</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">2.64</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">275.49</td>

            <td class="px-3 py-2 border-b border-gray-700">158.72</td>

            <td class="px-3 py-2 border-b border-gray-700">17.62</td>

            <td class="px-3 py-2 border-b border-gray-700">0.94</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">217</td>

            <td class="px-3 py-2 border-b border-gray-700">3.70</td>

            <td class="px-3 py-2 border-b border-gray-700">6.80</td>

            <td class="px-3 py-2 border-b border-gray-700">285.88</td>

            <td class="px-3 py-2 border-b border-gray-700">164.91</td>

            <td class="px-3 py-2 border-b border-gray-700">19.78</td>

            <td class="px-3 py-2 border-b border-gray-700">0.94</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">6.33</td>

            <td class="px-3 py-2 border-b border-gray-700">14.29</td>

            <td class="px-3 py-2 border-b border-gray-700">301.04</td>

            <td class="px-3 py-2 border-b border-gray-700">198.31</td>

            <td class="px-3 py-2 border-b border-gray-700">22.06</td>

            <td class="px-3 py-2 border-b border-gray-700">0.94</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">12.47</td>

            <td class="px-3 py-2 border-b border-gray-700">32.59</td>

            <td class="px-3 py-2 border-b border-gray-700">306.60</td>

            <td class="px-3 py-2 border-b border-gray-700">285.91</td>

            <td class="px-3 py-2 border-b border-gray-700">24.46</td>

            <td class="px-3 py-2 border-b border-gray-700">0.94</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">22.22</td>

            <td class="px-3 py-2 border-b border-gray-700">48.68</td>

            <td class="px-3 py-2 border-b border-gray-700">320.98</td>

            <td class="px-3 py-2 border-b border-gray-700">428.31</td>

            <td class="px-3 py-2 border-b border-gray-700">27.00</td>

            <td class="px-3 py-2 border-b border-gray-700">0.94</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 11: Metrics corresponding to Grand Product. GKR denotes Grand product using techniques from [GKR08,Tha13], and AIR denotes grand-product check using AoK from Appendix 5.3</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Gemini</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ (d+4)G1+(d+1)F</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ (3D+D)G1+O(D)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(2d+2)G1+2G2+3e</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zeromorph</td>

            <td class="px-3 py-2 border-b border-gray-700">(d+3)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">(5D/2-3+logD+5)G1+O(D)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(2d+2)G1+2G2+3e</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZG-FOURIER</td>

            <td class="px-3 py-2 border-b border-gray-700">4dF+(2d+1)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ O(D log2D)F+O(D logD)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">(5d+3)G1+2G2+2e</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 12: Comparison of Gemini, Zeromorph and KZG-FOURIER for multilinear polynomial. Here  <span class="math">D = 2^{d}</span>  where  <span class="math">d</span>  is the number of variables in the multilinear polynomial, and  <span class="math">e</span>  is a pairing operation.</p>`;
---

<BaseLayout title="Dual Polynomial Commitment Schemes and Applications to Commi... (2024/943)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/943
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
