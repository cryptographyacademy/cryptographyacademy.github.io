---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1799';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'BabySpartan: Lasso-based SNARK for non-uniform computation';
const AUTHORS_HTML = 'Srinath Setty, Justin Thaler';

const CONTENT = `    <p class="text-gray-300">BabySpartan: Lasso-based SNARK for non-uniform computation</p>

    <p class="text-gray-300">Srinath Setty* Justin Thaler</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Lasso (Setty, Thaler, Wahby, ePrint 2023/1216) is a recent lookup argument that ensures that the prover cryptographically commits to only “small” values. This note describes BabySpartan, a SNARK for a large class of constraint systems that achieves the same property. The SNARK is a simple combination of SuperSpartan and Lasso. The specific class of constraint systems supported is a generalization of so-called Plonkish constraint systems (and a special case of customizable constraint systems (CCS)). Whereas a recent work called Jolt (Arun, Setty, and Thaler, ePrint 2023/1217) can be viewed as an application of Lasso to <em>uniform</em> computation, BabySpartan can be viewed as applying Lasso to non-uniform computation.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A succinct non-interactive argument of knowledge (SNARK) <em>[x14, x16, x11]</em> allows an untrusted prover to prove that it knows a witness satisfying some property. Most SNARKs are designed by combining a protocol called a <em>polynomial IOP</em> with a <em>polynomial commitment scheme</em>. Popular examples of polynomial commitment schemes include KZG <em>[x12]</em> and FRI <em>[x1]</em> (for univariate polynomials), and KZG+Gemini <em>[x2]</em>, Zeromorph <em>[x13]</em>, Ligero <em>[x1]</em>, Brakedown <em>[GLS^{+}23]</em>, Hyrax <em>[WTS^{+}18]</em>, and Bulletproofs/IPA <em>[BCC^{+}16, BBB^{+}18]</em> (for univariate or multilinear polynomials).</p>

    <p class="text-gray-300">The notion of Plonkish constraint systems was introduced to roughly capture the most general class of constraint systems that Plonk <em>[x10]</em>, a popular SNARK, can prove statements about. However, the polynomial IOP underlying Plonk requires the prover to commit to many random field elements, even when all variables in the witness are small. Such random field elements are much more expensive to commit to with many polynomial commitment schemes, especially those based on elliptic curve group operations, such as Bulletproofs/IPA, KZG and its variants, and Hyrax.</p>

    <p class="text-gray-300">SuperSpartan <em>[x23]</em>, a natural generalization of Spartan <em>[x20]</em>, is an alternative SNARK for that applies to a substantial generalization of Plonkish constraint systems. This generalization is called <em>customizable constraint systems</em> (CCS). In the case of “uniform” CCS instances, the Super-Spartan prover does <em>not</em> commit to any random values (we will define what we mean by uniform shortly). However, for non-uniform instances of CCS, the SuperSpartan prover does commit to a number of random values that is linear in the number of non-zero entries of the CCS constraint matrices.</p>

    <p class="text-gray-300">In this note, we describe an alternative SNARK, which we refer to as BabySpartan, for Plonkish that avoids the prover committing to random values. This construction is a combination of SuperSpartan <em>[x23]</em> and Lasso <em>[x23]</em> (the latter is also a generalization of a core component of Spartan <em>[x20]</em> to obtain a lookup argument). In particular, BabySpartan can be viewed as a SNARK for non-uniform circuits built from (indexed) lookup arguments.</p>

    <p class="text-gray-300">We hope that BabySpartan makes it easier to combine the performance benefits of Lasso with existing tooling, which often involves non-uniform constraint systems.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Preliminaries</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.1 Background on the sum-check protocol</h3>

    <p class="text-gray-300">Let <span class="math">g</span> be an <span class="math">\\ell</span>-variate polynomial over field <span class="math">\\mathbb{F}</span>. The sum-check protocol <em>[x14]</em> is an interactive proof for proving claims of the form, where <span class="math">T\\in\\mathbb{F}</span>:</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{x\\in\\{0,1\\}^{\\ell}}g(x).</span> (1)</p>

    <p class="text-gray-300">It consists of <span class="math">\\ell</span> rounds, with the prover sending a univariate polynomial <span class="math">s_{i}</span> in each round <span class="math">i</span>, whereby the degree of <span class="math">s_{i}</span> is at most the degree of <span class="math">g</span> in its <span class="math">i</span>th variable. At the end of the sum-check protocol, the verifier must evaluate <span class="math">g(r)</span> for a single <span class="math">r\\in\\mathbb{F}^{\\ell}</span>. Hence, from the verifier’s perspective, the sum-check protocol is a reduction from the task of checking Equation (1), which involves evaluating <span class="math">g</span> at <span class="math">2^{\\ell}</span> inputs and summing the results, to the potentially easier task of evaluating <span class="math">g</span> at the single random point <span class="math">r</span>.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">The sum-check protocol is a perfectly complete interactive proof protocol for proving</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{x\\in\\{0,1\\}^{\\ell}}g(x),</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with soundness error at most $\\ell\\cdot d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The sum-check protocol is public-coin, which means it can be rendered non-interactive via the Fiat-Shamir transformation <em>[x10]</em>. It is known to satisfy round-by-round soundness, and hence if the interactive protocol has soundness error <span class="math">2^{-\\lambda}</span>, the non-interactive protocol obtained by applying Fiat-Shamir has roughly <span class="math">\\lambda</span> bits of security <em>[x2, CCH^{+}19, x1]</em>.</p>

    <p class="text-gray-300">An <span class="math">\\ell</span>-variate polynomial is said to be multilinear if it has degree at most one in each variable. It is well-known that if <span class="math">g(x)=\\prod_{i=1}^{k}p_{i}(x)</span> where each <span class="math">p_{i}</span> is multilinear, then given as input <span class="math">\\{p_{i}(x)\\colon x\\in\\{0,1\\}^{\\ell},i=1,\\ldots,k\\}</span>, the sum-check protocol prover applied to <span class="math">g</span> can be implemented in <span class="math">O_{k}(2^{\\ell})</span> time, where the <span class="math">O_{k}</span> notation hides a dependence on <span class="math">k</span> that is at most quadratic <em>[x21, x23]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Multilinear extensions</h3>

    <p class="text-gray-300">It is well-known that for any function <span class="math">f\\colon\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span>, there exists a unique <span class="math">\\ell</span>-variate multilinear polynomial <span class="math">\\widetilde{f}</span> such that <span class="math">\\widetilde{f}(x)=f(x)</span> for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>. We refer to <span class="math">\\widetilde{f}</span> as the multilinear extension of <span class="math">f</span>.</p>

    <p class="text-gray-300">For a vector <span class="math">a\\in\\mathbb{F}^{n}</span>, where <span class="math">n</span> is a power of <span class="math">2</span>, we similarly define the multilinear extension <span class="math">\\widetilde{a}\\colon\\mathbb{F}^{\\log n}\\to\\mathbb{F}</span> as follows. Interpret <span class="math">a</span> in the natural way as listing all <span class="math">n</span> evaluations of a function with domain <span class="math">\\{0,1\\}^{\\log n}</span>, and define <span class="math">\\widetilde{a}</span> to be the multilinear extension of this function.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Lagrange basis polynomials.</h4>

    <p class="text-gray-300">For any <span class="math">S\\in\\{0,1\\}^{\\ell}</span>, let</p>

    <p class="text-gray-300"><span class="math">\\chi_{S}(x)=\\prod_{i=1}^{\\ell}(x_{i}\\cdot S_{i}+(1-x_{i})\\cdot(1-S_{i}))</span></p>

    <p class="text-gray-300">denote the <span class="math">S</span>’th multilinear Lagrange basis polynomial. For example, if <span class="math">\\ell=4</span> and <span class="math">S=(0,1,1,0)</span>, then <span class="math">\\chi_{S}(x)=(1-x_{i})\\cdot x_{2}\\cdot x_{3}\\cdot(1-x_{4})</span>.</p>

    <p class="text-gray-300">The following lemma is also well-known. Below, we index entries of <span class="math">a\\in\\mathbb{F}^{n}</span> by integers in <span class="math">\\{0,1,\\ldots,n-1\\}</span>, and, in the natural way, associate each such integer with a bit vector in <span class="math">\\{0,1\\}^{\\log n}</span> and vice versa.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Lemma 1 (Multilinear Lagrange interpolation).</h6>

    <p class="text-gray-300">For any vector <span class="math">a\\in\\mathbb{F}^{n}</span>, <span class="math">\\widetilde{a}(r)=\\sum_{i=0}^{n-1}a_{i}\\cdot\\chi_{i}(r)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\widetilde{\\mathfrak{eq}}_{\\ell}\\colon\\mathbb{F}^{\\ell}\\times\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> be the following multilinear polynomial:</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathfrak{eq}}_{\\ell}(x,y)=\\prod_{j=1}^{\\ell}\\left(x_{j}\\cdot y_{j}+(1-x_{j})\\cdot(1-y_{j})\\right).</span></p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathfrak{eq}}_{\\ell}</span> is the unique multilinear polynomial satisfying, for all <span class="math">x,y\\in\\{0,1\\}^{\\ell}</span>,</p>

    <p class="text-gray-300">\\[ \\tilde{\\mathfrak{eq}}_{\\ell}(x,y)=\\begin{cases}1\\text{ if }x=y\\\\ 0\\text{ otherwise.}\\end{cases} \\]</p>

    <p class="text-gray-300">That is, <span class="math">\\tilde{\\mathfrak{eq}}_{\\ell}</span> is the so-called multilinear extension of the equality function over <span class="math">\\{0,1\\}^{\\ell}\\times\\{0,1\\}^{\\ell}</span>. Note that for any <span class="math">S\\in\\{0,1\\}^{\\ell}</span>, <span class="math">\\tilde{\\mathfrak{eq}}_{\\ell}(S,y)=\\chi_{S}(y)</span>. We omit the subscript <span class="math">\\ell</span> from <span class="math">\\tilde{\\mathfrak{eq}}_{\\ell}</span> when <span class="math">\\ell</span> is clear from context.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.3 Customizable constraint systems</h3>

    <p class="text-gray-300">The following notion of customizable constraint systems (CCS) is defined in <em>[x21]</em>. CCS generalizes popular constraint systems including Plonkish, R1CS, and AIR without overheads.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.1 (CCS).</h6>

    <p class="text-gray-300">A CCS structure <span class="math">\\mathcal{S}</span> consists of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>size bounds <span class="math">m,n,N,\\ell,t,q,d\\in\\mathbb{N}</span> where <span class="math">n&gt;\\ell</span>;</li>

      <li>a sequence of matrices <span class="math">M_{0},\\ldots,M_{t-1}\\in\\mathbb{F}^{m\\times n}</span> with at most <span class="math">N=\\Omega(\\max(m,n))</span> non-zero entries in total;</li>

      <li>a sequence of <span class="math">q</span> multisets <span class="math">[S_{0},\\ldots,S_{q-1}]</span>, where an element in each multiset is from the domain</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\{0,\\ldots,t-1\\}</span></p>

    <p class="text-gray-300">and the cardinality of each multiset is at most <span class="math">d</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a sequence of <span class="math">q</span> constants <span class="math">[c_{0},\\ldots,c_{q-1}]</span>, where each constant is from <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">A CCS instance consists of public input <span class="math">x\\in\\mathbb{F}^{\\ell}</span>. A CCS witness consists of a vector <span class="math">w\\in\\mathbb{F}^{n-\\ell-1}</span>. A CCS structure-instance tuple <span class="math">(\\mathcal{S},x)</span> is satisfied by a CCS witness <span class="math">w</span> if</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{q-1}c_{i}\\cdot\\bigcirc_{j\\in S_{i}}M_{j}\\cdot z=\\mathbf{0},</span> (2)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">z=(w,1,x)\\in\\mathbb{F}^{n},</span> (3)</p>

    <p class="text-gray-300"><span class="math">M_{j}\\cdot z</span> denotes matrix-vector multiplication, <span class="math">\\bigcirc</span> denotes the Hadamard product between vectors, and <span class="math">\\mathbf{0}</span> is an <span class="math">m</span>-sized vector with entries equal to the the additive identity in <span class="math">\\mathbb{F}</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.4 Polynomial IOPs and polynomial commitments</h3>

    <p class="text-gray-300">Roughly, a polynomial IOP is an interactive protocol where, in one or more rounds, the prover may send to the verifier a large polynomial <span class="math">g</span>. Because <span class="math">g</span> is so large, one does not wish for the verifier to read a complete description of <span class="math">g</span>. Instead, in any efficient polynomial IOP, the verifier only “queries” <span class="math">g</span> at one point (or a handful of points). This means that the only information the verifier needs about <span class="math">g</span> to check that the prover is behaving honestly is one (or a few) evaluations of <span class="math">g</span>.</p>

    <p class="text-gray-300">In turn, a polynomial commitment scheme enables an untrusted prover to succinctly <em>commit</em> to a polynomial <span class="math">g</span>, and later provide to the verifier any evaluation <span class="math">g(r)</span> for a point <span class="math">r</span> chosen by the verifier, along with a proof that the returned value is indeed consistent with the committed polynomial. Essentially, a polynomial commitment scheme is exactly the cryptographic primitive that one needs to obtain a succinct argument from a polynomial IOP. Rather than having the prover send a large polynomial <span class="math">g</span> to the verifier as in the polynomial IOP, the argument system prover instead cryptographically commits to <span class="math">g</span> and later reveals any evaluations of <span class="math">g</span> required by the verifier to perform its checks.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2.5 Indexed lookup arguments</p>

    <p class="text-gray-300">A lookup argument allows an untrusted prover to commit to a vector <span class="math">a\\in\\mathbb{F}^{m}</span> and prove that all entries of <span class="math">a</span> reside in some predetermined table <span class="math">t\\in\\mathbb{F}^{n}</span>. In an indexed lookup argument, in addition to a commitment to <span class="math">a\\in\\mathbb{F}^{m}</span>, the verifier is handed a commitment to a second vector <span class="math">b\\in\\mathbb{F}^{m}</span>. The prover claims that for all <span class="math">i=1,\\ldots,m</span>, <span class="math">a_{i}=t_{b_{i}}</span>. We refer to <span class="math">a</span> as the vector of <em>looked-up values</em>, and <span class="math">b</span> as the vector of <em>indices</em>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.2 (Statement proven in an indexed lookup argument).</h6>

    <p class="text-gray-300">Given commitment <span class="math">\\mathsf{cm}_{a}</span> and <span class="math">\\mathsf{cm}_{b}</span>, and a public array <span class="math">T</span> of <span class="math">N</span> field elements, represented as vector <span class="math">t=(t_{0},\\ldots,t_{N-1})\\in\\mathbb{F}^{N}</span> to which the verifier has (possibly) been provided a commitment <span class="math">\\mathsf{cm}_{t}</span>, the prover knows an opening <span class="math">a=(a_{0},\\ldots,a_{m-1})\\in\\mathbb{F}^{m}</span> of <span class="math">\\mathsf{cm}_{a}</span> and <span class="math">b=(b_{0},\\ldots,b_{m-1})\\in\\mathbb{F}^{m}</span> of <span class="math">\\mathsf{cm}_{b}</span> such that for each <span class="math">i=0,\\ldots,m-1</span>, <span class="math">a_{i}=T[b_{j}]</span>, where <span class="math">T[b_{j}]</span> is short hand for the <span class="math">b_{j}</span>’th entry of <span class="math">t</span>.</p>

    <p class="text-gray-300">Lasso <em>[x21]</em> gives an indexed lookup argument where the prover commits to a vector of length <span class="math">m</span>, referred to as “read counts”, and a second vector of length <span class="math">n</span>, referred to as “final counts”. When the prover is honest, all of the read counts and final counts are in <span class="math">\\{0,\\ldots,m\\}</span>,</p>

    <h2 id="sec-12" class="text-2xl font-bold">3 BabySpartan: Lasso-based SNARK for non-uniform circuits</h2>

    <p class="text-gray-300">To describe BabySpartan, it is cleanest to first focus on a popular special case of CCS, namely R1CS. In this case, the prover commits to a witness vector vector <span class="math">z\\in\\mathbb{F}^{n}</span> and the prover’s goal is to prove that <span class="math">Az\\circ Bz=Cz</span> where <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span> are public <span class="math">m\\times n</span> matrices and <span class="math">\\circ</span> denotes the Hadamard (i.e., entry-wise) vector product. BabySpartan can be viewed as a simple modification of SuperSpartan to incorporate Lasso.</p>

    <p class="text-gray-300">Let <span class="math">a=Az</span>, <span class="math">b=Bz</span>, and <span class="math">c=Cz</span>. The SuperSpartan prover runs two instances of the <em>sum-check protocol</em> <em>[x12]</em>. In the first instance, the verifier selects a random <span class="math">\\tau\\in\\mathbb{F}^{\\log m}</span>, and applies the sum-check protocol to the polynomial</p>

    <p class="text-gray-300"><span class="math">g(x)=\\mathsf{elq}(\\tau,x)\\left(\\widetilde{a}(x)\\cdot\\widetilde{b}(x)-\\widetilde{c}(x)\\right),</span></p>

    <p class="text-gray-300">using it to confirm that</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{x\\in\\{0,1\\}^{\\log m}}g(x).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">z</span> satisfies the constraint system then this equality is guaranteed to hold, and if <span class="math">z</span> does not satisfy the constraint system then this equality will fail to hold with probability at least $1-2\\log m/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At the end of this first invocation of the sum-check protocol, the verifier has to evaluate <span class="math">\\widetilde{a}(r)</span>, <span class="math">\\widetilde{b}(r)</span> and <span class="math">\\widetilde{c}(r)</span> at a random point <span class="math">r\\in\\mathbb{F}^{\\log m}</span>. Hence, this first instance of the sum-check protocol reduced the task of checking that <span class="math">z</span> satisfies the constraint system, to the task of evaluating the multilinear extensions of <span class="math">a</span>, <span class="math">b</span>, and <span class="math">c</span> each at a random point <span class="math">r\\in\\mathbb{F}^{\\log m}</span>.</p>

    <p class="text-gray-300">Lasso <em>[x21]</em> provides a protocol for this task when <span class="math">A,B,C</span> have exactly one non-zero entry per row and were committed in a pre-processing phase (using any multilinear polynomial commitment scheme). So, BabySpartan simply invokes Lasso for this task. This completes a description of BabySpartan. For completeness, in the next section we unpack how Lasso works in this context.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.1 Details of using Lasso to compute <span class="math">\\widetilde{a}(r)</span>, <span class="math">\\widetilde{b}(r)</span>, and <span class="math">\\widetilde{c}(r)</span></h3>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Background on SuperSpartan.</h4>

    <p class="text-gray-300">In SuperSpartan <em>[x21]</em>, the verifier invokes the sum-check protocol a second time to reduce the task of computing <span class="math">\\widetilde{a}(r)</span> to that of evaluating <span class="math">\\widetilde{A}(r,r^{\\prime})</span> and <span class="math">\\widetilde{z}(r^{\\prime})</span> for some random <span class="math">r^{\\prime}\\in\\mathbb{F}^{\\log n}</span>, and similarly for <span class="math">\\widetilde{B}</span> and <span class="math">\\widetilde{C}</span>. <span class="math">\\widetilde{z}(r^{\\prime})</span> can be obtained from the commitment to <span class="math">\\widetilde{z}</span>, via one evaluation query at evaluation point <span class="math">r^{\\prime}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\widetilde{A}(r,r^{\\prime})</span> can be evaluated in (poly)logarithmic time, then the verifier can compute this quantity on its own and still run in (poly)logarithmic time (this is what we mean above by “uniform” R1CS instances). But, for general matrices <span class="math">A\\in\\mathbb{F}^{m\\times n}</span>, the amount of time required to evaluate <span class="math">\\widetilde{A}(r,r^{\\prime})</span> may be linear in the number of non-zero entries of <span class="math">A</span>. In this case, SuperSpartan assumes that <span class="math">\\widetilde{A}</span> has been committed in</p>

    <p class="text-gray-300">pre-processing by an honest party, using a so-called sparse polynomial commitment scheme that it describes, called Spark [Set20]. Spark provides a procedure to prove an evaluation of <span class="math">\\widetilde{A}(r,r&#x27;)</span>. Unfortunately, this procedure requires the prover to commit to many random field elements (the number of committed random field elements is proportional to the number of non-zero entries of <span class="math">A</span>). Lasso shows how to avoid the prover needing to commit to random field elements.</p>

    <p class="text-gray-300">Details of Lasso. Lasso is a generalization of Spark. In both Spark and Lasso, the matrix <span class="math">A</span> is committed with dense vectors in the same way. Specifically, the commitment is to two vectors <span class="math">u</span> and <span class="math">v</span> of length <span class="math">m</span>. The first vector <span class="math">u</span> has <span class="math">i</span>'th entry equal to index (in <span class="math">\\{0,\\ldots,n-1\\}</span>) of the unique column with non-zero entry in row <span class="math">i</span> of <span class="math">A</span>. The second vector <span class="math">v</span> has <span class="math">i</span>'th entry equal to <span class="math">A_{i,u_i}</span>). Note that <span class="math">u</span> and <span class="math">v</span> together completely specify the matrix <span class="math">A</span>. In the context of a SNARK for R1CS, such a commitment is created by the verifier (or another trusted party) in a preprocessing step.</p>

    <p class="text-gray-300">The proof of the value of <span class="math">\\widetilde{a}(r)</span>. Recall that <span class="math">a = Az</span>, where <span class="math">A</span> was committed in a preprocessing phase by an honest party as per the above paragraph, and <span class="math">\\widetilde{z}</span> was committed by the prover using any polynomial commitment scheme.</p>

    <p class="text-gray-300">Lasso uses the following expression for <span class="math">\\widetilde{a}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{a}(x) = \\sum_{i=1}^{m} \\widetilde{\\operatorname{eq}}(x,i) \\cdot v_i \\cdot z_{u_i}. \\tag{4}</span></div>

    <p class="text-gray-300">To see that Equation (4) holds, observe that the right hand side is clearly a multilinear polynomial in <span class="math">x</span>. Moreover, it agrees with <span class="math">a</span> for all inputs <span class="math">x \\in \\{0,1\\}^{\\log m}</span>. This holds because, if <span class="math">A_j</span> denotes the <span class="math">j</span>'th column of <span class="math">z</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">a = A z = \\sum_{i=0}^{m-1} A_{i,u_i} \\cdot z_{u_i}.</span></div>

    <p class="text-gray-300">And so the <span class="math">x</span>'th entry of <span class="math">a</span> equals</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{i=1}^{m} \\widetilde{\\operatorname{eq}}(i,x) \\cdot A_{i,u_i} \\cdot z_{u_i} = \\\\ \\sum_{i=1}^{m} \\widetilde{\\operatorname{eq}}(i,x) \\cdot v_i \\cdot z_{u_i}. \\tag{5} \\end{array}</span></div>

    <p class="text-gray-300">Hence, the right hand side of Equation (4) must equal the unique multilinear extension of <span class="math">a</span>.</p>

    <p class="text-gray-300">Accordingly, to prove what is the value of <span class="math">\\widetilde{a}(r)</span>, the Lasso prover commits to a vector <span class="math">w \\in \\mathbb{F}^m</span> whose <span class="math">i</span>'th entry is purportedly <span class="math">z_{u_i}</span>. Lasso then applies the sum-check protocol to the <span class="math">(\\log m)</span>-variate polynomial</p>

    <div class="my-4 text-center"><span class="math-block">g(y) = \\widetilde{\\operatorname{eq}}(r,y) \\cdot \\widetilde{v}(y) \\cdot \\widetilde{w}(y)</span></div>

    <p class="text-gray-300">to confirm that Expression (5) equals the claimed value of <span class="math">\\widetilde{a}(r)</span>. At the end of the sum-check protocol, the verifier needs to evaluate <span class="math">g</span> at a random point <span class="math">r&#x27;&#x27;&#x27;</span>. It can evaluate <span class="math">\\widetilde{\\operatorname{eq}}(r,r&#x27;&#x27;&#x27;)</span> on its own in <span class="math">O(\\log m)</span> time, while <span class="math">\\widetilde{v}(r&#x27;&#x27;&#x27;)</span> and <span class="math">\\widetilde{w}(r&#x27;&#x27;&#x27;)</span> can be obtained from the commitments to <span class="math">\\widetilde{v}</span> and <span class="math">\\widetilde{w}</span> respectively.</p>

    <p class="text-gray-300">All that remains is for the verifier to confirm that <span class="math">\\widetilde{w}(x) = z_{\\widetilde{a}(x)}</span> for all <span class="math">x \\in \\{0,1\\}^{\\log m}</span>. Lasso gives a way to do this based on a technique called offline memory-checking [BEG⁺91, SAGL18, Set20, GLS⁺23].</p>

    <p class="text-gray-300">Specifically, mapping our setting to the indexed lookup argument in Lasso, <span class="math">z</span> is the lookup table, <span class="math">u</span> is the indices of the <span class="math">m</span> lookups, and <span class="math">w</span> is the claimed results of the lookups.</p>

    <p class="text-gray-300">5</p>

    <p class="text-gray-300">For completeness, we sketch how the lookup argument works. Consider the length-<span class="math">m</span> vector <span class="math">q</span> whose <span class="math">i</span>’th entry is the number of rows <span class="math">j\\leq i</span> with <span class="math">u_{j}=u_{i}</span>. The prover commits to a length-<span class="math">m</span> vector <span class="math">y</span> whose <span class="math">i</span>’th entry is <span class="math">z_{u_{i}}</span> (here, <span class="math">z</span> can be thought of as a lookup table), as well as a length-<span class="math">m</span> vector <span class="math">\\alpha</span> whose <span class="math">i</span>’th entry is the number of rows <span class="math">j\\leq i</span> with <span class="math">u_{j}=u_{i}</span> (think of these as read-counts, i.e., the <span class="math">i</span>’th row specifies which cell of <span class="math">z</span> is read by the <span class="math">i</span>’th read operation, and <span class="math">\\alpha_{i}</span> describes how many times the memory cell read at time <span class="math">i</span> has been read by earlier read operations), followed by a length-<span class="math">n</span> vector <span class="math">\\beta</span> whose <span class="math">j</span>’th entry is the total number of non-zero entries in column <span class="math">j</span> of <span class="math">A</span> (think of these values as final counts). Using these committed values, Lasso gives a way to confirm that <span class="math">y_{i}=z_{u_{i}}</span> for <span class="math">i=1,\\ldots,m</span>. Roughly speaking, it confirms that the vector of (value, count) pairs returned by read operations is a permutation of the vector of (value, count) pairs obtained by combining the “initialization“ (i.e., commitment to) the lookup table <span class="math">z</span> with the (value, count) pairs obtained by incrementing each read-count by 1.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.2 The SNARK</h3>

    <p class="text-gray-300">In general, our SNARK, BabySpartan, applies to CCS instances in which each constraint matrix <span class="math">M_{0},\\ldots,M_{t-1}</span> has exactly one non-zero entry per row. Our prior work <em>[x21]</em> described a simple and essentially costless transformation from Plonkish constraint systems to CCS that is guaranteed to yield CCS constraint matrices of this form.</p>

    <p class="text-gray-300">Specifically, after the prover commits to the multilinear extension of a purported solution vector <span class="math">z</span> for the CCS instance, SuperSpartan <em>[x21]</em> invokes the sum-check protocol once to reduce the task of confirming that <span class="math">z</span> is a solution, to the task of evaluating <span class="math">\\widetilde{a}_{i}(r)</span> for a random <span class="math">r\\in\\mathbb{F}^{\\log m}</span>, where <span class="math">a_{i}=M_{i}\\cdot z</span> for <span class="math">i=0,\\ldots,t-1</span>. As explained in Section 3.1, Lasso directly gives a SNARK for computing <span class="math">\\widetilde{a}_{i}(r)</span>.</p>

    <p class="text-gray-300">Note that multiple invocations of Lasso can be batched via standard techniques to ensure that the proof length of the various invocations of the sum-check protocol underlying Lasso does not grow with the number <span class="math">t</span> of constraint matrices.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Pre-processing costs.</h4>

    <p class="text-gray-300">In pre-processing, for each constraint matrix, an honest party commits to <span class="math">m</span> column identifiers (i.e., the MLE of the vector <span class="math">u</span>), <span class="math">m</span> values (the MLE of the vector <span class="math">v</span> specifying the non-zero entry in each row), <span class="math">m</span> read-counts (the MLE of the vector <span class="math">\\alpha</span>) and <span class="math">n</span> final-counts (the MLE of the vector <span class="math">\\beta</span>).</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Prover costs.</h4>

    <p class="text-gray-300">The prover commits to (the MLE of) the solution vector <span class="math">z</span> of length <span class="math">n</span>, and for each constraint matrix it commits to (the MLE of) the length-<span class="math">m</span> vector <span class="math">w</span> of claimed results to the lookups into <span class="math">z</span>.</p>

    <p class="text-gray-300">Note that if the prover is honest, none of the committed vectors have any entries larger than those in <span class="math">z</span>, or those of the constraint matrices, or the number <span class="math">m</span> and <span class="math">n</span> of rows and columns of the constraint matrices. This is what we mean when we say the prover only commits to small values. For all of these commitments (including the ones computed in pre-processing), any multilinear polynomial commitment scheme can be used.</p>

    <p class="text-gray-300">The SNARK prover must evaluate <span class="math">M_{i}\\cdot z</span> for each <span class="math">i=0,\\ldots,t-1</span>. The number of field operations required is clearly proportional to the number of non-zero entries of the constraint matrices. On top of this, the Lasso prover performs <span class="math">O(m+n)</span> field operations for each of the <span class="math">t</span> constraint matrices (this does not asymptotically increase prover field work beyond what is required simply to evaluate <span class="math">M_{i}\\cdot z</span>).</p>

    <p class="text-gray-300">The prover provides one evaluation proof for each committed polynomial (for many polynomial commitment schemes, evaluation proofs can be batched, so that both prover and verifier roughly pay for only a single evaluation proof across all committed polynomials and evaluation points).</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Verifier costs.</h4>

    <p class="text-gray-300">The proof size <span class="math">O(\\log^{2}(n+m))</span> field elements, plus the evaluation proof provided for each committed polynomial (see the remark above on batching these evaluation proofs across all committed polynomials). The verifier’s runtime is <span class="math">O(\\log^{2}(n+m))</span> field operations plus the cost of checking the evaluation proofs. The former can be reduced to <span class="math">O(\\log(m+n)\\log\\log(m+n))</span> at the cost of a low-order additive increase in the number of elements the prover commits to (see <em>[x21]</em> for details).</p>

    <p class="text-gray-300">4 Discussion</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Comparison with Diamond and Posen <em>[x10]</em>.</h4>

    <p class="text-gray-300">In a new paper, Diamond and Posen <em>[x10]</em> give an alternative SNARK for Plonkish constraint systems, in which, like BabySpartan, the prover only commits to small values. Their SNARK is based on Hyperplonk <em>[x4]</em> combined with Lasso. Diamond and Posen also give an improvement to the Ligero/Brakedown <em>[x1, GLS^{+}23]</em> hashing-based polynomial commitment scheme, enabling extremely fast commitments to “small” values. Their SNARK for Plonkish is motivated by ease of integration with their polynomial commitment scheme. In particular, it is convenient for them to view the witness vector <span class="math">z</span> as itself being decomposed into columns, where each column potentially satisfies a different size bound. This makes Plonkish constraint systems a natural target, and Hyperplonk a natural starting point for their SNARK.</p>

    <p class="text-gray-300">We think that BabySpartan is conceptually simpler and may have efficiency benefits when combined with elliptic-curve-based commitment schemes. We leave a careful comparison of Diamond and Posen’s SNARK to BabySpartan to near-term future work.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Generalizing BabySpartan to handle arbitrary CCS.</h4>

    <p class="text-gray-300">BabySpartan proves a particular class of CCS including the ones that we obtain from transforming Plonkish to CCS. One might wonder if it is possible to extend BabySpartan to handle general CCS instances in which a row of a CCS matrix might have more than one non-zero entry. There are some possible extensions, but they all end up having the prover pay cryptographic commitment costs proportional to the number of non-zero entries in the CCS matrices (i.e., there are no “free” additions or linear combinations), and require the prover to commit to intermediate state of the linear combinations (i.e., commit to ”partial linear combinations”).</p>

    <p class="text-gray-300">One can achieve a similar effect by transforming general CCS instances to Plonkish instances (which introduces additional addition gates to emulate linear combinations) and then apply BabySpartan. Note that the generality of CCS still allows lower proving costs when SuperSpartan is applied to uniform instances of CCS (meaning that the multilinear extensions of the constraint matrices are efficiently evaluable by the verifier). This is because in this case SuperSpartan itself already has the prover only cryptographically commit to the witness. That is, the prover’s cryptographic costs are proportional only to the size of the witness and not the number of non-zero entries (so the linear combinations are effectively “free”).</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Disclosures.</h4>

    <p class="text-gray-300">Justin Thaler is a Research Partner at a16z crypto and is an investor in various blockchain-based platforms, as well as in the crypto ecosystem more broadly (for general a16z disclosures, see https://www.a16z.com/disclosures/.)</p>

    <h2 id="sec-22" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthu Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Proceedings of the ACM Conference on Computer and Communications Security (CCS), 2017.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2018.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast Reed-Solomon interactive oracle proofs of proximity. In Proceedings of the International Colloquium on Automata, Languages and Programming (ICALP), 2018.</li>

      <li>[BCC^{+}16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2016.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCHO22] Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orru. Gemini: Elastic snarks for diverse environments. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2022.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive Oracle Proofs. In Theory of Cryptography Conference (TCC), 2016.</li>

      <li>[BEG^{+}91] Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. Checking the correctness of memories. In Proceedings of the IEEE Symposium on Foundations of Computer Science (FOCS), 1991.</li>

      <li>[CBBZ23] Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. HyperPlonk: Plonk with linear-time prover and high-degree custom gates. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2023.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Proceedings of the ACM Symposium on Theory of Computing (STOC), 2019.</li>

      <li>[CMS19] Alessandro Chiesa, Peter Manohar, and Nicholas Spooner. Succinct arguments in the quantum random oracle model. In Theory of Cryptography Conference (TCC), pages 1–29, 2019.</li>

      <li>[DP23] Benjamin E. Diamond and Jim Posen. Succinct arguments over towers of binary fields. Cryptology ePrint Archive, Paper 2023/1784, 2023.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Proceedings of the International Cryptology Conference (CRYPTO), pages 186–194, 1986.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Proceedings of the International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), 2013.</li>

      <li>[GLS^{+}23] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad S Wahby. Brakedown: Linear-time and field-agnostic SNARKs for R1CS. In Proceedings of the International Cryptology Conference (CRYPTO), pages 193–226, 2023.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. ePrint Report 2019/953, 2019.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In Proceedings of the ACM Symposium on Theory of Computing (STOC), 1992.</li>

      <li>[KT23] Tohru Kohrita and Patrick Towa. Zeromorph: Zero-knowledge multilinear-evaluation proofs from homomorphic univariate commitments. Cryptology ePrint Archive, Paper 2023/917, 2023.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Proceedings of the International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT), pages 177–194, 2010.</li>

      <li>[LFKN90] Carsten Lund, Lance Fortnow, Howard Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. In Proceedings of the IEEE Symposium on Foundations of Computer Science (FOCS), October 1990.</li>

      <li>[Mic94] Silvio Micali. CS proofs. In Proceedings of the IEEE Symposium on Foundations of Computer Science (FOCS), 1994.</li>

      <li>[SAGL18] Srinath Setty, Sebastian Angel, Trinabh Gupta, and Jonathan Lee. Proving the correct execution of concurrent services in zero-knowledge. In Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI), October 2018.</li>

    </ul>

    <p class="text-gray-300">[Set20] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Proceedings of the International Cryptology Conference (CRYPTO), 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[STW23a] Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct arguments. Cryptology ePrint Archive 2023/552, 2023.</li>

      <li>[STW23b] Srinath Setty, Justin Thaler, and Riad S. Wahby. Lasso: Unlocking the lookup singularity. Cryptology ePrint Archive 2023/1216, 2023.</li>

      <li>[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Proceedings of the International Cryptology Conference (CRYPTO), 2013.</li>

      <li>[WTS^{+}18] Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In Proceedings of the IEEE Symposium on Security and Privacy (S&P), 2018.</li>

    </ul>`;
---

<BaseLayout title="BabySpartan: Lasso-based SNARK for non-uniform computation (2023/1799)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1799
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
