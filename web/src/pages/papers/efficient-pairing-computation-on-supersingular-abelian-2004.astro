---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/375';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient Pairing Computation on Supersingular Abelian Varieties';
const AUTHORS_HTML = 'Paulo S.  L.  M.  Barreto, Steven Galbraith, Colm O hEigeartaigh, Michael Scott';

const CONTENT = `    <p class="text-gray-300">Paulo S. L. M. Barreto¹, Steven Galbraith², Colm Ó hÉigeartaigh³, and Michael Scott³</p>

    <p class="text-gray-300">¹ Department of Computing and Digital Systems Engineering, Escola Politécnica, Universidade de São Paulo. Av. Prof. Luciano Gualberto, tr. 3, n. 158. 05508-900 São Paulo (SP), Brazil. pbarreto@larc.usp.br</p>

    <p class="text-gray-300">² Mathematics Department, Royal Holloway University of London. Egham, Surrey TW20 0EX, UK. steven.galbraith@rhul.ac.uk</p>

    <p class="text-gray-300">³ School of Computing, Dublin City University. Ballymun, Dublin 9, Ireland. {coheigeartaigh,mike}@computing.dcu.ie</p>

    <p class="text-gray-300">Abstract. We present a general technique for the efficient computation of pairings on supersingular Abelian varieties. This formulation, which we call the eta pairing, generalises results of Duursma and Lee for computing the Tate pairing on supersingular elliptic curves in characteristic three.</p>

    <p class="text-gray-300">We then show how our general technique leads to a new algorithm which is about twice as fast as the Duursma-Lee method.</p>

    <p class="text-gray-300">These ideas are then used for elliptic and hyperelliptic curves in characteristic 2 with very efficient results. In particular, the hyperelliptic case is faster than all previously known pairing algorithms.</p>

    <p class="text-gray-300">Keywords: Tate pairing, supersingular curves, pairing-based cryptosystems, efficient algorithms.</p>

    <p class="text-gray-300">Efficient computation of pairings is essential to the large and ever growing area of pairing-based cryptosystems (see e.g. Chapter 10 of [6] or [9] for a comprehensive overview).</p>

    <p class="text-gray-300">There has been a lot of work on efficient implementation of pairings on elliptic curves. Supersingular curves lead to more efficient implementations in terms of processing speed [3, 15, 10] and bandwidth requirements [28, 17] than the best available algorithms for ordinary curves [4]. Pairings on hyperelliptic curves have received considerably less attention than their elliptic counterparts. The best results are by Duursma and Lee [10] for a very special family of supersingular hyperelliptic curves. These results suggest that supersingular hyperelliptic curves may provide similar efficiency to elliptic curves, but these issues have not been at all clear until now.</p>

    <p class="text-gray-300">We tackle this problem by providing criteria under which pairings on supersingular hyperelliptic curves are efficiently computable. Our method is fairly general and includes that of Duursma-Lee <em>[10]</em> as a particular case. We also obtain a significant improvement over previous methods, even in the characteristic three case. We illustrate the method by describing efficient pairing algorithms for supersingular genus 1 and genus 2 curves in characteristic 2.</p>

    <p class="text-gray-300">This paper is organised as follows. Section 2 gives a brief summary on standard techniques for the efficient computation of the Tate pairing. Section 3 discusses the contributions of Duursma and Lee for certain supersingular curves, and section 4 generalises those contributions using the simpler, unified approach of <em>eta pairings</em>. Section 5 shows how the Duursma-Lee results fit into the eta pairing framework and then gives a significant improvement. Sections 6 and 7 explore the consequences of the eta pairing approach for certain elliptic curves and genus 2 curves in characteristic 2. We compare our pairings on genus 2 curves with the work of Rubin and Silverberg in section 9, and present some experimental results in section 10. Finally, we draw our conclusions in section 11.</p>

    <p class="text-gray-300">Parts of this work were presented by one of the authors <em>[2]</em> at the ECC’2004 conference on September 20–22, 2004. Subsequently and independently, on November, 14 2004, a paper <em>[21]</em> containing some results related to those in this paper was posted on the ePrint archive.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 The Tate pairing on supersingular curves</h2>

    <p class="text-gray-300">Let <span class="math">C</span> be a smooth, projective, absolutely irreducible curve over a finite field <span class="math">K=\\mathbb{F}_{q^{k}}</span>. We denote the degree zero divisor class group of <span class="math">C</span> over <span class="math">K</span> by <span class="math">\\mathrm{Pic}_{0}^{K}(C)</span>. Let <span class="math">r</span> be an integer such that <span class="math">r\\mid\\#\\mathrm{Pic}_{0}^{K}(C)</span>. We denote by <span class="math">\\mathrm{Pic}_{0}^{K}(C)[r]</span> the divisor classes of order dividing <span class="math">r</span>.</p>

    <p class="text-gray-300">Let <span class="math">D_{1}</span> be a divisor representing a class in <span class="math">\\mathrm{Pic}_{0}^{K}(C)[r]</span> and let <span class="math">D_{2}</span> be a divisor on <span class="math">C</span> defined over <span class="math">K</span> such that the supports of <span class="math">D_{1}</span> and <span class="math">D_{2}</span> are disjoint. Since <span class="math">rD_{1}</span> is principal there is a function <span class="math">f</span> on <span class="math">C</span> defined over <span class="math">K</span> such that <span class="math">(f)=rD_{1}</span>. The Tate pairing (also called the Tate-Lichtenbaum pairing) is</p>

    <p class="text-gray-300"><span class="math">\\langle D_{1},D_{2}\\rangle_{r}=f(D_{2}).</span></p>

    <p class="text-gray-300">One can show (see Frey and Rück <em>[14]</em>) that the Tate pairing is a well-defined, non-degenerate, bilinear pairing</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Pic}_{0}^{K}(C)[r]\\times\\mathrm{Pic}_{0}^{K}(C)/r\\mathrm{Pic}_{0}^{K}(C)\\to K^{<em>}/(K^{</em>})^{r}.</span></p>

    <p class="text-gray-300">The fact that the Tate pairing is only defined up to <span class="math">r</span>-th powers is often undesirable. To obtain a unique value, one defines the <em>reduced</em> pairing</p>

    <p class="text-gray-300"><span class="math">e(D_{1},D_{2})=\\langle D_{1},D_{2}\\rangle_{r}^{(q^{k}-1)/r}.</span></p>

    <p class="text-gray-300">Throughout the paper we will refer to the extra powering required to compute the reduced pairing as the <em>final exponentiation</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">One very important property of the reduced pairing is the following <em>[15]</em>. Let <span class="math">N=hr</span> for some <span class="math">h</span>.</p>

    <p class="text-gray-300"><span class="math">e(D_{1},D_{2})=\\langle D_{1},D_{2}\\rangle_{r}^{(q^{k}-1)/r}=\\langle D_{1},D_{2}\\rangle_{N}^{(q^{k}-1)/N}.</span> (1)</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Miller’s algorithm in the elliptic case</h3>

    <p class="text-gray-300">We recall how the Tate pairing can be computed in polynomial time using Miller’s algorithm <em>[24]</em>. For simplicity we restrict to the case of elliptic curves. The divisor class group of an elliptic curve is isomorphic to the curve itself, so all divisors may be assumed to have the form <span class="math">D=(P)-(\\infty)</span>.</p>

    <p class="text-gray-300">Let <span class="math">E</span> be an elliptic curve over <span class="math">\\mathbb{F}_{q}</span> and let <span class="math">r\\mid\\#E(\\mathbb{F}_{q})</span> be a prime. Suppose the embedding degree is <span class="math">k</span> (i.e., <span class="math">k</span> is the smallest positive integer such that <span class="math">r\\mid(q^{k}-1)</span>). Let <span class="math">P\\in E[r]</span> and <span class="math">Q\\in E(\\mathbb{F}_{q^{k}})</span>, where typically <span class="math">Q</span> is the image of some multiple of <span class="math">P</span> under a non-rational endomorphism called a distortion map. We construct an <span class="math">\\mathbb{F}_{q^{k}}</span>-rational divisor <span class="math">D</span> equivalent to <span class="math">(Q)-(\\infty)</span> by taking a random point <span class="math">R\\in E(\\mathbb{F}_{q^{k}})</span> and defining <span class="math">D=(Q+R)-(R)</span>. We aim to compute</p>

    <p class="text-gray-300"><span class="math">e(P,Q)=e((P)-(\\infty),D).</span></p>

    <p class="text-gray-300">For every integer <span class="math">n</span> and point <span class="math">P</span> there is a function <span class="math">f_{n,P}</span> such that</p>

    <p class="text-gray-300"><span class="math">(f_{n,P})=n(P)-([n]P)-(n-1)(\\infty).</span></p>

    <p class="text-gray-300">Miller’s algorithm builds up these functions <span class="math">f_{n,P}</span> according to the following formula: If <span class="math">l</span> and <span class="math">v</span> are the lines which arise in the addition rule for adding <span class="math">[n]P</span> and <span class="math">[m]P</span> then we have</p>

    <p class="text-gray-300"><span class="math">f_{n+m,P}=f_{n,P}f_{m,P}l/v.</span></p>

    <p class="text-gray-300">The pairing value <span class="math">\\langle(P)-(\\infty),D\\rangle_{r}</span> is <span class="math">f_{r,P}(D)</span>.</p>

    <p class="text-gray-300">Miller’s algorithm is explicitly described in Algorithm 1. Note that the addition in the final iteration is simplified in that <span class="math">l</span> is a vertical line and <span class="math">v</span> disappears.</p>

    <p class="text-gray-300">Miller’s algorithm can be generalised to general divisor class groups. The basic algorithm is the same, but the functions are more complicated.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Improvements to Miller’s algorithm</h3>

    <p class="text-gray-300">Several improved implementation techniques to compute the reduced Tate pairing on supersingular elliptic curves have been proposed <em>[3, 15]</em>. These include:</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Exploiting properties of the field of definition:</h4>

    <p class="text-gray-300">It is typical in pairing applications to pair a point defined over <span class="math">\\mathbb{F}_{q}</span> with a point defined over <span class="math">\\mathbb{F}_{q^{k}}</span>. Hence it makes sense to represent <span class="math">\\mathbb{F}_{q^{k}}</span> as an extension of <span class="math">\\mathbb{F}_{q}</span> and to try to simplify the operations in <span class="math">\\mathbb{F}_{q^{k}}</span> as much as possible.</p>

    <p class="text-gray-300">The final exponentiation eliminates terms defined over subfields. Hence, terms defined over subfields can be omitted from the calculations. For example, if <span class="math">k&gt;1</span> then the point <span class="math">R</span> can be chosen to be defined over a subfield, in which case all terms <span class="math">l(R)</span> and <span class="math">v(R)</span> may be ignored.</p>

    <p class="text-gray-300">Algorithm 1 Miller’s algorithm (base 2) 0: <span class="math">r</span>, <span class="math">P</span>, <span class="math">Q+R</span>, <span class="math">R</span>, where the binary representation of <span class="math">r</span> is <span class="math">\\{r_{i}\\}</span>. 0: <span class="math">T\\leftarrow P</span>, <span class="math">Q</span>, 1: <span class="math">T\\leftarrow P</span> 2: <span class="math">f\\leftarrow 1</span> 3: for <span class="math">i\\leftarrow\\lfloor\\log_{2}(r)\\rfloor-1</span> downto <span class="math">0</span> do 4: <span class="math">\\triangleright</span> Calculate lines <span class="math">l</span> and <span class="math">v</span> in doubling <span class="math">T</span> 5: <span class="math">T\\leftarrow[2]T</span> 6: <span class="math">f\\leftarrow f^{2}\\cdot l(Q+R)v(R)/(v(Q+R)l(R))</span> 7: if <span class="math">r_{i}=1</span> then 8: <span class="math">\\triangleright</span> Calculate lines <span class="math">l</span> and <span class="math">v</span> in adding <span class="math">P</span> to <span class="math">T</span> 9: <span class="math">T\\leftarrow T+P</span> 10: <span class="math">f\\leftarrow f\\cdot l(Q+R)v(R)/((v(Q+R)l(R))</span> 11: end if 12: end for 13: return <span class="math">f</span></p>

    <p class="text-gray-300">Changing the base in Miller’s algorithm: Miller’s algorithm is usually presented as a loop through the binary expansion of the group order. It is sometimes more efficient to use other bases, for example to write the group order in base three when implementing pairings in characteristic three (in which case, in line 6 of Miller’s algorithm above, we change <span class="math">f^{2}</span> to <span class="math">f^{3}</span> and there are now two cases in the addition step).</p>

    <p class="text-gray-300">Replacing divisors by points: As explained above, the point <span class="math">R</span> can be ignored. In fact, one can choose <span class="math">R=\\infty</span> by <em>[3, Theorem 1]</em>. Hence, the reduced pairing can be computed as</p>

    <p class="text-gray-300"><span class="math">e(P,Q)=f_{r,P}(Q)^{(q^{k}-1)/r},</span></p>

    <p class="text-gray-300">where the function <span class="math">f_{r}</span> is now evaluated on a point rather than on a divisor.</p>

    <p class="text-gray-300">Exploiting the form of the distortion maps and denominator elimination: If the distortion map is chosen so that the <span class="math">x</span>-coordinates always lies in a subfield, then all terms <span class="math">v(Q)</span> may be eliminated. As a result there are no longer any divisions in Miller’s algorithm.</p>

    <p class="text-gray-300">Note that a distortion map with this property can always be obtained by combining with a map into the trace zero subgroup (see <em>[27]</em> for an example of this).</p>

    <p class="text-gray-300">Hamming weight/group order issues: Miller’s algorithm to compute <span class="math">f_{r}</span> involves a number of arithmetic operations proportional to the Hamming weight of <span class="math">r</span>, and for this reason it is advantageous to choose <span class="math">r</span> with low Hamming weight (with respect to the base being used) whenever possible. In many cases it is worth using a small multiple of <span class="math">r</span> which has low Hamming weight and exploiting formula (1).</p>

    <p class="text-gray-300">Speeding up the final exponentiation: The naive way to compute the final powering to <span class="math">(q^{k}-1)/N</span> (for some multiple <span class="math">N</span> of <span class="math">r</span>) has cubic complexity. However, this exponent</p>

    <p class="text-gray-300">has a rather simple structure for supersingular curves when one chooses <span class="math">N</span> to be the full curve order rather than a factor <span class="math">r</span> thereof. By carefully exploiting that structure, one can replace the powering by a few applications of the Frobenius, some multiplications, and one inversion. Details can be found in <em>[3, Appendix A.2]</em>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Pairing value compression:</h4>

    <p class="text-gray-300">It is possible to reduce the bandwidth requirements of pairing values by storing and manipulating traces <em>[28]</em>, or by working on a torus <em>[17]</em>. These methods compress pairing values to half their usual size, or to a third thereof in the case of supersingular elliptic curves with embedding degree 6 in characteristic 3, supersingular genus 2 curves with embedding degree 12 in characteristic 2, or ordinary BN elliptic curves <em>[5]</em> with embedding degree 12 in large prime characteristic.</p>

    <p class="text-gray-300">The techniques mentioned above give impressive results for pairing implementation. For the remainder of the paper we focus on further improvements. We consider only supersingular curves over <span class="math">\\mathbb{F}_{q}</span> with embedding degree <span class="math">k&gt;1</span> and with suitable distortion maps <span class="math">\\psi</span>. We will always be computing a modified pairing</p>

    <p class="text-gray-300"><span class="math">\\hat{e}_{r}(P,Q)=\\langle P,\\psi(Q)\\rangle_{r}</span></p>

    <p class="text-gray-300">where <span class="math">P</span> and <span class="math">Q</span> are defined over <span class="math">\\mathbb{F}_{q}</span>, or its reduced version <span class="math">\\hat{e}(P,Q)=\\hat{e}_{r}(P,Q)^{(q^{k}-1)/r}</span>.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 The Duursma-Lee techniques</h2>

    <p class="text-gray-300">Duursma and Lee <em>[10]</em> gave a significant improvement to the computation of pairings on curves of the form <span class="math">y^{2}=x^{p}-x+d</span> over <span class="math">\\mathbb{F}_{p^{m}}</span> where <span class="math">p\\geq 3</span> and <span class="math">(m,2p)=1</span> (these curves have embedding degree <span class="math">2p</span>). In particular, their results apply to the case of the embedding degree 6 curve in characteristic three.</p>

    <p class="text-gray-300">One crucial aspect of <em>[10]</em> is that they replace the group order <span class="math">r</span> by the value <span class="math">p^{mp}+1</span> which has Hamming weight 2 in base <span class="math">p</span>. Also, the final exponentiation is to the power <span class="math">(p^{2mp}-1)/(p^{pm}+1)=p^{mp}-1</span>, which is simply computing a Frobenius conjugation and a division. Hence, both the final exponentiation and the main body of Miller’s algorithm are simplified, at the expense of extending the main loop from <span class="math">m</span> iterations to <span class="math">mp</span> iterations. Duursma and Lee show the surprising fact that this loop can be shortened from <span class="math">mp</span> iterations to <span class="math">m</span> iterations.</p>

    <p class="text-gray-300">A careful reading of <em>[10]</em> shows that it contains four independent contributions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A nice choice of function for computing <span class="math">pD</span> in the divisor class group;</li>

      <li>The definition of a pairing on <em>points</em> (in <span class="math">g&gt;1</span>). In other words, they propose the use of degenerate divisors rather than general divisors;</li>

      <li>A shorter loop than would be expected for the given group order;</li>

      <li>Incorporating Frobenius operations directly into the formulae (this has a huge saving, since it removes the exponentiation of <span class="math">f</span> to the power <span class="math">p</span> in line 6 of Miller’s algorithm).</li>

    </ol>

    <p class="text-gray-300">Generalising points 1, 2 and 4 is relatively straightforward. In this paper we show how to generalise the loop shortening idea to many other cases.</p>

    <p class="text-gray-300">4 The eta pairing approach</p>

    <p class="text-gray-300">Let <span class="math">C</span> be a curve over <span class="math">\\mathbb{F}_{q}</span> (where <span class="math">q=p^{m}</span>) with a single point at infinity. In all the examples in this paper, <span class="math">C</span> will be an elliptic or hyperelliptic curve. We will always assume that <span class="math">C</span> is supersingular, with even embedding degree <span class="math">k&gt;1</span>, and that there is a distortion map <span class="math">\\psi</span> which allows denominator elimination (i.e., if <span class="math">P\\in C(\\mathbb{F}_{q})</span> then <span class="math">\\psi(P)\\in C(\\mathbb{F}_{q^{k}})</span> has <span class="math">x</span>-coordinate defined over <span class="math">\\mathbb{F}_{q^{k/2}}</span>).</p>

    <p class="text-gray-300">Let <span class="math">D,D^{\\prime}</span> be reduced divisors on <span class="math">C</span> defined over <span class="math">\\mathbb{F}_{q}</span> which represent divisor classes of order dividing <span class="math">N</span>. In all examples in this paper, these divisors will be represented using the Mumford notation (see Cantor <em>[8]</em>) which, in the elliptic curve case, corresponds to just a single point. Let <span class="math">M=(q^{k}-1)/N</span>. We want to efficiently compute the Tate pairing (including the final exponentiation) <span class="math">\\langle D,\\psi(D^{\\prime})\\rangle_{N}^{M}</span>.</p>

    <p class="text-gray-300">Let <span class="math">n\\in\\mathbb{N}</span>. We use the notation <span class="math">D_{n}</span> for a reduced divisor equivalent to <span class="math">nD</span> and <span class="math">f_{n,D}</span> for a function whose divisor is <span class="math">nD-D_{n}-m(\\infty)</span> for some <span class="math">m\\in\\mathbb{N}</span>. In the elliptic case we have <span class="math">D=(P)-(\\infty)</span> and so <span class="math">D_{n}=(nP)-(\\infty)</span> and <span class="math">f_{n,D}</span> is the Miller function introduced in subsection 2.1 . If <span class="math">n\\in\\mathbb{Z}</span> with <span class="math">n&lt;0</span> then <span class="math">nD=(-n)(-D)</span>. We therefore write <span class="math">D_{n}</span> for a divisor equivalent to <span class="math">(-n)(-D)</span> and write <span class="math">f_{n,D}</span> for a function with divisor <span class="math">(-n)(-D)-(D_{n})-m(\\infty)</span> for some <span class="math">m</span>. The Tate pairing is defined to be <span class="math">\\langle D,D^{\\prime}\\rangle_{N}=f_{N,D}(D^{\\prime})</span>.</p>

    <p class="text-gray-300">An important observation is that, for many supersingular curves, multiplication by <span class="math">p</span> has an extremely special form. This has already been exploited by many authors. In this paper we will be concerned with cases where multiplication by some power of <span class="math">p</span> can be represented by an automorphism on the curve (which we will call <span class="math">\\gamma</span>).</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">For <span class="math">T\\in\\mathbb{Z}</span> we define the <em>eta pairing</em> to be</p>

    <p class="text-gray-300"><span class="math">\\eta_{T}(D,D^{\\prime})=f_{T,D}(\\psi(D^{\\prime})).</span> (2)</p>

    <p class="text-gray-300">In general, this definition will not give a non-degenerate, bilinear pairing. The aim of this paper is to explain some cases where the resulting pairing is non-degenerate and bilinear. The key property of the eta pairing is that we do not necessarily demand that <span class="math">TD</span> is equivalent to zero. The aim is to choose values of <span class="math">T</span> which are smaller than <span class="math">N</span>. This is a generalisation of the loop reduction idea of Duursma and Lee.</p>

    <p class="text-gray-300">As we will see, the Duursma-Lee method arises from the choice <span class="math">T=q</span> in the above definition while our improved version uses the choice <span class="math">T=q-N</span>. In the later part of the paper, when discussing running times, we will drop the subscript in the case <span class="math">T=q</span> and refer to the pairing as <span class="math">\\eta</span>. Hence, the notation <span class="math">\\eta_{T}</span> will generally be reserved for the improved version.</p>

    <p class="text-gray-300">The following theorem is the main result of this paper. It relates the eta pairing to the Tate pairing for certain values of <span class="math">T</span>. From this relation one immediately deduces (as long as <span class="math">L,a</span> and <span class="math">T</span> are coprime to <span class="math">N</span>) that the eta pairing (for these values of <span class="math">T</span>) is non-degenerate and bilinear.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">C</span> be a supersingular curve over <span class="math">\\mathbb{F}_{q}</span> with distortion map <span class="math">\\psi</span> and embedding degree <span class="math">k</span> as above. Let <span class="math">D</span> be a divisor on <span class="math">C</span> defined over <span class="math">\\mathbb{F}_{q}</span> with order dividing <span class="math">N\\in\\mathbb{N}</span> and let <span class="math">M=(q^{k}-1)/N</span>. Suppose <span class="math">T\\in\\mathbb{Z}</span> is such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">TD \\equiv \\gamma(D)</span> in the divisor class group where <span class="math">\\gamma</span> is an automorphism of <span class="math">C</span> which is defined over <span class="math">\\mathbb{F}_q</span>.</li>

      <li><span class="math">\\gamma</span> and <span class="math">\\psi</span> satisfy the condition<span class="math">^4</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\gamma \\psi^q(Q) = \\psi(Q) \\tag{3}</span></div>

    <p class="text-gray-300">for all points <span class="math">Q \\in C(\\mathbb{F}_q)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T^a + 1 = LN</span> for some <span class="math">a \\in \\mathbb{N}</span> and <span class="math">L \\in \\mathbb{Z}</span>.</li>

      <li><span class="math">T = q + cN</span> for some <span class="math">c \\in \\mathbb{Z}</span>.</li>

    </ol>

    <p class="text-gray-300">Then</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\langle D, \\psi(D&#x27;) \\rangle_N^M\\right)^L = \\left(\\eta_T(D, D&#x27;)^M\\right)^{aT^{a-1}}.</span></div>

    <h2 id="sec-11" class="text-2xl font-bold">4.1 Proof of Theorem 1</h2>

    <p class="text-gray-300">We split the proof into a number of lemmas.</p>

    <p class="text-gray-300">First note that, since <span class="math">TD</span> is equivalent to <span class="math">\\gamma(D)</span> we have <span class="math">D_{T^i} = \\gamma^i(D)</span>. Write <span class="math">d</span> for the degree of the finite part of <span class="math">D</span>. Then <span class="math">D = \\sum_{j=1}^{d}(P_j) - d(\\infty)</span> and so <span class="math">D_{T^i} = \\sum_{j=1}^{d}(\\gamma^i(P_j)) - d(\\infty)</span>.</p>

    <p class="text-gray-300">The key result is the following.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> With notation as above and <span class="math">D</span> any divisor such that <span class="math">TD</span> is equivalent to <span class="math">\\gamma(D)</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">f_{T,D}(\\psi(D&#x27;))^{TM} = f_{T,TD}(\\psi(D&#x27;))^M.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> We have <span class="math">(f_{T,D}) = TD - D_T - (T - 1)d(\\infty)</span> and <span class="math">(f_{T,D}^T) = T(f_{T,D})</span> and <span class="math">(f_{T,TD}) = TD_T - D_{T^2} - (T - 1)d(\\infty)</span>.</p>

    <p class="text-gray-300">We now use the assumption that <span class="math">TD \\equiv D_T = \\gamma(D)</span>. The pullback (see Silverman [30] Chapter II page 33) satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\gamma^*( \\sum_P n_P(P) ) = \\sum_P \\sum_{S \\in \\gamma^{-1}(P)} n_P e_\\gamma(S)(S) = \\sum_P n_P (\\gamma^{-1}(P)).</span></div>

    <p class="text-gray-300">Hence</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\gamma^*(f_{T,TD}) = \\gamma^*(TD_T - D_{T^2} - (T - 1)d(\\infty)) \\\\ = TD - D_T - (T - 1)d(\\infty) \\\\ = (f_{T,D}). \\end{array}</span></div>

    <p class="text-gray-300">Also, (Silverman [30] pages 33-34)</p>

    <div class="my-4 text-center"><span class="math-block">\\gamma^*(f_{T,TD}) = (\\gamma^* f_{T,TD}) = (f_{T,TD} \\circ \\gamma).</span></div>

    <p class="text-gray-300">Hence, we have (up to a scalar multiple in <span class="math">\\mathbb{F}_q^c</span>)</p>

    <div class="my-4 text-center"><span class="math-block">f_{T,TD} \\circ \\gamma = f_{T,D}.</span></div>

    <p class="text-gray-300"><span class="math">^4</span> An alternative formulation of this condition is <span class="math">\\gamma \\psi^\\pi = \\psi</span> where <span class="math">\\pi</span> is the <span class="math">q</span>-power Frobenius and <span class="math">\\psi^\\pi</span> means the map obtained by applying <span class="math">\\pi</span> to the coefficients of the map <span class="math">\\psi</span>.</p>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">Evaluating at <span class="math">\\psi(D^{\\prime})</span> and raising to the power <span class="math">M</span> (which kills <span class="math">\\mathbb{F}_{q}^{*}</span>) we get</p>

    <p class="text-gray-300"><span class="math">f_{T,TD}(\\gamma(\\psi(D^{\\prime})))^{M}=f_{T,D}(\\psi(D^{\\prime})^{M}.</span></p>

    <p class="text-gray-300">Consider the left hand side of the statement of the Lemma</p>

    <p class="text-gray-300"><span class="math">f_{T,D}(\\psi(D^{\\prime}))^{TM}=(f_{T,TD}(\\gamma(\\psi(D^{\\prime})))^{TM}.</span></p>

    <p class="text-gray-300">Now use the fact that <span class="math">T=q+cN</span> and that <span class="math">NM=(q^{k}-1)</span> so anything raised to the power <span class="math">NM</span> is <span class="math">1</span>. We therefore have that the above is equal to</p>

    <p class="text-gray-300"><span class="math">(f_{T,TD}(\\gamma(\\psi(D^{\\prime})))^{qM}.</span></p>

    <p class="text-gray-300">Interpreting a power of <span class="math">q</span> as action by Frobenius and using the fact that <span class="math">f_{T,TD}</span>, <span class="math">\\gamma</span> and <span class="math">D^{\\prime}</span> are defined over <span class="math">\\mathbb{F}_{q}</span> gives</p>

    <p class="text-gray-300"><span class="math">(f_{T,TD}(\\gamma(\\psi^{q}(D^{\\prime})))^{M}.</span></p>

    <p class="text-gray-300">By condition (3), <span class="math">\\gamma\\psi^{q}=\\psi</span> so we get</p>

    <p class="text-gray-300"><span class="math">f_{T,TD}(\\psi(D^{\\prime}))^{M}</span></p>

    <p class="text-gray-300">which proves the result.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">With notation as above</p>

    <p class="text-gray-300"><span class="math">(f_{T^{a},D})=(f_{T,D}^{T^{a-1}}f_{T,TD}^{T^{a-2}}\\cdots f_{T,T^{a-1}D}).</span></p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We have <span class="math">(f_{T^{a},D})=T^{a}D-D_{T^{a}}-(T^{a}-1)d(\\infty)</span>. Hence</p>

    <p class="text-gray-300"><span class="math">(f_{T,D}^{T^{a-1}}f_{T,TD}^{T^{a-2}}\\cdots f_{T,T^{a-1}D})</span> <span class="math">=T^{a-1}(f_{T,D})+T^{a-2}(f_{T,TD})+\\cdots+(f_{T,T^{a-1}D})</span> <span class="math">=T^{a-1}(TD-D_{T}-(T-1)d(\\infty))+T^{a-2}(TD_{T}-D_{T^{2}}</span> <span class="math">-(T-1)d(\\infty))+\\cdots+TD_{T^{a-1}}-D_{T^{a}}-(T-1)d(\\infty)</span> <span class="math">=T^{a}D-D_{T^{a}}-(T^{a}-1)d(\\infty)</span></p>

    <p class="text-gray-300">which proves the result.</p>

    <p class="text-gray-300">We can now obtain the statement of the theorem:</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">With notation as above</p>

    <p class="text-gray-300"><span class="math">(f_{N,D}(\\psi(D^{\\prime})))^{ML}=(f_{T,D}(\\psi(D^{\\prime})))^{MaT^{a-1}}.</span></p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that <span class="math">f_{N,D}^{L}=f_{LN,D}=f_{T^{a}+1,D}</span>. Since <span class="math">T^{a}+1=LN</span> we know that <span class="math">(T^{a}+1)D\\equiv 0</span>, which implies <span class="math">T^{a}D\\equiv-D</span> and so (up to scalar in <span class="math">\\mathbb{F}_{q}^{*}</span>)</p>

    <p class="text-gray-300"><span class="math">f_{T^{a}+1,D}=f_{T^{a},D}\\cdot v</span></p>

    <p class="text-gray-300">where <span class="math">v</span> is the vertical line through <span class="math">D</span> and <span class="math">-D</span>.</p>

    <p class="text-gray-300">Evaluating at  <span class="math">\\psi(D&#x27;)</span>  and raising to the power  <span class="math">M</span>  we have (since  <span class="math">\\psi</span>  admits denominator elimination)</p>

    <div class="my-4 text-center"><span class="math-block">f _ {N, D} (\\psi (D ^ {\\prime})) ^ {M L} = f _ {T ^ {n}, D} (\\psi (D ^ {\\prime})) ^ {M} \\cdot v (\\psi (D ^ {\\prime})) ^ {M} = f _ {T ^ {n}, D} (\\psi (D ^ {\\prime})) ^ {M}.</span></div>

    <p class="text-gray-300">By Lemma 2 this is</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {j = 0} ^ {\\alpha - 1} f _ {T, T ^ {j} D} \\left(\\psi \\left(D ^ {\\prime}\\right)\\right) ^ {M T ^ {\\alpha - 1 - j}}.</span></div>

    <p class="text-gray-300">Now, substituting  <span class="math">T^j D</span>  for  <span class="math">D</span>  in Lemma 1 implies that</p>

    <div class="my-4 text-center"><span class="math-block">f _ {T, T ^ {j} D} \\left(\\psi \\left(D ^ {\\prime}\\right)\\right) ^ {M T ^ {\\alpha - 1 - j}} = f _ {T, D} ^ {M T ^ {\\alpha - 1}}.</span></div>

    <p class="text-gray-300">Hence the result follows.</p>

    <p class="text-gray-300">We first show how the eta pairing idea explains the loop shortening used by Duursma and Lee.</p>

    <p class="text-gray-300">The elliptic curve of interest is  <span class="math">E: y^2 = x^3 - x + b</span>  over  <span class="math">\\mathbb{F}_{3^m}</span>  where  <span class="math">b = \\pm 1</span>  and  <span class="math">\\gcd(m, 6) = 1</span> . The number of points on this curve is given in Table 1. The tripling formula (see [11, 3]) is  <span class="math">3 = \\phi \\pi^2(x, y)</span>  where  <span class="math">\\pi</span>  is the 3-power Frobenius and  <span class="math">\\phi(x, y) = (x - b, -y)</span> . Note that  <span class="math">\\phi^2(x, y) = (x - 2b, y)</span> ,  <span class="math">\\phi^3 = -1</span>  etc. The distortion map is  <span class="math">\\psi(x, y) = (\\rho - x, \\sigma y)</span>  where  <span class="math">\\sigma^2 = -1</span>  and  <span class="math">\\rho^3 = \\rho + b</span>  (and thus  <span class="math">\\rho^{3^3} = \\rho + 2b</span> ,  <span class="math">\\rho^{3^3} = \\rho</span> ).</p>

    <p class="text-gray-300">Table 1. Order of the curve  <span class="math">E : {y}^{2} = {x}^{3} - x + b</span>  over  <span class="math">{\\mathbb{F}}_{{3}^{m}},b =  \\pm  1</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#E(F3m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">condition</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3m+1+b3(m+1)/2</td>

            <td class="px-3 py-2 border-b border-gray-700">m ≡ 1,11 (mod 12)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3m+1-b3(m+1)/2</td>

            <td class="px-3 py-2 border-b border-gray-700">m ≡ 5,7 (mod 12)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">q = 3^m</span> . It follows that multiplication by  <span class="math">[q]</span>  is  <span class="math">q = 3^m = \\phi^m \\pi^{2m}(x,y) = \\phi^m(x,y)</span> . Hence we take  <span class="math">\\gamma = \\phi^m</span> .</p>

    <p class="text-gray-300">Lemma 4. With notation as above, condition (3) is satisfied.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">q = 3^m</span>  with  <span class="math">m \\equiv 1 \\pmod{6}</span> . Suppose  <span class="math">(x,y) \\in E(\\mathbb{F}_q)</span> . Then  <span class="math">q = \\phi(x,y)</span>  and so  <span class="math">\\gamma = \\phi</span> . Now,  <span class="math">\\psi^q = \\psi^3</span>  and so</p>

    <div class="my-4 text-center"><span class="math-block">\\gamma \\psi^ {q} (x, y) = \\phi (\\rho + b - x, - \\sigma y) = (\\rho + b - x - b, \\sigma y) = (\\rho - x, \\sigma y) = \\psi (x, y).</span></div>

    <p class="text-gray-300">5 Note that all supersingular curves in characteristic three have <span class="math">j</span>-invariant 0 (by Theorem V.4.1 of [30]) and hence are isomorphic over <span class="math">\\overline{\\mathbb{F}}_3</span> ([30] Theorem A.1.2). It follows that all choices of supersingular equations over <span class="math">\\mathbb{F}_{3^m}</span> with fixed embedding degree <span class="math">k</span> are equally secure for pairing applications and so there is no loss of generality from considering just this case.</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">Similarly, when <span class="math">m\\equiv 5\\pmod{6}</span> we have <span class="math">\\gamma=\\phi^{5}=-\\phi^{2}</span> and <span class="math">\\psi^{q}=-\\psi^{3^{2}}</span> and so</p>

    <p class="text-gray-300"><span class="math">\\gamma\\psi^{q}(x,y)=\\phi^{2}(\\rho+2b-x,\\sigma y)=(\\rho+2b-x-2b,\\sigma y)=\\psi(x,y).</span></p>

    <p class="text-gray-300">This completes the proof. ∎</p>

    <p class="text-gray-300">Since condition (3) is satisfied we may apply Theorem 1.</p>

    <p class="text-gray-300">The method of Duursma and Lee computes the eta pairing with respect to the value <span class="math">T=q=3^{m}</span>. In the notation of Theorem 1 we have <span class="math">N=q^{3}+1</span>, <span class="math">M=q^{3}-1</span>, <span class="math">a=3</span>, <span class="math">L=1</span> and <span class="math">c=0</span>. Hence, we have</p>

    <p class="text-gray-300"><span class="math">\\left(\\eta_{T}(P,Q)^{M}\\right)^{3q^{2}}=\\langle P,\\psi(Q)\\rangle_{N}^{M}</span></p>

    <p class="text-gray-300">The formulae given in <em>[10]</em> computes the Tate pairing directly by bringing the powering to <span class="math">3q^{2}</span> into the formulae. Further efficiency is obtained in <em>[10]</em> by using the other three techniques mentioned in section 3.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.1 An improvement on Duursma and Lee</h3>

    <p class="text-gray-300">The power of the eta pairing approach is that one can immediately improve on the Duursma-Lee method giving a further halving of the length of the loop.</p>

    <p class="text-gray-300">We know that the number of points on <span class="math">E(\\mathbb{P}_{q})</span> is <span class="math">N=3^{m}\\pm 3^{(m+1)/2}+1</span> and we have established that <span class="math">[3^{m}]P=\\gamma(P)</span> for some automorphism <span class="math">\\gamma</span>. If <span class="math">P\\in E(\\mathbb{P}_{q})</span> then, since <span class="math">[N]P=\\infty</span>, we deduce that</p>

    <p class="text-gray-300"><span class="math">[\\mp 3^{(m+1)/2}-1]P=[q-N]P=[q]P=\\gamma(P).</span></p>

    <p class="text-gray-300">We can therefore choose <span class="math">T=q-N=\\mp 3^{(m+1)/2}-1</span> (when <span class="math">T</span> is negative we use the relation <span class="math">TD=(-T)(-D)</span>). In the notation of Theorem 1 we have <span class="math">c=-1</span>. Taking <span class="math">a=3</span> gives <span class="math">T^{3}+1=LN</span> where <span class="math">L=\\mp 3^{(m+3)/2}</span>. We have <span class="math">M=(3^{6m}-1)/N</span>. Theorem 1 implies that the pairing satisfies</p>

    <p class="text-gray-300"><span class="math">\\left(\\eta_{T}(P,Q)^{M}\\right)^{3T^{2}}=\\left(\\langle P,\\psi(Q)\\rangle_{N}^{M}\\right)^{L}</span></p>

    <p class="text-gray-300">and so, since 3, <span class="math">T</span> and <span class="math">L</span> are all coprime to <span class="math">N</span>, it is bilinear and non-degenerate.</p>

    <p class="text-gray-300">With this method we can compute the Tate pairing using an algorithm with roughly half as many iterations as the original Duursma-Lee method. However, the final exponentiation is now more complicated since the value <span class="math">M</span> required to obtain a unique pairing value is <span class="math">(3^{3m}-1)(3^{m}+1)(3^{m}\\mp 3^{(m+1)/2}+1)</span>. Unlike the original Duursma-Lee method, this value has terms which are not powers of <span class="math">3^{m}</span>, hence an extra <span class="math">(m+1)/2</span> cubings in the large field are required. Luckily, cubing is faster than a step in the loop of Miller’s algorithm, so this approach does give faster code. Notice that the result of raising to <span class="math">3^{3m}-1</span> produces a unitary value, so that any further inversion reduces to a simple conjugation.</p>

    <p class="text-gray-300">Further exponentiations are also required to transform the value of the eta pairing to a correct Tate pairing value, but the extra cost of these is not very significant (see the end of section 5.2). One possibility is to design cryptosystems using the eta pairing instead of the Tate pairing. On the other hand, for some applications there may be compatibility issues with using a ‘non-standard’ pairing and so the actual Tate pairing value may be required.</p>

    <p class="text-gray-300">5.2 Implementation details</p>

    <p class="text-gray-300">We now give some of the implementation details for the eta pairing in this case. Recall from <em>[10]</em> that, for any point <span class="math">V\\in E(\\mathbb{F}_{q})</span> the function</p>

    <p class="text-gray-300"><span class="math">g_{V}(x,y)=y_{V}^{3}y-(x_{V}^{3}-x+b)^{2}</span></p>

    <p class="text-gray-300">has divisor <span class="math">(g_{V})=3(V)+(-3V)-4(\\infty)</span>.</p>

    <p class="text-gray-300">Consider the eta pairing of <span class="math">P</span> and <span class="math">Q</span> where <span class="math">T=q-N=\\mp 3^{(m+1)/2}-1</span>. If <span class="math">T&lt;0</span> we first replace <span class="math">P</span> by <span class="math">-P</span> and <span class="math">T</span> by <span class="math">-T</span>. From Table 1 it follows that we have <span class="math">T=3^{(m+1)/2}+b</span> when <span class="math">m\\equiv 1,11\\pmod{12}</span> and <span class="math">T=3^{(m+1)/2}-b</span> when <span class="math">m\\equiv 5,7\\pmod{12}</span>.</p>

    <p class="text-gray-300">We are required to compute</p>

    <p class="text-gray-300"><span class="math">f_{T,P}(\\psi(Q))=\\left(\\prod_{i=0}^{(m-1)/2}g_{3^{i}P}(\\psi(Q))^{3^{(m-1)/2-i}}\\right)l(\\psi(Q))</span></p>

    <p class="text-gray-300">where <span class="math">l</span> is a function corresponding to addition of <span class="math">3^{(m+1)/2}P</span> with <span class="math">\\pm P</span>. Note that this final addition cannot be ommited since <span class="math">T</span> is not the order of <span class="math">P</span>.</p>

    <p class="text-gray-300">We now explain that the extra addition can be easily handled.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">With notation as above, let <span class="math">l(x,y)</span> be the line in the final addition of the algorithm. Then <span class="math">l</span> has slope <span class="math">\\lambda=y_{P}</span> if <span class="math">m\\equiv 7,11\\pmod{12}</span> or <span class="math">\\lambda=-y_{P}</span> if <span class="math">m\\equiv 1,5\\pmod{12}</span>.</p>

    <p class="text-gray-300">If <span class="math">m\\equiv 1,11\\pmod{12}</span> the equation for <span class="math">l</span> is <span class="math">y=\\lambda(x-x_{P})+by_{P}</span> and if <span class="math">m\\equiv 5,7\\pmod{12}</span> then the equation for <span class="math">l</span> is <span class="math">y=\\lambda(x-x_{P})-by_{P}</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is straightforward. For example, when <span class="math">m\\equiv 1\\pmod{12}</span> then <span class="math">T=3^{(m+1)/2}+b</span> and <span class="math">[3^{(m+1)/2}]P=\\phi(x_{P}^{3},y_{P}^{3})=(x_{P}^{3}-b,-y_{P}^{3})</span>. The slope is therefore <span class="math">\\lambda=(-y_{P}^{3}-y_{P})/(x_{P}^{3}-b-x_{P})</span>. Using <span class="math">x_{P}^{3}-x_{P}-b=y_{P}^{2}+b</span> gives <span class="math">\\lambda=-y_{P}</span>. The addition is of <span class="math">[3^{(m+1)/2}]P</span> with <span class="math">bP</span>, from which the equation for <span class="math">l(x,y)</span> follows.</p>

    <p class="text-gray-300">The other cases are similar. ∎</p>

    <p class="text-gray-300">The exponent <span class="math">3^{(m-1)/2}</span> is inconvenient and a naive implementation would lead to an unnecessary <span class="math">(m-1)/2</span> cubings. There are two ways to avoid this problem. One method is to bring the powering <span class="math">3^{(m-1)/2}</span> into the formulae as a Frobenius action. The other method, which we adopt here, is to compute the product in reverse, by setting <span class="math">j=(m-1)/2-i</span>. We define <span class="math">P^{\\prime}=3^{(m-1)/2}P</span> which can be efficiently computed as <span class="math">\\phi^{(m-1)/2}\\pi^{m-1}P=\\phi^{(m-1)/2}(x_{P}^{1/3},y_{P}^{1/3})</span>. Then the desired product is</p>

    <p class="text-gray-300"><span class="math">l(\\psi(Q))\\prod_{j=0}^{(m-1)/2}g_{3^{-j}P^{\\prime}}(\\psi(Q))^{3^{j}}.</span></p>

    <p class="text-gray-300">It is then relatively straightforward to obtain an explicit description of the algorithm. We use the notation <span class="math">a^{(i)}</span> for <span class="math">a^{3^{i}}</span>. For example, in the case <span class="math">m\\equiv 1\\pmod{12}</span> one shows that</p>

    <p class="text-gray-300"><span class="math">g_{3^{-j}P^{\\prime}}(\\psi(Q))^{3^{j}}=(\\sigma y_{P}^{(-j)}y_{Q}^{(j)}-u^{2})-\\rho u-\\rho^{2}</span></p>

    <p class="text-gray-300">where <span class="math">u=x_{P}^{(-j)}+x_{Q}^{(j)}+b</span>. The algorithm in this case is given in Algorithm 2.</p>

    <p class="text-gray-300">|  Algorithm 2 Computation of ηT(P,Q) on E(Γ3m): y2 = x3 - x + b, m ≡ 1 (mod 12) case  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  INPUT: P,Q  |   |</p>

    <p class="text-gray-300">|  OUTPUT: ηT(P,Q)  |   |</p>

    <p class="text-gray-300">|  1: P0← -P  |   |</p>

    <p class="text-gray-300">|  2: if T < 0 then T← -T, P← -P  |   |</p>

    <p class="text-gray-300">|  3: let P = (xP, yP), Q = (xQ, yQ)  |   |</p>

    <p class="text-gray-300">|  4: l← the line between 3(m+1)/2P and P0  |   |</p>

    <p class="text-gray-300">|  5: f← l(ψ(Q))  |   |</p>

    <p class="text-gray-300">|  6: for j← 0 to (m-1)/2 do  |   |</p>

    <p class="text-gray-300">|  7: u← xP + xQ + b  |   |</p>

    <p class="text-gray-300">|  8: g← σyP yQ - u2 - ρu - ρ2  |   |</p>

    <p class="text-gray-300">|  9: f← f·g  |   |</p>

    <p class="text-gray-300">|  10: xP← xP1/3, yP← yP1/3  |   |</p>

    <p class="text-gray-300">|  11: xQ← xQ3, yQ← yQ3  |   |</p>

    <p class="text-gray-300">|  12: end for  |   |</p>

    <p class="text-gray-300">|  13: return f(33m-1)(3m+1)(3m-b)(m+1)/2+1)  |   |</p>

    <p class="text-gray-300">Depending on the choice of basis, we can unroll the loop if necessary to exploit the innate sparseness of  <span class="math">g</span> . Cube roots can be calculated quickly using the method described by Barreto [1]. However this is still substantially slower than calculating cubes. Therefore it makes sense to do a precalculation to build a list of all cubes of  <span class="math">x_{P}</span>  and  <span class="math">y_{P}</span> , and to get the cube roots by accessing this list in reverse order. Note however that we only need the 'last' half of the cubes.</p>

    <p class="text-gray-300">The final exponentiation can be obtained for the relatively inexpensive cost of  <span class="math">(m + 1) / 2</span>  extension field cubings, plus nine applications of the  <span class="math">3^{m}</span> -power Frobenius, nine extension field multiplications, one extension field squaring, one more cubing, and one extension field division.</p>

    <p class="text-gray-300">If the Tate pairing is required then we should also power to  <span class="math">3T^2 / L</span> . A sensible strategy seems to be to raise the  <span class="math">\\eta_T</span>  pairing value to  <span class="math">3T^2 q / L</span>  instead, and then to compute the inverse  <span class="math">q</span> -power Frobenius  <span class="math">\\pi</span>  to get rid of the extra  <span class="math">q</span> -th power. Namely, if  <span class="math">u = \\eta_T(P, Q)</span> , then  <span class="math">\\hat{e}(P, Q) = \\pi^{-1}(u^{\\gamma 3^{(m-1)/2}}) u^{\\gamma 3^{(m+1)/2}-2}</span> , which amounts to  <span class="math">m</span>  extra cubings, one squaring, three products, one inverse Frobenius and at most three conjugations, totalling a small amount of extra work compared to the cost of pairing computation.</p>

    <p class="text-gray-300">We now consider the case of the supersingular curve  <span class="math">E: y^2 + y = x^3 + x + b</span>  over  <span class="math">\\mathbb{F}_{2^m}</span>  where  <span class="math">b = 0, 1</span>  and  <span class="math">m</span>  is odd. We will use the ideas presented in section 4. The order of  <span class="math">E</span>  is given in table 2. It follows that the embedding degree in this case is  <span class="math">k = 4</span> .</p>

    <p class="text-gray-300">The field  <span class="math">\\mathbb{F}_{2^{4m}}</span>  has elements  <span class="math">s, t</span>  such that  <span class="math">s^2 = s + 1</span>  and  <span class="math">t^2 = t + s</span> ; we will represent  <span class="math">\\mathbb{F}_{2^{4m}}</span>  using the basis  <span class="math">\\{1, s, t, st\\}</span> . Following [3] we use the distortion map  <span class="math">\\psi(x, y) = (x + s^2, y + sx + t)</span> .</p>

    <p class="text-gray-300">Table 2. Order of the curve  <span class="math">E : {y}^{2} + y = {x}^{3} + x + b</span>  over  <span class="math">{\\mathbb{F}}_{{2}^{m}},b \\in  {\\mathbb{F}}_{2}</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#E(F2m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">condition</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2m+1+(-1)b2(m+1)/2</td>

            <td class="px-3 py-2 border-b border-gray-700">m ≡ 1,7 (mod 8)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2m+1-(-1)b2(m+1)/2</td>

            <td class="px-3 py-2 border-b border-gray-700">m ≡ 3,5 (mod 8)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">P = (x_{P}, y_{P}) \\in E(\\mathbb{F}_{2^{m}})</span> . We define  <span class="math">\\phi(x, y) = (x + 1, y + x)</span> . One can verify that  <span class="math">\\phi^{2}(x, y) = (x, y + 1) = -(x, y)</span> ,  <span class="math">\\phi^{3}(x, y) = (x + 1, y + x + 1)</span> , and  <span class="math">\\phi^{4}(x, y) = (x, y)</span> . One can show by induction that</p>

    <div class="my-4 text-center"><span class="math-block">[ 2 ^ {i} ] P = \\phi^ {i} \\left(x _ {P} ^ {(2 i)}, y _ {P} ^ {(2 i)}\\right) \\tag {4}</span></div>

    <p class="text-gray-300">If  <span class="math">q = 2^m</span>  it follows that  <span class="math">[q]P = \\phi^m(P)</span>  and we are in the setting of our main result (set  <span class="math">\\gamma = \\phi^m</span> ).</p>

    <p class="text-gray-300">For any field element  <span class="math">a</span>  we use the notation  <span class="math">a^{(i)}</span>  for  <span class="math">a^{2^i}</span> . Depending on the field of definition of  <span class="math">a</span>  we will usually have either  <span class="math">a^{(m)} = a</span>  or  <span class="math">a^{(4m)} = a</span> . Hence we can consider the values  <span class="math">(i)</span>  as being modulo  <span class="math">m</span>  or  <span class="math">4m</span> . This allows us to extend to negative values by  <span class="math">a^{(-i)} = a^{(4m - i)}</span> , which can also be interpreted as the  <span class="math">2^i</span> -th root of  <span class="math">a</span> .</p>

    <p class="text-gray-300">For future reference we compute how  <span class="math">s</span>  and  <span class="math">t</span>  and  <span class="math">\\psi</span>  behave under powers of the 2-power Frobenius. Element  <span class="math">s</span>  satisfies  <span class="math">s^{(1)} = s^2 = s + 1</span> ,  <span class="math">s^{(2)} = s</span> , and thus  <span class="math">s^{(i)} = s + i</span>  and  <span class="math">s^{(-i)} = s^{(4m - i)} = s + i</span> . Similarly for  <span class="math">t, t^{(1)} = t + s, t^{(2)} = t + 1, t^{(3)} = t + s + 1, t^{(4)} = t</span> , and thus  <span class="math">t^{(i)} = t + is + \\tau(i)</span>  where  <span class="math">\\tau(i) = 0</span>  for  <span class="math">i \\equiv 0, 1 \\pmod{4}</span>  and  <span class="math">\\tau(i) = 1</span>  for  <span class="math">i \\equiv 2, 3 \\pmod{4}</span> . Hence,  <span class="math">t^{(-i)} = t^{(4m - i)} = t + is + \\tau(-i)</span> .</p>

    <p class="text-gray-300">We now show that the eta pairing can be applied in this case.</p>

    <p class="text-gray-300">Lemma 6. Let notation be as above, in particular,  <span class="math">q = 2^m</span>  and  <span class="math">\\gamma = \\phi^m</span> . Then condition (3) is satisfied.</p>

    <p class="text-gray-300">Proof. We must show that  <span class="math">\\gamma \\psi^q = \\psi</span> . Consider first the case  <span class="math">m \\equiv 1 \\pmod{4}</span> . We have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\gamma \\psi^ {2 ^ {m}} (x, y) = \\phi \\psi^ {2} (x, y) = \\phi (x + s, y + s ^ {2} x + (t + s)) \\\\ = (x + s + 1, y + s ^ {2} x + t + s + x + s) \\\\ = (x + s ^ {2}, y + s x + t) \\\\ = \\psi (x, y). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Similarly, when  <span class="math">m \\equiv 3 \\pmod{4}</span>  we find that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\gamma \\psi^ {2 ^ {m}} (x, y) = \\phi^ {3} \\psi^ {2 ^ {3}} (x, y) = \\phi^ {3} (x + s, y + s ^ {2} x + (t + s + 1)) \\\\ = (x + s + 1, y + s ^ {2} x + t + s + 1 + x + s + 1) \\\\ = \\psi (x, y). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This completes the proof.</p>

    <p class="text-gray-300">To generalise the Duursma-Lee idea to characteristic 2 is now straightforward using Theorem 1. Let  <span class="math">N = 2^{2m} + 1</span>  and  <span class="math">M = 2^{2m} - 1</span> . We take  <span class="math">T = q = 2^m</span>  (so that  <span class="math">c = 0</span> ) and take  <span class="math">a = 2</span>  so that  <span class="math">T^2 + 1 = NL</span>  where  <span class="math">L = 1</span> . Then the eta pairing satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\eta_ {T} (P, Q) ^ {M}\\right) ^ {2 q} = \\langle P, \\psi (Q) \\rangle_ {N} ^ {M}.</span></div>

    <p class="text-gray-300">Adapting the other methods of <em>[10]</em> gives a very fast pairing computation in characteristic <span class="math">2</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">6.1 A further improvement</h3>

    <p class="text-gray-300">As in characteristic <span class="math">3</span>, we can obtain a further halving of the loop.</p>

    <p class="text-gray-300">Let <span class="math">N=\\#E(\\mathbb{F}_{2^{m}})=2^{m}\\pm 2^{(m+1)/2}+1</span>. For <span class="math">P\\in E(\\mathbb{F}_{2^{m}})</span> we have</p>

    <p class="text-gray-300"><span class="math">[\\mp 2^{(m+1)/2}-1]P=[2^{m}-N]P=\\gamma(P).</span></p>

    <p class="text-gray-300">Taking <span class="math">T=\\mp 2^{(m+1)/2}-1</span> we have <span class="math">T=2^{m}-N</span> so <span class="math">c=-1</span>. Taking <span class="math">a=2</span> gives <span class="math">T^{2}+1=2N</span> so <span class="math">L=2</span>. We have <span class="math">M=((2^{m})^{4}-1)/N=(2^{m}\\mp 2^{(m+1)/2}+1)(2^{2m}-1)</span>. Theorem 1 therefore implies that</p>

    <p class="text-gray-300"><span class="math">\\left(\\eta_{T}(P,Q)^{M}\\right)^{2T}=\\langle P,\\psi(Q)\\rangle_{N}^{2M}</span></p>

    <p class="text-gray-300">from which it follows that</p>

    <p class="text-gray-300"><span class="math">\\left(\\eta_{T}(P,Q)^{M}\\right)^{T}=\\langle P,\\psi(Q)\\rangle_{N}^{M}.</span></p>

    <p class="text-gray-300">We can therefore easily compute the exact Tate pairing using the eta approach in this case. As before, the halving of the loop is slightly offset by the extra squarings required for the final exponentiation, but we still see an overall gain in performance.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">6.2 Implementation details</h3>

    <p class="text-gray-300">Let <span class="math">P,Q\\in E(\\mathbb{F}_{2^{m}})</span> be the input points for the eta pairing with <span class="math">T=\\mp 2^{(m+1)/2}-1</span>. In the case <span class="math">T&lt;0</span> we replace <span class="math">P</span> by <span class="math">-P</span> and <span class="math">T</span> by <span class="math">-T</span>. Thus we have <span class="math">T=2^{(m+1)/2}\\pm 1</span>. To compute the eta pairing we must compute the Miller function <span class="math">f_{T,P}</span>, which will require <span class="math">(m+1)/2</span> doublings and an addition. Note that the addition cannot be ommitted since the point <span class="math">P</span> does not have order <span class="math">T</span>.</p>

    <p class="text-gray-300">Given a point <span class="math">V</span>, it is easy to show that the straight line in doubling <span class="math">V</span> is given by</p>

    <p class="text-gray-300"><span class="math">g_{V}(x,y)=(x_{V}^{2}+1)(x_{V}+x)+y_{V}+y.</span></p>

    <p class="text-gray-300">The function <span class="math">g_{V}</span> has divisor <span class="math">2(V)+(-2V)-3(\\infty)</span>. Hence, by a standard argument similar to the proof of Lemma 2 combined with the fact that we can disregard functions of <span class="math">x</span> only, we have</p>

    <p class="text-gray-300"><span class="math">f_{T,P}(\\psi(Q))=\\left(\\prod_{i=0}^{(m-1)/2}\\left(g_{[2^{i}]P}(\\psi(Q))\\right)^{2^{(m-1)/2-i}}\\right)l(\\psi(Q))</span></p>

    <p class="text-gray-300">where the function <span class="math">l</span> comes from the elliptic curve addition of <span class="math">[2^{(m+1)/2}]P</span> with <span class="math">\\pm P</span>.</p>

    <p class="text-gray-300">The power <span class="math">2^{(m-1)/2}</span> is somewhat inconvenient. A naive implementation might involve <span class="math">(m-1)/2</span> unnecessary squarings because of it. There are two ways around this problem, which both give equally efficient solutions. One solution would be to absorb</p>

    <p class="text-gray-300">the powering by <span class="math">2^{(m-1)/2}</span> into the equations. Another solution is to re-write the expression by substituting <span class="math">j=2^{(m-1)/2}-i</span> and <span class="math">P^{\\prime}=[2^{(m-1)/2}]P</span>. This gives</p>

    <p class="text-gray-300"><span class="math">f_{T,P}(\\psi(Q))=l(\\psi(Q))\\prod_{j=0}^{(m-1)/2}g_{[2^{-j}]P^{\\prime}}(\\psi(Q))^{2^{j}}.</span></p>

    <p class="text-gray-300">Note that, due to our doubling formula, the ‘point halving’ in <span class="math">[2^{-j}]P^{\\prime}</span> has the same efficiency as point doubling. Also note that <span class="math">P^{\\prime}=\\phi^{(m-1)/2}(\\sqrt{x_{P}},\\sqrt{y_{P}})</span>.</p>

    <p class="text-gray-300">We now give some formulae which allow us to present an efficient and general algorithm. The first result gives the equation of the line <span class="math">l</span> for the final addition (note that no inversions are required to compute this). The proof of this result is straightforward.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">Let <span class="math">m</span> and <span class="math">b</span> be as above. Define <span class="math">\\epsilon=-1</span> when <span class="math">m\\equiv 1,7\\pmod{8}</span> and <span class="math">b=1</span> or when <span class="math">m\\equiv 3,5\\pmod{8}</span> and <span class="math">b=0</span>. Define <span class="math">\\epsilon=1</span> in all other cases. Then <span class="math">T</span> is taken to be <span class="math">2^{(m+1)/2}+\\epsilon</span>.</p>

    <p class="text-gray-300">Let <span class="math">P=(x_{P},y_{P})</span>. Define <span class="math">\\lambda=x_{P}</span> when <span class="math">m\\equiv 1,5\\pmod{8}</span> and <span class="math">\\lambda=x_{P}+1</span> when <span class="math">m\\equiv 3,7\\pmod{8}</span>. Then the formula for the line <span class="math">l(x,y)</span> through <span class="math">2^{(m+1)/2}P</span> and <span class="math">\\epsilon P</span> is given by <span class="math">l(x,y)=y+\\lambda(x+x_{P})+y_{P}+(1-\\epsilon)/2</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Lemma 8.</h6>

    <p class="text-gray-300">Let notation be as above. Define <span class="math">v_{1}=1</span> if <span class="math">m\\equiv 1,5\\pmod{8}</span> and <span class="math">v_{1}=0</span> otherwise. Define <span class="math">v_{2}=1</span> if <span class="math">m\\equiv 5,7\\pmod{8}</span> and <span class="math">v_{2}=0</span> otherwise. Define <span class="math">u=x_{P}^{(-j)}+v_{1}</span>. Then the function <span class="math">g_{[2^{-j}]P^{\\prime}}(\\psi(Q))^{2^{j}}</span> is given by</p>

    <p class="text-gray-300"><span class="math">u(x_{P}^{(-1-j)}+x_{Q}^{(j)}+v_{1})+y_{P}^{(-1-j)}+y_{Q}^{(j)}+(1-v_{1})x_{P}^{(-1-j)}+s(u+x_{Q}^{(j)})+t+v_{2}.</span></p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Note that <span class="math">[2^{-j}]P^{\\prime}=\\phi^{(m-1)/2-j}(x_{P}^{(-1-2j)},y_{P}^{(-1-2j)})</span>. The result is proved by a tedious case-by-case analysis.</p>

    <p class="text-gray-300">For example, when <span class="math">m\\equiv 3\\pmod{8}</span> and <span class="math">j\\equiv 2\\pmod{4}</span> then <span class="math">(m-1)/2-j\\equiv 3\\pmod{4}</span> and so <span class="math">[2^{-j}]P^{\\prime}=(x_{P}^{(-1-2j)}+1,y_{P}^{(-1-2j)}+x_{P}^{(-1-2j)}+1)</span>. The function is therefore</p>

    <p class="text-gray-300"><span class="math">\\left((x_{P}^{(-2j)})(x_{P}^{(-1-2j)}+x_{Q}+s)+y_{P}^{(-1-2j)}+x_{P}^{(-1-2j)}+1+y_{Q}+sx_{Q}+t\\right)^{2^{j}}</span> <span class="math">=x_{P}^{(-j)}(x_{P}^{(-1-j)}+x_{Q}^{(j)}+s)+y_{P}^{(-1-j)}+x_{P}^{(-1-j)}+1+y_{Q}^{(j)}+sx_{Q}^{(j)}+t+1.</span></p>

    <p class="text-gray-300">Letting <span class="math">u=x_{P}^{(-j)}</span> this simplifies to</p>

    <p class="text-gray-300"><span class="math">u(x_{P}^{(-1-j)}+x_{Q}^{(j)})+y_{P}^{(-1-j)}+x_{P}^{(-1-j)}+y_{Q}^{(j)}+s(u+x_{Q}^{(j)})+t</span></p>

    <p class="text-gray-300">as required. The other 15 cases are similar. <span class="math">\\Box</span></p>

    <p class="text-gray-300">Here we give the algorithm in the case of a curve with <span class="math">m\\equiv 3\\pmod{8}</span>.</p>

    <p class="text-gray-300">In this optimized algorithm the point addition is dealt with first, using the formula of Lemma 7.</p>

    <p class="text-gray-300">Each step in the subsequent loop costs <span class="math">7\\ \\mathbb{F}_{q}</span> multiplications (<span class="math">1</span> to compute <span class="math">g</span>, <span class="math">6</span> to accumulate it into <span class="math">f</span> by making use of the sparse structure of <span class="math">g</span>). In practise to obtain this speed-up we might have to unroll the loop times <span class="math">2</span> (depending on the basis chosen). The total cost of the loop plus the initial point addition is therefore <span class="math">7(m+1)/2+1</span></p>

    <p class="text-gray-300">Algorithm 3 Computation of <span class="math">\\eta_T(P, Q)</span> on <span class="math">E(\\mathbb{F}_{2^m}): y^2 + y = x^3 + x + b, m \\equiv 3 \\pmod{8}</span> case INPUT: <span class="math">P, Q</span> OUTPUT: <span class="math">\\eta_T(P, Q)</span> 1: let <span class="math">P = (x_P, y_P)</span>, <span class="math">Q = (x_Q, y_Q)</span> 2: <span class="math">u \\gets x_P + 1</span> 3: <span class="math">f \\gets u \\cdot (x_P + x_Q + 1) + y_P + y_Q + b + 1 + (u + x_Q)s + t</span> 4: for <span class="math">i \\gets 1</span> to <span class="math">(m + 1)/2</span> do 5: <span class="math">u \\gets x_P, x_P \\gets \\sqrt{x_P}, y_P \\gets \\sqrt{y_P}</span> 6: <span class="math">g \\gets u \\cdot (x_P + x_Q) + y_P + y_Q + x_P + (u + x_Q)s + t</span> 7: <span class="math">f \\gets f \\cdot g</span> 8: <span class="math">x_Q \\gets x_Q^2, y_Q \\gets y_Q^2</span> 9: end for 10: return <span class="math">f^{(2^2m - 1)(2^m - 2^{(m + 1)/2} + 1)}</span></p>

    <p class="text-gray-300">multiplications. The final exponentiation can be obtained for the relatively inexpensive cost of <span class="math">(m + 1)/2</span> extension field squarings, plus three applications of the <span class="math">2^m</span>-power Frobenius, four extension field multiplications, and one extension field division. To obtain the Tate pairing, the result must be further exponentiated to the power of <span class="math">T</span>.</p>

    <p class="text-gray-300">Unlike the case of characteristic three, there seems to be no reason to precompute and store the square roots. This is because a careful implementation of the technique described in [12] for calculating square roots in the field <span class="math">\\mathbb{F}_{2^m}</span> is in fact just as fast as squaring. In fact it may be a little faster, as large precomputed tables can lead to memory cache misses which are detrimental to performance.</p>

    <h2 id="sec-26" class="text-2xl font-bold">6.3 Compression of pairing elements</h2>

    <p class="text-gray-300">Pairing values lie in the subgroup of order <span class="math">q^2 + 1</span> in <span class="math">\\mathbb{F}_{q^4}^*</span>, which is the torus <span class="math">T_2(\\mathbb{F}_{q^2})</span>. Hence it is trivial to compress pairing values by a factor of 2 using standard torus or trace methods.</p>

    <p class="text-gray-300">In the case of the eta pairing with <span class="math">T = q</span>, the method of Granger, Page and Stam [17] avoids performing the final exponentiation (though note that their compression method requires an inversion so is of similar complexity to the final exponentiation anyway). Their idea is to note that the pairing value <span class="math">e</span> can be written as <span class="math">e = gh = e_0 + e_1t</span> where <span class="math">g</span> has order dividing <span class="math">(q^2 + 1)</span> and where <span class="math">h, e_0, e_1 \\in \\mathbb{F}_{q^2}</span>. Hence, the value <span class="math">e_0 / e_1</span> is a uniquely defined element in <span class="math">\\mathbb{F}_{q^2}</span> corresponding to the class of <span class="math">e</span>.</p>

    <p class="text-gray-300">When using the eta pairing with <span class="math">T = q - N</span> the method of Granger, Page and Stam to avoid the final exponentiation cannot be applied. Nevertheless, once the final exponentiation has been performed one can compress by a factor of 2 using traces or tori in the standard way.</p>

    <p class="text-gray-300">We now consider the curve  <span class="math">C_d: y^2 + y = x^5 + x^3 + d</span>  with  <span class="math">d = 0</span>  or 1 over  <span class="math">\\mathbb{F}_{2^m}</span> , where  <span class="math">m</span>  is coprime to 6. This curve is supersingular and has embedding degree 12 (see [16]). The group order is given in Table 3; some examples are listed in Table 4.</p>

    <p class="text-gray-300">In this section we show that the eta pairing approach can be easily applied in this setting. We give an octupling formula which enables fast point exponentiation and give a corresponding function for Miller's algorithm.</p>

    <p class="text-gray-300">A general reduced divisor  <span class="math">D</span>  on a genus 2 curve has support consisting of two affine points (i.e.,  <span class="math">D = (P_{1}) + (P_{2}) - 2(\\infty)</span> ). Following Duursma and Lee [10] (also see [18, 19]) we exploit the benefits of using degenerate divisors of the form  <span class="math">D = (P) - (\\infty)</span>  where possible.</p>

    <p class="text-gray-300">Table 3. Order of  <span class="math">\\operatorname{Jac}\\left( {C}_{d}\\right)</span>  for the curve  <span class="math">{C}_{d} : {y}^{2} + y = {x}^{5} + {x}^{3} + d</span>  over  <span class="math">{\\mathbb{F}}_{{2}^{m}},d \\in  {\\mathbb{F}}_{2}</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#Jac(Cd)(F2m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">condition</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22m + (-1)d2(3m+1)/2 + 2m + (-1)d2(m+1)/2 + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">m ≡ 1, 7, 17, 23 (mod 24)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22m - (-1)d2(3m+1)/2 + 2m - (-1)d2(m+1)/2 + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">m ≡ 5, 11, 13, 19 (mod 24)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Examples where  <span class="math">\\# \\operatorname{Jac}\\left( C\\right) \\left( {\\mathbb{F}}_{{2}^{m}}\\right)</span>  is equal to a small cofactor times a prime.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cofactor</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F279</td>

            <td class="px-3 py-2 border-b border-gray-700">y2+y=x5+x3+1</td>

            <td class="px-3 py-2 border-b border-gray-700">151681</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2103</td>

            <td class="px-3 py-2 border-b border-gray-700">y2+y=x5+x3</td>

            <td class="px-3 py-2 border-b border-gray-700">13·1237</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2127</td>

            <td class="px-3 py-2 border-b border-gray-700">y2+y=x5+x3+1</td>

            <td class="px-3 py-2 border-b border-gray-700">198168459411337</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2199</td>

            <td class="px-3 py-2 border-b border-gray-700">y2+y=x5+x3+1</td>

            <td class="px-3 py-2 border-b border-gray-700">2389·121789</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2259</td>

            <td class="px-3 py-2 border-b border-gray-700">y2+y=x5+x3+1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2313</td>

            <td class="px-3 py-2 border-b border-gray-700">y2+y=x5+x3+1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that our special curve has certain properties that lend to faster arithmetic than the explicit formulae given in [22] for general genus 2 curves, namely that the equation is sparse and that all the coefficients are defined over  <span class="math">\\mathbb{F}_2</span> . See [23] for examples of arithmetic on similar (albeit non-supersingular) curves.</p>

    <p class="text-gray-300">We first introduce the representation of  <span class="math">\\mathbb{F}_{2^{12}}</span>  and the distortion map we will be using.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Choose <span class="math">w\\in\\mathbb{F}_{2^{6}}</span> to be a root of the polynomial</p>

    <p class="text-gray-300"><span class="math">x^{6}+x^{5}+x^{3}+x^{2}+1.</span></p>

    <p class="text-gray-300">Note that <span class="math">w^{8}=w+1</span>. Define <span class="math">s_{1}=w^{2}+w^{4}</span>, <span class="math">s_{2}=w^{4}+1</span>, and let <span class="math">s_{0}\\in\\mathbb{F}_{2^{12}}</span> be a solution of <span class="math">s_{0}^{2}+s_{0}=w^{5}+w^{3}</span>.</p>

    <p class="text-gray-300">We will represent elements of the field <span class="math">\\mathbb{F}_{2^{12m}}</span> as 12-tuples with respect to the basis</p>

    <p class="text-gray-300"><span class="math">\\{1,w,w^{2},w^{3},w^{4},w^{5},s_{0},ws_{0},w^{2}s_{0},w^{3}s_{0},w^{4}s_{0},w^{5}s_{0}\\}.</span></p>

    <p class="text-gray-300">We choose the distortion map</p>

    <p class="text-gray-300"><span class="math">\\psi(x,y)=(x+w,y+s_{2}x^{2}+s_{1}x+s_{0}).</span></p>

    <p class="text-gray-300">We now consider the octupling formula and hence determine when <span class="math">[2^{3m}]D</span> can be written as <span class="math">\\gamma(D)</span> for some <span class="math">\\gamma</span>.</p>

    <p class="text-gray-300">Consider a divisor of form <span class="math">D=(P)-(\\infty)</span>. In general, <span class="math">jD</span> is not equivalent to a divisor of the form <span class="math">(Q)-(\\infty)</span>, but as shown in Appendix A, in this case we have the octupling formula <span class="math">8D=(P^{\\prime})-(\\infty)</span> where <span class="math">P^{\\prime}=\\phi\\pi^{6}(P)</span>, <span class="math">\\pi</span> is the 2-power Frobenius map, and</p>

    <p class="text-gray-300"><span class="math">\\phi(x,y)=(x+1,y+x^{2}+1).</span></p>

    <p class="text-gray-300">Note that <span class="math">\\phi^{2}=-1</span>. As a suggestive (but non-standard) notation, we write <span class="math">[8]P=\\phi\\pi^{6}(P)</span> and so <span class="math">8D=([8]P)-(\\infty)</span>. Koblitz <em>[20]</em> gives a map for <span class="math">64D</span>, which is exactly the octupling operation applied twice in succession. Similar results for other supersingular curves were obtained by Duursma and Lee <em>[10]</em>.</p>

    <p class="text-gray-300">Since our basic operation is octupling, we are forced to consider the <span class="math">\\eta</span> pairing in the case where we have a power of <span class="math">2^{3}</span>. Hence we will work with <span class="math">q=2^{3m}</span> rather than <span class="math">q=2^{m}</span>. Nevertheless, since our basic operation is octupling, our loops will still have at most <span class="math">m</span> iterations. It follows that, if <span class="math">D</span> is a divisor class defined over <span class="math">\\mathbb{F}_{2^{m}}</span>, then</p>

    <p class="text-gray-300"><span class="math">[q]D=[2^{3m}]D=\\phi^{m}(D)</span></p>

    <p class="text-gray-300">hence we define <span class="math">\\gamma=\\phi^{m}</span>.</p>

    <p class="text-gray-300">We also note that it is possible to use the octupling operation for straightforward scalar multiplication, which yields a simple and speedy implementation.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">7.2 Eta pairings in genus 2</h3>

    <p class="text-gray-300">We now show that condition (3) is satisfied for our distortion map.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">Let the notation be as above with <span class="math">q=2^{3m}.</span> Then condition (3) is satisfied.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We have <span class="math">q=2^{3m}</span> where <span class="math">m\\equiv 1,5,7</span> or <span class="math">11\\pmod{12}</span> and <span class="math">\\gamma=\\phi^{m}</span>.</p>

    <p class="text-gray-300">As before, we write <span class="math">a^{(i)}</span> for <span class="math">a^{\\gamma}</span>. We will repeatedly use the easily checked formulae that <span class="math">w^{(3)}=w+1</span>, <span class="math">s_{0}^{(3)}=s_{0}+w^{2}</span>, <span class="math">s_{1}^{(3)}=s_{1}</span> and <span class="math">s_{2}^{(3)}=s_{2}+1</span>.</p>

    <p class="text-gray-300">First suppose <span class="math">m\\equiv 1\\pmod{4}</span> (and so <span class="math">3m\\equiv 3\\pmod{12}</span>). Then</p>

    <p class="text-gray-300"><span class="math">\\gamma\\psi^{q}(x,y)</span> <span class="math">=\\phi\\psi^{(3)}(x,y)</span> <span class="math">=\\phi(x+w+1,y+(s_{2}+1)x^{2}+s_{1}x+s_{0}+w^{2})</span> <span class="math">=(x+w,y+s_{2}x^{2}+s_{1}x+s_{0})</span> <span class="math">=\\psi(x,y).</span></p>

    <p class="text-gray-300">Similarly, when <span class="math">m\\equiv 3\\pmod{4}</span> we have <span class="math">\\gamma=-\\phi</span> and <span class="math">3m\\equiv 9\\pmod{12}</span>. Hence</p>

    <p class="text-gray-300"><span class="math">\\gamma\\psi^{q}(x,y)</span> <span class="math">=-\\phi^{3}\\psi^{(9)}(x,y)</span> <span class="math">=-\\phi(x+w+1,y+(s_{2}+1)x^{2}+s_{1}x+s_{0}+w^{2}+1)</span> <span class="math">=(x+w,y+s_{2}x^{2}+s_{1}x+s_{0})</span> <span class="math">=\\psi(x,y).</span></p>

    <p class="text-gray-300">This proves the lemma. ∎</p>

    <p class="text-gray-300">Having established this, we can now apply Theorem 1. For the basic generalisation of Duursma and Lee we take <span class="math">T=q=2^{3m}</span> so that <span class="math">c=0</span>. We have <span class="math">N=2^{6m}+1</span> so that <span class="math">M=2^{6m}-1</span>. We then take <span class="math">a=2</span> so that <span class="math">q^{2}+1=N</span> and <span class="math">L=1</span>. It therefore follows that</p>

    <p class="text-gray-300"><span class="math">\\left(\\eta_{T}(D,D^{\\prime})^{M}\\right)^{2q}=\\langle D,\\psi(D^{\\prime})\\rangle_{N}^{M}.</span></p>

    <p class="text-gray-300">Computing the eta pairing with respect to <span class="math">T=2^{3m}</span> requires <span class="math">m</span> iterations of the octupling formula. Interestingly, this is not much better than the basic BKLS-GHS method generalised to genus 2 (see Section 7.7).</p>

    <p class="text-gray-300">As before, we can obtain a further halving of the loop. Let <span class="math">q=2^{3m}</span> and <span class="math">N=2^{2m}\\pm 2^{(3m+1)/2}+2^{m}\\pm 2^{(m+1)/2}+1</span>. Consider the equation</p>

    <p class="text-gray-300"><span class="math">(2^{m}\\mp 2^{(m+1)/2}+1)N=2^{3m}\\pm 2^{(3m+1)/2}+1.</span></p>

    <p class="text-gray-300">This suggests taking <span class="math">T=\\mp 2^{(3m+1)/2}-1</span> so that, if <span class="math">D</span> is a divisor defined over <span class="math">\\mathbb{F}_{q}</span> (and hence of order dividing <span class="math">N</span>),</p>

    <p class="text-gray-300"><span class="math">[T]D=[q-(2^{m}\\mp 2^{(m+1)/2}+1)N]D=[q]D=\\gamma(D).</span></p>

    <p class="text-gray-300">Then <span class="math">c=-(2^{m}\\mp 2^{(m+1)/2}+1)</span> in the notation of Theorem 1. Taking <span class="math">a=2</span> gives <span class="math">T^{2}+1=LN</span> where <span class="math">L=2^{m+1}\\mp 2^{(m+3)/2}+2</span>. Theorem 1 therefore implies that</p>

    <p class="text-gray-300"><span class="math">\\left(\\eta_{T}(D,D^{\\prime})^{M}\\right)^{2T}=\\left(\\langle D,\\psi(D^{\\prime})\\rangle_{N}^{M}\\right)^{L}.</span></p>

    <p class="text-gray-300">Computing the eta pairing using <span class="math">T=\\mp 2^{(3m+1)/2}-1</span> will require roughly <span class="math">m/2</span> iterations of the octupling formula, which is clearly superior to the BKLS-GHS method.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">7.3 Implementation Details</h3>

    <p class="text-gray-300">We compute the <span class="math">\\eta_{T}</span> pairing of divisors <span class="math">D</span> and <span class="math">D^{\\prime}</span> using the order <span class="math">T=\\mp 2^{(3m+1)/2}-1</span>. As usual, if <span class="math">T&lt;0</span> then set <span class="math">T=-T</span> and <span class="math">D=-D</span>. Hence we have <span class="math">T=2^{(3m+1)/2}\\pm 1</span>.</p>

    <p class="text-gray-300">We will exploit the octupling formula. Let <span class="math">f_{8,P}</span> be a function such that <span class="math">(f_{8,P})=8(P)-([8]P)-7(\\infty)</span>. We show in appendix A that,</p>

    <p class="text-gray-300"><span class="math">f_{8,P}(x,y)=\\frac{(y+b_{4}(x))^{2}(y+b_{8}^{\\prime\\prime}(x))}{a_{4}^{\\prime}(x)^{2}a_{8}^{\\prime}(x)}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">b_{4}(x)=x^{3}+(x_{P}^{8}+x_{P}^{4})x^{2}+(x_{P}^{4})x+y_{P}^{4}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">b_{8}^{\\prime\\prime}(x)=(x_{P}^{32}+1)x^{2}+(x_{P}^{32}+x_{P}^{16})x+(y_{P}^{16}+x_{P}^{16}+x_{P}^{48}+1).</span></p>

    <p class="text-gray-300">The denominator <span class="math">a_{4}^{\\prime}(x)^{2}a_{8}^{\\prime}(x)</span> can be ignored for the usual reasons. We will be composing our function with <span class="math">\\psi</span>, and so we will use the notation <span class="math">\\alpha\\beta</span> for the function, where <span class="math">\\alpha=(y+b_{4}(x))^{2}\\circ\\psi</span> and <span class="math">\\beta=(y+b_{8}^{\\prime\\prime})\\circ\\psi</span>.</p>

    <p class="text-gray-300">To compute a function <span class="math">f_{T,P}</span> with divisor <span class="math">T(P)-(D_{T,P})-n(\\infty)</span> where <span class="math">D_{T,P}</span> is a reduced divisor equivalent to <span class="math">TD</span> we want to use the above functions. Since <span class="math">(3m+1)/2=3(m-1)/2+2</span> we must use <span class="math">(m-1)/2</span> octuplings and two doublings.</p>

    <p class="text-gray-300">In other words, we have</p>

    <p class="text-gray-300"><span class="math">f_{T,P}(\\psi(Q))=\\left(\\prod_{i=0}^{(m-3)/2}f_{8,[8^{i}]P}(\\psi(Q))^{2^{(3m-5)/2-3i}}\\right)l_{1}(\\psi(Q))^{2}l_{2}(\\psi(Q))l_{3}(\\psi(Q))</span></p>

    <p class="text-gray-300">where <span class="math">l_{1}</span> and <span class="math">l_{2}</span> are functions coming from the extra doublings and <span class="math">l_{3}</span> is from the final addition of <span class="math">2^{(3m+1)/2}((P)-(\\infty))</span> and <span class="math">\\pm((P)-(\\infty))</span>.</p>

    <p class="text-gray-300">Appendix B gives more detail on implementing the pairing. In Appendix B.1 the distortion map is built into the functions, and formulae are derived for <span class="math">f_{8,[8^{i}]P}(\\psi(Q))</span> which do not require the explicit computation of <span class="math">[8^{i}]P</span>. These formulae are computed efficiently by accessing a table of precomputed values for <span class="math">x_{P}^{2^{i}}</span> and <span class="math">y_{P}^{2^{i}}</span>. In Appendix B.4 powers of <span class="math">8</span> are absorbed into the formulae, which involves precomputing powers of the second point. Appendix B.7 describes how the final doublings and addition can be simplified for degenerate divisors. Algorithm 4 details the genus <span class="math">2</span> <span class="math">\\eta_{T}</span> pairing for degenerate divisors in the case when <span class="math">m=103</span> (although only trivial changes are required to modify the algorithm for arbitrary <span class="math">m</span>).</p>

    <p class="text-gray-300">All of these optimisations lead to a very fast pairing implementation on genus <span class="math">2</span> curves in characteristic two. Details of timings are given in Section 10.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">7.4 Degenerate divisors versus general divisors</h3>

    <p class="text-gray-300">We have focussed on the case of degenerate divisors since this gives a convincing example where hyperelliptic curves can be superior to elliptic curves. Nevertheless, most applications will also require pairings to be computed on general divisors.</p>

    <p class="text-gray-300">A general reduced divisor defined over <span class="math">\\mathbb{F}_{q}</span> on a genus <span class="math">2</span> curve <span class="math">C</span> is represented by <span class="math">(P_{1})+(P_{2})-2(\\infty)</span> where either <span class="math">P_{1},P_{2}\\in C(\\mathbb{F}_{q})</span> or <span class="math">P_{1},P_{2}\\in C(\\mathbb{F}_{q^{2}})</span> are Galois conjugates of each other. The Mumford representation for divisors on hyperelliptic curves essentially gives the symmetric functions of the coordinates of the points <span class="math">P_{i}</span> in the support of the divisor.</p>

    <p class="text-gray-300">INPUT:  <span class="math">P = (x_{P},y_{P}),Q = (x_{Q},y_{Q})\\in J_{C}(F_{2^{m}})</span></p>

    <p class="text-gray-300">OUTPUT:  <span class="math">f\\in F_{2^{12m}}</span></p>

    <p class="text-gray-300">1:  <span class="math">\\triangleright</span>  Initialisation: set  <span class="math">\\gamma = 1</span>  if  <span class="math">m\\equiv 1</span>  mod 4, otherwise  <span class="math">\\gamma = 0</span> 2:  <span class="math">\\triangleright</span>  Precompute powers of P and Q 3:  <span class="math">x_{1}[i]\\gets x_{P}^{2^{i}},y_{1}[i]\\gets y_{P}^{2^{i}},x_{2}[i]\\gets x_{Q}^{2^{i}},y_{2}[i]\\gets y_{Q}^{2^{i}},0 &amp;lt;   = i &amp;lt;   = m - 1</span> 4:  <span class="math">f\\gets 1</span> 5: 6: for  <span class="math">i = 0</span>  to  <span class="math">(m - 3) / 2</span>  do 7:  <span class="math">\\triangleright</span>  All  <span class="math">k_{*}</span>  in the next 2 lines to be considered modulo  <span class="math">m</span> 8:  <span class="math">k_{1}\\gets (3m - 9 - 6i) / 2,k_{2}\\gets (k_{1} + 1),k_{3}\\gets (k_{2} + 1)</span> 9:  <span class="math">k_{4}\\gets (3m - 3 + 6i) / 2,k_{5}\\gets (k_{4} + 1),k_{6}\\gets (k_{5} + 1)</span> 10: 11:  <span class="math">\\triangleright</span>  Calculate  <span class="math">\\alpha \\gets a + bw + cw^2 +dw^4 +s_0</span> 12:  <span class="math">d\\gets x_1[k_4] + x_1[k_5]</span> 13:  <span class="math">a\\gets y_2[k_2] + (x_1[k_4] + 1 + x_2[k_3])\\cdot x_2[k_2] + d\\cdot x_2[k_3] + y_1[k_4] + \\gamma</span> 14:  <span class="math">b\\gets x_2[k_3] + x_2[k_2]</span> 15:  <span class="math">c\\gets x_2[k_3] + x_1[k_4] + 1</span> 16: 17:  <span class="math">\\triangleright</span>  Calculate  <span class="math">\\beta \\gets e + f_2w + gw^2 +hw^4 +s_0</span> 18:  <span class="math">f_{2}\\gets x_{1}[k_{5}] + x_{1}[k_{6}]</span> 19:  <span class="math">e\\gets y_2[k_1] + f_2\\cdot x_2[k_1] + y_1[k_5] + x_1[k_6]\\cdot (x_1[k_5] + x_2[k_2]) + x_1[k_5] + \\gamma</span> 20:  <span class="math">g\\gets x_2[k_1] + x_1[k_6] + 1</span> 21:  <span class="math">h\\gets x_2[k_2] + x_2[k_1]</span> 22: 23:  <span class="math">f\\gets f\\cdot (\\alpha \\cdot \\beta)</span> 24: end for 25: 26:  <span class="math">\\triangleright</span>  "Extract" current point  <span class="math">(x_{P},y_{P})</span> 27:  <span class="math">x_{P}\\gets x_{1}[100] + 1</span> 28:  <span class="math">y_{P}\\gets y_{1}[100] + x_{1}[101]</span> 29: 30:  <span class="math">\\triangleright</span>  Perform the final doublings/addition 31:  <span class="math">t\\gets (y_2[0] + x_2[1]\\cdot (1 + x_2[0] + x_P^8 +x_P^4) + x_P^4\\cdot x_2[0] + y_P^4)</span> 32:  <span class="math">f\\gets f^4\\cdot (t,x_2[1] + x_P^4,x_P^8 +x_P^4,1,x_2[1] + x_2[0],0,1,0,0,0,0,0)</span> 33: 34:  <span class="math">\\triangleright</span>  Perform the final exponentiation 35:  <span class="math">f\\gets f^{(2^{6m} - 1)(2^{3m} - 2^{4m}2^{jm + 1) / 2} - 1)}</span> 36:</p>

    <p class="text-gray-300">General divisors may appear as either the first or second components of the pairing (or both). Handling the second case (i.e., generalising evaluation of a function at a point to evaluation at a divisor in Mumford representation) is relatively straightforward.</p>

    <p class="text-gray-300">For the first case, bilinearity implies that <span class="math">\\eta_{T}((P_{1})+(P_{2})-2(\\infty),D^{\\prime})=\\eta_{T}(P_{1},D^{\\prime})\\eta_{T}(P_{2},D^{\\prime})</span> and so one can compute a pairing on divisors by taking a product of pairings on points. However, in the case where the points <span class="math">P_{i}</span> are actually defined over <span class="math">\\mathbb{F}_{q^{2}}</span> this will not be the most efficient way to proceed. It is relatively straightforward to obtain the general formulae: just multiply the functions obtained from the single point case and then express the resulting polynomials in terms of the symmetric polynomials in the point coordinates. We leave this as an exercise for the reader; a full discussion will be given in the thesis of the third author.</p>

    <p class="text-gray-300">From a performance point of view, the cost of computing a pairing between general divisors in genus <span class="math">2</span> is at worst <span class="math">4</span> times the cost of a pairing between single points. Obviously, various optimisations are applicable, including only performing the final exponentiation once, sharing some of the function calculations and only having to precompute squarings of points once.</p>

    <p class="text-gray-300">We now briefly discuss how degenerate divisors can be used to speed up pairing-based cryptosystems. First, note that Katagi et al. <em>[19]</em> showed (using the random self-reducibility of the discrete logarithm problem) that there is no loss of security from using degenerate divisors.</p>

    <p class="text-gray-300">In most of the cases we consider, the divisor class group has (nearly) prime order <span class="math">N</span> and we work with pairings of order <span class="math">N</span>. Hence, a randomly chosen degenerate divisor <span class="math">(P)-(\\infty)</span> will have order divisible by our large prime and the pairing value will be non-degenerate. In the general case of pairings on higher genus curves this assumption may not hold; we refer to Frey and Lange <em>[13]</em> for a discussion of these issues.</p>

    <p class="text-gray-300">In the case of pairing-based cryptography it is easy to benefit from the use of degenerate divisors. As a case study we consider the Boneh-Franklin identity-based encryption scheme <em>[7]</em> (similar ideas can speed up aspects of other pairing-based cryptosystems, we refer to Frey and Lange <em>[13]</em> for further discussion). The natural generalisation of this system to genus <span class="math">g</span> curves (see <em>[16]</em>) is to have a master public key pair <span class="math">D,D_{\\text{pub}}=[s]D</span> of divisors; identities are hashed to obtain divisors <span class="math">D(ID)</span>; user private keys are <span class="math">[s]D(ID)</span>; encryption involves computing <span class="math">[r]P</span> and the pairing of <span class="math">D_{\\text{pub}}</span> with <span class="math">D(ID)</span> (and then raising to the power <span class="math">r</span>); decryption involves the pairing of <span class="math">[s]D(ID)</span> with <span class="math">[r]P</span>.</p>

    <p class="text-gray-300">Without loss of security, one can choose several of these divisors to be degenerate. For example, one can choose <span class="math">D_{\\text{pub}}</span> to be degenerate (i.e., choose <span class="math">D_{\\text{pub}}</span> first and then set <span class="math">D=[s^{-1}]D_{\\text{pub}}</span>). One can also choose <span class="math">H(ID)</span> to be degenerate, so that we are hashing to points on the curve, rather than general divisors. This simplified hashing process is also easier to implement than the general case. Of course, the user private keys are now general divisors. Encryption therefore involves a pairing of two degenerate divisors and so can be performed very efficiently, while decryption involves a pairing of general divisors. This is similar to RSA with small public exponents, where the public operations are fast compared to the private ones. For some applications this may be a useful feature.</p>

    <p class="text-gray-300">7.5 The Final Exponentiation</p>

    <p class="text-gray-300">Theorem 1 relates the <span class="math">\\eta_{T}</span> pairing to the Tate pairing in the genus 2 case as follows</p>

    <p class="text-gray-300"><span class="math">\\left(\\eta_{T}(D,D^{\\prime})^{M}\\right)^{2T}=\\left(\\langle D,\\psi(D^{\\prime})\\rangle_{N}^{M}\\right)^{L}.</span></p>

    <p class="text-gray-300">where <span class="math">T=\\mp 2^{(3m+1)/2}-1</span>, <span class="math">M=(2^{12m}-1)/N</span>, <span class="math">N=2^{2m}\\pm 2^{(3m+1)/2}+2^{m}\\pm 2^{(m+1)/2}+1</span> and <span class="math">L=2^{m+1}\\mp 2^{(m+3)/2}+2</span>.</p>

    <p class="text-gray-300">One can compute a bilinear pairing by computing the <span class="math">\\eta_{T}</span> pairing and raising to the power of <span class="math">M</span>. However, it is actually more efficient to compute the full Tate pairing with <span class="math">\\eta_{T}^{\\frac{M2T}{2}}</span>. By factoring <span class="math">M</span> we get the product</p>

    <p class="text-gray-300"><span class="math">M=(2^{6m}-1)(2^{m}\\mp 2^{(m+1)/2}+1)(2^{3m}\\mp 2^{(3m+1)/2}+1)</span></p>

    <p class="text-gray-300">Note that <span class="math">L</span> can be written as <span class="math">L=2(2^{m}\\mp 2^{(m+1)/2}+1)</span>, which cancels out with the middle factor of <span class="math">M</span> and the squaring of the <span class="math">\\eta_{T}</span> function. The exponent to compute the Tate pairing is now;</p>

    <p class="text-gray-300"><span class="math">(2^{6m}-1)(2^{3m}\\mp 2^{(3m+1)/2}+1)(\\mp 2^{(3m+1)/2}-1)</span></p>

    <p class="text-gray-300">Some cancellations occur whilst unrolling the multiplication of the second and third factor, and we get</p>

    <p class="text-gray-300"><span class="math">(2^{6m}-1)(2^{3m}\\mp 2^{4m}2^{(m+1)/2}-1)</span></p>

    <p class="text-gray-300">Note that raising an element to the power of <span class="math">2^{6m}</span> over <span class="math">\\mathbb{F}_{2^{12m}}</span> can be computed with a simple conjugation. Also note that, once the powering to <span class="math">(2^{6m}-1)</span> has been performed, we have <span class="math">z^{2^{6m}\\mp 1}=1</span> and so <span class="math">z^{-1}=z^{2^{6m}}</span>, i.e., computing an inverse is done by simple conjugation. Using these facts, we can compute the final exponentiation in <span class="math">(m+1)/2</span> squarings, 4 Frobenius actions, 2 multiplications and a division.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">7.6 Compression of pairing values</h3>

    <p class="text-gray-300">After the final exponentiation our pairing values lie in the subgroup of order <span class="math">(q^{4}-q^{2}+1)</span> in <span class="math">\\mathbb{F}_{q^{12}}^{<em>}</span>. This subgroup is the torus <span class="math">T_{6}(\\mathbb{F}_{q^{2}})</span> so we can represent the field elements using 2 elements of <span class="math">\\mathbb{F}_{q^{2}}</span> rather than 6. This gives compression by a factor of 3. The details are similar to those given by </em>[17]*.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">7.7 Computing BKLS-GHS using octupling</h3>

    <p class="text-gray-300">In this section we will briefly look at computing the Tate pairing using the BKLS-GHS algorithm, degenerate divisors and the fast octupling operation defined previously. At first glance, the group order <span class="math">N\\approx 2^{2m}</span> requires about <span class="math">2m/3</span> iterations of the octupling formula, so the BKLS-GHS method looks competitive. However, care is needed as the additions will destroy the special form of the divisor. The best approach is to postpone the additions until the end. In other words, compute the appropriate functions for <span class="math">2^{2m}P</span>, <span class="math">2^{(3m+1)/2}P</span>, <span class="math">2^{m}P</span> and <span class="math">2^{(m+1)/2}P</span> separately in different loops and then add them up at the end.</p>

    <p class="text-gray-300">Let <span class="math">h_{1},h_{2},h_{3}</span> be the functions that arise from Cantor composition and reduction of the divisors that occur at <span class="math">2^{2m}P</span>, <span class="math">2^{(3m+1)/2}P</span>, <span class="math">2^{m}P</span> and <span class="math">2^{(m+1)/2}P</span>. The function we desire is then:</p>

    <p class="text-gray-300"><span class="math">f=f_{2^{2m}}f_{2^{(3m+1)/2}}f_{2^{m}}f_{2^{(m+1)/2}}h_{1}h_{2}h_{3}</span></p>

    <p class="text-gray-300">This can be computed using <span class="math">2m/3</span> octuplings, as well as a few additions and doublings. The powers of <span class="math">8</span> can also be absorbed as is done in Appendix B, however as each function is raised to a different power, we require four different sets of formulae. We can take some advantage of similarities between the four functions however, to speed up the computation. The end result is an efficient if messy pairing computation. See section 10 for timings.</p>

    <h2 id="sec-37" class="text-2xl font-bold">8 The Duursma-Lee hyperelliptic curves</h2>

    <p class="text-gray-300">Duursma and Lee <em>[10]</em> also consider the curves <span class="math">C:y^{2}=x^{p}-x+d</span> over <span class="math">\\mathbb{F}_{p^{m}}</span> where <span class="math">p\\geq 5</span> and <span class="math">d\\neq 0</span>. The genus of <span class="math">C</span> is <span class="math">(p-1)/2</span>. When <span class="math">p\\equiv 3\\pmod{4}</span> the embedding degree is <span class="math">k=2p</span> and <span class="math">\\#\\mathrm{Jac}(C)(\\mathbb{F}_{p^{m}})\\mid(p^{mp}+1)</span>. The distortion map is <span class="math">\\psi(x,y)=(\\rho-x,iy)</span> where <span class="math">i^{2}=-1</span> and <span class="math">\\rho^{p}-\\rho+2d=0</span>.</p>

    <p class="text-gray-300">Duursma and Lee <em>[10]</em> show that <span class="math">p((x,y)-(\\infty))</span> is equivalent to <span class="math">(x^{p^{2}}+2d,-y^{p^{2}})</span>. Let <span class="math">q=p^{m}</span> where <span class="math">m</span> is coprime to <span class="math">2p</span>. Let <span class="math">\\phi(x,y)=(x+2d,-y)</span>. If <span class="math">P\\in C(\\mathbb{F}_{p^{m}})</span> then it follows that <span class="math">q((P)-(\\infty))</span> is equivalent to <span class="math">(\\phi^{m}(P))-(\\infty)</span>. Hence we set <span class="math">\\gamma=\\phi^{m}</span>.</p>

    <p class="text-gray-300">We check condition (3) for this case. Note that <span class="math">\\rho^{p}=\\rho-2d</span>.</p>

    <p class="text-gray-300">If <span class="math">p\\equiv 3\\pmod{4}</span> then we have (since <span class="math">m</span> is odd)</p>

    <p class="text-gray-300"><span class="math">\\gamma\\psi^{q}</span> <span class="math">=\\phi^{m}\\psi^{p^{m}}(x,y)</span> <span class="math">=\\phi^{m}(\\rho^{p^{m}}-x,i^{p^{m}}y)</span> <span class="math">=\\phi^{m}(\\rho-2dm-x,-iy)</span> <span class="math">=(\\rho-x,iy)</span> <span class="math">=\\psi(x,y).</span></p>

    <p class="text-gray-300">Having established this, we set <span class="math">N=p^{pm}+1</span>, <span class="math">T=p^{m}</span>, <span class="math">c=0</span>, <span class="math">a=p</span> and <span class="math">L=1</span> and apply Theorem 1 to show that the eta pairing approach recovers the results of Duursma and Lee.</p>

    <p class="text-gray-300">If <span class="math">p\\equiv 1\\pmod{4}</span> then the embedding degree is <span class="math">k=p</span> and our methods do not immediately apply. Theorem 1 can be generalised so that condition 3 reads <span class="math">T^{a}-1=LN</span>, in which case we may choose <span class="math">a=p</span>. But when <span class="math">p^{m}\\equiv 1\\pmod{4}</span> we have <span class="math">i^{p^{m}}=i</span> and so condition (3) is not satisfied.</p>

    <p class="text-gray-300">There are two natural open problems for these curves. The first is to develop an eta pairing for the cases where <span class="math">p\\equiv 1\\pmod{4}</span>. The second natural problem is to give the further halving of the loop for these curves. We leave these problems for future research.</p>

    <h2 id="sec-38" class="text-2xl font-bold">9 The Rubin-Silverberg approach</h2>

    <p class="text-gray-300">Rubin and Silverberg <em>[25]</em> (also see <em>[26, 29]</em>) have proposed an alternative way to view pairings on Abelian varieties. Their method can be thought of as a method for computing pairings on trace zero subvarieties of Weil restrictions of elliptic curves. A simpler</p>

    <p class="text-gray-300">way to think about their method is as a form of point compression for pairings on elliptic curves.</p>

    <p class="text-gray-300">The Jacobian of the supersingular genus <span class="math">2</span> curve considered in Section 7 is a <span class="math">2</span>-dimensional Abelian variety over <span class="math">\\mathbb{F}_{2^{m}}</span> with embedding degree <span class="math">k=12</span>. Another way to get this Abelian variety (up to isogeny) is with the Rubin-Silverberg approach, by taking the <span class="math">k=4</span> elliptic case and using the Rubin-Silverberg construction with <span class="math">r=3</span>, to obtain a <span class="math">2</span>-dimensional Abelian variety with embedding degree <span class="math">3\\times 4=12</span>. We recall the details in this case.</p>

    <p class="text-gray-300">Let <span class="math">E_{b}:y^{2}+y=x^{3}+x+b</span> with <span class="math">b=0,1</span> over <span class="math">\\mathbb{F}_{2}</span> be the supersingular elliptic curves with embedding degree <span class="math">k=4</span>. The idea of Rubin and Silverberg is to compute pairings with points defined over <span class="math">\\mathbb{F}_{2^{3m}}</span> where <span class="math">m</span> is coprime to <span class="math">12</span>. This means that pairing values lie in <span class="math">\\mathbb{F}_{2^{12m}}</span>.</p>

    <p class="text-gray-300">To transmit group elements, Rubin and Silverberg propose a compression method so that the element is represented using only <span class="math">2</span> elements in <span class="math">\\mathbb{F}_{2^{m}}</span>. Hence, the bandwidth is about <span class="math">2m</span> bits but the finite field security is <span class="math">2^{12m}</span>, which corresponds to ‘security multiplier 6’.</p>

    <p class="text-gray-300">The group <span class="math">E(\\mathbb{F}_{2^{3m}})</span> clearly has <span class="math">E(\\mathbb{F}_{2^{m}})</span> as a subgroup. Indeed, we can write</p>

    <p class="text-gray-300"><span class="math">E(\\mathbb{F}_{2^{3m}})\\cong E(\\mathbb{F}_{2^{m}})\\times A</span></p>

    <p class="text-gray-300">where <span class="math">A</span> is a finite group and one can check that the order of <span class="math">A</span> is <span class="math">2^{2m}\\pm 2^{(3m+1)/2}+2^{m}\\pm 2^{(m+1)/2}+1</span>. Note that this agrees with the group orders in Table 3.</p>

    <p class="text-gray-300">The following result is an important classification of <span class="math">A</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">Let <span class="math">m</span> be coprime to 12. Let <span class="math">\\mathrm{Tr}</span> be the trace map with respect to <span class="math">\\mathbb{F}_{2^{3m}}/\\mathbb{F}_{2^{m}}</span>. Then <span class="math">A=\\{P\\in E(\\mathbb{F}_{2^{3m}}):\\mathrm{Tr}(P)=0\\}</span>.</p>

    <p class="text-gray-300">The method is to perform pairing computations with the curve <span class="math">E</span> over <span class="math">\\mathbb{F}_{2^{3m}}</span> so that the pairing values lie in <span class="math">\\mathbb{F}_{2^{12m}}</span>. Suitable group orders are the same as in the genus <span class="math">2</span> case (e.g. <span class="math">m=103</span> with a <span class="math">192</span>-bit subgroup).</p>

    <p class="text-gray-300">Write <span class="math">\\mathbb{F}_{2^{3m}}</span> as <span class="math">\\mathbb{F}_{2^{m}}(\\theta)</span> where <span class="math">\\theta^{3}=\\theta+1</span>. So points in <span class="math">E(\\mathbb{F}_{2^{3m}})</span> are represented as <span class="math">(x,y)</span> where <span class="math">x</span> is represented as a triple <span class="math">(x_{0},x_{1},x_{2})</span> over <span class="math">\\mathbb{F}_{2^{m}}</span> with respect to the basis <span class="math">\\{1,\\theta,\\theta^{2}\\}</span>.</p>

    <p class="text-gray-300">To transmit a point we first apply point compression so that we need send only the <span class="math">x</span>-coordinate and a single bit determining the sign (sometimes even this bit can be removed). Then to transmit the <span class="math">x</span>-coordinate just send <span class="math">x_{0}</span> and <span class="math">x_{1}</span> (and possibly another bit).</p>

    <p class="text-gray-300">To recover (decompress) we must do the following: Given <span class="math">x_{0}</span> and <span class="math">x_{1}</span> compute an element <span class="math">x_{2}\\in\\mathbb{F}_{2^{m}}</span> such that there is a point <span class="math">P</span> with <span class="math">x</span>-coordinate <span class="math">(x_{0},x_{1},x_{2})</span> which satisfies <span class="math">\\mathrm{Tr}(P)=0</span>.</p>

    <p class="text-gray-300">In this case the trace is <span class="math">\\mathrm{Tr}(P)=P+\\pi(P)+\\pi^{2}(P)</span> where <span class="math">\\pi</span> is the <span class="math">2^{m}</span>-power Frobenius map. So the condition is that <span class="math">P,\\pi(P)</span> and <span class="math">\\pi^{2}(P)</span> sum to zero, or in other words, lie on a straight line. The decompression procedure is to deduce which <span class="math">x_{2}</span> ensures that there is a line <span class="math">l(x,y)=0</span> through the three points.</p>

    <p class="text-gray-300">Let <span class="math">P=(x_{P},y_{P})</span> and write <span class="math">l(x,y)=y+u_{0}x+u_{1}</span> where <span class="math">u_{0},u_{1}\\in\\mathbb{F}_{2^{3m}}</span>. Define <span class="math">\\hat{l}(x,y)=l(x,y)+1</span>. Then</p>

    <p class="text-gray-300"><span class="math">l(x,y)\\hat{l}(x,y)</span> <span class="math">=y^{2}+y+(u_{0}x+u_{1})+(u_{0}x+u_{1})^{2}</span> <span class="math">=x^{3}+u_{0}^{2}x^{2}+(u_{0}+1)x+(u_{1}^{2}+u_{1}+b).</span></p>

    <p class="text-gray-300">Also,</p>

    <p class="text-gray-300"><span class="math">l(x,y)\\tilde{l}(x,y)=(x-x_{P})(x-x_{\\pi(P)})(x-x_{\\pi^{2}(P)})=x^{3}+Tx^{2}+Sx+N</span></p>

    <p class="text-gray-300">from which we deduce that <span class="math">T=S^{2}+1</span>. One can check that <span class="math">T=x_{0}</span> and <span class="math">S=x_{0}^{2}+x_{1}^{2}+x_{1}x_{2}+x_{2}^{2}</span>. Hence <span class="math">x_{2}</span> is a solution to the equation</p>

    <p class="text-gray-300"><span class="math">y^{4}+x_{1}y^{2}+(x_{0}^{4}+x_{0}+1+x_{1}^{2})=0.</span></p>

    <p class="text-gray-300">Solving this equation involves solving a quadratic and then taking square roots. A single bit is needed to distinguish the two roots of the quadratic and to ensure a unique solution to the decompression process.</p>

    <p class="text-gray-300">The total cost is solving a quadratic and then taking a square root, plus solving another quadratic to recover the <span class="math">y</span>-coordinate of the point.</p>

    <p class="text-gray-300">From a performance point of view it is essential to compare the running time of the pairing computation on the genus 2 curve with the Rubin-Silverberg method. In a general implementation, where we may be required to compute the pairing of general divisors on the genus 2 curve, then the Rubin-Silverberg approach may be superior.</p>

    <h2 id="sec-40" class="text-2xl font-bold">10 Experimental results</h2>

    <p class="text-gray-300">We have proposed a number of algorithms for pairing computation which apply to different supersingular curves. The only natural way to compare these methods is to give running times for equivalent security levels. A precise formulation of ‘equivalent security’ is deeply problematic, but a reasonable approach is to consider parameters so that the value <span class="math">q^{k}</span> is roughly the same. This would mean that the cost of index calculus in the finite field is roughly equal for all examples. Two different field sizes are chosen for testing. Firstly, 950-bit finite fields with (g=1) <span class="math">q=2^{239}</span>, (g=1) <span class="math">q=3^{97}</span>, (g=2) <span class="math">q=2^{79}</span>, and 1230-bit finite fields with (g=1) <span class="math">q=2^{307}</span>, (g=1) <span class="math">q=3^{127}</span>, (g=2) <span class="math">q=2^{103}</span>.</p>

    <p class="text-gray-300">As noted, there are two different ways to view the dimension two case, the first using the genus 2 curve directly, and the second using the Rubin-Silverberg approach. The relative performance is seen by comparing the running time of the pairing on the Jacobian of the curve over <span class="math">\\mathbb{F}_{2^{m}}</span> with the pairing on <span class="math">E(\\mathbb{F}_{2^{3m}})</span>. The latter will be roughly the same as the cost of a pairing on <span class="math">E(\\mathbb{F}_{2^{m^{\\prime}}})</span> where <span class="math">m^{\\prime}\\approx 3m</span>. Note that this does not take into account the cost of conversion between the Rubin-Silverberg Abelian variety representation and the elliptic curve over the larger field.</p>

    <p class="text-gray-300">Table 5 gives some running times for calculating the 950-bit case, and Table 6 the running times for the 1230-bit case. As noted earlier, we use the notation <span class="math">\\eta</span> for the eta pairing with <span class="math">T=q</span> and write <span class="math">\\eta_{T}</span> for the faster variant with <span class="math">T=q-N</span>. In both tables, cases 1 to 3 illustrate the computation of the <span class="math">\\eta</span> pairing for the elliptic characteristic 2 and 3 cases, as well as the genus 2, characteristic 2 case. Cases 4 to 7 give timings for the computation of the <span class="math">\\eta_{T}</span> pairing, where the genus 2 “general” case is a general divisor, rather than a divisor with one point on it as is the case for the third and sixth entries in the tables. The final case in Table 6 gives a time for computing the Tate pairing using BKLS-GHS.</p>

    <p class="text-gray-300">The first observation to make from the tables is that the new <span class="math">\\eta_{T}</span> method is clearly superior to the <span class="math">\\eta</span> generalisation of the Duursma-Lee method for all cases. In Table 5, the</p>

    <p class="text-gray-300">Table 5. Running times for pairing computation (950-bit finite field).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">optimisation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pairing time (ms)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P239)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 2 η</td>

            <td class="px-3 py-2 border-b border-gray-700">3.16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P397)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 3 (see [17])</td>

            <td class="px-3 py-2 border-b border-gray-700">4.05</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">C(P279)</td>

            <td class="px-3 py-2 border-b border-gray-700">genus 2 η</td>

            <td class="px-3 py-2 border-b border-gray-700">1.95</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P2199)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 2 ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">1.70</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P397)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 3 ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">2.72</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">C(P279)</td>

            <td class="px-3 py-2 border-b border-gray-700">genus 2 ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">1.25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">C(P279)</td>

            <td class="px-3 py-2 border-b border-gray-700">genus 2 general ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">4.20</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6. Running times for pairing computation (1230-bit finite field).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">optimisation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pairing time (ms)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P2307)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 2 η</td>

            <td class="px-3 py-2 border-b border-gray-700">5.83</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P3127)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 3 η</td>

            <td class="px-3 py-2 border-b border-gray-700">8.42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">C(P2103)</td>

            <td class="px-3 py-2 border-b border-gray-700">genus 2 η</td>

            <td class="px-3 py-2 border-b border-gray-700">3.00</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P2307)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 2 ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">3.50</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">E(P3127)</td>

            <td class="px-3 py-2 border-b border-gray-700">elliptic char 3 ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">5.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">C(P2103)</td>

            <td class="px-3 py-2 border-b border-gray-700">genus 2 ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">1.87</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">C(P2103)</td>

            <td class="px-3 py-2 border-b border-gray-700">genus 2 general ηT</td>

            <td class="px-3 py-2 border-b border-gray-700">6.42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">C(P2103)</td>

            <td class="px-3 py-2 border-b border-gray-700">genus 2 BKLS-GHS</td>

            <td class="px-3 py-2 border-b border-gray-700">3.15</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">elliptic char 2 case is  <span class="math">46\\%</span>  faster, the elliptic char 3 case is  <span class="math">32\\%</span>  faster, and the genus 2 char 2 case is  <span class="math">36\\%</span>  faster.</p>

    <p class="text-gray-300">The second observation is that the genus  <span class="math">2\\eta_{T}</span>  pairing is considerably faster than either of the elliptic cases for both levels of security. In Table 5, the genus  <span class="math">2\\eta_{T}</span>  case is  <span class="math">26\\%</span>  faster than the elliptic char 2 case, and  <span class="math">54\\%</span>  faster than the elliptic char 3 case. The difference is even more pronounced in Table 6. The timings for the genus 2 BKLS-GHS method confirm the surprising observation that the BKLS-GHS method is roughly computationally equivalent to the  <span class="math">\\eta</span>  method in the genus 2 case.</p>

    <p class="text-gray-300">One of the potential advantages of using hyperelliptic curves is that the base field can be much smaller than that required for an elliptic curve, for the same level of security. Great potential savings can be realised if an element of the base field can be represented in a single machine word, rather than using a multi-precision representation, and for comparison with elliptic curves we regard it as quite "fair" to try to exploit this feature.</p>

    <p class="text-gray-300">So in implementing arithmetic in the field  <span class="math">\\mathbb{F}_{2^{103}}</span>  and  <span class="math">\\mathbb{F}_{2^{79}}</span>  we take advantage of the 128-bit registers available to those processors, like the Pentium IV, which support the SSE2 instruction set, and have written a special function to carry out field multiplication using SSE2 instructions. This is twice as fast as a standard multi-precision implementation, and improves the overall timings by about  <span class="math">50\\%</span> .</p>

    <p class="text-gray-300">All timings were done on a Pentium IV running at 3 GHz.</p>

    <p class="text-gray-300">11 Conclusions</p>

    <p class="text-gray-300">We have presented the eta pairing approach to compute pairings on supersingular curves. This approach generalises and clarifies the Duursma-Lee algorithm. We have provided full examples of the method in characteristic 2 for genus 1 and 2, which turn out to be very efficiently implementable.</p>

    <h2 id="sec-41" class="text-2xl font-bold">12 Acknowledgements</h2>

    <p class="text-gray-300">We are grateful to Alice Silverberg for discussions regarding section 9, to Eunjeong Lee for pointing out a missing validity condition for theorem 1, and to Tanja Lange for some comments.</p>

    <h2 id="sec-42" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] P. S. L. M. Barreto. A note on efficient computation of cube roots in characteristic 3. Cryptology ePrint Archive, Report 2004/305, 2004. Available from http://eprint.iacr.org/2004/305.</li>

      <li>[2] P. S. L. M. Barreto. The well-tempered pairing. In 8th Workshop on Elliptic Curve Cryptography – ECC’2004, Bochum, Germany, 2004. Invited talk.</li>

      <li>[3] P. S. L. M. Barreto, H. Y. Kim, B. Lynn, and M. Scott. Efficient algorithms for pairing-based cryptosystems. In Advances in Cryptology – Crypto’2002, volume 2442 of Lecture Notes in Computer Science, pages 354–368. Springer-Verlag, 2002.</li>

      <li>[4] P. S. L. M. Barreto, B. Lynn, and M. Scott. Efficient implementation of pairing-based cryptosystems. Journal of Cryptology, 17(4):321–334, 2004.</li>

      <li>[5] P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography – SAC’2005, Lecture Notes in Computer Science. Springer-Verlag, 2005. to appear.</li>

      <li>[6] I. F. Blake, G. Seroussi, and N. P. Smart. Advances in elliptic curve cryptography. Cambridge, 2005.</li>

      <li>[7] D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. SIAM Journal of Computing, 32(3):586–615, 2003.</li>

      <li>[8] D. G. Cantor. Computing in the jacobian of a hyperelliptic curve. Math. Comp., 48(177):95–101, 1987.</li>

      <li>[9] R. Dutta, R. Barua, and P. Sarkar. Pairing-based cryptography: A survey. Cryptology ePrint Archive, Report 2004/064, 2004. http://eprint.iacr.org/2004/064.</li>

      <li>[10] I. Duursma and H.-S. Lee. Tate pairing implementation for hyperelliptic curves <span class="math">y^{2}=x^{p}-x+d</span>. In Advances in Cryptology – Asiacrypt’2003, volume 2894 of Lecture Notes in Computer Science, pages 111–123. Springer-Verlag, 2003.</li>

      <li>[11] I. Duursma and K. Sakurai. Efficient algorithms for the jacobian variety of hyperelliptic curves <span class="math">y^{2}=x^{p}-x+1</span> over a finite field of odd characteristic <span class="math">p</span>. In Coding theory, cryptography and related areas (Guanajuato, 1998), pages 73–89. Springer-Verlag, 2000.</li>

      <li>[12] K. Fong, D. Hankerson, J. López, and A. Menezes. Field inversion and point halving revisited. Technical report CORR 2003-18, University of Waterloo, 2002.</li>

      <li>[13] G. Frey and T. Lange. Fast bilinear maps from the tate-lichtenbaum pairing on hyperelliptic curves, 2005.</li>

      <li>[14] G. Frey and H.-G. Rück. A remark concerning <span class="math">m</span>-divisibility and the discrete logarithm problem in the divisor class group of curves. Math. Comp., 52:865–874, 1994.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S. Galbraith, K. Harrison, and D. Soldera. Implementing the Tate pairing. In Algorithmic Number Theory – ANTS V, volume 2369 of Lecture Notes in Computer Science, pages 324–337. Springer-Verlag, 2002.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>16. S. D. Galbraith. Supersingular curves in cryptography. In ASIACRYPT 2001, volume 2248 of Lecture Notes in Computer Science, pages 495–513. Springer-Verlag, 2001.</li>

      <li>17. R. Granger, D. Page, and M. Stam. On small characteristic algebraic tori in pairing-based cryptography. Cryptology ePrint Archive, Report 2004/132, 2004.</li>

      <li>18. M. Katagi, T. Akishita, I. Kitamura, and T. Takagi. Some improved algorithms for hyperelliptic curve cryptosystems using degenerate divisors. In ICISC 2004, volume 3506, pages 296–312. Springer-Verlag, 2005.</li>

      <li>19. M. Katagi, I. Kitamura, T. Akishita, and T. Takagi. Novel efficient implementations of hyperelliptic curve cryptosystems using degenerate divisors. In Information Security Applications – WISA’2004, volume 3325 of Lecture Notes in Computer Science, pages 345–359. Springer-Verlag, 2005.</li>

      <li>20. N. Koblitz. Hyperelliptic cryptosystems. Journal of Cryptology, 1(3):139–150, 1989.</li>

      <li>21. S. Kwon. Efficient Tate pairing computation for supersingular elliptic curves over binary fields. Cryptology ePrint Archive, Report 2004/303, 2004. http://eprint.iacr.org/2004/303.</li>

      <li>22. T. Lange. Formulae for arithmetic on genus 2 hyperelliptic curves. In Applicable Algebra in Engineering, Communication and Computing, Online publication. Springer-Verlag, 2004. http://www.springerlink.com/openurl.asp?genre=article&id=doi:10.1007/s0%0200-004-0154-8.</li>

      <li>23. T. Lange and M. Stevens. Efficient doubling on genus two curves over binary fields. In Selected Areas in Cryptography – SAC’2004, volume 3357 of Lecture Notes in Computer Science, pages 170–181. Springer-Verlag, 2004.</li>

      <li>24. V. S. Miller. Short programs for functions on curves. Unpublished manuscript, 1986. http://crypto.stanford.edu/miller/miller.pdf.</li>

      <li>25. K. Rubin and A. Silverberg. Supersingular abelian varieties in cryptology. In Advances in Cryptology – Crypto’2002, volume 2442 of Lecture Notes in Computer Science, pages 336–353. Springer-Verlag, 2002.</li>

      <li>26. K. Rubin and A. Silverberg. Using primitive subgroups to do more with fewer bits. In Algorithmic Number Theory – ANTS VI, volume 3076 of Lecture Notes in Computer Science, pages 18–41. Springer-Verlag, 2004.</li>

      <li>27. M. Scott. Faster identity based encryption. Electronics Letters, 40(14):861, 2004.</li>

      <li>28. M. Scott and P. Barreto. Compressed pairings. In Advances in Cryptology – Crypto’ 2004, volume 3152 of Lecture Notes in Computer Science, pages 140–156. Springer-Verlag, 2004. Also available from http://eprint.iacr.org/2004/032/.</li>

      <li>29. A. Silverberg. Compression for trace zero subgroups of elliptic curves. Preprint, 2004. Available from http://www.math.uci.edu/~asilverb/bibliography/compress.pdf.</li>

      <li>30. J. H. Silverman. The Arithmetic of Elliptic Curves. Number 106 in Graduate Texts in Mathematics. Springer-Verlag, Berlin, Germany, 1986.</li>

    </ul>

    <h2 id="sec-43" class="text-2xl font-bold">Appendix A The hyperelliptic function <span class="math">f_{8,P}</span></h2>

    <p class="text-gray-300">We now derive an explicit expression for the function <span class="math">f_{8,P}</span> needed for Miller’s algorithm on the supersingular hyperelliptic curve <span class="math">C_{b}:y^{2}+y=x^{5}+x^{3}+b</span>.</p>

    <p class="text-gray-300">Let <span class="math">P=(x_{P},y_{P})</span>. We will consider divisors <span class="math">D_{n}=n(P)-n(\\infty)</span>. To achieve this we will consider the reduced divisor (via Cantor’s algorithm) <span class="math">D^{\\prime}_{n}</span> which is equivalent to <span class="math">D_{n}</span>. We will consider functions such that <span class="math">D_{n}=D^{\\prime}_{n}+(f_{n})</span>.</p>

    <p class="text-gray-300">The divisor <span class="math">D_{1}=(P)-(\\infty)</span> has Mumford representation</p>

    <p class="text-gray-300"><span class="math">(a_{1}(x),b_{1}(x))=(x+x_{P},y_{P}).</span></p>

    <p class="text-gray-300">We take the function <span class="math">f_{1}=1</span>.</p>

    <p class="text-gray-300">Now consider <span class="math">D_{2}=2(P)-2(\\infty)</span>. One can show that this divisor has Mumford representation <span class="math">(a_{2}(x),b_{2}(x))=(x^{2}+x_{P}^{2},(x_{P}^{4}+x_{P}^{2})x+y_{P}^{2})</span>. This divisor is reduced (so no reduction step in Cantor’s algorithm is performed). Hence <span class="math">D_{2}^{\\prime}=D_{2}</span> and so the function <span class="math">f_{2}</span> may be chosen to be 1.</p>

    <p class="text-gray-300">Now consider <span class="math">D_{4}=4(P)-4(\\infty)</span>. The Mumford representation (after performing the composition step of Cantor’s algorithm) is</p>

    <p class="text-gray-300"><span class="math">(a_{4}(x),b_{4}(x))=(x^{4}+x_{P}^{4},x^{3}+(x_{P}^{8}+x_{P}^{4})x^{2}+(x_{P}^{4})x+y_{P}^{4}).</span></p>

    <p class="text-gray-300">This divisor is not reduced. We have <span class="math">(b_{4}^{2}+b_{4}+x^{5}+x^{3}+b)/a_{4}(x)=a_{4}^{\\prime}(x)=x^{2}+x+(x_{P}^{16}+x_{P}^{8})</span> and <span class="math">b_{4}^{\\prime}(x):=b_{4}(x)+1\\pmod{a_{4}^{\\prime}(x)}=(x_{P}^{16}+1)x+(y_{P}^{8}+x_{P}^{8}+x_{P}^{24}+1)</span>.</p>

    <p class="text-gray-300">We must consider functions and divisors. The divisor <span class="math">D_{4}</span> is equivalent to the divisor <span class="math">D_{4}^{\\prime}=E-2(\\infty)</span> where <span class="math">E</span> is effective. The divisor <span class="math">D_{4}^{\\prime}</span> has the Mumford representation <span class="math">(a_{4}^{\\prime}(x),b_{4}^{\\prime}(x))</span> given above. Denote by <span class="math">\\overline{E}</span> the ‘negative’ of <span class="math">E</span>. The function <span class="math">a_{4}(x)</span> has divisor <span class="math">4(P)+4(\\overline{P})-8(\\infty)</span> while the function <span class="math">a_{4}^{\\prime}(x)</span> has divisor <span class="math">E+\\overline{E}-4(\\infty)</span>. The function <span class="math">y+b_{4}(x)</span> has divisor <span class="math">4(P)+\\overline{E}-6(\\infty)</span> while the function <span class="math">y+b_{4}(x)+1</span> has divisor <span class="math">4(\\overline{P})+E-6(\\infty)</span>. It follows that</p>

    <p class="text-gray-300"><span class="math">((y+b_{4}(x))/a_{4}^{\\prime}(x))=4(P)-E-2(\\infty).</span></p>

    <p class="text-gray-300">Hence we define <span class="math">f_{4}=(y+b_{4}(x))/a_{4}^{\\prime}(x)</span> and we have <span class="math">D_{4}=D_{4}^{\\prime}+(f_{4})</span>.</p>

    <p class="text-gray-300">Now for the final step (thankfully!). We double the divisor <span class="math">D_{4}^{\\prime}</span> using Cantor’s composition rule to obtain <span class="math">D_{8}^{\\prime\\prime}=2E-4(\\infty)</span>. Note that <span class="math">D_{8}=2D_{4}=2(D_{4}^{\\prime}+(f_{4}))=D_{8}^{\\prime\\prime}+(f_{4}^{2})</span>. One computes the Mumford representation of <span class="math">D_{8}^{\\prime\\prime}</span> to be</p>

    <p class="text-gray-300"><span class="math">(a_{8}^{\\prime\\prime}(x),b_{8}^{\\prime\\prime}(x))=(a_{4}^{\\prime}(x)^{2},(x_{P}^{32}+1)x^{2}+(x_{P}^{32}+x_{P}^{16})x+(y_{P}^{16}+x_{P}^{16}+x_{P}^{48}+1))</span></p>

    <p class="text-gray-300">and one can check that <span class="math">((b_{8}^{\\prime\\prime})^{2}+b_{8}^{\\prime\\prime}+f(x))/a_{8}^{\\prime\\prime}(x)=a_{8}^{\\prime}(x)=(x+(x_{P}^{64}+1))</span>. Thus, <span class="math">b_{8}^{\\prime}(x):=b_{8}^{\\prime\\prime}(x)+1\\pmod{a_{8}^{\\prime}(x)}=y_{P}^{64}+x_{P}^{128}+1</span>. Define <span class="math">[8]P=(x_{P}^{64}+1,y_{P}^{64}+x_{P}^{128}+1)</span>. We obtain <span class="math">D_{8}^{\\prime}=([8]P)-(\\infty)</span> which confirms the octupling formula for the point <span class="math">[8]P</span>. Algorithm 5 describes divisor octupling in detail.</p>

    <p class="text-gray-300">We now consider principal divisors. As before, <span class="math">y+b_{8}^{\\prime\\prime}(x)</span> has divisor <span class="math">2E+(\\overline{[8]P})-5(\\infty)</span> and <span class="math">(a_{8}^{\\prime}(x))=(\\overline{[8]P})+([8]P)-2(\\infty)</span>. Hence we have <span class="math">D_{8}^{\\prime\\prime}=D_{8}^{\\prime}+(f_{8}^{\\prime})</span> where <span class="math">f_{8}^{\\prime}=(y+b_{8}^{\\prime\\prime}(x))/a_{8}^{\\prime}(x)</span>.</p>

    <p class="text-gray-300">Putting it all together, we get</p>

    <p class="text-gray-300"><span class="math">(f_{8})=8(P)-([8]P)-7(\\infty)</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">f_{8}=\\left(\\frac{y+b_{4}(x)}{a_{4}^{\\prime}(x)}\\right)^{2}\\frac{y+b_{8}^{\\prime\\prime}(x)}{a_{8}^{\\prime}(x)}.</span></p>

    <p class="text-gray-300">|  Algorithm 5 Octupling of a divisor [u, v]  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  INPUT: divisor [u, v].  |   |</p>

    <p class="text-gray-300">|  OUTPUT: [u', v'] = 8[u, v].  |   |</p>

    <p class="text-gray-300">|  1: if deg(u) = 2 then ▷ [u, v] = [x2 + u1x + u0, v1x + v0]  |   |</p>

    <p class="text-gray-300">|  2: [u', v'] ← [x2 + u164x + (u1 + u0 + 1)64, (v1 + u1)64x + (u1 + u0 + v1 + v0 + 1)64]  |   |</p>

    <p class="text-gray-300">|  3: else if deg(u) = 1 then ▷ [u, v] = [x + u0, v0]  |   |</p>

    <p class="text-gray-300">|  4: [u', v'] ← [x + (u0 + 1)64, (v0 + u02 + 1)64]  |   |</p>

    <p class="text-gray-300">|  5: else ▷ [u, v] = [1, 0]  |   |</p>

    <p class="text-gray-300">|  6: [u', v'] ← [1, 0]  |   |</p>

    <p class="text-gray-300">|  7: end if  |   |</p>

    <p class="text-gray-300">We will precompute a table of powers of  <span class="math">x_P</span>  and  <span class="math">y_P</span>  (these are the initial input values for the point  <span class="math">P</span> ) labelled as</p>

    <div class="my-4 text-center"><span class="math-block">x _ {P} ^ {(i)} = \\pi^ {i} (x _ {P}) = x _ {P} ^ {2 ^ {i}}, \\quad \\text {and} \\quad y _ {P} ^ {(i)} = \\pi^ {i} (y _ {P}) = y _ {P} ^ {2 ^ {i}}</span></div>

    <p class="text-gray-300">for  <span class="math">i = 0,1,\\ldots ,m - 1</span></p>

    <p class="text-gray-300">We focus on computing the term  <span class="math">f_{8,P}(\\psi(Q))</span>  (i.e. we do not bring Frobenius actions into this computation).</p>

    <p class="text-gray-300">Note that, at loop iteration  <span class="math">i</span> , the current value of the  <span class="math">x</span> -coordinate of  <span class="math">[2^{3i}]P</span>  can be written in terms of the precomputed initial values as</p>

    <div class="my-4 text-center"><span class="math-block">x _ {P} ^ {(6 i)} + \\gamma_ {1} (i)</span></div>

    <p class="text-gray-300">where  <span class="math">\\gamma_{1}(i)</span>  is 1 when  <span class="math">i</span>  is odd and 0 otherwise. Similarly, the current value of the  <span class="math">y</span> -coordinate of  <span class="math">[2^{3i}]P</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">y _ {P} ^ {(6 i)} + \\gamma_ {1} (i) x _ {P} ^ {(6 i + 1)} + \\gamma_ {3} (i)</span></div>

    <p class="text-gray-300">where  <span class="math">\\gamma_3(i) = 1</span>  when  <span class="math">i\\equiv 1,2\\pmod{4}</span>  and 0 otherwise.</p>

    <p class="text-gray-300">Obviously, in the above the exponents  <span class="math">6i</span>  in  <span class="math">x_P^{(6i)}</span>  are taken modulo  <span class="math">m</span> . One sees that they wrap around rapidly.</p>

    <p class="text-gray-300">Write  <span class="math">\\alpha = (y + b_4(x))^2\\circ \\psi</span>  as a function of  <span class="math">(x_{Q},y_{Q})</span> . We have  <span class="math">(y + b_{4}(x))\\circ \\psi =</span></p>

    <div class="my-4 text-center"><span class="math-block">y + s _ {2} x ^ {2} + s _ {1} x + s _ {0} + (x + w) ^ {3} + (x _ {P} ^ {8} + x _ {P} ^ {4}) (x + w) ^ {2} + (x _ {P} ^ {4}) (x + w) + y _ {P} ^ {4}</span></div>

    <p class="text-gray-300">and squaring gives</p>

    <div class="my-4 text-center"><span class="math-block">y ^ {2} + s _ {2} ^ {2} x ^ {4} + s _ {1} ^ {2} x ^ {2} + s _ {0} ^ {2} + x ^ {6} + x ^ {4} w ^ {2} + x ^ {2} w ^ {4} + w ^ {6} + (x _ {P} ^ {1 6} + x _ {P} ^ {8}) (x ^ {4} + w ^ {4}) + (x _ {P} ^ {8}) (x ^ {2} + w ^ {2}) + y _ {P} ^ {8}.</span></div>

    <p class="text-gray-300">Now,  <span class="math">s_2^2 = (w^4 + 1)^2 = w</span>  and  <span class="math">s_1^2 = (w^2 + w^4)^2 = w^4 + w + 1</span> . Also,  <span class="math">s_0^2 = s_0 + w^5 + w^3</span> .</p>

    <p class="text-gray-300">Expressing as a 12-tuple we get <span class="math">\\alpha</span> as follows: The first component is</p>

    <p class="text-gray-300"><span class="math">y^{2}+x^{2}+x^{6}+1+(x_{P}^{16}+x_{P}^{8})x^{4}+x_{P}^{8}x^{2}+y_{P}^{8}</span></p>

    <p class="text-gray-300">and the remaining components are</p>

    <p class="text-gray-300"><span class="math">(x^{4}+x^{2},x^{4}+1+x_{P}^{8},1+1,x^{2}+x^{2}+x_{P}^{16}+x_{P}^{8},1+1,1,0,0,0,0,0)</span></p>

    <p class="text-gray-300">which can be slightly simplified.</p>

    <p class="text-gray-300">Finally, we want to evaluate this on <span class="math">(x_{Q},y_{Q})</span> and to replace the current value for <span class="math">x_{P}</span> with the precomputed values. We obtain the 12-tuple with first component</p>

    <p class="text-gray-300"><span class="math">y_{Q}^{2}+x_{Q}^{6}+(x_{P}^{(6i+4)}+x_{P}^{(6i+3)})x_{Q}^{4}+(x_{P}^{(6i+3)}+1+\\gamma_{1}(i))x_{Q}^{2}+y_{P}^{(6i+3)}+\\gamma_{1}(i)x_{P}^{(6i+4)}+\\gamma_{3}(i)+1</span></p>

    <p class="text-gray-300">and remaining components</p>

    <p class="text-gray-300"><span class="math">(x_{Q}^{4}+x_{Q}^{2},x_{Q}^{4}+x_{P}^{(6i+3)}+\\gamma_{1}(i)+1,0,x_{P}^{(6i+4)}+x_{P}^{(6i+3)},0,1,0,0,0,0,0).</span></p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">B.3 The <span class="math">\\beta</span> factor</h3>

    <p class="text-gray-300">We then do a similar thing for <span class="math">\\beta=(y+b_{8}^{\\prime\\prime})\\circ\\psi</span>. We have</p>

    <p class="text-gray-300"><span class="math">\\beta=y+s_{2}x^{2}+s_{1}x+s_{0}+(x_{P}^{32}+1)(x+w)^{2}+(x_{P}^{32}+x_{P}^{16})(x+w)+(y_{P}^{16}+x_{P}^{16}+x_{P}^{48}+1).</span></p>

    <p class="text-gray-300">We expand <span class="math">s_{2}=1+w^{4}</span> etc and write <span class="math">x_{P}^{16}+x_{P}^{48}=x_{P}^{16}(1+x_{P}^{32})</span>. Hence, <span class="math">\\beta</span> can be expressed as a 12-tuple with first component</p>

    <p class="text-gray-300"><span class="math">y+(x_{P}^{32})x^{2}+(x_{P}^{32}+x_{P}^{16})x+y_{P}^{16}+x_{P}^{16}(1+x_{P}^{32})+1</span></p>

    <p class="text-gray-300">and remaining components</p>

    <p class="text-gray-300"><span class="math">(x_{P}^{32}+x_{P}^{16},x+x_{P}^{32}+1,0,x^{2}+x,0,1,0,0,0,0,0).</span></p>

    <p class="text-gray-300">Finally, we substitute <span class="math">(x,y)=(x_{Q},y_{Q})</span> and insert the precomputed values <span class="math">x_{P}=x_{P}^{(6i)}+\\gamma_{1}(i)</span> and <span class="math">y_{P}=y_{P}^{(6i)}+\\gamma_{1}(i)x_{P}^{(6i+1)}+\\gamma_{3}(i)</span>. Using the formula <span class="math">\\gamma_{1}(i)(1+\\gamma_{1}(i))=0</span> gives the 12-tuple with first component</p>

    <p class="text-gray-300"><span class="math">y_{Q}+(x_{P}^{(6i+5)}+\\gamma_{1}(i))x_{Q}^{2}+(x_{P}^{(6i+5)}+x_{P}^{(6i+4)})x_{Q}</span> <span class="math">+y_{P}^{(6i+4)}+x_{P}^{(6i+4)}\\left(x_{P}^{(6i+5)}+\\gamma_{1}(i)+1\\right)+\\gamma_{3}(i)+1.</span></p>

    <p class="text-gray-300">and remaining components</p>

    <p class="text-gray-300"><span class="math">(x_{P}^{(6i+5)}+x_{P}^{(6i+4)},x_{Q}+x_{P}^{(6i+5)}+\\gamma_{1}(i)+1,0,x_{Q}^{2}+x_{Q},0,1,0,0,0,0,0).</span></p>

    <p class="text-gray-300">It remains to multiply the <span class="math">\\alpha</span> and <span class="math">\\beta</span> together efficiently. But first we consider how to absorb the powers of 8 into the equations.</p>

    <p class="text-gray-300">B.4 Absorbing powers of 8</p>

    <p class="text-gray-300">We break the computation of the eta pairing <span class="math">\\eta_{T}(P,Q)</span> into two parts, the main part is the loop corresponding to the <span class="math">(m-1)/2</span> octuplings, and the secondary part is the final two doublings and addition. The main part can be expressed as the product</p>

    <p class="text-gray-300"><span class="math">\\prod_{i=0}^{(m-3)/2}f_{8,2^{3i}P}(\\psi(Q))^{2^{3(m-3-2i)/2}}</span></p>

    <p class="text-gray-300">where <span class="math">f_{8,2^{3i}P}=\\alpha\\beta</span> as described previously. The goal of this section is to write this as</p>

    <p class="text-gray-300"><span class="math">\\prod_{i=0}^{(m-3)/2}f_{i}</span></p>

    <p class="text-gray-300">where each <span class="math">f_{i}</span> is an equation which has the 2-power Frobenius action already brought into the equation. Using the formulae for <span class="math">\\alpha</span> and <span class="math">\\beta</span> above we will compute <span class="math">\\alpha^{2^{3(m-3-2i)/2}}</span> and <span class="math">\\beta^{2^{3(m-3-2i)/2}}</span>.</p>

    <p class="text-gray-300">To achieve this efficiently requires precomputation of the 2-power Frobenius orbit of the point <span class="math">Q</span>, so define for <span class="math">i=0,1,\\ldots,m-1</span></p>

    <p class="text-gray-300"><span class="math">s_{Q}^{(i)}=s_{Q}^{2^{i}}\\qquad\\text{and}\\qquad y_{Q}^{(i)}=y_{Q}^{2^{i}}.</span></p>

    <p class="text-gray-300">The most delicate part of the argument is handling how <span class="math">w</span> and <span class="math">s_{0}</span> behave under powering by <span class="math">2^{3(m-3-2i)/2}</span>. Recall that <span class="math">w^{8}=w+1</span> from which we deduce</p>

    <p class="text-gray-300">\\[ \\begin{split}s_{0}^{8}&=s_{0}+w^{2}\\\\ s_{0}^{8^{2}}&=s_{0}+1\\\\ s_{0}^{8^{3}}&=s_{0}+w^{2}+1\\end{split} \\] (5)</p>

    <p class="text-gray-300">Note that <span class="math">m</span> is coprime to 12 and so is odd. We have <span class="math">w^{8}=w+1</span> and so, since <span class="math">(m-3-2i)/2\\equiv i\\pmod{2}</span> we have <span class="math">w^{2^{3(m-3-2i)/2}}=w+\\gamma_{1}(i)</span>. The same formula holds when <span class="math">w</span> is replaced by <span class="math">w^{2}</span> or <span class="math">w^{4}</span>. For <span class="math">s_{0}</span> note that if <span class="math">m\\equiv 1\\pmod{4}</span> then</p>

    <p class="text-gray-300"><span class="math">s_{0}^{2^{3(m-3-2i)/2}}=s_{0}+\\gamma_{1}(i)w^{2}+\\gamma_{3}(i)</span></p>

    <p class="text-gray-300">while if <span class="math">m\\equiv 3\\pmod{4}</span> then</p>

    <p class="text-gray-300"><span class="math">s_{0}^{2^{3(m-3-2i)/2}}=s_{0}+\\gamma_{1}(i)w^{2}+\\gamma_{3}(i)+1.</span></p>

    <p class="text-gray-300">We denote by <span class="math">\\gamma_{4}(m,i)</span> the value <span class="math">\\gamma_{3}(i)</span> when <span class="math">m\\equiv 1\\pmod{4}</span> and <span class="math">\\gamma_{3}(i)+1</span> otherwise.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">B.5 The <span class="math">\\alpha</span> factor</h3>

    <p class="text-gray-300">The basic shape of the term <span class="math">\\alpha</span> will be similar to previously, except a few extra terms due to equation (5). The process is simple, just bring the 2-power operation into the formula and simplify the ‘exponents’.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The “constant” term will be</p>

    <p class="text-gray-300"><span class="math">y_{Q}^{((3m-7-6i)/2)}+(x_{Q}^{((3m-7-6i)/2)})^{3}+(x_{P}^{((3m-1+6i)/2)}+x_{P}^{((3m-3+6i)/2)})x_{Q}^{((3m-6i-5)/2)}+</span> <span class="math">(x_{P}^{((3m-3+6i)/2)}+1+\\gamma_{1}(i))x_{Q}^{((3m-7-6i)/2)}+y_{P}^{((3m-3+6i)/2)}+\\gamma_{1}(i)x_{P}^{((3m-1+6i)/2)}+\\gamma_{3}(i)+1</span></p>

    <p class="text-gray-300">plus when <span class="math">(m-3-2i)/2</span> is odd (i.e., when <span class="math">i</span> is odd) another term must be added (coming from the fact that <span class="math">(w^{2j})^{8}=w^{2j}+1</span> and the <span class="math">s_{0}</span> term). We write this other term as</p>

    <p class="text-gray-300"><span class="math">\\gamma_{1}(i)\\left(x_{Q}^{(3m-7-6i)/2)}+1+\\gamma_{1}(i)+x_{P}^{((3m-1+6i)/2)}\\right)+\\gamma_{4}(m,i).</span></p>

    <p class="text-gray-300">We can apply <span class="math">\\gamma_{1}(i)(1+\\gamma_{1}(i))=0</span>, cancel various terms and simplify the cubing of <span class="math">x_{Q}^{((3m-7-6i)/2)}</span>. The expression simplifies to</p>

    <p class="text-gray-300"><span class="math">y_{Q}^{((3m-7-6i)/2)}+(x_{P}^{((3m-1+6i)/2)}+x_{P}^{((3m-3+6i)/2)})x_{Q}^{((3m-5-6i)/2)}+</span> <span class="math">(x_{P}^{((3m-3+6i)/2)}+1+x_{Q}^{((3m-5-6i)/2)})x_{Q}^{((3m-7-6i)/2)}+y_{P}^{((3m-3+6i)/2)}+\\gamma_{5}(i)</span></p>

    <p class="text-gray-300">where <span class="math">\\gamma_{5}(i)=1</span> if <span class="math">i\\equiv 1\\pmod{4}</span> and <span class="math">0</span> otherwise.</p>

    <p class="text-gray-300">The remaining terms are (note that there is an additional <span class="math">\\gamma_{1}(i)w^{2}</span> term due to the <span class="math">s_{0}</span> term):</p>

    <p class="text-gray-300"><span class="math">(x_{Q}^{((3m-5-6i)/2)}+x_{Q}^{((3m-7-6i)/2)})w+(x_{Q}^{((3m-5-6i)/2)}+x_{P}^{((3m-3+6i)/2)}+1)w^{2}</span> <span class="math">+(x_{P}^{((3m-1+6i)/2)}+x_{P}^{((3m-3+6i)/2)})w^{4}+s_{0}</span></p>

    <p class="text-gray-300">As usual, the indices inside round brackets should be reduced modulo <span class="math">m</span> to the range <span class="math">\\{0,1,\\ldots,m-1\\}</span>.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">B.6 The <span class="math">\\beta</span> factor</h3>

    <p class="text-gray-300">We now consider the <span class="math">\\beta</span> factor. One sees that the “constant term” of <span class="math">\\beta^{2^{3((m-3-2i)/2)}}</span> is</p>

    <p class="text-gray-300"><span class="math">y_{Q}^{((3m-9-6i)/2)}+(x_{P}^{((3m+1+6i)/2)}+\\gamma_{1}(i))x_{Q}^{(3m-7-6i)/2)}+(x_{P}^{((3m+1+6i)/2)}</span> <span class="math">\\qquad+x_{P}^{((3m-1+6i)/2)})x_{Q}^{(3m-9-6i)/2)}+y_{P}^{((3m-1+6i)/2)}</span> <span class="math">\\qquad+x_{P}^{((3m-1+6i)/2)}(x_{P}^{(3m+1+6i)/2)}+\\gamma_{1}(i)+1)+\\gamma_{3}(i)+1</span></p>

    <p class="text-gray-300">plus</p>

    <p class="text-gray-300"><span class="math">\\gamma_{1}(i)\\left(x_{P}^{((3m-1+6i)/2)}+x_{Q}^{(3m-7-6i)/2)}+\\gamma_{1}(i)+1\\right)+\\gamma_{4}(m,i).</span></p>

    <p class="text-gray-300">This simplifies to</p>

    <p class="text-gray-300"><span class="math">y_{Q}^{((3m-9-6i)/2)}+(x_{P}^{((3m+1+6i)/2)}+x_{P}^{((3m-1+6i)/2)})x_{Q}^{(3m-9-6i)/2)}+y_{P}^{((3m-1+6i)/2)}</span> <span class="math">\\qquad+x_{P}^{((3m+1+6i)/2)}(x_{P}^{(3m-1+6i)/2)}+x_{Q}^{(3m-7-6i)/2)})+x_{P}^{((3m-1+6i)/2)}+\\gamma_{5}(i)</span></p>

    <p class="text-gray-300">The remaining terms are (again, including a <span class="math">\\gamma_{1}(i)w^{2}</span> term)</p>

    <p class="text-gray-300"><span class="math">(x_{P}^{((3m+1+6i)/2)}+x_{P}^{((3m-1+6i)/2)})w+(x_{P}^{(3m+1+6i)/2)}+x_{Q}^{(3m-9-6i)/2)}+1)w^{2}</span> <span class="math">\\qquad+(x_{Q}^{(3m-7-6i)/2)}+x_{Q}^{(3m-9-6i)/2)})w^{4}+s_{0}</span></p>

    <p class="text-gray-300">B.7 Simplifying the final operations</p>

    <p class="text-gray-300">After the loop of <span class="math">(m-1)/2</span> iterations, it remains to perform two doublings and an addition. For the case in which the input divisors are both of the form <span class="math">D_{i}=(P_{i})-(\\infty)</span> the final addition can be skipped as it has no impact on the function. Note that <span class="math">(2^{(3m+1)/2}+1)D_{1}=\\phi(D_{1})</span>, where <span class="math">\\phi(D_{1})=(x+1,y+x^{2}+1)-(\\infty)</span>. Denote by <span class="math">D_{1}^{\\prime}</span> the reduced divisor <span class="math">2^{(3m+1)/2}D_{1}</span>. <span class="math">D_{1}^{\\prime}</span> is equivalent to <span class="math">\\phi(D_{1})-D_{1}=(\\phi(P))-(P)</span>.</p>

    <p class="text-gray-300">Now, let <span class="math">v</span> be the vertical line through <span class="math">P</span> and <span class="math">-P</span>. So <span class="math">(v)=(P)+(-P)-2(\\infty)</span>. Then</p>

    <p class="text-gray-300"><span class="math">(\\phi(P))-(P)+(v)=(\\phi(P))+(-P)-2(\\infty)</span></p>

    <p class="text-gray-300">Hence, by the uniqueness of the reduced divisors in Mumford representation we have</p>

    <p class="text-gray-300"><span class="math">D^{\\prime}=(\\phi(P))+(-P)-2(\\infty).</span></p>

    <p class="text-gray-300">As one of the points on <span class="math">D^{\\prime}</span> is <span class="math">-P</span>, the composition stage of Cantor’s algorithm immediately cancels <span class="math">P</span> and <span class="math">-P</span> using a vertical line function. As we don’t need to know what the “current” divisor is before the addition, we can also skip the two doublings. We know from Appendix A that the mumford representation of the divisor <span class="math">D=4(P)-4(\\infty)</span> is <span class="math">(a_{4}(x),b_{4}(x))=(x^{4}+x_{P}^{4},x^{3}+(x_{P}^{8}+x_{P}^{4})x^{2}+(x_{P}^{4})x+y_{P}^{4})</span>. So, we need to extract the point on the divisor after the <span class="math">(m-1)/2</span> octupling phase, square the function twice, and then multiply it by the function defined below;</p>

    <p class="text-gray-300"><span class="math">y+b_{4}(x)=y+x^{3}+(x_{P}^{8}+x_{P}^{4})x^{2}+(x_{P}^{4})x+y_{P}^{4}</span></p>

    <p class="text-gray-300">Building the distortion map into the formula gives us a constant term;</p>

    <p class="text-gray-300"><span class="math">y+x^{2}(1+x+x_{P}^{8}+x_{P}^{4})+x_{P}^{4}x+y_{P}^{4}</span></p>

    <p class="text-gray-300">and the remaining terms are;</p>

    <p class="text-gray-300"><span class="math">(x^{2}+x_{P}^{4},x_{P}^{8}+x_{P}^{4},1,x^{2}+x,0,1,0,0,0,0,0).</span></p>

    <p class="text-gray-300">When we are working with the general divisor case, we cannot skip the final addition as we can for the simple divisor case. For both the doublings and the addition, we need to evaluate the points on the second divisor at the function <span class="math">y+s_{1}x^{3}+l_{2}x^{2}+l_{1}x+l_{0}</span>, where <span class="math">s_{1},l_{2},l_{1},l_{0}</span> come from Cantor’s algorithm. After building the distortion map into this formula, we get the “constant” term:</p>

    <p class="text-gray-300"><span class="math">(y+x^{2}+x(s_{1}x^{2}+l_{1})+l_{2}x^{2}+l_{0})</span></p>

    <p class="text-gray-300">and the remaining terms are;</p>

    <p class="text-gray-300"><span class="math">(s_{1}x^{2}+l_{1},x+s_{1}x+l_{2},s_{1},x^{2}+x,0,1,0,0,0,0).</span></p>`;
---

<BaseLayout title="Efficient Pairing Computation on Supersingular Abelian Varie... (2004/375)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/375
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
