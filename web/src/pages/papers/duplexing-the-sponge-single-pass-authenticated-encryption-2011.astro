---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/499';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Duplexing the sponge: single-pass authenticated encryption and other applications';
const AUTHORS_HTML = 'Guido Bertoni, Joan Daemen, Michaël Peeters, Gilles Van Assche';

const CONTENT = `    <p class="text-gray-300">Guido Bertoni<sup>1</sup> , Joan Daemen<sup>1</sup> , Michaël Peeters<sup>2</sup> , and Gilles Van Assche<sup>1</sup></p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><sup>1</sup> STMicroelectronics <sup>2</sup> NXP Semiconductors</p>
    </blockquote>

    <p class="text-gray-300"><strong>Abstract.</strong> This paper proposes a novel construction, called duplex, closely related to the sponge construction, that accepts message blocks to be hashed and—at no extra cost—provides digests on the input blocks received so far. It can be proven equivalent to a cascade of sponge functions and hence inherits its security against single-stage generic aĴacks. The main application proposed here is an authenticated encryption mode based on the duplex construction. This mode is efficient, namely, enciphering and authenticating together require only a single call to the underlying permutation per block, and is readily usable in, e.g., key wrapping. Furthermore, it is the first mode of this kind to be directly based on a permutation instead of a block cipher and to natively support intermediate tags. The duplex construction can be used to efficiently realize other modes, such as a reseedable pseudo-random bit sequence generators and a sponge variant that overwrites part of the state with the input block rather than to XOR it in.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> sponge functions, duplex construction, authenticated encryption, key wrapping, provable security, pseudo-random bit sequence generator, Keccak</p>

    <h2 id="sec-2" class="text-2xl font-bold"><strong>1 Introduction</strong></h2>

    <p class="text-gray-300">While most symmetric-key modes of operations are based on a block cipher or a stream cipher, there exist modes using a fixed permutation as underlying primitive. Designing a cryptographically strong permutation suitable for such purposes is similar to designing a block cipher without a key schedule and this design approach was followed for several recent hash functions, see, e.g., [19].</p>

    <p class="text-gray-300">The sponge construction is an example of such a mode. With its arbitrarily long input and output sizes, it allows building various primitives such as a stream cipher or a hash function [7]. In the former, the input is short (typically the key and a nonce) while the output is as long as the messag<a href="#page-18-0">e to</a> encrypt. In contrast, the laĴer takes a message of any length at input and produces a digest of small length.</p>

    <p class="text-gray-300">Some applications can take advantage of both a long input and a long output size. For instance, <a href="#page-18-1">au</a>thenticated encryption combines the encryption of a message and the generation of a message authentication code (MAC) on it. It could be implemented with one sponge function call to generate a key stream (long output) for the encryption and another call to generate the MAC (long input). However, in this case, encryption and authentication are separate processes without any synergy.</p>

    <p class="text-gray-300">The duplex construction is a novel way to use a fixed permutation (or transformation) to allow the alternation of input and output blocks at the same rate as the sponge construction, like a full-duplex communication. In fact, the duplex construction can be seen as a particular way to use the sponge construction, hence it inherits its security properties. By using the duplex construction, authenticated encryption requires only one call to the underlying permutation (or transformation) per message block. In a nutshell, the input blocks of the duplex are used to input the key and the message blocks, while the intermediate output blocks are used as key stream and the last one as a MAC.</p>

    <p class="text-gray-300">Authenticated encryption (AE) has been extensively studied in the last ten years. Block cipher modes clearly are a popular way to provide simultaneously both integrity and confidentiality. Many block cipher modes have been proposed and most of these come with a security proof against generic attacks, e.g., [3,21,28,45,38,5,30,43,32,24,46,39,25,27,26,31]. Interestingly, there have also been attempts at designing dedicated hybrid primitives offering efficient simultaneous stream encryption and MAC computation, e.g., Helix and Phelix [20,48]. However, these primitives were shown to be weak [36,40,49]. Another example of hybrid primitive is the Grain-128 stream cipher to which optional built-in authentication was recently added [50].</p>

    <p class="text-gray-300">Our proposed mode shares with these hybrid primitives that it offers efficient simultaneous stream encryption and MAC computation. It shares with the block cipher modes that it has provable security against generic attacks. However, it is the first such construction that (directly) relies on a permutation rather than a block cipher and that proves its security based on this type of primitive. An important efficiency parameter of an AE mode is the number of calls to the block cipher or to the permutation per block. While encryption or authentication alone requires one call per block, some AE modes only require one call per block for both functions. The duplex construction naturally provides a good basis for building such an efficient AE mode. Also, the AE mode we propose natively supports intermediate tags and the authenticated encryption of a sequence of messages.</p>

    <p class="text-gray-300">Authenticated encryption can also be used to transport secret keys in a confidential way and to ensure their integrity. This task, called key wrapping, is very important in key management and can be implemented with our construction if each key has a unique identifier.</p>

    <p class="text-gray-300">Finally, the duplex construction can be used for other modes as well, such as a reseedable pseudo-random bit sequence generator (PRG) or to prove the security of an "overwrite" mode where the input block overwrites part of the state instead of XORing it in.</p>

    <p class="text-gray-300">These modes can readily be used by the concrete sponge function Keccak [11] and the members of a recent wave of lightweight hash functions that are in fact sponge functions: Quark [2], Photon [23] and Spongent [14]. For these, and for the small-width instances of Keccak, our security bound against generic attacks beyond the birthday bound published in [10] allows constructing solutions that are at the same time compact, efficient and potentially secure.</p>

    <p class="text-gray-300">The remainder of this paper is organized as follows. First, we propose a model for authenticated encryption in Section 2. Then in Section 3, we review the sponge construction. The core concept of this paper, namely the duplex construction, is defined in Section 4. Its use for authenticated encryption is given in Section 5 and for other applications in Section 6. Finally, Section 7 discusses the use of a flexible and compact padding.</p>

    <p class="text-gray-300"><span id="page-1-0"></span>We consider authenticated encryption as a process that takes as input a key K, a data header A and a data body B and that returns a cryptogram C and a tag T. We denote this operation by the term wrapping and the operation of taking a data header A, a cryptogram C and a tag T and returning the data body B if the tag T is correct by the term unwrapping.</p>

    <p class="text-gray-300">The cryptogram is the data body enciphered under the key K and the tag is a MAC computed under the same key K over both header A and body B. So here the header A can play the role of associated data as described in [42]. We assume the wrapping and unwrapping operations as such to be deterministic. Hence two equal inputs (A, B) = (A', B') will give rise to the same output (C, T) under the same key K. If this is a problem, it can be tackled by expanding A with a nonce.</p>

    <p class="text-gray-300">Formally, for a given key length k and tag length t, we consider a pair of algorithms W and U, with</p>

    <p class="text-gray-300"><span class="math-block">W: \\mathbb{Z}_2^k \\times (\\mathbb{Z}_2^<em>)^2 \\to \\mathbb{Z}_2^</em> \\times \\mathbb{Z}_2^t : (K, A, B) \\to (C, T) = W(K, A, B)</span> , and  <span class="math">U: \\mathbb{Z}_2^k \\times (\\mathbb{Z}_2^<em>)^2 \\times \\mathbb{Z}_2^t \\to \\mathbb{Z}_2^</em> \\cup \\{\\text{error}\\} : (K, A, C, T) \\to B \\text{ or error.}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The algorithms are such that if (C, T) = W(K, A, B) then U(K, A, C, T) = B. As we consider only the case of non-expanding encryption, we assume from now on that</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 Intermediate tags and authenticated encryption of a sequence</h4>

    <p class="text-gray-300"><span id="page-2-1"></span>So far, we have only considered the case of the authentication and encryption of a single message, i.e., a header and body pair (A, B). It can also be interesting to authenticate and encrypt a sequence of messages in such a way that the authenticity is guaranteed not only on each (A, B) pair but also on the sequence received so far. Intermediate tags can also be useful in practice to be able to catch fraudulent transactions early.</p>

    <p class="text-gray-300">Let  <span class="math">(\\overline{A}, \\overline{B}) = (A^{(1)}, B^{(1)}, A^{(2)}, \\dots, A^{(n)}, B^{(n)})</span>  be a sequence of header-body pairs. We extend the function of wrapping and unwrapping as providing encryption over the last body  <span class="math">B^{(n)}</span>  and authentication over the whole sequence  <span class="math">(\\overline{A}, \\overline{B})</span> . Formally, W and W are defined as:</p>

    <div class="my-4 text-center"><span class="math-block">W: \\mathbb{Z}_2^k \\times (\\mathbb{Z}_2^*)^{2+} \\to \\mathbb{Z}_2^* \\times \\mathbb{Z}_2^t : (K, \\overline{A, B}) \\to (C^{(\\text{last})}, T^{(\\text{last})}) = W(K, \\overline{A, B}), \\text{ and } U: \\mathbb{Z}_2^k \\times (\\mathbb{Z}_2^*)^{2+} \\times \\mathbb{Z}_2^t \\to \\mathbb{Z}_2^* \\cup \\{\\text{error}\\} : (K, \\overline{A, C}, T^{(\\text{last})}) \\to B^{(\\text{last})} \\text{ or error.}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here,  <span class="math">(\\mathbb{Z}_2^*)^{2+}</span>  means any sequence of binary strings, with an even number of such strings and at least two. To wrap a sequence of header-body pairs, the sender calls  <span class="math">W(K,A^{(1)},B^{(1)})</span>  with the first header-body pair to get  <span class="math">(C^{(1)},T^{(1)})</span> , then  <span class="math">W(K,A^{(1)},B^{(1)},A^{(2)},B^{(2)})</span>  with the second one to get  <span class="math">(C^{(2)},T^{(2)})</span> , and so on. To unwrap, the receiver first calls  <span class="math">U(K,A^{(1)},C^{(1)},T^{(1)})</span>  to retrieve the first body  <span class="math">B^{(1)}</span> , then  <span class="math">U(K,A^{(1)},C^{(1)},A^{(2)},C^{(2)},T^{(2)})</span>  to retrieve the second body, and so on. As we consider only the case of non-expanding encryption, we assume that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  for all i.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-5" class="text-2xl font-bold">2.2 Security requirements</h2>

    <p class="text-gray-300">We consider two security notions from [45] and works cited therein, called <em>privacy</em> and <em>authenticity</em>. Together, these notions are central to the security of authenticated encryption [3].</p>

    <p class="text-gray-300">Privacy is defined in Eq. (1) below. Informally, it means that the output of the wrapping function looks like uniformly chosen random bits to an observer who does not know the key.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$Adv^{\\text{priv}}(\\mathcal{A}) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[K \\xleftarrow{\\$} \\mathbb{Z}_2^k : \\mathcal{A}[W(K, \\cdot, \\cdot)] = 1] - \\Pr[\\mathcal{A}[R(\\cdot, \\cdot)] = 1] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\tag{1}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-2-0"></span>with  $R(\\overline{A,B}) = \\lfloor \\mathcal{RO}(\\overline{A,B}) \\rfloor_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+t}<span class="math">  where  </span>B^{(n)}<span class="math">  is the last body in  </span>\\overline{A,B}$ ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is the bitlength of string x,  <span class="math">\\lfloor \\cdot \\rfloor_{\\ell}</span>  indicates truncation to  <span class="math">\\ell</span>  bits and  <span class="math">K \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_2^k<span class="math">  means that K is chosen randomly and uniformly among the set  </span>\\mathbb{Z}_2^k<span class="math"> . In this definition, we use a random oracle  </span>\\mathcal{RO}<span class="math">  as defined in [4], but allowing sequences of one or more binary strings as input (instead of a single binary string). Here, a random oracle is a map from  </span>(\\mathbb{Z}_2^<em>)^+<span class="math">  to  </span>\\mathbb{Z}_2^\\infty<span class="math"> , chosen by selecting each bit of  </span>\\mathcal{RO}(x)<span class="math">  uniformly and independently, for every input. The original definition can still be used by defining an injective mapping from  </span>(\\mathbb{Z}_2^</em>)^+<span class="math">  to  </span>\\mathbb{Z}_2^*$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For privacy, we consider only adversaries who respect the nonce requirement. For a single header-body pair, it means that, for any two queries (A, B) and (A', B'), we have  <span class="math">A = A&#x27; \\Rightarrow B = B&#x27;</span> . In general, the nonce requirement specifies that for any two queries  <span class="math">(\\overline{A}, \\overline{B})</span>  and  <span class="math">(\\overline{A&#x27;}, \\overline{B&#x27;})</span>  of equal length n, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{pre}(\\overline{A,B}) = \\operatorname{pre}(\\overline{A&#x27;,B&#x27;}) \\Rightarrow B^{(n)} = B&#x27;^{(n)},</span></div>

    <p class="text-gray-300">with  <span class="math">\\operatorname{pre}(\\overline{A}, \\overline{B}) = (A^{(1)}, B^{(1)}, A^{(2)}, \\dots, B^{(n-1)}, A^{(n)})</span>  the sequence with the last body omitted. As for a stream cipher, not respecting the nonce requirement means that the adversary can learn the bitwise difference between two plaintext bodies.</p>

    <p class="text-gray-300">Authenticity is defined in Eq. (2) below. Informally, it quantifies the probability of the adversary successfully generating a forged ciphertext-tag pair.</p>

    <p class="text-gray-300"><span id="page-3-1"></span> <span class="math-block">Adv^{\\text{auth}}(\\mathcal{A}) = \\Pr[K \\xleftarrow{\\$} \\mathbb{Z}_2^k : \\mathcal{A}[W(K,\\cdot,\\cdot)] \\text{ outputs a forgery}]. \\tag{2}</span></p>

    <p class="text-gray-300">Here a forgery is a sequence  <span class="math">(\\overline{A}, \\overline{C}, T)</span>  such that  <span class="math">U(K, \\overline{A}, \\overline{C}, T) \\neq</span>  error and that the adversary made no query to W with input  <span class="math">(\\overline{A}, \\overline{B})</span>  returning  <span class="math">(C^{(n)}, T)</span> , with  <span class="math">C^{(n)}</span>  the last ciphertext body of  <span class="math">\\overline{A}, \\overline{C}</span> . Note that authenticity does not need the nonce requirement.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.3 An ideal system</h3>

    <p class="text-gray-300">We can define an ideal system using a pair of independent random oracles  <span class="math">(\\mathcal{RO}_C, \\mathcal{RO}_T)</span> . For a single header-body pair, encryption and tag computation are implemented as follows. The ciphertext C is produced by XORing B with a key stream. This key stream is the output of  <span class="math">\\mathcal{RO}_C(K,A)</span> . If (K,A) is a nonce, key streams for different data inputs are the result of calls to  <span class="math">\\mathcal{RO}_C</span>  with different inputs and hence one key stream gives no information on another. The tag T is the output of  <span class="math">\\mathcal{RO}_T(K,A,B)</span> . Tags computed over different header-body pairs will be the result of calls to  <span class="math">\\mathcal{RO}_T</span>  with different inputs. Key stream sequences give no information on tags and vice versa as they are obtained by calls to different random oracles.</p>

    <p class="text-gray-300">Let us define the ideal system in the general case, which we call ROWRAP. Wrapping is defined as  <span class="math">W(K, \\overline{A}, \\overline{B}) = (C^{(n)}, T^{(n)})</span> , if  <span class="math">\\overline{A}, \\overline{B}</span>  contains n header-body pairs, with</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$C^{(n)} = \\lfloor \\mathcal{RO}_{\\mathbb{C}}(K, \\operatorname{pre}(\\overline{A, B})) \\rfloor_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\oplus B^{(n)},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">T^{(n)} = \\lfloor \\mathcal{RO}_{\\mathbb{T}}(K, \\overline{A, B}) \\rfloor_{t}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The unwrapping algorithm U first checks that  <span class="math">T^{(n)} = \\lfloor \\mathcal{RO}_{\\mathbf{T}}(K, \\overline{A}, \\overline{B}) \\rfloor_t</span>  and if so decrypts each body  $B^{(i)} = \\lfloor \\mathcal{RO}_{\\mathbf{C}}(K, A^{(1)}, B^{(1)}, A^{(2)}, \\dots, A^{(i)}) \\rfloor_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\oplus C^{(i)}<span class="math">  from the first one to the last one and finally returns the last one  </span>B^{(n)} = \\lfloor \\mathcal{RO}_{\\mathbf{C}}(K, \\operatorname{pre}(\\overline{A}, \\overline{B})) \\rfloor_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\oplus C^{(n)}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The security of ROWRAP is captured by Lemmas 1 and 2.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let  <span class="math">\\mathcal{A}[\\mathcal{RO}_C, \\mathcal{RO}_T]</span>  be an adversary having access to  <span class="math">\\mathcal{RO}_C</span>  and  <span class="math">\\mathcal{RO}_T</span>  and respecting the nonce requirement. Then,  <span class="math">Adv^{priv}_{\\mathcal{RO}_{WRAP}}(\\mathcal{A}) \\leq q2^{-k}</span>  if the adversary makes no more than q queries to  <span class="math">\\mathcal{RO}_C</span>  or  <span class="math">\\mathcal{RO}_T</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For any fixed last body  <span class="math">B^{(n)}</span> , the output of ROWRAP is indistinguishable from that of  <span class="math">\\mathcal{RO}</span>  used in Eq. (1), unless  <span class="math">\\mathcal{A}</span>  makes a query to  <span class="math">\\mathcal{RO}_{\\mathbb{C}}</span>  or  <span class="math">\\mathcal{RO}_{\\mathbb{T}}</span>  with the correct key K as first argument. This last event has probability  <span class="math">q2^{-k}</span>  among q queries and the advantage can be bounded following [34, Theorem 1]. The conclusion is still valid for a variable  <span class="math">B^{(n)}</span> , as a different  <span class="math">B^{(n)}</span>  implies a different pre <span class="math">(\\overline{A}, \\overline{B})</span> .</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">\\mathcal{A}[\\mathcal{RO}_C, \\mathcal{RO}_T]</span>  be an adversary having access to  <span class="math">\\mathcal{RO}_C</span>  and  <span class="math">\\mathcal{RO}_T</span> . Then, ROWRAP satisfies  <span class="math">Adv^{auth}_{ROWRAP}(\\mathcal{A}) \\leq q2^{-k} + 2^{-t}</span>  if the adversary makes no more than q queries to  <span class="math">\\mathcal{RO}_C</span>  or  <span class="math">\\mathcal{RO}_T</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> A similar argument as in Lemma 1 can be applied here. In addition, the adversary can just be lucky and output the correct tag T with probability  <span class="math">2^{-t}</span> .</p>

    <p class="text-gray-300"><span id="page-3-0"></span>The sponge construction [7] builds a function sponge[f,pad,r] with variable-length input and arbitrary output length using a fixed-length permutation (or transformation) f, a padding rule "pad" and a parameter  <span class="math">bitrate\\ r</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the padding rule we use the following notation: the padding of a message <em>M</em> to a sequence of <em>x</em>-bit blocks is denoted by *M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>pad[</em>x<em>](</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>), where </em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em> is the length of </em>M<em>. This notation highlights that we only consider padding rules that append a bitstring that is fully determined by the length of </em>M<em> and the block length </em>x<em>. We may omit [</em>x<em>], </em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">* or both if their value is clear from the context.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 1.</strong> <em>A padding rule is</em> sponge-compliant <em>if it never results in the empty string and if it satisfies following criterion:</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\forall n \\geq 0, \\forall M, M' \\in \\mathbb{Z}_2^* : M \\neq M' \\Rightarrow M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{pad}[r](</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\neq M'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{pad}[r](</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{nr}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> (3)</p>

    <p class="text-gray-300">For the sponge construction to be secure (see Section 3.2), the padding rule pad must be sponge-compliant. As a sufficient condition, a padding rule that is reversible, non-empty and such that the last block must be non-zero, is sponge-compliant [7].</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8"><strong>3.1 Definition</strong></h3>

    <p class="text-gray-300">The permutation <em>f</em> operates on a fixed number of bits, the <em>width b</em>. The <a href="#page-18-1">s</a>ponge construction has a state of <em>b</em> bits. First, all the bits of the state are initialized to zero. The input message is padded with the function pad[<em>r</em>] and cut into <em>r</em>-bits blocks. Then it proceeds in two phases: the <em>absorbing phase</em> followed by the <em>squeezing phase</em>:</p>

    <p class="text-gray-300"><strong>Absorbing phase</strong> The <em>r</em>-bit input message blocks are XORed into the first <em>r</em> bits of the state, interleaved with applications of the function <em>f</em> . When all message blocks are processed, the sponge construction switches to the squeezing phase.</p>

    <p class="text-gray-300"><strong>Squeezing phase</strong> The first <em>r</em> bits of the state are returned as output blocks, interleaved with applications of the function <em>f</em> . The number of iterations is determined by the requested number of bits.</p>

    <p class="text-gray-300">Finally the output is truncated to the requested length. The sponge construction is illustrated in Figure 1, and Algorithm 1 provides a formal definition.</p>

    <p class="text-gray-300"><img src="_page_4_Figure_9.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><strong>Fig. 1.</strong> The sponge construction</p>

    <p class="text-gray-300">The value <em>c</em> = <em>b − r</em> is called the <em>capacity</em>. The last <em>c</em> bits of the state are never directly affected by the input blocks and are never output during the squeezing phase. The capacity <em>c</em> actually determines the aĴainable security level of the construction [8,10].</p>

    <pre><code class="language-text">Require: r &lt; b</code></pre>

    <pre><code class="language-text">Interface: Z = \\operatorname{sponge}(M,\\ell) with M \\in \\mathbb{Z}_2^*, integer \\ell &gt; 0 and Z \\in \\mathbb{Z}_2^\\ell P = M||\\operatorname{pad}[r](|M|) Let P = P_0||P_1||\\dots||P_w with |P_i| = r s = 0^b for i = 0 to w do s = s \\oplus (P_i||0^{b-r}) s = f(s) end for Z = \\lfloor s \\rfloor_r while |Z| &lt; \\ell do s = f(s) Z = Z||\\lfloor s \\rfloor_r end while return \\lfloor Z \\rfloor_\\ell</code></pre>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.2 Security</h3>

    <p class="text-gray-300"><span id="page-5-0"></span>Cryptographic functions are often designed in two steps. In the first step, one chooses a construction that uses a cryptographic primitive with fixed input and output size (e.g., a compression function or a permutation) and builds a function that can take inputs and or generate outputs of arbitrary size. If the security of this construction can be proven, for instance as in this case using the indifferentiability framework, it reduces the scope of cryptanalysis to that of the underlying primitive and guarantees the absence of single-stage generic attacks (e.g., preimage, second preimage and collision attacks) [35]. However, generic security in the multi-stage setting using the indifferentiability framework is currently an open problem [41].</p>

    <p class="text-gray-300">It is shown in [8] that the success probability of any single-stage generic attack for differentiating the sponge construction calling a random permutation or transformation from a random oracle is upper bounded by  <span class="math">2^{-(c+1)}N^2</span> . Here N is the number of calls to the underlying permutation or its inverse. This implies that any single-stage generic attack on a sponge function has success probability of at most  <span class="math">2^{-(c+1)}N^2</span>  plus the success probability of this attack on a random oracle.</p>

    <p class="text-gray-300">In [10], we address the security of the sponge construction when the message is prefixed with a key, as it will be done in the mode of Section 5. In this specific case, the security proof goes beyond the  <span class="math">2^{c/2}</span>  complexity if the number of input or output blocks for which the key is used (data complexity) is upper bounded by  <span class="math">M &lt; 2^{c/2-1}</span> . In that case, distinguishing the keyed sponge from a random oracle has time complexity of at least  <span class="math">2^{c-1}/M &gt; 2^{c/2}</span> . Hence, for keyed modes, one can reduce the capacity c for the same targeted security level.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.3 Implementing authenticated encryption</h4>

    <p class="text-gray-300">The simplest way to build an actual system that behaves as ROWRAP would be to replace the random oracles  <span class="math">\\mathcal{RO}_{\\mathbb{C}}</span>  and  <span class="math">\\mathcal{RO}_{\\mathbb{T}}</span>  by a sponge function with domain separation. The indifferentiability proof in [8] guarantees the result is secure if the permutation f of the sponge function has no structural distinguishers.</p>

    <p class="text-gray-300">However, such a solution requires two sponge function executions: one for the generation of the key stream and one for the generation of the tag, while we aim for a single-pass solution. To achieve this, we define a variant where the key stream blocks and tag are the responses of a sponge function to input sequences that are each other's prefix. This introduces a new construction that is closely related to the sponge construction: the duplex construction. Subsequently, we build an authenticated encryption mode on top of that.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4 The duplex construction</h3>

    <p class="text-gray-300">Like the sponge construction, the <em>duplex construction</em> DUPLEX[f, pad, r] uses a fixed-length transformation (or permutation) f, a padding rule "pad" and a parameter bitrate r. Unlike a sponge function that is stateless in between calls, the duplex construction accepts calls that take an input string and return an output string depending on all inputs received so far. We call an instance of the duplex construction a <em>duplex object</em>, which we denote D in our descriptions. We prefix the calls made to a specific duplex object D by its name D and a dot.</p>

    <p class="text-gray-300"><img src="_page_6_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 2. The duplex construction</p>

    <p class="text-gray-300"><span id="page-6-0"></span>The duplex construction works as follows. A duplex object D has a state of b bits. Upon initialization all the bits of the state are set to zero. From then on one can send to it D.duplexing( <span class="math">\\sigma</span> ,  <span class="math">\\ell</span> ) calls, with  <span class="math">\\sigma</span>  an input string and  <span class="math">\\ell</span>  the requested number of bits.</p>

    <pre><code class="language-text">Algorithm 2 The duplex construction DUPLEX[f, pad, r]</code></pre>

    <pre><code class="language-text">Require: r &lt; b
Require: \\rho_{\\max}(\\operatorname{pad}, r) &gt; 0
Require: \\rho_{\\max}(\\operatorname{pad}, r) &gt; 0
Require: s \\in \\mathbb{Z}_2^b (maintained across calls)

Interface: D.initialize()
s = 0^b

Interface: Z = D.duplexing(\\sigma, \\ell) with \\ell \\leq r, \\sigma \\in \\bigcup_{n=0}^{\\rho_{\\max}(\\operatorname{pad}, r)} \\mathbb{Z}_2^n, and Z \\in \\mathbb{Z}_2^\\ell
P = \\sigma||\\operatorname{pad}[r](|\\sigma|)
s = s \\oplus (P||0^{b-r})
s = f(s)
return |s|_{\\ell}</code></pre>

    <p class="text-gray-300">The maximum number of bits  <span class="math">\\ell</span>  one can request is r and the input string  <span class="math">\\sigma</span>  shall be short enough such that after padding it results in a single r-bit block. We call the maximum length of  <span class="math">\\sigma</span>  the <em>maximum duplex rate</em> and denote it by  <span class="math">\\rho_{\\max}(\\text{pad},r)</span> . Formally:</p>

    <p class="text-gray-300"><span id="page-6-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\rho_{\\max}(\\text{pad}, r) = \\min\\{x : x +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}<a href="x">r</a></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> r\\} - 1. \\tag{4}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Upon receipt of a D.duplexing( <span class="math">\\sigma</span> ,  <span class="math">\\ell</span> ) call, the duplex object pads the input string  <span class="math">\\sigma</span>  and XORs it into the first r bits of the state. Then it applies f to the state and returns the first</p>

    <p class="text-gray-300"><img src="_page_7_Picture_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 3. Generating the output of a duplexing call with a sponge</p>

    <p class="text-gray-300"> <span class="math">\\ell</span>  bits of the state at the output. We call a <em>blank call</em> a call with  <span class="math">\\sigma</span>  the empty string, and a <em>mute call</em> a call without output,  <span class="math">\\ell=0</span> . The duplex construction is illustrated in Figure 2, and Algorithm 2 provides a formal definition.</p>

    <p class="text-gray-300">The following lemma links the security of the duplex construction  <span class="math">\\mathtt{DUPLEX}[f,\\mathtt{pad},r]</span>  to that of the sponge construction  <span class="math">\\mathtt{SPONGE}[f,\\mathtt{pad},r]</span> . Generating the output of a D.duplexing() call using a sponge function is illustrated in Figure 3.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> [Duplexing-sponge lemma] <em>If we denote the input to the i-th call to a duplex object by</em>  <span class="math">(\\sigma_i, \\ell_i)</span>  <em>and the corresponding output by</em>  <span class="math">Z_i</span>  <em>we have:</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$Z_i = D.\\text{duplexing}(\\sigma_i, \\ell_i) = \\text{sponge}(\\sigma_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_i, \\ell_i)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-7-0"></span>with  <span class="math">pad_i</span>  a shortcut notation for  $pad[r](</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> The proof is by induction on the number of input strings  <span class="math">\\sigma_i</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First consider the case i=0. We must prove  <span class="math">D.\\mathrm{duplexing}(\\sigma_0,\\ell_0)=\\mathrm{sponge}(\\sigma_0,\\ell_0)</span> . The state of the duplex object before the call has value  <span class="math">0^b</span> , the same as the initial state of the sponge function. Both in the case of the sponge function and the duplex object the input string is padded with pad resulting in a single r-bit block P. Then, in both cases P is XORed to the first r bits of the state and f is applied to the state. At this point the sponge function and the duplex object have the same state and both return the first  <span class="math">\\ell \\leq r</span>  bits of the state as output string. Since the sponge function does not do any additional iterations of f on the state, the state of the duplex object after the call  <span class="math">D.\\mathrm{duplexing}(\\sigma_0,\\ell_0)</span>  is equal to the state of the sponge construction after absorbing a single block  $\\sigma_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now assume that after the call D.duplexing  <span class="math">(\\sigma_{i-1}, \\ell_{i-1})</span>  the duplex object has the same state as the sponge function after absorbing  $\\sigma_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_{i-1}<span class="math"> . During the call D.duplexing  </span>(\\sigma_i, \\ell_i)<span class="math"> , the block  </span>\\sigma_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_i<span class="math">  is XORed into the first r bits of the state and subsequently f is applied to the state. It follows that the state of the duplex object D after the call D.duplexing  </span>(\\sigma_i, \\ell_i)<span class="math">  is equal to the state of the sponge function after absorbing  </span>\\sigma_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots\\sigma_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_i<span class="math"> . As the output just consists of the first  </span>\\ell_i$  bits of the state, this proves Lemma 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The output of a duplexing call is thus the output of a sponge function with an input  $\\sigma_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pad}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and from this input the exact sequence  </span>\\sigma_0,\\sigma_1,\\dots,\\sigma_i$  can be recovered as shown in Lemma 4 below. As such, the duplex construction is as secure as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the sponge construction with the same parameters. In particular, it inherits its resistance against (single-stage) generic attacks. The reference point in this case is a random oracle whose input is the sequence of inputs to the duplexing calls since the initialization.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 4.</strong> Let pad and r be fixed. Then, the mapping from a sequence  <span class="math">(\\sigma_0, \\sigma_1, \\ldots, \\sigma_n)</span>  of binary strings with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\rho_{\\max}(\\text{pad}, r) \\, \\forall i<span class="math">  to the binary string  </span>s = \\sigma_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}_{n-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is injective.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-8-1"></span><em>Proof.</em> The length of  <span class="math">\\sigma_n</span>  can be determined as  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mod r<span class="math"> ; this allows recovering  </span>\\sigma_n<span class="math">  from s. Then, if n &gt; 0, pad&lt;sub&gt;n-1&lt;/sub&gt; can be removed and the process continues recursively with  </span>s' = \\sigma_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{pad}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{n-1}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following sections we will show that the duplex construction is a powerful tool for building modes of use.</p>

    <h2 id="sec-12" class="text-2xl font-bold">5 The authenticated encryption mode SpongeWrap</h2>

    <p class="text-gray-300">We propose an authenticated encryption mode SpongeWrap that realizes the authenticated encryption process defined in Section 2. Similarly to the duplex construction, we call an instance of the authenticated encryption mode a SpongeWrap object.</p>

    <p class="text-gray-300"><span id="page-8-0"></span>Upon initialization of a SpongeWrap object, it loads the key K. From then on one can send requests to it for wrapping and/or unwrapping data. The key stream blocks used for encryption and the tags depend on the key K and the data sent in all previous requests. The authenticated encryption of a sequence of header-body pairs, as described in Section 2.1, can be performed with a sequence of wrap or unwrap requests to a SpongeWrap object.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">5.1 Definition</h4>

    <p class="text-gray-300">A SpongeWrap object W internally uses a duplex object D with parameters f, pad and r. Upon initialization of a SpongeWrap object, it initializes D and forwards the (padded) key blocks K to D using mute D.duplexing() calls.</p>

    <p class="text-gray-300">When receiving a  <span class="math">W.\\text{wrap}(A, B, \\ell)</span>  request, it forwards the blocks of the (padded) header A and the (padded) body B to D. It generates the cryptogram C block by block  <span class="math">C_i = B_i \\oplus Z_i</span>  with  <span class="math">Z_i</span>  the response of D to the previous D.duplexing() call. The  <span class="math">\\ell</span> -bit tag T is the response of D to the last body block (possibly extended with the response to additional blank D.duplexing() calls in case  <span class="math">\\ell &gt; \\rho</span> ). Finally it returns the cryptogram C and the tag T.</p>

    <p class="text-gray-300">When receiving a W-unwrap(A, C, T) request, it forwards the blocks of the (padded) header A to D. It decrypts the data body B block by block  <span class="math">B_i = C_i \\oplus Z_i</span>  with  <span class="math">Z_i</span>  the response of D to the previous D-duplexing() call. The response of D to the last body block (possibly extended) is compared with the tag T received as input. If the tag is valid, it returns the data body B; otherwise, it returns an error. Note that in implementations one may impose additional constraints, such as SpongeWrap objects dedicated to either wrapping or unwrapping. Additionally, the SpongeWrap object should impose a minimum length t for the tag received before unwrapping and could break the entire session as soon as an incorrect tag is received.</p>

    <p class="text-gray-300">Before being forwarded to D, every key, header, data or cryptogram block is extended with a so-called <em>frame bit</em>. The rate  <span class="math">\\rho</span>  of the SpongeWrap mode determines the size of the blocks and hence the maximum number of bits processed per call to f. Its upper bound is  <span class="math">\\rho_{\\max}(\\text{pad},r)-1</span>  due to the inclusion of one frame bit per block. A formal definition of SpongeWrap is given in Algorithm 3.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6"><strong>Algorithm 3</strong> The authenticated encryption mode SpongeWrap[f, pad, r, <span class="math">\\rho</span> ].</h4>

    <pre><code class="language-text">Require: \\rho \\leq \\rho_{\\text{max}}(\\text{pad}, r) - 1
Require: D = \\text{DUPLEX}[f, \\text{pad}, r]
 1: Interface: W.initialize(K) with K \\in \\mathbb{Z}_2^*
 2: Let K = K_0 ||K_1|| \\dots ||K_u|| with |K_i| = \\rho for i &lt; u, |K_u| \\le \\rho and |K_u| &gt; 0 if u &gt; 0
 3: D.initialize()
 4: for i = 0 to u - 1 do
       D.\\text{duplexing}(K_i||1,0)
 6: end for
 7: D.\\text{duplexing}(K_u||0,0)
 8: Interface: (C, T) = W.\\text{wrap}(A, B, \\ell) with A, B \\in \\mathbb{Z}_2^*, \\ell \\ge 0, C \\in \\mathbb{Z}_2^{|B|} and T \\in \\mathbb{Z}_2^{\\ell}
9: Let A = A_0 ||A_1|| \\dots ||A_v|| with |A_i| = \\rho for i &lt; v, |A_v| \\le \\rho and |A_v| &gt; 0 if v &gt; 0
10: Let B = B_0 ||B_1|| \\dots ||B_w| with |B_i| = \\rho for i &lt; w, |B_w| \\le \\rho and |B_w| &gt; 0 if w &gt; 0
11: for i = 0 to v - 1 do
12: D.\\text{duplexing}(A_i||0,0)
13: end for
14: Z = D.duplexing(A_v||1, |B_0|)
15: C = B_0 \\oplus Z
16: for i = 0 to w - 1 do
17: Z = D.duplexing(B_i||1,|B_{i+1}|)
18: C = C||(B_{i+1} \\oplus Z)|
19: end for
20: Z = D.\\text{duplexing}(B_w||0,\\rho)
21: while |Z| &lt; \\ell do
22: Z = Z||D.\\text{duplexing}(0, \\rho)|
23: end while
24: T = |Z|_{\\ell}
25: return (C,T)
26: Interface: B = W.unwrap(A, C, T) with A, C, T \\in \\mathbb{Z}_2^*, B \\in \\mathbb{Z}_2^{|C|} \\cup \\{\\text{error}\\}
27: Let A = A_0 ||A_1|| \\dots ||A_v|| with |A_i| = \\rho for i &lt; v, |A_v| \\le \\rho and |A_v| &gt; 0 if v &gt; 0
28: Let C = C_0 ||C_1|| \\dots ||C_w| with |C_i| = \\rho for i &lt; w, |C_w| \\le \\rho and |C_w| &gt; 0 if w &gt; 0 29: Let T = T_0 ||T_1|| \\dots ||T_x|| with |T_i| = \\rho for i &lt; x, |C_x| \\le \\rho and |C_x| &gt; 0 if x &gt; 0
30: for i = 0 to v - 1 do
31: D.\\text{duplexing}(A_i||0,0)
32: end for
33: Z = D.\\text{duplexing}(A_v||1,|C_0|)
34: B_0 = C_0 \\oplus Z
35: for i = 0 to w - 1 do
       Z = D.duplexing(B_i||1, |C_{i+1}|)
36:
37:
       B_{i+1} = C_{i+1} \\oplus Z
38: end for
39: Z = D.\\text{duplexing}(B_w||0,\\rho)
40: while |Z| &lt; \\ell do
41: Z = Z||D.\\text{duplexing}(0, \\rho)|
42: end while
43: if T = |Z|_{\\ell} then
        return B_0||B_1||\\dots B_w
45: else
46.
        return Error
47: end if</code></pre>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">5.2 Security</h3>

    <p class="text-gray-300">In this section, we show the security of SpongeWrap against generic attacks. To do so, we proceed in two steps. First, we define a variant of ROwrap for which the key stream depends not only on A but also on previous blocks of B. Then, we quantify the increase in the adversary advantage when trading the random oracles  <span class="math">\\mathcal{RO}_{\\mathbb{C}}</span>  and  <span class="math">\\mathcal{RO}_{\\mathbb{T}}</span>  with a random sponge function and appropriate input mappings.</p>

    <p class="text-gray-300">For a fixed block length  <span class="math">\\rho</span> , let  <span class="math">\\operatorname{pre}_i(\\overline{A,B}) = (A^{(1)},B^{(1)},A^{(2)},\\ldots,B^{(n-1)},A^{(n)},\\lfloor B^{(n)}\\rfloor_{i\\rho})</span> , i.e., the last body  <span class="math">B^{(n)}</span>  is truncated to its first i blocks of  <span class="math">\\rho</span>  bits. We define  <span class="math">\\operatorname{ROwrap}[\\rho]</span>  identically to  <span class="math">\\operatorname{ROwrap}</span> , except that in the wrapping algorithm, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} C^{(n)} = & \\lfloor \\mathcal{RO}_{\\mathsf{C}}(K, \\mathsf{pre}_0(\\overline{A,B})) \\rfloor_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_0^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\oplus B_0^{(n)} \\\\ &</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lfloor \\mathcal{RO}_{\\mathsf{C}}(K, \\mathsf{pre}_1(\\overline{A,B})) \\rfloor_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_1^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\oplus B_1^{(n)} \\\\ & \\cdots \\\\ &</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lfloor \\mathcal{RO}_{\\mathsf{C}}(K, \\mathsf{pre}_w(\\overline{A,B})) \\rfloor_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_w^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\oplus B_w^{(n)} \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for  $B^{(n)} = B_0^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_1^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_w^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_i^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\rho<span class="math">  for i &lt; w,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_w^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\le \\rho<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_w^{(n)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> 0$  if w > 0. The unwrap algorithm U is defined accordingly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The scheme  <span class="math">ROwrap[\\rho]</span>  is as secure as ROwrap, as expressed in the following two lemmas. We omit the proofs, as they are very similar to those of Lemma 1 and 2.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Let  <span class="math">\\mathcal{A}[\\mathcal{RO}_C, \\mathcal{RO}_T]</span>  be an adversary having access to  <span class="math">\\mathcal{RO}_C</span>  and  <span class="math">\\mathcal{RO}_T</span>  and respecting the nonce requirement. Then,  <span class="math">Adv^{priv}_{\\mathcal{RO}_{WRAP}[\\rho]}(\\mathcal{A}) \\leq q2^{-k}</span>  if the adversary makes no more than q queries to  <span class="math">\\mathcal{RO}_C</span>  or  <span class="math">\\mathcal{RO}_T</span> .</p>

    <p class="text-gray-300"><span id="page-10-1"></span><strong>Lemma 6.</strong> Let  <span class="math">\\mathcal{A}[\\mathcal{RO}_C, \\mathcal{RO}_T]</span>  be an adversary having access to  <span class="math">\\mathcal{RO}_C</span>  and  <span class="math">\\mathcal{RO}_T</span> . Then, ROWRAP satisfies  <span class="math">\\operatorname{Adv}^{\\operatorname{auth}}_{RO_{WRAP}[\\rho]}(\\mathcal{A}) \\leq q2^{-k} + 2^{-t}</span>  if the adversary makes no more than q queries to  <span class="math">\\mathcal{RO}_C</span>  or  <span class="math">\\mathcal{RO}_T</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-10-2"></span>Clearly, ROWRAP and ROWRAP[ <span class="math">\\rho</span> ] are equally secure if we implement  <span class="math">\\mathcal{RO}_{C}</span>  and  <span class="math">\\mathcal{RO}_{T}</span>  using a single random oracle with domain separation:  $\\mathcal{RO}_{C}(x) = \\mathcal{RO}(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1)<span class="math">  and  </span>\\mathcal{RO}_{T}(x) = \\mathcal{RO}(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0)<span class="math"> . Notice that SpongeWrap uses the same domain separation technique: the last bit of the input of the last duplexing call is always a 1 (resp. 0) to produce key stream bits (resp. to produce the tag). With this change, SpongeWrap now works like ROWRAP[ </span>\\rho<span class="math"> ], except that the input is formatted differently and that a sponge function replaces  </span>\\mathcal{RO}$ . The next lemma focuses on the former aspect.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let  <span class="math">(K, \\overline{A}, \\overline{B})</span>  be a sequence of strings composed by a key followed by header-body pairs. Then, the mapping from  <span class="math">(K, \\overline{A}, \\overline{B})</span>  to the corresponding sequence of inputs  <span class="math">(\\sigma_0, \\sigma_1, \\ldots, \\sigma_n)</span>  to the duplexing calls in Algorithm 3 is injective.</p>

    <p class="text-gray-300"><span id="page-10-0"></span><em>Proof.</em> We show that from  <span class="math">(\\sigma_0, \\sigma_1, \\dots, \\sigma_n)</span>  we can always recover  <span class="math">(K, \\overline{A}, \\overline{B})</span> . The convention is that, when cutting input strings into blocks of  <span class="math">\\rho</span>  bits, there is always at least one block (see, e.g., line 2 of Algorithm 3). Consequently, any (possibly empty) input string causes at least one duplexing call (e.g., see lines 7, 14 and 20) or equivalently at least one element  <span class="math">\\sigma_i</span> .</p>

    <p class="text-gray-300">The key K can be found by looking for the first block  <span class="math">\\sigma_i</span>  that ends with frame bit 0; the key K is concatenation of the blocks  <span class="math">\\sigma_j</span> ,  <span class="math">j \\leq i</span> , with their last bit removed. Then we look for the first block  <span class="math">\\sigma_{i&#x27;}</span> , i' > i, that ends with a frame bit 1; blocks from  <span class="math">\\sigma_{i+1}</span>  to  <span class="math">\\sigma_{i&#x27;}</span>  are concatenated with their last bit removed to give the first header  <span class="math">A^{(1)}</span> . To find the first body  <span class="math">B^{(1)}</span> , we follow the same procedure, except that we look for the first block  <span class="math">\\sigma_{i&#x27;&#x27;}</span> , i'' > i', that</p>

    <p class="text-gray-300">ends with a bit 0. This operation is repeated to find the next header <em>A</em> (2) and the next body <em>B</em> (2) . And so on.</p>

    <p class="text-gray-300">Note that the blocks <em>σ</em> produced by line 22 of Algorithm 3 do not contribute to neither a header nor a body as they contain only one bit, which is removed in the above procedure.</p>

    <p class="text-gray-300"><em>⊓⊔</em></p>

    <p class="text-gray-300">We now have all the ingredients to pro<a href="#page-9-5">ve</a> the followin<a href="#page-9-0">g t</a>heorem.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> <em>The authenticated encryption mode SѝќћєђWџюѝ</em>[ <em>f</em> , pad,<em>r</em>, <em>ρ</em>] <em>defined in Algorithm 3 satisfies</em></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;Adv_{\\textit{SpongeWrap}[f,pad,r,\\rho]}^{priv}(\\mathcal{A}) &lt; q2^{-k} + \\frac{N(N+1)}{2^{c+1}} \\textit{ and} \\\\ &amp;Adv_{\\textit{SpongeWrap}[f,pad,r,\\rho]}^{auth}(\\mathcal{A}) &lt; q2^{-k} + 2^{-t} + \\frac{N(N+1)}{2^{c+1}}, \\end{split}</span></div>

    <p class="text-gray-300"><em>against any single adversary A if K</em> \\$<em>←−</em> <strong>Z</strong><em><sup>k</sup></em> 2 <em>, tags of ℓ ≥ t bits are used, f is a randomly chosen permutation, q is the number of queries and N is the number of times f is called.</em></p>

    <p class="text-gray-300"><em>Proof.</em> The scheme SѝќћєђWџюѝ[ <em>f</em> , pad,<em>r</em>, <em>ρ</em>] uses a ёѢѝљђѥ[ <em>f</em> , pad,<em>r</em>] object. Combining Lemmas 3, 4 and 7, we see that SѝќћєђWџюѝ[ <em>f</em> , pad,<em>r</em>, <em>ρ</em>] works like ROѤџюѝ[<em>ρ</em>] with a random oracle replaced by the sponge function Ѡѝќћєђ[ <em>f</em> , pad,<em>r</em>] and an injective input function from (<strong>Z</strong><em><sup>∗</sup></em> 2 ) <sup>+</sup> to <strong>Z</strong><em><sup>∗</sup></em> 2 . Compared to the expressions in Lemmas 5 and 6, the extra term in the advantages above accounts for the adversary being able to differentiate a random spo<a href="#page-7-0">ng</a><a href="#page-8-1">e</a> from <a href="#page-10-0">a</a> random oracle. This follows from [35], formalized in [1, Theorem 2], and from the value of the RO-differentiating advantage of a random s<a href="#page-10-1">po</a>nge <a href="#page-10-2">\\[8</a>]. <em>⊓⊔</em></p>

    <p class="text-gray-300">Note that all the outputs of SѝќћєђWџюѝ are equivalent to calls to a sponge function with the secret key blocks as a prefix. So the res<a href="#page-19-18">ults</a> of [10] can als<a href="#page-18-15">o b</a>e applied to SѝќћєђWџюѝ as explained in Section 3.2.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6"><strong>5.3 Advantages and limitations</strong></h4>

    <p class="text-gray-300">The authenticated encryption mode <a href="#page-5-0">Sѝќ</a>ћєђWџюѝ has the following unique combination of advantages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>–</strong> While most other authenticated encryption modes are described in terms of a block cipher, SѝќћєђWџюѝ only requires on a fixed-length permutation.</li>

      <li><strong>–</strong> It supports the alternation of strings that require authenticated encryption and strings that only require authentication.</li>

      <li><strong>–</strong> It can provide intermediate tags aĞer each <em>W</em>.wrap(<em>A</em>, <em>B</em>, <em>ℓ</em>) request.</li>

      <li><strong>–</strong> It has a strong security bound against generic aĴacks with a very simple proof.</li>

      <li><strong>–</strong> It is single-pass and requires only a single call to the permutation <em>f</em> per <em>ρ</em>-bit block.</li>

      <li><strong>–</strong> It is flexible as the bitrate can be freely chosen as long as the capacity is larger than some lower bound.</li>

      <li><strong>–</strong> The encryption is not expanding.</li>

    </ul>

    <p class="text-gray-300">As compared to some block cipher based authenticated encryption modes, it has some limitations. First, the mode as such is serial and cannot be parallelized at algorithmic level. Some block cipher based modes do actually allow parallelization, for instance, the offset codebook (OCB) mode [44]. Yet, SѝќћєђWџюѝ variants could be defined to support parallel streams in a fashion similar to tree hashing, but with some overhead.</p>

    <p class="text-gray-300">Second, if a system does not impose the nonce requirement on <em>A</em>, an aĴacker may send two requests (<em>A</em>, <em>B</em>) <a href="#page-19-20">a</a>nd (<em>A</em>, <em>B ′</em> ) with <em>B ̸</em>= <em>B ′</em> . In this case, the first differing blocks of B and B', say  <span class="math">B_i</span>  and  <span class="math">B&#x27;_i</span> , will be enciphered with the same key stream, making their bitwise XOR available to the attacker. Some block cipher based modes are <em>misuse resistant</em>, i.e., they are designed in such a way that in case the nonce requirement is not fulfilled, the only information an attacker can find out is whether B and B' are equal or not [46]. Yet, many applications already provide a nonce, such as a packet number or a key ID, and can put it in A.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.4 An application: key wrapping</h3>

    <p class="text-gray-300">Key wrapping is the process of ensuring the secrecy and integrity of cryptographic keys in transport or storage, e.g., [37,18]. A <em>payload key</em> is wrapped with a <em>key-encrypting key</em> (KEK). We can use the SpongeWrap mode with <em>K</em> equal to the KEK and let the data body be the payload key value. In a sound key management system every key has a unique identifier. It is sufficient to include the identifier of the payload key in the header <em>A</em> and two different payload keys will never be enciphered with the same key stream. When wrapping a private key, the corresponding public key or a digest computed from it can serve as identifier.</p>

    <h2 id="sec-18" class="text-2xl font-bold">6 Other applications of the duplex construction</h2>

    <p class="text-gray-300"><span id="page-12-0"></span>Authenticated encryption is just one application of the duplex construction. In this section we illustrate it by providing two more examples: a pseudo-random bit sequence generator and a sponge-like construction that overwrites part of the state with the input block rather than to XOR it in.</p>

    <h2 id="sec-19" class="text-2xl font-bold">6.1 A reseedable pseudo-random bit sequence generator</h2>

    <p class="text-gray-300">In various cryptographic applications and protocols, random bits are used to generate keys or unpredictable challenges. While randomness can be extracted from a physical source, it is often necessary to provide many more bits than the entropy of the physical source. A pseudo-random bit sequence generator (PRG) is initialized with a seed, generated in a secret or truly random way, and it then expands the seed into a sequence of bits. For cryptographic purposes, it is required that the generated bits cannot be predicted, even if subsets of the sequence are revealed. In this context, a PRG is similar to a stream cipher. A PRG is also similar to a cryptographic hash function when gathering entropy coming from different sources. Finally, some applications require a pseudo-random bit sequence generator to support forward security: The compromise of the current state does not enable the attacker to determine the previously generated pseudo-random bits [6,17].</p>

    <p class="text-gray-300">Conveniently, a pseudo-random bit sequence generator can be reseedable, i.e., one can bring an additional source of entropy after pseudo-random bits have been generated. Instead of throwing away the current state of the PRG, reseeding combines the current state of the generator with the new seed material. In [9] a reseedable PRG was defined based on the sponge construction that implements the required functionality. The ideas behind that PRG are very similar to the duplex construction. We however show that such a PRG can be defined on top of the duplex construction.</p>

    <p class="text-gray-300">A duplex object can readily be used as a reseedable PRG. Seed material can be fed via the  <span class="math">\\sigma</span>  inputs in D.duplexing() call and the responses can be used as pseudo-random bits. If pseudo-random bits are required and there is no seed available, one can simply send blank D.duplexing() calls. The only limitation of this is that the user must split his seed material in strings of at most  <span class="math">\\rho_{\\max}</span>  bits and that at most r bits can be requested in a single call.</p>

    <p class="text-gray-300">As a next step, we propose a reseedable pseudo-random bit sequence generator mode called SѝќћєђPRG. This mode is similar to the one proposed in [9] in that it minimizes the number of calls to <em>f</em> , although explicitly based on the duplex construction. Internally it makes use of a duplex object <em>D</em> and it has two buffers: an input buffer <em>B</em>in and an output buffer <em>B</em>out. During feed requests it accumulates seed material in <em>B</em>in and, if it has received at least <em>ρ</em> bits, it forwards them to <em>D</em> in a <em>D</em>.duplexing() call. <a href="#page-18-19">An</a>y surplus seed string is kept in the input buffer. Upon a fetch request, if the input buffer is not empty, it empties it by forwarding any remaining seed to <em>D</em> and returns the requested number of bits, performing more duplexing calls if necessary, each requesting <em>ρ</em> bits. The surplus of produced bits are kept in <em>B</em>out, which will be returned first upon the next fetch request. Note that at any moment, one of <em>B</em>in and <em>B</em>out is empty.</p>

    <p class="text-gray-300">As such, the operation of a SѝќћєђPRG object is based on a permutation and revealing the state allows the aĴacker to backtrack the generation back to the most recent unknown seed fed into it. Nevertheless, reseeding regularly with sufficient entropy already prevents the aĴacker from going backwards. Also, an embedded security device such as a smartcard in which such a PRG would be used is designed to protect the secrecy of keys and therefore reading out the state is expected to be difficult.</p>

    <p class="text-gray-300">Still, forward security can be explicitly enforced by means of a <em>P</em>.forget() request. The effect of this request is the reseĴing to zero of the first <em>ρ</em> bits of the state, an application of the padding and a subsequent application of <em>f</em> . Under the condition that <em>ρ ≥ c</em>, guessing the state before this operation given the state aĞerwards requires guessing at least <em>c</em> bits and hence is infeasible for reasonable values of <em>c</em>. On a PC, which might be more vulnerable to a memory recovery aĴack, this condition that <em>ρ ≥ c</em> can easily be satisfied by a suitable sponge function; e.g., this is the case for Kђѐѐюј[] with its default parameters.</p>

    <p class="text-gray-300">The SѝќћєђPRG mode is defined in Algorithm 4. Note that the buffers do not require separate storage but can be implemented merely as pointers to the state: The input buffer requires a pointer to the state indicating from where on new bits must be XORed into the state, while the output buffer pointer points in the state where the next output bit must be taken. The storage is thus limited to the <em>b</em>-bit st<a href="#page-14-0">ate</a> and two integers.</p>

    <p class="text-gray-300">It is clear that every bit returned by <em>P</em>.fetch() is part of the output of the sponge presented with a string that contains all seed material presented so far. The SѝќћєђPRG mode does not allow reconstructing the individual blocks <em>σ<sup>i</sup></em> but does allow reconstructing their concatenation.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8"><strong>6.2 The mode OѣђџѤџіѡђ</strong></h3>

    <p class="text-gray-300">In [22] sponge-like constructions were proposed and cryptanalyzed. In some of these constructions, absorbing is done by overwriting part of the state by the message block rather than XORing it in, e.g., as in the hash function Grindahl [29]. These overwrite functions have the advantage over sponge functions that between calls to <em>f</em> , only <em>c</em> bits must be ke<a href="#page-18-20">pt i</a>nstead of <em>b</em>. This may not be useful when hashing in a continuous fashion, as <em>b</em> bits must be processed by <em>f</em> anyway. However, when hashing a partial message, then puĴing it aside to continue later on, storing only <em>c</em> bits may be us<a href="#page-19-22">eful</a> on some platforms.</p>

    <p class="text-gray-300">The mode OѣђџѤџіѡђ differs from the sponge construction in that it overwrites part of the state with an input block instead of XORing it in. Such a mode can be analyzed by building it on top of the duplex construction. If the first <em>ρ</em> bits of the state are known to be <em>Z</em>, overwriting them with a message block <em>P<sup>i</sup></em> is equivalent to XORing in <em>Z ⊕ P<sup>i</sup></em> . Note that this idea is also used in the forget call of the SѝќћєђPRG mode and is formally implemented in Algorithm 5. In practice, of course, the implementation can just overwrite the first <em>ρ</em> bits of the state by a message block. As a maĴer of fact, Algorithm 5 can be rewriĴen to call <em>f</em> directly, similar to the sponge construction. We leave this as an exercise for the reader.</p>

    <p class="text-gray-300"><strong>Algorithm 4</strong> Pseudo-random bit sequence generator mode SpongePRG[f, pad, r,  <span class="math">\\rho</span> ]</p>

    <pre><code class="language-text">Require: \\rho \\leq \\rho_{\\text{max}}(\\text{pad}, r)
Require: D = \\text{DUPLEX}[f, \\text{pad}, r]
   Interface: P.initialize()
   D.initialize()
   B_{\\rm in} = {\\rm empty \\ string}
   B_{\\text{out}} = \\text{empty string}
   Interface: P.\\text{feed}(\\sigma) with \\sigma \\in \\mathbb{Z}_2^*
   M = B_{\\rm in} || \\sigma
   Let M = M_0 ||M_1|| \\dots ||M_w| with |M_i| = \\rho for i &lt; w and 0 \\le |M_w| &lt; \\rho
   for i = 0 to w - 1 do
       D.duplexing(M_i, 0)
   end for
   B_{\\rm in} = M_w
   B_{\\text{out}} = \\text{empty string}
   Interface: Z = P.\\text{fetch}(\\ell) with integer \\ell \\geq 0 and Z \\in \\mathbb{Z}_2^{\\ell}
   while |B_{\\text{out}}| &lt; \\ell do
       B_{\\text{out}} = B_{\\text{out}} || D.\\text{duplexing}(B_{\\text{in}}, \\rho)
       B_{\\rm in} = {\\rm empty \\ string}
   end while
   Z = |B_{\\text{out}}|_{\\ell}
   B_{\\text{out}} = \\text{last} (|B_{\\text{out}}| - \\ell) \\text{ bits of } B_{\\text{out}}
   return Z
   Interface: Z = P.\\text{forget}() requiring \\rho \\geq c
   Z = D.duplexing(B_{in}, \\rho)
   B_{\\rm in} = {\\rm empty\\ string}
   D.duplexing(Z, \\rho)
   B_{\\text{out}} = \\text{empty string}</code></pre>

    <p class="text-gray-300">We define the mode Overwrite on top of the duplex construction. An Overwrite function internally uses a duplex object D. It pads the message M and splits it in  <span class="math">\\rho</span> -bit blocks. Then it makes a sequence of D.duplexing() calls, each time with a message block XORed with the response of the previous D.duplexing() call and with a frame bit appended to it. This frame bit is equal to 1 for the last block and 0 for all other blocks. If the requested number of output bits  <span class="math">\\ell</span>  is larger than  <span class="math">\\rho</span> , additional D.duplexing() calls are done where each time the response of the previous D.duplexing() call is fed back to D.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> The construction Overwrite  <span class="math">[f, pad, r, \\rho]</span>  is as secure as sponge[f, pad, r].</p>

    <p class="text-gray-300"><em>Proof.</em> The construction Overwrite  <span class="math">[f, pad, r, \\rho]</span>  is defined in terms of calls to DUPLEX[f, pad, r]. From the sponge-duplexing lemma, the output of such a call is the output to SPONGE[f, pad, r] for a specific input. Hence, the theorem comes down to showing that the input M to Overwrite can be recovered from the inputs to the duplexing calls.</p>

    <p class="text-gray-300">The coding using the frame bits in Algorithm 5 allows, for any input sequence of D, finding the last block  <span class="math">(P_w \\oplus Z)</span>  and the length of the original input M. To recover the message M from the input sequence, one can start with the first block. Since  <span class="math">Z = 0^{\\rho}</span>  in the first block, the first block in the D.duplexing() call allows recovering the first block of M. Then, this block allows determining the output Z that was XORed into the next block, and so on.</p>

    <p class="text-gray-300">We have thus proven that the security of Overwrite is equivalent to that of the sponge construction with the same parameter, but at a cost of 2 bits of bitrate (or equivalently, of capacity): one for the padding rule (assuming pad10\\* is used) and one for the frame bit.</p>

    <h2 id="sec-21" class="text-2xl font-bold"><strong>Algorithm 5</strong> The construction OѣђџѤџіѡђ[ <em>f</em> , pad,<em>r</em>, <em>ρ</em>]</h2>

    <pre><code class="language-text">Require: ρ ≤ ρmax(pad,r) − 1
Require: D = ёѢѝљђѥ[ f , pad,r]
  Interface: Z = OѣђџѤџіѡђ(M, ℓ) with M ∈ Z∗
                                                2
                                                 , integer ℓ &gt; 0 and Z ∈ Zℓ
                                                                           2
  P = M||pad[ρ](|M|)
  Let P = P0||P1
                 || . . . ||Pw with |Pi
                                  | = ρ for i ≤ w
  D.initialize()
  Z = 0
        ρ
  for i = 0 to w − 1 do
    Z = D.duplexing((Pi ⊕ Z)||0, ρ)
  end for
  Z = D.duplexing((Pw ⊕ Z)||1, ρ)
  Bout = Z
  while |Bout| &lt; ℓ do
    Z = D.duplexing(Z||1, ρ)
    Bout = Bout||Z
  end while
  return ⌊Bout⌋ℓ</code></pre>

    <h2 id="sec-22" class="text-2xl font-bold"><strong>7 A flexible and compact padding rule</strong></h2>

    <p class="text-gray-300"><span id="page-15-0"></span>Sponge functions and duplex objects feature the nice property of allowing a range of security-performance trade-offs, via capacity-rate pairs, using the same fixed permutation <em>f</em> . To be able to fully exploit this property in the scope of the duplex construction, and for performance reasons, the padding rule should be compact and should be suitable for a family of sponge functions with different rates. In this section, we introduce the multi-rate padding and prove that it is suitable for such a family.</p>

    <p class="text-gray-300">For a given capacity and width, the padding reduces the maximum bitrate of the duplex construction, as in Eq. (4). To minimize this effect, especially when the width of the permutation is relatively small, one should look for the most compact padding rule. The sponge-compliant padding scheme (see Section 3) with the smallest overhead is the wellknown <em>simple reversible padding</em>, which appends a single 1 and the smallest number of zeroes such that the length <a href="#page-6-2">o</a>f the result is a multiple of the required block length. We denote it by pad10<em><sup>∗</sup></em> <a href="<em>M</em>"><em>r</em></a>. It satisfies <em>ρ</em>max(pad<a href="#page-3-0">10</a><em><sup>∗</sup></em> ,<em>r</em>) = <em>r −</em> 1 and hence has only one bit of overhead.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When considering the security of a set of sponge functions that make use of the same permutation <em>f</em> but with different bitrates, simple reversible padding is not sufficient. The indifferentiability proof of [8] actually only covers the indifferentiability of a single sponge function instance from a random oracle. As a solution, we propose the <em>multirate padding</em>, denoted pad10<em>∗</em>1[<em>r</em>](*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>), which returns a bitstring 10</em>q<em>1 with </em>q<em> = (</em>−</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">−<em> 2) mod </em>r<em>. This padding is sponge-compliant and has </em>ρ<em>max(pad10</em>∗<em>1,</em>r<em>) = </em>r −<em>2. Hence, this padding scheme is compact as t<a href="#page-18-14">he</a> duplex-level maximum rate differs from the spongelevel rate by only two bits. Furthermore, in Theorem 3 we will show it is sufficient for the indifferentiability of a set of sponge functions. The intuitive idea behind this is that, with the pad10</em>∗<em>1 padding scheme, the last block absorbed has a bit with value 1 at position </em>r −<em> 1, while any other function of the family with </em>r ′ < r* this bit has value 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Besides having a compact padding rule, it is also <a href="#page-16-0">use</a>ful to allow the sponge function to have specific bitrate values. In many applications one prefers to have block lengths that are a multiple of 8 or even higher powers of two to avoid bit shiĞing or misalignment issues. With modes using the duplex construction, one has to distinguish between the modelevel block size and the bitrate of the underlying sponge function. For instance in the authenticated encryption mode SѝќћєђWџюѝ, the block size is at most <em>ρ</em>max(pad,<em>r</em>) <em>−</em> 1. To have a block size with the desired value, it suffices to take a slightly higher value as bitrate r; hence, the sponge-level bitrate may no longer be a multiple of 8 or of a higher power of two. Therefore it is meaningful to consider the security of a set of sponge functions with common f and different bitrates, including bitrates that are not multiples of 8 or of a higher power of two. For instance, the mode SpongeWrap could be based on Keccak[r=1027, c=573] so as to process application-level blocks of  <span class="math">\\rho_{\\rm max}({\\rm pad}10^*1, 1027)-1=1024</span>  bits [11].</p>

    <p class="text-gray-300">Regarding the indifferentiability of a set of sponge functions, it is clear that the best one can achieve is bounded by the strength of the sponge construction with the lowest capacity (or, equivalently, the highest bitrate), as an adversary can always just try to differentiate the weakest construction from a random oracle. The next theorem states that we achieve this bound by using the multi-rate padding.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> Given a random permutation (or transformation) f, differentiating the array of sponge functions  <span class="math">sponge[f, pad10^<em>1, r]</span>  with  <span class="math">0 &lt; r \\le r_{max}</span>  from an array of independent random oracles  <span class="math">(\\mathcal{RO}_r)</span>  has the same advantage as differentiating  <span class="math">sponge[f, pad10^</em>, r_{max}]</span>  from a random oracle.</p>

    <p class="text-gray-300"><span id="page-16-0"></span><em>Proof.</em> We can implement the array of sponge functions sponge[f, pad10\\<em>1, r] using a single sponge function  <span class="math">sponge_{max} = sponge[f, pad10</em>, r_{max}]</span> , a bitrate-dependent input preprocessing function  <span class="math">I[r, r_{max}]</span>  and a bitrate-dependent output post-processing function  <span class="math">O[r, r_{max}]</span> . So we have:</p>

    <p class="text-gray-300"><span id="page-16-1"></span> <span class="math-block">SPONGE[f,pad10^<em>1,r] = O[r,r_{max}] \\circ SPONGE[f,pad10^</em>,r_{max}] \\circ I[r,r_{max}]. \\tag{5}</span></p>

    <p class="text-gray-300">The input pre-processing function  <span class="math">M&#x27; = I<a href="M">r, r_{\\text{max}}</a></span>  consists of the following steps:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1. Construct Q by padding M with multi-rate padding: Q = M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pad10\\*1[r](</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. Construct Q' by splitting Q in r-bit blocks, extending each block with  <span class="math">0^{r_{\\text{max}}-r}</span>  and concatenating the blocks again.</li>

      <li>3. Construct M' by unpadding Q' according to the padding rule pad10\\*.</li>

    </ul>

    <p class="text-gray-300">Note that the third step removes the trailing  <span class="math">r_{\\rm max}-r</span>  bits with value 0 and the bit with value 1 just before that. It follows that the length of M' modulo  <span class="math">r_{\\rm max}</span>  is r-1, hence this pre-processing implements domain separation between the different r values for a given value of  <span class="math">r_{\\rm max}</span> . Moreover, it is straightforward to extract M from  <span class="math">I<a href="M">r, r_{\\rm max}</a></span>  and hence the pre-processing function is injective:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall (M_1, r_1) \\neq (M_2, r_2) \\Rightarrow I[r_1, r_{\\max}](M_1) \\neq I[r_2, r_{\\max}](M_2).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The output post-processing function  <span class="math">Z = O<a href="Z&#x27;">r, r_{\\text{max}}</a></span>  consists of splitting Z' in  <span class="math">r_{\\text{max}}</span>  bit blocks  <span class="math">Z&#x27;_i</span> , truncating each block to its first r bits  <span class="math">Z_i = \\lfloor Z&#x27;_i \\rfloor_r</span>  and concatenating the blocks again:  $Z = Z_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is easy to verify that with these pre- and post-processing functions Eq. (5) holds.</p>

    <p class="text-gray-300">Any attack that can differentiate the set of sponge functions  <span class="math">\\mathsf{sponge}[f,\\mathsf{pad}10^*1,r]</span>  from a set of random oracles with an advantage  <span class="math">\\epsilon</span>  can be converted into an attack on  <span class="math">\\mathsf{sponge}_{\\mathsf{max}}</span>  with the same advantage. Namely, the response  <span class="math">Z^{(i)}</span>  to a query  <span class="math">M^{(i)}</span>  to  <span class="math">\\mathsf{sponge}[f,\\mathsf{pad}_1,r]</span>  can be obtained from  <span class="math">\\mathsf{sponge}_{\\mathsf{max}}</span>  by querying it with  <span class="math">I<a href="M^{(i">r,r_{\\mathsf{max}}</a>})</span>  and  <span class="math">\\mathsf{applying}\\,O[r,r_{\\mathsf{max}}]</span>  to its response  <span class="math">Z^{(i)}</span> .</p>

    <p class="text-gray-300">Hence, differentiating the array  <span class="math">sponge[f,pad10^*1,r]</span>  from the array  <span class="math">(\\mathcal{RO}_r)</span>  comes down to differentiating  <span class="math">sponge_{max}</span>  from  <span class="math">\\mathcal{RO}</span> , where  <span class="math">sponge_{max}</span>  has capacity  <span class="math">c_{min} = b - r_{max}</span> .</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8"><strong>8 Duplexing iterated functions in general</strong></h3>

    <p class="text-gray-300">The duplex construction can be seen as a way to use a sponge function in a cascaded way. The central idea is that a duplex object keeps a state equal to that of a sponge function that has absorbed the combination of all inputs to the duplex object so far. Clearly, the same principle can be applied to most other sequential hash function constructions that consist of the iterated application of a compression function or permutation <em>f</em> .</p>

    <p class="text-gray-300">In general, a duplex-like object corresponding to such a hash function would work as follows. Its state is the chaining value resulting from hashing all previous inputs and possibly a counter (e.g., if the hash function requires the message length for the padding or as input in the compression function). Upon presentation of an input <em>σ</em>, it performs two tasks. First, it generates an output: It pads <em>σ</em> with the padding rule of the hash function, applies the final compression function <em>f</em> or an output transformation <em>g</em>, and returns the result. Second, it updates its state by padding <em>σ</em> with reversible padding, applying <em>f</em> and updating the counter.</p>

    <p class="text-gray-300">The disadvantage of this method is that, in general, a single duplexing call to the object requires two calls to <em>f</em> , or in case of an output transformation <em>g</em>, one call to <em>f</em> and one to <em>g</em>. In contrast, for a sponge function, the generation of the output and the update of the state can be done in a single call to <em>f</em> .</p>

    <p class="text-gray-300">Three main obstacles may hinder the efficiency of duplexing.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>–</strong> First, as already mentioned, the special processing done aĞer the last block prevents to update the state and produce output at the same time. For instance, some constructions have an output transformation, which must be applied before producing output, while the main compression function is applied to update the state. The same problem occurs in the HAIFA framework [12], which enforces domain separation between the final call to <em>f</em> and the previous ones. In some constructions, blank iterations are applied at the end, which must be performed every time output is requested.</li>

      <li><strong>–</strong> Second, the overhead due to the padding reduces the number of bits that can be input in a duplexing call. If the input block <a href="#page-18-21">siz</a>e is fixed to a power of two (or a small multiple of it), the place taken by the padding can break the alignment of input blocks. Flexibility on the input block size is thus an advantage in this respect, as it can restore their alignment.</li>

      <li><strong>–</strong> Third, the output length of the hash function may be smaller than the input block size. This can be another slowdown factor, as in the case of the SѝќћєђWџюѝ mode, since as many output bits are needed as input bits. The last compression function, output transformation or blank iterations have then to be performed several times to produce output bits like in a mask generating function. Another possible solution is just to use shorter input blocks.</li>

    </ul>

    <p class="text-gray-300">The chop-MD construction [16,15] is a good candidate for duplexing. Producing output and updating the state can be made in the same operation. However, for the duplexing to be as fast as hashing, the output length should be as large as the message block and the padding should be as compact <a href="#page-18-22">as</a> <a href="#page-18-23">pos</a>sible.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6"><strong>9 Conclusions</strong></h4>

    <p class="text-gray-300">We have defined a new construction, namely the duplex construction, and showed that its security is equivalent to that of a sponge function with the same parameters. This construction was then used to give an efficient (single-pass) authenticated encryption mode. We proposed a reseedable pseudo-random bit sequence generator as another application of the duplex construction and to use it to prove the security of a mode overwriting input blocks instead of XORing them in. We have showed that the duplex construction inherits the flexibility of the sponge construction in terms of security-speed trade-offs. Finally, we have argued that duplexing with other hash function constructions is in most cases not as efficient as with the sponge construction.</p>

    <h2 id="sec-25" class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. E. Andreeva, B. Mennink, and B. Preneel, <em>Security reductions of the second round SHA-3 candidates</em>, Cryptology ePrint Archive, Report 2010/381, 2010, http://eprint.iacr.org/.</li>

      <li>2. J.-P. Aumasson, L. Henzen, W. Meier, and M. Naya-Plasencia, <em>Quark: A lightweight hash</em>, in Mangard and Standaert [33], pp. 1–15.</li>

      <li><span id="page-18-15"></span>3. M. Bellare and C. Namprempre, <em>Authenticated encryption: Relations among notions and analysis of the generic composition paradigm</em>, Asiacrypt (T. Ok<a href="http://eprint.iacr.org/">amoto, ed.\\), Lecture Notes in</a> Computer Science, vol. 1976, Springer, 2000, pp. 531–545.</li>

      <li><span id="page-18-9"></span>4. M. Bellare and P. Rogaway, <em>Random oracles are practical: A paradigm for designing efficient protocols</em>, ACM Conferenc<a href="#page-19-23">e on</a> Computer and Communications Security 1993 (ACM, ed.), 1993, pp. 62–73.</li>

      <li><span id="page-18-2"></span>5. M. Bellare, P. Rogaway, and D. Wagner, <em>The EAX mode of operation</em>, in Roy and Meier [47], pp. 389–407.</li>

      <li>6. M. Bellare and B. Yee, <em>Forward-security in private-key cryptography</em>, Cryptology ePrint Archive, Report 2001/035, 2001, http://eprint.iacr.org/.</li>

      <li><span id="page-18-13"></span><span id="page-18-4"></span>7. G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche, <em>Sponge functions</em>, Ecrypt Hash Workshop 2007, May 2007, also available as public comment to NIST from http://www.csrc.nist.gov/p<a href="#page-19-24">ki/</a>HashWorkshop/ Public\\_Comments/2007\\_May.html.</li>

      <li><span id="page-18-17"></span><span id="page-18-1"></span>8. , <em>On the <a href="http://eprint.iacr.org/">indifferentiability of the sponge</a> construction</em>, Advances in Cryptology – Eurocrypt 2008 (N. P. Smart, ed.), Lecture Notes in Computer Science, vol. 4965, Springer, 2008, http://sponge.noekeon.org/, pp. 181–197.</li>

      <li>9. , <em><a href="http://www.csrc.nist.gov/pki/HashWorkshop/Public_Comments/2007_May.html">Sponge-based pseudo-random</a> number generators</em>[, in Mangard and Standaert \\[33\\], pp. 33–47.](http://www.csrc.nist.gov/pki/HashWorkshop/Public_Comments/2007_May.html)</li>

      <li><span id="page-18-14"></span>10. , <em>On the security of the keyed sponge construction</em>, Symmetric Key Encryption Workshop (SKEW), February 2011.</li>

      <li>11. , <em>The</em> Kђѐѐюј <em>reference</em>, January 2011, http://keccak.noekeon.o<a href="http://sponge.noekeon.org/">rg/</a>.</li>

      <li><span id="page-18-19"></span>12. E. Biham and O. Dunkelman, <em>A framework for iterative hash functions—HAIFA</em>, Secon<a href="#page-19-23">d C</a>ryptographic Hash Workshop, Santa Barbara, August 2006.</li>

      <li><span id="page-18-12"></span>13. A. Biryukov (ed.), <em>Fast soĞware encryption, 14th international workshop, FSE 2007, Luxembourg, Luxembourg, march 26-28, 2007, revised selected papers</em>, Lec<a href="http://keccak.noekeon.org/">ture Notes in Computer Science</a>, vol. 4593, Springer, 2007.</li>

      <li><span id="page-18-21"></span><span id="page-18-8"></span>14. A. Bogdanov, M. Knezevic, G. Leander, D. Toz, K. Varici, and I. Verbauwhede, <em>SPONGENT: A lightweight hash function</em>, CHES (U. Parampalli and P. Hawkes, eds.), Lecture Notes in Computer Science, Springer, 2011, to appear.</li>

      <li><span id="page-18-24"></span>15. D. Chang and M. Nandi, <em>Improved indifferentiability security analysis of chopMD hash function</em>, Fast SoĞware Encryption (K. Nyberg, ed.), Lecture Notes in Computer Science, vol. 5086, Springer, 2008, pp. 429–443.</li>

      <li><span id="page-18-11"></span>16. J. Coron, Y. Dodis, C. Malinaud, and P. Puniya, <em>Merkle-Damgård revisited: How to construct a hash function</em>, Advances in Cryptology – Crypto 2005 (V. Shoup, ed.), LNCS, no. 3621, Springer-Verlag, 2005, pp. 430–448.</li>

      <li><span id="page-18-23"></span>17. A. Desai, A. Hevia, and Y. L. Yin, <em>A practice-oriented treatment of pseudorandom number generators</em>, Advances in Cryptology – Eurocrypt 2002 (L. R. Knudsen, ed.), Lecture Notes in Computer Science, vol. 2332, Springer, 2002, pp. 368–383.</li>

      <li><span id="page-18-22"></span>18. M. Dworkin, <em>Request for review of key wrap algorithms</em>, Cryptology ePrint Archive, Report 2004/340, 2004, http://eprint.iacr.org/.</li>

      <li><span id="page-18-18"></span>19. ECRYPT Network of excellence, <em>The SHA-3 Zoo</em>, 2011, http://ehash.iaik.tugraz.at/index.php/The\\_ SHA-3\\_Zoo.</li>

      <li><span id="page-18-16"></span>20. N. Ferguson, D. Whiting, B. Schneier, J. Kelsey, S. Lucks, and T. Kohno, <em>Helix: Fast encryption and authen<a href="http://eprint.iacr.org/">tication in a single cryptograp</a>hic primitive</em>, Fast SoĞware Encryption (T. Johansson, ed.), Lecture Notes in Computer Science, vol. 2887, Springer, 2003, pp. 330–346.</li>

      <li><span id="page-18-7"></span><span id="page-18-0"></span>21. <a href="http://ehash.iaik.tugraz.at/index.php/The_SHA-3_Zoo">V. D. Gligo</a>r and P. Donescu, <em>Fast encryption and authe<a href="http://ehash.iaik.tugraz.at/index.php/The_SHA-3_Zoo">ntication: XCBC encryption and XECB authentication</a> modes</em>, Fast SoĞware Encryption 2001 (M. Matsui, ed.), Lecture Notes in Computer Science, vol. 2355, Springer, 2001, pp. 92–108.</li>

      <li>22. M. Gorski, S. Lucks, and T. Peyrin, <em>Slide aĴacks on a class of hash functions</em>, Asiacrypt ( J. Pieprzyk, ed.), Lecture Notes in Computer Science, vol. 5350, Springer, 2008, pp. 143–160.</li>

      <li><span id="page-18-3"></span>23. J. Guo, T. Peyrin, and A. Poschman, <em>The PHOTON family of lightweight hash functions</em>, Advances in Cryptology – Crypto 2011 (P. Rogaway and R. Safavi-Naini, eds.), Lecture Notes in Computer Science, Springer, 2011, to appear.</li>

      <li><span id="page-18-20"></span>24. T. Iwata, <em>New blockcipher modes of operation with beyond the birthday bound security</em>, Fast SoĞware Encryption 2006 (M. J. B. Robshaw, ed.), Lecture Notes in Computer Science, vol. 4047, Springer, 2006, pp. 310–327.</li>

      <li><span id="page-18-10"></span><span id="page-18-6"></span><span id="page-18-5"></span>25. , <em>Authenticated encryption mode for beyond the birthday bound security</em>, Africacrypt (S. Vaudenay, ed.), Lecture Notes in Computer Science, vol. 5023, Springer, 2008, pp. 125–142.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>26. T. Iwata and K. Yasuda, <em>BTM: A single-key, inverse-cipher-free mode for deterministic authenticated encryption</em>, Selected Areas in Cryptography (M. J. Jacobson Jr., V. Rijmen, and R. Safavi-Naini, eds.), Lecture Notes in Computer Science, vol. 5867, Springer, 2009, pp. 313–330.</li>

      <li>27. , <em>HBS: A single-key mode of operation for deterministic authenticated encryption</em>, Fast SoĞware Encryption 2009 (O. Dunkelman, ed.), Lecture Notes in Computer Science, vol. 5665, Springer, 2009, pp. 394–415.</li>

      <li><span id="page-19-9"></span>28. C. S. Jutla, <em>Encryption modes with almost free message integrity</em>, Advances in Cryptology – Eurocrypt 2001 (B. Pfitzmann, ed.), Lecture Notes in Computer Science, vol. 2045, Springer, 2001, pp. 529–544.</li>

      <li><span id="page-19-8"></span>29. L. Knudsen, C. Rechberger, and S. Thomsen, <em>The Grindahl hash functions</em>, in Biryukov [13], pp. 39–57.</li>

      <li>30. T. Kohno, J. Viega, and D. Whiting, <em>CWC: A high-performance conventional authenticated encryption mode</em>, in Roy and Meier [47], pp. 408–426.</li>

      <li><span id="page-19-0"></span>31. T. Krovetz and P. Rogaway, <em>The soĞware performance of authenticated-encryption modes</em>, Fast SoĞware Encryption 2011, 2011.</li>

      <li><span id="page-19-22"></span><span id="page-19-3"></span>32. S. Lucks, <em>Two-pass authenticated encryption faster than generic composition</em>, Fast So<a href="#page-18-24">Ğw</a>are Encryption (H. Gilbert and <a href="#page-19-24">H</a>. Handschuh, eds.), Lecture Notes in Computer Science, vol. 3557, Springer, 2005, pp. 284–298.</li>

      <li><span id="page-19-10"></span><span id="page-19-5"></span>33. S. Mangard and F.-X. Standaert (eds.), <em>Cryptographic hardware and embedded systems, CHES 2010, 12th international workshop, Santa Barbara, CA, USA, August 17-20, 2010</em>, Lecture Notes in Computer Science, vol. 6225, Springer, 2010.</li>

      <li>34. U. Maurer, <em>Indistinguishability of random systems</em>, Advances in Cryptology Eurocrypt 2002 (L. Knudsen, ed.), Lecture Notes in Computer Science, vol. 2332, Springer-Verlag, May 2002, pp. 110–132.</li>

      <li><span id="page-19-23"></span>35. U. Maurer, R. Renner, and C. Holenstein, <em>Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology</em>, Theory of Cryptography - TCC 2004 (M. Naor, ed.), Lecture Notes in Computer Science, no. 2951, Springer-Verlag, 2004, pp. 21–39.</li>

      <li><span id="page-19-17"></span>36. F. Muller, <em>Differential aĴacks against the Helix stream cipher</em>, in Roy and Meier [47], pp. 94–108.</li>

      <li>37. NIST, <em>AES key wrap specification</em>, November 2001.</li>

      <li><span id="page-19-18"></span>38. , <em>NIST special publication 800-38C, recommendation for block cipher modes of operation: The CCM mode for authentication and confidentiality</em>, July 2007.</li>

      <li><span id="page-19-12"></span>39. , <em>NIST special publication 800-38D, recommendation for block cipher mod<a href="#page-19-24">es o</a>f operation: Galois/counter mode (GCM) and GMAC</em>, November 2007.</li>

      <li><span id="page-19-21"></span><span id="page-19-2"></span>40. S. Paul and B. Preneel, <em>Solving systems of differential equations of addition</em>, ACISP (C. Boyd and J. M. González Nieto, eds.), Lecture Notes in Computer Science, vol. 3574, Springer, 2005, pp. 75–88.</li>

      <li><span id="page-19-7"></span>41. T. Ristenpart, H. Shacham, and T. Shrimpton, <em>Careful with composition: Limitations of the indifferentiability framework</em>, Eurocrypt 2011 (K. G. Paterson, ed.), Lecture Notes in Computer Science, vol. 6632, Springer, 2011, pp. 487–506.</li>

      <li><span id="page-19-13"></span>42. P. Rogaway, <em>Authenticated-encryption with associated-data</em>, ACM Conference on Computer and Communications Security 2002 (CCS'02), ACM Press, 2002, pp. 98–107.</li>

      <li><span id="page-19-19"></span>43. , <em>Efficient instantiations of tweakable blockciphers and refinements to modes OCB and PMAC</em>, Asiacrypt (Pil Joong Lee, ed.), Lecture Notes in Computer Science, vol. 3329, Springer, 2004, pp. 16–31.</li>

      <li><span id="page-19-16"></span>44. P. Rogaway, M. Bellare, and J. Black, <em>OCB: A block-cipher mode of operation for efficient authenticated encryption</em>, ACM Trans. Inf. Syst. Secur. <strong>6</strong> (2003), no. 3, 365–403.</li>

      <li><span id="page-19-4"></span>45. P. Rogaway, M. Bellare, J. Black, and T. Krovetz, <em>OCB: A block-cipher mode of operation for efficient authenticated encryption</em>, CCS '01: Proceedings of the 8th ACM conference on Computer and Communications Security (New York, NY, USA), ACM, 2001, pp. 196–205.</li>

      <li><span id="page-19-20"></span>46. P. Rogaway and T. Shrimpton, <em>A provable-security treatment of the key-wrap problem</em>, Eurocrypt (S. Vaudenay, ed.), Lecture Notes in Computer Science, vol. 4004, Springer, 2006, pp. 373–390.</li>

      <li><span id="page-19-1"></span>47. B. K. Roy and W. Meier (eds.), <em>Fast soĞware encryption, 11th international workshop, FSE 2004, Delhi, India, February 5-7, 2004, revised papers</em>, Lecture Notes in Computer Science, vol. 3017, Springer, 2004.</li>

      <li><span id="page-19-6"></span>48. D. Whiting, B. Schneier, S. Lucks, and F. Muller, <em>Fast encryption and authentication in a single cryptographic primitive</em>, ECRYPT Stream Cipher Project Report 2005/027, 2005, http://www.ecrypt.eu.org/stream/ phelixp2.html.</li>

      <li><span id="page-19-24"></span>49. H. Wu and B. Preneel, <em>Differential-linear aĴacks against the stream cipher Phelix</em>, in Biryukov [13], pp. 87–100.</li>

      <li><span id="page-19-15"></span><span id="page-19-14"></span><span id="page-19-11"></span>50. M. Ågren, M. Hell, T. Johansson, and W. Meier, <em>A new version of Grain-128 with authentication</em>, Symmetric Key Encryption Workshop (SKEW), February 2011.</li>

    </ul>`;
---

<BaseLayout title="Duplexing the sponge: single-pass authenticated encryption a... (2011/499)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/499
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="duplexing-the-sponge-single-pass-authenticated-encryption-2011" />
  </article>
</BaseLayout>
