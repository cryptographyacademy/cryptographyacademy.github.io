---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1177';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proofs for Inner Pairing Products and Applications';
const AUTHORS_HTML = 'Benedikt Bünz, Mary Maller, Pratyush Mishra, Nirvan Tyagi, Psi Vesely';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz benedikt@cs.stanford.edu Stanford University Pratyush Mishra pratyush@berkeley.edu UC Berkeley Mary Maller mary.maller@ethereum.org Ethereum Foundation Nirvan Tyagi tyagi@cs.cornell.edu Cornell University Psi Vesely psi@berkeley.edu UC Berkeley</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present a generalized inner product argument and demonstrate its applications to pairing-based languages. We apply our generalized argument to proving that an inner pairing product is correctly evaluated with respect to committed vectors of <span class="math">n</span> source group elements. With a structured reference string (SRS), we achieve a logarithmic-time verifier whose work is dominated by <span class="math">6\\log n</span> target group exponentiations. Proofs are of size <span class="math">6\\log n</span> target group elements, computed using <span class="math">6n</span> pairings and <span class="math">4n</span> exponentiations in each source group.</p>

    <p class="text-gray-300">We apply our inner product arguments to build the first polynomial commitment scheme with succinct (logarithmic) verification, <span class="math">O(\\sqrt{d})</span> prover complexity for degree <span class="math">d</span> polynomials (not including the cost to evaluate the polynomial), and a CRS of size <span class="math">O(\\sqrt{d})</span>. Concretely, this means that for <span class="math">d=2^{28}</span>, producing an evaluation proof in our protocol is <span class="math">76\\times</span> faster than doing so in the KZG [KZG10] commitment scheme, and the CRS in our protocol is <span class="math">1,000\\times</span> smaller: <span class="math">13</span>MB vs <span class="math">13</span>GB for KZG. This gap only grows as the degree increases. Our polynomial commitment scheme is applicable to both univariate and bivariate polynomials.</p>

    <p class="text-gray-300">As a second application, we introduce an argument for aggregating <span class="math">n</span> Groth16 zkSNARKs into an <span class="math">O(\\log n)</span> sized proof. Our protocol is significantly more efficient than aggregating these SNARKs via recursive composition [BCGMMW20]: we can aggregate about <span class="math">130,000</span> proofs in <span class="math">25</span>min, while in the same time recursive composition aggregates just <span class="math">90</span> proofs.</p>

    <p class="text-gray-300">Finally, we show how to apply our aggregation protocol to construct a low-memory SNARK for machine computations. For a computation that requires time <span class="math">T</span> and space <span class="math">S</span>, our SNARK produces proofs in space <span class="math">\\tilde{\\mathcal{O}}(S+T)</span>, which is significantly more space efficient than a monolithic SNARK, which requires space <span class="math">\\tilde{\\mathcal{O}}(S\\cdot T)</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1 Introduction 3 2 Technical Overview 7 2.1 GIPA 7 2.2 Applications 8 3 Notation 9 4 Generalized Inner Product Argument (GIPA) 10 4.1 Doubly homomorphic commitments 11 4.2 Inner Product 12 4.3 Instantiation 13 5 Log-time verifier inner pairing product arguments 14 5.1 Inner product commitments with structured setup 14 5.2 Final commitment keys 15 5.3 TIPP: Inner pairing product 16 5.4 <span class="math">\\mathrm{MIPP}_n</span>: Multiexponentiation with unknown field vector 18 5.5 <span class="math">\\mathrm{MIPP}_h</span>: Multiexponentiation with known field vector 19 6 Log-time verifier polynomial commitments with square root SRS 22 6.1 Two-tiered inner product commitment 22 6.2 Two-tiered opening 22 6.3 Supporting univariate polynomials 23 6.4 Evaluation 23 7 Aggregating SNARK proofs 24 7.1 Groth 2016 background 25 7.2 Our aggregation protocol 25 7.3 Evaluation 26 8 Low-memory SNARKs for machine computations 27 8.1 Overview of solution 28 Acknowledgements 30 References 30 A Preliminaries 34 A.1 Bilinear groups 34 A.2 Interactive arguments of knowledge 34 A.3 Commitments 37 A.4 Polynomial commitments 37 A.5 Cryptographic assumptions 38 B Verifiable computation for inner pairing products (SIPP) 39 B.1 Construction 39 B.2 Efficiency 39 B.3 Security 40 B.4 Implementation 40 C Aggregate signature schemes based on BLS 41 C.1 Construction 42 C.2 Efficiency 43 D Deferred proofs 43 D.1 Proof of Theorem 1 43 D.2 Non interactive argument in the algebraic commitment model. 46 D.3 Proof of Theorem 2 47 D.4 Deferred proofs from Section 5 49 D.5 Deferred proofs from Section 6 52 E Hiding Polynomial Commitments 52</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">An inner product argument proves that an inner product relation holds between committed vectors. In this work, we present a new construction of inner product arguments for pairing-based languages that yields a logarithmic time verifier — a significant improvement over the linear time verifier of previous work. We use our new inner product argument to build (1) a new polynomial commitment scheme that achieves novel asymptotic characteristics of succinct verification and opening proofs that can be computed in time square root of the polynomial degree as well as a square root sized SRS; and (2) a new approach for aggregation of Groth16 general-purpose SNARKs <em>[x13]</em> useful for verifiable computation, avoiding the expensive costs of recursive proving circuits. We provide an open-source Rust implementation of all our protocols and applications and benchmark them against the state of the art. Our benchmarks show that the asymptotic improvements translate to significant practical gains.</p>

    <p class="text-gray-300">Inner product arguments. Inner product arguments (IPA) are core components of many primitives, including zero-knowledge proofs and polynomial and vector commitment schemes <em>[x1, x2, x11, x14, x15, x16]</em>. Despite the fact that the inner product arguments constructed in these works largely share the same core strategy as the original protocol in <em>[x1]</em>, they all spend significant effort in reproving security to accommodate for minor changes (introduced for efficiency and/or application-specific purposes). This repeated effort adds significant overhead in the process of auditing the security of inner product arguments, and enables errors to slip through unnoticed. Our first contribution is an abstraction of previous work into a generalized inner product argument (GIPA). While the techniques in GIPA are not novel, they do provide a unified view of all prior work, enabling simpler exposition and simpler security proofs. In particular, this means that our single security proof suffices to prove the security of all prior GIPA instantiations <em>[x1, x2, x14]</em>, as well as the protocols introduced in this paper.</p>

    <p class="text-gray-300">We additionally prove security for the non-interactive variant of GIPA in a generalization of the algebraic group model <em>[x12]</em>, which we dub the <em>algebraic commitment model</em>. Because GIPA is a public-coin protocol, it can be transformed to a non-interactive argument using the Fiat–Shamir heuristic, and it is this variant that is used in applications— non-interactive Bulletproofs secures almost <span class="math">2</span> billon USD of Monero <em>[x20]</em>. However, due to a technicality about modeling random oracles in recursive arguments (the generic transformation leads to a super-polynomial extractor), prior works provided no satisfactory security proof for these non-interactive variants. Our security proof remedies this oversight, and we envisage that our techniques may be useful in proving the security of other non-interactive and recursive protocols <em>[x5]</em>.</p>

    <p class="text-gray-300">Reducing verification cost. Making use of the high level GIPA blueprint, our second contribution is a protocol for reducing the verifier cost for specific inner product arguments over pairing-based languages. For a committed vector length of <span class="math">n</span>, we reduce the verifier cost from <span class="math">\\mathcal{O}(n)</span> for existing protocols <em>[x16]</em>, to <span class="math">\\mathcal{O}(\\log n)</span>, which is an exponential improvement. To do this, we introduce a new pairing-based commitment scheme with structured keys and prove its security. We then exploit a special structure of the “homomorphic collapsing” execution of GIPA (first observed in <em>[x4]</em>) with our commitment scheme. In particular, the outsourced computation is reduced to opening a KZG polynomial commitment scheme. We rely on a trusted setup that is updatable <em>[x11]</em> and can be used for languages of different sizes (up to some maximum bound specified by the SRS).</p>

    <p class="text-gray-300">Equipped with our new logarithmic-time verifier for inner products over pairing-based languages, we next turn to apply our techniques to two applications: (1) polynomial commitments, and (2) SNARK aggregation.</p>

    <p class="text-gray-300">Polynomial commitments. Polynomial commitment (PC) schemes <em>[x19]</em> are commitment schemes specialized to work with polynomials. A committer outputs a short commitment to a polynomial, and then</p>

    <p class="text-gray-300">later may convince a verifier of correctness of an evaluation of that committed polynomial at any point via a short evaluation proof, or “opening”. PC schemes have been used to reduce communication and computation costs in a vast breadth of applications including proofs of storage and replication <em>[x21, x11]</em>, anonymous credentials <em>[x13, x12]</em>, verifiable secret sharing <em>[x18, x3]</em>, and zero-knowledge arguments <em>[x24, x16, x19, x20, x2, x22, x23, x22]</em>.</p>

    <p class="text-gray-300">In this work, we use a combination of inner product arguments in order to build a pairing-based polynomial commitment scheme that requires a universal structured reference string of size only <span class="math">\\sqrt{d}</span> when committing to degree <span class="math">d</span> polynomials, and where proving an evaluation claim only requires <span class="math">\\mathcal{O}(\\sqrt{d})</span> cryptographic operations. We achieve this while maintaining constant-sized commitments, <span class="math">\\mathcal{O}(\\log d)</span>-sized evaluation proofs, and <span class="math">\\mathcal{O}(\\log d)</span> verifier time.</p>

    <p class="text-gray-300">This compares to a linear sized CRS for the widely used KZG <em>[x18]</em> commitment scheme. Concretely, this means that for polynomial of degree <span class="math">2^{22}</span>, KZG requires a large SRS of size <span class="math">\\sim 400</span>MB. This can cause deployment hurdles in applications in decentralized systems, as this SRS needs to be stored by every prover. For example, in SNARKs relying on polynomial commitments <em>[x15, x10]</em>, the degree of the polynomial is roughly the size of the circuit, which can be large <em>[x4, x23]</em>. A large SRS also has a non-trivial impact on security <em>[x13]</em>. In contrast, the SRS of our protocol has size <span class="math">3</span>MB, which is over <span class="math">130\\times</span> smaller, making deployment much easier.</p>

    <p class="text-gray-300">Furthermore, as noted above, computing an evaluation proof requires only <span class="math">\\mathcal{O}(\\sqrt{d})</span> cryptographic operations, which is much better than KZG, which requires <span class="math">\\mathcal{O}(d)</span> cryptographic operations. This is important for applications such as vector commitments <em>[x21]</em> and proofs of space <em>[x12]</em>, where a polynomial is committed to just once, but the commitment is opened at many different evaluation points.</p>

    <p class="text-gray-300">SNARK aggregation. A SNARK aggregation protocol takes as input many SNARK proofs and outputs a single aggregated proof that can be verified more quickly than individually verifying each SNARK. This is useful for applications where the batch of proofs will be verified many times by different clients. For example, this is the case in applications that aim to improve the scalability of decentralized blockchains by using SNARKs to prove the correctness of state transitions <em>[x25]</em>.</p>

    <p class="text-gray-300">We use our inner product arguments to design an aggregation protocol for Groth16 <em>[x17]</em> SNARKs that enjoys the following efficiency properties when aggregating <span class="math">n</span> proofs: (a) aggregation requires <span class="math">\\mathcal{O}(n)</span> cryptographic operations, (b) the aggregated proof has size <span class="math">\\mathcal{O}(\\log n)</span>, and (c) verification requires <span class="math">\\mathcal{O}(\\log n)</span> cryptographic operations, and <span class="math">\\mathcal{O}(n)</span> field operations.</p>

    <p class="text-gray-300">Our protocol offers asymptotic and concrete improvements over prior approaches that aggregate proofs via <em>recursive composition</em>. In more detail, these approaches create (another) SNARK for the circuit that contains <span class="math">n</span> copies of the Groth16 verifier circuit <em>[x2, x3]</em>. This entails constructing arithmetic circuits for computing pairings, which is expensive (for example, computing a pairing on the BLS12-377 curve requires <span class="math">\\sim 15,000</span> constraints <em>[x3]</em>). In contrast, our protocol “natively” works with pairing-based languages. This results in the following efficiency savings: (a) our protocol does not have to reason about about arithmetic circuits for computing pairings, (b) our protocol does not have to compute FFTs, which require time <span class="math">\\mathcal{O}(n\\log n)</span>, and (c) our protocol does not require special cycles or chains of curves <em>[x2, x3]</em>. Put together, these savings allow us to aggregate proofs over <span class="math">\\sim 1400\\times</span> faster than the recursive approach. Furthermore, our procol requires the verifier to only perform <span class="math">\\mathcal{O}(n)</span> field operations, as opposed to <span class="math">\\mathcal{O}(n)</span> cryptographic operations for the recursive approach.</p>

    <p class="text-gray-300">Low-memory SNARKs for machine computations. We leverage our aggregation protocol to construct a <em>low-memory SNARK</em> for (non-deterministic) machine computations. In more detail, if for a machine <span class="math">M</span>, checking an execution transcript requires space <span class="math">S</span> and time <span class="math">T</span>, then our SNARK prover takes space <span class="math">\\tilde{\\mathcal{O}}(S+T)</span> to produce a proof for that execution. In comparison, constructing a monolithic proof for the entire</p>

    <p class="text-gray-300">computation at once requires space <span class="math">\\tilde{\\mathcal{O}}(S\\cdot T)</span>, whereas the only other solution for constructing low-memory SNARKs for machine computations requires recursive composition of proofs <em>[x1]</em>, which is concretely expensive, as demonstrated above.</p>

    <p class="text-gray-300">Summary of contributions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We provide a unifying generalization of inner product arguments, identifying and formalizing the appropriate <em>doubly-homomorphic</em> commitment property.</li>

      <li>We prove security of the non-interactive Fiat-Shamir transform of this protocol, implying security for the entire family of protocols.</li>

      <li>We provide a new set of inner product arguments for pairing-based languages that improve verifier efficiency from linear to logarithmic by introducing a trusted structured setup.</li>

      <li>We construct a new polynomial commitment scheme with constant-sized commitments, opening time square root in the degree and square root sized CRS. The opening verifier runs in logarithmic time and opening proofs are logarithmic in size.</li>

      <li>We design an aggregator for Groth16 <em>[x12]</em> pairing-based SNARKs that produces an aggregated proof of logarithmic size. We apply our aggregator to construct a low-memory SNARK for machine computations <em>without relying on recursive composition</em>.</li>

      <li>We implement our inner product argument protocols and applications in Rust and evaluate their efficiency against state-of-the-art protocols. We find that our polynomial commitment scheme is over 14<span class="math">\\times</span> faster to open than a KZG commitment <em>[x17]</em> for polynomials of degree <span class="math">10^{6}</span>, and that our aggregation scheme aggregates proofs over 1400<span class="math">\\times</span> faster than the alternative two-chains approach.</li>

    </ul>

    <p class="text-gray-300">Additional constructions with a transparent setup. Prior versions of this work concentrate more closely on protocols that do not require a trusted setup. In Appendices B and C we include two of these constructions that we consider to be of independent interest, but that we decided to remove from the main body for reasons of conciseness.</p>

    <p class="text-gray-300">In Appendix B we discuss an outsourcing argument for demonstrating that <span class="math">n</span> pairings have been correctly computed. The prover computes <span class="math">2n</span> pairings, the proofs consist of <span class="math">2\\log(n)</span> target group elements, and the verifier computes <span class="math">2\\log(n)</span> target group operations in addition to <span class="math">2n</span> source group exponentiations (<span class="math">n</span> in each group). The writing style focuses on clarity rather than on generalisation and we recommend the less familiar reader to focus on this appendix before reading the generalisation in Section 4. In Appendix C we discuss how the outsourcing argument is applicable to BLS signatures.</p>

    <p class="text-gray-300">Related work. Lai, Malavolta, and Ronge <em>[x16]</em> introduced an inner product argument for pairing based languages. Their scheme runs over a transparent setup and is secure under the <span class="math">\\mathsf{SXDH}</span> assumption. Their work improves on Groth and Sahai Proofs <em>[x13]</em> which are a method to prove pairing-based languages under zero-knowledge without reducing to NP. Their proving costs are dominated by a linear number of pairings, their proof sizes are logarithmic and their verifier running costs are dominated by a linear number of group exponentiations. Our pairing based IPA’s have much lower verification costs but we use a trusted setup. Our generalized IPA argument can be used to greatly simplify the security proofs for their Theorems 3.2, 4.1, 4.2 and 4.3, and we prove security of a non-interactive variant in the algebraic commitment model.</p>

    <p class="text-gray-300">In Table 1, we compare the efficiency of various polynomial commitment schemes. Kate et al.<em>[x17]</em> introduced a pairing based polynomial commitment scheme with constant sized proofs. Their scheme is secure under an updatable setup in the algebraic group model. Groth <em>[x11]</em> designed a pairing based “batch product argument” secure under <span class="math">\\mathsf{SXDH}</span>. This argument that can be seen as a form of polynomial commitment scheme and our two-tiered polynomial commitment techniques were inspired by this work. Under discrete-logarithm</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomial commitment</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">communication complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">transparent setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CRS</td>

            <td class="px-3 py-2 border-b border-gray-700">commitments</td>

            <td class="px-3 py-2 border-b border-gray-700">openings</td>

            <td class="px-3 py-2 border-b border-gray-700">d=220</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Commit</td>

            <td class="px-3 py-2 border-b border-gray-700">Open</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kate et al.[KZG10]</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">96b</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 P, G1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs [BBBPWM18]</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d) G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax [WTSTW18]</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d) G1</td>

            <td class="px-3 py-2 border-b border-gray-700">33 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DARKs [BFS20]</td>

            <td class="px-3 py-2 border-b border-gray-700">d GU</td>

            <td class="px-3 py-2 border-b border-gray-700">1 GU</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d) GU</td>

            <td class="px-3 py-2 border-b border-gray-700">8.6 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">d GU</td>

            <td class="px-3 py-2 border-b border-gray-700">d log(d) GU</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d) GU</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Virgo [ZXZS20]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 H</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d)2 H</td>

            <td class="px-3 py-2 border-b border-gray-700">183 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">d log(d) H</td>

            <td class="px-3 py-2 border-b border-gray-700">d log(d) H</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d)2 H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth [Gro11]</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G2</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G2</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">25 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√d P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">√d G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d) G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">d G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√d P</td>

            <td class="px-3 py-2 border-b border-gray-700">log(d)G2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Efficiency comparisons for polynomial commitment schemes. All numbers are given asymptotically. We use  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  to represent groups in a bilinear map,  <span class="math">P</span>  to represent pairings,  <span class="math">\\mathbb{G}_U</span>  to represent groups of unknown order, and  <span class="math">\\mathbb{H}</span>  to represent hash functions. For simplicity we only specify the dominant costs e.g., if there are  <span class="math">d\\mathbb{G}_1</span>  and  <span class="math">d\\mathbb{G}_2</span>  group exponentiations we simple write  <span class="math">d\\mathbb{G}_2</span> . Column 5 is the expected size of one commitment plus one opening proof at  <span class="math">d = 2^{20}</span>  over a BN256 curve.</p>

    <p class="text-gray-300">assumptions, Bayer and Groth designed a zero-knowledge proving system to show that a committed value is the correct evaluation of a known polynomial [BG13]. Both the prover and verifier need only compute a logarithmic number of group exponentiations, however verifier costs are linear in the degree of the polynomial. Wahby et al. proved that it is possible to use the inner product argument of Bulletproofs [BBBPWM18] to build a polynomial commitment scheme [WTSTW18]. Bowe et al. [BGH19] argued that the inner product argument of Bulletproofs is also highly aggregatable, to the point where aggregated proofs can be verified using a one off linear cost and an additional logarithmic factor per proof. Attema and Cramer[AC20] recently provided an orthogonal generalization of the inner product argument. They show that the inner product argument can be seen as a black box compression mechanism for sigma protocols and show that it can be used as a proof system for secret shared data.</p>

    <p class="text-gray-300">Polynomial commitment schemes have also been constructed using Reed-Solomon codes [ZXZS20]. These commitments use highly efficient symmetric key primitives, however the protocols that use them require soundness boosting techniques that result in large constant overheads. Bünz et al.[BFS20] designed a polynomial commitment scheme in groups of unknown order such as RSA groups or class groups with efficient verifier time and small proof sizes. However, it requires super-linear commitment and prover time.</p>

    <p class="text-gray-300">Asymptotically, our scheme positions itself competitively among state-of-the-art PCs (see Table 1). In terms of concrete efficiency, the trusted setup scheme of Kate et al. [KZG10] allows for constant proof sizes and verifier time (versus our logarithmic results), whereas our protocol offers quadratic improvements to opening efficiency and the maximum degree polynomial supported by a SRS of a given size.</p>

    <p class="text-gray-300">Prior aggregatable SNARKs have relied on efficiently expressing SNARK verifiers as as arithmetic circuits [BCTV14b; BCGTV13]. For pairing based SNARKs this was achieved through the use of pairing-friendly cycles [BCTV14a] or two-chains [BCGMMW20]. Known cycles and two-chains for the 128-bit security level require roughly 768-bit curves, versus the roughly 384-bit curves used when recursion is not necessary ( <span class="math">\\sim 10 \\times</span>  performance hit in practice [SCI]). Bowe et al. introduce a novel approach to recursive SNARKs that works in cycles of non-pairing friendly curves [BGH19]. Bünz et al. [BCMS20] generalize and formalize this approach. Chiesa et al. build a post-quantum recursive SNARK [COS20]. For all of these approaches we expect to significantly improve on prover time because we do not rely on expensive  <span class="math">NP</span>  reductions.</p>

    <p class="text-gray-300">2 Technical Overview</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 GIPA</h3>

    <p class="text-gray-300">The first contribution of our paper is a generalized inner product argument we denote GIPA. At a high level, our protocol generalizes the protocols of <em>[x1, x2]</em> as follows. The protocols of <em>[x1, x2]</em> enable proving the correctness of inner products of scalar vectors committed via the Pedersen commitment scheme <em>[x24]</em>. Our protocol generalizes their techniques to enable proving the correct computation of a large class of inner products between vectors of group and/or field elements committed to using (possibly distinct) doubly homomorphic commitments. We explain in more detail below.</p>

    <p class="text-gray-300">Starting point: inner product arguments. The inner product argument (IPA) by <em>[x1]</em> enables a prover to convince a verifier that two committed vectors (using Pedersen vector commitments) have a publicly known inner product. It does this by elegantly rescaling the committed vectors to half their size in each round. In each round the verifier sends a random challenge, which the prover uses to take a linear combination of the right and left half of the committed vectors, and they both rescale the commitment keys accordingly.</p>

    <p class="text-gray-300">After <span class="math">\\log_{2}m</span> such reduction step the prover simply opens the commitment and the verifier checks that the product relation holds. In Bulletproofs <em>[x1]</em> the authors improve on the IPA by committing to the two vectors and the scalar in a single commitment, while maintaining the halving structure of the argument. This enables sending just two commitments per round.</p>

    <p class="text-gray-300">We observe that the same argument structure works for a much wider class of commitment schemes. In particular we require only that the commitment scheme is binding and has the homomorphic properties that enable the rescaling step. This property is that the commitment scheme is doubly homomorphic, i.e., homomorphic over the messages and the commitment keys.</p>

    <p class="text-gray-300">Doubly homomorphic commitments. At a high level, a doubly homomorphic commitment scheme is a binding commitment scheme <span class="math">(\\mathsf{Setup},\\mathsf{CM})</span> where the key space <span class="math">\\mathcal{K}</span>, message space <span class="math">\\mathcal{M}</span>, and commitment space <span class="math">\\mathcal{C}</span> form abelian groups of the same size such that <span class="math">\\mathsf{CM}((\\mathsf{ck}_{1}+\\mathsf{ck}_{2});(M_{1}+M_{2}))=\\mathsf{CM}(\\mathsf{ck}_{1},M_{1})+\\mathsf{CM}(\\mathsf{ck}_{1};M_{2})+\\mathsf{CM}(\\mathsf{ck}_{2},M_{1})+\\mathsf{CM}(\\mathsf{ck}_{2},M_{2})\\quad</span>.</p>

    <p class="text-gray-300">The Pedersen commitment <span class="math">\\mathsf{CM}(\\bm{g},\\bm{a})\\rightarrow\\prod_{i}g_{i}^{a_{i}}</span> is the doubly homomorphic commitment used in Bulletproofs. Lai, Malavolta, and Ronge <em>[x16]</em> used a doubly homomorphic commitment for bilinear groups where the committed vectors consist of group elements in a bilinear group: <span class="math">\\mathsf{CM}(\\bm{v},\\bm{v}^{\\prime},\\bm{w},\\bm{w}^{\\prime};\\bm{A},\\bm{B})\\rightarrow\\prod_{i}e(v_{i},A_{i})e(B_{i},w_{i}),\\prod_{i}e(v_{i}^{\\prime},A_{i})e(B_{i},w_{i}^{\\prime})\\enspace</span>.</p>

    <p class="text-gray-300">In some of our protocols the verifier already has access to one of the committed vectors. For instance, in the polynomial commitment scheme the verifier can simply compute the vector consisting of the monomials of the evaluation point. Such protocols are also captured by our abstraction since the identity commitment is doubly homomorphic. In the actual protocols, the prover doesn’t send any scalings of these vectors, and the verifier simply computes them directly.</p>

    <p class="text-gray-300">Generalized Inner Product Argument. Building on our generalization of commitment schemes that work for inner product arguments, GIPA also generalizes the types of inner products that can be proven between committed vectors. It can be used not only to show inner products between field elements, but for arbitrary inner product maps <span class="math">\\langle\\cdot,\\cdot\\rangle</span> that are bilinear, i.e., for which <span class="math">\\langle\\bm{a}+\\bm{b},\\bm{c}+\\bm{d}\\rangle=\\langle\\bm{a},\\bm{c}\\rangle+\\langle\\bm{a},\\bm{d}\\rangle+\\langle\\bm{b},\\bm{c}\\rangle+\\langle\\bm{b},\\bm{d}\\rangle\\quad</span>. It immediately follows our generalized argument works for bilinear pairings. We apply GIPA to three different inner products:</p>

    <p class="text-gray-300"><span class="math">\\langle\\cdot,\\cdot\\rangle:\\mathbb{G}_{1}^{m}\\times\\mathbb{G}_{2}^{m}\\mapsto\\mathbb{G}_{T},\\quad</span> <span class="math">\\langle\\bm{A},\\bm{B}\\rangle=\\prod_{i=0}^{m-1}e(A_{i},B_{i})</span> <span class="math">\\langle\\cdot,\\cdot\\rangle:\\mathbb{G}_{1}^{m}\\times\\mathbb{F}^{m}\\mapsto\\mathbb{G}_{1},\\quad</span> <span class="math">\\langle\\bm{A},\\bm{b}\\rangle=\\prod_{i=0}^{m-1}A_{i}^{b_{i}}</span> <span class="math">\\langle\\cdot,\\cdot\\rangle:\\mathbb{F}^{m}\\times\\mathbb{F}^{m}\\mapsto\\mathbb{F},\\quad</span> <span class="math">\\langle\\bm{a},\\bm{b}\\rangle=\\sum_{i=0}^{m-1}a_{i}b_{i}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">We refer to the first inner product as the inner pairing product.</p>

    <p class="text-gray-300">Security Proof. We prove both the interactive and the non-interactive variant of GIPA to be knowledge-sound. The interactive security proof shows the <span class="math">(k_{1},\\ldots,k_{r})</span>-special soundness of GIPA protocols, which implies knowledge-soundness via a recent result of Attema and Cramer <em>[x1]</em> (previous interactive security proofs showed only witness-extended emulation). In particular, we reduce the security of any GIPA instantion to the binding of its commitment scheme.</p>

    <p class="text-gray-300">We also prove knowledge-soundness of the non-interactive version of GIPA given by the Fiat-Shamir transform. It is known from folklore that applying the Fiat-Shamir transformation to a <span class="math">r</span>-round interactive argument of knowledge with negligible soundness error yields a non-interactive argument of knowledge in the random oracle model where the extractor <span class="math">\\mathcal{E}</span> runs in time <span class="math">O(t^{r})</span> for an adversary that performs at most <span class="math">t=\\mathrm{poly}(\\lambda)</span> random oracle queries. GIPA has <span class="math">\\log m</span> rounds for <span class="math">m=\\mathrm{poly}(\\lambda)</span> so this transformation yields a super-polynomial extractor. Given this, we directly prove the security of the non-interactive argument in the algebraic commitment model , a generalization of the algebraic group model <em>[x11]</em>. In essence, whenever the prover outputs a commitment he must also give an opening to it with respect to some linear combination of commitment key. Our security proof yields an efficient linear-time extractor and negligible knowledge-soundness. Given the generality of GIPA this also yields the first tight security analysis of non-interactive Bulletproofs <em>[x5, x4]</em> and the many related protocols <em>[x21, x3, x5]</em>.</p>

    <p class="text-gray-300">TIPP and MIPP. Generically GIPA protocols have logarithmic communication but linear verifier time as computing the final commitment key takes a linear number of operations. We introduce TIPP, a logarithmic verifier variant for the inner pairing product and MIPP for the multi-exponentiation inner product. These schemes use universal and updatable structured references string as commitment keys. Their commitments are based on that of Abe et al. <em>[x2]</em>, where given a commitment key <span class="math">(v_{0},v_{1})\\in\\mathbb{G}_{2}</span> the commitment to <span class="math">(A_{0},A_{1})\\in\\mathbb{G}_{1}^{2}</span> is given by <span class="math">e(A_{0},v_{0})e(A_{1},v_{1})</span>, and the KZG polynomial commitment <em>[x24]</em>.</p>

    <p class="text-gray-300">Instead of the verifier having to compute the verification key itself, we leverage a recent insight by Bowe, Grigg, and Hopwood <em>[x3]</em>. The final commitment key in GIPA can be viewed as a polynomial commitment to a degree <span class="math">m</span> polynomial that can be evaluated in <span class="math">\\log m</span> time. Using the structured setup we can outsource computing the commitment key to the prover. The verifier simply verifies that the commitment key was computed correctly. This amounts to evaluating the polynomial at a random point and checking a KZG <em>[x24]</em> polynomial commitment proof.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Applications</h3>

    <p class="text-gray-300">We show how to use instantiations of our generalized inner product argument to obtain interesting applications: a polynomial commitment scheme where computing evaluation proofs for polynomials of degree <span class="math">d</span> requires only <span class="math">O(\\sqrt{d})</span> cryptographic operations, and a protocol for aggregating <span class="math">n</span> Groth16 SNARKs <em>[x16]</em> to produce an aggregrate proof of size <span class="math">O(\\log n)</span> and verifiable in time <span class="math">O(\\log n)</span>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">2.2.1 Polynomial commitment</h4>

    <p class="text-gray-300">Following Groth <em>[x16]</em> we use two-tiered homomorphic commitments: i.e. commitments to commitments. Suppose we wish to commit to a polynomial</p>

    <p class="text-gray-300"><span class="math">f(X,Y)=f_{0}(Y)+f_{1}(Y)X+\\ldots+f_{m-1}(Y)X^{m-1}=\\sum_{i=0}^{m-1}f_{i}(Y)X^{i}.</span></p>

    <p class="text-gray-300">We can view this polynomial in matrix form</p>

    <div class="my-4 text-center"><span class="math-block">f (X, Y) = (1, X, X ^ {2}, \\ldots , X ^ {m - 1}) \\left( \\begin{array}{c c c c c} a _ {0, 0} &amp;amp; a _ {0, 1} &amp;amp; a _ {0, 2} &amp;amp; \\ldots &amp;amp; a _ {0, \\ell - 1} \\\\ a _ {1, 0} &amp;amp; a _ {1, 1} &amp;amp; a _ {1, 2} &amp;amp; \\ldots &amp;amp; a _ {1, \\ell - 1} \\\\ a _ {2, 0} &amp;amp; a _ {2, 1} &amp;amp; a _ {2, 2} &amp;amp; \\ldots &amp;amp; a _ {2, \\ell - 1} \\\\ \\vdots &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; \\vdots \\\\ a _ {m - 1, 0} &amp;amp; a _ {m - 1, 1} &amp;amp; a _ {m - 1, 2} &amp;amp; \\ldots &amp;amp; a _ {m - 1, \\ell - 1} \\end{array} \\right) \\left( \\begin{array}{c} 1 \\\\ Y \\\\ Y ^ {2} \\\\ \\ldots \\\\ Y ^ {\\ell - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">One first computes commitments  <span class="math">A_0, \\ldots, A_{m-1}</span>  to  <span class="math">f_0(Y), \\ldots, f_{m-1}(Y)</span> . Next one commits to the commitments  <span class="math">A_0, \\ldots, A_{m-1}</span> .</p>

    <p class="text-gray-300">On receiving an opening challenge  <span class="math">(x,y)</span>  the prover evaluates the first tier at  <span class="math">x</span>  to obtain a commitment  <span class="math">A</span>  to  <span class="math">f(x,Y)</span> . This is done using MIPP. The prover then opens the second tier commitment  <span class="math">A</span>  at  <span class="math">y</span>  in order to obtain  <span class="math">\\nu = f(x,y)</span> . This is done using a KZG univariate polynomial commitment scheme [KZG10]. To apply our prover efficient polynomial commitment scheme to univariate polynomials, commit to  <span class="math">f(X,X^n)</span>  and open at  <span class="math">(x,x^n)</span> .</p>

    <p class="text-gray-300">Note that for  <span class="math">m \\approx \\ell \\approx \\sqrt{d}</span>  both the MIPP and the KZG commitment are only of square root size. This results in a square root reference string. In order to achieve square root prover time (in addition to evaluating the polynomial) the prover needs to store the  <span class="math">A_0, \\ldots, A_{m-1}</span>  when committing to the polynomial. Using these values the resulting MIPP can be opened in  <span class="math">O(m) = O(\\sqrt{d})</span>  time.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2.2.2 SNARK aggregation and proofs of machine computation</h2>

    <p class="text-gray-300">Pairing-based SNARKs such as Groth16 can be proven and verified using only algebraic operations (e.g., field operations, group operations and pairings). This means we can aggregate by applying TIPP to the Groth16 verifier equations, such that whenever TIPP verifies the aggregator must have seen some verifying proof. In particular, to aggregate  <span class="math">n</span>  Groth 16 proofs  <span class="math">\\{(A_i, B_i, C_i)\\}_{i=1}^n \\in \\mathbb{G}_1 \\times \\mathbb{G}_2 \\times \\mathbb{G}_1</span> , one first computes commitments to the  <span class="math">A_i, B_i, C_i</span>  values. Then the prover computes  <span class="math">\\prod_{i=1}^n e(A_i, B_i)^{r^{2i}}</span>  and  <span class="math">\\prod_{i=1}^n C_i^{r^{2i}}</span>  for some random value  <span class="math">r</span>  and proves these are correct using our pairing based arguments. Finally the verifier checks that these values satisfy a randomized version of the Groth16 verifier equations. Overall the prover only performs one field multiplication per instance and  <span class="math">O(\\log(n))</span>  cryptographic operations for the TIPP protocol.</p>

    <p class="text-gray-300">Low-memory SNARKs for machine computation. We leverage our aggregation protocol in to construct a low-memory SNARK for (non-deterministic) machine computations that requires time  <span class="math">\\tilde{\\mathcal{O}}(T)</span>  and space  <span class="math">\\tilde{\\mathcal{O}}(S + T)</span>  to produce a proof to for a machine computation that requires space  <span class="math">S</span>  and time  <span class="math">T</span> . This is much better than a monolithic proof for the entire computation at once, which requires time  <span class="math">\\tilde{\\mathcal{O}}(S \\cdot T)</span> . Crucially, our protocol does not rely on recursive composition of proofs [BCCT13], which was the prior solution for constructing low-memory SNARKs.</p>

    <p class="text-gray-300">Our approach proceeds by producing an individual proof for each machine step, aggregates these individual proofs, and then additionally speeds up the checks relating to the state between machine steps via techniques based on polynomial commitments. See Section 8 for details.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Notation</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by  <span class="math">[n]</span>  the set  <span class="math">\\{1, \\ldots, n\\} \\subseteq \\mathbb{N}</span> . We use  <span class="math">\\pmb{a} = [a_i]_{i=1}^n</span>  as a short-hand for the vector  <span class="math">(a_1, \\ldots, a_n)</span> , and  <span class="math">[\\pmb{a}_i]_{i=1}^n = [[a_{i,j}]_{j=1}^m]_{i=1}^n</span>  as a short-hand for the vector  <span class="math">(a_{1,1}, \\ldots, a_{1,m}, \\ldots, a_{n,1}, \\ldots, a_{n,m})</span> ;  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the number of entries in  </span>\\pmb{a}<span class="math"> . We analogously define  </span>\\{a_i\\}_{i=1}^n<span class="math">  with respect to sets instead of vectors. If  </span>x$  is a</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">binary string then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its bit length. For a finite set </span>S<span class="math">, let </span>x\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}S</span> denote that <span class="math">x</span> is an element sampled uniformly at random from <span class="math">S</span>. We also write <span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{A}()<span class="math"> to denote an algorithm </span>\\mathsf{A}<span class="math"> sampled and used randomness in the computation of </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Inner pairing product notation. We introduce some special notation related to our inner pairing product argument, some of which is borrowed from the Pedersen inner product introduced in <em>[x1]</em>. We write group operations as multiplication. For a scalar <span class="math">x\\in\\mathbb{F}</span> and vector <span class="math">\\bm{A}\\in\\mathbb{G}^{n}</span>, we let <span class="math">\\bm{A}^{x}=(A_{1}^{x},\\ldots,A_{n}^{x})\\in\\mathbb{G}^{n}</span>, and for a vector <span class="math">\\bm{x}=(x_{0},\\ldots,x_{m-1})\\in\\mathbb{F}^{n}</span> we let <span class="math">\\bm{A^{x}}=(A_{0}^{x_{0}},\\ldots,A_{m-1}^{x_{m-1}})</span>. For a bilinear group <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},q,g,h,e)</span> (see Appendix A.1) and pair of source group vectors <span class="math">\\bm{A}\\in\\mathbb{G}_{1}^{n},\\ \\bm{B}\\in\\mathbb{G}_{2}^{n}</span> we define <span class="math">\\bm{A}\\ast\\bm{B}=\\prod_{i=1}^{n}e(A_{i},B_{i})</span>. For two vectors <span class="math">\\bm{A},\\bm{A}^{\\prime}\\in\\mathbb{G}^{n}</span> we let <span class="math">\\bm{A}\\circ\\bm{A}^{\\prime}=(A_{0}A_{0}^{\\prime},\\ldots,A_{m-1}A_{m-1}^{\\prime})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $\\bm{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{A}^{\\prime}=(A_{0},\\ldots,A_{n-1},A_{0}^{\\prime},\\ldots,A_{m-1}^{\\prime})<span class="math"> be the concatenation of two vectors </span>\\bm{A}\\in\\mathbb{G}^{n}<span class="math"> and </span>\\bm{A}^{\\prime}\\in\\mathbb{G}^{m}<span class="math">. To denote slices of vectors given </span>\\bm{A}\\in\\mathbb{G}_{-}^{n}<span class="math"> and </span>0\\leq\\ell<n-1<span class="math"> we write </span>\\bm{A}_{[:\\ell]}=(A_{0},\\ldots,A_{\\ell-1})\\in\\mathbb{G}^{\\ell}<span class="math"> and </span>\\bm{A}_{[\\ell:]}=(A_{\\ell},\\ldots,A_{n-1})\\in\\mathbb{G}^{n-\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Languages and relations. We write <span class="math">\\{(\\mathtt{x}):p(\\mathtt{x})\\}</span> to describe a polynomial-time language <span class="math">\\mathcal{L}\\subseteq\\{0,1\\}^{<em>}</span> decided by the polynomial-time predicate <span class="math">p(\\cdot)</span>. We write <span class="math">\\{(\\mathtt{x};\\mathtt{w}):p(\\mathtt{x},\\mathtt{w})\\}</span> to describe a NP relation <span class="math">\\mathcal{R}\\subseteq\\{0,1\\}^{</em>}\\times\\{0,1\\}^{*}</span> between instances <span class="math">\\mathtt{x}</span> and witnesses <span class="math">\\mathtt{w}</span> decided by the polynomial-time predicate <span class="math">p(\\cdot,\\cdot)</span>.</p>

    <p class="text-gray-300">Security notions. We denote by <span class="math">\\lambda\\in\\mathbb{N}</span> a security parameter. When we state that <span class="math">n\\in\\mathbb{N}</span> for some variable <span class="math">n</span>, we implicitly assume that <span class="math">n=\\mathrm{poly}(\\lambda)</span>. We denote by <span class="math">\\mathrm{negl}(\\lambda)</span> an unspecified function that is <em>negligible</em> in <span class="math">\\lambda</span> (namely, a function that vanishes faster than the inverse of any polynomial in <span class="math">\\lambda</span>). When a function can be expressed in the form <span class="math">1-\\mathrm{negl}(\\lambda)</span>, we say that it is <em>overwhelming</em> in <span class="math">\\lambda</span>. When we say that algorithm <span class="math">\\mathcal{A}</span> is an <em>efficient</em> we mean that <span class="math">\\mathcal{A}</span> is a family <span class="math">\\{\\mathcal{A}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> of non-uniform polynomial-size circuits. If the algorithm consists of multiple circuit families <span class="math">\\mathcal{A}_{1},\\ldots,\\mathcal{A}_{n}</span>, then we write <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\ldots,\\mathcal{A}_{n})</span>.</p>

    <p class="text-gray-300">Arguments of knowledge and Commitments. We use several standard notions in this paper such as interactive arguments of knowledge and commitments. For completeness, we include their definitions in Appendix A.</p>

    <h2 id="sec-9" class="text-2xl font-bold">4 Generalized Inner Product Argument (GIPA)</h2>

    <p class="text-gray-300">We now generalize the inner product argument (IPA) from <em>[x1, x2]</em> to work for all “doubly homomorphic” inner product commitments. The generalized inner product argument (GIPA) protocol is described with respect to a doubly homomorphic inner product commitment and an inner product map defined over its message space. All of the inner pairing product arguments in this paperas well as the discrete-log inner product argument from <em>[x1, x2]</em> can be described as instantiations of GIPA, sometimes with non-black-box optimizations that do not work generally. The generalized version enables us to simplify the proof of security of the specific instantiations presented in the rest of the paper and provides a “compiler” that lets the reader plug in their own computationally binding “inner product commitment” to obtain a new inner product argument (of knowledge).</p>

    <p class="text-gray-300">Protocol intuition. The protocol works by reducing the instance from size <span class="math">m</span> to <span class="math">m/2</span> each round. As an intuition, we will show how to reduce an instance with <span class="math">2</span> expensive mappings <span class="math">\\circledast</span> to an instance with just a single <span class="math">\\circledast</span>. Given <span class="math">a_{1},a_{2},b_{1},b_{2}</span> a prover wants to convince a verifier that <span class="math">(a_{1}\\circledast b_{1})+(a_{2}\\circledast b_{2})=c</span> for an expensive map <span class="math">\\circledast</span>. To do this the prover sends cross terms <span class="math">l=a_{1}\\circledast b_{2}</span> and <span class="math">r=a_{2}\\circledast b_{1}</span>. The verifier then sends a challenge <span class="math">x</span>. Note that for <span class="math">a^{\\prime}=x\\cdot a_{1}+a_{2}</span> and <span class="math">b^{\\prime}=x^{-1}\\cdot b_{1}+b_{2}</span> we have that <span class="math">a^{\\prime}\\circledast b^{\\prime}=x\\cdot l+c+x^{-1}\\cdot r</span>. Since the prover has to commit to the cross terms <span class="math">l</span> and <span class="math">r</span> before knowing <span class="math">x</span>, if <span class="math">x</span> is uniformly sampled from a sufficiently large space then checking this latter equation implies that <span class="math">c=(a_{1}\\circledast b_{1})+(a_{2}\\circledast b_{2})</span> with overwhelming probability.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Generalized inner product argument. Cases are based on the length  <span class="math">m</span>  of the message (and correspondingly commitment key) vectors. Here,  <span class="math">\\mathbf{0}</span>  is the vector containing  <span class="math">m&#x27;</span>  sequential group identity elements for the appropriate group.</p>

    <p class="text-gray-300">GIPA extends this idea to work for committed vectors  <span class="math">\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{b}_1, \\mathbf{b}_2</span> . It relies on doubly homomorphic commitments with a commitment key  <span class="math">\\mathbf{ck}</span>  where  <span class="math">\\mathsf{CM}(\\mathsf{ck}, \\mathbf{a}) = \\mathsf{CM}(x^{-1} \\cdot \\mathsf{ck}, x \\cdot \\mathbf{a})</span> .</p>

    <p class="text-gray-300">We can apply GIPA over any commitment scheme which is "doubly-homomorphic." For example, consider the Pedersen commitment scheme:</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">This scheme allows us to commit to elements in the message space  <span class="math">\\mathcal{M} = \\mathbb{F}_p^m</span>  under commitment keys in the key space  <span class="math">\\mathcal{K} = \\mathbb{G}^m</span>  for a group  <span class="math">\\mathbb{G}</span>  of prime order  <span class="math">p</span> . We denote the key space (i.e., the image of the setup algorithm) by  <span class="math">\\mathcal{K}</span> . The commitment space is additively homomorphic because for all  <span class="math">\\boldsymbol{a}, \\boldsymbol{b} \\in \\mathcal{M}</span>  and  <span class="math">\\boldsymbol{g} \\in \\mathcal{K}</span>  we have that  <span class="math">\\boldsymbol{g}^a \\cdot \\boldsymbol{g}^b = \\boldsymbol{g}^{a + b}</span> . The key space is also homomorphic because for all  <span class="math">\\boldsymbol{g}, \\boldsymbol{w} \\in \\mathcal{K}</span>  and  <span class="math">\\boldsymbol{a} \\in \\mathcal{M}</span>  we have that  <span class="math">\\boldsymbol{g}^a \\cdot \\boldsymbol{w}^a = (\\boldsymbol{g} \\circ \\boldsymbol{w})^a</span> . Thus, we consider the Pedersen commitment scheme to be doubly-homomorphic (i.e., homomorphic in both the commitment space and the key space).</p>

    <p class="text-gray-300">Definition 1 (Doubly homomorphic commitment scheme). A commitment scheme (Setup, CM) (see Definition 9) is doubly homomorphic if  <span class="math">(\\mathcal{K}, +), (\\mathcal{M}, +)</span>  and  <span class="math">(\\mathrm{Image}(\\mathrm{CM}), +)</span>  define abelian groups such that for</p>

    <p class="text-gray-300">all <span class="math">\\mathsf{ck},\\mathsf{ck}^{\\prime}\\in\\mathcal{K}</span> and <span class="math">M,M^{\\prime}\\in\\mathcal{M}</span> it holds that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{CM}(\\mathsf{ck};M)+\\mathsf{CM}(\\mathsf{ck};M^{\\prime})=\\mathsf{CM}(\\mathsf{ck};M_{1}+M^{\\prime})</span></li>

      <li><span class="math">\\mathsf{CM}(\\mathsf{ck};M)+\\mathsf{CM}(\\mathsf{ck}^{\\prime};M)=\\mathsf{CM}(\\mathsf{ck}+\\mathsf{ck}^{\\prime};M)</span></li>

    </ol>

    <p class="text-gray-300">Observe that if <span class="math">\\mathsf{CM}</span> is doubly homomorphic then for all <span class="math">x\\in\\mathbb{Z}_{p}</span> it holds that <span class="math">\\mathsf{CM}(x\\cdot\\mathsf{ck};M)=\\mathsf{CM}(\\mathsf{ck};x\\cdot M)</span>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.2 Inner Product</h3>

    <p class="text-gray-300">We consider inner products as bilinear maps from two equal-dimension vector spaces over two groups to a third group.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 2 (Inner product map).</h6>

    <p class="text-gray-300">A map <span class="math">\\circledast:\\mathcal{M}_{1}\\times\\mathcal{M}_{2}\\to\\mathcal{M}_{3}</span> from two groups of prime order <span class="math">p</span> to a third group of order <span class="math">p</span> is an inner product map if for all <span class="math">a,b\\in\\mathcal{M}_{1}</span> and <span class="math">c,d\\in\\mathcal{M}_{2}</span> we have that</p>

    <p class="text-gray-300"><span class="math">(a+b)\\circledast(c+d)=a\\circledast c+a\\circledast d+b\\circledast c+b\\circledast d</span></p>

    <p class="text-gray-300">Given an inner product <span class="math">\\circledast</span> between groups we define the inner product between vector spaces <span class="math">\\langle,\\rangle:\\mathcal{M}_{1}^{m}\\times\\mathcal{M}_{2}^{m}\\to\\mathcal{M}_{3}</span> to be <span class="math">\\langle\\bm{a},\\bm{b}\\rangle:=\\sum_{i=1}^{m}a_{i}\\circledast b_{i}</span></p>

    <p class="text-gray-300">We use three different inner products in this paper. For the Pedersen commitment described above we have that <span class="math">\\circledast</span> is multiplication between elements in <span class="math">\\mathbb{F}_{p}</span> and <span class="math">\\langle,\\rangle</span> is the dot product. In <span class="math">\\mathsf{TIPP}</span> we have that <span class="math">\\circledast:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> and <span class="math">A\\circledast B=e(A,B)</span>. In this case we refer to the resulting protocols as inner pairing product arguments. In <span class="math">\\mathsf{MIPP}</span> we use the inner product <span class="math">\\circledast:\\mathbb{G}\\times\\mathbb{F}\\to\\mathbb{G}</span> and <span class="math">A\\circledast b=A^{b}</span>, a multiexponentiation inner product.</p>

    <p class="text-gray-300">Inner product commitment. We further define an inner product commitment which consists of a doubly homomorphic commitment with a message space that is the Cartesian product of three message subspaces and an inner product that maps the first two message subspaces to the third. For GIPA the committed vectors and commitment keys halve in every round. If the commitments are constant sized, we can add commitments of different length. If not, we need to assume that the commitment key has a collapsing property such that additions of commitments are still well defined: Concretely we require that there exists a collapsing function <span class="math">\\mathsf{Collapse}</span> to reduce the size of commitments with repeated entries. For example consider a commitment scheme with commitment key <span class="math">g_{1},g_{2},g_{3},g_{4}\\in\\mathbb{G}^{4}</span> that commits to <span class="math">(a_{1},a_{2},a_{3},a_{4})\\in\\mathbb{F}^{4}</span> as <span class="math">[g_{1}^{a_{1}},g_{2}^{a_{2}},g_{3}^{a_{3}},g_{4}^{a_{4}}]</span>. Then whenever <span class="math">(a_{1},a_{2})=(a_{3},a_{4})</span> the collapsing function outputs the shorter commitment <span class="math">[(g_{1}g_{3})^{a_{1}},(g_{2}g_{4})^{a_{2}}]</span> under a compressed commitment key.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3 (Inner product commitment).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">(\\mathsf{Setup},\\mathsf{CM})</span> be a doubly homomorphic commitment with message space <span class="math">\\mathcal{M}=\\mathcal{M}_{1}^{m}\\times\\mathcal{M}_{2}^{m}\\times\\mathcal{M}_{3}</span> and key space <span class="math">\\mathcal{K}=\\mathcal{K}_{1}^{m}\\times\\mathcal{K}_{2}^{m}\\times\\mathcal{K}_{3}</span> defined for all <span class="math">m\\in[2^{j}]_{j\\in\\mathbb{N}}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{K}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=p<span class="math"> is prime for </span>i\\in[3]<span class="math">. Let </span>\\circledast:\\mathcal{M}_{1}\\times\\mathcal{M}_{2}\\to\\mathcal{M}_{3}<span class="math">. We call </span>((\\mathsf{Setup},\\mathsf{CM}),\\circledast)<span class="math"> an inner product commitment if there exists an efficient deterministic function </span>\\mathsf{Collapse}<span class="math"> such that for all </span>m\\in[2^{j}]_{j\\in\\mathbb{N}}<span class="math">, </span>M\\in\\mathcal{M}<span class="math">, and </span>\\mathsf{ck},\\mathsf{ck}^{\\prime}\\in\\mathcal{K}<span class="math"> such that </span>\\mathsf{ck}_{3}=\\mathsf{ck}_{3}^{\\prime}$ it holds as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{Collapse}\\left(\\mathsf{CM}\\left(\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c}\\mathsf{ck}_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ck}_{1}^{\\prime}&M_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{1}\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{ck}_{3}&M_{3}\\end{array}\\right)\\right)=\\mathsf{CM}\\left(\\begin{array}[]{c</td>

            <td class="px-3 py-2 border-b border-gray-700">c}\\mathsf{ck}_{1}+\\mathsf{ck}_{1}^{\\prime}&M_{1}\\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{ck}_{2}+\\mathsf{ck}_{2}^{\\prime}&M_{2}\\\\ \\mathsf{ck}_{3}&M_{3}\\end{array}\\right)\\enspace. \\]</p>

    <p class="text-gray-300">We refer to the requirement above as the collapsing property.</p>

    <p class="text-gray-300">Let <span class="math">((\\mathsf{Setup},\\mathsf{CM}),\\circledast)</span> be a binding inner product commitment as defined above. In Fig. 1 we present a generalized inner product argument defined for all <span class="math">m\\in[2^{j}]_{j\\in\\mathbb{N}}</span>. We prove that this protocol is an argument (resp., proof) of knowledge when instantiated with a computationally (resp., statistically) binding inner product commitment. The proof of the following theorem is presented in Appendix D.1.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Theorem 1 (GIPA knowledge-soundness).</h6>

    <p class="text-gray-300">If <span class="math">((\\mathsf{Setup},\\mathsf{CM}),\\circledast)</span> is a computationally (resp., perfectly) binding inner product commitment, then <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify})</span>, where <span class="math">\\mathsf{CM}</span> and <span class="math">\\circledast</span> instantiate the <span class="math">\\mathsf{Prove}</span> and <span class="math">\\mathsf{Verify}</span> algorithms presented in Fig. 1, has perfect completeness ( Definition 5) and computational (resp., statistical) knowledge-soundness ( Definition 6) for the relation</p>

    <p class="text-gray-300">\\[ \\mathcal{R}_{\\mathsf{IPA}}=\\left\\{\\begin{array}[]{c}\\big{(}\\begin{array}[]{c}\\mathsf{ck}\\in\\mathcal{K}_{1}^{m}\\times\\mathcal{K}_{2}^{m}\\times\\mathcal{K}_{3}\\ C\\in\\mathsf{Image}(\\mathsf{CM});\\bm{a}\\in\\mathcal{M}_{1}^{m},\\bm{b}\\in\\mathcal{M}_{2}^{m}\\ \\big{)}:\\\\ C=\\mathsf{CM}\\left(\\mathsf{ck};\\ (\\bm{a},\\bm{b},\\langle\\bm{a},\\bm{b}\\rangle)\\right)\\end{array}\\right\\}\\ . \\]</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Non-interactive argument.</h4>

    <p class="text-gray-300">In order to turn the public-coin interactive argument into a non-interactive proof we rely on the Fiat-Shamir heuristic. This results in all challenges being generated from a cryptographic hash function instead of by a verifier.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">If <span class="math">((\\mathsf{Setup},\\mathsf{CM}),\\circledast)</span> is a computationally (resp., perfectly) binding inner product commitment then in the algebraic group model and modeling <span class="math">\\mathsf{Hash}</span> as a random oracle <span class="math">\\mathsf{FS}-Transform(\\mathsf{GIPA})</span> is a non-interactive argument of knowledge Definition 7 against an efficient <span class="math">t</span>-query adversary in the random oracle model.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">Let <span class="math">m</span> be a power of <span class="math">2</span> and <span class="math">\\ell=\\log_{2}m</span>, the number of rounds in the <span class="math">\\mathsf{GIPA}</span> protocol. The prover communication consists of <span class="math">2\\ell</span> commitments, <span class="math">1</span> <span class="math">\\mathcal{M}_{1}</span> element, and <span class="math">1</span> <span class="math">\\mathcal{M}_{2}</span> element. When the commitment scheme used is constant-sized, an instantiation of <span class="math">\\mathsf{GIPA}</span> produces log-size proof. The prover makes <span class="math">2</span> commitments to <span class="math">(m+1)</span>-element messages in the first round, <span class="math">2</span> commitments to <span class="math">(m/2+1)</span>-element messages in the second, and <span class="math">2</span> commitments to <span class="math">(m/2^{i-1}+1)</span>-element messages in the <span class="math">i</span>-th. It holds that <span class="math">2\\cdot\\sum_{i=1}^{\\ell}\\left(\\frac{m}{2^{i-1}}+1\\right)=4m+2\\ell-4\\approx 4m</span>. So we say the prover commits to a total of <span class="math">4m</span> elements. Before computing these commitments, however, the prover first must compute the <span class="math">z_{L}</span> and <span class="math">z_{R}</span> inner products, similarly requiring <span class="math">2m</span> invocations of <span class="math">\\circledast</span> on <span class="math">4m</span> elements. Upon receiving the <span class="math">2</span> commitments sent each round, the verifier uses them along with the challenge <span class="math">x_{i}</span> it sampled that round to compute <span class="math">C^{\\prime}</span>, requiring <span class="math">2\\ell</span> multiplications in <span class="math">\\mathsf{Image}(\\mathsf{CM})</span>.</p>

    <p class="text-gray-300">The prover and verifier each compute <span class="math">\\mathsf{ck}^{\\prime}</span> in each round, requiring <span class="math">2m</span> multiplications in <span class="math">\\mathcal{K}</span>. Some extensions of the <span class="math">\\mathsf{GIPA}</span> protocol we’ll introduce later use trusted setups to produced structured commitment keys. In these protocols, the verifier doesn’t compute <span class="math">\\mathsf{ck}^{\\prime}</span> themself in each round, but instead is sent the final rescaling <span class="math">\\mathsf{ck}\\in\\mathcal{K}_{1}\\times\\mathcal{K}_{2}\\times\\mathcal{K}_{3}</span> that can be seen as a polynomial commitment in the verifiers challenges because of how the commitment key was structured. The verifier asks for an opening at a random point, which they can check with a small constant number of multiplications and pairings, and <span class="math">O(\\ell)</span> field operations. This technique achieves a log-time verifier.</p>

    <p class="text-gray-300">The prover alone computes <span class="math">\\bm{a}^{\\prime}</span> and <span class="math">\\bm{b}^{\\prime}</span>, requiring <span class="math">m</span> multiplications in each of <span class="math">\\mathcal{M}_{1}</span> and <span class="math">\\mathcal{M}_{2}</span>. In some instantiations of <span class="math">\\mathsf{GIPA}</span>, one or both of the vectors in <span class="math">\\mathcal{M}_{1}</span> and <span class="math">\\mathcal{M}_{2}</span> are included in full in the public input (i.e., the commitment performs the identity map on these inputs). In this case the verifier computes <span class="math">\\bm{a}^{\\prime}</span> and/or <span class="math">\\bm{b}^{\\prime}</span> themself.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.3 Instantiation</h3>

    <p class="text-gray-300"><span class="math">\\mathsf{GIPA}</span> can be instantiated with different commitments and inner product maps. In Bulletproofs <em>[x1]</em> it is instantiated with the generalized Pedersen commitment defined above, where <span class="math">\\mathcal{K}=\\mathbb{G}^{m}\\times\\mathbb{G}^{m}\\times\\mathbb{G}^{m}</span>, <span class="math">\\mathcal{M}=\\mathbb{F}_{p}^{m}\\times\\mathbb{F}_{p}^{m}\\times\\mathbb{F}_{p}</span>, and <span class="math">\\circledast</span> is the field addition operation. The reader can verify the commitment is a binding, doubly-homomorphic commitment scheme if the <span class="math">\\mathsf{DL}</span> assumption holds for <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">As a second example, in <em>[x11]</em> GIPA is instantiated for the inner pairing product <span class="math">a\\circledast b\\equiv e(a,b)</span> using the public-coin setup commitment scheme</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}((\\bm{v},\\bm{w},\\bm{1});\\ (\\bm{A},\\bm{B},\\bm{A}\\ast\\bm{B}))=(\\bm{A}\\ast\\bm{v},\\bm{w}\\ast\\bm{B},\\bm{A}\\ast\\bm{B})\\enspace.</span></p>

    <p class="text-gray-300">Parts of the commitment may be computable directly from inputs to the verifier. For efficiency reasons the prover would not have to transmit that part of the commitment. We can formulate instantiations of GIPA for the inner pairing product map and the identity commitment scheme, which is perfectly (and thus statistically) binding.</p>

    <p class="text-gray-300">An improvement on <em>[x11]</em>. GIPA also directly yields an improvement to the protocol presented in <em>[x11]</em> for proving knowledge of committed vectors of source group elements such that their inner pairing product is a public target group element. Replacing Lai et al.’s commitment scheme with <em>[x1]</em> results in a <span class="math">2</span> times faster prover and verifier for the relation while retaining the same proof size and assumptions.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5 Log-time verifier inner pairing product arguments</h2>

    <p class="text-gray-300">We present three inner product protocols that build on GIPA with the use of a trusted setup. Informally, these protocols prove the following relations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TIPP: An inner pairing product argument that proves <span class="math">Z\\in\\mathbb{G}_{T}</span> is the inner pairing product between committed vectors <span class="math">\\bm{A}\\in\\mathbb{G}_{1}^{m}</span> and <span class="math">\\bm{B}\\in\\mathbb{G}_{2}^{m}</span>.</li>

      <li><span class="math">\\mathsf{MIPP}_{u}</span>: An unknown-exponent multiexponentiation inner product argument that proves <span class="math">U\\in\\mathbb{G}_{1}</span> is the multiexponentiation product between committed vectors <span class="math">\\bm{A}\\in\\mathbb{G}_{1}^{m}</span> and <span class="math">\\bm{b}\\in\\mathbb{F}^{m}</span>.</li>

      <li><span class="math">\\mathsf{MIPP}_{k}</span>: A known-exponent multiexponentiation inner product argument that proves <span class="math">U\\in\\mathbb{G}_{1}</span> is the multiexponentiation inner product between a committed vector <span class="math">\\bm{A}\\in\\mathbb{G}_{1}^{m}</span> and an uncommitted vector <span class="math">\\bm{b}\\in\\mathbb{F}^{m}</span>.</li>

    </ol>

    <p class="text-gray-300">Our arguments achieve log-time verification by building on a recent observation about inner product arguments by Bowe, Grigg, and Hopwood <em>[x2]</em>. A specially structured commitment scheme allows the prover to send the final commitment key and a succinct proof (as a KZG polynomial opening) of its correctness, which is verified via a log-time evaluation of the polynomial and two pairings.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.1 Inner product commitments with structured setup</h3>

    <p class="text-gray-300">We construct inner product commitments for our arguments that are structured-key variants of the pairing-based commitment for group elements introduced by Abe et al. in <em>[x1]</em> and of the Pedersen commitment for field elements <em>[x23]</em>. The setup algorithms for the inner product arguments are input a security parameter <span class="math">\\lambda</span> and a max instance size <span class="math">m\\in\\left\\{2^{n}\\right\\}_{n\\in\\mathbb{Z}^{+}}</span>. A type <span class="math">3</span> bilinear group description <span class="math">\\langle\\mathsf{group}\\rangle\\leftarrow\\mathsf{SampleGrp_{3}}(1^{\\lambda})</span> is sampled. The structured setup proceeds by sampling random trapdoor elements <span class="math">\\alpha,\\beta\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math">, and constructing the prover and verifier keys (SRS) as follows for generators </span>g\\in\\mathbb{G}_{1}<span class="math"> and </span>h\\in\\mathbb{G}_{2}$:</p>

    <p class="text-gray-300"><span class="math">(\\langle\\mathsf{group}\\rangle,\\mathsf{pk}=(\\left[g^{\\alpha^{i}}\\right]_{i=0}^{2m-2},\\left[h^{\\beta^{i}}\\right]_{i=0}^{2m-2}),\\ \\mathsf{vk}=(g^{\\beta},h^{\\alpha}))\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Setup}(1^{\\lambda},m)$</p>

    <p class="text-gray-300">The inner product commitment keys are derived by taking the even powers from the prover SRS as <span class="math">\\bm{w}=\\left[g^{\\alpha^{2i}}\\right]_{i=0}^{m-1}</span> and <span class="math">\\bm{v}=\\left[h^{\\beta^{2i}}\\right]_{i=0}^{m-1}</span>. They are used as keys for the following inner product commitments. Observe that the vector commitment components of these inner product commitments are simply the</p>

    <p class="text-gray-300">ructured-key variants of <em>[x1]</em> and <em>[x22]</em>. The inner product values <span class="math">U,Z</span> and the known vector <span class="math">\\bm{b}</span> are committed to as the identity with keys initialized to <span class="math">1</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{TIPP}\\colon\\mathsf{CM}_{\\mathsf{TIPP}}((\\bm{v},\\bm{w},1_{\\mathbb{G}_{T}});\\,\\bm{A},\\bm{B},Z):=(\\bm{A}\\ast\\bm{v},\\bm{w}\\ast\\bm{B},Z)</span></li>

      <li><span class="math">\\mathsf{MIPP}_{u}\\colon\\mathsf{CM}_{\\mathsf{MIPP}\\text{-}u}((\\bm{v},\\bm{w},1_{\\mathbb{G}_{T}});\\,\\bm{A},\\bm{b},U):=(\\bm{A}\\ast\\bm{v},\\bm{w}^{\\bm{b}},U)</span></li>

      <li><span class="math">\\mathsf{MIPP}_{k}\\colon\\mathsf{CM}_{\\mathsf{MIPP}\\text{-}k}((\\bm{v},\\bm{1}_{\\mathbb{F}},1_{\\mathbb{G}_{T}});\\,\\bm{A},\\bm{b},U):=(\\bm{A}\\ast\\bm{v},\\bm{b},U)</span></li>

    </ol>

    <p class="text-gray-300">It follows directly from the <span class="math">q</span>-<span class="math">\\mathsf{ASDBP}</span> assumption (Assumption 1) that these commitments are binding with respect to both the commitment key and the proving SRS. Note that the commitment keys only use even powers of trapdoor elements. This is to prevent an adversary from using <span class="math">(g^{\\beta},h^{\\alpha})</span> to find collisions in the commitment scheme—observe that <span class="math">e(g,h^{\\alpha})\\cdot e(g^{\\alpha},h^{-1})=1_{\\mathbb{G}_{T}}</span>. The proving SRS requires all powers in order to compute the succinct KZG polynomial opening proofs for the final commitment keys. This is the reason for our introduction of a new security assumption.</p>

    <p class="text-gray-300">KZG polynomial commitments. As mentioned, we make use of the KZG polynomial commitment scheme <em>[x21]</em> which commits to polynomials of some max degree <span class="math">n</span>. For polynomial <span class="math">f(X)=\\sum_{i=0}^{n-1}a_{i}X^{i}</span> where <span class="math">\\bm{a}=[a_{i}]_{i=0}^{n-1}</span>, the commitment is computed with an analogously-structured trapdoor commitment key <span class="math">\\bm{ck}=\\left[g^{\\alpha^{i}}\\right]_{i=0}^{n-1}</span> as <span class="math">\\mathsf{KZG.CM}(\\langle\\mathsf{group}\\rangle,\\bm{ck},\\bm{a})=\\bm{ck}^{\\bm{a}}</span>.</p>

    <p class="text-gray-300">To open a point <span class="math">(x,y)</span> where <span class="math">y=f(x)</span>, To prove that <span class="math">y=f(x)</span> at a point <span class="math">x</span>, KZG uses the polynomial remainder theorem which says <span class="math">f(x)=y\\Leftrightarrow\\exists q(X):\\,f(X)-y=q(X)(X-x)</span>. The proof is just a KZG commitment to the quotient polynomial <span class="math">q(X)</span> where if <span class="math">q(X)</span> has coefficients <span class="math">\\bm{b}</span>, then <span class="math">\\mathsf{KZG.Open}(\\langle\\mathsf{group}\\rangle,\\bm{ck},\\bm{a},x)=\\bm{ck}^{\\bm{b}}</span>. The verifier key consists of <span class="math">h^{\\alpha}</span>, and the verifier runs <span class="math">\\mathsf{KZG.Verify}(\\langle\\mathsf{group}\\rangle,h^{\\alpha},C,W,y)</span> for commitment <span class="math">C</span> and opening <span class="math">W</span> and checks that <span class="math">e(Cg^{-y}W^{y},h)=e(W,h^{\\alpha})</span>. The KZG polynomial commitment scheme is extractable by Proposition 1.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.2 Final commitment keys</h3>

    <p class="text-gray-300">Recall in <span class="math">\\mathsf{GIPA}</span>, the verifier is required to perform a logarithmic amount of work to verify the final commitments <span class="math">C_{L}</span> and <span class="math">C_{R}</span>, using the challenges of each round of recursion to transform the commitments homomorphically. Assuming the commitments are of constant size this means that the verifier can efficiently check that these values are correct. However, the verifier must also perform a linear amount of work in rescaling the commitment key <span class="math">\\mathsf{ck}</span>. Thus to achieve logarithmic verification time, when instantiating <span class="math">\\mathsf{GIPA}</span> we need to avoid having the verifier rescale the commitment keys. We do this by outsourcing the work of rescaling the commitment keys to the prover.</p>

    <p class="text-gray-300">The prover will compute the final commitment keys and then prove that they are well-formed, i.e., that they are exactly what the verifier would have computed in an unmodified instantiation of <span class="math">\\mathsf{GIPA}</span>. Recall, we have structured our commitment keys as <span class="math">\\bm{w}=\\left[g^{\\alpha^{2i}}\\right]_{i=0}^{m-1}</span> and <span class="math">\\bm{v}=\\left[h^{\\beta^{2i}}\\right]_{i=0}^{m-1}</span>. Without loss of generality, we will present the approach inspired by techniques from <em>[x6]</em> with respect to proving well-formedness of the final commitment key for <span class="math">\\bm{w}\\in\\mathbb{G}_{1}</span>; the techniques will apply analogously to <span class="math">\\bm{v}\\in\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">In each round of <span class="math">\\mathsf{GIPA}</span>, the commitment key is homomorphically rescaled by the round challenge <span class="math">x</span> as:</p>

    <p class="text-gray-300"><span class="math">\\bm{w}^{\\prime}=\\bm{w}_{[:m/2]}\\circ\\bm{w}_{[m/2:]}^{x}=\\left[g^{\\alpha^{2i}(1+x\\alpha^{m+2i})}\\right]_{i=0}^{m/2-1}\\ .</span></p>

    <p class="text-gray-300">Repeating this rescaling over <span class="math">\\ell=\\log m</span> recursive rounds with challenges <span class="math">\\bm{x}=[x_{j}]_{j=0}^{\\ell}</span>, we claim (and show using an inductive argument in Proposition 1) that the final commitment key <span class="math">w</span> takes the form:</p>

    <p class="text-gray-300"><span class="math">w=g^{\\prod_{j=0}^{\\ell}\\left(1+x_{\\ell-j}\\alpha^{2^{j+1}}\\right)}\\ .</span></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 2: The argument (of  <span class="math">\\mathcal{R}_{ck}</span> ) used to allow a prover to prove well-formedness of the final structured commitment key. The final commitment key  <span class="math">w</span>  is interpreted as a KZG polynomial commitment that the prover must open at a random point. Shown for  <span class="math">w \\in \\mathbb{G}_1</span> , but holds analogously for  <span class="math">v \\in \\mathbb{G}_2</span> .</p>

    <p class="text-gray-300">We can then view this final commitment key  <span class="math">w</span>  as a KZG polynomial commitment to the polynomial  <span class="math">f_{w}(X)</span>  defined below (and analogously  <span class="math">v</span>  as the commitment to  <span class="math">f_{v}(X)</span> ):</p>

    <div class="my-4 text-center"><span class="math-block">f _ {w} (X) = \\prod_ {j = 0} ^ {\\ell} \\left(1 + x _ {\\ell - j} X ^ {2 ^ {j + 1}}\\right) \\qquad f _ {v} (X) = \\prod_ {j = 0} ^ {\\ell} \\left(1 + x _ {\\ell - j} ^ {- 1} X ^ {2 ^ {j + 1}}\\right)</span></div>

    <p class="text-gray-300">Thus, to prove the well-formedness of the final commitment keys, the prover will prove the following relation  <span class="math">\\mathcal{R}_{\\mathrm{ck}}</span>  making direct use of the KZG polynomial opening proof. Again, without loss of generality, the relation is presented with respect to the final commitment key  <span class="math">w \\in \\mathbb{G}_1</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {c k}} = \\left\\{\\left( \\begin{array}{l l} \\langle \\mathrm {g r o u p} \\rangle , w \\in \\mathbb {G} _ {2}, f (X), h ^ {\\alpha}; \\boldsymbol {g} = [ g ^ {\\alpha^ {i}} ] _ {i = 0} ^ {2 m - 2} \\end{array} \\right): \\quad w = g ^ {f (\\alpha)} \\right\\}</span></div>

    <p class="text-gray-300">Our protocol for proving  <span class="math">\\mathcal{R}_{\\mathrm{ck}}</span>  is given in Fig. 2. At a high level, the verifier produces a challenge point  <span class="math">z \\in \\mathbb{F}</span> . If the prover can provide a valid KZG opening proof of  <span class="math">f_w(z)</span>  for commitment  <span class="math">w</span> , then the verifier accepts. We formally prove the security of this argument system in Lemma 4 in the algebraic group model.</p>

    <p class="text-gray-300">The TIPP protocol allows a prover to show that for  <span class="math">T, U, Z \\in \\mathbb{G}_T</span> , they know  <span class="math">A \\in \\mathbb{G}_1</span>  and  <span class="math">B \\in \\mathbb{G}_2</span>  such that  <span class="math">T</span>  and  <span class="math">U</span>  are pairing commitments to  <span class="math">A</span>  and  <span class="math">B</span> , and  <span class="math">Z</span>  is the inner pairing product  <span class="math">Z = A * B</span> .</p>

    <p class="text-gray-300">This description is not quite general enough to cover the needs of our applications, such as batch verification. For example, to check that  <span class="math">m</span>  pairing equations are simultaneously satisfied (i.e., that  <span class="math">[Z_i = e(A_i, B_i)]_{i=0}^{m-1}</span> ), it is not sufficient to prove that  <span class="math">\\Pi_{i=0}^{m-1} e(A_i, B_i) = \\Pi_{i=0}^{m-1} Z_i</span> . Rather, instead you must prove the inner pairing product of a random linear combination defined by verifier challenge  <span class="math">r \\in \\mathbb{F}</span> :  <span class="math">\\Pi_{i=0}^{m-1} e(A_i, B_i)^{r^i} = \\Pi_{i=0}^{m-1} Z_i^{r^i}</span> .</p>

    <p class="text-gray-300">We support this by modifying the TIPP relation to include the linear combination challenge  <span class="math">r</span> . For notational simplicity, we will use powers of two (matching that of our commitment keys) and define a public vector of field elements  <span class="math">\\boldsymbol{r} = [r^{2i}]_{i=0}^{2m-2}</span> . The prover first commits to  <span class="math">T</span>  and  <span class="math">U</span> , and then the verifier sends a random field element  <span class="math">r</span> .</p>

    <p class="text-gray-300">Thus, the TIPP relation is captured formally as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {T I P P}} = \\left\\{ \\begin{array}{c} \\langle \\mathrm {g r o u p} \\rangle , g ^ {\\beta} \\in \\mathbb {G} _ {1}, h ^ {\\alpha} \\in \\mathbb {G} _ {2}, T, U, Z \\in \\mathbb {G} _ {T}, r \\in \\mathbb {F}; \\\\ \\boldsymbol {w} = [ g ^ {\\alpha^ {2 i}} ] _ {i = 0} ^ {m - 1}, \\boldsymbol {A} \\in \\mathbb {G} _ {1} ^ {m}, \\boldsymbol {v} = [ h ^ {\\beta^ {2 i}} ] _ {i = 0} ^ {m - 1}, \\boldsymbol {B} \\in \\mathbb {G} _ {2} ^ {m}, \\\\ \\boldsymbol {r} = [ r ^ {2 i} ] _ {i = 0} ^ {m - 1} \\in \\mathbb {F} ^ {m} \\\\ T = \\boldsymbol {A} * \\boldsymbol {v} \\wedge U = \\boldsymbol {w} * \\boldsymbol {B} \\wedge Z = \\boldsymbol {A} ^ {\\boldsymbol {r}} * \\boldsymbol {B} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Observe that if <span class="math">T=\\bm{A}<em>\\bm{v}</span> is a commitment to <span class="math">\\bm{A}</span>, then <span class="math">T=\\bm{A^{r}}</em>\\bm{v^{r}}^{-1}</span> is a commitment to <span class="math">\\bm{A^{r}}</span> under the commitment key <span class="math">\\bm{v^{r}}^{-1}</span>. Intuitively, the argument proceeds by having the prover act as if it is working with a rescaled commitment key <span class="math">\\bm{v}^{\\prime}=\\bm{v^{r}}^{-1}</span>. <span class="math">\\mathsf{TIPP}</span> runs the <span class="math">\\mathsf{GIPA}</span> protocol with <span class="math">\\mathsf{CM}_{\\mathsf{TIPP}}</span> where the collapsing function is defined as the identity, <span class="math">\\mathsf{Collapse}_{\\mathsf{id}}(C)=C</span>, over message <span class="math">(\\bm{A^{r}},\\bm{B},Z=\\bm{A^{r}}*\\bm{B})</span> and commitment key <span class="math">(\\bm{v}^{\\prime}=\\bm{v^{r}}^{-1},\\bm{w},1_{\\mathbb{G}_{T}})</span>. Since all components of the commitment are compact, the identity collapsing function is sufficient.</p>

    <p class="text-gray-300">Lastly, since the protocol is run over a rescaled commitment key <span class="math">\\bm{v}^{\\prime}</span>, the polynomial with which the prover proves the well-formedness of the final commitment key is also rescaled. It is as follows (derived in Proposition 1):</p>

    <p class="text-gray-300"><span class="math">f^{\\prime}_{v}(X)=\\prod_{j=0}^{\\ell}\\left(1+x_{\\ell-j}^{-1}(rX)^{2^{j+1}}\\right)</span></p>

    <p class="text-gray-300">A full description of the protocol is given in Figure 3. Because the protocol is public-coin, we can transform the interactive argument into a non-interactive proof using the Fiat-Shamir heuristic. In later sections, we may overload <span class="math">\\mathsf{TIPP}.\\mathsf{Prove}</span> and <span class="math">\\mathsf{TIPP}.\\mathsf{Verify}</span> as their non-interactive counterparts in which the prover will output a proof <span class="math">\\pi</span> that will be taken as an additional input by the verifier. This will be the case for <span class="math">\\mathsf{MIPP}_{u}</span> and <span class="math">\\mathsf{MIPP}_{k}</span> as well.</p>

    <p class="text-gray-300">Communication and time complexity. Table 2 gives an overview of the communication and time complexity of our inner product protocols. Here we provide accounting for <span class="math">\\mathsf{TIPP}</span>. The prover SRS consists of <span class="math">2m</span> elements in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">2m</span> elements in <span class="math">\\mathbb{G}_{2}</span>. The SRS consists only of monomials and therefore is updatable. The verifier’s SRS consists of the group description, <span class="math">1</span> elements in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">1</span> elements in <span class="math">\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">We calculate the prover computation. Our recursive argument requires <span class="math">\\log(m)</span> rounds. The left and right commitments at each recursive round of <span class="math">\\mathsf{GIPA}</span> require a total of <span class="math">6m</span> pairings to compute: <span class="math">3m</span> in the first round, <span class="math">\\frac{3m}{2}</span> in the second round, and <span class="math">\\frac{3m}{2i^{-1}}</span> in the <span class="math">j</span>-th round. Homomorphically rescaling the commitment keys <span class="math">(\\bm{v},\\bm{w})</span> and the messages <span class="math">(\\bm{A},\\bm{B})</span> require a total of <span class="math">2m</span> exponentiations in each source group. The prover for the final commitment key costs <span class="math">2m</span> group exponentiations in each source group (for each commitment key). In total this sums to <span class="math">6m</span> pairings, <span class="math">4m</span> <span class="math">\\mathbb{G}_{1}</span> exponentiations and <span class="math">4m</span> <span class="math">\\mathbb{G}_{2}</span> exponentiations.</p>

    <p class="text-gray-300">Regarding proof size, we have <span class="math">6\\log(m)</span> <span class="math">\\mathbb{G}_{T}</span> elements from the recursive argument, <span class="math">1</span> <span class="math">\\mathbb{G}_{1}</span> element and <span class="math">1</span> <span class="math">\\mathbb{G}_{2}</span> element from the final openings, and <span class="math">2</span> <span class="math">\\mathbb{G}_{1}</span> elements and <span class="math">2</span> <span class="math">\\mathbb{G}_{2}</span> elements from the final commitment key argument (i.e., <span class="math">w</span>, <span class="math">v</span>, and their proofs of correctness).</p>

    <p class="text-gray-300">The verifier computes <span class="math">7</span> pairings: <span class="math">3</span> from the recursive argument and <span class="math">4</span> from the final commitment key argument. Homomorphically rescaling the commitments in the recursive argument requires <span class="math">6\\log(m)</span> exponentiations in <span class="math">\\mathbb{G}_{T}</span>. The verifier also computes <span class="math">f(z)</span> in the final commitment key argument which costs <span class="math">2\\ell=2\\log_{2}(m)</span> field multiplications and additions.</p>

    <p class="text-gray-300">Security. Here we prove soundness for <span class="math">\\mathsf{TIPP}</span> in the algebraic group model.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 3 (Computational knowledge-soundness <span class="math">\\mathsf{TIPP}</span>).</h6>

    <p class="text-gray-300">The protocol defined in Section 5.3 for the NP relation <span class="math">\\mathcal{R}_{\\mathsf{TIPP}}</span> has computational knowledge-soundness (Definition 6) against algebraic adversaries under the <span class="math">q</span>-<span class="math">\\mathsf{ASDBP}</span> and <span class="math">2q</span>-<span class="math">\\mathsf{SDH}</span> assumptions.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The commitment scheme <span class="math">\\mathsf{CM}((\\bm{v}^{\\prime},\\bm{w},1),(\\bm{A}^{\\prime},\\bm{B},Z))=(\\bm{A}^{\\prime}<em>\\bm{v}^{\\prime},\\ \\bm{w}</em>\\bm{B},Z)=(T,U,Z)</span> is doubly homomorphic: the key space <span class="math">\\mathbb{G}_{2}^{m}\\times\\mathbb{G}_{1}^{m}\\times\\mathbb{F}</span> is homomorphic under <span class="math">\\mathbb{G}_{2}</span> multiplication, <span class="math">\\mathbb{G}_{1}</span> multiplication, and <span class="math">\\mathbb{F}</span> addition. The message space <span class="math">\\mathbb{G}_{1}^{m}\\times\\mathbb{G}_{2}^{m}\\times\\mathbb{G}_{T}</span> is homomorphic under the respective group multiplications. The commitment space <span class="math">\\mathbb{G}_{T}\\times\\mathbb{G}_{T}\\times\\mathbb{G}_{T}</span> is homomorphic under <span class="math">\\mathbb{G}_{T}</span> multiplication. All groups have prime order <span class="math">p</span> for <span class="math">p&gt;2^{\\lambda}</span>. The commitment scheme is also binding by the <span class="math">q</span>-<span class="math">\\mathsf{ASDBP}</span> assumption. This means that the commitment scheme is an inner product commitment. Thus either the adversary convinces the verifier of</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 3: TIPP argument of knowledge for inner pairing product between committed vectors.</p>

    <p class="text-gray-300">incorrect  <span class="math">w, v</span> , or by Theorem 1 an adversary that breaks knowledge-soundness can extract a valid  <span class="math">m</span> -ASDBP instance. An algebraic adversary that convinces a verifier of incorrect  <span class="math">w, v</span>  can extract a valid  <span class="math">2m</span> -SDH instance by Lemma 4.</p>

    <p class="text-gray-300">In the  <span class="math">\\mathsf{MIPP}_u</span>  protocol, a prover demonstrates knowledge for pairing commitment  <span class="math">T\\in \\mathbb{G}_T</span>  and KZG commitment  <span class="math">B\\in \\mathbb{G}_2</span>  of  <span class="math">\\pmb {A}\\in \\mathbb{G}_1^m</span>  as the opening of  <span class="math">T</span>  and  <span class="math">\\pmb {b}\\in \\mathbb{F}^{m}</span>  as the opening of  <span class="math">B</span>  where  <span class="math">U = \\prod_{i = 0}^{m - 1}A_i^{r^{2i}b_i}</span>  for a public field element  <span class="math">r</span> . The public field element  <span class="math">r</span> , as in Section 5.3, allows the argument to be used for random linear combinations.</p>

    <p class="text-gray-300">The  <span class="math">\\mathsf{MIPP}_u</span>  relation is captured formally as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">communication complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">SRS</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TIPP</td>

            <td class="px-3 py-2 border-b border-gray-700">2m G1 + 2m G2</td>

            <td class="px-3 py-2 border-b border-gray-700">6 log m GT + 3 G1 + 3 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">4m G1 + 4m G2 + 6m P</td>

            <td class="px-3 py-2 border-b border-gray-700">7 P + 6 log m GT</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MIPP_u</td>

            <td class="px-3 py-2 border-b border-gray-700">m G1 + 2m G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log m GT + 3 G1 + 2 G2 + 1 F</td>

            <td class="px-3 py-2 border-b border-gray-700">3m G1 + 3m G2 + 2m P</td>

            <td class="px-3 py-2 border-b border-gray-700">6 P + 2 log m GT</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MIPP_k</td>

            <td class="px-3 py-2 border-b border-gray-700">2m G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log m GT + 1 G1 + 2 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">m G1 + 3m G2 + 2m P</td>

            <td class="px-3 py-2 border-b border-gray-700">4 P + 2 log m GT + log m F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Efficiency table for TIPP,  <span class="math">\\mathsf{MIPP}_k</span> , and  <span class="math">\\mathsf{MIPP}_u</span> . The verifier keys are succinct.</p>

    <p class="text-gray-300">| R_MIPP_u = { { {group}}, g^β ∈ G1, h^α ∈ G2, T ∈ G_T, B, U ∈ G1, r ∈ F; w = [g^α2i]m-1i=0, A ∈ G1m, v = [h^β2i]m-1i=0, b ∈ Fm, r = [r2i]m-1i=0 ∈ Fm} : } . |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| T = A * v ∧ B = wb ∧ U = Ar^o b |</p>

    <p class="text-gray-300">The  <span class="math">\\mathsf{MIPP}_u</span>  argument proceeds analogously to TIPP if using the inner product commitment  <span class="math">\\mathsf{CM}_{\\mathsf{MIPP - u}}</span>  where  <span class="math">k_{U}</span>  is initialized to  <span class="math">1_{\\mathbb{G}_T}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {C M} _ {\\mathsf {M I P P - u}} \\left(\\left(\\boldsymbol {v}, \\boldsymbol {w}, k _ {U}\\right); \\boldsymbol {A}, \\boldsymbol {b}, U\\right) := \\left(\\boldsymbol {A} * \\boldsymbol {v}, \\boldsymbol {w} ^ {\\boldsymbol {b}}, k _ {U} U\\right)</span></div>

    <p class="text-gray-300">However, we make a small optimization by replacing the above commitment scheme with a modified scheme  <span class="math">\\mathsf{CM}_{\\mathsf{MIPP - u}}^{\\prime}</span>  with a commitment size consisting only of one element in  <span class="math">\\mathbb{G}_T</span>  (concretely  <span class="math">\\sim 25\\%</span>  reduction in size). Recall, the proof sizes are logarithmic with respect to the commitment, so cutting the commitment size by  <span class="math">25\\%</span>  more or less cuts the proof size by the same proportion.</p>

    <p class="text-gray-300">Using  <span class="math">\\mathsf{CM}_{\\mathsf{MIPP - u}}^{\\prime}</span>  adds two additional random group elements  <span class="math">\\hat{h}_1, \\hat{h}_2 \\stackrel{\\</span>}{\\leftarrow} \\mathbb{G}_2<span class="math">  to the prover key and verifier key (pk, vk) during setup. After setting  </span>(T, B, U, r)<span class="math"> , the verifier samples values  </span>(c_1, c_2) \\stackrel{\\<span class="math">}{\\leftarrow} \\mathbb{F}</span>  and sends them to the prover. The prover and verifier then each set  <span class="math">\\hat{h}_1&#x27; = \\hat{h}_1^{c_1}</span>  and  <span class="math">\\hat{h}_2&#x27; = \\hat{h}_2^{c_2}</span> . The values  <span class="math">\\hat{h}_1&#x27;</span>  and  <span class="math">\\hat{h}_2&#x27;</span>  become part of the commitment key for the following inner product commitment:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {C M} _ {\\mathsf {M I P P - u}} ^ {\\prime} \\left(\\left(\\boldsymbol {v}, \\boldsymbol {w}, \\left(\\hat {h} _ {1} ^ {\\prime}, \\hat {h} _ {2} ^ {\\prime}\\right)\\right); \\boldsymbol {A}, \\boldsymbol {b}, U\\right) := \\left(\\boldsymbol {A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol {w} ^ {\\boldsymbol {b}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U\\right) * \\left(\\boldsymbol {v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat {h} _ {1} ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat {h} _ {2} ^ {\\prime}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The prover then proceeds analogously to TIPP. First, running GIPA with  <span class="math">\\mathsf{CM}_{\\mathsf{MIPP - u}}^{\\prime}</span>  with the identity collapsing function over message  <span class="math">(A^{r},b,U = A^{r\\circ b})</span>  and commitment key  <span class="math">(\\pmb {v}^{\\prime} = \\pmb{v}^{r^{-1}},\\pmb {w},(\\hat{h}_1&#x27;,\\hat{h}_2&#x27;))</span> . The verifier runs with commitment  <span class="math">C = T\\cdot e(B,\\hat{h}_1^{\\prime})\\cdot e(U,\\hat{h}_2^{\\prime})</span> . The final commitment keys  <span class="math">w</span>  and  <span class="math">v</span>  are proved with respect to the same polynomials  <span class="math">f_{w}(X)</span>  and  <span class="math">f_{v}^{\\prime}(X)</span> .</p>

    <p class="text-gray-300">A full description of the protocol is given in Figure 4. Soundness follows for algebraic adversaries from the  <span class="math">q</span> -ASDBP and the  <span class="math">q</span> -SDH assumptions and the algorithm is proven secure in Theorem 7 deferred to Appendix D.4.</p>

    <p class="text-gray-300">In the  <span class="math">\\mathsf{MIPP}_k</span>  protocol a prover demonstrates knowledge of  <span class="math">A \\in \\mathbb{G}_1^m</span>  such that  <span class="math">A</span>  commits to pairing commitment  <span class="math">T</span>  under  <span class="math">\\pmb{v}</span>  and  <span class="math">U = A^b</span>  for a public vector  <span class="math">\\pmb{b} \\in \\mathbb{F}^m</span> .</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 4:  <span class="math">\\mathsf{MIPP}_u</span>  argument of knowledge for multiexponentiation inner product between committed vectors.</p>

    <p class="text-gray-300">The  <span class="math">\\mathsf{MIPP}_k</span>  relation is captured formally as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathsf {M I P P -} k} = \\left\\{\\left. \\left( \\begin{array}{c} \\langle \\mathsf {g r o u p} \\rangle , g ^ {\\beta} \\in \\mathbb {G} _ {1}, T \\in \\mathbb {G} _ {T}, U \\in \\mathbb {G} _ {1}, b \\in \\mathbb {F}; \\\\ \\boldsymbol {A} \\in \\mathbb {G} _ {1} ^ {m}, \\boldsymbol {v} = [ h ^ {\\beta^ {2 i}} ] _ {i = 0} ^ {m - 1}, \\boldsymbol {b} = [ b ^ {i} ] _ {i = 0} ^ {m - 1}\\right): \\\\ T = \\boldsymbol {A} * \\boldsymbol {v} \\wedge U = \\boldsymbol {A} ^ {\\boldsymbol {b}} \\end{array} \\right\\} \\right\\}.</span></div>

    <p class="text-gray-300">For the known vector multiexponentiation inner product, we use an inner product commitment that commits to the vector  <span class="math">\\pmb{b}</span>  as itself using a key  <span class="math">\\pmb{k}_{\\pmb{b}}</span>  initialized to  <span class="math">\\mathbf{1}_{\\mathbb{F}}</span> . Since the commitment is no longer compact, we use a collapsing function that collapses the vector by adding the first and second halves. This provides the required homomorphic properties of Definition 3.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {C M} _ {\\mathsf {M I P P -} k} ((\\boldsymbol {v}, \\boldsymbol {k} _ {\\boldsymbol {b}}, 1 _ {\\mathbb {G} _ {T}}); \\boldsymbol {A}, \\boldsymbol {b}, U) := (\\boldsymbol {A} * \\boldsymbol {v}, [ k _ {b, i} b _ {i} ] _ {i = 0} ^ {m - 1}, U)</span></div>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 1: MIPP <span class="math">_k</span>  argument of knowledge for multiexponentiation inner product between a committed vector of group elements and a known structured vector of field elements.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">prover and verifier then each set <span class="math">\\hat{h}^{\\prime}=\\hat{h}^{c}</span>. The value <span class="math">\\hat{h}^{\\prime}</span> becomes part of the commitment key for the following inner product commitment:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{CM}^{\\prime}_{\\mathsf{MIPP}\\text{-}k}((\\bm{v},\\bm{k_{b}},\\hat{h}^{\\prime});\\ \\bm{A},\\bm{b},U):=((\\bm{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U)*(\\bm{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{h}^{\\prime}),[k_{b,i}b_{i}]_{i=0}^{m-1})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A full description of the protocol is given in Figure 5. Soundness follows for algebraic adversaries from the <span class="math">q</span>-<span class="math">\\mathsf{ASDBP}</span> and the <span class="math">q</span>-<span class="math">\\mathsf{SDH}</span> assumptions and the algorithm is proven secure in Theorem 6 deferred to Appendix D.4.</p>

    <h2 id="sec-27" class="text-2xl font-bold">6 Log-time verifier polynomial commitments with square root SRS</h2>

    <p class="text-gray-300">In this section we introduce a polynomial commitment (PC) scheme with a square root sized SRS and opening time, and logarithmic proof sizes and verifier time. We use a two-tiered homomorphic commitment algorithm similar to the one from <em>[x10]</em> but with structured keys. We first describe how our PC can be used for bivariate polynomials, and then present a simple way to use it for univariate polynomials as well. In Appendix E, we show how these polynomial commitments can be made hiding for zero-knowledge applications.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">6.1 Two-tiered inner product commitment</h3>

    <p class="text-gray-300">We describe a two-tiered inner product commitment for bivariate polynomials. It is based on the <em>[x10]</em> two tiered commitment. We use the structured-key variant of the <em>[x1]</em> commitment introduced in Section 5.1 to commit to the KZG commitments <em>[x21]</em>. A brief description of KZG commitments was also given in Section 5.1. We describe our polynomial commitment in Figure 6.</p>

    <p class="text-gray-300">To commit to a polynomial <span class="math">f(X,Y)=\\sum_{j=0}^{m-1}f_{j}(Y)X^{j}</span> given commitment key <span class="math">ck=(\\bm{g},\\bm{v},\\hat{h})</span>, the committer computes <span class="math">m</span> KZG polynomial commitments <span class="math">\\bm{A}=[A_{j}]_{j=0}^{m-1}</span> to y-polynomials <span class="math">\\bm{f}=[f_{j}(Y)]_{j=0}^{m-1}</span> where say <span class="math">f_{j}(Y)</span> has coefficients <span class="math">\\bm{a}_{j}=[a_{i,j}]_{i=0}^{\\ell-1}</span>: <span class="math">A_{j}=\\mathsf{KZG}.\\mathsf{CM}(\\bm{g},\\bm{a}_{j})=\\bm{g}^{\\bm{a}_{j}}=g^{\\sum_{i=0}^{\\ell-1}a_{i,j}\\alpha^{i}}.</span> The committer then computes the pairing commitment <em>[x1]</em> to the KZG commitments</p>

    <p class="text-gray-300"><span class="math">T=\\bm{A}*\\bm{v}=\\prod_{j=0}^{m-1}e(A_{j},v_{i})=\\prod_{j=0}^{m-1}e(A_{j},h^{\\beta^{2j}})\\enspace.</span></p>

    <p class="text-gray-300">Thus, <span class="math">T=e(g,h)^{\\sum_{i,j=0}^{\\ell-1,m-1}a_{i,j}\\alpha^{i}\\beta^{2j}}</span>, and this commitment is binding under the <span class="math">q</span>-<span class="math">\\mathsf{ASDBP}</span> assumption and the <span class="math">q</span>-<span class="math">\\mathsf{SDH}</span> assumption.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">6.2 Two-tiered opening</h3>

    <p class="text-gray-300">Our opening algorithm proves a commitment <span class="math">T</span> to a polynomial <span class="math">f(X,Y)</span> evaluates to <span class="math">\\nu</span> at a point <span class="math">(x,y)\\in\\mathbb{F}^{2}</span>. We proceed in three steps. First the prover produces an opening for an outer tier partial evaluation <span class="math">U=f(x,Y)=\\prod_{i=0}^{m-1}A_{i}^{x^{i}}</span> for a point <span class="math">x\\in\\mathbb{F}</span>. Observe that <span class="math">U</span> is a KZG commitment to the univariate polynomial <span class="math">f(x,Y)=\\sum_{j=0}^{\\ell-1}(\\sum_{i=0}^{m-1}a_{i,j}x^{i})Y^{j}</span>. Second the prover produces a <span class="math">\\mathsf{MIPP}_{k}</span> proof (see Section 5.5) that <span class="math">U</span> is the inner product of the opening to <span class="math">T</span> and the vector <span class="math">\\bm{x}=(1,x,\\ldots,x^{m-1})</span>. Third the prover produce a KZG proof that <span class="math">\\nu</span> is the evaluation of <span class="math">U</span> at <span class="math">y</span>. The prover returns <span class="math">U</span> and the two proofs. The verifier simply checks the two proofs.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 6: A two-tiered inner product commitment.</p>

    <p class="text-gray-300">Theorem 4. If there exists a bilinear group sampler  <span class="math">\\mathrm{SampleGrp}_3</span>  that satisfies the q-ASDBP assumption in  <span class="math">\\mathbb{G}_2</span>  and the  <span class="math">q</span> -SDH assumption, then the protocol in Fig. 6 is a polynomial commitment scheme with computational extractability against algebraic adversaries.</p>

    <p class="text-gray-300">Note that computing the partial opening  <span class="math">U</span>  takes  <span class="math">m\\ell \\mathbb{G}_1</span>  exponentiations if computing from scratch. Instead, if the KZG commitments to the y-polynomials  <span class="math">\\mathbf{A}</span>  are given as input,  <span class="math">U</span>  can be computed with only  <span class="math">m</span> <span class="math">\\mathbb{G}_1</span>  exponentiations. Thus, we pass  <span class="math">\\mathbf{A}</span> , which was already computed during commitment, as auxiliary data to the opening algorithm to facilitate our square root degree opening time.</p>

    <p class="text-gray-300">If we have a univariate polynomial, then we set  <span class="math">\\ell m = d</span>  for  <span class="math">d</span>  the degree of  <span class="math">f(X)</span>  and  <span class="math">f_{i}(Y) = a_{i\\ell} + a_{i\\ell +1}Y + \\ldots +a_{(i + 1)\\ell -1}Y^{\\ell -1} = \\sum_{j = 0}^{\\ell -1}a_{i\\ell +j}Y^{j}</span> . Observe now that  <span class="math">p(X,Y) = \\sum_{i = 0}^{m - 1}f_i(Y)X^i</span>  is such that  <span class="math">p(X^{\\ell},X) = f(X)</span> . Thus we commit to  <span class="math">f(X)</span>  by committing to  <span class="math">p(X,Y)</span> . To evaluate  <span class="math">f(X)</span>  at  <span class="math">x</span>  the prover evaluates the first tier at  <span class="math">x^{\\ell}</span>  and the second at  <span class="math">x</span> . If  <span class="math">\\ell \\approx m</span>  then we have square root values  <span class="math">f_{i}(X)</span>  which each have degree square root in  <span class="math">d</span> . Hence our IPP arguments are ran over a square root number of commitments, which is what makes our verifier complexity and SRS size square root.</p>

    <p class="text-gray-300">In Figure 7, we compare the performance for of our polynomial commitment scheme against the state-of-the-art KZG commitment scheme. In optimizing the IPA commitment scheme, we found that the  <span class="math">\\mathsf{MIPP}_k</span>  proof was more expensive than the KZG proof. Therefore, it makes sense to skew the split of the polynomial so the  <span class="math">\\mathsf{MIPP}_k</span>  proof is over a smaller vector than the KZG proof. We found a skew of  <span class="math">\\kappa = 16</span>  to be optimal, leading to a split of  <span class="math">m = \\frac{\\sqrt{d}}{\\kappa}</span>  and  <span class="math">\\ell = \\kappa \\sqrt{d}</span> ; this explains the hitch in the plots until the optimal tradeoff is able to be made at  <span class="math">d = 2^{10}</span> .</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 7: Measured performance of the IPA polynomial commitment.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> polynomial degree</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> KZG10 This work</p>

    <p class="text-gray-300">Both KZG and our IPA produce commitments of constant size (a single  <span class="math">\\mathbb{G}_1</span>  element for KZG and a single  <span class="math">\\mathbb{G}_T</span>  element for IPA). The differences are that KZG allows for constant opening proof sizes and constant verifier time (versus our logarithmic opening sizes and verifier time), whereas IPA allows for square root opening time and SRS size (compared to the linear complexity of KZG).</p>

    <p class="text-gray-300">These asymptotic differences result in significant concrete tradeoffs between the two schemes. As expected, the IPA commitment, while expensive for low degree polynomials due to overhead of the inner product argument, quickly becomes much faster to compute opening proofs with breakeven degree being  <span class="math">d \\approx 2000</span> ; at  <span class="math">d = 10^6</span> , IPA is  <span class="math">14 \\times</span>  faster, and at  <span class="math">d = 250 \\times 10^6</span>  is  <span class="math">80 \\times</span>  faster. Similar savings are made with respect to prover SRS size. For degree  <span class="math">10^6</span> , IPA requires an SRS of size 800KB,  <span class="math">60 \\times</span>  smaller than the 50MB SRS required by KZG. In contrast, the IPA verifier time and opening size grow logarithmically and thus do not get too large; verifier time remains below 50ms even for polynomials of degree  <span class="math">d = 250 \\times 10^6</span> , and opening proof size remains below 4KB.</p>

    <p class="text-gray-300">We now discuss how the inner pairing product can be used to verify that  <span class="math">n</span>  independently generated SNARK proofs on independent instances can be aggregated to a  <span class="math">O(\\log(n))</span>  sized proof. While zk-SNARKs have constant-sized proofs and verifiers, in many settings such as blockchains a verifier needs to read and verify many proofs created by independent provers. We show how the TIPP protocol run by an untrusted aggregator can be used to aggregate these proofs into a small logarithmic sized proof. The verifiers only need to check the aggregated proof to be convinced of the existence of the underlying pairing-based SNARKs. The protocol can be made non-interactive and publicly verifiable using the Fiat-Shamir transform. This results in a logarithmic sized aggregation of  <span class="math">n</span>  SNARKs without the need for expensive pairing-friendly cycles of elliptic curves.</p>

    <p class="text-gray-300">To date the most efficient zkSNARK is due to Groth [Gro16] and consists of 3 group elements and 3 pairings to check. We thus choose to describe our methods with respect to Groth16, but note that they apply more generally to pairing based SNARKs that do not use random oracles. We present only the Groth16 verifier and not the prover, for it is the verification equations that we aim to prove are satisfied.</p>

    <p class="text-gray-300">We describe our protocol for aggregating Groth16 SNARKs recalling the following facts:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Structure of the verification key vk: The verification key is of the form:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {v k} := (p = g ^ {\\rho}, q = h ^ {\\tau}, [ s _ {j} = g ^ {(\\beta u _ {j} (x) + \\alpha v _ {j} (x) - w _ {j} (x))} ] _ {j = 1} ^ {2 \\ell}, d = h ^ {\\delta}).</span></div>

    <p class="text-gray-300">Here  <span class="math">\\rho, \\tau, \\delta, x \\in \\mathbb{F}</span>  are secrets generated (and discarded) during the generation of the proving and verification keys, and  <span class="math">u_{i}(X), v_{i}(X), w_{i}(X)</span>  are public polynomials that together define the QAP representation of the computation being checked.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Structure of the proof  <span class="math">\\pi</span> : The proof  <span class="math">\\pi</span>  is of the form  <span class="math">\\pi := (A, B, C) \\in \\mathbb{G}_1 \\times \\mathbb{G}_2 \\times \\mathbb{G}_1</span>  is of the form:</li>

      <li>Verifier's checks: On input a verification key  <span class="math">\\mathsf{vk}</span> , an NP instance  <span class="math">\\mathbf{x} := (a_1, \\ldots, a_m) \\in \\mathbb{F}^m</span> , and a proof  <span class="math">\\pi = (A, B, C)</span> , the verifier checks that  <span class="math">e(A, B) = e(p, q) \\cdot e(\\prod_{j=1}^{2\\ell} s_{1,j}^a, h) \\cdot e(C, d)</span> .</li>

    </ul>

    <p class="text-gray-300">Setup( <span class="math">\\langle \\text{group} \\rangle</span> ,  <span class="math">[\\mathsf{pk}_i, \\mathsf{vk}_i]_{i=1}^n</span> ):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\alpha, \\beta \\stackrel{\\mathbb{S}}{\\leftarrow} \\mathbb{F}</span> .</li>

      <li>Construct commitment key for the commitment scheme from Section 5.1:  <span class="math">\\mathsf{ck}_{\\langle \\mathsf{group}\\rangle} := (\\langle \\mathsf{group}\\rangle, \\mathbf{w} = [g^{\\alpha^{2i}}]_{i=0}^{n-1}, \\mathbf{v} = [h^{\\beta^{2i}}]_{i=0}^{n-1})</span> .</li>

      <li>Construct TIPP SRS:  <span class="math">\\mathsf{srs}_{\\mathsf{TIPP}} \\gets \\mathsf{TIPP}. \\mathsf{Setup}(\\langle \\mathsf{group} \\rangle, \\mathcal{R}_{\\langle \\mathsf{group} \\rangle}, \\alpha, \\beta)</span> .</li>

      <li>For each  <span class="math">i\\in [n]</span>  , parse  <span class="math">\\mathsf{vk}_i</span>  as  <span class="math">(\\langle \\mathrm{group}\\rangle ,\\mathcal{R}_i,p,q,[s_{i,j}]_{j = 1}^{\\ell},d_i)</span></li>

      <li>Commit to instance-specific elements from Groth16 verification keys:</li>

    </ol>

    <p class="text-gray-300">(a) Set  <span class="math">\\pmb{d} \\coloneqq [d_1, \\dots, d_n]</span> . (b) Commit to  <span class="math">\\pmb{d}</span> :  <span class="math">C_d \\coloneqq \\mathsf{CM}(\\mathsf{ck}_{\\langle \\mathsf{group} \\rangle}, \\pmb{d}) = \\pmb{w} <em> \\pmb{d}</span> . (c) For each  <span class="math">j\\in [\\ell ]</span>  , commit to  <span class="math">\\pmb {s}_j</span>  ..  <span class="math">C_{s_j}\\coloneqq \\mathsf{CM}(\\mathsf{ck}_{\\langle \\mathsf{group}\\rangle},\\pmb {s}_j = [s_{i,j}]_{i = 1}^n) = \\pmb {s}_j</em>\\pmb {v}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set prover key  <span class="math">\\mathsf{pk}_{\\mathrm{agg}} := ([\\mathsf{pk}_i]_{i=1}^n, \\mathsf{ck}_{\\langle \\mathsf{group} \\rangle}, \\mathsf{srs}_{\\mathsf{TIPP}}, [C_{s_j}]_{j=1}^\\ell, C_d, \\mathbf{d})</span> .</li>

      <li>Set verifier key  <span class="math">\\mathsf{vk}_{\\mathrm{agg}} := ([\\mathsf{vk}_i]_{i=1}^n, \\mathsf{ck}_{\\langle \\mathsf{group} \\rangle}, (h^\\alpha, g^\\beta), [C_{s_j}]_{j=1}^\\ell, C_d)</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{Agg}(\\mathsf{pk}_{\\mathrm{agg}},[(\\mathbf{x}_i,\\pi_i)]_{i = 1}^n)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\pi_{\\mathrm{agg}},r)\\coloneqq \\mathrm{AggHelper}(\\mathsf{pk}_{\\mathrm{agg}},[(\\mathbf{x}_i,\\pi_i)]_{i = 1}^n,\\bot)</span>  , and output  <span class="math">\\pi_{\\mathrm{agg}}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\operatorname{Verify}(\\mathsf{vk}_{\\mathrm{agg}}, [\\mathbf{x}_i = [a_{i,j}]_{j=1}^{\\ell}]_{i=1}^n, \\pi_{\\mathrm{agg}})</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j\\in [\\ell ]</span>  , compute  <span class="math">Z_{s_j}\\coloneqq \\prod_{i = 1}^n s_{i,j}^{a_{i,j}r^{2(i - 1)}}</span></li>

      <li>Check that Verify  <span class="math">\\text{Helper}(\\mathsf{vk}_{\\text{agg}}, [Z_{s_j}]_{j=1}^{\\ell}, \\pi_{\\text{agg}}, \\bot) = (1, r)</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 8: Aggregation of Groth16 SNARKs</p>

    <p class="text-gray-300">Our aggregation protocol is described in Fig. 8. Given  <span class="math">n</span>  instances  <span class="math">[[a_{i,j}]_{i=0}^{\\ell}]_{j=0}^{n-1}</span>  and proofs  <span class="math">[(A_j, B_j, C_j)]_{j=0}^{n-1}</span> , checking each equation separately requires performing  <span class="math">3n</span>  pairings and  <span class="math">n\\ell</span>  exponentiations. To reduce this computation to a single verification, the verifier can take a random linear combination between all equations.</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-16.jpeg">img-16.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-17.jpeg">img-17.jpeg</a> Figure 9: Measured performance of TIPP aggregation of SNARK proofs compared to the cost of proving a one layer of recursion inside a SNARK.</p>

    <p class="text-gray-300">!<a href="img-18.jpeg">img-18.jpeg</a> number of proofs to aggregate</p>

    <p class="text-gray-300">!<a href="img-19.jpeg">img-19.jpeg</a></p>

    <p class="text-gray-300">That is, the verifier samples  <span class="math">r \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}<span class="math"> , sets  </span>\\boldsymbol{r} = (1, r^2, \\dots, r^{2n-2})$  and then checks whether</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {A} ^ {- r} * \\boldsymbol {B} = e \\left(p ^ {\\sum_ {j} ^ {n - 1} r ^ {2 j}}, q\\right) \\cdot e \\left(\\prod_ {i = 1} ^ {\\ell} s _ {i} ^ {\\sum_ {j = 0} ^ {n - 1} a _ {i, j} r ^ {2 j}}, h\\right) \\cdot e \\left(\\prod_ {j = 0} ^ {n - 1} C _ {j} ^ {r ^ {2 j}}, d\\right), \\tag {2}</span></div>

    <p class="text-gray-300">If this equation holds then with overwhelming probability each individual verification holds. It therefore suffices to check this one pairing product instead of checking all SNARKs individually.</p>

    <p class="text-gray-300">Our aggregator uses an aggregator helper (Fig. 10) as a subroutine that is also used in our the complexity-preserving SNARKs. The aggregator helper is where the bulk of the algorithm is described. The aggregator helper allows for additional proof components to be sent before the challenge  <span class="math">r</span>  is computed. Here those proof elements will just be  <span class="math">\\bot</span> . The aggregator helper generates a commitment to  <span class="math">A</span> ,  <span class="math">B</span>  and  <span class="math">C</span> . These are hashed to get the challenge  <span class="math">r</span> . Then the prover computes  <span class="math">A^r * B</span>  and  <span class="math">C^r</span>  and proves using inner product arguments that these are correct. The verifier checks the proof and also that Eq. (2) is satisfied.</p>

    <h2 id="sec-35" class="text-2xl font-bold">7.3 Evaluation</h2>

    <p class="text-gray-300">In Figure 9, we compare the performance for aggregating varying numbers of SNARK proofs using our aggregation protocol, aggregating by using two-chains recursive SNARKs [BCGMMW20], and not aggregating at all (i.e., sending all proofs individually). The two-chains recursive approach proves inside another SNARK that each of the aggregated SNARKs are valid. The verification time for no aggregation consists of a single batched pairing check.</p>

    <p class="text-gray-300">While our protocol does not produce constant-sized proofs, it provides orders of magnitude improvements in setup size and aggregation time; allowing for a  <span class="math">900 \\times</span>  speedup in aggregating 64 proofs, the maximum size the two-chains approach was able to aggregate on our 250GB benchmark machine before running out of memory <span class="math">^3</span> . In the same time it takes to aggregate 64 proofs with the two-chains approach our protocol can aggregate 65k proofs into a 35KB proof that takes 300ms to verify.</p>

    <p class="text-gray-300">3The memory issues stem from the requirement to compute a large fast furrier transform</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">!<a href="img-20.jpeg">img-20.jpeg</a> Figure 10: Aggregation Helper functions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now show how to leverage our aggregation protocol in Section 7 to construct a low-memory SNARK for (non-deterministic) machine computations. A machine computation  <span class="math">M</span>  consists of a repeated computation  <span class="math">P</span>  over a fixed number of registers. An external memory of size  <span class="math">S</span>  that  <span class="math">P</span>  can read and write to can be modeled using techniques for online memory checking [BCCT13; BCGT13; BEGKN91] in which the memory is represented as a Merkle tree. In this case, an arithmetic circuit  <span class="math">C</span>  for computation  <span class="math">P</span>  can be built such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{polylog}(S)<span class="math"> . Taking this same approach, we prove Theorem 5, which states that if for a machine computation  </span>M<span class="math">  which executes using memory  </span>S<span class="math">  over  </span>T<span class="math">  repeated steps of computation  </span>P$ , then our SNARK</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-21.jpeg">img-21.jpeg</a> Figure 11: Setup for our low-memory SNARK for machines.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover takes time  $\\tilde{\\mathcal{O}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot T)<span class="math">  and space  </span>\\tilde{\\mathcal{O}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ T + S)$  to produce a proof for that execution.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In comparison, constructing a monolithic proof for the entire computation at once requires the same time, but incurs a space usage of  $\\tilde{\\mathcal{O}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot T + S)<span class="math"> . The only other solution for constructing low-memory SNARKs for machine computations requires recursive composition of proofs [BCCT13]. Recursive composition achieves a further improved space usage of  </span>\\tilde{\\mathcal{O}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ S)$ , but the time to prove, while asymptotically is equivalent to the previous solutions, is concretely very expensive.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 4 (Machine relation). For a Turing machine  <span class="math">M</span>  with step computation  <span class="math">P</span> , the NP relation  <span class="math">\\mathcal{R}_M</span>  is the set of instance-witness pairs  <span class="math">(y, w) = ((x, T), w)</span> , such that  <span class="math">M</span>  accepts  <span class="math">(x, w)</span>  after at most  <span class="math">T</span>  steps applying  <span class="math">P</span> .</p>

    <p class="text-gray-300">Theorem 5. Let  <span class="math">\\mathcal{R}_M</span>  be a machine relation for some machine  <span class="math">M</span>  with step computation  <span class="math">P</span>  that can be represented with arithmetic circuit  <span class="math">C</span> . Then there exists a SNARK for  <span class="math">\\mathcal{R}_M</span>  where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1) Setup takes time  $\\mathcal{O}(T_{\\max} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , where  </span>T_{\\max}$  is an upper bound on the number of computation steps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(3) Verification takes time  <span class="math">\\mathcal{O}(\\log (T))</span> (4) Proof size is  <span class="math">\\mathcal{O}(\\log (T))</span></p>

    <p class="text-gray-300">Let  <span class="math">M</span>  be a machine, such that each step performs some computation  <span class="math">P</span> , and the state at the end of the  <span class="math">i</span> -th timestep consists of  <span class="math">\\ell</span>  registers  <span class="math">(r_{i,1},\\ldots ,r_{i,\\ell})</span> , where  <span class="math">\\ell = \\mathrm{polylog}(S)</span> .</p>

    <p class="text-gray-300">We describe our setup, prove and verify functions in Figures 11, 12, and 13. Our solution, as described, keeps the witness elements  <span class="math">(w_{1},\\ldots ,w_{n})</span>  perfectly hidden. This is due to the fact that Groth 16 proofs are perfectly zero-knowledge. However we warn the reader that the elements in the registers  <span class="math">\\pmb{a},\\pmb{b}</span>  are not hidden. Further work would need to be performed to make our solution zero-knowledge.</p>

    <p class="text-gray-300">Our protocol can be extended to support the case where the each step of the machine computation is a different function. For example, our protocol can support the case where first ten steps check a hash function evaluation, while the next ten steps verify signatures. For simplicity of exposition, our protocol description considers only the single function case.</p>

    <p class="text-gray-300">Attempt #1: Just aggregate. A first idea would be to generate a Groth16 SNARK for each step, and then to aggregate the proofs for all steps using the protocol of Section 7. In more detail, the setup algorithm first</p>

    <p class="text-gray-300">MSNARK.Prove(pkagg, x, w):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{pk}_M</span>  as  <span class="math">(\\mathsf{pk}_{\\mathrm{agg}},\\mathsf{vk}_M,[\\mathsf{pk}_i]_{i = 1}^n,\\mathsf{ck}_{\\mathsf{KZG}})</span> , and parse  <span class="math">\\mathsf{vk}_M</span>  as  <span class="math">(\\mathsf{vk}_{\\mathrm{agg}},[C_{s_j}]_{j = 1}^{2\\ell},h^\\gamma)</span> .</li>

      <li>From  <span class="math">(\\mathbf{x},\\mathbf{w})</span>  , obtain the execution transcript transcript.</li>

      <li>For each  <span class="math">i\\in [n]</span></li>

    </ol>

    <p class="text-gray-300">(a) Obtain the  <span class="math">i</span> -th state  <span class="math">\\left([a_{i,j}]_{j=1}^{\\ell}, [b_{i,j}]_{j=1}^{\\ell}\\right)</span>  and  <span class="math">i</span> -th witness  <span class="math">\\mathbf{w}_i</span>  from transcript. (b) Compute  <span class="math">\\pi_i = (A_i, B_i, C_i) \\coloneqq \\text{Groth16.Prove}(\\mathsf{pk}_i, ([a_{i,j}]_{j=1}^\\ell, [b_{i,j}]_{j=1}^\\ell), \\mathsf{w})</span> . (c) Parse  <span class="math">\\mathsf{pk}_i</span>  to obtain  <span class="math">\\mathsf{vk}_i</span> , and parse  <span class="math">\\mathsf{vk}_i</span>  as  <span class="math">\\langle \\text{group} \\rangle</span> ,  <span class="math">\\mathcal{R}_i, p, q, [s_{i,j}]_{j=1}^{2\\ell}, d_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in [\\ell]</span> , compute a KZG10 commitment to  <span class="math">[a_{i,j}]_{i=1}^{n}</span>  and  <span class="math">[b_{i,j}]_{i=1}^{n}</span> :</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{\\phi_j}\\coloneqq \\mathsf{KZG.CM}(\\mathsf{ck}_{\\mathsf{KZG}},[a_{i,j}]_{i = 1}^n),</span></p>

    <p class="text-gray-300"><span class="math">C_{\\phi_{\\ell +j}}\\coloneqq \\mathsf{KZG.CM}(\\mathsf{ck}_{\\mathsf{KZG}},[b_{i,j}]_{i = 1}^{n}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute challenge point  <span class="math">x\\coloneqq \\mathrm{Hash}(C_{\\phi_1},\\ldots ,C_{\\phi_{2\\ell}})</span></li>

      <li>For each  <span class="math">j \\in [\\ell]</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Construct "instance-checker" polynomial  <span class="math">p_j(X) \\coloneqq \\sum_i (a_{i,j} - b_{i,j}x)X^i</span> . (b) Prove the claim that  <span class="math">p_j(x) = a_{1,j} - b_{n,j}x^{n}</span> ;  <span class="math">\\nu_j \\stackrel{\\</span>}{\\leftarrow} \\mathsf{KZG.Open}(\\mathsf{ck}_{\\mathsf{KZG}}, p_j, x)$ .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\pi_{\\mathrm{agg}},r)\\coloneqq \\mathrm{Agg.AggHelper}(\\mathsf{pk}_{\\mathrm{agg}},[(\\mathbf{x}_i,\\pi_i)]_{i = 1}^n,x).</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in [\\ell]</span> , set  <span class="math">Z_{s_j} := \\prod_{i=1}^{n} s_{i,j}^{a_{i,j} r^{2(i-1)}}</span> , and  <span class="math">Z_{s_{\\ell+j}} := \\prod_{i=1}^{n} s_{i,(\\ell+j)}^{b_{i,j} r^{2(i-1)}}</span> .</li>

      <li>For each  <span class="math">j \\in [2\\ell]</span> :</li>

    </ol>

    <p class="text-gray-300">Prove that  <span class="math">(C_{s_j}, C_{\\phi_j}, Z_{s_j}, r) \\in \\mathcal{R}_{\\mathrm{MIPP}}</span> :  <span class="math">\\pi_{\\mathrm{MIPP},j} := \\mathrm{MIPP}_n</span> . Prove  <span class="math">((C_{s_j}, C_{\\phi_j}, Z_{s_j}, r))</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the proof</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi_M\\coloneqq \\left( \\begin{array}{lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll} &amp;amp; \\text{instance proofs} &amp;amp; [\\nu_j]_{j = 1}^{\\ell}\\\\ \\text{instance proofs} &amp;amp; [\\nu_j]_{j = 1}^{\\ell}\\\\ \\text{instance proofs} &amp;amp; [\\pi_{\\mathrm{MIPP},j}]_{j = 1}^{2\\ell} \\end{array} \\right).</span></p>

    <p class="text-gray-300">Figure 12: Prover for our low-memory SNARK for machines.</p>

    <p class="text-gray-300">MSNARK.Verify(vkagg, [a1,j]j=1, [bn,j]j=1, πagg):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{vk}_M</span>  as  <span class="math">(\\mathsf{vk}_{\\mathrm{agg}},[C_{s_j}]_{j = 1}^{2\\ell},h^\\gamma)</span></li>

      <li>Parse  <span class="math">\\pi_{\\mathrm{agg}}</span>  as  <span class="math">\\begin{array}{rlr}{\\left(\\begin{array}{lllllllllllllllll} &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\end{array}\\right)} &amp;amp; \\text{instance proofs} &amp;amp; &amp;amp; [\\nu_j]_{j = 1}^{\\ell}\\\\ {\\left(\\begin{array}{lllllllllllllllllll} &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\end{array}\\right)} &amp;amp; \\text{instance proofs} &amp;amp; &amp;amp; [\\nu_j]_{j = 1}^{\\ell}\\\\ {\\left(\\begin{array}{lllllllllllllllllll} &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\end{array}\\right)} &amp;amp; \\text{instance proofs} &amp;amp; &amp;amp; [\\nu_j]_{j = 1}^{\\ell} \\end{array}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute challenge point  <span class="math">x\\coloneqq \\mathrm{Hash}(C_{\\phi_1},\\ldots ,C_{\\phi_{2\\ell}})</span></li>

      <li>For each  <span class="math">j \\in [\\ell]</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Compute the commitment  <span class="math">C\\coloneqq C_{\\phi_j}C_{\\phi_{\\ell +j}}^{-x}</span> (b) Compute the expected evaluation  <span class="math">y\\coloneqq a_{1,j} - b_{n,j}x^{n}</span> (c) Check the KZG10 evaluation proof: KZG.Verify  <span class="math">(h^{\\gamma},C,y,\\nu_{j}) = 1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(b,r)\\coloneqq \\mathrm{Agg.VerifyHelper}(\\mathsf{vk}_{\\mathrm{agg}},[Z_{s_j}]_{j = 1}^{2\\ell},\\pi_{\\mathrm{agg}},x)</span> , and check  <span class="math">b = 1</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in [2\\ell]</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Check that  <span class="math">(C_{s_j}, C_{\\phi_j}, Z_{s_j}, r)</span>  is a valid instance of  <span class="math">\\mathcal{R}_{\\mathrm{MIPP}}</span> :  <span class="math">\\mathrm{MIPP}_{\\mathrm{ws}}</span> . Verify  <span class="math">((C_{s_{\\ell + j}}, C_{\\phi_{\\ell + j}}, Z_{s_j}, r), \\pi_{\\mathrm{MIPP}, j}) = 1</span> .</p>

    <p class="text-gray-300">Figure 13: Verifier for our low-memory SNARK for machines.</p>

    <p class="text-gray-300">invokes <span class="math">(\\mathsf{pk},\\mathsf{vk}):=\\mathsf{Groth16.Setup}(1^{\\lambda},P^{\\prime})</span>, where <span class="math">P^{\\prime}</span> is an arithmetic circuit that takes as public input <span class="math">2\\ell</span> field elements <span class="math">(a_{1},\\ldots,a_{\\ell},b_{1},\\ldots,b_{\\ell})</span>, and checks that <span class="math">P</span>, when invoked on a register assignment <span class="math">(a_{1},\\ldots,a_{\\ell})</span> produces registers whose assigned value is <span class="math">(b_{1},\\ldots,b_{\\ell})</span>. It then invokes <span class="math">\\mathsf{Agg.Setup}(1^{\\lambda},\\mathsf{pk})</span> to generate keys for aggregating <span class="math">T</span> proofs for <span class="math">P^{\\prime}</span>.</p>

    <p class="text-gray-300">The proving algorithm then simply generates all <span class="math">T</span> proofs, aggregates them using the <span class="math">\\mathsf{Agg.Agg}</span> algorithm, and outputs <span class="math">\\pi:=(\\pi_{\\mathsf{agg}},[([a_{i,j}]_{j=1}^{\\ell},[b_{i,j}]_{j=1}^{\\ell})]_{i=1}^{T})</span>. Finally, the verifier checks that, for each <span class="math">i\\in[T]</span>, <span class="math">[b_{i,j}]_{j=1}^{\\ell}=[a_{i+1,j}]_{j=1}^{\\ell}</span>, and then invokes <span class="math">\\mathsf{Agg.Verify}</span> to check that the aggregated proofs are correct. There are two problems with this approach: the output proof <span class="math">\\pi</span> is not succinct, and the verifier performs <span class="math">O(T)</span> work.</p>

    <p class="text-gray-300">Attempt #2: Our protocol. Notice that the foregoing protocol has succinct proofs and succinct verification except for the steps that handle the registers. To remedy this, we handle the two sources of inefficiency as follows.</p>

    <p class="text-gray-300">First, to speed up the checks asserting that the output of one step is the input of the next, we use the following idea: for each <span class="math">j\\in[\\ell]</span>, the prover defines the <span class="math">j</span>-th “instance-checker” polynomial <span class="math">p_{j}(X):=\\sum_{i}(a_{i,j}-b_{i,j}x)X^{i}</span> (for a random <span class="math">x\\in\\mathbb{F}</span>). This polynomial has the property that <span class="math">\\forall i\\in[n],a_{i,j}=b_{i-1,j}</span> if and only <span class="math">p_{j}(x)=a_{1,j}-b_{n,j}x^{n}</span>. The prover then commits to each of these <span class="math">j</span> polynomials via KZG commitment <span class="math">C_{j}</span>, and proves the foregoing evaluation claim. The verifier can check the resulting evaluation proof by appropriately rescaling the commitments <span class="math">[C_{j}]_{j=1}^{\\ell}</span>. Next, to assert that the values committed inside <span class="math">[C_{j}]_{j=1}^{\\ell}</span> indeed satisfy the Groth16 verifier, we use a MIPP proof. Together, these approaches allow us to make both proof size and verifier time logarithmic, as required.</p>

    <h2 id="sec-45" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">Thank you to Russell Lai, Giulio Malavolta, Alessandro Chiesa, Alistair Stewart, Oana Ciobotaru, and Dan Boneh for helpful discussions and feedback. This work was partially supported by NSF, SGF, ONR, and the Simons Foundation and Institute for the Theory of Computation. Mary Maller was supported in part by EPSRC Grant EP/N028104/1 and this work was completed in part while Mary Maller and Psi Vesely were at University College London.</p>

    <h2 id="sec-46" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AC20] T. Attema and R. Cramer. “Compressed <span class="math">\\Sigma</span>-Protocol Theory and Practical Application to Plug & Play Secure Algorithmics”. In: Proceedings of the 40th Annual International Cryptology Conference. CRYPTO ’20. 2020, pp. 513–543.</li>

      <li>[AFGHO16] M. Abe, G. Fuchsbauer, J. Groth, K. Haralambiev, and M. Ohkubo. “Structure-Preserving Signatures and Commitments to Group Elements”. In: J. Cryptology 29.2 (2016), pp. 363–421.</li>

      <li>[BB08] D. Boneh and X. Boyen. “Short Signatures Without Random Oracles and the SDH Assumption in Bilinear Groups”. In: J. Cryptology 21.2 (2008), pp. 149–177.</li>

      <li>[BBBPWM18] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 315–334.</li>

      <li>[BCCGP16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BCCT13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. “Recursive Composition and Bootstrapping for SNARKs and Proof-Carrying Data”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 111–120.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCGMMW20] S. Bowe, A. Chiesa, M. Green, I. Miers, P. Mishra, and H. Wu. “ZEXE: Enabling Decentralized Private Computation”. In: Proceedings of the 41st IEEE Symposium on Security and Privacy. S&P ’20. 2020.</li>

      <li>[BCGT13] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. “Fast reductions from RAMs to delegatable succinct constraint satisfaction problems: extended abstract”. In: ITCS. ACM, 2013, pp. 401–414.</li>

      <li>[BCGTV13] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. “SNARKs for C: Verifying Program Executions Succinctly and in Zero Knowledge”. In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO ’13. 2013, pp. 90–108.</li>

      <li>[BCMS20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. “Proof-Carrying Data from Accumulation Schemes”. In: Proceedings of the 17th Theory of Cryptography Conference. TCC ’20. 2020, To appear.</li>

      <li>[BCTV14a] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: Proceedings of the 34th Annual International Cryptology Conference. CRYPTO ’14. Extended version at http://eprint.iacr.org/2014/595. 2014, pp. 276–294.</li>

      <li>[BCTV14b] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture”. In: Proceedings of the 23rd USENIX Security Symposium. USENIX Security ’14. Extended version at http://eprint.iacr.org/2013/879. 2014, pp. 781–796.</li>

      <li>[BDK13] M. Backes, A. Datta, and A. Kate. “Asynchronous Computational VSS with Reduced Communication Complexity”. In: Proceedings of the Cryptographers’ Track at the RSA Conference 2013. CT-RSA ’13. 2013, pp. 259–276.</li>

      <li>[BDN18] D. Boneh, M. Drijvers, and G. Neven. “Compact Multi-signatures for Smaller Blockchains”. In: Proceedings of the 24th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’18. 2018, pp. 435–464.</li>

      <li>[BEGKN91] M. Blum, W. S. Evans, P. Gemmell, S. Kannan, and M. Naor. “Checking the Correctness of Memories”. In: FOCS. IEEE Computer Society, 1991, pp. 90–99.</li>

      <li>[Ben+14] E. Ben-Sasson et al. “Zerocash: Decentralized Anonymous Payments from Bitcoin”. In: Proceedings of the 2014 IEEE Symposium on Security and Privacy. SP ’14. 2014, pp. 459–474.</li>

      <li>[BFS20] B. Bünz, B. Fisch, and A. Szepieniec. “Transparent SNARKs from DARK Compilers”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020.</li>

      <li>[BG13] S. Bayer and J. Groth. “Zero-Knowledge Argument for Polynomial Evaluation with Application to Blacklists”. In: Proceedings of 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques,the Advances in Cryptology. EUROCRYPT ’13. 2013, pp. 646–663.</li>

      <li>[BGH19] S. Bowe, J. Grigg, and D. Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. 2019.</li>

      <li>[BGLS03] D. Boneh, C. Gentry, B. Lynn, and H. Shacham. “Aggregate and Verifiably Encrypted Signatures from Bilinear Maps”. In: Advances in Cryptology - EUROCRYPT 2003, International Conference on the Theory and Applications of Cryptographic Techniques, Warsaw, Poland, May 4-8, 2003, Proceedings. 2003, pp. 416–432.</li>

      <li>[BLS01] D. Boneh, B. Lynn, and H. Shacham. “Short Signatures from the Weil Pairing”. In: Proceedings of the 7th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’01. 2001, pp. 514–532.</li>

      <li>[BMRS20] J. Bonneau, I. Meckler, V. Rao, and E. Shapiro. Coda: Decentralized Cryptocurrency at Scale. Cryptology ePrint Archive, Report 2020/352. 2020.</li>

      <li>[BR93] M. Bellare and P. Rogaway. “Random Oracles are Practical: A Paradigm for Designing Efficient Protocols”. In: Proceedings of the 1st ACM Conference on Computer and Communications Security. CCS ’93. 1993, pp. 62–73.</li>

      <li>[CDHK15] J. Camenisch, M. Dubovitskaya, K. Haralambiev, and M. Kohlweiss. “Composable and Modular Anonymous Credentials: Definitions and Practical Constructions”. In: Proceedings of the 21st International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’15. 2015, pp. 262–288.</li>

      <li>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020.</li>

    </ul>

    <p class="text-gray-300">[COS20] A. Chiesa, D. Ojha, and N. Spooner. “Fractal: Post-quantum and Transparent Recursive Proofs from Holography”. In: Advances in Cryptology - EUROCRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part I. 2020, pp. 769–793.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[FHS19] G. Fuchsbauer, C. Hanser, and D. Slamanig. “Structure-Preserving Signatures on Equivalence Classes and Constant-Size Anonymous Credentials”. In: Journal of Cryptology 32.2 (2019), pp. 498–546.</li>

      <li>[Fis18] B. Fisch. PoReps: Proofs of Space on Useful Data. Cryptology ePrint Archive, Report 2018/678. 2018.</li>

      <li>[Fis19] B. Fisch. “Tight Proofs of Space and Replication”. In: Proceedings of the 39th Annual Cryptology Conference. CRYPTO ’19. 2019, pp. 324–348.</li>

      <li>[FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. “The Algebraic Group Model and its Applications”. In: Proceedings of the 38th Annual International Cryptology Conference. CRYPTO ’18. 2018, pp. 33–62.</li>

      <li>[Gab19] A. Gabizon. Improved prover efficiency and SRS size in a Sonic-like system. Cryptology ePrint Archive, Report 2019/601. 2019.</li>

      <li>[GGW18] K. Gurkan, A. Gabizon, and Z. Williamson. Cheon’s attack and its effect on the security of big trusted setups. https://ethresear.ch/t/cheons-attack-and-its-effect-on-the-security-of-big-trusted-setups/6692. 2018.</li>

      <li>[GKMMM18] J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. “Updatable and Universal Common Reference Strings with Applications to zk-SNARKs”. In: Proceedings of the 38th Annual International Cryptology Conference. CRYPTO ’18. 2018, pp. 698–728.</li>

      <li>[GPS08] S. D. Galbraith, K. G. Paterson, and N. P. Smart. “Pairings for cryptographers”. In: Discrete Applied Mathematics 156.16 (2008), pp. 3113–3121.</li>

      <li>[Gro11] J. Groth. “Efficient Zero-Knowledge Arguments from Two-Tiered Homomorphic Commitments”. In: Proceedings of the 17th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’11. 2011, pp. 431–448.</li>

      <li>[Gro16] J. Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[GS08] J. Groth and A. Sahai. “Efficient Non-interactive Proof Systems for Bilinear Groups”. In: Proceedings of the 27th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’08. 2008, pp. 415–432.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive, Report 2019/953. 2019.</li>

      <li>[HKR19] M. Hoffmann, M. Klooß, and A. Rupp. “Efficient Zero-Knowledge Arguments in the Discrete Log Setting, Revisited”. In: Proceedings of the 26th ACM Conference on Computer and Communications Security. CCS ’19. 2019, pp. 2093–2110.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’10. 2010, pp. 177–194.</li>

      <li>[LMR19] R. W. F. Lai, G. Malavolta, and V. Ronge. “Succinct Arguments for Bilinear Group Arithmetic: Practical Structure-Preserving Cryptography”. In: Proceedings of the 26th ACM Conference on Computer and Communications Security. CCS ‘19. 2019, pp. 2057–2074.</li>

      <li>[LY10] B. Libert and M. Yung. “Concise Mercurial Vector Commitments and Independent Zero-Knowledge Sets with Short Proofs”. In: Proceedings of the 7th Theory of Cryptography Conference. TCC ’10. 2010, pp. 499–517.</li>

      <li>[MBKM19] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. “Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updatable Structured Reference Strings”. In: Proceedings of the 26th ACM Conference on Computer and Communications Security. CCS ’19. 2019, pp. 2111–2128.</li>

      <li>[MJ16] N. E. Mrabet and M. Joye. Guide to Pairing-Based Cryptography. 2016.</li>

    </ul>

    <p class="text-gray-300">[O’L18] R. O’Leary. Monero to Become First Billion-Dollar Crypto to Implement ‘Bulletproofs’ Tech. https://www.coindesk.com/monero-to-become-first-billion-dollar-crypto-to-implement-bulletproofs-tech. 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Ped92] T. P. Pedersen. “Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing”. In: Proceedings of the 11th Annual International Cryptology Conference. CRYPTO ’91. 1992, pp. 129–140.</li>

      <li>[Pip80] N. Pippenger. “On the Evaluation of Powers and Monomials”. In: SIAM Journal on Computing 9.2 (1980), pp. 230–250.</li>

      <li>[RY07] T. Ristenpart and S. Yilek. “The Power of Proofs-of-Possession: Securing Multiparty Signatures against Rogue-Key Attacks”. In: Proceedings of the 26th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’07. 2007, pp. 228–245.</li>

      <li>[SCI] SCIPR Lab. zexe: a Rust library for decentralizd private computation. url: https://github.com/scipr-lab/zexe.</li>

      <li>[Set20] S. Setty. “Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup”. In: Proceedings of the 40th Annual International Cryptology Conference. CRYPTO ’20. 2020, pp. 704–737.</li>

      <li>[Whi] B. Whitehat. Roll up: Scale Ethereum with SNARKs. url: https://github.com/barryWhiteHat/roll_up.</li>

      <li>[WTSTW18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. “Doubly-Efficient zkSNARKs Without Trusted Setup”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 926–943.</li>

      <li>[WZCPS18] H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica. “DIZK: A Distributed Zero Knowledge Proof System”. In: Proceedings of the 27th USENIX Security Symposium. USENIX Security ’18. 2018, pp. 675–692.</li>

      <li>[XYZW16] J. Xu, A. Yang, J. Zhou, and D. S. Wong. “Lightweight Delegatable Proofs of Storage”. In: Proceedings of the 21st European Symposium on Research in Computer Security. ESORICS ’16. 2016, pp. 324–343.</li>

      <li>[XZZPS19] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. “Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019.</li>

      <li>[ZXZS20] J. Zhang, T. Xie, Y. Zhang, and D. Song. “Transparent Polynomial Delegation and Its Applications to Zero Knowledge Proof”. In: Proceedings of the 41st IEEE Symposium on Security and Privacy. S&P ’20. 2020, pp. 859–876.</li>

    </ul>

    <p class="text-gray-300">A Preliminaries</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">A.1 Bilinear groups</h3>

    <p class="text-gray-300">The cryptographic primitives that we construct in this paper rely on cryptographic assumptions about bilinear groups. We formalize these via a <em>bilinear group sampler</em>, which is an efficient algorithm <span class="math">\\mathsf{SampleGrp}</span> that given a security parameter <span class="math">\\lambda</span> (represented in unary), outputs a tuple <span class="math">\\langle\\mathsf{group}\\rangle=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},q,g,h,e)</span> where <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span> are groups with order divisible by the prime <span class="math">q\\in\\mathbb{N}</span>, <span class="math">g</span> generates <span class="math">\\mathbb{G}_{1}</span>, <span class="math">h</span> generates <span class="math">\\mathbb{G}_{2}</span>, and <span class="math">e\\colon\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is a (non-degenerate) bilinear map.</p>

    <p class="text-gray-300">Galbraith et al. distinguish between three types of bilinear group samplers in <em>[x10]</em>. Type I groups have <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span> and are known as <em>symmetric</em> bilinear groups. Types II and III are <em>asymmetric</em> bilinear groups, where <span class="math">\\mathbb{G}_{1}\\neq\\mathbb{G}_{2}</span>. Type II groups have an efficiently computable homomorphism <span class="math">\\psi:\\mathbb{G}_{2}\\to\\mathbb{G}_{1}</span>, while Type III groups do not have an efficiently computable homomorphism in either direction. Certain assumptions are provably false w.r.t. certain group types (e.g., <span class="math">\\mathsf{SXDH}</span> only holds for Type III groups), and in general in this work we assume we are working with working with a Type III groups. We will write <span class="math">\\mathsf{SampleGrp}_{3}</span> to explicitly denote a bilinear group sampler that outputs Type III groups.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">A.2 Interactive arguments of knowledge</h3>

    <p class="text-gray-300">An <em>interactive argument of knowledge</em> for a relation <span class="math">\\mathcal{R}</span> is defined by an efficient non-interactive setup algorithm <span class="math">\\mathsf{Setup}</span> and a pair of efficient interactive algorithms <span class="math">(\\mathsf{Prove},\\mathsf{Verify})</span> that work as follows</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda})\\to\\mathsf{crs}</span>: the generator algorithm takes as input a security parameter <span class="math">\\lambda</span> (in unary) and outputs a common reference string <span class="math">\\mathsf{crs}</span>.</li>

      <li><span class="math">\\langle\\mathsf{Prove}(\\mathsf{w}),\\mathsf{Verify}\\rangle(\\mathsf{crs},\\mathbbm{x})</span>: the prover and verifier get as common input a set of public parameters <span class="math">\\mathsf{crs}</span> and an instance <span class="math">\\mathbbm{x}</span>. The prover also gets a witness <span class="math">\\mathsf{w}</span> for <span class="math">\\mathbbm{x}</span> as private input. The interaction begins with a prover message <span class="math">\\alpha_{0}</span>, to which the verifier responds with a challenge <span class="math">\\beta_{1}</span>. The prover and verifier exchange messages until the prover sends its final message <span class="math">\\alpha_{r}</span>. The verifer then outputs a bit <span class="math">b\\leftarrow\\mathsf{Verify}(\\mathsf{crs},\\mathbbm{x},\\alpha_{0},\\beta_{1},\\ldots,\\beta_{r},\\alpha_{r})</span>, where <span class="math">b=1</span> if the verifier accepts and <span class="math">b=0</span> if the verifier rejects.</li>

    </ul>

    <p class="text-gray-300">and satisfy completeness and knowledge-soundness, as defined below. We say an interactive proving protocol is <em>public-coin</em> when all verifier messages are uniformly chosen from some challenge set <span class="math">\\mathcal{C}</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Definition 5 (Perfectly complete argument).</h6>

    <p class="text-gray-300">We say <span class="math">(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify})</span> has perfect completeness when for all <span class="math">(\\mathbbm{x},\\mathsf{w})\\in\\mathcal{R}</span> it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\big{[}\\ \\langle\\mathsf{Prove}(\\mathsf{w}),\\mathsf{Verify}\\rangle(\\mathsf{crs},\\mathbbm{x})=1\\ \\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\ \\mathsf{crs}\\leftarrow\\mathsf{Setup}(1^{\\lambda})\\ \\big{]}=1\\ \\ .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 6 (Knowledge-sound argument).</h6>

    <p class="text-gray-300">We say <span class="math">\\Pi=(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify})</span> has knowledge-error <span class="math">\\kappa(\\lambda)</span> if for each efficient prover <span class="math">\\tilde{\\mathcal{P}}</span> there exists an efficient extractor <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span> such that for all efficient adversaries <span class="math">\\mathcal{A}</span> it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c}\\mathsf{tr}\\text{ is accepting }&amp;\\mathsf{crs}\\leftarrow\\mathsf{Setup}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\land&amp;(\\mathbbm{x},\\mathsf{tr})\\leftarrow\\langle\\tilde{\\mathcal{P}},\\mathsf{Verify}\\rangle(\\mathsf{crs})\\\\ (\\mathbbm{x},\\mathsf{w})\\notin\\mathcal{R}&amp;\\mathsf{w}\\leftarrow\\mathcal{E}^{\\tilde{\\mathcal{P}}}(\\mathsf{crs},\\mathbbm{x},\\mathsf{tr})\\end{array}\\right]\\leq\\kappa(\\lambda)\\ \\ , \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span> has black-box access to each of the next-message functions of <span class="math">\\tilde{\\mathcal{P}}</span> (i.e., it may “rewind” <span class="math">\\tilde{\\mathcal{P}}</span>). We say <span class="math">\\Pi</span> has computational knowledge-soundness when <span class="math">\\kappa(\\lambda)</span> is negligible. When <span class="math">\\tilde{\\mathcal{P}}</span> and <span class="math">\\mathcal{A}</span> are not required to be efficient, but <span class="math">\\kappa(\\lambda)</span> is still negligible, we say <span class="math">\\Pi</span> has statistical knowledge-soundness.</p>

    <p class="text-gray-300">##</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Special soundness.</h4>

    <p class="text-gray-300">We consider a notion of knowledge-soundness called <em>special soundness</em>, also known as special knowledge-soundess. In the theory of <span class="math">\\Sigma</span>-protocols, we say a interactive proof system has special soundness when there exists an efficient extraction algorithm that, given common reference string <span class="math">\\mathsf{crs}</span>, instance <span class="math">\\mathbbm{x}</span>, and two accepting transcripts <span class="math">(\\alpha_{0},\\beta_{1},\\alpha_{1})</span> and <span class="math">(\\alpha_{0},\\beta_{1}^{\\prime},\\alpha_{1}^{\\prime})</span> for <span class="math">(\\mathsf{pp},\\mathbbm{x})</span> where <span class="math">\\beta_{1}\\neq\\beta_{1}^{\\prime}</span> (a “collision”), outputs a witness <span class="math">\\mathbbm{w}</span>. Sometimes this property is called <span class="math">2</span>-special soundness. We consider a generalization of this notion for <span class="math">(2r+1)</span>-message protocols when proving the knowledge-soundness of <span class="math">\\mathsf{GIPA}</span>.</p>

    <p class="text-gray-300">First, we define a <span class="math">(k_{1},\\ldots,k_{r})</span>-tree of accepting transcripts. In the <span class="math">2</span>-special soundness case above, we presented constraints for a <span class="math">2</span>-tree of accepting transcripts. A <span class="math">(k_{1},\\ldots,k_{r})</span>-tree of accepting transcripts is composed of <span class="math">K:=\\prod_{i\\in[r]}k_{i}</span> accepting transcripts <span class="math">(\\alpha_{0},\\beta_{1,j},\\alpha_{1,j},\\ldots,\\beta_{r,j},\\alpha_{r,j})</span> for a parameters-instance pair <span class="math">(\\mathsf{pp},\\mathbbm{x})</span>, arranged in a tree structure. The root of the <span class="math">(k_{1},\\ldots,k_{r})</span>-tree is labeled with the public parameters <span class="math">\\mathsf{pp}</span>, instance <span class="math">\\mathbbm{x}</span>, and prover first message <span class="math">\\alpha_{0}</span>. Each node of depth <span class="math">1\\leq i\\leq r</span> is labeled with some prover message <span class="math">\\alpha_{i,j}</span>, <span class="math">1\\leq j\\leq\\prod_{i\\in[i]}k_{i}</span>. Besides the leaves, which are labeled with final prover messages, each node and has <span class="math">k_{i+1}</span> children, the edges to which are labeled with <em>distinct</em> values for the verifier challenge <span class="math">\\beta_{i+1}</span>. (Note that set of edges below two different nodes may share a common challenge, but the edges below any particular internal node must be distinct.) When for an interactive argument system <span class="math">\\Pi</span> there exists an efficient extractor that always succeeds in extracting a witness for <span class="math">\\mathbbm{x}</span> given a <span class="math">(k_{1},\\ldots,k_{r})</span>-tree of accepting transcripts for <span class="math">\\mathbbm{x}</span>, we say that <span class="math">\\Pi</span> is <span class="math">(k_{1},\\ldots,k_{r})</span>-special sound.</p>

    <p class="text-gray-300">The following Forking Lemma due to Attema and Cramer <em>[x1]</em> shows that <span class="math">(k_{1},\\ldots,k_{r})</span>-special soundness implies knowledge soundness and is used to prove Theorem 1, that <span class="math">\\mathsf{GIPA}</span> is knowledge sound when instantiated with a binding inner product argument.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 1 (Forking Lemma <em>[x1, Lemma 3]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Prove},\\mathsf{Verify})</span> be a <span class="math">(k_{1},\\ldots,k_{r})</span>-special sound <span class="math">(2r+1)</span>-move, public-coin interactive protocol for a relation <span class="math">\\mathcal{R}</span>, where <span class="math">\\mathsf{Verify}</span> samples challenges uniformly from a space of size <span class="math">q</span>. Let <span class="math">\\mathbbm{x}\\in\\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span> and let <span class="math">\\tilde{\\mathcal{P}}</span> be a prover such that <span class="math">\\langle\\tilde{\\mathcal{P}},\\mathsf{Verify}\\rangle(\\mathbbm{x})</span> accepts with probability <span class="math">\\epsilon(\\mathbbm{x})&gt;\\mu</span>, where</p>

    <p class="text-gray-300"><span class="math">\\mu=\\frac{\\sum_{i=1}^{r}(k_{i}-1)q^{r-i}\\prod_{j=1}^{i-1}(q-k_{j}+1)}{q^{r}}\\leq\\frac{\\sum_{i=1}^{r}(k_{i}-1)}{q}\\enspace.</span></p>

    <p class="text-gray-300">Then there exists an efficient extractor <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span> with black box access to each of the next-message functions of <span class="math">\\tilde{\\mathcal{P}}</span>, that outputs a witness <span class="math">\\mathbbm{w}</span> for <span class="math">\\mathbbm{x}</span> with probability at least <span class="math">(\\epsilon(\\mathbbm{x})-\\mu)^{K}</span> in at most <span class="math">K</span> runs of each of the next-message functions of <span class="math">\\tilde{\\mathcal{P}}</span>, where <span class="math">K=\\prod_{i=1}^{r}k_{i}</span>.</p>

    <p class="text-gray-300">We briefly discuss how this lemma implies Definition 6. Most of the proof of Lemma 1 involves showing it’s possible to efficiently construct a <span class="math">(k_{1},\\ldots,k_{r})</span>-tree of accepting transcripts for an instance <span class="math">\\mathbbm{x}</span> with probability at least <span class="math">(\\epsilon(\\mathbbm{x})-\\mu)^{K}</span> using an adversary <span class="math">\\tilde{\\mathcal{P}}</span> that succeeds with probability <span class="math">\\epsilon(\\mathbbm{x})&gt;\\mu</span>. At the end of the proof the extractor promised by the definition of <span class="math">(k_{1},\\ldots,k_{r})</span>-special soundness is then used as a subroutine, thus proving the lemma.</p>

    <p class="text-gray-300">To account for a <span class="math">\\mathsf{Setup}</span> algorithm, we observe that if we instead run <span class="math">\\tilde{\\mathcal{P}}</span> and <span class="math">\\mathsf{Verify}</span> on joint input <span class="math">\\mathsf{crs}</span> and let <span class="math">\\mathbbm{x}</span> be part of the first prover message, then given an adversary <span class="math">\\tilde{\\mathcal{P}}</span> that succeeds with probability <span class="math">\\epsilon(\\mathsf{crs})&gt;\\mu</span> we can build an accepting <span class="math">(k_{1},\\ldots,k_{r})</span>-tree of transcripts for <span class="math">\\mathsf{crs}</span> with probability at least <span class="math">(\\epsilon(\\mathsf{crs})-\\mu)^{K}</span>. Since every transcript in an accepting <span class="math">(k_{1},\\ldots,k_{r})</span>-tree of transcripts for <span class="math">\\mathsf{crs}</span> has the same first prover message and thus <span class="math">\\mathbbm{x}</span>, we indeed have obtained an accepting <span class="math">(k_{1},\\ldots,k_{r})</span>-tree of transcripts for <span class="math">(\\mathsf{crs},\\mathbbm{x})</span>.</p>

    <p class="text-gray-300">Next, we note that if given the transcript <span class="math">\\mathsf{tr}</span> of an honest execution and the random coins used by <span class="math">\\tilde{\\mathcal{P}}</span> when interacting with the challenger running <span class="math">\\mathsf{Verify}</span> as in Definition 6, then the extractor can use that transcript as the left-most branch of the transcript tree. The left-most branch is the first branch that extractor constructs in the lemma of Attema and Cramer—meaning that if <span class="math">\\mathsf{tr}</span> doesn’t accept, then <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span> immediately aborts, and if <span class="math">\\mathsf{tr}</span> accepts, then <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span> proceeds to try to build the rest of the transcript tree for <span class="math">(\\mathsf{crs},\\mathbbm{x})</span>, using the same coins when</p>

    <p class="text-gray-300">running  <span class="math">\\tilde{\\mathcal{P}}</span> . Since  <span class="math">\\mathrm{tr}</span>  is the result of the execution of  <span class="math">\\tilde{\\mathcal{P}}</span>  on independently random verifier challenges, and this is exactly how the extractor of Attema and Cramer builds each branch, it follows the rest of the tree can be built with probability at least  <span class="math">(\\epsilon (\\mathrm{crs}) - \\mu)^K</span> .</p>

    <p class="text-gray-300">Finally, we note that with the expectation taken over  <span class="math">\\mathsf{crs} \\gets \\mathsf{Setup}(1^{\\lambda})</span> , that</p>

    <div class="my-4 text-center"><span class="math-block">E \\left[ \\left(\\epsilon (\\mathsf {c r s}) - \\mu\\right) ^ {K} \\right] \\geq E \\left[ \\left(\\epsilon (\\mathsf {c r s}) - \\mu\\right) \\right] ^ {K} = \\left(E \\left[ \\epsilon (\\mathsf {c r s}) \\right] - \\mu\\right) ^ {K} = \\left(\\epsilon (\\lambda) - \\mu\\right) ^ {K},</span></div>

    <p class="text-gray-300">where the first inequality follows from Jensen's inequality. Thus, given a prover  <span class="math">\\tilde{\\mathcal{P}}</span>  for Definition 6 that succeeds with probability  <span class="math">\\epsilon (\\lambda)</span> , we obtain an extractor  <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}}</span>  with knowledge error  <span class="math">\\kappa \\leq \\epsilon (\\lambda) - (\\epsilon (\\lambda) - \\mu)^{K}</span> . It follows that every  <span class="math">(k_{1},\\ldots ,k_{r})</span> -special sound interactive public-coin protocol with challenge space size  <span class="math">q</span>  exponential in  <span class="math">\\lambda</span>  and with  <span class="math">K\\in \\mathrm{poly}(\\lambda)</span>  is knowledge-sound. Since the transcript tree extractors we build in our proofs extract either witnesses for the relation or commitment binding breaks, whether an inner product proof is statistically or computationally knowledge-sound corresponds to whether its inner product commitment is perfectly or computationally binding.</p>

    <p class="text-gray-300">Non-interactive argument of knowledge in the ROM. We define a non-interactive argument of knowledge in the random oracle model. The non-interactive argument is an argument system where the prover sends a single message  <span class="math">\\pi</span> , and the verifier using the proof accepts or rejects. Both the prover and verifier have access to a random oracle  <span class="math">\\rho</span> . An argument of knowledge in the ROM has the property that for each convincing prover there exists an extractor which can rewind the prover and reinitialize the random oracle with new randomness.</p>

    <p class="text-gray-300">Definition 7 (Non interactive argument of knowledge in the RO). We say that a non-interactive argument is an argument of knowledge with knowledge error  <span class="math">\\kappa(\\lambda)</span>  if for every adversary  <span class="math">\\tilde{\\mathcal{P}}</span>  there exists an extractor  <span class="math">\\mathcal{E}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathcal {V} ^ {\\rho} (\\mathsf {c r s}, \\mathbb {x}, \\pi) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ (\\mathbb {x}, \\mathbb {w}) \\notin \\mathcal {R} &amp;amp; (\\mathbb {x}, \\pi) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathsf {c r s}) \\\\ &amp;amp; \\mathbb {w} \\leftarrow \\mathcal {E} ^ {\\tilde {\\mathcal {P}}, \\rho} (\\mathsf {c r s}, \\mathbb {x}, \\pi) \\end{array} \\right] \\leq \\kappa (\\lambda)</span></div>

    <p class="text-gray-300">The  <span class="math">\\mathcal{E}</span>  can rewind the prover and reinitialize the random oracle (but not program it). Additionally if  <span class="math">\\tilde{\\mathcal{P}}</span>  is algebraic [FKL18] then the extractor will have access to the representations of group elements that the  <span class="math">\\tilde{\\mathcal{P}}</span>  outputs.</p>

    <p class="text-gray-300">Zero-Knowledge. Bootle et al. [BCCGP16] define an argument as honest verifier zero-knowledge (HVZK) if there exists an efficient simulator that can simulate transcripts generated between an honest prover and an honest verifier when given only a valid instance and not the corresponding witness for a NP relation  <span class="math">\\mathcal{R}</span> . The Fiat-Shamir transform turns an interactive public-coin HVZK argument into a non-interactive argument with zero-knowledge even against malicious verifier. The simulator is modeled as having access to the verifier's challenges in advance.</p>

    <p class="text-gray-300">Definition 8 (Perfect honest verifier zero-knowledge argument). An argument system (Setup, Prove, Verify) for a relation  <span class="math">\\mathcal{R}</span>  is honest verifier zero-knowledge (HVZK) if there exists an efficient simulator  <span class="math">S</span>  such that for all adversaries  <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span>  it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\mathbb {x}, \\mathbb {w}) \\in \\mathcal {R} &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; (\\mathbb {x}, \\mathbb {w}, \\rho) \\leftarrow \\mathcal {A} _ {0} (\\mathsf {c r s}) \\\\ \\mathcal {A} _ {1} (\\mathsf {t r}) = 1 &amp;amp; \\mathsf {t r} \\leftarrow \\langle \\mathsf {P r o v e} (\\mathbb {w}), \\mathsf {V e r i f y} _ {\\rho} \\rangle (\\mathsf {c r s}, \\mathbb {x}) \\end{array} \\right] = \\Pr \\left[ \\begin{array}{c c} (\\mathbb {x}, \\mathbb {w}) \\in \\mathcal {R} &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; (\\mathbb {x}, \\mathbb {w}, \\rho) \\leftarrow \\mathcal {A} _ {0} (\\mathsf {c r s}) \\\\ \\mathcal {A} _ {1} (\\mathsf {t r}) = 1 &amp;amp; \\mathsf {t r} \\leftarrow \\mathcal {S} (\\mathsf {c r s}, \\mathbb {x}; \\rho) \\end{array} \\right]</span></div>

    <p class="text-gray-300">where  <span class="math">\\rho</span>  is the public-coin randomness used by the verifier.</p>

    <p class="text-gray-300">A.3 Commitments</p>

    <p class="text-gray-300">A commitment scheme for a message space <span class="math">\\mathcal{M}</span> consists of a pair of efficient algorithms <span class="math">(\\text{Setup},\\text{CM})</span> that work as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Setup}(1^{\\lambda}) \\to \\text{ck}</span>: a setup algorithm that, given a security parameter <span class="math">\\lambda</span> (represented in unary), outputs a commitment key <span class="math">\\text{ck}</span>. The commitment key implicitly contains the security parameter and a description of the message and key spaces.</li>

      <li><span class="math">\\text{CM}(\\text{ck}; M; r) \\mapsto C</span>: a commitment algorithm that, given a commitment key <span class="math">\\text{ck} \\in \\mathcal{K}</span>, (optionally) a random string <span class="math">r</span> of a prescribed length, and a message <span class="math">M \\in \\mathcal{M}</span>, outputs a commitment <span class="math">C</span>.</li>

    </ul>

    <p class="text-gray-300">When the commitment scheme is deterministic we write <span class="math">\\text{CM}(\\text{ck}; M)</span>. We denote <span class="math">\\text{CM}(\\text{ck}; M) \\xrightarrow{\\</span>} C<span class="math"> to mean that the commitment algorithm first samples </span>r<span class="math"> uniformly at random and then computes </span>\\text{CM}(\\text{ck}; M; r)$.</p>

    <p class="text-gray-300">We require that a commitment scheme satisfies binding (i.e., no adversary can open the same commitment to two different messages).</p>

    <p class="text-gray-300"><strong>Definition 9 (Computationally binding commitment).</strong> A commitment scheme <span class="math">(\\text{Setup},\\text{CM})</span> is computationally binding if for all efficient adversaries <span class="math">\\mathcal{A}</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{Pr} \\left[ \\begin{array}{c c c} \\text{CM}(\\text{ck}; M_0; r_0) = \\text{CM}(\\text{ck}; M_1; r_1) \\wedge M_0 \\neq M_1 &amp;amp; \\text{ck} \\leftarrow \\text{Setup}(1^{\\lambda}) \\\\ &amp;amp; (M_0, r_0, M_1, r_1) \\leftarrow \\mathcal{A}(\\text{ck}, \\mathcal{M}) \\\\ \\end{array} \\right] \\leq \\operatorname{negl}(\\lambda) . \\\\ \\operatorname{Pr} \\left[ \\begin{array}{c c c} \\text{CM}(\\text{ck}; M_0; r_0) = 0 \\wedge M_0 \\neq 0 &amp;amp; \\text{ck} \\leftarrow \\text{Setup}(1^{\\lambda}) \\\\ &amp;amp; (M_0, r_0, M_1, r_1) \\leftarrow \\mathcal{A}(\\text{ck}, \\mathcal{M}) \\\\ \\end{array} \\right] \\leq \\operatorname{negl}(\\lambda) . \\end{array}</span></div>

    <p class="text-gray-300">We say the commitment is statistically binding if this probability holds for all (even unbounded) adversaries <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Some of our commitment schemes must also satisfy hiding (i.e., the commitment scheme is randomised such that no adversary can distinguish which of two messages a commitment contains).</p>

    <p class="text-gray-300"><strong>Definition 10 (Perfectly hiding commitment).</strong> A commitment scheme <span class="math">(\\text{Setup},\\text{CM})</span> is perfectly hiding if for all non-uniform adversaries <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c c} &amp;amp; \\text{ck} \\leftarrow \\text{Setup}(1^{\\lambda}) \\\\ b = b&#x27; &amp;amp; (M_0, M_1) \\leftarrow \\mathcal{A}_0(\\text{ck}, \\mathcal{M}) \\\\ &amp;amp; b \\stackrel{\\$}{\\leftarrow} \\{0, 1\\}, \\quad C \\stackrel{\\$}{\\leftarrow} \\text{CM}(\\text{ck}; M_b) \\\\ &amp;amp; &amp;amp; b&#x27; \\leftarrow \\mathcal{A}_2(C) \\end{array} \\right] = \\frac{1}{2} .</span></div>

    <p class="text-gray-300">A.4 Polynomial commitments</p>

    <p class="text-gray-300">Polynomial commitments (PCs) are commitments for the message space <span class="math">\\mathbb{F}^{\\leq d}[X]</span>, the ring of polynomials in <span class="math">X</span> with maximum degree <span class="math">d \\in \\mathbb{N}</span> and coefficients in <span class="math">\\mathbb{F}</span>, that support an interactive argument of knowledge <span class="math">(\\text{Setup}, \\text{Open}, \\text{Check})</span> for proving the correct evaluation of a committed polynomial at a given point without revealing any other information about the committed polynomial.</p>

    <p class="text-gray-300">A polynomial commitment scheme over a field family <span class="math">\\mathcal{F}</span> is a 4-tuple of efficient algorithms <span class="math">\\mathsf{PC} = (\\text{Setup}, \\text{CM}, \\text{Open}, \\text{Check})</span> with the following interface</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Setup}(1^{\\lambda}, d) \\to (\\text{ck}, \\text{vk})</span>: a setup algorithm that, given a field and a maximum degree, samples a group description <span class="math">\\langle \\text{group} \\rangle</span> containing a description of a field <span class="math">\\mathbb{F} \\in \\mathcal{F}</span>, and commitment and verification keys <span class="math">(\\text{ck}, \\text{vk})</span>. We implicitly assume ck and vk each contain <span class="math">\\langle \\text{group} \\rangle</span>.</li>

    </ul>

    <p class="text-gray-300">37</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{CM}(\\mathsf{ck};f(X);r)\\to C</span> : a commitment algorithm that, given commitment key <span class="math">\\mathsf{ck}</span> and polynomial <span class="math">f(X)\\in \\mathbb{F}^{\\leq d}[X]</span>, outputs a commitment <span class="math">C</span>.</li>

      <li><span class="math">(\\mathsf{Setup},\\mathsf{Open}(\\mathsf{ck};C,x,\\nu ,f(X);r),\\mathsf{Check}(\\mathsf{vk};C,x,\\nu))</span> is an interactive AoK with respect to the relation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\nu} = \\left\\{ \\begin{array}{c c} &amp;amp; C = \\mathsf {C M} (\\mathsf {c k}; f (X); r) \\\\ (\\mathsf {c k}, C, x, \\nu ; r, f (X) \\in \\mathbb {F} [ X ]) : &amp;amp; \\wedge \\deg (f (X)) \\leq d \\\\ &amp;amp; \\wedge f (x) = \\nu \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">and satisfying extractability and hiding as defined below. When the polynomial commitment scheme is deterministic we write <span class="math">\\mathsf{CM}(\\mathsf{ck};f(X))</span>. We denote <span class="math">\\mathsf{PC.CM}(\\mathsf{ck};f(X))\\xrightarrow{\\S}C</span> to mean that the commitment algorithm first samples <span class="math">r</span> randomly and then computes <span class="math">\\mathsf{CM}(\\mathsf{ck};f(X);r)</span>.</p>

    <p class="text-gray-300"><strong>Definition 11 (Computationally extractable polynomial commitment).</strong> A polynomial commitment <span class="math">\\mathsf{PC} = (\\mathsf{Setup},\\mathsf{CM},\\mathsf{Open},\\mathsf{Check})</span> is computationally extractable if <span class="math">(\\mathsf{Setup},\\mathsf{CM})</span> is a computationally binding commitment scheme (Definition 9) and <span class="math">(\\mathsf{Setup},\\mathsf{Open},\\mathsf{Check})</span> is a computationally knowledge-sound AoK (Definition 6).</p>

    <p class="text-gray-300"><strong>Definition 12 (Perfectly hiding polynomial commitment).</strong> A polynomial commitment <span class="math">\\mathsf{PC} = (\\mathsf{Setup},\\mathsf{CM},\\mathsf{Open},\\mathsf{Check})</span> is perfectly hiding if <span class="math">(\\mathsf{Setup},\\mathsf{CM})</span> is a perfectly hiding commitment scheme (Definition 10) and <span class="math">(\\mathsf{Setup},\\mathsf{Open},\\mathsf{Check})</span> satisfies perfect honest verifier zero-knowledge (Definition 8).</p>

    <h2 id="sec-53" class="text-2xl font-bold">A.5 Cryptographic assumptions</h2>

    <p class="text-gray-300">Our trusted inner product protocols use commitment schemes with structured keys. The security of these commitment schemes hold under a new assumption we call the computational <span class="math">q</span>-Auxiliary Structured Double Pairing assumption, which holds in the GGM.</p>

    <p class="text-gray-300"><strong>Assumption 1</strong> (<span class="math">q</span>-Auxiliary Structured Double Pairing assumption (<span class="math">q</span>-ASDBP)). We say the <span class="math">q</span>-ASDBP assumption holds relative to <span class="math">\\mathsf{SampleGrp}_3</span> if for any efficient algorithm <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} (A _ {0}, \\ldots , A _ {q - 1}) \\neq \\mathbf {1} _ {\\mathbb {G} _ {1}} &amp;amp; \\langle \\mathsf {g r o u p} \\rangle \\leftarrow \\mathsf {S a m p l e G r p} _ {3} (1 ^ {\\lambda}); \\beta \\stackrel {\\S} {\\leftarrow} \\mathbb {F} \\\\ \\wedge 1 _ {\\mathbb {G} _ {T}} = \\prod_ {i = 0} ^ {q - 1} e (A _ {i}, h ^ {\\beta^ {2 i}}) &amp;amp; (A _ {0}, \\ldots , A _ {q - 1}) \\leftarrow \\mathcal {A} (\\langle \\mathsf {g r o u p} \\rangle , g ^ {\\beta}, [ h ^ {\\beta^ {2 i}} ] _ {i = 1} ^ {q - 1}) \\end{array} \\right] \\leq \\mathrm {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">More specifically, we refer to this as the <span class="math">q\\text{-ASDBP}_{\\mathbb{G}_2}</span> assumption and also define its dual, the <span class="math">q\\text{-ASDBP}_{\\mathbb{G}_1}</span> assumption, by swapping <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> in the definition above. Observe that in this assumption it is essential that the adversary does not see <span class="math">g^{\\beta^2}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> The <span class="math">q</span>-ASDBP assumption holds in the generic group model.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose <span class="math">\\mathcal{A}</span> is an adversary that on input <span class="math">\\langle \\mathrm{group} \\rangle, h_1, \\ldots, h_q</span>, outputs <span class="math">A_0, \\ldots, A_{q-1}</span> such that <span class="math">\\prod_{i=0}^{q-1} e(A_i, h^{\\beta^{2i}}) = 1</span>. Then its GGM extractor outputs <span class="math">\\{a_{2i}, a_{2i+1}\\}</span> such that <span class="math">A_i = g^{a_{2i} + a_{2i+1}\\beta}</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 0} ^ {q - 1} \\left(a _ {2 i} + a _ {2 i + 1} X\\right) X ^ {2 i} = 0.</span></div>

    <p class="text-gray-300">Thus</p>

    <div class="my-4 text-center"><span class="math-block">a _ {0} + a _ {1} X + a _ {2} X ^ {2} + a _ {3} X ^ {3} + \\dots + a _ {2 q - 2} X ^ {2 q - 2} + a _ {2 q - 1} X ^ {2 q - 1} = 0.</span></div>

    <p class="text-gray-300">As a result, <span class="math">a_{i} = 0</span> for all <span class="math">0\\leq i\\leq 2q - 1</span> and <span class="math">A_{i} = g^{0} = 1_{\\mathbb{G}_{1}}</span>.</p>

    <p class="text-gray-300">We use Boneh and Boyen’s <span class="math">q</span>-<span class="math">\\mathsf{SDH}</span> assumption <em>[x1]</em> when proving the security of our TIPP scheme.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Assumption 2 (<span class="math">q</span>-Strong Diffie-Hellman assumption (<span class="math">q</span>-<span class="math">\\mathsf{SDH}</span>).</h6>

    <p class="text-gray-300">We say the <span class="math">q</span>-Strong Diffie-Hellman assumption holds relative to <span class="math">\\mathsf{SampleGrp_{3}}</span> if for any efficient algorithm <span class="math">\\mathcal{A}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[\\begin{array}[]{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cc}A=h^{\\frac{1}{\\beta-n}}&\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\langle\\mathsf{group}\\rangle\\leftarrow\\mathsf{SampleGrp_{3}}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\\\ \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\end{array}\\right.\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array}\\right]\\leq\\mathop{\\mathrm{negl}}(\\lambda)\\enspace. \\]</p>

    <h2 id="sec-55" class="text-2xl font-bold">Appendix B Verifiable computation for inner pairing products (<span class="math">\\mathsf{SIPP}</span>)</h2>

    <p class="text-gray-300">In this section we introduce a Statistically sound Inner Pairing Product (<span class="math">\\mathsf{SIPP}</span>) proof system. By running <span class="math">\\mathsf{SIPP}</span>, a prover can produce a publicly verifiable proof of the correct computation of an inner pairing product with respect to two public, length-<span class="math">m</span> vectors of source group elements. <span class="math">\\mathsf{SIPP}</span> requires no setup and is public-coin.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SIPP}</span> can also be used to outsource the verification a large number of pairing equations. Those pairing equations need to be folded into a single pairing equation by taking a linear combination of the equations (e.g., using the small exponent test).</p>

    <p class="text-gray-300">Verification of a <span class="math">\\mathsf{SIPP}</span> proof requires computing a multi-exponentiation of size <span class="math">m</span> in each source group, which can be computed in <span class="math">O(m/\\log m)</span> time. This is asymptotically faster than direct computation, which requires <span class="math">m</span> <span class="math">\\mathbb{G}_{1}</span> exponentiations, <span class="math">n</span> Miller loops, and a final target group exponentiation. Proofs are <span class="math">2\\log m</span> target group elements and the prover computes <span class="math">2m</span> pairings and <span class="math">m</span> <span class="math">\\mathbb{G}_{1}</span> exponentiations.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">B.1 Construction</h3>

    <p class="text-gray-300"><span class="math">\\mathsf{SIPP}</span> is a proof system for the membership in the following language:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathsf{SIPP}}=\\{(\\bm{A}\\in\\mathbb{G}_{1}^{m},\\bm{r}\\in\\mathbb{F}^{m},\\enspace\\bm{B}\\in\\mathbb{G}_{2}^{m},\\enspace Z\\in\\mathbb{G}_{T})\\;:\\enspace Z=\\bm{A^{r}}*\\bm{B}\\}\\enspace.</span></p>

    <p class="text-gray-300">The proof is an instantiation of <span class="math">\\mathsf{GIPA}</span> using the identity commitment</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}(\\bm{A},\\bm{B},\\bm{A}<em>\\bm{B})\\rightarrow\\bm{A},\\bm{B},\\bm{A}</em>\\bm{B}</span></p>

    <p class="text-gray-300">Since the verifier already has access to the <span class="math">\\bm{A}</span> and <span class="math">\\bm{B}</span> values the prover does not in fact have to send these. In each round of the protocol the prover simply sends <span class="math">Z_{L}</span> an <span class="math">Z_{R}</span> which are two target group elements. The prover and verifier then both use the challenge <span class="math">x</span> in order to rescale the vectors <span class="math">\\bm{A}</span> and <span class="math">\\bm{B}</span>. In the final step the verifier needs to perform only a single pairing in order to verify the proof.</p>

    <p class="text-gray-300">Pseudocode. We give pseudocode for our protocol in Fig. 14.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">B.2 Efficiency</h3>

    <p class="text-gray-300">In the first round the prover computes <span class="math">Z_{L},Z_{R}</span> using <span class="math">m</span> pairings. This halves to <span class="math">m/2</span> in the second and <span class="math">n/2^{i}</span> in the <span class="math">i</span>-th. Over <span class="math">\\log(m)</span> rounds the prover computes <span class="math">2m</span> pairings in total. The prover also requires a total of <span class="math">m</span> exponentiations (over <span class="math">\\log m</span> rounds) in each source group to update <span class="math">\\bm{A}^{\\prime}</span> and <span class="math">\\bm{B}^{\\prime}</span> values. The proof consists of the <span class="math">Z_{L},Z_{R}</span> values in each round, making the total proof size <span class="math">2\\log m</span> <span class="math">\\mathbb{G}_{T}</span> elements.</p>

    <p class="text-gray-300">In each round, the verifier performs <span class="math">2</span> target group exponentiations to update <span class="math">Z^{\\prime}</span> for a total of <span class="math">2\\log(m)</span> <span class="math">\\mathbb{G}_{T}</span> exponentiations. The computation of <span class="math">\\bm{A}^{\\prime}</span> and <span class="math">\\bm{B}^{\\prime}</span> for the verifier can be delayed until the final round. They then compute a size-<span class="math">m</span> multi-exponentiation in each source group to obtain the final <span class="math">A^{\\prime}</span> and <span class="math">B^{\\prime}</span>. Using these</p>

    <p class="text-gray-300">!<a href="img-22.jpeg">img-22.jpeg</a> Figure 14: A RBR sound protocol for outsourcing pairings.</p>

    <p class="text-gray-300">values the verifier performs a single pairing to check  <span class="math">Z&#x27; = e(A&#x27;, B&#x27;)</span> . Note that if  <span class="math">A</span>  and  <span class="math">B</span>  are themselves the result of exponentiations then the verifier can combine these exponentiations with the final computation of  <span class="math">A&#x27;</span>  and  <span class="math">B&#x27;</span> . This happens when batch verifying pairings or for accountable multi signatures [BDN18].</p>

    <p class="text-gray-300">SIPP is an instantiation of GIPA using the perfectly binding identity commitment. Theorems 1 and 2 show that the interactive variant of SIPP is statistically sound and that the non-interactive Fiat-Shamir transform of SIPP is sound in the random oracle and algebraic group model.</p>

    <p class="text-gray-300">We implemented the SIPP protocol in Rust, based on efficient elliptic curve and finite field libraries. Our implementation utilizes Pippenger's fast multi-exponentiation algorithm [Pip80] to speed up the verifier's computation. We also implemented standard optimizations for direct computation of pairing products [MJ16, Section 11.4.2]. In the direct computation implementation, we first compute the product of the results of each Miller loop, then perform the final target group exponentiation on that product to obtain the inner pairing product.</p>

    <p class="text-gray-300">We evaluated our implementation on a machine with an Intel Xeon 6136 CPU at  <span class="math">3.0\\mathrm{GHz}</span> . Our experiments relied on the efficient BLS12-377 elliptic curve [BCGMMW20]. As noted in Fig. 15, our evaluation demonstrates that using the SIPP verifier becomes faster than direct computation the pairing product at roughly 128 pairings. Our experiments also validate the asymptotic superiority of the verifier: the gap between direct computation and verification widens as the number of pairings increases. For example, at  <span class="math">2^{20}</span>  pairings, our verifier is roughly  <span class="math">8\\times</span>  faster than directly computing the pairing product.</p>

    <p class="text-gray-300">!<a href="img-23.jpeg">img-23.jpeg</a> (a) Ratio of the time to compute a direct pairing product to the time to verify a SIPP for that computation.</p>

    <p class="text-gray-300">!<a href="img-24.jpeg">img-24.jpeg</a> (b) Running time of the SIPP algorithms compared to the time to directly compute the pairing product. Figure 15: Measured performance of SIPP compared to the cost of directly computing the pairing product on the BLS12-377 elliptic curve [BCGMMW20]. Experiments were performed on a machine with an Intel Xeon 6136 CPU at  <span class="math">3.0\\mathrm{GHz}</span> .</p>

    <p class="text-gray-300">Boneh, Lynn, and Shacham introduced the BLS signature scheme in [BLS01]. Boneh, Gentry, Lynn, and Shacham later extended this scheme by showing how to accomplish offline aggregation of signatures and keys in [BGLS03]. This is different from aggregate Schnorr signatures [BR93], which require signers to remain online throughout the signing process. In this section we describe an alternative aggregate signature scheme based on BLS, where the verifier is required to compute just one pairing for any number of signatures. Previous aggregate signature schemes based on BLS including [BGLS03; RY07; BDN18] have constant-sized  <span class="math">(\\mathcal{O}_{\\lambda}(1))</span>  aggregate signatures and require computing  <span class="math">n + 1</span>  pairings to verifying an aggregate signature over  <span class="math">n</span>  distinct messages. Our scheme trades off space for time, requiring the verifier compute just 1 pairing and one  <span class="math">n</span> -sized multi-exponentiation in each of the source groups at the cost of a logarithmic-sized signature.</p>

    <p class="text-gray-300">The basic BLS signature scheme is given in Fig. 16. Our description is given over Type III bilinear groups as opposed to the original scheme which was described only over the less efficient Type I bilinear groups.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup(1λ) return ⟨group⟩ ← SampleGrp3(1λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KeyGen(⟨group⟩) sk ←8 pk ← gsk return (pk, sk)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sign(⟨group⟩, sk, M): h ∈ G2 ← RO2(M) return σ ← hsk</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(⟨group⟩, pk, M, σ) h ∈ G2 ← RO2(M) return e(g, σ) = e(pk, h)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 16: The BLS signature scheme where  <span class="math">\\mathsf{RO}_2:\\{0,1\\}^*\\to \\mathbb{G}_2</span>  is a random oracle.</p>

    <p class="text-gray-300">We introduce a pair of algorithms (AggSign, VerifyAgg) that extends the BLS signature scheme into a aggregate signature scheme. These algorithms make use SIPP.Prove and SIPP.Verify, respectively, as subroutines. The aggregator AggSign is given a group description  <span class="math">\\langle \\text{group} \\rangle</span> , a list of public keys  <span class="math">[\\mathsf{pk}_i]_{i=1}^n</span> , a set of distinct messages  <span class="math">\\{M_i\\}_{i=1}^n</span> , and a list of signatures  <span class="math">[\\sigma_i]_{i=1}^n</span> . The aggregator begins by computing  <span class="math">\\sigma_A = \\prod_i \\sigma_i</span> . Next, they use SIPP.Prove to produce a proof  <span class="math">\\pi</span>  that</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(g ^ {- 1}, \\sigma_ {A}\\right) \\cdot \\prod_ {i = 1} ^ {n} e \\left(\\mathrm {p k} _ {i}, \\mathrm {R O} _ {2} \\left(M _ {i}\\right)\\right) = 1.</span></div>

    <p class="text-gray-300">The aggregator returns  <span class="math">\\Sigma \\gets (\\sigma_A,\\pi)</span></p>

    <p class="text-gray-300">The verifier running VerifyAgg is given group description  <span class="math">\\langle \\text{group} \\rangle</span> , public keys  <span class="math">[\\mathsf{pk}_i]_{i=1}^n</span> , distinct messages  <span class="math">\\{M_i\\}_{i=1}^n</span> , and aggregate signature  <span class="math">\\Sigma</span> . The verifier then has the full inputs it needs to run SIPP.Verify, and outputs the result of checking the inner pairing product proof.</p>

    <p class="text-gray-300">Pseudocode. We present pseudocode for our BLS aggregation protocol in Fig. 17.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AggSign(⟨group⟩, [pk_i]i=1, {Mi}i=1, [σi]i=1): (h1, ..., hn) ← (RO2(Mi), ..., RO2(Mn)) σA ← ∏i=1n σi π ← SIPP.Prove(⟨group⟩, g-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pk, σA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h, 1) Σ ← (σA, π) return Σ</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VerifyAgg(⟨group⟩, [pk_i]i=1, {Mi}i=1, Σ): (σA, π) ← Σ (h1, ..., hn) ← (RO2(M1), ..., RO2(Mn)) return SIPP.Verify(⟨group⟩, g-1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk, σA</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">h, 1, π)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 17: Aggregation and verification algorithms for an aggregate signature scheme.</p>

    <p class="text-gray-300">Verifying  <span class="math">n</span>  signatures on  <span class="math">n</span>  different messages using VerifyAgg requires computing  <span class="math">n</span>  hashes and then running SIPP.Verify. Running AggSign requires  <span class="math">n</span>  hash evaluations and a call to SIPP.Prove. Ignoring small constant terms, the prover computes a total of  <span class="math">2n</span>  pairings,  <span class="math">n</span>  exponentiations in each source group, and  <span class="math">n</span>  hashes. The verifier computes a single pairing,  <span class="math">n</span>  exponentiations in each source group,  <span class="math">2\\log (n)</span>  target group exponentiations, and  <span class="math">n</span>  hashes. The aggregate signatures consists of  <span class="math">2\\log (n)</span>  elements in  <span class="math">\\mathbb{G}_T</span>  and 1 element in  <span class="math">\\mathbb{G}_2</span> .</p>

    <p class="text-gray-300">In this section we present various proofs promised in the main body of this work.</p>

    <p class="text-gray-300">We prove Theorem 1, showing that GIPA has perfect completeness and knowledge-soundness if  <span class="math">((\\mathsf{Setup},\\mathsf{CM}),*)</span>  is a binding inner product commitment.</p>

    <p class="text-gray-300">Proof. Completeness follows directly from the doubly-homomorphic and collapsing properties of CM. The double homomorphism implies a distributive property between keys and messages. For ease of notation for  <span class="math">m \\in [2^i]_{i \\in \\mathbb{Z}^+}</span>  we let  <span class="math">m&#x27; = m/2</span> ,  <span class="math">L = [:m&#x27;]</span> ,  <span class="math">R = [m&#x27;:]</span> ,  <span class="math">\\mathsf{ck}_L = (\\mathsf{ck}_{1,L}, \\mathsf{ck}_{2,L}, \\mathsf{ck}_3)</span> ,  <span class="math">\\mathsf{ck}_R = (\\mathsf{ck}_{1,R}, \\mathsf{ck}_{2,R}, \\mathsf{ck}_3)</span> ,  <span class="math">M_{1,L} = \\pmb{a}_{[:m&#x27;]}</span> ,  <span class="math">M_{1,R} = \\pmb{a}_{[m&#x27;:]}</span> ,  <span class="math">M_{2,L} = \\pmb{b}_{[:m&#x27;]}</span> , and  <span class="math">M_{2,R} = \\pmb{b}_{[m&#x27;:]}</span> . Also let  <span class="math">\\mathbf{0}</span>  be the vector containing  <span class="math">m&#x27;</span>  sequential group identity elements for the appropriate group. We prove perfect completeness by showing that in each round if  <span class="math">C = \\mathsf{CM}(\\mathsf{ck}; (\\pmb{a}, \\pmb{b}, \\langle \\pmb{a}, \\pmb{b} \\rangle))</span>  then  <span class="math">C&#x27; = \\mathsf{CM}(\\mathsf{ck}&#x27;; (\\pmb{a}&#x27;, \\pmb{b}&#x27;, \\langle \\pmb{a}&#x27;, \\pmb{b}&#x27; \\rangle))</span> . First observe that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x·CL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x·CM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ck1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M1,R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ck1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">xM1,R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M2,L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x·ck2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M2,L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck3</td>

            <td class="px-3 py-2 border-b border-gray-700">(M1,R,M2,L)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck3</td>

            <td class="px-3 py-2 border-b border-gray-700">(M1,R,xM2,L)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">CM</td>

            <td class="px-3 py-2 border-b border-gray-700">ck1</td>

            <td class="px-3 py-2 border-b border-gray-700">M1,L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M1,R</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">CM</td>

            <td class="px-3 py-2 border-b border-gray-700">ck1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">xM1,R</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck2</td>

            <td class="px-3 py-2 border-b border-gray-700">M2,L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M2,R</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x·ck2</td>

            <td class="px-3 py-2 border-b border-gray-700">M2,L</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck3</td>

            <td class="px-3 py-2 border-b border-gray-700">(M1,L,M2,L)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck3</td>

            <td class="px-3 py-2 border-b border-gray-700">(xM1,R,x-1M2,R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x-1·CR</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">x-1·CM</td>

            <td class="px-3 py-2 border-b border-gray-700">ck1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M1,L</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">CM</td>

            <td class="px-3 py-2 border-b border-gray-700">x-1·ck1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M1,L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck2</td>

            <td class="px-3 py-2 border-b border-gray-700">M2,R</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x-1M2,R</td>

            <td class="px-3 py-2 border-b border-gray-700">x-1M2,R</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ck3</td>

            <td class="px-3 py-2 border-b border-gray-700">(M1,L,M2,R)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x-1M2,R</td>

            <td class="px-3 py-2 border-b border-gray-700">x-1M2,R</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Second observe that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} x \\cdot C _ {L} + C _ {L} ^ {\\prime} = \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {c k} _ {1} &amp; x M _ {1, R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {0} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle x M _ {1, R}, M _ {2, L} \\rangle \\end{array} \\right) + \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {c k} _ {1} &amp; M _ {1, L} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {0} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle M _ {1, L}, M _ {2, L} \\rangle \\end{array} \\right) \\\\ = \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {c k} _ {1} &amp; M _ {1, L} + x M _ {1, R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {0} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle M _ {1, L} + x M _ {1, L} ^ {\\prime}, M _ {2, L} \\rangle \\end{array} \\right) \\\\ \\end{array} $$</p>

    <p class="text-gray-300">$$ \\begin{array}{l} x ^ {- 1} \\cdot C _ {R} + C _ {R} ^ {\\prime} = \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x ^ {- 1} \\cdot \\mathsf {c k} _ {1} &amp; \\mathbf {0} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {1, L} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle M _ {1, L}, x ^ {- 1} M _ {2, R} \\rangle \\end{array} \\right) + \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x ^ {- 1} \\cdot \\mathsf {c k} _ {1} &amp; \\mathbf {0} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x M _ {1, R} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle x M _ {1, R}, x ^ {- 1} M _ {2, R} \\rangle \\end{array} \\right) \\\\ = \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x ^ {- 1} \\cdot \\mathsf {c k} _ {1} &amp; \\mathbf {0} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {1, L} + x M _ {1, R} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle M _ {1, L} + x M _ {1, R}, x ^ {- 1} M _ {2, R} \\rangle \\end{array} \\right) \\\\ \\end{array} $$</p>

    <p class="text-gray-300">Because our commitment scheme is doubly homomorphic, for all  <span class="math">\\mathsf{ck}, M</span>  we have that  <span class="math">\\mathsf{CM}(\\mathsf{ck}; \\mathbf{0}) = \\mathsf{CM}(\\mathbf{0}; M) = 1</span> . Thus  <span class="math">x \\cdot C_L + C_L&#x27;</span>  is equal to</p>

    <p class="text-gray-300">$$ \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {c k} _ {1, L} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {0} &amp; M _ {1, L} + x M _ {1, R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {1, L} + x M _ {1, R} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle M _ {1, L} + x M _ {1, R}, M _ {2, L} \\rangle \\end{array} \\right) $$</p>

    <p class="text-gray-300">and  <span class="math">x^{-1}\\cdot C_R + C_R&#x27;</span>  is equal to</p>

    <p class="text-gray-300">$$ \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {0} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x ^ {- 1} \\cdot \\mathsf {c k} _ {1, R} &amp; M _ {1, L} + x M _ {1, R} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {1, L} + x M _ {1, R} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle M _ {1, L} + x M _ {1, R}, x ^ {- 1} M _ {2, R} \\rangle \\end{array} \\right) $$</p>

    <p class="text-gray-300">Hence we have that  <span class="math">x \\cdot C_L + C + x^{-1} \\cdot C_R</span>  is given by</p>

    <p class="text-gray-300">$$ \\mathsf {C M} \\left( \\begin{array}{l l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {c k} _ {1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x ^ {- 1} \\cdot \\mathsf {c k} _ {1} ^ {\\prime} &amp; M _ {1, L} + x M _ {1, L} ^ {\\prime} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {1, L} + x M _ {1, L} ^ {\\prime} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf {c k} _ {3} &amp; \\langle M _ {1, L} + x M _ {1, R}, M _ {2, L} + x ^ {- 1} M _ {2, R} \\rangle \\end{array} \\right) $$</p>

    <p class="text-gray-300">Finally observe that because our commitment scheme is collapsing we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {C o l l a p s e} (x \\cdot C _ {L} + C + x ^ {- 1} \\cdot C _ {R}) = \\mathsf {C M} \\left( \\begin{array}{l l} \\mathsf {c k} _ {1} + x ^ {- 1} \\cdot \\mathsf {c k} _ {1} ^ {\\prime} &amp;amp; M _ {1, L} + x M _ {1, L} ^ {\\prime} \\\\ \\mathsf {c k} _ {2} + x \\cdot \\mathsf {c k} _ {2} ^ {\\prime} &amp;amp; M _ {2, L} + x ^ {- 1} M _ {2, R} \\\\ \\mathsf {c k} _ {3} &amp;amp; \\langle M _ {1, L} + x M _ {1, L} ^ {\\prime}, M _ {2, L} + x ^ {- 1} M _ {2, R} \\rangle \\end{array} \\right)</span></div>

    <p class="text-gray-300">completing the proof</p>

    <p class="text-gray-300"><strong>Extraction.</strong> We show that GIPA is  <span class="math">(k_{1},\\ldots ,k_{\\log (m)})</span> -special sound, where  <span class="math">k_{i} = 4</span>  for  <span class="math">i\\in [\\log (m)]</span> , and then invoke Lemma 1 to conclude GIPA is knowledge-sound Definition 6. Given a  <span class="math">(k_{1},\\dots ,k_{\\log (m)})</span> -tree of valid transcripts for an instance  <span class="math">\\mathbb{x} = (\\mathsf{ck} = (\\mathsf{ck}_1,\\mathsf{ck}_2,\\mathsf{ck}_3),C)</span> , we show how to build an efficient extractor  <span class="math">\\mathcal{E}</span>  that always either outputs a witness for the relation  <span class="math">\\mathcal{R}_{\\mathrm{IPA}}</span>  or breaks the binding property of CM.</p>

    <p class="text-gray-300">See the discussion below Lemma 1 to see how it implies Definition 6.</p>

    <p class="text-gray-300">The extractor begins by computing the <span class="math">C</span> value for each node at height <span class="math">\\log(m) - 1</span> according to the transcript tree. The extractor computes a witness <span class="math">(\\mathbf{a}, \\mathbf{b}) \\in \\mathcal{M}_1^2 \\times \\mathcal{M}_2^2</span> for each such <span class="math">C</span> using the <span class="math">(C_L, C_R)</span> prover message labeling the node corresponding to <span class="math">C</span>, the four final prover messages labeling its child leaf nodes, and the four distinct challenges labeling the edges to those leaves. This procedure is carried out recursively until a witness for the root node is obtained.</p>

    <p class="text-gray-300">Given four pairs of "partially recovered witnesses" <span class="math">\\mathbf{a}^{(i)} \\in \\mathcal{M}_1^{m&#x27;}</span> and <span class="math">\\mathbf{b}^{(i)} \\in \\mathcal{M}_2^{m&#x27;}</span> for <span class="math">i \\in [4]</span> from four sibling nodes at depth <span class="math">d</span>, the extractor computes a partial witness <span class="math">(\\mathbf{a}, \\mathbf{b}) \\in \\mathcal{M}_1^m \\times \\mathcal{M}_2^m</span> corresponding to their parent node at depth <span class="math">d - 1</span>. Let <span class="math">x_1, x_2, x_3, x_4 \\in \\mathbb{Z}_q</span> be the distinct challenge values from the edges above each child. Let the <span class="math">C_L, C_R \\in \\operatorname{Image}(\\mathsf{CM})</span> values be those corresponding to their parent node. Let <span class="math">C \\in \\operatorname{Image}(\\mathsf{CM}), \\operatorname{ck}_1 \\in \\mathcal{K}_1^m</span>, and <span class="math">\\operatorname{ck}_2 \\in \\mathcal{K}_2^m</span> be the values the verifier would have computed according to the transcript tree path to the parent node and let <span class="math">\\operatorname{ck}_1^{(i)} \\in \\mathcal{K}_1^{m&#x27;}</span> and <span class="math">\\operatorname{ck}_2^{(i)} \\in \\mathcal{K}_2^{m&#x27;}</span> for <span class="math">i \\in [4]</span> be the values the verifier would have computed according to the path to each of the children. We know for the base case of <span class="math">d = \\log(m)</span>, where the initial partial witnesses <span class="math">(a^{(i)}, b^{(i)}) \\in \\mathcal{M}_1 \\times \\mathcal{M}_2</span> are taken from leaf nodes, it holds for all <span class="math">i \\in [4]</span> that</p>

    <p class="text-gray-300">$$ \\begin{aligned} x_i \\cdot C_L + C + x_i^{-1} \\cdot C_R &amp;= \\mathsf{CM} \\left( \\begin{array}{ll} \\mathsf{ck}_1^{(i)} &amp; \\mathbf{a}^{(i)} \\\\ \\mathsf{ck}_2^{(i)} &amp; \\mathbf{b}^{(i)} \\\\ \\mathsf{ck}_3 &amp; \\langle \\mathbf{a}^{(i)}, \\mathbf{b}^{(i)} \\rangle \\end{array} \\right) \\\\ &amp;= \\mathsf{CM} \\left( \\begin{array}{ll} \\mathsf{ck}_{1,[:m']} + x_i^{-1} \\cdot \\mathsf{ck}_{1,[m':]} &amp; \\mathbf{a}^{(i)} \\\\ \\mathsf{ck}_{2,[:m']} + x_i \\cdot \\mathsf{ck}_{2,[m':]} &amp; \\mathbf{b}^{(i)} \\\\ \\mathsf{ck}_3 &amp; \\langle \\mathbf{a}^{(i)}, \\mathbf{b}^{(i)} \\rangle \\end{array} \\right) \\\\ &amp;= \\mathsf{CM} \\left( \\begin{array}{ll}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ck}_1 &amp; \\mathbf{a}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i^{-1} \\cdot \\mathbf{a}^{(i)} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{ck}_3 &amp; \\langle \\mathbf{a}^{(i)}, \\mathbf{b}^{(i)} \\rangle \\end{array} \\right) \\tag{3} \\end{aligned} $$</p>

    <p class="text-gray-300">since the transcripts are all accepting, and we assume it for the inductive case. Here Eq. (3) follows from the doubly homomorphic and concatenation properties of an inner product commitment.</p>

    <p class="text-gray-300">The extractor uses the first three challenges to compute <span class="math">\\nu_{1}, \\nu_{2}, \\nu_{3} \\in \\mathbb{Z}_{q}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [3]} \\nu_i \\cdot x_i = 1, \\quad \\sum_{i \\in [3]} \\nu_i = 0, \\quad \\sum_{i \\in [3]} \\nu_i \\cdot x_i^{-1} = 0.</span></div>

    <p class="text-gray-300">Then we can write <span class="math">C_L</span> as</p>

    <p class="text-gray-300">$$ \\begin{aligned} C_L &amp;= \\sum_{i \\in [3]} \\left(v_i \\cdot \\left(x_i \\cdot C_L + C + x_i^{-1} \\cdot C_R\\right)\\right) \\\\ &amp;= \\sum_{i \\in [3]} \\mathsf{CM} \\left( \\begin{array}{ll}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ck}_1 &amp; v_i \\cdot (\\mathbf{a}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i^{-1} \\cdot \\mathbf{a}^{(i)}) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} \\right) \\end{aligned} $$</p>

    <p class="text-gray-300">We define <span class="math">(\\mathbf{a}_L, \\mathbf{b}_L, z_L) \\in \\mathcal{M}_1^m \\times \\mathcal{M}_2^m \\times \\mathcal{M}_3</span> such that <span class="math">C_L = \\mathsf{CM}(\\mathsf{ck}_1, \\mathsf{ck}_2, \\mathsf{ck}_3; \\mathbf{a}_L, \\mathbf{b}_L, z_L)</span>. By using different systems of equations producing different <span class="math">\\nu_1, \\nu_2, \\nu_3 \\in \\mathbb{Z}_q</span>, we can use the same technique to find <span class="math">\\mathbf{a}_C, \\mathbf{b}_C, z_C</span> and <span class="math">\\mathbf{a}_R, \\mathbf{b}_R, z_R</span> such that it similarly holds <span class="math">C = \\mathsf{CM}(\\mathsf{ck}_1, \\mathsf{ck}_2, \\mathsf{ck}_3; \\mathbf{a}_C, \\mathbf{b}_C, z_C)</span> and <span class="math">C_R = \\mathsf{CM}(\\mathsf{ck}_1, \\mathsf{ck}_2, \\mathsf{ck}_3; \\mathbf{a}_R, \\mathbf{b}_R, z_R)</span>.</p>

    <p class="text-gray-300">Observe that for <span class="math">i \\in [4]</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block">x_i \\cdot C_L + C + x_i^{-1} \\cdot C_R</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = \\mathrm{CM} \\left(\\mathrm{ck}_1, \\mathrm{ck}_2, \\mathrm{ck}_3; (x_i \\cdot \\boldsymbol{a}_L + \\boldsymbol{a}_C + x_i^{-1} \\cdot \\boldsymbol{a}_R), (x_i \\cdot \\boldsymbol{b}_L + \\boldsymbol{b}_C + x_i^{-1} \\cdot \\boldsymbol{b}_R), (x_i \\cdot z_L + z_C + x_i^{-1} \\cdot z_R)\\right). \\end{array}</span></div>

    <p class="text-gray-300">Then by Eq. (3), the concatenation property of inner product commitments it holds either that for <span class="math">[i] \\in [4]</span></p>

    <div class="my-4 text-center"><span class="math-block">x_i \\cdot \\boldsymbol{a}_{L,[:m&#x27;]} + \\boldsymbol{a}_{C,[:m&#x27;]} + x_i^{-1} \\cdot \\boldsymbol{a}_{R,[:m&#x27;]} = \\boldsymbol{a}^{(i)}</span></div>

    <div class="my-4 text-center"><span class="math-block">x_i \\cdot \\boldsymbol{a}_{L,[m&#x27;:]} + \\boldsymbol{a}_{C,[m&#x27;:]} + x_i^{-1} \\cdot \\boldsymbol{a}_{R,[m&#x27;:]} = x^{-1} \\cdot \\boldsymbol{a}^{(i)}</span></div>

    <div class="my-4 text-center"><span class="math-block">x_i \\cdot \\boldsymbol{b}_{L,[:m&#x27;]} + \\boldsymbol{b}_{C,[:m&#x27;]} + x_i^{-1} \\cdot \\boldsymbol{b}_{R,[:m&#x27;]} = \\boldsymbol{b}^{(i)}</span></div>

    <div class="my-4 text-center"><span class="math-block">x_i \\cdot \\boldsymbol{b}_{L,[m&#x27;:]} + \\boldsymbol{b}_{C,[m&#x27;:]} + x_i^{-1} \\cdot \\boldsymbol{b}_{R,[m&#x27;:]} = x_i \\cdot \\boldsymbol{b}^{(i)}</span></div>

    <div class="my-4 text-center"><span class="math-block">x_i \\cdot z_L + z_C + x_i^{-1} \\cdot z_R = \\langle \\boldsymbol{a}^{(i)}, \\boldsymbol{b}^{(i)} \\rangle,</span></div>

    <p class="text-gray-300">or that we can directly compute a break of the binding property of the commitment scheme. These equations imply for <span class="math">i \\in [4]</span> that</p>

    <div class="my-4 text-center"><span class="math-block">x_i^{-1} \\cdot \\boldsymbol{a}_{R,[:m&#x27;]} + (\\boldsymbol{a}_{C,[:m&#x27;]} - \\boldsymbol{a}_{R,[m&#x27;:]}) + x_i \\cdot (\\boldsymbol{a}_{L,[:m&#x27;]} - \\boldsymbol{a}_{C,[m&#x27;:]}) - x_i^2 \\cdot \\boldsymbol{a}_{L,[m&#x27;:]} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">x_i^{-2} \\cdot \\boldsymbol{b}_{R,[m&#x27;:]} + x_i^{-1} (\\boldsymbol{b}_{C,[m&#x27;:]} - \\boldsymbol{b}_{R,[m&#x27;]}) + (\\boldsymbol{b}_{L,[m&#x27;:]} - \\boldsymbol{b}_{C,[m&#x27;]}) - x_i \\cdot \\boldsymbol{b}_{L,[m&#x27;]} = 0.</span></div>

    <p class="text-gray-300">Since both of the polynomials above have at most 3 distinct roots and the 4 challenges are distinct, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{a}_{R,[:m&#x27;]} = \\boldsymbol{a}_{L,[m&#x27;:]} = \\boldsymbol{b}_{R,[m&#x27;:]} = \\boldsymbol{b}_{L,[m&#x27;]} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{a}_{C,[:m&#x27;]} = \\boldsymbol{a}_{R,[m&#x27;:]} \\quad \\boldsymbol{a}_{C,[m&#x27;:]} = \\boldsymbol{a}_{L,[m&#x27;]}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{b}_{C,[m&#x27;:]} = \\boldsymbol{b}_{R,[m&#x27;]} \\quad \\boldsymbol{b}_{C,[m&#x27;]} = \\boldsymbol{b}_{L,[m&#x27;:]}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">So $\\boldsymbol{a}_C = \\boldsymbol{a}_{R,[m':]}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{a}_{L,[m']}<span class="math"> and </span>\\boldsymbol{b}_C = \\boldsymbol{b}_{L,[m':]}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{b}_{R,[m']}<span class="math">. Finally, this means that for </span>i \\in [4]$ that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\langle \\boldsymbol{a}^{(i)}, \\boldsymbol{b}^{(i)} \\rangle = \\langle \\boldsymbol{a}_{C,[m&#x27;]} + x_i \\cdot \\boldsymbol{a}_{C,[m&#x27;:]}, \\boldsymbol{b}_{C,[m&#x27;]} + x_i^{-1} \\cdot \\boldsymbol{b}_{C,[m&#x27;:]} \\rangle = x_i \\cdot z_L + z_C + x_i^{-1} \\cdot z_R \\\\ \\Rightarrow x_i \\cdot \\left(\\left\\langle \\boldsymbol{a}_{C,[m&#x27;]}, \\boldsymbol{b}_{C,[m&#x27;:]} \\right\\rangle - z_L\\right) + \\left(\\left\\langle \\boldsymbol{a}_C, \\boldsymbol{b}_C \\right\\rangle - z_C\\right) + x_i^{-1} \\cdot \\left(\\left\\langle \\boldsymbol{a}_{C,[m&#x27;:]}, \\boldsymbol{b}_{C,[m&#x27;]} \\right\\rangle - z_R\\right) = 0. \\end{array}</span></div>

    <p class="text-gray-300">Again, since there are more distinct challenges than roots of the above polynomial, we conclude <span class="math">z_C = \\langle \\boldsymbol{a}_C, \\boldsymbol{b}_C \\rangle</span>, which in turn shows that <span class="math">C = \\mathsf{CM}(\\mathsf{ck}_1, \\mathsf{ck}_2, \\mathsf{ck}_3; \\boldsymbol{a}_C, \\boldsymbol{b}_C, z_C)</span> is in fact an inner product commitment for which the extractor has computed a witness.</p>

    <p class="text-gray-300">The extractor performs this recursive procedure <span class="math">\\sum_{i\\in [\\log (m) - 1]}4^{\\log (m) - i} &amp;lt; 4^{\\log (m)}</span> times and thus runs in <span class="math">O(m\\cdot 4^{\\log (m)})</span> time, meeting the efficiency requirements of Lemma 1.</p>

    <h2 id="sec-65" class="text-2xl font-bold">D.2 Non interactive argument in the algebraic commitment model.</h2>

    <p class="text-gray-300">We will show that the Fiat-Shamir transform GIPA is a non-interactive argument of knowledge</p>

    <p class="text-gray-300">We begin by defining an algebraic commitment model. This is a generalization of the algebraic group model for doubly homomorphic commitments (Definition 3). In particular, we assume that there exists an oracle <span class="math">\\mathcal{O}</span> that generates commitment keys <span class="math">\\mathsf{ck}_i \\in \\mathcal{K}</span>. Additionally, there exists an extractor <span class="math">\\mathcal{E}_{\\mathsf{CM}}</span> that given a commitment <span class="math">C \\in \\mathrm{Image}(\\mathsf{CM})</span> produces an opening <span class="math">M \\in \\mathcal{M}</span> with respect to <span class="math">\\mathsf{ck}^<em></span> such that <span class="math">\\mathsf{ck}^</em></span> is in the output list of <span class="math">\\mathcal{O}</span> and such that <span class="math">C = \\mathsf{CM}(\\mathsf{ck}^<em>, M)</span>. We can always force an adversary to use a particular commitment key <span class="math">\\mathsf{ck}&#x27;</span> by generating all other commitment keys <span class="math">\\mathsf{ck}^</em></span> as a function of <span class="math">\\mathsf{ck}&#x27;</span>. Note that if the commitment key space <span class="math">\\mathcal{K} \\subset \\mathbb{G}^n</span> and <span class="math">\\mathcal{M} \\subset \\mathbb{F}_p^n</span> then this corresponds to the algebraic group model [FKL18]. Additionally, for the SIPP protocol the commitment scheme is the identity function, i.e. the prover receives the committed values. This means that the algebraic commitment protocol is not an abstraction but in fact corresponds to the actual protocol.</p>

    <p class="text-gray-300">For an inner-product commitment (Definition 3) the algebraic commitment model says that there exists an extractor that extracts <span class="math">\\boldsymbol{a} \\in \\mathcal{M}_1^m, \\boldsymbol{b} \\in \\mathcal{M}_2^m, c \\in \\mathcal{M}^3</span> from a commitment <span class="math">C</span>, but not necessarily that <span class="math">\\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle = c</span>.</p>

    <p class="text-gray-300">Definition 13 (Fiat-Shamir Transform). Let  <span class="math">\\Pi_{\\mathsf{IP}} = (\\mathsf{Setup}_{\\mathsf{IP}}, \\mathcal{P}_{\\mathsf{IP}}, \\mathcal{V}_{\\mathsf{IP}})</span>  be an  <span class="math">r</span> -round public coin interactive argument of knowledge (Appendix A.2). Let  <span class="math">\\pi_i</span>  be the  <span class="math">i</span> th message by the prover and  <span class="math">\\mathcal{C}</span>  the challenge space. The Fiat-Shamir transform of  <span class="math">\\mathsf{IP}</span>  is the non-interactive argument  <span class="math">\\Pi_{\\mathsf{FS}} = (\\mathsf{Setup}_{\\mathsf{FS}}, \\mathcal{P}_{\\mathsf{FS}}, \\mathcal{V}_{\\mathsf{FS}}) = \\mathsf{FS} - \\mathsf{Transform}(\\Pi_{\\mathsf{IP}})</span>  where  <span class="math">\\mathsf{Setup}_{\\mathsf{FS}}</span>  runs  <span class="math">\\mathsf{crs}_{\\mathsf{IP}} \\gets \\mathsf{Setup}_{IP}(1^{\\lambda})</span>  and outputs  <span class="math">\\mathsf{crs}_{FS} = (\\mathsf{crs}_{\\mathsf{IP}}, \\mathsf{Hash})</span>  contains the description of a hash function  <span class="math">\\mathsf{Hash}: \\{0,1\\}^* \\to \\mathcal{C}</span>  and the first challenge  <span class="math">\\alpha_1</span>  is generated as  <span class="math">\\alpha_1 = \\mathsf{Hash}(\\pi, \\pi_1)</span>  and subsequent challenges as  <span class="math">\\alpha_i = \\mathsf{Hash}(\\alpha_{i-1}, \\pi_i)</span> . The Prover  <span class="math">\\mathcal{P}_{\\mathsf{FS}}</span>  runs  <span class="math">\\mathcal{P}_{\\mathsf{IP}}</span>  while simulating  <span class="math">\\mathcal{V}_{\\mathsf{IP}}</span>  by generating the challenges using  <span class="math">\\mathsf{Hash}</span>  as described above.  <span class="math">\\mathcal{P}_{\\mathsf{FS}}</span>  outputs the proof  <span class="math">\\pi = \\{\\pi_1, \\dots, \\pi_r\\}</span> .  <span class="math">\\mathcal{V}_{\\mathsf{FS}}</span>  generates the challenges from  <span class="math">\\pi</span>  using the hash function  <span class="math">\\mathsf{Hash}</span> . It then runs the decision procedure of  <span class="math">\\mathcal{V}_{\\mathsf{IP}}</span>  and using  <span class="math">\\pi</span>  and the generated challenges. It outputs the same decision bit as  <span class="math">\\mathcal{V}_{\\mathsf{IP}}</span> .</p>

    <p class="text-gray-300">We analyze the security of the Fiat-Shamir transform in the random oracle model, where Hash is replaced by a random function which is sampled from the space of all random functions  <span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span> . All algorithms and adversaries have oracle access to this function.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">(\\mathsf{Setup},\\mathsf{CM})</span>  be a commitment scheme. Fix a maximum degree  <span class="math">d\\in \\mathbb{N}</span> . Then for every family of functions  <span class="math">\\{f_{\\mathrm{ck}}\\}_{\\mathrm{ck}}</span>  and fields  <span class="math">\\{\\mathbb{F}_{\\mathrm{ck}}\\}_{\\mathrm{ck}}</span>  where  <span class="math">f_{\\mathrm{ck}}:\\mathcal{M}\\to \\mathbb{F}_{\\mathrm{ck}}^{\\leq d}[X]</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{\\mathrm{ck}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math"> ; for every efficient  </span>t<span class="math"> -query oracle algorithm  </span>\\mathcal{A}$ , the following holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ p \\not \\equiv 0 &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; M, r \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {c k}) \\\\ p (\\boldsymbol {z}) = 0 &amp;amp; C \\leftarrow \\mathsf {C M} (\\mathsf {c k}; M; r) \\\\ &amp;amp; \\boldsymbol {z} \\in \\mathbb {F} _ {\\mathsf {c k}} \\leftarrow \\rho (C) \\\\ &amp;amp; p \\leftarrow f _ {\\mathsf {c k}} (M) \\end{array} \\right] \\leq \\sqrt {(t + 1) \\cdot \\frac {d}{2 ^ {\\lambda}}} + \\mathrm {n e g l} (\\lambda) .</span></div>

    <p class="text-gray-300">If the commitment scheme is perfectly binding then this holds even against unbounded t-query adversaries.</p>

    <p class="text-gray-300">Proof. The prover produces an instance commitment  <span class="math">C</span>  and a proof  <span class="math">\\pi = \\{[C_L^{(i)} \\in \\mathsf{Image}(\\mathsf{CM}), C_R^{(i)} \\in \\mathsf{Image}(\\mathsf{CM})]_{i=1}^{\\log_2(m)}, a \\in \\mathbb{G}_1, b \\in \\mathbb{G}_2\\}</span> . If the verifier accepts the proof then the extractor  <span class="math">\\mathcal{E}</span>  simply extracts  <span class="math">a, b, c</span>  from the commitment and returns  <span class="math">a, b</span>  as a witness.</p>

    <p class="text-gray-300">We will now argue that the extractor succeeds with overwhelming probability, i.e. that  <span class="math">\\langle \\pmb{a},\\pmb{b}\\rangle = c</span></p>

    <p class="text-gray-300">Ensuring correct representations. We denote proof elements and extracted witnesses from round  <span class="math">i</span>  of the protocol with a  <span class="math">(i)</span>  superscript.</p>

    <p class="text-gray-300">Given that the adversary is algebraic we can compute vectors  <span class="math">\\pmb{a}_L^{(i)} \\in \\mathbb{G}_1^m, \\pmb{b}_L^{(i)} \\in \\mathbb{G}_2^m</span>  and scalar  <span class="math">c_L^{(i)} \\in \\mathbb{G}_T</span>  such that  <span class="math">C_{L,i} = \\mathsf{CM}(\\mathsf{ck}_1, \\mathsf{ck}_2, \\mathsf{ck}_3; \\pmb{a}_L, \\pmb{b}_{L,i}, c_{L,i})</span> . Similarly we can compute representations for each  <span class="math">C_{R,i}</span>  value. Additionally let  <span class="math">\\{x_1, \\ldots, x_{\\log_2(m)}\\}</span>  be the Fiat-Shamir challenges computed from the proof. Let  <span class="math">\\mathsf{ck}^{(i)} = (\\mathsf{ck}_1^{(i)}, \\mathsf{ck}_2^{(i)}, \\mathsf{ck}_3^{(i)})</span>  be the resulting commitment keys for each round computed from the original commitment key  <span class="math">\\mathsf{ck}</span>  and the respective challenges as in the protocol. Finally given the challenges and representations we can compute representations using the commitment key  <span class="math">\\mathsf{ck}</span>  of the intermediary round commitments  <span class="math">C^{(i+1)} = x_i^{-1} \\cdot C_L^{(i)} + C^{(i)} + x_i C_R^{(i)}</span> , with  <span class="math">C^{(1)} = C</span> .</p>

    <p class="text-gray-300">We will prove through induction that  <span class="math">C^{(i)}</span>  can be written as  <span class="math">\\mathsf{CM}(\\mathsf{ck}^{(i)};\\pmb{a}^{(i)},\\pmb{b}^{(i)},c^{(i)})</span>  for  <span class="math">\\pmb{a}^{(i)} \\in \\mathbb{G}_1^{m^{(i)}}, \\pmb{b}^{(i)} \\in \\mathbb{G}_2^{m^{(i)}}</span>  and  <span class="math">c^{(i)} \\in \\mathbb{G}_T</span>  and that  <span class="math">\\langle \\pmb{a}^{(i)},\\pmb{b}^{(i)}\\rangle = c^{(i)}</span> . Note that</p>

    <div class="my-4 text-center"><span class="math-block">C ^ {(\\log_ {2} (m) + 1)} = \\mathsf {C M} (\\mathsf {c k}; \\boldsymbol {a} ^ {(\\log_ {2} (m) + 1)}, \\boldsymbol {b} ^ {(\\log_ {2} (m) + 1)}, c ^ {(\\log_ {2} (m) + 1)}) = \\mathsf {C M} (\\mathsf {c k} ^ {(\\log_ {2} (m) + 1)}; a, b, a * b)</span></div>

    <p class="text-gray-300">. Now assuming that <span class="math">C^{(i+1)}=\\mathsf{CM}(\\mathsf{ck}^{(i+1)};\\bm{a}^{(i+1)},\\bm{b}^{(i+1)},c^{(i+1)})</span> and <span class="math">C^{(i+1)}=x_{i}^{-1}\\cdot C_{L}^{(i)}+C^{(i)}+x_{i}C_{R}^{(i)}</span> we will show that we can compute a proper representation for <span class="math">C^{(i)}</span> using commitment key <span class="math">\\mathsf{ck}^{(i)}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can write $C^{(i+1)}=\\mathsf{CM}(\\mathsf{ck}^{i};\\bm{a}^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}^{-1}\\bm{a}^{(i+1)},\\bm{b}^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}\\bm{b}^{(i+1)},c^{(i+1)})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\bm{h}^{(i)}\\in\\mathbb{F}_{p}^{2^{i-1}}</span> denote a vector such that <span class="math">\\mathsf{ck}^{i}_{1,j}=\\sum_{k=0}^{2^{i-1}-1}h_{k}^{(i)}\\mathsf{ck}_{1,j+k\\cdot 2^{1-i\\cdot}m}</span>. Each entry of <span class="math">\\bm{h}^{(i)}</span> is non zero and a function of the challenges <span class="math">x_{1},\\ldots,x_{i-1}</span> and <span class="math">h^{(1)}=1</span>. Now consider the three following exclusive scenarios: a) The representation with respect to <span class="math">\\mathsf{ck}</span> of <span class="math">C^{(i+1)}</span> computed from <span class="math">C_{L}^{(i)},C_{R}^{(i)}</span> and <span class="math">C^{(i)}</span> does not match the representation of <span class="math">C^{(i+1)}</span> computed from <span class="math">\\bm{a}^{(i+1)},\\bm{b}^{(i+1)},c^{(i+1)}</span>. This directly is a break of the binding property of <span class="math">\\mathsf{CM}</span>, which happens with at most negligible probability.</p>

    <p class="text-gray-300">b) The representations match but the representations of <span class="math">C_{L}^{(i)},C_{R}^{(i)},C^{(i)}</span> cannot be written using the commitment key <span class="math">\\mathsf{ck}^{(i)}</span>.</p>

    <p class="text-gray-300">Without loss of generality assume that <span class="math">\\mathsf{ck}^{(i)}_{1,k}</span> be one particular commitment key such that one of <span class="math">C_{L}^{(i)},C_{R}^{(i)},C^{(i)}</span> cannot be expressed using <span class="math">\\mathsf{ck}^{(i)}_{1,k}</span>. This means that there exist <span class="math">j,\\ell\\in[k,k+2^{1-i}\\cdot m,\\ldots,k+(1-2^{1-i})\\cdot m]</span> such that</p>

    <p class="text-gray-300"><span class="math">x_{i}\\cdot a_{L,j}^{(i)}+a_{C,j}^{(i)}+x_{i}^{-1}\\cdot a_{R,j}^{(i)}=h_{j}^{(i)}a_{k}^{(i+1)}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">x_{i}\\cdot a_{L,\\ell}^{(i)}+a_{C,\\ell}^{(i)}+x_{i}^{-1}\\cdot a_{R,\\ell}^{(i)}=h_{\\ell}^{(i)}a_{k}^{(i+1)}</span></p>

    <p class="text-gray-300">Further we can write <span class="math">a_{L,j}^{(i)}=h_{j}^{(i)}\\cdot\\bar{a}_{L,j}^{(i)}</span> and <span class="math">a_{L,\\ell}^{(i)}=h_{\\ell}^{(i)}\\cdot(\\bar{a}_{L,j}^{(i)}+\\Delta_{L})</span> similarly we can express <span class="math">a_{C,j}^{(i)},a_{C,\\ell}^{(i)}</span> and <span class="math">a_{R,j}^{(i)},a_{R,\\ell}^{(i)}</span> using <span class="math">\\Delta_{C}</span> and <span class="math">\\Delta_{R}</span> respectively. Note that one of <span class="math">\\Delta,\\Delta_{C},\\Delta_{R}</span> must be non-zero as otherwise we could factor out <span class="math">h_{j}^{(i)}</span> and <span class="math">h_{\\ell}^{(i)}</span> respectively.</p>

    <p class="text-gray-300">This means that</p>

    <p class="text-gray-300"><span class="math">h_{j}^{(i)}\\cdot(x_{i}\\cdot\\bar{a}_{L,j}^{(i)}+\\bar{a}_{C,j}^{(i)}+x_{i}^{-1}\\cdot\\bar{a}_{R,j}^{(i)})=h_{j}^{(i)}a_{k}^{(i+1)}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">h_{\\ell}^{(i)}\\cdot(x_{i}\\cdot(\\bar{a}_{L,j}^{(i)}+\\Delta_{L})+(\\bar{a}_{C,j}^{(i)}+\\Delta_{C})+x_{i}^{-1}\\cdot(\\bar{a}_{R,j}^{(i)})+\\Delta_{R}))=h_{j^{\\prime}}^{(i)}a_{k}^{(i+1)}</span></p>

    <p class="text-gray-300">This implies that</p>

    <p class="text-gray-300"><span class="math">x_{i}\\cdot\\Delta_{L}+\\Delta_{C}+x_{i}^{-1}\\Delta_{R}=0</span></p>

    <p class="text-gray-300">Let <span class="math">p(X)=\\Delta_{R}+X\\Delta_{C}+X^{2}\\Delta_{L}</span> be a non-zero polynomial of degree 2. Note that <span class="math">\\Delta_{L},\\Delta_{C},\\Delta_{R}</span> are fully defined by the proof elements and challenges before <span class="math">x_{i}</span> is generated but <span class="math">p(x_{i})=0</span>. This however happens with at most probability <span class="math">\\sqrt{(t+1)\\frac{2}{2^{\\lambda}}}+\\mathrm{negl}(\\lambda)</span> by Lemma 3.</p>

    <p class="text-gray-300">Note that the proof does not only extend to pairs of vector entries but to the entire <span class="math">\\bm{a}_{[:m^{(i)}/2]}^{(i)}</span>. Further we can symmetrically proof the correct representation of <span class="math">\\bm{a}_{[m^{(i)}/2:]}^{(i)}</span>, <span class="math">\\bm{b}_{[:m^{(i)}/2]}^{(i)}</span>, <span class="math">\\bm{b}_{[m^{(i)}/2:]}^{(i)}</span> and <span class="math">c^{(i)}</span>.</p>

    <p class="text-gray-300">Using a union bound we can bound the probability that we fail to extract a valid representation in a given round bu <span class="math">5\\sqrt{(t+1)\\frac{2}{2^{\\lambda}}}+\\mathrm{negl}(\\lambda)</span>. This shows that with only negligible probability can <span class="math">C_{L}^{(i)},C^{(i)},C_{R}^{(i)}</span> not be expressed using <span class="math">ck^{(i)}</span></p>

    <p class="text-gray-300">c) We can write <span class="math">C_{L}^{(i)}=\\mathsf{CM}(\\mathsf{ck}^{(i)};\\bm{a}_{L}^{(i)},\\bm{b}_{L}^{(i)},c_{L}^{(i)})</span> and <span class="math">C^{(i)},C_{R}^{(i)}</span> also using commitment key <span class="math">\\mathsf{ck}^{(i)}</span>. Given that there are is collision of the commitment function we can deduce that for <span class="math">m^{\\prime}=m^{(i+1)}</span></p>

    <p class="text-gray-300"><span class="math">x_{i}^{-1}\\bm{a}^{(i)}_{L,[:m^{\\prime}]}+\\bm{a}^{(i)}_{[:m^{\\prime}]}+x_{i}^{-1}\\bm{a}^{(i)}_{R,[:m^{\\prime}]}=\\bm{a}^{(i+1)}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">x_{i}\\bm{a}^{(i)}_{L,[m^{\\prime}:]}+\\bm{a}^{(i)}_{[m^{\\prime}:]}+x_{i}^{-1}\\bm{a}^{(i)}_{R,[m^{\\prime}:]}=x_{i}^{-1}\\bm{a}^{(i+1)}</span></p>

    <p class="text-gray-300">We can write up similar equations for <span class="math">\\bm{b}^{(i+1)}</span> Similarly as in the proof of Theorem 1 we can deduce that</p>

    <p class="text-gray-300"><span class="math">\\bm{a}^{(i)}_{R,[:m^{\\prime}]}=\\bm{a}^{(i)}_{L,[m^{\\prime}:]}=\\bm{b}^{(i)}_{R,[m^{\\prime}:]}</span> <span class="math">=\\bm{b}^{(i)}_{L,[:m^{\\prime}]}=0</span> <span class="math">\\bm{a}^{(i)}_{[:m^{\\prime}]}</span> <span class="math">=\\bm{a}^{(i)}_{R,[m^{\\prime}:]}</span> <span class="math">\\bm{a}^{(i)}_{[m^{\\prime}:]}</span> <span class="math">=\\bm{a}^{(i)}_{L,[:m^{\\prime}]}</span> <span class="math">\\bm{b}^{(i)}_{[m^{\\prime}:]}</span> <span class="math">=\\bm{b}^{(i)}_{R,[:m^{\\prime}]}</span> <span class="math">\\bm{b}^{(i)}_{[:m^{\\prime}]}</span> <span class="math">=\\bm{b}^{(i)}_{L,[m^{\\prime}:]}\\enspace.</span></p>

    <p class="text-gray-300">This means that <span class="math">\\bm{a}^{(i+1)}=\\bm{a}^{(i)}_{[:m^{\\prime}]}+x_{i}\\cdot\\bm{a}^{(i)}_{[m^{\\prime}:]}</span> and <span class="math">\\bm{b}^{(i+1)}=\\bm{a}^{(i)}_{[:m^{\\prime}]}+x_{i}^{-1}\\cdot\\bm{a}^{(i)}_{[m^{\\prime}:]}</span> Otherwise we get two non-zero, degree <span class="math">3</span> polynomial that are fully defined by the openings of the commitments <span class="math">C^{(i)}_{L},C^{(i)},C^{(i)}_{R}</span> which evaluated at <span class="math">x_{i}</span> is equal to <span class="math">0</span>. By Lemma 3 this happens with at most probability <span class="math">2\\cdot\\sqrt{(t+1)\\frac{3}{2^{\\lambda}}}+\\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Ensuring inner product correctness. If <span class="math">\\langle\\bm{a}^{(i+1)},\\bm{b}^{(i+1)}\\rangle=c^{(i+1)}</span> and <span class="math">x_{i}c^{(i)}_{L}+c^{(i)}+x_{i}^{-1}c^{(i)}_{R}=c^{(i+1)}</span> then it follows that <span class="math">\\langle\\bm{a}^{(i)},\\bm{b}^{(i)}\\rangle=c^{(i)}</span>. This is because <span class="math">\\bm{a}^{(i)}=\\bm{a}^{(i)}_{[:m^{\\prime}]}+x_{i}\\cdot\\bm{a}^{(i)}_{[m^{\\prime}:]}</span> and <span class="math">\\bm{a}^{(i)}=\\bm{b}^{(i)}_{[:m^{\\prime}]}+x_{i}^{-1}\\cdot\\bm{b}^{(i)}_{[m^{\\prime}:]}</span>. Plugging this in we get that</p>

    <p class="text-gray-300"><span class="math">\\langle\\bm{a}^{(i+1)},\\bm{b}^{(i+1)}\\rangle=\\langle\\bm{a}^{(i)}_{[:m^{\\prime}]}+x_{i}\\cdot\\bm{a}^{(i)}_{[m^{\\prime}:]},\\bm{b}^{(i)}_{[:m^{\\prime}]}+x_{i}^{-1}\\cdot\\bm{b}^{(i)}_{[m^{\\prime}:]}\\rangle</span> <span class="math">=x_{i}\\cdot\\langle\\bm{a}^{(i)}_{[m^{\\prime}:]},\\bm{b}^{(i)}_{[:m^{\\prime}]}\\rangle+\\langle\\bm{a}^{(i)},\\bm{b}^{(i)}\\rangle+x^{-1}\\langle\\bm{a}^{(i)}_{[:m^{\\prime}]},\\bm{b}^{(i)}_{[m^{\\prime}:]}\\rangle</span> <span class="math">=x_{i}c^{(i)}_{L}+c^{(i)}+x_{i}^{-1}c^{(i)}_{R}</span></p>

    <p class="text-gray-300">If <span class="math">\\langle\\bm{a}^{(i)},\\bm{b}^{(i)}\\rangle\\neq c^{(i)}</span> then we again have that a degree <span class="math">2</span> polynomial defined by committed values is <span class="math">0</span> at a random oracle generated point. By the zero-finding game (Lemma 3) this happens with negligible probability <span class="math">\\left(\\sqrt{(t+1)\\frac{2}{2^{\\lambda}}}+\\mathrm{negl}(\\lambda)\\right)</span>.</p>

    <p class="text-gray-300">Knowledge error. Otherwise we have shown that if at round <span class="math">i+1</span> the committed vectors form an inner product then so will the committed vectors at round <span class="math">i</span> with overwhelming probability. This shows that the extracted witness <span class="math">\\bm{a},\\bm{b}</span> is valid. The probability that extraction fails, i.e. the knowledge error, can be bounded by <span class="math">O(\\log_{2}(m)\\sqrt{\\frac{t}{2^{\\lambda}}}+\\mathrm{negl}(\\lambda))</span> for a <span class="math">t</span>-query adversary.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">D.4 Deferred proofs from Section 5</h3>

    <p class="text-gray-300">In Theorem Theorem 3 we prove that <span class="math">\\mathsf{TIPP}</span> satisfies computational knowledge soundness. In the proof we use the facts that: (1) the structure of our honestly generated final commitment keys is correct; (2) an algebraic adversary that convinces a verifier of ill-formed final commitment keys can break <span class="math">q</span>-<span class="math">\\mathsf{SDH}</span>. We prove these two facts in this section in Proposition 1 and Lemma 4.</p>

    <p class="text-gray-300">The following p:fin demonstrates the correctness of the format of our final commitment keys.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">In the <span class="math">\\mathsf{GIPA}</span> protocol, if the commitment key <span class="math">\\bm{v}=(g,g^{(r\\alpha)^{2}},\\ldots,g^{(r\\alpha)^{2m-2}})</span>, then the final commitment key has the structure</p>

    <p class="text-gray-300"><span class="math">v=g\\prod_{j=0}^{\\ell}(1+x_{j}(r\\alpha)^{2^{j+1}})</span></p>

    <p class="text-gray-300">where <span class="math">x_{j}</span> is the <span class="math">(\\ell-j)</span>th verifier challenge and <span class="math">\\ell=\\log_{2}(m)</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">First, recall that in each round of GIPA, the prover and the verifier compute the new commitment key to equal</p>

    <p class="text-gray-300"><span class="math">\\bm{v}^{\\prime}=\\bm{v}_{[:m^{\\prime}]}\\circ\\bm{v}_{[m^{\\prime}:]}^{x}~{}.</span></p>

    <p class="text-gray-300">We now provide an inductive argument for our proposition. First observe that if there is only one round, i.e., if <span class="math">\\ell=0</span>, then we see that</p>

    <p class="text-gray-300"><span class="math">v=v_{0}v_{1}^{x_{0}}=g^{(r\\alpha)^{2}x_{0}+1}=g\\prod_{j=0}^{0}(1+x_{j}(r\\alpha)^{2^{j+1}})~{}~{}.</span></p>

    <p class="text-gray-300">Next, suppose the statement is true for <span class="math">\\ell-1</span>. We show that the statement is true for <span class="math">\\ell</span>. On the first round we rescale the commitment key to</p>

    <p class="text-gray-300"><span class="math">\\bm{v}^{\\prime}=\\bm{v}_{[:2^{\\ell}]}\\circ\\bm{v}_{[2^{\\ell}:]}^{x_{\\ell}}=\\left(v_{0}v_{0}^{x_{\\ell}\\alpha^{2^{\\ell+1}}},\\ldots,v_{2^{\\ell}-1}v_{2^{\\ell}-1}^{x_{\\ell}\\alpha^{2^{\\ell+1}}}\\right)</span></p>

    <p class="text-gray-300">We then run the IPP protocol with respect to <span class="math">\\ell-1</span> and the generators</p>

    <p class="text-gray-300"><span class="math">\\bm{v}^{\\prime}=\\bm{v}_{[:2^{\\ell}]}^{1+x_{\\ell}(r\\alpha)^{2^{\\ell+1}}}~{}~{}.</span></p>

    <p class="text-gray-300">From our inductive assumption we have that running GIPA on <span class="math">\\bm{v}_{[:2^{\\ell}]}</span> yields</p>

    <p class="text-gray-300"><span class="math">v=g\\prod_{j=0}^{\\ell-1}(1+x_{j}(r\\alpha)^{2^{j+1}})~{}~{}.</span></p>

    <p class="text-gray-300">with respect to the challenges <span class="math">(x_{\\ell-1},\\ldots,x_{0})</span>. Hence the final commitment key has the form</p>

    <p class="text-gray-300"><span class="math">v^{\\prime}=v^{1+x_{\\ell}(r\\alpha)^{2^{\\ell+1}}}=g^{(1+x_{\\ell}(r\\alpha)^{2^{\\ell+1}})}\\prod_{j=0}^{\\ell-1}(1+x_{j}(r\\alpha)^{2^{j+1}})=g\\prod_{j=0}^{\\ell}(x_{j}+(r\\alpha)^{2^{j+1}})</span></p>

    <p class="text-gray-300">as required. ∎</p>

    <p class="text-gray-300">We show the soundness of our final commitment key argument i.e. we show that an adversarial prover cannot convince an honest verifier.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">The protocol defined by Fig. 2 for the language <span class="math">\\mathcal{L}_{\\textup{ck}}</span> is sound in the algebraic group model under the <span class="math">q</span>-SDH assumption.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}=(\\mathcal{A}_{0},\\mathcal{A}_{1})</span> be a pair of algorithms that share state. On input <span class="math">(\\langle\\textsf{group}\\rangle,f(X),\\bm{g}=[g^{\\alpha^{i}}]_{i=0}^{2m-2})</span>, the algorithm <span class="math">\\mathcal{A}_{0}</span> returns <span class="math">w</span> and, on input <span class="math">z</span>, the algorithm <span class="math">\\mathcal{A}_{1}</span> returns <span class="math">P</span> such that the verifier accepts.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{B}</span> be an algorithm against <span class="math">q</span>-<span class="math">\\mathsf{SDH}</span>. Then <span class="math">\\mathcal{B}</span>, on input of <span class="math">\\langle\\textsf{group}\\rangle,\\bm{g}=[g^{\\alpha^{i}}]_{i=0}^{2m-2},\\bm{h}=[h^{\\alpha^{i}}]_{i=0}^{2m-2})</span>, behaves as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\mathcal{A}_{0}</span> on the input <span class="math">(\\langle\\textsf{group}\\rangle,f(X),\\bm{g}=[g^{\\alpha^{i}}]_{i=0}^{2m-2})</span> to obtain <span class="math">w</span>.</li>

      <li>Extract <span class="math">s(X)</span> such that <span class="math">w=g^{s(\\alpha)}</span>.</li>

      <li>Run <span class="math">\\mathcal{A}_{1}</span> on input <span class="math">z\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> to obtain verifying </span>P$.</li>

      <li>Compute <span class="math">P^{\\prime}=g^{\\frac{s(\\alpha)-s(z)}{\\alpha-z}}</span>.</li>

      <li>Return <span class="math">\\Big{(}z,(P^{\\prime}P^{-1})^{\\frac{1}{s(z)-f(z)}}\\Big{)}</span>.</li>

    </ol>

    <p class="text-gray-300">6.</p>

    <p class="text-gray-300">We now argue that if <span class="math">(\\mathcal{A}_{0},\\mathcal{A}_{1})</span> succeeds then either <span class="math">w</span> has been computed correctly with overwhelming probability or <span class="math">\\mathcal{B}</span> succeeds. First observe that due to the verifiers equation</p>

    <p class="text-gray-300"><span class="math">e(wg^{-f(z)}P^{z},h)=e(P,h^{\\alpha}).</span></p>

    <p class="text-gray-300">Also observe that by design</p>

    <p class="text-gray-300"><span class="math">e(wg^{-s(z)},h)=e(P^{\\prime},h^{\\alpha-z}).</span></p>

    <p class="text-gray-300">Thus</p>

    <p class="text-gray-300"><span class="math">e(g^{f(z)-s(z)},h)=e(P^{\\prime}P^{-1},h^{\\alpha-z})</span></p>

    <p class="text-gray-300">and either <span class="math">f(z)=s(z)</span> or</p>

    <p class="text-gray-300"><span class="math">(P^{\\prime}P^{-1})^{\\frac{1}{s(z)-f(z)}}=g^{\\frac{1}{\\alpha-z}}</span></p>

    <p class="text-gray-300">and <span class="math">\\mathcal{B}</span> succeeds.</p>

    <p class="text-gray-300">If <span class="math">f(z)=s(z)</span> then with overwhelming probability <span class="math">f(X)=s(X)</span>. Hence <span class="math">w=g^{s(\\alpha)}=g^{f(\\alpha)}</span> and <span class="math">w</span> has been computed correctly. ∎</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem 6 (Computational knowledge-soundness of <span class="math">\\mathsf{MIPP}_{k}</span>).</h6>

    <p class="text-gray-300">The protocol defined in Section 5.5 for the NP relation <span class="math">\\mathcal{R}_{\\mathsf{MIPP}_{k}}</span> has computational knowledge soundness (Definition 6) against algebraic adversaries under <span class="math">m</span>-<span class="math">\\mathsf{ASDBP}</span> and <span class="math">2m</span>-<span class="math">\\mathsf{SDH}</span>.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The commitment scheme</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{CM}((\\bm{v},\\bm{1},\\hat{h}^{\\prime}),(\\bm{A},\\bm{b},U))=((\\bm{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U)*(\\bm{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{h}),\\ \\bm{b}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is doubly homomorphic: the key space <span class="math">\\mathbb{G}_{2}^{m}\\times\\mathbb{F}^{m}\\times\\mathbb{G}_{2}</span> is homomorphic under <span class="math">\\mathbb{G}_{2}</span> multiplication, <span class="math">\\mathbb{F}</span> addition, and <span class="math">\\mathbb{G}_{2}</span> multiplication. The message space <span class="math">\\mathbb{G}_{1}^{m}\\times\\mathbb{F}^{m}\\times\\mathbb{G}_{1}</span> is homomorphic under <span class="math">\\mathbb{G}_{1}</span> multiplication, <span class="math">\\mathbb{F}</span> addition, and <span class="math">\\mathbb{G}_{1}</span> multiplication. The commitment space <span class="math">\\mathbb{G}_{T}\\times\\mathbb{F}^{m}</span> is homomorphic under <span class="math">\\mathbb{G}_{T}</span> multiplication and <span class="math">\\mathbb{F}</span> addition. All groups have prime order <span class="math">p</span> for <span class="math">p&gt;2^{\\lambda}</span>. The commitment scheme is also binding by the <span class="math">m</span>-<span class="math">\\mathsf{ASDBP}</span> assumption. This means that the commitment scheme is an inner product commitment. Thus either the adversary convinces the verifier of incorrect <span class="math">w,v</span>, or by Theorem 1 an adversary that breaks computational knowledge soundness can extract a valid <span class="math">m</span>-<span class="math">\\mathsf{ASDBP}</span> instance.</p>

    <p class="text-gray-300">An algebraic adversary that convinces a verifier of incorrect <span class="math">v</span> can extract a valid <span class="math">2m</span>-<span class="math">\\mathsf{SDH}</span> instance by Lemma 4. ∎</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Theorem 7 (Computational knowledge-soundness of <span class="math">\\mathsf{MIPP}_{u}</span>).</h6>

    <p class="text-gray-300">The protocol defined in Section 5.4 for the NP relation <span class="math">\\mathcal{R}_{\\mathsf{MIPP}_{u}}</span> has computational knowledge-soundness (Definition 6) against algebraic adversaries under <span class="math">m</span>-<span class="math">\\mathsf{ASDBP}</span> and <span class="math">2m</span>-<span class="math">\\mathsf{SDH}</span> assumptions.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The commitment scheme</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{CM}((\\bm{v},\\bm{w},\\hat{h}_{2}^{\\prime}),(\\bm{A},\\bm{b},U))=((\\bm{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}^{\\bm{b}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U)*(\\bm{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{h}_{1}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{h}_{2}^{\\prime}))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is doubly homomorphic: the key space <span class="math">\\mathbb{G}_{2}^{m}\\times\\mathbb{G}_{1}^{m}\\times\\mathbb{G}_{2}</span> is homomorphic under the respective group multiplication. The message space <span class="math">\\mathbb{G}_{1}^{m}\\times\\mathbb{F}^{m}\\times\\mathbb{G}_{1}</span> is homomorphic under <span class="math">\\mathbb{G}_{1}</span> multiplication, <span class="math">\\mathbb{F}</span> addition, and <span class="math">\\mathbb{G}_{1}</span> multiplication. The commitment space <span class="math">\\mathbb{G}_{T}</span> is homomorphic under <span class="math">\\mathbb{G}_{T}</span> multiplication. All groups have prime order <span class="math">p</span> for <span class="math">p&gt;2^{\\lambda}</span>. The commitment scheme is also binding by the <span class="math">m</span>-<span class="math">\\mathsf{ASDBP}</span> assumption. This means that the commitment scheme is an inner product commitment. Thus either the adversary convinces the verifier of incorrect <span class="math">w,v</span>, or by Theorem 1 an adversary that breaks computational knowledge soundness can extract a valid <span class="math">m</span>-<span class="math">\\mathsf{ASDBP}</span> instance.</p>

    <p class="text-gray-300">An algebraic adversary that convinces a verifier of incorrect <span class="math">w,v</span> can extract a valid <span class="math">2m</span>-<span class="math">\\mathsf{SDH}</span> instance by Lemma 4. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">D.5 Deferred proofs from Section 6</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">D.5.1 Proof of Theorem 4</h4>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adversary that succeeds at convincing a verifier with non-negligible probability for random evaluation challenges <span class="math">(x,y)</span>. By Theorem 6 there exists an extractor that outputs <span class="math">\\bm{A}</span> such that <span class="math">T=\\bm{A}*\\bm{v}</span> and <span class="math">A=\\bm{A^{\\bm{x}}}</span>. By Lemma 4on there exists an extractor that outputs <span class="math">\\bm{a}^{\\prime}</span> such that <span class="math">\\nu=\\bm{a}^{\\prime}\\cdot\\bm{y}</span> and <span class="math">A=\\bm{g^{\\bm{a}}^{\\prime}}</span>.</p>

    <p class="text-gray-300">The extractor runs <span class="math">\\mathcal{A}</span> on <span class="math">\\max(m,\\ell)</span> parallel instances of <span class="math">(x,y)</span>. They compute a Vandermonde matrix to find <span class="math">\\hat{M}\\in\\mathbb{F}^{m,\\ell}</span> which relates the exponents of <span class="math">A_{i}</span> to the exponents of <span class="math">\\bm{g}</span>. With overwhelming probability this matrix is invertible, so they learn <span class="math">a_{i,0},\\ldots,a_{i,\\ell-1}</span> such that <span class="math">A_{i}=\\prod_{j=0}^{\\ell-1}g_{j}^{a_{i,j}}</span>. They return <span class="math">f(X,Y)=\\sum_{i,j}a_{i,j}X^{i}Y^{j}</span>. Observe that <span class="math">\\nu=\\sum_{i=0}^{m-1}(\\sum_{j=0}^{\\ell}a_{i,j}y^{j})x_{i}</span> is the correct evaluation of <span class="math">f(X,Y)</span>. ∎</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">The polynomial commitment scheme in Appendix E is special honest verifier zero-knowledge.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First observe that both the prover samples <span class="math">T</span> from a uniformly random distribution and thus the commitment scheme is hiding.</p>

    <p class="text-gray-300">Consider a simulator that knows the verifier responses in advance:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To simulate a commitment, return <span class="math">T\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{G}_{T}$.</li>

      <li>To simulate an evaluation of <span class="math">T</span> to <span class="math">\\nu</span> with respect to the challenge <span class="math">c\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}$</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">\\rho^{\\prime}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> and </span>r(X,Y)<span class="math"> a random polynomial that evaluates at </span>(x,y)<span class="math"> to </span>\\nu$.</li>

      <li>Set <span class="math">R^{\\prime}=\\mathsf{PC.CM}(\\mathsf{ck};r(X,Y))</span> and <span class="math">R=T^{-c}\\cdot R^{\\prime}\\cdot e(g_{0}^{\\rho^{\\prime}},h^{m})</span>. Send <span class="math">(R,r(x,y))</span> to the verifier.</li>

      <li>When the verifier sends <span class="math">c</span>, respond with <span class="math">\\rho^{\\prime}</span>.</li>

      <li>Run the provers evaluation algorithm on <span class="math">T^{\\prime}=T^{c}\\cdot R\\cdot e(g_{0}^{-\\rho^{\\prime}},v_{m})=R^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">The provers evaluations <span class="math">(R,r(x,y))</span> is masked by <span class="math">r_{1,2},r_{1,3}</span> and thus is indistinguishable from the verifiers random evaluation. By Lemma 4.6 of <em>Hoffmann et al. [10]</em>, <span class="math">\\mathbb{M}_{m}</span> and <span class="math">\\mathbb{M}_{\\ell}</span> are masking sets for <span class="math">\\mathsf{MIPP}</span> and <span class="math">\\mathsf{DL-IP}</span> respectively. Thus the provers recursive arguments <span class="math">Z_{L},Z_{R},P_{L},P_{R}</span> are distributed uniformly at random and are indistinguishable from the simulators uniformly random recursive arguments. The provers evaluation <span class="math">A=\\mathsf{CM}(\\mathsf{ck},f(x,Y))</span> is masked by <span class="math">r_{1,1}</span> and thus is indistinguishable from the simulators random evaluation <span class="math">A</span>. Hence <span class="math">(\\mathsf{PC.Setup}</span>, <span class="math">\\mathsf{PC.CM}</span>, <span class="math">\\mathsf{EvalSetup}</span>, <span class="math">\\mathsf{EvalProve}</span>, <span class="math">\\mathsf{EvalVerify})</span> satisfies honest verifier zero-knowledge. ∎</p>

    <h2 id="sec-80" class="text-2xl font-bold">Appendix E Hiding Polynomial Commitments</h2>

    <p class="text-gray-300">The inner product arguments we have described thus far are, by default, not hiding. An attacker can easily distinguish one polynomial from another, for example by computing the commitment themselves (our commitment algorithm is deterministic). When instantiating zero-knowledge arguments that use polynomial commitments, this is potentially problematic. For example, Marlin <em>[11]</em> only achieves zero-knowledge when it is instantiated using a hiding polynomial commitment scheme.</p>

    <p class="text-gray-300">Fortunately there exists a simple generic approach to transforming homomorphic polynomial commitment schemes from non-hiding to hiding <em>[1]</em>. First the initial commitment <span class="math">T</span> to the polynomial <span class="math">f(X,Y)</span> needs to be randomised so as to make it hiding. Upon evaluation, the prover sends: the evaluation <span class="math">f(x,y)</span>; a</p>

    <p class="text-gray-300">commitment  <span class="math">R</span>  to a fully random polynomial  <span class="math">r(X, Y)</span>  (with the same degree as  <span class="math">f(X, Y)</span> ); and the evaluation  <span class="math">r(x, y)</span>  to the verifier. The verifier returns a challenge  <span class="math">c</span> . The prover then proves that  <span class="math">T^c R</span>  evaluates to  <span class="math">c \\cdot f(x, y) + r(x, y)</span> . Hoffmann et al. [HKR19] optimise this method for the prover by observing that it suffices for  <span class="math">r(X, Y)</span>  to have only a logarithmic number of non-zero coefficients.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HidingPC.Setup(1λ, l, m) return PC.Setup(1λ, l, m + 1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HidingPC.CM(ck, v, f(X, Y)) τ ←$ F T ← PC.CM(ck, f(X, Y)) T ← T · e(g0+, vm) return T</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ZKEvalSetup(ck; α, β) return EvalSetup(ck; α, β) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ZKEvalProve(crs, (T, (x, y), ν), (f(X, Y), A, τ)) sample r(X, Y) ←<span class="math"> F[X, Y] sample ρ ←</span> F R ← HidingPC.CM(ck, r(X, Y); ρ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ZKEvalVerify(crs, (T, (x, y), ν)) receive (R, r) from the prover send challenge c ∈ F receive ρ' from the prover</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  T' ← Tc · R · e(g0-ρ', vm) ν' ← c · f(x, y) + r(x, y) f'(X, Y) = c · f(X, Y) + r(X, Y) A' ← Ac ∘ R run EvalProve(crs, (T', (x, y), ν'), (f'(X, Y), A')) |   |</p>

    <p class="text-gray-300">Figure 18: Our hiding extension to our polynomial commitment schemes. Here ck and crs are taken to be the commitment keys and common reference strings from either the transparent or the structured setup polynomial commitment schemes. Additionally the prover inputs  <span class="math">\\mathbf{A}</span>  and  <span class="math">\\mathbf{R}</span>  are commitments to  <span class="math">f_0(Y), \\ldots, f_{m-1}(Y)</span>  and  <span class="math">r_0(Y), \\ldots, r_{m-1}(Y)</span>  respectively.</p>

    <p class="text-gray-300">We specify the hiding variation on our polynomial commitment schemes in Figure E and prove security in Lemma 5.</p>

    <p class="text-gray-300">Hiding Commitment: Our commitment key contains an additional value  <span class="math">v_{m} \\in \\mathbb{G}_{2}</span> . Our prover commits to  <span class="math">f(X,Y)</span>  by sampling  <span class="math">\\tau \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}$  and setting</p>

    <div class="my-4 text-center"><span class="math-block">T = \\mathsf {P C . C M} (\\mathsf {c k}, f (X, Y)) \\cdot e (g _ {0} ^ {\\tau}, v _ {m}) = e (g _ {0} ^ {\\tau}, v _ {m}) \\prod_ {i = 0} ^ {m - 1} e \\left(\\prod_ {j = 0} ^ {\\ell - 1} g _ {j} ^ {a _ {i, j}}, v _ {i}\\right).</span></div>

    <p class="text-gray-300">Observe that this commitment is perfectly hiding because there is one group element and one randomiser.</p>

    <p class="text-gray-300">Zero-Knowledge Evaluation Argument: Upon receiving an evaluation instance  <span class="math">(x,y)</span>  for the commitment</p>

    <p class="text-gray-300"><span class="math">T</span>, the prover samples</p>

    <div class="my-4 text-center"><span class="math-block">r(X, Y) = \\sum_{i,j=0}^{m-1,\\ell-1} r_{i,j} X^i Y^j</span></div>

    <p class="text-gray-300">for <span class="math">r_{i,j}</span> sampled randomly from <span class="math">\\mathbb{F}</span> and computes</p>

    <div class="my-4 text-center"><span class="math-block">R = \\operatorname{PC.CM}(\\operatorname{ck}, r(X, Y)).</span></div>

    <p class="text-gray-300">The prover sends <span class="math">(R, r(x, y))</span> to the verifier. The verifier returns <span class="math">c \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}<span class="math">. The prover sends </span>\\rho' = c\\tau + \\rho<span class="math"> to the verifier. The prover now demonstrates to the verifier that </span>T^c \\cdot R \\cdot e(g_0^{-\\rho'}, v_m)<span class="math"> evaluates to </span>c \\cdot f(x, y) + r(x, y)$.</p>

    <p class="text-gray-300"><strong>Optimization.</strong> We specify an optimization by Hoffmann et al. [HKR19] for reducing the number of non-zero coefficients in <span class="math">r(X, Y)</span>. This optimization is important because otherwise computing the commitment <span class="math">R</span> would require <span class="math">m\\ell \\mathbb{G}_1</span> operations, increasing our prover time not only practically but also asymptotically. Let <span class="math">\\mathbb{M}_m = \\{0\\} \\cup \\{2^k, 2^k + 1\\}_{k=0}^{m-1}</span> and <span class="math">\\mathbb{M}_\\ell = \\{0\\} \\cup \\{2^k, 2^k + 1\\}_{k=0}^{\\ell-1}</span> and observe that these sets have logarithmic size. Rather than sampling <span class="math">r(X, Y)</span> from the full polynomial space, instead sample</p>

    <div class="my-4 text-center"><span class="math-block">r_{i,j} = \\begin{cases} r \\stackrel{\\$}{\\leftarrow} \\mathbb{F} \\text{ for } (i,j) \\in \\{(0,1), (0,2), (0,3)\\} \\\\ r \\stackrel{\\$}{\\leftarrow} \\mathbb{F} \\text{ for } i \\in \\mathbb{M}_m \\text{ and } j = 6 \\\\ r \\stackrel{\\$}{\\leftarrow} \\mathbb{F} \\text{ for } i = 6 \\text{ and } j \\in \\mathbb{M}_\\ell \\\\ 0 \\text{ otherwise} \\end{cases}</span></div>

    <p class="text-gray-300">and set <span class="math">r(X, Y) = \\sum_{i,j} r_{i,j} X^i Y^j</span>. We have chosen <span class="math">r_{i,6}</span> because 6 is the first value not in <span class="math">\\mathbb{M}_\\ell</span> (and similarly for <span class="math">r_{6,j}</span>).</p>

    <p class="text-gray-300">54</p>`;
---

<BaseLayout title="Proofs for Inner Pairing Products and Applications (2019/1177)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1177
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
