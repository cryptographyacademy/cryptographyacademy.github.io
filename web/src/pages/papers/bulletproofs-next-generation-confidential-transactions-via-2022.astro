---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/510';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Bulletproofs++: Next Generation Confidential Transactions via Reciprocal Set Membership Arguments';
const AUTHORS_HTML = 'Liam Eagen, Sanket Kanjalkar, Tim Ruffing, Jonas Nick';

const CONTENT = `    <p class="text-gray-300">Liam Eagen [liam.eagen@protonmail.com] Sanket Kanjalkar Tim Ruffing Jonas Nick Blockstream Research [Blockstream Research]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Zero-knowledge proofs are a cryptographic cornerstone of privacy-preserving technologies such as “Confidential Transactions” (CT), which aims at hiding monetary amounts in cryptocurrency transactions. Due to its asymptotically logarithmic proof size and transparent setup, most state-of-the-art CT protocols use the Bulletproofs (BP) <em>[1]</em> zero-knowledge proof system for set membership proofs such as range proofs. However, even taking into account recent efficiency improvements, BP comes with a serious overhead in terms of concrete proof size as well as verifier running time and thus puts a large burden on practical deployments of CT and its extensions.</p>

    <p class="text-gray-300">In this work, we introduce Bulletproofs++ (BP++), a drop-in replacement for BP that improves its concrete efficiency and compactness significantly. As for BP, the security of BP++ relies only on the hardness of the discrete logarithm problem in the random oracle model, and BP++ retains all features of Bulletproofs including transparent setup and support for proof aggregation, multi-party proving and batch verification. Asymptotically, BP++ range proofs require only <span class="math">O(n/\\log n)</span> group scalar multiplications compared to <span class="math">O(n)</span> for BP and BP+.</p>

    <p class="text-gray-300">At the heart of our construction are novel techniques for permutation and set membership, which enable us to prove statements encoded as arithmetic circuits very efficiently. Concretely, a single BP++ range proof to establish that a committed value is in a 64-bit range (as commonly required by CT) is just 416 bytes over a 256-bit elliptic curve, 38% smaller than an equivalent BP and 27% smaller than BP+. When instantiated using the secp256k1 curve as used in Bitcoin, our benchmarks show that proving is about 5 times faster than BP and verification is about 3 times faster than BP. When aggregating 32 range proofs, proving and verification are about 9.5 times and 5.5 times faster, respectively.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">^{*} liameagen@protonmail.com</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Contributions  4 1.2 Related Work  5</p>

    <p class="text-gray-300">2  Preliminaries  6 2.1 Discrete Logarithm Relation Problem  7 2.2 Zero-Knowledge Arguments of Knowledge  7</p>

    <p class="text-gray-300">3  Technical Overview  8 3.1 Bulletproofs and Bulletproofs+  9 3.2 Reciprocal Argument  9 3.2.1 The Logarithmic Derivative  10 3.2.2 Application to Range Proofs  10 3.2.3 Application to MACT  11 3.3 Norm Linear Argument  11 3.4 Arithmetic Circuits  12</p>

    <p class="text-gray-300">4  Norm Linear Argument  12 4.1 Norm Reduction  13 4.2 Norm Linear Argument  13 4.3 Full Protocol Description  14</p>

    <p class="text-gray-300">5  Arithmetic Circuits  14 5.1 Equivalence to BP Circuits  15 5.2 Polynomial Encoding  15 5.2.1 Commitment Layout  16 5.2.2 Constraints and Inputs  17 5.2.3 Polynomial  17 5.2.4 Error Terms  18 5.3 Full Protocol Description  19 5.4 Multi-party Proving  21</p>

    <p class="text-gray-300">6  Reciprocal Argument  21 6.1 Warmup: Reciprocal Argument Protocol  22 6.2 Reciprocal Form Circuits  23 6.3 Full Protocol Description  24 6.4 Reciprocal Range Proofs  25 6.4.1 Arbitrary Ranges  25 6.4.2 Arithmetic Circuit  26 6.5 Multi-Asset Confidential Transactions  26 6.5.1 Arithmetic Circuit  27</p>

    <p class="text-gray-300">7  Implementation and Benchmarks  28</p>

    <p class="text-gray-300">Changelog  28</p>

    <p class="text-gray-300">A  Binary Range Proof  31</p>

    <p class="text-gray-300">B  Fast Scalar Multiplication  33 B.1 Complex Multiplication  33</p>

    <p class="text-gray-300">C  Theorems and Proofs  34 C.1 Norm Linear Argument  35 C.1.1 Proof of Theorem 1  35 C.2 Arithmetic Circuits  36 C.2.1 Proof of Theorem 2  36 C.3 Proof of Theorem 3  37</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Cryptocurrencies like Bitcoin <em>[2]</em> enable decentralized, peer-to-peer payments by maintaining a distributed public ledger called the blockchain. While this innovation has permitted an unprecedented degree of financial autonomy on the Internet, the fact that every transaction leaves a permanent record in the blockchain poses a substantial threat to the financial privacy of users. Even though cryptocurrency transactions are not typically associated with real-world identities, a surprisingly large amount of information can be extracted from the information in the blockchain <em>[3, 4, 5, 6, 7, 8]</em>.</p>

    <p class="text-gray-300">Among the most glaring pieces of data that an observer can extract are the amounts of funds that transactions move from sender to recipient. These monetary amounts are stored as plain integers in many popular cryptocurrencies, including Bitcoin, which makes it easy for blockchain nodes to verify that a transaction is balanced, i.e., that the sum of all its input amounts equals the sum of all its output amounts (except for a small fee given to the miners).</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Confidential Transactions</h4>

    <p class="text-gray-300">A common countermeasure to this leak of information, e.g., as suggested first in the “Confidential Transactions” proposal <em>[9, 10]</em> (CT), is to hide the monetary amounts in homomorphic commitments such as Pedersen commitments. The additive homomorphism ensures that blockchain nodes can verify the amounts in a confidential transaction without learning the plain amounts, by performing the necessary additions for checking the balance equation on the homomorphic commitments instead of the plain amounts. However, this approach is only sound if the amounts do not overflow during the homomorphic addition, because this would allow an attacker to violate balance and thus create money out of thin air. To exclude overflow, transactions are required to carry a non-interactive zero-knowledge (NIZK) <em>range proof</em> that demonstrates that committed amounts are in a range <span class="math">[0,2^{b})</span> of non-negative integers much smaller than the message space of the commitment space.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Bulletproofs</h4>

    <p class="text-gray-300">Motivated by this application, the seminal Bulletproofs (BP) by Bünz et al. <em>[1]</em> was the first to achieve range proofs with an asymptotic size logarithmic in the number of bits in the range as well as concrete sizes less than <span class="math">1\\text{\\,}\\mathrm{kB}</span>. Moreover, BP supports aggregate proving, i.e., a single range proof can cover multiple commitments at once, and this proof is significantly more compact than proving each commitment separately. This efficiency makes it feasible to use BP in cryptocurrencies, and BP range proofs have been successfully deployed in Grin <em>[11]</em> and Monero <em>[12]</em> in conjunction with other privacy-preserving features. However, even though Monero has subsequently upgraded <em>[13]</em> to Chung et al. <em>[14]</em>’s recent improvement Bulletproofs+ (BP+), which reduces the size of a single 64-bit range proof to 576 bytes, range proofs still account for 29% to 42% of the size of a typical Monero transaction. These concrete storage costs as well as the concrete verification efficiency still leave much to be desired, considering that all nodes in a cryptocurrency are required to download and verify the entirety of all range proofs created within the system.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Multi-asset Confidential Transactions</h4>

    <p class="text-gray-300">While the initial CT proposal <em>[9]</em> supports only a single asset (e.g., only Bitcoin), the protocol by Poelstra et al. <em>[15]</em> (as deployed for instance in the Liquid sidechain <em>[16]</em>) extends the idea to <em>multi-asset confidential transactions</em> (MACT), i.e., a single transaction can transfer multiple assets simultaneously, and no observer can learn the transacted amounts or the involved assets. Moreover, the range proof construction used in this protocol supports multi-party proving for transactions created by multiple senders. This is a prerequisite to using coin mixing protocols <em>[17]</em> on top of MACT, which further enhance privacy.</p>

    <p class="text-gray-300">However, it is thus far unclear how to fully leverage the potential of BP in MACT protocols. While it is possible to implement the range proofs in MACT using BP, the protocol by Poelstra et al. <em>[15]</em> requires additional zero-knowledge proofs, called surjection proofs, to show that the assets on the output side of the transaction are a permutation of the assets on the input side of the transactions. These additional proofs are large and since they are constructed using techniques different from BP, it is not possible to aggregate them together with BP range proofs. The alternative approach taken by the Cloak <em>[18]</em> MACT protocol overcomes this problem by using BP to encode a permutation argument as an arithmetic circuit. This avoids surjection proofs, but the way the circuit is constructed makes it incompatible with known multi-party proving techniques for BP. In summary, there is currently no solution to MACT that is practical and compatible with BP.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Range</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BP++</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BP+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BP</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">10g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">15g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">16g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">10g + 5s</td>

            <td class="px-3 py-2 border-b border-gray-700">17g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">18g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">12g + 5s</td>

            <td class="px-3 py-2 border-b border-gray-700">19g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">20g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">14g + 5s</td>

            <td class="px-3 py-2 border-b border-gray-700">21g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">22g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">15g + 4s</td>

            <td class="px-3 py-2 border-b border-gray-700">23g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">24g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">18g + 5s</td>

            <td class="px-3 py-2 border-b border-gray-700">17g + 4s</td>

            <td class="px-3 py-2 border-b border-gray-700">26g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">19g + 4s</td>

            <td class="px-3 py-2 border-b border-gray-700">27g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">28g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">21g + 5s</td>

            <td class="px-3 py-2 border-b border-gray-700">31g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">32g + 5s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">384 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">21g + 5s</td>

            <td class="px-3 py-2 border-b border-gray-700">31g + 3s</td>

            <td class="px-3 py-2 border-b border-gray-700">32g + 5s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: BP++ range proof sizes compared to BP and BP+. The range column of the table  <span class="math">(m \\times n)</span>  indicates the number of aggregated proofs  <span class="math">(m)</span>  and bits of range proven  <span class="math">(n)</span>  by each proof. To allow for comparisons independent of the elliptic curve, we express the resulting proof size in terms of the number of group elements  <span class="math">g</span>  and scalars  <span class="math">s</span> .</p>

    <p class="text-gray-300">The main contribution of this work is Bulletproofs++ (BP++, a zero-knowledge argument of knowledge for arithmetic circuits in the discrete logarithm setting.</p>

    <p class="text-gray-300">Reciprocal Argument At the core of  <span class="math">\\mathrm{BP}++</span>  is the reciprocal argument, a novel interactive oracle proof (IOP) that generalizes permutation arguments and set membership arguments in the sense that it makes it possible to prove statements over objects similar to multi-sets. This approach builds on the work by Bayer and Groth [19], who encode a multiset as the roots of a polynomial, and whose basic technique has been extended to show richer permutation arguments in plookup [20] and plays a critical role in protocols based on Plonk [21]. These protocols use a "grand product", i.e., the product of numerous committed values, to show that a particular permutation, which encodes the structure of an arithmetic circuit, was applied correctly. The reciprocal argument of  <span class="math">\\mathrm{BP}++</span>  is essentially the logarithmic derivative of the polynomials used by Bayer-Groth permutation arguments. The logarithmic derivative transforms a product of linear factors into a sum, thereby linearizing the representation of the multiset.</p>

    <p class="text-gray-300">Since the initial publication of a preprint of our work, the reciprocal argument has already been used in several other works: Habock [22] modifies the "grand product" of Hyperplonk [23] to use a variant of the reciprocal argument, which he rederives via the logarithmic derivative. Eagen, Fiore, and Gabizon [24] develop a more asymptotically and concretely performant lookup argument, improving upon the sequence of works beginning with Caulk [25, 26]. As evident from these works, the reciprocal argument is clearly of independent interest.</p>

    <p class="text-gray-300">Compactness and Efficiency  <span class="math">\\mathrm{BP}++</span>  's novel techniques improve the compactness and efficiency of  <span class="math">\\mathrm{BP}(+)</span>  significantly. Table 1 compares the size of  <span class="math">\\mathrm{BP}++</span>  range proofs with BP and  <span class="math">\\mathrm{BP}+</span>  range proofs. As demonstrated by the table,  <span class="math">\\mathrm{BP}++</span>  has a clear advantage in terms of proof size compared to the alternative.</p>

    <p class="text-gray-300">The time needed for proving and verification is dominated in practice by multiplications of group elements with scalars. In BP and  <span class="math">\\mathrm{BP + }</span>  range proofs, the count of these multiplications scales linearly with  <span class="math">n</span> . However,  <span class="math">\\mathrm{BP + + }</span>  offers an asymptotic improvement, reducing the count to  <span class="math">O(n / \\log n)</span> . The benchmarks in Section 7 demonstrate that  <span class="math">\\mathrm{BP + + }</span> 's improvements do in fact translate to actual implementations. A 64-bit range proof takes roughly  <span class="math">4\\mathrm{ms}</span>  for proving and  <span class="math">0.9\\mathrm{ms}</span>  for verifying, making it  <span class="math">5\\times</span>  quicker than BP in proving and  <span class="math">3\\times</span>  quicker in verification.</p>

    <p class="text-gray-300">Modularity without Sacrificing Performance Since  <span class="math">\\mathrm{BP}++</span>  is capable of proving arbitrary statements encoded in arithmetic circuits, our range proofs construction is simply an arithmetic circuit encoding the range relation. As opposed to  <span class="math">\\mathrm{BP}(+)</span> , the resulting range proof is just barely less efficient than a "direct construction" of a range proof, which demonstrates the power of our techniques. Moreover,</p>

    <p class="text-gray-300">this approach simplifies the security analysis of the range proof to the correctness of the circuit and enhances its reusability in other applications.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">MACT</h4>

    <p class="text-gray-300">On the MACT side, we introduce a BP++ MACT protocol (again by specifying an arithmetic circuit) that relies on the same asset representation as Cloak but uses an instance of the reciprocal argument, substantially simplifying the permutation argument. The marginal cost of a BP++ MACT over an aggregated range proof is negligible in prover and verifier time, and proof size.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Compatibility with BP</h4>

    <p class="text-gray-300">Since BP++ maintains the same interface and security assumptions established by BP(+), BP++ is a drop-in replacement for existing uses of BP(+).</p>

    <p class="text-gray-300">For example, BP range proofs in existing protocols like Grin <em>[11]</em>, Monero <em>[12]</em>, and Liquid <em>[16]</em> can be replaced without any change in security assumptions and with only minimal modification to existing protocols. This is also true for statements encoded as general arithmetic circuits. Moreover, the MACT protocol uses the same asset representation as Cloak, and so can be directly substituted for Cloak for smaller proof sizes and faster prover and verifier. These replacements retain all benefits of BP:</p>

    <p class="text-gray-300">A prover who would like to prove multiple statements simultaneously can create a single aggregated proof, which is more compact than simply giving multiple independent proofs. For example, in the common case that a cryptocurrency transaction creates <span class="math">m\\geq 1</span> commitments, an aggregate range proof can prove that <span class="math">m</span> committed values are in range in just <span class="math">O(\\log n+\\log m)</span> bits, instead of <span class="math">m\\cdot O(\\log n)</span> bits in the case of <span class="math">m</span> separate range proofs. For the case that multiple provers want to create a single aggregated proof, BP++ offers a natural MPC protocol. Multi-party proving yields large space savings when CT is combined with coin mixing protocols <em>[27]</em>. Multiple (possibly aggregated) proofs can be verified in a batch computation, improving efficiency further. BP++ is provably secure assuming only the hardness of the discrete logarithm problem and can be made non-interactive in the random oracle model, thus ensuring compatibility with assumptions widely accepted by engineers and users in the cryptocurrency ecosystem. Concretely, BP++ neither requires pairings nor cycles of curves and can be instantiated on the secp256k1 elliptic curve which used in Bitcoin, for which a wide range of implementations exist. Since the public setup parameters only consist of random group elements, the setup is trustless assuming a common random string or the random oracle model.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Range Proofs</h4>

    <p class="text-gray-300">The complexity of the BP range protocol is roughly proportional to the number of digits in the range <span class="math">[A,B)</span>, which in the case of BP is <span class="math">n=\\lceil\\log_{2}(B-A)\\rceil</span>.</p>

    <p class="text-gray-300">Using larger bases, it is possible to reduce the number of digits. The optimal base for a given range is the value <span class="math">b</span> such that <span class="math">b^{b}\\approx B-A</span>, which allows representing the range using <span class="math">O(n/\\log n)</span> base <span class="math">b</span> digits. Such a base is used in the range proof protocol by Camenisch, Chaabouni, and shelat <em>[28]</em>. Their protocol is inherently interactive but achieves <span class="math">O(n/\\log n)</span> proof size by batching the set membership checks for each digit, which is on a high-level similar to the approach in BP++. An alternative to digit decomposition range proofs are those based on Lagrange’s four square theorem. This theorem states that any positive integer can be written as a sum of four squares, as originally proposed by Lipmaa <em>[29]</em>. In practice, this is often transformed to an instance of the three square theorem as was originally observed by Groth <em>[30]</em>. To show that a value <span class="math">v&amp;lt;B</span> one can find a four, or three, square decomposition of the value <span class="math">B-v</span>, which is positive only if the initial condition is met. These protocols require integer commitments, which historically required either RSA groups, and hence a trusted setup, or ideal class groups.</p>

    <p class="text-gray-300">More recently, Couteau et al. <em>[31]</em> developed a bounded integer commitment protocol that requires only the discrete logarithm assumption in a group of known order. This allows them to construct three-square range proofs using elliptic curves, which are highly performant and smaller than BP and BP+ range</p>

    <p class="text-gray-300">3While the protocol by Camenisch, Chaabouni, and shelat [28] uses Boneh-Boyen signatures, which also have the structure of a reciprocal, this reciprocal is not used in the same way as the reciprocal argument of \\mathrm{BP}++ , and alternative signature protocols can be used instead with different security assumptions.</p>

    <p class="text-gray-300">roofs. However, BP++ range proofs remain smaller as compared to their approach. Moreover, since their bounded integer commitment scheme requires the committed values to remain in a bounded interval, their approach requires a curve with order somewhat larger than 256 bits at the 128-bit security level. This lower bound on the group size or, equivalently, on the security of their approach is inherent and applies even if one ignores the non-tightness of the security analysis when setting parameters, as often done in practice. This limits their applicability to existing blockchains.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Generalizations of BP</h4>

    <p class="text-gray-300">There are a number of other works building on BP, including BP+ <em>[14]</em> which uses a weighted inner product argument to reduce proving time and uses several other improvements to reduce proof size, and Flashproofs <em>[32]</em> which combine the BP inner product argument with Groth polynomial commitments <em>[33]</em> to reduce verifier complexity and attempt to minimize Ethereum gas costs. There has also been work to unify BP with the large, existing body of work on Sigma protocols <em>[34]</em>, and to further generalize this to other related contexts like groups of unknown order <em>[35]</em> to support homomorphic commitments of arbitrary order. BP have also been generalized to inner product arguments in other contexts, including by Lee <em>[36]</em>, who propose a general purpose SNARK protocol over a pairing friendly curve that uses an inner product to avoid trusted setup requirements. BP are also core to the structure of Halo <em>[37]</em> and Halo2 <em>[38]</em>, which are now implemented in Zcash <em>[39]</em> and have inspired the development of accumulation schemes <em>[40]</em>. These allow a prover to efficiently aggregate multiple proofs in such a way that verification time depends only on the time to verify a single proof.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Preliminaries</h2>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Notation</h4>

    <p class="text-gray-300">Hereafter, we denote the set of <em>polynomially-bounded</em> functions in the security parameter <span class="math">\\lambda</span> by <span class="math">\\mathit{poly}(\\lambda)=\\{f:\\exists a\\in\\mathbb{N},\\ f(\\lambda)\\in O(\\lambda^{a})\\}</span>, the set of <em>negligible</em> functions in the security parameter <span class="math">\\lambda</span> by <span class="math">\\mathit{negl}(\\lambda)=\\{f:f(\\lambda)^{-1}\\not\\in\\mathit{poly}(\\lambda)\\}.</span> A function <span class="math">f</span> is <em>overwhelming</em> if <span class="math">1-f</span> is negligible.</p>

    <p class="text-gray-300">A probabilistic interactive Turing machine <span class="math">\\mathcal{A}</span> is <em>probabilistic polynomial-time (PPT)</em> if its runtime is in <span class="math">\\mathit{poly}(\\lambda)</span>; it is <em>probabilistic expected polynomial-time (expected-PPT)</em> if its expected runtime is in <span class="math">\\mathit{poly}(\\lambda)</span>; it is <em>deterministic polynomial-time (DPT)</em> if it is PPT and does not read from its randomness tape.</p>

    <p class="text-gray-300">We denote by <span class="math">\\mathbb{G}</span> a cyclic group of prime order <span class="math">p</span> written additively, which is in practice typically a subgroup of an elliptic curve. We write group elements in <span class="math">\\mathbb{G}</span> with capital letters and scalars in <span class="math">\\mathbb{F}:=\\mathbb{F}_{p}</span> with lower case letters. We write <span class="math">\\mathbb{F}[X]</span> for the ring of polynomials over <span class="math">\\mathbb{F}</span> in indeterminate <span class="math">X</span>; when we treat it a vector space, then as vector space over the field <span class="math">\\mathbb{F}</span>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Vectors</h4>

    <p class="text-gray-300">Vectors are written with bold letters, and matrices with capital letters. These can be distinguished from <span class="math">\\mathbb{G}</span> elements from context. We write the diagonal matrix of powers of <span class="math">\\mu</span> starting with <span class="math">\\mu^{0}</span> as <span class="math">\\mathrm{diag}(\\mu)</span>. Vectors are zero indexed and implicitly padded with zeros on the right as necessary for various operations to be well-defined, i.e. addition and inner products. We denote the vector of all zeros by <span class="math">\\mathbf{0}</span> and the vector of all ones by <span class="math">\\mathbf{1}</span>. To access a slice of a vector, we write <span class="math">(\\bm{v}_{k:})_{i}=\\bm{v}_{k+i}</span>.</p>

    <p class="text-gray-300">We write the inner product of two vectors using angle brackets and an optional subscript to denote weighting by powers of the subscript. If the subscript is not present, it is implicitly 1. Inner products are defined for any vectors of quantities that can be multiplied, i.e. scalars and scalars or scalars and group elements. The norm of a vector refers to its self inner product and uses the same subscripting convention for weights. For example, the weighted inner product of <span class="math">\\bm{x}</span> and <span class="math">\\bm{G}</span> and the weighted norm of <span class="math">\\bm{x}</span> are written</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\langle\\bm{x},\\bm{G}\\right\\rangle_{\\mu}=\\sum_{i=0}x_{i}G_{i}\\mu^{i+1}\\quad\\text{and}\\quad\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{x}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}=\\left\\langle\\bm{x},\\bm{x}\\right\\rangle_{\\mu}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We write concatenation of vectors using $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and tensor product of vectors using </span>\\otimes$. Iterated tensor product is evaluated from left to right and obeys the convention</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\bigotimes_{i=0}^{n}(1,x_{i})=\\left(1,x_{0},x_{1},x_{0}x_{1},x_{2},\\ldots,\\prod_{i=0}^{n}x_{i}\\right).</span></p>

    <p class="text-gray-300">This is convenient for describing, e.g., the vector of challenges used by the verifier for the norm linear argument.</p>

    <p class="text-gray-300">We denote the vector of powers from <span class="math">\\mu^{0}</span> to <span class="math">\\mu^{n-1}</span> by <span class="math">\\mathbf{e}_{n}(\\mu)</span>. It obeys the tensor product equation</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_{ab}(\\mu)=\\mathbf{e}_{a}(\\mu)\\otimes\\mathbf{e}_{b}(\\mu^{a})=(1,\\mu,\\ldots,\\mu^{ab-1}).</span></p>

    <p class="text-gray-300">We decompose vectors into subvectors of even (indices <span class="math">0</span>, <span class="math">2</span>, <span class="math">\\ldots</span>) and odd (indices <span class="math">1</span>, <span class="math">3</span>, <span class="math">\\ldots</span>) components, instead of left and right halves as in BP, written as written as <span class="math">[\\bm{a}]_{0}</span> and <span class="math">[\\bm{a}]_{1}</span> respectively. This transformation simplifies certain parts of the protocol, and may help with locality in implementations. BP and BP+ can easily be modified to use even and odd halves, as can BP++ to use left and right halves.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.1 Discrete Logarithm Relation Problem</h3>

    <p class="text-gray-300">BP++ is provably secure assuming the expected-PPT hardness of the <em>discrete logarithm relation (DLR) problem</em>, which is well-known to be tightly equivalent to the standard discrete logarithm problem <em>[41, Lemma 3]</em>. The DLR problem is, given a random collection of points in <span class="math">\\mathbb{G}</span>, the problem to find a non-trivial <span class="math">\\bm{a}\\neq\\bm{0}</span> such that <span class="math">\\langle\\bm{a},\\bm{G}\\rangle=0_{\\mathbb{G}}</span>, where <span class="math">0_{\\mathbb{G}}</span> is the identity in <span class="math">\\mathbb{G}</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 1 (Discrete Logarithm Relation (DLR) Problem).</h6>

    <p class="text-gray-300">The <em>discrete logarithm relation (DLR) problem in <span class="math">\\mathbb{G}</span></em> is hard if for all <span class="math">n\\geq 1</span> and for all expected-PPT adversaries <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle\\bm{a},\\bm{G}\\rangle=0_{\\mathbb{G}}\\wedge\\bm{a}\\neq\\bm{0}\\mid\\bm{G}\\leftarrow\\sharp\\mathbb{G}^{n};\\bm{a}\\leftarrow\\mathcal{A}(\\bm{G})]\\leq\\text{negl}(\\lambda).</span></p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.2 Zero-Knowledge Arguments of Knowledge</h3>

    <p class="text-gray-300">A zero-knowledge argument of knowledge consists of a non-interactive PPT Turing machine <span class="math">\\mathcal{K}</span> which outputs a <em>common random string</em> <span class="math">\\sigma</span>, and two interactive PPT Turing machines <span class="math">\\mathcal{P}</span> (prover) and <span class="math">\\mathcal{V}</span> (verifier). Critically, <span class="math">\\sigma</span> does not have any internal structure and can be chosen transparently, without a trusted setup. The prover and verifier interacting on inputs <span class="math">x</span> and <span class="math">y</span> will produce a transcript <span class="math">\\pi</span> and output a bit <span class="math">b</span> indicating whether the verifier accepts, which we write <span class="math">\\pi\\leftarrow\\langle\\mathcal{P}(x),\\mathcal{V}(y)\\rangle=b</span>. For any <span class="math">\\sigma</span>, a value <span class="math">w</span> is a <em>witness</em> for a <em>statement</em> <span class="math">x</span> if it satisfies the polynomial time relation <span class="math">(\\sigma,x,w)\\in\\mathcal{R}</span>.</p>

    <p class="text-gray-300">A zero-knowledge argument of knowledge must satisfy completeness, soundness, and zero-knowledge. Completeness requires that the prover be able to convince the verifier to accept <span class="math">x</span> with overwhelming probability if <span class="math">(\\sigma,x,w)\\in\\mathcal{R}</span>. Soundness requires that the prover fail with overwhelming probability to convince the verifier to accept if <span class="math">(\\sigma,x,w)\\notin\\mathcal{R}</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 2 (Completeness).</h6>

    <p class="text-gray-300">A triple <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfies perfect <em>completeness</em> if for all PPT <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\biggl{[}\\begin{array}[]{c}\\langle\\mathcal{P}(\\sigma,u,w),\\mathcal{V}(\\sigma,u)\\rangle=1\\\\ \\vee(\\sigma,u,w)\\not\\in\\mathcal{R}\\end{array}\\begin{array}[]{c}\\sigma\\leftarrow\\mathcal{K}(1^{\\lambda});\\\\ (u,w)\\leftarrow\\mathcal{A}(\\sigma)\\end{array}\\biggr{]}=1. \\]</p>

    <p class="text-gray-300">The soundness notion we consider in this work is computational witness-extended emulation <em>[42, 43]</em>. This demonstrates that for any prover convincing the verifier of a statement with a particular probability, there exists an emulator producing transcript indistinguishable from a real transcript and a witness with probability negligibly different from the prover. The emulator can rerun the prover with the same internal state but different randomness in order to solve for a witness from the transcript. Since the emulator can always extract the witness from a proof, the proof is a sound argument of knowledge for the witness.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 3 (Computational Witness-Extended Emulation).</h6>

    <p class="text-gray-300">The protocol <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> has WEE if for all DPT provers <span class="math">\\mathcal{P}^{<em>}</span>, there exists an expected-PPT emulator <span class="math">\\mathcal{E}^{\\mathsf{O}}</span> with access to rewinding oracle <span class="math">\\mathsf{O}=\\langle\\mathcal{P}^{</em>}(\\sigma,u,s),\\mathcal{V}(\\sigma,u)\\rangle</span> such that for all pairs of adversaries <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\bigl{[}\\mathcal{A}_{2}(\\sigma,\\pi)=1\\mid\\sigma\\leftarrow\\mathcal{K}(1^{\\lambda});(u,s)\\leftarrow\\mathcal{A}_{1}(\\sigma);\\pi\\leftarrow\\mathsf{O}\\bigr{]}</span> \\[ -\\Pr\\biggl{[}\\begin{array}[]{c}(\\pi\\text{ is accepting}\\Rightarrow\\\\ (\\sigma,u,w)\\in\\mathcal{R})\\\\ \\wedge\\mathcal{A}_{2}(\\sigma,\\pi)=1\\end{array}\\begin{array}[]{c}\\sigma\\leftarrow\\mathcal{K}(1^{\\lambda});\\\\ (u,s)\\leftarrow\\mathcal{A}_{1}(\\sigma);\\\\ (\\pi,w)\\leftarrow\\mathcal{E}^{\\mathsf{O}}(\\sigma,u)\\end{array}\\biggr{]}\\leq\\text{negl}(\\lambda). \\]</p>

    <p class="text-gray-300">The protocol has CWEE when adversaries <span class="math">A_{1}</span> and <span class="math">A_{2}</span> are restricted to non-uniform polynomial time.</p>

    <p class="text-gray-300">The zero-knowledge property requires that the verifier learns nothing about the witness from interacting with an honest prover. This is formalized via the existence of a simulator that is able to construct an identically distributed proof without knowledge of the witness. In the notion used here, the simulator has access to randomness used by the verifier; this is commonly called “special” zero-knowledge in the literature and requires the protocol to be public coin.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 4 (Public Coin).</h6>

    <p class="text-gray-300">The protocol <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> is public coin if all the verifier’s randomness is drawn uniformly at random independently of interaction with the prover.</p>

    <p class="text-gray-300">Definition 5 (Perfect Special Honest Verifier Zero-Knowledge). The protocol  <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  has perfect Special Honest Verifier Zero-Knowledge (SHVZK) if there exists a simulator  <span class="math">\\mathcal{S}</span>  such that for all pairs of adversaries  <span class="math">(\\mathcal{A}_1,\\mathcal{A}_2)</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} (\\sigma , u, w) \\in \\mathcal {R} &amp;amp; \\sigma \\leftarrow \\mathcal {K} (1 ^ {\\lambda}); (u, w, \\rho) \\leftarrow \\mathcal {A} _ {1} (\\sigma); \\\\ \\wedge \\mathcal {A} _ {2} (\\sigma , \\pi) = 1 &amp;amp; \\pi \\leftarrow \\langle \\mathcal {P} (\\sigma , u, w), \\mathcal {V} (\\sigma , u; \\rho) \\rangle \\end{array} \\right] \\\\ = \\Pr \\left[ \\begin{array}{c c} (\\sigma , u, w) \\in \\mathcal {R} &amp;amp; \\sigma \\leftarrow \\mathcal {K} (1 ^ {\\lambda}); (u, w, \\rho) \\leftarrow \\mathcal {A} _ {1} (\\sigma); \\\\ \\wedge \\mathcal {A} _ {2} (\\sigma , \\pi) = 1 &amp;amp; \\pi \\leftarrow \\mathcal {S} (u, \\rho) \\end{array} \\right]. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">General Forking Lemma To show CWE, BP++ will use the generalized forking lemma by Bootle et al. [44] (Lemma 2 in Appendix C). It allows handling extractors for multi-round zero-knowledge argument of knowledge generically.</p>

    <p class="text-gray-300">Trustless Common Setup As a convention, all zero-knowledge arguments presented in this paper use the same setup algorithm  <span class="math">\\mathcal{K}</span> , which outputs  <span class="math">\\sigma = (G, H, G)</span> , where  <span class="math">G</span>  and the components of the two vectors  <span class="math">H, G</span>  (of sufficient size, which will be clear from the context) are random generators in  <span class="math">\\mathbb{G}</span> . Since  <span class="math">\\mathcal{K}</span>  is transparent, it is possible to use make the setup trustless in the random oracle model.</p>

    <p class="text-gray-300">Non-Interactive Proofs from Fiat-Shamir All zero-knowledge arguments presented in this paper are public coin, interactive protocols between a prover and honest verifier. This means that they can be made non-interactive via the Fiat-Shamir transform [45], and honest-verifier zero-knowledge of the interactive protocols immediately implies that the Fiat-Shamir transformed variants are non-interactive zero-knowledge in the random oracle model. Recent work has shown that also soundness is retained, even for multi-round protocols [48, 49, 50]. Concretely, we establish that our protocols achieve special soundness, which implies that their Fiat-Shamir version achieves knowledge soundness as shown by Attema, Fehr, and Kloos [48, Theorem 4] and further elaborated on by Ganesh et al. [51, Section 2.8].</p>

    <p class="text-gray-300">Commitments as Inputs Our zero-knowledge arguments accept witness inputs in Pedersen vector commitments. For convenience later, given generators  <span class="math">\\sigma = (G,H,\\ldots)</span>  from the zero-knowledge setup, we define a commitment to message  <span class="math">\\pmb{v}</span>  with randomness  <span class="math">s</span>  to be</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m} (\\boldsymbol {m}; s) = v _ {0} G + s H _ {0} + \\left\\langle \\boldsymbol {v} _ {1:}, \\boldsymbol {H} _ {8:} \\right\\rangle .</span></div>

    <p class="text-gray-300">Generators  <span class="math">H_0, \\ldots, H_7</span>  are intentionally not used for commitments to simplify the notation in later sections.</p>

    <p class="text-gray-300">Pedersen commitments are homomorphic, perfectly hiding, and computationally binding up to the hardness of the discrete logarithm relation problem. We omit a formal treatment of these properties because the security analysis of our protocols uses the underlying group directly and does not invoke these abstract properties.</p>

    <p class="text-gray-300">BP++ consists of four primary improvements over earlier, transparent discrete logarithm-based range proof protocols. First, we substitute the BP+ weighted inner product argument by a weighted norm argument, which reduces verifier time by approximately half in many common cases. Second, we introduce a novel set membership and permutation argument based on logarithmic derivatives called the reciprocal argument, which has already found significant applications beyond BP++. Third, we modify the BP arithmetic circuit protocol to accomplish "blinding" in one round of communication of a single group element, which can be easily adapted to other similarly constructed protocols. These modified circuits are extended to support first order use of the reciprocal argument, similarly to integration of plookup [20] into Halo2 [38]. Finally, we use these techniques to construct the shortest, and most verifier performant transparent range proof and MACT protocols.</p>

    <p class="text-gray-300">4The Fiat-Shamir transform replaces every verifier message with the invocation of a hash function applied to the entire proof transcript up to that point. The transcript must include the problem statement and all prover communication with the verifier. Failure to properly implement the Fiat-Shamir heuristic has been a common source of bugs [46, 47].</p>

    <p class="text-gray-300">3.1 Bulletproofs and Bulletproofs+</p>

    <p class="text-gray-300">BP uses a recursive argument to show the inner product relation</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\left(\\bm{G},\\bm{H}\\in\\mathbb{G}^{n},G\\in\\mathbb{G};C\\in\\mathbb{G};\\bm{x},\\bm{y}\\in\\mathbb{Z}_{p}^{n}\\right):C=\\langle\\bm{x},\\bm{y}\\rangle G+\\langle\\bm{x},\\bm{G}\\rangle+\\langle\\bm{y},\\bm{H}\\rangle\\right\\}.</span> (1)</p>

    <p class="text-gray-300">The recursive structure of the argument is itself derived from the recursive structure in Bootle et al. <em>[44]</em>. In each round, a commitment to a scalar <span class="math">v</span> and vectors <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span> of length <span class="math">n</span> is reduced to a commitment to vectors <span class="math">\\bm{x}^{\\prime}</span> and <span class="math">\\bm{y}^{\\prime}</span> of length <span class="math">n/2</span>. If this commitment satisfies the relation, then the original commitment satisfies the relation with overwhelming probability.</p>

    <p class="text-gray-300">In our notation, given a commitment <span class="math">C</span>, the prover sends the verifier commitments <span class="math">(L,R)</span>, and the verifier chooses a challenge <span class="math">\\gamma</span>. The reduced commitment is defined as</p>

    <p class="text-gray-300"><span class="math">C^{\\prime}=C+\\gamma^{-2}L+\\gamma^{2}R=v^{\\prime}G+\\langle\\bm{x}^{\\prime},\\bm{G}^{\\prime}\\rangle+\\langle\\bm{y}^{\\prime},\\bm{H}^{\\prime}\\rangle.</span> (2)</p>

    <p class="text-gray-300">Each round of the protocol forms essentially a vector valued polynomial commitment. The key to ensuring that the reduced vectors are of length <span class="math">n/2</span> comes from the folding relation. The reduced vectors are defined, in terms of the challenge</p>

    <p class="text-gray-300"><span class="math">\\bm{x}^{\\prime}=\\gamma[\\bm{x}]_{0}+\\gamma^{-1}[\\bm{x}]_{1}\\qquad\\bm{y}^{\\prime}=\\gamma^{-1}[\\bm{y}]_{0}+\\gamma[\\bm{y}]_{1}.</span> (3)</p>

    <p class="text-gray-300">Computing the inner product of these vectors as polynomials in <span class="math">\\gamma</span>, we find that the original inner product <span class="math">\\langle\\bm{x},\\bm{y}\\rangle</span> from the inner product relation occurs as the <span class="math">\\gamma^{0}</span> term</p>

    <p class="text-gray-300"><span class="math">\\langle\\bm{x}^{\\prime},\\bm{y}^{\\prime}\\rangle=\\langle\\bm{x},\\bm{y}\\rangle+\\gamma^{-2}\\langle[\\bm{x}]_{0},[\\bm{y}]_{1}\\rangle+\\gamma^{2}\\langle[\\bm{x}]_{1},[\\bm{y}]_{0}\\rangle.</span> (4)</p>

    <p class="text-gray-300">BP applies this same relation to the inner products between the basis points <span class="math">\\bm{G}</span> and <span class="math">\\bm{H}</span> and the witness vectors. That is, the reduced basis points are defined in terms of <span class="math">\\gamma</span> to be</p>

    <p class="text-gray-300"><span class="math">\\bm{G}^{\\prime}=\\gamma^{-1}[\\bm{G}]_{0}+\\gamma[\\bm{G}]_{1}\\qquad\\bm{H}^{\\prime}=\\gamma[\\bm{H}]_{0}+\\gamma^{-1}[\\bm{H}]_{1}.</span> (5)</p>

    <p class="text-gray-300">This means when the inner products <span class="math">\\langle\\bm{x}^{\\prime},\\bm{G}^{\\prime}\\rangle</span> and <span class="math">\\langle\\bm{y}^{\\prime},\\bm{H}^{\\prime}\\rangle</span> are evaluated, the original inner products will appear on the <span class="math">\\gamma^{0}</span> term. The <span class="math">\\gamma^{-2}</span> coefficients from all three reduced inner products are then collected into <span class="math">L</span> and likewise the <span class="math">\\gamma^{2}</span> coefficients into <span class="math">R</span>. This reduction is applied until the reduced vectors are of length <span class="math">2</span>, at which point the reduced vectors are sent to the verifier.</p>

    <p class="text-gray-300">BP+ uses a very similar recursive structure that also incorporates weights to show a weighted inner product relation, with the inner product replaced by a weighted inner product. BP+ also differs in how it handles blinding, but BP++ behaves like BP in this regard.</p>

    <p class="text-gray-300">Both BP and BP+ construct a range proof by decomposing the value into binary digits and proving the validity of each digit, then showing that the linear combination of these digits equals the committed value. Binary digits are used since their validity is easy to check: <span class="math">d\\in\\{0,1\\}</span> if and only if <span class="math">d(d-1)=0</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.2 Reciprocal Argument</h3>

    <p class="text-gray-300">The primary technique that makes BP++ range proofs and MACT possible is the reciprocal argument. Let <span class="math">A</span> be a collection of pairs of multiplicities and values <span class="math">(m\\in\\mathbb{F},v\\in\\mathbb{F})\\in A</span>. The reciprocal argument is a simple interactive protocol by which the prover can convince a verifier that the total multiplicity <span class="math">\\hat{m}_{v}</span> for each value <span class="math">v\\in\\mathbb{F}</span> vanishes. In that case, we say <span class="math">A</span> vanishes.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">Let <span class="math">A</span> be a collection of pairs of multiplicities and values. Let the total multiplicity of a value <span class="math">v\\in\\mathbb{F}</span> in <span class="math">A</span> be <span class="math">\\hat{m}_{v}(A)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\hat{m}_{v}=\\sum_{(m^{\\prime},v^{\\prime})\\in A:v=v^{\\prime}}m^{\\prime}.</span></p>

    <p class="text-gray-300">We say <span class="math">A</span> vanishes if <span class="math">\\forall v\\in\\mathbb{F}:\\hat{m}_{v}(A)=0</span>. When <span class="math">A</span> is clear from context, we will write <span class="math">\\hat{m}_{v}</span>.</p>

    <p class="text-gray-300">The underlying idea of the protocol is that we can associate to <span class="math">A</span> a rational function <span class="math">f_{A}(X)</span> defined as a sum of poles at each <span class="math">-v</span> with multiplicity <span class="math">m</span> for <span class="math">(m,v)\\in A</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f_{A}(X)=\\sum_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}\\frac{m_{i}}{X+v_{i}}.$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This rational function vanishes if and only if the total multiplicity for each symbol vanishes. To show that this function vanishes, it suffices to evaluate it at a uniformly random value. This follows from a modification of the Schwartz-Zippel lemma.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">3.2.1 The Logarithmic Derivative</h4>

    <p class="text-gray-300">The rational function <span class="math">f_{A}(X)</span> has the structure of a logarithmic derivative. The logarithmic derivative of a function <span class="math">f(X)</span> is the derivative of the logarithm of <span class="math">f(X)</span> with respect to <span class="math">X</span>, i.e., <span class="math">(\\log f)^{\\prime}(X)</span> for <span class="math">(\\log f)(X)=\\log(f(X))</span>. Ordinarily, logarithms are not well-defined over a finite field, but in this case we can apply the chain rule to simplify</p>

    <p class="text-gray-300"><span class="math">(\\log f)^{\\prime}(X)=\\frac{f^{\\prime}(X)}{f(X)}.</span> (7)</p>

    <p class="text-gray-300">This expression is well-defined over a finite field when <span class="math">f(X)</span> is a rational function. Since the derivative is linear and the logarithm is a group homomorphism taking multiplication to addition, the logarithmic derivative takes <span class="math">\\mathbb{F}(X)^{\\times}\\to\\mathbb{F}(X)^{+}</span>. Using the product rule, we can check this directly since</p>

    <p class="text-gray-300"><span class="math">\\frac{f^{\\prime}(X)}{f(X)}+\\frac{g^{\\prime}(X)}{g(X)}=\\frac{f^{\\prime}(X)g(X)+f(X)g^{\\prime}(X)}{f(X)g(X)}=\\frac{(fg)^{\\prime}(X)}{(fg)(X)}.</span> (8)</p>

    <p class="text-gray-300">Consider the function <span class="math">g_{A}(X)</span> for <span class="math">A</span> as defined before as a collection of pairs of multiplicities and values</p>

    <p class="text-gray-300"><span class="math">g_{A}(X)=\\prod_{(m,v)\\in A}(X+v)^{m}.</span> (9)</p>

    <p class="text-gray-300">Applying the logarithmic derivative to this polynomial, the product becomes a sum of <span class="math">m</span> times the logarithmic derivative of <span class="math">X+v</span>. This logarithmic derivative simplifies to become <span class="math">1/(X+v)</span> since the derivative of <span class="math">X+v</span> is <span class="math">1</span>. So we have</p>

    <p class="text-gray-300"><span class="math">(\\log g_{A})^{\\prime}(X)=\\sum_{(v,m)\\in A}\\frac{m}{X+v}=f_{A}(X).</span> (10)</p>

    <p class="text-gray-300">This is the sense in which <span class="math">f_{A}(X)</span> is a logarithmic derivative.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">3.2.2 Application to Range Proofs</h4>

    <p class="text-gray-300">Consider the problem of proving a base-<span class="math">b</span> range proof. We want to prove knowledge of some digits <span class="math">\\boldsymbol{d}</span> such that each <span class="math">d_{i}\\in[0,b-1]</span>, and that these are the base-<span class="math">b</span> digits of some value <span class="math">v</span>.</p>

    <p class="text-gray-300">A natural solution is to use a lookup argument: given a collection of values <span class="math">t_{j}\\in T</span> called the “table” and a collection of values <span class="math">v_{i}\\in V</span>, a lookup argument shows that all elements of <span class="math">V</span> occur in <span class="math">T</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can use the reciprocal argument to construct a lookup argument by using the reciprocal argument on <span class="math">A=\\{(-1,v_{i}):i\\}\\cup\\{(m_{j},t_{j}):j\\}</span>. Note that the largest magnitude multiplicity for an element <span class="math">v_{i}\\in V</span> is $-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which occurs when </span>V<span class="math"> contains only a single element. As long as </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, this means that the total multiplicity of </span>v_{i}\\in V<span class="math"> can only vanish if </span>v_{i}<span class="math"> occurs in </span>T<span class="math">. Therefore, the prover can convince the verifier that all elements of </span>V<span class="math"> are in </span>T<span class="math"> if </span>A<span class="math">. For a base </span>b<span class="math"> range proof, </span>T=\\{0,\\ldots,b-1\\}<span class="math"> and </span>V<span class="math"> consisting of all the digits </span>d_{i}<span class="math">, the rational function </span>f_{A}(X)$ is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f_{A}(X)=-\\sum_{i}\\frac{1}{X+d_{i}}+\\sum_{j=0}^{b-1}\\frac{m_{j}}{X+j}.</span> (11)</p>

    <p class="text-gray-300">The BP range proof construction uses the binary case <span class="math">b=2</span>, for which it is easy to check directly that <span class="math">d_{i}(d_{i}-1)=0</span> with one multiplication per digit. However, Camenisch, Chaabouni, and shelat <em>[28]</em> suggest to select <span class="math">b</span> such that <span class="math">b^{b}\\approx B-A</span>. This base uses only <span class="math">O(n/\\log n)</span> digits, where <span class="math">n=\\lceil\\log_{2}(B-A)\\rceil</span>, which is optimal in the sense that the witness length is a function of the base <span class="math">b</span> and the number <span class="math">n</span> of digits and is minimized when they are equal.</p>

    <p class="text-gray-300">Unfortunately, the natural generalization of the binary digit check <span class="math">d_{i}(d_{i}-1)</span> to bases <span class="math">b&gt;2</span> does not result in a more efficient proof in BP. In the binary case, each digit requires a single multiplication, but the number of multiplications increases linearly in the size of the base. What we really want is an efficient lookup argument, which is where the reciprocal argument comes in. Rather than checking each digit is the root of some polynomial separately as in BP, we can use Eq. (11) to check membership of each digit in the set of valid digits. This enables us to construct range proofs with “optimal” base while retaining efficiency.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">3.2.3 Application to MACT</h4>

    <p class="text-gray-300">For MACT, we face a related problem when proving multi-asset conservation of money. In this case, we have two collections of amounts and types of tokens <span class="math">I</span> and <span class="math">O</span> corresponding to the inputs and outputs of a transaction. We want to show that the total amount of each token in <span class="math">I</span> is equal to the total amount of each token in <span class="math">O</span> and that each amount in <span class="math">I</span> and <span class="math">O</span> is a positive integer. The latter claim can be shown using a range proof and the former using a new invocation of the reciprocal argument. Let <span class="math">A=\\{(v,t):(v,t)\\in I\\}\\cup\\{(-v,t):(v,t)\\in O\\}</span>. If <span class="math">A</span> vanishes then the sum of all the amounts in <span class="math">I</span> equals the sum of all the amounts in <span class="math">O</span> for each token <span class="math">t</span>. If the amounts are all positive integers much smaller than <span class="math">p</span>, it follows that no tokens were created or destroyed in the transaction. In this case <span class="math">f_{A}(X)</span> is</p>

    <p class="text-gray-300"><span class="math">f_{A}(X)=\\sum_{(v,t)\\in I}\\frac{v}{X+t}-\\sum_{(v,t)\\in O}\\frac{v}{X+t}.</span> (12)</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">3.3 Norm Linear Argument</h3>

    <p class="text-gray-300">As described in Section 3.1, BP and BP+ show a (weighted) inner product relation involving two vectors <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span> by letting the prover send commitments for both <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span>. This introduces undesirable redundancy in some cases. Consider the motivating example of a binary range proof: A prover wants to show <span class="math">d_{i}(d_{i}-1)=0</span> for each digit <span class="math">d_{i}</span> in the digit vector <span class="math">\\bm{d}</span> that encodes the binary representation of some value <span class="math">v</span>. In a BP range proof, this requires committing to both <span class="math">\\bm{x}=\\bm{d}</span> and <span class="math">\\bm{y}=-(\\bm{1}-\\bm{d})</span>, even though <span class="math">\\bm{y}</span> is entirely determined by <span class="math">\\bm{x}</span> up to the addition of a constant.</p>

    <p class="text-gray-300">Towards a BP++ binary range proof, we can rewrite <span class="math">d_{i}(d_{i}-1)=0</span> and consider the equivalent constraint <span class="math">(d_{i}-1/2)^{2}=1/4</span> instead. This allows us to substitute the inner product relation by a norm relation, which is a relation involving the inner product of a <em>single</em> vector with itself, and thus requires only a commitment to that single vector. As a result, we not only save data to be committed and hence communication, but also roughly half the prover and verifier cost.</p>

    <p class="text-gray-300">However, while this motivating example provides an intuition for why a norm relation can be preferable over an inner product relation, it turns out that in practice, it is almost always more efficient to use a BP++ reciprocal range proof instead of a BP++ binary range proof. As a consequence, we defer the details of BP++ binary range proofs to Appendix A, and now turn our attention towards arithmetic circuits instead.</p>

    <p class="text-gray-300">In the case of arithmetic circuits, similarly as for binary range proofs, using a norm argument allows reducing the verifier time by half, provided we can commit to only a single vector per commitment instead of two. Unfortunately, the inner product relation of BP and the weighted inner product relation of BP+ cannot work for this purpose, since even if the initial <span class="math">\\bm{x}=\\bm{y}</span> the reduction is asymmetric so <span class="math">\\bm{x}^{\\prime}\\neq\\bm{y}^{\\prime}</span>. To show a norm relation, we need a new reduction technique that is symmetric in the way it reduces <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span>. Unlike BP, the reduced vectors are now defined to be</p>

    <p class="text-gray-300"><span class="math">\\bm{x}^{\\prime}=[\\bm{x}]_{0}+\\gamma[\\bm{x}]_{1}\\qquad\\bm{y}^{\\prime}=[\\bm{y}]_{0}+\\gamma[\\bm{y}]_{1}.</span> (13)</p>

    <p class="text-gray-300">The reduction can be derived by computing the coefficients of the three polynomials <span class="math">1,\\gamma,\\gamma^{2}-1\\in\\mathbb{F}[\\gamma]</span> where in BP we computed the coefficients of the polynomials <span class="math">\\gamma^{-2},1,\\gamma^{2}\\in\\mathbb{F}[\\gamma]</span>. Since these polynomials are linearly independent in <span class="math">\\mathbb{F}[\\gamma]</span>, the reduction is sound. Setting <span class="math">\\bm{x}=\\bm{y}=\\bm{n}</span> we can show a norm relation, and with some modifications can show a weighted norm relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A norm by itself is not sufficient; we want to be able to show that the witness satisfies linear constraints without introducing extraneous terms. We can apply this reduction relation to an inner product of an additional vector <span class="math">\\bm{l}</span> and a public constraint vector <span class="math">\\bm{c}</span>. This will be especially relevant when handling the blinding procedure for arithmetic circuits and also helps in the MPC proving setting. Thus, BP++ will show the weighted norm linear relation for a witness <span class="math">(v,\\bm{l},\\bm{n})</span> and public <span class="math">(\\mu,\\bm{c})</span> satisfy $v=\\langle\\bm{c},\\bm{l}\\rangle+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">3.4 Arithmetic Circuits</p>

    <p class="text-gray-300">In BP and BP+, arithmetic circuits are given as a separate protocol from range proofs. The circuit is encoded as four matrices a vector <span class="math">(W_{L},W_{R},W_{O},W_{V},\\bm{c})</span> and a witness <span class="math">(\\bm{a}_{L},\\bm{a}_{R},\\bm{a}_{O},\\bm{v})</span> satisfies the circuit if</p>

    <p class="text-gray-300"><span class="math">W_{L}\\bm{a}_{L}+W_{R}\\bm{a}_{R}+W_{O}\\bm{a}_{O}=W_{V}\\bm{v}+\\bm{c}</span> (14) <span class="math">\\bm{a}_{L}\\circ\\bm{a}_{R}=\\bm{a}_{O}.</span></p>

    <p class="text-gray-300">While one could use an arithmetic circuit to prove a range proof in BP, it would be less efficient than the specialized range proof protocol. In the BP protocol for circuits, the prover constructs a vector valued polynomial commitment to some <span class="math">(v(X),\\bm{x}(X),\\bm{y}(X))</span> and wants to show that when we apply the inner product equation to this witness, the <span class="math">X^{2}</span> term of the <span class="math">t(X)=v(X)-\\langle\\bm{x}(X),\\bm{y}(X)\\rangle</span> vanishes. To show this, the prover commits to all the other “error” terms of <span class="math">t(X)</span> in Pedersen scalar commitments in <span class="math">T_{1},T_{3},T_{4},T_{5},T_{6}</span>.</p>

    <p class="text-gray-300">BP++ arithmetic circuits avoids these extra commitments, as well as the two final commitments necessary to blind in both BP and BP+. Rather than committing to these other terms in scalar commitments, we commit to them as a vector in the final blinding commitment. This is free, and conveniently generalizes to larger polynomials without increasing proof size. The norm linear argument naturally allows us to evaluate the committed <span class="math">t(X)</span> at a random <span class="math">X</span> by placing the coefficients in <span class="math">\\bm{l}</span> and changing the <span class="math">\\bm{c}</span> vector to be powers of <span class="math">X</span>. We are then able to use the other commitments in the proof to blind these error terms at no additional cost in terms of proof size. This procedure is responsible for the much of the reduction in proof size.</p>

    <p class="text-gray-300">BP++ also modifies the circuit protocol so that instead of the constraint <span class="math">\\bm{a}_{L}\\circ\\bm{a}_{R}=\\bm{a}_{O}</span>, the arithmetic circuit checks that <span class="math">\\bm{a}_{L}\\circ\\bm{a}_{R}</span> equals a linear combination of the entire witness. Here, the operation <span class="math">\\circ</span> is the component-wise product of vectors, also known as the Hadamard product.</p>

    <p class="text-gray-300">This makes it efficient to formulate reciprocal constraints, where the denominators occur in <span class="math">\\bm{a}_{L}</span>, the reciprocals in <span class="math">\\bm{a}_{R}</span>, and the numerators can be any linear combination on the right hand side. This new arithmetic circuit protocol allows encoding reciprocal range proofs and MACT more efficiently than existing protocols without the use of specialized protocols.</p>

    <h2 id="sec-29" class="text-2xl font-bold">4 Norm Linear Argument</h2>

    <p class="text-gray-300">Unlike BP and BP+ which show inner product relations, BP++ is an argument of knowledge for the weighted norm linear relation</p>

    <p class="text-gray-300">\\[ \\left\\{\\left(\\begin{array}[]{cc}\\bm{H}\\in\\mathbb{G}^{l},\\bm{G}\\in\\mathbb{G}^{n},G\\in\\mathbb{G};\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\in\\mathbb{G},\\bm{c}\\in\\mathbb{F}^{n},\\mu\\in\\mathbb{F};\\bm{l}\\in\\mathbb{Z}_{p}^{l},\\bm{n}\\in\\mathbb{Z}_{p}^{n}\\end{array}\\right):\\begin{array}[]{cc}v=\\langle\\bm{c},\\bm{l}\\rangle+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C=vG+\\langle\\bm{l},\\bm{H}\\rangle+\\langle\\bm{n},\\bm{G}\\rangle\\end{array}\\right\\}. \\] (15)</p>

    <p class="text-gray-300">There are two practical advantages to using a norm linear argument over an inner product argument. First, certain types of constraints can be more efficiently expressed as a square. In particular, the binary digit constraint of BP <span class="math">b(b-1)=0</span> can be rewritten in terms of a square. The inner product version requires committing to both factors in the product, whereas the squared version requires only committing to one factor. Given a suitable norm linear argument, this reduces the verifier complexity by half.</p>

    <p class="text-gray-300">The second advantage comes in the arithmetic circuit blinding protocol. Unlike BP and BP+ which perform blinding after committing to the circuit witness, or in the case of BP+ after performing the argument, over the course of two additional rounds, BP++ arithmetic circuit protocol is able to perform blinding using a single round. This relies on the linear portion of commitment <span class="math">\\bm{l}</span> and is particularly convenient to express using the norm linear argument. This blinding procedure is responsible for much of the reduction in proof size as compared to the predecessor protocols and means that norm linear argument protocols are able to have uniformly smaller proof sizes than existing inner product protocols.</p>

    <p class="text-gray-300">This relation is equivalent to the weighted inner product relation, in the sense that both are capable of proving arithmetic circuit satisfiability and more narrowly in the sense that one could, in principle, write the norm linear relation as an inner product and thus construct a norm linear argument by reducing directly to an inner product argument. However, the latter requires committing to the vector <span class="math">\\bm{n}</span> twice, in both <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span> from the inner product relation. While it is possible to simplify the initial commitment, by computing <span class="math">\\langle\\bm{n},\\bm{G}+\\bm{H}\\rangle</span> in the inner product commitment, the vectors <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span> are reduced asymmetrically. This means that even if <span class="math">\\bm{x}=\\bm{y}</span> it is not the case that <span class="math">\\bm{x}^{\\prime}\\neq\\bm{y}^{\\prime}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">4.1 Norm Reduction</p>

    <p class="text-gray-300">This makes clear what we want from a norm linear argument: given a commitment <span class="math">C</span> to vectors as defined in the relation, we want to reduce this commitment to a new commitment to vectors <span class="math">\\bm{l}^{\\prime}</span> and <span class="math">\\bm{n}^{\\prime}</span> of half the length of the original vectors. To this end, we need a folding relation for a pair of vectors that treats both vectors symmetrically. That is, instead of scaling the halves of <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span> by complementary <span class="math">\\gamma</span> and <span class="math">\\gamma^{-1}</span>, we would like to use reduced vectors that are folded in the same way, such as</p>

    <p class="text-gray-300"><span class="math">\\bm{x}^{\\prime}=\\rho^{-1}[\\bm{x}]_{0}+\\gamma[\\bm{x}]_{1}\\qquad\\bm{y}^{\\prime}=\\rho^{-1}[\\bm{y}]_{0}+\\gamma[\\bm{y}]_{1}.</span> (16)</p>

    <p class="text-gray-300">Now if <span class="math">\\bm{x}=\\bm{y}</span> then <span class="math">\\bm{x}^{\\prime}=\\bm{y}^{\\prime}</span>. Here the value is defined as <span class="math">\\rho^{2}=\\mu</span> for weight <span class="math">\\mu</span>. Taking the weighted inner product of these vectors by <span class="math">\\mu</span> we can work out a relation that includes the original weighted inner product <span class="math">\\left\\langle\\bm{x},\\bm{y}\\right\\rangle_{\\mu}</span> as one coefficient of a polynomial in <span class="math">\\gamma</span></p>

    <p class="text-gray-300"><span class="math">v_{x}=\\rho^{-1}(\\left\\langle[\\bm{x}]_{0},[\\bm{y}]_{1}\\right\\rangle_{\\mu^{2}}+\\left\\langle[\\bm{x}]_{1},[\\bm{y}]_{0}\\right\\rangle_{\\mu^{2}})\\qquad v_{r}=\\left\\langle[\\bm{x}]_{1},[\\bm{y}]_{1}\\right\\rangle_{\\mu^{2}}</span> (17) <span class="math">\\left\\langle\\bm{x}^{\\prime},\\bm{y}^{\\prime}\\right\\rangle_{\\mu^{2}}=\\left\\langle\\bm{x},\\bm{y}\\right\\rangle_{\\mu}+v_{x}\\gamma+v_{r}(\\gamma^{2}-1).</span></p>

    <p class="text-gray-300">Note that this relation is sound because the polynomials <span class="math">1,\\gamma,\\gamma^{2}-1\\in\\mathbb{F}[\\gamma]</span> are linearly independent. As in BP(+), the protocol follows straightforwardly from this relation by applying it to all the inner products in the commitment and grouping like terms. The prover can commit to the <span class="math">\\gamma</span> and <span class="math">\\gamma^{2}-1</span> coefficients <span class="math">(X,R)</span> and then the verifier can select a random <span class="math">\\gamma</span> to evaluate the relation. Because this relation is symmetric, the prover can apply it to the <span class="math">\\bm{x}=\\bm{y}=\\bm{n}</span> case and reduce <span class="math">\\bm{n}</span> to a single <span class="math">\\bm{n}^{\\prime}</span>.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">4.2 Norm Linear Argument</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the norm linear relation, there are 4 inner products that the prover needs to reduce: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}<span class="math">, </span>\\left\\langle\\bm{n},\\bm{G}\\right\\rangle<span class="math">, </span>\\left\\langle\\bm{c},\\bm{l}\\right\\rangle<span class="math">, and </span>\\left\\langle\\bm{l},\\bm{H}\\right\\rangle<span class="math">. Since </span>\\bm{n}<span class="math"> participates in a weighted inner product (norm), we need to modify the relation for </span>\\bm{G}<span class="math"> slightly, and since </span>\\bm{l}<span class="math">, </span>\\bm{c}<span class="math">, and </span>\\bm{H}$ only participate in unweighted relations, there are no weights present. The reduced vectors are thus</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v^{\\prime}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu^{2}}^{2}+\\left\\langle\\bm{c}^{\\prime},\\bm{l}^{\\prime}\\right\\rangle\\qquad\\bm{c}^{\\prime}=[\\bm{c}]_{0}+\\gamma[\\bm{c}]_{1}$ (18)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\bm{l}^{\\prime}=[\\bm{l}]_{0}+\\gamma[\\bm{l}]_{1}\\qquad\\bm{n}^{\\prime}=\\rho^{-1}[\\bm{n}]_{0}+\\gamma[\\bm{n}]_{1}</span> <span class="math">\\bm{G}^{\\prime}=\\rho[\\bm{G}]_{0}+\\gamma[\\bm{G}]_{1}\\qquad\\bm{H}^{\\prime}=[\\bm{H}]_{0}+\\gamma[\\bm{H}]_{1}.</span></p>

    <p class="text-gray-300">The commitments <span class="math">X</span> and <span class="math">R</span> follow directly from expanding all the reduced inner products and gathering <span class="math">\\gamma</span> and <span class="math">\\gamma^{2}-1</span> coefficients. Explicitly</p>

    <p class="text-gray-300"><span class="math">v_{x}=\\left(2\\rho^{-1}\\langle[\\bm{n}]_{0},[\\bm{n}]_{1}\\rangle_{\\mu^{2}}+\\langle[\\bm{c}]_{0},[\\bm{l}]_{1}\\rangle+\\langle[\\bm{c}]_{1},[\\bm{l}]_{0}\\rangle\\right)</span> (19)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v_{r}=\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[\\bm{n}]_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu^{2}}^{2}+\\langle[\\bm{c}]_{1},[\\bm{l}]_{1}\\rangle\\right)$ (20)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">X=v_{x}G+\\langle[\\bm{l}]_{1},[\\bm{H}]_{0}\\rangle+\\langle[\\bm{l}]_{0},[\\bm{H}]_{1}\\rangle</span> (21) <span class="math">+\\left\\langle\\rho[\\bm{n}]_{1},[\\bm{G}]_{0}\\right\\rangle+\\left\\langle\\rho^{-1}[\\bm{n}]_{0},[\\bm{G}]_{1}\\right\\rangle</span> <span class="math">R=v_{r}G+\\langle[\\bm{l}]_{1},[\\bm{H}]_{1}\\rangle+\\langle[\\bm{n}]_{1},[\\bm{G}]_{1}\\rangle.</span> (22)</p>

    <p class="text-gray-300">Evaluating the polynomial commitment at <span class="math">\\gamma</span> yields a commitment on the reduced basis to the reduced witness, i.e., we have</p>

    <p class="text-gray-300"><span class="math">C+\\gamma X+(\\gamma^{2}-1)R=v^{\\prime}G+\\langle\\bm{l}^{\\prime},\\bm{H}^{\\prime}\\rangle+\\langle\\bm{n}^{\\prime},\\bm{G}^{\\prime}\\rangle.</span> (23)</p>

    <p class="text-gray-300">The full protocol applies this reduction recursively until doing so does not reduce the overall proof size. This occurs when <span class="math">\\mathit{len}\\left(\\bm{l}\\right)+\\mathit{len}\\left(\\bm{n}\\right)\\leq 6</span>, at which point the prover sends the reduced <span class="math">\\bm{l}</span> and <span class="math">\\bm{n}</span> to the verifier. If these vectors satisfy the norm linear relation for the reduced <span class="math">\\bm{c}</span> and <span class="math">\\mu</span>, then it follows by induction that the original commitment satisfies the relation.</p>

    <p class="text-gray-300">Completeness follows directly from this equation holding and soundness from the linear independence of the polynomials <span class="math">1,\\gamma,\\gamma^{2}-1\\in\\mathbb{F}[\\gamma]</span>. Linear independence can be used to construct a round extractor, which as in BP can be used to construct an extractor for the entire protocol.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">The weighted norm linear argument has perfect completeness. Assuming the expected-PPT hardness of the discrete logarithm relation problem, the argument has CWEE and is therefore an argument of knowledge for the weighted norm linear relation.</p>

    <p class="text-gray-300">See Appendix C.1.1 for the proof.</p>

    <p class="text-gray-300">4.3 Full Protocol Description</p>

    <p class="text-gray-300">The setup protocol for the norm linear argument <span class="math">\\mathcal{K}</span> simply chooses all the group elements uniformly at random <span class="math">G,\\bm{H},\\bm{G}\\rightarrow\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Weighted Norm Linear Argument <span class="math">\\langle\\mathcal{P}_{nl},\\mathcal{V}_{nl}\\rangle</span></p>

    <p class="text-gray-300">Common input: <span class="math">G,\\bm{G},\\bm{H},\\bm{c},C,\\rho</span> and <span class="math">\\mu=\\rho^{2}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{P}</span>’s input: <span class="math">(\\bm{l},\\bm{n})</span> and $v=\\langle\\bm{c},\\bm{l}\\rangle+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}<span class="math"> such that </span>C=vG+\\langle\\bm{l},\\bm{H}\\rangle+\\langle\\bm{n},\\bm{G}\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If len <span class="math">(\\bm{l})+</span>len <span class="math">(\\bm{n})&lt;</span> 6:</li>

    </ol>

    <p class="text-gray-300">1.1 <span class="math">\\mathcal{P}\\rightarrow\\mathcal{V}:\\bm{l},\\bm{n}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.2 <span class="math">\\mathcal{V}</span> computes $v:=\\langle\\bm{c},\\bm{l}\\rangle+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1.3 <span class="math">\\mathcal{V}</span> accepts if <span class="math">C\\stackrel{{\\scriptstyle?}}{{=}}vG+\\langle\\bm{l},\\bm{H}\\rangle+\\langle\\bm{n},\\bm{G}\\rangle</span>, otherwise reject</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else:</li>

    </ol>

    <p class="text-gray-300">2.1 <span class="math">\\mathcal{P}\\rightarrow\\mathcal{V}:X,R</span> 2.2 <span class="math">\\mathcal{V}\\rightarrow\\mathcal{P}:\\gamma\\leftarrow\\S\\mathbb{F}</span> 2.3 <span class="math">\\mathcal{P}</span> computes <span class="math">\\bm{l}^{\\prime},\\bm{n}^{\\prime}</span> 2.4 <span class="math">\\mathcal{P},\\mathcal{V}</span> compute <span class="math">\\bm{G}^{\\prime},\\bm{H}^{\\prime},\\bm{c}^{\\prime}</span> and <span class="math">\\rho^{\\prime}:=\\mu</span>, <span class="math">\\mu^{\\prime}:=\\mu^{2}</span>, <span class="math">C^{\\prime}:=C+\\gamma X+(\\gamma^{2}-1)R</span> 2.5 Run <span class="math">\\langle\\mathcal{P}_{nl},\\mathcal{V}_{nl}\\rangle</span> with <span class="math">(G,\\bm{G}^{\\prime},\\bm{H}^{\\prime},\\bm{c}^{\\prime},C^{\\prime},\\rho^{\\prime},\\mu^{\\prime};\\bm{l}^{\\prime},\\bm{n}^{\\prime})</span>.</p>

    <p class="text-gray-300">As in BP, it is not necessary for the verifier to actually compute the intermediate <span class="math">(\\bm{G},\\bm{H},\\bm{c},C)</span> values and the final verification check can be replaced with a single linear combination of public curve points. Letting <span class="math">k</span> be the number of rounds before stopping and the vectors <span class="math">\\bm{\\gamma}_{l}</span> and <span class="math">\\bm{\\gamma}_{n}</span> be defined as</p>

    <p class="text-gray-300"><span class="math">\\bm{\\gamma}_{l}=\\bigotimes_{i=0}^{k-1}(1,\\gamma_{i})\\qquad\\bm{\\gamma}_{n}=\\bigotimes_{i=0}^{k-1}(\\rho^{2^{i}},\\gamma_{i}),</span> (24)</p>

    <p class="text-gray-300">the <span class="math">(\\bm{G},\\bm{H},\\bm{c},C)</span> in the final verification equation can be rewritten in terms of the original <span class="math">(\\bm{G},\\bm{H},\\bm{c},C)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v=\\langle\\bm{c},\\bm{\\gamma}_{l}\\otimes\\bm{l}\\rangle+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}$ (25)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">vG+\\langle\\bm{\\gamma}_{l}\\otimes\\bm{l},\\bm{H}\\rangle+\\langle\\bm{\\gamma}_{n}\\otimes\\bm{n},\\bm{G}\\rangle\\stackrel{{\\scriptstyle?}}{{=}}C+\\sum_{i=0}^{k-1}\\gamma_{i}X_{i}+(\\gamma_{i}^{2}-1)R_{i}.</span> (26)</p>

    <p class="text-gray-300">Also as in BP, when verifying multiple proofs simultaneously, the verifier can take a random linear combination of the equations and combine the <span class="math">\\bm{\\gamma}_{l}\\otimes\\bm{l}</span> and <span class="math">\\bm{\\gamma}_{n}\\otimes\\bm{n}</span> from different proofs if the <span class="math">\\bm{G}</span> and <span class="math">\\bm{H}</span> are the same. Thus the marginal cost of verifying an additional proof is only <span class="math">k=O(\\log n)</span> additional scalar multiplications and <span class="math">O(n)</span> field operations. There are additional optimizations that help reduce prover work discussed in Appendix B.</p>

    <h2 id="sec-32" class="text-2xl font-bold">5 Arithmetic Circuits</h2>

    <p class="text-gray-300">In BP, arithmetic circuits are represented using four public matrices and one public vector <span class="math">(W_{L},W_{R},W_{O},</span> <span class="math">W_{V},\\bm{c})</span> and four witness vectors <span class="math">(\\bm{a}_{L},\\bm{a}_{R},\\bm{a}_{O},\\bm{v})</span>, which must satisfy Eq. (14). BP arithmetic circuits can accept inputs to the circuit via Pedersen scalar commitments <span class="math">V_{i}</span>, and each element of <span class="math">\\bm{v}</span> comes from one of these scalar commitments. To ensure the correctness of the extractor, and soundness, the matrix <span class="math">W_{V}</span> must have a left inverse <span class="math">X</span> such that <span class="math">XW_{V}=I</span>.</p>

    <p class="text-gray-300">This representation is closely related to the more common Rank 1 Constraint System (R1CS) and similarly supports arbitrary linear constraints and fan-in 2 multiplication gates. For each multiplication in the circuit, the prover commits to the left input in <span class="math">\\bm{w}_{L,i}</span>, the right input in <span class="math">\\bm{w}_{R,i}</span> and the output in <span class="math">\\bm{w}_{O,i}</span>. This is perfectly sensible in general, but we note that components of <span class="math">\\bm{a}_{O}</span> can be both output of</p>

    <p class="text-gray-300">a multiplication gate and subject to linear constraints in the components of <span class="math">\\bm{a}_{L}</span> and <span class="math">\\bm{a}_{R}</span>. Systems like R1CS require additional (redundant) constraints to handle these cases which can be encoded at no extra cost if the prover were able to directly show</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{L}\\circ\\bm{a}_{R}=W_{m,L}\\bm{a}_{L}+W_{m,R}\\bm{a}_{R}+W_{m,O}\\bm{a}_{O}.</span> (27)</p>

    <p class="text-gray-300">This motivates the BP++ circuit encoding, where we make exactly this change. It turns out that effectively every multiplication gate in reciprocal range proofs (Section 6.2) and MACT is of this form, and the savings from this change make it efficient to directly represent range proofs using arithmetic circuits. We also modify the circuits to accept input vectors from Pedersen vector commitments, rather than just scalars.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Concretely, an arithmetic circuit <span class="math">\\mathcal{C}</span> will be represented using two matrices <span class="math">(W_{l},W_{m})</span>, two vectors <span class="math">(\\bm{a}_{l},\\bm{a}_{m})</span> and two binary flags <span class="math">(f_{l},f_{m})</span>. The witness for the circuit will consist of four vectors <span class="math">(\\bm{w}_{L},\\bm{w}_{R},\\bm{w}_{O},\\bm{w}_{V})</span> where <span class="math">\\bm{w}_{L}</span> and <span class="math">\\bm{w}_{R}</span> are the left and right inputs to each multiplication, as in BP. To define linear constraints, rather than using one matrix per witness vector like BP, we use a single matrix defined over the entire non-input witness $\\bm{w}=\\bm{w}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{O}<span class="math">. This is equivalent to having a matrix per witness vector, and we will refer to the portion of such a matrix </span>W_{l}$ that “acts” on each of these vectors using the notation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">W_{l}\\bm{w}=W_{l,L}\\bm{w}_{L}+W_{l,R}\\bm{w}_{R}+W_{l,O}\\bm{w}_{O}.</span> (28)</p>

    <p class="text-gray-300">The matrices on the right-hand side are just the columns of <span class="math">W_{l}</span> that multiply each component of the witness. So if <span class="math">\\bm{w}\\in\\mathbb{F}^{N_{w}}</span> and <span class="math">\\bm{w}_{L},\\bm{w}_{R}\\in\\mathbb{F}^{N_{m}}</span>, the matrix <span class="math">W_{l,L}</span> consists of the first <span class="math">N_{m}-1</span> columns of <span class="math">W_{l}</span>, <span class="math">W_{l,R}</span> consists of columns <span class="math">[N_{m},2N_{m})</span>, and <span class="math">W_{l,O}</span> of columns <span class="math">[2N_{m},N_{w})</span>. The inputs to the circuit are <span class="math">k</span> vectors <span class="math">\\bm{v}_{i}\\in\\mathbb{F}^{N_{v}}</span> and <span class="math">\\bm{w}_{V}</span> refers to the concatenation of all <span class="math">\\bm{v}_{i}</span>. This witness satisfies the circuit <span class="math">\\mathcal{C}</span> if it satisfies the following equations, and the circuit protocol is for the following relation</p>

    <p class="text-gray-300">\\[ \\mathcal{C}=\\left(\\begin{array}[]{c}W_{l}\\in\\mathbb{F}^{N_{l}\\times N_{w}},\\bm{a}_{l}\\in\\mathbb{F}^{N_{l}},f_{l}\\in\\{0,1\\}\\\\ W_{m}\\in\\mathbb{F}^{N_{m}\\times N_{w}},\\bm{a}_{m}\\in\\mathbb{F}^{N_{m}},f_{m}\\in\\{0,1\\}\\end{array}\\right) \\] (29) <span class="math">\\bm{0}=W_{l}\\bm{w}+f_{l}\\bm{w}_{V}+\\bm{a}_{l}</span> (30) <span class="math">\\bm{w}_{L}\\circ\\bm{w}_{R}=W_{m}\\bm{w}+f_{m}\\bm{w}_{V}+\\bm{a}_{m}</span> (31) \\[ \\mathcal{R}_{ac}=\\left\\{\\left(\\begin{array}[]{c}G\\in\\mathbb{G},\\bm{H}\\in\\mathbb{G}^{N_{v}+7},\\bm{G}\\in\\mathbb{G}^{N_{m}};\\\\ \\mathcal{C},\\bm{V}\\in\\mathbb{G}^{k};\\bm{v}_{i}\\in\\mathbb{F}^{N_{v}}:i=[0,k),\\\\ \\bm{s}_{V}\\in\\mathbb{F}^{k},\\bm{w}_{O}\\in\\mathbb{F}^{N_{O}}\\bm{w}_{L},\\bm{w}_{R}\\in\\mathbb{F}^{N_{m}}\\end{array}\\right):\\begin{array}[]{c}V_{i}=\\mathsf{Com}(\\bm{v}_{i};s_{V,i})\\\\ \\text{Eq. \\eqref{eq:2000}}\\\\ \\text{Eq. \\eqref{eq:2000}}\\end{array}\\right\\} \\] (32)</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">5.1 Equivalence to BP Circuits</h3>

    <p class="text-gray-300">Since BP circuit representation is capable of representing any arithmetic circuit, it suffices to show that this new format can encode satisfiability of BP circuits to show it is also capable of representing any arithmetic circuit. To see how, let <span class="math">X</span> be the left inverse of <span class="math">W_{V}</span> as before and let <span class="math">M</span> be the columns of <span class="math">X</span> with a basis for the orthogonal complement of <span class="math">X</span>, the left null space of <span class="math">W_{V}</span> concatenated as columns. This means the matrix <span class="math">M</span> is invertible by construction and satisfies</p>

    <p class="text-gray-300">\\[ MW_{V}=\\begin{bmatrix}I\\\\ \\bm{0}\\end{bmatrix}. \\]</p>

    <p class="text-gray-300">Then let <span class="math">\\bm{w}_{O}=\\bm{a}_{O}</span>, <span class="math">\\bm{w}_{L}=\\bm{a}_{L}</span>, and <span class="math">\\bm{w}_{R}=\\bm{a}_{R}</span> and define the constraints <span class="math">(W_{m},W_{l},f_{m},f_{l},\\bm{a}_{m},\\bm{a}_{l})</span> such that</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{l}f_{m}=0\\qquad f_{l}=1\\qquad\\bm{a}_{l}=M\\bm{c}\\qquad\\bm{a}_{m}=\\bm{0}\\\\ W_{m}\\bm{w}=\\bm{a}_{O}\\qquad W_{l}\\bm{w}=M(W_{L}\\bm{a}_{L}+W_{R}\\bm{a}_{R}+W_{O}\\bm{a}_{O})\\end{array} \\] (33)</p>

    <p class="text-gray-300">In practice it is not efficient to actually compute <span class="math">M</span>. In the case that elements of <span class="math">\\bm{w}_{V}</span> are used in multiple constraints it is most efficient to add “copy” constraints that move each <span class="math">\\bm{w}_{V,i}</span> into <span class="math">\\bm{w}_{O}</span>. Since <span class="math">\\bm{w}_{O}</span> elements can be used in any number of constraints, this allows elements of <span class="math">\\bm{w}_{V}</span> to be used in multiple constraints. While this is marginally less efficient than BP, inputs must already be copied like this to be used in multiplication constraints.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">5.2 Polynomial Encoding</h3>

    <p class="text-gray-300">In order to show the relation is satisfied, we need to reduce arithmetic circuit satisfiability to the norm linear argument. That is, construct some <span class="math">(v,\\bm{l},\\bm{n})</span> such that if it satisfies the norm linear argument for</p>

    <p class="text-gray-300"><span class="math">(\\mu,\\bm{c})</span> then the relation is satisfied. To do this, we transform the systems of equations in Eqs. (30) and (31) to a single equation by taking a random linear combination of the by power of <span class="math">\\lambda</span> and <span class="math">\\mu</span>. This makes the right hand side of Eq. (31) into a weighted inner product, so the linear combination of equations is</p>

    <p class="text-gray-300">\\[ \\begin{split}0&=\\mathbf{e}_{N_{l}}(\\lambda)^{\\top}\\left(W_{l}\\bm{w}+f_{l}\\bm{w}_{V}+\\bm{a}_{l}\\right)+\\left\\langle\\bm{w}_{L},\\bm{w}_{R}\\right\\rangle_{\\mu}\\\\ &-\\mathbf{e}_{N_{m}}(\\mu)^{\\top}\\left(W_{m}\\bm{w}+f_{m}\\bm{w}_{V}+\\bm{a}_{m}\\right).\\end{split} \\] (34)</p>

    <p class="text-gray-300">As in BP, the prover commits to the witness in a collection of vector commitments <span class="math">C_{L},C_{R},C_{O}</span>. To show that Eq. (34) is satisfied for the openings of these commitments, we can treat these commitments as a vector valued polynomial commitment to some <span class="math">(v(T),\\bm{l}(T),\\bm{n}(T))</span>. The verifier can take a linear combination of these commitments to evaluate this witness at any value of <span class="math">T</span>. Let the polynomial <span class="math">f(T)</span> be the scalar valued polynomial that is the application of the norm linear relation to these polynomials</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f(T)=v(T)-\\left\\langle\\bm{c}(T),\\bm{l}(T)\\right\\rangle-\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}(T)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}.$ (35)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We want <span class="math">f(T)=0</span> only if Eq. (34) is satisfied. One natural way to establish this is to split <span class="math">f(T)</span> into a polynomial <span class="math">\\hat{f}(T)</span> that depends on the vector commitments and some other polynomial <span class="math">g(T)</span> so <span class="math">f(T)=\\hat{f}(T)-g(T)</span>. The polynomial <span class="math">\\hat{f}(T)</span> will have a distinguished “value” term that vanishes with overwhelming probability if and only if Eq. (34) is satisfied, and the polynomial <span class="math">g(T)</span> will always have zero value term. We can choose <span class="math">g(T)</span> so that all the non-value terms (also referred to as “error” terms) of <span class="math">\\hat{f}(T)</span> vanish. So, if <span class="math">\\hat{f}(T)-g(T)=f(T)=0</span> then the value term must be zero.</p>

    <p class="text-gray-300">BP uses a similar technique and commits to each coefficient of <span class="math">g(T)</span> in a separate Pedersen scalar commitment. This takes a total of 5 group elements and 2 scalars. We are able to improve on this by instead committing to the error terms in <span class="math">\\bm{l}</span> as part of the blinding commitment. This is effectively free, in the sense that it requires no additional group elements or scalars beyond the blinding commitment, but also raises the issue of blinding for the error terms. The prover can’t just send <span class="math">g(T)</span> to the verifier. Instead we blind these error terms using a novel protocol that puts the blinding in <span class="math">C_{L},C_{R},C_{O}</span>, while still ensuring that <span class="math">f(T)=0</span>. This requires no additional rounds or commitments beyond a single blinding commitment. While the prover and verifier performance improvements are largely due to the reciprocal argument, the proof size reduction is due largely to this blinding protocol.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">5.2.1 Commitment Layout</h4>

    <p class="text-gray-300">When the prover commits to the circuit witness in <span class="math">(C_{L},C_{R},C_{O})</span> there is an important degree of freedom in how the witness can be laid out. Let these commitments be in norm linear form and define the witnesses <span class="math">(\\bm{r}_{X}\\in\\mathbb{F}^{8},\\bm{l}_{X}\\in\\mathbb{F}^{N_{l}},\\bm{n}_{X}\\in\\mathbb{F}^{N_{m}})</span> for <span class="math">X=L,R,O</span> and the commitments</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$C_{X}=r_{X,0}G+\\left\\langle\\bm{r}_{X,1:}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{l}_{X},\\bm{H}\\right\\rangle+\\left\\langle\\bm{n}_{X},\\bm{G}\\right\\rangle.$ (36)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The <span class="math">\\bm{r}_{X}</span> vectors are the error term blinding vectors. The rest of the vectors will commit to the witness, with <span class="math">\\bm{n}_{L}=\\bm{w}_{L}</span> and <span class="math">\\bm{n}_{R}=\\bm{w}_{R}</span>. This is necessary since Eq. (34) requires the weighted inner product of these two vectors. The degree of freedom is how the vector <span class="math">\\bm{w}_{O}</span> is represented in the vectors <span class="math">(\\bm{n}_{O},\\bm{l}_{O},\\bm{l}_{L},\\bm{l}_{R})</span>. We can quantify this degree of freedom in a function <span class="math">\\mathcal{F}</span> that injectively maps each component of <span class="math">\\bm{w}_{O}</span> to one component of these vectors so for <span class="math">\\mathrm{t_{X}\\in\\{l_{O},l_{L},l_{R},n_{O}\\}}</span> we have</p>

    <p class="text-gray-300"><span class="math">w_{O,\\mathcal{F}^{-1}(\\mathrm{t_{X},}j)}=\\bm{t}_{X,j}\\qquad\\bm{t}_{X,j}=0\\text{ if }(\\mathrm{t_{X}},j)\\not\\in\\mathrm{im}\\,\\mathcal{F}.</span> (37)</p>

    <p class="text-gray-300">Different protocols prefer different layouts for performance reasons and compatibility to multiparty proving, which is why we do not just pick a canonical layout. Given the function <span class="math">\\mathcal{F}</span>, we need to partition the matrices <span class="math">W_{l}</span> and <span class="math">W_{m}</span> into their constituent matrices that act on each of the <span class="math">\\bm{t}_{X}</span> for <span class="math">t=n,l</span> and <span class="math">X=L,R,O</span>. Let <span class="math">M_{a,t,X}</span> be the portion of <span class="math">W_{a}</span> for <span class="math">a=l,m</span> that act on <span class="math">\\bm{t}_{X}</span> and that therefore satisfy</p>

    <p class="text-gray-300"><span class="math">W_{a}\\bm{w}=\\sum_{X=L,R,O}M_{a,l,X}\\bm{l}_{X}+M_{a,n,X}\\bm{n}_{X}.</span> (38)</p>

    <p class="text-gray-300">Since <span class="math">\\bm{n}_{L}=\\bm{w}_{L}</span> and <span class="math">\\bm{n}_{R}=\\bm{w}_{R}</span>, we have <span class="math">M_{a,n,L}=W_{a,L}</span> and <span class="math">M_{a,n,R}=W_{a,R}</span>. The rest of the matrices <span class="math">M_{a,l,X}</span> and <span class="math">M_{a,n,O}</span> can be constructed by applying function <span class="math">\\mathcal{F}</span> to the columns of <span class="math">W_{a,O}</span>. Column <span class="math">j</span> of matrix <span class="math">M_{a,t,X}</span> equals column <span class="math">i</span> of <span class="math">W_{a,O}</span> if <span class="math">i=\\mathcal{F}^{-1}(\\mathrm{t_{X}},j)</span> and is the all zero column otherwise.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">5.2.2 Constraints and Inputs</p>

    <p class="text-gray-300">Given a layout, the prover commits to <span class="math">C_{L},C_{R},C_{O}</span> and then the verifier chooses the linear challenge <span class="math">\\lambda</span> and the multiplicative challenge <span class="math">\\mu</span>. These challenges determine the random linear combination of the constraints, as well as the linear combination of inputs. Recall that <span class="math">\\bm{w}_{V}</span> is the concatenation of the input vectors <span class="math">\\bm{v}_{i}</span>, and that <span class="math">\\bm{w}_{V}</span> can appear in both the multiplicative and linear constraints. In BP, each input commitment commits to a single scalar, so we can simply take a linear combination of the input commitments to take a linear combination of the vector of input vector. This is no longer the case when we are dealing with vector commitments; we can only take a linear combination of the vectors <span class="math">\\bm{v}_{i}</span>.</p>

    <p class="text-gray-300">Suppose we use the powers of <span class="math">\\mu</span> to separate the multiplicative constraints, and so we want to evaluate <span class="math">\\langle\\bm{\\mathbf{e}}_{kN_{v}}(\\mu),\\bm{w}_{V}\\rangle</span> in the proof. We can expand it using the tensor product structure of <span class="math">\\bm{\\mathbf{e}}_{kN_{v}}(\\mu)=\\bm{\\mathbf{e}}_{N_{v}}(\\mu)\\otimes\\bm{\\mathbf{e}}_{k}(\\mu^{N_{v}})</span> as</p>

    <p class="text-gray-300"><span class="math">\\langle\\bm{\\mathbf{e}}_{kN_{v}}(\\mu),\\bm{w}_{V}\\rangle=\\left\\langle\\bm{\\mathbf{e}}_{N_{v}}(\\mu),\\sum_{i=0}^{k-1}\\mu^{N_{v}i}\\bm{v}_{i}\\right\\rangle.</span> (39)</p>

    <p class="text-gray-300">We can obtain the <span class="math">\\mu^{N_{v}i}</span> linear combination of <span class="math">\\bm{v}_{i}</span> by multiplying <span class="math">\\mu^{N_{v}i}</span> with <span class="math">V_{i}</span>. Treating the result as a norm linear commitment, we can use <span class="math">\\bm{\\mathbf{e}}_{N_{v}}(\\mu)</span> in the constraint vector to compute the and obtain our desired result of <span class="math">\\langle\\bm{\\mathbf{e}}_{kN_{V}}(\\mu),\\bm{w}_{V}\\rangle</span>. This trick is not generally possible with a matrix <span class="math">W_{V}</span> as used in BP’ arithmetic circuit representation.</p>

    <p class="text-gray-300">There is an additional complexity that arises when using powers of both <span class="math">\\lambda</span> and <span class="math">\\mu</span> at the same time, that is when <span class="math">f_{m}f_{l}=1</span>. In that case taking the <span class="math">\\lambda^{N_{v}i}+\\mu^{N_{v}i+1}</span> linear combination of <span class="math">V_{i}</span> and then then taking the inner product with <span class="math">\\bm{\\mathbf{e}}_{N_{v}}(\\lambda)+\\bm{\\mathbf{e}}_{N_{v}}(\\mu)</span> produces unwanted cross terms of the form <span class="math">\\lambda^{i}\\mu^{N_{v}j}</span> and <span class="math">\\mu^{i}\\lambda^{N_{v}j}</span>. To deal with these terms, we can subtract the linear constraint corresponding to each input weighted by these cross terms. Since the cross terms add <span class="math">\\bm{w}_{V}</span> scaled by these values, and since <span class="math">f_{l}=1</span>, subtracting off the corresponding linear constraints will balance. After making this adjustment, we can now define the randomization vectors and randomized constraints</p>

    <p class="text-gray-300"><span class="math">\\bm{\\lambda}</span> <span class="math">=\\bm{\\mathbf{e}}_{N_{l}}(\\lambda)-f_{l}f_{m}(\\mu\\bm{\\mathbf{e}}_{N_{v}}(\\lambda)\\otimes\\bm{\\mathbf{e}}_{k}(\\mu^{N_{v}})+\\bm{\\mathbf{e}}_{N_{v}}(\\mu)\\otimes\\bm{\\mathbf{e}}_{k}(\\lambda^{N_{v}}))</span> (40) <span class="math">\\bm{\\mu}</span> <span class="math">=\\mu\\bm{\\mathbf{e}}_{N_{m}}(\\mu)</span> (41) <span class="math">\\bm{c}_{n,X}</span> <span class="math">=(\\bm{\\lambda}^{\\top}M_{l,n,X}+\\bm{\\mu}^{\\top}M_{m,n,X})\\operatorname{diag}(\\mu)^{-1}</span> (42) <span class="math">\\bm{c}_{l,X}</span> <span class="math">=\\bm{\\lambda}^{\\top}M_{l,l,X}+\\bm{\\mu}^{\\top}M_{m,l,X}.</span> (43)</p>

    <p class="text-gray-300">Note that <span class="math">\\bm{c}_{n,X}</span> is scaled by <span class="math">\\operatorname{diag}(\\mu)^{-1}</span> so that the weighted inner product yields an ordinary inner product The input commitments will in general be scaled by the power of <span class="math">\\lambda^{N_{v}i}</span> if <span class="math">f_{l}=1</span> and <span class="math">\\mu^{N_{v}i+1}</span> if <span class="math">f_{m}=1</span>. Let the linear combination of inputs be</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\hat{V}=2\\sum_{i=0}^{k-1}(f_{l}\\lambda^{N_{v}i}+f_{m}\\mu^{N_{v}i+1})V_{i}=\\hat{v}G+\\langle\\bm{r}_{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\bm{v}},\\bm{H}\\rangle.$ (44)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">5.2.3 Polynomial</h4>

    <p class="text-gray-300">Following the choice of <span class="math">\\lambda</span> and <span class="math">\\mu</span> by the verifier, the prover will commit to the blinding for the proof in the commitment <span class="math">C_{S}</span> organized with the same naming convention as <span class="math">C_{X}</span>. When laying out the polynomials <span class="math">(v(T),\\bm{l}(T),\\bm{n}(T))</span> we need to ensure that verifier can evaluate these polynomials by taking a linear combination of commitments and that the resulting <span class="math">f(T)</span> polynomial from Eq. (35) from applying the norm linear relation has the correct value term (which is the term that vanishes with overwhelming probability if and only if Eq. (34) is satisfied). Let <span class="math">\\delta</span> be a random value chosen by the verifier. The polynomials we will use arise from the following linear combination of commitments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T^{-1}C_{S}+\\delta C_{O}+TC_{L}+T^{2}C_{R}+T^{3}\\hat{V}=(\\hat{v}T^{3}+r_{0}(T))G+\\langle\\bm{r}_{1:}(T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\bm{l}}(T),\\bm{H}\\rangle+\\langle\\hat{\\bm{n}}(T),\\bm{G}\\rangle$ (45)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is easy to see that the value term must be the <span class="math">T^{3}</span> term, since the witnesses of <span class="math">C_{L}</span> and <span class="math">C_{R}</span> will be multiplied, and the coefficient of this product is <span class="math">T^{3}</span>. Unfortunately, the product of <span class="math">C_{O}</span> and <span class="math">\\hat{V}</span> also maps to the value term, but their product is also scaled by challenge <span class="math">\\delta</span>. This ensures that if it does not vanish then the value term will be distributed uniformly.</p>

    <p class="text-gray-300">Given the polynomial, the linear constraints follow naturally: any linear constraints that are applied to the witness of a commitment with coefficient <span class="math">T^{i}</span> will be scaled by <span class="math">T^{3-i}</span>. The constraints vectors,</p>

    <p class="text-gray-300">including the affine terms and some other public values, are</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">p_{s}(T)</span> $=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{p}_{n}(T)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}+\\langle\\boldsymbol{\\lambda},\\boldsymbol{a}_{l}\\rangle T^{3}+\\langle\\boldsymbol{\\mu},\\boldsymbol{a}_{m}\\rangle T^{3}$ (46)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\boldsymbol{p}_{n}(T)</span> <span class="math">=\\delta^{-1}T^{3}\\boldsymbol{c}_{n,O}+T^{2}\\boldsymbol{c}_{n,L}+T\\boldsymbol{c}_{n,R}</span> (47) <span class="math">\\hat{\\boldsymbol{c}}_{l}(T)</span> <span class="math">=2(\\delta^{-1}T^{3}\\boldsymbol{c}_{l,O}+T^{2}\\boldsymbol{c}_{l,L}+T\\boldsymbol{c}_{l,R})+f_{m}\\mu\\boldsymbol{\\mathrm{e}}_{N_{c}}(\\mu)_{1:}+f_{l}\\boldsymbol{\\mathrm{e}}_{N_{c}}(\\lambda)_{1:}\\ .</span> (48)</p>

    <p class="text-gray-300">Adding <span class="math">\\boldsymbol{p}_{n}(T)</span> and <span class="math">\\hat{\\boldsymbol{n}}(T)</span> to obtain <span class="math">\\boldsymbol{n}(T)</span> and using <span class="math">\\hat{\\boldsymbol{c}}_{l}</span> as the constraint for <span class="math">\\hat{\\boldsymbol{l}}</span>, we have a witness and constraint vector such that applying the norm linear verification equation yields polynomial</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\hat{f}(T)=p_{s}(T)+\\hat{v}T^{3}-\\left\\langle\\hat{\\boldsymbol{c}}_{l}(T),\\boldsymbol{\\hat{l}}(T)\\right\\rangle-\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{n}(T)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}.$ (49)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When writing out the coefficients of <span class="math">\\hat{f}(T)</span>, one can see that its <span class="math">T^{3}</span> term vanishes when Eq. (34) is satisfied and therefore, as required, the <span class="math">T^{3}</span> term is the value term. To summarize, we have polynomials</p>

    <p class="text-gray-300"><span class="math">P(T)</span> <span class="math">=p_{s}(T)G+\\langle\\boldsymbol{p}_{n}(T),\\boldsymbol{G}\\rangle</span> (50) <span class="math">C(T)</span> <span class="math">=P(T)+T^{-1}C_{S}+\\delta C_{O}+TC_{L}+T^{2}C_{R}+T^{3}\\hat{V}</span> <span class="math">=(v(T)+r_{0}(T))G+\\langle\\boldsymbol{l}(T),\\boldsymbol{H}\\rangle+\\langle\\boldsymbol{n}(T),\\boldsymbol{G}\\rangle</span> (51) <span class="math">\\hat{\\boldsymbol{r}}(T)</span> <span class="math">=\\boldsymbol{r}(T)-T^{-1}\\boldsymbol{r}_{S}(T)</span> (52) <span class="math">v(T)</span> <span class="math">=p_{s}(T)+\\hat{v}T^{3}+r_{0}(T)</span> (53)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\boldsymbol{l}(T)</span> $=\\boldsymbol{r}_{1:}(T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\boldsymbol{l}}(T)$ (54)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\boldsymbol{n}(T)</span> <span class="math">=\\boldsymbol{p}_{n}(T)+\\hat{\\boldsymbol{n}}(T)</span> (55)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\hat{f}(T)</span> $=p_{s}(T)+\\hat{v}T^{3}-\\left\\langle\\hat{\\boldsymbol{c}}_{l}(T),\\hat{\\boldsymbol{l}}(T)\\right\\rangle-\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{n}(T)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}$ (56)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">5.2.4 Error Terms</h4>

    <p class="text-gray-300">Now, we can work backwards to derive what <span class="math">\\boldsymbol{r}(T)</span> needs to be in order to satisfy the verification equation. Recall Eq. (35), which can be rewritten as</p>

    <p class="text-gray-300"><span class="math">f(T)=\\hat{f}(T)-\\langle\\hat{\\boldsymbol{c}}_{r}(T),\\boldsymbol{r}(T)\\rangle.</span> (58)</p>

    <p class="text-gray-300">Our original strategy was to construct a polynomial <span class="math">g(T)</span> that has a zero value term by construction so that <span class="math">f(T)=\\hat{f}(T)-g(T)=0</span>. Now we can define <span class="math">g(T)=\\langle\\hat{\\boldsymbol{c}}_{r}(T),\\boldsymbol{r}(T)\\rangle</span> and our goal becomes defining <span class="math">\\hat{\\boldsymbol{c}}_{r}(T)</span> such that value term is always zero. Then, we can simply check that <span class="math">f(\\tau)=0</span> at a random challenge to verify that the value term vanishes.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{\\boldsymbol{c}}_{r}(T)=(1,\\beta T^{-1},\\beta T,\\beta T^{2},\\beta T^{3},\\beta T^{5},\\beta T^{6},\\beta T^{7})</span> for random challenge <span class="math">\\beta</span> chosen by the verifier after <span class="math">C_{L},C_{R},C_{O}</span> but before <span class="math">C_{S}</span>. Now expanding <span class="math">g(T)</span> we find</p>

    <p class="text-gray-300"><span class="math">g(T)</span> <span class="math">=\\langle\\hat{\\boldsymbol{c}}_{r}(T),\\boldsymbol{r}(T)\\rangle</span> (59) <span class="math">=\\left\\langle\\hat{\\boldsymbol{c}}_{r}(T),T^{-1}\\boldsymbol{r}_{S}\\right\\rangle+\\langle\\hat{\\boldsymbol{c}}_{r}(T),\\hat{\\boldsymbol{r}}(T)\\rangle.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\hat{\\boldsymbol{f}}</span> be the vector of <span class="math">\\hat{f}(T)</span> coefficients not including the value term or constant, so that <span class="math">\\hat{f}(T)=\\left\\langle(1,T^{-1},T,T^{2},T^{3},T^{5},T^{6},T^{7}),\\hat{\\boldsymbol{f}}\\right\\rangle\\!T^{-1}</span>. We want <span class="math">\\hat{f}(T)=g(T)</span>, so we can make the substitution $\\boldsymbol{r}_{S}=(\\hat{f}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta^{-1}\\hat{\\boldsymbol{f}}_{1:})-\\boldsymbol{s}_{r}<span class="math"> and cancelling </span>\\hat{f}(T)<span class="math"> and </span>g(T)$ results in</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\left\\langle\\hat{\\boldsymbol{c}}_{r},T^{-1}\\boldsymbol{s}_{r}\\right\\rangle=\\left\\langle\\hat{\\boldsymbol{c}}_{r},\\delta\\boldsymbol{r}_{O}+T\\boldsymbol{r}_{L}+T^{2}\\boldsymbol{r}_{R}+T^{3}\\boldsymbol{r}_{V}\\right\\rangle.</span> (60)</p>

    <p class="text-gray-300">The critical point here is that <span class="math">\\boldsymbol{s}_{r}</span> is <em>not</em> a function of <span class="math">T</span>, so if we group terms on the right hand side by their <span class="math">T^{i}</span> coefficient, we can determine exactly what <span class="math">\\boldsymbol{s}_{r}</span> must be in order to satisfy this equation, as well as some restrictions on <span class="math">\\boldsymbol{r}_{X}</span>. Most importantly, there is no <span class="math">T^{3}</span> term on the left hand side, so if the right hand side has a <span class="math">T^{3}</span> term, then it will be scaled by <span class="math">\\beta</span>. Since all the terms on the right hand side are committed before <span class="math">\\beta</span>, <span class="math">\\hat{f}(T)\\neq g(T)</span> with overwhelming probability if the RHS has a non-zero <span class="math">T^{3}</span> term.</p>

    <p class="text-gray-300">The prover chooses all the components of <span class="math">\\boldsymbol{r}_{X}</span> uniformly at random except for <span class="math">r_{O,4}=r_{L,3}=r_{R,2}=0</span> which are the terms that have degree <span class="math">3</span> in Eq. (60) and the terms with degree greater than <span class="math">6</span>. The prover commits to <span class="math">C_{S}</span> and the verifier chooses a uniformly random <span class="math">T=\\tau</span>. The prover and verifier can</p>

    <p class="text-gray-300">compute <span class="math">C(\\tau)</span>, and the prover will then prove to the verifier that <span class="math">C(\\tau)</span> commits to <span class="math">(v(\\tau), \\boldsymbol{l}(\\tau), \\boldsymbol{n}(\\tau))</span> that satisfies the norm linear relation for <span class="math">(\\mu, c(\\tau))</span>, either using the norm linear argument or by just sending the opening.</p>

    <p class="text-gray-300">Completeness of the protocol follows straightforwardly from the protocol definition. Soundness requires that we demonstrate the value term faithfully encodes Eq. (34), but otherwise follows from describing an extractor and Lemma 2. Zero-knowledge requires a more complex argument to show that <span class="math">(v, l, n)</span> is distributed uniformly at random, which ultimately reduces to showing that <span class="math">r</span> contains a rank 7 linear combination of the blinding values <span class="math">r_L</span>, <span class="math">r_R</span>, <span class="math">r_O</span>. Given this, the simulator is simple.</p>

    <p class="text-gray-300"><strong>Theorem 2 (Arithmetic Circuits).</strong> The arithmetic circuit protocol has perfect completeness and perfect honest verifier zero-knowledge. Assuming the expected-PPT hardness of the discrete logarithm relation problem, the protocol has computational witness-extended emulation.</p>

    <p class="text-gray-300">See Appendix C.2.1 for the proof.</p>

    <h2 id="sec-38" class="text-2xl font-bold">5.3 Full Protocol Description</h2>

    <p class="text-gray-300"><strong>Arithmetic Circuit Protocol</strong> <span class="math">\\langle \\mathcal{P}_{ac},\\mathcal{V}_{ac}\\rangle</span></p>

    <p class="text-gray-300">Common input: <span class="math">G\\in \\mathbb{G}</span>, <span class="math">\\pmb {G}\\in \\mathbb{G}^{N_m}</span>, <span class="math">\\pmb {H}\\in \\mathbb{G}^{N_v + 7}</span>, <span class="math">W_{m}\\in \\mathbb{F}^{N_{m}\\times N_{w}}</span>, <span class="math">\\pmb{a}_{m}\\in \\mathbb{F}^{N_{m}}</span>, <span class="math">W_{l}\\in \\mathbb{F}^{N_{l}\\times N_{w}}</span>, <span class="math">\\pmb{a}_{l}\\in \\mathbb{F}^{N_{l}}</span>, <span class="math">f_{l}</span>, <span class="math">f_{m}\\in \\{0,1\\}</span>, <span class="math">\\pmb {V}\\in \\mathbb{G}^{k}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>'s input: <span class="math">\\pmb{v}_i \\in \\mathbb{F}^{N_v}</span>, <span class="math">\\pmb{s}_V \\in \\mathbb{F}^k</span>, <span class="math">\\pmb{w}_L</span>, <span class="math">\\pmb{w}_R \\in \\mathbb{F}^{N_m}</span>, <span class="math">\\pmb{w}_O \\in \\mathbb{F}^{N_O}</span>, <span class="math">\\mathcal{F}:[0..N_O - 1] \\to (\\{\\mathrm{l_O}, \\mathrm{l_L}, \\mathrm{l_R}\\} \\times [0..N_v - 1]) \\cup (\\{\\mathrm{n_O}\\} \\times [0..N_O - 1])</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> computes:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\boldsymbol {r} _ {O}, \\boldsymbol {r} _ {L}, \\boldsymbol {n} _ {O}, \\boldsymbol {n} _ {L}, \\boldsymbol {l} _ {O}, \\boldsymbol {l} _ {L}, C _ {O}, C _ {L} := \\operatorname {C o m m i t O L} (\\boldsymbol {w} _ {O}, \\boldsymbol {w} _ {L}, \\mathcal {F}) \\\\ \\boldsymbol {r} _ {R}, \\boldsymbol {n} _ {R}, \\boldsymbol {l} _ {R}, C _ {R} := \\operatorname {C o m m i t R} \\left(\\boldsymbol {w} _ {O}, \\boldsymbol {w} _ {R}, \\mathcal {F}\\right) \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span> run the Inner Arithmetic Circuit protocol <span class="math">\\langle \\mathcal{P}_{iac},\\mathcal{V}_{iac}\\rangle</span></li>

    </ol>

    <p class="text-gray-300"><strong>CommitOL Subroutine</strong></p>

    <p class="text-gray-300">Input: <span class="math">\\pmb{w}_{O},\\pmb{w}_{L},\\mathcal{F}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {r} _ {O} ^ {\\prime} \\leftarrow \\mathrm {s} \\mathbb {F} ^ {6}, \\boldsymbol {r} _ {L} ^ {\\prime} \\leftarrow \\mathrm {s} \\mathbb {F} ^ {5}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {r} _ {O} := \\left(r _ {O, 0} ^ {\\prime}, r _ {O, 1} ^ {\\prime}, r _ {O, 2} ^ {\\prime}, r _ {O, 3} ^ {\\prime}, 0, r _ {O, 4} ^ {\\prime}, r _ {O, 5} ^ {\\prime}, 0\\right) \\in \\mathbb {F} ^ {8}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {r} _ {L} := \\left(r _ {L, 0} ^ {\\prime}, r _ {L, 1} ^ {\\prime}, r _ {L, 2} ^ {\\prime}, 0, r _ {L, 3} ^ {\\prime}, r _ {L, 4} ^ {\\prime}, 0, 0\\right) \\in \\mathbb {F} ^ {8}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {n} _ {L} := \\boldsymbol {w} _ {L} \\in \\mathbb {F} ^ {N _ {m}}</span></div>

    <p class="text-gray-300">Let <span class="math">\\pmb{n}_{O}\\in \\mathbb{F}^{N_{m}}</span> such that <span class="math">\\pmb{n}_{O,j}\\coloneqq \\left\\{ \\begin{array}{ll}\\pmb{w}_{O,i}\\mathrm{if~}\\mathcal{F}^{-1}(\\mathrm{n}_O,j) = i\\\\ 0\\mathrm{otherwise} \\end{array} \\right.</span></p>

    <p class="text-gray-300">Let <span class="math">\\pmb{l}_X\\in \\mathbb{F}^{N_v}</span> for <span class="math">X = L,O</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {l} _ {X, j} := \\left\\{ \\begin{array}{l} \\boldsymbol {w} _ {O, i} \\text { if } \\mathcal {F} ^ {- 1} (\\mathrm {l} _ {\\mathrm {X}}, j) = i \\\\ 0 \\text { otherwise} \\end{array} \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C _ {X} := r _ {X, 0} G + \\langle \\boldsymbol {r} _ {X, 1}; \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol {l} _ {X}, \\boldsymbol {H} \\rangle + \\langle \\boldsymbol {n} _ {X}, \\boldsymbol {G} \\rangle \\in G \\text { for } X = L, O.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Return <span class="math">\\pmb{r}_O, \\pmb{r}_L, \\pmb{n}_O, \\pmb{n}_L, \\pmb{l}_O, \\pmb{l}_L, C_O, C_L</span></p>

    <p class="text-gray-300"><strong>CommitR Subroutine</strong></p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">Input:  <span class="math">\\pmb{w}_O, \\pmb{w}_R, \\mathcal{F}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{r}_R^{\\prime}\\gets \\# \\mathbb{F}^{4}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{r}_{R} \\coloneqq (r_{R,0}^{\\prime}, r_{R,1}^{\\prime}, 0, r_{R,2}^{\\prime}, r_{R,3}^{\\prime}, 0, 0, 0) \\in \\mathbb{F}^{8}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{n}_{R} \\coloneqq \\pmb{w}_{R} \\in \\mathbb{F}^{N_{m}}</span></p>

    <p class="text-gray-300">Let  <span class="math">\\pmb{l}_R\\in \\mathbb{F}^{N_v}</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\pmb{l}_{R,j}\\coloneqq \\left\\{ \\begin{array}{ll}\\pmb{w}_{O,i}\\mathrm{if}\\mathcal{F}^{-1}(\\mathrm{l}_{\\mathrm{R}},j) = i\\\\ 0\\mathrm{otherwise} \\end{array} \\right.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$C_R \\coloneqq r_{R,0}G + \\langle \\pmb{r}_{R,1},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{l}_R,\\pmb{H}\\rangle +\\langle \\pmb{n}_R,\\pmb{G}\\rangle \\in G$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Return  <span class="math">\\pmb{r}_R, \\pmb{n}_R, \\pmb{l}_R, C_R</span></p>

    <p class="text-gray-300">Common input: Same as the Arithmetic Circuit Protocol</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span> 's input: Same as the Arithmetic Circuit Protocol and  <span class="math">\\pmb{r}_X \\in \\mathbb{F}^8</span> ,  <span class="math">\\pmb{n}_X \\in \\mathbb{F}^{N_m}</span> ,  <span class="math">\\pmb{l}_X \\in \\mathbb{F}^{N_v}</span> ,  <span class="math">C_X \\in \\mathbb{G}</span>  for  <span class="math">X = L, R, O</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to \\mathcal{V}:C_L,C_R,C_O</span></li>

      <li><span class="math">\\mathcal{V}\\to \\mathcal{P}:\\rho ,\\lambda ,\\beta ,\\delta \\leftarrow \\# \\mathbb{F}</span></li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>  compute:</li>

    </ol>

    <p class="text-gray-300"><span class="math">M_{a,n,L} \\coloneqq (W_{a,i,j})_{0 \\leq j \\leq N_m - 1} \\in \\mathbb{F}^{N_a \\times N_m}</span>  for  <span class="math">a = l, m</span></p>

    <p class="text-gray-300"><span class="math">M_{a,n,R} \\coloneqq (W_{a,i,j})_{N_m \\leq j \\leq 2N_m - 1} \\in \\mathbb{F}^{N_a \\times N_m}</span>  for  <span class="math">a = l, m</span></p>

    <p class="text-gray-300"><span class="math">W_{a,O} \\coloneqq (W_{a,i,j})_{2N_m \\leq j \\leq N_w - 1} \\in \\mathbb{F}^{N_a \\times N_O}</span>  for  <span class="math">a = l, m</span></p>

    <p class="text-gray-300">Let  <span class="math">M_{a,n,O} \\in \\mathbb{F}^{N_a \\times N_m}</span>  for  <span class="math">a = l, m</span>  such that</p>

    <p class="text-gray-300"><span class="math">M_{a,n,O,j^{\\prime},j}\\coloneqq \\left\\{ \\begin{array}{ll}(W_{a,O,j^{\\prime},i})\\mathrm{if}\\mathcal{F}^{-1}(\\mathrm{n}_{\\mathrm{O}},j) = i\\\\ 0\\mathrm{otherwise} \\end{array} \\right.</span></p>

    <p class="text-gray-300">Let  <span class="math">M_{a,l,X} \\in \\mathbb{F}^{N_a \\times N_v}</span>  for  <span class="math">a = l, m, X = L, R, O</span>  such that</p>

    <p class="text-gray-300"><span class="math">M_{a,l,X,j^{\\prime},j}\\coloneqq \\left\\{ \\begin{array}{ll}(W_{a,O,j^{\\prime},i})\\mathrm{if}\\mathcal{F}^{-1}(\\mathrm{l}_{\\mathrm{X}},j) = i\\\\ 0\\mathrm{otherwise} \\end{array} \\right.</span></p>

    <p class="text-gray-300"><span class="math">\\mu \\coloneqq \\rho^2\\in \\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\hat{V} \\coloneqq 2\\sum_{i=0}^{k-1}(f_l\\lambda^{N_v i} + f_m\\mu^{N_v i+1})V_i \\in \\mathbb{G}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{\\lambda} \\coloneqq \\mathbf{e}_{N_l}(\\lambda) - f_l f_m(\\mu \\mathbf{e}_{N_v}(\\lambda) \\otimes \\mathbf{e}_k(\\mu^{N_v}) + \\mathbf{e}_{N_v}(\\mu) \\otimes \\mathbf{e}_k(\\lambda^{N_v})) \\in \\mathbb{F}^{N_l}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{\\mu} \\coloneqq \\mu \\mathbf{e}_{N_m}(\\mu) \\in \\mathbb{F}^{N_m}</span></p>

    <p class="text-gray-300">For  <span class="math">X = L,R,O</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{c}_{n,X} \\coloneqq (\\pmb{\\lambda}^{\\top}M_{l,n,X} + \\pmb{\\mu}^{\\top}M_{m,n,X})\\mathrm{diag}\\mu^{-1} \\in \\mathbb{F}^{N_m}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{c}_{l,X} \\coloneqq \\pmb{\\lambda}^{\\top}M_{l,l,X} + \\pmb{\\mu}^{\\top}M_{m,l,X} \\in \\mathbb{F}^{N_v}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{p}_n(T) \\coloneqq \\delta^{-1}T^3\\pmb{c}_{n,O} + T^2\\pmb{c}_{n,L} + T\\pmb{c}_{n,R} \\in \\mathbb{F}^{N_m}[T]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p_{s}(T)\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_{n}(T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2} + \\langle \\pmb {\\lambda},\\pmb {a}_{l}\\rangle T^{3} + \\langle \\pmb {\\mu},\\pmb {a}_{m}\\rangle T^{3}\\in \\mathbb{F}[T]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pmb{l}_S \\gets \\# \\mathbb{F}^{N_v}</span></p>

    <p class="text-gray-300"><span class="math">\\pmb{n}_{S} \\gets \\# \\mathbb{F}^{N_{m}}</span></p>

    <p class="text-gray-300"><span class="math">\\hat{v}:=2\\sum_{i=0}^{k-1}(f_{l}\\lambda^{N_{v}i}+f_{m}\\mu^{N_{v}i+1})v_{i,0}\\in\\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{c}}_{l}(T):=2\\left(\\delta^{-1}T^{3}\\bm{c}_{l,O}+T^{2}\\bm{c}_{l,L}+T\\bm{c}_{l,R}\\right)+f_{m}\\mu\\bm{\\mathrm{e}}_{N_{v}}(\\mu)_{1:}+f_{l}\\bm{\\mathrm{e}}_{N_{v}}(\\lambda)_{1:}\\in\\mathbb{F}^{N_{v}}[T]</span></p>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{l}}(T):=T^{-1}\\bm{l}_{S}+\\delta\\bm{l}_{O}+T\\bm{l}_{L}+T^{2}\\bm{l}_{R}+T^{3}(2\\sum_{i=0}^{k-1}(f_{l}\\lambda^{N_{v}i}+f_{m}\\mu^{N_{v}i+1})\\bm{v}_{i,1:})\\in\\mathbb{F}^{N_{v}}[T]</span></p>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{n}}(T):=T^{-1}\\bm{n}_{S}+\\delta\\bm{n}_{O}+T\\bm{n}_{L}+T^{2}\\bm{n}_{R}\\in\\mathbb{F}^{N_{m}}[T]</span></p>

    <p class="text-gray-300"><span class="math">\\bm{n}(T):=\\bm{p}_{n}(T)+\\hat{\\bm{n}}(T)\\in\\mathbb{F}^{N_{m}}[T]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\hat{f}(T):=p_{s}(T)+\\hat{v}T^{3}-\\left\\langle\\hat{\\bm{c}}_{l}(T),\\hat{\\bm{l}}(T)\\right\\rangle-\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}(T)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}\\in\\mathbb{F}^{8}[T]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\hat{\\bm{f}}\\in\\mathbb{F}^{8}</span> be the vector of coefficients of <span class="math">\\hat{f}(T)</span></p>

    <p class="text-gray-300"><span class="math">\\bm{r}_{V}=(0,2\\sum_{i=0}^{k-1}(f_{l}\\lambda^{N_{v}i}+f_{m}\\mu^{N_{v}i+1})s_{V,i},0,\\ldots,0)\\in\\mathbb{F}^{8}</span></p>

    <p class="text-gray-300"><span class="math">\\bm{s}_{r}:=(\\beta\\delta\\bm{r}_{O,1},0,\\beta^{-1}\\delta\\bm{r}_{O,0}+\\bm{r}_{L,1},\\delta\\bm{r}_{O,2}+\\beta^{-1}\\bm{r}_{L,0}+\\bm{r}_{R,1},\\delta\\bm{r}_{O,3}+\\bm{r}_{L,2}+\\bm{r}_{V,1}+\\beta^{-1}\\bm{r}_{R,0},\\bm{r}_{L,4}+\\bm{r}_{R,3},\\delta\\bm{r}_{O,5}+\\bm{r}_{R,4},\\delta\\bm{r}_{O,6}+\\bm{r}_{L,5})\\in\\mathbb{F}^{8}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\bm{r}_{S}:=(\\hat{f}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta^{-1}\\hat{\\bm{f}}_{1:})-\\bm{s}_{r}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$C_{S}:=r_{S,0}G+\\langle\\bm{r}_{S,1:}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{l}_{S},\\bm{H}\\rangle+\\langle\\bm{n}_{S},\\bm{G}\\rangle\\in G$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}:C_{S}</span></li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}:\\tau\\leftrightarrows\\mathbb{F}</span></li>

      <li><span class="math">\\mathcal{P}</span> computes:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\bm{r}(T):=T^{-1}\\bm{r}_{S}+\\delta\\bm{r}_{O}+T\\bm{r}_{L}+T^{2}\\bm{r}_{R}+T^{3}\\bm{r}_{V}\\in\\mathbb{F}^{8}[T]</span></p>

    <p class="text-gray-300"><span class="math">v(T):=p_{s}(T)+\\hat{v}T^{3}+r_{0}(T)\\in\\mathbb{F}[T]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\bm{l}(T):=\\bm{r}_{1:}(T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\bm{l}}(T)\\in\\mathbb{F}^{7+N_{v}}[T]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span> compute:</li>

    </ol>

    <p class="text-gray-300"><span class="math">P(T):=p_{s}(T)G+\\langle\\bm{p}_{n}(T),\\bm{G}\\rangle\\in G[T]</span></p>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{c}}_{r}(T):=(1,\\beta T^{-1},\\beta T,\\beta T^{2},\\beta T^{3},\\beta T^{5},\\beta T^{6},\\beta T^{7})\\in\\mathbb{F}^{8}[T]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\bm{c}(T):=\\hat{\\bm{c}}_{r,1:}(T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\bm{c}}_{l}(T)\\in\\mathbb{F}^{7+N_{v}}[T]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">C(T):=P(T)+T^{-1}C_{S}+\\delta C_{O}+TC_{L}+T^{2}C_{R}+T^{3}\\hat{V}\\in G[T]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span> run the weighted norm linear argument <span class="math">\\langle\\mathcal{P}_{nl},\\mathcal{V}_{nl}\\rangle=b</span> with common input <span class="math">(G,\\bm{G},\\bm{H},\\bm{c}(\\tau),C(\\tau),\\mu=\\rho^{2})</span> and prover input <span class="math">(\\bm{l}(\\tau),\\bm{n}(\\tau),v(\\tau))</span>.</li>

    </ol>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">5.4 Multi-party Proving</h3>

    <p class="text-gray-300">BP++ is amenable to exactly the same kind of MPC protocol as BP. Each prover will own a distinct portion of the norm vector, and these portions should be concatenated to support both kinds of MPC arguments. The linear portion of the commitment can be shared among all the provers, in the same way that the scalar component of the BP MPC protocol is shared among all the provers. If the circuit splits into local circuits for each prover such that each is independently satisfied, then the protocol will be secure. This is stated without proof, although the techniques of Alupotha, Boyen, and Foo <em>[52]</em> should transpose directly to BP++ given the similarity of the underlying protocols. Informally, it is sufficient to show that the protocol is complete if no elements of the witness owned by different provers are ever multiplied. This is true by construction, as the only elements that are ever multiplied lie over the same basis element in the norm vector, and this basis element is owned by exactly one prover.</p>

    <h2 id="sec-41" class="text-2xl font-bold">6 Reciprocal Argument</h2>

    <p class="text-gray-300">In this section, we formalize the reciprocal argument as an interactive protocol, describe an arithmetic circuit protocol that integrates the reciprocal argument, and then use that circuit protocol to build higher</p>

    <p class="text-gray-300">level protocols for range proofs and MACT. The range proofs work by instantiating a lookup argument using the reciprocal argument as described in the technical overview. We also define the MACT protocols using the conservation of money check from the technical overview. Because these protocols are simply given as arithmetic circuits in “reciprocal” form they do not require special security proofs.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">6.1 Warmup: Reciprocal Argument Protocol</h3>

    <p class="text-gray-300">Let <span class="math">A</span> be a collection of pairs of multiplicities and values <span class="math">(m\\in\\mathbb{F},v\\in\\mathbb{F})\\in A</span>. Recall that the reciprocal argument is an interactive protocol by which the prover can convince a verifier that the total multiplicity <span class="math">\\hat{m}_{v}</span> for each value <span class="math">v\\in\\mathbb{F}</span> vanishes, in which case we say <span class="math">A</span> vanishes (Definition 6).</p>

    <p class="text-gray-300">We present the protocol in a simple form in which the prover sends the verifier all the information directly, and the verifier will perform all checks on the prover messages. This protocol independently demonstrates the key technique used in reciprocal form circuits, range proofs, and MACTs. While this form is not very useful by itself, the protocol can be naturally adapted to an argument of knowledge by replacing the prover messages with commitments and changing the verifier checks accordingly. In order to make use of the reciprocal argument in BP++, we will not run the simple protocol in a black box manner but instead incorporate it into an arithmetic circuit protocol (see Section 6.2).</p>

    <p class="text-gray-300">The protocol works as follows. First, the prover sends multiplicities <span class="math">\\bm{m}</span> and values <span class="math">\\bm{v}</span> in <span class="math">A</span>. Next the verifier selects a random challenge <span class="math">\\alpha</span>, and the prover responds by sending the “reciprocals” <span class="math">r_{i}=m_{i}/(\\alpha+v_{i})</span>. Finally, the verifier checks that each reciprocal is properly formed and that the sum of all the reciprocals vanish, i.e., if</p>

    <p class="text-gray-300"><span class="math">(\\alpha+v_{i})r_{i}=m_{i}\\qquad\\text{and}\\qquad\\sum_{i}r_{i}=0.</span> (61)</p>

    <p class="text-gray-300">Reciprocal Argument Protocol <span class="math">\\langle\\mathcal{P}_{ra},\\mathcal{V}_{ra}\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}:\\bm{m},\\bm{v}</span></li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}:\\alpha\\leftarrow\\S\\E</span></li>

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}:\\bm{r}\\text{ s.t. }r_{i}=m_{i}/(\\alpha+v_{i})</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. <span class="math">\\mathcal{V}</span> accepts if <span class="math">(\\alpha+v_{i})r_{i}=m_{i}</span> for $i=0\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> and </span>\\sum_{i}r_{i}=0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This protocol lacks perfect completeness because if <span class="math">\\alpha=-v_{i}</span> for any <span class="math">v_{i}</span> then <span class="math">r_{i}</span> is not well-defined. However, this only occurs with negligile probability since <span class="math">\\alpha\\leftarrow\\S\\E</span>. Informally, soundness follows from the structure of the sum of the reciprocals. If <span class="math">(\\alpha+v_{i})r_{i}=m_{i}</span>, then either <span class="math">\\alpha=-v_{i}</span> and <span class="math">m_{i}=0</span> or <span class="math">r_{i}=m_{i}/(\\alpha+v_{i})</span>. So, with overwhelming probability if <span class="math">\\sum_{i}r_{i}=0</span> we have that <span class="math">f_{A}(\\alpha)=0</span> where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f_{A}(X)=\\sum_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}\\frac{m_{i}}{X+v_{i}}.$ (62)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since addition is commutative and associative, we can sum terms in <span class="math">f_{A}(X)</span> with a common denominator and write it as a sum over the total multiplicities. Let <span class="math">V=\\{v:\\exists m:(m,v)\\in A\\}</span> be the set of values in <span class="math">A</span>. Then</p>

    <p class="text-gray-300"><span class="math">f_{A}(X)=\\sum_{v\\in V}\\frac{\\hat{m}_{v}}{X+v}.</span> (63)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can show that if <span class="math">f(\\alpha_{j})=0</span> for $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> distinct challenges </span>\\alpha_{j}<span class="math"> then </span>\\hat{m}_{v}<span class="math"> must be zero for all </span>v\\in V<span class="math">. This follows from two simple observations. First, the “poles” </span>1/(X+v_{i})<span class="math"> are linearly independent in the ring </span>\\E(X)<span class="math"> of rational functions in </span>X<span class="math"> (as vector space over </span>\\E<span class="math">), and second, </span>f_{A}(\\alpha)=0<span class="math"> implies </span>f_{A}(X)=0$ by a slight modification of the Schwartz-Zippel lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 1 (Reciprocal Argument Vanishing).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">A</span> be a collection of pairs of multiplicities and values. If there exist $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> accepting transcripts of the reciprocal argument protocol for </span>A<span class="math"> with pairwise distinct challenges </span>\\alpha_{j}<span class="math">, then </span>A$ vanishes in the sense of Definition 6.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">V=\\{v:\\exists m:(m,v)\\in A\\}</span> be the set of values in <span class="math">A</span>. There are at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> values </span>\\alpha<span class="math"> such that there exists </span>v_{i}\\in V<span class="math"> for which </span>\\alpha=-v_{i}<span class="math">. Let </span>\\bm{\\alpha}^{\\prime}<span class="math"> be a vector of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> challenges </span>\\alpha_{j}<span class="math"> such that </span>\\alpha_{j}^{\\prime}\\neq-v_{i}<span class="math"> for any </span>i,j<span class="math">. Let </span>\\bm{v}<span class="math"> be the vector of elements in </span>V<span class="math">, and note that the components of vector </span>-\\bm{v}<span class="math"> are pairwise distinct and the components in </span>\\bm{\\alpha}^{\\prime}<span class="math"> are pairwise distinct. This means the </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> Cauchy matrix </span>C<span class="math"> formed from </span>-\\bm{v}<span class="math"> and </span>\\bm{\\alpha}^{\\prime}<span class="math"> is well-defined and therefore invertible. Let </span>f_{j}=f_{A}(\\alpha_{j}^{\\prime})<span class="math"> for </span>f_{A}<span class="math"> as defined in Eq. (63) and note that </span>\\bm{f}=C\\tilde{\\bm{m}}_{v}=\\bm{0}<span class="math">. Since </span>C<span class="math"> is invertible, </span>\\tilde{\\bm{m}}_{v}=\\bm{0}<span class="math"> and therefore </span>A$ vanishes. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">6.2 Reciprocal Form Circuits</h3>

    <p class="text-gray-300">We want to incorporate the reciprocal argument as a higher order operation into the arithmetic circuit protocol. This is analogous to the use of more complex “gates” <em>[23]</em> in other circuit representations. In particular, the integration of plookup into plonk in Halo2 <em>[38]</em>. This has the advantage of simplifying the analysis of protocols that use the reciprocal argument, since they can reuse the security proofs for general reciprocal form circuits rather than proving the soundness and zero-knowledge of every new, bespoke protocol.</p>

    <p class="text-gray-300">Suppose we have an arithmetic circuit <span class="math">\\mathcal{C}</span> and the arithmetic circuit witness <span class="math">(\\bm{w}_{L},\\bm{w}_{R},\\bm{w}_{O},\\bm{w}_{V})</span>. To integrate the reciprocal argument, we want to show that this circuit is satisfied and that some set of rational functions <span class="math">\\bm{f}(X)</span> vanishes, where each rational function encodes a reciprocal argument instance. In general, we want the symbols and multiplicities to be able to depend on the arithmetic circuit witness <span class="math">\\bm{w}</span> and ultimately would like to be able to compile the <span class="math">\\bm{f}(X)</span> vanishing check into an arithmetic circuit for a particular <span class="math">X=\\alpha</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can define three matrices <span class="math">(W_{n},W_{d},W_{p}(X))</span> and one witness vector <span class="math">\\bm{w}_{D}</span> to convert the check <span class="math">\\bm{f}(X)=\\bm{0}</span> into a form that can be compiled into an arithmetic circuit. Let $\\bm{w}_{I}=\\bm{w}_{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{D}<span class="math"> be the “initial” witness and </span>\\bm{w}(X)=\\bm{w}_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{P}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{O}$ be the entire witness. These matrices will ultimately be incorporated into arithmetic circuit constraint matrices, and for practical reasons we want the new constraints to have access to the inputs. These matrices will satisfy</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">w_{P,i}(X)=\\frac{(W_{n}\\bm{w}_{I}+f_{m}\\bm{w}_{V}+\\bm{a}_{n})_{i}}{X+w_{D,i}}</span> (64) <span class="math">W_{d}\\bm{w}_{I}+f_{l}\\bm{w}_{V}+\\bm{a}_{d}=\\bm{0}</span> (65) <span class="math">\\bm{f}(X)=W_{p}(X)\\bm{w}(X)+\\bm{a}_{p}(X).</span> (66)</p>

    <p class="text-gray-300">The initial witness is the portion of the witness committed before the verifier chooses <span class="math">\\alpha</span>, and <span class="math">\\bm{w}_{D}</span> is a list of all the private poles. For example, in Eq. (11) this vector would include all the <span class="math">d_{i}</span>. The matrix <span class="math">W_{n}\\bm{w}_{I}</span> allows expressing the multiplicities for each private pole as a linear combination of the initial witness, and the matrix <span class="math">W_{d}</span> relates the private poles to the rest of the initial witness. The matrix <span class="math">W_{p}(X)</span> maps each pole <span class="math">w_{i,P}(X)</span> to a reciprocal argument equation. That is, each reciprocal argument equation corresponds to a row of <span class="math">W_{p}(X)</span>. If the pole <span class="math">w_{i,P}(X)</span> appears in an equation, then the element of that row multiplying the pole is non-zero. The vector <span class="math">\\bm{a}_{p}(X)</span> adds all the poles whose denominators are public, for example <span class="math">m_{j}/(X+j)</span> in Eq. (11). For the purposes of this paper, it is more convenient to describe reciprocal form circuits in terms of the reciprocal arguments rather than actually describing the matrices. This is sufficient since these matrices exist for any collection of reciprocal arguments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Following commitment to <span class="math">\\bm{w}_{I}</span>, the verifier chooses <span class="math">\\alpha</span>, and the prover commits to <span class="math">\\bm{w}_{R}</span> and <span class="math">\\bm{w}_{P}(\\alpha)</span>. We can now define the new arithmetic circuit <span class="math">\\mathcal{C}^{\\prime}</span> for <span class="math">\\alpha</span>. First, prepend the vector <span class="math">\\bm{w}_{D}</span> onto <span class="math">\\bm{w}_{L}</span> and the vector <span class="math">\\bm{w}_{P}(\\alpha)</span> onto <span class="math">\\bm{w}_{R}</span> to produce <span class="math">\\bm{w}_{L}^{\\prime}</span> and <span class="math">\\bm{w}_{R}^{\\prime}</span> for <span class="math">\\mathcal{C}^{\\prime}</span>. We keep <span class="math">\\bm{w}_{O}^{\\prime}=\\bm{w}_{O}</span>, and can let $\\bm{w}^{\\prime}=\\bm{w}_{L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{R}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{O}^{\\prime}<span class="math">. To verify that the committed vector </span>\\bm{w}_{P}^{\\prime}<span class="math"> is correctly constructed as </span>\\bm{w}_{P}(\\alpha)$, we can clear the denominator of Eq. (64) and check</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">w_{D,i}w_{P,i}^{\\prime}=(W_{n}\\bm{w}_{I}+f_{m}\\bm{w}_{V}+\\bm{a}_{n})_{i}-\\alpha w_{P,i}^{\\prime}.</span> (67)</p>

    <p class="text-gray-300">This is satisfied if <span class="math">w_{P,i}^{\\prime}=w_{P,i}(\\alpha)</span> or if <span class="math">w_{D,i}=-\\alpha</span> and the numerator is zero. The latter occurs with negligible probability, so this is sufficient to check <span class="math">\\bm{w}_{P}^{\\prime}</span> is correctly constructed. The rest of the constraints can be appended onto the <span class="math">W_{l}</span> and <span class="math">W_{m}</span> matrices to construct the <span class="math">W_{l}^{\\prime}</span> and <span class="math">W_{m}^{\\prime}</span> matrices for <span class="math">\\mathcal{C}^{\\prime}</span> as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$W_{l}^{\\prime}\\bm{w}^{\\prime}=(W_{d}\\bm{w}_{I})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(W_{p}(\\alpha)\\bm{w}(X))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(W_{l}\\bm{w})$ (68)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The order of the concatenations was chosen so that <span class="math">\\bm{w}_{V}</span> can appear in the definition of <span class="math">\\bm{w}_{P}(X)</span> since this is convenient for reciprocal range proofs and MACT. It can be easily changed as necessary without affecting the security of the protocol. Formally, the reciprocal form arithmetic circuit protocol shows that</p>

    <p class="text-gray-300">the reciprocal form arithmetic circuit relation is satisfied for the circuit <span class="math">\\mathcal{RC}</span>. In the relation, <span class="math">A_{i}</span> refers to the collection for the <span class="math">i</span>th instance of the reciprocal argument. That is, the collection <span class="math">A_{i}</span> is encoded as in Eq. (62) by <span class="math">f_{i}(X)</span> in Eq. (66).</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{RC} = \\left( \\begin{array}{c} \\mathcal{C}, W_{n} \\in \\mathbb{F}^{N_{p} \\times N_{I}}, W_{d} \\in \\mathbb{F}^{N_{d} \\times N_{I}}, \\\\ W_{p}(X) \\in \\mathbb{F}(X)^{N_{p} \\times N_{w}^{\\prime}} \\\\ \\boldsymbol{a}_{n} \\in \\mathbb{F}^{N_{p}}, \\boldsymbol{a}_{d} \\in \\mathbb{F}^{N_{d}}, \\boldsymbol{a}_{p}(X) \\in \\mathbb{F}(X)^{N_{p}} \\end{array} \\right) \\tag{70}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{rf} = \\left\\{ (\\sigma; x, \\mathcal{RC}; w, \\boldsymbol{w}_{D} \\in \\mathbb{F}^{N_{p}}): A_{i} \\text{ vanishes, Eq. (65)}, (\\sigma; x; w) \\in \\mathcal{R}_{ac} \\right\\} \\tag{71}</span></div>

    <p class="text-gray-300">Given that we can compile reciprocal form circuits to arithmetic circuits for a particular <span class="math">\\alpha</span>, the security proofs are able to inherit most of the structure of those of arithmetic circuits. Zero-knowledge follows almost trivially, and soundness requires one additional level in the transcript tree for <span class="math">\\alpha</span> to extract the vanishing of <span class="math">\\boldsymbol{f}(\\alpha)</span>. The protocol too is very similar, the only difference is rather than committing to all <span class="math">C_L, C_R, C_O</span> together, the prover will send <span class="math">C_L, C_O</span>, which commit to the initial witness, the verifier will choose <span class="math">\\alpha</span>, and then the prover will send <span class="math">C_R</span>.</p>

    <p class="text-gray-300"><strong>Theorem 3 (Reciprocal Form Arithmetic Circuits).</strong> The arithmetic circuit protocol for circuits in reciprocal form has completeness and perfect honest verifier zero-knowledge. Assuming the expected-PPT hardness of the discrete logarithm relation problem, the protocol has computational witness-extended emulation.</p>

    <p class="text-gray-300">See Appendix C.3 for the proof.</p>

    <h2 id="sec-46" class="text-2xl font-bold">6.3 Full Protocol Description</h2>

    <p class="text-gray-300"><strong>Reciprocal Form Protocol</strong> <span class="math">\\langle \\mathcal{P}_{rf}, \\mathcal{V}_{rf} \\rangle</span></p>

    <p class="text-gray-300">Common input: Same as the Arithmetic Circuit Protocol and <span class="math">W_{n} \\in \\mathbb{F}^{N_{p} \\times N_{I}}, W_{d} \\in \\mathbb{F}^{N_{d} \\times N_{I}}, W_{p}(X) \\in \\mathbb{F}(X)^{N_{d} \\times N_{w}^{\\prime}}, \\boldsymbol{a}_{n} \\in \\mathbb{F}^{N_{p}}, \\boldsymbol{a}_{d} \\in \\mathbb{F}(X)^{N_{d}}, \\boldsymbol{a}_{p}(X) \\in \\mathbb{F}(X)^{N_{p}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>'s input: Same as the Arithmetic Circuit Protocol and <span class="math">\\boldsymbol{w}_{D} \\in \\mathbb{F}^{N_{p}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> computes:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w}_{L}^{\\prime} := \\boldsymbol{w}_{D} \\mid \\mid \\boldsymbol{w}_{L} \\in \\mathbb{F}^{N_{p} + N_{m}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w}_{O}^{\\prime} := \\boldsymbol{w}_{O} \\in \\mathbb{F}^{N_{O}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{r}_{O}, \\boldsymbol{r}_{L}, \\boldsymbol{n}_{O}, \\boldsymbol{n}_{L}, \\boldsymbol{l}_{O}, \\boldsymbol{l}_{L}, C_{O}, C_{L} := \\text{CommitOL}(\\boldsymbol{w}_{O}^{\\prime}, \\boldsymbol{w}_{L}^{\\prime}, \\mathcal{F})</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}: C_{L}, C_{O}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}: \\alpha \\leftarrow \\S \\mathbb{F}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> computes:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w}_{I} := \\boldsymbol{w}_{O} \\mid \\mid \\boldsymbol{w}_{L} \\mid \\mid \\boldsymbol{w}_{D} \\in \\mathbb{F}^{N_{O} + N_{m} + N_{p}}</span></div>

    <p class="text-gray-300">Fail if <span class="math">\\alpha + w_{D,i} = 0</span> for any <span class="math">i = 0..N_p - 1</span></p>

    <div class="my-4 text-center"><span class="math-block">w_{P,i}^{\\prime} := \\left(W_{n} \\boldsymbol{w}_{I} + f_{m} \\boldsymbol{w}_{V} + \\boldsymbol{a}_{n}\\right)_{i} \\cdot (\\alpha + w_{D,i})^{-1} \\text{ for } i = 0..N_p - 1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w}_{R}^{\\prime} := \\boldsymbol{w}_{P}^{\\prime} \\mid \\mid \\boldsymbol{w}_{R} \\in \\mathbb{F}^{N_{p} + N_{m}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{r}_{R}, \\boldsymbol{n}_{R}, \\boldsymbol{l}_{R}, C_{R} := \\text{CommitR}(\\boldsymbol{w}_{O}^{\\prime}, \\boldsymbol{w}_{R}^{\\prime}, \\mathcal{F})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w}^{\\prime} := \\boldsymbol{w}_{L}^{\\prime} \\mid \\mid \\boldsymbol{w}_{R}^{\\prime} \\mid \\mid \\boldsymbol{w}_{O}^{\\prime} \\in \\mathbb{F}^{2(N_{p} + N_{m}) + N_{O}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}: C_{R}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}, \\mathcal{V}</span> compute:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{w} := \\boldsymbol{w}_{L} \\mid \\mid \\boldsymbol{w}_{R} \\mid \\mid \\boldsymbol{w}_{O}</span></div>

    <p class="text-gray-300">Let <span class="math">W_{l}^{\\prime} \\in \\mathbb{F}^{2N_{d} + N_{l} \\times N_{w}^{\\prime}}</span> such that <span class="math">W_{l}^{\\prime} \\boldsymbol{w}^{\\prime} = (W_{d} \\boldsymbol{w}_{I}) \\mid \\mid (W_{p}(\\alpha) \\boldsymbol{w}) \\mid \\mid (W_{l} \\boldsymbol{w})</span></p>

    <p class="text-gray-300">24</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">W^{\\prime}_{m}\\in\\mathbb{F}^{N_{p}+N_{m}\\times N^{\\prime}_{n}}</span> such that $W^{\\prime}_{m}\\bm{w}^{\\prime}=(W_{n}\\bm{w}_{I}-\\alpha\\bm{w}^{\\prime}_{P})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(W_{m}\\bm{w})$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\bm{a}^{\\prime}_{l}:=\\bm{a}_{d}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\bm{a}_{p}(\\alpha)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\bm{a}_{l}\\in\\mathbb{F}^{N_{d}+N_{p}+N_{l}}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span> run the Inner Arithmetic Circuit Protocol <span class="math">\\langle\\mathcal{P}_{iac},\\mathcal{V}_{iac}\\rangle</span> with <span class="math">W_{l}=W^{\\prime}_{l}</span> <span class="math">W_{m}=W^{\\prime}_{m}</span> <span class="math">\\bm{w}_{L}=w^{\\prime}_{L}</span>, <span class="math">\\bm{w}_{R}=w^{\\prime}_{L}</span>, <span class="math">\\bm{w}_{O}=w^{\\prime}_{O}</span>, <span class="math">\\bm{a}_{m}=\\bm{a}^{\\prime}_{m}</span>, <span class="math">\\bm{a}_{l}=\\bm{a}^{\\prime}_{l}</span>.</li>

    </ol>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">6.4 Reciprocal Range Proofs</h3>

    <p class="text-gray-300">Given the reciprocal argument and reciprocal form arithmetic circuits, describing reciprocal range proofs is fairly simple. We want an argument for range proof relation</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{rp}=\\big{\\{}\\big{(}G,H\\in\\mathbb{G};\\bm{V}\\in\\mathbb{G}^{k},\\bm{A},\\bm{B}\\in\\mathbb{Z}^{k},B_{i}-A_{i}\\in(0,p);\\bm{v},\\bm{s}\\in\\mathbb{F}^{k}\\big{)}:\\forall i:v_{i}\\in[A_{i},B_{i}),V_{i}=\\mathsf{Com}(v_{i};s_{i})\\big{\\}}.</span> (72)</p>

    <p class="text-gray-300">Assume that some base has been chosen for each range <span class="math">[A_{i},B_{i})</span>. To show the relation for a given value <span class="math">v_{i}</span>, the prover just needs to show the linear constraints <span class="math">\\langle\\bm{b}_{i},\\bm{d}_{i}\\rangle=v_{i}-A_{i}</span> for appropriately defined <span class="math">\\bm{b}_{i}</span> and the reciprocal constraints. The <span class="math">\\bm{d}_{i}</span> appear as the roots of the denominators, so <span class="math">\\bm{w}_{D}</span> naturally is just the concatenation of these values.</p>

    <p class="text-gray-300">The only two remaining questions are how to compute <span class="math">\\bm{b}_{i}</span> for a given range and base and how to arrange the multiplicities. Computing the base vector is slightly more complex in the general case. Arithmetic circuits, as mentioned before, allow placing the vector <span class="math">\\bm{w}_{O}</span> of witness elements that participate only linear constraints either in the <span class="math">\\bm{l}_{X}</span> portion of the witness, or in the <span class="math">\\bm{n}_{O}</span> portion of the witness. For reciprocal range proofs, it makes sense to either place them in <span class="math">\\bm{n}_{O}</span>, which we will call “inline” multiplicity range proofs, or in <span class="math">\\bm{l}_{L}</span>, which we will call “shared” multiplicity range proofs. The terminology refers to the fact that in the multiparty setting when multiplicities are placed in the linear portion of the witness multiple provers can reuse the same basis points in their separate proofs. Inline range proofs are so called because in the multiparty setting, multiplicities must be represented over the basis elements used by each prover to commit to their digits, so the multiplicities are inline with the digits.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">6.4.1 Arbitrary Ranges</h4>

    <p class="text-gray-300">Support for arbitrary ranges is always useful and is especially so for larger bases. While in some cases like <span class="math">B-A=2^{64}</span> the optimal base <span class="math">b=16</span> satisfies <span class="math">b^{b}=B-A</span>, this is typically not the case. In general, we need to modify <span class="math">\\bm{b}</span>. This problem was already studied and solved in the protocol by Chaabouni, Lipmaa, and shelat <em>[53]</em>, in this sense that this protocol always produces the optimal number of digits. Unfortunately, this protocol requires one digit that is in base <span class="math">b^{\\prime}</span> with <span class="math">0&lt;b^{\\prime}&lt;b</span> depending on the range. For the reciprocal argument, this is not as efficient as using one additional base <span class="math">b</span> digit and a binary digit, which we describe here without loss of generality letting <span class="math">A=0</span> and <span class="math">n=\\lceil\\log_{b}B\\rceil</span>.</p>

    <h5 id="sec-49" class="text-base font-semibold mt-4">Case 1: <span class="math">b-1\\mid B-1</span></h5>

    <p class="text-gray-300">This is the natural generalization of the binary case, in the sense that <span class="math">2-1=1</span> divides every range. For arbitrary bases this is obviously not the case, but when it is the prover will use the base vector <span class="math">\\bm{b}</span> consisting of powers of <span class="math">b</span> except for the final component, <span class="math">b_{n-1}=B-b^{n-1}/b-1</span></p>

    <h5 id="sec-50" class="text-base font-semibold mt-4">Case 2: <span class="math">b^{n-1}&lt;B\\leq 2b^{n-1}</span></h5>

    <p class="text-gray-300">When the range is not divisible by <span class="math">b-1</span> but is sufficiently close to the lower power of <span class="math">b</span> the prover can still use <span class="math">n</span> digits by making the last digit binary. This is because the range can be covered by two overlapping ranges of size <span class="math">b^{n-1}</span>. In this case the final base value is <span class="math">b_{n-1}=B-b^{n-1}</span>.</p>

    <h5 id="sec-51" class="text-base font-semibold mt-4">Case 3: <span class="math">2b^{n-1}&lt;B&lt;b^{n}</span></h5>

    <p class="text-gray-300">In the protocol by Chaabouni, Lipmaa, and shelat <em>[53]</em>, one would use a larger final base for this case. As discussed, this is not efficient for the reciprocal argument, so instead the protocol will use another base <span class="math">b</span> digit to put the range in form of case 2.</p>

    <p class="text-gray-300"><span class="math">b_{n-1}=\\left\\lceil\\frac{B-1}{2(b-1)}\\right\\rceil-\\frac{b^{n-1}-1}{b-1}\\qquad b_{n}=B-(b-1)b_{n-1}-b^{n-1}</span> (73)</p>

    <p class="text-gray-300">6.4.2 Arithmetic Circuit</p>

    <p class="text-gray-300">In both the inline and reciprocal cases, the vector <span class="math">\\bm{w}_{D}</span> consists of the concatenation of the digit vectors for all the ranges. The numerator for each digit reciprocal is always <span class="math">1</span>, so the numerator matrix is simply zero and <span class="math">\\bm{a}_{n}=\\bm{1}</span>. The vector of reciprocals <span class="math">\\bm{w}_{P}(X)</span> is the concatenation of the values <span class="math">r_{i,j}=1/(\\alpha+d_{i,j})</span> so they align with <span class="math">\\bm{w}_{D}</span> per value that verifies the range using</p>

    <p class="text-gray-300"><span class="math">\\langle W_{d,i},\\bm{w}_{D}\\rangle=\\langle\\bm{b}_{i},\\bm{d}_{i}\\rangle\\qquad a_{d,i}=A_{i}</span> (74)</p>

    <p class="text-gray-300">which requires that <span class="math">f_{l}=1</span>. Now all that remains is to describe the matrix <span class="math">W_{p}(X)</span> in terms of the multiplicities. In both the inline and shared cases, the prover is shows that the set membership check is satisfied for all the digits of each base. Let the vector <span class="math">\\bm{m}_{i}</span> be the number of times each symbol in <span class="math">[1,b_{i})</span> occurs in <span class="math">\\bm{d}_{i}</span>. Note this does not include a multiplicity for zero, as this multiplicity is equal to the number of digits minus the sum of the other multiplicities. For base <span class="math">b</span>, let the total multiplicity be <span class="math">\\hat{\\bm{m}}_{b}=\\sum_{i:b_{i}=b}\\bm{m}_{i}</span> and the total number of digits be <span class="math">\\hat{n}_{b}=\\sum_{i:b_{i}=b}\\textit{len}\\left(\\bm{d}_{i}\\right)</span>. In both the inline and the shared cases, the prover uses the vectors of reciprocals for each base to show the truth of set membership equation</p>

    <p class="text-gray-300"><span class="math">\\sum_{i:b_{i}=b}\\langle\\bm{1},\\bm{r}_{i}\\rangle=\\frac{\\hat{n}_{b}-\\langle\\bm{1},\\hat{\\bm{m}}_{b}\\rangle}{X}+\\sum_{j=0}^{b-2}\\frac{\\hat{m}_{b,j}}{X+j+1}.</span> (75)</p>

    <p class="text-gray-300">The difference arises in how the prover commits to the multiplicities in the inline case, the prover commits to the vectors <span class="math">\\bm{m}_{i}</span> in <span class="math">\\bm{w}_{O}</span> padded so that they align with <span class="math">\\bm{d}_{i}</span>. The partition function <span class="math">\\mathcal{F}</span> in the inline case maps all of <span class="math">\\bm{w}_{O}</span> to <span class="math">\\bm{n}_{O}</span>. Since the <span class="math">\\hat{\\bm{m}}_{b}</span> are a linear function of the <span class="math">\\bm{m}_{i}</span>, the matrix <span class="math">W_{p}(X)</span> is defined to compute this function and then the right hand side of Eq. (75).</p>

    <p class="text-gray-300">In the shared case, the prover commits to the all the <span class="math">\\hat{\\bm{m}}_{b}</span> directly in <span class="math">\\bm{w}_{O}</span> and the partition function maps these values to <span class="math">\\bm{l}_{L}</span>. In this case, since neither <span class="math">\\bm{l}_{O}</span> or <span class="math">\\bm{n}_{O}</span> are used, the commitment can be safely dropped from the protocol. The matrix <span class="math">W_{p}(X)</span> once again encodes Eq. (75) for each base, but now uses the committed total multiplicities.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Theorem 4 (Reciprocal Range Proofs).</h6>

    <p class="text-gray-300">Both the inline and shared multiplicity reciprocal range proofs and zero knowledge arguments of knowledge for the reciprocal range proof relation <span class="math">\\mathcal{R}_{rp}</span> Eq. (72) assuming the expected-PPT hardness of the discrete logarithm relation problem.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The reciprocal range proof protocols are both instances of the reciprocal form arithmetic circuit protocol, so they have SHVZK, CWEE, and completeness. To show they are arguments for Eq. (72), we must establish that the circuit is satisfiable only if the inputs <span class="math">\\bm{v}</span> satisfy the relation. The protocol applies the reciprocal form circuit protocol to <span class="math">A=\\left\\{(-1,d_{i}):i\\right\\}\\cup\\left\\{(m_{j},t_{j}):j\\right\\}</span>. By the soundness of the reciprocal form circuit protocol, <span class="math">A</span> vanishes (Definition 6). So long as the number of digits is less than <span class="math">\\mathbb{F}</span>, which is the case by assumption, this implies all <span class="math">d_{i}</span> are valid base <span class="math">b</span> digits. Therefore <span class="math">v_{i}=\\langle\\bm{b}_{i},\\bm{d}_{i}\\rangle+A_{i}</span> implies that <span class="math">v_{i}\\in[A_{i},B_{i})</span>. Thus, the reciprocal range proof protocol is a zero knowledge argument of knowledge for Eq. (72). ∎</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">6.5 Multi-Asset Confidential Transactions</h3>

    <p class="text-gray-300">In a MACT, the prover wants to prove a closely related relation to that of an aggregated range proof. Given a transaction with a set of inputs <span class="math">I</span> (<span class="math">o_{i}=0</span>) and outputs <span class="math">O</span> (<span class="math">o_{i}=1</span>), each with a type and amount, the prover wants to show that the amount of input tokens of each type equals the amount of tokens output of each type and that all the output token amounts are “positive.” This is because if one of the outputs were negative it would be possible to secretly create new tokens, by adding more tokens to one of the other outputs to be larger. It is typically not necessary to check that the inputs are positive since they are the outputs of some other transaction.</p>

    <p class="text-gray-300">In a finite field, the positivity condition is checked by bounding each output (<span class="math">o_{i}=1</span>) by a range much smaller than the field characteristic. More precisely, it must be the case that any negligible amount of inputs and outputs cannot wrap around in the field to create a “negative” value. For simplicity, we can assume that all transaction outputs use the same range in the range proof <span class="math">[0,B)</span>, and in practice we can assume that <span class="math">B=2^{64}</span>. The MACT relation is thus</p>

    <p class="text-gray-300">\\[ \\mathcal{R}_{ct}=\\left\\{\\left(\\begin{array}[]{cc}G,H_{0},H_{1}\\in\\mathbb{G};\\bm{o}\\in\\{0,1\\}^{k},\\bm{V}\\in\\mathbb{G}^{k},B\\in\\mathbb{Z},\\\\ kB<p,\\forall i:o_{i}=0\\>v_{i}\\in[0,B);\\bm{v},\\bm{t},\\bm{s}\\in\\mathbb{F}^{k}\\end{array}\\right):\\begin{array}[]{cc}V_{i}=v_{i}G+t_{i}H_{0}+s_{i}H_{1}\\\\ \\forall i:o_{i}=1:v_{i}\\in[0,B)\\\\ \\forall t:\\sum_{i:t_{i}=t}(-1)^{o_{i}}v_{i}=0\\end{array}\\right\\}. \\] (76)</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">To check the range proof part of the relation, we can use any reciprocal range proof over all the transaction outputs, i.e. <span class="math">o_{i}=1</span>, for the optimal base <span class="math">b</span> and range <span class="math">[0,B)</span>. To check that all the amounts of each type net to zero in <span class="math">\\mathbb{F}</span>, we can use Eq. (12). This is essentially a multiset permutation check with large multiplicities, and can be stated in the form of the reciprocal argument using the input/output bits <span class="math">\\bm{o}</span> as</p>

    <p class="text-gray-300"><span class="math">f(X)=\\sum_{i=1}^{k}\\frac{(-1)^{o_{i}}v_{i}}{X+t_{i}}=0.</span> (77)</p>

    <p class="text-gray-300">From Lemma 1 it follows that if <span class="math">f(\\alpha)=0</span> for a uniformly random <span class="math">\\alpha</span> then with overwhelming probability the total multiplicity associated to each <span class="math">t_{i}</span> must be zero in <span class="math">\\mathbb{F}</span>. From the structure of the function, this total multiplicity is the sum of all the inputs of that type minus the sum of all the outputs of that type, and so the total multiplicity is zero in <span class="math">\\mathbb{F}</span> if and only if the amounts net to zero in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Taking these together, we can show that the total amount of each type of asset nets to zero in <span class="math">\\mathbb{Z}</span>. We know by assumption that each transaction input amount lies in <span class="math">[0,B)</span>, and we know from the range proof that each transaction output amount lies in <span class="math">[0,B)</span>. Therefore, the total multiplicity of any type of asset <span class="math">\\hat{m}_{v}</span> lies in <span class="math">(-kB,kB)</span>, which occurs in a transaction with k inputs or k outputs all of the same type and maximum amount. Since <span class="math">kB&lt;p</span>, this value cannot wrap around the field, so if <span class="math">\\hat{m}_{v}=0\\mod p</span> and <span class="math">\\hat{m}_{v}\\in(-kB,kB)</span> it must be the case that <span class="math">\\hat{m}_{v}=0</span>.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">6.5.1 Arithmetic Circuit</h4>

    <p class="text-gray-300">Each input and each output commit to two values, so <span class="math">N_{v}=2</span>. As in the reciprocal range proofs, all multiplicative constraints are reciprocal constraints and the matrices <span class="math">W_{L},W_{R}</span> have zero rows. The protocol can use any reciprocal range proof, and for the purposes of this protocol assume one is fixed by a reciprocal form circuit <span class="math">\\mathcal{RC}</span> for either a shared or inline digit range proof for all <span class="math">v_{i}</span> with <span class="math">o_{i}=1</span> for the range <span class="math">[0,B)</span>.</p>

    <p class="text-gray-300">We will append the vector <span class="math">\\bm{t}</span> of types to <span class="math">\\bm{w}_{D}</span> from the range proof, and we will add copy constraints to check that these are the same values from the input commitments. Note these copy constraints should be interleaved with the range proof linear constraints to line up with <span class="math">\\bm{t}</span> in <span class="math">\\bm{w}_{V}</span>. This requires <span class="math">f_{l}=1</span>, which is also required by the range proof. Each reciprocal in Eq. (77) has <span class="math">v_{i}(-1)^{o_{i}}</span> as its numerator and <span class="math">X+t_{i}</span> as its denominator. We will define <span class="math">w_{P,i}(X)</span> to be the unsigned reciprocals <span class="math">w_{P,i}(X)=v_{i}/(X+t_{i})</span>. This lets us simplify <span class="math">(W_{n}\\bm{w}_{I}+f_{m}\\bm{w}_{V}+\\bm{a}_{n})_{i}=v_{i}</span> for these terms and also requires <span class="math">f_{m}=1</span>. We can insert dummy constraints that check <span class="math">t_{i}=t_{i}</span> in the multiplicative constraints so that the inputs align with the constraint matrix. To check that Eq. (77) holds, we can then append a row <span class="math">W_{p}(X)</span> so that</p>

    <p class="text-gray-300"><span class="math">\\langle W_{p}(X)_{0},\\bm{w}\\rangle=\\sum_{i=1}^{k}(-1)^{o_{i}}w_{P,i}(X).</span> (78)</p>

    <p class="text-gray-300">This completes the MACT arithmetic circuit. In total, each input adds only one element to <span class="math">\\bm{w}_{D}</span> and <span class="math">\\bm{w}_{P}(X)</span>, one copy constraint to <span class="math">W_{d}</span> and one, trivial, row to <span class="math">W_{n}</span>. There is also one constraint in <span class="math">W_{p}(X)</span> to check Eq. (12).</p>

    <p class="text-gray-300">The marginal cost of a MACT over an aggregated range proof is negligible in prover time, verifier time, and proof size. This is in stark contrast to existing protocols which either require large proofs, complex circuits, and require trading off multi-party proving for the full relation.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 5 (Multi-Asset Confidential Transactions).</h6>

    <p class="text-gray-300">The confidential transaction protocol, instantiated with any of the reciprocal range proofs is a zero-knowledge argument of knowledge for the MACT relation Eq. (76) assuming the expected-PPT hardness of the discrete logarithm relation problem.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since the MACT protocol is an instantiation of the reciprocal form arithmetic circuit protocol, it has completeness and perfect SHVZK and CWEE. Therefore, it is sufficient to show that this circuit is satisfied if and only if the protocol inputs <span class="math">\\bm{v}</span> and <span class="math">\\bm{t}</span> satisfy the relation. As a consequence of Theorem 4, we know that all the transaction output commitments commit to values in <span class="math">[0,B)</span> if they satisfy the circuit, and we know by assumption that all inputs lie in this range. Since <span class="math">kB&lt;p</span>, the magnitude of the total multiplicity of any type of asset cannot exceed <span class="math">p</span>. The circuit invokes the reciprocal argument on the collection <span class="math">A</span> formed as <span class="math">\\{(v,t):(v,t)\\in I\\}\\cup\\{(-v,t):(v,t)\\in O\\}</span>. By the soundness of the reciprocal form circuits, <span class="math">A</span> vanishes (Definition 6), so total multiplicity of each token type must be zero in <span class="math">\\mathbb{F}</span>. Therefore, the total multiplicity of each type of asset must be <span class="math">0</span> as an integer. Thus, the MACT protocol is a zero-knowledge argument of knowledge for Eq. (76). ∎</p>

    <p class="text-gray-300">7 Implementation and Benchmarks</p>

    <p class="text-gray-300">To demonstrate the performance of BP++ in practice, we provide a reference implementation written in the C programming language.</p>

    <p class="text-gray-300">This implementation uses secp256k1, a popular elliptic curve used in Bitcoin and other cryptocurrencies. All operations on secret data performed by the prover implementation are constant time. Since the norm linear argument part of proving does not operate on secret data, it is allowed to use variable time operations. All rangeproof benchmarks use shared multiplicity for aggregating rangeproofs. The experiments were performed on an Intel i7-10510U system at 1.80GHz using a single thread. The 64-bit range proof size is 416 bytes, which is 28% smaller than BP+ (576 bytes) and 39% smaller than BP (672 bytes). As described in a paragraph below, the implementation uses a single multi-exponentiation algorithm and scalar precomputation optimizations. In summary, verifying a 64-bit range-proof took about 0.9 ms and proving about 4 ms. Figure 1 shows the proving and verification time as a function of the total number of range proof bits.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Comparison with BP (secp256k1), BP (Ristretto255) and BP+ (Ristretto255)</h4>

    <p class="text-gray-300">In order to compare the performance of BP++ with existing implementations of BP and BP+, we ran a BP implementation on secp256k1 <em>[54]</em>, a BP implementation on Ristretto255 <em>[55]</em> and a BP+ implementation on Ristretto255 <em>[56]</em>. The results are summarized in Table 2.</p>

    <p class="text-gray-300">Despite secp256k1 having slower group operations than Ristretto255, for a 64-bit range proof, the BP++ prover is about 3 times and the verifier about 2.2 times faster than the BP+ implementation. The performance improvement in BP++ is amplified when aggregating multiple range proofs, e.g., when aggregating 32 64-bit range proofs, the BP++ prover and verifier are about 5-6 times faster than BP+. A large portion of the speedup in verification and proving time can be explained by the reduced number of multiplications of group elements with scalars, which decreases from <span class="math">O(n)</span> in BP and BP+ to <span class="math">O(n/\\log n)</span> in BP++. In practice, this translates to only 16 basis points used for BP++’s norm argument in a single 64-bit range proof compared to 128 basis points for BP’s inner product argument and explains the 4x improvement in proving time on the curve secp256k1.</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Implemented Verification Optimizations</h4>

    <p class="text-gray-300">Since the primary applications of BP++ are in the area of blockchains, verification time is of significant importance. To improve verifier performance, the BP paper suggests a few optimizations, such as using a single multi-exponentiation, batch verification, and an efficient method to compute scalars. The first two optimizations can be directly translated to BP++, but the method to compute scalars has to be slightly adapted from BP’s inner product argument to BP++’s norm linear argument. All three optimizations have been implemented in the benchmarked code.</p>

    <p class="text-gray-300">The BP++ verifier can calculate the coefficients for each <span class="math">\\bm{G}_{i}</span>, <span class="math">\\bm{H}_{i}</span> directly in terms of norm linear challenges <span class="math">\\gamma</span> and <span class="math">\\mu</span>. To elaborate, <span class="math">s_{i}</span> the coefficient of <span class="math">\\bm{G}_{i}</span> can be computed as <span class="math">s_{i}=s_{i-j}\\gamma_{\\kappa}\\rho^{-2^{n}}</span> where <span class="math">j</span> is the nearest power of two smaller than <span class="math">i</span> and <span class="math">\\kappa=\\lfloor\\log_{2}(i)\\rfloor</span>. Combining all the mentioned optimizations, verifying <span class="math">m</span> proofs of <span class="math">n</span> bits each now only requires a single multi-exponentiation of <span class="math">O(mn/\\log(mn))</span> points and <span class="math">O(mn)</span> scalar operations.</p>

    <h2 id="sec-60" class="text-2xl font-bold">7.2 Changelog</h2>

    <p class="text-gray-300">2023-07-17</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Major rewrite. Range proofs are now described as circuits for an arithmetic circuit protocol. Added security proofs.</li>

      <li>Fixed soundness vulnerability in range proofs that required the introduction of new challenge variable <span class="math">\\delta</span> to the arithmetic circuit protocol.</li>

    </ul>

    <p class="text-gray-300">2022-03-30</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First public draft.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BP++</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BP+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BP([55])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BP([54])</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Curve</td>

            <td class="px-3 py-2 border-b border-gray-700">secp256k1</td>

            <td class="px-3 py-2 border-b border-gray-700">Ristretto255</td>

            <td class="px-3 py-2 border-b border-gray-700">Ristretto255</td>

            <td class="px-3 py-2 border-b border-gray-700">secp256k1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Range</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover time (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">4.041</td>

            <td class="px-3 py-2 border-b border-gray-700">11.851</td>

            <td class="px-3 py-2 border-b border-gray-700">12.136</td>

            <td class="px-3 py-2 border-b border-gray-700">19.241</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">52.108</td>

            <td class="px-3 py-2 border-b border-gray-700">307.26</td>

            <td class="px-3 py-2 border-b border-gray-700">384.20</td>

            <td class="px-3 py-2 border-b border-gray-700">499.060</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Range</td>

            <td class="px-3 py-2 border-b border-gray-700">Verifier time (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">0.840</td>

            <td class="px-3 py-2 border-b border-gray-700">1.815</td>

            <td class="px-3 py-2 border-b border-gray-700">1.907</td>

            <td class="px-3 py-2 border-b border-gray-700">2.223</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32 × 64</td>

            <td class="px-3 py-2 border-b border-gray-700">6.424</td>

            <td class="px-3 py-2 border-b border-gray-700">28.920</td>

            <td class="px-3 py-2 border-b border-gray-700">29.490</td>

            <td class="px-3 py-2 border-b border-gray-700">33.548</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Proving and verification time compared to prior work.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Proving and verification time for  <span class="math">\\mathrm{BP}++</span>  range proofs. X-axis shows the total number of bits in range proof. For  <span class="math">x &amp;gt; 64</span>  bits, we consider aggregation of 64-bit range proofs. Y-axis shows time in milliseconds.</p>

    <p class="text-gray-300">[1] Benedikt Bünz et al. Bulletproofs: Short Proofs for Confidential Transactions and More. https://ia.cr/2017/1066.2017. [2] Satoshi Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System. 2008. URL: https://bitcoin.org/bitcoin.pdf. [3] Sarah Meiklejohn et al. “A Fistful of Bitcoins: Characterizing Payments Among Men with No Names”. In: Internet Measurement Conference (IMC). DOI: 10.1145/2504730.2504747. [4] Simon Barber et al. "Bitter to Better. How to Make Bitcoin a Better Currency". In: Financial Cryptography and Data Security (FC). DOI: 10.1007/978-3-642-32946-3_29. [5] Elli Androulaki et al. “Evaluating User Privacy in Bitcoin”. In: FC 2013. DOI: 10.1007/978-3-642-39884-1_4. [6] Michele Spagnuolo, Federico Maggi, and Stefano Zanero. "BitIodine: Extracting Intelligence from the Bitcoin Network". In: FC 2014. DOI: 10.1007/978-3-662-45472-5_29. [7] Maria Apostolaki, Cedric Maire, and Laurent Vanbever. “Perimeter: A Network-Layer Attack on the Anonymity of Cryptocurrencies”. In: Financial Cryptography (1). [8] Simin Ghesmati, Walid Fdhila, and Edgar R. Weippl. "SoK: How private is Bitcoin? Classification and Evaluation of Bitcoin Privacy Techniques". In: ARES. [9] Gregory Maxwell. Confidential Transactions. https://web.archive.org/web/20190502140939/https://people.xiph.org/~greg/confidential_values.txt. 2015. [10] Adam Gibson. An Investigation into Confidential Transactions. https://github.com/AdamISZ/ConfidentialTransactionsDoc/raw/master/essayonCT.pdf. 2016.</p>

    <p class="text-gray-300">[11] Grin. https://www.grin-tech.org/.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[12] Monero. https://monero.org/.</li>

      <li>[13] sethforprivacy. Monero will undergo a network upgrade on 13th August, 2022. https://web.getmonero.org/2022/04/20/network-upgrade-july-2022.html. 2022.</li>

      <li>[14] Heewon Chung et al. Bulletproofs+: Shorter Proofs for Privacy-Enhanced Distributed Ledger. https://ia.cr/2020/735. 2020.</li>

      <li>[15] Andrew Poelstra et al. “Confidential Assets”. In: FC 2018 Workshops. doi: 10.1007/978-3-662-58820-8_4.</li>

      <li>[16] Jonas Nick, Andrew Poelstra, and Gregory Sanders. Liquid: A Bitcoin Sidechain. Tech. rep. 2020. url: https://blockstream.com/assets/downloads/pdf/liquid-whitepaper.pdf.</li>

      <li>[17] G. Maxwell. CoinJoin: Bitcoin privacy for the real world. BitcoinTalk post, https://bitcointalk.org/index.php?topic=279249.0. 2013.</li>

      <li>[18] Henry de Valence, Cathie Yun, and Oleg Andreev. Cloak. https://github.com/stellar/slingshot/blob/main/spacesuit/spec.md. 2019.</li>

      <li>[19] Stephanie Bayer and Jens Groth. “Efficient Zero-Knowledge Argument for Correctness of a Shuffle”. In: EUROCRYPT 2012. doi: 10.1007/978-3-642-29011-4_17.</li>

      <li>[20] Ariel Gabizon and Zachary J. Williamson. plookup: A simplified polynomial protocol for lookup tables. https://eprint.iacr.org/2020/315. 2020.</li>

      <li>[21] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. https://eprint.iacr.org/2019/953. 2019.</li>

      <li>[22] Ulrich Haböck. Multivariate lookups based on logarithmic derivatives. https://eprint.iacr.org/2022/1530. 2022.</li>

      <li>[23] Binyi Chen et al. “HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates”. In: EUROCRYPT 2023, Part II. doi: 10.1007/978-3-031-30617-4_17.</li>

      <li>[24] Liam Eagen, Dario Fiore, and Ariel Gabizon. cq: Cached quotients for fast lookups. https://eprint.iacr.org/2022/1763. 2022.</li>

      <li>[25] Arantxa Zapico et al. “Caulk: Lookup Arguments in Sublinear Time”. In: ACM CCS 2022. doi: 10.1145/3548606.3560646.</li>

      <li>[26] Jim Posen and Assimakis A. Kattis. Caulk+: Table-independent lookup arguments. https://eprint.iacr.org/2022/957. 2022.</li>

      <li>[27] Tim Ruffing and Pedro Moreno-Sanchez. “ValueShuffle: Mixing Confidential Transactions for Comprehensive Transaction Privacy in Bitcoin”. In: FC 2017 Workshops.</li>

      <li>[28] Jan Camenisch, Rafik Chaabouni, and abhi shelat. “Efficient Protocols for Set Membership and Range Proofs”. In: ASIACRYPT 2008. doi: 10.1007/978-3-540-89255-7_15.</li>

      <li>[29] Helger Lipmaa. “On Diophantine Complexity and Statistical Zero-Knowledge Arguments”. In: ASIACRYPT 2003. doi: 10.1007/978-3-540-40061-5_26.</li>

      <li>[30] Jens Groth. “Non-interactive Zero-Knowledge Arguments for Voting”. In: ACNS 05. doi: 10.1007/11496137_32.</li>

      <li>[31] Geoffroy Couteau et al. “Efficient Range Proofs with Transparent Setup from Bounded Integer Commitments”. In: EUROCRYPT 2021, Part III. doi: 10.1007/978-3-030-77883-5_9.</li>

      <li>[32] Nan Wang and Sid Chi-Kin Chau. Flashproofs: Efficient Zero-Knowledge Arguments of Range and Polynomial Evaluation with Transparent Setup. https://eprint.iacr.org/2022/1251. 2022.</li>

      <li>[33] Jens Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: EUROCRYPT 2016, Part II. doi: 10.1007/978-3-662-49896-5_11.</li>

      <li>[34] Thomas Attema and Ronald Cramer. “Compressed <span class="math">\\Sigma</span>-Protocol Theory and Practical Application to Plug & Play Secure Algorithmics”. In: CRYPTO 2020, Part III. doi: 10.1007/978-3-030-56877-1_18.</li>

      <li>[35] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. “Transparent SNARKs from DARK Compilers”. In: EUROCRYPT 2020, Part I. doi: 10.1007/978-3-030-45721-1_24.</li>

    </ul>

    <p class="text-gray-300">[36] Jonathan Lee. “Dory: Efficient, Transparent Arguments for Generalised Inner Products and Polynomial Commitments”. In: TCC 2021, Part II. doi: 10.1007/978-3-030-90453-1_1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[37] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. https://eprint.iacr.org/2019/1021. 2019.</li>

      <li>[38] The Halo 2 developers. Halo2. https://zcash.github.io/halo2/. 2020.</li>

      <li>[39] Electric Coin Company. Zcash. url: https://z.cash/.</li>

      <li>[40] Benedikt Bünz et al. “Recursive Proof Composition from Accumulation Schemes”. In: TCC 2020, Part II. doi: 10.1007/978-3-030-64378-2_1.</li>

      <li>[41] Joseph Jaeger and Stefano Tessaro. “Expected-Time Cryptography: Generic Techniques and Applications to Concrete Soundness”. In: TCC 2020, Part III. doi: 10.1007/978-3-030-64381-2_15.</li>

      <li>[42] Yehuda Lindell. “Parallel Coin-Tossing and Constant-Round Secure Two-Party Computation”. In: Journal of Cryptology 16.3 (June 2003). doi: 10.1007/s00145-002-0143-7.</li>

      <li>[43] Jens Groth and Yuval Ishai. “Sub-linear Zero-Knowledge Argument for Correctness of a Shuffle”. In: EUROCRYPT 2008. doi: 10.1007/978-3-540-78967-3_22.</li>

      <li>[44] Jonathan Bootle et al. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: EUROCRYPT 2016, Part II. doi: 10.1007/978-3-662-49896-5_12.</li>

      <li>[45] Mihir Bellare and Phillip Rogaway. “Random Oracles are Practical: A Paradigm for Designing Efficient Protocols”. In: ACM CCS 93. doi: 10.1145/168588.168596.</li>

      <li>[46] David Bernhard, Olivier Pereira, and Bogdan Warinschi. “How Not to Prove Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios”. In: ASIACRYPT 2012. doi: 10.1007/978-3-642-34961-4_38.</li>

      <li>[47] Jim Miller. Coordinated disclosure of vulnerabilities affecting Girault, Bulletproofs, and PlonK. https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs-and-plonk/. 2022.</li>

      <li>[48] Thomas Attema, Serge Fehr, and Michael Klooß. “Fiat-Shamir Transformation of Multi-round Interactive Proofs”. In: TCC 2022, Part I. doi: 10.1007/978-3-031-22318-1_5.</li>

      <li>[49] Douglas Wikström. Special Soundness in the Random Oracle Model. https://eprint.iacr.org/2021/1265. 2021.</li>

      <li>[50] Ashrujit Ghoshal and Stefano Tessaro. “Tight State-Restoration Soundness in the Algebraic Group Model”. In: CRYPTO 2021, Part III. doi: 10.1007/978-3-030-84252-9_3.</li>

      <li>[51] Chaya Ganesh et al. “Fiat-Shamir Bulletproofs are Non-Malleable (in the Algebraic Group Model)”. In: EUROCRYPT 2022, Part II. doi: 10.1007/978-3-031-07085-3_14.</li>

      <li>[52] Jayamine Alupotha, Xavier Boyen, and Ernest Foo. “Compact Multi-Party Confidential Transactions”. In: CANS 20. doi: 10.1007/978-3-030-65411-5_21.</li>

      <li>[53] Rafik Chaabouni, Helger Lipmaa, and abhi shelat. “Additive Combinatorics and Discrete Logarithm Based Range Protocols”. In: ACISP 10.</li>

      <li>[54] Bulletproofs secp256k1-zkp code. https://github.com/BlockstreamResearch/secp256k1-zkp/pull/23/commits/6fb7e058dc03a54ad44f9bc8ead68686304ee978.</li>

      <li>[55] Dalek Crypto Bulletproofs. https://github.com/dalek-cryptography/bulletproofs/commit/be67b6d5f5ad1c1f54d5511b52e6d645a1313d07.</li>

      <li>[56] Bulletproofs+ github. https://github.com/KyoohyungHan/BulletProofsPlus/commit/2c9dd4075c1bbb8f984990.</li>

    </ul>

    <h2 id="sec-62" class="text-2xl font-bold">Appendix A Binary Range Proof</h2>

    <p class="text-gray-300">In this appendix, we show how to construct a BP++ binary range proof. For most ranges, the reciprocal range proof is substantially more efficient for the prover and the verifier than a binary range proof. However for some small ranges with <span class="math">B-A&lt;2^{8}</span>, a binary range proof can be more efficient.</p>

    <p class="text-gray-300">The structure of the proof follows the construction used by BP(+) where each <span class="math">v</span> is decomposed into a vector <span class="math">\\bm{d}</span> of digits so that <span class="math">A\\leq v&lt;B</span> iff each <span class="math">d_{j}\\in\\{0,1\\}</span> and <span class="math">\\langle\\bm{d},\\bm{b}\\rangle=v+A</span> for some public constants. In the case <span class="math">B-A=2^{k}</span>, these constants are just powers of 2, and for arbitrary ranges the final constant is modified to be <span class="math">b_{n-1}=B-A-2^{n-1}</span>.</p>

    <p class="text-gray-300">The main advantage of this protocol over <span class="math">\\mathrm{BP}(+)</span> is the ability to complete the square for each bit check. Where those protocols check that each digit satisfies <span class="math">d_{i}(d_{i}-1)=0</span>, we will instead check <span class="math">\\left(d_{i}-\\frac{1}{2}\\right)^{2}=\\frac{1}{4}</span>. This is efficient to check using a weighted norm argument, and more importantly only requires the prover commit to the vector <span class="math">\\bm{d}</span> once. In inner product based range proofs, both factors <span class="math">d_{i}</span> and <span class="math">d_{i}-1</span> need to be committed, roughly double the amount of data. This results in a verifier that is approximately twice as fast.</p>

    <p class="text-gray-300">Given the input commitments <span class="math">V_{i}</span> and <span class="math">(\\bm{d}_{i},\\bm{b}_{i})</span> for each <span class="math">v_{i}</span> and range <span class="math">[A_{i},B_{i})</span>, the prover will commit to the concatenation of all the digit vectors, along with some blinding values <span class="math">s_{0}</span> and <span class="math">s_{d}</span>, in</p>

    <p class="text-gray-300"><span class="math">D=s_{0}G+s_{d}H_{1}+\\langle\\bm{d},\\bm{G}\\rangle.</span> (79)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier will choose multiplicative challenge <span class="math">\\mu</span> and linear challenge <span class="math">\\lambda</span>, which serve essentially the same role in the arithmetic circuit protocol. The linear challenge will separate the linear constraints by defining the $\\bm{b}=\\lambda^{1}\\bm{b}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda^{k}\\bm{b}_{k}$ and computing its inner product with the concatenated digits. The multiplicative challenge will separate the multiplicative constraints by serving as the weights in the weighted norm. This transforms all the constraints into two vector equations</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\langle\\bm{b},\\bm{d}\\rangle=\\sum_{i=1}^{k}\\lambda^{i}(v_{i}-A_{i})</span> (80)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{d}-\\frac{1}{2}\\bm{1}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}=\\sum_{i}\\left(d_{i}-\\frac{1}{2}\\right)^{2}\\mu^{i+1}=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}$ (81)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If these equations hold for random <span class="math">\\lambda</span> and <span class="math">\\mu</span>, then with overwhelming probability each <span class="math">\\lambda</span> and <span class="math">\\mu</span> monomial’s coefficient vanishes. These coefficients encode the statement to prove. Since these equations do not share any monomials, it is sound to simply check that their sum vanishes. Let <span class="math">\\delta</span> be similarly defined to separate the norm error term. After defining a few public constants</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p_{s}=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{p}_{n}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}-2\\sum_{i=1}^{k}\\lambda^{i}A_{i}\\qquad\\bm{p}_{n}=-\\frac{1}{2}\\bm{1}+\\mu^{-1}\\operatorname{diag}\\mu^{-1}\\bm{b}$ (82)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the vector equations can be transformed into a single weighted norm check</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{d}+\\bm{p}_{n}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}=p_{s}+2\\sum_{i=1}^{k}\\lambda^{i}v_{i}.$ (83)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If this equation is satisfied, then with overwhelming probability all the values belong to their respective ranges. Using a simplified version of the arithmetic circuit blinding protocol, the prover can transform this relation into a zero-knowledge protocol using only one additional round. The prover will sample uniformly random <span class="math">\\bm{s}\\in\\mathbb{F}^{n}</span> and compute the first two coefficients</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{s}+\\tau\\delta(\\bm{d}+\\bm{p}_{n})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}=f_{0}+f_{1}\\tau+\\tau^{2}\\delta^{2}(p_{s}+2\\sum_{i=1}^{k}\\lambda^{i}v_{i})$ (84)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as the third coefficient encodes the statement to prove. The verifier will choose a challenge <span class="math">\\beta</span>, and the prover will commit to the blinding commitment <span class="math">S</span> so that all the blinding on <span class="math">H_{0}</span> term cancels, like in the arithmetic circuit protocol. Now, for any challenge <span class="math">\\tau</span>, the prover knows an opening to the commitment</p>

    <p class="text-gray-300"><span class="math">C(\\tau)</span> <span class="math">=\\tau^{2}p_{s}G+\\tau\\langle\\bm{p}_{n},\\bm{G}\\rangle+S+\\tau\\delta D+2\\tau^{2}\\delta^{2}\\sum_{i=1}^{k}\\lambda^{i}V_{i}</span> (85) <span class="math">=v(\\tau)G+\\langle\\bm{l}(\\tau),\\bm{H}\\rangle+\\langle\\bm{n}(\\tau),\\bm{G}\\rangle</span> (86)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">that satisfies the norm linear relation for constraint vector $\\bm{c}(\\tau)=\\beta\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0$ only if the range proof relation is satisfied. Intuitively, this is because</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">v(\\tau)-\\langle\\bm{c}(\\tau),\\bm{l}(\\tau)\\rangle=f_{0}+f_{1}\\tau+\\tau^{2}\\delta^{2}(p_{s}+2\\sum_{i=1}^{k}\\lambda^{i}v_{i})</span> (87)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is exactly the same expression, as a polynomial in the challenges, as $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{n}(\\tau)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}$ only in the case of a valid proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness follows from essentially the same reasoning as the arithmetic circuit protocol, since the <span class="math">\\beta</span> term prevents the <span class="math">H_{0}</span> coefficient in <span class="math">D</span> from being anything other than zero. Therefore, the second term still encodes the correct expression. Zero-knowledge follows straightforwardly from the fact that the <span class="math">H_{1}</span> coefficient of every term is chosen uniformly at random.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Theorem 6 (Binary Range Proof).</h6>

    <p class="text-gray-300">The binary range proof protocol has perfect completeness, perfect honest verifier zero-knowledge. Assuming the expected-PPT hardness of the discrete logarithm relation problem, the protocol has computational witness-extended emulation.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This protocol is almost similar enough to be subsumed into the arithmetic circuit framework, but unfortunately is not quite. This is because there are not enough commitments do blinding in the same way, as well as the direct evaluation of a norm on the witness vector. However, it is similar enough to see that both completeness, SHVZK, and CWEE follow by more or less exactly the same reasoning as the arithmetic circuit proof.</p>

    <p class="text-gray-300">In the case of SHVZK, the distribution of <span class="math">(v,\\boldsymbol{l},\\boldsymbol{n})</span> is uniformly random, so the simulator will similarly sample everything uniformly at random except for <span class="math">S</span>, and choose this value so the verification equation is satisfied.</p>

    <p class="text-gray-300">For CWEE, given a tree of transcripts, the extractor will rewind using the same challenges, with the same names, in the same way as for an arithmetic circuit with minor changes to accommodate e.g. differences in degree.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-65" class="text-2xl font-bold">Appendix B Fast Scalar Multiplication</h2>

    <p class="text-gray-300">In computing the norm linear argument, and in the original BP and BP+ inner product arguments, the prover needs to compute updated basis points at each round of the protocol. Each of these updated points is a linear combination of two points from the previous round, and in total the prover must compute <span class="math">O(n)</span> of these for vectors of length <span class="math">n</span>. This represents a non-trivial amount of the total prover computation.</p>

    <p class="text-gray-300">The amount of time spent on computing the updated bases can be substantially reduced by taking advantage of the fact that each updated basis element is the same linear combination of different basis points. That is, the updated basis points <span class="math">\\boldsymbol{G}^{\\prime}</span> are</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{G}^{\\prime}=s\\boldsymbol{G}_{0}+t\\boldsymbol{G}_{1}.</span> (88)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The particular values of <span class="math">s</span> and <span class="math">t</span> are not relevant for this protocol. For $p=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and fixed </span>s,t\\in\\mathbb{F}$, consider the lattice</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">L=\\left\\{(a,b,q):tb-sa+pq=0\\right\\}.</span> (89)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The shortest vector in this lattice has components smaller than approximately <span class="math">\\sqrt{p}</span> and can be computed using the extended Euclidean algorithm in $O(\\log\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time. We can renormalize the vector equation defining </span>\\boldsymbol{G}^{\\prime}<span class="math"> so that the multiplications by </span>s<span class="math"> and </span>t<span class="math"> are replaced by </span>b<span class="math"> and </span>a$ respectively</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">bs^{-1}\\boldsymbol{G}^{\\prime}=b\\boldsymbol{G}_{0}+a\\boldsymbol{G}_{1}.</span> (90)</p>

    <p class="text-gray-300">These multiplications can be performed in slightly more than half the time it would take the prover to perform multiplications by <span class="math">s</span> and <span class="math">t</span> by using Shamir’s trick. The normalization factor of <span class="math">bs^{-1}</span> can be deferred to the end of the proof as it factors out of subsequent rounds. This technique may be of independent interest.</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">B.1 Complex Multiplication</h3>

    <p class="text-gray-300">In curves with complex multiplication (CM), such as secp256k1, we can do even better. For the purposes of this appendix, it suffices to assume that there exists some efficiently computable endomorphism that sends a point <span class="math">P</span> to <span class="math">\\alpha P</span> for some fixed <span class="math">\\alpha\\in\\mathbb{F}</span> so that computing <span class="math">\\alpha P</span> via the endomorphism is much cheaper than a generic scalar multiplication.</p>

    <p class="text-gray-300">We can use this endomorphism to make basis updates even more efficient. Consider the lattice</p>

    <p class="text-gray-300"><span class="math">L^{\\prime}=\\left\\{(a,b,c,d,q):(c+d\\alpha)t-(a+b\\alpha)s+pq=0\\right\\}.</span> (91)</p>

    <p class="text-gray-300">Every element of <span class="math">L^{\\prime}</span> will satisfy</p>

    <p class="text-gray-300"><span class="math">t=s\\frac{c+d\\alpha}{a+b\\alpha}.</span> (92)</p>

    <p class="text-gray-300">The shortest vector in <span class="math">L^{\\prime}</span> will have components which are all smaller than <span class="math">p^{1/4}</span>. Basis updates can now be computed using four scalar multiplications of one quarter the length as</p>

    <p class="text-gray-300"><span class="math">(c+d\\alpha)s^{-1}\\bm{G}^{\\prime}=c\\bm{G}_{0}+d(\\alpha\\bm{G}_{0})+a\\bm{G}_{1}+b(\\alpha\\bm{G}_{0}).</span> (93)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Computing the shortest vector in <span class="math">L^{\\prime}</span> may seem like it would require a general purpose algorithm, but for certain kinds of CM it can be stated in terms of the extended Euclidean algorithm once again. Specifically when the CM field is a Euclidean domain, then one can first write <span class="math">s/t=u+\\alpha v</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> smaller than approximately </span>\\sqrt{p}<span class="math"> and then apply the extended Euclidean algorithm to this value and a factor of </span>p$ over the CM field.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-67" class="text-2xl font-bold">Appendix C Theorems and Proofs</h2>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 7 (Tree of Transcripts <em>[48]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\bm{k}=(k_{0},\\ldots,k_{r-1})\\in N^{r}</span>. A <span class="math">\\bm{k}</span>-tree of transcripts for a <span class="math">(2r+1)</span>-move public-coin interactive proof is a set of <span class="math">\\prod_{i=0}^{r-1}k_{i}</span> transcripts arranged in the following tree structure. The nodes in this tree correspond to the prover’s messages and the edges to the verifier’s challenges. Every node at depth <span class="math">i</span> has precisely <span class="math">k_{i}</span> children corresponding to <span class="math">k_{i}</span> pairwise distinct challenges. Every transcript corresponds to exactly one path from the root node to a leaf node.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 8 (<span class="math">\\bm{k}</span>-Special-Soundness <em>[48]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\bm{k}=(k_{0},\\ldots,k_{r-1})\\in N^{r}</span>. A <span class="math">(2r+1)</span>-round public-coin interactive proof for relation <span class="math">\\mathcal{R}</span> is <span class="math">\\bm{k}</span>-special-sound (<span class="math">\\bm{k}</span>-SS) if there exists a polynomial time algorithm that, on input a statement <span class="math">x</span> and a <span class="math">\\bm{k}</span>-tree of accepting transcripts outputs a witness <span class="math">w</span> such that <span class="math">(\\sigma,x,w)\\in\\mathcal{R}</span>.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Lemma 2 (General Forking Lemma <em>[44]</em>).</h6>

    <p class="text-gray-300">If <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> is a <span class="math">\\bm{k}</span>-special-sound interactive protocol where <span class="math">\\prod_{i=0}^{k-1}k_{i}\\in\\text{poly}(\\lambda)</span>, then the protocol has WEE.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a relation and <span class="math">\\mathcal{R}_{DLR}=\\{\\bm{G}\\in\\mathbb{G}^{n};;\\bm{a}\\in\\mathbb{F}^{n}:\\langle\\bm{a},\\bm{G}\\rangle=0_{\\mathbb{G}},\\bm{a}\\neq\\bm{0}\\}</span> be the relation that encodes solutions of the DLR problem (Definition 1). An interactive protocol <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> that has WEE for the relation <span class="math">\\mathcal{R}^{\\prime}=\\mathcal{R}\\cup\\mathcal{R}_{DLR}</span>, where <span class="math">\\bm{G}=\\mathcal{K}(1^{\\lambda})</span>, has CWEE for the relation <span class="math">\\mathcal{R}</span> assuming expected-PPT hardness of the discrete logarithm relation (DLR) problem.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}^{*}</span> be a DPT prover for <span class="math">\\mathcal{R}^{\\prime}</span> and <span class="math">\\mathcal{E}</span> the corresponding witness-extended emulator. We define <span class="math">\\mathcal{E}^{\\prime}</span> as being equal to <span class="math">\\mathcal{E}</span> but failing when <span class="math">\\mathcal{E}</span> extracts a witness for <span class="math">\\mathcal{R}_{DLR}</span>. <span class="math">\\mathcal{E}^{\\prime}</span> is a computational witness extended emulator for <span class="math">\\mathcal{R}</span> if <span class="math">\\mathcal{E}^{\\prime}</span> fails with negligible probability.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{E}^{\\prime}</span> would fail with non-negligible probability, then there exists a pair of non-uniform polynomial-time adversaries <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> such that <span class="math">\\mathcal{E}</span> outputs a solution to the DLR problem with non-negligible probability. This contradicts the assumed expected-PPT hardness of the DLR problem. ∎</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">The Cauchy matrix for two vectors <span class="math">\\bm{x}</span> and <span class="math">\\bm{y}</span> of the same length is the matrix <span class="math">C_{i,j}=1/(x_{i}-y_{j}).</span> It is invertible when all the <span class="math">x_{i}</span> and <span class="math">y_{j}</span> are unique.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Given <span class="math">n</span> linearly independent polynomials <span class="math">f_{i}(X)</span> of degree <span class="math">d&lt;m</span> and <span class="math">m\\geq n</span> pairwise distinct <span class="math">\\alpha_{j}\\in\\mathbb{F}</span> the matrix <span class="math">M_{i,j}=f_{i}(\\alpha_{j})</span> has rank <span class="math">n</span>.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By way of contradiction, suppose <span class="math">n\\times m</span> matrix <span class="math">M</span> was not rank <span class="math">n</span>. Since <span class="math">M</span> has <span class="math">n</span> rows, if <span class="math">M</span> has rank less than <span class="math">n</span>, there must exist some non-zero <span class="math">\\bm{c}\\in\\mathbb{F}^{n}</span> such that <span class="math">M^{\\top}\\bm{c}=\\bm{0}</span>. Since the polynomials <span class="math">f_{i}(X)</span> are linearly independent in <span class="math">\\mathbb{F}[X]</span>, for every <span class="math">\\bm{c}</span> the polynomial <span class="math">\\sum_{i}c_{i}f_{i}(X)=g(X)</span> is non-zero and has degree at most <span class="math">d</span>. It holds that <span class="math">M^{\\top}\\bm{c}=(g(\\alpha_{0}),\\ldots,g(\\alpha_{m-1}))</span>. If <span class="math">M^{\\top}\\bm{c}=\\bm{0}</span>, it must be the case that <span class="math">g(\\alpha_{i})=0</span> for <span class="math">m</span> values of <span class="math">\\alpha_{i}</span>. Since <span class="math">m&gt;d</span> this means <span class="math">g</span> is zero on more points than its degree and therefore must be identically zero. This contradicts the assumption of linear independence, therefore <span class="math">M</span> must be rank <span class="math">n</span>. ∎</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Lemma 5 (Round Extractor).</h6>

    <p class="text-gray-300">For any <span class="math">k</span> group elements <span class="math">\\bm{G}\\in\\mathbb{G}^{k}</span> and <span class="math">n</span> linearly independent polynomials <span class="math">f_{i}(X)\\in\\mathbb{F}[X]</span> of degree <span class="math">d&lt;m</span> over <span class="math">\\mathbb{F}[X]</span>, there exists an efficient extractor <span class="math">\\chi</span> such that for <span class="math">n</span> commitments <span class="math">C_{i}</span> and <span class="math">m\\geq n</span> transcripts <span class="math">(\\alpha_{j}\\in\\mathbb{F},\\bm{w}_{j}\\in\\mathbb{F}^{k})</span> with distinct <span class="math">\\alpha_{j}</span> such that <span class="math">\\langle\\bm{w}_{j},\\bm{G}\\rangle=\\sum_{i=0}^{n-1}f_{i}(\\alpha_{j})C_{i}</span>, <span class="math">\\chi</span> either outputs <span class="math">\\bm{s}</span> such that <span class="math">\\langle\\bm{s},\\bm{G}\\rangle=O</span> or a collection of <span class="math">\\bm{x}_{i}</span> such that <span class="math">C_{i}=\\langle\\bm{x}_{i},\\bm{G}\\rangle</span> and <span class="math">\\sum_{i}f_{i}(X)\\bm{x}_{i}=\\bm{0}</span> in <span class="math">\\mathbb{F}[X]</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">M_{i,j}=f_{i}(\\alpha_{j})</span>. By Lemma 4 this matrix has rank <span class="math">n</span>. Let the matrix <span class="math">W\\in\\mathbb{F}^{m\\times k}</span> have as its rows the vectors <span class="math">\\bm{w}_{j}</span> and note <span class="math">W\\bm{G}=M\\bm{C}</span>. If the vectors <span class="math">\\bm{x}_{i}</span> exist, then there exists some matrix <span class="math">X</span> with rows equal to <span class="math">\\bm{x}_{i}</span> such that <span class="math">\\bm{C}=X\\bm{G}</span> and <span class="math">W=MX</span>. Since <span class="math">m&gt;d</span>, and each <span class="math">\\sum_{i=0}^{n-1}f_{i}(X)x_{i,j}</span> is of degree <span class="math">d</span> but zero on the <span class="math">m</span> values <span class="math">\\alpha_{j}</span>, if <span class="math">W=MX</span> then <span class="math">\\sum_{i}f_{i}(X)\\bm{x}_{i}=\\bm{0}</span>.</p>

    <p class="text-gray-300">If <span class="math">W=MX</span>, it must be the case that every column of <span class="math">W</span> lies in the image of <span class="math">M</span>. This is not necessarily the case and when it is not the extractor will be able to find a discrete log relation. Let <span class="math">M^{+}</span> be the Moore-Penrose pseudo inverse, which since <span class="math">M</span> is of full rank is a left inverse for <span class="math">M</span>. By the properties of the pseudo inverse, we have</p>

    <p class="text-gray-300"><span class="math">MM^{+}W\\bm{G}=MM^{+}M\\bm{C}=M\\bm{C}=W\\bm{G}.</span> (94)</p>

    <p class="text-gray-300">Let <span class="math">W^{\\prime}=MM^{+}W</span>. If <span class="math">W^{\\prime}=W</span> then <span class="math">X=M^{+}W</span> such that <span class="math">MX=W</span>. In this case, the extractor will return the rows of <span class="math">X</span> as <span class="math">\\bm{x}_{i}</span>. If <span class="math">W^{\\prime}\\neq W</span>, then we have <span class="math">(W^{\\prime}-W)\\bm{G}=\\bm{O}</span> and every non-zero row of <span class="math">W^{\\prime}-W</span> is a discrete log relation. Since <span class="math">W^{\\prime}-W\\neq 0</span>, there exists a first non-zero row <span class="math">\\bm{s}</span> and the extractor will return <span class="math">\\bm{s}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">C.1 Norm Linear Argument</h3>

    <h4 id="sec-79" class="text-lg font-semibold mt-6">C.1.1 Proof of Theorem 1</h4>

    <h6 id="sec-80" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><em>Completeness</em> follows from running the protocol and checking that all the algebraic equations are satisfied.</p>

    <p class="text-gray-300"><em>CWEE</em> follows by essentially the same argument as the original inner product argument: Given a tree of transcripts, the norm linear argument extractor <span class="math">\\chi_{nl}</span> will apply a round extractor <span class="math">\\chi</span> as in Lemma 5 sequentially <span class="math">\\log_{2}n</span> times. Each invocation of the round extractor will use 4 transcripts and extract a witness for the previous round of the norm linear argument or relation <span class="math">\\mathcal{R}_{DLR}</span> as defined in Lemma 3. So the entire extractor will find a witness for relation <span class="math">\\mathcal{R}</span>’, the union of <span class="math">\\mathcal{R}_{DLR}</span> and the norm linear relation, from four accepting transcripts and use <span class="math">4^{\\lceil\\log_{2}n\\rceil}=O(n^{2})</span> total transcripts, where <span class="math">n</span> is the longer of the lengths of <span class="math">\\bm{l}</span> and <span class="math">\\bm{n}</span>. Since <span class="math">\\chi_{nl}</span> runs in polynomial time, the protocol has <span class="math">\\bm{k}</span>-SS for <span class="math">\\mathcal{R}^{\\prime}</span> and, further, since the number of transcripts is polynomial in the security parameter, the protocol has CWEE for the norm linear relation under the expected-PPT hardness of the DLR problem by Lemma 2 and Lemma 3. Within an invocation of the round extractor, fix <span class="math">\\mu</span> and <span class="math">\\bm{c}</span>, commitments <span class="math">(C,X,R)</span>, and basis points <span class="math">(G,\\bm{G},\\bm{H})</span> and let <span class="math">\\gamma_{i}</span> be the challenge from each transcript. In each transcript the extractor has <span class="math">(v_{i},\\bm{l}_{i},\\bm{n}_{i})</span> such that</p>

    <p class="text-gray-300"><span class="math">C_{i}^{\\prime}</span> <span class="math">=C+\\gamma_{i}X+(\\gamma_{i}^{2}-1)R</span> (95) <span class="math">=v_{i}G+\\langle\\bm{l}_{i},[\\bm{H}]_{0}+\\gamma_{i}[\\bm{H}]_{1}\\rangle+\\langle\\bm{n}_{i},[\\bm{G}]_{0}+\\gamma_{i}[\\bm{G}]_{1}\\rangle</span> <span class="math">=v_{i}G+\\langle\\bm{l}_{i}^{\\prime},\\bm{H}\\rangle+\\langle\\bm{n}_{i}^{\\prime},\\bm{G}\\rangle.</span></p>

    <p class="text-gray-300">Note that the <span class="math">\\bm{l}_{i}^{\\prime}</span> and <span class="math">\\bm{n}_{i}^{\\prime}</span> are multiplied by the same generators in each transcript, and that they satisfy <span class="math">\\gamma_{i}[\\bm{l}_{i}^{\\prime}]_{0}-[\\bm{l}_{i}^{\\prime}]_{1}=\\bm{0}</span> and likewise for <span class="math">\\bm{n}_{i}^{\\prime}</span>. The extractor can also compute <span class="math">\\bm{c}_{i}=[\\bm{c}]_{0}+\\gamma_{i}[\\bm{c}]_{1}</span>.</p>

    <p class="text-gray-300">Per Definition 7, the challenges are pairwise distinct and therefore, the extractor can apply <span class="math">\\chi</span> from Lemma 5. If <span class="math">\\chi</span> returns a witness for <span class="math">\\mathcal{R}_{DLR}</span>, the extractor has a solution to the a DLR problem for basis points <span class="math">(G,\\bm{G},\\bm{H})</span> and returns it. Otherwise, the extractor obtains openings for <span class="math">C,X,R</span>, denoted <span class="math">v_{C}</span>, <span class="math">v_{X}</span>, <span class="math">v_{R}</span>, <span class="math">\\bm{l}_{C}^{\\prime}</span>, etc. There exist polynomials <span class="math">v(T)=v_{C}+v_{X}T+v_{R}(T^{2}-1)</span>, and likewise for <span class="math">\\bm{l}^{\\prime}(T)</span> and <span class="math">\\bm{n}^{\\prime}(T)</span> such that <span class="math">v(\\gamma_{i})=v_{i}</span>, <span class="math">\\bm{l}^{\\prime}(\\gamma_{i})=\\bm{l}_{i}^{\\prime}</span>, and <span class="math">\\bm{n}^{\\prime}(\\gamma_{i})=\\bm{n}_{i}^{\\prime}</span>. Since we know that each transcript is accepting, we know that <span class="math">T[\\bm{l}^{\\prime}(T)]_{0}-[\\bm{l}^{\\prime}(T)]_{1}=\\bm{0}</span> at four <span class="math">T=\\gamma_{i}</span> but only has degree 3 since <span class="math">\\bm{l}^{\\prime}(T)</span> and <span class="math">\\bm{n}^{\\prime}(T)</span> have degree 2. Therefore, the left hand side must be identically zero as a polynomial in <span class="math">T</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From this, it follows that $\\bm{l}^{\\prime}(T)=(1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T)\\otimes\\bm{l}(T)<span class="math"> for </span>\\bm{l}(T)<span class="math"> degree 1 and </span>\\bm{l}(\\gamma_{i})=\\bm{l}_{i}<span class="math">. This is similarly true for </span>\\bm{n}^{\\prime}(T)<span class="math"> and the degree one polynomial </span>\\bm{n}(T)<span class="math">. Writing </span>\\bm{l}(T)=\\bm{l}_{0}+\\bm{l}_{1}T<span class="math"> and grouping like terms, we find </span>\\bm{l}_{C}=\\bm{l}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{l}_{1}<span class="math">, </span>\\bm{l}_{X}=\\bm{l}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{l}_{0}<span class="math">, </span>\\bm{l}_{R}=\\bm{l}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{0}<span class="math">, as well as for </span>\\bm{n}(T)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, applying the norm linear equation to <span class="math">(v(T),\\bm{l}(T),\\bm{n}(T))</span> we obtain the quadratic equation $v(T)-\\langle\\bm{c}(T),\\bm{l}(T)\\rangle-\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}(T)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\text{p}}^{2}=0<span class="math"> that holds at 4 values of </span>T=\\gamma_{i}<span class="math"> and therefore must also be identically zero. Expanding the right hand side in </span>T<span class="math"> we find that this implies </span>v_{X}<span class="math"> and </span>v_{R}<span class="math"> must be constructed according to the protocol and that </span>v_{C}<span class="math"> must satisfy the norm linear relation for </span>(v_{C},\\bm{l}_{C},\\bm{n}_{C})<span class="math"> and the appropriate linear constraint and weight. So, the round extractor finds a witness for </span>\\mathcal{R}_{DLR}<span class="math"> or a valid opening for </span>C<span class="math"> from four accepting transcripts. Let </span>\\mathcal{R}^{\\prime}<span class="math"> be the union of the norm linear relation and </span>\\mathcal{R}_{DLR}<span class="math">. By running the round extractor </span>\\log_{2}n<span class="math"> times we extract a witness for </span>\\mathcal{R}^{\\prime}<span class="math">, which proves that the protocol has </span>\\bm{k}$-SS. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">C.2 Arithmetic Circuits</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma 6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For fixed <span class="math">\\bm{c}</span> and <span class="math">\\mu</span>, let <span class="math">(v,\\bm{l},\\bm{n})</span> be a valid opening if $v=\\langle\\bm{c},\\bm{l}\\rangle+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}<span class="math"> and let </span>\\bm{l}=\\bm{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{l}^{\\prime}<span class="math"> and </span>\\bm{c}=\\hat{\\bm{c}}_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\bm{c}}_{l}<span class="math">. The uniform distribution of openings is equal to the distribution </span>(v+s_{0},(\\bm{r}^{\\prime}+\\bm{s}_{1:})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{l}^{\\prime},\\bm{n})<span class="math"> where </span>\\bm{n}<span class="math"> and </span>\\bm{l}^{\\prime}<span class="math"> are drawn uniformly at random, </span>(\\hat{v},\\bm{r}^{\\prime})<span class="math"> are any values such that </span>(\\hat{v},\\bm{r}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{l}^{\\prime},\\bm{n})<span class="math"> is a valid opening, and </span>\\bm{s}<span class="math"> are drawn uniformly at random such that </span>\\langle\\hat{\\bm{c}}_{r},\\bm{s}\\rangle=0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, note that the uniform distribution on <span class="math">(v,\\bm{l},\\bm{n})</span> is equal to the distribution by first choosing <span class="math">\\bm{n}</span> and <span class="math">\\bm{l}^{\\prime}</span> uniformly at random and then choosing <span class="math">\\bm{v}</span> and <span class="math">\\bm{r}</span> uniformly at random such that the opening is valid for <span class="math">\\bm{c}</span>, <span class="math">\\mu</span>, <span class="math">\\bm{n}</span>, and <span class="math">\\bm{l}^{\\prime}</span>. Equivalently, letting $C=\\langle\\hat{\\bm{c}}_{l},\\bm{l}^{\\prime}\\rangle+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mu}^{2}<span class="math">, choosing </span>(v,\\bm{r})<span class="math"> such that </span>v+\\langle\\hat{\\bm{c}}_{r,1:},\\bm{r}\\rangle=C<span class="math">, assuming </span>\\hat{\\bm{c}}_{r}=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note this equation is affine in <span class="math">(v,\\bm{r})</span>. In particular, any two solutions always differ by a solution <span class="math">\\bm{s}</span> to the equation <span class="math">\\langle\\hat{\\bm{c}}_{r},\\bm{s}\\rangle=0</span>. Therefore, given any initial solution <span class="math">(\\hat{v},\\bm{r}^{\\prime})</span>, we can generate a uniformly random solution by choosing <span class="math">\\bm{s}</span> uniformly at random and letting <span class="math">v=\\hat{v}+s_{0}</span> and <span class="math">\\bm{r}=\\bm{r}+\\bm{s}_{1:}</span>. This is precisely the distribution described in the lemma. ∎</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">For a matrix <span class="math">M</span> and uniformly random <span class="math">\\bm{a}</span>, the vector <span class="math">\\bm{b}=M\\bm{a}</span> is uniformly distributed at random in the image of the matrix.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Every element of the image of <span class="math">M</span> has a unique, disjoint pre-image <span class="math">P_{\\bm{b}}</span>. By linearity, the difference of any two elements of the pre-image is an element of the right null space of <span class="math">M</span> and thus each pre-image has the same size. Therefore, a uniformly random vector <span class="math">\\bm{a}</span> will fall in a uniformly random pre-image, and so <span class="math">\\bm{b}</span> will be distributed uniformly at random in the image of <span class="math">M</span>. ∎</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">M</span> be a matrix such that the left null space <span class="math">\\bm{v}^{\\top}M=\\bm{0}^{\\top}</span> is generated by one non-zero vector <span class="math">\\bm{v}_{0}</span>. For uniformly random <span class="math">\\bm{a}</span>, the distribution of <span class="math">M\\bm{a}</span> is the same as the uniform distribution of <span class="math">\\bm{b}</span> such that <span class="math">\\langle\\bm{v}_{0},\\bm{b}\\rangle=0</span>.</p>

    <h4 id="sec-86" class="text-lg font-semibold mt-6">C.2.1 Proof of Theorem 2</h4>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness Perfect completeness follows from the protocol description. Since all the constraints vanish for a valid witness, and all other terms in <span class="math">f(T)</span> also vanish, the norm linear relation always holds.</p>

    <p class="text-gray-300">Perfect SHVZK follows very straightforwardly if we can show that <span class="math">(v,\\bm{l},\\bm{n})</span> is distributed uniformly at random among valid openings. We will use Lemma 6 to show that the opening produced by an honest prover is distributed uniformly at random. First, note that the vectors <span class="math">\\bm{l}^{\\prime}</span> and <span class="math">\\bm{n}</span> as defined in the protocol and the lemma are chosen uniformly at random, and that the primitive witness from the lemma is just <span class="math">(\\hat{f}_{0},\\beta^{-1}\\hat{\\bm{f}}_{1:})</span>. Now it remains to show that the values <span class="math">(v_{b},\\bm{r}_{b})</span> which in this case are <span class="math">s_{0}=r_{0}-\\hat{f}_{0}</span> and <span class="math">\\bm{s}_{1:}=\\bm{r}_{1:}-\\hat{\\bm{f}}_{1:}</span> are distributed uniformly at random.</p>

    <p class="text-gray-300">The values <span class="math">\\bm{s}</span> as noted in the body, are a linear combination of the vectors <span class="math">\\bm{r}_{L}</span>, <span class="math">\\bm{r}_{R}</span>, <span class="math">\\bm{r}_{O}</span>, and <span class="math">\\bm{r}_{V}</span>. We can use Lemma 7 to show that the values <span class="math">\\bm{s}</span> are distributed uniformly at random such that <span class="math">\\langle\\hat{\\bm{c}}_{r},\\bm{s}\\rangle=0</span> by showing that the rank of this matrix is 7, since the dimension of its image is 8. To show that the matrix has rank 7, it is sufficient to show that it has 7 linearly independent columns.</p>

    <p class="text-gray-300">There are 6 linearly independent columns that come from the 6 linearly blinding factors from <span class="math">C_{O}</span>. There are only 6 because both <span class="math">r_{O,4}</span> and <span class="math">r_{O,7}</span> are both zero. The seventh can be taken from <span class="math">r_{L,4}</span>, which is independent of all the <span class="math">\\bm{r}_{O}</span> blinding factors. Thus, we have 7 linearly independent columns, so <span class="math">\\bm{s}</span> is chosen uniformly at random. The simulator thus will choose the opening, all challenges, and all commitments except for <span class="math">C_{S}</span> uniformly at random. It will then choose <span class="math">C_{S}</span> so that Eq. (34) is satisfied.</p>

    <p class="text-gray-300">CWEE Given a tree of transcripts, the extractor <span class="math">\\chi_{ac}</span> will use <span class="math">N_{m}</span> values of <span class="math">\\rho</span>, or equivalently <span class="math">\\mu=\\rho^{2}</span>, <span class="math">N_{l}</span> values of <span class="math">\\lambda</span>, 2 values of <span class="math">\\delta</span>, 2 values of <span class="math">\\beta</span>, and 13 values of <span class="math">\\tau</span> to extract a valid witness for the AC relation or <span class="math">\\mathcal{R}_{DLR}</span> as defined in Lemma 3 from <span class="math">52N_{l}N_{m}</span> transcripts. In total, with the additional <span class="math">O(\\max(N_{m},N_{l}+7)^{2})</span> for the norm linear extractor, this is polynomial in the security parameter, so the whole protocol is <span class="math">\\bm{k}</span>-SS and has CWEE for the AC relation assuming the expected-PPT hardness of the DIR problem by Lemma 2 and Lemma 3.</p>

    <p class="text-gray-300">The extractor will begin by running <span class="math">\\chi_{nl}</span> to extract <span class="math">(v,\\bm{l},\\bm{n})</span> with <span class="math">O(N_{m}^{2})</span> transcripts. Then, the extractor will use all 13 values of <span class="math">\\tau</span> to extract openings with overwhelming probability, or a discrete log relation with negligible probability, for <span class="math">C_{S},C_{O},C_{L},C_{R},\\hat{V}</span> using the round extractor <span class="math">\\chi</span> from Lemma 5. From these openings, the extractor knows <span class="math">\\hat{v}</span> and can form the polynomials <span class="math">\\hat{\\bm{l}}(T)</span> and <span class="math">n(T))</span> from the protocol and can therefore construct <span class="math">\\hat{f}(T)</span>. Likewise, the prover can construct the polynomial <span class="math">g(T)=\\langle\\hat{\\bm{c}}_{r}(T),\\bm{r}(T)\\rangle</span>. The polynomial <span class="math">\\hat{f}(T)</span> terms for <span class="math">-2</span> through 6, and <span class="math">g(T)</span> has terms for <span class="math">-2</span> through possible 10.</p>

    <p class="text-gray-300">We know that <span class="math">\\hat{f}(T)-g(T)=0</span> on 13 values of <span class="math">T</span>. Multiplying by <span class="math">T^{2}</span>, the left hand side is a polynomial of degree 12 that is zero on 13 values, so it must be identically zero. In particular the value term must be zero. From the protocol, <span class="math">g(T)</span> must have zero value term by construction, so <span class="math">\\hat{f}(T)</span> has zero value term.</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=\\mathbf{e}_{N_{l}}(\\lambda)^{\\top}\\left(W_{l}\\bm{w}+f_{l}\\bm{w}_{V}+\\bm{a}_{l}\\right)</span> (96) <span class="math">+\\left\\langle\\bm{w}_{L},\\bm{w}_{R}\\right\\rangle_{\\mu}-\\mu\\mathbf{e}_{N_{m}}(\\mu)^{\\top}\\left(W_{m}\\bm{w}+f_{m}\\bm{w}_{V}+\\bm{a}_{m}\\right)</span> <span class="math">-\\delta\\!\\left\\langle\\bm{n}_{O},\\bm{n}_{\\hat{V}}\\right\\rangle_{\\mu}-\\beta\\left(r_{O,4}+r_{L,3}+r_{R,2}\\right)</span></p>

    <p class="text-gray-300">Now, we will unwind each challenge in the value term to show that if it is zero, it must be the case that the rest of the value term is zero. Since all the remaining challenges <span class="math">\\rho,\\lambda,\\beta,\\delta</span> are all chosen in the same round, it doesn’t matter the order they are unwound. Starting with <span class="math">\\beta</span>, the degree 1 terms in <span class="math">\\beta</span> are the <span class="math">\\bm{r}</span> components that map to the value term, and everything else has degree 0. We know that the value terms is zero at 2 values of beta, which means that both the degree zero and degree one terms must be zero. Thus, all the interfering error term blinding components must net to zero, the remainder of the value term must also be zero. Similarly for <span class="math">\\delta</span> there is a <span class="math">\\delta^{0}</span> term that includes the inner product of <span class="math">\\left\\langle\\bm{n}_{O},\\bm{n}_{V}\\right\\rangle</span> and the rest of the terms of are of degree 0 in <span class="math">\\delta</span>. Since this polynomial in <span class="math">\\delta</span> is zero at two values of <span class="math">\\delta</span> it must be the case that the interfering inner product is zero and that the remainder of the value term is zero.</p>

    <p class="text-gray-300">The remaining non-zero terms of the value term are precisely those on the right hand side of equation Eq. (96), which are the <span class="math">\\bm{\\mu}</span> and <span class="math">\\bm{\\lambda}</span> linear combination of the circuit constraints. Depending on whether <span class="math">f_{l}=1</span> or <span class="math">f_{m}=1</span>, the extractor can obtain openings for all <span class="math">\\bm{V}</span> from <span class="math">\\hat{V}</span>, or solve the DLR problem, using the round extractor from Lemma 5. This is because at least one of <span class="math">f_{l}</span> or <span class="math">f_{m}</span> must be non-zero and <span class="math">\\hat{V}</span> is a linear combination of <span class="math">\\bm{V}</span> by powers of either <span class="math">\\lambda</span> or <span class="math">\\mu</span>.</p>

    <p class="text-gray-300">Starting with <span class="math">\\mu</span>, the final rest of the value term is a degree <span class="math">N_{m}</span> polynomial in <span class="math">\\mu</span>. The constant coefficient is a large polynomial in <span class="math">\\lambda</span>, and every other coefficient is either a multiplicative constraint that does not depend on <span class="math">\\lambda</span>, or it is a polynomial in <span class="math">\\lambda</span> if <span class="math">f_{m}f_{l}=1</span>. In the case that it is a polynomial in <span class="math">\\lambda</span>, it will have two terms with the constant term equal to a multiplicative constraint, and a <span class="math">\\lambda^{i}</span> term multiplying a row of <span class="math">W_{l}\\bm{w}+f_{l}\\bm{w}_{V}+\\bm{a}_{l}</span>. Using the <span class="math">N_{m}+1</span> transcripts for <span class="math">\\mu</span>, the extractor can show that each <span class="math">\\mu^{i}</span> coefficient is zero. Now using the <span class="math">N_{l}+1</span> transcripts with different values of <span class="math">\\lambda</span>, we can do the same for the remaining constant term, and the other terms if <span class="math">f_{l}f_{m}=1</span>, to show that all the linear constraints must vanish. Thus, we have extracted a valid witness from <span class="math">O(N_{l}N_{m}\\max(N_{l}+7,N_{m})^{2})</span> transcripts, which is polynomial in the security parameter which proves that the protocol has <span class="math">\\bm{k}</span>-SS for the union of the AC relation and <span class="math">\\mathcal{R}_{DLR}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-88" class="text-xl font-semibold mt-8">C.3 Proof of Theorem 3</h3>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness. Completeness follows from executing the protocol. In selecting the reciprocal challenge <span class="math">\\alpha</span>, it is possible for the prover to fail if any of the denominators vanish. Since the number of reciprocals is negligible by construction, the probability of failure is negligible, so the protocol has completeness.</p>

    <p class="text-gray-300">SHVZK. SHVZK follows directly from the SHVZK of the arithmetic circuit protocol. Since the reciprocal circuit is compiled to an arithmetic circuit, the simulator will simply choose random <span class="math">\\alpha</span> and then run the arithmetic circuit simulator on the resulting circuit. Thus, the protocol is SHVZK.</p>

    <p class="text-gray-300">CWEE. Given a tree of transcripts, the extractor <span class="math">\\chi_{rf}</span> for the reciprocal form circuit relation <span class="math">\\mathcal{R}_{rf}</span> (Eq. (71)) will use the arithmetic circuit extractor <span class="math">\\chi_{ac}</span> on the compiled arithmetic circuit for particular challenges <span class="math">\\alpha</span>. Extractor <span class="math">\\chi_{ac}</span> obtains a valid witness for the AC relation or <span class="math">\\mathcal{R}_{DLR}</span> as defined in Lemma 3 using <span class="math">O(N_{l}N_{m}\\max(N_{l}+7,N_{m})^{2})</span> total transcripts. If <span class="math">\\chi_{ac}</span> returns a witness for <span class="math">\\mathcal{R}_{DLR}</span>, <span class="math">\\chi_{rf}</span> returns it. We will show below that, otherwise, the polynomial time extractor <span class="math">\\chi_{rf}</span> succeeds in extracting a witness for <span class="math">\\mathcal{R}_{rf}</span> when receiving a tree of transcripts with <span class="math">2N_{p}</span> pairwise distinct challenges <span class="math">\\alpha</span>. Thus, the reciprocal form circuit protocol is <span class="math">\\bm{k}</span>-SS and has CWEE for relation <span class="math">\\mathcal{R}_{rf}</span> assuming the expected-PPT hardness of the DLR problem by Lemma 2 and Lemma 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now show that if <span class="math">\\chi_{ac}</span> does not return a solution to the DLR problem, <span class="math">\\chi_{rf}</span> returns a witness that satisfies Eq. (65) and the collections <span class="math">A_{i}</span> encoded by Eq. (66) vanish. Following the notation of Section 6.3, we can see that <span class="math">\\chi_{ac}</span> extracts a witness $\\bm{w}^{\\prime}=\\bm{w}_{L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{R}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{O}^{\\prime}<span class="math"> for a particular challenge </span>\\alpha$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\bm{0}</span> <span class="math">=W_{l}^{\\prime}\\bm{w}^{\\prime}+f_{l}\\bm{w}_{V}+\\bm{a}_{l}^{\\prime}</span> (97)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$=((W_{d}\\bm{w}_{I})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(W_{p}(\\alpha)\\bm{w}(\\alpha))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(W_{l}\\bm{w}))+f_{l}\\bm{w}_{V}+(\\bm{a}_{d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}_{p}(\\alpha)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}_{l}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that Eq. (65) is satisfied.</p>

    <p class="text-gray-300">In order to show that the encoded collections <span class="math">A_{i}</span> vanish, we show that the circuit encodes instances of the reciprocal argument for <span class="math">\\bm{m}=W_{n}\\bm{w}_{I}+f_{m}\\bm{w}_{V}+\\bm{a}_{n},\\bm{v}=\\bm{w}_{D},\\bm{r}=\\bm{w}_{P}^{\\prime}</span>. We can see that for the extracted witness <span class="math">\\sum r_{i}+\\sum a_{P,i}(\\alpha)=0</span>, since from Eq. (97) it follows that <span class="math">\\bm{0}=W_{p}(\\alpha)\\bm{w}(\\alpha)+\\bm{a}_{p}(\\alpha)=\\bm{f}(\\alpha)</span>. This implies <span class="math">\\sum r_{i}+\\sum a_{P,i}(\\alpha)=0</span>, if <span class="math">W_{p}(X)</span> and <span class="math">\\bm{a}_{p}(X)</span> are correctly constructed.</p>

    <p class="text-gray-300">Moreover, for the witness <span class="math">\\bm{w}^{\\prime}</span> extracted by <span class="math">\\chi_{ac}</span> it holds that</p>

    <p class="text-gray-300"><span class="math">\\bm{w}_{L}^{\\prime}\\circ\\bm{w}_{R}^{\\prime}</span> <span class="math">=W_{m}^{\\prime}\\bm{w}^{\\prime}+f_{m}\\bm{w}_{V}+\\bm{a}_{m}^{\\prime}</span> (98)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(\\bm{w}_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{L})\\circ(\\bm{w}_{P}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{w}_{R})<span class="math"> </span>=((W_{n}\\bm{w}_{I}-\\alpha\\bm{w}_{P}^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(W_{m}\\bm{w}))+f_{m}\\bm{w}_{V}+(\\bm{a}_{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}_{m}).$ (99)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, it holds that</p>

    <p class="text-gray-300"><span class="math">\\alpha\\bm{w}_{P}^{\\prime}+\\bm{w}_{D}\\circ\\bm{w}_{P}^{\\prime}</span> <span class="math">=W_{n}\\bm{w}_{I}+f_{m}\\bm{w}_{V}+\\bm{a}_{n}</span> (100) <span class="math">\\alpha\\bm{r}+\\bm{v}\\circ\\bm{r}</span> <span class="math">=\\bm{m}.</span> (101)</p>

    <p class="text-gray-300">which proves that the reciprocal form circuit protocol encodes instances of the reciprocal argument protocol for collections <span class="math">A_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the total size of the collections <span class="math">A_{i}</span> sums to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N_{p}<span class="math"> and the extractor has </span>2N_{p}<span class="math"> transcripts with pairwise distinct challenges </span>\\alpha<span class="math">, by Lemma 1 all </span>A_{i}<span class="math"> vanish. By assumption, </span>N_{p}<span class="math"> is polynomial in the security parameter, so </span>\\chi_{rf}<span class="math"> uses polynomially many transcripts to extract a witness for the reciprocal form circuit relation or </span>\\mathcal{R}_{DLR}<span class="math">. Thus, the reciprocal form circuit protocol is </span>\\bm{k}$-SS. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Bulletproofs++: Next Generation Confidential Transactions vi... (2022/510)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/510
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
